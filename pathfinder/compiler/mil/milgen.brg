%{

/*
 * Compile MIL algebra tree into a MIL program.
 *
 *
 * Copyright Notice:
 * -----------------
 *
 *  The contents of this file are subject to the MonetDB Public
 *  License Version 1.0 (the "License"); you may not use this file
 *  except in compliance with the License. You may obtain a copy of
 *  the License at http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
 *
 *  Software distributed under the License is distributed on an "AS
 *  IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
 *  implied. See the License for the specific language governing
 *  rights and limitations under the License.
 *
 *  The Original Code is the ``Pathfinder'' system. The Initial
 *  Developer of the Original Code is the Database & Information
 *  Systems Group at the University of Konstanz, Germany. Portions
 *  created by U Konstanz are Copyright (C) 2000-2004 University
 *  of Konstanz. All Rights Reserved.
 *
 *
 * $Id$
 */


#include "pathfinder.h"
#include "oops.h"
#include "mem.h"
#include "milalgebra.h"
#include "mil.h"

#include <stdio.h>
#include <assert.h>

/*
 * Accessors for the burg matcher
 */
typedef struct PFma_op_t *NODEPTR_TYPE;

/* accessor to the node kind */
#define OP_LABEL(p)    ((p)->kind)

/* accessors to left and right child node */
#define LEFT_CHILD(p)  ((p)->child[0])
#define RIGHT_CHILD(p) ((p)->child[1])

/* the state determined during bottom-up labeling is stored here */
#define STATE_LABEL(p) ((p)->state_label)

/* If something goes wrong, call PFoops */
#define PANIC(...) PFoops (OOPS_BURG, __VA_ARGS__)

%}

/* start non-terminal */
%start Prog

/*
 * Node indentifiers. Keep these properly aligned with the
 * node kinds in include/milalgebra.h!
 */
%term lit_oid    =  1
%term lit_int    =  2
%term lit_dbl    =  3
%term lit_str    =  4
%term lit_bit    =  5
%term new        =  6
%term insert     =  7
%term bun        =  8
%term seqbase    =  9
%term project    = 10
%term reverse    = 11
%term sort       = 12
%term ctrefine   = 13
%term join       = 14
%term leftjoin   = 15
%term cross      = 16
%term mirror     = 17
%term kunique    = 18
%term mark_grp   = 19
%term mark       = 20
%term count      = 21
%term append     = 22
%term oid        = 23
%term moid       = 24
%term mint       = 25
%term mstr       = 26
%term mdbl       = 27
%term mbit       = 28
%term madd       = 29
%term msub       = 30
%term mmult      = 31
%term mdiv       = 32
%term serialize  = 33
%term ser_args   = 34

%%

Prog: serialize (BatExpr, ser_args (BatExpr, ser_args (BatExpr, ser_args (BatExpr, ser_args (BatExpr, ser_args (BatExpr, BatExpr)))))) = 1 (1);

BatExpr:  new                                           =  2 (1);
BatExpr:  insert (BatExpr, bun (AtomExpr, AtomExpr))    =  3 (1);
BatExpr:  seqbase (BatExpr, AtomExpr)                   =  4 (1);
BatExpr:  reverse (BatExpr)                             =  5 (1);
BatExpr:  mark (BatExpr, AtomExpr)                      =  6 (1);
BatExpr:  sort (BatExpr)                                =  7 (1);
BatExpr:  mark_grp (BatExpr, BatExpr)                   =  8 (1);
BatExpr:  project (BatExpr, AtomExpr)                   =  9 (1);
BatExpr:  kunique (BatExpr)                             = 10 (1);
BatExpr:  leftjoin (BatExpr, BatExpr)                   = 11 (1);
BatExpr:  cross (BatExpr, BatExpr)                      = 12 (1);
BatExpr:  mirror (BatExpr)                              = 13 (1);
BatExpr:  ctrefine (BatExpr, BatExpr)                   = 14 (1);
BatExpr:  join (BatExpr, BatExpr)                       = 15 (1);
BatExpr:  append (BatExpr, BatExpr)                     = 16 (1);

BatExpr:  moid (BatExpr)                                = 17 (1);
BatExpr:  mint (BatExpr)                                = 18 (1);
BatExpr:  mstr (BatExpr)                                = 19 (1);
BatExpr:  mdbl (BatExpr)                                = 20 (1);
BatExpr:  mbit (BatExpr)                                = 21 (1);

BatExpr:  madd (BatExpr, AtomExpr)                      = 22 (1);
BatExpr:  madd (AtomExpr, BatExpr)                      = 23 (1);
BatExpr:  madd (BatExpr, BatExpr)                       = 24 (1);
BatExpr:  msub (BatExpr, AtomExpr)                      = 25 (1);
BatExpr:  msub (AtomExpr, BatExpr)                      = 26 (1);
BatExpr:  msub (BatExpr, BatExpr)                       = 27 (1);
BatExpr:  mmult (BatExpr, AtomExpr)                     = 28 (1);
BatExpr:  mmult (AtomExpr, BatExpr)                     = 29 (1);
BatExpr:  mmult (BatExpr, BatExpr)                      = 30 (1);
BatExpr:  mdiv (BatExpr, AtomExpr)                      = 31 (1);
BatExpr:  mdiv (AtomExpr, BatExpr)                      = 32 (1);
BatExpr:  mdiv (BatExpr, BatExpr)                       = 33 (1);

AtomExpr: Literal                                       = 100 (1);
AtomExpr: oid (AtomExpr)                                = 101 (1);
AtomExpr: count (BatExpr)                               = 102 (1);

Literal:  lit_oid                                       = 201 (1);
Literal:  lit_int                                       = 202 (1);
Literal:  lit_str                                       = 203 (1);
Literal:  lit_dbl                                       = 204 (1);
Literal:  lit_bit                                       = 205 (1);

%%

#include "mil_mnemonic.h"

/**
 * We collect the MIL program during compilation here.
 */
static PFmil_t *milprog = NULL;

/**
 * Processing is done bottom-up. This is just the order in
 * which we want to print our code. So we keep the whole
 * MIL program in the variable #milprog, and append commands
 * as we go. Think of it as ``executing'' the commands
 * right away.
 */
#define execute(...) milprog = seq (milprog, __VA_ARGS__)

/**
 * ``Invent'' new MIL variable name.
 *
 * This function will return a unique string on each call that can
 * be used as a valid Monet identifier.
 */
static PFmil_ident_t
new_var (void)
{
    static unsigned int varno = 0;
    PFmil_ident_t ret = PFmalloc (sizeof ("a000000"));

    assert (varno < 1000000);

    sprintf ((char *) ret, "a%06u", varno++);

    return ret;
}

/*
 * Easily access subtree-parts.
 */
/** starting from p, make a step left */
#define L(p) (LEFT_CHILD(p))
/** starting from p, make a step right */
#define R(p) (RIGHT_CHILD(p))
/** starting from p, make two steps left */
#define LL(p) L(L(p))
/** starting from p, make a step left, then a step right */
#define LR(p) R(L(p))
/** starting from p, make a step right, then a step left */
#define RL(p) L(R(p))
/** starting from p, make two steps right */
#define RR(p) R(R(p))
/* ... and so on ... */
#define RRL(p) L(R(R(p)))
#define RRRL(p) L(R(R(R(p))))
#define RRRRL(p) L(R(R(R(R(p)))))
#define RRRRRL(p) L(R(R(R(R(R(p))))))
#define RRRRRR(p) R(R(R(R(R(R(p))))))


/**
 * Reducer function. This is the heart of this source file. It
 * contains all the action code for the above burg patterns.
 */
static void
reduce (PFma_op_t *p, int goalnt)
{
    int        rule;      /* rule number that matches for this node */
    short     *nts;       /* target non-terminals for the leaf nodes of
                             the current rule */
    PFma_op_t *kids[10];  /* leaf nodes of this rule */

    /* Nothing to do if this subtree is already translated */
    if (p->varname)
        return;

    /* determine rule that matches for this non-terminal */
    rule = PFmilgen_rule (STATE_LABEL (p), goalnt);

    /*
     * prepare recursive traversal: get information on leaf nodes of
     * this rule
     */
    nts = PFmilgen_nts[rule];
    PFmilgen_kids (p, rule, kids);

    /*
     * Recursively invoke compilation.  This means bottom-up compilation.
     */
    unsigned short i;
    for (i = 0; nts[i]; i++)
        reduce (kids[i], nts[i]);

    /* Nothing to do if this subtree is already translated */
    if (p->varname)
        return;

    /* Get a new variable name for this subexpression */
    p->varname = new_var ();

    switch (rule) {

        /* Prog: serialize (...) */
        case 1:
            execute (
                serialize (
                    var (L(p)->varname),
                    var (RL(p)->varname),
                    var (RRL(p)->varname),
                    var (RRRL(p)->varname),
                    var (RRRRL(p)->varname),
                    var (RRRRRL(p)->varname),
                    var (RRRRRR(p)->varname)));
            break;

        /* BatExpr:  new */
        case 2:
            execute (assgn (var (p->varname),
                            new (type (p->sem.new.htype),
                                 type (p->sem.new.ttype))));
            break;

        /* BatExpr: insert (BatExpr, bun (AtomExpr, AtomExpr)) */
        case 3:
            assert (L(p)->varname);
            assert (RL(p)->varname); assert (RR(p)->varname);
            if (p->refctr == L(p)->refctr)
                execute (
                    assgn (var (p->varname),
                           access (insert (access (var (L(p)->varname),
                                                   BAT_APPEND),
                                           var (RL(p)->varname),
                                           var (RR(p)->varname)),
                                   BAT_READ)));
            else
                execute (
                    assgn (var (p->varname),
                           access (
                               insert (access (copy (var (L(p)->varname)),
                                               BAT_APPEND),
                                       var (RL(p)->varname),
                                       var (RR(p)->varname)),
                                   BAT_READ)));
            break;

        /* BatExpr:  seqbase (BatExpr, AtomExpr) */
        case 4:
            assert (L(p)->varname);
            assert (R(p)->varname);
            if (p->refctr == L(p)->refctr)
                execute (assgn (var (p->varname),
                                seqbase (var (L(p)->varname),
                                         var (R(p)->varname))));
            else
                execute (assgn (var (p->varname),
                                seqbase (copy (var (L(p)->varname)),
                                         var (R(p)->varname))));
            break;

        /* BatExpr:  reverse (BatExpr) */
        case 5:
            assert (L(p)->varname);
            execute (assgn (var (p->varname),
                            reverse (var (L(p)->varname))));
            break;

        /* BatExpr:  mark (BatExpr, AtomExpr) */
        case 6:
            execute (assgn (var (p->varname),
                            mark (var (L(p)->varname),
                                  var (R(p)->varname))));
            break;

        /* BatExpr:  sort (BatExpr) */
        case 7:
            execute (assgn (var (p->varname),
                            sort (var (L(p)->varname))));
            break;

        /* BatExpr: mark_grp (BatExpr, BatExpr) */
        case 8:
            execute (assgn (var (p->varname),
                            mark_grp (var (L(p)->varname),
                                      var (R(p)->varname))));
            break;

        /* BatExpr:  project (BatExpr, AtomExpr) */
        case 9:
            execute (assgn (var (p->varname),
                            project (var (L(p)->varname),
                                     var (R(p)->varname))));
            break;

        /* BatExpr:  kunique (BatExpr) */
        case 10:
            execute (assgn (var (p->varname),
                            kunique (var (L(p)->varname))));
            break;

        /* BatExpr:  leftjoin (BatExpr, BatExpr) */
        case 11:
            execute (assgn (var (p->varname),
                            leftjoin (var (L(p)->varname),
                                      var (R(p)->varname))));
            break;

        /* BatExpr:  cross (BatExpr, BatExpr) */
        case 12:
            execute (assgn (var (p->varname),
                            cross (var (L(p)->varname),
                                   var (R(p)->varname))));
            break;

        /* BatExpr:  mirror (BatExpr) */
        case 13:
            execute (assgn (var (p->varname),
                            mirror (var (L(p)->varname))));
            break;

        /* BatExpr:  ctrefine (BatExpr, BatExpr) */
        case 14:
            execute (assgn (var (p->varname),
                            ctrefine (var (L(p)->varname),
                                      var (R(p)->varname))));
            break;

        /* BatExpr:  join (BatExpr, BatExpr) */
        case 15:
            execute (assgn (var (p->varname),
                            join (var (L(p)->varname),
                                  var (R(p)->varname))));
            break;

        /* BatExpr:  append (BatExpr, BatExpr) */
        case 16:
            if (p->refctr == L(p)->refctr)
                execute (
                    assgn (var (p->varname),
                           access (
                               binsert (access (var (L(p)->varname),
                                                     BAT_APPEND),
                                       var (R(p)->varname)),
                               BAT_READ)));
            else
                execute (
                    assgn (var (p->varname),
                           access (
                               binsert (
                                   access (copy (var (L(p)->varname)),
                                           BAT_APPEND),
                                   var (R(p)->varname)),
                               BAT_READ)));
            break;

        /* BatExpr:  moid (BatExpr) */
        case 17:
            execute (assgn (var (p->varname),
                            mcast (type (m_oid), (var (L(p)->varname)))));
            break;

        /* BatExpr:  mint (BatExpr) */
        case 18:
            execute (assgn (var (p->varname),
                            mcast (type (m_int), (var (L(p)->varname)))));
            break;

        /* BatExpr:  mstr (BatExpr) */
        case 19:
            execute (assgn (var (p->varname),
                            mcast (type (m_str), (var (L(p)->varname)))));
            break;

        /* BatExpr:  mdbl (BatExpr) */
        case 20:
            execute (assgn (var (p->varname),
                            mcast (type (m_dbl), (var (L(p)->varname)))));
            break;

        /* BatExpr:  mbit (BatExpr) */
        case 21:
            execute (assgn (var (p->varname),
                            mcast (type (m_bit), (var (L(p)->varname)))));
            break;

        /* BatExpr:  madd (BatExpr, AtomExpr) */
        case 22:
        /* BatExpr:  madd (AtomExpr, BatExpr) */
        case 23:
        /* BatExpr:  madd (BatExpr, BatExpr) */
        case 24:
            execute (assgn (var (p->varname),
                            madd (var (L(p)->varname),
                                  var (R(p)->varname))));
            break;

        /* BatExpr:  msub (BatExpr, AtomExpr) */
        case 25:
        /* BatExpr:  msub (AtomExpr, BatExpr) */
        case 26:
        /* BatExpr:  msub (BatExpr, BatExpr) */
        case 27:
            execute (assgn (var (p->varname),
                            msub (var (L(p)->varname),
                                  var (R(p)->varname))));
            break;

        /* BatExpr:  mmult (BatExpr, AtomExpr) */
        case 28:
        /* BatExpr:  mmult (AtomExpr, BatExpr) */
        case 29:
        /* BatExpr:  mmult (BatExpr, BatExpr) */
        case 30:
            execute (assgn (var (p->varname),
                            mmult (var (L(p)->varname),
                                   var (R(p)->varname))));
            break;

        /* BatExpr:  mdiv (BatExpr, AtomExpr) */
        case 31:
        /* BatExpr:  mdiv (AtomExpr, BatExpr) */
        case 32:
        /* BatExpr:  mdiv (BatExpr, BatExpr) */
        case 33:
            execute (assgn (var (p->varname),
                            mdiv (var (L(p)->varname),
                                  var (R(p)->varname))));
            break;

        /* AtomExpr: Literal */
        case 100:
            break;

        /* AtomExpr: oid (AtomExpr) */
        case 101:
            execute (assgn (var (p->varname),
                            cast (type (m_oid), var (L(p)->varname))));
            break;

        /* AtomExpr: count (AtomExpr) */
        case 102:
            execute (assgn (var (p->varname),
                            count (var (L(p)->varname))));
            break;

        /* Literal: lit_oid */
        case 201:
            execute (assgn (var (p->varname), lit_oid (p->sem.lit_val.val.o)));
            break;

        /* Literal: lit_int */
        case 202:
            execute (assgn (var (p->varname), lit_int (p->sem.lit_val.val.i)));
            break;

        /* Literal: lit_str */
        case 203:
            execute (assgn (var (p->varname), lit_str (p->sem.lit_val.val.s)));
            break;

        /* Literal: lit_dbl */
        case 204:
            execute (assgn (var (p->varname), lit_dbl (p->sem.lit_val.val.d)));
            break;

        /* Literal: lit_bit */
        case 205:
            execute (assgn (var (p->varname), lit_bit (p->sem.lit_val.val.b)));
            break;

        default:
            PFoops (OOPS_FATAL, "untranslated expression");
            p->varname = NULL;
            break;
    }

#undef REDUCE
#undef REDUCE_ALL

}

/**
 * Set reference counter of all MIL algebra nodes to 0,
 * set all burg state labels to 0. See also #set_refctr().
 *
 * @param n Current node.
 */
static void
clear_fields (PFma_op_t *n)
{
    int i;

    n->refctr = 0;
    STATE_LABEL(n) = 0;

    for (i = 0; i < MILALGEBRA_MAXCHILD && n->child[i]; i++)
        clear_fields (n->child[i]);
}

/**
 * Walk through algebra tree and increment the reference counter of
 * each node. Common subtrees will be visited more than once, resulting
 * in a reference count non-equal to 1. (Note that physically the algebra
 * is not actually a tree.)
 *
 * @param n Current node.
 */
static void
inc_refctr (PFma_op_t *n)
{
    int i;

    n->refctr++;

    for (i = 0; i < MILALGEBRA_MAXCHILD && n->child[i]; i++)
        inc_refctr (n->child[i]);
}

/**
 * Set reference counter of each algebra tree node.
 *
 * While on the logic level, we think of the algebra as an expression
 * @b tree, we physically implement it as a directed @b graph. Generated
 * algebra expressions will contain many common subexpressions. During
 * the generation, we will map all common subtrees to the same physical
 * node. When generating the MIL code from the algebra, we will evaluate
 * each subtree only once. Later references to that expression will use
 * that same result. A reference counter gives us the information, how
 * many references we have to each node - an information we will use to
 * correctly clean up variables that are no longer used in MIL.
 *
 * @param root Root of the algebra tree.
 */
static void
set_refctr (PFma_op_t *root)
{
    /* first set all reference counters to zero (play safe) */
    clear_fields (root);

    /* now, during a tree-walk, increment the counter for each visit. */
    inc_refctr (root);
}


/**
 * Translate MIL algebra tree in a MIL program.
 */
PFmil_t *
PFmilgen (PFma_op_t *n)
{
    assert (n);

    /* set reference counters */
    set_refctr (n);

    PFmilgen_label (n);
    milprog = nop ();
    reduce (n, 1);
    return milprog;
}

/* vim:set shiftwidth=4 expandtab filetype=c: */
