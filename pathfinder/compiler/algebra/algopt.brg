%{

/*
 * Map MIL algebra expressions to MIL code
 *
 *
 * Copyright Notice:
 * -----------------
 *
 *  The contents of this file are subject to the MonetDB Public
 *  License Version 1.0 (the "License"); you may not use this file
 *  except in compliance with the License. You may obtain a copy of
 *  the License at http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
 *
 *  Software distributed under the License is distributed on an "AS
 *  IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
 *  implied. See the License for the specific language governing
 *  rights and limitations under the License.
 *
 *  The Original Code is the ``Pathfinder'' system. The Initial
 *  Developer of the Original Code is the Database & Information
 *  Systems Group at the University of Konstanz, Germany. Portions
 *  created by U Konstanz are Copyright (C) 2000-2004 University
 *  of Konstanz. All Rights Reserved.
 *
 *
 * $Id$
 */

#include "pathfinder.h"
#include "oops.h"         /* PFoops() */
#include "algebra.h"
#include "algopt.h"
#include "mem.h"          /* PFstrdup() */

#include <assert.h>
#include <string.h>
#include <stdio.h>

/*
 * Accessors for the burg matcher
 */
typedef struct PFalg_op_t *NODEPTR_TYPE;

/* accessor to the node kind */
#define OP_LABEL(p) ((p)->kind)

/* accessors to left and right child node */
#define LEFT_CHILD(p)  ((p)->child[0])
#define RIGHT_CHILD(p) ((p)->child[1])

/* the state determined during bottom-up labeling is stored here */
#define STATE_LABEL(p) ((p)->state_label)

/* If something goes wrong, call PFoops */
#define PANIC(...) PFoops (OOPS_BURG, __VA_ARGS__)

%}

/* start non-terminal */
%start Query

/*
 * Node identifiers.
 * Keep them aligned with the node kinds in include/algebra.h!
 */
%term lit_tbl        =  1
%term empty_tbl      =  2
%term disjunion      =  3
%term intersect      =  4
%term difference     =  5
%term cross          =  6
%term eqjoin         =  7
%term scjoin         =  8
%term select_        =  9
%term type           = 10
%term cast           = 11
%term project        = 12
%term rownum         = 13
%term serialize      = 14
%term num_add        = 15
%term num_subtract   = 16
%term num_multiply   = 17
%term num_divide     = 18
%term num_modulo     = 19
%term num_eq         = 20
%term num_gt         = 21
%term num_neg        = 22
%term bool_and       = 23
%term bool_or        = 24
%term bool_not       = 25
%term sum            = 26
%term count          = 27
%term distinct       = 28
%term element        = 29
%term element_tag    = 30
%term attribute      = 31
%term textnode       = 32
%term docnode        = 33
%term comment        = 34
%term processi       = 35
%term concat         = 36
%term merge_adjacent = 37
%term seqty1         = 38
%term all            = 39
%term roots_         = 40
%term fragment       = 41
%term frag_union     = 42
%term empty_frag     = 43
%term doc_tbl        = 44

%%

Query:  serialize (Frag, Rel)                     =  1 (10);

Rel:    lit_tbl                                   =  2 (10);
Rel:    disjunion (Rel, Rel)                      =  3 (10);
Rel:    disjunion (EmptyRel, Rel)                 =  4 (10);
Rel:    disjunion (Rel, EmptyRel)                 =  5 (10);
Rel:    difference (Rel, Rel)                     =  6 (10);
Rel:    difference (Rel, EmptyRel)                =  7 (10);
Rel:    intersect (Rel, Rel)                      =  8 (10);
Rel:    cross (Rel, Rel)                          =  9 (10);
Rel:    eqjoin (Rel, Rel)                         = 10 (10);
Rel:    scjoin (Frag, Rel)                        = 11 (10);
Rel:    rownum (Rel)                              = 12 (10);
Rel:    project (Rel)                             = 13 (10);
Rel:    select_ (Rel)                             = 14 (10);
Rel:    sum (Rel)                                 = 15 (10);
Rel:    count (Rel)                               = 16 (10);
Rel:    distinct (Rel)                            = 17 (10);
Rel:    type (Rel)                                = 18 (10);
Rel:    cast (Rel)                                = 19 (10);
Rel:    num_add (Rel)                             = 20 (10);
Rel:    num_subtract (Rel)                        = 21 (10);
Rel:    num_multiply (Rel)                        = 22 (10);
Rel:    num_divide (Rel)                          = 23 (10);
Rel:    num_modulo (Rel)                          = 24 (10);
Rel:    num_neg (Rel)                             = 25 (10);
Rel:    num_gt (Rel)                              = 26 (10);
Rel:    num_eq (Rel)                              = 27 (10);
Rel:    bool_and (Rel)                            = 28 (10);
Rel:    bool_or (Rel)                             = 29 (10);
Rel:    bool_not (Rel)                            = 30 (10);
Rel:    concat (Rel)                              = 31 (10);
Rel:    seqty1 (Rel)                              = 32 (10);
Rel:    all (Rel)                                 = 33 (10);

Rel:    roots_ (FragRel)                          = 34 (10);
Rel:    element_tag (Rel, Rel)                    = 35 (10);
Rel:    element_tag (Rel, EmptyRel)               = 36 (10);


FragRel:    element (Frag, Rel)                   = 37 (10);
FragRel:    attribute (Rel, Rel)                  = 38 (10);
FragRel:    textnode (Rel)                        = 39 (10);
FragRel:    docnode (Frag, Rel)                   = 40 (10);
FragRel:    comment (Rel)                         = 41 (10);
FragRel:    processi (Rel)                        = 42 (10);
FragRel:    merge_adjacent (Frag, Rel)            = 43 (10);
FragRel:    doc_tbl (Rel)                         = 44 (10);


Frag:    fragment (FragRel)                       = 45 (10);
Frag:    frag_union (Frag, Frag)                  = 46 (10);
Frag:    frag_union (empty_frag, empty_frag)      = 47 (10);
Frag:    empty_frag                               = 48 (10);


EmptyRel:    empty_tbl                            = 49 (10);

EmptyRel:    disjunion (EmptyRel, EmptyRel)       = 50 (10);
EmptyRel:    difference (EmptyRel, Rel)           = 51 (10);
EmptyRel:    intersect (EmptyRel, Rel)            = 53 (10);
EmptyRel:    intersect (Rel, EmptyRel)            = 54 (10);
EmptyRel:    cross (EmptyRel, Rel)                = 55 (10);
EmptyRel:    cross (Rel, EmptyRel)                = 56 (10);
EmptyRel:    eqjoin (EmptyRel, Rel)               = 57 (10);
EmptyRel:    eqjoin (Rel, EmptyRel)               = 58 (10);
EmptyRel:    scjoin (Frag, EmptyRel)              = 59 (10);
EmptyRel:    rownum (EmptyRel)                    = 60 (10);
EmptyRel:    project (EmptyRel)                   = 61 (0);
EmptyRel:    select_ (EmptyRel)                   = 62 (10);
EmptyRel:    sum (EmptyRel)                       = 63 (10);
EmptyRel:    count (EmptyRel)                     = 64 (10);
EmptyRel:    distinct (EmptyRel)                  = 65 (10);
EmptyRel:    type (EmptyRel)                      = 66 (10);
EmptyRel:    cast (EmptyRel)                      = 67 (10);
EmptyRel:    num_add (EmptyRel)                   = 68 (10);
EmptyRel:    num_subtract (EmptyRel)              = 69 (10);
EmptyRel:    num_multiply (EmptyRel)              = 70 (10);
EmptyRel:    num_divide (EmptyRel)                = 71 (10);
EmptyRel:    num_modulo (EmptyRel)                = 72 (10);
EmptyRel:    num_neg (EmptyRel)                   = 73 (10);
EmptyRel:    num_gt (EmptyRel)                    = 74 (10);
EmptyRel:    num_eq (EmptyRel)                    = 75 (10);
EmptyRel:    bool_and (EmptyRel)                  = 76 (10);
EmptyRel:    bool_or (EmptyRel)                   = 77 (10);
EmptyRel:    bool_not (EmptyRel)                  = 78 (10);
EmptyRel:    concat (EmptyRel)                    = 79 (10);
EmptyRel:    seqty1 (EmptyRel)                    = 80 (10);
EmptyRel:    all (EmptyRel)                       = 81 (10);

EmptyRel:    element_tag (EmptyRel, Rel)          = 82 (10);


EmptyRel:    roots_ (element (Frag, EmptyRel))    = 83 (10);
EmptyRel:    roots_ (attribute (EmptyRel, Rel))   = 84 (9);
EmptyRel:    roots_ (attribute (Rel, EmptyRel))   = 85 (10);
EmptyRel:    roots_ (textnode (EmptyRel))         = 86 (10);
EmptyRel:    roots_ (comment (EmptyRel))          = 87 (10);
EmptyRel:    roots_ (processi (EmptyRel))         = 88 (10);
EmptyRel:    roots_ (merge_adjacent (Frag, EmptyRel)) = 89 (10);

Rel:    EmptyRel                                  = 90 (0);

Rel:    project (project (Rel))                   = 91 (1);


%%

#include "algebra_mnemonic.h"

/*
 * Easily access subtree-parts.
 */
/** starting from p, make a step left */
#define L(p) (LEFT_CHILD(p))
/** starting from p, make a step right */
#define R(p) (RIGHT_CHILD(p))
/** starting from p, make two steps left */
#define LL(p) L(L(p))
/** starting from p, make a step left, then a step right */
#define LR(p) R(L(p))
/** starting from p, make a step right, then a step left */
#define RL(p) L(R(p))
/** starting from p, make two steps right */
#define RR(p) R(R(p))

#define MAX_KIDS 10

/* Relabel node p if it is not contained in kids. */
static void relabel (PFalg_op_t *p,  PFalg_op_t **kids);

/*
 * Check whether the second input projection list @a p1 is contained
 * in the first projection list @a p2. @a n1 and @a n2 are the number
 * of projection items in both lists, respecitvely.
 */
static bool contains_projlist (PFalg_proj_t *p1, int n1,
                               PFalg_proj_t *p2, int n2);

/**
 * Reducer function. This is the heart of this source file. It
 * contains all the action code for the above burg patterns.
 */
static bool
reduce (PFalg_op_t *p, int goalnt)
{
    int         rule;       /* rule number that matches for this node */
    short      *nts;        /* target non-terminals for the leaf nodes of
                               the current rule */
    PFalg_op_t *kids[MAX_KIDS];   /* leaf nodes of this rule */
    bool rewritten = false;

    short            state_label;
    unsigned short   i;

    /* determine rule that matches for this non-terminal */
    rule = PFalgopt_rule (STATE_LABEL (p), goalnt);

    /*
     * prepare recursive traversal: get information on leaf nodes of
     * this rule
     */
    nts = PFalgopt_nts[rule];
    PFalgopt_kids (p, rule, kids);

    /* recursively translate all leaf expressions */
    for (i = 0; nts[i]; i++) {
        rewritten = reduce (kids[i], nts[i]);

        /*
         * Subtree below p was rewritten during reduction, so we must
         * stop the reduction process here and start relabelling.
         */
        if (rewritten)
            break;
    }

    if (rewritten) {
        /* Remember p's old label. */
        state_label = STATE_LABEL(p);

        /*
         * Relabel p and the children of p (until we reach p's kids
         * which do not have to be relabelled).
         */
        relabel (p, kids);

        /* If old and new label differ, p's parent must be relabelled, too. */
        if (state_label != STATE_LABEL(p))
            return true;
    }

    /*
     * Stop if we have now already translated that expression.
     * TODO: is that possible at all?
     */

    switch (rule) {

        /* Query:    serialize (Frag, Rel) */
        case 1:
            break;

        /* Rel:    lit_tbl */
        case 2:
            break;

        /* Rel:  disjunion (Rel, Rel) */
        case 3:
            break;

        /*
         * Rel:  disjunion (EmptyRel, Rel);
         * return right child
	 */
        case 4:
            *p = *(R(p));
            rewritten = true;
            break;

        /*
         * Rel:  disjunion (Rel, EmptyRel);
         * return left child
	 */ 
        case 5:
            *p = *(L(p));
            rewritten = true;
            break;

        /* Rel:    difference (Rel, Rel) */
        case 6:
            break;

        /*
         * Rel:    difference (Rel, EmptyRel)
         * return right child
	 */ 
        case 7:
            *p = *(R(p));
            rewritten = true;
            break;

        /* Rel:    intersect (Rel, Rel) */
        case 8:

        /* Rel:    cross (Rel, Rel) */
        case 9:

        /* Rel:    eqjoin (Rel, Rel) */
        case 10:

        /* Rel:    scjoin (Frag, Rel) */
        case 11:

        /* Rel:    rownum (Rel) */
        case 12:

        /* Rel:    project (Rel) */
        case 13:

        /* Rel:    select_ (Rel) */
        case 14:

        /* Rel:    sum (Rel) */
        case 15:

        /* Rel:    count (Rel) */
        case 16:

        /* Rel:    distinct (Rel) */
        case 17:

        /* Rel:    type (Rel) */
        case 18:
            break;

        /* Rel:    cast (Rel) */
        case 19:
        {
            /*
             * If an algebra expression already has the requested
             * type, remove the cast.
             */
            int i;

            for (i = 0; i < L(p)->schema.count; i++)
                if (!strcmp (p->sem.cast.att, L(p)->schema.items[i].name)) {
                    if (p->sem.cast.ty == L(p)->schema.items[i].type) {
                        *p = *(L(p));
                        rewritten = true;
                        break;
                    }
                }
        } break;

        /* Rel:    num_add (Rel) */
        case 20:

        /* Rel:    num_subtract (Rel) */
        case 21:

        /* Rel:    num_multiply (Rel) */
        case 22:

        /* Rel:    num_divide (Rel) */
        case 23:

        /* Rel:    num_modulo (Rel) */
        case 24:

        /* Rel:    num_neg (Rel) */
        case 25:

        /* Rel:    num_gt (Rel) */
        case 26:

        /* Rel:    num_eq (Rel) */
        case 27:

        /* Rel:    bool_and (Rel) */
        case 28:

        /* Rel:    bool_or (Rel) */
        case 29:

        /* Rel:    bool_not (Rel) */
        case 30:

        /* Rel:    concat (Rel) */
        case 31:

        /* Rel:    seqty1 (Rel) */
        case 32:

        /* Rel:    all (Rel) */
        case 33:

        /* Rel:    roots_ (FragRel) */
        case 34:

        /* Rel:    element_tag (Rel, Rel) */
        case 35:

        /* Rel:    element_tag (Rel, EmptyRel) */
        case 36:

        /* FragRel:    element (Frag, Rel) */
        case 37:

        /* FragRel:    attribute (Rel, Rel  */
        case 38:

        /* FragRel:    textnode (Rel) */
        case 39:

        /* FragRel:    docnode (Frag, Rel) */
        case 40:

        /* FragRel:    comment (Rel) */
        case 41:

        /* FragRel:    processi (Rel) */
        case 42:

        /* FragRel:    merge_adjacent (Frag, Rel) */
        case 43:

        /* FragRel:    doc_tbl (Rel) */
        case 44:

        /* Frag:    fragment (FragRel) */
        case 45:

        /* Frag:    frag_union (Frag, Frag) */
        case 46:
            break;

        /* Frag:    frag_union (empty_frag, empty_frag) */
        case 47:
            *p = *(L(p));
            rewritten = true;
            break;

        /* Frag:    empty_frag */
        case 48:
            break;

        /* EmptyRel:    empty_tbl */
        case 49:

        /* EmptyRel:    disjunion (EmptyRel, EmptyRel) */
        case 50:

        /* EmptyRel:    difference (EmptyRel, Rel) */
        case 51:

        /* EmptyRel:    difference (EmptyRel, EmptyRel) */
        case 52:

        /* EmptyRel:    intersect (EmptyRel, Rel) */
        case 53:

        /* EmptyRel:    intersect (Rel, EmptyRel) */
        case 54:

        /* EmptyRel:    cross (EmptyRel, Rel) */
        case 55:

        /* EmptyRel:    cross (Rel, EmptyRel) */
        case 56:

        /* EmptyRel:    eqjoin (EmptyRel, Rel) */
        case 57:

        /* EmptyRel:    eqjoin (Rel, EmptyRel) */
        case 58:

        /* EmptyRel:    scjoin (Frag, EmptyRel) */
        case 59:

        /* EmptyRel:    rownum (EmptyRel) */
        case 60:

        /* EmptyRel:    project (EmptyRel) */
        case 61:

        /* EmptyRel:    select_ (EmptyRel) */
        case 62:

        /* EmptyRel:    sum (EmptyRel) */
        case 63:

        /* EmptyRel:    count (EmptyRel) */
        case 64:

        /* EmptyRel:    distinct (EmptyRel) */
        case 65:

        /* EmptyRel:    type (EmptyRel) */
        case 66:

        /* EmptyRel:    cast (EmptyRel) */
        case 67:

        /* EmptyRel:    num_add (EmptyRel) */
        case 68:

        /* EmptyRel:    num_subtract (EmptyRel) */
        case 69:

        /* EmptyRel:    num_multiply (EmptyRel) */
        case 70:

        /* EmptyRel:    num_divide (EmptyRel) */
        case 71:

        /* EmptyRel:    num_modulo (EmptyRel) */
        case 72:

        /* EmptyRel:    num_neg (EmptyRel) */
        case 73:

        /* EmptyRel:    num_gt (EmptyRel) */
        case 74:

        /* EmptyRel:    num_eq (EmptyRel) */
        case 75:

        /* EmptyRel:    bool_and (EmptyRel) */
        case 76:

        /* EmptyRel:    bool_or (EmptyRel) */
        case 77:

        /* EmptyRel:    bool_not (EmptyRel) */
        case 78:

        /* EmptyRel:    concat (EmptyRel) */
        case 79:

        /* EmptyRel:    seqty1 (EmptyRel) */
        case 80:

        /* EmptyRel:    all (EmptyRel) */
        case 81:

        /* EmptyRel:    element_tag (EmptyRel, Rel) */
        case 82:

        /* EmptyRel:    roots_ (element (Frag, EmptyRel)) */
        case 83:

        /* EmptyRel:    roots_ (attribute (EmptyRel, Rel)) */
        case 84:

        /* EmptyRel:    roots_ (attribute (Rel, EmptyRel)) */
        case 85:

        /* EmptyRel:    roots_ (textnode (EmptyRel)) */
        case 86:

        /* EmptyRel:    roots_ (comment (EmptyRel)) */
        case 87:

        /* EmptyRel:    roots_ (processi (EmptyRel)) */
        case 88:

        /* EmptyRel:    roots_ (merge_adjacent (Frag, EmptyRel)) */
        case 89:
            break;

        /* Rel:    EmptyRel */
        case 90:
        {
            /*
             * Replace any sub-tree that we determined empty with these
             * rules by the literal empty table.
             */
            int          i;
            PFalg_att_t *atts = PFmalloc (p->schema.count *
	                                  sizeof (PFalg_att_t));

            for (i = 0; i < p->schema.count; i++)
                 atts[i] = p->schema.items[i].name;

            *p = *(PFalg_lit_tbl_ (PFalg_attlist_ (p->schema.count, atts),
                                0 /* no of tuples */, NULL /* tuples */));
            rewritten = true;
        }
            break;

        /* Rel:    project (project (Rel)) */
        case 91:
        {
            /* THIS IS ONLY A TEST! */
            PFalg_proj_t *projlist1 = p->sem.proj.items;
            PFalg_proj_t *projlist2 = L(p)->sem.proj.items;
            int n1 = p->sem.proj.count;
            int n2 = L(p)->sem.proj.count;

            /* If projlist2 is contained in projlist1, the second
             * projection is redundant.
             */
            if (contains_projlist (projlist1, n1, projlist2, n2)) {
                L(p) = L(L(p));
                rewritten = true;
            }

            break;
        }

        default:
            PFinfo (OOPS_NOTICE, "unknown expression during algebra "
                    "optimization (rule %i)", rule);
            break;
    }

    return rewritten;
}


/*
 * Check whether the second input projection list @a p1 is contained
 * in the first projection list @a p2. @a n1 and @a n2 are the number
 * of projection items in both lists, respecitvely.
 */
static bool
contains_projlist (PFalg_proj_t *p1, int n1,
                   PFalg_proj_t *p2, int n2)
{
    int i, j;
    bool item_contained;

    for (i = 0; i < n1; i++) {
        item_contained = false;

        for (j = 0; j < n2; j++) {
            if ((!strcmp (p1[i].old, p2[j].new) &&
                !strcmp (p1[i].old, p2[j].old)) ||
                (!strcmp (p1[i].new, p2[j].new) &&
                !strcmp (p1[i].old, p2[j].old)))
                item_contained = true;
        }
        if (!item_contained)
            return false;
    }

    return true;
}

/* Relabel node p if it is not contained in kids. */
static void
relabel (PFalg_op_t *p,  PFalg_op_t **kids)
{
    unsigned int i;

    for (i = 0; i < MAX_KIDS; i++) {
        if (kids[i] && p == kids[i])
            return;
    }

    /* Relabel p's children. */
    if (L(p) && !R(p)) {
        relabel (L(p), kids);
        STATE_LABEL(p) = PFalgopt_state (OP_LABEL(p),
                                         STATE_LABEL(L(p)),
                                         0);
    }
    else if (!L(p) && R(p)) {
        relabel (R(p), kids);
        STATE_LABEL(p) = PFalgopt_state (OP_LABEL(p),
                                         STATE_LABEL(R(p)),
                                         0);
    }
    else {
        relabel (L(p), kids);
        relabel (R(p), kids);
        STATE_LABEL(p) = PFalgopt_state (OP_LABEL(p),
                                         STATE_LABEL(L(p)),
                                         STATE_LABEL(R(p)));
    }

}


/**
 * Invoke algebra optimization.
 */
PFalg_op_t *
PFalgopt (PFalg_op_t *root)
{
    /* Attach node labels in a tree walk bottom-up */
    PFalgopt_label (root);

    /* Optimize algebra tree */
    reduce (root, 1);
    return root;
}

/* vim:set shiftwidth=4 expandtab filetype=c: */
