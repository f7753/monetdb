{-# OPTIONS -fallow-overlapping-instances #-}

{--

    XQuery Core to relational algebra compiler (emits DAG).

    Copyright Notice:
    -----------------

     The contents of this file are subject to the MonetDB Public
     License Version 1.0 (the "License"); you may not use this file
     except in compliance with the License. You may obtain a copy of
     the License at http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html

     Software distributed under the License is distributed on an "AS
     IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
     implied. See the License for the specific language governing
     rights and limitations under the License.

     The Original Code is the ``Pathfinder'' system. The Initial
     Developer of the Original Code is the Database & Information
     Systems Group at the University of Konstanz, Germany. Portions
     created by U Konstanz are Copyright (C) 2000-2004 University
     of Konstanz. All Rights Reserved.

     Contributors:
             Torsten Grust <torsten.grust@uni-konstanz.de>

    $Id$

--}

module Compile (compile, live) where

import DM
import Algb
import Core
import Item
import Ty
import UDF

import Control.Monad.State

-- algebra DAG computing XQuery xq
-- (emits DAG of relational algebra operators and DAG root node)

compile :: Core -> Algb
compile xq = q
    where
    (q, _) = algebra xq

-- list of roots of algebra sub-DAGs computing the live node fragments
-- generated by XQuery xq (emits list of DAG root nodes)

live :: Core -> [Node]
live xq = ns
    where
    (_, ns) = algebra xq


-- variable environment
--            v |-> ( qv , frags )
type Env = [(QName, (Node, [Node]))]
 
-- XQuery Core to relational algebra DAG compiler

algebra :: Core -> (Algb, [Node])
algebra xq = ((n, a), ns)
    where
    ((n, ns), a) = runState (t [] (top loop) xq) (dag loop)

    -- loop relation in top-level scope
    loop :: Algb
    loop = algb (leaf (TBL [("iter",[NAT])] [[O 1]]))


--   var    loop |-  e   =>                   ( q,   frags )
t :: Env -> Node -> Core -> State (DAG AlgOp) (Node, [Node])

t env loop (XSTR s) =
    do a0 <- leaf (TBL [("pos",[NAT]),("item",[STR])] [[O 1,S s]])
       a1 <- connect X [loop, a0]
       return (a1, [])

t env loop (XINT i) =
    do a0 <- leaf (TBL [("pos",[NAT]),("item",[INT])] [[O 1,I i]])
       a1 <- connect X [loop, a0]
       return (a1, [])

t env loop (XDEC e) =
    do a0 <- leaf (TBL [("pos",[NAT]),("item",[DEC])] [[O 1,E e]])
       a1 <- connect X [loop, a0]
       return (a1, [])

t env loop (XDBL d) =
    do a0 <- leaf (TBL [("pos",[NAT]),("item",[STR])] [[O 1,D d]])
       a1 <- connect X [loop, a0]
       return (a1, [])

t env loop XEMPTY =
    do a0 <- leaf (TBL [("iter",[NAT]),("pos",[NAT]),("item",[])] [])
       return (a0, [])

t env loop (XNEG e0) =
    do (q0, _) <- t env loop e0

       a0 <- connect (NEG "res" "item") [q0]
       a1 <- connect (PROJ [("iter","iter"),("pos","pos"),("item","res")]) [a0]

       return (a1, [])

t env loop (XPLUS e0 e1) =
    do (q0, _) <- t env loop e0
       (q1, _) <- t env loop e1

       a0 <- connect (PROJ [("iter1","iter"),("item1","item")]) [q1]
       a1 <- connect (JOIN ("iter","iter1")) [q0, a0]
       a2 <- connect (PLUS "res" ["item","item1"]) [a1]
       a3 <- connect (PROJ [("iter","iter"),("pos","pos"),("item","res")]) [a2]
                     
       return (a3, [])

t env loop (XTIMES e0 e1) =
    do (q0, _) <- t env loop e0
       (q1, _) <- t env loop e1

       a0 <- connect (PROJ [("iter1","iter"),("item1","item")]) [q1]
       a1 <- connect (JOIN ("iter","iter1")) [q0, a0]
       a2 <- connect (TIMES "res" ["item","item1"]) [a1]
       a3 <- connect (PROJ [("iter","iter"),("pos","pos"),("item","res")]) [a2]
                     
       return (a3, [])

t env loop (XMINUS e0 e1) =
    do (q0, _) <- t env loop e0
       (q1, _) <- t env loop e1

       a0 <- connect (PROJ [("iter1","iter"),("item1","item")]) [q1]
       a1 <- connect (JOIN ("iter","iter1")) [q0, a0]
       a2 <- connect (MINUS "res" ["item","item1"]) [a1]
       a3 <- connect (PROJ [("iter","iter"),("pos","pos"),("item","res")]) [a2]
                     
       return (a3, [])

t env loop (XIDIV e0 e1) =
    do (q0, _) <- t env loop e0
       (q1, _) <- t env loop e1

       a0 <- connect (PROJ [("iter1","iter"),("item1","item")]) [q1]
       a1 <- connect (JOIN ("iter","iter1")) [q0, a0]
       a2 <- connect (IDIV "res" ["item","item1"]) [a1]
       a3 <- connect (PROJ [("iter","iter"),("pos","pos"),("item","res")]) [a2]
                     
       return (a3, [])

t env loop (XDIV e0 e1) =
    do (q0, _) <- t env loop e0
       (q1, _) <- t env loop e1

       a0 <- connect (PROJ [("iter1","iter"),("item1","item")]) [q1]
       a1 <- connect (JOIN ("iter","iter1")) [q0, a0]
       a2 <- connect (DIV "res" ["item","item1"]) [a1]
       a3 <- connect (PROJ [("iter","iter"),("pos","pos"),("item","res")]) [a2]
                     
       return (a3, [])

t env loop (XMOD e0 e1) =
    do (q0, _) <- t env loop e0
       (q1, _) <- t env loop e1

       a0 <- connect (PROJ [("iter1","iter"),("item1","item")]) [q1]
       a1 <- connect (JOIN ("iter","iter1")) [q0, a0]
       a2 <- connect (MOD "res" ["item","item1"]) [a1]
       a3 <- connect (PROJ [("iter","iter"),("pos","pos"),("item","res")]) [a2]
                     
       return (a3, [])

t env loop (XLT e0 e1) = t env loop (XGT e1 e0)

t env loop (XGT e0 e1) =
    do (q0, _) <- t env loop e0
       (q1, _) <- t env loop e1

       a0 <- connect (PROJ [("iter1","iter"),("item1","item")]) [q1]
       a1 <- connect (JOIN ("iter","iter1")) [q0, a0]
       a2 <- connect (GRT "res" ["item","item1"]) [a1]
       a3 <- connect (PROJ [("iter","iter"),("pos","pos"),("item","res")]) [a2]
       
       return (a3, [])

t env loop (XEQ e0 e1) =
    do (q0, _) <- t env loop e0
       (q1, _) <- t env loop e1

       a0 <- connect (PROJ [("iter1","iter"),("item1","item")]) [q1]
       a1 <- connect (JOIN ("iter","iter1")) [q0, a0]
       a2 <- connect (EQL "res" ["item","item1"]) [a1]
       a3 <- connect (PROJ [("iter","iter"),("pos","pos"),("item","res")]) [a2]
       
       return (a3, [])

t env loop (XOR e0 e1) =
    do (q0, _) <- t env loop e0
       (q1, _) <- t env loop e1

       a0 <- connect (PROJ [("iter1","iter"),("item1","item")]) [q1]
       a1 <- connect (JOIN ("iter","iter1")) [q0, a0]
       a2 <- connect (OR "res" ["item","item1"]) [a1]
       a3 <- connect (PROJ [("iter","iter"),("pos","pos"),("item","res")]) [a2]
       
       return (a3, [])

t env loop (XAND e0 e1) =
    do (q0, _) <- t env loop e0
       (q1, _) <- t env loop e1

       a0 <- connect (PROJ [("iter1","iter"),("item1","item")]) [q1]
       a1 <- connect (JOIN ("iter","iter1")) [q0, a0]
       a2 <- connect (AND "res" ["item","item1"]) [a1]
       a3 <- connect (PROJ [("iter","iter"),("pos","pos"),("item","res")]) [a2]
       
       return (a3, [])

t env loop (XFNSUM e0) =
    do (q0, _) <- t env loop e0
		 
       a0 <- connect (PROJ [("iter","iter")]) [q0]
       a1 <- connect DIFF [loop, a0]
       a2 <- leaf (TBL [("item",[INT])] [[I 0]])
       a3 <- connect X [a1,a2]
       a4 <- connect (SUM "item" "item" ["iter"]) [q0]
       a5 <- connect U [a4, a3]
       a6 <- leaf (TBL [("pos",[NAT])] [[O 1]])
       a7 <- connect X [a5, a6]

       return (a7, [])

t env loop (XFNCOUNT e0) =
    do (q0, _) <- t env loop e0
		 
       a0 <- connect (PROJ [("iter","iter")]) [q0]
       a1 <- connect DIFF [loop, a0]
       a2 <- leaf (TBL [("item",[INT])] [[I 0]])
       a3 <- connect X [a1,a2]
       a4 <- connect (COUNT "item" ["iter"]) [q0]
       a5 <- connect U [a4, a3]
       a6 <- leaf (TBL [("pos",[NAT])] [[O 1]])
       a7 <- connect X [a5, a6]

       return (a7, [])

t env loop (XFNNOT e0) =
    do (q0, _) <- t env loop e0

       a0 <- connect (NOT "res" "item") [q0]
       a1 <- connect (PROJ [("iter","iter"),("pos","pos"),("item","res")]) [a0]

       return (a1, [])

t env loop (XIS e0 e1) = t env loop (XEQ e0 e1)

t env loop (XBEFORE e0 e1) = t env loop (XLT e0 e1)

t env loop (XAFTER e0 e1) = t env loop (XGT e0 e1)

t env loop (XFNEMPTY e0) =
    do (q0, _) <- t env loop e0

       a0 <- connect (PROJ [("iter","iter")]) [q0]
       a1 <- connect DIST [a0]
       a2 <- leaf (TBL [("item",[BOOL])] [[B False]])
       a3 <- connect X [a1, a2]
       a4 <- connect DIFF [loop, a0]
       a5 <- leaf (TBL [("item",[BOOL])] [[B True]])
       a6 <- connect X [a4, a5]
       a7 <- connect U [a3, a6]
       a8 <- leaf (TBL [("pos",[NAT])] [[O 1]])
       a9 <- connect X [a7, a8]

       return (a9, [])

t env loop (XFNDIST e0) =
    do (q0, lv0) <- t env loop e0

       a0 <- connect (PROJ [("iter","iter"),("item","item")]) [q0]
       a1 <- connect DIST [a0]
       a2 <- connect (ROWNUM ("pos",[]) ["iter"]) [a1]

       return (a2, lv0)

t env loop (XFNDDO e0) =
    do (q0, lv0) <- t env loop e0

       a0 <- connect (PROJ [("iter","iter"),("item","item")]) [q0]
       a1 <- connect DIST [a0]
       a2 <- connect (ROWNUM ("pos",["item"]) ["iter"]) [a1]

       return (a2, lv0)

t env loop (XFNDOC e0) =
    do (q0, _) <- t env loop e0

       a0 <- connect DMDOC [q0]
       a1 <- connect DMFRAGS [a0]
       a2 <- connect DMROOTS [a0]
       a3 <- connect (PROJ [("iter","iter"),("item","pre")]) [a2]
       a4 <- leaf (TBL [("pos",[NAT])] [[O 1]])
       a5 <- connect X [a4, a3]

       return (a5, [a1])

t env loop (XFNDATA e0) =
    do (q0, lv0) <- t env loop e0

       a0 <- live_nodes lv0
       a1 <- connect DMDATA [a0, q0]
       a2 <- leaf (TBL [("pos",[NAT])] [[O 1]])
       a3 <- connect X [a1, a2]

       return (a3, [])

t env loop (XFNROOT e0) =
    do (q0, lv0) <- t env loop e0

       a0 <- live_nodes lv0
       a1 <- connect DMROOT [a0, q0]
       a2 <- leaf (TBL [("pos",[NAT])] [[O 1]])
       a3 <- connect X [a1, a2]

       return (a3, lv0)
       
t env loop XFNTRUE =
    do a0 <- leaf (TBL [("pos",[NAT]),("item",[BOOL])] [[O 1, B True]])
       a1 <- connect X [loop, a0]

       return (a1, [])

t env loop XFNFALSE =
    do a0 <- leaf (TBL [("pos",[NAT]),("item",[BOOL])] [[O 1, B False]])
       a1 <- connect X [loop, a0]

       return (a1, [])

t env loop (XCASTINT e0) =
    do (q0, _) <- t env loop e0

       a0 <- connect (CINT "item") [q0]
       
       return (a0, [])

t env loop (XCASTSTR e0) =
    do (q0, _) <- t env loop e0

       a0 <- connect (CSTR "item") [q0]
       
       return (a0, [])

t env loop (XCASTDEC e0) =
    do (q0, _) <- t env loop e0

       a0 <- connect (CDEC "item") [q0]
       
       return (a0, [])

t env loop (XCASTDBL e0) =
    do (q0, _) <- t env loop e0

       a0 <- connect (CDBL "item") [q0]
       
       return (a0, [])

t env loop (XTYPESW e0 ty e1 e2) =
    do (q0, _) <- t env loop e0

       -- sequence type matching
       let seqtym (Item t) = seqtym' False SEQTY1 t
	   seqtym ((:?) t) = seqtym' True  SEQTY1 t
	   seqtym ((:+) t) = seqtym' False ALL    t
	   seqtym ((:*) t) = seqtym' True  ALL    t

           seqtym' b op t =
	       do a0 <- connect (TYPE "itemty" "item" t) [q0]
                  a1 <- connect (PROJ [("iter","iter")]) [a0]
                  a2 <- connect DIFF [loop, a1]
                  a3 <- leaf (TBL [("subty",[BOOL])] [[B b]])
                  a4 <- connect X [a3, a2]
                  a5 <- connect (op "subty" "itemty" ["iter"]) [a0]
                  a6 <- connect U [a4, a5]
                  return a6

       stm <- seqtym ty

       a7    <- connect (SEL "subty") [stm]
       loop1 <- connect (PROJ [("iter","iter")]) [a7]
       a8    <- connect (NOT "res" "subty") [stm]
       a9    <- connect (SEL "res") [a8]
       loop2 <- connect (PROJ [("iter","iter")]) [a9]

       let lift loop (vi, (qvi, lvi)) = 
	       do a10 <- connect (PROJ [("iter1","iter")]) [loop]
		  a11 <- connect (JOIN ("iter","iter1")) [qvi, a10]
		  a12 <- connect (PROJ [("iter","iter"),
				       ("pos","pos"),
                                       ("item","item")]) [a11]
		  return (vi, (a12, lvi))

       env1 <- mapM (lift loop1) env
       env2 <- mapM (lift loop2) env

       (q1, lv1) <- t env1 loop1 e1
       (q2, lv2) <- t env2 loop2 e2

       a13 <- connect U [q1, q2]
            
       return (a13, lv1 ++ lv2)
       
t env loop (XORDER e0 e1s) =
    do (q0, lv0) <- t env loop e0

       let -- unique column names
           iters = map ("iter" ++) (map show [1..])
           items = map ("item" ++) (map show [1..length e1s])

       -- compile order specs (ignore live node fragments)
       q1s <- mapM (liftM fst . t env loop) e1s

       (a0:a0s) <- mapM (\(q,(iter,item)) ->
                         connect (PROJ [(iter,"iter"),(item,"item")]) [q])
                        (zip q1s (zip iters items))

       a1 <- foldM (\q (q',p) -> connect (JOIN p) [q, q']) 
                   a0 
                   (zip a0s (zip iters (tail iters)))

       a2 <- connect (ROWNUM ("ord", items) []) [a1]
       a3 <- connect (PROJ [("ord","ord"),("iter1","iter1")]) [a2]
       a4 <- connect (JOIN ("iter1","iter")) [q0, a3]
       a5 <- connect (PROJ [("iter","ord"),("pos","pos"),("item","item")]) [a4]

       return (a5, lv0)

t env loop (XIF e0 e1 e2) =
    do (q0, _) <- t env loop e0
       
       a0    <- connect (SEL "item") [q0]
       loop1 <- connect (PROJ [("iter","iter")]) [a0]
       a1    <- connect (NOT "res" "item") [q0]
       a2    <- connect (SEL "res") [a1]
       loop2 <- connect (PROJ [("iter","iter")]) [a2]
       
       let lift loop (vi, (qvi, lvi)) = 
	       do a3 <- connect (PROJ [("iter1","iter")]) [loop]
                  a4 <- connect (JOIN ("iter","iter1")) [qvi, a3]
                  a5 <- connect (PROJ [("iter","iter"),
                                       ("pos","pos"),
                                       ("item","item")]) [a4]
                  return (vi, (a5, lvi))

       env1 <- mapM (lift loop1) env
       env2 <- mapM (lift loop2) env

       (q1, lv1) <- t env1 loop1 e1
       (q2, lv2) <- t env2 loop2 e2

       a6 <- connect U [q1, q2]
            
       return (a6, lv1 ++ lv2)

t env loop (XSEQ e0 e1) =
    do (q0, lv0) <- t env loop e0
       (q1, lv1) <- t env loop e1

       a0 <- leaf (TBL [("ord",[NAT])] [[O 0]])
       a1 <- leaf (TBL [("ord",[NAT])] [[O 1]]) 
       a2 <- connect X [a0, q0]
       a3 <- connect X [a1, q1]
       a4 <- connect U [a2, a3]
       a5 <- connect (ROWNUM ("pos1", ["ord","pos"]) ["iter"]) [a4]
       a6 <- connect (PROJ [("iter","iter"),("pos","pos1"),("item","item")]) 
                     [a5]

       return (a6, lv0 ++ lv1) 

t env loop (XLET v e0 e1) =
    do (q0, lv0) <- t env loop e0
       (q1, lv1) <- t ((v, (q0, lv0)):env) loop e1

       return (q1, lv1)

t env loop (XVAR v) =
    do let (qv, lnv) = case lookup v env of
		       Just e  -> e
                       Nothing -> error ("variable $" ++ v ++ " unknown")
        
       return (qv, lnv)

t env loop (XFUN fn e0s) =
    do a0s <- mapM (t env loop) e0s

       let (vs, e1) = case lookup fn udfs of
		           Just (vs, e1) -> (vs, e1)
                           Nothing       -> error ("function " ++ fn ++ 
						   " unknown")

           env' = zip vs a0s ++ env

       (q1, lv1) <- t env' loop e1

       return (q1, lv1)
 
t env loop (XFOR v e0 e1) =
    do (q0, lv0) <- t env loop e0

       a0 <- connect (ROWNUM ("inner", ["iter","pos"]) []) [q0]
       a1 <- connect (PROJ [("iter","inner"),("item","item")]) [a0]
       a2 <- leaf (TBL [("pos",[NAT])] [[O 1]])
       qv <- connect X [a2, a1]

       loop0 <- connect (PROJ [("iter","iter")]) [qv]
       map0  <- connect (PROJ [("outer","iter"),("inner","inner")]) [a0]

       let lift m (vi, (qvi, lvi)) =
	       do a3   <- connect (JOIN ("iter","outer")) [qvi, m]
                  qvi' <- connect (PROJ [("iter","inner"),
                                         ("pos","pos"),
                                         ("item","item")]) [a3]
                  return (vi, (qvi', lvi))
                  
       env' <- mapM (lift map0) env
 
       (q1, lv1) <- t ((v, (qv, lv0)):env') loop0 e1

       a4 <- connect (JOIN ("iter","inner")) [q1, map0]
       a5 <- connect (ROWNUM ("pos1", ["iter","pos"]) ["outer"]) [a4]
       a6 <- connect (PROJ [("iter","outer"),
                            ("pos","pos1"),
                            ("item","item")]) [a5]

       return (a6, lv1)

t env loop (XFORAT v p e0 e1) =
    do (q0, lv0) <- t env loop e0
       
       a0 <- connect (ROWNUM ("inner", ["iter","pos"]) []) [q0]
       a1 <- connect (PROJ [("iter","inner"),("item","item")]) [a0]
       a2 <- leaf (TBL [("pos",[NAT])] [[O 1]])
       qv <- connect X [a2, a1]

       loop0 <- connect (PROJ [("iter","iter")]) [qv]
       map0  <- connect (PROJ [("outer","iter"),("inner","inner")]) [a0]

       -- compute representation of variable that holds value of
       -- position variable p 
       a3 <- connect (ROWNUM ("item", ["inner"]) ["outer"]) [map0]
       a4 <- connect (CINT "item") [a3]
       a5 <- connect (PROJ [("iter","inner"),("item","item")]) [a4]
       qp <- connect X [a2, a5]
              
       let lift m (vi, (qvi, lvi)) =
	       do a6   <- connect (JOIN ("iter","outer")) [qvi, m]
                  qvi' <- connect (PROJ [("iter","inner"),
                                         ("pos","pos"),
                                         ("item","item")]) [a6]
                  return (vi, (qvi', lvi))
                  
       env' <- mapM (lift map0) env
 
       (q1, lv1) <- t ((p, (qp, [])):(v, (qv, lv0)):env') loop0 e1

       a7 <- connect (JOIN ("iter","inner")) [q1, map0]
       a8 <- connect (ROWNUM ("pos1", ["iter","pos"]) ["outer"]) [a7]
       a9 <- connect (PROJ [("iter","outer"),
                            ("pos","pos1"),
                            ("item","item")]) [a8]

       return (a9, lv1)

t env loop (XELEM e0 e1) = 
    do (q0, _)   <- t env loop e0
       (q1, lv1) <- t env loop e1

       a0 <- live_nodes lv1
       a1 <- connect ELEM [a0, q0, q1] 
       a2 <- connect DMFRAGS [a1]
       a3 <- connect DMROOTS [a1]
       a4 <- connect (PROJ [("iter","iter"),("item","pre")]) [a3]
       a5 <- leaf (TBL [("pos",[NAT])] [[O 1]])
       a6 <- connect X [a4, a5]

       return (a6, [a2])

t env loop (XTEXT e0) =
    do (q0, _) <- t env loop e0

       a0  <- connect (PROJ [("iter","iter")]) [q0]
       a1  <- connect DIFF [loop, a0]
       a2  <- leaf (TBL [("pos",[NAT]),("item",[STR])] [[O 1,S ""]])
       a3  <- connect X [a1, a2]
       a4  <- connect U [q0, a3]
       a5  <- connect TEXT [a4]
       a6  <- connect DMROOTS [a5]
       a7  <- connect DMFRAGS [a5]
       a8  <- connect (PROJ [("iter","iter"),("item","pre")]) [a6]
       a9  <- leaf (TBL [("pos",[NAT])] [[O 1]])
       a10 <- connect X [a8, a9]

       return (a10, [a7])

t env loop (XPATH e0 s) =
    do (q0, lv0) <- t env loop e0

       a0 <- live_nodes lv0
       a1 <- connect (PROJ [("iter","iter"),("item","item")]) [q0]
       a2 <- connect (SCJ s) [a0, a1]
       a3 <- connect (ROWNUM ("pos", ["item"]) ["iter"]) [a2]

       return (a3, lv0)

----------------------------------------------------------------------
-- DAG construction (used during query compilation)

live_nodes :: [Node] -> State (DAG AlgOp) Node
live_nodes []     = leaf DMEMPTY
live_nodes [f]    = return f
live_nodes (f:fs) = do a0 <- live_nodes fs
                       a1 <- connect DMU [f,a0]
                       return a1

-- connect new node labelled l to nodes vs in the DAG 
-- (returns new node)
connect :: a -> [Node] -> State (DAG a) Node
connect l vs = do g <- get
                  let n = newNode g
                  put ((n, l, zip (repeat ()) vs) & g) 
                  return n

-- create (disconnected) leaf with label in DAG 
-- (returns new leaf)
leaf :: a -> State (DAG a) Node
leaf l = do g <- get
            let n = newNode g
            put ((n, l, []) & g)
            return n
            
       