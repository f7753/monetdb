@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2005 CWI.
@' All Rights Reserved.

@' 
@' Contributor(s):
@' 		Martin Kersten <Martin.Kersten@cwi.nl>
@' 		Peter Boncz <Peter.Boncz@cwi.nl>
@' 		Niels Nes <Niels.Nes@cwi.nl>
@' 		Stefan Manegold  <Stefan.Manegold@cwi.nl>

@f pf_support
@a Stefan Manegold
@v 1.0
@t MIL primitives to support the XQuery front-end "Pathfinder"

@* Introduction
This modules provides new MIL primitives to support the XQuery
implementation on to of MonetDB within the "Pathfinder" project.
@
@* Module Definition 
@m
.MODULE pf_support;

.COMMAND mark_grp( BAT[any::1,oid] b , BAT[oid,oid] g)
		: BAT[any::1,OID] = CMDmark_grp; 
"\"grouped mark\": Produces a new BAT with per group a locally unique dense
 ascending sequense of OIDs in the tail. The tail of the first BAT (b)
 identifies the group that each BUN of b belongs to. The second BAT (g)
 represents the group extend, i.e., the head is the unique list of group IDs
 from b's tail. The tail of g gives for each group the base value for the new
 OID sequence."

.COMMAND merged_union( BAT[oid,any::1] left, BAT[oid,any::1] right, ..BAT[oid,any].. )
		: BAT[void,BAT] = CMDmerged_union;
"PARAMETERS:
Even number of BAT[oid,any] with dense heads and pairs of equal tail type;
all odd BATs must be head-aligned and all even BATs must be head-aligned;
first two BATs must be sorted on tail values.
DESCRIPITON:
Merges pairs of bats according to the order as defined by the first pair's tails."
@(
"Returns the union of two *tail-sorted* BATs. All BUNs of both BATs appear
 in the result, i.e., duplicates are not eliminated. As opposed to standard
 "union", the sortedness on the tail column is maintained in the result and
 all BUNs in the result appear in the same order as in their respective
 input."
@)

.COMMAND combine_text_string( BAT[void,oid] iter, BAT[void,oid] kind, BAT[void,str] str_value, int result_size )
		: BAT[oid,str] = CMDcombine_text_string;
"PARAMETERS:
BAT[void,oid] - iter values which have to be ordered
BAT[void,oid] - one of three different kinds (strings '3@0'; text-nodes '2@0' and other nodes '1@0')
BAT[void,str] - string values of the strings and text-nodes; an empty string for each other node
DESCRIPITON:
very specialized helper function for the translation of the item-sequence-to-node-sequence function in XQuery.
It expects three aligned columns and creates out of adjazent strings and text-nodes one string,
which can be translated into a text-node again. Every other node and every new iter divide the strings.
A space is inserted if two strings are adjazent and no space is inserted, if a text-node is in between. 
Empty strings are not added to the output."

.COMMAND string_join( BAT[oid,str] iter_str, BAT[oid,str] separator )
		: BAT[oid,str] = CMDstring_join;
"PARAMETERS:
BAT[oid,str] - sorted iters in the head, string values in the tail
BAT[oid,str] - separator which is added between strings, within an iter
DESCRIPITON:
string_join constructs for each iter one strings by appending the strings
with the separator for this iter in between."

.COMMAND mposjoin( BAT[oid,oid] pre, BAT[oid,oid] frag, BAT[oid, bat] ws_item )
		: BAT[void,any] = CMDmposjoin;
"PARAMETERS:
BAT[oid,oid] - the values which have to be looked up
BAT[oid,oid] - the corresponding fragments in which the values have to be looked up
BAT[oid,BAT[oid,any]] - the list of bats where the values are looked up
All BAT-heads must be dense.
DESCRIPITON:
looks up the values in a list of bats. The first argument specifies the
value to be looked up (joined) and the second one saves which bat contains
the value (see also 'mvaljoin').
The result is a bat with the tail values from the batlist (any) and the same
void column like the first two arguments"

.COMMAND mvaljoin( BAT[oid,oid] pre, BAT[oid,oid] frag, BAT[oid, bat] ws_item )
		: BAT[oid,oid] = CMDmvaljoin;
"PARAMETERS:
BAT[oid,oid] - the values which have to be joined
BAT[oid,oid] - the corresponding fragments in which the values have to be looked up
BAT[oid,BAT[oid,oid]] - the list of bats where the tail values are joined
All BAT-heads must be dense.
DESCRIPITON:
joins the tail values of the first argument with the tail values of the bat
from one bat of the third argument. Which bat from the list is chosen is
specified by the second argument (see also 'mposjoin').
The result is a bat with the head values of the first two arguments in the head
and the head values from the batlist"

.END pf_support;

@mil
PROC chk_order( BAT[any::1,any::2] b ) : bat[any::1,any::2] 
{
        VAR h1 := b.ordered();
        VAR t1 := b.reverse().ordered();
	return b;
}
PROC chk_order( BAT[any::1,any::2] b, bit warn ) : int 
{
        VAR h1 := b.ordered();
        VAR t1 := b.reverse().ordered();
        VAR rtrn := 0;
        if (not(h1)) {
		# head is not sorted
                rtrn :or= 4;
        }
        if (not(t1)) {
		# tail is not sorted
                rtrn :or= 8;
        }
        return rtrn;
}
ADDHELP("chk_order", "manegold", "Jul 24 2004",
	" Simple proc that triggers property checking on BAT b.\n"+
	" If 'warn' is 'TRUE', warnings are issued if properties\n"+
	" (e.g., sortedness) do hold, but the respective flags were not set.\n"+
	" The return value 'r' is a 4-bit pattern, where the bits indicate\n"+
	" the following when set:\n"+
	"  0 (and(r,1)==1): 'ordered'-flag of head did change,\n"+
	"  1 (and(r,2)==2): 'ordered'-flag of tail did change,\n"+
	"  2 (and(r,4)==4): head is not sorted,\n"+
	"  3 (and(r,8)==8): tail is not sorted.",
	"pf_support");

proc fetch(bat[any::1,any::2] b, bat[void,any] sel) : bat[any::1,any::2] {
	var cnt := sel.count();
	var lo := int(sel.seqbase());
	var hi := lo + cnt - 1;
	if ((cnt = 0) or isnil(lo)) {
		lo := 1; hi := 0;
	}
	return b.slice(lo,hi);
}


proc htordered_unique_thetajoin( bat[oid,any::2] l, 
                                 int mode, 
                                 bat[any::2,oid] r ) : bat[oid,oid] {
	return htordered_unique_thetajoin( nil, l, mode, r, nil );
}

proc htordered_unique_thetajoin( bat[any::1,oid] lx, bat[oid,any::2] l, 
                                 int mode, 
                                 bat[any::2,oid] r ) : bat[any::1,oid] {
	return htordered_unique_thetajoin( lx, l, mode, r, nil );
}

proc htordered_unique_thetajoin( bat[oid,any::2] l, 
                                 int mode, 
                                 bat[any::2,oid] r, bat[oid,any::3] rx ) : bat[oid,any::3] {
	return htordered_unique_thetajoin( nil, l, mode, r, rx );
}

@= bat_any1_oid
bat[any::1,oid]
@
@= bat_oid_any3
bat[oid,any::3]
@mil

@:htordered_unique_thetajoin( void           , void           , oid   , oid   ,                              ,                            ,                                               )@

@:htordered_unique_thetajoin( @:bat_any1_oid@, void           , any::1, oid   , @:lx_join_opt@               , @:lx_join(l)@              , @:lx_join(join_order)@                        )@

@:htordered_unique_thetajoin( void           , @:bat_oid_any3@, oid   , any::3,                @:rx_join_opt@,               @:rx_join(r)@,                        @:rx_join(join_order)@ )@

@:htordered_unique_thetajoin( @:bat_any1_oid@, @:bat_oid_any3@, any::1, any::3, @:lx_join_opt@ @:rx_join_opt@, @:lx_join(l)@ @:rx_join(r)@, @:lx_join(join_order)@ @:rx_join(join_order)@ )@

@= lx_join_opt
    # try to reduce footprint, first:
    # join with lx only if it's smaller than l
    if (htype(lx) <= 3) { # <= sht  hence  < oid
        @:lx_join(l)@
    }
@
@= rx_join_opt
    # try to reduce footprint, first:
    # join with rx only if it's smaller than r
    if (htype(rx) <= 3) { # <= sht  hence  < oid
        @:rx_join(r)@
    }
@
@= lx_join
    if (not(isnil(lx))) {
        @1 := reverse(leftfetchjoin(reverse(@1),reverse(lx)));
        lx := nil;
    }
@
@= rx_join
    if (not(isnil(rx))) {
        @1 := leftfetchjoin(@1,rx);
        rx := nil;
    }
@mil

@= htordered_unique_thetajoin
proc htordered_unique_thetajoin( @1 lx, bat[oid,any::2] l,
                                 int mode,
                                 bat[any::2,oid] r, @2 rx ) : bat[@3,@4]
{
    if ((int(l).count() = 0LL) or (int(r).count() = 0LL)) { 
        # if present, join with lx/rx
        @6
        return l.join(r); 
    }
    if (not(l.ordered()) or not(r.reverse().ordered())) {
        ERROR("htordered_unique_thetajoin(): ordered l.head and r.tail columns (iters) expected.\n");
    }

    if (mode != EQ) {
        # try to reduce footprint, first:
        # join with lx/rx only if smaller than l/r
        @5
        # trick: as we eliminate double matches anyway, let's not generate them to start with
        # pumps are efficient because merge-based
        if ((mode = GT) or (mode = GE)) {
            l := {max}(l);
            r := {min}(r.reverse()).reverse();
        } else {
            l := {min}(l);
            r := {max}(r.reverse()).reverse();
        }
        # now warm up r with a nice sequential scan.. investigating what is to come
        var cnt := nlthetajoin(r.reverse(), l.sample(16).reverse(), mode, int(l).count());
        cnt := int(cnt).count();
        if (cnt > (int(r).count() / 16LL)) {
            # if not done, yet, join with lx/rx
            @6
            # a large intermediate result is better handled with nested loop
            return nlthetajoin(l, r, mode, (cnt / 16LL)*int(l).count()); # no reordering necessary!!
        }
    }
    var join_order := leftthetajoin(l, r, mode);
    var snd_iter := join_order.reverse().mark(0@0).reverse();
    var fst_iter := join_order.mark(0@0).reverse();
    var sorting := fst_iter.CTrefine(snd_iter); # this may hurt
    if (lng(max(sorting)) != int(sorting).count()) {
        # the output of CTrefine allows to easily check if it is kunique
        sorting := sorting.reverse().kunique().reverse(); # merge-based kunique
    }
    join_order := join_order.fetch(sorting); # this may hurt as well
    # joins with lx/rx can only be done after the CTrefine() and kunique()
    @7
    return join_order;
}
@mil


PROC fake_project (any::1 c) : bat[void,any::1]
{
    	return new(void,type(c),1).seqbase(nil).insert(nil,c).access(BAT_READ);
}

PROC is_fake_project (bat[oid,any::1] b) : bit
{
	return and(count(b) = 1, isnil(seqbase(b)));
}

@= fake_fetch
PROC fake_fetch (bat[void,any::1] b, @1 p) : any::1
{
	if (is_fake_project(b)) {
		return b.fetch(0);
	} else {
		return b.fetch(p);
	}
}
@mil
@:fake_fetch(int)@
@:fake_fetch(oid)@

PROC fake_leftfetchjoin (bat[oid,oid] l, bat[oid,any::3] r) : bat[oid,any::3]
{
	if (is_fake_project(r)) {
		return r;
	} else {
		return leftfetchjoin(l,r);
	}
}


@* Module Implementation
@h
#ifndef PF_SUPPORT_H
#define PF_SUPPORT_H

#include "pf_support.proto.h"

#endif
@c
#include "pf_support.h"
#include <gdk_scanselect.h> /* for type-specific HT_bunfastins_nocheck_noinc(), until they're moved to gdk.mx */
#if SIZEOF_OID == SIZEOF_INT
#define oidoid_bunfastins(b,h,t) intint_bunfastins(b,h,t);
#else
#define oidoid_bunfastins(b,h,t) lnglng_bunfastins(b,h,t);
#endif

static bit is_fake_project (BAT* b)
{
	BATcheck(b, "is_fake_project");
	if ((BATcount(b)==1) && (b->hseqbase==oid_nil)) {
		return TRUE;
	} else {
		return FALSE;
	}
}

@= mark_grp_loop3
{	BUN p, q;
	int xx;
	BATloopFast(b, p, q, xx) {
		oid n = oid_nil;
		BUN w;
		ptr v = BUNt@2(b, p);

		BUNfnd@3(w, gc, v);
		if (w) {
			oid *m = (oid*) BUNtloc(gc, w);
			if (*m != oid_nil) {
				n = (*m)++;
			}
		}
		if (n == oid_nil) {
			tsdk = 0;
		}
		bunfastins_nocheck(bn, r, BUNh@1(b, p), &n, yy); 
		r += yy; 
	}
}
@= mark_grp_loop2
	if (gc->htype==TYPE_void) {
		@:mark_grp_loop3(@1,@2,VOID)@
	} else {
		@:mark_grp_loop3(@1,@2,OID)@
	}
@= mark_grp_loop1
	if (b->ttype==TYPE_void) {
		@:mark_grp_loop2(@1,var)@
	} else {
		@:mark_grp_loop2(@1,loc)@
	}
@= mark_grp_loop
{	BUN r = BUNfirst(bn);
	int yy = BUNsize(bn);
	if (b->hvarsized) {
		@:mark_grp_loop1(var)@
	} else {
		@:mark_grp_loop1(loc)@
	}
}

@c
static BAT *BATmark_grp( BAT *b, BAT *g )
{
        BAT *bn, *gc;
	int tsdk;
 
        BATcheck(b, "BATmark_grp");
        BATcheck(g, "BATmark_grp");
	ERRORcheck((b->ttype!=TYPE_void) && (b->ttype!=TYPE_oid),
	           "BATmark_grp: tail of BAT b must be oid.\n");
	ERRORcheck((g->htype!=TYPE_void) && (g->htype!=TYPE_oid),
	           "ERRORcheck: head of BAT g must be oid.\n");
	ERRORcheck((g->ttype!=TYPE_oid),
	           "BATmark_grp: tail of BAT g must be oid.\n");

	tsdk = ((BATcount(g) == 1) || (BATcount(b) == 0));
	gc = batcopy(g, g->htype, g->ttype, TRUE);
	if (gc == NULL) return NULL;
	bn = BATnew(b->htype, TYPE_oid, BATcount(b));
	if (bn == NULL) {
		BBPreclaim(gc);
		return NULL;
	}

	@:mark_grp_loop@

	ALIGNsetH(bn,b);
	bn->hsorted = BAThordered(b);
	bn->hdense = BAThdense(b);
	if (BAThdense(bn)) {
		BATseqbase(bn, b->hseqbase);
	}
	BATkey(bn, (b->hkey!=0));
	bn->tsorted = (tsdk?GDK_SORTED:0);
	bn->tdense = tsdk;
	if (BATtdense(bn)) {
		if (BATcount(bn) == 0) {
			BATseqbase(BATmirror(bn), (oid)0);
		} else {
			BATseqbase(BATmirror(bn), *(oid*)BUNtloc(bn,BUNfirst(bn)));
		}
	}
	BATkey(BATmirror(bn), tsdk);

	BBPreclaim(gc);
        return bn;
bunins_failed:
	BBPreclaim(gc);
	BBPreclaim(bn);
	return NULL;
}

int CMDmark_grp( BAT** res, BAT *b, BAT *g )
{
	return (*res=BATmark_grp(b, g))?GDK_SUCCEED:GDK_FAIL;
}


int CMDmerged_union( BAT** res, BAT *L, BAT *R, ... )
{
	BAT *b[MAXPARAMS], *bn[MAXPARAMS>>1], *BN;
	BUN cur[MAXPARAMS], lst[MAXPARAMS], dst[MAXPARAMS>>1], DST;
	int bs[MAXPARAMS], bns[MAXPARAMS>>1], BS;
	int nbats = 2, npairs = 1, i, j, k, any;
	chr *w = NULL;
	size_t sze = 0, h = 0;
	va_list ap;
	
	*res = NULL;

	/* check arguments */

	BATcheck(L, "merged_union");
	BATcheck(R, "merged_union");
	ERRORcheck(BATcount(L)>1 && !(BATtordered(L)&1), "merged_union: tail of first BAT must be sorted.\n");
	ERRORcheck(BATcount(R)>1 && !(BATtordered(R)&1), "merged_union: tail of second BAT must be sorted.\n");

	b[0] = L;
	b[1] = R;
	va_start(ap,R);
	while((b[nbats] = va_arg(ap, BAT*)) != NULL) {
		nbats++;
	}
	va_end(ap);
	
	if (nbats&1) {
		GDKerror("merged_union: uneven number of BATs: %d.\n", nbats);
		return GDK_FAIL;
	}
	npairs = nbats>>1;

	for (i=0; i<nbats; i+=2) {
		bit ci, cj;
		j = i+1;
		ci = (i==0 || !is_fake_project(b[i]));
		cj = (j==1 || !is_fake_project(b[j]));
		if (ci && !BAThdense(b[i])) {
			GDKerror("merged_union: BAT %d must have a dense head.\n", i+1);
			return GDK_FAIL;
		}
		if (cj && !BAThdense(b[j])) {
			GDKerror("merged_union: BAT %d must have a dense head.\n", j+1);
			return GDK_FAIL;
		}
		if (ATOMtype(b[i]->ttype) != ATOMtype(b[j]->ttype)) {
			GDKerror("merged_union: BATs %d & %d must have the same tail types.\n", i+1, j+1);
			return GDK_FAIL;
		}
		if (ci && b[i]->hseqbase != b[0]->hseqbase) {
			GDKerror("merged_union: BAT %d must have the same hseqbase as BAT 1.\n", i+1);
			return GDK_FAIL;
		}
		if (cj && b[j]->hseqbase != b[1]->hseqbase) {
			GDKerror("merged_union: BAT %d must have the same hseqbase as BAT 2.\n", j+1);
			return GDK_FAIL;
		}
		if (ci && BATcount(b[i]) != BATcount(b[0])) {
			GDKerror("merged_union: BAT %d must have the same size as BAT 1.\n", i+1);
			return GDK_FAIL;
		}
		if (cj && BATcount(b[j]) != BATcount(b[1])) {
			GDKerror("merged_union: BAT %d must have the same size as BAT 2.\n", j+1);
			return GDK_FAIL;
		}
	}

	/* create result BATs */

	sze = BATcount(b[0]) + BATcount(b[1]);
	BN = BATnew(TYPE_void, TYPE_bat, npairs);
	if (BN == NULL) {
		GDKerror("merged_union: BATnew(TYPE_void, TYPE_bat, %d) failed.\n", npairs);
		return GDK_FAIL;
	}
	for (k=0; k<npairs; k++) {
		i = k<<1;
		bn[k] = BATnew(TYPE_void, ATOMtype(b[i]->ttype), sze);
		if (bn[k] == NULL) {
			GDKerror("merged_union: BATnew(TYPE_void, %s, " SZFMT ") failed.\n", ATOMname(ATOMtype(b[i]->ttype)), sze);
			while (k>0) {
				BBPreclaim(bn[--k]);
			}
			BBPreclaim(BN);
			return GDK_FAIL;
		}
	}
	if (sze > 0) {
		w = (chr*)GDKmalloc(sze);
		if (w == NULL) {
			GDKerror("merged_union: GDKmalloc(" SZFMT ") failed.\n", sze);
			goto cleanup;
		}
	}

	/* do the merged_union */

	for (k=0; k<npairs; k++) {
		bns[k] = BUNsize(bn[k]);
		dst[k] = BUNlast(bn[k]);
	}
	for (i=0; i<nbats; i++) {
		if (is_fake_project(b[i])) {
			bs[i] = 0;
		} else {
			bs[i] = BUNsize(b[i]);
		}
		cur[i] = BUNfirst(b[i]);
		lst[i] = BUNlast(b[i]);
	}
@= merged_union_0
	/*  @1: ATOMstorage(b[@3]->ttype) (chr, sht, int, flt, lng, dbl, any=b[@3]->ttype)
	 *  @2: tloc, tvar, tail
	 *  @3: 0, 1
	 *  @5: tail value comparison,
		e.g.,	simple_LE(BUN@2(b[0],cur[0]), BUN@2(b[1],cur[1]), @1)
		or	atom_GT(BUN@2(b[0],cur[0]), BUN@2(b[1],cur[1]), @1)
	 */
	/* copy tails from BAT @3 to the results; 
	   for each BUN, remember in w, whether it came from BAT 0 or BAT 1 */
	while ((cur[@3] < lst[@3]) && (@4)) {
		void@1_bunfastins_nocheck_noinc(bn[0],dst[0],0,BUN@2(b[@3],cur[@3]));
		cur[@3] += bs[@3];
		dst[0] += bns[0];
		w[h++] = (chr)@3;
	}
@= merged_union_1
	/*  @1: ATOMstorage(b[0]->ttype) (chr, sht, int, flt, lng, dbl, any=b[0]->ttype)
	 *  @2: tloc, tvar, tail (for BAT 0)
	 *  @3: tloc, tvar, tail (for BAT 1)
	 *  @4: simple, atom
	 */
	/* merge-union the first two BATs; regard and preserve tail-order */
	h = 0;
	while ((cur[0] < lst[0]) && (cur[1] < lst[1])) {
		@:merged_union_0(@1,@2,0,@4_LE(BUN@2(b[0],cur[0]),BUN@3(b[1],cur[1]),@1))@
		if (cur[0] < lst[0]) {
			@:merged_union_0(@1,@3,1,@4_GT(BUN@2(b[0],cur[0]),BUN@3(b[1],cur[1]),@1))@
		}
	}
	/* get remaining BUNs */
	@:merged_union_0(@1,@2,0,TRUE)@
	@:merged_union_0(@1,@3,1,TRUE)@
@= merged_union_2
	/*  @1: ATOMstorage(b[0]->ttype) (chr, sht, int, flt, lng, dbl, any=b[0]->ttype)
	 *  @2: tloc, tvar, tail (for BAT 0)
	 *  @3: simple, atom
	 */
	@:merged_union_1(@1,@2,@2,@3)@
	break;
@= merged_union_3
	/*  @1: ATOMstorage(b[@3]->ttype) (chr, sht, int, flt, lng, dbl, any=b[0]->ttype)
	 *  @2: tloc, tvar, tail
	 */
	/* merge-union each of the remaining BAT-pairs; 
	   w tell us, from which BAT we need to get the next BUN */
	for (h=0; h<sze; h++) {
		j = i + (int)w[h];
		void@1_bunfastins_nocheck_noinc(bn[k],dst[k],0,BUN@2(b[j],cur[j]));
		cur[j] += bs[j];
		dst[k] += bns[k];
	}
@= merged_union_4
	/*  @1: ATOMstorage(b[@3]->ttype) (chr, sht, int, flt, lng, dbl, any=b[0]->ttype)
	 *  @2: tloc, tvar, tail
	 */
	@:merged_union_3(@1,@2)@
	break;
@c
	/* merge-union the first two BATs */
/* HACK(?): compare [v]oid (unsigned) at int/lng (signed) to get nil's first... */
#if SIZEOF_OID == SIZEOF_INT
	if (b[0]->ttype==TYPE_void && b[1]->ttype==TYPE_void) {
		@:merged_union_1(int,tvar,tvar,simple)@
	} else if (b[0]->ttype==TYPE_void && b[1]->ttype==TYPE_oid) {
		@:merged_union_1(int,tvar,tloc,simple)@
	} else if (b[0]->ttype==TYPE_oid && b[1]->ttype==TYPE_void) {
		@:merged_union_1(int,tloc,tvar,simple)@
	} else if (b[0]->ttype==TYPE_oid && b[1]->ttype==TYPE_oid) {
		@:merged_union_1(int,tloc,tloc,simple)@
#else
	if (b[0]->ttype==TYPE_void && b[1]->ttype==TYPE_void) {
		@:merged_union_1(lng,tvar,tvar,simple)@
	} else if (b[0]->ttype==TYPE_void && b[1]->ttype==TYPE_oid) {
		@:merged_union_1(lng,tvar,tloc,simple)@
	} else if (b[0]->ttype==TYPE_oid && b[1]->ttype==TYPE_void) {
		@:merged_union_1(lng,tloc,tvar,simple)@
	} else if (b[0]->ttype==TYPE_oid && b[1]->ttype==TYPE_oid) {
		@:merged_union_1(lng,tloc,tloc,simple)@
#endif
	} else {
		any = b[0]->ttype;
		switch(ATOMstorage(b[0]->ttype)) {
		case TYPE_chr:	@:merged_union_2(chr,tloc,simple)@
		case TYPE_sht:	@:merged_union_2(sht,tloc,simple)@
		case TYPE_int:	@:merged_union_2(int,tloc,simple)@
		case TYPE_flt:	@:merged_union_2(flt,tloc,simple)@
		case TYPE_lng:	@:merged_union_2(lng,tloc,simple)@
		case TYPE_dbl:	@:merged_union_2(dbl,tloc,simple)@
		default:
			if (b[0]->tvarsized) {
				@:merged_union_2(any,tvar,atom)@
			} else {
				@:merged_union_2(any,tloc,atom)@
			}
		}
	}
	/* merge-union each of the remaining BAT-pairs */
	for (k=1; k<npairs; k++) {
		i = (k<<1);
		j = i+1;
/* HACK(?): compare [v]oid (unsigned) at int/lng (signed) to get nil's first... */
#if SIZEOF_OID == SIZEOF_INT
		if (b[i]->ttype==TYPE_void || b[j]->ttype==TYPE_void) {
			@:merged_union_3(int,tail,simple)@
		} else if (b[i]->ttype==TYPE_oid && b[j]->ttype==TYPE_oid) {
			@:merged_union_3(int,tloc,simple)@
#else
		if (b[i]->ttype==TYPE_void || b[j]->ttype==TYPE_void) {
			@:merged_union_3(lng,tail,simple)@
		} else if (b[i]->ttype==TYPE_oid && b[j]->ttype==TYPE_oid) {
			@:merged_union_3(lng,tloc,simple)@
#endif
		} else {
			any = b[i]->ttype;
			switch(ATOMstorage(b[i]->ttype)) {
			case TYPE_chr:	@:merged_union_4(chr,tloc)@
			case TYPE_sht:	@:merged_union_4(sht,tloc)@
			case TYPE_int:	@:merged_union_4(int,tloc)@
			case TYPE_flt:	@:merged_union_4(flt,tloc)@
			case TYPE_lng:	@:merged_union_4(lng,tloc)@
			case TYPE_dbl:	@:merged_union_4(dbl,tloc)@
			default:
				if (b[i]->tvarsized) {
					@:merged_union_4(any,tvar)@
				} else {
					@:merged_union_4(any,tloc)@
				}
			}
		}
	}

	/* set BAT properties */

	for (k=0; k<npairs; k++) {
		BATseqbase(bn[k], (oid)0);
		bn[k]->batBuns->free = dst[k] - bn[k]->batBuns->base;
		if (!bn[k]->batDirty) bn[k]->batDirty = TRUE;
		BATkey(bn[k],TRUE);
		BATkey(BATmirror(bn[k]),FALSE);
		bn[k]->hsorted = GDK_SORTED;
		bn[k]->tsorted = ((k==0)?GDK_SORTED:FALSE);
		bn[k]->hdense = TRUE;
		bn[k]->tdense = FALSE;
	}

	/* insert bn[] BATs in BN BAT */

	DST = BUNlast(BN);
	BS = BUNsize(BN);
	BATseqbase(BN, (oid)0);
	for (k=0; k<npairs; k++) {
		voidany_bunfastins_nocheck_noinc(BN,DST,0,&bn[k]->batCacheid);
		BBPunfix(bn[k]->batCacheid);
		DST += BS;
	}
	BN->batBuns->free = DST - BN->batBuns->base;
	if (!BN->batDirty) BN->batDirty = TRUE;
	BATkey(BN,TRUE);
	BATkey(BATmirror(BN),TRUE);
	BN->hsorted = GDK_SORTED;
	BN->tsorted = FALSE;
	BN->hdense = TRUE;
	BN->tdense = FALSE;

	*res = BN;

	GDKfree(w);

	return GDK_SUCCEED;
bunins_failed:
	GDKerror("merged_union: bunins failed.\n");
cleanup:
	BBPreclaim(BN);
	for (k=0; k<npairs; k++) {
		BBPreclaim(bn[k]);
	}
	return GDK_FAIL;
}


#define KIND_NODE (oid)1
#define KIND_TEXT (oid)2
#define KIND_STR  (oid)3

int CMDcombine_text_string( BAT** res, BAT *iter, BAT *kind, BAT *str_value, int *result_size )
{
	BAT *bn;
	BUN qi, pi, pk, ps;
	int bsi, bsk, bss;
	size_t cnt, len, strsize = 1024;
	oid base0, base, i0, k0;
	str actual_str = NULL;
	bit triv_prop;
	
	*res = NULL;

	/* check arguments */

	BATcheck(iter, "combine_text_string");
	BATcheck(kind, "combine_text_string");
	BATcheck(str_value, "combine_text_string");

	cnt = BATcount(iter);
	base = iter->hseqbase;
	ERRORcheck(!BAThdense(iter) || !BAThdense(kind) || !BAThdense(str_value), 
		"combine_text_string: all input BATs (iter, kind, str_value) must be void-headed with non-nil seqbase.\n");
	ERRORcheck(BATcount(kind)!=cnt || BATcount(str_value)!=cnt || kind->hseqbase!=base || str_value->hseqbase!=base,
		"combine_text_string: all input BATs (iter, kind, str_value) must be head-aligned.\n");
	ERRORcheck(!(BATtordered(iter)&1),
		"combine_text_string: input BAT iter must be sorted on tail.\n");

	/* create result BAT */

	bn = BATnew(TYPE_oid, TYPE_str, *result_size);
	if (bn == NULL) {
		GDKerror("combine_text_string: BATnew(TYPE_oid, TYPE_str, %d) failed.\n", *result_size);
		return GDK_FAIL;
	}

	/* do the combine_text_string */

	bsi = BUNsize(iter);
	bsk = BUNsize(kind);
	bss = BUNsize(str_value);

	pi = BUNfirst(iter);
	pk = BUNfirst(kind);
	ps = BUNfirst(str_value);

@= alloc_str
	/* allocate str buffer */
	@1 = (str)GDKmalloc(strsize);
	if (@1 == NULL) {
		GDKerror("combine_text_string: GDKmalloc(" SZFMT ") failed.\n", strsize);
		goto cleanup;
	}
@c
	@:alloc_str(actual_str)@
	len = 0;
	actual_str[0] = '\0';
	k0 = oid_nil;
	i0 = *(oid*)BUNtail(iter,pi); /* FIXME: "tvar" (void) vs. "tloc" (oid) */
	base0 = oid_nil;

	for (qi = BUNlast(iter) ; pi < qi ; pi += bsi, pk += bsk, ps += bss) {
		oid i = *(oid*)BUNtail(iter,pi); /* FIXME: "tvar" (void) vs. "tloc" (oid) */
		oid k = *(oid*)BUNtail(kind,pk); /* FIXME: "tvar" (void) vs. "tloc" (oid) */
		str s = (str)BUNtvar(str_value,ps);
		size_t l = strlen(s) + 1;
		if ( i0 < i || k == KIND_NODE ) {
			/* new iter or new node */
			if (len > 0) {
				/* actual_str of (previous) iter is not empty => insert it into result */
				bunfastins(bn, &base0, actual_str);
				len = 0;
				actual_str[0] = '\0';
			}
			k0 = oid_nil;
		}
		if (len+l >= strsize) {
			/* extend str buffer */
			str new_str = NULL;
			do {
				strsize *= 2;
			} while (len+l >= strsize);
			@:alloc_str(new_str)@
			memcpy(new_str, actual_str, len+1);
			GDKfree(actual_str);
			actual_str = new_str;
		}
		if (k0 == KIND_STR && k == KIND_STR) {
			/* insert ' '-separator between adjacent STRs */
			actual_str[len++] = ' ';
			actual_str[len] = '\0';
		}
		len += snprintf(actual_str+len, strsize-len, s);
		i0 = i;
		k0 = k;
		base0 = base++;
	}

	if (len > 0) {
		bunfastins(bn, &base0, actual_str);
	}

	GDKfree(actual_str);

	/* set result properties */

	if (!bn->batDirty) bn->batDirty = TRUE;
	triv_prop = (BATcount(bn) < 2);
	BATkey(bn,TRUE);
	BATkey(BATmirror(bn),triv_prop);
	bn->hsorted = GDK_SORTED;
	bn->tsorted = triv_prop;
	bn->hdense = triv_prop;
	bn->tdense = FALSE;
	if (BATcount(bn) == 0) {
		BATseqbase(bn, (oid)0);
	} else if (BATcount(bn) == 1) {
		BATseqbase(bn, *(oid*)BUNhloc(bn,BUNfirst(bn)));
	}
	*res = bn;

	return GDK_SUCCEED;
bunins_failed:
	GDKerror("combine_text_string: bunins failed.\n");
cleanup:
	if (actual_str) GDKfree(actual_str);
	BBPreclaim(bn);
	return GDK_FAIL;
}

int CMDstring_join ( BAT** res, BAT *iter_str, BAT *separator  )
{
	BAT *bn;
	BUN bun_iter_str, bun_sep, last_iter_str, last_sep;
	int bs_iter_str, bs_sep;
	size_t len, sep_len, strsize = 1024;
	oid i, i0, sep_oid, sep0;
	str s, sep, actual_str = NULL;
	bit triv_prop, first_string;
	
	*res = NULL;

	/* check arguments */

	BATcheck(iter_str, "string_join");
	BATcheck(separator, "string_join");

	ERRORcheck(!(BAThordered(iter_str)&1),
		"string_join: input BAT iter_str must be sorted on head.\n");
	ERRORcheck(!(BAThordered(separator)&1),
		"string_join: input BAT separator must be sorted on head.\n");

	/* create result BAT */

	bn = BATnew(TYPE_oid, TYPE_str, BATcount(separator));
	if (bn == NULL) {
		GDKerror("string_join: BATnew(TYPE_oid, TYPE_str, %d) failed.\n", BATcount(separator));
		return GDK_FAIL;
	}

	/* do the string_join */

	bs_iter_str = BUNsize(iter_str);
	bs_sep = BUNsize(separator);

	bun_iter_str = BUNfirst(iter_str);
	last_iter_str = BUNlast(iter_str);
	bun_sep = BUNfirst(separator);
	last_sep = BUNlast(separator);

	/* handling the empty cases */

	if (bun_iter_str == last_iter_str && bun_sep == last_sep) {
		/* ... head */
		BATkey (bn, TRUE);
                bn->hsorted = GDK_SORTED;
		bn->hdense = TRUE;
		BATseqbase (bn, (oid)0); /* does not really matter */
		/* ... tail */
		BATkey (BATmirror(bn), TRUE);
                bn->tsorted = GDK_SORTED;
		bn->tdense = FALSE;
		*res = bn;
 	       	return GDK_SUCCEED;
	}
	else if (bun_sep == last_sep) {
		GDKerror("string_join: expected oid %i@0 in iter_str "
                         "is missing in separator (0 rows).",
                         *(oid*)BUNhead(iter_str,bun_iter_str)); /* FIXME: "hvar" (void) vs. "hloc" (oid) */
		return GDK_FAIL;
	}
	else if (bun_iter_str == last_iter_str) {
		sep0 = oid_nil;
		sep_oid = *(oid*)BUNhead(separator,bun_sep); /* FIXME: "hvar" (void) vs. "hloc" (oid) */
		@:append_sep_and_set_props@
 	       	return GDK_SUCCEED;
	}

@= alloc_str
	/* allocate str buffer */
	@1 = (str)GDKmalloc(strsize);
	if (@1 == NULL) {
		GDKerror("string_join: GDKmalloc(" SZFMT ") failed.\n", strsize);
		goto cleanup;
	}
@c
	@:alloc_str(actual_str)@
	len = 0;
	actual_str[0] = '\0';

	i0 = *(oid*)BUNhead(iter_str,bun_iter_str); /* FIXME: "hvar" (void) vs. "hloc" (oid) */
	first_string = 1;
	sep0 = oid_nil;

@= get_next_separator
	/* - goes to the next row in the separator bat
	     to get the separator for the next iter value
	   - produces an error if oids are not aligned */
	sep_oid = *(oid*)BUNhead(separator,bun_sep); /* FIXME: "hvar" (void) vs. "hloc" (oid) */

	while (i0 > sep_oid && bun_sep != last_sep) {
		if (sep0 == sep_oid) {
			GDKerror("string_join: the head of separator has to be keyed.");
			return GDK_FAIL;
		}
		bunfastins(bn, &sep_oid, "");
		sep0 = sep_oid;
		bun_sep += bs_sep;
	        sep_oid = *(oid*)BUNhead(separator,bun_sep); /* FIXME: "hvar" (void) vs. "hloc" (oid) */
	}
	if (i0 == sep_oid && bun_sep != last_sep) {
		sep = (str)BUNtvar(separator,bun_sep);
		sep_len = strlen(sep);
	}
	else {
		GDKerror("string_join: expected oid %i@0 in iter_str "
			 "is missing in separator.",
			 i0);
		return GDK_FAIL;
	}
@c
	@:get_next_separator@

	for (; bun_iter_str < last_iter_str ; bun_iter_str += bs_iter_str) {
		i = *(oid*)BUNhead(iter_str,bun_iter_str); /* FIXME: "hvar" (void) vs. "hloc" (oid) */
		s = (str)BUNtvar(iter_str,bun_iter_str);

		size_t l = strlen(s) + sep_len + 1;

		if (i0 < i) {
			bunfastins(bn, &i0, actual_str);
			len = 0;
			actual_str[0] = '\0';
			i0 = i;
			first_string = 1;

			sep0 = sep_oid;
			bun_sep += bs_sep;
			@:get_next_separator@
		}

		if (len+l >= strsize) {
			/* extend str buffer */
			str new_str = NULL;
			do {
				strsize *= 2;
			} while (len+l >= strsize);
			@:alloc_str(new_str)@
			memcpy(new_str, actual_str, len+1);
			GDKfree(actual_str);
			actual_str = new_str;
		}

		/* adds the separator (starting before the second string) */

		if (first_string) {
			first_string = 0;
		}
		else {
			len += snprintf(actual_str+len, strsize-len, sep);
		}

		len += snprintf(actual_str+len, strsize-len, s);
	}

	/* inserts last row */

	if (len > 0) {
		bunfastins(bn, &i0, actual_str);
		sep0 = sep_oid;
		bun_sep += bs_sep;
	}

@= append_sep_and_set_props
	while (bun_sep != last_sep) {
	        sep_oid = *(oid*)BUNhead(separator,bun_sep); /* FIXME: "hvar" (void) vs. "hloc" (oid) */
		if (sep0 == sep_oid) {
			GDKerror("string_join: the head of separator has to be keyed.");
			return GDK_FAIL;
		}
		bunfastins(bn, &sep_oid, "");
		sep0 = sep_oid;
		bun_sep += bs_sep;
	}

	GDKfree(actual_str);

	/* set result properties */

	if (!bn->batDirty) bn->batDirty = TRUE;
	triv_prop = (BATcount(bn) < 2);
	BATkey(bn,TRUE);
	BATkey(BATmirror(bn),triv_prop);
	bn->hsorted = GDK_SORTED;
	bn->tsorted = triv_prop;
	bn->hdense = triv_prop;
	bn->tdense = FALSE;
	if (BATcount(bn) == 0) {
		BATseqbase(bn, (oid)0);
	} else if (BATcount(bn) == 1) {
		BATseqbase(bn, *(oid*)BUNhloc(bn,BUNfirst(bn)));
	}
	*res = bn;
@c
	@:append_sep_and_set_props@

	return GDK_SUCCEED;
bunins_failed:
	GDKerror("string_join: bunins failed.\n");
cleanup:
	if (actual_str) GDKfree(actual_str);
	BBPreclaim(bn);
	return GDK_FAIL;
}

int CMDmposjoin ( BAT** res, BAT* pre, BAT* frag, BAT* ws_item )
{
	BAT *bn, **batlist = NULL, *the_frag_bat = NULL;
	BUN q, pp, pf, pw, dst;
	int bs, bsp, bsf, ii = 0, tt = 0;
	size_t cnt, len;
	oid base, wl, wh;
	bit triv_prop;
	bit fake_frag = FALSE;
	bit fake_ws_item = FALSE;
	
	*res = NULL;

	/* check arguments */

	BATcheck(pre, "mposjoin");
	BATcheck(frag, "mposjoin");
	BATcheck(ws_item, "mposjoin");

	len = BATcount(ws_item);
	cnt = BATcount(pre);
	base = pre->hseqbase;
	fake_frag = is_fake_project(frag);
	
	if (fake_frag) {
		ERRORcheck(!BAThdense(pre) || !BAThdense(ws_item), 
			"mposjoin: input BATs pre & ws_item must have a dense head.\n");
	} else {
		ERRORcheck(!BAThdense(pre) || !BAThdense(frag) || !BAThdense(ws_item), 
			"mposjoin: all input BATs (pre, frag, ws_item) must have a dense head.\n");
		ERRORcheck(BATcount(frag)!=cnt || frag->hseqbase!=base,
			"mposjoin: first two input BATs (pre & frag) must be head-aligned.\n");
	}
	ERRORcheck(len==0,
		"mposjoin: third input BAT (ws_item) must not be empty.\n");

	the_frag_bat = BATdescriptor(*(bat*)BUNtloc(ws_item, BUNfirst(ws_item)));
	tt = the_frag_bat->ttype;
	BBPunfix(the_frag_bat->batCacheid);
	the_frag_bat = NULL;

	ii = 0;
	
	if (cnt==0) {
		@:mpos_res_empty@
	}
	if (fake_frag) {
		oid the_frag_id = *(oid*)BUNtail(frag, BUNfirst(frag));
		len = 1;
		batlist = &the_frag_bat;
		BUNfndVOID(pw, ws_item, &the_frag_id);
		if (pw==NULL) {
			@:mpos_res_empty@
		}

		@:mpos_init_batlist@
		if (!fake_ws_item) {
			*res = bn = BATleftfetchjoin(pre, batlist[0], oid_nil);
			@:mpos_free_batlist@
			if (bn == NULL) {
				GDKerror("mposjoin: BATleftfetchjoin(pre, ws_item["SZFMT"]) failed.\n",
					 the_frag_id);
				return GDK_FAIL;
			}
			return GDK_SUCCEED;
		}
	
	} else {
		batlist = (BAT**)GDKmalloc(len * sizeof(BAT*));
		if (batlist == NULL) {
			GDKerror("mposjoin: GDKmalloc(" SZFMT ") failed.\n", len * sizeof(BAT*));
			return GDK_FAIL;
		}
		BATloopFast(ws_item, pw, q, bs) {
			@:mpos_init_batlist@
		}
	}

@= mpos_init_batlist
{
		bit fake_item = FALSE;
		bat bid = *(bat*)BUNtloc(ws_item, pw);
		batlist[ii] = BATdescriptor(bid);
		fake_item = is_fake_project(batlist[ii]);
		fake_ws_item |= fake_item;
		if (!(fake_item || BAThdense(batlist[ii]))) {
			GDKerror("mposjoin: all BATs in the tail of the third input BAT (ws_item) must have a dense head.\n");
			ii++;
			@:mpos_free_batlist@
			return GDK_FAIL;
		}
		if (batlist[0]->ttype != batlist[ii]->ttype) {
			GDKerror("mposjoin: all BATs in the tail of the third input BAT (ws_item) must have the same tail type.\n");
			ii++;
			@:mpos_free_batlist@
			return GDK_FAIL;
		}
		ii++;
}	
@
@= mpos_res_empty
	cnt = 0;
	@:mpos_res_create@
	@:mpos_res_prop@

	return GDK_SUCCEED;
@
@= mpos_res_create
	/* create result BAT */

	bn = BATnew(TYPE_void, tt, cnt);
	if (bn == NULL) {
		GDKerror("mposjoin: BATnew(TYPE_void, %s, " SZFMT ") failed.\n", ATOMname(ATOMtype(tt)), cnt);
		@:mpos_free_batlist@
		return GDK_FAIL;
	}
	BATseqbase(bn, base);
@c
	@:mpos_res_create@
	bs = BUNsize(bn);
	dst = BUNlast(bn);

	/* do the mposjoin */

	wl = ws_item->hseqbase;
	wh = wl + len - 1;

	bsp = BUNsize(pre);
	if (fake_frag) {
		bsf = 0;
	} else {
		bsf = BUNsize(frag);
	}

	pp = BUNfirst(pre);
	pf = BUNfirst(frag);

@= mposjoin
	/*  @1: ATOMstorage(batlist[0]->ttype) (chr, sht, int, flt, lng, dbl, any)
	 *  @2: tloc, tvar, tail
	 */
	 if (fake_frag) {
	 	/* !fake_ws_item handled above */
	 	@:mposjoin_fake_fake(@1,@2)@
	 } else {
		if (fake_ws_item) {
			@:mposjoin_(@1,@2,is_fake_project(b))@
		} else {
			@:mposjoin_(@1,@2,FALSE)@
		}
	}
	break;
@
@= mposjoin_fake_fake
	/*  @1: ATOMstorage(batlist[0]->ttype) (chr, sht, int, flt, lng, dbl, any)
	 *  @2: tloc, tvar, tail
	 */
	BAT *b = batlist[0];
	ptr  w = BUN@2(b, BUNfirst(b));
	for (q = BUNlast(pre) ; pp < q ; pp += bsp) {
		void@1_bunfastins_nocheck_noinc(bn,dst,0,w);
		dst += bs;
	}
@
@= mposjoin_
	/*  @1: ATOMstorage(batlist[0]->ttype) (chr, sht, int, flt, lng, dbl, any)
	 *  @2: tloc, tvar, tail
	 *  @3: FALSE / is_fake_project(b)
	 */
	for (q = BUNlast(pre) ; pp < q ; pp += bsp, pf += bsf) {
		oid p = *(oid*)BUNtail(pre,pp);  /* FIXME: "tvar" (void) vs. "tloc" (oid) */
		oid f = *(oid*)BUNtail(frag,pf); /* FIXME: "tvar" (void) vs. "tloc" (oid) */
		if (f >= wl && f <= wh) {
			BAT *b = batlist[f - wl];
			if (@3) {
				void@1_bunfastins_nocheck_noinc(bn,dst,0,BUN@2(b,BUNfirst(b)));
				dst += bs;
			} else {
				oid l = b->hseqbase;
				oid h = l + BATcount(b) - 1;
				if (p >= l && p <= h) {
					oid b0 = BUNindex(b,BUNfirst(b));
					void@1_bunfastins_nocheck_noinc(bn,dst,0,BUN@2(b,BUNptr(b,p-l+b0)));
					dst += bs;
				}
			}
		}
	}
@c

	switch(ATOMstorage(batlist[0]->ttype)) {
	case TYPE_chr:	@:mposjoin(chr,tloc,simple)@
	case TYPE_sht:	@:mposjoin(sht,tloc,simple)@
	case TYPE_int:	@:mposjoin(int,tloc,simple)@
	case TYPE_flt:	@:mposjoin(flt,tloc,simple)@
	case TYPE_lng:	@:mposjoin(lng,tloc,simple)@
	case TYPE_dbl:	@:mposjoin(dbl,tloc,simple)@
	default:
		if (batlist[0]->tvarsized) {
			@:mposjoin(any,tvar,atom)@
		} else {
			@:mposjoin(any,tloc,atom)@
		}
	}
	bn->batBuns->free = dst - bn->batBuns->base;

@= mpos_res_prop
	/* set result properties */

	if (!bn->batDirty) bn->batDirty = TRUE;
	triv_prop = (BATcount(bn) < 2);
	BATkey(bn,TRUE);
	BATkey(BATmirror(bn),triv_prop);
	bn->hsorted = GDK_SORTED;
	bn->tsorted = triv_prop;
	bn->hdense = TRUE;
	bn->tdense = FALSE;

	*res = bn;
@c
	@:mpos_res_prop@
	@:mpos_free_batlist@

	return GDK_SUCCEED;
bunins_failed:
	GDKerror("mposjoin: bunins failed.\n");
	BBPreclaim(bn);
@= mpos_free_batlist
	while (ii > 0) {
		BBPunfix(batlist[--ii]->batCacheid);
	}
	if (batlist && !fake_frag) {
		GDKfree(batlist);
	}
@c
	@:mpos_free_batlist@
	return GDK_FAIL;
}


int CMDmvaljoin ( BAT** res, BAT* pre, BAT* frag, BAT* ws_item )
{
	BAT *bn, **batlist = NULL, *the_frag_bat = NULL;
	BUN q, pp, pf, pw;
	int bsp, bsf, bsw, ii = 0;
	size_t cnt, len, sze;
	oid base, wl, wh;
	bit triv_prop, all_hash, all_sort, some_hash, some_sort, all_key, fake_frag = FALSE;
	
	*res = NULL;

	/* check arguments */

	BATcheck(pre, "mvaljoin");
	BATcheck(frag, "mvaljoin");
	BATcheck(ws_item, "mvaljoin");

	len = BATcount(ws_item);
	cnt = BATcount(pre);
	base = pre->hseqbase;
	fake_frag = ((BATcount(frag) == 1) && (frag->hseqbase == oid_nil));
	
	if (fake_frag) {
		ERRORcheck(!BAThdense(pre) || !BAThdense(ws_item), 
			"mvaljoin: input BATs pre & ws_item must have a dense head.\n");
	} else {
		ERRORcheck(!BAThdense(pre) || !BAThdense(frag) || !BAThdense(ws_item), 
			"mvaljoin: all input BATs (pre, frag, ws_item) must have a dense head.\n");
		ERRORcheck(BATcount(frag)!=cnt || frag->hseqbase!=base,
			"mvaljoin: first two input BATs (pre & frag) must be head-aligned.\n");
	}
	ERRORcheck(len==0,
		"mvaljoin: third input BAT (ws_item) must not be empty.\n");

	sze = cnt;
	ii = 0;
	all_hash = all_sort = all_key = TRUE;
	some_hash = some_sort = FALSE;
	
	if (sze == 0) {
		@:mval_res_empty@
	}
	if (fake_frag) {
		oid the_frag_id = *(oid*)BUNtail(frag, BUNfirst(frag));
		len = 1;
		batlist = &the_frag_bat;
		BUNfndVOID(pw, ws_item, &the_frag_id);
		if (pw==NULL) {
			@:mval_res_empty@
		}

		@:mval_init_batlist@
		*res = bn = BATleftjoin(pre, BATmirror(batlist[0]), oid_nil);
		@:mval_free_batlist@
		if (bn == NULL) {
			GDKerror("mvaljoin: BATleftjoin(pre, BATmirror(ws_item["SZFMT"])) failed.\n",
				 the_frag_id);
			return GDK_FAIL;
		}
		return GDK_SUCCEED;

	} else {
		batlist = (BAT**)GDKmalloc(len * sizeof(BAT*));
		if (batlist == NULL) {
			GDKerror("mvaljoin: GDKmalloc(" SZFMT ") failed.\n", len * sizeof(BAT*));
			return GDK_FAIL;
		}
		BATloopFast(ws_item, pw, q, bsw) {
			@:mval_init_batlist@
		}
	}
	if (all_key) {
		sze = cnt;
	}

@= mval_init_batlist
{
		bit hsh, srt;
		bat bid = *(bat*)BUNtloc(ws_item, pw);
		batlist[ii] = BATdescriptor(bid);
		if (!BAThdense(batlist[ii])) {
			GDKerror("mvaljoin: all BATs in the tail of the third input BAT (ws_item) must have a dense head.\n");
			ii++;
			@:mval_free_batlist@
			return GDK_FAIL;
		}
		if (batlist[ii]->ttype != TYPE_oid) {
			GDKerror("mvaljoin: all BATs in the tail of the third input BAT (ws_item) must have tail type OID.\n");
			ii++;
			@:mval_free_batlist@
			return GDK_FAIL;
		}
		hsh = (BAThash(BATmirror(batlist[ii]), 0) != NULL);
		srt = (BATtordered(batlist[ii])&1);
		all_hash &= hsh;
		all_sort &= srt;
		some_hash |= hsh;
		some_sort |= srt;
		all_key &= (batlist[ii]->tkey!=0);
		sze = MAX(sze, BATcount(batlist[ii]));
		ii++;
}	
@
@= mval_res_empty
	sze = 0;
	@:mval_res_create@
	@:mval_res_prop@

	return GDK_SUCCEED;
@
@= mval_res_create
	/* create result BAT */

	bn = BATnew(TYPE_oid, TYPE_oid, sze);
	if (bn == NULL) {
		GDKerror("mvaljoin: BATnew(TYPE_oid, TYPE_oid, " SZFMT ") failed.\n", sze);
		@:mval_free_batlist@
		return GDK_FAIL;
	}
@c
	@:mval_res_create@

	/* do the mvaljoin */

	wl = ws_item->hseqbase;
	wh = wl + len - 1;

	bsp = BUNsize(pre);
	bsf = BUNsize(frag);

	pp = BUNfirst(pre);
	pf = BUNfirst(frag);

@= hash_only
	hash_t h;
	BUN r;
	b = BATmirror(b);
	HASHloop_oid(b, b->hhash, h, &p, r) {
		oidoid_bunfastins(bn,&base,BUNtail(b,r)); /* FIXME: "tvar" (void) vs. "tloc" (oid) */
	}
@= sort_only
	BUN rp, rq;
	int bs;
	SORTloop_oid(b, rp, rq, &p, &p, bs) {
		oidoid_bunfastins(bn,&base,BUNhead(b,rp)); /* FIXME: "hvar" (void) vs. "hloc" (oid) */
	}
@= scan_only
	BUN rp, rq;
	int bs;
	BATloopFast(b, rp, rq, bs) {
		if (p == *(oid*)BUNtail(b,rp)) { /* FIXME: "tvar" (void) vs. "tloc" (oid) */
			oidoid_bunfastins(bn,&base,BUNhead(b,rp)); /* FIXME: "hvar" (void) vs. "hloc" (oid) */
		}
	}
@= hash_scan
	if (b->thash_heap) {
		@:hash_only@
	} else {
		@:scan_only@
	}
@= sort_scan
	if (BATtordered(b)&1) {
		@:sort_only@
	} else {
		@:scan_only@
	}
@= hash_sort_scan
	if (b->thash_heap) {
		@:hash_only@
	} else if (BATtordered(b)&1) {
		@:sort_only@
	} else {
		@:scan_only@
	}
@= mvaljoin
	for (q = BUNlast(pre) ; pp < q ; pp += bsp, pf += bsf) {
		oid p = *(oid*)BUNtail(pre,pp); /* FIXME: "tvar" (void) vs. "tloc" (oid) */
		oid f = *(oid*)BUNtail(frag,pf); /* FIXME: "tvar" (void) vs. "tloc" (oid) */
		if (f >= wl && f <= wh) {
			BAT *b = batlist[f - wl];
			@1
		}
		base++;
	}
@c

	if (all_hash) {
		@:mvaljoin(@:hash_only@)@
	} else if (all_sort) {
		@:mvaljoin(@:sort_only@)@
	} else if (some_hash && some_sort) {
		@:mvaljoin(@:hash_sort_scan@)@
	} else if (some_hash) {
		@:mvaljoin(@:hash_scan@)@
	} else if (some_sort) {
		@:mvaljoin(@:sort_scan@)@
	} else {
		@:mvaljoin(@:scan_only@)@
	}

@= mval_res_prop
	/* set result properties */

	if (!bn->batDirty) bn->batDirty = TRUE;
	triv_prop = (BATcount(bn) < 2);
	BATkey(bn,all_key);
	BATkey(BATmirror(bn),triv_prop);
	bn->hsorted = GDK_SORTED;
	bn->tsorted = triv_prop;
	bn->hdense = triv_prop;
	bn->tdense = triv_prop;
	if (BATcount(bn) == 0) {
		BATseqbase(bn, (oid)0);
		BATseqbase(BATmirror(bn), (oid)0);
	} else if (BATcount(bn) == 1) {
		BATseqbase(bn, *(oid*)BUNhloc(bn,BUNfirst(bn)));
		BATseqbase(BATmirror(bn), *(oid*)BUNtloc(bn,BUNfirst(bn)));
	}

	*res = bn;
@c
	@:mval_res_prop@
	@:mval_free_batlist@

	return GDK_SUCCEED;
bunins_failed:
	GDKerror("mvaljoin: bunins failed.\n");
	BBPreclaim(bn);
@= mval_free_batlist
	while (ii > 0) {
		BBPunfix(batlist[--ii]->batCacheid);
	}
	if (batlist && !fake_frag) {
		GDKfree(batlist);
	}
@c
	@:mval_free_batlist@
	return GDK_FAIL;
}
