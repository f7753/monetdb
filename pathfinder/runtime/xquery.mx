# Copyright Notice:
# -----------------
# 
# The contents of this file are subject to the MonetDB Public
# License Version 1.0 (the "License"); you may not use this file
# except in compliance with the License. You may obtain a copy of
# the License at http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
# 
# Software distributed under the License is distributed on an "AS
# IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
# implied. See the License for the specific language governing
# rights and limitations under the License.
# 
# The Original Code is the ``Pathfinder'' system. The Initial
# Developer of the Original Code is the Database & Information
# Systems Group at the University of Konstanz, Germany. Portions
# created by U Konstanz are Copyright (C) 2000-2004 University
# of Konstanz. All Rights Reserved.
#
# Contributors:
#         Torsten Grust <torsten.grust@uni-konstanz.de>
#         Maurice van Keulen <M.van.Keulen@bigfoot.com>
#         Jens Teubner <jens.teubner@uni-konstanz.de>
#         Jan Flokstra <flokstra@cs.utwente.nl>
#
# $Id$

@f xquery
@a Jan Flokstra
@t xquery

@c

/*******************************************
* xquery.c : xquery command stuff
*
* TODO:
* - Decide how to generate output for query results. I propose that we
*   generate output in three different modes:
*   1) "xml", generate the xml output data as we do now.
*   2) "sax", generate the Sax-O-Phone SAX event stream as we do now
*   3) "?galax?", generate exactly the same output as GALAX
*/

#include <gdk.h>
#include <monet.h>

#include <setjmp.h>

#include "pathfinder.h"

#include "compile_interface.h"
 
static bit is_fake_project (BAT* b)
{
	BATcheck(b, "is_fake_project");
	if ((BATcount(b)==1) && (b->hseqbase==oid_nil)) {
		return TRUE;
	} else {
		return FALSE;
	}
}

#define MAXTAGDEPTH        1024

#define WS_BATS     19

/**
 *
 * 0. SMALL UTILITY SECTION
 *
 * Here a structure is defined to prevent too much alloc/free actions.
 * If the size of a string is smaller then SMART_STR_SZ the value is
 * stored in stack_buff[] within the structure. Otherwise it is strdupped and
 * freed like usual.
 */


#define SMART_STR_SZ    32

typedef struct {
        char stack_buff[SMART_STR_SZ];
        str  val;
} SmartStrBuff;

static str ssb_alloc(SmartStrBuff* ssb, str s) {
        if ( s ) {
                size_t l = strlen(s)+1;

                if ( l <= SMART_STR_SZ )
                        return ssb->val = memcpy(&ssb->stack_buff,s,l);
                else
                        return ssb->val = strdup(s);
        } else
                return ssb->val = NULL;
}

static void ssb_free(SmartStrBuff* ssb) {
        if ( ssb->val && (ssb->val != (str)&ssb->stack_buff) ) {
                free( ssb->val );
        }
        ssb->val = NULL;
}

/**
 *
 * I. THE CONTEXT NODE DEFINITION AND USAGE PART
 *
 * This structure contains the context of the print session.
 * It has several functions. But its main use is the administration 
 * of all BATs containing the XML documents.
 *
 */

typedef struct {
        int     dmMode;         /* Data model flag, true if printing in
                                 * data-model mode, eg. look like GALAX */
        int     saxMode;        /* true if printing a Sax-O-Phone stream */
        BAT*    ws;             /* working set BAT */
        int     curFRAG;        /* current fragment used by working set */
        BAT*    curBAT[WS_BATS];/* The BAT's of the current fragment*/
        /* */
        /**
         * Next elements is a stack used during printing to store the 
         * pre-value, name, namespace of the nodes currently being printed. 
         */
        int     stackPtr;    
        struct {
                oid             pre;
                SmartStrBuff    ssb_ns;
                SmartStrBuff    ssb_name;
        } tagStack[MAXTAGDEPTH];
        /* */
        int     nAttrOnLine; /* used by top result print routine to count the
                              * number of top-level result items printed on
                              * the current line.
                              */
        jmp_buf exitPoint;   /* point to jump to after error */
} XqueryCtx;

/** 
 * The error handler which finishes the execution of the print with a 
 * longjmp() to the end.
 */
static void fatal_err(XqueryCtx* ctx, const char *msg, ...) {
    va_list msgs;
    char    errmsg[1024];
        
    va_start (msgs, msg);
    vsnprintf (errmsg, 1024, msg, msgs);
    va_end (msgs);
    /* */
    stream_printf(GDKerr,"!ERROR: XML Generation: %s\n",errmsg);
    /* */
    longjmp(ctx->exitPoint,1);
}


/**
 * Functions fills a new context() record with mode and BAT data and
 * initializes all other data structures.
 */

static BAT* fetchWsContextBAT(XqueryCtx* ctx, BAT* ws, int batID, int wsID) {
        BUN bun;

        if ( !(bun = BUNfnd(ws,&batID)) )
              fatal_err(ctx,"fetchWsContextBAT: NOT FOUND BAT[%d]",batID);

        BAT* batbat;
        
        if ( !( batbat = BATdescriptor(*(bat*)bun)) )
                fatal_err(ctx,"fetchWsContextBAT:FETCH BATBAT for WS[%d][%d] FAILED\n",batID ,wsID);

        BUN bbun = BUNfnd(batbat,&wsID);
        BAT *res = NULL;
        if ( !bbun )
                fatal_err(ctx,"fetchWsContextBAT:NOT FOUND BAT[%d][%d] in WS!!!!\n",batID,wsID);
        else {
                if ( !(res = BATdescriptor(*(bat*)bbun)) )
                         fatal_err(ctx,"fetchWsContextBAT:FETCH WS[%d][%d] FAILED\n",batID,wsID);
        }
        BBPunfix( BBPcacheid( batbat ) );
        return res;
}

/**
 * The wsBAT() function is responsible for 'demand-loading' the BAT with index
 * 'batId in the current working set. No BAT is loaded until it is needed. This
 * solves some funny problems with loading BAT's which were not needed
 * anyway.
 */
static BAT* wsBAT(XqueryCtx* ctx, int batId) {
        if ( !ctx->curBAT[batId] ) { 
                if ( !( ctx->curBAT[batId] = 
                        fetchWsContextBAT(ctx,ctx->ws,batId,ctx->curFRAG)) )
                        fatal_err(ctx,"unable to load wsBAT[%d]",batId);
        }
        return ctx->curBAT[batId];
}

static void switchWsContext(XqueryCtx* ctx, int wsID) {
        if ( ctx->curFRAG != wsID ) {
                int i;

                if ( ctx->curFRAG >= 0 ) {
                        /* close the old open context BAT's */
                        for(i=0; i<WS_BATS; i++) {
                                if ( ctx->curBAT[i] ) {
                                        BBPunfix( BBPcacheid(ctx->curBAT[i]));
                                        ctx->curBAT[i] = NULL;
                                }
                        }
                }
                ctx->curFRAG   = wsID;
        }
}

static void createWsContext(XqueryCtx* ctx, BAT* ws, int wsID, str mode) {
        int i;

        if ( strcmp(mode,"sax")==0 ) {
            ctx->saxMode = 1;
        } else {
            ctx->saxMode = 0;
            if ( strcmp(mode,"dm")==0 )
                ctx->dmMode = 1;
            else
                ctx->dmMode = 0;
        }
        ctx->ws        = ws;
        ctx->curFRAG   = -1; /* empty, no frag loaded */
        /* initialize with all wsBAT()'s closed */
        for(i=0; i<WS_BATS; i++) {
                ctx->curBAT[i] = NULL;
        }
        /* */
        if ( wsID >= 0 )
                switchWsContext(ctx, wsID);
        /* */
        ctx->stackPtr  = 0;
}

/**
 * Return if there are still nodes on stack.
 */
static int moreTags(XqueryCtx* ctx) {
        return (ctx->stackPtr > 0);
}

/**
 * Push the pre-value, namespace and nodename of stack
 */
static void pushTag(XqueryCtx* ctx, oid pre, str ns, str name) {
        ctx->tagStack[ctx->stackPtr].pre  = pre;
        ssb_alloc(&ctx->tagStack[ctx->stackPtr].ssb_ns,   ns);
        ssb_alloc(&ctx->tagStack[ctx->stackPtr].ssb_name, name);
        ctx->stackPtr++;
}

/**
 * Three function to retrieve the pre-value, namespace or nodename of the
 * top element on the stack.
 */
static oid topTag(XqueryCtx* ctx)  {return ctx->tagStack[ctx->stackPtr-1].pre;}
static str topNs(XqueryCtx* ctx)   {return ctx->tagStack[ctx->stackPtr-1].ssb_ns.val;}
static str topName(XqueryCtx* ctx) {return ctx->tagStack[ctx->stackPtr-1].ssb_name.val;}


/**
 * Pop the top element of the stack. Means that processing the node has
 * finished.
 */
static void popTag(XqueryCtx* ctx) {
        /* de-alloc the ns and name strings */
        ssb_free(&ctx->tagStack[ctx->stackPtr-1].ssb_ns);
        ssb_free(&ctx->tagStack[ctx->stackPtr-1].ssb_name);
        --ctx->stackPtr;
}

/**
 *
 * II. THE OUTPUT HANDLER PART 
 *
 * The emit functions are used to encapsulate the Sax-O-Phone event
 * emission functions.
 * The current implementation emits the Sax-O-Phone events as if they are
 * a BAT.
 *
 * TODO: solve characters() newline in string problem. 
 *
 */

static void emit_start() {
        stream_printf(GDKout,"#-------------------------#\n");
        stream_printf(GDKout,"# h     SAXtape           #\n");
        stream_printf(GDKout,"# str   str               #\n");
        stream_printf(GDKout,"#-------------------------#\n");
}

/**
 *
 * The character translation section responsible for the special character
 * recognition and XML entity characters. It consists of a small main table
 * 'isspecial_tab' containing the flags for every possible character.
 * v=0: no special char
 * v=1: special char, should be presented as octal char in output
 * v>1: special char, string repr of char is isspecial_val[v]
 * isspecial_cnt has 2 purposes. 1) variabe use dfilling the tables and
 * 2) as boolean flag to indicate if tables are initialized yet 
 */

static unsigned char  isspecial_tab[CHAR_MAX]; /* the main table */
static char*          isspecial_val[16]; /* the values of the special chars */
static int            isspecial_cnt = 0; /* 0 = tables are not initialized */

static void init_isspecial() {
        int i;

        for(i=0; i<CHAR_MAX; i++)
                isspecial_tab[i] = 0;
        for(i=0; i<32; i++)
                isspecial_tab[i] = 1; /* means write as octal */
        isspecial_tab[(int)'\377'] = 1; /* means write as octal */
        isspecial_val[0] = "[*ERROR*]"; /* not used, 0 = no special meaning */
        isspecial_val[1] = "[*ERROR*]"; /* not used, 1 = write as octal */
        isspecial_cnt    = 2;
        isspecial_tab[(int)'\t']       = isspecial_cnt;
        isspecial_val[isspecial_cnt++] = "\\t";
        isspecial_tab[(int)'\n']       = isspecial_cnt;
        isspecial_val[isspecial_cnt++] = "\\n";
        isspecial_tab[(int)'\\']       = isspecial_cnt;
        isspecial_val[isspecial_cnt++] = "\\\\";
        isspecial_tab[(int)'\"']       = isspecial_cnt;
        isspecial_val[isspecial_cnt++] = "&quot;";
        isspecial_tab[(int)'\'']       = isspecial_cnt;
        isspecial_val[isspecial_cnt++] = "&apos;";
        isspecial_tab[(int)'&']       = isspecial_cnt;
        isspecial_val[isspecial_cnt++] = "&amp;";
        isspecial_tab[(int)'<']       = isspecial_cnt;
        isspecial_val[isspecial_cnt++] = "&lt;";
        isspecial_tab[(int)'>']       = isspecial_cnt;
        isspecial_val[isspecial_cnt++] = "&gt;";
}

/*
 * This function is responsible for the presentation of special characters
 * and XML entity characters in the result.
 */
static void emit_escaped(char* src) {
        /* Emit a string with all special character escaped. Inspired by
         * function strToStr() in gdk_atoms.mx
         */
        int start=0,end;
        unsigned char isspecial_ch;

        if ( !isspecial_cnt ) /* module not initialized yet */
                init_isspecial();
        for(end=0; src[end]; end++) {
            if ( (isspecial_ch = isspecial_tab[(int)src[end]]) ) {
                stream_write(GDKout,&src[start],end-start,1); /*flush */
                start = end+1;

                if ( isspecial_ch == 1 ) {
                   stream_printf(GDKout,"\\%03o",(unsigned char)src[end]);
                   stream_flush(GDKout);
                } else {
                   char *emit_val = isspecial_val[(int)isspecial_ch];
                   stream_write(GDKout,emit_val,strlen(emit_val),1);
                }
            }
        }
        if ( start < end ) {
                stream_flush(GDKout);
                stream_write(GDKout,&src[start],end-start,1); /* flush */
        }
}

static void emit(char* eventName, char* val, int escaped) {
        if ( val ) {
                if ( escaped ) {
                        stream_printf(GDKout,"[\"%s\",\t\"",eventName);
                        emit_escaped(val);
                        stream_printf(GDKout,"\"]\n");
                } else {
                        stream_printf(GDKout,"[\"%s\",\t\"%s\"]\n",eventName,val);
                }
        } else
                stream_printf(GDKout,"[\"%s\",\tnil]\n",eventName);
}

static void emit_end() {
}

/*
 *
 * The output handlers. Responslibe for generating the output representing
 * the handles xml structure. Cuurently 3 output structures are used:
 *
 * 1) plain xml text (ctx->saxMode is false)
 * 2) xml Sax-O-Phone stream (ctx->saxMode is true AND SAXOPHONE=1 )
 * 3) My own SAX event stream (ctx->saxMode is true AND SAXOPHONE=0 )
 *
 */

/* The SAXOPHONE define is a temporary flag used by JF to compile 'in'
 * his own Sax-O-Phone version which he thinks is much more efficient
 * than the original (but not as fancy) of course.
 */
#define SAXOPHONE 1

/**
 * Output generation handler. Handles equivalent of * SAX startDocument() event.
 */
static void handle_startDocument(XqueryCtx* ctx) {
        if (ctx->saxMode ) {
                if ( SAXOPHONE ) {
                        emit_start();
                } else
                        stream_printf(GDKout,"<S\n");
        } else { /* xmlMode */
                stream_printf(GDKout,"<?xml version=\"1.0\" encoding=\"utf-8\"?>\n");
        }
}

/**
 * Output generation handler. Handles equivalent of * SAX endDocument() event.
 */
static void handle_endDocument(XqueryCtx* ctx) {
        if (ctx->saxMode ) {
                if ( SAXOPHONE ) {
                        emit_end();
                } else 
                        stream_printf(GDKout,"<E\n");
        } else { /* xmlMode */
                stream_printf(GDKout,"\n\n");
        }
}

/**
 * Output generation handler. This one of my own invented event describing
 * the usage of an attribute. A sequence of these events will be ended
 * by a handle_attributeEnd() call.
 */
static void handle_attribute(XqueryCtx* ctx, str ns, str name, str value) {
        if (ctx->saxMode ) {
                if ( SAXOPHONE ) {
                        emit(" attribute",name,0);
                        if ( ns && (strlen(ns)>0) )
                                emit(" attribute prefix",ns,0);
                        emit(" attribute value",value,0);
                } else {
                        stream_printf(GDKout,"<A %s=\"%s\"\n",name,value);
                }
        } else { /* xmlMode */
                if ( ns && strlen(ns)>0 ) {
                        stream_printf(GDKout," %s:%s=\"%s\"",ns,name,value);
                } else {
                        stream_printf(GDKout," %s=\"%s\"",name,value);
                }
        }
}

/**
 * Output generation handler. This one of my own invented event indicating
 * there will be no more attribute events for this node.
 */
static void handle_attributeEnd(XqueryCtx* ctx) {
        if (ctx->saxMode ) {
        } else { /* xmlMode */
                stream_printf(GDKout,">");
        }

}

/**
 * Output generation handler. Handles equivalent of * SAX startElement() event.
 */
static void handle_startElement(XqueryCtx* ctx, str ns, str name /*,str *atts*/) {
        if (ctx->saxMode ) {
                if ( SAXOPHONE ) {
                        emit("startElement",NULL,0);
                        if ( ns && (strlen(ns)>0) )
                                emit(" prefix",ns,0);
                        emit(" localname",name,0);
                } else {
                        stream_printf(GDKout,"<s %s\n",name);
                }
        } else { /* xmlMode */
                if ( ns && strlen(ns)>0 ) {
                        stream_printf(GDKout,"<%s:%s",ns,name);
                } else {
                        stream_printf(GDKout,"<%s",name);
                }
        }
}

/**
 * Output generation handler. Handles equivalent of * SAX endElement() event.
 */
static void handle_endElement(XqueryCtx* ctx, str ns, str name) {
        if (ctx->saxMode ) {
                if ( SAXOPHONE ) {
                        emit("endElement",NULL,0);
                        if ( ns && (strlen(ns)>0) )
                                emit(" prefix",ns,0);
                        emit(" localname",name,0);
                } else {
                        stream_printf(GDKout,"<e %s\n",name);
                }
        } else { /* xmlMode */
                if ( ns && strlen(ns)>0 ) {
                        stream_printf(GDKout,"</%s:%s>",ns,name);
                } else {
                        stream_printf(GDKout,"</%s>",name);
                }
        }
}

/**
 * Output generation handler. One on my own again. This one should handle a
 * reference. Don't know wat to to about it now.
 */
static void handle_reference(XqueryCtx* ctx, str name) {
        if (ctx && name) {};
}

/**
 * Output generation handler. Handles equivalent of * SAX characters() event.
 */
static void handle_characters(XqueryCtx* ctx, str ch) {
        if (ctx->saxMode ) {
                if ( SAXOPHONE ) {
                        emit("characters",NULL,0);
                        emit(" pcdata",ch,1);
                } else {
                        stream_printf(GDKout,"%s\n",ch);
                }
        } else { /* xmlMode */
                stream_printf(GDKout,"%s",ch);
        }
}

/**
 * Output generation handler. Handles equivalent of * SAX ignorableWhitespace()
 * event. I see no reason why it should be used here but I include it for
 * completeness.
 */
static void handle_ignorableWhitespace(XqueryCtx* ctx, str ch) {
        handle_characters(ctx,ch); /* dispatch */
}

/**
 * Output generation handler. Again an own event. But this one should be
 * used I think because the comments are used and stored by  Pathfinder.
 */
static void handle_comment(XqueryCtx* ctx, str comm) {
        if (ctx->saxMode ) {
                /* incomplete */
        } else { /* xmlMode */
                stream_printf(GDKout,"<!--%s-->",comm);
        }
}

/**
 * Output generation handler. Handles equivalent of * SAX processingInstruction() event.
 */
static void handle_processingInstruction(XqueryCtx* ctx, str target, str data) {
        if (ctx->saxMode ) {
                /* incomplete */
        } else { /* xmlMode */
                stream_printf(GDKout,"<?%s %s?>",target,data);
        }
}

/**
 * Utility function. It reads the tail value of an element in a 
 * [void,any] BAT indexed by oid_index. 
 */
static ptr idxTV(XqueryCtx* ctx, str name, BAT* b, oid oid_index) {
        ptr res;

        if ( !b )
                fatal_err(ctx,"NIL BAT[\"%s\"]\n",name);
        if (is_fake_project(b)) {
        	res = BUNtail(b,BUNfirst(b));
        } else if ( BUNsize(b) == 1 ) {
                /* There is a probably bug in monet. The else code should work */
                /* for all situations but does not work for all BAT[void,chr] */
                /* arguments. At the moment some do and some don't. */
                /* I reported this bug once and then I could not reproduce */
                /* the failure. But it still fails for the 'kind' BAT in */
                /* the xquery_result_main() function */
                BUN bun = BUNfirst(b);
                res = &bun[oid_index];
        } else {
                oid real_index = oid_index + 1; /*this one cost me 2 hrs */

                BUN bun = BUNptr(b,real_index);
                res = BUNtail(b,bun);
        }
        if ( ! res )
                fatal_err(ctx,"idxTV: BAT[%s][%d], NULL (ptr) result",name,oid_index);
        return res;
}

/**
 * Reads the index tailvalue in a Working Set BAT
 */

static ptr idxTVinWS(XqueryCtx* ctx, int batId, oid oid_index) {
        BAT* b = wsBAT(ctx, batId);

        return idxTV(ctx,"tmp",b,oid_index);
}

/**
 * Reads the index tailvalue in a Working Set BAT or when fragId is not the
 * current working set it reads in the BAT outside the working set.
 */
static ptr idxTVinWSorFRGN(XqueryCtx* ctx, int fragId, int batId, oid oid_index) {
        if ( ctx->curFRAG == fragId ) 
                return idxTVinWS(ctx,batId,oid_index);
        else {
                BAT* b = fetchWsContextBAT(ctx,ctx->ws,batId,fragId);

                ptr res = idxTV(ctx,"tmp",b,oid_index);
                BBPunfix( BBPcacheid( b ) );
                return res;
        }
}

/**
 * Handle the generation of the attributes of the node with oid 'pre'. This
 * function is only called from the xquery_node_print() function.
 */
static int query_attr_print(XqueryCtx* ctx, oid pre) {
        BAT *b;

        if ( !(b  = BATuselect(wsBAT(ctx,ATTR_OWN),&pre,&pre)) )
                fatal_err(ctx,"query_attr_print: uselect fails\n");
        BUN p, q; 
        BATloop(b, p, q) {
                oid id = *(oid*)BUNhead(b, p);
                /* */
                oid poid = *(oid*)idxTVinWS(ctx,ATTR_PROP,id);
                int frag = *(oid*)idxTVinWS(ctx,ATTR_FRAG,id);
                str val  = (str)idxTVinWSorFRGN(ctx,frag,PROP_VAL,poid);
                /* */
                oid qoid = *(oid*)idxTVinWS(ctx,ATTR_QN,id);
                str ns   = (str)idxTVinWSorFRGN(ctx,frag,QN_NS,qoid);
                str name = (str)idxTVinWSorFRGN(ctx,frag,QN_LOC,qoid);
                /* */

                handle_attribute(ctx,ns,name,val);
        }
        handle_attributeEnd(ctx);
        BBPunfix( BBPcacheid( b ) );
        return 1;
}

/**
 * Handle the generation of the node with oid 'pre'.
 */
static void xquery_node_print(XqueryCtx* ctx, oid pre, BAT* pre_frag) {
        chr kind = *(chr*)idxTVinWS(ctx,PRE_KIND,pre);
        oid prop = *(oid*)idxTVinWS(ctx,PRE_PROP,pre);

        int valueFRAG = ctx->curFRAG;
        if ( pre_frag )
                valueFRAG = *(int*)idxTVinWS(ctx,PRE_FRAG,pre);
        switch( kind ) {
                case (char)0: {/* ELEMENT */
                        str name = (str)idxTVinWSorFRGN(ctx,valueFRAG,QN_LOC,prop);
                        str ns   = (str)idxTVinWSorFRGN(ctx,valueFRAG,QN_NS,prop);
                        handle_startElement(ctx,ns,name);
                        query_attr_print(ctx,pre);
                        oid size = *(oid*)idxTVinWS(ctx,PRE_SIZE,pre);
                        pushTag(ctx,pre+size,ns,name);
                        break;
                        }
                case (char)1: {/* TEXT */
                        handle_characters(ctx,(str)idxTVinWSorFRGN(ctx,valueFRAG,PROP_TEXT,prop));
                        break;
                        }
                case (char)2: {/* COMMENT */
                        handle_comment(ctx,(str)idxTVinWSorFRGN(ctx,valueFRAG,PROP_COM,prop));
                        break;
                        }
                case (char)3: {/* PI */
                        str target = (str)idxTVinWSorFRGN(ctx,valueFRAG,PROP_TGT,prop);
                        str data   = (str)idxTVinWSorFRGN(ctx,valueFRAG,PROP_INS,prop);
                        handle_processingInstruction(ctx,target,data);
                        break;
                        }
                case (char)4: {/* DOCUMENT */
                        /* The node represents an entire document */
                        oid offset = *(oid*)idxTVinWS(ctx,PRE_SIZE,pre);
                        pushTag(ctx,pre+offset,"","");
                        break;
                        }
                default:
                        fatal_err(ctx,"Unknow kind IN xquery_node_print");
        }
}

#define ALLTAGS INT_MAX

/**
 * handle the closing tag of a document.
 */
static void xquery_endtag_print(XqueryCtx* ctx, oid pre) {
        while( moreTags(ctx) && ((pre==ALLTAGS)||(pre > topTag(ctx))) ) { /*?? */
                if ( strlen(topName(ctx)) > 0 )
                        handle_endElement(ctx,topNs(ctx),topName(ctx));
                popTag(ctx);
        }
}

/**
 * handle the range of pre numbers [from .. to]
 */
static void xquery_pre_range(XqueryCtx* ctx, BAT* b, oid from, oid to) {
        BUN p, q; 
        if ( from == 0 ) /* first BUN, because of 1..n/0..n-1 problem */
                p = BUNfirst(b);
        else
                BUNfndOID(p, b,&from);
        for(q = BUNlast(b); p<q; p = BUNnext(b, p)) {
                oid pre = *(oid*)BUNhead(b, p);
                do {
                        xquery_node_print(ctx, pre, 0 /* pre_frag */);
                        xquery_endtag_print(ctx,++pre);
                } while( moreTags(ctx) && (pre<to) );
        }
        if ( moreTags(ctx) ) {
                /* INCOMPLETE, the next line works but WHY? Should work without */
                xquery_endtag_print(ctx,ALLTAGS);
        }
}

static void MY_xquery_pre_range(XqueryCtx* ctx, oid from, oid to, BAT* pre_frag) {
        oid pre = from;

        do {
                xquery_node_print(ctx, pre,pre_frag);
                xquery_endtag_print(ctx,++pre);
        } while( moreTags(ctx) && (pre<=to) );
}

/**
 *
 * X. THE MAIN XML DOCUMENT PRINTING PART
 *
 * Main XML document printing routine
 */

static int ws_documentIndex(BAT* ws, str docName) {
        int doc_loaded_idx = DOC_LOADED;

        BUN b = BUNfnd(ws,&doc_loaded_idx);
        /*
         * if ( !b )
         *       stream_printf(GDKxxx,"NOT FOUND DOCBAT!!!!\n");
         */
        BAT* doc_loaded = BATdescriptor(*(bat*)b);

        BUN p, q; 
        BATloop(doc_loaded, p, q) {
                oid docId = *(oid*)BUNhead(doc_loaded, p);
                str docNm = (str)BUNtail(doc_loaded, p);

                if ( strcmp(docName,docNm) == 0 ) {
                        BBPunfix( BBPcacheid( doc_loaded ) );
                        return docId;
                }
        }
        BBPunfix( BBPcacheid( doc_loaded ) );
        return -1;
}

int xquery_print_doc_main(str mode, BAT* ws, str docName) {
        int docIndex = ws_documentIndex(ws,docName);
        if ( docIndex < 0 ) {
                stream_printf(GDKerr,"# unable to find document \"%s\" in working set!\n",docName);
                return GDK_SUCCEED;
        }
        /* */
        XqueryCtx  ctx_struct, *ctx = &ctx_struct;
        createWsContext(ctx,ws,docIndex,mode);
        /* */
        /* now set the exit point in case of an error */
        if ( setjmp(ctx_struct.exitPoint) != 0 ) {
                return GDK_FAIL;
        }
        /* */
        handle_startDocument(ctx);
        xquery_pre_range(ctx,wsBAT(ctx,PRE_SIZE),0/*start*/,1 /* first is doc ? */);
        handle_endDocument(ctx);
        switchWsContext(ctx,-1); /* close all open context BAT's */
        /* */
        return GDK_SUCCEED;
}

/**
 * XI. THE MAIN PATHFINDER QUERY RESULT PART
 *
 * First the event/emit handlers for the sequnce are defined and after that
 * the main function
 */

#define XQRESTAG        "XQueryResult"

/**
 * Handle the start() of an XQUERY/Pathfinder result sequence
 */
static void  seqStart(XqueryCtx* ctx) {
        if ( ctx->saxMode ) {
                handle_startElement(ctx,NULL,XQRESTAG);
        } else if ( ctx->dmMode ) {
                stream_printf(GDKout,"INCOMPLETE, dmMode-seqStart here\n");
        } else {
                stream_printf(GDKout,"<?xml version=\"1.0\" encoding=\"utf-8\"?>\n");
                stream_printf(GDKout,"<%s>\n",XQRESTAG);
                ctx->nAttrOnLine = 0;
        }
}

/**
 * Handle the end() of an XQUERY/Pathfinder result sequence
 */
static void  seqEnd(XqueryCtx* ctx) {
        if ( ctx->saxMode ) {
                handle_endElement(ctx,NULL,XQRESTAG);
        } else if ( ctx->dmMode ) {
                stream_printf(GDKout,"INCOMPLETE, dmMode-seqEnd here\n");
        } else {
                stream_printf(GDKout,"\n");
                stream_printf(GDKout,"</%s>\n",XQRESTAG);
        }
}


/**
 * Emit a NODE element of an XQUERY/Pathfinder result sequence
 */
static void  seqEmitNode(XqueryCtx* ctx, oid preVal, BAT* pre_frag) {
        /* incomplete, different for dmMode ?? */
        int size = *(int*)idxTVinWS(ctx,PRE_SIZE,preVal);
        MY_xquery_pre_range(ctx,preVal,preVal+size, pre_frag);
}

/**
 * Emit a Boolean element of an XQUERY/Pathfinder result sequence
 */
static void  seqEmitBool(XqueryCtx* ctx, int bv) {
        char *bool_str = (char*)(bv?"true":"false");

        if ( ctx->saxMode ) {
                handle_characters(ctx,bool_str);
        } else if ( ctx->dmMode ) {
                stream_printf(GDKout,"%s() ",bool_str);
        } else {
                ctx->nAttrOnLine++;
                stream_printf(GDKout,"%s ",bool_str);
        }
}

/**
 * Emit a Integer element of an XQUERY/Pathfinder result sequence
 */
static void  seqEmitInt(XqueryCtx* ctx, int iv) {
        if ( ctx->saxMode ) {
                char buff[32];

                sprintf(buff,"%d",iv);
                handle_characters(ctx,buff);
        } else if ( ctx->dmMode ) {
                stream_printf(GDKout,"INCOMPLETE, dmMode-seqEmitInt here\n");
        } else {
                ctx->nAttrOnLine++;
                stream_printf(GDKout,"%d ",iv);
        }
}

/**
 * Emit a Double element of an XQUERY/Pathfinder result sequence
 */
static void  seqEmitDbl(XqueryCtx* ctx, dbl dv) {
        if ( ctx->saxMode ) {
                char buff[32];

                sprintf(buff,"%f",dv);
                handle_characters(ctx,buff);
        } else if ( ctx->dmMode ) {
                stream_printf(GDKout,"INCOMPLETE, dmMode-seqEmitDbl here\n");
        } else {
                ctx->nAttrOnLine++;
                stream_printf(GDKout,"%f ",dv);
        }
}

/**
 * Emit a String element of an XQUERY/Pathfinder result sequence
 */
static void  seqEmitStr(XqueryCtx* ctx, str sv) {
        if ( ctx->saxMode ) {
                handle_characters(ctx,sv);
        } else if ( ctx->dmMode ) {
                stream_printf(GDKout,"INCOMPLETE, dmMode-seqEmitStr here\n");
        } else {
                ctx->nAttrOnLine++;
                /* stream_printf(GDKout,"\"%s\" ",sv); */
                stream_printf(GDKout,"\"");
                emit_escaped( sv );
                stream_printf(GDKout,"\" ");
        }
}

/**
 * Main XQUERY/Pathfinder result sequence printing routine. Arguments are
 * mode: "xml" or "sax"
 * ws : the working set
 * item/kind : sequence result BATs
 * intVAL,dblVAL,decVAL,strVAL : BATSs containing the values of seq elements
 * remainder BATs: conatins the data for the document nodes
 *
 * The function iterates through the item/kind BAT's and retrieves the values
 * from the xxxVAL BATs. Then it calls one of the seqXXXXX() functions
 * defined above to handle the output generation.
 */

/*
 * BAT format definitions. These must be equal to the definitions
 * in pathfinder.mx
 */

#define XTRACT_KIND(X)  (X & 63)
#define XTRACT_FRAG(X)  (X >> 6)

#define QNAME 2
#define BOOL  3
#define INT   4
#define DEC   5
#define DBL   6
#define STR   7
#define NODE  32
#define ELEM  33
#define ATTR  34

#define DEBUG_BAT       0

int xquery_print_result_main(
                str  mode,
                BAT* ws,
                BAT* item,
                BAT* kind,
                BAT* intVAL,
                BAT* dblVAL,
                BAT* decVAL,
                BAT* strVAL
        ) {
        XqueryCtx  ctx_struct, *ctx = &ctx_struct;
        createWsContext(ctx,ws,-1,mode);
        /* */
        /* now set the exit point in case of an error */
        if ( setjmp(ctx_struct.exitPoint) != 0 ) {
                return GDK_FAIL;
        }
        if ( DEBUG_BAT ) {
                stream_printf(GDKout,"# RAW XQUERY RESULT:\n");
                stream_printf(GDKout,"# pre\tkind\tvaloid\tval\n");
                stream_printf(GDKout,"# ---\t----\t------\t---\n");
        }
        /* */
        seqStart(ctx);
        /* */
        BUN p, q; 
        BATloop(item, p, q) {
                oid pre = *(oid*)BUNhead(item, p);
                oid valoid = *(oid*)BUNtail(item, p);
                int cmbn_frag_kind = *(int*)idxTV(ctx,"kind",kind,pre);
                if ( DEBUG_BAT )
                        stream_printf(GDKout,"## pre=%d\tcbn=%d\tkind=%d\tv_oid=%d\t",pre,cmbn_frag_kind,XTRACT_KIND(cmbn_frag_kind),valoid);
                switch( XTRACT_KIND(cmbn_frag_kind) ) {
                 case ATTR: {
                        stream_printf(GDKout,"<!--attr-not-impl-yet-->\n");
                        break;
                        };
                 case ELEM: {
                        int frag = XTRACT_FRAG(cmbn_frag_kind);
                        if (DEBUG_BAT) stream_printf(GDKout,"ELEM(frag=%d,v_oid=%d)\n",frag, valoid);
                        /* if ( ctx->dmMode ),check for first kind text { "t" } 
                         * check idxTVinWSorFRGN(ctx,frag,PRE_KIND,valoid);
                         * for TEXT
                         */
                        switchWsContext(ctx,frag);
                        seqEmitNode(ctx, valoid, wsBAT(ctx,PRE_FRAG));
                        break;
                        };
                 case NODE: {
                        /* incomplete, suppose just ignore ?*/
                        break;
                        };
                 case BOOL: {
                        if (DEBUG_BAT) stream_printf(GDKout,"%s\n",(valoid?"true":"false"));
                        seqEmitBool(ctx,valoid);
                        break;
                        }
                 case DBL: {
                        dbl dv = *(dbl*)idxTV(ctx,"dblVAL",dblVAL,valoid);
                        if (DEBUG_BAT) stream_printf(GDKout,"%f\n",dv);
                        seqEmitDbl(ctx,dv); /* INCOMPLETE ?diff between d and e */
                        break;
                        }
                 case DEC: {
                        dbl dv = *(dbl*)idxTV(ctx,"decCVAL",decVAL,valoid);
                        if (DEBUG_BAT) stream_printf(GDKout,"%f\n",dv);
                        seqEmitDbl(ctx,dv); /* INCOMPLETE ?diff between d and e */
                        break;
                        }
                 case INT: {
                        int iv = *(int*)idxTV(ctx,"intVAL",intVAL,valoid);
                        if (DEBUG_BAT) stream_printf(GDKout,"%d\n",iv);
                        seqEmitInt(ctx,iv);
                        break;
                        }
                 case STR: {
                        str sv = (str)idxTV(ctx,"strVAL",strVAL,valoid);
                        if (DEBUG_BAT) stream_printf(GDKout,"\"%s\"\n",sv);
                        seqEmitStr(ctx,sv);
                        break;
                        }
                 default:
                        stream_printf(GDKerr,"[kind=%d, frag=%d]\n",XTRACT_KIND(cmbn_frag_kind),XTRACT_FRAG(cmbn_frag_kind));
                        fatal_err(ctx,"UNKNOW_TYPE(\'%c\'ch(%d))\n",cmbn_frag_kind,cmbn_frag_kind);
                }
        }
        /* */
        seqEnd(ctx);
        /* */
        switchWsContext(ctx,-1); /* close all open context BAT's */
        /* */
        return GDK_SUCCEED;
}

static FILE *string2FILE(char* s) {
        /* hoped fmemopen() would work, but it did not! */
        FILE    *res;
        char    fileName[L_tmpnam];

        if ( !(tmpnam(fileName) && (res = fopen(fileName,"w+"))) )
                return NULL;
        fputs(s, res);
        rewind( res );
        if ( unlink(fileName) < 0 ) 
                return NULL;
        return res;
}

/**
 * This function compiles the XQUERY query in stream 'in' and writes the
 * MIL translation to stream 'out'. The 'mode' parameter indicates the kind
 * of output needed eg. "sax" or "xml".
 */
static int xquery_compile2MIL(FILE* in, FILE* out, char* mode) {
        return pf_compile_interface(in, out, mode);
}

/**
 * This function executes the MIL script stored in the argument filename
 */
static int xquery_executeMIL(char* milFileName) {
        str milBuffer;
        if ( !(milBuffer = monet_load_script(milFileName, NULL)) )
                return -1;
        int res = monet_exec(milBuffer);
        GDKfree(milBuffer);
        return res;
}

/* #define XQMILDEBUG "/tmp/xqmildebug" */

/**
 * Main XQUERY/Pathfinder excution function. The function compiles the 
 * argument query 'q' and generates depending on the 'mode' parameter
 * a result in the form of a Sax-O-Phone stream or and xml string.
 * mode: "xml" or "sax"
 * q   : the xquery query
 */
int xquery_xquery(str  mode, str q) {
        FILE    *milStream;
        FILE    *queryStream;

        /* first open a temporary file to store the comp */
#ifdef XQMILDEBUG
        char* milFile = XQMILDEBUG;
#else
        char    milFileBuff[L_tmpnam];
        char*   milFile=tmpnam(milFileBuff);
#endif
        if ( !(milFile && (milStream = fopen(milFile,"w"))) ) {
                stream_printf(GDKerr,"Unable to open tmpFile \"%s\"\n",milFile);
                return GDK_FAIL;
        }
        /* create a FILE* stream of the input query string 'q' */
        if ( !(queryStream = string2FILE(q)) ) {
                stream_printf(GDKerr,"Unable to create tmp inputstream\n");
                return GDK_FAIL;
        }
        fputs("# enclosing block to garbage collect variables after execution\n{\n", milStream);
        /* now compile from the queryStream to the MIL stream */
        if ( !xquery_compile2MIL(queryStream, milStream, mode) ) {
                stream_printf(GDKerr,"xquery: Compilation failed!\n");
                return GDK_FAIL;
        }
        fputs("\n}\n", milStream);
        fclose(milStream);
        fclose(queryStream);

        /* execute the MIL code in the compiled milFile */
        if ( xquery_executeMIL(milFile) < 0 ) {
                stream_printf(GDKerr,"xquery: Execution failed!\n");
                return GDK_FAIL;
        }
#ifndef XQMILDEBUG
        /* when not debugging throw the temporary MIL file away */
        if ( unlink(milFile) < 0 ) {
                stream_printf(GDKerr,"Unable to unlink tmpFile \"%s\"\n",milFile);
                return GDK_FAIL;
        }
#endif
        return GDK_SUCCEED;
}

@c
/* vim:set shiftwidth=4 expandtab: */
