# Copyright Notice:
# -----------------
# 
# The contents of this file are subject to the MonetDB Public
# License Version 1.0 (the "License"); you may not use this file
# except in compliance with the License. You may obtain a copy of
# the License at http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
# 
# Software distributed under the License is distributed on an "AS
# IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
# implied. See the License for the specific language governing
# rights and limitations under the License.
# 
# The Original Code is the ``Pathfinder'' system. The Initial
# Developer of the Original Code is the Database & Information
# Systems Group at the University of Konstanz, Germany. Portions
# created by U Konstanz are Copyright (C) 2000-2004 University
# of Konstanz. All Rights Reserved.
#
# Contributors:
#         Torsten Grust <torsten.grust@uni-konstanz.de>
#         Maurice van Keulen <M.van.Keulen@bigfoot.com>
#         Jens Teubner <jens.teubner@uni-konstanz.de>
#         Jan Flokstra <flokstra@cs.utwente.nl>
#
# $Id$

@f xquery
@a Jan Flokstra
@t xquery

@c

/*******************************************
* xquery.c : xquery command stuff
*
*/
#include <gdk.h>
#include "pathfinder.h"

#define MAXTAGDEPTH        1024

#define WS_BATS     19
/**
 *
 * I. THE CONTEXT NODE DEFINITION AND USAGE PART
 *
 * This structure contains the context of the print session.
 * It has several functions. But its main use is the administration 
 * of all BATs containing the XML documents.
 *
 */
typedef struct {
        int     saxMode;        /* Flag, true if printing a Sax-O-Phone stream */
        BAT*    ws;             /* working set BAT */
        int     curFRAG;        /* current fragment used by working set */
        BAT*    curBAT[WS_BATS];/* The BAT's of the current fragment*/
        /* */
        /**
         * Next elements is a stack used during printing to store the 
         * pre-value, name, namespace of the nodes currently being printed. 
         */
        int     stackPtr;    
        struct {
                oid     pre;
                str     ns;
                str     name;
        } tagStack[MAXTAGDEPTH];
        /* */
        int     nAttrOnLine; /* used by top result print routine to count the
                              * number of top-level result items printed on
                              * the current line.
                              */
} XqueryCtx;


/**
 * Functions fills a new context() record with mode and BAT data and
 * initializes all other data structures.
 */

BAT* fetchWsContextBAT(BAT* ws, int batID, int wsID) {
        /* stream_printf(GDKout,"# FTECH WS[%d][%d] \n",batID,wsID); */
        BUN bun = BUNfnd(ws,&batID);
        if ( !bun )
              stream_printf(GDKout,"# NOT FOUND BAT[%d] in WS!!!!\n",batID);
        BAT* batbat = BATdescriptor(*(bat*)bun);

        BUN bbun = BUNfnd(batbat,&wsID);
        BAT *res;
        if ( !bbun ) {
                res = 0;
                /* stream_printf(GDKout,"# NOT FOUND BAT[%d][%d] in WS!!!!\n",batID,wsID); */
        } else {
                res = BATdescriptor(*(bat*)bbun);
        }
        BBPunfix( BBPcacheid( batbat ) );
        return res;
}

void switchWsContext(XqueryCtx* ctx, int wsID) {
        if ( ctx->curFRAG != wsID ) {
                int i;

                if ( ctx->curFRAG >= 0 ) {
                        for(i=0; i<WS_BATS; i++) {
                                if ( ctx->curBAT[i] )
                                        BBPunfix( BBPcacheid( ctx->curBAT[i] ) );
                        }
                }
                ctx->curFRAG   = wsID;
                for(i=0; i<WS_BATS; i++) {
                        ctx->curBAT[i] = fetchWsContextBAT(ctx->ws,i,wsID);
                }
        }
}

void createWsContext(XqueryCtx* ctx, BAT* ws, int wsID, str mode) {
        ctx->saxMode   = (strcmp(mode,"sax")==0);
        ctx->ws        = ws;
        ctx->curFRAG   = -1; /* empty, no frag loaded */
        /* */
        if ( wsID >= 0 )
                switchWsContext(ctx, wsID);
        /* */
        ctx->stackPtr  = 0;
}

/**
 * Return if there are still nodes on stack.
 */
int moreTags(XqueryCtx* ctx) {
        return (ctx->stackPtr > 0);
}

/**
 * Push the pre-value, namespace and nodename of stack
 */
void pushTag(XqueryCtx* ctx, oid pre, str ns, str name) {
        ctx->tagStack[ctx->stackPtr].pre  = pre;
        ctx->tagStack[ctx->stackPtr].ns   = strdup(ns); /* incomplete, free? */
        ctx->tagStack[ctx->stackPtr].name = strdup(name); /* incomplete, free? */
        ctx->stackPtr++;
}

/**
 * Three function to retrieve the pre-value, namespace or nodename of the
 * top lement on the stack.
 */
oid topTag(XqueryCtx* ctx)  { return ctx->tagStack[ctx->stackPtr-1].pre; }
str topNs(XqueryCtx* ctx)   { return ctx->tagStack[ctx->stackPtr-1].ns; }
str topName(XqueryCtx* ctx) { return ctx->tagStack[ctx->stackPtr-1].name; }

/**
 * Pop the top element of the stack. Means that processing the node has
 * finished.
 */
void popTag(XqueryCtx* ctx) {
        free( topNs(ctx) );
        free( topName(ctx) );
        --ctx->stackPtr;
}

/**
 *
 * II. THE OUTPUT HANDLER PART 
 *
 * The emit functions are used to encapsulate the Sax-O-Phone event
 * emission functions.
 * The current implementation emits the Sax-O-Phone events as if they are
 * a BAT.
 *
 * TODO: solve characters() newline in string problem. 
 *
 */

void emit_start() {
        stream_printf(GDKout,"#-------------------------#\n");
        stream_printf(GDKout,"# h     SAXtape           #\n");
        stream_printf(GDKout,"# str   str               #\n");
        stream_printf(GDKout,"#-------------------------#\n");
}


/* define borrowed fom gdk_atoms.mx */
#define allowed_chr(ch) (!(0 < (ch) && (ch) < 32) && (ch) != '\377')

void emit_escaped(char* src) {
        /* Emit a string with all special character escaped
         * Function adapted from strToStr() in gdk_atoms.mx
         */
        int start=0,end;
        for(end=0; src[end]; end++) {
                if (src[end] == '\t' || src[end] == '\n' ||
                    src[end] == '\\' || src[end] == '\"' ||
                    (!allowed_chr(src[end])) ) {
                        stream_write(GDKout,&src[start],end-start,1); /*flush */
                        start = end+1;
                        switch( src[end] ) {
                         case '\t':
                                stream_write(GDKout,"\\t",2,1);
                                break;
                         case '\n':
                                stream_write(GDKout,"\\n",2,1);
                                break;
                         case '\\':
                                stream_write(GDKout,"\\\\ ",2,1);
                                break;
                         case '\"':
                                stream_write(GDKout,"\"",2,1);
                                break;
                         default: /* case: not_allowed() */
                                stream_printf(GDKout,"\\%03o",(unsigned char)src[end]);
                                stream_flush(GDKout);
                        }
                }
        }
        if ( start < end ) {
                stream_flush(GDKout);
                stream_write(GDKout,&src[start],end-start,1); /* flush */
        }
}

void emit(char* eventName, char* val, int escaped) {
        if ( val ) {
                if ( escaped ) {
                        stream_printf(GDKout,"[\"%s\",\t\"",eventName);
                        emit_escaped(val);
                        stream_printf(GDKout,"\"]\n");
                } else {
                        stream_printf(GDKout,"[\"%s\",\t\"%s\"]\n",eventName,val);
                }
        } else
                stream_printf(GDKout,"[%s,\tnil]\n",eventName);
}

void emit_end() {
}


/*
 *
 * The output handlers. Responslibe for generating the output representing
 * the handles xml structure. Cuurently 3 output structures are used:
 *
 * 1) plain xml text (ctx->saxMode is false)
 * 2) xml Sax-O-Phone stream (ctx->saxMode is true AND SAXOPHONE=1 )
 * 3) My own SAX event stream (ctx->saxMode is true AND SAXOPHONE=0 )
 *
 */

/* The SAXOPHONE define is a temporary flag used by JF to compile 'in'
 * his own Sax-O-Phone version which he thinks is much more efficient
 * than the original (but not as fancy) of course.
 */
#define SAXOPHONE 1

/**
 * Output generation handler. Handles equivalent of * SAX startDocument() event.
 */
void handle_startDocument(XqueryCtx* ctx) {
        if (ctx->saxMode ) {
                if ( SAXOPHONE ) {
                        emit_start();
                        /* emit(START_DOC, NULL); */
                } else
                        stream_printf(GDKout,"<S\n");
        } else { /* xmlMode */
                stream_printf(GDKout,"<?xml version=\"1.0\" encoding=\"utf-8\"?>\n");
        }
}

/**
 * Output generation handler. Handles equivalent of * SAX endDocument() event.
 */
void handle_endDocument(XqueryCtx* ctx) {
        if (ctx->saxMode ) {
                if ( SAXOPHONE ) {
                        /* emit(END_DOC, NULL); */
                        emit_end();
                } else 
                        stream_printf(GDKout,"<E\n");
        } else { /* xmlMode */
                stream_printf(GDKout,"\n\n");
        }
}

/**
 * Output generation handler. This one of my own invented event describing
 * the usage of an attribute. A sequnce of these events will be ended
 * by a handle_attributeEnd() call.
 */
void handle_attribute(XqueryCtx* ctx, str ns, str name, str value) {
        if (ctx->saxMode ) {
                if ( SAXOPHONE ) {
                        emit(" attribute",name,0);
                        if ( ns && (strlen(ns)>0) )
                                emit(" attribute prefix",ns,0);
                        emit(" attribute value",value,0);
                } else {
                        stream_printf(GDKout,"<A %s=\"%s\"\n",name,value);
                }
        } else { /* xmlMode */
                if ( ns && strlen(ns)>0 ) {
                        stream_printf(GDKout," %s:%s=\"%s\"",ns,name,value);
                } else {
                        stream_printf(GDKout," %s=\"%s\"",name,value);
                }
        }
}

/**
 * Output generation handler. This one of my own invented event indicating
 * there will be no more attribute events for this node.
 */
void handle_attributeEnd(XqueryCtx* ctx) {
        if (ctx->saxMode ) {
        } else { /* xmlMode */
                stream_printf(GDKout,">");
        }

}

/**
 * Output generation handler. Handles equivalent of * SAX startElement() event.
 */
void handle_startElement(XqueryCtx* ctx, str ns, str name /*,str *atts*/) {
        if (ctx->saxMode ) {
                if ( SAXOPHONE ) {
                        emit("startElement",NULL,0);
                        if ( ns && (strlen(ns)>0) )
                                emit(" prefix",ns,0);
                        emit(" localname",name,0);
                } else {
                        stream_printf(GDKout,"<s %s\n",name);
                }
        } else { /* xmlMode */
                if ( ns && strlen(ns)>0 ) {
                        stream_printf(GDKout,"<%s:%s",ns,name);
                } else {
                        stream_printf(GDKout,"<%s",name);
                }
        }
}

/**
 * Output generation handler. Handles equivalent of * SAX endElement() event.
 */
void handle_endElement(XqueryCtx* ctx, str ns, str name) {
        if (ctx->saxMode ) {
                if ( SAXOPHONE ) {
                        emit("endElement",NULL,0);
                        if ( ns && (strlen(ns)>0) )
                                emit(" prefix",ns,0);
                        emit(" localname",name,0);
                } else {
                        stream_printf(GDKout,"<e %s\n",name);
                }
        } else { /* xmlMode */
                if ( ns && strlen(ns)>0 ) {
                        stream_printf(GDKout,"</%s:%s>",ns,name);
                } else {
                        stream_printf(GDKout,"</%s>",name);
                }
        }
}

/**
 * Output generation handler. One on my own again. This one should handle a
 * reference. Don't know wat to to about it now.
 */
void handle_reference(XqueryCtx* ctx, str name) {
        if (ctx && name) {};
}

/**
 * Output generation handler. Handles equivalent of * SAX characters() event.
 */
void handle_characters(XqueryCtx* ctx, str ch) {
        if (ctx->saxMode ) {
                if ( SAXOPHONE ) {
                        emit("characters",NULL,0);
                        emit(" pcdata",ch,1);
                } else {
                        stream_printf(GDKout,"%s\n",ch);
                }
        } else { /* xmlMode */
                stream_printf(GDKout,"%s",ch);
        }
}

/**
 * Output generation handler. Handles equivalent of * SAX ignorableWhitespace()
 * event. I see no reason why it should be used here but I include it for
 * completeness.
 */
void handle_ignorableWhitespace(XqueryCtx* ctx, str ch) {
        handle_characters(ctx,ch); /* dispatch */
}

/**
 * Output generation handler. Again an own event. But this one should be
 * used I think because the comments are used and stored by  Pathfinder.
 */
void handle_comment(XqueryCtx* ctx, str comm) {
        if (ctx->saxMode ) {
                /* incomplete */
        } else { /* xmlMode */
                stream_printf(GDKout,"<!--%s-->",comm);
        }
}

/**
 * Output generation handler. Handles equivalent of * SAX processingInstruction() event.
 */
void handle_processingInstruction(XqueryCtx* ctx, str target, str data) {
        if (ctx->saxMode ) {
                /* incomplete */
        } else { /* xmlMode */
                stream_printf(GDKout,"<?%s %s?>",target,data);
        }
}

/**
 * Utility function. It reads the tail value of an element in a 
 * [void,any] BAT indexed by oid_index. 
 */
ptr indexedTail(str name, BAT* b, oid oid_index) {
        ptr res;

        if ( !b )
                stream_printf(GDKout,"NIL BAT[\"%s\"]\n",name);
        if ( BUNsize(b) == 1 ) {
                /* There is a probably bug in monet. The else code should work */
                /* for all situations but does not work for all BAT[void,chr] */
                /* arguments. At the moment some do and some don't. */
                /* I reported this bug once and then I could not reproduce */
                /* the failure. But it still fails for the 'kind' BAT in */
                /* the xquery_result_main() function */
                BUN bun = BUNfirst(b);
                res = &bun[oid_index];
        } else {
                oid real_index = oid_index + 1; /*this one cost me 2 hrs */

                BUN bun = BUNptr(b,real_index);
                res = BUNtail(b,bun);
        }
        return res;
}

ptr IDT(XqueryCtx* ctx, int batId, oid oid_index) {
        BAT* b = ctx->curBAT[batId];
        if ( !b ) 
                stream_printf(GDKout,"NIL ctx->curBAT[%d]\n",batId);
        ptr res = indexedTail("tmp",b,oid_index);
        return res;
}

ptr IDT_FRGN(XqueryCtx* ctx, int fragId, int batId, oid oid_index) {
        if ( ctx->curFRAG == fragId ) 
                return IDT(ctx,batId,oid_index);
        else {
                BAT* b = fetchWsContextBAT(ctx->ws, batId, fragId);

                if ( !b )
                        stream_printf(GDKout,"NIL BAT[%d][%d]\n",fragId,batId);

                ptr res = indexedTail("tmp",b,oid_index);

                BBPunfix( BBPcacheid( b ) );

                return res;
        }
}

/**
 * Handle the generation of the attributes of the node with oid 'pre'. This
 * function is only called from the xquery_node_print() function.
 */
void query_attr_print(XqueryCtx* ctx, oid pre) {
        BAT* b = BATuselect(ctx->curBAT[ATTR_OWN],&pre,&pre);

        BUN p, q; 
        BATloop(b, p, q) {
                oid id = *(oid*)BUNhead(b, p);
                /* */
                oid poid = *(oid*)IDT(ctx,ATTR_PROP,id);
                str val = (str)IDT(ctx,PROP_VAL,poid);
                /* */
                oid qoid = *(oid*)IDT(ctx,ATTR_QN,id);
                str ns   = (str)IDT(ctx,QN_NS,qoid);
                str name = (str)IDT(ctx,QN_LOC,qoid);
                /* */
                handle_attribute(ctx,ns,name,val);
        }
        handle_attributeEnd(ctx);
        /* BATdelete(b); INCOMPLETE, CRASHES WHY?? */
}

/**
 * Handle the generation of the node with oid 'pre'.
 */
void xquery_node_print(XqueryCtx* ctx, oid pre, BAT* pre_frag) {
        chr kind = *(chr*)IDT(ctx,PRE_KIND,pre);
        oid prop = *(oid*)IDT(ctx,PRE_PROP,pre);

        int valueFRAG = ctx->curFRAG;
        if ( pre_frag )
                valueFRAG = *(int*)IDT(ctx,PRE_FRAG,pre);
        switch( kind ) {
                case (char)0: {/* ELEMENT */
                        str name = (str)IDT_FRGN(ctx,valueFRAG,QN_LOC,prop);
                        str ns   = (str)IDT_FRGN(ctx,valueFRAG,QN_NS,prop);
                        handle_startElement(ctx,ns,name);
                        query_attr_print(ctx,pre);

                        oid size = *(oid*)IDT(ctx,PRE_SIZE,pre);
                        pushTag(ctx,pre+size,ns,name);
                        break;
                        }
                case (char)1: {/* TEXT */
                        handle_characters(ctx,(str)IDT_FRGN(ctx,valueFRAG,PROP_TEXT,prop));
                        break;
                        }
                case (char)2: {/* COMMENT */
                        handle_comment(ctx,(str)IDT_FRGN(ctx,valueFRAG,PROP_COM,prop));
                        break;
                        }
                case (char)3: {/* PI */
                        str target = (str)IDT_FRGN(ctx,valueFRAG,PROP_TGT,prop);
                        str data   = (str)IDT_FRGN(ctx,valueFRAG,PROP_INS,prop);
                        handle_processingInstruction(ctx,target,data);
                        break;
                        }
                case (char)4: {/* DOCUMENT */
                        /* The node represents an entire document */
                        oid offset = *(oid*)IDT(ctx,PRE_SIZE,pre);
                        pushTag(ctx,pre+offset,"","");
                        break;
                        }
                default:
                        stream_printf(GDKout,"Unknow kind IN xquery_node_print");
        }
}

#define ALLTAGS INT_MAX

/**
 * handle the closing tag of a document.
 */
void xquery_endtag_print(XqueryCtx* ctx, oid pre) {
        while( moreTags(ctx) && ((pre==ALLTAGS)||(pre > topTag(ctx))) ) { /*?? */
                if ( strlen(topName(ctx)) > 0 )
                        handle_endElement(ctx,topNs(ctx),topName(ctx));
                popTag(ctx);
        }
}

/**
 * handle the range of pre numbers [from .. to]
 */
void xquery_pre_range(XqueryCtx* ctx, BAT* b, oid from, oid to) {
        BUN p, q; 
        if ( from == 0 ) /* first BUN, because of 1..n/0..n-1 problem */
                p = BUNfirst(b);
        else
                BUNfndOID(p, b,&from);
        for(q = BUNlast(b); p<q; p = BUNnext(b, p)) {
                oid pre = *(oid*)BUNhead(b, p);
                do {
                        xquery_node_print(ctx, pre, 0 /* pre_frag */);
                        xquery_endtag_print(ctx,++pre);
                } while( moreTags(ctx) && (pre<to) );
        }
        if ( moreTags(ctx) ) {
                /* INCOMPLETE, the next line works but WHY? Should work without */
                xquery_endtag_print(ctx,ALLTAGS);
        }
}

void MY_xquery_pre_range(XqueryCtx* ctx, oid from, oid to, BAT* pre_frag) {
        oid pre = from;

        do {
                if (0) stream_printf(GDKout,"[pb%dp]",pre);
                xquery_node_print(ctx, pre,pre_frag);
                xquery_endtag_print(ctx,++pre);
                if (0) stream_printf(GDKout,"[pe%dp]",pre);
        } while( moreTags(ctx) && (pre<=to) );
        if (0) stream_printf(GDKout,"[*%d>=%d]",pre,to);
        if ( 0 && moreTags(ctx) ) {
                /* INCOMPLETE, see above */
                xquery_endtag_print(ctx,ALLTAGS);
        }
}

/**
 *
 * X. THE MAIN XML DOCUMENT PRINTING PART
 *
 * Main XML document printing routine
 */

int ws_documentIndex(BAT* ws, str docName) {
        int doc_loaded_idx = DOC_LOADED;

        BUN b = BUNfnd(ws,&doc_loaded_idx);
        /*
         * if ( !b )
         *       stream_printf(GDKout,"NOT FOUND DOCBAT!!!!\n");
         */
        BAT* doc_loaded = BATdescriptor(*(bat*)b);

        BATprintf(GDKout,doc_loaded);

        BUN p, q; 
        BATloop(doc_loaded, p, q) {
                oid docId = *(oid*)BUNhead(doc_loaded, p);
                str docNm = (str)BUNtail(doc_loaded, p);

                if ( strcmp(docName,docNm) == 0 ) {
                        /* stream_printf(GDKout,"found document: %s\t(id=%d@0)\n",docNm,docId); */
                        BBPunfix( BBPcacheid( doc_loaded ) );
                        return docId;
                }
        }
        BBPunfix( BBPcacheid( doc_loaded ) );
        return -1;
}

void doDump(str docName, XqueryCtx* ctx) {
        stream_printf(GDKout,"# dump of document \"%s\", frag=%d\n",docName,ctx->curFRAG);
        stream_printf(GDKout,"# ********pre_size********:\n");

}

int xquery_dump_doc_main(BAT* ws, str docName) {
        int docIndex = ws_documentIndex(ws,docName);
        if ( docIndex < 0 ) {
                stream_printf(GDKout,"# unable to find document \"%s\" in working set!\n",docName);
                return GDK_SUCCEED;
        }
        /* */
        XqueryCtx  ctx_struct, *ctx = &ctx_struct;
        createWsContext(ctx,ws,docIndex,"xml");
        /* */
        doDump(docName,ctx);
        /* */
        return GDK_SUCCEED;
}

int xquery_print_doc_main(str mode, BAT* ws, str docName) {
        int docIndex = ws_documentIndex(ws,docName);
        if ( docIndex < 0 ) {
                stream_printf(GDKout,"# unable to find document \"%s\" in working set!\n",docName);
                return GDK_SUCCEED;
        }
        /* */
        XqueryCtx  ctx_struct, *ctx = &ctx_struct;
        createWsContext(ctx,ws,docIndex,mode);
        /* */
        handle_startDocument(ctx);
        xquery_pre_range(ctx,ctx->curBAT[PRE_SIZE],0/*start*/,1 /* first is doc ? */);
        handle_endDocument(ctx);
        /* */
        return GDK_SUCCEED;
}

/**
 * XI. THE MAIN PATHFINDER QUERY RESULT PART
 *
 * First the event/emit handlers for the sequnce are defined and after that
 * the main function
 */

#define XQRESTAG        "XqueryResult"

/**
 * Handle the start() of an XQUERY/Pathfinder result sequence
 */
void  seqStart(XqueryCtx* ctx) {
        if ( ctx->saxMode ) {
                handle_startElement(ctx,NULL,XQRESTAG);
        } else {
                stream_printf(GDKout,"<?xml version=\"1.0\" encoding=\"utf-8\"?>\n");
                stream_printf(GDKout,"<%s>\n",XQRESTAG);
                ctx->nAttrOnLine = 0;
        }
}

/**
 * Handle the end() of an XQUERY/Pathfinder result sequence
 */
void  seqEnd(XqueryCtx* ctx) {
        if ( ctx->saxMode ) {
                handle_endElement(ctx,NULL,XQRESTAG);
        } else {
                stream_printf(GDKout,"\n");
                stream_printf(GDKout,"</%s>\n",XQRESTAG);
        }
}


/**
 * Emit a NODE element of an XQUERY/Pathfinder result sequence
 */
void  seqEmitNode(XqueryCtx* ctx, oid preVal, BAT* pre_frag) {
        int size = *(int*)IDT(ctx,PRE_SIZE,preVal);
        /* stream_printf(GDKout,"Emit NODE: %d, size = %d\n",preVal,size); */
        MY_xquery_pre_range(ctx,preVal,preVal+size, pre_frag);
}

/**
 * Emit a Boolean element of an XQUERY/Pathfinder result sequence
 */
void  seqEmitBool(XqueryCtx* ctx, int bv) {
        char *bool_str = (char*)(bv?"true":"false");

        if ( ctx->saxMode ) {
                handle_characters(ctx,bool_str);
        } else {
                ctx->nAttrOnLine++;
                stream_printf(GDKout,"%d ",bool_str);
        }
}

/**
 * Emit a Integer element of an XQUERY/Pathfinder result sequence
 */
void  seqEmitInt(XqueryCtx* ctx, int iv) {
        if ( ctx->saxMode ) {
                char buff[32];

                sprintf(buff,"%d",iv);
                handle_characters(ctx,buff);
        } else {
                ctx->nAttrOnLine++;
                stream_printf(GDKout,"%d ",iv);
        }
}

/**
 * Emit a Double element of an XQUERY/Pathfinder result sequence
 */
void  seqEmitDbl(XqueryCtx* ctx, dbl dv) {
        if ( ctx->saxMode ) {
                char buff[32];

                sprintf(buff,"%f",dv);
                handle_characters(ctx,buff);
        } else {
                ctx->nAttrOnLine++;
                stream_printf(GDKout,"%f ",dv);
        }
}

/**
 * Emit a String element of an XQUERY/Pathfinder result sequence
 */
void  seqEmitStr(XqueryCtx* ctx, str sv) {
        if ( ctx->saxMode ) {
                handle_characters(ctx,sv);
        } else {
                ctx->nAttrOnLine++;
                stream_printf(GDKout,"\"%s\" ",sv);
        }
}

/**
 * Main XQUERY/Pathfinder result sequence printing routine. Arguments are
 * mode: "xml" or "sax"
 * ws : the working set
 * item/kind : sequence result BATs
 * intVAL,dblVAL,decVAL,strVAL : BATSs containing the values of seq elements
 * remainder BATs: conatins the data for the document nodes
 *
 * The function iterates through the item/kind BAT's and retrieves the values
 * from the xxxVAL BATs. Then it calls one of the seqXXXXX() functions
 * defined above to handle the output generation.
 */

/*
 * BAT format definitions. These must be equal to the definitions
 * in pathfinder.mx
 */

#define XTRACT_KIND(X)  (X & 63)
#define XTRACT_FRAG(X)  (X >> 6)

#define QNAME 2
#define BOOL  3
#define INT   4
#define DEC   5
#define DBL   6
#define STR   7
#define NODE  32
#define ELEM  33
#define ATTR  34

#define DEBUG_BAT       0

int xquery_print_result_main(
                str  mode,
                BAT* ws,
                BAT* item,
                BAT* kind,
                BAT* intVAL,
                BAT* dblVAL,
                BAT* decVAL,
                BAT* strVAL
        ) {
        XqueryCtx  ctx_struct, *ctx = &ctx_struct;
        createWsContext(ctx,ws,-1,mode);
        /* */
        if ( DEBUG_BAT ) {
                stream_printf(GDKout,"# RAW XQUERY RESULT:\n");
                stream_printf(GDKout,"# pre\tkind\tvaloid\tval\n");
                stream_printf(GDKout,"# ---\t----\t------\t---\n");
        }
        /* */
        seqStart(ctx);
        /* */
        BUN p, q; 
        BATloop(item, p, q) {
                oid pre = *(oid*)BUNhead(item, p);
                oid valoid = *(oid*)BUNtail(item, p);
                int cmbn_frag_kind = *(int*)indexedTail("kind",kind,pre);
                if ( DEBUG_BAT )
                        stream_printf(GDKout,"## pre=%d\tcbn=%d\tkind=%d\tv_oid=%d\t",pre,cmbn_frag_kind,XTRACT_KIND(cmbn_frag_kind),valoid);
                switch( XTRACT_KIND(cmbn_frag_kind) ) {
                 case ATTR: {
                        stream_printf(GDKout,"<!--attr-not-impl-yet-->\n");
                        break;
                        };
                 case ELEM: {
                        int frag = XTRACT_FRAG(cmbn_frag_kind);
                        if (DEBUG_BAT) stream_printf(GDKout,"ELEM(frag=%d,v_oid=%d)\n",frag, valoid);
                        switchWsContext(ctx,frag);
                        seqEmitNode(ctx, valoid, ctx->curBAT[PRE_FRAG]);
                        break;
                        };
                 case NODE: {
                        // incomplete, suppose just ignore
                        // stream_printf(GDKout,"<!--node-not-impl-yet-->\n");
                        break;
                        };
                 case BOOL: {
                        if (DEBUG_BAT) stream_printf(GDKout,"%s\n",(valoid?"true":"false"));
                        seqEmitBool(ctx,valoid);
                        break;
                        }
                 case DBL: {
                        dbl dv = *(dbl*)indexedTail("dblVAL",dblVAL,valoid);
                        if (DEBUG_BAT) stream_printf(GDKout,"%f\n",dv);
                        seqEmitDbl(ctx,dv); /* INCOMPLETE ?diff between d and e */
                        break;
                        }
                 case DEC: {
                        dbl dv = *(dbl*)indexedTail("decCVAL",decVAL,valoid);
                        if (DEBUG_BAT) stream_printf(GDKout,"%f\n",dv);
                        seqEmitDbl(ctx,dv); /* INCOMPLETE ?diff between d and e */
                        break;
                        }
                 case INT: {
                        int iv = *(int*)indexedTail("intVAL",intVAL,valoid);
                        if (DEBUG_BAT) stream_printf(GDKout,"%d\n",iv);
                        seqEmitInt(ctx,iv);
                        break;
                        }
                 case STR: {
                        str sv = (str)indexedTail("strVAL",strVAL,valoid);
                        if (DEBUG_BAT) stream_printf(GDKout,"\"%s\"\n",sv);
                        seqEmitStr(ctx,sv);
                        break;
                        }
                 default:
                        stream_printf(GDKout,"XUNKNOW_TYPE(\'%c\'ch(%d))\n",cmbn_frag_kind,cmbn_frag_kind);
                        stream_printf(GDKout,"[kind=%d, frag=%d]\n",XTRACT_KIND(cmbn_frag_kind),XTRACT_FRAG(cmbn_frag_kind));
                }
        }
        /* */
        seqEnd(ctx);
        /* */
        return GDK_SUCCEED;
}

@c
/* vim:set shiftwidth=4 expandtab: */
