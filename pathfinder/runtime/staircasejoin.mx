# Copyright Notice:
# -----------------
# 
# The contents of this file are subject to the MonetDB Public
# License Version 1.0 (the "License"); you may not use this file
# except in compliance with the License. You may obtain a copy of
# the License at http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
# 
# Software distributed under the License is distributed on an "AS
# IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
# implied. See the License for the specific language governing
# rights and limitations under the License.
# 
# The Original Code is the ``Pathfinder'' system. The Initial
# Developer of the Original Code is the Database & Information
# Systems Group at the University of Konstanz, Germany. Portions
# created by U Konstanz are Copyright (C) 2000-2003 University
# of Konstanz. All Rights Reserved.
#
# Contributors:
#         Torsten Grust <torsten.grust@uni-konstanz.de>
#         Maurice van Keulen <M.van.Keulen@bigfoot.com>
#         Jens Teubner <jens.teubner@uni-konstanz.de>
#
# $Id$

@f staircasejoin
@a Torsten Teggy Grust
@a Maurice van Keulen
@a Henning Rode
@t staircasejoin

@c

/*******************************************
* staircasejoin.c : staircase join operators
*
*/

#include <gdk.h>

#if 0
#define prefetch_loc(addr) \
/* Parameters */
const int PF_SOFTWARE_PREFETCH = 128;

/* software prefetching is not used currently */
  __asm__ __volatile__ ("prefetchnta %0" \
                        : \
                        : \
                        "m" (*(((char*)(size_t)(((unsigned int)(size_t)(addr))&~0x7f)))))
                            /* StM: extended casting to pacify 64-bit compilers */
#else
#define prefetch_loc(addr)
#endif

/*******************************************************************/

#define PF_INCL_BOUNDARY
	@:scj_void(_descorself)
#undef PF_INCL_BOUNDARY
	@:scj_void(_desc)

@= scj_void
int
PFscj_void@1(BAT **result, BAT *pre_size, BAT *ctx, int *height, int *upperbound)
{
    /* --------------------------- declaration ----------------------------- */

    char *name = "PFscj_void@1";
    BUN ctx_cur, ctx_last;
    oid pre_cur, *res_cur;
    int max_post, ctx_bunsize, *size;
    
    /* result bat allocation. for result size use upperbound parameter */
    BAT *res = BATnew(TYPE_oid, TYPE_void, *upperbound);


    /* --------------------------- special cases --------------------------- */
    if (!(BAThordered(ctx) & 1))
    {
        GDKerror("%s: context must be ordered on head.\n", name);
        return GDK_FAIL;
    }
    if (BATcount(ctx) == 0 || BATcount(pre_size) == 0)
    {
        *result = BATnew(TYPE_oid, TYPE_void, 0);
        return GDK_SUCCEED;
    }
    if (res == NULL) 
    { 
        GDKerror("%s: could not allocate a result BAT of size %d.\n", name, *upperbound);
        return GDK_FAIL;
    }

    /* ----------------- initialization of table cursors ------------------- */

    res_cur = (oid*)BUNfirst(res);
    max_post = -1;

    /* definition for "array-like" access on size values of given nodes */
    size = ((int*) BUNfirst(pre_size)) - pre_size->hseqbase;

    ALGODEBUG
        THRprintf(GDKout, "%s: node set of %u buns, context set of %u buns, height %u\n",
                          name, BATcount(pre_size), BATcount(ctx), *height);

    /* ---------------------------- main part ----------------------------- 
     * - the outer loop traverses all context nodes
     * - the inner loop writes all descendants to result 
     */

    BATloopFast (ctx, ctx_cur, ctx_last, ctx_bunsize)
    {
        pre_cur = *(oid*)BUNhead(ctx, ctx_cur);
        
        /* on-the-fly pruning of the context set */
        if ((int)pre_cur > max_post)
        {
            max_post = pre_cur + size[pre_cur];
#ifndef PF_INCL_BOUNDARY
            pre_cur++;
#endif
            while ((int)pre_cur <= max_post)
                *res_cur++ = pre_cur++;
        }
    }
    

    /* ---------------------------- end of main part --------------------------
     * tidy up and propagate result properties
     */

    /* mark the end point of the BUNs section in the BUNheap 
     */
    res->batBuns->free = ((BUN)res_cur) - res->batBuns->base;

    res->batDirty = TRUE;
    res->hsorted = GDK_SORTED;
    BATkey(res,TRUE);
    BATseqbase(BATmirror(res), oid_nil);
    *result = res;

    return GDK_SUCCEED;
}

/* vim:set shiftwidth=4 expandtab: */
