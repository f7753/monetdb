# pathfinder.mx
#
# Monet runtime support for the Pathfinder XQuery compiler
#
# Copyright Notice:
# -----------------
# 
# The contents of this file are subject to the MonetDB Public
# License Version 1.0 (the "License"); you may not use this file
# except in compliance with the License. You may obtain a copy of
# the License at http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
# 
# Software distributed under the License is distributed on an "AS
# IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
# implied. See the License for the specific language governing
# rights and limitations under the License.
# 
# The Original Code is the ``Pathfinder'' system. The Initial
# Developer of the Original Code is the Database & Information
# Systems Group at the University of Konstanz, Germany. Portions
# created by U Konstanz are Copyright (C) 2000-2004 University
# of Konstanz. All Rights Reserved.
#
# Contributors:
#         Torsten Grust <torsten.grust@uni-konstanz.de>
#         Maurice van Keulen <M.van.Keulen@bigfoot.com>
#         Jens Teubner <jens.teubner@uni-konstanz.de>
#
# $Id$
#

@f pathfinder
@a Torsten Teggy Grust
@a Maurice van Keulen
@a Henning Rode
@a Jan Flokstra
@a Jens Teubner
@t Runtime Support for the Pathfinder XQuery Compiler

@m
.MODULE pathfinder;

.USE xtables;

@:prec_foll(following)@
@:prec_foll(preceding)@

@= prec_foll
.COMMAND @1_void (BAT[void,int] pre_size,
               BAT[oid,any] ctx,
               BAT[void,oid] doc_pre,
	       int height,
               int upperbound) : BAT[oid,void] = PF@1_void;
"PARAMETERS
  pre_size: the complete size BAT (preorder rank, size)
  ctx: context node sequence (preorder rank, *)
  doc_pre: table of document fragments (doc id, preorder start value)
  height: document height
  upperbound: upperbound for size of result context node sequence
DESCRIPTION
axis step evaluation on the @1 axis from the given context."
@m
@:scj_cmd(descorself,descendant-or-self)@
@:scj_cmd(desc,descendant)@
@:scj_cmd(ancorself,ancestor-or-self)@
@:scj_cmd(anc,ancestor)@

@= scj_cmd
.COMMAND scj_@1(BAT[void,int] pre_size,
                BAT[oid,any] ctx,
                int height,
                int upperbound): BAT[oid,void] = PFscj_@1_void;
"PARAMETERS
  pre_size: the complete size BAT (preorder rank, size)
  ctx: context node sequence (preorder rank, *)
  height: document height
  upperbound: upperbound for size of result context node sequence
DESCRIPTION
axis step evaluation on the @2 axis from the given context."
@m
@:ll_cmd(descendant)@
@:ll_cmd(descendant_or_self)@
@:ll_cmd(child)@

@= ll_cmd
.COMMAND ll_@1(BAT[void,oid] iter,
                   BAT[void,oid] ctx,
                   oid frag,
                   BAT[void,bat] ws): BAT[oid,oid] = PFll_@1;
"PARAMETERS:
BAT[void,oid] iter (grouping relation)
BAT[void,oid] ctx (context set)
oid frag (the current fragment of the ws)
BAT[void,bat] ws (working set)
DESCRIPITON:
returns all nodes on the @1 axis of the ctx-nodes duplicate free for each group."
@m
@:lev_cmd(child,child)@
@:lev_cmd(parent,parent)@
@:lev_cmd(fs,following-sibling)@
@:lev_cmd(ps,preceding-sibling)@

@= lev_cmd
.COMMAND lev_@1(BAT[void,chr] pre_level,
                BAT[oid,any] ctx,
		int height,
                int upperbound) : BAT[oid,void] = PFlev_@1;
"PARAMETERS
  pre_level: the complete level BAT (preorder rank, level)
  ctx: context node sequence (preorder rank, *)
  height: document height
  upperbound: upperbound for size of result context node sequence
DESCRIPTION
axis step evaluation on the @2 axis from the given context."

@m

.COMMAND ebv(BAT[oid, bit] b) : BAT[oid, bit] = CMDebv;
"PARAMETERS
BAT[oid, bit], sorted on head values.
DESCRIPTION:
This is a helper function to implement the XQuery ``effective boolean\n
value.'' Grouped by the head values, it will look at the tail values.\n
If for a head value there is exactly one BUN whose tail equals `true',\n
the result for this group will be `true' as well. In any other case\n
(a single `false' BUN, or multiple BUNs for this group), a `false'\n
tuple will be in the result for this group."

@m

#############################################
# The NEW XQUERY and XML print functions
#
# - print_doc(str mode, BAT[void,bat] ws, str name)
# - print_result(str mode, BAT[void,bat] ws, BAT[void,oid] item,
#			BAT[void,int] kind, .... the value BATs)
#
.COMMAND xquery(str, str) : void = xquery_xquery;
 "Main XQUERY function for Pathfinder"
.COMMAND print_doc(str,BAT[void,bat], str) : void = xquery_print_doc_main;
 "C interface to Workset print routine"
.COMMAND print_result(str,BAT[void,bat],BAT[void,oid],BAT[void,int],BAT[void,int],BAT[void,dbl],BAT[void,dbl],BAT[void,str]) : void = xquery_print_result_main;
 "C interface to Workset result print routine"
.COMMAND dump_doc(BAT[void,bat], str) : void = xquery_dump_doc_main;
 "C interface to Workset print routine"

.END pathfinder;

@mil
# load modules used in pathfinder.mx
module(pf_support);
module(malalgebra);

PROC get_type (bat[void,int] kind, int type_) : bat[oid,void]
{
        return kind.[and](63).ord_uselect(type_); # 63 = 2^6 - 1
}

PROC get_type_node (bat[void,int] kind) : bat[oid,void]
{
        return kind.ord_uselect(NODE, int(nil));
}

PROC get_type_atomic (bat[void,int] kind) : bat[oid,void]
{
        return kind.ord_uselect(int(nil), ATOMIC);
}

PROC get_fragment (bat[void,int] kind) : bat[void,oid]
{
        return kind.[>>](6).[oid]();
}

PROC get_kind (bat[void,oid] frag, int type_) : bat[void,int]
{
        return frag.[int]().[<<](6).[or](type_);
}

PROC get_types (bat[void,int] kind) : bat[void,int]
{
        return kind.[and](63); # 63 = 2^6 - 1
}

#PROC get_kind (bat[void,oid] frag, bat[void,int] type_) : bat[void,int]
#{
#        return frag.[int]().[<<](6).[or](type_);
#}

#PROC get_kind (int frag, bat[void,int] type_) : bat[void,int]
#{
#        return type_.[or](frag<<6);
#}

#
# Serialization function, mainly for debugging purposes.
#
# Serialization should probably be done in a more sophisticated fashion.
# For now we just implement it in MIL to have something for debugging.
# If for the final version we decide on different paraemters, the
# MIL generation code in the Pathfinder compiler should be adapted
# accordingly. Have a look at the top-level rule in milgen.mt.sed, and
# at the stuff related to PFmil_ser() in mil.c. The printing routines
# in milprint.c need to be adapted as well.
#
# Parameters:
#   pos            This BAT defines the order of the output
#   item_int       Integer values that contribute to result
#   item_str       String values that contribute to result
#   item_dec       Decimal values that contribute to result
#   item_dbl       Double values that contribute to result
#   item_bit       Boolean values that contribute to result
#   item_node      Nodes that contribute to result
#
PROC serialize (BAT[void,oid] pos,
                BAT[oid,int] item_int,
                BAT[oid,str] item_str,
                BAT[oid,dbl] item_dec,
                BAT[oid,dbl] item_dbl,
                BAT[oid,bit] item_bit,
                BAT[oid,oid] item_node) : void
{
    var positions;
    var values := new (void, BAT);

    values.insert (nil, item_int);
    values.insert (nil, item_str);
    values.insert (nil, item_dec);
    values.insert (nil, item_dbl);
    values.insert (nil, item_bit);
    values.insert (nil, item_node);

    # Sort by pos column
    positions := pos.reverse().sort().reverse();

    positions@batloop () {
        var curr_oid := $h;

        values@batloop () {
            $t.reverse().select (curr_oid).reverse()@batloop () {
                print ($t);
            }
        }
    }
}

ADDHELP("serialize", "teubner", "September 2004",
"PARAMETERS:\n\
 pos            This BAT defines the order of the output\n\
 item_int       Integer values that contribute to result\n\
 item_str       String values that contribute to result\n\
 item_dec       Decimal values that contribute to result\n\
 item_dbl       Double values that contribute to result\n\
 item_bit       Boolean values that contribute to result\n\
 item_node      Nodes that contribute to result\n\
\n\
DESCRIPTION:\n\
Serialize algebra expression. \n\
All BATs are expected to be head-aligned, where values may be missing\n\
in the item_* BATs. (In fact, the MIL code generated by the Pathfinder\n\
compiler will produce BATs where for each key in pos there will a\n\
BUN in exactly one of the item_* BATs.)\n\
Given the sort order in pos, all values in the item_* are printed\n\
(using the MIL print() primitive) in that order.\n\
NOTE: This implementation is mainly meant for debugging, it is far from\n\
efficient. Feel free to implement it the right way ;-).",
"pathfinder");


#############################################
# Document management functions
#
# - import_doc
# - delete_doc
# - delete_all_docs
# - compress_properties
# - create_ws
# - add_doc
#
# Each imported XML-document is stored as a collection of persistent BATs 
# whose name starts with the name of the BAT and ends with the document ID. 
# The execution of an XQuery is not performed on the persistent BATs, but on 
# the transient 'working set', a global document collection represented
# by the ws-BAT.
#
# Each collection contains the following BATs:
# - pre_size    : BAT[oid,int]  pre-value of node / and its descendant size,
# - pre_level   : BAT[oid,chr]  pre-value of node / and its level,
# - pre_prop    : BAT[oid,oid]  pre-value of node / and property ID,
# - pre_kind    : BAT[oid,chr]  pre-value of node / and property ID,
#
# - qn_ns        : BAT[oid,str]  property ID / and name space (elements and attributes),
# - qn_loc       : BAT[oid,str]  property ID / and local name (elements and attributes),
# - prop_text    : BAT[oid,str]  property ID / and text,
# - prop_com     : BAT[oid,str]  property ID / and comment,
# - prop_ins     : BAT[oid,str]  property ID / and processing instruction,
# - prop_tgt     : BAT[oid,str]  property ID / and processing instruction target,
#
# - attr_own  : BAT[oid,oid]  attribute ID / pre-value of owner
# - attr_qn   : BAT[oid,oid]  attribute ID / and qname/property ID
# - attr_prop : BAT[oid,oid]  attribute ID / value ID
#
# - prop_val  : BAT[oid,str]  value ID / value of attribute nodes
#
# Global information on persistent stored documents:
# - doc_name    : BAT[oid,str]  document ID / document name
# - doc_height  : BAT[oid,int]  document ID / height of document
# 
# Information on documents/fragments in the working set:
# - PRE_FRAG   : BAT[void,BAT[void,oid]] list of bats with fragments
#                oids for each pre value (copied in element construction)
# - ATTR_FRAG  : BAT[void,BAT[void,oid]] list of bats with fragments
#                oids for each attr value (copied in element/attribute 
#                construction)
# - DOC_LOADED : BAT[void,str] fragment ID / name of document 
#                (starts with 1@0 because WS is first 'loaded' document
# - FRAG       : BAT[void,oid] 0@0 / oid of the newest added fragment
# - WS_FRAG    : BAT[void,oid] enumeration / root-pre values of
#                generated element fragments
# - HEIGTH     : BAT[void,int] enumeration of the fragments / maximal
#                depth of the fragment (starts with 0@0 - WS)

# DEFINITION of constants concerning the data model
const PRE_BASE := 0@0;
const ELEMENT := chr(0);
const TEXT := chr(1);
const COMMENT := chr(2);
const PI := chr(3);
const DOCUMENT := chr(4);

# types in translation
const QNAME := 2;
const BOOL := 3;
const INT := 4;
const DEC := 5;
const DBL := 6;
const STR := 7;
# ATOMIC is not a type but all atomic types
# can be retrieved with 'select(int(nil),ATOMIC)'
const ATOMIC := 31;
# NODE is not a type but all node types
# can be retrieved with 'select(NODE,int(nil))'
const NODE := 32;
const ELEM := 33;
const ATTR := 34;

const WS := 0@0;

# don't switch the values without also changing the order in create_ws
const PRE_SIZE   :=  0;
const PRE_LEVEL  :=  1;
const PRE_PROP   :=  2;
const PRE_KIND   :=  3;
const PRE_FRAG   :=  4;
const QN_NS      :=  5;
const QN_LOC     :=  6;
const PROP_TEXT  :=  7;
const PROP_COM   :=  8;
const PROP_INS   :=  9;
const PROP_TGT   := 10;
const ATTR_OWN   := 11;
const ATTR_QN    := 12;
const ATTR_PROP  := 13;
const ATTR_FRAG  := 14;
const PROP_VAL   := 15;
const DOC_LOADED := 16;
const FRAG       := 17;
const WS_FRAG    := 18;
const HEIGHT     := 19;
const WS_SIZE    := 20; # must be last!
@= define_ws_constants
#define PRE_SIZE     0
#define PRE_LEVEL    1
#define PRE_PROP     2
#define PRE_KIND     3
#define PRE_FRAG     4
#define QN_NS        5
#define QN_LOC       6
#define PROP_TEXT    7
#define PROP_COM     8
#define PROP_INS     9
#define PROP_TGT    10
#define ATTR_OWN    11
#define ATTR_QN     12
#define ATTR_PROP   13
#define ATTR_FRAG   14
#define PROP_VAL    15
#define DOC_LOADED  16
#define FRAG        17
#define WS_FRAG     18
#define HEIGHT      19
#define WS_SIZE     20 /* must be last! */
@mil

PROC add_doc(BAT[void,bat] ws, str name) : BAT[void,bat]
{
    if (not(bat("doc_name").reverse().exist(name)))
        { ERROR("Document %s does not exist\n",name); }
    var docid := str(int(bat("doc_name").reverse().find(name)));
    
    var frag := ws.fetch(DOC_LOADED).uselect(name);
    if (frag.count() = 0)
    {
        ws.fetch(DOC_LOADED).insert(nil,name);
	frag := oid(ws.fetch(DOC_LOADED).count());
	ws.fetch(PRE_SIZE).insert(nil,bat("pre_size" + docid));
	ws.fetch(PRE_LEVEL).insert(nil,bat("pre_level" + docid));
	ws.fetch(PRE_PROP).insert(nil,bat("pre_prop" + docid));
	ws.fetch(PRE_KIND).insert(nil,bat("pre_kind" + docid));
	ws.fetch(PRE_FRAG).insert(nil,fake_project(frag));
	ws.fetch(QN_NS).insert(nil,bat("qn_ns" + docid));
	ws.fetch(QN_LOC).insert(nil,bat("qn_loc" + docid));
	ws.fetch(PROP_TEXT).insert(nil,bat("prop_text" + docid));
	ws.fetch(PROP_COM).insert(nil,bat("prop_com" + docid));
	ws.fetch(PROP_INS).insert(nil,bat("prop_ins" + docid));
	ws.fetch(PROP_TGT).insert(nil,bat("prop_tgt" + docid));
	ws.fetch(ATTR_OWN).insert(nil,bat("attr_own" + docid));
	ws.fetch(ATTR_QN).insert(nil,bat("attr_qn" + docid));
	ws.fetch(ATTR_PROP).insert(nil,bat("attr_prop" + docid));
	ws.fetch(ATTR_FRAG).insert(nil,fake_project(frag));
	ws.fetch(PROP_VAL).insert(nil,bat("prop_val" + docid));
        ws.fetch(FRAG).replace(0@0,frag);
        ws.fetch(HEIGHT).insert(nil,bat("doc_height").find(oid(docid)));
    }
    else
       { ws.fetch(FRAG).replace(0@0,frag.reverse().fetch(0)); }

    return ws;
}
ADDHELP("add_doc", "tsheyar", "July 2004",
"PARAMETERS:\n\
bat(void,bat) - actual working set,\n\
str - the name of the document, which is added\n\
DESCRIPITON:\n\
adds the document to the working set and gives back the\n\
updated working set. (At position FRAG stands the actual\n\
fragment to which the new root is linked.)",
"pathfinder");

PROC create_ws () : BAT[void,bat]
{
    var ws := bat (void,bat).seqbase(PRE_BASE);
    # don't switch the order without also changing the constants
    ws.insert(nil, bat(void,bat).seqbase(PRE_BASE)); # PRE_SIZE
    ws.insert(nil, bat(void,bat).seqbase(PRE_BASE)); # PRE_LEVEL
    ws.insert(nil, bat(void,bat).seqbase(PRE_BASE)); # PRE_PROP
    ws.insert(nil, bat(void,bat).seqbase(PRE_BASE)); # PRE_KIND
    ws.insert(nil, bat(void,bat).seqbase(PRE_BASE)); # PRE_FRAG
    ws.insert(nil, bat(void,bat).seqbase(PRE_BASE)); # QN_NS
    ws.insert(nil, bat(void,bat).seqbase(PRE_BASE)); # QN_LOC
    ws.insert(nil, bat(void,bat).seqbase(PRE_BASE)); # PROP_TEXT
    ws.insert(nil, bat(void,bat).seqbase(PRE_BASE)); # PROP_COM
    ws.insert(nil, bat(void,bat).seqbase(PRE_BASE)); # PROP_INS
    ws.insert(nil, bat(void,bat).seqbase(PRE_BASE)); # PROP_TGT
    ws.insert(nil, bat(void,bat).seqbase(PRE_BASE)); # ATTR_OWN
    ws.insert(nil, bat(void,bat).seqbase(PRE_BASE)); # ATTR_QN
    ws.insert(nil, bat(void,bat).seqbase(PRE_BASE)); # ATTR_PROP
    ws.insert(nil, bat(void,bat).seqbase(PRE_BASE)); # ATTR_FRAG
    ws.insert(nil, bat(void,bat).seqbase(PRE_BASE)); # PROP_VAL
    # offset starts with 1@0 because temporary variables have no name
    ws.insert(nil, bat(void,str).seqbase(1@0));      # DOC_LOADED
    ws.insert(nil, bat(void,oid).seqbase(0@0));      # FRAG
    ws.insert(nil, bat(void,oid).seqbase(0@0));      # WS_FRAG
    ws.insert(nil, bat(void,int).seqbase(0@0));      # HEIGHT

    # add the working set
    ws.fetch(PRE_SIZE).insert(nil, bat(void,int).seqbase(PRE_BASE)); # PRE_SIZE
    ws.fetch(PRE_LEVEL).insert(nil, bat(void,chr).seqbase(PRE_BASE)); # PRE_LEVEL
    ws.fetch(PRE_PROP).insert(nil, bat(void,oid).seqbase(PRE_BASE)); # PRE_PROP
    ws.fetch(PRE_KIND).insert(nil, bat(void,chr).seqbase(PRE_BASE)); # PRE_KIND
    ws.fetch(PRE_FRAG).insert(nil, bat(void,oid).seqbase(PRE_BASE)); # PRE_FRAG
    ws.fetch(QN_NS).insert(nil, bat(void,str).seqbase(PRE_BASE)); # QN_NS
    ws.fetch(QN_LOC).insert(nil, bat(void,str).seqbase(PRE_BASE)); # QN_LOC
    ws.fetch(PROP_TEXT).insert(nil, bat(void,str).seqbase(PRE_BASE)); # PROP_TEXT
    ws.fetch(PROP_COM).insert(nil, bat(void,str).seqbase(PRE_BASE)); # PROP_COM
    ws.fetch(PROP_INS).insert(nil, bat(void,str).seqbase(PRE_BASE)); # PROP_INS
    ws.fetch(PROP_TGT).insert(nil, bat(void,str).seqbase(PRE_BASE)); # PROP_TGT
    ws.fetch(ATTR_OWN).insert(nil, bat(void,oid).seqbase(PRE_BASE)); # ATTR_OWN
    ws.fetch(ATTR_QN).insert(nil, bat(void,oid).seqbase(PRE_BASE)); # ATTR_QN
    ws.fetch(ATTR_PROP).insert(nil, bat(void,oid).seqbase(PRE_BASE)); # ATTR_PROP
    ws.fetch(ATTR_FRAG).insert(nil, bat(void,oid).seqbase(PRE_BASE)); # ATTR_FRAG
    ws.fetch(PROP_VAL).insert(nil, bat(void,str).seqbase(PRE_BASE)); # PROP_VAL
    ws.fetch(FRAG).insert(0@0,nil);
    ws.fetch(HEIGHT).insert(nil,0);

    return ws;
}
ADDHELP("create_ws", "tsheyar", "July 2004",
"DESCRIPITON:\n\
creates a new working set and gives back the reference",
"pathfinder");

# called by compress_properties
PROC compress_val(str batname) : bat[void,oid]
{
    var bat1 := bat(batname);
    bat1.access(BAT_WRITE); # to avoid bat view for 'bat1'
    var grp := CTgroup(bat1);
    var unq := grp.tunique().mark(0@0).reverse();

    { var tmp := unq.join(bat1); bat1.delete().insert(tmp).access(BAT_READ); }

    return grp.join(unq.reverse());
}

# called by compress_properties
PROC compress_val(str batname1, str batname2) : bat[void,oid]
{
    var bat1 := bat(batname1);
    var bat2 := bat(batname2);
    bat1.access(BAT_WRITE); # to avoid bat view for 'bat1'
    bat2.access(BAT_WRITE); # to avoid bat view for 'bat2'
    var grp := CTgroup(bat1).CTgroup(bat2);
    var unq := grp.tunique().mark(0@0).reverse(); # void,new-oid 

    { var tmp := unq.join(bat1); bat1.delete().insert(tmp).access(BAT_READ); }
    { var tmp := unq.join(bat2); bat2.delete().insert(tmp).access(BAT_READ); }
 
    return grp.leftjoin(unq.reverse());
}

PROC compress_properties(str name) : void
{
    if (not(bat("doc_name").reverse().exist(name)))
	{ ERROR("Document %s does not exist\n",name); }
    var docid := str(int(bat("doc_name").reverse().find(name)));

    printf("# \">>> Compress properties of loaded document '%s'\"\n",name);
    
    # eliminate property duplicates in each BAT prop_*
    # (in case of tag-names and PIs every unique combination of
    #  ns:loc, (resp. tgt:ins) gets a property ID)
    
    var pre_kind := bat("pre_kind" + docid);
    var pre_prop := bat("pre_prop" + docid);

    var pre_oldProp := pre_kind.ord_uselect(DOCUMENT).mirror().leftfetchjoin(pre_prop); 
    var _pre := pre_oldProp.mark(0@0).reverse();
    var _newProp := pre_oldProp.reverse().mark(0@0).reverse();

    pre_oldProp := pre_kind.ord_uselect(ELEMENT).mirror().leftfetchjoin(pre_prop);
    var oldProp_newProp := compress_val(("qn_ns" + docid), ("qn_loc" + docid));
    # combine the intermediate results
    var pre_newProp_part := pre_oldProp.leftjoin(oldProp_newProp);
    var _pre_part := pre_newProp_part.mark(0@0).reverse();
    var _newProp_part := pre_newProp_part.reverse().mark(0@0).reverse();
    var tmp := merged_union (_pre, _pre_part, _newProp, _newProp_part);
    pre_oldProp := nil;
    pre_newProp_part := nil;
    _pre_part := nil;
    _newProp_part := nil;
    _pre := tmp.fetch(0);
    _newProp := tmp.fetch(1);
    tmp := nil;
    # use the already compressed QNames to get the new attr qn references
    var attr_oldQn := bat("attr_qn" + docid);
    var attr_newQn := attr_oldQn.leftfetchjoin(oldProp_newProp);
    # FIXME: leftfetchjoin has to be order preserving to allow such a mark
    attr_newQn := attr_newQn.reverse().mark(0@0).reverse();
    # change the persistent attr_qn bat
    attr_oldQn.access(BAT_WRITE).delete().insert(attr_newQn).access(BAT_READ);

    pre_oldProp := pre_kind.ord_uselect(TEXT).mirror().leftfetchjoin(pre_prop); 
    oldProp_newProp := compress_val(("prop_text" + docid));
    # combine the intermediate results
    pre_newProp_part := pre_oldProp.leftjoin(oldProp_newProp);
    _pre_part := pre_newProp_part.mark(0@0).reverse();
    _newProp_part := pre_newProp_part.reverse().mark(0@0).reverse();
    tmp := merged_union (_pre, _pre_part, _newProp, _newProp_part);
    pre_oldProp := nil;
    pre_newProp_part := nil;
    _pre_part := nil;
    _newProp_part := nil;
    _pre := tmp.fetch(0);
    _newProp := tmp.fetch(1);
    tmp := nil;

    pre_oldProp := pre_kind.ord_uselect(COMMENT).mirror().leftfetchjoin(pre_prop); 
    oldProp_newProp := compress_val(("prop_com" + docid));
    # combine the intermediate results
    pre_newProp_part := pre_oldProp.leftjoin(oldProp_newProp);
    _pre_part := pre_newProp_part.mark(0@0).reverse();
    _newProp_part := pre_newProp_part.reverse().mark(0@0).reverse();
    tmp := merged_union (_pre, _pre_part, _newProp, _newProp_part);
    pre_oldProp := nil;
    oldProp_newProp := nil;
    pre_newProp_part := nil;
    _pre_part := nil;
    _newProp_part := nil;
    _pre := tmp.fetch(0);
    _newProp := tmp.fetch(1);
    tmp := nil;

    pre_oldProp := pre_kind.ord_uselect(PI).mirror().leftfetchjoin(pre_prop); 
    oldProp_newProp := compress_val(("prop_ins" + docid), ("prop_tgt" + docid));
    # combine the intermediate results
    pre_newProp_part := pre_oldProp.leftjoin(oldProp_newProp);
    _pre_part := pre_newProp_part.mark(0@0).reverse();
    _newProp_part := pre_newProp_part.reverse().mark(0@0).reverse();
    tmp := merged_union (_pre, _pre_part, _newProp, _newProp_part);
    pre_oldProp := nil;
    pre_newProp_part := nil;
    _pre_part := nil;
    _newProp_part := nil;
    _pre := tmp.fetch(0);
    _newProp := tmp.fetch(1);
    tmp := nil;

    # change the persistent pre_prop bat
    pre_prop.access(BAT_WRITE).delete().insert(_pre.reverse().leftjoin(_newProp)).access(BAT_READ);
    _pre := nil;
    _newProp := nil;

    var attr_prop := bat("attr_prop" + docid);
    oldProp_newProp := compress_val(("prop_val" + docid));
    var attr_newProp := attr_prop.leftfetchjoin(oldProp_newProp);
    oldProp_newProp := nil;
    # FIXME: leftfetchjoin has to be order preserving to allow such a mark
    attr_newProp := attr_newProp.reverse().mark(0@0).reverse();
    # change the persistent attr_prop bat
    attr_prop.access(BAT_WRITE).delete().insert(attr_newProp).access(BAT_READ);
    attr_prop := nil;

    commit();
    print("Compression completed");
}
ADDHELP("compress_properties", "tsheyar", "Juli 2004",
"PARAMETERS:\n\
str document name\n\
DESCRIPITON:\n\
compression of property duplicates",
"pathfinder");

PROC import_doc(str flnm, str name) : void
{
    # create doc_name table in case it does not exist
    if (not(view_bbp_name().reverse().exist("doc_name")))
    {    
        new(oid,str).persists(true).bbpname("doc_name");
        new(oid,int).persists(true).bbpname("doc_height");
    }
    var doc_oid;
    if (bat("doc_name").count() = 0) { doc_oid := 0@0; }
    else { doc_oid := oid(int(bat("doc_name").reverse().max()) + 1); }
    
    if (bat("doc_name").reverse().exist(name))
	{ ERROR("Document %s already exists\n",name); }

    module("ascii_io");

    printf("# \">>> Importing '%s' with name '%s'\"\n",flnm,name);

    # column/line separators (4 columns)
    var seps4 := new (void, str);
    seps4.insert (nil, ",");
    seps4.insert (nil, ",");
    seps4.insert (nil, ",");
    seps4.insert (nil, "\n");

    # column/line separators (3 columns)
    var seps3 := new (void, str);
    seps3.insert (nil, ",");
    seps3.insert (nil, ",");
    seps3.insert (nil, "\n");

    # column/line separators (2 columns)
    var seps2 := new (void, str);
    seps2.insert (nil, ",");
    seps2.insert (nil, "\n");

    # column/line separators (1 column)
    var seps1 := new (void, str);
    seps1.insert (nil, "\n");

    # table pre|size|level|prop|kind 
    var pre := new (void, str);
    pre.insert (nil, "size");
    pre.insert (nil, "level");
    pre.insert (nil, "prop");
    pre.insert (nil, "kind");

    # column types
    var pre_ty := new (void, str);
    pre_ty.insert (nil, "int");
    pre_ty.insert (nil, "sht");
    pre_ty.insert (nil, "oid");
    pre_ty.insert (nil, "sht");

    # table prop|ns|loc
    var tag := new (void, str);
    tag.insert (nil, "ns");
    tag.insert (nil, "loc");

    # column types
    var tag_ty := new (void, str);
    tag_ty.insert (nil, "str");
    tag_ty.insert (nil, "str");

    # table prop|text
    var text := new (void, str);
    text.insert (nil, "text");

    # column types
    var text_ty := new (void, str);
    text_ty.insert (nil, "str");

    # table prop|com
    var com := new (void, str);
    com.insert (nil, "com");

    # column types
    var com_ty := new (void, str);
    com_ty.insert (nil, "str");

    # table prop|tgt|ins
    var pi := new (void, str);
    pi.insert (nil, "tgt");
    pi.insert (nil, "ins");

    # column types
    var pi_ty := new (void, str);
    pi_ty.insert (nil, "str");
    pi_ty.insert (nil, "str");

    # table att|own|qn|prop
    var att := new (void, str);
    att.insert (nil, "own");
    att.insert (nil, "qn");
    att.insert (nil, "prop");

    # column types
    var att_ty := new (void, str);
    att_ty.insert (nil, "oid");
    att_ty.insert (nil, "oid");
    att_ty.insert (nil, "oid");

    # table prop|val
    var att_val := new (void, str);
    att_val.insert (nil, "val");

    # column types
    var att_val_ty := new (void, str);
    att_val_ty.insert (nil, "str");

    # load table pre|size|level|prop|kind 
    var tmp := load(pre, seps4, pre_ty, flnm + ".pre", -1);
    
    bat("doc_name").insert(doc_oid, name);
    bat("doc_height").insert(doc_oid, tmp.find("level").max() + 1);
    var docid := str(int(doc_oid));
    doc_oid := nil;

    tmp.find("size").persists(true).bbpname("pre_size" + docid);
    tmp.find("level").[chr]().copy().persists(true).bbpname("pre_level" + docid);
    tmp.find("prop").persists(true).bbpname("pre_prop" + docid);
    tmp.find("kind").[chr]().copy().persists(true).bbpname("pre_kind" + docid);

    # load table prop|ns|loc
    tmp := load(tag, seps2, tag_ty, flnm + ".qn", -1);
    tmp.find("ns").persists(true).bbpname("qn_ns" + docid);
    tmp.find("loc").persists(true).bbpname("qn_loc" + docid);

    # load table prop|text
    tmp := load(text, seps1, text_ty, flnm + ".text", -1);
    tmp.find("text").persists(true).bbpname("prop_text" + docid);

    # load table prop|com
    tmp := load(com, seps1, com_ty, flnm + ".com", -1);
    tmp.find("com").persists(true).bbpname("prop_com" + docid);

    # load table prop|tgt|ins
    tmp := load(pi, seps2, pi_ty, flnm + ".pi", -1);
    tmp.find("tgt").persists(true).bbpname("prop_tgt" + docid);
    tmp.find("ins").persists(true).bbpname("prop_ins" + docid);

    # load table att|own|qn|prop
    tmp := load(att, seps3, att_ty, flnm + ".@", -1);
    tmp.find("own").persists(true).bbpname("attr_own" + docid);
    tmp.find("qn").persists(true).bbpname("attr_qn" + docid);
    tmp.find("prop").persists(true).bbpname("attr_prop" + docid);

    # load table prop|val
    tmp := load(att_val, seps1, att_val_ty, flnm + ".@val", -1);
    tmp.find("val").persists(true).bbpname("prop_val" + docid);

    # save all persistent BATs
    commit();
    print("Document successfully imported");

    if (((bat("pre_kind" + docid).select(ELEMENT).count() +
          bat("attr_own" + docid).count()) = 
         bat("qn_ns" + docid).count())
        and
	(bat("pre_kind" + docid).select(TEXT).count() =
        bat("prop_text" + docid).count()))
    {
        printf("# \"The properties of the file '%s' are propably not compressed!\"\n", flnm);
	printf("# \"You can compress the loaded instance '%s' with: 'compress_properties(\"%s\");'\"\n", name, name);
    }
}
ADDHELP("import_doc", "rode", "Nov 2003",
"PARAMETERS:\n\
str file name (\"/anypath/foo.xml\" if loader output is located in \"/anypath/foo.xml.*\")\n\
str document name in database\n\
DESCRIPITON:\n\
Import files generated by the loader as persistent document.",
"pathfinder");

PROC delete_doc(str name) : void
{
    if (not(bat("doc_name").reverse().exist(name)))
	{ ERROR("Document %s does not exist\n",name); }
    var doc_oid := bat("doc_name").reverse().find(name);
    
    bat("doc_name").delete(doc_oid);
    bat("doc_height").delete(doc_oid);
    
    var docid := str(int(doc_oid));
    bat("pre_size" + docid).persists(false);
    bat("pre_level" + docid).persists(false);
    bat("pre_prop" + docid).persists(false);
    bat("pre_kind" + docid).persists(false);
    bat("qn_ns" + docid).persists(false);
    bat("qn_loc" + docid).persists(false);
    bat("prop_text" + docid).persists(false);
    bat("prop_com" + docid).persists(false);
    bat("prop_tgt" + docid).persists(false);
    bat("prop_ins" + docid).persists(false);
    bat("attr_own" + docid).persists(false);
    bat("attr_qn" + docid).persists(false);
    bat("attr_prop" + docid).persists(false);
    bat("prop_val" + docid).persists(false);
    
    commit();
}
ADDHELP("delete_doc", "tsheyar", "July 2004",
"PARAMETERS:\n\
str document name\n\
DESCRIPITON:\n\
delete the persistent BATS that store the document.",
"pathfinder");

PROC delete_all_docs() : void
{
    if (not(view_bbp_name().reverse().exist("doc_name")))
	{ print("no documents to delete"); }
    else {
        bat("doc_name")@batloop () {
            delete_doc($t);
        }
#        bat("doc_name").persists(false);
#        bat("doc_height").persists(false);
#        commit();
    }
}
ADDHELP("delete_all_docs", "tsheyar", "July 2004",
"DESCRIPITON:\n\
deletes all persistent document BATs that store xml documents.",
"pathfinder");


#############################################
# XML print functions / XML Serialization
#
# - xml_print(BAT[void,bat] ws, str docname)
# - xml_print(BAT[void,bat] ws, BAT[void,oid] item, BAT[void,int] kind,
#             BAT[void,int] int_values, BAT[void,dbl] dbl_values,
#     	      BAT[void,dbl] dec_values, BAT[void,str] str_values )
#
# The xml_print function serializes the information stored in the
# collection of BATs. Thus, it restores fragments of the textual
# representation of the XML-document.
# xml_print() can be either called with a working set and a document
# name of a loaded document or prints the result or related to a specific
# context set. In the latter case, for each node within the context
# set, the node itself and its descendant fragment is printed (even if
# this means to repeatedly print the same information, when context 
# nodes relate to each other on the descendant axis).
#

PROC saxquery(str q) : void { xquery("sax",q); }

PROC xmlquery(str q) : void { xquery("xml",q); }

PROC attr_print(oid pre, oid frag, BAT[void,bat] ws) : void
{
    var attr_list := ws.fetch(ATTR_OWN).fetch(frag).uselect(pre);
    var name;
    attr_list@batloop ()
    {
	var attr_frag := ws.fetch(ATTR_FRAG).fetch(frag).fake_fetch($h);
	var attr_prop := ws.fetch(ATTR_PROP).fetch(frag).fetch($h);
	var attr_qn := ws.fetch(ATTR_QN).fetch(frag).fetch($h);
	var attr_ns := ws.fetch(QN_NS).fetch(attr_frag).fetch(attr_qn);
	var attr_loc := ws.fetch(QN_LOC).fetch(attr_frag).fetch(attr_qn);
	var attr_val := ws.fetch(PROP_VAL).fetch(attr_frag).fetch(attr_prop);
	# recompose name
	name := attr_ns;
	if (name != "") { name :+= ":"; }
	name :+= attr_loc;
	# TODO: distinguish quot and apos enclosed attributes
        printf(" %s=\"%s\"", name, attr_val);
    }
}

PROC node_print(oid pre, oid frag, BAT[void,bat] ws, BAT[oid,str] S) : void
{
    var kind := ws.fetch(PRE_KIND).fetch(frag).fetch(pre);
    var elem_frag := ws.fetch(PRE_FRAG).fetch(frag).fake_fetch(pre);
    var elem_prop := ws.fetch(PRE_PROP).fetch(frag).fetch(pre);
    
	
    if (kind = ELEMENT)
    {    
	# recompose tag name
	var tag := ws.fetch(QN_NS).fetch(elem_frag).fetch(elem_prop);
	if (tag != "") { tag :+= ":"; }
	tag :+=  ws.fetch(QN_LOC).fetch(elem_frag).fetch(elem_prop);
	
	var size := ws.fetch(PRE_SIZE).fetch(frag).fetch(pre);

	if (size = 0) {
		printf("<%s",tag);
		attr_print(pre, frag, ws);
		printf("/>");
	}
        else {
        	printf("<%s",tag);
		attr_print(pre, frag, ws);
		printf(">");
		# push node on S
		S.insert(oid(int(pre) + ws.fetch(PRE_SIZE).fetch(frag).fetch(pre)), tag);
	}
    }
    else { if (kind = TEXT)
        { printf("%s", ws.fetch(PROP_TEXT).fetch(elem_frag).fetch(elem_prop)); }
    else { if (kind = COMMENT)
        { printf("<!--%s-->", ws.fetch(PROP_COM).fetch(elem_frag).fetch(elem_prop)); }
    else { if (kind = PI)
        { printf("<?%s %s?>", ws.fetch(PROP_INS).fetch(elem_frag).fetch(elem_prop),
			      ws.fetch(PROP_TGT).fetch(elem_frag).fetch(elem_prop)); }
    else { if (kind = DOCUMENT)
	{ S.insert(oid(int(pre) + ws.fetch(PRE_SIZE).fetch(frag).fetch(pre)), ""); }
	 }}}}
}

PROC endtag_print(oid pre, BAT[oid,str] S) : void
{
    # pseudocode of this procedure:
    # while (pre > S.top()) print(name(S.pop()));
    var i := S.count() - 1;
    var popped := S.reverse().select(oid(nil), pre, true, false).reverse();
    var poplimit := i - popped.count();
    var tag;
    
    while (i > poplimit)
    {
        # the 'tag != ""'-check is needed, to suppress output
        # if a document node is popped from the stack
        tag := S.fetch(i);
	if (tag != "") { printf("</%s>", tag); }
	i :-= 1;
    }
    
    S.delete(popped);
}

PROC xml_print(BAT[void,bat] ws, 
	       BAT[void,oid] item,
	       BAT[void,int] kind,
	       BAT[void,int] int_values,
	       BAT[void,dbl] dbl_values,
	       BAT[void,dbl] dec_values,
	       BAT[void,str] str_values) : void
{
    if (item.count() = 0) { printf("()\n"); return; }
    
    # line feed
    printf("\n");

    var frags := kind.get_fragment();
    var types := kind.get_types();

    # node stack (storing pre+size and the name of a node)
    var S := new(oid,str);
    
    # cursor moving over the pre values
    var pre;
    var lastpre;
    var format_last := item.reverse().max();

    if (is_fake_project(kind)) {
        @:item_batloop(0)@
    } else {
        @:item_batloop($h)@
    }
@= item_batloop
    # for all nodes in the context set do ...
    item@batloop () {
        var type_ := types.fetch(@1);
	var frag := frags.fetch(@1);
	if (type_ = INT) {
		printf("%i\n", int_values.fetch($t));
	}
	else if (type_ = DBL) {
		printf("%d\n", dbl_values.fetch($t));
	}
	else if (type_ = DEC) {
		printf("%d\n", dec_values.fetch($t));
	}
	else if (type_ = STR) {
		printf("\"%s\"\n", str_values.fetch($t));
	}
	else if (type_ = ATTR)
	{
		var attr_frag := ws.fetch(ATTR_FRAG).fetch(frag).fake_fetch($t);
		var attr_prop := ws.fetch(ATTR_PROP).fetch(frag).fetch($t);
		var attr_qn := ws.fetch(ATTR_QN).fetch(frag).fetch($h);
		var attr_ns := ws.fetch(QN_NS).fetch(attr_frag).fetch(attr_qn);
		var attr_loc := ws.fetch(QN_LOC).fetch(attr_frag).fetch(attr_qn);
		var attr_val := ws.fetch(PROP_VAL).fetch(attr_frag).fetch(attr_prop);
		if (attr_ns = "")
			printf("%s='%s'\n", attr_loc, attr_val);
		else 
			printf("%s:%s=\"%s\"\n", attr_ns, attr_loc, attr_val);
	}
	else if (type_ = ELEM)
	{
		pre := $t;
        	lastpre := oid(int(pre) + ws.fetch(PRE_SIZE).fetch(frag).fetch(pre));

		# cheat a little bit to get the same output like Galax
    		if (ws.fetch(PRE_KIND).fetch(frag).fetch(pre) = TEXT) {
    			var elem_frag := ws.fetch(PRE_FRAG).fetch(frag).fake_fetch(pre);
			var elem_prop := ws.fetch(PRE_PROP).fetch(frag).fetch(pre);
			printf("text \{\"");
			printf("%s", ws.fetch(PROP_TEXT).fetch(elem_frag).fetch(elem_prop));
			printf("\"\}");
		}
		else {
			# missing "do...while"-loops in mil ... 
			node_print(pre, frag, ws, S);
			pre := oid(int(pre) + 1);
	        	endtag_print(pre, S);
	
	        	while ((S.count() > 0) and (pre <= lastpre))
			{
			    node_print(pre, frag, ws, S);
			    pre := oid(int(pre) + 1);
        		    endtag_print(pre, S);
		        }
		}
	}
	else 
		printf("ERROR: not supported type '%i'.\n", type_);

	if ($h != format_last) printf(",");
	# line feed
	printf("\n");
    }
@mil
}
ADDHELP("xml_print", "tsheyar", "Sep 2004",
"PARAMETERS:\n\
BAT[void,bat] working_set,\n\
BAT[void,oid] item,\n\
BAT[void,int] kind,\n\
BAT[void,int] int_values,\n\
BAT[void,dbl] dbl_values,\n\
BAT[void,dbl] dec_values,\n\
BAT[void,str] str_values\n\
DESCRIPITON:\n\
Print XML-fragment enclosed by each context node.",
"pathfinder");

@(
PROC xml_print(BAT[void,bat] ws) : void
{
    xml_print(ws, 
	      ws.fetch(PRE_SIZE).fetch(0).mirror(),
              fake_project(0@0).get_kind(ELEM),
	      bat(void,int),
              bat(void,dbl),
              bat(void,dbl),
              bat(void,str));
}
ADDHELP("xml_print", "tsheyar", "Sep 2004",
"DESCRIPITON:\n\
Print all XML-fragmets in the working set.",
"pathfinder");
@)

PROC xml_print(BAT[void,bat] ws, str name) : void
{
    if (not(ws.fetch(DOC_LOADED).reverse().exist(name)))
	{ ERROR("Document %s does not exist in working set\n",name); }
    var docid := int(ws.fetch(DOC_LOADED).reverse().find(name));
    xml_print(ws, 
	      ws.fetch(PRE_SIZE).fetch(docid).slice(0,0).mirror(),
              fake_project(oid(docid)).get_kind(ELEM),
	      bat(void,int),
              bat(void,dbl),
              bat(void,dbl),
              bat(void,str));
}
ADDHELP("xml_print", "tsheyar", "Sep 2004",
"PARAMETERS:\n\
BAT[void,bat] working_set,\n\
str document_name\n\
DESCRIPITON:\n\
Print loaded XML-document with the specified name.",
"pathfinder");


@mil
#############################################
# MIL WRAPPER for AXIS STEPS 
#
# In order to simplify the invocation of the axis steps functions, this
# interface provides...
# 

@(
@:step(descendant,descendant,scj_desc,,@:sizes_code@,,)@
@:step(descendant_or_self,descendant-or-self,scj_descorself,,@:sizes_code@,,)@
@)

@:wrap(descendant)@
@:wrap(descendant_or_self)@

@:step(ancestor,ancestor,scj_anc,,@:sizes_code@,,)@
@:step(ancestor_or_self,ancestor-or-self,scj_ancorself,,@:sizes_code@,,)@

@(
@:step(child,child,lev_child,@:level_intro@,@:level_code@,,)@
@)

@:wrap(child)@

@:step(parent,parent,lev_parent,@:level_intro@,@:level_code@,,)@
@:step(following_sibling,following-sibling,lev_fs,@:level_intro@,@:level_code@,,)@
@:step(preceding_sibling,preceding-sibling,lev_ps,@:level_intro@,@:level_code@,,)@

@:step(following,following,following_void,,@:sizes_code@,@:foll_prec_code@,@:doc_pre@)@
@:step(preceding,preceding,preceding_void,,@:sizes_code@,@:foll_prec_code@,@:doc_pre@)@

@= wrap
proc @1 (BAT[void,oid] iter, BAT[void,oid] ctx, oid frag, BAT[void,bat] ws) : BAT[oid,oid] {
	return ll_@1 (iter, ctx, frag, ws);
}
ADDHELP("@1", "tsheyar", "Sep 2004",
"PARAMETERS:\n\
BAT[void,oid] iter (grouping relation)\n\
BAT[void,oid] ctx (context set)\n\
oid frag (the current fragment of the ws)\n\
BAT[void,bat] ws (working set)\n\
DESCRIPITON:\n\
returns all nodes on the @1 axis of the ctx-nodes duplicate free for each group.",
"pathfinder");
@
@
# use size concept
@= sizes_code
pre_sizes
@
# use level concept
@= level_intro
    var pre_levels := ws.fetch(PRE_LEVEL).fetch(frag);
@
@= level_code
pre_levels
@
# code for following and preceding steps
@= foll_prec_code
    # dirty code to make possible, that old scj still works
    var doc_pre;
    if (frag = 0@0)
        { doc_pre := ws.fetch(WS_FRAG); }
    else
        { doc_pre := bat(void,oid).seqbase(0@0).insert(nil,1@0); }
@
@= doc_pre
doc_pre,
@

@= step
PROC @1(BAT[void,oid] iter, BAT[void,oid] ctx, oid frag, BAT[void,bat] ws) : BAT[oid,oid]
{
    var pre_sizes := ws.fetch(PRE_SIZE).fetch(frag);
    @4
    var heights := ws.fetch(HEIGHT).fetch(frag);

    var unq := {count}(iter.reverse(), iter.tunique());

    var result := bat(oid,oid);
    var offset := 0;
    var ctx_slice;

    @6

    unq@batloop () {
	ctx_slice := ctx.slice(offset, offset + $t - 1).reverse().mark(nil);
	ctx_slice.chk_order(false); # have to check because step expects it sorted
        result.insert(@3
                              (@5,
                               ctx_slice,
			       @7
                               heights,
                               pre_sizes.count())
	              .project($h).reverse());
        offset := offset + $t;
    }
    return result.access(BAT_READ);
#    return @2(Tpre_size, ctx, Theight, Tpre_size.count());
}
ADDHELP("@1", "tsheyar", "Sep 2004",
"PARAMETERS:\n\
BAT[void,any] iter (grouping relation)\n\
BAT[void,any] ctx (context set)\n\
oid frag (the current fragment of the ws)\n\
BAT[void,bat] ws (working set)\n\
DESCRIPITON:\n\
returns all nodes on the @2 axis of the ctx-nodes duplicate free for each group.",
"pathfinder");
@

@mil
@:loop_lifted_scj_step1(ancestor)@
@:loop_lifted_scj_step1(ancestor_or_self)@
@:loop_lifted_scj_step1(child)@
@:loop_lifted_scj_step1(descendant)@
@:loop_lifted_scj_step1(descendant_or_self)@
@:loop_lifted_scj_step1(following)@
@:loop_lifted_scj_step1(following_sibling)@
@:loop_lifted_scj_step1(parent)@
@:loop_lifted_scj_step1(preceding)@
@:loop_lifted_scj_step1(preceding_sibling)@
@
#==================================================================
# expansions of the loop lifted scj
@= comma
,
@
# kind argument
@= kind
@:comma@chr kind
@
# tagname argument
@= tagname_ns
@:comma@str ns
@
@= tagname_loc
@:comma@str loc
@
@= tagname_nsloc
@:comma@str ns@:comma@ str loc
@
# code for variable initialisation
@= ns_loc_vars
var tmp;
var pre_frag;
var pre_prop;
var qn_loc;
var qn_ns;
var kind := ELEMENT;
var pre_kind;
@
@= loc_vars
var tmp;
var pre_frag;
var pre_prop;
var qn_loc;
var kind := ELEMENT;
var pre_kind;
@
@= ns_vars
var tmp;
var pre_frag;
var pre_prop;
var qn_ns;
var kind := ELEMENT;
var pre_kind;
@
@= kind_vars
var tmp;
var pre_kind;
@

# code for tagname testing
@= ns_loc_code
		@:kind_code(@1,@2)@
		pre_frag := result@1_item.fake_leftfetchjoin(ws.fetch(PRE_FRAG).fetch(@2));
		pre_prop := result@1_item.leftfetchjoin(ws.fetch(PRE_PROP).fetch(@2));
		qn_loc := mposjoin(pre_prop, pre_frag, ws.fetch(QN_LOC));
		qn_ns := mposjoin(pre_prop, pre_frag, ws.fetch(QN_NS));
		pre_frag := nil;
		pre_prop := nil;
		tmp := qn_ns.ord_uselect(ns).mirror();
		tmp := tmp.leftjoin(qn_loc).ord_uselect(loc).mark(0@0).reverse();
		qn_loc := nil;
		qn_ns := nil;
		@:mapping_code(@1)@
@
@= loc_code
		@:kind_code(@1,@2)@
		pre_frag := result@1_item.fake_leftfetchjoin(ws.fetch(PRE_FRAG).fetch(@2));
		pre_prop := result@1_item.leftfetchjoin(ws.fetch(PRE_PROP).fetch(@2)); 
		qn_loc := mposjoin(pre_prop, pre_frag, ws.fetch(QN_LOC));
		pre_frag := nil;
		pre_prop := nil;
		tmp := qn_loc.ord_uselect(loc).mark(0@0).reverse();
		qn_loc := nil;
		@:mapping_code(@1)@
@
@= ns_code
		@:kind_code(@1,@2)@
		pre_frag := result@1_item.fake_leftfetchjoin(ws.fetch(PRE_FRAG).fetch(@2));
		pre_prop := result@1_item.leftfetchjoin(ws.fetch(PRE_PROP).fetch(@2));
		qn_ns := mposjoin(pre_prop, pre_frag, ws.fetch(QN_NS));
		pre_frag := nil;
		pre_prop := nil;
		tmp := qn_ns.ord_uselect(ns).mark(0@0).reverse();
		qn_ns := nil;
		@:mapping_code(@1)@
@
@= kind_code
		pre_kind := result@1_item.leftfetchjoin(ws.fetch(PRE_KIND).fetch(@2));
		tmp := pre_kind.ord_uselect(kind).mark(0@0).reverse();
		pre_kind := nil;
		@:mapping_code(@1)@
@
@= mapping_code
		result@1_iter := tmp.leftfetchjoin(result@1_iter);
		result@1_item := tmp.leftfetchjoin(result@1_item);
		tmp := nil;
@

# expanding the scj for the different tests
@= loop_lifted_scj_step1
@:loop_lifted_scj_step2(@1,,,,,)@
@:loop_lifted_scj_step2(@1,_with_kind_test,@:kind@,@:kind_vars@,@:kind_code(,uniqueFrag.reverse().fetch(0))@,@:kind_code(_part,$h))@
@:loop_lifted_scj_step2(@1,_with_ns_test,@:tagname_ns@,@:ns_vars@,@:ns_code(,uniqueFrag.reverse().fetch(0))@,@:ns_code(_part,$h))@
@:loop_lifted_scj_step2(@1,_with_loc_test,@:tagname_loc@,@:loc_vars@,@:loc_code(,uniqueFrag.reverse().fetch(0))@,@:loc_code(_part,$h))@
@:loop_lifted_scj_step2(@1,_with_nsloc_test,@:tagname_nsloc@,@:ns_loc_vars@,@:ns_loc_code(,uniqueFrag.reverse().fetch(0))@,@:ns_loc_code(_part,$h))@
@
#==================================================================
# actual definition of the scj proc
@= loop_lifted_scj_step2
proc loop_lifted_@1_step@2 (bat[void, oid] iter, bat[void, oid] item, bat[void, oid] frag, bat[void, bat] ws@3) : bat[void,bat]
{
    # handle empty results correctly
    if (iter.count() = 0) {
	var empty := bat(void,oid).seqbase(0@0).access(BAT_READ);
	return bat(void,bat).seqbase(0@0)
			    .insert(nil,empty)
			    .insert(nil,empty)
			    .insert(nil,empty)
			    .access(BAT_READ);
    }

    var result;
    var result_iter;
    var result_item;
    var result_frag;
    # variable initialisation for tests
    @4 

    var uniqueFrag := frag.tunique().sort();
    if (uniqueFrag.count() = 1) {
	iter.chk_order(FALSE);
	item.chk_order(FALSE);
	result := @1 (iter, item, frag.fetch(0), ws);
	result_iter := result.mark(0@0).reverse();
	result_item := result.reverse().mark(0@0).reverse();
	# test
	@5
        result_frag := fake_project(uniqueFrag.reverse().fetch(0));
    } else {
        var result_part_frag := frag.ord_uselect(uniqueFrag.reverse().fetch(0)).mark(0@0).reverse();
        var result_part_iter := result_part_frag.leftfetchjoin(iter);
        var result_part_item := result_part_frag.leftfetchjoin(item);
	result_part_iter.chk_order(FALSE);
	result_part_item.chk_order(FALSE);
        var result := @1 (result_part_iter, result_part_item, uniqueFrag.reverse().fetch(0), ws);
        result_part_iter := nil;
        result_part_item := nil;
        result_part_frag := nil;

	result_iter := result.mark(0@0).reverse();
	result_item := result.reverse().mark(0@0).reverse();
	# test
	@5
        result_frag := result_iter.project(uniqueFrag.reverse().fetch(0));

        var res_mu;

	uniqueFrag.slice(1,uniqueFrag.count() - 1)@batloop () {
            result_part_frag := frag.ord_uselect($h).mark(0@0).reverse();
            result_part_iter := result_part_frag.leftfetchjoin(iter);
            result_part_item := result_part_frag.leftfetchjoin(item);
  	    result_part_iter.chk_order(FALSE);
	    result_part_item.chk_order(FALSE);
            result := @1 (result_part_iter, result_part_item, $h, ws);
            result_part_iter := nil;
            result_part_item := nil;
            result_part_frag := nil;

            result_part_iter := result.mark(0@0).reverse();
            result_part_item := result.reverse().mark(0@0).reverse();

            # test
            @6
            result_part_frag := result_part_iter.project($h);

            res_mu := merged_union(result_iter, result_part_iter,
				   result_item, result_part_item,
				   result_frag, result_part_frag);
            result_part_iter := nil;
            result_part_item := nil;
            result_part_frag := nil;
            result_iter := res_mu.fetch(0);
            result_item := res_mu.fetch(1);
            result_frag := res_mu.fetch(2);
            res_mu := nil;
        }
    }
    
    result_iter.access(BAT_READ);
    result_item.access(BAT_READ);
    result_frag.access(BAT_READ);
    var result_scj := bat(void,bat).seqbase(0@0);
    result_scj.insert(nil,result_iter);
    result_scj.insert(nil,result_item);
    result_scj.insert(nil,result_frag);

    return result_scj.access(BAT_READ);
}
@

@h
#ifndef PATHFINDER_H
#define PATHFINDER_H

#include "pathfinder.proto.h"

@:define_ws_constants@

#endif

@c
#include "pathfinder.h"

/*
 * Worker for the ebv() function.
 */
BAT *
BATebv (BAT *b)
{
    BAT *ret = NULL;    /* return value */
    BUN p = 0, q = 0;   /* BUN variables for iteration */
    int bunsz;          /* BUN size used for iteration (BATloopFast) */
    oid old;            /* Last head value we had seen */
    bit val;            /* Boolean result value that belongs to `old' */
    size_t cnt = 0;     /* "guess" of result cardinality */
    bit trivial;        /* indicator for "trivial" result properties */

    /* Just in case BATebv might be called from elsewhere than CMDebv:
     * check, that b in not NULL.
     */
    BATcheck(b, "BATebv");
    /* Input must be sorted by head value, tail must be boolean */
    ERRORcheck (!(BAThordered(b)&1), "BATebv: head of BAT must be sorted.\n");
    /* Needed only, if you want to disallow TYPE_void, 
     * which also matches the oid requirement of the signature;
     * or if BATebv could be called from somewhere/one else than CMDebv.
     */
    ERRORcheck (!(b->htype == TYPE_oid),
                "BATebv: head of BAT must have oid type.\n");
@(
    /* Not needed, if BATebv is only called from CMDebv,
     * since the signature only allows bit-tailed BATs.
     */
    ERRORcheck (!(b->ttype == TYPE_bit),
                "BATebv: tail of BAT must have bit type.\n");
@)

    /* Try to "guess" the result cardinality:
     * on the one hand, we don't want too allocate (far) too much memory;
     * on the other hand, we want to avoid BATextends (i.e., (large) memcpy's),
     * that occur if we initially allow too little space ... 
     * Obviously, BATcount(b) is the upper limit;
     * lower limit is just a "wild guess"...
     */
    if (BAThkey (b))
        cnt = BATcount (b);
    else
        cnt = MIN (200, BATcount (b));

    /* Create return BAT */
    ret = BATnew (b->htype, TYPE_bit, cnt);
    if (!ret)
        return ret;

    /*
     * Iterate over the input BAT.
     * Whenever we see a head value the first time, we record its tail
     * value in val. If we see the same head value a second (third,...)
     * time, we re-set val to false. When we reach the next head
     * value, (old, val) will be the correct BUN for the last group.
     */

    /* Initialize, ... */
    bunsz = BUNsize (b);
    p = BUNfirst (b);
    old = *(oid *) BUNhloc (b, p);
    val = *(bit *) BUNtloc (b, p);
    /* ... skip first, ... */
    p += bunsz;
    /* ... and process the rest. */
    for(q = BUNlast(b); p < q; p += bunsz) {
    	oid *head = (oid *) BUNhloc (b, p);
        if (*head == old)
            val = FALSE;
        else {
            bunfastins (ret, &old, &val);
            old = *head;
            val = *(bit *) BUNtloc (b, p);
        }
    }
    /* Don't forget to produce the last BUN. */
    bunfastins (ret, &old, &val);
    
    /* Set result properties ... */
    cnt = BATcount (ret);
    trivial = (cnt < 2) ? TRUE : FALSE;
    /* ... head ... */
    BATkey (ret, TRUE);
    ret->hsorted = GDK_SORTED;
    ret->hdense = trivial;
    if (trivial == TRUE) {
        if (cnt == 0)
            BATseqbase (ret, (oid)0); /* does not really matter */
        else /* (cnt == 1) */
            BATseqbase (ret, old);
    }
    /* ... tail */
    BATkey (BATmirror(ret), trivial);
    ret->tsorted = trivial;
    ret->tdense = FALSE;

    return ret;

/* required by bunfastins macro */
bunins_failed:
    BBPreclaim(b);
    return NULL;
}

/*
 * Implementation of ebv(). Basically just calls BATebv().
 */
int
CMDebv (BAT **result, BAT *b)
{
    return (*result = BATebv (b)) ? GDK_SUCCEED : GDK_FAIL;
}

