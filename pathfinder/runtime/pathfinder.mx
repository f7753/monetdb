# pathfinder.mx
#
# Monet runtime support for the Pathfinder XQuery compiler
#
# Copyright Notice:
# -----------------
# 
# The contents of this file are subject to the MonetDB Public
# License Version 1.0 (the "License"); you may not use this file
# except in compliance with the License. You may obtain a copy of
# the License at http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
# 
# Software distributed under the License is distributed on an "AS
# IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
# implied. See the License for the specific language governing
# rights and limitations under the License.
# 
# The Original Code is the ``Pathfinder'' system. The Initial
# Developer of the Original Code is the Database & Information
# Systems Group at the University of Konstanz, Germany. Portions
# created by U Konstanz are Copyright (C) 2000-2004 University
# of Konstanz. All Rights Reserved.
#
# Contributors:
#         Torsten Grust <torsten.grust@uni-konstanz.de>
#         Maurice van Keulen <M.van.Keulen@bigfoot.com>
#         Jens Teubner <jens.teubner@uni-konstanz.de>
#
# $Id$
#

@f pathfinder
@a Torsten Teggy Grust
@a Maurice van Keulen
@a Henning Rode
@a Jan Flokstra
@a Jens Teubner
@a Stefan Manegold
@a Peter Boncz 

@t Runtime Support for the Pathfinder XQuery Compiler

@m
.MODULE pathfinder;

.USE xtables;
.USE streams;
.USE monettime;
.USE lock;

@- Path steps (staircase join) 
@m
@:prec_foll(following)@
@:prec_foll(preceding)@

@= prec_foll
.COMMAND @1_void (BAT[void,int] pre_size,
               BAT[oid,any] ctx,
               BAT[void,oid] doc_pre,
	       int height,
               int upperbound) : BAT[oid,void] = PF@1_void;
"PARAMETERS
  pre_size: the complete size BAT (preorder rank, size)
  ctx: context node sequence (preorder rank, *)
  doc_pre: table of document fragments (doc id, preorder start value)
  height: document height
  upperbound: upperbound for size of result context node sequence
DESCRIPTION
axis step evaluation on the @1 axis from the given context."
@m
@:scj_cmd(descorself,descendant-or-self)@
@:scj_cmd(desc,descendant)@
@:scj_cmd(ancorself,ancestor-or-self)@
@:scj_cmd(anc,ancestor)@

@= scj_cmd
.COMMAND scj_@1(BAT[void,int] pre_size,
                BAT[oid,any] ctx,
                int height,
                int upperbound): BAT[oid,void] = PFscj_@1_void;
"PARAMETERS
  pre_size: the complete size BAT (preorder rank, size)
  ctx: context node sequence (preorder rank, *)
  height: document height
  upperbound: upperbound for size of result context node sequence
DESCRIPTION
axis step evaluation on the @2 axis from the given context."
@m
@:ll_cmd(descendant)@
@:ll_cmd(descendant_or_self)@
@:ll_cmd(child)@

@= ll_cmd
.COMMAND ll_@1(BAT[void,oid] iter,
                   BAT[void,oid] ctx,
                   BAT[void,int] pre_size,
                   BAT[oid,oid] cands,
                   int height,
                   bit one_iter, bit one_ctx,
                   oid min_iter, oid max_iter): BAT[oid,oid] = PFll_@1;
"PARAMETERS:
BAT[void,oid] iter (grouping relation; sorted on tail within each ctx group)
BAT[void,oid] ctx (context set; sorted on tail)
BAT[void,int] pre_size (from the working set)
BAT[oid,oid]  cands (sorted list of result candidate OIDs in the tail)
int           height (height of the document)
bit           one_iter (only one iter?)
bit           one_ctx  (only one ctx node, i.e., the same for all iters?)
oid           min_iter,max_iter (smallest and largest iter id)
DESCRIPITON:
returns all nodes on the @1 axis of the ctx-nodes duplicate free for each group."
@m
@:lev_cmd(child,child)@
@:lev_cmd(parent,parent)@
@:lev_cmd(fs,following-sibling)@
@:lev_cmd(ps,preceding-sibling)@

@= lev_cmd
.COMMAND lev_@1(BAT[void,chr] pre_level,
                BAT[oid,any] ctx,
		int height,
                int upperbound) : BAT[oid,void] = PFlev_@1;
"PARAMETERS
  pre_level: the complete level BAT (preorder rank, level)
  ctx: context node sequence (preorder rank, *)
  height: document height
  upperbound: upperbound for size of result context node sequence
DESCRIPTION
axis step evaluation on the @2 axis from the given context."

@- utility commands
@m
.COMMAND ebv(BAT[oid, bit] b) : BAT[oid, bit] = CMDebv;
"PARAMETERS
BAT[oid, bit], sorted on head values.
DESCRIPTION:
This is a helper function to implement the XQuery ``effective boolean\n
value.'' Grouped by the head values, it will look at the tail values.\n
If for a head value there is exactly one BUN whose tail equals `true',\n
the result for this group will be `true' as well. In any other case\n
(a single `false' BUN, or multiple BUNs for this group), a `false'\n
tuple will be in the result for this group."

.COMMAND pflock() : lock = CMDpflock;
 "provide a pointer to the runtime lock"

.COMMAND lastmod_time(str filename) : timestamp = CMDlastmod_time;
 "return the last modification time of a file"

@- xquery execution commands (xquery.mx)
@m
.COMMAND xquery(str, str) : void = CMDxquery;
 "xquery execution. usage: xquery(\"xml\", str)"
.BUILTIN xquery_server(Stream in, Stream out) : void = CMDxquery_server;
 "read xquery from stream, and print on a stream."

@- XML shredder (shredder.mx)
@m
.COMMAND shred2bats(str location, str opt) : BAT[oid, bat] = CMDshred2bats;
 "C implementation of the document shredder"

@- XML print functions (serialize.mx)
@m
.COMMAND print_doc(str,BAT[void,bat], str) : void = xquery_print_doc_main;
 "C interface to Workset print routine"
.COMMAND print_result(str,BAT[void,bat],BAT[void,oid],BAT[void,int],BAT[void,int],BAT[void,dbl],BAT[void,dbl],BAT[void,str]) : void = xquery_print_result_main;
 "C interface to Workset result print routine"

.PRELUDE = pathfinder_prelude;
.EPILOGUE = pathfinder_epilogue;

.END pathfinder;

@mil
# load modules used in pathfinder.mx
module(alarm);
module(aggrX3);
module(malalgebra);
module(pf_support);
module(mmath);
module(mapi);

PROC pfstart() : void {
        mapi_listen(int(monet_environment.find("xquery_port")), 5, "xquery_server").fork();
}

PROC get_type (bat[void,int] kind, int type_) : bat[oid,void]
{
        return kind.[and](63).ord_uselect(type_); # 63 = 2^6 - 1
}

PROC get_type_node (bat[void,int] kind) : bat[oid,void]
{
        return kind.ord_uselect(NODE, int(nil));
}

PROC get_type_atomic (bat[void,int] kind) : bat[oid,void]
{
        return kind.ord_uselect(int(nil), ATOMIC);
}

PROC get_fragment (bat[void,int] kind) : bat[void,oid]
{
        return kind.[>>](6).[oid]();
}

PROC set_kind (bat[void,oid] frag, int type_) : bat[void,int]
{
        return frag.[int]().[<<](6).[or](type_);
}

PROC get_types (bat[void,int] kind) : bat[void,int]
{
        return kind.[and](63); # 63 = 2^6 - 1
}

#############################################
# Document management functions
#
# - import_doc
# - delete_doc
# - delete_all_docs
# - compress_properties
# - create_ws
# - add_doc
#
# Each imported XML-document is stored as a collection of persistent BATs 
# whose name starts with the name of the BAT and ends with the document ID. 
# The execution of an XQuery is not performed on the persistent BATs, but on 
# the transient 'working set', a global document collection represented
# by the ws-BAT.
#
# Each collection contains the following BATs:
# - pre_size    : BAT[oid,int]  pre-value of node / and its descendant size,
# - pre_level   : BAT[oid,chr]  pre-value of node / and its level,
# - pre_prop    : BAT[oid,oid]  pre-value of node / and property ID,
# - pre_kind    : BAT[oid,chr]  pre-value of node / and property ID,
#
# - qn_ns        : BAT[oid,str]  property ID / and name space (elements and attributes),
# - qn_loc       : BAT[oid,str]  property ID / and local name (elements and attributes),
# - prop_text    : BAT[oid,str]  property ID / and text,
# - prop_com     : BAT[oid,str]  property ID / and comment,
# - prop_ins     : BAT[oid,str]  property ID / and processing instruction,
# - prop_tgt     : BAT[oid,str]  property ID / and processing instruction target,
#
# - attr_own  : BAT[oid,oid]  attribute ID / pre-value of owner
# - attr_qn   : BAT[oid,oid]  attribute ID / and qname/property ID
# - attr_prop : BAT[oid,oid]  attribute ID / value ID
#
# - prop_val  : BAT[oid,str]  value ID / value of attribute nodes
#
# Global information on persistent stored documents:
# - doc_name    : BAT[oid,str]  document ID / document name
# - doc_height  : BAT[oid,int]  document ID / height of document
# 
# Information on documents/fragments in the working set:
# - PRE_FRAG   : BAT[void,BAT[void,oid]] list of bats with fragments
#                oids for each pre value (copied in element construction)
# - ATTR_FRAG  : BAT[void,BAT[void,oid]] list of bats with fragments
#                oids for each attr value (copied in element/attribute 
#                construction)
# - DOC_LOADED : BAT[void,str] fragment ID / name of document 
#                (starts with 1@0 because WS is first 'loaded' document
# - FRAG       : BAT[void,oid] 0@0 / oid of the newest added fragment
# - WS_FRAG    : BAT[void,oid] enumeration / root-pre values of
#                generated element fragments
# - HEIGTH     : BAT[void,int] enumeration of the fragments / maximal
#                depth of the fragment (starts with 0@0 - WS)

# get a handle to the global lock
var pf_lock := pflock();

# DEFINITION of constants concerning the data model
const PRE_BASE := 0@0;
const ELEMENT := chr(0);
const TEXT := chr(1);
const COMMENT := chr(2);
const PI := chr(3);
const DOCUMENT := chr(4);

# types in translation
const QNAME := 2;
const BOOL := 3;
const INT := 4;
const DEC := 5;
const DBL := 6;
const STR := 7;
const U_A := 8;
# ATOMIC is not a type but all atomic types
# can be retrieved with 'select(int(nil),ATOMIC)'
const ATOMIC := 31;
# NODE is not a type but all node types
# can be retrieved with 'select(NODE,int(nil))'
const NODE := 32;
const ELEM := 33;
const ATTR := 34;

const WS := 0@0;

@- ws definition

This macro is used for the MIL const defs, the C const defs,
but also in the MIL procs for creating, filling and destroying
a working set.

We define a table with the column name, its number,
the type of data (typically again a bat), and if
so the head and tail type of that bat.

actually the fielf 'tpe' is taken to be bat *always*, 
EXCEPT when (child-t != void)

('tpe' = void means it is a view; without persistent name)

        name       number  tpe  col[H,T]    col-seqbase 
        ========   ======  ===  ==========  ===========
@= ws
@:@1_ws(PRE_SIZE,       0, bat, void,  int, PRE_BASE)@
@:@1_ws(PRE_LEVEL,      1, bat, void,  chr, PRE_BASE)@
@:@1_ws(PRE_PROP,       2, bat, void,  oid, PRE_BASE)@
@:@1_ws(PRE_KIND,       3, bat, void,  chr, PRE_BASE)@
@:@1_ws(PRE_FRAG,       4, void,void,  oid, PRE_BASE)@
@:@1_ws(QN_URI,         5, bat, void,  str, PRE_BASE)@
@:@1_ws(QN_PREFIX,      6, bat, void,  str, PRE_BASE)@
@:@1_ws(QN_LOC,         7, bat, void,  str, PRE_BASE)@
@:@1_ws(PROP_TEXT,      8, bat, void,  str, PRE_BASE)@
@:@1_ws(PROP_COM,       9, bat, void,  str, PRE_BASE)@
@:@1_ws(PROP_INS,      10, bat, void,  str, PRE_BASE)@
@:@1_ws(PROP_TGT,      11, bat, void,  str, PRE_BASE)@
@:@1_ws(ID_PRE,        12, bat,  str,  oid, nil)@
@:@1_ws(IDREF_PRE,     13, bat,  str,  oid, nil)@
@:@1_ws(ATTR_OWN,      14, bat, void,  oid, PRE_BASE)@
@:@1_ws(ATTR_QN,       15, bat, void,  oid, PRE_BASE)@
@:@1_ws(ATTR_PROP,     16, bat, void,  oid, PRE_BASE)@
@:@1_ws(ATTR_FRAG,     17, void,void,  oid, PRE_BASE)@
@:@1_ws(PROP_VAL,      18, bat, void,  str, PRE_BASE)@
@:@1_ws(DOC_LOADED,    19, str, void, void, nil)@
@:@1_ws(FRAG,          20, oid, void, void, nil)@
@:@1_ws(WS_FRAG,       21, oid, void, void, nil)@
@:@1_ws(HEIGHT,        22, int, void, void, nil)@
@:@1_ws(QN_PREFIX_URI, 23, bat, void,  str, nil)@
@:@1_ws(QN_LOC_URI,    24, bat, void,  str, nil)@
@:@1_ws(KIND_PRE_0,    25, bat, void,  oid, nil)@
@:@1_ws(KIND_PRE_1,    26, bat, void,  oid, nil)@
@:@1_ws(KIND_PRE_2,    27, bat, void,  oid, nil)@
@:@1_ws(KIND_PRE_3,    28, bat, void,  oid, nil)@
@:@1_ws(KIND_PRE_4,    29, bat, void,  oid, nil)@
@:@1_ws(PROP_PRE_0,    30, bat,  oid,  oid, nil)@
@:@1_ws(PROP_PRE_3,    31, bat,  oid,  oid, nil)@

@= c_decl_ws
#define @1 @2
@h
@:ws(c_decl)@
#define WS_SIZE 32  /* should be last */

@= mil_decl_ws
const @1 := @2;
@mil
@:ws(mil_decl)@
const WS_SIZE  := 32; # WS_SIZE should be last
const KIND_PRE := KIND_PRE_0;
const PROP_PRE := PROP_PRE_0;

var doc_query; # bat[oid,int] active working-sets (queries) that use a particular document 
var doc_sema;  # bat[oid,sema] used by delete_doc to wait until all doc users have gone
var uri_duration; # pattern bat[str,lng] that determines how many seconds URIs are cached (longest string prefix match counts)

PROC doc_check(str name) : bit
{
    # check if anythimg is initialized at all
    if (type(doc_query) != bat) {
        if (not(isnil(CATCH(bat("doc_name").count())))) {
            # create doc_name table in case it does not exist
            new(oid,str).persists(true).bbpname("doc_name");
            new(oid,str).persists(true).bbpname("doc_location");
            new(oid,timestamp).persists(true).bbpname("doc_timestamp");
            new(oid,int).persists(true).bbpname("doc_height");
            new(oid,lng).persists(true).bbpname("doc_size");
        }
        if (isnil(CATCH(bat("doc_query").count()))) {
            doc_query := bat("doc_query"); 
            doc_sema := bat("doc_sema"); 
            uri_duration := bat("uri_duration"); 
        } else {
            (doc_query := new(oid,int)).bbpname("doc_query"); 
            (doc_sema := new(oid,sema)).bbpname("doc_sema"); 
            (uri_duration := new(str,lng)).bbpname("uri_duration"); 
        }
    }
    return bat("doc_name").reverse().exist(name);
}


PROC create_ws () : BAT[void,bat]
{
    var ws := bat(void,bat,WS_SIZE).seqbase(PRE_BASE);

    # use our ws macro to instatiate a working set with the proper types
@= create_ws
    if (@5 != void) { # a bat of bats (persistent or view)
        var b := bat(@4,@5);
        if (not(isnil(@6))) b.seqbase(@6); 
        ws.insert(nil, bat(void,bat).seqbase(PRE_BASE).insert(nil, b));
    } else {
        ws.insert(nil, bat(void,@3).seqbase(PRE_BASE)); # a constant bat
    }
@mil
    @:ws(create)@

    # fill the constant bats with initial values
    ws.fetch(DOC_LOADED).seqbase(1@0);
    ws.fetch(FRAG).seqbase(0@0).insert(0@0,nil);
    ws.fetch(HEIGHT).seqbase(0@0).insert(nil,0);
    return ws.access(BAT_READ);
}
ADDHELP("create_ws", "tsheyar", "July 2004",
"DESCRIPTION:\n\
creates a new working set and gives back the reference",
"pathfinder");


PROC destroy_ws_locked(BAT[void,bat] ws) : bit {
    if (type(doc_query) = bat)
    doc_query.select(int(ws))@batloop() {
        var doc_oid := $h;
        doc_query.delete(doc_oid, int(ws));
        if (not(doc_query.exist(doc_oid))) {
            if (doc_sema.exist(doc_oid)) {
                sema_up(doc_sema.find(doc_oid));
            }
        }
    }
    # determine whether a cache flush is desired (only count cached bats; those with a timestamp)
    var cursize := sum(bat("doc_timestamp").select(timestamp(nil),timestamp(nil)).mirror().join(bat("doc_size")));
    var maxsize := (1024LL * 1024LL) * lng(monet_environment.find("xquery_cacheMB"));

    if (cursize > maxsize)
	delete_all_docs_locked(true);
}

PROC destroy_ws(BAT[void,bat] ws) : void {
    var err, flush_cache := false;

    # always make sure not to cause errors while holding the lock
    lock_set(pf_lock);
    err := CATCH(flush_cache := destroy_ws_locked(ws));
    lock_unset(pf_lock);

    if (not(isnil(err))) ERROR(err);

}
ADDHELP("destroy_ws", "boncz", "May 2005",
"DESCRIPTION:\n\
destroys the working set, removing all doument pins. Also chech cache occupancy and flush if full.\n",
"pathfinder");



PROC shred_doc_locked(BAT[str,bat] docBAT, str location, str name, timestamp ts, int ws, int height) : void 
{
    # get a new persistent doc id
    var doc_oid := 0@0;
    if (bat("doc_name").count() > 0) 
        doc_oid := oid(int(bat("doc_name").reverse().max()) + 1); 

    # rename all new bats with the doc id as suffix
    [rename](docBAT, [+](mirror(docBAT), str(int(doc_oid))));
    var totsize := sum([batsize](docBAT));

    # add to meta table
    bat("doc_name").insert(doc_oid, name);
    bat("doc_location").insert(doc_oid, location);
    bat("doc_timestamp").insert(doc_oid, ts);
    bat("doc_height").insert(doc_oid, height);
    bat("doc_size").insert(doc_oid, totsize);

    [persists](docBAT, true);
   
    # add the meta table to the commit set 
    #docBAT.insert(str(nil),bat("doc_name"));
    #docBAT.insert(str(nil),bat("doc_location"));
    #docBAT.insert(str(nil),bat("doc_timestamp"));
    #docBAT.insert(str(nil),bat("doc_height"));
    #docBAT.insert(str(nil),bat("doc_size"));
    #if (not(subcommit(docBAT))) 
    if (not(commit())) ERROR("shred_doc(%s) : commit failed\n");

    if (not(isnil(ws))) {
        pin_doc(doc_oid, ws);
    }
}

# HACK: overwrite 'height'
PROC shred_doc_impl(str location, str name, bit doCommit, str opt, timestamp ts, int ws) : BAT[void,bat]
{
    var err, exists := false;

    # always make sure not to cause errors while holding the lock
    lock_set(pf_lock);
    err := CATCH(exists := doc_check(name));
    lock_unset(pf_lock);
 
    if (not(isnil(err))) ERROR(err);
    else if (exists) ERROR("shred_doc(%s): already exists in database!\n", name);

    # shred it unlocked
    var docBAT := new(str,bat); # contains all new bats
    var us := usec();
    var shredRES := shred2bats(location,opt);

    # use the ws macro to get the the basic working set (excluding views, constants and indices)
@= shred_doc_ws
    if (and(=(@3, bat), <(@1, DOC_LOADED)))
        docBAT.insert(toLower("@1"), shredRES.fetch(@1));
@mil
    @:ws(shred_doc)@

    # these are simple concatenations (to accelerate combPRINT_WS_SZined lookup)
    docBAT.insert("qn_prefix_uri", docBAT.find("qn_prefix").[+](str('\1')).[+](docBAT.find("qn_uri")));
    docBAT.insert("qn_loc_uri",    docBAT.find("qn_loc").[+](str('\1')).[+](docBAT.find("qn_uri")));

    # create our indices
    var knd := ELEMENT;
    while ( knd <= DOCUMENT ) {
       docBAT.insert("kind_pre" + "_" + chr(48 + knd),
                     docBAT.find("pre_kind").ord_uselect(knd).reverse().chk_order());
       knd :+= chr(1);
    }

    var knd_pre_bat := docBAT.find("kind_pre" + "_" + chr(48 + ELEMENT)).reverse().mirror();
    docBAT.insert("prop_pre" + "_" + chr(48 + ELEMENT),
                  knd_pre_bat.leftfetchjoin(docBAT.find("pre_prop")).reverse().chk_order());

    knd_pre_bat := docBAT.find("kind_pre" + "_" + chr(48 + PI)).reverse().mirror();
    docBAT.insert("prop_pre" + "_" + chr(48 + PI),
                  knd_pre_bat.leftfetchjoin(docBAT.find("pre_prop")).reverse().chk_order());

    height := shredRES.fetch(PRE_LEVEL).max().int() + 1;

    if (doCommit) {
        [mmap](docBAT, STORE_MMAP);
	[save](docBAT);

        # add doc to the database locked
        lock_set(pf_lock);
        err := CATCH(shred_doc_locked(docBAT, location, name, ts, ws, height));
        lock_unset(pf_lock);

        if (not(isnil(err))) ERROR(err);
    }
    return docBAT;
}

PROC shred_doc_base(str location, str name, bit doCommit, str opt) : BAT[void,bat]
{
    var height, us := usec();
    var docBAT := shred_doc_impl(location, name, doCommit, opt, timestamp(nil), int(nil));
    # save all persistent BATs and print timings
    us := usec() - us;
    var ms := us/1000;
    if ( doCommit ) {
        printf("# Shredded XML doc(\"%s\"), total time after commit=%d.%03ds\n", name, ms/1000,ms%1000);
    } else {
        printf("# Shredded XML doc(\"%s\") uncommitted, total time =%d.%03ds\n", name, ms/1000,ms%1000);
    }
    return docBAT;
}

PROC shred_doc(str location, str name) : void
{
    shred_doc_base(location, name, true, "");
}
ADDHELP("shred_doc", "flokstra", "Dec 2004",
"PARAMETERS:\n\
str file name (\"/anypath/foo.xml\" containing the xml document to be shredded)\n\
str document name in database\n\
DESCRIPITON:\n\
Shred xml document to the internal Pathfinder format, (analog to import_doc()).",
"pathfinder");

PROC delete_doc_locked(oid doc_oid) : bit {
    var docBAT := new(void,str);

    if (doc_sema.exist(doc_oid)) {
	# somebody else is deleting the same doc!
        while(doc_sema.exist(doc_oid)) {
            lock_unset(pf_lock);
            sleep(1);
            lock_set(pf_lock);
        }
        return; # now he is done
    }
    # we will delete it
    while (doc_query.exist(doc_oid)) {
        var sem := sema_create(0);
        doc_sema.insert(doc_oid, sem);

        lock_unset(pf_lock);
        sema_down(sem); # wait for the users to go away 
        lock_set(pf_lock);
    
        sema_destroy(sem);
        doc_sema.delete(doc_oid, sem);
    }

    # use the ws macro to get the names of all non-(view or constant) bats
@= getlower_ws
    if (@3 = bat)
        docBAT.insert(nil, toLower("@1"));
@mil
    @:ws(getlower)@
  
    # docBAT becomes [name,bat]
    docBAT := [bat]([+](docBAT, str(int(doc_oid))).reverse().mirror());

    # rename the bats so even in case of failure they don't bother us directly anymore
    [rename](docBAT, [+]([+]("rm_", mirror(docBAT)), +("_" , str(lng(current_timestamp()))))).access(BAT_WRITE);

    # remove them from the repository
    [persists](docBAT, false);

    bat("doc_name").delete(doc_oid);
    bat("doc_location").delete(doc_oid);
    bat("doc_timestamp").delete(doc_oid);
    bat("doc_height").delete(doc_oid);
    bat("doc_size").delete(doc_oid);

    # also commit the meta bats
    #docBAT.insert(str(nil), bat("doc_name"));
    #docBAT.insert(str(nil), bat("doc_location"));
    #docBAT.insert(str(nil), bat("doc_timestamp"));
    #docBAT.insert(str(nil), bat("doc_height"));
    #docBAT.insert(str(nil), bat("doc_size"));
    #return subcommit(docBAT);
    return commit();
}

PROC delete_doc(str name) : void
{
    var err;
    # always make sure not to cause errors while holding the lock
    lock_set(pf_lock);
    err := CATCH(delete_doc_locked(bat("doc_name").reverse().find(name)));
    lock_unset(pf_lock);

    if (not(isnil(err))) ERROR(err);
}
ADDHELP("delete_doc", "tsheyar", "July 2004",
"PARAMETERS:\n\
str document name\n\
DESCRIPITON:\n\
delete the persistent BATS that store the document.",
"pathfinder");

PROC delete_all_docs_locked(bit cachedOnly) : void
{
    doc_check("dummy");
    bat("doc_timestamp").copy()@batloop() {
        if (or(cachedOnly, not(isnil($t))))
            delete_doc_locked($h);
    }
}

PROC delete_all_docs(bit cachedOnly) : void
{
    var err, b := bat(timestamp,str);
    
    # always make sure not to cause errors while holding the lock
    lock_set(pf_lock);
    err := CATCH(delete_all_docs_locked(cachedOnly));
    lock_unset(pf_lock);

    if (not(isnil(err))) ERROR(err);

}
ADDHELP("delete_all_docs", "tsheyar", "July 2004",
"DESCRIPITON:\n\
deletes all persistent document BATs that store xml documents.",
"pathfinder");


PROC pin_doc(oid doc_oid, int ws) : void 
{
    # pin the document on this working set (must hold lock!)
    doc_query.insert(doc_oid, int(ws));
}

# HACK: this proc overwrites variables 'lifetime' and 'ts'
PROC add_doc_locked(str name, timestamp ts, int ws) : oid
{
    var doc_oid := nil;
    var filename := name;
    var lim := timestamp(nil);

    # check if the document already existed
    if (doc_check(name)) {
        doc_oid := bat("doc_name").reverse().find(name);
        filename := bat("doc_location").find(doc_oid);
    } else if (bat("doc_location").reverse().exist(name)) {
        # existed as cached location (URI): must check timestamp
        var doc_oid := bat("doc_location").reverse().find(name);
    }

    # do some first analysis on the URI
    if (not(isnil(doc_oid))) { 
        filename := bat("doc_location").find(doc_oid);
	lim := bat("doc_timestamp").find(doc_oid);
    }

    if (startsWith(filename, "file://") or startsWith(filename, "FILE://")) {
        filename := string(filename, 7);
    } else {
	idx := search(filename, '/');
    }
    if (and(>=(idx,0), =(chrAt(filename,idx+1), '/'))) {
	# add uri-dependent lifetime
        var b := [startsWith](filename, mirror(uri_duration)).uselect(true);
        if (b.count() > 0) {
            var matchlen := [length](mirror(b));
            lifetime := *(1000LL, uri_duration.find(matchlen.reverse().find(matchlen.max())));
        } else {
            lifetime := lng(nil); # doc will *not* be cached 
        }
    } else {
        # a file: get lastmodification time
        var tts;
        var err := CATCH(tts := lastmod_time(filename));
	if (isnil(err)) {
            ts := tts; # timestamp was read succesfully
	} else if (not(isnil(lim))) {
            ts := add(lim, 1LL); # file-error on cached file: force remove
	}
    }

    if (isnil(doc_oid)) {
        return nil; # document not in database
    } else if (and(not(isnil(lim)), >(ts,lim))) { # if so, check if it still valid
        # remove outdated document from the cache
        delete_doc_locked(doc_oid); 
        return nil;
    }
    pin_doc(doc_oid, ws); # make sure nobody can delete it
    return doc_oid;
}

# if docid != "", it holds the str(id) of the persistent doc
# if not, the temporary document is in tmp_doc (by name without id)
PROC add_doc_bat(BAT[str,bat] tmp_doc, str name, str docid) : bat[any,any]
{
    if (docid != "") return bat(name + docid);
    return tmp_doc.find(name);
}

var time_shred := 0; # dummy declarartion to avoid errors when timing is not activated in the script

# HACK: this proc overwrites variable 'time_shred' 
PROC add_doc(BAT[void,bat] ws, str name) : BAT[void,bat]
{
    var ts := current_timestamp();
    var lifetime := 0LL;
    var idx := -1;
    var doc_oid;
    var err, height;
    var t := time();

    # always make sure not to cause errors while holding the lock
    lock_set(pf_lock);
    err := CATCH(doc_oid := add_doc_locked(name, ts, int(ws)));
    lock_unset(pf_lock);

    if (not(isnil(err))) ERROR(err);

    var docBAT, docid := "", doCommit := true;

    if (isnil(doc_oid)) {
        ts := add(ts, lifetime);
        if (isnil(ts)) doCommit := false;
        docBAT := shred_doc_impl(name, name, doCommit, "", ts, int(ws));
        # overwrites 'height'
        time_shred :+=  time() - t;
    } else {
        docBAT := new(str,bat);
    }
    if (doCommit) { 
        docid := str(int(bat("doc_name").reverse().find(name)));
        height := bat("doc_height").find(oid(int(docid)));
    }

    # add it to the working set
    var frag := ws.fetch(DOC_LOADED).uselect(name);
    if (frag.count() = 0) {
        ws.fetch(DOC_LOADED).insert(nil,name);
	frag := oid(ws.fetch(DOC_LOADED).count());

        # use the ws macro to instantiate all non-(view or constant) bats
@= add_doc_bat_ws
        if (@3 = bat)
            ws.fetch(@1).insert(nil,docBAT.add_doc_bat(toLower("@1"), docid));
@mil
	@:ws(add_doc_bat)@

        # create views
        ws.fetch(PRE_FRAG).insert(nil,fake_project(frag));
        ws.fetch(ATTR_FRAG).insert(nil,fake_project(frag));

        # adapt constants
        ws.fetch(FRAG).replace(0@0,frag);
        ws.fetch(HEIGHT).insert(nil,height);
    } else { 
        ws.fetch(FRAG).replace(0@0,frag.reverse().fetch(0)); 
    }
    return ws;
}
ADDHELP("add_doc", "tsheyar", "July 2004",
"PARAMETERS:\n\
bat(void,bat) - actual working set,\n\
str - the name of the document, which is added\n\
DESCRIPITON:\n\
adds the document to the working set and gives back the\n\
updated working set. (At position FRAG stands the actual\n\
fragment to which the new root is linked.)",
"pathfinder");


PROC saxquery(str q) : void { xquery("sax",q); }

@mil
#############################################
# MIL WRAPPER for AXIS STEPS 
#
# In order to simplify the invocation of the axis steps functions, this
# interface provides...
# 

@(
@:step(descendant,descendant,scj_desc,,@:sizes_code@,,)@
@:step(descendant_or_self,descendant-or-self,scj_descorself,,@:sizes_code@,,)@
@)

@:wrap(descendant)@
@:wrap(descendant_or_self)@

@:step(ancestor,ancestor,scj_anc,,@:sizes_code@,,)@
@:step(ancestor_or_self,ancestor-or-self,scj_ancorself,,@:sizes_code@,,)@

@(
@:step(child,child,lev_child,@:level_intro@,@:level_code@,,)@
@)

@:wrap(child)@

@:step(parent,parent,lev_parent,@:level_intro@,@:level_code@,,)@
@:step(following_sibling,following-sibling,lev_fs,@:level_intro@,@:level_code@,,)@
@:step(preceding_sibling,preceding-sibling,lev_ps,@:level_intro@,@:level_code@,,)@

@:step(following,following,following_void,,@:sizes_code@,@:foll_prec_code@,@:doc_pre@)@
@:step(preceding,preceding,preceding_void,,@:sizes_code@,@:foll_prec_code@,@:doc_pre@)@

@= chk_order
	if ( and(order,1) = @2 ) {
		@3 := @3.chk_order(); # just in case...
		if ( not(ordered(reverse(@3))) ) {
			ERROR("@1: tail of @3 must be sorted!");
		}
	}
@
@= one_iter_many_items
	# 1 iter, n items
	one_iter := TRUE;
	@:chk_order(@1@2,0,item)@
	# =>  we don't need to sort the input
	order := and(order,1);
@
@= many_iters_one_item
	# n iters, 1 item 
	one_item := TRUE;
	@:chk_order(@1@2,1,iter)@
	# =>  we don't need to sort the input
	order := and(order,1);
@
@= descs_per_item
	# "descendant" / "descendant_or_self"
	# => result for a single item is a simple slice of cands
	var fst := item.fetch(@2);
	var lst := oid(int(fst) + pre_size.fetch(fst));
        fst := oid(int(fst) + skip_self);
	var item_descs := cands.ord_select(fst,lst).reverse();
@
@= wrap
PROC @1 (BAT[void,oid] iter, BAT[void,oid] item, oid frag, BAT[void,bat] ws, int order, BAT[oid,oid] cands) : BAT[oid,oid] 
{
	var result := nil;
	var one_iter := FALSE;
	var one_item := FALSE;
	var min_iter := oid(nil);
	var max_iter := oid(nil);
	var skip_self := 1;
	if ( "@1" = "descendant_or_self" ) {
		skip_self := 0;
	}

	# check consistency
	if ( isnil(seqbase(iter)) or isnil(seqbase(item)) ) {
		ERROR("@1(0): heads of iter & item/ctx must not be NIL!");
	}
	if ( (count(iter) != count(item)) or (seqbase(iter) != seqbase(item)) ) {
		ERROR("@1(1): heads of iter & item/ctx must be aligned!");
	}
	if ( ((tail(cands) = "void") or (ttype(cands) = 0)) and isnil(seqbase(reverse(cands))) ) {
		ERROR("@1(2): tail of cands must not be NIL!");
	}
	@:chk_order(@1(3),0,iter)@
	@:chk_order(@1(4),1,item)@
	cands := cands.chk_order(); # just in case...
	if ( not(ordered(reverse(cands))) ) {
		ERROR("@1(5): tail of cands must be sorted!");
	}

	var pre_size := ws.fetch(PRE_SIZE).fetch(frag);
	var height   := ws.fetch(HEIGHT).fetch(frag);

	# trivial cases	
	if ( (count(item) = 0) or (count(cands) = 0) or (count(pre_size) = 0) ) {
		result := bat(oid,oid,0).access(BAT_READ);
		result := result.chk_order();
		return result;
	}
	
	# special cases
	if ( count(item) = 1 ) {
		# 1 iter, 1 item
		one_iter := TRUE;
		one_item := TRUE;
		if ( "@1" != "child" ) {
			# "descendant" / "descendant_or_self"
			# =>  result is a simple slice of cands
			@:descs_per_item(@1,0)@
			result := item_descs.project(iter.fetch(0)).reverse();
			result := result.chk_order();
			return result;
		}
		# =>  we don't need to sort neither input nor output
		order := 3;
		iter := iter.chk_order(); # just in case...
		item := item.chk_order(); # just in case...
	} else {
	# first: try cheap min==max checks on ordered columns
	if ( ordered(reverse(iter)) and (min(iter) = max(iter)) ) {
		@:one_iter_many_items(@1,(6))@
	} else {
	if ( ordered(reverse(item)) and (min(item) = max(item)) ) {
		@:many_iters_one_item(@1,(7))@
	} else {
	# then: invest in one scan to check order to save two scans for min/max
	iter := iter.chk_order(); # just in case...
	if ( ordered(reverse(iter)) and (min(iter) = max(iter)) ) {
		@:one_iter_many_items(@1,(8))@
	} else {
	item := item.chk_order(); # just in case...
	if ( ordered(reverse(item)) and (min(item) = max(item)) ) {
		@:many_iters_one_item(@1,(9))@
	}}}}}

	min_iter := min(iter);
	max_iter := max(iter);

	# pre-sort input
	if ( and(order,1) = 0 ) {
		var ord := item.reverse().sort().reverse();
		    ord := ord.CTrefine(iter).mark(0@0).reverse();
		iter := ord.leftfetchjoin(iter);
		item := ord.leftfetchjoin(item);
		iter := iter.chk_order();
		item := item.chk_order();
	}

	# the actual location step
	if ( isnil(result) ) {
		result := ll_@1 (iter, item, pre_size, cands,
		                   height, one_iter, one_item, 
		                   min_iter, max_iter);
	}
	
	# post-sort output
	if ( (and(order,2) = 2) and not(ordered(reverse(result))) ) {
		iter := result.mark(0@0).reverse();
		item := result.reverse().mark(0@0).reverse();
		var ord := item.reverse().sort().reverse();
		    ord := ord.CTrefine(iter).mark(nil);
		result := result.fetch(ord);
		result := result.chk_order();
	}
	
	# post-sort output
	if ( (and(order,2) = 0) and not(ordered(result)) ) {
		iter := result.mark(0@0).reverse();
		item := result.reverse().mark(0@0).reverse();
		var ord := iter.reverse().sort().reverse();
		    ord := ord.CTrefine(item).mark(nil);
		result := result.fetch(ord);
		result := result.chk_order();
	}
	
	return result;
}
ADDHELP("@1", "tsheyar", "Sep 2004",
"PARAMETERS:\n\
BAT[void,oid] iter (grouping relation)\n\
BAT[void,oid] item (context set)\n\
oid frag (the current fragment of the ws)\n\
BAT[void,bat] ws (working set)\n\
int order (input & output order properties:\n\
           bit 0: input is sorted on iter(0) or item(1)\n\
           bit 1: output must be sorted on iter(0) or item(1))\n\
BAT[oid,oid] cands (sorted list of result candidate OIDs in the tail)\n\
DESCRIPITON:\n\
returns all nodes on the @1 axis of the ctx-nodes duplicate free for each group.",
"pathfinder");
@
@
# use size concept
@= sizes_code
pre_sizes
@
# use level concept
@= level_intro
    var pre_levels := ws.fetch(PRE_LEVEL).fetch(frag);
@
@= level_code
pre_levels
@
# code for following and preceding steps
@= foll_prec_code
    # dirty code to make possible, that old scj still works
    var doc_pre;
    if (frag = 0@0)
        { doc_pre := ws.fetch(WS_FRAG); }
    else
        { doc_pre := bat(void,oid,1).seqbase(0@0).insert(nil,1@0).access(BAT_READ); }
@
@= doc_pre
doc_pre,
@

@= step
PROC @1(BAT[void,oid] iter, BAT[void,oid] ctx, oid frag, BAT[void,bat] ws, int order) : BAT[oid,oid]
{
    # "order" is not (yet?) used, here.

    var pre_sizes := ws.fetch(PRE_SIZE).fetch(frag);
    @4
    var heights := ws.fetch(HEIGHT).fetch(frag);

    var unq := {count}(iter.reverse(), iter.tunique());

    var result := bat(oid,oid);
    var offset := 0;
    var ctx_slice;

    @6

    unq@batloop () {
	ctx_slice := ctx.slice(offset, offset + $t - 1).reverse().mark(nil);
	ctx_slice := ctx_slice.chk_order(); # have to check because step expects it sorted
        result.insert(@3
                              (@5,
                               ctx_slice,
			       @7
                               heights,
                               pre_sizes.count())
	              .project($h).reverse());
        offset := offset + $t;
    }
    return result.access(BAT_READ);
#    return @2(Tpre_size, ctx, Theight, Tpre_size.count());
}
ADDHELP("@1", "tsheyar", "Sep 2004",
"PARAMETERS:\n\
BAT[void,any] iter (grouping relation)\n\
BAT[void,any] ctx (context set)\n\
oid frag (the current fragment of the ws)\n\
BAT[void,bat] ws (working set)\n\
DESCRIPITON:\n\
returns all nodes on the @2 axis of the ctx-nodes duplicate free for each group.",
"pathfinder");
@

@mil
@:loop_lifted_scj_step1(ancestor)@
@:loop_lifted_scj_step1(ancestor_or_self)@

@:loop_lifted_scj_wrap1(child)@
@:loop_lifted_scj_wrap1(descendant)@
@:loop_lifted_scj_wrap1(descendant_or_self)@

@:loop_lifted_scj_step1(following)@
@:loop_lifted_scj_step1(following_sibling)@
@:loop_lifted_scj_step1(parent)@
@:loop_lifted_scj_step1(preceding)@
@:loop_lifted_scj_step1(preceding_sibling)@
@
#==================================================================
# expansions of the loop lifted scj
# kind argument
@= kind_args
, chr kind
@
@= kind_params
, kind
@
# tagname argument
@= ns_args
, str ns
@
@= ns_params
, ns
@
@= loc_args
, str loc
@
@= loc_params
, loc
@
@= tgt_args
, str tgt
@
@= tgt_params
, tgt
@
@= nsloc_args
, str ns, str loc
@
@= nsloc_params
, ns, loc
@
@= params2
, cands
@

# code for tagname testing
@= nsloc_post
 {
	var pre_frag := ws.fetch(PRE_FRAG).fetch(theFrag);
	if (is_fake_project(pre_frag)) {
		var frag := pre_frag.fetch(0);
		pre_frag := nil;
		var qn_nsloc := ws.fetch(QN_LOC_URI).fetch(frag);
		    qn_nsloc  := qn_nsloc.ord_uselect(loc+str('\1')+ns);
		var pre_prop := ws.fetch(PROP_PRE + int(ELEMENT)).fetch(theFrag).reverse();
		if (flt(count(pre_prop)) <= (1.1 * flt(count(result_part_item)))) {
			var pre_nsloc;
			if (count(qn_nsloc) = 1) {
				pre_nsloc := pre_prop.ord_uselect(qn_nsloc.reverse().fetch(0));
			} else {
				pre_nsloc := pre_prop.leftjoin(qn_nsloc);
			}
			pre_prop := nil;
			qn_nsloc := nil;
			tmp_res := result_part_item.leftjoin(pre_nsloc).mark(0@0).reverse();
		} else {
			var res_prop := result_part_item.leftjoin(pre_prop);
			pre_prop := nil;
			tmp_res := res_prop.leftjoin(qn_nsloc).mark(0@0).reverse();
		}
	} else {
		var pre_prop := ws.fetch(PROP_PRE + int(ELEMENT)).fetch(theFrag).reverse();
		    pre_frag := pre_prop.mirror().leftfetchjoin(pre_frag);
		var res_prop := result_part_item.leftjoin(pre_prop);
		    pre_prop := nil;
		var res_frag := result_part_item.leftjoin(pre_frag);
		    pre_frag := nil;
		var X_res    := res_prop.mark(0@0).reverse();
		var X_prop   := res_prop.reverse().mark(0@0).reverse();
		    res_prop := nil;
		var X_frag   := res_frag.reverse().mark(0@0).reverse();
		    res_frag := nil;
		var X_nsloc  := mposjoin(X_prop, X_frag, ws.fetch(QN_LOC_URI));
		    X_prop   := nil;
		    X_frag   := nil;
		var _X       := X_nsloc.ord_uselect(loc+str('\1')+ns).reverse();
		    X_nsloc  := nil;
		tmp_res := _X.leftfetchjoin(X_res).reverse().mark(0@0).reverse();
	}
	@:mapping_code@
 }
@
@= loc_post
	@:ns_loc_post(qn,loc,QN,LOC,ELEMENT)@
@
@= ns_post
	@:ns_loc_post(qn,ns,QN,URI,ELEMENT)@
@
@= target_post
        @:ns_loc_post(prop,tgt,PROP,TGT,1)@
@( FIXME: '1' is used instead of PI because we skip the other kinds @)
@
@= ns_loc_post
 {
	var pre_frag := ws.fetch(PRE_FRAG).fetch(theFrag);
	if (is_fake_project(pre_frag)) {
		var frag := pre_frag.fetch(0);
		pre_frag := nil;
		var @1_@2 := ws.fetch(@3_@4).fetch(frag);
		    @1_@2 := @1_@2.ord_uselect(@2);
		var pre_prop := ws.fetch(PROP_PRE + int(@5)).fetch(theFrag).reverse();
		if (flt(count(pre_prop)) <= (1.1 * flt(count(result_part_item)))) {
			var pre_@2;
			if (count(@1_@2) = 1) {
				pre_@2 := pre_prop.ord_uselect(@1_@2.reverse().fetch(0));
			} else {
				pre_@2 := pre_prop.leftjoin(@1_@2);
			}
			pre_prop := nil;
			@1_@2 := nil;
			tmp_res := result_part_item.leftjoin(pre_@2).mark(0@0).reverse();
		} else {
			var res_prop := result_part_item.leftjoin(pre_prop);
			pre_prop := nil;
			tmp_res := res_prop.leftjoin(@1_@2).mark(0@0).reverse();
		}
	} else {
		var pre_prop := ws.fetch(PROP_PRE + int(@5)).fetch(theFrag).reverse();
		    pre_frag := pre_prop.mirror().leftfetchjoin(pre_frag);
		var res_prop := result_part_item.leftjoin(pre_prop);
		    pre_prop := nil;
		var res_frag := result_part_item.leftjoin(pre_frag);
		    pre_frag := nil;
		var X_res    := res_prop.mark(0@0).reverse();
		var X_prop   := res_prop.reverse().mark(0@0).reverse();
		    res_prop := nil;
		var X_frag   := res_frag.reverse().mark(0@0).reverse();
		    res_frag := nil;
		var X_@2     := mposjoin(X_prop, X_frag, ws.fetch(@3_@4));
		    X_prop   := nil;
		    X_frag   := nil;
		var _X       := X_@2.ord_uselect(@2).reverse();
		    X_@2     := nil;
		tmp_res := _X.leftfetchjoin(X_res).reverse().mark(0@0).reverse();
	}
	@:mapping_code@
 }
@
@= kind_post
 {
	var pre_kind := ws.fetch(KIND_PRE + int(@1)).fetch(theFrag).reverse();
	tmp_res := result_part_item.leftjoin(pre_kind).mark(0@0).reverse();
	pre_kind := nil;
	@:mapping_code@
 }
@
@= mapping_code
	result_part_iter := tmp_res.leftfetchjoin(result_part_iter);
	result_part_item := tmp_res.leftfetchjoin(result_part_item);
	tmp_res := nil;
@
@= shrink_code
 {
	if ( (count(cands) > 0) and (count(result_part_item) > 0) ) {
		var min_cand := min(cands);
		var min_item := min(result_part_item);
		if ( min_cand < min_item ) {
			cands := cands.ord_select(min_item,oid(nil));
		}
	}
	if ( (count(cands) > 0) and (count(result_part_item) > 0) ) {
		var max_cand := max(cands);
		var max_item := max(result_part_item);
		if ( max_cand < max_item ) {
			tmp_res := result_part_item.ord_uselect(oid(nil),max_cand).mark(0@0).reverse();
			@:mapping_code@
		}
	}
 }
@
@= no_pre
	cands := ws.fetch(PRE_SIZE).fetch(theFrag).mark(nil).reverse();
	cands := cands.chk_order();
@
@= kind_pre
	cands := ws.fetch(KIND_PRE + int(@1)).fetch(theFrag);
	cands := cands.chk_order();
	@:shrink_code@
@
@= nsloc_pre
 {
	var pre_frag := ws.fetch(PRE_FRAG).fetch(theFrag);
	if (is_fake_project(pre_frag)) {
		var frag := pre_frag.fetch(0);
		pre_frag := nil;
		var qn_nsloc := ws.fetch(QN_LOC_URI).fetch(frag);
		    qn_nsloc := qn_nsloc.ord_uselect(loc+str('\1')+ns);
		var pre_prop := ws.fetch(PROP_PRE + int(ELEMENT)).fetch(theFrag).reverse();
		if (count(qn_nsloc) = 1) {
			cands := pre_prop.ord_uselect(qn_nsloc.reverse().fetch(0)).reverse();
		} else {
			cands := pre_prop.leftjoin(qn_nsloc).reverse();
		}
		pre_prop := nil;
		qn_nsloc := nil;
	} else {
		var pre_prop := ws.fetch(PROP_PRE + int(ELEMENT)).fetch(theFrag).reverse();
		    pre_frag := pre_prop.mirror().leftfetchjoin(pre_frag);
		var X_pre    := pre_prop.mark(0@0).reverse();
		var X_prop   := pre_prop.reverse().mark(0@0).reverse();
		    pre_prop := nil;
		var X_frag   := pre_frag.reverse().mark(0@0).reverse();
		    pre_frag := nil;
		var X_nsloc  := mposjoin(X_prop, X_frag, ws.fetch(QN_LOC_URI));
		    X_prop   := nil;
		    X_frag   := nil;
		var _X       := X_nsloc.ord_uselect(loc+str('\1')+ns).reverse();
		    X_nsloc  := nil;
		cands := _X.leftfetchjoin(X_pre);
	}
	cands := cands.chk_order();
	@:shrink_code@
 }
@
@= loc_pre
	@:ns_loc_pre(qn,loc,QN,LOC,ELEMENT)@
@
@= ns_pre
	@:ns_loc_pre(qn,ns,QN,URI,ELEMENT)@
@
@= target_pre
	@:ns_loc_pre(prop,tgt,PROP,TGT,1)@ 
@( FIXME: '1' is used instead of PI because we skip the other kinds @)
@
@= ns_loc_pre
 {
	var pre_frag := ws.fetch(PRE_FRAG).fetch(theFrag);
	if (is_fake_project(pre_frag)) {
		var frag := pre_frag.fetch(0);
		pre_frag := nil;
		var @1_@2 := ws.fetch(@3_@4).fetch(frag);
		    @1_@2 := @1_@2.ord_uselect(@2);
		var pre_prop := ws.fetch(PROP_PRE + int(@5)).fetch(theFrag).reverse();
		if (count(@1_@2) = 1) {
			cands := pre_prop.ord_uselect(@1_@2.reverse().fetch(0)).reverse();
		} else {
			cands := pre_prop.leftjoin(@1_@2).reverse();
		}
		pre_prop := nil;
		@1_@2 := nil;
	} else {
		var pre_prop := ws.fetch(PROP_PRE + int(@5)).fetch(theFrag).reverse();
		    pre_frag := pre_prop.mirror().leftfetchjoin(pre_frag);
		var X_pre    := pre_prop.mark(0@0).reverse();
		var X_prop   := pre_prop.reverse().mark(0@0).reverse();
		    pre_prop := nil;
		var X_frag   := pre_frag.reverse().mark(0@0).reverse();
		    pre_frag := nil;
		var X_@2     := mposjoin(X_prop, X_frag, ws.fetch(@3_@4));
		    X_prop   := nil;
		    X_frag   := nil;
		var _X       := X_@2.ord_uselect(@2).reverse();
		    X_@2     := nil;
		cands := _X.leftfetchjoin(X_pre);
	}
	cands := cands.chk_order();
	@:shrink_code@
 }
@

# expanding the scj for the different tests
@= loop_lifted_scj_wrap1
@:loop_lifted_scj_wrap_pre(@1)@
@
@= loop_lifted_scj_wrap_pre
@:loop_lifted_scj_step2(@1,,,,,                                             @:params2@,@:no_pre@        )@
@:loop_lifted_scj_step2(@1,_with_kind_test,  @:kind_args@, @:kind_params@,, @:params2@,@:kind_pre(kind)@)@
@:loop_lifted_scj_step2(@1,_with_ns_test,    @:ns_args@,   @:ns_params@,,   @:params2@,@:ns_pre@        )@
@:loop_lifted_scj_step2(@1,_with_loc_test,   @:loc_args@,  @:loc_params@,,  @:params2@,@:loc_pre@       )@
@:loop_lifted_scj_step2(@1,_with_target_test,@:tgt_args@,  @:tgt_params@,,  @:params2@,@:target_pre@    )@
@:loop_lifted_scj_step2(@1,_with_nsloc_test, @:nsloc_args@,@:nsloc_params@,,@:params2@,@:nsloc_pre@     )@
@
@= loop_lifted_scj_wrap_post
@:loop_lifted_scj_step2(@1,,,,,                                                               @:params2@,@:no_pre@)@
@:loop_lifted_scj_step2(@1,_with_kind_test,  @:kind_args@, @:kind_params@, @:kind_post(kind)@,@:params2@,@:no_pre@)@
@:loop_lifted_scj_step2(@1,_with_ns_test,    @:ns_args@,   @:ns_params@,   @:ns_post@,        @:params2@,@:no_pre@)@
@:loop_lifted_scj_step2(@1,_with_loc_test,   @:loc_args@,  @:loc_params@,  @:loc_post@,       @:params2@,@:no_pre@)@
@:loop_lifted_scj_step2(@1,_with_target_test,@:tgt_args@,  @:tgt_params@,  @:target_post@,    @:params2@,@:no_pre@)@
@:loop_lifted_scj_step2(@1,_with_nsloc_test, @:nsloc_args@,@:nsloc_params@,@:nsloc_post@,     @:params2@,@:no_pre@)@
@
@= loop_lifted_scj_step1
@:loop_lifted_scj_step2(@1,,,,,,                                                               )@
@:loop_lifted_scj_step2(@1,_with_kind_test,  @:kind_args@, @:kind_params@, @:kind_post(kind)@,,)@
@:loop_lifted_scj_step2(@1,_with_ns_test,    @:ns_args@,   @:ns_params@,   @:ns_post@        ,,)@
@:loop_lifted_scj_step2(@1,_with_loc_test,   @:loc_args@,  @:loc_params@,  @:loc_post@       ,,)@
@:loop_lifted_scj_step2(@1,_with_target_test,@:tgt_args@,  @:tgt_params@,  @:target_post@    ,,)@
@:loop_lifted_scj_step2(@1,_with_nsloc_test, @:nsloc_args@,@:nsloc_params@,@:nsloc_post@     ,,)@
@
#==================================================================
# actual definition of the scj proc
@= loop_lifted_scj_per_frag
	result_part_iter := result_part_iter.chk_order();
	result_part_item := result_part_item.chk_order();
        result_part_frag := nil;

	# pre-test
	@4

        var result := @1 (result_part_iter, result_part_item, theFrag, ws, order @3);
	result_part_iter := result.mark(0@0).reverse();
	result_part_item := result.reverse().mark(0@0).reverse();
        result_part_frag := fake_project(theFrag);
	cands := nil;

	# post-test
	@2
@
@= loop_lifted_scj_step2
proc loop_lifted_@1_step@2 (bat[void, oid] iter, bat[void, oid] item, bat[void, oid] frag, bat[void, bat] ws @3) : bat[void,bat]
{
     return loop_lifted_@1_step@2 (iter, item, frag, ws, 0 @4);
}
proc loop_lifted_@1_step@2 (bat[void, oid] iter, bat[void, oid] item, bat[void, oid] frag, bat[void, bat] ws, int order @3) : bat[void,bat]
{
    # handle empty results correctly
    if (iter.count() = 0) {
	var empty := bat(void,oid,0).seqbase(0@0).access(BAT_READ);
	return bat(void,bat,3).seqbase(0@0)
			    .insert(nil,empty)
			    .insert(nil,empty)
			    .insert(nil,empty)
			    .access(BAT_READ);
    }

    var result;
    var result_iter;
    var result_item;
    var result_frag;
    var tmp_res;
    var cands;

    var uniqueFrag := frag.tunique().sort();
    var theFrag := uniqueFrag.reverse().fetch(0);
    if (uniqueFrag.count() = 1) {
        var result_part_frag := nil;
        var result_part_iter := iter;
        var result_part_item := item;

        @:loop_lifted_scj_per_frag(@1,@5,@6,@7)@

        result_iter := result_part_iter;
        result_item := result_part_item;
        result_frag := result_part_frag;
        result_part_iter := nil;
        result_part_item := nil;
        result_part_frag := nil;
    } else {
        var result_part_frag := frag.ord_uselect(theFrag).mark(0@0).reverse();
        var result_part_iter := result_part_frag.leftfetchjoin(iter);
        var result_part_item := result_part_frag.leftfetchjoin(item);

        @:loop_lifted_scj_per_frag(@1,@5,@6,@7)@

        result_iter := result_part_iter;
        result_item := result_part_item;
        result_frag := result_part_frag;
        result_part_iter := nil;
        result_part_item := nil;
        result_part_frag := nil;

        var res_mu;
	uniqueFrag.slice(1,uniqueFrag.count() - 1)@batloop () {
	    theFrag := $h;
            result_part_frag := frag.ord_uselect(theFrag).mark(0@0).reverse();
            result_part_iter := result_part_frag.leftfetchjoin(iter);
            result_part_item := result_part_frag.leftfetchjoin(item);

            @:loop_lifted_scj_per_frag(@1,@5,@6,@7)@

            res_mu := merged_union(result_iter, result_part_iter,
				   result_item, result_part_item,
				   result_frag, result_part_frag);
            result_part_iter := nil;
            result_part_item := nil;
            result_part_frag := nil;
            result_iter := res_mu.fetch(0);
            result_item := res_mu.fetch(1);
            result_frag := res_mu.fetch(2);
            res_mu := nil;
        }
    }
    
    result_iter.access(BAT_READ);
    result_item.access(BAT_READ);
    result_frag.access(BAT_READ);
    var result_scj := bat(void,bat,3).seqbase(0@0);
    result_scj.insert(nil,result_iter);
    result_scj.insert(nil,result_item);
    result_scj.insert(nil,result_frag);

    return result_scj.access(BAT_READ);
}
@

@h
#ifndef PATHFINDER_H
#define PATHFINDER_H

#include <monet.h>
#include <monet_interpreter.h>
#include <streams.h>


#endif

@c
#include "pathfinder.h"
#include "compile_interface.h"

/*
 * Worker for the ebv() function.
 */
BAT *
BATebv (BAT *b)
{
    BAT *ret = NULL;    /* return value */
    BUN p = 0, q = 0;   /* BUN variables for iteration */
    int bunsz;          /* BUN size used for iteration (BATloopFast) */
    oid old;            /* Last head value we had seen */
    bit val;            /* Boolean result value that belongs to `old' */
    size_t cnt = 0;     /* "guess" of result cardinality */
    bit trivial;        /* indicator for "trivial" result properties */

    /* Just in case BATebv might be called from elsewhere than CMDebv:
     * check, that b in not NULL.
     */
    BATcheck(b, "BATebv");
    /* Input must be sorted by head value, tail must be boolean */
    ERRORcheck (!(BAThordered(b)&1), "BATebv: head of BAT must be sorted.\n");
    /* Needed only, if you want to disallow TYPE_void, 
     * which also matches the oid requirement of the signature;
     * or if BATebv could be called from somewhere/one else than CMDebv.
     */
    ERRORcheck (!(b->htype == TYPE_oid),
                "BATebv: head of BAT must have oid type.\n");
@(
    /* Not needed, if BATebv is only called from CMDebv,
     * since the signature only allows bit-tailed BATs.
     */
    ERRORcheck (!(b->ttype == TYPE_bit),
                "BATebv: tail of BAT must have bit type.\n");
@)

    /* Try to "guess" the result cardinality:
     * on the one hand, we don't want too allocate (far) too much memory;
     * on the other hand, we want to avoid BATextends (i.e., (large) memcpy's),
     * that occur if we initially allow too little space ... 
     * Obviously, BATcount(b) is the upper limit;
     * lower limit is just a "wild guess"...
     */
    if (BAThkey (b))
        cnt = BATcount (b);
    else
        cnt = MIN (200, BATcount (b));

    /* Create return BAT */
    ret = BATnew (b->htype, TYPE_bit, cnt);
    if (!ret)
        return ret;

    /*
     * Iterate over the input BAT.
     * Whenever we see a head value the first time, we record its tail
     * value in val. If we see the same head value a second (third,...)
     * time, we re-set val to false. When we reach the next head
     * value, (old, val) will be the correct BUN for the last group.
     */

    /* Initialize, ... */
    bunsz = BUNsize (b);
    p = BUNfirst (b);
    old = *(oid *) BUNhloc (b, p);
    val = *(bit *) BUNtloc (b, p);
    /* ... skip first, ... */
    p += bunsz;
    /* ... and process the rest. */
    for(q = BUNlast(b); p < q; p += bunsz) {
    	oid *head = (oid *) BUNhloc (b, p);
        if (*head == old)
            val = FALSE;
        else {
            bunfastins (ret, &old, &val);
            old = *head;
            val = *(bit *) BUNtloc (b, p);
        }
    }
    /* Don't forget to produce the last BUN. */
    bunfastins (ret, &old, &val);
    
    /* Set result properties ... */
    cnt = BATcount (ret);
    trivial = (cnt < 2) ? TRUE : FALSE;
    /* ... head ... */
    BATkey (ret, TRUE);
    ret->hsorted = GDK_SORTED;
    ret->hdense = trivial;
    if (trivial == TRUE) {
        if (cnt == 0)
            BATseqbase (ret, (oid)0); /* does not really matter */
        else /* (cnt == 1) */
            BATseqbase (ret, old);
    }
    /* ... tail */
    BATkey (BATmirror(ret), trivial);
    ret->tsorted = trivial;
    ret->tdense = FALSE;

    return ret;

/* required by bunfastins macro */
bunins_failed:
    BBPreclaim(ret);
    return NULL;
}

/*
 * Implementation of ebv(). Basically just calls BATebv().
 */
int
CMDebv (BAT **result, BAT *b)
{
    return (*result = BATebv (b)) ? GDK_SUCCEED : GDK_FAIL;
}

MT_Lock pf_runtime_lock;
MT_Lock pf_compiler_lock;

bat* pathfinder_prelude() {
    pf_runtime_lock = MT_create_lock();
    pf_compiler_lock = MT_create_lock();
    return NULL;
}

void pathfinder_epilogue() {
    MT_destroy_lock(pf_runtime_lock);
    MT_destroy_lock(pf_compiler_lock);
}

int CMDpflock(ptr *ret) {
    *ret = (ptr) pf_runtime_lock;
    return GDK_SUCCEED;
}

/*
 * translate xquery to MIL and execute
 */
int
CMDxquery(char *mode, char* xquery) {
    char *prologue = NULL, *query = NULL, *epilogue = NULL, *err = NULL;
    int len = 0, ret = GDK_FAIL, debug = strstr(mode,"debug") != NULL;
    char *mapi = strstr(mode, "mapi")?"=":"";
     
    if (debug) {
        stream_printf(GDKout, "%s#xquery######################################################\n", mapi);
	stream_write(GDKout, xquery, strlen(xquery), 1);
    }
    MT_set_lock(pf_compiler_lock, "CMDxquery");
    err = pf_compile_MonetDB(xquery, mode, &prologue, &query, &epilogue);
    if (err) {
      len = strlen(err);
      if (*mapi) {
	/* put ! before error lines */
	char *p = err, *q = err;
	while(*p) { if (*p++ == '\n') len++; }
	err = (char*) alloca(len+3);
	*err = '!'; 
	for(p=err+1; *q; q++) {
		*p++ = *q;
		if (*q == '\n') *p++ = '!'; 
	}
	/* guard against errors that do not terminate in a newline */
        if (*q && *q != '\n') *p++ = '\n';
  	else if (p[-1] == '!') p--;  
	p[1] = 0;
	len = p - err;
      }
    }
    MT_unset_lock(pf_compiler_lock, "CMDxquery");

    if (debug) {
        stream_printf(GDKout, "%s#mil#########################################################\n", mapi);
	if (prologue) stream_write(GDKout, prologue, strlen(prologue), 1);
        else stream_printf(GDKout, "%s#null prologue\n", mapi);
	if (query) stream_write(GDKout, query, strlen(query), 1);
        else stream_printf(GDKout, "%s#null query\n", mapi);
	if (epilogue) stream_write(GDKout, epilogue, strlen(epilogue), 1);
        else stream_printf(GDKout, "%s#null epilogue\n", mapi);
    }
    if (err) {
        if (debug) {
            stream_printf(GDKout, "%s#err#########################################################\n", mapi);
        }
    	stream_write(GDKout, err, len, 1);
    } else if (prologue && query && epilogue) {
        if (debug) {
            stream_printf(GDKout, "%s#exec prologue...############################################\n", mapi);
	}
        if (monet_exec(prologue) >= 0) {
            if (debug) {
                stream_printf(GDKout, "%s#exec query...###############################################\n", mapi);
            }
            if (monet_exec(query) >= 0) {
                if (debug) {
                    stream_printf(GDKout, "%s#exec epilogue...############################################\n", mapi);
                }
                if (monet_exec(epilogue) >= 0) {
                    if (debug) {
                        stream_printf(GDKout, "%s#ok##########################################################\n", mapi);
                    }
	            ret = GDK_SUCCEED;
                }
	    }
	}
    }
    if (debug && ret != GDK_SUCCEED) {
        stream_printf(GDKout, "%s#execution failed############################################\n", mapi);
    }
    /* what comes out of PF is alloced differently */
    if (prologue) free(prologue);
    if (query) free(query);
    if (epilogue) free(epilogue);
    return ret;
}

@= builtin_operand
{
	int _k = interpret(stk, arg(lt, @1), res);
	if (_k < 0) {
		return _k;
	}
	@3 = VALconvert(@2, res);
	if ((@3 == ILLEGALVALUE)  || (@2 == TYPE_bat && !@3)) {
		return handle_paramerror(res,@1,res->vtype,@2);
	}
}
@c
int
connect_error(stream *in, stream *out)
{
	/* Make sure that the write- (out-) stream is closed first,
	 * as the related read- (in-) stream closes the shared
	 * socket; see also MonetDB/src/common/stream.mx:socket_close .
	 */
	if (out) {
		stream_close(out);
		stream_destroy(out);
	}
	if (in) {
		stream_close(in);
		stream_destroy(in);
	}
	return GDK_FAIL;
}

#define XQUERY_CHALLENGE "::mserver_xquery:4\n"

/*
 * read xquery from input stream; execute and print on output stream 
 */  
int
CMDxquery_server(Cntxt stk, YYSTREE lt, ValPtr res)
{
	stream **In, **Out;
	stream *in = NULL, *out = NULL;
	stream *bkin, *bkout;
	Thread XQthread = THRget(THRgettid());
	Client client;
	size_t curlen = 0, maxlen = BUFSIZ;
	char *xquery, *user, *buf = GDKmalloc(maxlen + 1); /* one extra for terminator */
	int i, ret = GDK_FAIL;

	if (lt->cnt != 2)
		return handle_argerror(res, lt->cnt, 2);

	/* this is a BUILTIN because we must obtain the client context (and thus the streams) */
	CNTXTclient((Cntxt) (ptrdiff_t) stk, &client);
	@:builtin_operand(0,TYPE_Stream,In)@
	in = *In;
	@:builtin_operand(1,TYPE_Stream,Out)@
	out = *Out;
	bkin = client->fdin;
	bkout = client->fdout;
	monetSetChannel(XQthread, in, out);

	/* send challenge */
        snprintf(buf, 100, "%2d%s", strlen(XQUERY_CHALLENGE), XQUERY_CHALLENGE);
        if (stream_write(out, buf, strlen(buf), 1) < 0) 
		return connect_error(in, out);

        /* get user name (ignored later), and mapiclient mode */
        memset(buf, 0, BUFSIZ);
        user = buf;
        if (stream_read(in, user, 1, 1) < 0)
                return connect_error(in, out);
        for (i = 0; i < BUFSIZ && *user != '\n'; i++) {
                user++;
                if (stream_read(in, user, 1, 1) < 0)
                        return connect_error(in, out);
        }
        *user = 0;

	/* check for blocked mode */
	if (strncmp(buf + i - 8, ":blocked", 8) == 0) {
                in = block_stream(stream_rstream(in));
                out = block_stream(stream_wstream(out));
		monetSetChannel(XQthread, in, out);
	}

	/* use the MAPI protocol to read as much xquery buffer as possible */
	if (stream_write(out, PROMPT1, sizeof(PROMPT1) - 1, 1) < 0)
		return connect_error(in, out);
	if (stream_flush(out))
		return connect_error(in, out);

	for (;buf;) {
		ssize_t n = stream_read(in, buf + curlen, 1, maxlen - curlen);
		if (n < 0)
			return connect_error(in, out);
		if (n == 0) {
			if (stream_write(out, PROMPT2, sizeof(PROMPT2) - 1, 1) < 0)
				return connect_error(in, out);
			if (stream_flush(out))
				return connect_error(in, out);
			n = stream_read(in, buf + curlen, 1, maxlen - curlen);
			if (n < 0)
				return connect_error(in, out);
			if (n == 0)
				break;
		}
		curlen += n;
		if (curlen == maxlen) {
			maxlen += 1024;
			buf = GDKrealloc(buf, maxlen + 1);
		}
	}

	/* execute query */
	if (buf) {
		buf[curlen] = 0;	/* terminate (we know there is space) */

		/* first line of the query is the mode */ 
		for(xquery=buf; *xquery; xquery++)
			if (*xquery == '\n') { *xquery++ = 0; break; }

		ret = CMDxquery(buf, xquery); /* execute, see above */
		GDKfree(buf);
	}

	/* end of session */
	stream_write(out, PROMPT1, sizeof(PROMPT1) - 1, 1);
	stream_flush(out);
	closeClient(client, 0); 	
	return ret;
}

#include <monettime.h>

int
CMDlastmod_time(timestamp *ret, str filename) {
	struct stat st;
	int year = 1970, one = 1, zero = 0;
	lng msecs;
	timestamp ts;
        daytime dt;
	date d;

	if (stat(filename, &st)) {
		return GDK_FAIL;
	}
	msecs = 1000*st.st_mtime;
        return date_create(&d, &year, &one, &one) &&
               daytime_create(&dt, &zero, &zero, &zero, &zero) &&
               timestamp_create_default(&ts, &d, &dt) &&
               timestamp_add(ret, &ts, &msecs);
}
