# pathfinder.mx
#
# Monet runtime support for the Pathfinder XQuery compiler
#
# Copyright Notice:
# -----------------
# 
# The contents of this file are subject to the MonetDB Public
# License Version 1.0 (the "License"); you may not use this file
# except in compliance with the License. You may obtain a copy of
# the License at http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
# 
# Software distributed under the License is distributed on an "AS
# IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
# implied. See the License for the specific language governing
# rights and limitations under the License.
# 
# The Original Code is the ``Pathfinder'' system. The Initial
# Developer of the Original Code is the Database & Information
# Systems Group at the University of Konstanz, Germany. Portions
# created by U Konstanz are Copyright (C) 2000-2003 University
# of Konstanz. All Rights Reserved.
#
# Contributors:
#         Torsten Grust <torsten.grust@uni-konstanz.de>
#         Maurice van Keulen <M.van.Keulen@bigfoot.com>
#         Jens Teubner <jens.teubner@uni-konstanz.de>
#
# $Id$
#

@f pathfinder
@a Torsten Teggy Grust
@a Maurice van Keulen
@a Henning Rode
@t Runtime Support for the Pathfinder XQuery Compiler

@m
.MODULE pathfinder;

@:scj_cmd(descorself,Result includes nodes exactly on the boundary.)@
@:scj_cmd(desc,Result excludes nodes exactly on the boundary.)@
@:scj_cmd(ancorself,Result excludes nodes exactly on the boundary.)@
@:scj_cmd(anc,Result excludes nodes exactly on the boundary.)@

@:lev_cmd(child,child)@
@:lev_cmd(parent,parent)@
@:lev_cmd(fs,following-sibling)@
@:lev_cmd(ps,preceding-sibling)@

@= scj_cmd
.COMMAND scj_@1(BAT[void,int] doc,
                BAT[oid,any] context,
                int height,
                int upperbound): BAT[oid,void] = PFscj_@1_void;
"PARAMETERS
  doc: document BAT (preorder rank, postorder rank)
  context: context node sequence (preorder rank, postorder rank)
  height: document height
  upperbound: upperbound for size of result context node sequence
DESCRIPTION
doc represents a collection of (x,y) coordinates of nodes where
each x- and each y-coordinate occurs only once. context represents
a sub-collection of 'boundary nodes'. For each boundary node,
staircasejoin uselects all nodes from doc (x-coordinates), which
have an x-coordinate between the boundary node and the next one (or
right edge of the xy-plane in case there is no next), and an y-coordinate
smaller than the y-coordinate of the boundary node. context effectively
represents a boundary in the xy-plane of doc for which staircasejoin
uselects the nodes in the bottom-right part. @2"

@= lev_cmd
.COMMAND lev_@1(BAT[void,chr] doc_level,
                BAT[oid,any] context,
		int estimation,
                int height) : BAT[oid,void] = PFlev_@1;
"PARAMETERS
  doc_level: the complete level BAT (preorder rank, level)
  context: context node sequence (preorder rank, *)
  height: document height
  upperbound: upperbound for size of result context node sequence
DESCRIPTION
axis step evaluation on the @2 axis from the given context."
@m
.END pathfinder;

@mil
#############################################
# Document management functions
#
# - import_doc
# - delete_doc
# - compress_properties
# - doc_to_working_set
#
# Each imported XML-document is stored as a collection of persistent BATs 
# whose name starts with the name of the BAT and ends with the document ID. 
# The execution of an XQuery is not performed on the persistent BATs, but on 
# the transient 'working set', a global document collection represented
# by the T*-BATs.
#
# Each collection contains the following BATs:
# - pre_size    : BAT[oid,int]  pre-value of node / and its descendant size,
# - pre_level   : BAT[oid,chr]  pre-value of node / and its level,
# - pre_prop    : BAT[oid,oid]  pre-value of node / and property ID,
# - pre_kind    : BAT[oid,chr]  pre-value of node / and property ID,
#
# - prop_ns      : BAT[oid,str]  property ID / and name space,
# - prop_loc     : BAT[oid,str]  property ID / and local name,
# - prop_text    : BAT[oid,str]  property ID / and text,
# - prop_com     : BAT[oid,str]  property ID / and comment,
# - prop_ins     : BAT[oid,str]  property ID / and processing instruction,
# - prop_tgt     : BAT[oid,str]  property ID / and processing instruction target,
#
# - attr_ns   : BAT[oid,str]  attribute ID / and name space of attribute names
# - attr_loc  : BAT[oid,str]  attribute ID / and local name of attribute names
# - attr_val  : BAT[oid,str]  attribute ID / value of attribute nodes
# - attr_own  : BAT[oid,oid]  attribute ID / pre-value of owner
#
# Global information on persistent stored documents:
# - doc_name    : BAT[oid,str]  document ID / document name
# - doc_height  : BAT[oid,int]  document ID / height of document
# 
# Information on documents/fragments in the working set:
# - Tdoc_pre : BAT[oid,oid] document ID / pre-value of document node in working set
# - Tdoc_name : BAT[oid,str] document ID / name of document (only if name exists)
# - Theight : int height of the working set

# DEFINITION of constants concerning the data model
const DOC_BASE := 0@0;
const PRE_BASE := 0@0;
const ATTR_BASE := 1073741824@0; #2 * 2^29
const ELEMENT := chr(0);
const TEXT := chr(1);
const COMMENT := chr(2);
const PI := chr(3);
const DOCUMENT := chr(4);

# INITIALIZATION of working set (T*-BATs)
var Tpre_size;
var Tpre_level;
var Tpre_prop;
var Tpre_kind;
var Tprop_ns;
var Tprop_loc;
var Tprop_text;
var Tprop_com;
var Tprop_ins;
var Tprop_tgt;
var Tattr_ns;
var Tattr_loc;
var Tattr_val;
var Tattr_own;
var Tdoc_pre;
var Tdoc_name;
var Theight;
clear_working_set();

# called by compress_properties
PROC compress_val(BAT[oid,oid] pre_prop, BAT[oid,oid] pre_newprop,
                  str batname) : void :=
{
    prop_val := bat(batname);
    
    var cprval_newprop := prop_val.reverse.kunique.mark(PRE_BASE);
    var prop_newprop := prop_val.join(cprval_newprop);
    pre_newprop.insert(pre_prop.join(prop_newprop));

    # replace persistent prop_val by the new compressed BAT
    prop_val := nil;
    bat(batname).persists(false).rename(batname + "_");
    cprval_newprop.reverse.persists(true).bbpname(batname);
}

# called by compress_properties
PROC compress_val(BAT[oid,oid] pre_prop, BAT[oid,oid] pre_newprop,
                  str batname1, str batname2) : void :=
{
    prop_val1 := bat(batname1);
    prop_val2 := bat(batname2);
    
    # ":" is added to distinguish between "foo:bar" and "fo:obar"
    var prop_val12 := prop_val1.[+](":").[+](prop_val2);
    var cprval12_prop := prop_val12.reverse.kunique;
    var cprval12_newprop := cprval12_prop.mark(PRE_BASE);
    
    var prop_newprop := prop_val12.join(cprval12_newprop);
    pre_newprop.insert(pre_prop.join(prop_newprop));
    
    var cprval1_prop := prop_val1.semijoin(cprval12_prop.reverse).reverse;
    var cprval2_prop := prop_val2.semijoin(cprval12_prop.reverse).reverse;
    
    var cprval1_newprop := cprval1_prop.join(prop_newprop);
    var cprval2_newprop := cprval2_prop.join(prop_newprop);
    
    # replace persistent prop_val1/2 by the new compressed BATs
    prop_val1 := nil;
    bat(batname1).persists(false).rename(batname1 + "_");
    cprval1_newprop.reverse.persists(true).bbpname(batname1);
    prop_val2 := nil;
    bat(batname2).persists(false).rename(batname2 + "_");
    cprval2_newprop.reverse.persists(true).bbpname(batname2);
}

PROC compress_properties(str name) : void :=
{
    if (not(doc_name.reverse.exist(name)))
	ERROR("Document %s does not exist\n",name);
    var docid := str(int(doc_name.reverse.find(name)));
    
    var batname := "pre_prop" + docid;
    var pre_prop := bat(batname);
    var pre_kind := bat("pre_kind" + docid);
    var pre_newprop := new(oid,oid);
   
    # eliminate property duplicates in each BAT prop_*
    # (in case of tag-names and PIs every unique combination of
    #  ns:loc, (resp. tgt:ins) gets a property ID)
    pre_newprop.insert(pre_prop.semijoin(pre_kind.select(DOCUMENT)));
    var tmp := pre_prop.semijoin(pre_kind.select(ELEMENT));
    compress_val(tmp, pre_newprop, ("prop_loc" + docid), ("prop_ns" + docid));
    tmp := pre_prop.semijoin(pre_kind.select(TEXT));
    compress_val(tmp, pre_newprop, ("prop_text" + docid));
    tmp := pre_prop.semijoin(pre_kind.select(COMMENT));
    compress_val(tmp, pre_newprop, ("prop_com" + docid));
    tmp := pre_prop.semijoin(pre_kind.select(PI));
    compress_val(tmp, pre_newprop, ("prop_ins" + docid), ("prop_tgt" + docid));
    
    # replace persistent pre_prop by the new BAT with compressed property IDs
    pre_newprop := pre_newprop.sort.reverse.mark(PRE_BASE).reverse;
    pre_prop := nil;
    bat(batname).persists(false).rename(batname + "_");
    pre_newprop.persists(true).bbpname(batname);
    
    commit;
}
ADDHELP("compress_properties", "rode", "Nov 2003",
"PARAMETERS:\n\
str document name\n\
DESCRIPITON:\n\
compression of property duplicates\n\
(this function should be called if the loader was used without property compression)",
"pathfinder");

# called by "doc_to_working_set" when importing properties
PROC add_properties(BAT[oid,oid] pre_prop, BAT[oid,oid] pre_newprop,
                    BAT[void,str] Tprop_val, str batname) : oid :=
{
    # get the actual property ID offset
    var new_prop_base := oid(int(Tprop_val.seqbase) + Tprop_val.count);

    # get the <prop/val> BAT of the new document
    var prop_val := bat(batname);

    # import all new property values and replace the corresponding
    # property IDs 
    var prop_newprop := prop_val.mirror.mark(new_prop_base);
    pre_newprop.insert(pre_prop.join(prop_newprop));
    Tprop_val.insert(prop_val.reverse.mark(new_prop_base).reverse);

    return new_prop_base;
}

PROC doc_to_working_set(str name) : void :=
{
    if (not(doc_name.reverse.exist(name)))
	ERROR("Document %s does not exist\n",name);
    var docid := doc_name.reverse.find(name);

    var new_pre_base := oid(int(PRE_BASE) + Tpre_size.count);
    
    # create document entry for Tdoc_pre, Tdoc_name and update max-height;
    Tdoc_pre.insert(nil, new_pre_base);
    Tdoc_name.insert(nil, name);
    Theight := max(Theight, doc_height.find(docid));

    docid := str(int(docid));

    # append the size and level table to the respective T-BATs
    Tpre_size.insert(bat("pre_size" + docid).reverse.mark(new_pre_base).reverse);
    Tpre_level.insert(bat("pre_level" + docid).reverse.mark(new_pre_base).reverse);
    Tpre_kind.insert(bat("pre_kind" + docid).reverse.mark(new_pre_base).reverse);

    # append the property BATs
    var pre_prop := bat("pre_prop" + docid).reverse.mark(new_pre_base).reverse;
    var pre_newprop := new(oid,oid);
    
    pre_newprop.insert(pre_prop.semijoin(Tpre_kind.select(DOCUMENT)));
    var tmp := pre_prop.semijoin(Tpre_kind.select(ELEMENT));
    tmp_seqbase := add_properties(tmp, pre_newprop, Tprop_loc, "prop_loc" + docid);
    Tprop_ns.insert(bat("prop_ns" + docid).reverse.mark(tmp_seqbase).reverse);
    tmp := pre_prop.semijoin(Tpre_kind.select(TEXT));
    add_properties(tmp, pre_newprop, Tprop_text, "prop_text" + docid);
    tmp := pre_prop.semijoin(Tpre_kind.select(COMMENT));
    add_properties(tmp, pre_newprop, Tprop_com, "prop_com" + docid);
    tmp := pre_prop.semijoin(Tpre_kind.select(PI));
    tmp_seqbase := add_properties(tmp, pre_newprop, Tprop_ins, "prop_ins" + docid);
    Tprop_tgt.insert(bat("prop_tgt" + docid).reverse.mark(tmp_seqbase).reverse);
    
    pre_newprop := pre_newprop.sort.reverse.mark(new_pre_base).reverse;
    Tpre_prop.insert(pre_newprop);

    # append the attribute tables to the respective T-BATs
    var new_attr_base := oid(int(ATTR_BASE) + Tattr_own.count);

    Tattr_ns.insert(bat("attr_ns" + docid).reverse.mark(new_attr_base).reverse);
    Tattr_loc.insert(bat("attr_loc" + docid).reverse.mark(new_attr_base).reverse);
    Tattr_val.insert(bat("attr_val" + docid).reverse.mark(new_attr_base).reverse);

    # the debugmask instructions helps to pass the sorted property,
    # which would be lost otherwise after the [+](int) instruction
    tmp := bat("attr_own" + docid).reverse.mark(new_attr_base).reverse;
    tmp := tmp.[int];
    var orgDebugMask := debugmask();
    var newDebugMask := or(or(2,8),orgDebugMask);
    debugmask(newDebugMask);
    tmp := tmp.[+](int(new_pre_base) - int(PRE_BASE));
    debugmask(orgDebugMask);
    tmp := tmp.[oid];
    Tattr_own.insert(tmp);
}
ADDHELP("doc_to_working_set", "rode", "Nov 2003",
"PARAMETERS:\n\
str document name\n\
DESCRIPITON:\n\
Load persistent document into working set (T-BATs).",
"pathfinder");

PROC clear_working_set() : void :=
{
    Tpre_size := new(void,int).seqbase(PRE_BASE);
    Tpre_level := new(void,chr).seqbase(PRE_BASE);
    Tpre_prop := new(void,oid).seqbase(PRE_BASE);
    Tpre_kind := new(void,chr).seqbase(PRE_BASE);
    Tprop_ns := new(void,str).seqbase(PRE_BASE);
    Tprop_loc := new(void,str).seqbase(PRE_BASE);
    Tprop_text := new(void,str).seqbase(PRE_BASE);
    Tprop_com := new(void,str).seqbase(PRE_BASE);
    Tprop_ins := new(void,str).seqbase(PRE_BASE);
    Tprop_tgt := new(void,str).seqbase(PRE_BASE);
    Tattr_ns := new(void,str).seqbase(ATTR_BASE);
    Tattr_loc := new(void,str).seqbase(ATTR_BASE);
    Tattr_val := new(void,str).seqbase(ATTR_BASE);
    Tattr_own := new(void,oid).seqbase(ATTR_BASE);
    Tdoc_pre := new(void,oid).seqbase(DOC_BASE);
    Tdoc_name := new(void,str).seqbase(DOC_BASE);
    Theight := 0;
}
ADDHELP("clear_working_set", "rode", "Dec 2003",
"DESCRIPITON:\n\
Empty the working set (T-BATs).",
"pathfinder");

PROC delete_doc(str name) : void :=
{
    if (not(doc_name.reverse.exist(name)))
	ERROR("Document %s does not exist\n",name);
    var docid := doc_name.reverse.find(name);
    
    doc_name.delete(docid);
    doc_height.delete(docid);
    
    docid := str(int(docid));
    bat("pre_size" + docid).persists(false);
    bat("pre_level" + docid).persists(false);
    bat("pre_prop" + docid).persists(false);
    bat("pre_kind" + docid).persists(false);
    bat("prop_ns" + docid).persists(false);
    bat("prop_loc" + docid).persists(false);
    bat("prop_text" + docid).persists(false);
    bat("prop_com" + docid).persists(false);
    bat("prop_tgt" + docid).persists(false);
    bat("prop_ins" + docid).persists(false);
    bat("attr_ns" + docid).persists(false);
    bat("attr_loc" + docid).persists(false);
    bat("attr_val" + docid).persists(false);
    bat("attr_own" + docid).persists(false);
    
    commit;
}
ADDHELP("delete_doc", "rode", "Nov 2003",
"PARAMETERS:\n\
str document name\n\
DESCRIPITON:\n\
delete the persistent BATS that store the document.",
"pathfinder");

PROC import_doc(str flnm, str name) : void :=
{
    # create doc_name table in case it does not exist
    if (not(view_bbp_name.reverse.exist("doc_name")))
    {    
        new(oid,str).persists(true).bbpname("doc_name");
        new(oid,int).persists(true).bbpname("doc_height");
    }
    var docid;
    if (doc_name.count = 0) docid := DOC_BASE;
    else docid := oid(int(doc_name.reverse.fetch(doc_name.count - 1)) + 1);
    
    if (doc_name.reverse.exist(name))
	ERROR("Document %s already exists\n",name);

    module("ascii_io");

    printf(">>> Importing '%s' with name '%s'\n",flnm,name);

    # column/line separators (4 columns)
    var seps4 := new (void, str);
    seps4.insert (nil, ",");
    seps4.insert (nil, ",");
    seps4.insert (nil, ",");
    seps4.insert (nil, "\n");

    # column/line separators (2 columns)
    var seps2 := new (void, str);
    seps2.insert (nil, ",");
    seps2.insert (nil, "\n");

    # column/line separators (1 column)
    var seps1 := new (void, str);
    seps1.insert (nil, "\n");

    # table pre|size|level|prop|kind 
    var pre := new (void, str);
    pre.insert (nil, "size");
    pre.insert (nil, "level");
    pre.insert (nil, "prop");
    pre.insert (nil, "kind");

    # column types
    var pre_ty := new (void, str);
    pre_ty.insert (nil, "int");
    pre_ty.insert (nil, "sht");
    pre_ty.insert (nil, "oid");
    pre_ty.insert (nil, "sht");

    # table prop|ns|loc
    var tag := new (void, str);
    tag.insert (nil, "ns");
    tag.insert (nil, "loc");

    # column types
    var tag_ty := new (void, str);
    tag_ty.insert (nil, "str");
    tag_ty.insert (nil, "str");

    # table prop|text
    var text := new (void, str);
    text.insert (nil, "text");

    # column types
    var text_ty := new (void, str);
    text_ty.insert (nil, "str");

    # table prop|com
    var com := new (void, str);
    com.insert (nil, "com");

    # column types
    var com_ty := new (void, str);
    com_ty.insert (nil, "str");

    # table prop|tgt|ins
    var pi := new (void, str);
    pi.insert (nil, "tgt");
    pi.insert (nil, "ins");

    # column types
    var pi_ty := new (void, str);
    pi_ty.insert (nil, "str");
    pi_ty.insert (nil, "str");

    # table att|own|ns|loc|val
    var att := new (void, str);
    att.insert (nil, "own");
    att.insert (nil, "ns");
    att.insert (nil, "loc");
    att.insert (nil, "val");

    # column types
    var att_ty := new (void, str);
    att_ty.insert (nil, "oid");
    att_ty.insert (nil, "str");
    att_ty.insert (nil, "str");
    att_ty.insert (nil, "str");

    # load table pre|size|level|prop|kind 
    tmp := load(pre, seps4, pre_ty, flnm + ".pre", -1);
    
    doc_name.insert(docid, name);
    doc_height.insert(docid, tmp.find("level").max + 1);
    docid := str(int(docid));

    tmp.find("size").persists(true).bbpname("pre_size" + docid);
    tmp.find("level").[chr].copy.persists(true).bbpname("pre_level" + docid);
    tmp.find("prop").persists(true).bbpname("pre_prop" + docid);
    tmp.find("kind").[chr].copy.persists(true).bbpname("pre_kind" + docid);

    # load table prop|ns|loc
    tmp := load(tag, seps2, tag_ty, flnm + ".tag", -1);
    tmp.find("ns").persists(true).bbpname("prop_ns" + docid);
    tmp.find("loc").persists(true).bbpname("prop_loc" + docid);

    # load table prop|text
    tmp := load(text, seps1, text_ty, flnm + ".text", -1);
    tmp.find("text").persists(true).bbpname("prop_text" + docid);

    # load table prop|com
    tmp := load(com, seps1, com_ty, flnm + ".com", -1);
    tmp.find("com").persists(true).bbpname("prop_com" + docid);

    # load table prop|tgt|ins
    tmp := load(pi, seps2, pi_ty, flnm + ".pi", -1);
    tmp.find("tgt").persists(true).bbpname("prop_tgt" + docid);
    tmp.find("ins").persists(true).bbpname("prop_ins" + docid);

    # load table att|own|ns|loc|val
    tmp := load(att, seps4, att_ty, flnm + ".@", -1);
    tmp.find("ns").persists(true).bbpname("attr_ns" + docid);
    tmp.find("loc").persists(true).bbpname("attr_loc" + docid);
    tmp.find("val").persists(true).bbpname("attr_val" + docid);
    tmp.find("own").persists(true).bbpname("attr_own" + docid);

    # save all persistent BATs
    commit;
}
ADDHELP("import_doc", "rode", "Nov 2003",
"PARAMETERS:\n\
str file name (\"/anypath/foo.xml\" if loader output is located in \"/anypath/foo.xml.*\")\n\
str document name in database\n\
DESCRIPITON:\n\
Import files generated by the loader as persistent document.",
"pathfinder");

#############################################
# XML print functions / XML Serialization
#
# - xml_print()
# - xml_print(str docname)
# - xml_print(BAT[oid,any] context set)
#
# The xml_print function serializes the information stored in the
# collection of BATs. Thus, it restores fragments of the textual
# representation of the XML-document.
# xml_print() can be either called without argument, which causes
# printing of the whole working set, or related to a specific document
# or context set. In the latter case, for each node within the context
# set, the node itself and its descendant fragment is printed (even if
# this means to repeatedly print the same information, when context 
# nodes relate to each other on the descendant axis).
#

PROC attr_print(oid pre) : void :=
{
    var attr_list := Tattr_own.uselect(pre);
    var name;
    attr_list@batloop
    {
	# recompose name
	name := Tattr_ns.fetch($h);
	if (name != "") name :+= ":";
	name :+= Tattr_loc.fetch($h);
	# TODO: distinguish quot and apos enclosed attributes
        printf(" %s=\"%s\"", name, Tattr_val.fetch($h));
    }
}

PROC node_print(oid pre, BAT[oid,str] S) : void :=
{
    var kind := Tpre_kind.fetch(pre);
    var prop := Tpre_prop.fetch(pre);
	
    if (kind = ELEMENT)
    {    
	# recompose tag name
	var tag := Tprop_ns.fetch(prop);
	if (tag != "") tag :+= ":";
	tag :+= Tprop_loc.fetch(prop);
	
        printf("<%s",tag);
	attr_print(pre);
	printf(">");

	# push node on S
	S.insert(oid(int(pre) + Tpre_size.fetch(pre)), tag);
    }
    else if (kind = TEXT)
        printf("%s",Tprop_text.fetch(prop));
    else if (kind = COMMENT)
        printf("<!--%s-->",Tprop_com.fetch(prop));
    else if (kind = PI)
        printf("<?%s %s?>",Tprop_tgt.fetch(prop), Tprop_ins.fetch(prop));
    else if (kind = DOCUMENT)
	S.insert(oid(int(pre) + Tpre_size.fetch(pre)), "");
}

PROC endtag_print(oid pre, BAT[oid,str] S) : void :=
{
    # pseudocode of this procedure:
    # while (pre > S.top()) print(name(S.pop()));
    var i := S.count - 1;
    var popped := S.reverse.select(oid(nil), pre, true, false).reverse;
    var poplimit := i - popped.count;
    var tag;
    
    while (i > poplimit)
    {
        # the 'tag != ""'-check is needed, to suppress output
        # if a document node is popped from the stack
        tag := S.fetch(i);
	if (tag != "") printf("</%s>", tag);
	i :-= 1;
    }
    
    S.delete(popped);
}

PROC xml_print(BAT[oid,any] CS) : void :=
{
    if (CS.count = 0) return; 
    
    # line feed
    printf("\n");

    # node stack (storing pre+size and the name of a node)
    var S := new(oid,str);
    
    # cursor moving over the pre values
    var pre;
    var lastpre := Tpre_size.reverse.fetch(Tpre_size.count - 1);
   
    # for all nodes in the context set do ...
    CS@batloop{
        
	pre := $h;
        
	# missing "do...while"-loops in mil ... 
	node_print(pre, S);
	pre := oid(int(pre) + 1);
        endtag_print(pre, S);
	
        while ((S.count > 0) and (pre <= lastpre))
	{
	    node_print(pre, S);
	    pre := oid(int(pre) + 1);
            endtag_print(pre, S);
        }
	# line feed
	printf("\n\n");
    }
}
ADDHELP("xml_print", "rode", "Dec 2003",
"PARAMETERS:\n\
BAT[oid,any] context set\n\
DESCRIPITON:\n\
Print XML-fragment enclosed by each context node.",
"pathfinder");

PROC xml_print() : void :=
{
    xml_print(Tdoc_pre.reverse);
}
ADDHELP("xml_print", "rode", "Dec 2003",
"DESCRIPITON:\n\
Print all XML-documents in the working set.",
"pathfinder");

PROC xml_print(str name) : void :=
{
    if (not(Tdoc_name.reverse.exist(name)))
	ERROR("Document %s does not exist in working set\n",name);
    var docid := int(Tdoc_name.reverse.find(name));	
    xml_print(Tdoc_pre.slice(docid,docid).reverse);
}
ADDHELP("xml_print", "rode", "Dec 2003",
"PARAMETERS:\n\
str document name\n\
DESCRIPITON:\n\
Print XML-document with the specified name.",
"pathfinder");

#############################################
# MIL WRAPPER for AXIS STEPS 
#
# In order to simplify the invocation of the axis steps functions, this
# interface provides...
# 

PROC descendant(BAT[oid,any] ctx) : BAT[oid,void] :=
{
    return scj_desc(Tpre_size, ctx, Theight, Tpre_size.count);
}
ADDHELP("descendant", "rode", "Jan 2004",
"PARAMETERS:\n\
BAT[oid,any] ctx context set\n\
DESCRIPITON:\n\
returns all nodes on the descendant axis of the ctx-nodes.",
"pathfinder");

PROC descendant_or_self(BAT[oid,any] ctx) : BAT[oid,void] :=
{
    return scj_descorself(Tpre_size, ctx, Theight, Tpre_size.count);
}
ADDHELP("descendant_or_self", "rode", "Jan 2004",
"PARAMETERS:\n\
BAT[oid,any] ctx context set\n\
DESCRIPITON:\n\
returns all nodes on the descendant-or-self axis of the ctx-nodes.",
"pathfinder");

PROC ancestor(BAT[oid,any] ctx) : BAT[oid,void] :=
{
    return scj_anc(Tpre_size, ctx, Theight, Tpre_size.count);
}
ADDHELP("ancestor", "rode", "Jan 2004",
"PARAMETERS:\n\
BAT[oid,any] ctx context set\n\
DESCRIPITON:\n\
returns all nodes on the ancestor axis of the ctx-nodes.",
"pathfinder");

PROC ancestor_or_self(BAT[oid,any] ctx) : BAT[oid,void] :=
{
    return scj_ancorself(Tpre_size, ctx, Theight, Tpre_size.count);
}
ADDHELP("ancestor_or_self", "rode", "Jan 2004",
"PARAMETERS:\n\
BAT[oid,any] ctx context set\n\
DESCRIPITON:\n\
returns all nodes on the ancestor-or-self axis of the ctx-nodes.",
"pathfinder");

PROC child(BAT[oid,any] ctx) : BAT[oid,void] :=
{
    return lev_child(Tpre_level, ctx, Theight, Tpre_level.count);
}
ADDHELP("child", "rode", "Jan 2004",
"PARAMETERS:\n\
BAT[oid,any] ctx context set\n\
DESCRIPITON:\n\
returns all nodes on the child axis of the ctx-nodes.",
"pathfinder");

PROC parent(BAT[oid,any] ctx) : BAT[oid,void] :=
{
    return lev_parent(Tpre_level, ctx, Theight, Tpre_level.count);
}
ADDHELP("parent", "rode", "Jan 2004",
"PARAMETERS:\n\
BAT[oid,any] ctx context set\n\
DESCRIPITON:\n\
returns all nodes on the parent axis of the ctx-nodes.",
"pathfinder");

PROC following_sibling(BAT[oid,any] ctx) : BAT[oid,void] :=
{
    return lev_fs(Tpre_level, ctx, Theight, Tpre_level.count);
}
ADDHELP("following_sibling", "rode", "Jan 2004",
"PARAMETERS:\n\
BAT[oid,any] ctx context set\n\
DESCRIPITON:\n\
returns all nodes on the following-sibling axis of the ctx-nodes.",
"pathfinder");

PROC preceding_sibling(BAT[oid,any] ctx) : BAT[oid,void] :=
{
    return lev_ps(Tpre_level, ctx, Theight, Tpre_level.count);
}
ADDHELP("preceding_sibling", "rode", "Jan 2004",
"PARAMETERS:\n\
BAT[oid,any] ctx context set\n\
DESCRIPITON:\n\
returns all nodes on the preceding-sibling axis of the ctx-nodes.",
"pathfinder");

