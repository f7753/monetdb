# pathfinder.mx
#
# Monet runtime support for the Pathfinder XQuery compiler
#
# Copyright Notice:
# -----------------
# 
# The contents of this file are subject to the MonetDB Public
# License Version 1.0 (the "License"); you may not use this file
# except in compliance with the License. You may obtain a copy of
# the License at http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
# 
# Software distributed under the License is distributed on an "AS
# IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
# implied. See the License for the specific language governing
# rights and limitations under the License.
# 
# The Original Code is the ``Pathfinder'' system. The Initial
# Developer of the Original Code is the Database & Information
# Systems Group at the University of Konstanz, Germany. Portions
# created by U Konstanz are Copyright (C) 2000-2003 University
# of Konstanz. All Rights Reserved.
#
# Contributors:
#         Torsten Grust <torsten.grust@uni-konstanz.de>
#         Maurice van Keulen <M.van.Keulen@bigfoot.com>
#         Jens Teubner <jens.teubner@uni-konstanz.de>
#
# $Id$
#

@f pathfinder
@a Torsten Teggy Grust
@a Maurice van Keulen
@a Henning Rode
@t Runtime Support for the Pathfinder XQuery Compiler

@m
.MODULE pathfinder;

@:scjbr_cmd(_void_incl,Result includes nodes exactly on the boundary.)@
@:scjbr_cmd(_void_excl,Result excludes nodes exactly on the boundary.)@

@= scjbr_cmd
.COMMAND staircasejoin_br@1(BAT[oid,oid] doc,
                         BAT[oid,oid] context,
                         int height,
                         int upperbound) : BAT[oid,void] = PFstaircasejoin_br@1;
"PARAMETERS
  doc: document BAT (preorder rank, postorder rank)
  context: context node sequence (preorder rank, postorder rank)
  height: document height
  upperbound: upperbound for size of result context node sequence
DESCRIPTION
doc represents a collection of (x,y) coordinates of nodes where
each x- and each y-coordinate occurs only once. context represents
a sub-collection of 'boundary nodes'. For each boundary node,
staircasejoin uselects all nodes from doc (x-coordinates), which
have an x-coordinate between the boundary node and the next one (or
right edge of the xy-plane in case there is no next), and an y-coordinate
smaller than the y-coordinate of the boundary node. context effectively
represents a boundary in the xy-plane of doc for which staircasejoin
uselects the nodes in the bottom-right part. @2"
@m

.COMMAND child_lev(BAT[void,chr] doc_level,
                   BAT[oid,any] context,
		   int estimation,
                   int height) : BAT[oid,void] = PFchild_lev;
"PARAMETERS
  doc_level: the complete level BAT (preorder rank, level)
  context: context node sequence (preorder rank, *)
  height: document height
  upperbound: upperbound for size of result context node sequence
DESCRIPTION
child step evaluation from the given context."

.COMMAND parent_lev(BAT[void,chr] doc_level,
                   BAT[oid,any] context,
		   int estimation,
                   int height) : BAT[oid,void] = PFparent_lev;
"PARAMETERS
  doc_level: the complete level BAT (preorder rank, level)
  context: context node sequence (preorder rank, *)
  height: document height
  upperbound: upperbound for size of result context node sequence
DESCRIPTION
parent step evaluation from the given context."

.COMMAND followingsibling_lev(BAT[void,chr] doc_level,
                   BAT[oid,any] context,
		   int estimation,
                   int height) : BAT[oid,void] = PFfollowingsibling_lev;
"PARAMETERS
  doc_level: the complete level BAT (preorder rank, level)
  context: context node sequence (preorder rank, *)
  height: document height
  upperbound: upperbound for size of result context node sequence
DESCRIPTION
following-sibling evaluation from the given context."

.COMMAND precedingsibling_lev(BAT[void,chr] doc_level,
                   BAT[oid,any] context,
		   int estimation,
                   int height) : BAT[oid,void] = PFprecedingsibling_lev;
"PARAMETERS
  doc_level: the complete level BAT (preorder rank, level)
  context: context node sequence (preorder rank, *)
  height: document height
  upperbound: upperbound for size of result context node sequence
DESCRIPTION
preceding-sibling evaluation from the given context."

.END pathfinder;

@mil
#############################################
# docmgmt.mil : Document management functions
#
# Each XML-document is stored in a collection of BATs whose name starts
# with the name of the document. During execution of an XQuery, the
# 'working set' of documents is copied to a 'global document' represented
# by the T* collection of BATs.
#
# Each collection contains the following BATs:
# - pre_size    : BAT[oid,int]  Pre-value of node / and its descendant size,
# - pre_level   : BAT[oid,chr]  Pre-value of node / and its level,
# - pre_prop    : BAT[oid,oid]  Pre-value of node / and Property ID,
# - pre_kind    : BAT[oid,chr]  Pre-value of node / and Property ID,
#
# - prop_ns      : BAT[oid,str]  Property ID / and name space,
# - prop_loc     : BAT[oid,str]  Property ID / and local name,
# - prop_text    : BAT[oid,str]  Property ID / and text,
# - prop_com     : BAT[oid,str]  Property ID / and comment,
# - prop_ins     : BAT[oid,str]  Property ID / and processing instruction,
# - prop_tgt     : BAT[oid,str]  Property ID / and processing instruction target,
#
# - attr_ns   : BAT[oid,str]  Attribute ID/ and name space of attribute names
# - attr_loc  : BAT[oid,str]  Attribute ID/ and local name of attribute names
# - attr_val  : BAT[oid,str]  Attribute ID/ Value of attribute nodes
# - attr_own  : BAT[oid,oid]  Attribute ID/ Pre-value of owner
# These are stored in a doc BAT[str,bat] with the name (left) in the
# head and the BAT (right) in the tail.
#
# Document information
# - doc_name    : BAT[oid,str]  Document Id/Document name (incl XML)
# - doc_doc     : BAT[oid,bat]  Document Id/Collection of doc bats
# - doc_height  : BAT[oid,int]  Document Id/Height of document
# - Troot_pre : BAT[oid,oid] Document Id/Pre-value of working document
# - Theight : int  Max. height of docs in working set

var pre_base := 0@0;
var attr_base := 1073741824@0; #2 * 2^29

var Tpre_size;
var Tpre_level;
var Tpre_prop;
var Tpre_kind;
var Tprop_ns;
var Tprop_loc;
var Tprop_text;
var Tprop_com;
var Tprop_ins;
var Tprop_tgt;
var Tattr_ns;
var Tattr_loc;
var Tattr_val;
var Tattr_own;
var Troot_pre;
var Theight:=0;

PROC merge_properties(BAT[void,oid] pre_prop, BAT[oid,oid] pre_propnew,
                      BAT[void,str] Tprop_value, str batname) : void :=
{
        # get the actual property ID offset
	var new_prop_base := oid(int(Tprop_value.seqbase) + Tprop_value.count);
	
	# get the <prop/value> BAT of the new document
	var prop_value := doc.find(batname).copy;
	
	# search for already existing property values and replace the corresponding
	# property IDs in the pre_prop table which will be imported later
	var prop_propnew := prop_value.join(Tprop_value.reverse);
	pre_propnew.insert(pre_prop.join(prop_propnew));
        
	# import all new property values and replace the corresponding
	# property IDs as in the above case
	prop_value := prop_value.kdiff(prop_propnew);
	prop_propnew := prop_value.mirror.mark(new_prop_base);
	pre_propnew.insert(pre_prop.join(prop_propnew));
	Tprop_value.insert(prop_value.reverse.mark(new_prop_base).reverse);
}

PROC merge_properties(BAT[void,oid] pre_prop, BAT[oid,oid] pre_propnew,
                      BAT[void,str] Tprop_value, str batname,
                      BAT[void,str] Tprop_value2, str batname2) : void :=
{
        # get the actual property ID offset
	var new_prop_base := oid(int(Tprop_value.seqbase) + Tprop_value.count);
	
	# get the <prop/value> BAT of the new document
	var prop_value := doc.find(batname).copy;
	var prop_value2 := doc.find(batname2).copy;
	
	# search for already existing property values and replace the corresponding
	# property IDs in the pre_prop table which will be imported later
	var prop_propnew := prop_value.join(Tprop_value.reverse);
	
	var tmp := prop_value2.semijoin(prop_propnew);
	var prop_mark := tmp.mark(0@0);
	var mark_value := tmp.reverse.mark(0@0).reverse;
	var mark_Tvalue := Tprop_value2.semijoin(prop_propnew.reverse).reverse.mark(0@0).reverse;
	var mark_sel := mark_value.[=](mark_Tvalue).select(TRUE);
	prop_propnew.semijoin(prop_mark.join(mark_sel));
	pre_propnew.insert(pre_prop.join(prop_propnew));
        
	# import all new property values and replace the corresponding
	# property IDs as in the above case
	prop_value := prop_value.kdiff(prop_propnew);
	prop_value2 := prop_value2.kdiff(prop_propnew);
	prop_propnew := prop_value.mirror.mark(new_prop_base);
	pre_propnew.insert(pre_prop.join(prop_propnew));
	Tprop_value.insert(prop_value.reverse.mark(new_prop_base).reverse);
	Tprop_value2.insert(prop_value2.reverse.mark(new_prop_base).reverse);
}


PROC doc_to_working_set(str name) : void :=
{
	var docid := doc_name.reverse.find(name);
	var doc := doc_doc.find(docid);

	var new_pre_base := oid(int(pre_base) + Tpre_size.count);
        
	Troot_pre.insert(docid, new_pre_base);
	Theight := max(Theight, doc_height.find(docid));

        # append the size and level table to the respective T-BATs
	Tpre_size.insert(doc.find("pre_size").seqbase(new_pre_base));
	doc.find("pre_size").seqbase(pre_base);
	Tpre_level.insert(doc.find("pre_level").seqbase(new_pre_base));
	doc.find("pre_level").seqbase(pre_base);
	Tpre_kind.insert(doc.find("pre_kind").seqbase(new_pre_base));
	doc.find("pre_kind").seqbase(pre_base);

        # merge and append the property BATs
        if (new_pre_base = pre_base)
	{
	   Tpre_prop.insert(doc.find("pre_prop"));
	   Tprop_ns.insert(doc.find("prop_ns"));
	   Tprop_loc.insert(doc.find("prop_loc"));
	   Tprop_com.insert(doc.find("prop_com"));
	   Tprop_text.insert(doc.find("prop_text"));
	   Tprop_ins.insert(doc.find("prop_ins"));
	   Tprop_tgt.insert(doc.find("prop_tgt"));
	}
	else
	{
	   pre_prop := doc.find("pre_prop").seqbase(new_pre_base);
	   var pre_propnew := new(oid,oid);
           merge_properties(pre_prop, pre_propnew, Tprop_loc, "prop_loc", Tprop_ns, "prop_ns");
           merge_properties(pre_prop, pre_propnew, Tprop_text, "prop_text");
           merge_properties(pre_prop, pre_propnew, Tprop_com, "prop_com");
           merge_properties(pre_prop, pre_propnew, Tprop_ins, "prop_ins", Tprop_tgt, "prop_tgt");
           pre_propnew := pre_propnew.sort.reverse.mark(new_pre_base).reverse;
	   doc.find("pre_prop").seqbase(pre_base);
	   Tpre_prop.insert(pre_propnew);
	}
	
        # append the attribute tables to the respective T-BATs
	var new_attr_base := oid(int(attr_base) + Tattr_own.count);
	
	Tattr_ns.insert(doc.find("attr_ns").seqbase(new_attr_base));
	doc.find("attr_ns").seqbase(attr_base);
	Tattr_loc.insert(doc.find("attr_loc").seqbase(new_attr_base));
	doc.find("attr_loc").seqbase(attr_base);
	Tattr_val.insert(doc.find("attr_val").seqbase(new_attr_base));
	doc.find("attr_val").seqbase(attr_base);

        # the debugmask instructions helps to pass the sorted property,
	# which would be lost otherwise after the [+](int) instruction
	var tmp := doc.find("attr_own").seqbase(new_attr_base);
	tmp := tmp.[int];
	var orgDebugMask := debugmask();
	var newDebugMask := or(or(2,8),orgDebugMask);
	debugmask(newDebugMask);
	tmp := tmp.[+](int(new_pre_base) - int(pre_base));
	debugmask(orgDebugMask);
	tmp := tmp.[oid];
	Tattr_own.insert(tmp);
	doc.find("attr_own").seqbase(attr_base);
}
ADDHELP("doc_to_working_set", "keulen", "May 28, 2003",
"Load persistent document into working set.",
"pathfinder");

PROC import_doc(str flnm, str name) : void :=
{
	printf(">>> Importing '%s' with name '%s'\n",flnm,name);
	
	if (doc_name.reverse.exist(name))
	    ERROR("new_Pdoc: Document %s already exists\n",name);

        # column/line separators (4 columns)
        var seps4 := new (void, str);
        seps4.insert (nil, ",");
        seps4.insert (nil, ",");
        seps4.insert (nil, ",");
        seps4.insert (nil, "\n");
        
        # column/line separators (2 columns)
        var seps2 := new (void, str);
        seps2.insert (nil, ",");
        seps2.insert (nil, "\n");
        
        # column/line separators (1 column)
        var seps1 := new (void, str);
        seps1.insert (nil, "\n");

        # ...............................................................
        # table pre|size|level|prop|kind 
        var pre := new (void, str);
        pre.insert (nil, "size");
        pre.insert (nil, "level");
        pre.insert (nil, "prop");
        pre.insert (nil, "kind");
        
        # column types
        var pre_ty := new (void, str);
        pre_ty.insert (nil, "int");
        pre_ty.insert (nil, "sht");
        pre_ty.insert (nil, "oid");
        pre_ty.insert (nil, "sht");
        
        # ...............................................................
        # table prop|ns|loc
        var tag := new (void, str);
        tag.insert (nil, "ns");
        tag.insert (nil, "loc");
        
        # column types
        var tag_ty := new (void, str);
        tag_ty.insert (nil, "str");
        tag_ty.insert (nil, "str");
        
        # ..............................................................
        # table prop|text
        var text := new (void, str);
        text.insert (nil, "text");
        
        # column types
        var text_ty := new (void, str);
        text_ty.insert (nil, "str");
        
        # ..............................................................
        # table prop|com
        var com := new (void, str);
        com.insert (nil, "com");
        
        # column types
        var com_ty := new (void, str);
        com_ty.insert (nil, "str");
        
        # ..............................................................
        # table prop|tgt|ins
        var pi := new (void, str);
        pi.insert (nil, "tgt");
        pi.insert (nil, "ins");
        
        # column types
        var pi_ty := new (void, str);
        pi_ty.insert (nil, "str");
        pi_ty.insert (nil, "str");
        
        # ..............................................................
        # table att|own|ns|loc|val
        var att := new (void, str);
        att.insert (nil, "own");
        att.insert (nil, "ns");
        att.insert (nil, "loc");
        att.insert (nil, "val");
        
        # column types
        var att_ty := new (void, str);
        att_ty.insert (nil, "oid");
        att_ty.insert (nil, "str");
        att_ty.insert (nil, "str");
        att_ty.insert (nil, "str");
        
        # ..............................................................
        # initiate the load
        var doc := new(str,BAT); 
       
        tmp := load(pre, seps4, pre_ty, flnm + ".pre", -1);
	var h := tmp.find("level").max + 1;
	doc.insert("pre_size", tmp.find("size"));
	doc.insert("pre_level", tmp.find("level").[chr].copy);
	doc.insert("pre_prop", tmp.find("prop"));
	doc.insert("pre_kind", tmp.find("kind").[chr].copy);

        tmp := load(tag, seps2, tag_ty, flnm + ".tag", -1);
	doc.insert("prop_ns", tmp.find("ns"));
	doc.insert("prop_loc", tmp.find("loc"));
	
        tmp := load(text, seps1, text_ty, flnm + ".text", -1);
	doc.insert("prop_text", tmp.find("text"));
	
        tmp := load(com, seps1, com_ty, flnm + ".com", -1);
	doc.insert("prop_com", tmp.find("com"));
	
        tmp := load(pi, seps2, pi_ty, flnm + ".pi", -1);
	doc.insert("prop_tgt", tmp.find("tgt"));
	doc.insert("prop_ins", tmp.find("ins"));
	
        tmp := load(att, seps4, att_ty, flnm + ".@", -1);
	doc.insert("attr_ns", tmp.find("ns").seqbase(attr_base));
	doc.insert("attr_loc", tmp.find("loc").seqbase(attr_base));
	doc.insert("attr_val", tmp.find("val").seqbase(attr_base));
	doc.insert("attr_own", tmp.find("own").seqbase(attr_base));
        
	# persistent storage of the document
	doc_name.insert(nil, name);
	doc_doc.insert(nil, doc);
	doc_height.insert(nil, h);
}
ADDHELP("import_doc", "keulen", "May 28, 2003",
"Import files flnm.* generated by xml-loader as persistent document\nwith name.","pathfinder");

PROC Pdoc_init() : void :=
{
	new(void,str).persists(true).seqbase(pre_base).bbpname("doc_name");
	new(void,bat).persists(true).seqbase(pre_base).bbpname("doc_doc");
	new(void,int).persists(true).seqbase(pre_base).bbpname("doc_height");
}
ADDHELP("Pdoc_init", "keulen", "May 28, 2003",
"Initialize the BATs for storage of persistent documents.","pathfinder");

PROC T_init() : void :=
{
	Tpre_size := new(void,int).seqbase(pre_base);
	Tpre_level := new(void,chr).seqbase(pre_base);
	Tpre_prop := new(void,oid).seqbase(pre_base);
	Tpre_kind := new(void,chr).seqbase(pre_base);
	Tprop_ns := new(void,str).seqbase(pre_base);
	Tprop_loc := new(void,str).seqbase(pre_base);
	Tprop_text := new(void,str).seqbase(pre_base);
	Tprop_com := new(void,str).seqbase(pre_base);
	Tprop_ins := new(void,str).seqbase(pre_base);
	Tprop_tgt := new(void,str).seqbase(pre_base);
	Tattr_ns := new(void,str).seqbase(attr_base);
	Tattr_loc := new(void,str).seqbase(attr_base);
	Tattr_val := new(void,str).seqbase(attr_base);
	Tattr_own := new(void,oid).seqbase(attr_base);
	Troot_pre := new(void,oid).seqbase(pre_base);
}
ADDHELP("T_init", "keulen", "May 28, 2003",
"Initialize the BATs for storage of the working set of documents.",
"pathfinder");

