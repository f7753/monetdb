# Copyright Notice:
# -----------------
# 
# The contents of this file are subject to the MonetDB Public
# License Version 1.0 (the "License"); you may not use this file
# except in compliance with the License. You may obtain a copy of
# the License at http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
# 
# Software distributed under the License is distributed on an "AS
# IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
# implied. See the License for the specific language governing
# rights and limitations under the License.
# 
# The Original Code is the ``Pathfinder'' system. The Initial
# Developer of the Original Code is the Database & Information
# Systems Group at the University of Konstanz, Germany. Portions
# created by U Konstanz are Copyright (C) 2000-2004 University
# of Konstanz. All Rights Reserved.
#
# Contributors:
#         Torsten Grust <torsten.grust@uni-konstanz.de>
#         Maurice van Keulen <M.van.Keulen@bigfoot.com>
#         Jens Teubner <jens.teubner@uni-konstanz.de>
#
# $Id$

@f ll_staircasejoin
@a Stefan Manegold
@a Jan Rittinger
@t loop-lifted staircasejoin

@c

/**********************************************
* ll_staircasejoin.c : staircase join operators
*
*/

#include <gdk.h>
#include <xtables.proto.h>
#include "pathfinder.h"

#if 0
#define prefetch_loc(addr) \
/* Parameters */
const int PF_SOFTWARE_PREFETCH = 128;

/* software prefetching is not used currently */
  __asm__ __volatile__ ("prefetchnta %0" \
                        : \
                        : \
                        "m" (*(((char*)(size_t)(((unsigned int)(size_t)(addr))&~0x7f)))))
                            /* StM: extended casting to pacify 64-bit compilers */
#else
#define prefetch_loc(addr)
#endif

/*******************************************************************/

/* DESCENDANT STEP */
@:ll_head(descendant)@
@:ll_specialcases@
    self = FALSE;
    res_size = BATcount(iter_bat);	/* FIXME: estimate size! */
    chunk_size = 1000;			/* FIXME: estimate size! */
@:ll_resultallocation@
@:ll_main(descendant)@
@:ll_end@

/* DESCENDANT-OR-SELF STEP */
@:ll_head(descendant_or_self)@
@:ll_specialcases@
    self = TRUE;
    res_size = BATcount(iter_bat);	/* FIXME: estimate size! */
    chunk_size = 1000;			/* FIXME: estimate size! */
@:ll_resultallocation@
@:ll_main(descendant)@
@:ll_end@

/* CHILD STEP */
@:ll_head(child)@
@:ll_specialcases@
    res_size = BATcount(iter_bat);	/* FIXME: estimate size! */
@:ll_resultallocation@
@:ll_main(child)@
@:ll_reorder_res@
@:ll_end@

/* Templates / Wrappers */

@= ll_head
static int
ll_@1 (BAT **res, BAT *iter_bat, BAT *ctx_bat, BAT *pre_size, int height, oid fst_iter, oid lst_iter, bit self);
int
PFll_@1 (BAT **result, BAT *iter_bat, BAT *ctx_bat, oid *fragment, BAT *workingset)
{
    /* --------------------------- declaration ----------------------------- */

    char *name = "PFll_@1";
    bit self = FALSE;
    BAT *res = NULL;
    BAT *iter_chunk = NULL, *ctx_chunk = NULL;
    BAT *pre_size_bat = NULL, *pre_size_frag = NULL;
    size_t res_size = 0;
    size_t chunk_size = 0;
    oid pre_size_id = (oid)PRE_SIZE;
    oid doc_height_id = (oid)HEIGHT;
    int doc_height = 0;
    BUN p;

@= ll_specialcases
    /* --------------------------- special cases --------------------------- */
    BATcheck(iter_bat, name);
    BATcheck(ctx_bat, name);
    BATcheck(workingset, name);
    if (!(BAThdense(iter_bat) && BAThdense(ctx_bat)))
    {
        GDKerror("%s: both iter_bat and ctx_bat must have a dense head.\n", name);
        @:ll_return(GDK_FAIL)@
    }
    if ((iter_bat->hseqbase != ctx_bat->hseqbase) || (BATcount(iter_bat) != BATcount(ctx_bat)))
    {
        GDKerror("%s: iter_bat and ctx_bat must be head-aligned, i.e., have equal head seqbases and length.\n", name);
        @:ll_return(GDK_FAIL)@
    }
    if (!(BATtordered(iter_bat) & 1))
    {
        GDKerror("%s: iter_bat must be ordered on tail.\n", name);
        @:ll_return(GDK_FAIL)@
    }
    if (!BAThdense(workingset))
    {
        GDKerror("%s: workingset must have a dense head.\n", name);
        @:ll_return(GDK_FAIL)@
    }
    if (BATcount(workingset) == 0)
    {
        GDKerror("%s: workingset must not be empty.\n", name);
        @:ll_return(GDK_FAIL)@
    }
    if (BATcount(workingset) != WS_SIZE)
    {
        GDKerror("%s: inconsistent workingset: |workingset| = " SZFMT " != WS_SIZE = %d.\n", 
                 name, BATcount(workingset), WS_SIZE);
        @:ll_return(GDK_FAIL)@
    }

    BUNfndVOID(p, workingset, &pre_size_id);
    if (p == NULL)
    {
        GDKerror("%s: inconsistent workingset: PRE_SIZE not found.\n", name);
        @:ll_return(GDK_FAIL)@
    }
    pre_size_bat = BATdescriptor(*(bat*)BUNtloc(workingset, p));
    BATcheck(pre_size_bat, name);
    if (!BAThdense(pre_size_bat))
    {
        GDKerror("%s: inconsistent workingset: head of pre_size_bat not dense.\n", name);
        @:ll_return(GDK_FAIL)@
    }
    if (pre_size_bat->ttype != TYPE_bat)
    {
        GDKerror("%s: inconsistent workingset: tail of pre_size_bat not type BAT.\n", name);
        @:ll_return(GDK_FAIL)@
    }

    BUNfndVOID(p, pre_size_bat, fragment);
    if (p == NULL)
    {
        GDKerror("%s: inconsistent workingset: fragment " SZFMT " not found in PRE_SIZE.\n", name, *fragment);
        @:ll_return(GDK_FAIL)@
    }
    pre_size_frag = BATdescriptor(*(bat*)BUNtloc(pre_size_bat, p));
    BATcheck(pre_size_frag, name);
    if (!BAThdense(pre_size_frag))
    {
        GDKerror("%s: inconsistent workingset: head of pre_size_frag not dense.\n", name);
        @:ll_return(GDK_FAIL)@
    }
    if (pre_size_frag->ttype != TYPE_int)
    {
        GDKerror("%s: inconsistent workingset: tail of pre_size_frag not type INT.\n", name);
        @:ll_return(GDK_FAIL)@
    }

    BUNfndVOID(p, workingset, &doc_height_id);
    if (p == NULL)
    {
        GDKerror("%s: inconsistent workingset: HEIGHT not found.\n", name);
        @:ll_return(GDK_FAIL)@
    }
    doc_height = *(int*)BUNtloc(workingset, p);

    if (BATcount(iter_bat) == 0)
    {
        res = BATnew(TYPE_oid, TYPE_oid, 0);
        BATkey (res, TRUE);
        res->hsorted = GDK_SORTED;
        res->hdense = TRUE;
        BATseqbase (res, (oid)0); /* does not really matter */
        BATkey (BATmirror(res), TRUE);
        res->tsorted = TRUE;
        res->tdense = TRUE;
        BATseqbase (BATmirror(res), (oid)0); /* does not really matter */
        *result = res;
        @:ll_return(GDK_SUCCEED)@
    }

    chunk_size = BATcount(iter_bat);

@- ll_resultallocation
    /* --- result bat allocation. for result size use res_size parameter --- */
    res = BATnew(TYPE_oid, TYPE_oid, res_size);
    if (res == NULL) 
    { 
        GDKerror("%s: could not allocate a result BAT[oid,oid] of size " SZFMT ".\n", name, res_size);
        @:ll_return(GDK_FAIL)@
    }

@= ll_sort_2
    /* --------- sort on two criteria (i.e., BAT tails): (major, minor) ------- */
    /* 
     * @1: major
     * @2: minor
     */
{
    BAT *b1 = NULL, *b2 = NULL, *b3 = NULL;
    bit err = TRUE;
    if ((b1 = BATmirror(BATsetaccess(BATsort(BATmirror(@1)), BAT_READ))) == NULL)
    {
        GDKerror("%s: sort failed.\n", name);
    }
    else if (CTrefine(&b2, b1, @2) == GDK_FAIL)
    {
        GDKerror("%s: CTrefine failed.\n", name);
    }
    else if ((b3 = BATmirror(BATmark(b2, (oid)0))) == NULL)
    {
        GDKerror("%s: mark failed.\n", name);
    }
    else if ((@1 = BATsetaccess(BATleftfetchjoin(b3, @1, BATcount(b3)), BAT_READ)) == NULL)
    {
        GDKerror("%s: first leftfetchjoin failed.\n", name);
    }
    else if ((@2 = BATsetaccess(BATleftfetchjoin(b3, @2, BATcount(b3)), BAT_READ)) == NULL)
    {
        GDKerror("%s: second leftfetchjoin failed.\n", name);
    }
    else
    {
        err = FALSE;
    }
    if (b1) BBPunfix(b1->batCacheid);
    if (b2) BBPunfix(b2->batCacheid);
    if (b3) BBPunfix(b3->batCacheid);
    if (err)
    {
        @:ll_return(GDK_FAIL)@
    }
}

@= ll_split_bat
    /* ----- BAT[any::1,any::2] => BAT[void,any::1] & BAT[void,any::2] ----- */
    /* 
     * @1: in
     * @2: head-out
     * @3: tail-out
     */
    if ((@2 = BATmirror(BATmark(@1, (oid)0))) == NULL)
    {
        GDKerror("%s: head-mark failed.\n", name);
        @:ll_return(GDK_FAIL)@
    }
    if ((@3 = BATmirror(BATmark(BATmirror(@1), (oid)0))) == NULL)
    {
        GDKerror("%s: tail-mark failed.\n", name);
        @:ll_return(GDK_FAIL)@
    }

@= ll_merge_bats
    /* ----- BAT[void,any::1] & BAT[void,any::2] => BAT[any::1,any::2] ----- */
    /* 
     * @1: head-in
     * @2: tail-in
     * @3: out
     */
    if ((@3 = BATsetaccess(BATleftfetchjoin(BATmirror(@1), @2, BATcount(@1)), BAT_READ)) == NULL)
    {
        GDKerror("%s: leftfetchjoin failed.\n", name);
        @:ll_return(GDK_FAIL)@
    }
     
@= ll_main
    /* ---------------------------- main part ----------------------------- */
    /* 
     * @1: step name
     */
{
    int    bun_size = BUNsize(iter_bat);
    BUN    max_BUN  = BUNlast(iter_bat);
    BUN    fst_BUN  = BUNfirst(iter_bat);
    size_t fst_idx  = 0;

    while (fst_BUN < max_BUN)
    {
        BAT *iter_tmp = NULL, *ctx_tmp = NULL;
        oid    fst_iter = *(oid*)BUNtail(iter_bat, fst_BUN);
        oid    lst_iter = oid_nil;
        oid    max_iter = fst_iter + chunk_size;
        size_t lst_idx  = fst_idx  + 1;
        BUN    lst_BUN  = fst_BUN  + bun_size;

	/* FIXME/TODO: use binary search (SORTfndfirst/SORTfndlast) on [fst_BUN,max_BUN] ? */
        while (lst_BUN < max_BUN && *(oid*)BUNtail(iter_bat, lst_BUN) < max_iter)
        {
            lst_BUN += bun_size;
            lst_idx++;
        }
        lst_iter = *(oid*)BUNtail(iter_bat, lst_BUN - bun_size);

        iter_tmp = iter_chunk = BATslice(iter_bat, fst_idx, lst_idx);
        ctx_tmp  = ctx_chunk  = BATslice(ctx_bat,  fst_idx, lst_idx);
        @:ll_sort_2(ctx_chunk, iter_chunk)@
        BBPunfix(iter_tmp->batCacheid);
        BBPunfix(ctx_tmp->batCacheid);

        if (ll_@1(&res, iter_chunk, ctx_chunk, pre_size_frag, doc_height, fst_iter, lst_iter, self) == GDK_FAIL)
        {
            @:ll_return(GDK_FAIL)@
        }
        BBPunfix(ctx_chunk->batCacheid);
        BBPunfix(iter_chunk->batCacheid);
        ctx_chunk = iter_chunk = NULL;

        fst_BUN  = lst_BUN;
        fst_idx  = lst_idx;
    }
    
}   

@= ll_reorder_res
{
    BAT *iter_tmp = NULL, *ctx_tmp = NULL;

    @:ll_split_bat(res, iter_chunk, ctx_chunk)@
    BBPreclaim(res);

    iter_tmp = iter_chunk;
    ctx_tmp = ctx_chunk;
    @:ll_sort_2(iter_chunk, ctx_chunk)@
    BBPunfix(iter_tmp->batCacheid);
    BBPunfix(ctx_tmp->batCacheid);

    @:ll_merge_bats(iter_chunk, ctx_chunk, res)@
}

@= ll_end
    /* ---------------------------- end of main part --------------------------
     * tidy up and propagate result properties
     */

    *result = res;

    @:ll_return(GDK_SUCCEED)@
}

@= ll_return
    if (res && (@1 == GDK_FAIL))
        BBPreclaim(res);
    if (iter_chunk && (iter_chunk != iter_bat))
        BBPunfix(iter_chunk->batCacheid);
    if (ctx_chunk && (ctx_chunk != ctx_bat))
        BBPunfix(ctx_chunk->batCacheid);
    if (pre_size_bat)
        BBPunfix(pre_size_bat->batCacheid);
    if (pre_size_frag)
        BBPunfix(pre_size_frag->batCacheid);
    return @1;
@c

/* ============================== Step implementations ==================== */

/* ------------------------------ Child ----------------------------------- */

typedef struct stack_item_C si_C;

struct stack_item_C {
    oid ctx;            /* ctx node (preorder rank) */
    oid eocs;           /* end of ctx scope (pre + size) */
    oid next_child;     /* preorder rank of the next child node */
    BUN first;          /* first iter row of the actual ctx node */
    BUN last;           /* last iter row of the actual ctx node */
};

static int
ll_child ( BAT **result, BAT *iter_bat, BAT *ctx_bat, BAT *pre_size, int height, oid fst_iter, oid lst_iter, bit self)
{
    BAT *res = *result;
    si_C *stack = 0;
    int stack_top = 0, ctx_bunsize = 0, iter_bunsize = 0, *size = 0;
    oid pre = 0, ctx = 0;
    BUN cur_bun = 0, iter_bun = 0, ctx_bun = 0, ctx_last = 0;

    /* not used, here; keep compilers happy */
    (void)fst_iter;
    (void)lst_iter;
    (void)self;

    /* stack for context set nodes will never grow over height of doc. tree */
    stack = (si_C*)GDKmalloc(sizeof(si_C) * (height + 1));
    if (stack == NULL) {
        GDKerror("ll_child: could not allocate stack of size %d.\n", sizeof(si_C) * (height + 1));
        return GDK_FAIL;
    }
    stack_top = 0;

    /* definition for "array-like" access on size values of given nodes */
    /* ! FIXME: works only if BUNsize(pre_size) == sizeof(int) !!!!!!!! */
    size = ((int*) BUNtloc(pre_size, BUNfirst(pre_size))) - pre_size->hseqbase;

    iter_bunsize = BUNsize(iter_bat);
    ctx_bunsize = BUNsize(ctx_bat);

    iter_bun = BUNfirst(iter_bat);
    ctx_bun = BUNfirst(ctx_bat);
    ctx_last = BUNlast(ctx_bat);
    ctx = *(oid*)BUNtail(ctx_bat,ctx_bun);

@= getnextctx
    iter_bun += iter_bunsize;
    ctx_bun += ctx_bunsize;
    ctx = *(oid*)BUNtail(ctx_bat,ctx_bun);
@
@= pushctx
    si_C new_stack_item;
    new_stack_item.ctx = ctx;
    new_stack_item.eocs = ctx + size[ctx];
    new_stack_item.next_child = ctx + 1;
    new_stack_item.first = iter_bun;
    new_stack_item.last = iter_bun;
    stack[stack_top++] = new_stack_item;
@
@= popctx
    stack_top--;
@
@c

    /* iterate over all context nodes - evaluation is only done
       starting from the ctx (on the top of the stack) until
       the next ctx node (or the end of the stack top
       ctx node scope) is reached */
    while (ctx_bun < ctx_last) {
        /* if the stack is empty the next ctx node
           has to be pushed on the stack 
           and the next ctx node is called*/
        if (!stack_top) {
            @:pushctx@
            @:getnextctx@
        }
        /* only a new iter has to be added
           to the list of active iters */
        else if (stack[stack_top-1].ctx == ctx) {
            stack[stack_top-1].last = iter_bun;
            @:getnextctx@
        }
        /* evaluates the ctx node on top of the stack
           until a descendant is reached. The descendant is then
           pushed on the stack and is the new active ctx */
        else if (stack[stack_top-1].eocs >= ctx) {
            @:inner_loop_child(ctx)@
            stack[stack_top-1].next_child = pre;
            @:pushctx@
            @:getnextctx@
        }
        /* evaluates the ctx node on top of the stack
           until the end of its scope is reached. Then the
           node is popped and the next cycle is called with
           the same ctx node to first activate older nodes
           on the stack */
        else {
            @:inner_loop_child(stack[stack_top-1].eocs)@
            @:popctx@
        }
    }
    /* need to process the ctx nodes, which are still on the stack 
       - only need to evaluate the inner loop and pop, because 
         there are no more new ctx nodes */
    while (stack_top) {
        @:inner_loop_child(stack[stack_top-1].eocs)@
        @:popctx@
    }

@
@= inner_loop_child
    pre = stack[stack_top-1].next_child;
    /* iterates over all childs until the next limit is reached
       (either descendant ctx node or end of scope) and prunes
       all subtree which can't hold any matches */
    for (; pre <= @1; pre += size[pre] + 1) {
        /* creates a row for every iter, whose ctx node produced
           a match */
        for (cur_bun = stack[stack_top-1].first;
             cur_bun <= stack[stack_top-1].last;
             cur_bun += iter_bunsize) {
            bunfastins(res,  (oid*)BUNtail(iter_bat,cur_bun), &pre);
        }
    }
@
@c

    GDKfree(stack);
{
    bit trivial = (BATcount(res) < 2);
    res->batDirty = TRUE;
    res->hdense = trivial;
    if (trivial) {
        if (BATcount(res) == 0) {
            BATseqbase (res, (oid)0); /* does not really matter */
        } else {
            BATseqbase (res, *(oid*)BUNhead(res, BUNfirst(res)));
        }
    }
    res->hsorted = (trivial?GDK_SORTED:0); /*might be GDK_SORTED in some more cases... */
    BATkey(res,trivial); /* might be TRUE in some more cases... */
    res->tdense = trivial;
    if (trivial) {
        if (BATcount(res) == 0) {
            BATseqbase (BATmirror(res), (oid)0); /* does not really matter */
        } else {
            BATseqbase (BATmirror(res), *(oid*)BUNtail(res, BUNfirst(res)));
        }
    }
    res->tsorted = GDK_SORTED;
    BATkey(BATmirror(res),trivial); /* might be TRUE in some more cases... */
}
    *result = res;    
    return GDK_SUCCEED;
bunins_failed:
    GDKfree(stack);
    GDKerror("ll_child: bunins failed.\n");
    *result = res;    
    return GDK_FAIL;
}


/* ------------------------------ Descendant ------------------------------ */

typedef struct stack_item_D si_D;

struct stack_item_D {
    oid iter_idx;       /* index of iter */
    oid ctx;            /* ctx node (preorder rank) */
    oid eocs;           /* end of ctx scope (pre + size) */
};

#define OST unsigned long long		/* type for "onstack" bitvector: "lng" or "chr" */

#define onstack_set(b)	 onstack[(b)>>OST_shift] |=   ((OST)1)<<((b)&OST_mask) 
#define onstack_clr(b)	 onstack[(b)>>OST_shift] &= ~(((OST)1)<<((b)&OST_mask))
#define onstack_get(b)	(onstack[(b)>>OST_shift] &   (((OST)1)<<((b)&OST_mask)))

static int
ll_descendant ( BAT **result, BAT *iter_bat, BAT *ctx_bat, BAT *pre_size, int height, oid fst_iter, oid lst_iter, bit self )
{
    BAT *res = *result;
    BAT **tmp_res = NULL;
    si_D *stack = 0;
    OST *onstack = 0;
    int stack_size = 0, onstack_size = 0;
    int stack_top = 0, ctx_bunsize = 0, iter_bunsize = 0, *size = 0;
    oid pre = 0, ctx = 0, iter_idx = 0;
    BUN iter_bun = 0, ctx_bun = 0, ctx_last = 0;
    oid num_iters = (lst_iter - fst_iter) + 1, i;
    int OST_bytes = sizeof(OST);
    int OST_bits  = OST_bytes * 8;
    int OST_mask  = OST_bits - 1;
    int OST_shift = 0;
    
    for (i=OST_mask; i; i>>=1) OST_shift++;

    /* stack for context set nodes will never grow over
       height of doc. tree times number of iters */
    stack_size = sizeof(si_D) * (height + 1) * num_iters;
    stack = (si_D*)GDKmalloc(stack_size);
    if (stack == NULL) {
        GDKerror("ll_descendant: could not allocate stack of size %d.\n", stack_size);
        @:ll_fail_descendant@
    }
    stack_top = 0;

    /* bitvektor to maintain which iters are currently on the stack */
    onstack_size = OST_bytes * ((num_iters >> OST_shift) + 1);
    onstack = (OST*)GDKmalloc(onstack_size);
    if (onstack == NULL) {
        GDKerror("ll_descendant: could not allocate bitvector of size %d.\n", onstack_size);
        @:ll_fail_descendant@
    }
    memset(onstack, 0, onstack_size);

    /* temporary results per iter */
    tmp_res = (BAT**)GDKmalloc(num_iters * sizeof(BAT*));
    if (tmp_res == NULL) {
        GDKerror("ll_descendant: could not allocate BAT array of size %d.\n", num_iters);
        @:ll_fail_descendant@
    }
    memset(tmp_res, 0, num_iters * sizeof(BAT*));
    for (i=0; i<num_iters; i++) {
    	size_t tmp_size = 100; 					/* FIXME: estimate size! */
    	tmp_res[i] = BATnew(TYPE_oid, TYPE_oid, tmp_size);
        if (tmp_res[i] == NULL) 
        { 
            GDKerror("ll_descendant: could not allocate result BAT[oid,oid] of size " SZFMT ".\n", tmp_size);
            @:ll_fail_descendant@
        }
    }

    /* definition for "array-like" access on size values of given nodes */
    /* ! FIXME: works only if BUNsize(pre_size) == sizeof(int) !!!!!!!! */
    size = ((int*) BUNtloc(pre_size, BUNfirst(pre_size))) - pre_size->hseqbase;

    iter_bunsize = BUNsize(iter_bat);
    ctx_bunsize = BUNsize(ctx_bat);

    iter_bun = BUNfirst(iter_bat);
    ctx_bun = BUNfirst(ctx_bat);
    ctx_last = BUNlast(ctx_bat);
    ctx = *(oid*)BUNtail(ctx_bat,ctx_bun);
    iter_idx = *(oid*)BUNtail(iter_bat,iter_bun) - fst_iter;

@= getnextctx_D
    iter_bun += iter_bunsize;
    ctx_bun += ctx_bunsize;
    ctx = *(oid*)BUNtail(ctx_bat,ctx_bun);
    iter_idx = *(oid*)BUNtail(iter_bat,iter_bun) - fst_iter;
@
@= pushctx_D
    if (!onstack_get(iter_idx)) {
        si_D new_stack_item;
        new_stack_item.iter_idx = iter_idx;
        new_stack_item.ctx = ctx;
        new_stack_item.eocs = ctx + size[ctx];
        stack[stack_top++] = new_stack_item;
        onstack_set(iter_idx);
        pre = ctx;
        if (self) {
            oid iter = iter_idx + fst_iter;
            bunfastins(tmp_res[iter_idx], &iter, &pre);
        }
        pre++;
    }
@
@= popctx_D
    stack_top--;
    onstack_clr(stack[stack_top].iter_idx);
@
@c

    /* iterate over all context nodes - evaluation is only done
       starting from the ctx (on the top of the stack) until
       the next ctx node (or the end of the stack top
       ctx node scope) is reached */
    while (ctx_bun < ctx_last) {
        /* put the new ctx node on the stack */
        @:pushctx_D@
        @:getnextctx_D@
        /* scan over all iters for the current ctx node;
           only a new (non-active) iters have to be added
           to the list of active iters */
        while (ctx_bun < ctx_last && ctx == stack[stack_top-1].ctx) {
            @:pushctx_D@
            @:getnextctx_D@
        }
        if (ctx_bun < ctx_last) {
            if (ctx <= stack[stack_top-1].eocs) {
                /* find all results between the current ctx node
                   and the next (descendant) ctx node */
                @:inner_loop_descendant(ctx)@
                /* proceed with descendant ctx node */
            } else {
                /* successively finish all active scopes
                   that do not contain the next ctx node */
                while (stack_top && stack[stack_top-1].eocs < ctx) {
                    @:finish_scope_descendant@
                }
            }
        }
    }
    /* need to process the ctx nodes, which are still on the stack 
       - only need to evaluate the inner loop and pop, because 
         there are no more new ctx nodes */
    while (stack_top) {
    	@:finish_scope_descendant@
    }
@
@= finish_scope_descendant
    oid eocs = stack[stack_top-1].eocs;
    /* find all results in the current scope */
    @:inner_loop_descendant(eocs)@
    /* back to enclosing scope: remove all iters that are done */
    while (stack_top && stack[stack_top-1].eocs <= eocs) {
        @:popctx_D@
    }
@
@= inner_loop_descendant
    /* iterate over all descendants until the next limit is reached
       (either descendant ctx node or end of scope) */
    for ( ; pre <= @1; pre++ ) {
        oid iter, idx;
        /* create a row for every iter, whose ctx node produced a match */
        for (iter = fst_iter, idx = 0 ; iter <= lst_iter && idx < num_iters ; iter++, idx++ ) {
            if (onstack_get(idx)) {
                bunfastins(tmp_res[idx ], &iter, &pre);
            }
        }
    }
@
@c

    GDKfree(stack);

    for ( i=0; i<num_iters; i++ ) {
        if (BATcount(tmp_res[i]) > 0) {
            bit trivial = (BATcount(tmp_res[i]) < 2);
            tmp_res[i]->batDirty = TRUE;
            tmp_res[i]->hdense = FALSE;
            tmp_res[i]->hsorted = GDK_SORTED; /* only one iter value */
            BATkey(tmp_res[i],trivial);
            tmp_res[i]->tdense = FALSE;
            tmp_res[i]->tsorted = GDK_SORTED;
            BATkey(BATmirror(tmp_res[i]),trivial); /* might be TRUE in some more cases... */
            res = BATins(res, tmp_res[i]);
            if (res == NULL) {
                GDKerror("ll_descendant: BATins failed.\n");
                @:ll_fail_descendant@
            }
        }
        BBPreclaim(tmp_res[i]);
        if (onstack_get(i)) {
            GDKwarning("ll_descendant: iter %d still on stack !??\n", i + fst_iter);
        }
    }
    GDKfree(tmp_res);
    GDKfree(onstack);
    
    *result = res;    
    return GDK_SUCCEED;
bunins_failed:
    GDKerror("ll_descendant: bunins failed.\n");
    @:ll_fail_descendant@
}

@= ll_fail_descendant
    if (stack) GDKfree(stack);
    if (onstack) GDKfree(onstack);
    if (tmp_res) {
        for (i=0; i<num_iters; i++) {
            if (tmp_res[i]) BBPreclaim(tmp_res[i]);
        }
        GDKfree(tmp_res);
    }
    *result = res;    
    return GDK_FAIL;
@

@c
/* vim:set shiftwidth=4 expandtab: */
