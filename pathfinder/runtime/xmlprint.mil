#############################################
# xmlprint.mil : Functions for XML-export
#

PROC xmlprint(BAT[oid,oid] c, bit verbose) : void :=
{
    context := new(oid,oid);
    nodenum := 1;

    if (verbose) { printf("Sequence of %d nodes:\n",c.count); }
    c@batloop()
    {
        if (verbose)
        {
            printf("Node %d ",nodenum);
            if (Tdoc_text.exist($h)) {
                printf("[text]");
            } else {
                printf("[element]");
            }
            printf(":\n");
            if (Tdoc_text.exist($h)) printf("'");
        }

        if (not(Tdoc_prepost.exist($h)))
        {
            ERROR("xmlprint: Non-existing node in context: %d@0\n",$h);
        }
        
        currootpre := $h;
        currootpost := Tdoc_prepost.find(currootpre);

        context.delete;
        context.insert(currootpre,nil);

        desc := Tdoc_prepost.fragment(currootpre,nil, nil,currootpost);
        nodestack := new(oid,str);  # post and tag name
        lastpost := oid(int(currootpost) + 1);

        desc@batloop()
        {
            pre:=$h; post:=$t;
            tag:=str(nil); txt:=str(nil);
            if (Tdoc_tag.exist(pre)) {
                tag:=decode(enumtag_type, Tdoc_tag.find(pre));
            }
            if (Tdoc_text.exist(pre)) {
                txt:=Tdoc_text.find(pre);
            }

            while (lastpost < post)
            {
                toppost := nodestack.reverse.min;
                poptag := nodestack.find(toppost);
                nodestack.delete(toppost);

                if (not(isnil(poptag))) { printf("</%s>", poptag); }
                lastpost:=nodestack.reverse.min;
            }

            nodestack.insert(post,tag);

            if (not(isnil(tag)))
            {
                printf("<%s", tag);
                attrs := Tdoc_aowner.select(pre);
                attrs@batloop()
                {
                    aname:=decode(enumaname_type, Tdoc_aname.find($h));
                    aval := Tdoc_avalue.find($h);
                    printf(" %s=\"%s\"", aname,aval);
                }
                printf(">");
            }
            else if (not(isnil(txt)))
            {
                printf("%s", txt);
            }

            lastpost := post;
        }
        while (nodestack.count > 0)
        {
            toppost := nodestack.reverse.min;
            poptag := nodestack.find(toppost);
            nodestack.delete(toppost);

            if (not(isnil(poptag))) { printf("</%s>", poptag); }
            lastpost:=nodestack.reverse.min;
        }
        if (verbose and Tdoc_text.exist($h)) printf("'");
        printf("\n");
        nodenum+=1;
    }
}
ADDHELP("xmlprint", "keulen", "June 5, 2003",
"Print each context node as full XML-document.\nc: Nodelist of context (pre-values in head, tail not used)\nverbose: print node ids, etc.",
"pathfinder");


PROC xmlprint(BAT[oid,oid] c) : void :=
{
    c.xmlprint(false);
}
ADDHELP("xmlprint", "keulen", "June 5, 2003",
"Print each context node as full XML-document.\nc: Nodelist of context (pre-values in head, tail not used).",
"pathfinder");

PROC xmlprint() : void :=
{
    # Create context with global root.
    c:=new(oid,oid);
    c.insert(0@0,nil);

    c.xmlprint(false);
}
ADDHELP("xmlprint", "keulen", "June 5, 2003",
"Print document working set as full XML-document.",
"pathfinder");


# vim:set shiftwidth=4 expandtab:
