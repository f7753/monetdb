# Copyright Notice:
# -----------------
# 
# The contents of this file are subject to the MonetDB Public
# License Version 1.0 (the "License"); you may not use this file
# except in compliance with the License. You may obtain a copy of
# the License at http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
# 
# Software distributed under the License is distributed on an "AS
# IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
# implied. See the License for the specific language governing
# rights and limitations under the License.
# 
# The Original Code is the ``Pathfinder'' system. The Initial
# Developer of the Original Code is the Database & Information
# Systems Group at the University of Konstanz, Germany. Portions
# created by U Konstanz are Copyright (C) 2000-2004 University
# of Konstanz. All Rights Reserved.
#
# Contributors:
#         Torsten Grust <torsten.grust@uni-konstanz.de>
#         Maurice van Keulen <M.van.Keulen@bigfoot.com>
#         Jens Teubner <jens.teubner@uni-konstanz.de>
#         Jan Flokstra <flokstra@cs.utwente.nl>
#
# $Id$

@f serialize
@a Jan Flokstra
@t serialize

@c

/*******************************************
* serialize.c : XML serialization
*
* TODO:
* - Decide how to generate output for query results. I propose that we
*   generate output in three different modes:
*   1) "xml", generate the xml output data as we do now.
*   2) "sax", generate the Sax-O-Phone SAX event stream as we do now
*   3) "?galax?", generate exactly the same output as GALAX
*/

#include <gdk.h>
#include <monet.h>

#include <setjmp.h>

#include "pathfinder.h"

static bit is_fake_project (BAT* b)
{
	BATcheck(b, "is_fake_project");
	if ((BATcount(b)==1) && (b->hseqbase==oid_nil)) {
		return TRUE;
	} else {
		return FALSE;
	}
}

#define MAXTAGDEPTH        1024

#define WS_BATS     PRINT_WS_SZ

/**
 *
 * 0. SMALL UTILITY SECTION
 *
 * Here a structure is defined to prevent too much alloc/free actions.
 * If the size of a string is smaller then SMART_STR_SZ the value is
 * stored in stack_buff[] within the structure. Otherwise it is strdupped and
 * freed like usual.
 */


#define SMART_STR_SZ    32

typedef struct {
        char stack_buff[SMART_STR_SZ];
        str  val;
} SmartStrBuff;

static str ssb_alloc(SmartStrBuff* ssb, str s) {
        if ( s ) {
                size_t l = strlen(s)+1;

                if ( l <= SMART_STR_SZ )
                        return ssb->val = memcpy(&ssb->stack_buff,s,l);
                else
                        return ssb->val = strdup(s);
        } else
                return ssb->val = NULL;
}

static void ssb_free(SmartStrBuff* ssb) {
        if ( ssb->val && (ssb->val != (str)&ssb->stack_buff) ) {
                free( ssb->val );
        }
        ssb->val = NULL;
}

/**
 *
 * I. THE CONTEXT NODE DEFINITION AND USAGE PART
 *
 * This structure contains the context of the print session.
 * It has several functions. But its main use is the administration 
 * of all BATs containing the XML documents.
 *
 */

typedef struct {
        int     dmMode;         /* Data model flag, true if printing in
                                 * data-model mode, eg. look like GALAX */
        int     saxMode;        /* true if printing a Sax-O-Phone stream */
        char*   dmSeparator;    /* seperation char in DM mode */
        BAT*    ws;             /* working set BAT */
        int     curFRAG;        /* current fragment used by working set */
        BAT*    curBAT[WS_BATS];/* The BAT's of the current fragment*/
        /* */
        /**
         * Next elements is a stack used during printing to store the 
         * pre-value, name, namespace of the nodes currently being printed. 
         */
        int     stackPtr;    
        struct {
                oid             pre;
                int             empty;  /* boolean indicating node is empty */
                SmartStrBuff    ssb_ns;
                SmartStrBuff    ssb_name;
        } tagStack[MAXTAGDEPTH];
        /* */
        int     nAttrOnLine; /* used by top result print routine to count the
                              * number of top-level result items printed on
                              * the current line.
                              */
        jmp_buf exitPoint;   /* point to jump to after error */
} XqueryCtx;

/** 
 * The error handler which finishes the execution of the print with a 
 * longjmp() to the end.
 */
static void fatal_err(XqueryCtx* ctx, const char *msg, ...) {
    va_list msgs;
    char    errmsg[1024];
        
    va_start (msgs, msg);
    vsnprintf (errmsg, 1024, msg, msgs);
    va_end (msgs);
    /* */
    stream_printf(GDKerr,"\n!ERROR: XML Generation: %s\n",errmsg);
    /* */
    longjmp(ctx->exitPoint,1);
}


/**
 * Functions fills a new context() record with mode and BAT data and
 * initializes all other data structures.
 */

static BAT* fetchWsContextBAT(XqueryCtx* ctx, BAT* ws, int batID, int wsID) {
        BUN bun;
        oid BATid = (oid)batID;
        oid WSid  = (oid)wsID;

	if ( wsID < 0 )
              fatal_err(ctx,"fetchWsContextBAT: NO wsID CONTEXT SELECTED");
        if ( !(bun = BUNfnd(ws,&BATid)) )
              fatal_err(ctx,"fetchWsContextBAT: NOT FOUND BAT[%d]",batID);

        BAT* batbat;
        
        if ( !( batbat = BATdescriptor(*(bat*)bun)) )
                fatal_err(ctx,"fetchWsContextBAT:FETCH BATBAT for WS[%d][%d] FAILED\n",batID ,wsID);

        BUN bbun = BUNfnd(batbat,&WSid);
        BAT *res = NULL;
        if ( !bbun )
                fatal_err(ctx,"fetchWsContextBAT:NOT FOUND BAT[%d][%d] in WS!!!!\n",batID,wsID);
        else {
                if ( !(res = BATdescriptor(*(bat*)bbun)) )
                         fatal_err(ctx,"fetchWsContextBAT:FETCH WS[%d][%d] FAILED\n",batID,wsID);
        }
        BBPunfix( BBPcacheid( batbat ) );
        return res;
}

/**
 * The wsBAT() function is responsible for 'demand-loading' the BAT with index
 * 'batId in the current working set. No BAT is loaded until it is needed. This
 * solves some funny problems with loading BAT's which were not needed
 * anyway.
 */
static BAT* wsBAT(XqueryCtx* ctx, int batId) {
        if ( !ctx->curBAT[batId] ) { 
                if ( !( ctx->curBAT[batId] = 
                        fetchWsContextBAT(ctx,ctx->ws,batId,ctx->curFRAG)) )
                        fatal_err(ctx,"unable to load wsBAT[%d]",batId);
        }
        return ctx->curBAT[batId];
}

static int switchWsContext(XqueryCtx* ctx, int wsID) {
	int res = ctx->curFRAG;

        if ( ctx->curFRAG != wsID ) {
                int i;

                if ( ctx->curFRAG >= 0 ) {
                        /* close the old open context BAT's */
                        for(i=0; i<WS_BATS; i++) {
                                if ( ctx->curBAT[i] ) {
                                        BBPunfix( BBPcacheid(ctx->curBAT[i]));
                                        ctx->curBAT[i] = NULL;
                                }
                        }
                }
                ctx->curFRAG   = wsID;
        }
	return res;
}

static void createWsContext(XqueryCtx* ctx, BAT* ws, int wsID, str mode) {
        int i;

        if ( strcmp(mode,"sax")==0 ) {
            ctx->saxMode = 1;
        } else {
            ctx->saxMode = 0;
            if ( strcmp(mode,"dm")==0 )
                ctx->dmMode = 1;
            else
                ctx->dmMode = 0;
        }
        /* ctx->dmSeparator = "\n"; */
        ctx->dmSeparator = ",\n";
        ctx->ws        = ws;
        ctx->curFRAG   = -1; /* empty, no frag loaded */
        /* initialize with all wsBAT()'s closed */
        for(i=0; i<WS_BATS; i++) {
                ctx->curBAT[i] = NULL;
        }
        /* */
        if ( wsID >= 0 )
                switchWsContext(ctx, wsID);
        /* */
        ctx->stackPtr  = 0;
}

/**
 * Return if there are still nodes on stack.
 */
static int moreTags(XqueryCtx* ctx) {
        return (ctx->stackPtr > 0);
}

/**
 * Push the pre-value, namespace and nodename of stack
 */
static void pushTag(XqueryCtx* ctx, oid pre, str ns, str name, int empty) {
        ctx->tagStack[ctx->stackPtr].pre    = pre;
        ctx->tagStack[ctx->stackPtr].empty  = empty;
        ssb_alloc(&ctx->tagStack[ctx->stackPtr].ssb_ns,   ns);
        ssb_alloc(&ctx->tagStack[ctx->stackPtr].ssb_name, name);
        ctx->stackPtr++;
}

/**
 * Three function to retrieve the pre-value, namespace or nodename of the
 * top element on the stack.
 */
static oid topTag(XqueryCtx* ctx)  {return ctx->tagStack[ctx->stackPtr-1].pre;}
static int topEmpty(XqueryCtx* ctx)  {return ctx->tagStack[ctx->stackPtr-1].empty;}
static str topNs(XqueryCtx* ctx)   {return ctx->tagStack[ctx->stackPtr-1].ssb_ns.val;}
static str topName(XqueryCtx* ctx) {return ctx->tagStack[ctx->stackPtr-1].ssb_name.val;}


/**
 * Pop the top element of the stack. Means that processing the node has
 * finished.
 */
static void popTag(XqueryCtx* ctx) {
        /* de-alloc the ns and name strings */
        ssb_free(&ctx->tagStack[ctx->stackPtr-1].ssb_ns);
        ssb_free(&ctx->tagStack[ctx->stackPtr-1].ssb_name);
        --ctx->stackPtr;
}

/**
 *
 * II. THE OUTPUT HANDLER PART 
 *
 * The emit functions are used to encapsulate the Sax-O-Phone event
 * emission functions.
 * The current implementation emits the Sax-O-Phone events as if they are
 * a BAT.
 *
 * TODO: solve characters() newline in string problem. 
 *
 */

static void emit_start() {
        stream_printf(GDKout,"#-------------------------#\n");
        stream_printf(GDKout,"# h     SAXtape           #\n");
        stream_printf(GDKout,"# str   str               #\n");
        stream_printf(GDKout,"#-------------------------#\n");
}

/**
 *
 * The character translation section responsible for the special character
 * recognition and XML entity characters. It consists of a small main table
 * 'isspecial_tab' containing the flags for every possible character.
 * v=0: no special char
 * v=1: special char, should be presented as octal char in output
 * v>1: special char, string repr of char is isspecial_val[v]
 * isspecial_cnt has 2 purposes. 1) variabe use dfilling the tables and
 * 2) as boolean flag to indicate if tables are initialized yet 
 */

static unsigned char  isspecial_tab[UCHAR_MAX+1]; /* the main table */
static char*          isspecial_val[16]; /* the values of the special chars */
static int            isspecial_cnt = 0; /* 0 = tables are not initialized */

static void init_isspecial() {
        int i;

        for(i=0; i<=UCHAR_MAX; i++)
                isspecial_tab[i] = 0;
        for(i=0; i<32; i++)
                isspecial_tab[i] = 1; /* means write as octal */
        isspecial_tab[(int)(unsigned char)'\377'] = 1; /* means write as octal */
        isspecial_val[0] = "[*ERROR*]"; /* not used, 0 = no special meaning */
        isspecial_val[1] = "[*ERROR*]"; /* not used, 1 = write as octal */
        isspecial_cnt    = 2;
        isspecial_tab[(int)'\t']       = isspecial_cnt;
        isspecial_val[isspecial_cnt++] = "\\t";
        isspecial_tab[(int)'\n']       = isspecial_cnt;
        isspecial_val[isspecial_cnt++] = "\\n";
        isspecial_tab[(int)'\\']       = isspecial_cnt;
        isspecial_val[isspecial_cnt++] = "\\\\";
        isspecial_tab[(int)'\"']       = isspecial_cnt;
        isspecial_val[isspecial_cnt++] = "&quot;";
        isspecial_tab[(int)'\'']       = isspecial_cnt;
        isspecial_val[isspecial_cnt++] = "&apos;";
        isspecial_tab[(int)'&']       = isspecial_cnt;
        isspecial_val[isspecial_cnt++] = "&amp;";
        isspecial_tab[(int)'<']       = isspecial_cnt;
        isspecial_val[isspecial_cnt++] = "&lt;";
        isspecial_tab[(int)'>']       = isspecial_cnt;
        isspecial_val[isspecial_cnt++] = "&gt;";
}

/*
 * This function is responsible for the presentation of special characters
 * and XML entity characters in the result.
 */
static void emit_escaped(char* src) {
        /* Emit a string with all special character escaped. Inspired by
         * function strToStr() in gdk_atoms.mx
         */
        int start=0,end;
        unsigned char isspecial_ch;

        if ( !isspecial_cnt ) /* module not initialized yet */
                init_isspecial();
        for(end=0; src[end]; end++) {
            if ( (isspecial_ch = isspecial_tab[(int)src[end]]) ) {
                stream_write(GDKout,&src[start],end-start,1); /*flush */
                start = end+1;

                if ( isspecial_ch == 1 ) {
                   stream_printf(GDKout,"\\%03o",(unsigned char)src[end]);
                   stream_flush(GDKout);
                } else {
                   char *emit_val = isspecial_val[(int)isspecial_ch];
                   stream_write(GDKout,emit_val,strlen(emit_val),1);
                }
            }
        }
        if ( start < end ) {
                stream_flush(GDKout);
                stream_write(GDKout,&src[start],end-start,1); /* flush */
        }
}

static void emit(char* eventName, char* val, int escaped) {
        if ( val ) {
                if ( escaped ) {
                        stream_printf(GDKout,"[\"%s\",\t\"",eventName);
                        emit_escaped(val);
                        stream_printf(GDKout,"\"]\n");
                } else {
                        stream_printf(GDKout,"[\"%s\",\t\"%s\"]\n",eventName,val);
                }
        } else
                stream_printf(GDKout,"[\"%s\",\tnil]\n",eventName);
}

static void emit_end() {
}

/*
 *
 * The output handlers. Responslibe for generating the output representing
 * the handles xml structure. Cuurently 3 output structures are used:
 *
 * 1) plain xml text (ctx->saxMode is false)
 * 2) xml Sax-O-Phone stream (ctx->saxMode is true AND SAXOPHONE=1 )
 * 3) My own SAX event stream (ctx->saxMode is true AND SAXOPHONE=0 )
 *
 */

/* The SAXOPHONE define is a temporary flag used by JF to compile 'in'
 * his own Sax-O-Phone version which he thinks is much more efficient
 * than the original (but not as fancy) of course.
 */
#define SAXOPHONE 1

/**
 * Output generation handler. Handles equivalent of * SAX startDocument() event.
 */
static void handle_startDocument(XqueryCtx* ctx) {
        if (ctx->saxMode ) {
                if ( SAXOPHONE ) {
                        emit_start();
                } else
                        stream_printf(GDKout,"<S\n");
        } else { /* xmlMode */
                stream_printf(GDKout,"<?xml version=\"1.0\" encoding=\"utf-8\"?>\n");
        }
}

/**
 * Output generation handler. Handles equivalent of * SAX endDocument() event.
 */
static void handle_endDocument(XqueryCtx* ctx) {
        if (ctx->saxMode ) {
                if ( SAXOPHONE ) {
                        emit_end();
                } else 
                        stream_printf(GDKout,"<E\n");
        } else { /* xmlMode */
                stream_printf(GDKout,"\n\n");
        }
}

/**
 * Output generation handler. This one of my own invented event describing
 * the usage of an attribute. A sequence of these events will be ended
 * by a handle_attributeEnd() call.
 */
static void handle_attribute(XqueryCtx* ctx, str ns, str name, str value, int top) {
        if (ctx->saxMode ) {
                if ( SAXOPHONE ) {
                        emit(" attribute",name,0);
                        if ( ns && (strlen(ns)>0) )
                                emit(" attribute prefix",ns,0);
                        emit(" attribute value",value,0);
                } else {
                        stream_printf(GDKout,"<A %s=\"%s\"\n",name,value);
                }
        } else if (ctx->dmMode && top) { /* dmMode */
                if ( ns && strlen(ns)>0 ) {
                        stream_printf(GDKout,"attribute %s:%s { %s }",ns,name,value);
                } else {
                        stream_printf(GDKout,"attribute %s { %s }",name,value);
                }
        } else { /* xmlMode */
                if ( ns && strlen(ns)>0 ) {
                        stream_printf(GDKout," %s:%s=\"%s\"",ns,name,value);
                } else {
                        stream_printf(GDKout," %s=\"%s\"",name,value);
                }
        }
}

/**
 * Output generation handler. This one of my own invented event indicating
 * there will be no more attribute events for this node.
 */
static void handle_attributeEnd(XqueryCtx* ctx, int emptyNode) {
        if (ctx->saxMode ) {
        } else { /* xmlMode */
                if ( emptyNode )
                     stream_printf(GDKout,"/");
                stream_printf(GDKout,">");
        }

}

/**
 * Output generation handler. Handles equivalent of * SAX startElement() event.
 */
static void handle_startElement(XqueryCtx* ctx, str ns, str name /*,str *atts*/) {
        if (ctx->saxMode ) {
                if ( SAXOPHONE ) {
                        emit("startElement",NULL,0);
                        if ( ns && (strlen(ns)>0) )
                                emit(" prefix",ns,0);
                        emit(" localname",name,0);
                } else {
                        stream_printf(GDKout,"<s %s\n",name);
                }
        } else { /* xmlMode */
                if ( ns && strlen(ns)>0 ) {
                        stream_printf(GDKout,"<%s:%s",ns,name);
                } else {
                        stream_printf(GDKout,"<%s",name);
                }
        }
}

/**
 * Output generation handler. Handles equivalent of * SAX endElement() event.
 */
static void handle_endElement(XqueryCtx* ctx, str ns, str name, int emptyNode) {
        if (ctx->saxMode ) {
                if ( SAXOPHONE ) {
                        emit("endElement",NULL,0);
                        if ( ns && (strlen(ns)>0) )
                                emit(" prefix",ns,0);
                        emit(" localname",name,0);
                } else {
                        stream_printf(GDKout,"<e %s\n",name);
                }
        } else { /* xmlMode */
                if ( !emptyNode ) {
                        if ( ns && strlen(ns)>0 ) {
                                stream_printf(GDKout,"</%s:%s>",ns,name);
                        } else {
                                stream_printf(GDKout,"</%s>",name);
                        }
                }
        }
}

/**
 * Output generation handler. One on my own again. This one should handle a
 * reference. Don't know wat to to about it now.
 */
static void handle_reference(XqueryCtx* ctx, str name) {
        if (ctx && name) {};
}

/**
 * Output generation handler. Handles equivalent of * SAX characters() event.
 */
static void handle_characters(XqueryCtx* ctx, str ch, str top) {
        if (ctx->saxMode ) {
                if ( SAXOPHONE ) {
                        emit("characters",NULL,0);
                        emit(" pcdata",ch,1);
                } else {
                        stream_printf(GDKout,"%s\n",ch);
                }
        } else { /* xmlMode */
                if ( ctx->dmMode && top )
                        stream_printf(GDKout,"%s {\"",top);
                stream_printf(GDKout,"%s",ch);
                if ( ctx->dmMode && top )
                        stream_printf(GDKout,"\"}");
        }
}

/**
 * Output generation handler. Handles equivalent of * SAX ignorableWhitespace()
 * event. I see no reason why it should be used here but I include it for
 * completeness.
 */
static void handle_ignorableWhitespace(XqueryCtx* ctx, str ch) {
        handle_characters(ctx,ch,0); /* dispatch */
}

/**
 * Output generation handler. Again an own event. But this one should be
 * used I think because the comments are used and stored by  Pathfinder.
 */
static void handle_comment(XqueryCtx* ctx, str comm) {
        if (ctx->saxMode ) {
                /* incomplete */
        } else { /* xmlMode */
                stream_printf(GDKout,"<!--%s-->",comm);
        }
}

/**
 * Output generation handler. Handles equivalent of * SAX processingInstruction() event.
 */
static void handle_processingInstruction(XqueryCtx* ctx, str target, str data) {
        if (ctx->saxMode ) {
                /* incomplete */
        } else { /* xmlMode */
                stream_printf(GDKout,"<?%s %s?>",target,data);
        }
}

/**
 * Utility function. It reads the tail value of an element in a 
 * [void,any] BAT indexed by oid_index. 
 */
static ptr idxTV(XqueryCtx* ctx, str name, BAT* b, oid oid_index) {
        ptr res = NULL;

        if ( !b ) {
                fatal_err(ctx,"idxTV: NIL BAT[\"%s\"]",name);
        } else if ( BATcount(b) == 0 ) {
                fatal_err(ctx,"idxTV: BAT[%s] is empty",name);
        } else if ( is_fake_project(b) ) {
        	res = BUNtail(b,BUNfirst(b));
        } else {
                BUN bun = NULL;

                BUNfndVOID(bun, b, &oid_index);
                if ( bun ) {
                        res = BUNtail(b,bun);
                } else {
                        fatal_err(ctx,"idxTV, BAT[%s]: "SZFMT" not within ["SZFMT","SZFMT"]", 
                                  name, (size_t)oid_index, (size_t)(*(oid*)BUNhead(b,BUNfirst(b))), 
                                  (size_t)(*(oid*)BUNhead(b,BUNlast(b)-BUNsize(b))));
                }
        }
        if ( ! res )
                fatal_err(ctx,"idxTV: BAT[%s]["SZFMT"], NULL (ptr) result",name,(size_t)oid_index);
        return res;
}

/**
 * Reads the index tailvalue in a Working Set BAT
 */

static ptr idxTVinWS(XqueryCtx* ctx, int batId, oid oid_index) {
        BAT* b = wsBAT(ctx, batId);

        return idxTV(ctx,"tmp",b,oid_index);
}

/**
 * Reads the index tailvalue in a Working Set BAT or when fragId is not the
 * current working set it reads in the BAT outside the working set.
 */
static ptr idxTVinWSorFRGN(XqueryCtx* ctx, int fragId, int batId, oid oid_index) {
        if ( ctx->curFRAG == fragId ) 
                return idxTVinWS(ctx,batId,oid_index);
        else {
                BAT* b = fetchWsContextBAT(ctx,ctx->ws,batId,fragId);

                ptr res = idxTV(ctx,"tmp",b,oid_index);
                BBPunfix( BBPcacheid( b ) );
                return res;
        }
}

/**
 * Handle the generation of the attributes of the node with oid 'pre'. This
 * function is only called from the xquery_node_print() function.
 */

static void process_attr(XqueryCtx* ctx, int frag, oid id, int top) {
        oid prop_oid = *(oid*)idxTVinWSorFRGN(ctx,frag,ATTR_PROP,id);
        int afrag     = (int)*(oid*)idxTVinWSorFRGN(ctx,frag,ATTR_FRAG,id);
        str val      = (str)idxTVinWSorFRGN(ctx,afrag,PROP_VAL,prop_oid);
        /* */
        oid qn_oid = *(oid*)idxTVinWSorFRGN(ctx,frag,ATTR_QN,id);
        str ns     = (str)idxTVinWSorFRGN(ctx,afrag,QN_NS,qn_oid);
        str name   = (str)idxTVinWSorFRGN(ctx,afrag,QN_LOC,qn_oid);
        /* */
        handle_attribute(ctx,ns,name,val,top);
}

static int process_node_attr(XqueryCtx* ctx, int nFRAG, oid pre, int emptyNode) {
        BAT *b;

        if ( !(b  = BATuselect(wsBAT(ctx,ATTR_OWN),&pre,&pre)) )
                fatal_err(ctx,"process_node_attr: uselect fails\n");
        BUN p, q; 
        BATloop(b, p, q) {
                oid id = *(oid*)BUNhead(b, p);
		process_attr(ctx,nFRAG,id,0/*top*/);
        }
        handle_attributeEnd(ctx,emptyNode);
        BBPunfix( BBPcacheid( b ) );
        return 1;
}

/**
 * Handle the generation of the node with oid 'pre'.
 */
static void xquery_node_print(XqueryCtx* ctx, oid pre, BAT* pre_frag, int top) {
        chr kind = *(chr*)idxTVinWS(ctx,PRE_KIND,pre);
        oid prop = *(oid*)idxTVinWS(ctx,PRE_PROP,pre);

        int vFRAG = ctx->curFRAG;
        if ( pre_frag ) {
                vFRAG = (int)*(oid*)idxTV(ctx,"par_pre_frag",pre_frag,pre);
	}
	if (0) stream_printf(GDKout,"QNP[|xpre="SZFMT",nf=%d,vf=%d|]",(size_t)pre,ctx->curFRAG,vFRAG);
        switch( kind ) {
                case (char)0: {/* ELEMENT */
                        str name = (str)idxTVinWSorFRGN(ctx,vFRAG,QN_LOC,prop);
                        str ns   = (str)idxTVinWSorFRGN(ctx,vFRAG,QN_NS,prop);
                        handle_startElement(ctx,ns,name);
                        int size = *(int*)idxTVinWS(ctx,PRE_SIZE,pre);
                        process_node_attr(ctx,ctx->curFRAG,pre,(size==0));
                        pushTag(ctx,pre+size,ns,name,(size==0));
                        break;
                        }
                case (char)1: {/* TEXT */
                        handle_characters(ctx,(str)idxTVinWSorFRGN(ctx,vFRAG,PROP_TEXT,prop),(top?"text":0));
                        break;
                        }
                case (char)2: {/* COMMENT */
                        handle_comment(ctx,(str)idxTVinWSorFRGN(ctx,vFRAG,PROP_COM,prop));
                        break;
                        }
                case (char)3: {/* PI */
                        str target = (str)idxTVinWSorFRGN(ctx,vFRAG,PROP_TGT,prop);
                        str data   = (str)idxTVinWSorFRGN(ctx,vFRAG,PROP_INS,prop);
                        handle_processingInstruction(ctx,target,data);
                        break;
                        }
                case (char)4: {/* DOCUMENT */
                        /* The node represents an entire document */
                        int offset = *(int*)idxTVinWS(ctx,PRE_SIZE,pre);
                        pushTag(ctx,pre+offset,"","",0/*false*/);
                        break;
                        }
                default:
                        fatal_err(ctx,"Unknow kind IN xquery_node_print");
        }
}

#define ALLTAGS INT_MAX

/**
 * handle the closing tag of a document.
 */
static void xquery_endtag_print(XqueryCtx* ctx, oid pre) {
        while( moreTags(ctx) && ((pre==ALLTAGS)||(pre > topTag(ctx))) ) { /*?? */
                if ( strlen(topName(ctx)) > 0 )
                        handle_endElement(ctx,topNs(ctx),topName(ctx),topEmpty(ctx));
                popTag(ctx);
        }
}

/**
 * handle the range of pre numbers [from .. to]
 */
static void xquery_pre_range(XqueryCtx* ctx, BAT* b, oid from, oid to) {
        BUN p, q; 
        if ( from == 0 ) /* first BUN, because of 1..n/0..n-1 problem */
                p = BUNfirst(b);
        else
                BUNfndOID(p, b, (ptr)(&from));
        for(q = BUNlast(b); p<q; p = BUNnext(b, p)) {
                oid pre = *(oid*)BUNhead(b, p);
                do {
                        xquery_node_print(ctx, pre, 0 /*pre_frag*/, 0 /*false*/);
                        xquery_endtag_print(ctx,++pre);
                } while( moreTags(ctx) && (pre<to) );
        }
        if ( moreTags(ctx) ) {
                /* INCOMPLETE, the next line works but WHY? Should work without */
                xquery_endtag_print(ctx,ALLTAGS);
        }
}

static void MY_xquery_pre_range(XqueryCtx* ctx, oid from, oid to, BAT* pre_frag, int top) {
        oid pre = from;

        do {
                xquery_node_print(ctx, pre,pre_frag,top&&(from==to)); /*cheat*/
                xquery_endtag_print(ctx,++pre);
        } while( moreTags(ctx) && (pre<=to) );
}

/**
 *
 * X. THE MAIN XML DOCUMENT PRINTING PART
 *
 * Main XML document printing routine
 */

static int ws_documentIndex(BAT* ws, str docName) {
        oid doc_loaded_idx = (oid)DOC_LOADED;

        BUN b = BUNfnd(ws,&doc_loaded_idx);
        /*
         * if ( !b )
         *       stream_printf(GDKxxx,"NOT FOUND DOCBAT!!!!\n");
         */
        BAT* doc_loaded = BATdescriptor(*(bat*)b);

        BUN p, q; 
        BATloop(doc_loaded, p, q) {
                oid docId = *(oid*)BUNhead(doc_loaded, p);
                str docNm = (str)BUNtail(doc_loaded, p);

                if ( strcmp(docName,docNm) == 0 ) {
                        BBPunfix( BBPcacheid( doc_loaded ) );
                        return docId;
                }
        }
        BBPunfix( BBPcacheid( doc_loaded ) );
        return -1;
}

int xquery_print_doc_main(str mode, BAT* ws, str docName) {
        int docIndex = ws_documentIndex(ws,docName);
        if ( docIndex < 0 ) {
                stream_printf(GDKerr,"# unable to find document \"%s\" in working set!\n",docName);
                return GDK_SUCCEED;
        }
        /* */
        XqueryCtx  ctx_struct, *ctx = &ctx_struct;
        createWsContext(ctx,ws,docIndex,mode);
        /* */
        /* now set the exit point in case of an error */
        if ( setjmp(ctx_struct.exitPoint) != 0 ) {
                return GDK_FAIL;
        }
        /* */
        handle_startDocument(ctx);
        xquery_pre_range(ctx,wsBAT(ctx,PRE_SIZE),0/*start*/,1 /* first is doc ? */);
        handle_endDocument(ctx);
        switchWsContext(ctx,-1); /* close all open context BAT's */
        /* */
        return GDK_SUCCEED;
}

/**
 * XI. THE MAIN PATHFINDER QUERY RESULT PART
 *
 * First the event/emit handlers for the sequnce are defined and after that
 * the main function
 */

#define XQRESTAG        "XQueryResult"

/**
 * Handle the start() of an XQUERY/Pathfinder result sequence
 */
static void  seqHeadStart(XqueryCtx* ctx) {
	if ( ! ctx->dmMode ) { /* dmMode has no header */
	     if ( !ctx->saxMode )
                stream_printf(GDKout,"<?xml version=\"1.0\" encoding=\"utf-8\"?>\n");
             handle_startElement(ctx,NULL,XQRESTAG);
             ctx->nAttrOnLine = 0;
	}
}

static void  seqHeadEnd(XqueryCtx* ctx) {
	if ( ! ctx->dmMode ) { /* dmMode has no header */
	    handle_attributeEnd(ctx,0);
	    if ( !ctx->saxMode )
	         stream_printf(GDKout,"\n");
	}
}

/**
 * Handle the end() of an XQUERY/Pathfinder result sequence
 */
static void  seqEnd(XqueryCtx* ctx) {
        if ( ctx->saxMode ) {
                handle_endElement(ctx,NULL,XQRESTAG,0/* not empty*/);
        } else if ( ctx->dmMode ) {
                /* in DM mode no footer is printed !!! */
        } else {
                stream_printf(GDKout,"\n");
                stream_printf(GDKout,"</%s>\n",XQRESTAG);
        }
}


/**
 * Emit a NODE element of an XQUERY/Pathfinder result sequence
 */
static void  seqEmitNode(XqueryCtx* ctx, oid preVal, BAT* pre_frag, int top) {
        /* incomplete, different for dmMode ?? */
        int size = *(int*)idxTVinWS(ctx,PRE_SIZE,preVal);
        MY_xquery_pre_range(ctx,preVal,preVal+size, pre_frag, top);
}

/**
 * Emit a Boolean element of an XQUERY/Pathfinder result sequence
 */
static void  seqEmitBool(XqueryCtx* ctx, int bv) {
        char *bool_str = (char*)(bv?"true":"false");

        if ( ctx->saxMode ) {
                handle_characters(ctx,bool_str,0);
        } else if ( ctx->dmMode ) {
                stream_printf(GDKout,"%s() ",bool_str);
        } else {
                ctx->nAttrOnLine++;
                stream_printf(GDKout,"%s ",bool_str);
        }
}

/**
 * Emit a Integer element of an XQUERY/Pathfinder result sequence
 */
static void  seqEmitInt(XqueryCtx* ctx, int iv) {
        if ( ctx->saxMode ) {
                char buff[32];

                sprintf(buff,"%d",iv);
                handle_characters(ctx,buff,0);
        } else if ( ctx->dmMode ) {
                ctx->nAttrOnLine++;
                stream_printf(GDKout,"%d",iv);
        } else {
                ctx->nAttrOnLine++;
                stream_printf(GDKout,"%d ",iv);
        }
}

/**
 * Emit a Double element of an XQUERY/Pathfinder result sequence
 */
static void  seqEmitDbl(XqueryCtx* ctx, dbl dv) {
        if ( ctx->saxMode ) {
                char buff[32];

                sprintf(buff,"%f",dv);
                handle_characters(ctx,buff,0);
        } else if ( ctx->dmMode ) {
                ctx->nAttrOnLine++;
                stream_printf(GDKout,"%f",dv);
        } else {
                ctx->nAttrOnLine++;
                stream_printf(GDKout,"%f ",dv);
        }
}

/**
 * Emit a String element of an XQUERY/Pathfinder result sequence
 */
static void  seqEmitStr(XqueryCtx* ctx, str sv) {
        if ( ctx->saxMode ) {
                handle_characters(ctx,sv,"text");
        } else if ( ctx->dmMode ) {
                ctx->nAttrOnLine++;
                stream_printf(GDKout,"\"");
                emit_escaped( sv );
                stream_printf(GDKout,"\"");
        } else {
                ctx->nAttrOnLine++;
                stream_printf(GDKout,"\"");
                emit_escaped( sv );
                stream_printf(GDKout,"\" ");
        }
}

/**
 * Main XQUERY/Pathfinder result sequence printing routine. Arguments are
 * mode: "xml" or "sax"
 * ws : the working set
 * item/kind : sequence result BATs
 * intVAL,dblVAL,decVAL,strVAL : BATSs containing the values of seq elements
 * remainder BATs: conatins the data for the document nodes
 *
 * The function iterates through the item/kind BAT's and retrieves the values
 * from the xxxVAL BATs. Then it calls one of the seqXXXXX() functions
 * defined above to handle the output generation.
 */

/*
 * BAT format definitions. These must be equal to the definitions
 * in pathfinder.mx
 */

#define XTRACT_KIND(X)  (X & 63)
#define XTRACT_FRAG(X)  (X >> 6)

#define QNAME 2
#define BOOL  3
#define INT   4
#define DEC   5
#define DBL   6
#define STR   7
#define U_A   8
#define NODE  32
#define ELEM  33
#define ATTR  34

int xquery_print_result_main(
                str  mode,
                BAT* ws,
                BAT* item,
                BAT* kind,
                BAT* intVAL,
                BAT* dblVAL,
                BAT* decVAL,
                BAT* strVAL
        ) {
        XqueryCtx  ctx_struct, *ctx = &ctx_struct;
        createWsContext(ctx,ws,-1,mode);
        /* */
        /* now set the exit point in case of an error */
        if ( setjmp(ctx_struct.exitPoint) != 0 ) {
                return GDK_FAIL;
        }
        /* */
        seqHeadStart(ctx);
	if ( ! ctx->dmMode ) {
	    /* If the mode is not the DM mode do a scan of all attributes here
	     * and generate the appropriate calls to connect them to the
	     * head tag of the result document
	     */
            BUN p, q; 
            BATloop(item, p, q) {
                oid pre = *(oid*)BUNhead(item, p);
                oid valoid = *(oid*)BUNtail(item, p);
                int cmbn_frag_kind = *(int*)idxTV(ctx,"kind",kind,pre);

                if ( XTRACT_KIND(cmbn_frag_kind) == ATTR ) {
                     int frag = XTRACT_FRAG(cmbn_frag_kind);
		     process_attr(ctx,frag,valoid,1/* top */);
		}
	    }
	}
        seqHeadEnd(ctx);
        /* */
	int cnt = 0; /* loopcounter, used for checking when to print commas. */
        BUN p, q; 
        BATloop(item, p, q) {
                oid pre = *(oid*)BUNhead(item, p);
                oid valoid = *(oid*)BUNtail(item, p);
                int cmbn_frag_kind = *(int*)idxTV(ctx,"kind",kind,pre);
                if ( cnt++ && ctx->dmMode  ) {
                        /* should print a separator here */
                        stream_printf(GDKout,"%s",ctx->dmSeparator);
                }
                switch( XTRACT_KIND(cmbn_frag_kind) ) {
                 case ATTR: {
		 	if ( ctx->dmMode ) {
                            int frag = XTRACT_FRAG(cmbn_frag_kind);
			    process_attr(ctx,frag,valoid,1/* top */);
			}
                        break;
                        };
                 case ELEM: {
                        int frag = XTRACT_FRAG(cmbn_frag_kind);
                        /* if ( ctx->dmMode ),check for first kind text { "t" } 
                         * check idxTVinWSorFRGN(ctx,frag,PRE_KIND,valoid);
                         * for TEXT
                         */
                        int oldCtx = switchWsContext(ctx,frag);
                        seqEmitNode(ctx, valoid, wsBAT(ctx,PRE_FRAG),1/*top*/);
                        switchWsContext(ctx,oldCtx);
                        break;
                        };
                 case NODE: {
                        /* INCOMPLETE, suppose just ignore ?*/
                        break;
                        };
                 case BOOL: {
                        seqEmitBool(ctx,valoid);
                        break;
                        }
                 case DBL: {
                        dbl dv = *(dbl*)idxTV(ctx,"dblVAL",dblVAL,valoid);
                        seqEmitDbl(ctx,dv); /* INCOMPLETE ?diff between d and e */
                        break;
                        }
                 case DEC: {
                        dbl dv = *(dbl*)idxTV(ctx,"decCVAL",decVAL,valoid);
                        seqEmitDbl(ctx,dv); /* INCOMPLETE ?diff between d and e */
                        break;
                        }
                 case INT: {
                        int iv = *(int*)idxTV(ctx,"intVAL",intVAL,valoid);
                        seqEmitInt(ctx,iv);
                        break;
                        }
                 case STR: {
                        str sv = (str)idxTV(ctx,"strVAL",strVAL,valoid);
                        seqEmitStr(ctx,sv);
                        break;
                        }
                 case U_A: {
                        str sv = (str)idxTV(ctx,"strVAL",strVAL,valoid);
                        seqEmitStr(ctx,sv);
                        break;
                        }
                 default:
                        stream_printf(GDKerr,"[kind=%d, frag=%d]\n",XTRACT_KIND(cmbn_frag_kind),XTRACT_FRAG(cmbn_frag_kind));
                        fatal_err(ctx,"UNKNOW_TYPE(\'%c\'ch(%d))\n",cmbn_frag_kind,cmbn_frag_kind);
                }
        }
        if ( ctx->dmMode ) {
            stream_printf(GDKout,"\n"); /* end of the sequence newline */
        }
        /* */
        seqEnd(ctx);
        /* */
        switchWsContext(ctx,-1); /* close all open context BAT's */
        /* */
        return GDK_SUCCEED;
}

/* vim:set shiftwidth=4 expandtab: */
