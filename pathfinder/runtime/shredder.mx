# Copyright Notice:
# -----------------
# 
# The contents of this file are subject to the MonetDB Public
# License Version 1.0 (the "License"); you may not use this file
# except in compliance with the License. You may obtain a copy of
# the License at http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
# 
# Software distributed under the License is distributed on an "AS
# IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
# implied. See the License for the specific language governing
# rights and limitations under the License.
# 
# The Original Code is the ``Pathfinder'' system. The Initial
# Developer of the Original Code is the Database & Information
# Systems Group at the University of Konstanz, Germany. Portions
# created by U Konstanz are Copyright (C) 2000-2004 University
# of Konstanz. All Rights Reserved.
#
# Contributors:
#         Jan Flokstra <flokstra@cs.utwente.nl>
#         Torsten Grust <torsten.grust@uni-konstanz.de>
#         Maurice van Keulen <M.van.Keulen@bigfoot.com>
#         Jens Teubner <jens.teubner@uni-konstanz.de>
#
# $Id$

@f shredder
@a Jan Flokstra
@t shredder

@c
/*******************************************
* shredder.c : 'fast' xml document shredder for pathfinder
* It is an adapted version from pf_shred of the pathfinder loader
*
*/

#define USE_COMPRESSION
#define PRINT_STAT 0

#if HAVE_CONFIG_H
#include <pf_config.h>
#endif

/**
 * take care of 32/64-bits differences 
 */
#if (SIZEOF_VOID_P==4)

/* 32 bits systems */
typedef unsigned int nat;
#define NIL ((nat) INT_MIN)
#define NATFMT "u"

#else

/* 64 bits systems */
typedef unsigned long long nat;
#define NIL ((nat) LLONG_MIN)
#ifdef HAVE___INT64
#define NATFMT "I64u" /* windoze */
#else
#define NATFMT "llu"
#endif

#endif

/* support oid-s up to the 48 bits boundary => 13 decimal digits */
#define OIDFMT "%13" NATFMT 

/**
 * next node property IDs to assign
 */
nat nnode_pre; /* next preorder rank to assign */
nat nnode_attr;/* number of attributes counter */

/*******
 *
 */

#include <gdk.h>
#include <monet.h>

#include "pathfinder.h"

/* define the number of BATs in the requuired result set */
#define SHRED_BATS (PROP_VAL + 1)

/* description of the static properties of a result BAT */
typedef struct shredBATdef {
        int     id;       /* the index in the BAT, for assert usage */
        char*   name;     /* the name for the bat */
        int     headType; /* the headType of the BAT */
        int     tailType; /* the tailtype of the BAT */
        double  sizeFact; /* The mult. factor sizewise */
        char    compress; /* In case of str BAT to flag compression */
} shredBATdef;

/* values of the static properties of a result BAT */
static shredBATdef shredbatdef[SHRED_BATS] = {
        { PRE_SIZE, "PRE_SIZE", TYPE_void, TYPE_int, 1.0, 0},
        { PRE_LEVEL,"PRE_LEVEL",TYPE_void, TYPE_chr, 1.0, 0},
        { PRE_PROP, "PRE_PROP", TYPE_void, TYPE_oid, 1.0, 0},
        { PRE_KIND, "PRE_KIND", TYPE_void, TYPE_chr, 1.0, 0},
        { PRE_FRAG, "PRE_FRAG", TYPE_void, TYPE_oid, 1.0, 0},
        { QN_NS,    "QN_NS",    TYPE_void, TYPE_str, 0.0, 0},
        { QN_LOC,   "QN_LOC",   TYPE_void, TYPE_str, 0.0, 0},
        { PROP_TEXT,"PROP_TEXT",TYPE_void, TYPE_str, 0.0, 1},
        { PROP_COM, "PROP_COM", TYPE_void, TYPE_str, 0.0, 1},
        { PROP_INS, "PROP_INS", TYPE_void, TYPE_str, 0.0, 0},
        { PROP_TGT, "PROP_TGT", TYPE_void, TYPE_str, 0.0, 0},
        { ATTR_OWN, "ATTR_OWN", TYPE_void, TYPE_oid, 0.5, 0},
        { ATTR_QN,  "ATTR_QN",  TYPE_void, TYPE_oid, 0.5, 0},
        { ATTR_PROP,"ATTR_PROP",TYPE_void, TYPE_oid, 0.5, 0},
        { ATTR_FRAG,"ATTR_FRAG",TYPE_void, TYPE_oid, 0.0, 0},
        { PROP_VAL, "PROP_VAL", TYPE_void, TYPE_str, 0.0, 1}
};

/* description of the dynamic properties of a result BAT */
typedef struct shredBAT {
        shredBATdef     *def; /* pointer to static properties */
        nat             cnt;  /* current #of elements in the BAT */
        nat             dupl; /* the number of duplicate BUNins so far */
        nat             size; /* current maximum size of the BAT */
        BAT             *bat; /* the physical BAT */
        /* */
        union { /* cast to perform direct indexex insert in [void,any] BATs */
            void* voidCAST; /* the basecast */
            nat*  intCAST;  /* cast for [void,int] BAT */
            chr*  chrCAST;  /* cast for [void,chr] BAT */
            oid*  oidCAST;  /* cast for [void,oid] BAT */
        } cast;
} shredBAT;

/* the computing context environmentf the shredding process */
typedef struct shredCtx {
        char*           name;           /* xml document name */
        int             fileSize;       /* size of the input file */
        int             estSize;        /* extimated number of pre nodes */
        shredBAT        dstBAT[SHRED_BATS]; /* all the result BATs */
        BAT*            nslocBAT;       /* the BAT to compress NS and LOC */
        int             nslocDUPL;      /* the number of duplicates nslocs */
        int             shredWords;     /* store all words in text seperate,
                                         * this is something the Tijah 
                                         * people were asking for
                                         */
} shredCtx;

/* the minimal incremental size of a BAT during estimation process */
#define MINCHUNK        1024

/* the global the describing the computing enviroment of the current shredding
 * process. This is note reentrant. But is it very convenient at the moment */
static shredCtx* glb_ctx;

static shredCtx *createShredCtx(char* name, int fileSize) {
        int i;

        shredCtx *res = (shredCtx*)malloc( sizeof(shredCtx) );
        res->name     = name;
        res->fileSize = fileSize;
        res->estSize  = MAX(MINCHUNK,fileSize/20);
        for(i=0; i<SHRED_BATS; i++) {
                shredBAT* sb = &res->dstBAT[i];

                sb->def = & shredbatdef[i];

                if ( sb->def->id != i ) {
                        stream_printf(GDKerr,"shredder.mx:createShredCtx: id - sync\n");
                        return NULL;
                }
                sb->cnt  = sb->dupl = 0;
                if ( sb->def->tailType == TYPE_str )
                        sb->size = MINCHUNK; /* let Monet do the resize self */
                else 
                        sb->size = (int)(sb->def->sizeFact * res->estSize);
                sb->bat  = BATnew(sb->def->headType,sb->def->tailType,sb->size);
#ifdef USE_COMPRESSION
                if ( sb->def->compress ) {
                        /* create an accelerator on the str tail of the BAT */
                        sb->bat = BATmirror(BAThash(BATmirror(sb->bat),0));
                        if ( !sb->bat ) {
                                stream_printf(GDKerr,"shredder.mx:Hash[%d]:create fails\n",i);
                                return NULL;
                        }
                }
#endif
                BATseqbase(sb->bat,0);
                if ( sb->def->tailType != TYPE_str )
                        sb->cast.voidCAST = (void*)BUNfirst(sb->bat);
        }
#ifdef USE_COMPRESSION
        /* incomplete, what does second arg of BAThash do ?? */
        res->nslocBAT = BAThash(BATnew(TYPE_str,TYPE_oid,res->estSize/50),0);
        if ( !res->nslocBAT ) {
            stream_printf(GDKerr,"shredder.mx:nslocBAT:create fails\n");
            return NULL;
        }
        res->nslocDUPL= 0;
#endif
        res->shredWords = 0; /* do not shred words by default */
        glb_ctx = res;
        return res;
}

/* function to tailor the exact size 'n' of the bat ctx->dstBAT[idx]. If
 * correct the batsize will always shrink!
 */
static void setBATcapacity(shredCtx* ctx, int idx, int n) {
        BAT* b = ctx->dstBAT[idx].bat;

        void* top;
        
        int bottomTop = n+1;
        ctx->dstBAT[idx].cnt = n;
        switch( ctx->dstBAT[idx].def->tailType ) {
         case TYPE_int :
                top = &ctx->dstBAT[idx].cast.intCAST[bottomTop];
                break;
         case TYPE_chr: {
                b->batBuns->free = n+(SIZEOF_VOID_P); /* incomplete, solves truncation bug */
                b->tsorted = 0;
                return;
                }
         case TYPE_oid:
                top = &ctx->dstBAT[idx].cast.oidCAST[bottomTop];
                break;
         default:
                stream_printf(GDKerr,"ERROR: setBATcapacity(): bad tailType\n");
                return;
        }
        b->batBuns->free = ((BUN)top) - BUNfirst(b);
        b->tsorted = 0;
}

static void printStat(shredCtx* ctx) {
        int i;

        stream_printf(GDKout,"############\n");
        stream_printf(GDKout,"# STATISTICS of shredding \"%s\":\n",ctx->name);
        for(i=0; i<SHRED_BATS; i++) {
                shredBAT* sb = &ctx->dstBAT[i];

                stream_printf(GDKout,"# [%9s, ",sb->def->name);
                stream_printf(GDKout,"cnt=%d",sb->cnt);
                if ( sb->def->compress || i==QN_NS || i==QN_LOC) {
                    int dupl;

                    if ( sb->def->compress )
                        dupl = sb->dupl;
                    else
                        dupl = ctx->nslocDUPL;
                    stream_printf(GDKout,", dupl=%d(=%.f\%) ",dupl, ((dupl+sb->cnt)?100.0*(float)(sb->cnt)/(float)(dupl+sb->cnt):100.0));
                }
                if ( i==PRE_SIZE )
                        stream_printf(GDKout,", eg. the number of document nodes");
                if ( i==QN_NS )
                        stream_printf(GDKout,", eg. the number of distinct tags");
                if ( i==ATTR_OWN )
                        stream_printf(GDKout,", eg. the number of attributes");
                stream_printf(GDKout,"]\n");
        }
}

static BAT* finalizeShredCtx(shredCtx* ctx) {
        int i;

        BAT* res = BATnew(TYPE_oid,TYPE_bat,SHRED_BATS); /* create result BAT */

        if ( !res ) {
                stream_printf(GDKerr,"finalizeShredCtx:resultBAT:create failed.\n");
                return NULL;
        }
        setBATcapacity(ctx,PRE_SIZE, nnode_pre);
        setBATcapacity(ctx,PRE_LEVEL,nnode_pre);
        setBATcapacity(ctx,PRE_PROP, nnode_pre);
        setBATcapacity(ctx,PRE_KIND, nnode_pre);

        setBATcapacity(ctx,ATTR_OWN, nnode_attr);
        setBATcapacity(ctx,ATTR_QN,  nnode_attr);
        setBATcapacity(ctx,ATTR_PROP,nnode_attr);

        /* BATprintf(GDKout,ctx->dstBAT[PROP_TEXT].bat); */

        for(i=0; i<SHRED_BATS; i++) {
                shredBAT* sb = &ctx->dstBAT[i];
#ifdef USE_COMPRESSION
                if ( sb->def->compress ) {
                        /* remove all accelerators from the BAT */
                        ACCremoveall(sb->bat);
                }
#endif
                if ( !BAThdense(sb->bat) )
                        stream_printf(GDKout,"WARNING: BAT[%s] not dense\n",sb->def->name);
                bat bbb = BBPcacheid( sb->bat );
                if ( ! BUNins(res, &i, &bbb) ) {
                     stream_printf(GDKerr,"finalizeShredCtx:copy2result fails\n");
                     return NULL;
                }
                BBPunfix( bbb );
        }
        if ( PRINT_STAT )
                printStat(ctx);
#ifdef USE_COMPRESSION
        BBPunfix( BBPcacheid( ctx->nslocBAT ) );
#endif
        free( ctx );
        return res;
}

extern int mainSHREDDER(char* xmlFile);
extern char *timer_str (long elapsed);

int fileSize(char* xmlFile) {
    struct stat statbuf;

    if (stat (xmlFile, &statbuf) < 0) {
        stream_printf(GDKerr,
                 "!ERROR: cannot stat `%s': %s\n",
                 xmlFile, strerror (errno));
        return -1;
    } else
        return statbuf.st_size;
}

int
CMDshred2bats(BAT **res2mil, str docname, str opt)
{
    /* shred context */
    shredCtx* ctx;

    /* timing */
    struct timeval now;
    long start, stop;

    /* start timer */
    (void) gettimeofday (&now, 0);
    start = now.tv_sec * 1000000 + now.tv_usec;
    
    int xmlFileSize;

    if ( (xmlFileSize = fileSize(docname)) < 0 )
        return GDK_FAIL;

    if ( !(ctx = createShredCtx(docname, xmlFileSize)) )
        return GDK_FAIL;
    ctx->shredWords = (strcmp(opt,"tijah")==0);

    if ( mainSHREDDER(docname) < 0 )
        return GDK_FAIL;

    if ( !(*res2mil = finalizeShredCtx( ctx )) )
        return GDK_FAIL;

    /* read elapsed time */
    gettimeofday (&now, 0);
    stop = now.tv_sec * 1000000 + now.tv_usec;

    if ( PRINT_STAT ) {
            stream_printf(GDKout,"# Elapsed time = %s [%s/node]\n",
                        timer_str (abs (stop - start)),
                        timer_str (abs (stop - start) / nnode_pre));
    }
    return GDK_SUCCEED;
}

#define CHECK_BAT_SIZE(SB,I)    if ( ((I)>=(SB)->size) && incrBATsize(SB,I)<0) return NIL; 

static int incrBATsize(shredBAT* sb, nat i) {
    size_t newsize;

    newsize = MAX(sb->size+MAX(MINCHUNK,sb->size/4),i);
    /* stream_printf(GDKerr,"incrBATsize[\"%s\"](%d to %d)\n",sb->def->name,sb->size,newsize); */
    sb->size= newsize;
    if ( !(sb->bat = BATextend(sb->bat,newsize)) )
        return -1;
    if ( sb->def->tailType != TYPE_str )
         sb->cast.voidCAST = (void*)BUNfirst(sb->bat);
    return 1;
}

static INLINE nat direct_int2bat(shredCtx* ctx, int idx, nat i, nat v) {
        shredBAT* sb = & ctx->dstBAT[idx];
#ifdef VERBOSE
        stream_printf(GDKout,"DIRECT[%s](%d) = %d\n",sb->def->name,i,v);
#endif
        CHECK_BAT_SIZE(sb,i);
        sb->cast.intCAST[i] = v;
        return i;
}

static INLINE nat direct_oid2bat(shredCtx* ctx, int idx, nat i, oid v) {
        shredBAT* sb = & ctx->dstBAT[idx];
#ifdef VERBOSE
        stream_printf(GDKout,"DIRECT[%s](%d) = %d@0\n",sb->def->name,i,v);
#endif
        CHECK_BAT_SIZE(sb,i);
        sb->cast.oidCAST[i] = v;
        return i;
}

static INLINE nat direct_chr2bat(shredCtx* ctx, int idx, nat i, chr v) {
        shredBAT* sb = & ctx->dstBAT[idx];
#ifdef VERBOSE
        stream_printf(GDKout,"DIRECT[%s](%d) = chr(%d)\n",sb->def->name,i,v);
#endif
        CHECK_BAT_SIZE(sb,i);
        sb->cast.chrCAST[i] = v;
        return i;
}

static INLINE nat append_str2bat(shredCtx* ctx, int idx, str v) {
        oid my_oid_nil = oid_nil;

        shredBAT* sb = & ctx->dstBAT[idx];

#ifdef USE_COMPRESSION
        if ( sb->def->compress ) {
                /* incomplete, this mirror stuff looks rather clumsy */
                BAT* mb = BATmirror(sb->bat);

                BUN bun;
                bun = BUNfnd(mb,v);
                if ( bun ) {
                        oid fo = *(oid*)BUNtail(mb,bun);
                        sb->dupl++;
                        return (int)fo;
                }
        }
#endif /*USE_COMPRESSION*/

#ifdef VERBOSE
        stream_printf(GDKout,"APPEND-STR[%s](%s)\n",sb->def->name,v);
#endif
        if ( !BUNins(sb->bat,(ptr)&my_oid_nil,(ptr)v) ) {
            stream_printf(GDKerr,"APPEND-STR[%s](%s), BUNins fails\n",sb->def->name,v);
            return NIL;
        }
        return sb->cnt++;
}

/*******
 *
 */

/**
 * XML node kinds
 */
#define ELEMENT   0
#define TEXT      1
#define COMMENT   2
#define PI        3
#define DOCUMENT  4

/* SAX parser interface (libxml2) */
#include "libxml/parser.h"
#include "libxml/parserInternals.h"

/**
 * maximum length of a string
 */
#define PFSHRED_STRLEN_MAX (1 << 23)
#define PFSHRED_BUFLEN (1 << 10)

/**
 * current node level
 */
nat level;
nat depth;

/**
 * number of text content bytes buffered,
 * the content buffer itself
 */
nat content;
char *content_buf;

/**
 * XML node
 */
#define XML_TAG_MAX PFSHRED_STRLEN_MAX

typedef struct node_t node_t;
struct node_t {
    nat  pre;                   /**< preorder rank */
    nat  size;                  /**< size of subtree below node */
    int  level;                 /**< tree level of parent 
                                     (0 if root, -1 if document node) */
    nat  prop;                  /**< property ID */
    nat  kind;                  /**< node kind */
};


/**
 * XML node stack maximum depth (use `-d' for deeper XML instances)
 */
#define XML_DEPTH_MAX 256
nat xml_depth_max;
node_t *lifo;

nat sp = 0;
#define PUSH(n) (lifo[sp++] = (n))
#define POP()   (lifo[--sp])
#define TOP()   (lifo[sp - 1])

/**
 * convert ms timing value into string
 */
char *
timer_str (long elapsed)
{
    char *tm, *str;

    tm = str = strdup ("000h 00m 00s 000ms 000us");

    if (elapsed / 3600000000UL) {
        str += sprintf (str, "%03ldh ", elapsed / 3600000000UL);
        elapsed %= 3600000000UL;
    }
  
    if (elapsed / 60000000UL) {
        str += sprintf (str, "%02ldm ", elapsed / 60000000UL);
        elapsed %= 60000000UL;
    }
  
    if (elapsed / 1000000UL) {
        str += sprintf (str, "%02lds ", elapsed / 1000000UL);
        elapsed %= 1000000UL;
    }

    if (elapsed / 1000UL) {
        str += sprintf (str, "%03ldms ", elapsed / 1000UL);
        elapsed %= 1000UL;
    }

    str += sprintf (str, "%03ldus", elapsed);

    return tm;
}

/**
 * extract namespace prefix ns from QName ns:loc
 * (returns "" if QName is of the form loc)
 */
char 
*only_ns (char *qn)
{
#define MAX_NS_SIZE 1024
    static char nsbuff[MAX_NS_SIZE];

    char* colon = strchr (qn, ':');

    if ( !colon ) {
        nsbuff[0] = 0;
    } else {
        *colon = 0;
        strncpy(nsbuff,qn,MAX_NS_SIZE);
        *colon = ':';
    }
    return nsbuff;
}

/**
 * extract local part loc from QName ns:loc
 */
char 
*only_loc (char *qn)
{
    char *colon;
    
    return (colon=strchr (qn, ':'))?++colon:qn;
}

/**
 * enter new XML node into pre|size|level|prop|kind relation
 */
static int
emitnode (node_t node)
{
    if (
       direct_int2bat(glb_ctx,PRE_SIZE, node.pre,node.size)  == NIL ||
       direct_chr2bat(glb_ctx,PRE_LEVEL,node.pre,node.level) == NIL ||
       direct_oid2bat(glb_ctx,PRE_PROP, node.pre,node.prop)  == NIL ||
       direct_chr2bat(glb_ctx,PRE_KIND, node.pre,node.kind)  == NIL 
    )
        return -1;
    else
        return 1;
}

void 
shred_start_document (void *ctx)
{
    (void) ctx;

    nnode_pre  = 0;   /* next ``node ID'' */
    nnode_attr = 0;   /* attribute value property ID */
    level      = 0;
    depth      = 0;
    content    = 0;

    /* push document node */
    PUSH (((node_t) { .pre   = 0, 
                      .size  = 0, 
                      .level = -1,
                      .prop  = NIL,
                      .kind  = DOCUMENT
                    }));
    nnode_pre++;
}


void 
shred_end_document (void *ctx)
{
    (void) ctx;

    /* pop document node and enter into pre|size|level|prop|kind relation */
    if ( emitnode (POP ()) < 0 )
        xmlStopParser(ctx);
}

/**
 * write buffered text content (if any) to prop|text relation
 */
int 
emitString(shredCtx* ctx, char* s)
{
    node_t node;

    (void)ctx;
    /* fill the node */
    node.pre   = nnode_pre++;
    node.size  = 0;
    node.level = level;
    node.kind  = TEXT;
    if ( (node.prop=append_str2bat(glb_ctx,PROP_TEXT,s)) == NIL)
            return -1;

    /* this text node contributes to the size of its parent */
    TOP ().size++;

    /* enter text node into pre|size|level|prop|kind relation */
    if ( emitnode (node) < 0 )
        return -1;
    return 1;
}

#include <strings.h>

const char* del = " \t\n\r";
int 
emitShreddedString(shredCtx* ctx, char* s)
{
    char *t;

    if ( (t = strtok(s,del)) ) do {
        if ( emitString(ctx,t) < 0 )
             return -1;
    } while ( (t=strtok(NULL,del)) );
    return 1;
}

int 
text2rel (shredCtx* ctx)
{
    /* is there any buffered text content? */
    if (content) {
        content_buf[content] = 0; /* properly terminate string content_buf */

        if ( !ctx->shredWords ) {
            if ( emitString(ctx,content_buf) < 0 )
                return -1;
        } else {
            /* do the Tijah support thing */
            if ( emitShreddedString(ctx,content_buf) < 0 )
                return -1;
        }
    }
    content = 0;
    return 1;
}

static nat store_NsLoc(char* nsloc) {
#ifdef USE_COMPRESSION
        BUN bun;
        if ( (bun = BUNfnd(glb_ctx->nslocBAT,nsloc)) ) {
                oid o = *(oid*)BUNtail(glb_ctx->nslocBAT,bun);
                glb_ctx->nslocDUPL++;
                return (nat)o;
        }
#endif
        nat res;
        if ( (res=append_str2bat(glb_ctx,QN_NS,only_ns(nsloc)))==NIL)
                return NIL;
        if ( res != append_str2bat(glb_ctx,QN_LOC,only_loc(nsloc)) ) {
                stream_printf(GDKerr,"store_NsLoc:NS-LOC sync error");
                return NIL;
        }
#ifdef USE_COMPRESSION
        if ( !BUNins(glb_ctx->nslocBAT,nsloc,&res) ) {
                stream_printf(GDKerr,"Error:store_NsLoc:compression table insert fails\n");
                return NIL;
        }
#endif
        return res;
}

/**
 * SAX callback, invoked whenever `<t ...>' is seen
 */
void 
shred_start_element (void *ctx, 
                     const xmlChar *t, const xmlChar **atts)
{
    (void) ctx;
    node_t node;
    nat qn_id, val_id;

    if ( text2rel (glb_ctx) < 0 ) {
        xmlStopParser(ctx);
        return;
    }
    /* (1) assign preorder rank (document order), size, level, and kind */
    node.pre   = nnode_pre++;
    node.size  = 0;
    node.level = level;
    node.kind  = ELEMENT;

    /* descend one level */
    level++;

    /* keep track of document depth */
    if (level > depth)
        depth = level;

    if ( (node.prop = store_NsLoc( (char*) t)) == NIL ) {
        xmlStopParser(ctx);
        return;
    }

    /* push node onto node stack: size to be determined later */
    PUSH (node);

    /* (2) process the element's attribute(s), if any */
    if (atts)
        while (*atts) {            
            qn_id  = store_NsLoc( (char*) *atts);
            val_id = append_str2bat(glb_ctx,PROP_VAL,(char*)*(atts + 1));
            /* */
            if ( 
               qn_id  == NIL ||
               val_id == NIL ||
               direct_oid2bat(glb_ctx,ATTR_OWN ,nnode_attr, node.pre) == NIL ||
               direct_oid2bat(glb_ctx,ATTR_QN  ,nnode_attr, qn_id)    == NIL ||
               direct_oid2bat(glb_ctx,ATTR_PROP,nnode_attr, val_id)   == NIL
            ) {
                xmlStopParser(ctx);
                return;
            }
            nnode_attr++;

            /* process next attribute */
            atts += 2;
        }
}

/** 
 * SAX callback invoked whenever `</t>' is seen
 */
void 
shred_end_element (void *ctx, const xmlChar *tag)
{
    node_t node;

    (void) ctx;
    (void) tag;

    if ( text2rel (glb_ctx) < 0 ) {
        xmlStopParser(ctx);
        return;
    }

    node = POP ();

    /* ascend up one level */
    level--;

    /* the size of the subtree below this element and the element
     * itself contributes to the size of its parent
     */
    TOP ().size += node.size + 1;

    /* enter element node into pre|size|level|prop|kind relation */
    if ( emitnode (node) < 0 )
        xmlStopParser(ctx);
}

/**
 * SAX callback invoked whenever text node content is seen,
 * simply buffer the content here
 */
void 
shred_characters (void *ctx, const xmlChar *cs, int n)
{
    int l = MIN (PFSHRED_STRLEN_MAX - (int) content, n);

    (void) ctx;

    memcpy (&(content_buf[content]), cs, l);
    content += l;

    if (l < n)
        stream_printf(GDKerr,
                 "!WARNING: truncated text node > %" NATFMT " characters (starts with `%.16s...')\n",
                 PFSHRED_STRLEN_MAX,
                 cs);
}

/**
 * SAX callback invoked whenever `<![CDATA[...]]>' is seenx
 */
void 
shred_cdata (void *ctx, const xmlChar *cdata, int n)
{
    shred_characters (ctx, cdata, n);
}

/** 
 * SAX callback invoked whenever `<?target ins?>' is seen
 */
void 
shred_pi (void *ctx, const xmlChar *tgt, const xmlChar *ins)
{
    /*
     * incomplete, do not compress tgt ins properties yet. Should do
     * it analog to nsloc with an extra BAT
     */
    node_t node;

    (void) ctx;

    if ( text2rel (glb_ctx) < 0 ) {
        xmlStopParser(ctx);
        return;
    }

    node.pre   = nnode_pre++;
    node.size  = 0;
    node.level = level;
    node.kind  = PI;

    /* this comment p-i contributes to the size of its parent */
    TOP ().size++;
        
    node.prop = append_str2bat(glb_ctx,PROP_TGT,(char*)tgt);
    if ( node.prop != append_str2bat(glb_ctx,PROP_INS,(char*)ins) )
        stream_printf(GDKerr,"shredder.mx:shred_pi: tgt-ins sync error\n");
    
    /* enter p-i node into pre|size|level|prop|kind relation */
    if ( emitnode (node) < 0 )
        xmlStopParser(ctx);
}

void 
shred_comment (void *ctx, const xmlChar *c)
{
    node_t node;

    (void) ctx;

    if ( text2rel (glb_ctx) < 0 ) {
        xmlStopParser(ctx);
        return;
    }

    node.pre   = nnode_pre++;
    node.size  = 0;
    node.level = level;
    node.kind  = COMMENT;

    /* this comment node contributes to the size of its parent */
    TOP ().size++;

    node.prop = append_str2bat(glb_ctx,PROP_COM,(char*)c);

    /* enter comment node into pre|size|level|prop|kind relation */
    if ( emitnode (node) < 0 )
        xmlStopParser(ctx);
}

void 
error (void *ctx, const char *msg, ...)
{
    va_list msgs;
    char errmsg[PFSHRED_BUFLEN];

    stream_printf(GDKerr, "!ERROR (XML parser): ");

    va_start (msgs, msg);
    vsnprintf (errmsg, PFSHRED_BUFLEN, msg, msgs);
    va_end (msgs);

    xmlParserError (ctx, errmsg);
}

/**
 * SAX callback table.
 */
xmlSAXHandler shredder = {
    .startDocument         = shred_start_document
  , .endDocument           = shred_end_document
  , .startElement          = shred_start_element
  , .endElement            = shred_end_element
  , .characters            = shred_characters
  , .processingInstruction = shred_pi
  , .comment               = shred_comment
  , .error                 = error
  , .cdataBlock            = shred_cdata
  , .internalSubset        = 0
  , .isStandalone          = 0
  , .hasInternalSubset     = 0
  , .hasExternalSubset     = 0
  , .resolveEntity         = 0
  , .getEntity             = 0
  , .entityDecl            = 0
  , .notationDecl          = 0
  , .attributeDecl         = 0
  , .elementDecl           = 0
  , .unparsedEntityDecl    = 0
  , .setDocumentLocator    = 0
  , .reference             = 0
  , .ignorableWhitespace   = 0
  , .warning               = 0
  , .fatalError            = 0
  , .getParameterEntity    = 0
  , .externalSubset        = 0
  , .initialized           = 0
};


int 
shred (const char *in, const char *out)
{
    xmlParserCtxtPtr ctx;

    (void) out;

    /* parse XML input (receive SAX events) */
    if ( !(ctx = xmlCreateFileParserCtxt (in)) ) {
        stream_printf(GDKerr,"shred:xmlCreateFileParserCtxt failed\n"); 
        return -1;
    }
    ctx->sax = &shredder;
    xmlSwitchEncoding (ctx, XML_CHAR_ENCODING_UTF8);
    
    (void) xmlParseDocument (ctx);

    /* incomplete, check if something has gone wrong durin shred */
    if (! ctx->wellFormed) {
        stream_printf(GDKerr, 
                 "!ERROR: XML input not well-formed "
                 "(relation files probably contain garbage)\n");

        return -1;
    }
    return 1;
}

int 
mainSHREDDER(char* xmlFile)
{
    char out[FILENAME_MAX];
    strncpy (out, xmlFile, FILENAME_MAX);

    /* buffer for file I/O status */
    struct stat statbuf;
    
    /* this code is not really Unicode or multi-byte aware (yet) */
    assert (sizeof (char) == sizeof (xmlChar));

    xml_depth_max = XML_DEPTH_MAX;

    content_buf = (char*) malloc(PFSHRED_STRLEN_MAX);

    assert(content_buf);

    /* is FILE readable? */
    if (stat (xmlFile, &statbuf) < 0) {
        stream_printf(GDKerr,
                 "!ERROR: cannot stat `%s': %s\n",
                 xmlFile, strerror (errno));

        return( -1 );
    }

    /* allocate XML node stack */
    if (! (lifo = (node_t *) malloc (xml_depth_max * sizeof (node_t)))) {
        stream_printf(GDKerr,
                 "!ERROR: cannot allocate XML node stack: %s\n",
                 strerror (errno));

        return( -1 );
    }

    /* shredding... */
    int res = shred (xmlFile, out);

    /* free the buffers */
    free(content_buf);

    return res;
}

@c
/* vim:set shiftwidth=4 expandtab: */
