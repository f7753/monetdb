@chapter SQL

This chapter provides an introduction to SQL Implementation,
a full-fledged SQL implementation for database management.
It assumes basic knowledge on the SQL language syntax.
If you are new to this world then pick up any of the
introductionary books and study it carefully.

The SQL Implementation front-end is based on the SQL-99 standard,
which is covered in many text books e.g.
@emph{J. Melton and A.R. Simon}, SQL:1999 Understanding
Relational Language Components, ISBN 1558604561.

The architecture is based on a separate compiler, which translates 
SQL statements into MAL. In this process common optimization heuristics,
specific to relational algebra are performed.

The SQL Implementation compiler can be downloaded from the
@url{"http://sourceforge.net/project/showfiles.php?group_id=56967",download} 
section at SourceForge. It is already included in the Windows installers.

There are bindings for SQL Implementation with for example JDBC, ODBC, PHP and C, 
(see @ref{MapiClient and Interfaces} to integrate seamlessly in existing 
developments environments.
Client utilities like Aqua Data Studio and iSQL will work flawlessly 
with SQL Implementation to make your experience with MonetDB/SQL even better! 

The remainder of this chapter provides a short tutorial to get
going. A synopsis of the language features supported provides
a quick intro on the scope of the current implementation and
the plans.
The programming support sections illustrate some of the advanced
features to analyse and your SQL code.
@menu
* The VOC Tutorial::
* SQL Feature Overview::
@menu
* SQL Feature List::
* SQL Session Variables::
* SQL EXPLAIN Statement::
* SQL DEBUG Statement::
* SQL Optimizer Control::
@end menu
* SQL Implementation Roadmap ::
@end menu

@node The VOC Tutorial, SQL Feature Overview, SQL, SQL
@section The VOC tutorial

@node SQL Feature Overview, SQL Feature List, The VOC Tutorial, SQL
@section SQL Features 
The SQL Implementation implementation is based on the SQL-99 standard. 
It is built incrementally over time to cope with the effort
required to realize all features. Priority is given to those
features relevant to our research and upon request from our valued
partners.

The plethora of SQL implementations also show that the standard
alone is hardly sufficient. All database systems have extended
or twisted the language structure to satisfy the needs of their
customer, support legacy, and to better tap into the functionality
offered by their kernels. 
SQL Implementation is bound to follow this path too. The kernel imposes
limitations on the features that can and cannot be realized.

In the context of programming support, we provide a few
primitives to simplify debugging of SQL programs. They are described
separately. The list below provides a synopsis of the SQL features
supported in the released version.
@itemize
\item 
foreign key integrity
@end itemize

@node SQL Feature List, SQL Session Variables, SQL Feature Overview, SQL
@subsection SQL-99 Feature list
In this section we give an itemized list of the SQL-99 features
supported in the current release.

@node SQL Session Variables, SQL EXPLAIN Statement, SQL Feature List, SQL
@subsection SQL Session Variables

MonetDB/SQL comes with a limited variable scheme.
Globel, session based variables can be introduced using the
construct:
@example
SET <variable>=<string>
SET <variable>=<boolean>
SET <variable>=<int>
@end example
Their type is inherited from the literal value supplied.
The SQL engine comes with a limited set of environment variables
to control its behavior.
@itemize
@item
The @code{debug} variable takes an integer and sets the Mserver global
debug flag. (See MonetDB documentation) It also activates the
debugger when the query is being executed.
@item
The @code{explain} variable currently takes the values 'plan' or
'performance'. The 'plan' qualifier produces a relational table with
the plan derived for execution using the applicable back end and
optimizer schemes. The 'performance' qualifier produces a performance
trace of the SQL queries for post analysis. It is available in
the system table called @code{history}. Omission of either qualifier merely
results in a straight execution of the query.
@item

The @code{auto_commit} variable takes a boolean and controls automatic commit
after a successful SQL execution, or conversely an automatic rollback.

@item
The @code{reply_size} limits the number of tuples sent to the front end.
[It is unclear how the remainder can be obtained within the SQL language
framework. The reply_size should be replaced by the @code{limit} language
construct]

@item
The @code{history} variable is a boolean flag which leads to 
capturing execution information of any SQL query in a table for post-analysis.
@end itemize

By default all remaining variables are stored as strings and
any type analysis is up to the user. The can be freely used by the
SQL programmer for inclusion in his queries. [TODO, a little more
flexibilty would mean a lot]

The variables and their type definition are assembled in a system table
called 'sessions'. A snippet of its content is shown below:
@example
>select * from sessions;
#-----------------------------------------------------------------#
# t                     t               t               t         # name
# str                   str             str             int       # type
#-----------------------------------------------------------------#
[ "debug",                "0",            "int",          0       ]
[ "reply_size",           "-1",           "int",          0       ]
[ "explain",              "",             "varchar",      0       ]
[ "auto_commit",          "false",        "boolean",      0       ]
[ "current_schema",       "sys",          "varchar",      1       ]
[ "current_user",         "monetdb",      "varchar",      1       ]
[ "current_role",         "monetdb",      "varchar",      0       ]
[ "current_timezone",     "0",            "sec_interval", 0       ]
[ "cache",                "true",         "boolean",      0       ]
[ "factory",              "true",         "boolean",      0       ]
@end example

@node SQL EXPLAIN Statement, SQL DEBUG Statement, SQL Session Variables, SQL
@subsection SQL EXPLAIN Statement
The intermediate code produced by the SQL Implementation compiler can be made 
visible using the @code{explain} statement modifier. 
It gives a detailed description of the actions taken to produce the
answer. The example below illustrates what you can expect when a
simple query is pre-pended by the @code{explain} modifier.
Although the details of this program are better understood
when you have read the Chapter on MAL @ref{MonetDB Assembler Language}
the global structure is easy to explain.

@verbatim
>select count(*) from tables;
[ 23 ]
>explain select count(*) from tables;
!function user.main():int;
!    sql_cache.sql1();
!end main;
!factory sql_cache.sql1():any;
!    $1{count=0} := sql.bind("sys","ptables","id",0);
!    $6{count=0} := sql.bind_dbat("sys","ptables",0);
!    $14{count=0} := sql.bind("sys","ttables","id",0);
!    $16{count=0} := sql.bind_dbat("sys","ttables",0);
!barrier always := true;
!    $7 := bat.reverse($6{count=0});
!    $8 := algebra.kdiff($1{count=0},$7);
!    $11 := algebra.markT($8,0@0);
!    $12 := bat.reverse($11);
!    $13 := algebra.join($12,$1{count=0});
!    $17 := bat.reverse($16{count=0});
!    $18 := algebra.kdiff($14{count=0},$17);
!    $20 := algebra.markT($18,0@0);
!    $21 := bat.reverse($20);
!    $22 := algebra.join($21,$14{count=0});
!    $23 := bat.append($13,$22);
!    $25 := algebra.markT($23,0@0);
!    $26 := bat.reverse($25);
!    $27 := algebra.join($26,$23);
!    $29 := algebra.markT($27,0@0);
!    $30 := bat.reverse($29);
!    $31 := algebra.join($30,$27);
!    $32 := algebra.count($31);
!    sql.column($32,"count_id","int",32,0);
!    sql.output(0,$32);
!    yield always;
!    redo always;
!exit always;
!end sql1;
@end verbatim

The SQL compiler keeps a limited cache of queries and before MAL code is
produced. Each query is looked up in the cache based on an expression pattern 
match where the constants may take on different values.
If it doesn;t exist, the query is converted into 
a @emph{factory} code block and stored in the
module @code{sqlcache}. 
It consists of a prelude section, which locates
the tables of interest in the SQL catalogs.
The block between @code{barrier} and @code{yield} is the actual code
executed upon each call of this function. It is a large collection
of relational algebra operators, whose execution semantics depend
on the actual MAL engine. The @code{factory} ensures that only this part
is called when the query is executed repetitively.

The call to the cached function is included in the function @code{main},
which is the only piece of code produced if the query is used more than once.
The query cache disappears when the server is brought to a halt. 

When/how is the cache cleared? Can you list elements in the
cache directly, e.g @code{explain;} or @code{explain sqlcache} or @code{explain sqlcache.sql0;}

@node SQL DEBUG Statement, SQL Optimizer Control, SQL EXPLAIN Statement, SQL
@subsection SQL DEBUG Statement

The default execution engine for SQL statements is 
the MAL interpreter, which comes with a debugger (See @ref{The MAL Debugger})
It provides a simple mechanism to trace the execution, hunting
for possible errors and performance bottlenecks.

The example below, illustrates how you can easily obtain a quick 
overview of the cost components of the query.
@example
> debug select count(*) from tables;
#mdb>timer
...
@end example
Using the MAL debugger it is also possible to inspect
the content of the intermediate results. See @ref{Runtime Inspection} for
examples.

@node SQL Optimizer Control, SQL Implementation Roadmap, SQL DEBUG Statement,  SQL
@section SQL Optimizer Control
The code produced by MonetDB/SQL is massaged by several code optimizers
to arrive at the best possible plan for evaluation.
However, for development purposes and the rare case that more control
is needed, the SQL session variable @code{optimizer} can be set
to a MAL instruction list to identify the optimizer steps needed. [todo]

@example
>select optimizer;
#--------------------#
# t                  # name
# str                # type
#--------------------#
[ "optimizer.sql();" ]
>set optimizer="optimizer.factorize();";
>explain select 1;
@end example

The final result the optimizer steps become visible using the @code{explain}
statement modifier. Alternatively, the optimizer script line may include
a call to @code{optimizer.showPlan();}.

@node SQL Implementation Roadmap, XQuery, SQL Optimizer Control,  SQL
@section SQL Implementation Roadmap
In this section we summarize the SQL features scheduled for implementation
and those that won;t be supported in the foreseeable future.
@subsection Features that won;t make it.
The database backend architecture prohibits easy implementation of
several SQL-99 features. Those on the list below are not expected to
be supported.
@itemize
@item
Cursor based processing, because the execution engine is not based
on the iterator model deployed in other engines. A simulation of the
cursor based scheme would be utterly expensive from a performance
point of view.
@item
Multi-level isolation levels.
@end itemize
