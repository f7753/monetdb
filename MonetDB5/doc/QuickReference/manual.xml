<?xml version="1.0"?>
<manual>
<module name="Admin">
  <function  name="main">
  <instantiation>
    <signature>():int;</signature>
  </instantiation>
  <instantiation>
    <signature>():int;</signature>
  </instantiation>
  </function>
</module>
<module name="aggrX3">
  <command  name="avg">
    <comment>grouped tail average on flt</comment>
  <instantiation>
    <signature>(b:bat[:oid,:flt],g:bat[:oid,:oid],e:bat[:oid,:any]):bat[:oid,:flt] </signature>
    <implementation> AX3aggrX3\_avg3\_flt;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:oid,:flt],e:bat[:oid,:any]):bat[:oid,:flt] </signature>
    <implementation> AX3aggrX3\_avg\_flt;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:oid,:lng],g:bat[:oid,:oid],e:bat[:oid,:any]):bat[:oid,:lng] </signature>
    <implementation> AX3aggrX3\_avg3\_lng;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:oid,:lng],e:bat[:oid,:any]):bat[:oid,:lng] </signature>
    <implementation> AX3aggrX3\_avg\_lng;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:oid,:dbl],g:bat[:oid,:oid],e:bat[:oid,:any]):bat[:oid,:dbl] </signature>
    <implementation> AX3aggrX3\_avg3\_dbl;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:oid,:dbl],e:bat[:oid,:any]):bat[:oid,:dbl] </signature>
    <implementation> AX3aggrX3\_avg\_dbl;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:oid,:int],g:bat[:oid,:oid],e:bat[:oid,:any]):bat[:oid,:int] </signature>
    <implementation> AX3aggrX3\_avg3\_int;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:oid,:int],e:bat[:oid,:any]):bat[:oid,:int] </signature>
    <implementation> AX3aggrX3\_avg\_int;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:oid,:sht],g:bat[:oid,:oid],e:bat[:oid,:any]):bat[:oid,:sht] </signature>
    <implementation> AX3aggrX3\_avg3\_sht;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:oid,:sht],e:bat[:oid,:any]):bat[:oid,:sht] </signature>
    <implementation> AX3aggrX3\_avg\_sht;</implementation>
  </instantiation>
  </command>
  <command  name="count">
    <comment>grouped count</comment>
  <instantiation>
    <signature>(b:bat[:oid,:any],g:bat[:oid,:oid],e:bat[:oid,:any],nonils:bit):bat[:oid,:int] </signature>
    <implementation> AX3aggrX3\_count3;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:oid,:any],e:bat[:oid,:any]):bat[:oid,:int] </signature>
    <implementation> AX3aggrX3\_count;</implementation>
  </instantiation>
  </command>
  <command  name="max">
    <comment>grouped tail maximum</comment>
  <instantiation>
    <signature>(b:bat[:oid,:any\$1],g:bat[:oid,:oid],e:bat[:oid,:any]):bat[:oid,:any\$1] </signature>
    <implementation> AX3aggrX3\_max3;</implementation>
  </instantiation>
  </command>
  <command  name="min">
    <comment>grouped tail minimum</comment>
  <instantiation>
    <signature>(b:bat[:oid,:any\$1],g:bat[:oid,:oid],e:bat[:oid,:any]):bat[:oid,:any\$1] </signature>
    <implementation> AX3aggrX3\_min3;</implementation>
  </instantiation>
  </command>
  <command  name="max">
    <comment>grouped tail maximum</comment>
  <instantiation>
    <signature>(b:bat[:oid,:any\$1],e:bat[:oid,:any]):bat[:oid,:any\$1] </signature>
    <implementation> AX3aggrX3\_max;</implementation>
  </instantiation>
  </command>
  <command  name="min">
    <comment>grouped tail minimum</comment>
  <instantiation>
    <signature>(b:bat[:oid,:any\$1],e:bat[:oid,:any]):bat[:oid,:any\$1] </signature>
    <implementation> AX3aggrX3\_min;</implementation>
  </instantiation>
  </command>
  <command  name="prod">
    <comment>grouped tail product on flt</comment>
  <instantiation>
    <signature>(b:bat[:oid,:flt],e:bat[:oid,:any]):bat[:oid,:flt] </signature>
    <implementation> AX3aggrX3\_prod\_flt\_flt;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:oid,:lng],e:bat[:oid,:any]):bat[:oid,:lng] </signature>
    <implementation> AX3aggrX3\_prod\_lng\_lng;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:oid,:dbl],e:bat[:oid,:any]):bat[:oid,:dbl] </signature>
    <implementation> AX3aggrX3\_prod\_dbl\_dbl;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:oid,:int],e:bat[:oid,:any]):bat[:oid,:int] </signature>
    <implementation> AX3aggrX3\_prod\_int\_int;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:oid,:sht],e:bat[:oid,:any]):bat[:oid,:sht] </signature>
    <implementation> AX3aggrX3\_prod\_sht\_sht;</implementation>
  </instantiation>
  </command>
  <command  name="size">
    <comment>grouped count of true values</comment>
  <instantiation>
    <signature>(b:bat[:oid,:bit],e:bat[:oid,:any]):bat[:oid,:int] </signature>
    <implementation> AX3aggrX3\_size;</implementation>
  </instantiation>
  </command>
  <command  name="sum">
    <comment>grouped tail sum on flt</comment>
  <instantiation>
    <signature>(b:bat[:oid,:flt],g:bat[:oid,:oid],e:bat[:oid,:any]):bat[:oid,:flt] </signature>
    <implementation> AX3aggrX3\_sum3\_flt\_flt;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:oid,:flt],e:bat[:oid,:any]):bat[:oid,:flt] </signature>
    <implementation> AX3aggrX3\_sum\_flt\_flt;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:oid,:int],g:bat[:oid,:oid],e:bat[:oid,:any]):bat[:oid,:lng] </signature>
    <implementation> AX3aggrX3\_sum3\_int\_lng;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:oid,:int],e:bat[:oid,:any]):bat[:oid,:lng] </signature>
    <implementation> AX3aggrX3\_sum\_int\_lng;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:oid,:int],g:bat[:oid,:oid],e:bat[:oid,:any]):bat[:oid,:int] </signature>
    <implementation> AX3aggrX3\_sum3\_int\_int;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:oid,:int],e:bat[:oid,:any]):bat[:oid,:int] </signature>
    <implementation> AX3aggrX3\_sum\_int\_int;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:oid,:sht],g:bat[:oid,:oid],e:bat[:oid,:any]):bat[:oid,:int] </signature>
    <implementation> AX3aggrX3\_sum3\_sht\_int;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:oid,:sht],e:bat[:oid,:any]):bat[:oid,:int] </signature>
    <implementation> AX3aggrX3\_sum\_sht\_int;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:oid,:sht],g:bat[:oid,:oid],e:bat[:oid,:any]):bat[:oid,:sht] </signature>
    <implementation> AX3aggrX3\_sum3\_sht\_sht;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:oid,:sht],e:bat[:oid,:any]):bat[:oid,:sht] </signature>
    <implementation> AX3aggrX3\_sum\_sht\_sht;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:oid,:flt],g:bat[:oid,:oid],e:bat[:oid,:any]):bat[:oid,:dbl] </signature>
    <implementation> AX3aggrX3\_sum3\_flt\_dbl;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:oid,:flt],e:bat[:oid,:any]):bat[:oid,:dbl] </signature>
    <implementation> AX3aggrX3\_sum\_flt\_dbl;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:oid,:flt],g:bat[:oid,:oid],e:bat[:oid,:any]):bat[:oid,:flt] </signature>
    <implementation> AX3aggrX3\_sum3\_flt\_flt;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:oid,:flt],e:bat[:oid,:any]):bat[:oid,:flt] </signature>
    <implementation> AX3aggrX3\_sum\_flt\_flt;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:oid,:lng],g:bat[:oid,:oid],e:bat[:oid,:any]):bat[:oid,:lng] </signature>
    <implementation> AX3aggrX3\_sum3\_lng\_lng;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:oid,:lng],e:bat[:oid,:any]):bat[:oid,:lng] </signature>
    <implementation> AX3aggrX3\_sum\_lng\_lng;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:oid,:dbl],g:bat[:oid,:oid],e:bat[:oid,:any]):bat[:oid,:dbl] </signature>
    <implementation> AX3aggrX3\_sum3\_dbl\_dbl;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:oid,:dbl],e:bat[:oid,:any]):bat[:oid,:dbl] </signature>
    <implementation> AX3aggrX3\_sum\_dbl\_dbl;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:oid,:int],g:bat[:oid,:oid],e:bat[:oid,:any]):bat[:oid,:int] </signature>
    <implementation> AX3aggrX3\_sum3\_int\_int;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:oid,:int],e:bat[:oid,:any]):bat[:oid,:int] </signature>
    <implementation> AX3aggrX3\_sum\_int\_int;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:oid,:sht],g:bat[:oid,:oid],e:bat[:oid,:any]):bat[:oid,:sht] </signature>
    <implementation> AX3aggrX3\_sum3\_sht\_sht;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:oid,:sht],e:bat[:oid,:any]):bat[:oid,:sht] </signature>
    <implementation> AX3aggrX3\_sum\_sht\_sht;</implementation>
  </instantiation>
  </command>
</module>
<module name="alarm">
  <command  name="alarm">
    <comment>execute action in X secs</comment>
  <instantiation>
    <signature>(secs:int,action:str):void </signature>
    <implementation> ALARMsetalarm;</implementation>
  </instantiation>
  </command>
  <command  name="ctime">
    <comment>current time as a string</comment>
  <instantiation>
    <signature>():str </signature>
    <implementation> ALARMctime;</implementation>
  </instantiation>
  </command>
  <command  name="epilogue">
    <comment>Finalize alarm module</comment>
  <instantiation>
    <signature>():void </signature>
    <implementation> ALARMepilogue;</implementation>
  </instantiation>
  </command>
  <command  name="epoch">
    <comment>current time as unix epoch</comment>
  <instantiation>
    <signature>():int </signature>
    <implementation> ALARMepoch;</implementation>
  </instantiation>
  </command>
  <command  name="prelude">
    <comment>Initialize alarm module</comment>
  <instantiation>
    <signature>():void </signature>
    <implementation> ALARMprelude;</implementation>
  </instantiation>
  </command>
  <command  name="sleep">
    <comment>sleep X secs</comment>
  <instantiation>
    <signature>(secs:int):void </signature>
    <implementation> ALARMsleep;</implementation>
  </instantiation>
  </command>
  <command  name="time">
    <comment>time in millisecs</comment>
  <instantiation>
    <signature>():int </signature>
    <implementation> ALARMtime;</implementation>
  </instantiation>
  </command>
  <command  name="timers">
    <comment>give a list of all active timers</comment>
  <instantiation>
    <signature>():bat[:str,:str] </signature>
    <implementation> ALARMtimers;</implementation>
  </instantiation>
  </command>
  <command  name="usec">
    <comment>return cpu microseconds info</comment>
  <instantiation>
    <signature>():lng </signature>
    <implementation> ALARMusec;</implementation>
  </instantiation>
  </command>
</module>
<module name="algebra">
  <function  name="betweenOO">
  <instantiation>
    <signature>(b:bat[:any\$1,:any\$2],l:any\$2,h:any\$2):bat[:any\$1,:any\$2];</signature>
  </instantiation>
  </function>
  <function  name="betweenOC">
  <instantiation>
    <signature>(b:bat[:any\$1,:any\$2],l:any\$2,h:any\$2):bat[:any\$1,:any\$2];</signature>
  </instantiation>
  </function>
  <function  name="betweenCO">
  <instantiation>
    <signature>(b:bat[:any\$1,:any\$2],l:any\$2,h:any\$2):bat[:any\$1,:any\$2];</signature>
  </instantiation>
  </function>
  <function  name="between">
  <instantiation>
    <signature>(b:bat[:any\$1,:any\$2],l:any\$2,h:any\$2):bat[:any\$1,:any\$2];</signature>
  </instantiation>
  </function>
  <command  name="bandjoin">
    <comment>This is a join() for which the predicate 
	is that two BUNs match if the left-tail 
	value is within the range [right-head - 
	minus, right-head + plus]. Works only for 
	the builtin numerical types, and their 
	derivates.</comment>
  <instantiation>
    <signature>(outer:bat[:any\$1,:any\$2],inner:bat[:any\$2,:any\$3],minus:any\$2,plus:any\$2):bat[:any\$1,:any\$3] </signature>
    <implementation> ALGbandjoin;</implementation>
  </instantiation>
  </command>
  <command  name="card">
    <comment>Return the cardinality of the BAT 
	tail values.</comment>
  <instantiation>
    <signature>(b:bat[:any,:any]):lng </signature>
    <implementation> ALGcard;</implementation>
  </instantiation>
  </command>
  <command  name="count\_no\_nil">
    <comment>Return the number of elements currently 
	in a BAT ignoring BUNs with nil-tail</comment>
  <instantiation>
    <signature>(b:bat[:any,:any]):int </signature>
    <implementation> ALGcount\_no\_nil;</implementation>
  </instantiation>
  </command>
  <command  name="count">
    <comment>Return the number of elements currently 
	in a BAT ignores BUNs with nil-tail iff 
	ignore\_nils==TRUE.</comment>
  <instantiation>
    <signature>(b:bat[:any,:any],ignore\_nils:bit):int </signature>
    <implementation> ALGcount\_nil;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any,:any]):lng </signature>
    <implementation> ALGcount\_bat;</implementation>
  </instantiation>
  </command>
  <command  name="cross">
    <comment>Returns the cross product</comment>
  <instantiation>
    <signature>(left:bat[:any\$1,:any\$2],right:bat[:any,:any]):bat[:any\$1,:any\$4] </signature>
    <implementation> ALGcross;</implementation>
  </instantiation>
  </command>
  <command  name="copy">
    <comment>Returns physical copy of a BAT.</comment>
  <instantiation>
    <signature>(b:bat[:any\$1,:any\$2]):bat[:any\$1,:any\$2] </signature>
    <implementation> ALGcopy;</implementation>
  </instantiation>
  </command>
  <command  name="diff">
  <instantiation>
    <signature>(left:bat[:any\$1,:any\$2],right:bat[:any\$1,:any\$2]):bat[:any\$1,:any\$2] </signature>
    <implementation> ALGsdiff;</implementation>
  </instantiation>
  </command>
  <command  name="exist">
    <comment>Returns true when 'h,t' occurs as a 
	bun in b.</comment>
  <instantiation>
    <signature>(b:bat[:any\$1,:any\$2],h:any\$1,t:any\$2):bit </signature>
    <implementation> ALGexistBUN;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:any],h:any\$1):bit </signature>
    <implementation> ALGexist;</implementation>
  </instantiation>
  </command>
  <command  name="fetchjoin">
    <comment>Hook directly into the fetch 
	implementation of the join.</comment>
  <instantiation>
    <signature>(left:bat[:any\$1,:any\$2],right:bat[:any\$2,:any\$3]):bat[:any\$1,:any\$3] </signature>
    <implementation> ALGfetchjoin;</implementation>
  </instantiation>
  </command>
  <command  name="fragment">
    <comment>Select both on head and tail range.</comment>
  <instantiation>
    <signature>(b:bat[:any\$1,:any\$2],hlow:any\$1,hhigh:any\$1,tlow:any\$2,thigh:any\$2):bat[:any\$1,:any\$2] </signature>
    <implementation> ALGfragment;</implementation>
  </instantiation>
  </command>
  <command  name="fetch">
    <comment>Returns a positional selection of b 
	by the oid head values of s</comment>
  <instantiation>
    <signature>(b:bat[:any\$1,:any\$2],s:bat[:oid,:any]):bat[:any\$1,:any\$2] </signature>
    <implementation> ALGfetchbat;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:any\$2],s:bat[:lng,:any]):bat[:any\$1,:any\$2] </signature>
    <implementation> ALGfetchbat;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:any\$2],s:bat[:int,:any]):bat[:any\$1,:any\$2] </signature>
    <implementation> ALGfetchbat;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any,:any\$1],x:int):any\$1 </signature>
    <implementation> ALGfetchint;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any,:any\$1],x:lng):any\$1 </signature>
    <implementation> ALGfetch;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any,:any\$1],x:oid):any\$1 </signature>
    <implementation> ALGfetchoid;</implementation>
  </instantiation>
  </command>
  <command  name="find">
    <comment>Returns the tail value 't' for which 
	some [h,t] BUN exists in b.  If no such
	BUN exists, an error occurs.</comment>
  <instantiation>
    <signature>(b:bat[:any\$1,:any\$2],h:any\$1):any\$2 </signature>
    <implementation> ALGfind;</implementation>
  </instantiation>
  </command>
  <command  name="histogram">
    <comment>Produce a BAT containing the histogram 
	of the tail values.  bat.histogram() 
	@= {count}(bat.reverse)</comment>
  <instantiation>
    <signature>(b:bat[:any,:any\$2]):bat[:any\$2,:int] </signature>
    <implementation> ALGhistogram;</implementation>
  </instantiation>
  </command>
  <command  name="hashsplit">
    <comment>Split a BAT on tail column according 
	(hash-value MOD buckets). Returns a 
	recursive BAT, containing the fragments 
	in the tail, their bucket number in the 
	head.</comment>
  <instantiation>
    <signature>(b:bat[:any\$1,:any\$2],buckects:int):bat[:int,:BAT] </signature>
    <implementation> ALGhashsplit;</implementation>
  </instantiation>
  </command>
  <command  name="hashjoin">
    <comment>Hook directly into the hash 
	implementation of the join.</comment>
  <instantiation>
    <signature>(left:bat[:any\$1,:any\$2],right:bat[:any\$2,:any\$3]):bat[:any\$1,:any\$3] </signature>
    <implementation> ALGhashjoin;</implementation>
  </instantiation>
  </command>
  <command  name="indexjoin">
    <comment>Hook directly into the index 
	implementation of the join.</comment>
  <instantiation>
    <signature>(left:bat[:any\$1,:any\$2],right:bat[:any\$2,:any\$3]):bat[:any\$1,:any\$3] </signature>
    <implementation> ALGindexjoin;</implementation>
  </instantiation>
  </command>
  <command  name="intersect">
  <instantiation>
    <signature>(left:bat[:any\$1,:any\$2],right:bat[:any\$1,:any\$2]):bat[:any\$1,:any\$2] </signature>
    <implementation> ALGsintersect;</implementation>
  </instantiation>
  </command>
  <command  name="join">
  <instantiation>
    <signature>(left:bat[:any\$1,:oid],right:bat[:void,:any\$3],estimate:lng):bat[:any\$1,:any\$3] </signature>
    <implementation> ALGjoinestimate;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:bat[:any\$1,:void],right:bat[:oid,:any\$3],estimate:lng):bat[:any\$1,:any\$3] </signature>
    <implementation> ALGjoinestimate;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:bat[:any\$1,:any\$2],right:bat[:any\$2,:any\$3],estimate:lng):bat[:any\$1,:any\$3] </signature>
    <implementation> ALGjoinestimate;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:bat[:any\$1,:oid],right:bat[:void,:any\$3]):bat[:any\$1,:any\$3] </signature>
    <implementation> ALGjoin;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:bat[:any\$1,:void],right:bat[:oid,:any\$3]):bat[:any\$1,:any\$3] </signature>
    <implementation> ALGjoin;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:bat[:any\$1,:any\$2],right:bat[:any\$2,:any\$3]):bat[:any\$1,:any\$3] </signature>
    <implementation> ALGjoin;</implementation>
  </instantiation>
  </command>
  <command  name="kunion">
    <comment>Returns the union of two BATs; looking 
	at head-columns only. Results in all BUNs 
	of 'left' that are  not in 'right', plus 
	all BUNs of 'right'. 
	*no* double-elimination is done. If you 
	want this, do:
	'kunion(left.kunique,right.kunique)' 
	or: 'sunion(left,right).kunique'.</comment>
  <instantiation>
    <signature>(left:bat[:any\$1,:any\$2],right:bat[:any\$1,:any\$2]):bat[:any\$1,:any\$2] </signature>
    <implementation> ALGkunion;</implementation>
  </instantiation>
  </command>
  <command  name="kdiff">
    <comment>Returns the difference taken over only 
	the *head* columns of two BATs.  Results 
	in all BUNs of 'left' that are *not* in 
	'right'. Does *not* do double-elimination 
	over the 'left' BUNs, If you want this, use:
	 'kdiff(left.kunique,right.kunique)' 
	or: 'kdiff(left,right).kunique'.</comment>
  <instantiation>
    <signature>(left:bat[:any\$1,:any\$2],right:bat[:any\$1,:any]):bat[:any\$1,:any\$2] </signature>
    <implementation> ALGkdiff;</implementation>
  </instantiation>
  </command>
  <command  name="kintersect">
    <comment>Returns the intersection taken over only 
	the *head* columns of two BATs. Results in 
	all BUNs of 'left' that are also in 'right'.
	Does *not* do double-elimination over the 
	'left' BUNs, If you want this, use:
	 'kintersect(left.kunique,right.kunique)' 
	or: 'kintersect(left,right).kunique'.</comment>
  <instantiation>
    <signature>(left:bat[:any\$1,:any\$2],right:bat[:any\$1,:any]):bat[:any\$1,:any\$2] </signature>
    <implementation> ALGsemijoin;</implementation>
  </instantiation>
  </command>
  <command  name="kunique">
    <comment>Select unique tuples from the input BAT.
	Double elimination is done only looking 
	at the head column. Result is a BAT with
	property hkeyed() == true.</comment>
  <instantiation>
    <signature>(b:bat[:any\$1,:any\$2]):bat[:any\$1,:any\$2] </signature>
    <implementation> ALGkunique;</implementation>
  </instantiation>
  </command>
  <command  name="like">
    <comment>Selects all elements that have 
	'substr' as in the tail.</comment>
  <instantiation>
    <signature>(b:bat[:any\$1,:str],substr:str):bat[:any\$1,:str] </signature>
    <implementation> ALGlike;</implementation>
  </instantiation>
  </command>
  <command  name="min">
    <comment>Give the lowest tail value. Error on empty BATs.</comment>
  <instantiation>
    <signature>(b:bat[:any,:lng]):lng </signature>
    <implementation> ALGmin\_lng;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any,:dbl]):dbl </signature>
    <implementation> ALGmin\_dbl;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any,:flt]):flt </signature>
    <implementation> ALGmin\_flt;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any,:int]):int </signature>
    <implementation> ALGmin\_int;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any,:sht]):sht </signature>
    <implementation> ALGmin\_sht;</implementation>
  </instantiation>
  </command>
  <command  name="max">
    <comment>Give the highest tail value. Error on empty BATs.</comment>
  <instantiation>
    <signature>(b:bat[:any,:lng]):lng </signature>
    <implementation> ALGmax\_lng;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any,:dbl]):dbl </signature>
    <implementation> ALGmax\_dbl;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any,:flt]):flt </signature>
    <implementation> ALGmax\_flt;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any,:int]):int </signature>
    <implementation> ALGmax\_int;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any,:sht]):sht </signature>
    <implementation> ALGmax\_sht;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:any\$2]):any\$2 </signature>
    <implementation> ALGmaxany;</implementation>
  </instantiation>
  </command>
  <command  name="min">
    <comment>Give the lowest tail value. Error 
	on empty BATs.</comment>
  <instantiation>
    <signature>(b:bat[:any\$1,:any\$2]):any\$2 </signature>
    <implementation> ALGminany;</implementation>
  </instantiation>
  </command>
  <command  name="mark">
    <comment>Produces a new BAT with fresh unique dense 
	sequense of OIDs in the tail that starts 
	at base (i.e. [base,..base+b.count()-1] ).</comment>
  <instantiation>
    <signature>(b:bat[:any\$1,:any],base:void):bat[:any\$1,:oid] </signature>
    <implementation> ALGmark0;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:any],base:oid):bat[:any\$1,:oid] </signature>
    <implementation> ALGmark;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:any]):bat[:any\$1,:oid] </signature>
    <implementation> ALGmark\_default;</implementation>
  </instantiation>
  </command>
  <command  name="mergejoin">
    <comment>Hook directly into the merge 
	implementation of the join.</comment>
  <instantiation>
    <signature>(left:bat[:any\$1,:any\$2],right:bat[:any\$2,:any\$3]):bat[:any\$1,:any\$3] </signature>
    <implementation> ALGmergejoin;</implementation>
  </instantiation>
  </command>
  <command  name="number">
    <comment>Produces a new BAT with identical head 
	column, and consecutively increasing 
	integers (start at 0) in the tail column.</comment>
  <instantiation>
    <signature>(b:bat[:any\$1,:any]):bat[:any\$1,:int] </signature>
    <implementation> ALGnumber;</implementation>
  </instantiation>
  </command>
  <command  name="outerjoin">
  <instantiation>
    <signature>(outer:bat[:any\$1,:any\$2],inner:bat[:any\$2,:any\$3],estimate:lng):bat[:any\$1,:any\$3] </signature>
    <implementation> ALGouterjoinestimate;</implementation>
  </instantiation>
  <instantiation>
    <signature>(outer:bat[:any\$1,:any\$2],inner:bat[:any\$2,:any\$3]):bat[:any\$1,:any\$3] </signature>
    <implementation> ALGouterjoin;</implementation>
  </instantiation>
  </command>
  <command  name="prod">
    <comment>Gives the produc of all tail values</comment>
  <instantiation>
    <signature>(b:bat[:any,:dbl]):dbl </signature>
    <implementation> ALGprod\_dbl\_dbl;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any,:flt]):dbl </signature>
    <implementation> ALGprod\_flt\_dbl;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any,:flt]):flt </signature>
    <implementation> ALGprod\_flt\_flt;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any,:lng]):lng </signature>
    <implementation> ALGprod\_lng\_lng;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any,:int]):lng </signature>
    <implementation> ALGprod\_int\_lng;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any,:int]):int </signature>
    <implementation> ALGprod\_int\_int;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any,:sht]):lng </signature>
    <implementation> ALGprod\_sht\_lng;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any,:sht]):int </signature>
    <implementation> ALGprod\_sht\_int;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any,:sht]):sht </signature>
    <implementation> ALGprod\_sht\_sht;</implementation>
  </instantiation>
  </command>
  <command  name="position">
    <comment>Returns the position of the value pair
	 It returns an error if 'val' does not 
	exist.</comment>
  <instantiation>
    <signature>(b:bat[:any\$1,:any\$2],val:any\$1,tval:any\$2):int </signature>
    <implementation> ALGpositionBUN;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:any],v:any\$1):int </signature>
    <implementation> ALGposition;</implementation>
  </instantiation>
  </command>
  <command  name="sum">
    <comment>Gives the sum of all tail values</comment>
  <instantiation>
    <signature>(b:bat[:any,:dbl]):dbl </signature>
    <implementation> ALGsum\_dbl\_dbl;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any,:flt]):dbl </signature>
    <implementation> ALGsum\_flt\_dbl;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any,:flt]):flt </signature>
    <implementation> ALGsum\_flt\_flt;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any,:lng]):lng </signature>
    <implementation> ALGsum\_lng\_lng;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any,:int]):lng </signature>
    <implementation> ALGsum\_int\_lng;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any,:int]):int </signature>
    <implementation> ALGsum\_int\_int;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any,:sht]):lng </signature>
    <implementation> ALGsum\_sht\_lng;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any,:sht]):int </signature>
    <implementation> ALGsum\_sht\_int;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any,:sht]):sht </signature>
    <implementation> ALGsum\_sht\_sht;</implementation>
  </instantiation>
  </command>
  <command  name="sunion">
    <comment>Returns the union of two BATs; looking 
	at both columns of both BATs. Results in 
	all BUNs of 'left' that are  not in 
	'right', plus all BUNs of 'right'. 
	*no* double-elimination is done. If you 
	want this, do:
	 'sunion(left.sunique,right.sunique)' 
	or: 'sunion(left,right).sunique'.</comment>
  <instantiation>
    <signature>(left:bat[:any\$1,:any\$2],right:bat[:any\$1,:any\$2]):bat[:any\$1,:any\$2] </signature>
    <implementation> ALGsunion;</implementation>
  </instantiation>
  </command>
  <command  name="sdiff">
    <comment>Returns the difference taken over 
	*both* columns of two BATs. Results in 
	all BUNs of 'left' that are *not* in 
	'right'. Does *not* do double-elimination 
	over the 'left' BUNs, If you want this, 
	use:
	     'sdiff(left.sunique,right.sunique)' 
	or: 'sdiff(left,right).sunique'.</comment>
  <instantiation>
    <signature>(left:bat[:any\$1,:any\$2],right:bat[:any\$1,:any\$2]):bat[:any\$1,:any\$2] </signature>
    <implementation> ALGsdiff;</implementation>
  </instantiation>
  </command>
  <command  name="semijoin">
    <comment>Patch to enable semijoin over void/oid columns</comment>
  <instantiation>
    <signature>(left:bat[:void,:any\$2],right:bat[:oid,:any]):bat[:oid,:any\$2] </signature>
    <implementation> ALGsemijoin;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:bat[:any\$1,:any\$2],right:bat[:any\$1,:any]):bat[:any\$1,:any\$2] </signature>
    <implementation> ALGsemijoin;</implementation>
  </instantiation>
  </command>
  <command  name="sintersect">
    <comment>Returns the intersection taken over 
	*both* columns of two BATs. Results in 
	all BUNs of 'left' that are also in 
	'right'. Does *not* do double-elimination 
	over the 'left' BUNs, If you want this, 
	use:
	 'sintersect(left.sunique,right.sunique)' 
	or: 'sintersect(left,right).sunique'.</comment>
  <instantiation>
    <signature>(left:bat[:any\$1,:any\$2],right:bat[:any\$1,:any\$2]):bat[:any\$1,:any\$2] </signature>
    <implementation> ALGsintersect;</implementation>
  </instantiation>
  </command>
  <command  name="sunique">
    <comment>Select unique tuples from the input BAT.
	Double elimination is done over BUNs as 
	a whole (head and tail).  Result is a BAT 
	with real set() semantics.</comment>
  <instantiation>
    <signature>(b:bat[:any\$1,:any\$2]):bat[:any\$1,:any\$2] </signature>
    <implementation> ALGsunique;</implementation>
  </instantiation>
  </command>
  <command  name="sort">
    <comment>Returns a BAT copy sorted on 
	the head column.</comment>
  <instantiation>
    <signature>(b:bat[:any\$1,:any\$2]):bat[:any\$1,:any\$2] </signature>
    <implementation> ALGsort;</implementation>
  </instantiation>
  </command>
  <command  name="sample">
    <comment>Produce a random selection of size 'num' 
	from the input BAT.</comment>
  <instantiation>
    <signature>(b:bat[:any\$1,:any\$2],num:int):bat[:any\$1,:any\$2] </signature>
    <implementation> ALGsample;</implementation>
  </instantiation>
  </command>
  <command  name="slice">
    <comment>Return the slice with the BUNs at 
	position x till y.</comment>
  <instantiation>
    <signature>(b:bat[:any\$1,:any\$2],x:int,y:int):bat[:any\$1,:any\$2] </signature>
    <implementation> ALGslice;</implementation>
  </instantiation>
  </command>
  <command  name="select">
    <comment>Select all BUNs of a BAT with a certain 
	tail value. Selection on NIL is also 
	possible (it should be properly casted, 
	e.g.:int(nil)).</comment>
  <instantiation>
    <signature>(b:bat[:any\$1,:any\$2],value:any\$2):bat[:any\$1,:any\$2] </signature>
    <implementation> ALGselect1;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:any\$2],low:any\$2,high:any\$2,li:bit,hi:bit):bat[:any\$1,:any\$2] </signature>
    <implementation> ALGselectInclusive;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:any\$2],low:any\$2,high:any\$2):bat[:any\$1,:any\$2] </signature>
    <implementation> ALGselect;</implementation>
  </instantiation>
  </command>
  <command  name="topN">
    <comment>Trim all but the top N tuples.</comment>
  <instantiation>
    <signature>(b:bat[:any,:any],top:lng):int </signature>
    <implementation> ALGtopN;</implementation>
  </instantiation>
  </command>
  <command  name="thetajoin">
  <instantiation>
    <signature>(left:bat[:any\$1,:any\$2],right:bat[:any\$2,:any\$3],opname:int,estimate:lng):bat[:any\$1,:any\$3] </signature>
    <implementation> ALGthetajoinEstimate;</implementation>
  </instantiation>
  </command>
  <command  name="tunique">
    <comment>Select unique tail tuples from the BAT.
	Equivalent to revers().kunique() </comment>
  <instantiation>
    <signature>(b:bat[:any\$1,:any\$2]):bat[:any\$1,:any\$2] </signature>
    <implementation> ALGsunique;</implementation>
  </instantiation>
  </command>
  <command  name="uhashsplit">
    <comment>Same as hashsplit, but only collect the 
	head values in the fragments</comment>
  <instantiation>
    <signature>(b:bat[:any\$1,:any\$2],buckets:int):bat[:int,:BAT] </signature>
    <implementation> ALGuhashsplit;</implementation>
  </instantiation>
  </command>
  <command  name="union">
  <instantiation>
    <signature>(left:bat[:any\$1,:any\$2],right:bat[:any\$1,:any\$2]):bat[:any\$1,:any\$2] </signature>
    <implementation> ALGsunion;</implementation>
  </instantiation>
  </command>
  <command  name="unique">
  <instantiation>
    <signature>(b:bat[:any\$1,:any\$2]):bat[:any\$1,:any\$2] </signature>
    <implementation> ALGsunique;</implementation>
  </instantiation>
  </command>
  <command  name="uselect">
    <comment>Value select, but returning only the 
	head values. SEE ALSO:select(bat,val)</comment>
  <instantiation>
    <signature>(b:bat[:any\$1,:any\$2],value:any\$2):bat[:any\$1,:void] </signature>
    <implementation> ALGuselect1;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:any\$2],low:any\$2,high:any\$2):bat[:any\$1,:void] </signature>
    <implementation> ALGuselect;</implementation>
  </instantiation>
  </command>
</module>
<module name="bat">
  <command  name="accpresent">
    <comment>Returns the accelerator type of the 
	*persistent* accelerator present on 
	the head column of b. Note that index 
	and hash accelerators are generally 
	*not* persistent, and will not be 
	returned by this function!</comment>
  <instantiation>
    <signature>(b:bat[:any,:any]):int </signature>
    <implementation> BKCaccpresent;</implementation>
  </instantiation>
  </command>
  <command  name="accdestroy">
    <comment>Destroy the accelerator of type 
	'acctype'  that is present on
	the head-type of b.</comment>
  <instantiation>
    <signature>(b:bat[:any,:any],acctype:int):void </signature>
    <implementation> BKCaccdestroy;</implementation>
  </instantiation>
  </command>
  <command  name="accbuild">
    <comment>like accbuild(bat[:any,:any] b, int acctype), but with a parameter that
 is provide to the specific accelerator build routine.</comment>
  <instantiation>
    <signature>(b:bat[:any,:any],acctype:int,param:ptr):int </signature>
    <implementation> BKCaccbuild;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any,:any],acctype:str):bit </signature>
    <implementation> BKCaccbuild\_std;</implementation>
  </instantiation>
  </command>
  <command  name="append">
    <comment>Special case append for empty bats,
	 works around impossible void,void case</comment>
  <instantiation>
    <signature>(i:bat[:oid,:void],u:bat[:oid,:void]):bat[:oid,:void] </signature>
    <implementation> BKCbat\_append\_oidvoid\_bat\_wrap;</implementation>
  </instantiation>
  <instantiation>
    <signature>(i:bat[:void,:any\$1],u:any\$1):bat[:void,:any\$1] </signature>
    <implementation> BKCbat\_append\_val\_wrap;</implementation>
  </instantiation>
  <instantiation>
    <signature>(i:bat[:void,:any\$1],u:bat[:oid,:any\$1]):bat[:void,:any\$1] </signature>
    <implementation> BKCbat\_append\_oid\_bat\_wrap;</implementation>
  </instantiation>
  <instantiation>
    <signature>(i:bat[:void,:any\$1],u:bat[:void,:any\$1]):bat[:void,:any\$1] </signature>
    <implementation> BKCbat\_append\_void\_bat\_wrap;</implementation>
  </instantiation>
  <instantiation>
    <signature>(i:bat[:oid,:any\$1],u:any\$1):bat[:oid,:any\$1] </signature>
    <implementation> BKCoid\_bat\_append\_val\_wrap;</implementation>
  </instantiation>
  <instantiation>
    <signature>(i:bat[:oid,:any\$1],u:bat[:oid,:any\$1]):bat[:oid,:any\$1] </signature>
    <implementation> BKCoid\_bat\_append\_oid\_bat\_wrap;</implementation>
  </instantiation>
  </command>
  <command  name="access">
  <instantiation>
    <signature>(b:bat[:any\$1,:any\$2],mode:int):void </signature>
    <implementation> BKCaccess;</implementation>
  </instantiation>
  </command>
  <command  name="bat">
    <comment>Creates a new empty BAT, directly 
	allocating for 'size' elements.</comment>
  <instantiation>
    <signature>(ht:int,tt:int,size:lng):bat[:any,:any] </signature>
    <implementation> BKCnewBATlng;</implementation>
  </instantiation>
  <instantiation>
    <signature>(ht:int,tt:int,size:int):bat[:any,:any] </signature>
    <implementation> BKCnewBATint;</implementation>
  </instantiation>
  <instantiation>
    <signature>(ht:int,tt:int):bat[:any,:any] </signature>
    <implementation> BKCnewBat;</implementation>
  </instantiation>
  </command>
  <command  name="clear">
    <comment>Delete all BUNs in a BAT.</comment>
  <instantiation>
    <signature>(b:bat[:any\$1,:any\$2]):void </signature>
    <implementation> BKCdelete\_all;</implementation>
  </instantiation>
  </command>
  <command  name="convert">
    <comment>Convert the contents of a BAT from 
	little-endian to big-endian and vice versa.
	 THIS command SHOULD NOT BE USED FROM MAL!
	DANGEROUS! DEBUGGING PURPOSES ONLY!</comment>
  <instantiation>
    <signature>(b:bat[:any\$1,:any\$2]):bat[:any\$1,:any\$2] </signature>
    <implementation> BKCconvert;</implementation>
  </instantiation>
  </command>
  <command  name="deleteBuns">
    <comment>Delete from the first BAT all BUNs 
	with a corresponding BUN in the second.</comment>
  <instantiation>
    <signature>(b:bat[:any\$1,:any\$2],src:bat[:any\$1,:any\$2]):void </signature>
    <implementation> BKCdelete\_bat\_bun;</implementation>
  </instantiation>
  </command>
  <command  name="delete">
    <comment>Delete from the first BAT all BUNs 
	with a head value that is in the 
	second.</comment>
  <instantiation>
    <signature>(b:bat[:any\$1,:any\$2],src:bat[:any\$1,:any]):void </signature>
    <implementation> BKCdelete\_bat\_head;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:any\$2]):void </signature>
    <implementation> BKCdelete\_all;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:void,:any\$2],h:oid):void </signature>
    <implementation> BKCdelete\_head;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:any\$2],h:any\$1):void </signature>
    <implementation> BKCdelete\_head;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:void,:any\$2],h:oid,t:any\$2):void </signature>
    <implementation> BKCdelete\_bun;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:any\$2],h:any\$1,t:any\$2):void </signature>
    <implementation> BKCdelete\_bun;</implementation>
  </instantiation>
  </command>
  <command  name="getName">
    <comment>Gives back the logical name of a BAT.</comment>
  <instantiation>
    <signature>(b:bat[:any,:any]):str </signature>
    <implementation> BKCgetBBPname;</implementation>
  </instantiation>
  </command>
  <command  name="getDelta">
    <comment>Obtain the list of BUNs deleted</comment>
  <instantiation>
    <signature>(b:bat[:any\$1,:any\$2]):bat[:any\$1,:any\$2] </signature>
    <implementation> BKCgetDelta;</implementation>
  </instantiation>
  </command>
  <command  name="getAlpha">
    <comment>Obtain the list of BUNs added</comment>
  <instantiation>
    <signature>(b:bat[:any\$1,:any\$2]):bat[:any\$1,:any\$2] </signature>
    <implementation> BKCgetAlpha;</implementation>
  </instantiation>
  </command>
  <command  name="getBatSize">
    <comment>A version of BATsize that does 
	not require loading the BAT.</comment>
  <instantiation>
    <signature>(b:bat[:any,:any]):int </signature>
    <implementation> BKCbatsize;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any,:any]):str </signature>
    <implementation> BKCbatsize\_str;</implementation>
  </instantiation>
  </command>
  <command  name="getSequenceBase">
  <instantiation>
    <signature>(b:bat[:oid,:any]):oid </signature>
    <implementation> BKCgetSequenceBase;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:void,:any]):oid </signature>
    <implementation> BKCgetSequenceBase;</implementation>
  </instantiation>
  </command>
  <command  name="getAccess">
    <comment>return the access mode attached to 
	this BAT as a character.</comment>
  <instantiation>
    <signature>(b:bat[:any,:any]):chr </signature>
    <implementation> BKCgetAccess;</implementation>
  </instantiation>
  </command>
  <command  name="getRole">
    <comment>Returns the rolename of the head column 
	of a BAT.</comment>
  <instantiation>
    <signature>(bid:bat[:any,:any]):str </signature>
    <implementation> BKCgetRole;</implementation>
  </instantiation>
  </command>
  <command  name="getTailType">
    <comment>Returns the type of the tail column of 
	a BAT, as an integer type number.</comment>
  <instantiation>
    <signature>(b:bat[:any,:any]):str </signature>
    <implementation> BKCgetTailType;</implementation>
  </instantiation>
  </command>
  <command  name="getHeadType">
    <comment>Returns the type of the head column of 
	a BAT, as an integer type number.</comment>
  <instantiation>
    <signature>(b:bat[:any,:any]):str </signature>
    <implementation> BKCgetHeadType;</implementation>
  </instantiation>
  </command>
  <command  name="getCapacity">
    <comment>Returns the current allocation size (in 
	max number of elements) of a BAT.</comment>
  <instantiation>
    <signature>(b:bat[:any,:any]):lng </signature>
    <implementation> BKCgetCapacity;</implementation>
  </instantiation>
  </command>
  <command  name="hasIndex">
  <instantiation>
    <signature>(b:bat[:any,:any]):bit </signature>
    <implementation> BKChasIndex;</implementation>
  </instantiation>
  </command>
  <command  name="hasHash">
  <instantiation>
    <signature>(b:bat[:any,:any]):bit </signature>
    <implementation> BKChasHash;</implementation>
  </instantiation>
  </command>
  <command  name="heat">
    <comment>Return the current BBP heat (LRU stamp)</comment>
  <instantiation>
    <signature>(name:str):lng </signature>
    <implementation> BKCheat;</implementation>
  </instantiation>
  </command>
  <command  name="hasReadMode">
    <comment>return true if to this BAT is 
	read only.</comment>
  <instantiation>
    <signature>(b:bat[:any,:any]):bit </signature>
    <implementation> BKChasReadMode;</implementation>
  </instantiation>
  </command>
  <command  name="hasWriteMode">
    <comment>return true if to this BAT is read 
	and write.</comment>
  <instantiation>
    <signature>(b:bat[:any,:any]):bit </signature>
    <implementation> BKChasWriteMode;</implementation>
  </instantiation>
  </command>
  <command  name="hasAppendMode">
    <comment>return true if to this BAT is 
	append only.</comment>
  <instantiation>
    <signature>(b:bat[:any,:any]):bit </signature>
    <implementation> BKChasAppendMode;</implementation>
  </instantiation>
  </command>
  <command  name="isSynced">
    <comment>Tests whether two BATs are synced or not. </comment>
  <instantiation>
    <signature>(b1:bat[:any,:any],b2:bat[:any,:any]):bit </signature>
    <implementation> BKCisSynced;</implementation>
  </instantiation>
  </command>
  <command  name="isCached">
    <comment>Bat is stored in main memory.</comment>
  <instantiation>
    <signature>(b:bat[:any,:any]):bit </signature>
    <implementation> BKCisCached;</implementation>
  </instantiation>
  </command>
  <command  name="isPersistent">
  <instantiation>
    <signature>(b:bat[:any,:any]):bit </signature>
    <implementation> BKCisPersistent;</implementation>
  </instantiation>
  </command>
  <command  name="isTransient">
  <instantiation>
    <signature>(b:bat[:any,:any]):bit </signature>
    <implementation> BKCisTransient;</implementation>
  </instantiation>
  </command>
  <command  name="insert">
    <comment>Insert a value in a 'void' bat</comment>
  <instantiation>
    <signature>(b:bat[:void,:any\$1],v:any\$1):void </signature>
    <implementation> BKCinsert\_void\_bun;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:void,:any\$2],h:oid,t:any\$2):void </signature>
    <implementation> BKCinsert\_bun;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:any\$2],h:any\$1,t:any\$2):void </signature>
    <implementation> BKCinsert\_bun;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:any\$2],src:bat[:any\$1,:any\$2]):void </signature>
    <implementation> BKCinsert\_bat;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:oid],src:bat[:any\$1,:void]):bat[:any\$1,:any\$2] </signature>
    <implementation> BKCinsert\_bat;</implementation>
  </instantiation>
  </command>
  <command  name="isSortedReverse">
    <comment>Returns whether a BAT is ordered on head or not.</comment>
  <instantiation>
    <signature>(b:bat[:any,:any]):bit </signature>
    <implementation> BKCisSortedReverse;</implementation>
  </instantiation>
  </command>
  <command  name="isSorted">
    <comment>Returns whether a BAT is ordered on head or not.</comment>
  <instantiation>
    <signature>(b:bat[:any,:any]):bit </signature>
    <implementation> BKCisSorted;</implementation>
  </instantiation>
  </command>
  <command  name="isaSet">
    <comment>return whether the BAT mode is set to unique.</comment>
  <instantiation>
    <signature>(b:bat[:any,:any]):bit </signature>
    <implementation> BKCisaSet;</implementation>
  </instantiation>
  </command>
  <command  name="isaKey">
    <comment>return whether the head column of a BAT 
	is unique (key).</comment>
  <instantiation>
    <signature>(b:bat[:any,:any]):bit </signature>
    <implementation> BKCgetKey;</implementation>
  </instantiation>
  </command>
  <command  name="info">
    <comment>Produce a BAT containing info about a BAT 
	in [attribute,value] format. It contains 
	all properties of the BAT record. See the 
	BAT documentation in GDK for more information.</comment>
  <instantiation>
    <signature>(b:bat[:any,:any]):bat[:str,:str] </signature>
    <implementation> BKCinfo;</implementation>
  </instantiation>
  </command>
  <command  name="load">
    <comment>Load a particylar bat from disk</comment>
  <instantiation>
    <signature>(name:str):bat[:any,:any] </signature>
    <implementation> BKCload;</implementation>
  </instantiation>
  </command>
  <command  name="madvise">
    <comment>alias for madvise(b,mode,mode,mode,
	mode,mode)</comment>
  <instantiation>
    <signature>(b:bat[:any,:any],mode:int):bit </signature>
    <implementation> BKCmadvise2;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any,:any],buns\_mode:int,hheap\_mode:int,theap\_mode:int,hacc\_mode:int,tacc\_mode:int):bit </signature>
    <implementation> BKCmadvise;</implementation>
  </instantiation>
  </command>
  <command  name="mmap">
    <comment>Alias for mmap(b,mode,mode,mode,
	mode,mode)</comment>
  <instantiation>
    <signature>(b:bat[:any,:any],mode:int):bit </signature>
    <implementation> BKCmmap2;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any,:any],buns\_mode:int,hheap\_mode:int,theap\_mode:int,hacc\_mode:int,tacc\_mode:int):bit </signature>
    <implementation> BKCmmap;</implementation>
  </instantiation>
  </command>
  <command  name="mirror">
    <comment>Returns the head-mirror image of a BAT 
	(two head columns).</comment>
  <instantiation>
    <signature>(b:bat[:any\$1,:any]):bat[:any\$1,:any\$1] </signature>
    <implementation> BKCmirror;</implementation>
  </instantiation>
  </command>
  <command  name="order">
    <comment>Sorts the BAT itself, in place. </comment>
  <instantiation>
    <signature>(b:bat[:any\$1,:any\$2]):bat[:any\$1,:any\$2] </signature>
    <implementation> BKCorder;</implementation>
  </instantiation>
  </command>
  <command  name="persists">
    <comment>Backward compatibility</comment>
  <instantiation>
    <signature>(b:bat[:any,:any],f:any):bit </signature>
    <implementation> BKCpersists;</implementation>
  </instantiation>
  </command>
  <command  name="replace">
    <comment>inplace replace values on the 
	given locations</comment>
  <instantiation>
    <signature>(o:bat[:void,:any\$1],d:bat[:oid,:any\$1]):bat[:void,:any\$1] </signature>
    <implementation> BKCbat\_replace\_oid\_bat\_wrap;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:void,:any\$2],h:oid,t:any\$2):void </signature>
    <implementation> BKCreplace\_bun;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:any\$2],h:any\$1,t:any\$2):void </signature>
    <implementation> BKCreplace\_bun;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:any\$2],src:bat[:any\$1,:any\$2]):bat[:any\$1,:any\$2] </signature>
    <implementation> BKCreplace\_bat;</implementation>
  </instantiation>
  </command>
  <command  name="revert">
    <comment>Puts all BUNs in a BAT in reverse order.
	(Belongs to the BAT sequence module)</comment>
  <instantiation>
    <signature>(b:bat[:any\$1,:any\$2]):bat[:any\$1,:any\$2] </signature>
    <implementation> BKCrevert;</implementation>
  </instantiation>
  </command>
  <command  name="reverse">
    <comment>Returns the reverse view of a BAT (head 
	is tail and tail is head). BEWARE  no 
	copying is involved; input and output 
	refer to the same object!</comment>
  <instantiation>
    <signature>(b:bat[:any\$1,:any\$2]):bat[:any\$2,:any\$1] </signature>
    <implementation> BKCreverse;</implementation>
  </instantiation>
  </command>
  <command  name="setIndex">
  <instantiation>
    <signature>(b:bat[:any,:any],prop:bit):bit </signature>
    <implementation> BKCsetIndex;</implementation>
  </instantiation>
  </command>
  <command  name="setHash">
  <instantiation>
    <signature>(b:bat[:any,:any],prop:bit):bit </signature>
    <implementation> BKCsetHash;</implementation>
  </instantiation>
  </command>
  <command  name="setHot">
  <instantiation>
    <signature>(b:bat[:any,:any]):void </signature>
    <implementation> BKChotBAT;</implementation>
  </instantiation>
  </command>
  <command  name="setCold">
  <instantiation>
    <signature>(b:bat[:any,:any]):void </signature>
    <implementation> BKCcoldBAT;</implementation>
  </instantiation>
  <instantiation>
    <signature>(nme:str):void </signature>
    <implementation> BKCcold;</implementation>
  </instantiation>
  </command>
  <command  name="setHot">
    <comment>Makes a BAT very hot for the BBP. The 
	chance of being chosen for swapout is 
	small, afterwards.  Returns the BAT itself.</comment>
  <instantiation>
    <signature>(name:str):void </signature>
    <implementation> BKChot;</implementation>
  </instantiation>
  </command>
  <command  name="save">
    <comment>Save a BAT to storage, if it was 
	loaded and dirty.  Returns whether 
	IO was necessary.  Please realize that 
	calling this function violates the 
	atomic commit protocol!!</comment>
  <instantiation>
    <signature>(nme:str):bit </signature>
    <implementation> BKCsave;</implementation>
  </instantiation>
  <instantiation>
    <signature>(nme:bat[:any,:any]):bit </signature>
    <implementation> BKCsave2;</implementation>
  </instantiation>
  </command>
  <command  name="setPersistent">
    <comment>Make the BAT persistent.  Returns 
	boolean which indicates if the
BAT administration has indeed changed.</comment>
  <instantiation>
    <signature>(b:bat[:any,:any]):bit </signature>
    <implementation> BKCsetPersistent;</implementation>
  </instantiation>
  </command>
  <command  name="setTransient">
    <comment>Make the BAT transient.  Returns 
	boolean which indicates if the
BAT administration has indeed changed.</comment>
  <instantiation>
    <signature>(b:bat[:any,:any]):bit </signature>
    <implementation> BKCsetTransient;</implementation>
  </instantiation>
  </command>
  <command  name="setColumn">
    <comment>Give both columns of a BAT a new name.</comment>
  <instantiation>
    <signature>(b:bat[:any\$1,:any\$2],h:str,t:str):void </signature>
    <implementation> BKCsetColumns;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:any\$2],t:str):void </signature>
    <implementation> BKCsetColumn;</implementation>
  </instantiation>
  </command>
  <command  name="setRole">
    <comment>Give a logical name to the columns of 
	a BAT.</comment>
  <instantiation>
    <signature>(b:bat[:any\$1,:any\$2],h:str,t:str):void </signature>
    <implementation> BKCsetRole;</implementation>
  </instantiation>
  </command>
  <command  name="setName">
    <comment>Give a logical name to a BAT. </comment>
  <instantiation>
    <signature>(b:bat[:any\$1,:any\$2],s:str):void </signature>
    <implementation> BKCsetName;</implementation>
  </instantiation>
  </command>
  <command  name="setSorted">
    <comment>Assure BAT is ordered on head.</comment>
  <instantiation>
    <signature>(b:bat[:any,:any]):bit </signature>
    <implementation> BKCsetSorted;</implementation>
  </instantiation>
  </command>
  <command  name="setSequenceBase">
  <instantiation>
    <signature>(b:bat[:oid,:any\$1],seqbase:oid):any </signature>
    <implementation> BKCsetSequenceBase;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:void,:any\$1],seqbase:oid):any </signature>
    <implementation> BKCsetSequenceBase;</implementation>
  </instantiation>
  </command>
  <command  name="setWriteMode">
    <comment>Change access privilige of BAT to 
	read and write</comment>
  <instantiation>
    <signature>(b:bat[:any\$1,:any\$2]):void </signature>
    <implementation> BKCsetWriteMode;</implementation>
  </instantiation>
  </command>
  <command  name="setReadMode">
    <comment>Change access privilige of BAT to 
	read only</comment>
  <instantiation>
    <signature>(b:bat[:any\$1,:any\$2]):void </signature>
    <implementation> BKCsetReadMode;</implementation>
  </instantiation>
  </command>
  <command  name="setAppendMode">
    <comment>Change access privilige of BAT to 
	append only</comment>
  <instantiation>
    <signature>(b:bat[:any\$1,:any\$2]):void </signature>
    <implementation> BKCsetAppendMode;</implementation>
  </instantiation>
  </command>
  <command  name="setAccess">
    <comment>Try to change the update access priviliges 
	to this BAT. Mode:
	 r[ead-only]      - allow only read access.
	 a[append-only]   - allow reads and update.
	 w[riteable]      - allow all operations.
	BATs are updatable by default. On making 
	a BAT read-only, all subsequent updates 
	fail with an error message.Returns the 
	BAT itself.</comment>
  <instantiation>
    <signature>(b:bat[:any\$1,:any\$2],mode:str):void </signature>
    <implementation> BKCsetAccess;</implementation>
  </instantiation>
  </command>
  <command  name="setSet">
    <comment>Sets the 'set' property on this BAT to 
	'mode'. In 'set' mode, the kernel will 
	silently block insertions that cause a 
	duplicate BUN [head,tail] entries
	in the BAT.
	KNOWN BUG:when 'set' is set to TRUE, this 
	function does not automatically
	 eliminate duplicates. Use b := b.sunique;
	 Returns the BAT itself.</comment>
  <instantiation>
    <signature>(b:bat[:any\$1,:any\$2],mode:bit):bat[:any\$1,:any\$2] </signature>
    <implementation> BKCsetSet;</implementation>
  </instantiation>
  </command>
  <command  name="setKey">
    <comment>Sets the 'key' property of the head 
	column to 'mode'. In 'key' mode, the kernel 
	will silently block insertions that cause 
	a duplicate entries in the head column.
	 KNOWN BUG:when 'key' is set to TRUE, this 
	function does not automatically eliminate 
	duplicates. Use b := b.kunique;</comment>
  <instantiation>
    <signature>(b:bat[:any\$1,:any\$2],mode:bit):bat[:any\$1,:any\$2] </signature>
    <implementation> BKCsetkey;</implementation>
  </instantiation>
  </command>
  <command  name="unload">
    <comment>Swapout a BAT to disk. Transient BATs 
	can also be swapped out. Returns 
	whether the unload indeed happened. </comment>
  <instantiation>
    <signature>(name:str):bit </signature>
    <implementation> BKCunload;</implementation>
  </instantiation>
  </command>
</module>
<module name="batcalc">
  <command  name="!=">
  <instantiation>
    <signature>(a:bat[:any\$1,:bit],b:bat[:any\$1,:lng],cst:lng):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpaccumNEQcst;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:lng],cst:lng):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpNEQcst;</implementation>
  </instantiation>
  <instantiation>
    <signature>(a:bat[:any\$1,:bit],b:bat[:any\$1,:lng],c:bat[:any\$1,:lng]):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpaccumNEQ;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:lng],c:bat[:any\$1,:lng]):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpNEQ;</implementation>
  </instantiation>
  <instantiation>
    <signature>(a:bat[:any\$1,:bit],b:bat[:any\$1,:int],cst:int):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpaccumNEQcst;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:int],cst:int):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpNEQcst;</implementation>
  </instantiation>
  <instantiation>
    <signature>(a:bat[:any\$1,:bit],b:bat[:any\$1,:int],c:bat[:any\$1,:int]):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpaccumNEQ;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:int],c:bat[:any\$1,:int]):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpNEQ;</implementation>
  </instantiation>
  <instantiation>
    <signature>(a:bat[:any\$1,:bit],b:bat[:any\$1,:sht],cst:sht):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpaccumNEQcst;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:sht],cst:sht):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpNEQcst;</implementation>
  </instantiation>
  <instantiation>
    <signature>(a:bat[:any\$1,:bit],b:bat[:any\$1,:sht],c:bat[:any\$1,:sht]):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpaccumNEQ;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:sht],c:bat[:any\$1,:sht]):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpNEQ;</implementation>
  </instantiation>
  <instantiation>
    <signature>(a:bat[:any\$1,:bit],b:bat[:any\$1,:oid],cst:oid):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpaccumNEQcst;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:oid],cst:oid):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpNEQcst;</implementation>
  </instantiation>
  <instantiation>
    <signature>(a:bat[:any\$1,:bit],b:bat[:any\$1,:oid],c:bat[:any\$1,:oid]):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpaccumNEQ;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:oid],c:bat[:any\$1,:oid]):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpNEQ;</implementation>
  </instantiation>
  <instantiation>
    <signature>(a:bat[:any\$1,:bit],b:bat[:any\$1,:flt],cst:flt):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpaccumNEQcst;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:flt],cst:flt):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpNEQcst;</implementation>
  </instantiation>
  <instantiation>
    <signature>(a:bat[:any\$1,:bit],b:bat[:any\$1,:flt],c:bat[:any\$1,:flt]):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpaccumNEQ;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:flt],c:bat[:any\$1,:flt]):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpNEQ;</implementation>
  </instantiation>
  <instantiation>
    <signature>(a:bat[:any\$1,:bit],b:bat[:any\$1,:dbl],cst:dbl):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpaccumNEQcst;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:dbl],cst:dbl):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpNEQcst;</implementation>
  </instantiation>
  <instantiation>
    <signature>(a:bat[:any\$1,:bit],b:bat[:any\$1,:dbl],c:bat[:any\$1,:dbl]):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpaccumNEQ;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:dbl],c:bat[:any\$1,:dbl]):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpNEQ;</implementation>
  </instantiation>
  <instantiation>
    <signature>(a:bat[:any\$1,:bit],b:bat[:any\$1,:bit],cst:bit):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpaccumNEQcst;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:bit],cst:bit):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpNEQcst;</implementation>
  </instantiation>
  <instantiation>
    <signature>(a:bat[:any\$1,:bit],b:bat[:any\$1,:bit],c:bat[:any\$1,:bit]):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpaccumNEQ;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:bit],c:bat[:any\$1,:bit]):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpNEQ;</implementation>
  </instantiation>
  </command>
  <command  name="\%">
    <comment>Binary BAT calculator function 
	with accumulator BAT result</comment>
  <instantiation>
    <signature>(a:bat[:any\$1,:any\$2],b:bat[:any\$1,:any\$2],c:bat[:any\$1,:any\$2]):bat[:any\$1,:any\$2] </signature>
    <implementation> CMDbataccumMOD;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:any\$2],c:bat[:any\$1,:any\$2]):bat[:any\$1,:any\$2] </signature>
    <implementation> CMDbatMOD;</implementation>
  </instantiation>
  <instantiation>
    <signature>(a:bat[:any\$1,:any\$2],b:bat[:any\$1,:any\$2],cst:any\$2):bat[:any\$1,:any\$2] </signature>
    <implementation> CMDbataccumMODcst;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:any\$2],cst:any\$2):bat[:any\$1,:any\$2] </signature>
    <implementation> CMDbatMODcst;</implementation>
  </instantiation>
  <instantiation>
    <signature>(a:bat[:any\$1,:any\$2],b:bat[:any\$1,:any\$2],c:bat[:any\$1,:any\$2]):bat[:any\$1,:any\$2] </signature>
    <implementation> CMDbataccumMOD;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:any\$2],c:bat[:any\$1,:any\$2]):bat[:any\$1,:any\$2] </signature>
    <implementation> CMDbatMOD;</implementation>
  </instantiation>
  <instantiation>
    <signature>(a:bat[:any\$1,:any\$2],b:bat[:any\$1,:any\$2],cst:any\$2):bat[:any\$1,:any\$2] </signature>
    <implementation> CMDbataccumMODcst;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:any\$2],cst:any\$2):bat[:any\$1,:any\$2] </signature>
    <implementation> CMDbatMODcst;</implementation>
  </instantiation>
  <instantiation>
    <signature>(a:bat[:any\$1,:any\$2],b:bat[:any\$1,:any\$2],c:bat[:any\$1,:any\$2]):bat[:any\$1,:any\$2] </signature>
    <implementation> CMDbataccumMOD;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:any\$2],c:bat[:any\$1,:any\$2]):bat[:any\$1,:any\$2] </signature>
    <implementation> CMDbatMOD;</implementation>
  </instantiation>
  <instantiation>
    <signature>(a:bat[:any\$1,:any\$2],b:bat[:any\$1,:any\$2],cst:any\$2):bat[:any\$1,:any\$2] </signature>
    <implementation> CMDbataccumMODcst;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:any\$2],cst:any\$2):bat[:any\$1,:any\$2] </signature>
    <implementation> CMDbatMODcst;</implementation>
  </instantiation>
  <instantiation>
    <signature>(a:bat[:any\$1,:any\$2],b:bat[:any\$1,:any\$2],c:bat[:any\$1,:any\$2]):bat[:any\$1,:any\$2] </signature>
    <implementation> CMDbataccumMOD;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:any\$2],c:bat[:any\$1,:any\$2]):bat[:any\$1,:any\$2] </signature>
    <implementation> CMDbatMOD;</implementation>
  </instantiation>
  <instantiation>
    <signature>(a:bat[:any\$1,:any\$2],b:bat[:any\$1,:any\$2],cst:any\$2):bat[:any\$1,:any\$2] </signature>
    <implementation> CMDbataccumMODcst;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:any\$2],cst:any\$2):bat[:any\$1,:any\$2] </signature>
    <implementation> CMDbatMODcst;</implementation>
  </instantiation>
  </command>
  <command  name="*">
    <comment>Binary BAT calculator function 
	with accumulator BAT result</comment>
  <instantiation>
    <signature>(a:bat[:any\$1,:any\$2],b:bat[:any\$1,:any\$2],c:bat[:any\$1,:any\$2]):bat[:any\$1,:any\$2] </signature>
    <implementation> CMDbataccumMUL;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:any\$2],c:bat[:any\$1,:any\$2]):bat[:any\$1,:any\$2] </signature>
    <implementation> CMDbatMUL;</implementation>
  </instantiation>
  <instantiation>
    <signature>(a:bat[:any\$1,:any\$2],b:bat[:any\$1,:any\$2],cst:any\$2):bat[:any\$1,:any\$2] </signature>
    <implementation> CMDbataccumMULcst;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:any\$2],cst:any\$2):bat[:any\$1,:any\$2] </signature>
    <implementation> CMDbatMULcst;</implementation>
  </instantiation>
  </command>
  <command  name="++">
    <comment>Unary minus over the tail of the bat</comment>
  <instantiation>
    <signature>(b:bat[:any\$1,:dbl]):bat[:any\$1,:dbl] </signature>
    <implementation> CMDunaryPLUSPLUS;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:flt]):bat[:any\$1,:flt] </signature>
    <implementation> CMDunaryPLUSPLUS;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:sht]):bat[:any\$1,:sht] </signature>
    <implementation> CMDunaryPLUSPLUS;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:lng]):bat[:any\$1,:lng] </signature>
    <implementation> CMDunaryPLUSPLUS;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:int]):bat[:any\$1,:int] </signature>
    <implementation> CMDunaryPLUSPLUS;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:oid]):bat[:any\$1,:oid] </signature>
    <implementation> CMDunaryPLUSPLUS;</implementation>
  </instantiation>
  </command>
  <command  name="+">
    <comment>Binary BAT calculator function 
	with accumulator BAT result</comment>
  <instantiation>
    <signature>(a:bat[:any\$1,:any\$2],b:bat[:any\$1,:any\$2],c:bat[:any\$1,:any\$2]):bat[:any\$1,:any\$2] </signature>
    <implementation> CMDbataccumADD;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:any\$2],c:bat[:any\$1,:any\$2]):bat[:any\$1,:any\$2] </signature>
    <implementation> CMDbatADD;</implementation>
  </instantiation>
  <instantiation>
    <signature>(a:bat[:any\$1,:any\$2],b:bat[:any\$1,:any\$2],cst:any\$2):bat[:any\$1,:any\$2] </signature>
    <implementation> CMDbataccumADDcst;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:any\$2],cst:any\$2):bat[:any\$1,:any\$2] </signature>
    <implementation> CMDbatADDcst;</implementation>
  </instantiation>
  </command>
  <command  name="--">
    <comment>Unary minus over the tail of the bat</comment>
  <instantiation>
    <signature>(b:bat[:any\$1,:dbl]):bat[:any\$1,:dbl] </signature>
    <implementation> CMDunaryMINMIN;</implementation>
  </instantiation>
  </command>
  <command  name="-">
    <comment>Unary minus over the tail of the bat</comment>
  <instantiation>
    <signature>(b:bat[:any\$1,:dbl]):bat[:any\$1,:dbl] </signature>
    <implementation> CMDunaryMIN;</implementation>
  </instantiation>
  </command>
  <command  name="--">
    <comment>Unary minus over the tail of the bat</comment>
  <instantiation>
    <signature>(b:bat[:any\$1,:flt]):bat[:any\$1,:flt] </signature>
    <implementation> CMDunaryMINMIN;</implementation>
  </instantiation>
  </command>
  <command  name="-">
    <comment>Unary minus over the tail of the bat</comment>
  <instantiation>
    <signature>(b:bat[:any\$1,:flt]):bat[:any\$1,:flt] </signature>
    <implementation> CMDunaryMIN;</implementation>
  </instantiation>
  </command>
  <command  name="--">
    <comment>Unary minus over the tail of the bat</comment>
  <instantiation>
    <signature>(b:bat[:any\$1,:sht]):bat[:any\$1,:sht] </signature>
    <implementation> CMDunaryMINMIN;</implementation>
  </instantiation>
  </command>
  <command  name="-">
    <comment>Unary minus over the tail of the bat</comment>
  <instantiation>
    <signature>(b:bat[:any\$1,:sht]):bat[:any\$1,:sht] </signature>
    <implementation> CMDunaryMIN;</implementation>
  </instantiation>
  </command>
  <command  name="--">
    <comment>Unary minus over the tail of the bat</comment>
  <instantiation>
    <signature>(b:bat[:any\$1,:lng]):bat[:any\$1,:lng] </signature>
    <implementation> CMDunaryMINMIN;</implementation>
  </instantiation>
  </command>
  <command  name="-">
    <comment>Unary minus over the tail of the bat</comment>
  <instantiation>
    <signature>(b:bat[:any\$1,:lng]):bat[:any\$1,:lng] </signature>
    <implementation> CMDunaryMIN;</implementation>
  </instantiation>
  </command>
  <command  name="--">
    <comment>Unary minus over the tail of the bat</comment>
  <instantiation>
    <signature>(b:bat[:any\$1,:int]):bat[:any\$1,:int] </signature>
    <implementation> CMDunaryMINMIN;</implementation>
  </instantiation>
  </command>
  <command  name="-">
    <comment>Unary minus over the tail of the bat</comment>
  <instantiation>
    <signature>(b:bat[:any\$1,:int]):bat[:any\$1,:int] </signature>
    <implementation> CMDunaryMIN;</implementation>
  </instantiation>
  </command>
  <command  name="--">
    <comment>Unary minus over the tail of the bat</comment>
  <instantiation>
    <signature>(b:bat[:any\$1,:oid]):bat[:any\$1,:oid] </signature>
    <implementation> CMDunaryMINMIN;</implementation>
  </instantiation>
  </command>
  <command  name="-">
    <comment>Unary minus over the tail of the bat</comment>
  <instantiation>
    <signature>(b:bat[:any\$1,:oid]):bat[:any\$1,:oid] </signature>
    <implementation> CMDunaryMIN;</implementation>
  </instantiation>
  <instantiation>
    <signature>(a:bat[:any\$1,:any\$2],b:bat[:any\$1,:any\$2],c:bat[:any\$1,:any\$2]):bat[:any\$1,:any\$2] </signature>
    <implementation> CMDbataccumMIN;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:any\$2],c:bat[:any\$1,:any\$2]):bat[:any\$1,:any\$2] </signature>
    <implementation> CMDbatMIN;</implementation>
  </instantiation>
  <instantiation>
    <signature>(a:bat[:any\$1,:any\$2],b:bat[:any\$1,:any\$2],cst:any\$2):bat[:any\$1,:any\$2] </signature>
    <implementation> CMDbataccumMINcst;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:any\$2],cst:any\$2):bat[:any\$1,:any\$2] </signature>
    <implementation> CMDbatMINcst;</implementation>
  </instantiation>
  </command>
  <command  name="/">
    <comment>Binary BAT calculator function 
	with accumulator BAT result</comment>
  <instantiation>
    <signature>(a:bat[:any\$1,:any\$2],b:bat[:any\$1,:any\$2],c:bat[:any\$1,:any\$2]):bat[:any\$1,:any\$2] </signature>
    <implementation> CMDbataccumDIV;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:any\$2],c:bat[:any\$1,:any\$2]):bat[:any\$1,:any\$2] </signature>
    <implementation> CMDbatDIV;</implementation>
  </instantiation>
  <instantiation>
    <signature>(a:bat[:any\$1,:any\$2],b:bat[:any\$1,:any\$2],cst:any\$2):bat[:any\$1,:any\$2] </signature>
    <implementation> CMDbataccumDIVcst;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:any\$2],cst:any\$2):bat[:any\$1,:any\$2] </signature>
    <implementation> CMDbatDIVcst;</implementation>
  </instantiation>
  </command>
  <command  name="$&lt;$=">
  <instantiation>
    <signature>(a:bat[:any\$1,:bit],b:bat[:any\$1,:lng],cst:lng):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpaccumLEcst;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:lng],cst:lng):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpLEcst;</implementation>
  </instantiation>
  <instantiation>
    <signature>(a:bat[:any\$1,:bit],b:bat[:any\$1,:lng],c:bat[:any\$1,:lng]):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpaccumLE;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:lng],c:bat[:any\$1,:lng]):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpLE;</implementation>
  </instantiation>
  </command>
  <command  name="$&lt;$">
  <instantiation>
    <signature>(a:bat[:any\$1,:bit],b:bat[:any\$1,:lng],cst:lng):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpaccumLTcst;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:lng],cst:lng):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpLTcst;</implementation>
  </instantiation>
  <instantiation>
    <signature>(a:bat[:any\$1,:bit],b:bat[:any\$1,:lng],c:bat[:any\$1,:lng]):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpaccumLT;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:lng],c:bat[:any\$1,:lng]):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpLT;</implementation>
  </instantiation>
  </command>
  <command  name="$&lt;$=">
  <instantiation>
    <signature>(a:bat[:any\$1,:bit],b:bat[:any\$1,:int],cst:int):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpaccumLEcst;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:int],cst:int):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpLEcst;</implementation>
  </instantiation>
  <instantiation>
    <signature>(a:bat[:any\$1,:bit],b:bat[:any\$1,:int],c:bat[:any\$1,:int]):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpaccumLE;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:int],c:bat[:any\$1,:int]):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpLE;</implementation>
  </instantiation>
  </command>
  <command  name="$&lt;$">
  <instantiation>
    <signature>(a:bat[:any\$1,:bit],b:bat[:any\$1,:int],cst:int):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpaccumLTcst;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:int],cst:int):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpLTcst;</implementation>
  </instantiation>
  <instantiation>
    <signature>(a:bat[:any\$1,:bit],b:bat[:any\$1,:int],c:bat[:any\$1,:int]):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpaccumLT;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:int],c:bat[:any\$1,:int]):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpLT;</implementation>
  </instantiation>
  </command>
  <command  name="$&lt;$=">
  <instantiation>
    <signature>(a:bat[:any\$1,:bit],b:bat[:any\$1,:sht],cst:sht):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpaccumLEcst;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:sht],cst:sht):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpLEcst;</implementation>
  </instantiation>
  <instantiation>
    <signature>(a:bat[:any\$1,:bit],b:bat[:any\$1,:sht],c:bat[:any\$1,:sht]):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpaccumLE;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:sht],c:bat[:any\$1,:sht]):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpLE;</implementation>
  </instantiation>
  </command>
  <command  name="$&lt;$">
  <instantiation>
    <signature>(a:bat[:any\$1,:bit],b:bat[:any\$1,:sht],cst:sht):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpaccumLTcst;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:sht],cst:sht):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpLTcst;</implementation>
  </instantiation>
  <instantiation>
    <signature>(a:bat[:any\$1,:bit],b:bat[:any\$1,:sht],c:bat[:any\$1,:sht]):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpaccumLT;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:sht],c:bat[:any\$1,:sht]):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpLT;</implementation>
  </instantiation>
  </command>
  <command  name="$&lt;$=">
  <instantiation>
    <signature>(a:bat[:any\$1,:bit],b:bat[:any\$1,:oid],cst:oid):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpaccumLEcst;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:oid],cst:oid):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpLEcst;</implementation>
  </instantiation>
  <instantiation>
    <signature>(a:bat[:any\$1,:bit],b:bat[:any\$1,:oid],c:bat[:any\$1,:oid]):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpaccumLE;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:oid],c:bat[:any\$1,:oid]):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpLE;</implementation>
  </instantiation>
  </command>
  <command  name="$&lt;$">
  <instantiation>
    <signature>(a:bat[:any\$1,:bit],b:bat[:any\$1,:oid],cst:oid):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpaccumLTcst;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:oid],cst:oid):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpLTcst;</implementation>
  </instantiation>
  <instantiation>
    <signature>(a:bat[:any\$1,:bit],b:bat[:any\$1,:oid],c:bat[:any\$1,:oid]):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpaccumLT;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:oid],c:bat[:any\$1,:oid]):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpLT;</implementation>
  </instantiation>
  </command>
  <command  name="$&lt;$=">
  <instantiation>
    <signature>(a:bat[:any\$1,:bit],b:bat[:any\$1,:flt],cst:flt):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpaccumLEcst;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:flt],cst:flt):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpLEcst;</implementation>
  </instantiation>
  <instantiation>
    <signature>(a:bat[:any\$1,:bit],b:bat[:any\$1,:flt],c:bat[:any\$1,:flt]):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpaccumLE;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:flt],c:bat[:any\$1,:flt]):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpLE;</implementation>
  </instantiation>
  </command>
  <command  name="$&lt;$">
  <instantiation>
    <signature>(a:bat[:any\$1,:bit],b:bat[:any\$1,:flt],cst:flt):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpaccumLTcst;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:flt],cst:flt):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpLTcst;</implementation>
  </instantiation>
  <instantiation>
    <signature>(a:bat[:any\$1,:bit],b:bat[:any\$1,:flt],c:bat[:any\$1,:flt]):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpaccumLT;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:flt],c:bat[:any\$1,:flt]):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpLT;</implementation>
  </instantiation>
  </command>
  <command  name="$&lt;$=">
  <instantiation>
    <signature>(a:bat[:any\$1,:bit],b:bat[:any\$1,:dbl],cst:dbl):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpaccumLEcst;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:dbl],cst:dbl):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpLEcst;</implementation>
  </instantiation>
  <instantiation>
    <signature>(a:bat[:any\$1,:bit],b:bat[:any\$1,:dbl],c:bat[:any\$1,:dbl]):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpaccumLE;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:dbl],c:bat[:any\$1,:dbl]):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpLE;</implementation>
  </instantiation>
  </command>
  <command  name="$&lt;$">
  <instantiation>
    <signature>(a:bat[:any\$1,:bit],b:bat[:any\$1,:dbl],cst:dbl):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpaccumLTcst;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:dbl],cst:dbl):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpLTcst;</implementation>
  </instantiation>
  <instantiation>
    <signature>(a:bat[:any\$1,:bit],b:bat[:any\$1,:dbl],c:bat[:any\$1,:dbl]):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpaccumLT;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:dbl],c:bat[:any\$1,:dbl]):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpLT;</implementation>
  </instantiation>
  </command>
  <command  name="$&lt;$=">
  <instantiation>
    <signature>(a:bat[:any\$1,:bit],b:bat[:any\$1,:bit],cst:bit):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpaccumLEcst;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:bit],cst:bit):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpLEcst;</implementation>
  </instantiation>
  <instantiation>
    <signature>(a:bat[:any\$1,:bit],b:bat[:any\$1,:bit],c:bat[:any\$1,:bit]):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpaccumLE;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:bit],c:bat[:any\$1,:bit]):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpLE;</implementation>
  </instantiation>
  </command>
  <command  name="$&lt;$">
  <instantiation>
    <signature>(a:bat[:any\$1,:bit],b:bat[:any\$1,:bit],cst:bit):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpaccumLTcst;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:bit],cst:bit):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpLTcst;</implementation>
  </instantiation>
  <instantiation>
    <signature>(a:bat[:any\$1,:bit],b:bat[:any\$1,:bit],c:bat[:any\$1,:bit]):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpaccumLT;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:bit],c:bat[:any\$1,:bit]):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpLT;</implementation>
  </instantiation>
  </command>
  <command  name="==">
  <instantiation>
    <signature>(a:bat[:any\$1,:bit],b:bat[:any\$1,:lng],cst:lng):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpaccumEQcst;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:lng],cst:lng):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpEQcst;</implementation>
  </instantiation>
  <instantiation>
    <signature>(a:bat[:any\$1,:bit],b:bat[:any\$1,:lng],c:bat[:any\$1,:lng]):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpaccumEQ;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:lng],c:bat[:any\$1,:lng]):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpEQ;</implementation>
  </instantiation>
  <instantiation>
    <signature>(a:bat[:any\$1,:bit],b:bat[:any\$1,:int],cst:int):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpaccumEQcst;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:int],cst:int):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpEQcst;</implementation>
  </instantiation>
  <instantiation>
    <signature>(a:bat[:any\$1,:bit],b:bat[:any\$1,:int],c:bat[:any\$1,:int]):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpaccumEQ;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:int],c:bat[:any\$1,:int]):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpEQ;</implementation>
  </instantiation>
  <instantiation>
    <signature>(a:bat[:any\$1,:bit],b:bat[:any\$1,:sht],cst:sht):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpaccumEQcst;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:sht],cst:sht):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpEQcst;</implementation>
  </instantiation>
  <instantiation>
    <signature>(a:bat[:any\$1,:bit],b:bat[:any\$1,:sht],c:bat[:any\$1,:sht]):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpaccumEQ;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:sht],c:bat[:any\$1,:sht]):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpEQ;</implementation>
  </instantiation>
  <instantiation>
    <signature>(a:bat[:any\$1,:bit],b:bat[:any\$1,:oid],cst:oid):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpaccumEQcst;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:oid],cst:oid):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpEQcst;</implementation>
  </instantiation>
  <instantiation>
    <signature>(a:bat[:any\$1,:bit],b:bat[:any\$1,:oid],c:bat[:any\$1,:oid]):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpaccumEQ;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:oid],c:bat[:any\$1,:oid]):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpEQ;</implementation>
  </instantiation>
  <instantiation>
    <signature>(a:bat[:any\$1,:bit],b:bat[:any\$1,:flt],cst:flt):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpaccumEQcst;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:flt],cst:flt):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpEQcst;</implementation>
  </instantiation>
  <instantiation>
    <signature>(a:bat[:any\$1,:bit],b:bat[:any\$1,:flt],c:bat[:any\$1,:flt]):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpaccumEQ;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:flt],c:bat[:any\$1,:flt]):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpEQ;</implementation>
  </instantiation>
  <instantiation>
    <signature>(a:bat[:any\$1,:bit],b:bat[:any\$1,:dbl],cst:dbl):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpaccumEQcst;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:dbl],cst:dbl):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpEQcst;</implementation>
  </instantiation>
  <instantiation>
    <signature>(a:bat[:any\$1,:bit],b:bat[:any\$1,:dbl],c:bat[:any\$1,:dbl]):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpaccumEQ;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:dbl],c:bat[:any\$1,:dbl]):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpEQ;</implementation>
  </instantiation>
  <instantiation>
    <signature>(a:bat[:any\$1,:bit],b:bat[:any\$1,:bit],cst:bit):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpaccumEQcst;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:bit],cst:bit):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpEQcst;</implementation>
  </instantiation>
  <instantiation>
    <signature>(a:bat[:any\$1,:bit],b:bat[:any\$1,:bit],c:bat[:any\$1,:bit]):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpaccumEQ;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:bit],c:bat[:any\$1,:bit]):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpEQ;</implementation>
  </instantiation>
  </command>
  <command  name="$&gt;$=">
  <instantiation>
    <signature>(a:bat[:any\$1,:bit],b:bat[:any\$1,:lng],cst:lng):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpaccumGEcst;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:lng],cst:lng):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpGEcst;</implementation>
  </instantiation>
  <instantiation>
    <signature>(a:bat[:any\$1,:bit],b:bat[:any\$1,:lng],c:bat[:any\$1,:lng]):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpaccumGE;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:lng],c:bat[:any\$1,:lng]):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpGE;</implementation>
  </instantiation>
  </command>
  <command  name="$&gt;$">
  <instantiation>
    <signature>(a:bat[:any\$1,:bit],b:bat[:any\$1,:lng],cst:lng):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpaccumGTcst;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:lng],cst:lng):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpGTcst;</implementation>
  </instantiation>
  <instantiation>
    <signature>(a:bat[:any\$1,:bit],b:bat[:any\$1,:lng],c:bat[:any\$1,:lng]):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpaccumGT;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:lng],c:bat[:any\$1,:lng]):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpGT;</implementation>
  </instantiation>
  </command>
  <command  name="$&gt;$=">
  <instantiation>
    <signature>(a:bat[:any\$1,:bit],b:bat[:any\$1,:int],cst:int):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpaccumGEcst;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:int],cst:int):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpGEcst;</implementation>
  </instantiation>
  <instantiation>
    <signature>(a:bat[:any\$1,:bit],b:bat[:any\$1,:int],c:bat[:any\$1,:int]):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpaccumGE;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:int],c:bat[:any\$1,:int]):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpGE;</implementation>
  </instantiation>
  </command>
  <command  name="$&gt;$">
  <instantiation>
    <signature>(a:bat[:any\$1,:bit],b:bat[:any\$1,:int],cst:int):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpaccumGTcst;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:int],cst:int):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpGTcst;</implementation>
  </instantiation>
  <instantiation>
    <signature>(a:bat[:any\$1,:bit],b:bat[:any\$1,:int],c:bat[:any\$1,:int]):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpaccumGT;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:int],c:bat[:any\$1,:int]):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpGT;</implementation>
  </instantiation>
  </command>
  <command  name="$&gt;$=">
  <instantiation>
    <signature>(a:bat[:any\$1,:bit],b:bat[:any\$1,:sht],cst:sht):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpaccumGEcst;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:sht],cst:sht):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpGEcst;</implementation>
  </instantiation>
  <instantiation>
    <signature>(a:bat[:any\$1,:bit],b:bat[:any\$1,:sht],c:bat[:any\$1,:sht]):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpaccumGE;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:sht],c:bat[:any\$1,:sht]):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpGE;</implementation>
  </instantiation>
  </command>
  <command  name="$&gt;$">
  <instantiation>
    <signature>(a:bat[:any\$1,:bit],b:bat[:any\$1,:sht],cst:sht):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpaccumGTcst;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:sht],cst:sht):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpGTcst;</implementation>
  </instantiation>
  <instantiation>
    <signature>(a:bat[:any\$1,:bit],b:bat[:any\$1,:sht],c:bat[:any\$1,:sht]):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpaccumGT;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:sht],c:bat[:any\$1,:sht]):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpGT;</implementation>
  </instantiation>
  </command>
  <command  name="$&gt;$=">
  <instantiation>
    <signature>(a:bat[:any\$1,:bit],b:bat[:any\$1,:oid],cst:oid):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpaccumGEcst;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:oid],cst:oid):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpGEcst;</implementation>
  </instantiation>
  <instantiation>
    <signature>(a:bat[:any\$1,:bit],b:bat[:any\$1,:oid],c:bat[:any\$1,:oid]):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpaccumGE;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:oid],c:bat[:any\$1,:oid]):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpGE;</implementation>
  </instantiation>
  </command>
  <command  name="$&gt;$">
  <instantiation>
    <signature>(a:bat[:any\$1,:bit],b:bat[:any\$1,:oid],cst:oid):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpaccumGTcst;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:oid],cst:oid):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpGTcst;</implementation>
  </instantiation>
  <instantiation>
    <signature>(a:bat[:any\$1,:bit],b:bat[:any\$1,:oid],c:bat[:any\$1,:oid]):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpaccumGT;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:oid],c:bat[:any\$1,:oid]):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpGT;</implementation>
  </instantiation>
  </command>
  <command  name="$&gt;$=">
  <instantiation>
    <signature>(a:bat[:any\$1,:bit],b:bat[:any\$1,:flt],cst:flt):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpaccumGEcst;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:flt],cst:flt):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpGEcst;</implementation>
  </instantiation>
  <instantiation>
    <signature>(a:bat[:any\$1,:bit],b:bat[:any\$1,:flt],c:bat[:any\$1,:flt]):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpaccumGE;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:flt],c:bat[:any\$1,:flt]):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpGE;</implementation>
  </instantiation>
  </command>
  <command  name="$&gt;$">
  <instantiation>
    <signature>(a:bat[:any\$1,:bit],b:bat[:any\$1,:flt],cst:flt):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpaccumGTcst;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:flt],cst:flt):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpGTcst;</implementation>
  </instantiation>
  <instantiation>
    <signature>(a:bat[:any\$1,:bit],b:bat[:any\$1,:flt],c:bat[:any\$1,:flt]):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpaccumGT;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:flt],c:bat[:any\$1,:flt]):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpGT;</implementation>
  </instantiation>
  </command>
  <command  name="$&gt;$=">
  <instantiation>
    <signature>(a:bat[:any\$1,:bit],b:bat[:any\$1,:dbl],cst:dbl):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpaccumGEcst;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:dbl],cst:dbl):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpGEcst;</implementation>
  </instantiation>
  <instantiation>
    <signature>(a:bat[:any\$1,:bit],b:bat[:any\$1,:dbl],c:bat[:any\$1,:dbl]):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpaccumGE;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:dbl],c:bat[:any\$1,:dbl]):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpGE;</implementation>
  </instantiation>
  </command>
  <command  name="$&gt;$">
  <instantiation>
    <signature>(a:bat[:any\$1,:bit],b:bat[:any\$1,:dbl],cst:dbl):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpaccumGTcst;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:dbl],cst:dbl):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpGTcst;</implementation>
  </instantiation>
  <instantiation>
    <signature>(a:bat[:any\$1,:bit],b:bat[:any\$1,:dbl],c:bat[:any\$1,:dbl]):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpaccumGT;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:dbl],c:bat[:any\$1,:dbl]):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpGT;</implementation>
  </instantiation>
  </command>
  <command  name="$&gt;$=">
  <instantiation>
    <signature>(a:bat[:any\$1,:bit],b:bat[:any\$1,:bit],cst:bit):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpaccumGEcst;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:bit],cst:bit):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpGEcst;</implementation>
  </instantiation>
  <instantiation>
    <signature>(a:bat[:any\$1,:bit],b:bat[:any\$1,:bit],c:bat[:any\$1,:bit]):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpaccumGE;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:bit],c:bat[:any\$1,:bit]):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpGE;</implementation>
  </instantiation>
  </command>
  <command  name="$&gt;$">
  <instantiation>
    <signature>(a:bat[:any\$1,:bit],b:bat[:any\$1,:bit],cst:bit):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpaccumGTcst;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:bit],cst:bit):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpGTcst;</implementation>
  </instantiation>
  <instantiation>
    <signature>(a:bat[:any\$1,:bit],b:bat[:any\$1,:bit],c:bat[:any\$1,:bit]):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpaccumGT;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:bit],c:bat[:any\$1,:bit]):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpGT;</implementation>
  </instantiation>
  </command>
  <command  name="atan2">
  <instantiation>
    <signature>(x:bat[:any\$1,:dbl],y:dbl):bat[:any\$1,:dbl] </signature>
    <implementation> CMDscience\_atan2;</implementation>
  </instantiation>
  </command>
  <command  name="atan">
  <instantiation>
    <signature>(x:bat[:any\$1,:dbl]):bat[:any\$1,:dbl] </signature>
    <implementation> CMDscience\_atan;</implementation>
  </instantiation>
  </command>
  <command  name="acos">
  <instantiation>
    <signature>(x:bat[:any\$1,:dbl]):bat[:any\$1,:dbl] </signature>
    <implementation> CMDscience\_acos;</implementation>
  </instantiation>
  </command>
  <command  name="asin">
  <instantiation>
    <signature>(x:bat[:any\$1,:dbl]):bat[:any\$1,:dbl] </signature>
    <implementation> CMDscience\_asin;</implementation>
  </instantiation>
  </command>
  <command  name="and">
  <instantiation>
    <signature>(a:bat[:any\$1,:bit],b:bat[:any\$1,:bit],cst:bit):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpaccumANDcst;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:bit],cst:bit):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpANDcst;</implementation>
  </instantiation>
  <instantiation>
    <signature>(a:bat[:any\$1,:bit],b:bat[:any\$1,:bit],c:bat[:any\$1,:bit]):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpaccumAND;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:bit],c:bat[:any\$1,:bit]):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpAND;</implementation>
  </instantiation>
  </command>
  <command  name="ceil">
  <instantiation>
    <signature>(x:bat[:any\$1,:dbl]):bat[:any\$1,:dbl] </signature>
    <implementation> CMDscience\_ceil;</implementation>
  </instantiation>
  </command>
  <command  name="cosh">
  <instantiation>
    <signature>(x:bat[:any\$1,:dbl]):bat[:any\$1,:dbl] </signature>
    <implementation> CMDscience\_cosh;</implementation>
  </instantiation>
  </command>
  <command  name="cos">
  <instantiation>
    <signature>(x:bat[:any\$1,:dbl]):bat[:any\$1,:dbl] </signature>
    <implementation> CMDscience\_cos;</implementation>
  </instantiation>
  </command>
  <command  name="dbl">
    <comment>Coerce an dbl tail to a bat with dbl tail.</comment>
  <instantiation>
    <signature>(b:bat[:any\$1,:dbl]):bat[:any\$1,:dbl] </signature>
    <implementation> CMDconvertdbl\_dbl;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:flt]):bat[:any\$1,:dbl] </signature>
    <implementation> CMDconvertflt\_dbl;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:lng]):bat[:any\$1,:dbl] </signature>
    <implementation> CMDconvertlng\_dbl;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:int]):bat[:any\$1,:dbl] </signature>
    <implementation> CMDconvertint\_dbl;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:sht]):bat[:any\$1,:dbl] </signature>
    <implementation> CMDconvertsht\_dbl;</implementation>
  </instantiation>
  </command>
  <command  name="exp">
  <instantiation>
    <signature>(x:bat[:any\$1,:dbl]):bat[:any\$1,:dbl] </signature>
    <implementation> CMDscience\_exp;</implementation>
  </instantiation>
  </command>
  <command  name="fmod">
  <instantiation>
    <signature>(x:bat[:any\$1,:dbl],y:dbl):bat[:any\$1,:dbl] </signature>
    <implementation> CMDscience\_fmod;</implementation>
  </instantiation>
  </command>
  <command  name="floor">
  <instantiation>
    <signature>(x:bat[:any\$1,:dbl]):bat[:any\$1,:dbl] </signature>
    <implementation> CMDscience\_floor;</implementation>
  </instantiation>
  </command>
  <command  name="fabs">
  <instantiation>
    <signature>(x:bat[:any\$1,:dbl]):bat[:any\$1,:dbl] </signature>
    <implementation> CMDscience\_fabs;</implementation>
  </instantiation>
  </command>
  <command  name="flt">
    <comment>Coerce an dbl tail to a bat with flt tail.</comment>
  <instantiation>
    <signature>(b:bat[:any\$1,:dbl]):bat[:any\$1,:flt] </signature>
    <implementation> CMDconvertdbl\_flt;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:flt]):bat[:any\$1,:flt] </signature>
    <implementation> CMDconvertflt\_flt;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:lng]):bat[:any\$1,:flt] </signature>
    <implementation> CMDconvertlng\_flt;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:int]):bat[:any\$1,:flt] </signature>
    <implementation> CMDconvertint\_flt;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:sht]):bat[:any\$1,:flt] </signature>
    <implementation> CMDconvertsht\_flt;</implementation>
  </instantiation>
  </command>
  <command  name="int">
    <comment>Coerce an str tail to a bat with a int tail.</comment>
  <instantiation>
    <signature>(b:bat[:any\$1,:str]):bat[:any\$1,:int] </signature>
    <implementation> CMDconvertstr\_int;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:dbl]):bat[:any\$1,:int] </signature>
    <implementation> CMDconvertdbl\_int;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:flt]):bat[:any\$1,:int] </signature>
    <implementation> CMDconvertflt\_int;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:lng]):bat[:any\$1,:int] </signature>
    <implementation> CMDconvertlng\_int;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:int]):bat[:any\$1,:int] </signature>
    <implementation> CMDconvertint\_int;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:sht]):bat[:any\$1,:int] </signature>
    <implementation> CMDconvertsht\_int;</implementation>
  </instantiation>
  </command>
  <command  name="ifthenelse">
    <comment>Ifthen operation to assemble a conditional 
	result </comment>
  <instantiation>
    <signature>(b:bat[:any\$1,:bit],v:dbl,w:dbl):bat[:any\$1,:dbl] </signature>
    <implementation> CMDifThenElseCst\_dbl;</implementation>
  </instantiation>
  </command>
  <command  name="ifthen">
    <comment>Ifthen operation to assemble a 
	conditional result </comment>
  <instantiation>
    <signature>(b:bat[:any\$1,:bit],v:dbl):bat[:any\$1,:dbl] </signature>
    <implementation> CMDifThenCst\_dbl;</implementation>
  </instantiation>
  </command>
  <command  name="ifthenelse">
    <comment>Ifthen operation to assemble a conditional 
	result </comment>
  <instantiation>
    <signature>(b:bat[:any\$1,:bit],v:flt,w:flt):bat[:any\$1,:flt] </signature>
    <implementation> CMDifThenElseCst\_flt;</implementation>
  </instantiation>
  </command>
  <command  name="ifthen">
    <comment>Ifthen operation to assemble a 
	conditional result </comment>
  <instantiation>
    <signature>(b:bat[:any\$1,:bit],v:flt):bat[:any\$1,:flt] </signature>
    <implementation> CMDifThenCst\_flt;</implementation>
  </instantiation>
  </command>
  <command  name="ifthenelse">
    <comment>Ifthen operation to assemble a conditional 
	result </comment>
  <instantiation>
    <signature>(b:bat[:any\$1,:bit],v:lng,w:lng):bat[:any\$1,:lng] </signature>
    <implementation> CMDifThenElseCst\_lng;</implementation>
  </instantiation>
  </command>
  <command  name="ifthen">
    <comment>Ifthen operation to assemble a 
	conditional result </comment>
  <instantiation>
    <signature>(b:bat[:any\$1,:bit],v:lng):bat[:any\$1,:lng] </signature>
    <implementation> CMDifThenCst\_lng;</implementation>
  </instantiation>
  </command>
  <command  name="ifthenelse">
    <comment>Ifthen operation to assemble a conditional 
	result </comment>
  <instantiation>
    <signature>(b:bat[:any\$1,:bit],v:sht,w:sht):bat[:any\$1,:sht] </signature>
    <implementation> CMDifThenElseCst\_sht;</implementation>
  </instantiation>
  </command>
  <command  name="ifthen">
    <comment>Ifthen operation to assemble a 
	conditional result </comment>
  <instantiation>
    <signature>(b:bat[:any\$1,:bit],v:sht):bat[:any\$1,:sht] </signature>
    <implementation> CMDifThenCst\_sht;</implementation>
  </instantiation>
  </command>
  <command  name="ifthenelse">
    <comment>Ifthen operation to assemble a conditional 
	result </comment>
  <instantiation>
    <signature>(b:bat[:any\$1,:bit],v:int,w:int):bat[:any\$1,:int] </signature>
    <implementation> CMDifThenElseCst\_int;</implementation>
  </instantiation>
  </command>
  <command  name="ifthen">
    <comment>Ifthen operation to assemble a 
	conditional result </comment>
  <instantiation>
    <signature>(b:bat[:any\$1,:bit],v:int):bat[:any\$1,:int] </signature>
    <implementation> CMDifThenCst\_int;</implementation>
  </instantiation>
  </command>
  <command  name="ifthenelse">
    <comment>Ifthen operation to assemble a conditional 
	result </comment>
  <instantiation>
    <signature>(b:bat[:any\$1,:bit],v:oid,w:oid):bat[:any\$1,:oid] </signature>
    <implementation> CMDifThenElseCst\_oid;</implementation>
  </instantiation>
  </command>
  <command  name="ifthen">
    <comment>Ifthen operation to assemble a 
	conditional result </comment>
  <instantiation>
    <signature>(b:bat[:any\$1,:bit],v:oid):bat[:any\$1,:oid] </signature>
    <implementation> CMDifThenCst\_oid;</implementation>
  </instantiation>
  </command>
  <command  name="ifthenelse">
    <comment>Ifthen operation to assemble a conditional 
	result </comment>
  <instantiation>
    <signature>(b:bat[:any\$1,:bit],v:str,w:str):bat[:any\$1,:str] </signature>
    <implementation> CMDifThenElseCst\_str;</implementation>
  </instantiation>
  </command>
  <command  name="ifthen">
    <comment>Ifthen operation to assemble a 
	conditional result </comment>
  <instantiation>
    <signature>(b:bat[:any\$1,:bit],v:str):bat[:any\$1,:str] </signature>
    <implementation> CMDifThenCst\_str;</implementation>
  </instantiation>
  </command>
  <command  name="ifthenelse">
    <comment>Ifthen operation to assemble a conditional 
	result </comment>
  <instantiation>
    <signature>(b:bat[:any\$1,:bit],v:chr,w:chr):bat[:any\$1,:chr] </signature>
    <implementation> CMDifThenElseCst\_chr;</implementation>
  </instantiation>
  </command>
  <command  name="ifthen">
    <comment>Ifthen operation to assemble a 
	conditional result </comment>
  <instantiation>
    <signature>(b:bat[:any\$1,:bit],v:chr):bat[:any\$1,:chr] </signature>
    <implementation> CMDifThenCst\_chr;</implementation>
  </instantiation>
  </command>
  <command  name="ifthenelse">
    <comment>Ifthen operation to assemble a conditional 
	result </comment>
  <instantiation>
    <signature>(b:bat[:any\$1,:bit],v:bit,w:bit):bat[:any\$1,:bit] </signature>
    <implementation> CMDifThenElseCst\_bit;</implementation>
  </instantiation>
  </command>
  <command  name="ifthen">
    <comment>Ifthen operation to assemble a 
	conditional result </comment>
  <instantiation>
    <signature>(b:bat[:any\$1,:bit],v:bit):bat[:any\$1,:bit] </signature>
    <implementation> CMDifThenCst\_bit;</implementation>
  </instantiation>
  </command>
  <command  name="ifthenelse">
    <comment>If-then-else operation to assemble 
	a conditional result </comment>
  <instantiation>
    <signature>(b:bat[:any,:bit],t:bat[:any\$1,:any\$2],e:bat[:any\$1,:any\$2]):bat[:any\$1,:any\$2] </signature>
    <implementation> CMDifThenElse;</implementation>
  </instantiation>
  </command>
  <command  name="ifthen">
    <comment>Ifthen operation to assemble a 
	conditional result </comment>
  <instantiation>
    <signature>(b:bat[:any\$1,:bit],t:bat[:any\$1,:any\$2]):bat[:any\$1,:any\$2] </signature>
    <implementation> CMDifThen;</implementation>
  </instantiation>
  </command>
  <command  name="ifthenelse">
    <comment>If-then-else operation to assemble a 
	conditional result </comment>
  <instantiation>
    <signature>(b:bat[:any\$1,:bit],t:bat[:any\$1,:any\$2],e:any\$2):bat[:any\$1,:any\$2] </signature>
    <implementation> CMDifThenElseCst2;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:bit],e:any\$2,t:bat[:any\$1,:any\$2]):bat[:any\$1,:any\$2] </signature>
    <implementation> CMDifThenElseCst1;</implementation>
  </instantiation>
  </command>
  <command  name="log10">
  <instantiation>
    <signature>(x:bat[:any\$1,:dbl]):bat[:any\$1,:dbl] </signature>
    <implementation> CMDscience\_log10;</implementation>
  </instantiation>
  </command>
  <command  name="log">
  <instantiation>
    <signature>(x:bat[:any\$1,:dbl]):bat[:any\$1,:dbl] </signature>
    <implementation> CMDscience\_log;</implementation>
  </instantiation>
  </command>
  <command  name="lng">
    <comment>Coerce an dbl tail to a bat with lng tail.</comment>
  <instantiation>
    <signature>(b:bat[:any\$1,:dbl]):bat[:any\$1,:lng] </signature>
    <implementation> CMDconvertdbl\_lng;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:flt]):bat[:any\$1,:lng] </signature>
    <implementation> CMDconvertflt\_lng;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:lng]):bat[:any\$1,:lng] </signature>
    <implementation> CMDconvertlng\_lng;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:int]):bat[:any\$1,:lng] </signature>
    <implementation> CMDconvertint\_lng;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:sht]):bat[:any\$1,:lng] </signature>
    <implementation> CMDconvertsht\_lng;</implementation>
  </instantiation>
  </command>
  <command  name="match">
    <comment>POSIX pattern matching against a string BAT</comment>
  <instantiation>
    <signature>(b:bat[:any\$1,:str],pat:str):bat[:any\$1,:bit] </signature>
    <implementation> CMDmatchStr;</implementation>
  </instantiation>
  </command>
  <command  name="not">
    <comment>Return a BAT with the negated tail</comment>
  <instantiation>
    <signature>(a:bat[:any\$1,:bit],b:bat[:any\$1,:bit]):bat[:any\$1,:bit] </signature>
    <implementation> CMDbitbataccumNOT;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:bit]):bat[:any\$1,:bit] </signature>
    <implementation> CMDbitbatNOT;</implementation>
  </instantiation>
  </command>
  <command  name="oid">
    <comment>Materialize the virtual oid into an oid</comment>
  <instantiation>
    <signature>(b:bat[:oid,:any\$1]):bat[:oid,:any\$1] </signature>
    <implementation> CMDconvertoid\_oid;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:void,:any\$1]):bat[:oid,:any\$1] </signature>
    <implementation> CMDconvertvoid\_oid;</implementation>
  </instantiation>
  </command>
  <command  name="or">
  <instantiation>
    <signature>(a:bat[:any\$1,:bit],b:bat[:any\$1,:bit],cst:bit):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpaccumORcst;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:bit],cst:bit):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpORcst;</implementation>
  </instantiation>
  <instantiation>
    <signature>(a:bat[:any\$1,:bit],b:bat[:any\$1,:bit],c:bat[:any\$1,:bit]):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpaccumOR;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:bit],c:bat[:any\$1,:bit]):bat[:any\$1,:bit] </signature>
    <implementation> CMDcmpOR;</implementation>
  </instantiation>
  </command>
  <command  name="pow">
  <instantiation>
    <signature>(x:bat[:any\$1,:dbl],y:dbl):bat[:any\$1,:dbl] </signature>
    <implementation> CMDscience\_pow;</implementation>
  </instantiation>
  </command>
  <command  name="sqrt">
  <instantiation>
    <signature>(x:bat[:any\$1,:dbl]):bat[:any\$1,:dbl] </signature>
    <implementation> CMDscience\_sqrt;</implementation>
  </instantiation>
  </command>
  <command  name="sinh">
  <instantiation>
    <signature>(x:bat[:any\$1,:dbl]):bat[:any\$1,:dbl] </signature>
    <implementation> CMDscience\_sinh;</implementation>
  </instantiation>
  </command>
  <command  name="sin">
  <instantiation>
    <signature>(x:bat[:any\$1,:dbl]):bat[:any\$1,:dbl] </signature>
    <implementation> CMDscience\_sin;</implementation>
  </instantiation>
  </command>
  <command  name="sht">
    <comment>Coerce an dbl tail to a bat with sht tail.</comment>
  <instantiation>
    <signature>(b:bat[:any\$1,:dbl]):bat[:any\$1,:sht] </signature>
    <implementation> CMDconvertdbl\_sht;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:flt]):bat[:any\$1,:sht] </signature>
    <implementation> CMDconvertflt\_sht;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:lng]):bat[:any\$1,:sht] </signature>
    <implementation> CMDconvertlng\_sht;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:int]):bat[:any\$1,:sht] </signature>
    <implementation> CMDconvertint\_sht;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:sht]):bat[:any\$1,:sht] </signature>
    <implementation> CMDconvertsht\_sht;</implementation>
  </instantiation>
  </command>
  <command  name="tanh">
  <instantiation>
    <signature>(x:bat[:any\$1,:dbl]):bat[:any\$1,:dbl] </signature>
    <implementation> CMDscience\_tanh;</implementation>
  </instantiation>
  </command>
  <command  name="tan">
  <instantiation>
    <signature>(x:bat[:any\$1,:dbl]):bat[:any\$1,:dbl] </signature>
    <implementation> CMDscience\_tan;</implementation>
  </instantiation>
  </command>
  <command  name="zipper">
    <comment>Fill the tail with a constant, eg [b~0].</comment>
  <instantiation>
    <signature>(b:bat[:any\$1,:any],v:dbl):bat[:any\$1,:dbl] </signature>
    <implementation> CMDfilltail\_dbl;</implementation>
  </instantiation>
  <instantiation>
    <signature>(v:dbl,b:bat[:any,:any\$1]):bat[:dbl,:any\$1] </signature>
    <implementation> CMDfillhead\_dbl;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:any],v:flt):bat[:any\$1,:flt] </signature>
    <implementation> CMDfilltail\_flt;</implementation>
  </instantiation>
  <instantiation>
    <signature>(v:flt,b:bat[:any,:any\$1]):bat[:flt,:any\$1] </signature>
    <implementation> CMDfillhead\_flt;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:any],v:lng):bat[:any\$1,:lng] </signature>
    <implementation> CMDfilltail\_lng;</implementation>
  </instantiation>
  <instantiation>
    <signature>(v:lng,b:bat[:any,:any\$1]):bat[:lng,:any\$1] </signature>
    <implementation> CMDfillhead\_lng;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:any],v:sht):bat[:any\$1,:sht] </signature>
    <implementation> CMDfilltail\_sht;</implementation>
  </instantiation>
  <instantiation>
    <signature>(v:sht,b:bat[:any,:any\$1]):bat[:sht,:any\$1] </signature>
    <implementation> CMDfillhead\_sht;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:any],v:int):bat[:any\$1,:int] </signature>
    <implementation> CMDfilltail\_int;</implementation>
  </instantiation>
  <instantiation>
    <signature>(v:int,b:bat[:any,:any\$1]):bat[:int,:any\$1] </signature>
    <implementation> CMDfillhead\_int;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:any],v:oid):bat[:any\$1,:oid] </signature>
    <implementation> CMDfilltail\_oid;</implementation>
  </instantiation>
  <instantiation>
    <signature>(v:oid,b:bat[:any,:any\$1]):bat[:oid,:any\$1] </signature>
    <implementation> CMDfillhead\_oid;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:any],v:str):bat[:any\$1,:str] </signature>
    <implementation> CMDfilltail\_str;</implementation>
  </instantiation>
  <instantiation>
    <signature>(v:str,b:bat[:any,:any\$1]):bat[:str,:any\$1] </signature>
    <implementation> CMDfillhead\_str;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:any],v:chr):bat[:any\$1,:chr] </signature>
    <implementation> CMDfilltail\_chr;</implementation>
  </instantiation>
  <instantiation>
    <signature>(v:chr,b:bat[:any,:any\$1]):bat[:chr,:any\$1] </signature>
    <implementation> CMDfillhead\_chr;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:any],v:bit):bat[:any\$1,:bit] </signature>
    <implementation> CMDfilltail\_bit;</implementation>
  </instantiation>
  <instantiation>
    <signature>(v:bit,b:bat[:any,:any\$1]):bat[:bit,:any\$1] </signature>
    <implementation> CMDfillhead\_bit;</implementation>
  </instantiation>
  </command>
</module>
<module name="bbp">
  <command  name="bind">
    <comment>Locate the BAT using its BBP index</comment>
  <instantiation>
    <signature>(idx:int):bat[:any,:any] </signature>
    <implementation> CMDbbpbindindex;</implementation>
  </instantiation>
  <instantiation>
    <signature>(name:str):bat[:any,:any] </signature>
    <implementation> CMDbbpbind;</implementation>
  </instantiation>
  <instantiation>
    <signature>(name:str,loc:str):bat[:any,:any] </signature>
    <implementation> CMDbbpbindDefinition;</implementation>
  </instantiation>
  </command>
  <command  name="close">
    <comment>Close the bbp box.</comment>
  <instantiation>
    <signature>():void </signature>
    <implementation> CMDbbpclose;</implementation>
  </instantiation>
  </command>
  <pattern  name="discard">
    <comment>Remove the BAT from the box</comment>
  <instantiation>
    <signature>(name:str):void </signature>
    <implementation> CMDbbpdiscard;</implementation>
  </instantiation>
  </pattern>
  <pattern  name="destroy">
    <comment>Schedule a BAT for removal at
	session end or immediately</comment>
  <instantiation>
    <signature>(b:bat[:any,:any],immediate:bit):void </signature>
    <implementation> CMDbbpdestroyBAT;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any,:any]):void </signature>
    <implementation> CMDbbpdestroyBAT1;</implementation>
  </instantiation>
  </pattern>
  <pattern  name="deposit">
    <comment>Enter a new bat into the bbp box.</comment>
  <instantiation>
    <signature>(name:str,v:bat[:any,:any]):void </signature>
    <implementation> CMDbbpdeposit;</implementation>
  </instantiation>
  </pattern>
  <command  name="destroy">
    <comment>Destroy the box</comment>
  <instantiation>
    <signature>():void </signature>
    <implementation> CMDbbpdestroy;</implementation>
  </instantiation>
  </command>
  <command  name="getLRefCount">
    <comment>Utility for debugging MAL interpreter</comment>
  <instantiation>
    <signature>(b:bat[:any,:any]):int </signature>
    <implementation> CMDgetBATlrefcnt;</implementation>
  </instantiation>
  </command>
  <command  name="getRefCount">
    <comment>Utility for debugging MAL interpreter</comment>
  <instantiation>
    <signature>(b:bat[:any,:any]):int </signature>
    <implementation> CMDgetBATrefcnt;</implementation>
  </instantiation>
  </command>
  <command  name="getKind">
    <comment>Map a BAT into its persistency status</comment>
  <instantiation>
    <signature>():bat[:int,:str] </signature>
    <implementation> CMDbbpKind;</implementation>
  </instantiation>
  </command>
  <command  name="getStatus">
    <comment>Map a BAT into disk/load status</comment>
  <instantiation>
    <signature>():bat[:int,:str] </signature>
    <implementation> CMDbbpStatus;</implementation>
  </instantiation>
  </command>
  <command  name="getDirty">
    <comment>Map a BAT into its dirty/
	diffs/clean status</comment>
  <instantiation>
    <signature>():bat[:int,:str] </signature>
    <implementation> CMDbbpDirty;</implementation>
  </instantiation>
  </command>
  <command  name="getHeat">
    <comment>Map a BAT into its heat</comment>
  <instantiation>
    <signature>():bat[:int,:int] </signature>
    <implementation> CMDbbpHeat;</implementation>
  </instantiation>
  </command>
  <command  name="getLocation">
    <comment>Map a BAT into its disk location</comment>
  <instantiation>
    <signature>():bat[:int,:str] </signature>
    <implementation> CMDbbpLocation;</implementation>
  </instantiation>
  </command>
  <command  name="getLRefCount">
    <comment>Map a BAT into its logical reference count</comment>
  <instantiation>
    <signature>():bat[:int,:int] </signature>
    <implementation> CMDbbpLRefCount;</implementation>
  </instantiation>
  </command>
  <command  name="getRefCount">
    <comment>Map a BAT into its (hard) reference count</comment>
  <instantiation>
    <signature>():bat[:int,:int] </signature>
    <implementation> CMDbbpRefCount;</implementation>
  </instantiation>
  </command>
  <command  name="getCount">
    <comment>Map a BAT into its cardinality</comment>
  <instantiation>
    <signature>():bat[:int,:lng] </signature>
    <implementation> CMDbbpCount;</implementation>
  </instantiation>
  </command>
  <command  name="getName">
    <comment>Map a BAT into its internal name</comment>
  <instantiation>
    <signature>(b:bat[:any,:any]):str </signature>
    <implementation> CMDbbpName;</implementation>
  </instantiation>
  </command>
  <command  name="getRNames">
    <comment>Map a BAT into its bbp physical name</comment>
  <instantiation>
    <signature>():bat[:int,:str] </signature>
    <implementation> CMDbbpRNames;</implementation>
  </instantiation>
  </command>
  <command  name="getNames">
    <comment>Map BAT into its bbp name</comment>
  <instantiation>
    <signature>():bat[:int,:str] </signature>
    <implementation> CMDbbpNames;</implementation>
  </instantiation>
  </command>
  <command  name="getTailType">
    <comment>Map a BAT into its tail type</comment>
  <instantiation>
    <signature>():bat[:int,:str] </signature>
    <implementation> CMDbbpTailType;</implementation>
  </instantiation>
  </command>
  <command  name="getHeadType">
    <comment>Map a BAT into its head type</comment>
  <instantiation>
    <signature>():bat[:int,:str] </signature>
    <implementation> CMDbbpHeadType;</implementation>
  </instantiation>
  </command>
  <pattern  name="getObjects">
    <comment>View of the box content.</comment>
  <instantiation>
    <signature>():bat[:int,:str] </signature>
    <implementation> CMDbbpGetObjects;</implementation>
  </instantiation>
  </pattern>
  <pattern  name="iterator">
    <comment>Locates the next element in the box</comment>
  <instantiation>
    <signature>(nme:str):lng </signature>
    <implementation> CMDbbpiterator;</implementation>
  </instantiation>
  </pattern>
  <pattern  name="new">
  <instantiation>
    <signature>(b:bat[:any\$1,:any\$2],size:lng):bat[:any\$1,:any\$2] </signature>
    <implementation> CMDBATnewDerived;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:any\$2]):bat[:any\$1,:any\$2] </signature>
    <implementation> CMDBATnewDerived;</implementation>
  </instantiation>
  <instantiation>
    <signature>(ht:void,tt:any\$2,size:lng):bat[:void,:any\$2] </signature>
    <implementation> CMDBATnew;</implementation>
  </instantiation>
  <instantiation>
    <signature>(ht:void,tt:any\$2,size:int):bat[:void,:any\$2] </signature>
    <implementation> CMDBATnew;</implementation>
  </instantiation>
  <instantiation>
    <signature>(ht:any\$1,tt:any\$2,size:lng):bat[:any\$1,:any\$2] </signature>
    <implementation> CMDBATnew;</implementation>
  </instantiation>
  <instantiation>
    <signature>(ht:any\$1,tt:any\$2,size:int):bat[:any\$1,:any\$2] </signature>
    <implementation> CMDBATnewint;</implementation>
  </instantiation>
  <instantiation>
    <signature>(ht:any\$1,tt:any\$2):bat[:any\$1,:any\$2] </signature>
    <implementation> CMDBATnew;</implementation>
  </instantiation>
  <instantiation>
    <signature>(ht:any\$1,tt:any\$2,b:bat[:any,:any]):bat[:any\$1,:any\$2] </signature>
    <implementation> CMDBATClone;</implementation>
  </instantiation>
  </pattern>
  <command  name="open">
    <comment>Locate the bbp box and open it.</comment>
  <instantiation>
    <signature>():void </signature>
    <implementation> CMDbbpopen;</implementation>
  </instantiation>
  </command>
  <pattern  name="project">
    <comment>Fill the tail column with a constant.</comment>
  <instantiation>
    <signature>(b:bat[:any\$1,:any],val:bat[:any\$1,:any\$2]):bat[:any\$1,:any\$2] </signature>
    <implementation> CMDproject;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:any],val:any\$2):bat[:any\$1,:any\$2] </signature>
    <implementation> CMDproject;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:any]):bat[:any\$1,:void] </signature>
    <implementation> CMDprojectNil;</implementation>
  </instantiation>
  </pattern>
  <pattern  name="prelude">
    <comment>Initialize the bbp box</comment>
  <instantiation>
    <signature>():void </signature>
    <implementation> CMDbbpprelude;</implementation>
  </instantiation>
  </pattern>
  <pattern  name="release">
    <comment>Remove the BAT from further 
	consideration</comment>
  <instantiation>
    <signature>(b:bat[:any,:any]):void </signature>
    <implementation> CMDbbpreleaseBAT;</implementation>
  </instantiation>
  <instantiation>
    <signature>(name:str,val:bat[:any,:any]):void </signature>
    <implementation> CMDbbprelease;</implementation>
  </instantiation>
  </pattern>
  <pattern  name="releaseAll">
    <comment>Commit updates for this client</comment>
  <instantiation>
    <signature>():void </signature>
    <implementation> CMDbbpReleasA;</implementation>
  </instantiation>
  </pattern>
  <pattern  name="toString">
    <comment>Get the string representation of an 
	element in the box</comment>
  <instantiation>
    <signature>(name:str):str </signature>
    <implementation> CMbbptoStr;</implementation>
  </instantiation>
  </pattern>
  <pattern  name="take">
    <comment>Load a particular bat from disk and 
	make a private copy</comment>
  <instantiation>
    <signature>(name:str):bat[:any,:any] </signature>
    <implementation> CMDbbptake;</implementation>
  </instantiation>
  </pattern>
</module>
<atommodule name="blob">
  <command  name="convert">
  <instantiation>
    <signature>():void </signature>
    <implementation> BLOBconvert;</implementation>
  </instantiation>
  </command>
  <command  name="del">
  <instantiation>
    <signature>():void </signature>
    <implementation> BLOBdel;</implementation>
  </instantiation>
  </command>
  <command  name="fromstr">
  <instantiation>
    <signature>():void </signature>
    <implementation> BLOBfromstr;</implementation>
  </instantiation>
  </command>
  <command  name="heap">
  <instantiation>
    <signature>():void </signature>
    <implementation> BLOBheap;</implementation>
  </instantiation>
  </command>
  <command  name="hash">
  <instantiation>
    <signature>():void </signature>
    <implementation> BLOBhash;</implementation>
  </instantiation>
  </command>
  <command  name="length">
  <instantiation>
    <signature>():void </signature>
    <implementation> BLOBlength;</implementation>
  </instantiation>
  </command>
  <command  name="nitems">
    <comment> get the number of bytes in this blob.</comment>
  <instantiation>
    <signature>(b:blob):int </signature>
    <implementation> BLOBnitems;</implementation>
  </instantiation>
  </command>
  <command  name="null">
  <instantiation>
    <signature>():void </signature>
    <implementation> BLOBnull;</implementation>
  </instantiation>
  </command>
  <command  name="nequal">
  <instantiation>
    <signature>():void </signature>
    <implementation> BLOBnequal;</implementation>
  </instantiation>
  </command>
  <command  name="put">
  <instantiation>
    <signature>():void </signature>
    <implementation> BLOBput;</implementation>
  </instantiation>
  </command>
  <command  name="toblob">
    <comment>store a string as a blob.</comment>
  <instantiation>
    <signature>(v:str):blob </signature>
    <implementation> BLOBtoblob;</implementation>
  </instantiation>
  </command>
  <command  name="tostring">
    <comment>get the bytes from blob as a string,
	 starting at byte 'index' till the first 
	0 byte or the end of the blob.</comment>
  <instantiation>
    <signature>(v:blob,index:int):str </signature>
    <implementation> BLOBfromidx;</implementation>
  </instantiation>
  <instantiation>
    <signature>(v:blob):str </signature>
    <implementation> BLOBfromblob;</implementation>
  </instantiation>
  </command>
  <command  name="tostr">
  <instantiation>
    <signature>():void </signature>
    <implementation> BLOBtostr;</implementation>
  </instantiation>
  </command>
</atommodule>
<module name="box">
  <pattern  name="close">
    <comment>Close the box </comment>
  <instantiation>
    <signature>(bname:any):void </signature>
    <implementation> BOXclose;</implementation>
  </instantiation>
  </pattern>
  <pattern  name="discard">
    <comment>Release the BAT from the client pool</comment>
  <instantiation>
    <signature>(bname:any,name:any):void </signature>
    <implementation> BOXdiscard;</implementation>
  </instantiation>
  </pattern>
  <pattern  name="deposit">
    <comment>Enter a new value into the box</comment>
  <instantiation>
    <signature>(bname:any,name:any):void </signature>
    <implementation> BOXdeposit;</implementation>
  </instantiation>
  </pattern>
  <pattern  name="destroy">
    <comment>Destroy the box </comment>
  <instantiation>
    <signature>(bname:any):void </signature>
    <implementation> BOXdestroy;</implementation>
  </instantiation>
  </pattern>
  <command  name="getBoxNames">
    <comment>Retrieve the names of all boxes</comment>
  <instantiation>
    <signature>():bat[:int,:str] </signature>
    <implementation> BOXgetBoxNames;</implementation>
  </instantiation>
  </command>
  <pattern  name="iterator">
    <comment>Locates the next element in the box</comment>
  <instantiation>
    <signature>(nme:str):lng </signature>
    <implementation> BOXiterator;</implementation>
  </instantiation>
  </pattern>
  <pattern  name="open">
    <comment>Locate the boxant box and open it </comment>
  <instantiation>
    <signature>(bname:any):void </signature>
    <implementation> BOXopen;</implementation>
  </instantiation>
  </pattern>
  <pattern  name="release">
    <comment>Release the BAT from the client pool</comment>
  <instantiation>
    <signature>(bname:any,nme:any):void </signature>
    <implementation> BOXrelease;</implementation>
  </instantiation>
  </pattern>
  <pattern  name="releaseAll">
    <comment>Release all objects for this client</comment>
  <instantiation>
    <signature>(bname:any):void </signature>
    <implementation> BOXreleaseAll;</implementation>
  </instantiation>
  </pattern>
  <pattern  name="toString">
    <comment>Get the string representation of 
	the i-th element in the box</comment>
  <instantiation>
    <signature>(bname:str,name:str):str </signature>
    <implementation> BOXtoString;</implementation>
  </instantiation>
  </pattern>
  <pattern  name="take">
    <comment>Locates the typed value in the box</comment>
  <instantiation>
    <signature>(bname:any,name:any):any </signature>
    <implementation> BOXtake;</implementation>
  </instantiation>
  </pattern>
</module>
<module name="calc">
  <command  name="!=">
  <instantiation>
    <signature>(left:str,right:str):bit </signature>
    <implementation> CALCcompNEQstrstr;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:lng,right:lng):bit </signature>
    <implementation> CALCcompNEQlnglng;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:lng,right:int):bit </signature>
    <implementation> CALCcompNEQlngint;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:lng,right:sht):bit </signature>
    <implementation> CALCcompNEQlngsht;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:lng,right:chr):bit </signature>
    <implementation> CALCcompNEQlngchr;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:int,right:lng):bit </signature>
    <implementation> CALCcompNEQintlng;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:int,right:int):bit </signature>
    <implementation> CALCcompNEQintint;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:int,right:sht):bit </signature>
    <implementation> CALCcompNEQintsht;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:int,right:chr):bit </signature>
    <implementation> CALCcompNEQintchr;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:sht,right:lng):bit </signature>
    <implementation> CALCcompNEQshtlng;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:sht,right:int):bit </signature>
    <implementation> CALCcompNEQshtint;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:sht,right:sht):bit </signature>
    <implementation> CALCcompNEQshtsht;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:sht,right:chr):bit </signature>
    <implementation> CALCcompNEQshtchr;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:bit,right:lng):bit </signature>
    <implementation> CALCcompNEQbitlng;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:bit,right:int):bit </signature>
    <implementation> CALCcompNEQbitint;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:bit,right:sht):bit </signature>
    <implementation> CALCcompNEQbitsht;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:bit,right:chr):bit </signature>
    <implementation> CALCcompNEQbitchr;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:chr,right:lng):bit </signature>
    <implementation> CALCcompNEQchrlng;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:chr,right:int):bit </signature>
    <implementation> CALCcompNEQchrint;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:chr,right:sht):bit </signature>
    <implementation> CALCcompNEQchrsht;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:chr,right:chr):bit </signature>
    <implementation> CALCcompNEQchrchr;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:dbl,right:dbl):bit </signature>
    <implementation> CALCcompNEQdbldbl;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:flt,right:dbl):bit </signature>
    <implementation> CALCcompNEQfltdbl;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:flt,right:flt):bit </signature>
    <implementation> CALCcompNEQfltflt;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:oid,right:oid):bit </signature>
    <implementation> CALCcompNEQoidoid;</implementation>
  </instantiation>
  </command>
  <command  name="\%">
  <instantiation>
    <signature>(left:int,right:sht):sht </signature>
    <implementation> CALCbinaryMODintsht;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:int,right:chr):chr </signature>
    <implementation> CALCbinaryMODintchr;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:lng,right:lng):lng </signature>
    <implementation> CALCbinaryMODlnglng;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:lng,right:int):int </signature>
    <implementation> CALCbinaryMODlngint;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:int,right:int):int </signature>
    <implementation> CALCbinaryMODintint;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:sht,right:int):int </signature>
    <implementation> CALCbinaryMODshtint;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:chr,right:int):int </signature>
    <implementation> CALCbinaryMODchrint;</implementation>
  </instantiation>
  </command>
  <command  name="*">
  <instantiation>
    <signature>(left:lng,right:dbl):dbl </signature>
    <implementation> CALCbinaryMULlngdbl;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:lng,right:flt):flt </signature>
    <implementation> CALCbinaryMULlngflt;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:lng,right:lng):lng </signature>
    <implementation> CALCbinaryMULlnglng;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:lng,right:int):lng </signature>
    <implementation> CALCbinaryMULlngint;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:lng,right:sht):lng </signature>
    <implementation> CALCbinaryMULlngsht;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:lng,right:chr):lng </signature>
    <implementation> CALCbinaryMULlngchr;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:int,right:dbl):dbl </signature>
    <implementation> CALCbinaryMULintdbl;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:int,right:flt):flt </signature>
    <implementation> CALCbinaryMULintflt;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:int,right:lng):lng </signature>
    <implementation> CALCbinaryMULintlng;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:int,right:int):int </signature>
    <implementation> CALCbinaryMULintint;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:int,right:sht):int </signature>
    <implementation> CALCbinaryMULintsht;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:int,right:chr):int </signature>
    <implementation> CALCbinaryMULintchr;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:sht,right:dbl):dbl </signature>
    <implementation> CALCbinaryMULshtdbl;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:sht,right:flt):flt </signature>
    <implementation> CALCbinaryMULshtflt;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:sht,right:lng):lng </signature>
    <implementation> CALCbinaryMULshtlng;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:sht,right:int):int </signature>
    <implementation> CALCbinaryMULshtint;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:sht,right:sht):sht </signature>
    <implementation> CALCbinaryMULshtsht;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:sht,right:chr):sht </signature>
    <implementation> CALCbinaryMULshtchr;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:chr,right:dbl):dbl </signature>
    <implementation> CALCbinaryMULchrdbl;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:chr,right:flt):flt </signature>
    <implementation> CALCbinaryMULchrflt;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:chr,right:lng):lng </signature>
    <implementation> CALCbinaryMULchrlng;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:chr,right:int):int </signature>
    <implementation> CALCbinaryMULchrint;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:chr,right:sht):sht </signature>
    <implementation> CALCbinaryMULchrsht;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:chr,right:chr):chr </signature>
    <implementation> CALCbinaryMULchrchr;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:oid,right:oid):oid </signature>
    <implementation> CALCbinaryMULoidoid;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:dbl,right:dbl):dbl </signature>
    <implementation> CALCbinaryMULdbldbl;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:dbl,right:flt):dbl </signature>
    <implementation> CALCbinaryMULdblflt;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:dbl,right:lng):dbl </signature>
    <implementation> CALCbinaryMULdbllng;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:dbl,right:int):dbl </signature>
    <implementation> CALCbinaryMULdblint;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:dbl,right:sht):dbl </signature>
    <implementation> CALCbinaryMULdblsht;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:dbl,right:chr):dbl </signature>
    <implementation> CALCbinaryMULdblchr;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:flt,right:dbl):dbl </signature>
    <implementation> CALCbinaryMULfltdbl;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:flt,right:flt):flt </signature>
    <implementation> CALCbinaryMULfltflt;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:flt,right:lng):flt </signature>
    <implementation> CALCbinaryMULfltlng;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:flt,right:int):flt </signature>
    <implementation> CALCbinaryMULfltint;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:flt,right:sht):flt </signature>
    <implementation> CALCbinaryMULfltsht;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:flt,right:chr):flt </signature>
    <implementation> CALCbinaryMULfltchr;</implementation>
  </instantiation>
  </command>
  <command  name="+">
  <instantiation>
    <signature>(left:lng,right:dbl):dbl </signature>
    <implementation> CALCbinaryADDlngdbl;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:lng,right:flt):flt </signature>
    <implementation> CALCbinaryADDlngflt;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:lng,right:lng):lng </signature>
    <implementation> CALCbinaryADDlnglng;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:lng,right:int):lng </signature>
    <implementation> CALCbinaryADDlngint;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:lng,right:sht):lng </signature>
    <implementation> CALCbinaryADDlngsht;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:lng,right:chr):lng </signature>
    <implementation> CALCbinaryADDlngchr;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:int,right:dbl):dbl </signature>
    <implementation> CALCbinaryADDintdbl;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:int,right:flt):flt </signature>
    <implementation> CALCbinaryADDintflt;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:int,right:lng):lng </signature>
    <implementation> CALCbinaryADDintlng;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:int,right:int):int </signature>
    <implementation> CALCbinaryADDintint;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:int,right:sht):int </signature>
    <implementation> CALCbinaryADDintsht;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:int,right:chr):int </signature>
    <implementation> CALCbinaryADDintchr;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:sht,right:dbl):dbl </signature>
    <implementation> CALCbinaryADDshtdbl;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:sht,right:flt):flt </signature>
    <implementation> CALCbinaryADDshtflt;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:sht,right:lng):lng </signature>
    <implementation> CALCbinaryADDshtlng;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:sht,right:int):int </signature>
    <implementation> CALCbinaryADDshtint;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:sht,right:sht):sht </signature>
    <implementation> CALCbinaryADDshtsht;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:sht,right:chr):sht </signature>
    <implementation> CALCbinaryADDshtchr;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:chr,right:dbl):dbl </signature>
    <implementation> CALCbinaryADDchrdbl;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:chr,right:flt):flt </signature>
    <implementation> CALCbinaryADDchrflt;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:chr,right:lng):lng </signature>
    <implementation> CALCbinaryADDchrlng;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:chr,right:int):int </signature>
    <implementation> CALCbinaryADDchrint;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:chr,right:sht):sht </signature>
    <implementation> CALCbinaryADDchrsht;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:chr,right:chr):chr </signature>
    <implementation> CALCbinaryADDchrchr;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:oid,right:oid):oid </signature>
    <implementation> CALCbinaryADDoidoid;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:dbl,right:dbl):dbl </signature>
    <implementation> CALCbinaryADDdbldbl;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:dbl,right:flt):dbl </signature>
    <implementation> CALCbinaryADDdblflt;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:dbl,right:lng):dbl </signature>
    <implementation> CALCbinaryADDdbllng;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:dbl,right:int):dbl </signature>
    <implementation> CALCbinaryADDdblint;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:dbl,right:sht):dbl </signature>
    <implementation> CALCbinaryADDdblsht;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:dbl,right:chr):dbl </signature>
    <implementation> CALCbinaryADDdblchr;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:flt,right:dbl):dbl </signature>
    <implementation> CALCbinaryADDfltdbl;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:flt,right:flt):flt </signature>
    <implementation> CALCbinaryADDfltflt;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:flt,right:lng):flt </signature>
    <implementation> CALCbinaryADDfltlng;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:flt,right:int):flt </signature>
    <implementation> CALCbinaryADDfltint;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:flt,right:sht):flt </signature>
    <implementation> CALCbinaryADDfltsht;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:flt,right:chr):flt </signature>
    <implementation> CALCbinaryADDfltchr;</implementation>
  </instantiation>
  </command>
  <command  name="-">
    <comment>negative value</comment>
  <instantiation>
    <signature>(x:lng):lng </signature>
    <implementation> CALCunarylngNEG;</implementation>
  </instantiation>
  <instantiation>
    <signature>(x:int):int </signature>
    <implementation> CALCunaryintNEG;</implementation>
  </instantiation>
  <instantiation>
    <signature>(x:sht):sht </signature>
    <implementation> CALCunaryshtNEG;</implementation>
  </instantiation>
  <instantiation>
    <signature>(x:chr):chr </signature>
    <implementation> CALCunarychrNEG;</implementation>
  </instantiation>
  <instantiation>
    <signature>(x:flt):flt </signature>
    <implementation> CALCunaryfltNEG;</implementation>
  </instantiation>
  <instantiation>
    <signature>(x:dbl):dbl </signature>
    <implementation> CALCunarydblNEG;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:lng,right:dbl):dbl </signature>
    <implementation> CALCbinarySUBlngdbl;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:lng,right:flt):flt </signature>
    <implementation> CALCbinarySUBlngflt;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:lng,right:lng):lng </signature>
    <implementation> CALCbinarySUBlnglng;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:lng,right:int):lng </signature>
    <implementation> CALCbinarySUBlngint;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:lng,right:sht):lng </signature>
    <implementation> CALCbinarySUBlngsht;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:lng,right:chr):lng </signature>
    <implementation> CALCbinarySUBlngchr;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:int,right:dbl):dbl </signature>
    <implementation> CALCbinarySUBintdbl;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:int,right:flt):flt </signature>
    <implementation> CALCbinarySUBintflt;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:int,right:lng):lng </signature>
    <implementation> CALCbinarySUBintlng;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:int,right:int):int </signature>
    <implementation> CALCbinarySUBintint;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:int,right:sht):int </signature>
    <implementation> CALCbinarySUBintsht;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:int,right:chr):int </signature>
    <implementation> CALCbinarySUBintchr;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:sht,right:dbl):dbl </signature>
    <implementation> CALCbinarySUBshtdbl;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:sht,right:flt):flt </signature>
    <implementation> CALCbinarySUBshtflt;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:sht,right:lng):lng </signature>
    <implementation> CALCbinarySUBshtlng;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:sht,right:int):int </signature>
    <implementation> CALCbinarySUBshtint;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:sht,right:sht):sht </signature>
    <implementation> CALCbinarySUBshtsht;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:sht,right:chr):sht </signature>
    <implementation> CALCbinarySUBshtchr;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:chr,right:dbl):dbl </signature>
    <implementation> CALCbinarySUBchrdbl;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:chr,right:flt):flt </signature>
    <implementation> CALCbinarySUBchrflt;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:chr,right:lng):lng </signature>
    <implementation> CALCbinarySUBchrlng;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:chr,right:int):int </signature>
    <implementation> CALCbinarySUBchrint;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:chr,right:sht):sht </signature>
    <implementation> CALCbinarySUBchrsht;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:chr,right:chr):chr </signature>
    <implementation> CALCbinarySUBchrchr;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:oid,right:oid):oid </signature>
    <implementation> CALCbinarySUBoidoid;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:dbl,right:dbl):dbl </signature>
    <implementation> CALCbinarySUBdbldbl;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:dbl,right:flt):dbl </signature>
    <implementation> CALCbinarySUBdblflt;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:dbl,right:lng):dbl </signature>
    <implementation> CALCbinarySUBdbllng;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:dbl,right:int):dbl </signature>
    <implementation> CALCbinarySUBdblint;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:dbl,right:sht):dbl </signature>
    <implementation> CALCbinarySUBdblsht;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:dbl,right:chr):dbl </signature>
    <implementation> CALCbinarySUBdblchr;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:flt,right:dbl):dbl </signature>
    <implementation> CALCbinarySUBfltdbl;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:flt,right:flt):flt </signature>
    <implementation> CALCbinarySUBfltflt;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:flt,right:lng):flt </signature>
    <implementation> CALCbinarySUBfltlng;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:flt,right:int):flt </signature>
    <implementation> CALCbinarySUBfltint;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:flt,right:sht):flt </signature>
    <implementation> CALCbinarySUBfltsht;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:flt,right:chr):flt </signature>
    <implementation> CALCbinarySUBfltchr;</implementation>
  </instantiation>
  </command>
  <command  name="/">
  <instantiation>
    <signature>(left:lng,right:dbl):dbl </signature>
    <implementation> CALCbinarycheckDIVlngdbl;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:lng,right:flt):flt </signature>
    <implementation> CALCbinarycheckDIVlngflt;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:lng,right:lng):lng </signature>
    <implementation> CALCbinarycheckDIVlnglng;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:lng,right:int):lng </signature>
    <implementation> CALCbinarycheckDIVlngint;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:lng,right:sht):lng </signature>
    <implementation> CALCbinarycheckDIVlngsht;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:lng,right:chr):lng </signature>
    <implementation> CALCbinarycheckDIVlngchr;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:int,right:dbl):dbl </signature>
    <implementation> CALCbinarycheckDIVintdbl;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:int,right:flt):flt </signature>
    <implementation> CALCbinarycheckDIVintflt;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:int,right:lng):lng </signature>
    <implementation> CALCbinarycheckDIVintlng;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:int,right:int):int </signature>
    <implementation> CALCbinarycheckDIVintint;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:int,right:sht):int </signature>
    <implementation> CALCbinarycheckDIVintsht;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:int,right:chr):int </signature>
    <implementation> CALCbinarycheckDIVintchr;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:sht,right:dbl):dbl </signature>
    <implementation> CALCbinarycheckDIVshtdbl;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:sht,right:flt):flt </signature>
    <implementation> CALCbinarycheckDIVshtflt;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:sht,right:lng):lng </signature>
    <implementation> CALCbinarycheckDIVshtlng;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:sht,right:int):int </signature>
    <implementation> CALCbinarycheckDIVshtint;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:sht,right:sht):sht </signature>
    <implementation> CALCbinarycheckDIVshtsht;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:sht,right:chr):sht </signature>
    <implementation> CALCbinarycheckDIVshtchr;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:chr,right:dbl):dbl </signature>
    <implementation> CALCbinarycheckDIVchrdbl;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:chr,right:flt):flt </signature>
    <implementation> CALCbinarycheckDIVchrflt;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:chr,right:lng):lng </signature>
    <implementation> CALCbinarycheckDIVchrlng;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:chr,right:int):int </signature>
    <implementation> CALCbinarycheckDIVchrint;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:chr,right:sht):sht </signature>
    <implementation> CALCbinarycheckDIVchrsht;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:chr,right:chr):chr </signature>
    <implementation> CALCbinarycheckDIVchrchr;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:oid,right:oid):oid </signature>
    <implementation> CALCbinarycheckDIVoidoid;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:dbl,right:dbl):dbl </signature>
    <implementation> CALCbinarycheckDIVdbldbl;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:dbl,right:flt):dbl </signature>
    <implementation> CALCbinarycheckDIVdblflt;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:dbl,right:lng):dbl </signature>
    <implementation> CALCbinarycheckDIVdbllng;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:dbl,right:int):dbl </signature>
    <implementation> CALCbinarycheckDIVdblint;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:dbl,right:sht):dbl </signature>
    <implementation> CALCbinarycheckDIVdblsht;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:dbl,right:chr):dbl </signature>
    <implementation> CALCbinarycheckDIVdblchr;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:flt,right:dbl):dbl </signature>
    <implementation> CALCbinarycheckDIVfltdbl;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:flt,right:flt):flt </signature>
    <implementation> CALCbinarycheckDIVfltflt;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:flt,right:lng):flt </signature>
    <implementation> CALCbinarycheckDIVfltlng;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:flt,right:int):flt </signature>
    <implementation> CALCbinarycheckDIVfltint;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:flt,right:sht):flt </signature>
    <implementation> CALCbinarycheckDIVfltsht;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:flt,right:chr):flt </signature>
    <implementation> CALCbinarycheckDIVfltchr;</implementation>
  </instantiation>
  </command>
  <command  name="$&lt;$$&lt;$">
  <instantiation>
    <signature>(left:lng,right:int):lng </signature>
    <implementation> CALCbinaryLSHlngint;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:int,right:int):int </signature>
    <implementation> CALCbinaryLSHintint;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:sht,right:int):sht </signature>
    <implementation> CALCbinaryLSHshtint;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:chr,right:int):chr </signature>
    <implementation> CALCbinaryLSHchrint;</implementation>
  </instantiation>
  </command>
  <command  name="$&lt;$=">
  <instantiation>
    <signature>(left:str,right:str):bit </signature>
    <implementation> CALCcompLEstrstr;</implementation>
  </instantiation>
  </command>
  <command  name="$&lt;$">
  <instantiation>
    <signature>(left:str,right:str):bit </signature>
    <implementation> CALCcompLTstrstr;</implementation>
  </instantiation>
  </command>
  <command  name="$&lt;$=">
  <instantiation>
    <signature>(left:lng,right:lng):bit </signature>
    <implementation> CALCcompLElnglng;</implementation>
  </instantiation>
  </command>
  <command  name="$&lt;$">
  <instantiation>
    <signature>(left:lng,right:lng):bit </signature>
    <implementation> CALCcompLTlnglng;</implementation>
  </instantiation>
  </command>
  <command  name="$&lt;$=">
  <instantiation>
    <signature>(left:lng,right:int):bit </signature>
    <implementation> CALCcompLElngint;</implementation>
  </instantiation>
  </command>
  <command  name="$&lt;$">
  <instantiation>
    <signature>(left:lng,right:int):bit </signature>
    <implementation> CALCcompLTlngint;</implementation>
  </instantiation>
  </command>
  <command  name="$&lt;$=">
  <instantiation>
    <signature>(left:lng,right:sht):bit </signature>
    <implementation> CALCcompLElngsht;</implementation>
  </instantiation>
  </command>
  <command  name="$&lt;$">
  <instantiation>
    <signature>(left:lng,right:sht):bit </signature>
    <implementation> CALCcompLTlngsht;</implementation>
  </instantiation>
  </command>
  <command  name="$&lt;$=">
  <instantiation>
    <signature>(left:lng,right:chr):bit </signature>
    <implementation> CALCcompLElngchr;</implementation>
  </instantiation>
  </command>
  <command  name="$&lt;$">
  <instantiation>
    <signature>(left:lng,right:chr):bit </signature>
    <implementation> CALCcompLTlngchr;</implementation>
  </instantiation>
  </command>
  <command  name="$&lt;$=">
  <instantiation>
    <signature>(left:int,right:lng):bit </signature>
    <implementation> CALCcompLEintlng;</implementation>
  </instantiation>
  </command>
  <command  name="$&lt;$">
  <instantiation>
    <signature>(left:int,right:lng):bit </signature>
    <implementation> CALCcompLTintlng;</implementation>
  </instantiation>
  </command>
  <command  name="$&lt;$=">
  <instantiation>
    <signature>(left:int,right:int):bit </signature>
    <implementation> CALCcompLEintint;</implementation>
  </instantiation>
  </command>
  <command  name="$&lt;$">
  <instantiation>
    <signature>(left:int,right:int):bit </signature>
    <implementation> CALCcompLTintint;</implementation>
  </instantiation>
  </command>
  <command  name="$&lt;$=">
  <instantiation>
    <signature>(left:int,right:sht):bit </signature>
    <implementation> CALCcompLEintsht;</implementation>
  </instantiation>
  </command>
  <command  name="$&lt;$">
  <instantiation>
    <signature>(left:int,right:sht):bit </signature>
    <implementation> CALCcompLTintsht;</implementation>
  </instantiation>
  </command>
  <command  name="$&lt;$=">
  <instantiation>
    <signature>(left:int,right:chr):bit </signature>
    <implementation> CALCcompLEintchr;</implementation>
  </instantiation>
  </command>
  <command  name="$&lt;$">
  <instantiation>
    <signature>(left:int,right:chr):bit </signature>
    <implementation> CALCcompLTintchr;</implementation>
  </instantiation>
  </command>
  <command  name="$&lt;$=">
  <instantiation>
    <signature>(left:sht,right:lng):bit </signature>
    <implementation> CALCcompLEshtlng;</implementation>
  </instantiation>
  </command>
  <command  name="$&lt;$">
  <instantiation>
    <signature>(left:sht,right:lng):bit </signature>
    <implementation> CALCcompLTshtlng;</implementation>
  </instantiation>
  </command>
  <command  name="$&lt;$=">
  <instantiation>
    <signature>(left:sht,right:int):bit </signature>
    <implementation> CALCcompLEshtint;</implementation>
  </instantiation>
  </command>
  <command  name="$&lt;$">
  <instantiation>
    <signature>(left:sht,right:int):bit </signature>
    <implementation> CALCcompLTshtint;</implementation>
  </instantiation>
  </command>
  <command  name="$&lt;$=">
  <instantiation>
    <signature>(left:sht,right:sht):bit </signature>
    <implementation> CALCcompLEshtsht;</implementation>
  </instantiation>
  </command>
  <command  name="$&lt;$">
  <instantiation>
    <signature>(left:sht,right:sht):bit </signature>
    <implementation> CALCcompLTshtsht;</implementation>
  </instantiation>
  </command>
  <command  name="$&lt;$=">
  <instantiation>
    <signature>(left:sht,right:chr):bit </signature>
    <implementation> CALCcompLEshtchr;</implementation>
  </instantiation>
  </command>
  <command  name="$&lt;$">
  <instantiation>
    <signature>(left:sht,right:chr):bit </signature>
    <implementation> CALCcompLTshtchr;</implementation>
  </instantiation>
  </command>
  <command  name="$&lt;$=">
  <instantiation>
    <signature>(left:chr,right:lng):bit </signature>
    <implementation> CALCcompLEchrlng;</implementation>
  </instantiation>
  </command>
  <command  name="$&lt;$">
  <instantiation>
    <signature>(left:chr,right:lng):bit </signature>
    <implementation> CALCcompLTchrlng;</implementation>
  </instantiation>
  </command>
  <command  name="$&lt;$=">
  <instantiation>
    <signature>(left:chr,right:int):bit </signature>
    <implementation> CALCcompLEchrint;</implementation>
  </instantiation>
  </command>
  <command  name="$&lt;$">
  <instantiation>
    <signature>(left:chr,right:int):bit </signature>
    <implementation> CALCcompLTchrint;</implementation>
  </instantiation>
  </command>
  <command  name="$&lt;$=">
  <instantiation>
    <signature>(left:chr,right:sht):bit </signature>
    <implementation> CALCcompLEchrsht;</implementation>
  </instantiation>
  </command>
  <command  name="$&lt;$">
  <instantiation>
    <signature>(left:chr,right:sht):bit </signature>
    <implementation> CALCcompLTchrsht;</implementation>
  </instantiation>
  </command>
  <command  name="$&lt;$=">
  <instantiation>
    <signature>(left:chr,right:chr):bit </signature>
    <implementation> CALCcompLEchrchr;</implementation>
  </instantiation>
  </command>
  <command  name="$&lt;$">
  <instantiation>
    <signature>(left:chr,right:chr):bit </signature>
    <implementation> CALCcompLTchrchr;</implementation>
  </instantiation>
  </command>
  <command  name="$&lt;$=">
  <instantiation>
    <signature>(left:dbl,right:dbl):bit </signature>
    <implementation> CALCcompLEdbldbl;</implementation>
  </instantiation>
  </command>
  <command  name="$&lt;$">
  <instantiation>
    <signature>(left:dbl,right:dbl):bit </signature>
    <implementation> CALCcompLTdbldbl;</implementation>
  </instantiation>
  </command>
  <command  name="$&lt;$=">
  <instantiation>
    <signature>(left:flt,right:dbl):bit </signature>
    <implementation> CALCcompLEfltdbl;</implementation>
  </instantiation>
  </command>
  <command  name="$&lt;$">
  <instantiation>
    <signature>(left:flt,right:dbl):bit </signature>
    <implementation> CALCcompLTfltdbl;</implementation>
  </instantiation>
  </command>
  <command  name="$&lt;$=">
  <instantiation>
    <signature>(left:flt,right:flt):bit </signature>
    <implementation> CALCcompLEfltflt;</implementation>
  </instantiation>
  </command>
  <command  name="$&lt;$">
  <instantiation>
    <signature>(left:flt,right:flt):bit </signature>
    <implementation> CALCcompLTfltflt;</implementation>
  </instantiation>
  </command>
  <command  name="$&lt;$=">
  <instantiation>
    <signature>(left:oid,right:oid):bit </signature>
    <implementation> CALCcompLEoidoid;</implementation>
  </instantiation>
  </command>
  <command  name="$&lt;$">
  <instantiation>
    <signature>(left:oid,right:oid):bit </signature>
    <implementation> CALCcompLToidoid;</implementation>
  </instantiation>
  </command>
  <command  name="==">
  <instantiation>
    <signature>(left:str,right:str):bit </signature>
    <implementation> CALCcompEQstrstr;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:lng,right:lng):bit </signature>
    <implementation> CALCcompEQlnglng;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:lng,right:int):bit </signature>
    <implementation> CALCcompEQlngint;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:lng,right:sht):bit </signature>
    <implementation> CALCcompEQlngsht;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:lng,right:chr):bit </signature>
    <implementation> CALCcompEQlngchr;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:int,right:lng):bit </signature>
    <implementation> CALCcompEQintlng;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:int,right:int):bit </signature>
    <implementation> CALCcompEQintint;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:int,right:sht):bit </signature>
    <implementation> CALCcompEQintsht;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:int,right:chr):bit </signature>
    <implementation> CALCcompEQintchr;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:sht,right:lng):bit </signature>
    <implementation> CALCcompEQshtlng;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:sht,right:int):bit </signature>
    <implementation> CALCcompEQshtint;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:sht,right:sht):bit </signature>
    <implementation> CALCcompEQshtsht;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:sht,right:chr):bit </signature>
    <implementation> CALCcompEQshtchr;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:bit,right:lng):bit </signature>
    <implementation> CALCcompEQbitlng;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:bit,right:int):bit </signature>
    <implementation> CALCcompEQbitint;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:bit,right:sht):bit </signature>
    <implementation> CALCcompEQbitsht;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:bit,right:chr):bit </signature>
    <implementation> CALCcompEQbitchr;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:chr,right:lng):bit </signature>
    <implementation> CALCcompEQchrlng;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:chr,right:int):bit </signature>
    <implementation> CALCcompEQchrint;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:chr,right:sht):bit </signature>
    <implementation> CALCcompEQchrsht;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:chr,right:chr):bit </signature>
    <implementation> CALCcompEQchrchr;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:dbl,right:dbl):bit </signature>
    <implementation> CALCcompEQdbldbl;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:flt,right:dbl):bit </signature>
    <implementation> CALCcompEQfltdbl;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:flt,right:flt):bit </signature>
    <implementation> CALCcompEQfltflt;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:oid,right:oid):bit </signature>
    <implementation> CALCcompEQoidoid;</implementation>
  </instantiation>
  </command>
  <command  name="$&gt;$$&gt;$">
  <instantiation>
    <signature>(left:lng,right:int):lng </signature>
    <implementation> CALCbinaryRSHlngint;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:int,right:int):int </signature>
    <implementation> CALCbinaryRSHintint;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:sht,right:int):sht </signature>
    <implementation> CALCbinaryRSHshtint;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:chr,right:int):chr </signature>
    <implementation> CALCbinaryRSHchrint;</implementation>
  </instantiation>
  </command>
  <command  name="$&gt;$">
  <instantiation>
    <signature>(left:str,right:str):bit </signature>
    <implementation> CALCcompGTstrstr;</implementation>
  </instantiation>
  </command>
  <command  name="$&gt;$=">
  <instantiation>
    <signature>(left:str,right:str):bit </signature>
    <implementation> CALCcompGEstrstr;</implementation>
  </instantiation>
  </command>
  <command  name="$&gt;$">
  <instantiation>
    <signature>(left:lng,right:lng):bit </signature>
    <implementation> CALCcompGTlnglng;</implementation>
  </instantiation>
  </command>
  <command  name="$&gt;$=">
  <instantiation>
    <signature>(left:lng,right:lng):bit </signature>
    <implementation> CALCcompGElnglng;</implementation>
  </instantiation>
  </command>
  <command  name="$&gt;$">
  <instantiation>
    <signature>(left:lng,right:int):bit </signature>
    <implementation> CALCcompGTlngint;</implementation>
  </instantiation>
  </command>
  <command  name="$&gt;$=">
  <instantiation>
    <signature>(left:lng,right:int):bit </signature>
    <implementation> CALCcompGElngint;</implementation>
  </instantiation>
  </command>
  <command  name="$&gt;$">
  <instantiation>
    <signature>(left:lng,right:sht):bit </signature>
    <implementation> CALCcompGTlngsht;</implementation>
  </instantiation>
  </command>
  <command  name="$&gt;$=">
  <instantiation>
    <signature>(left:lng,right:sht):bit </signature>
    <implementation> CALCcompGElngsht;</implementation>
  </instantiation>
  </command>
  <command  name="$&gt;$">
  <instantiation>
    <signature>(left:lng,right:chr):bit </signature>
    <implementation> CALCcompGTlngchr;</implementation>
  </instantiation>
  </command>
  <command  name="$&gt;$=">
  <instantiation>
    <signature>(left:lng,right:chr):bit </signature>
    <implementation> CALCcompGElngchr;</implementation>
  </instantiation>
  </command>
  <command  name="$&gt;$">
  <instantiation>
    <signature>(left:int,right:lng):bit </signature>
    <implementation> CALCcompGTintlng;</implementation>
  </instantiation>
  </command>
  <command  name="$&gt;$=">
  <instantiation>
    <signature>(left:int,right:lng):bit </signature>
    <implementation> CALCcompGEintlng;</implementation>
  </instantiation>
  </command>
  <command  name="$&gt;$">
  <instantiation>
    <signature>(left:int,right:int):bit </signature>
    <implementation> CALCcompGTintint;</implementation>
  </instantiation>
  </command>
  <command  name="$&gt;$=">
  <instantiation>
    <signature>(left:int,right:int):bit </signature>
    <implementation> CALCcompGEintint;</implementation>
  </instantiation>
  </command>
  <command  name="$&gt;$">
  <instantiation>
    <signature>(left:int,right:sht):bit </signature>
    <implementation> CALCcompGTintsht;</implementation>
  </instantiation>
  </command>
  <command  name="$&gt;$=">
  <instantiation>
    <signature>(left:int,right:sht):bit </signature>
    <implementation> CALCcompGEintsht;</implementation>
  </instantiation>
  </command>
  <command  name="$&gt;$">
  <instantiation>
    <signature>(left:int,right:chr):bit </signature>
    <implementation> CALCcompGTintchr;</implementation>
  </instantiation>
  </command>
  <command  name="$&gt;$=">
  <instantiation>
    <signature>(left:int,right:chr):bit </signature>
    <implementation> CALCcompGEintchr;</implementation>
  </instantiation>
  </command>
  <command  name="$&gt;$">
  <instantiation>
    <signature>(left:sht,right:lng):bit </signature>
    <implementation> CALCcompGTshtlng;</implementation>
  </instantiation>
  </command>
  <command  name="$&gt;$=">
  <instantiation>
    <signature>(left:sht,right:lng):bit </signature>
    <implementation> CALCcompGEshtlng;</implementation>
  </instantiation>
  </command>
  <command  name="$&gt;$">
  <instantiation>
    <signature>(left:sht,right:int):bit </signature>
    <implementation> CALCcompGTshtint;</implementation>
  </instantiation>
  </command>
  <command  name="$&gt;$=">
  <instantiation>
    <signature>(left:sht,right:int):bit </signature>
    <implementation> CALCcompGEshtint;</implementation>
  </instantiation>
  </command>
  <command  name="$&gt;$">
  <instantiation>
    <signature>(left:sht,right:sht):bit </signature>
    <implementation> CALCcompGTshtsht;</implementation>
  </instantiation>
  </command>
  <command  name="$&gt;$=">
  <instantiation>
    <signature>(left:sht,right:sht):bit </signature>
    <implementation> CALCcompGEshtsht;</implementation>
  </instantiation>
  </command>
  <command  name="$&gt;$">
  <instantiation>
    <signature>(left:sht,right:chr):bit </signature>
    <implementation> CALCcompGTshtchr;</implementation>
  </instantiation>
  </command>
  <command  name="$&gt;$=">
  <instantiation>
    <signature>(left:sht,right:chr):bit </signature>
    <implementation> CALCcompGEshtchr;</implementation>
  </instantiation>
  </command>
  <command  name="$&gt;$">
  <instantiation>
    <signature>(left:chr,right:lng):bit </signature>
    <implementation> CALCcompGTchrlng;</implementation>
  </instantiation>
  </command>
  <command  name="$&gt;$=">
  <instantiation>
    <signature>(left:chr,right:lng):bit </signature>
    <implementation> CALCcompGEchrlng;</implementation>
  </instantiation>
  </command>
  <command  name="$&gt;$">
  <instantiation>
    <signature>(left:chr,right:int):bit </signature>
    <implementation> CALCcompGTchrint;</implementation>
  </instantiation>
  </command>
  <command  name="$&gt;$=">
  <instantiation>
    <signature>(left:chr,right:int):bit </signature>
    <implementation> CALCcompGEchrint;</implementation>
  </instantiation>
  </command>
  <command  name="$&gt;$">
  <instantiation>
    <signature>(left:chr,right:sht):bit </signature>
    <implementation> CALCcompGTchrsht;</implementation>
  </instantiation>
  </command>
  <command  name="$&gt;$=">
  <instantiation>
    <signature>(left:chr,right:sht):bit </signature>
    <implementation> CALCcompGEchrsht;</implementation>
  </instantiation>
  </command>
  <command  name="$&gt;$">
  <instantiation>
    <signature>(left:chr,right:chr):bit </signature>
    <implementation> CALCcompGTchrchr;</implementation>
  </instantiation>
  </command>
  <command  name="$&gt;$=">
  <instantiation>
    <signature>(left:chr,right:chr):bit </signature>
    <implementation> CALCcompGEchrchr;</implementation>
  </instantiation>
  </command>
  <command  name="$&gt;$">
  <instantiation>
    <signature>(left:dbl,right:dbl):bit </signature>
    <implementation> CALCcompGTdbldbl;</implementation>
  </instantiation>
  </command>
  <command  name="$&gt;$=">
  <instantiation>
    <signature>(left:dbl,right:dbl):bit </signature>
    <implementation> CALCcompGEdbldbl;</implementation>
  </instantiation>
  </command>
  <command  name="$&gt;$">
  <instantiation>
    <signature>(left:flt,right:dbl):bit </signature>
    <implementation> CALCcompGTfltdbl;</implementation>
  </instantiation>
  </command>
  <command  name="$&gt;$=">
  <instantiation>
    <signature>(left:flt,right:dbl):bit </signature>
    <implementation> CALCcompGEfltdbl;</implementation>
  </instantiation>
  </command>
  <command  name="$&gt;$">
  <instantiation>
    <signature>(left:flt,right:flt):bit </signature>
    <implementation> CALCcompGTfltflt;</implementation>
  </instantiation>
  </command>
  <command  name="$&gt;$=">
  <instantiation>
    <signature>(left:flt,right:flt):bit </signature>
    <implementation> CALCcompGEfltflt;</implementation>
  </instantiation>
  </command>
  <command  name="$&gt;$">
  <instantiation>
    <signature>(left:oid,right:oid):bit </signature>
    <implementation> CALCcompGToidoid;</implementation>
  </instantiation>
  </command>
  <command  name="$&gt;$=">
  <instantiation>
    <signature>(left:oid,right:oid):bit </signature>
    <implementation> CALCcompGEoidoid;</implementation>
  </instantiation>
  </command>
  <command  name="and">
  <instantiation>
    <signature>(left:lng,right:lng):lng </signature>
    <implementation> CALCbinaryANDlnglng;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:int,right:int):int </signature>
    <implementation> CALCbinaryANDintint;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:sht,right:sht):sht </signature>
    <implementation> CALCbinaryANDshtsht;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:chr,right:chr):chr </signature>
    <implementation> CALCbinaryANDchrchr;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:bit,right:bit):bit </signature>
    <implementation> CALCbinaryANDbit;</implementation>
  </instantiation>
  </command>
  <command  name="abs">
    <comment>absolute value</comment>
  <instantiation>
    <signature>(x:lng):lng </signature>
    <implementation> CALCunarylngABS;</implementation>
  </instantiation>
  <instantiation>
    <signature>(x:int):int </signature>
    <implementation> CALCunaryintABS;</implementation>
  </instantiation>
  <instantiation>
    <signature>(x:sht):sht </signature>
    <implementation> CALCunaryshtABS;</implementation>
  </instantiation>
  <instantiation>
    <signature>(x:chr):chr </signature>
    <implementation> CALCunarychrABS;</implementation>
  </instantiation>
  <instantiation>
    <signature>(x:flt):flt </signature>
    <implementation> CALCunaryfltABS;</implementation>
  </instantiation>
  <instantiation>
    <signature>(x:dbl):dbl </signature>
    <implementation> CALCunarydblABS;</implementation>
  </instantiation>
  </command>
  <command  name="bat">
  <instantiation>
    <signature>(v:void):bat[:any,:any] </signature>
    <implementation> CALCnil2bat;</implementation>
  </instantiation>
  <instantiation>
    <signature>(v:str):bat[:any,:any] </signature>
    <implementation> CALCstr2bat;</implementation>
  </instantiation>
  </command>
  <command  name="bit">
  <instantiation>
    <signature>(v:void):bit </signature>
    <implementation> CALCnil2bit;</implementation>
  </instantiation>
  <instantiation>
    <signature>(v:str):bit </signature>
    <implementation> CALCstr2bit;</implementation>
  </instantiation>
  <instantiation>
    <signature>(x:dbl):bit </signature>
    <implementation> CALCdbl2bit;</implementation>
  </instantiation>
  <instantiation>
    <signature>(x:flt):bit </signature>
    <implementation> CALCflt2bit;</implementation>
  </instantiation>
  <instantiation>
    <signature>(x:lng):bit </signature>
    <implementation> CALClng2bit;</implementation>
  </instantiation>
  <instantiation>
    <signature>(x:int):bit </signature>
    <implementation> CALCint2bit;</implementation>
  </instantiation>
  <instantiation>
    <signature>(x:sht):bit </signature>
    <implementation> CALCsht2bit;</implementation>
  </instantiation>
  <instantiation>
    <signature>(x:bit):bit </signature>
    <implementation> CALCbit2bit;</implementation>
  </instantiation>
  <instantiation>
    <signature>(x:oid):bit </signature>
    <implementation> CALCoid2bit;</implementation>
  </instantiation>
  <instantiation>
    <signature>(x:dbl):bit </signature>
    <implementation> CALCdbl2bit;</implementation>
  </instantiation>
  <instantiation>
    <signature>(x:flt):bit </signature>
    <implementation> CALCflt2bit;</implementation>
  </instantiation>
  <instantiation>
    <signature>(x:lng):bit </signature>
    <implementation> CALClng2bit;</implementation>
  </instantiation>
  <instantiation>
    <signature>(x:int):bit </signature>
    <implementation> CALCint2bit;</implementation>
  </instantiation>
  <instantiation>
    <signature>(x:sht):bit </signature>
    <implementation> CALCsht2bit;</implementation>
  </instantiation>
  <instantiation>
    <signature>(x:bit):bit </signature>
    <implementation> CALCbit2bit;</implementation>
  </instantiation>
  </command>
  <command  name="between">
  <instantiation>
    <signature>(val:str,low:str,high:str):bit </signature>
    <implementation> CALCcompBetweenstr;</implementation>
  </instantiation>
  <instantiation>
    <signature>(val:lng,low:lng,high:lng):bit </signature>
    <implementation> CALCcompBetweenlng;</implementation>
  </instantiation>
  <instantiation>
    <signature>(val:lng,low:lng,high:lng):bit </signature>
    <implementation> CALCcompBetweenlng;</implementation>
  </instantiation>
  <instantiation>
    <signature>(val:lng,low:lng,high:lng):bit </signature>
    <implementation> CALCcompBetweenlng;</implementation>
  </instantiation>
  <instantiation>
    <signature>(val:lng,low:lng,high:lng):bit </signature>
    <implementation> CALCcompBetweenlng;</implementation>
  </instantiation>
  <instantiation>
    <signature>(val:int,low:int,high:int):bit </signature>
    <implementation> CALCcompBetweenint;</implementation>
  </instantiation>
  <instantiation>
    <signature>(val:int,low:int,high:int):bit </signature>
    <implementation> CALCcompBetweenint;</implementation>
  </instantiation>
  <instantiation>
    <signature>(val:int,low:int,high:int):bit </signature>
    <implementation> CALCcompBetweenint;</implementation>
  </instantiation>
  <instantiation>
    <signature>(val:int,low:int,high:int):bit </signature>
    <implementation> CALCcompBetweenint;</implementation>
  </instantiation>
  <instantiation>
    <signature>(val:sht,low:sht,high:sht):bit </signature>
    <implementation> CALCcompBetweensht;</implementation>
  </instantiation>
  <instantiation>
    <signature>(val:sht,low:sht,high:sht):bit </signature>
    <implementation> CALCcompBetweensht;</implementation>
  </instantiation>
  <instantiation>
    <signature>(val:sht,low:sht,high:sht):bit </signature>
    <implementation> CALCcompBetweensht;</implementation>
  </instantiation>
  <instantiation>
    <signature>(val:sht,low:sht,high:sht):bit </signature>
    <implementation> CALCcompBetweensht;</implementation>
  </instantiation>
  <instantiation>
    <signature>(val:chr,low:chr,high:chr):bit </signature>
    <implementation> CALCcompBetweenchr;</implementation>
  </instantiation>
  <instantiation>
    <signature>(val:chr,low:chr,high:chr):bit </signature>
    <implementation> CALCcompBetweenchr;</implementation>
  </instantiation>
  <instantiation>
    <signature>(val:chr,low:chr,high:chr):bit </signature>
    <implementation> CALCcompBetweenchr;</implementation>
  </instantiation>
  <instantiation>
    <signature>(val:chr,low:chr,high:chr):bit </signature>
    <implementation> CALCcompBetweenchr;</implementation>
  </instantiation>
  <instantiation>
    <signature>(val:dbl,low:dbl,high:dbl):bit </signature>
    <implementation> CALCcompBetweendbl;</implementation>
  </instantiation>
  <instantiation>
    <signature>(val:flt,low:flt,high:flt):bit </signature>
    <implementation> CALCcompBetweenflt;</implementation>
  </instantiation>
  <instantiation>
    <signature>(val:flt,low:flt,high:flt):bit </signature>
    <implementation> CALCcompBetweenflt;</implementation>
  </instantiation>
  <instantiation>
    <signature>(val:oid,low:oid,high:oid):bit </signature>
    <implementation> CALCcompBetweenoid;</implementation>
  </instantiation>
  </command>
  <command  name="chr">
  <instantiation>
    <signature>(v:void):chr </signature>
    <implementation> CALCnil2chr;</implementation>
  </instantiation>
  <instantiation>
    <signature>(v:str):chr </signature>
    <implementation> CALCstr2chr;</implementation>
  </instantiation>
  <instantiation>
    <signature>(x:lng):chr </signature>
    <implementation> CALClng2chr;</implementation>
  </instantiation>
  <instantiation>
    <signature>(x:int):chr </signature>
    <implementation> CALCint2chr;</implementation>
  </instantiation>
  <instantiation>
    <signature>(x:sht):chr </signature>
    <implementation> CALCsht2chr;</implementation>
  </instantiation>
  <instantiation>
    <signature>(x:chr):chr </signature>
    <implementation> CALCchr2chr;</implementation>
  </instantiation>
  <instantiation>
    <signature>(x:dbl):chr </signature>
    <implementation> CALCdbl2chr;</implementation>
  </instantiation>
  <instantiation>
    <signature>(x:flt):chr </signature>
    <implementation> CALCflt2chr;</implementation>
  </instantiation>
  <instantiation>
    <signature>(x:lng):chr </signature>
    <implementation> CALClng2chr;</implementation>
  </instantiation>
  <instantiation>
    <signature>(x:int):chr </signature>
    <implementation> CALCint2chr;</implementation>
  </instantiation>
  <instantiation>
    <signature>(x:sht):chr </signature>
    <implementation> CALCsht2chr;</implementation>
  </instantiation>
  <instantiation>
    <signature>(x:bit):chr </signature>
    <implementation> CALCbit2chr;</implementation>
  </instantiation>
  <instantiation>
    <signature>(x:oid):chr </signature>
    <implementation> CALCoid2chr;</implementation>
  </instantiation>
  </command>
  <command  name="dbl">
  <instantiation>
    <signature>(v:void):dbl </signature>
    <implementation> CALCnil2dbl;</implementation>
  </instantiation>
  <instantiation>
    <signature>(v:str):dbl </signature>
    <implementation> CALCstr2dbl;</implementation>
  </instantiation>
  <instantiation>
    <signature>(x:lng):dbl </signature>
    <implementation> CALClng2dbl;</implementation>
  </instantiation>
  <instantiation>
    <signature>(x:int):dbl </signature>
    <implementation> CALCint2dbl;</implementation>
  </instantiation>
  <instantiation>
    <signature>(x:sht):dbl </signature>
    <implementation> CALCsht2dbl;</implementation>
  </instantiation>
  <instantiation>
    <signature>(x:flt):dbl </signature>
    <implementation> CALCflt2dbl;</implementation>
  </instantiation>
  <instantiation>
    <signature>(x:dbl):dbl </signature>
    <implementation> CALCdbl2dbl;</implementation>
  </instantiation>
  </command>
  <command  name="flt">
  <instantiation>
    <signature>(v:void):flt </signature>
    <implementation> CALCnil2flt;</implementation>
  </instantiation>
  <instantiation>
    <signature>(v:str):flt </signature>
    <implementation> CALCstr2flt;</implementation>
  </instantiation>
  <instantiation>
    <signature>(x:lng):flt </signature>
    <implementation> CALClng2flt;</implementation>
  </instantiation>
  <instantiation>
    <signature>(x:int):flt </signature>
    <implementation> CALCint2flt;</implementation>
  </instantiation>
  <instantiation>
    <signature>(x:sht):flt </signature>
    <implementation> CALCsht2flt;</implementation>
  </instantiation>
  <instantiation>
    <signature>(x:dbl):flt </signature>
    <implementation> CALCdbl2flt;</implementation>
  </instantiation>
  <instantiation>
    <signature>(x:flt):flt </signature>
    <implementation> CALCflt2flt;</implementation>
  </instantiation>
  </command>
  <command  name="int">
  <instantiation>
    <signature>(v:void):int </signature>
    <implementation> CALCnil2int;</implementation>
  </instantiation>
  <instantiation>
    <signature>(v:str):int </signature>
    <implementation> CALCstr2int;</implementation>
  </instantiation>
  </command>
  <command  name="ifthenelse">
  <instantiation>
    <signature>(b:bit,t:any\$1,tpe:any\$1,f:any\$1):any\$1 </signature>
    <implementation> CALCswitchbit;</implementation>
  </instantiation>
  </command>
  <command  name="int">
    <comment>coercion dbl to int</comment>
  <instantiation>
    <signature>(x:dbl):int </signature>
    <implementation> CALCdbl2int;</implementation>
  </instantiation>
  <instantiation>
    <signature>(x:flt):int </signature>
    <implementation> CALCflt2int;</implementation>
  </instantiation>
  <instantiation>
    <signature>(x:lng):int </signature>
    <implementation> CALClng2int;</implementation>
  </instantiation>
  <instantiation>
    <signature>(x:int):int </signature>
    <implementation> CALCint2int;</implementation>
  </instantiation>
  <instantiation>
    <signature>(x:sht):int </signature>
    <implementation> CALCsht2int;</implementation>
  </instantiation>
  <instantiation>
    <signature>(x:bit):int </signature>
    <implementation> CALCbit2int;</implementation>
  </instantiation>
  <instantiation>
    <signature>(x:oid):int </signature>
    <implementation> CALCoid2int;</implementation>
  </instantiation>
  </command>
  <command  name="inv">
    <comment>inverse value (1/x)</comment>
  <instantiation>
    <signature>(x:lng):lng </signature>
    <implementation> CALCunarychecklngINV;</implementation>
  </instantiation>
  <instantiation>
    <signature>(x:int):int </signature>
    <implementation> CALCunarycheckintINV;</implementation>
  </instantiation>
  <instantiation>
    <signature>(x:sht):sht </signature>
    <implementation> CALCunarycheckshtINV;</implementation>
  </instantiation>
  <instantiation>
    <signature>(x:chr):chr </signature>
    <implementation> CALCunarycheckchrINV;</implementation>
  </instantiation>
  <instantiation>
    <signature>(x:flt):flt </signature>
    <implementation> CALCunarycheckfltINV;</implementation>
  </instantiation>
  <instantiation>
    <signature>(x:dbl):dbl </signature>
    <implementation> CALCunarycheckdblINV;</implementation>
  </instantiation>
  </command>
  <command  name="isnotnil">
    <comment>is a value not equal to nil?</comment>
  <instantiation>
    <signature>(v:void):bit </signature>
    <implementation> CALCisnotnil\_void;</implementation>
  </instantiation>
  </command>
  <command  name="isnil">
    <comment>is a value nil?</comment>
  <instantiation>
    <signature>(v:void):bit </signature>
    <implementation> CALCisnil\_void;</implementation>
  </instantiation>
  </command>
  <command  name="isnotnil">
    <comment>is a value not equal to nil?</comment>
  <instantiation>
    <signature>(v:str):bit </signature>
    <implementation> CALCisnotnil\_str;</implementation>
  </instantiation>
  </command>
  <command  name="isnil">
    <comment>is a value nil?</comment>
  <instantiation>
    <signature>(v:str):bit </signature>
    <implementation> CALCisnil\_str;</implementation>
  </instantiation>
  </command>
  <command  name="isnotnil">
    <comment>is a value not equal to nil?</comment>
  <instantiation>
    <signature>(v:dbl):bit </signature>
    <implementation> CALCisnotnil\_dbl;</implementation>
  </instantiation>
  </command>
  <command  name="isnil">
    <comment>is a value nil?</comment>
  <instantiation>
    <signature>(v:dbl):bit </signature>
    <implementation> CALCisnil\_dbl;</implementation>
  </instantiation>
  </command>
  <command  name="isnotnil">
    <comment>is a value not equal to nil?</comment>
  <instantiation>
    <signature>(v:lng):bit </signature>
    <implementation> CALCisnotnil\_lng;</implementation>
  </instantiation>
  </command>
  <command  name="isnil">
    <comment>is a value nil?</comment>
  <instantiation>
    <signature>(v:lng):bit </signature>
    <implementation> CALCisnil\_lng;</implementation>
  </instantiation>
  </command>
  <command  name="isnotnil">
    <comment>is a value not equal to nil?</comment>
  <instantiation>
    <signature>(v:flt):bit </signature>
    <implementation> CALCisnotnil\_flt;</implementation>
  </instantiation>
  </command>
  <command  name="isnil">
    <comment>is a value nil?</comment>
  <instantiation>
    <signature>(v:flt):bit </signature>
    <implementation> CALCisnil\_flt;</implementation>
  </instantiation>
  </command>
  <command  name="isnotnil">
    <comment>is a value not equal to nil?</comment>
  <instantiation>
    <signature>(v:oid):bit </signature>
    <implementation> CALCisnotnil\_oid;</implementation>
  </instantiation>
  </command>
  <command  name="isnil">
    <comment>is a value nil?</comment>
  <instantiation>
    <signature>(v:oid):bit </signature>
    <implementation> CALCisnil\_oid;</implementation>
  </instantiation>
  </command>
  <command  name="isnotnil">
    <comment>is a value not equal to nil?</comment>
  <instantiation>
    <signature>(v:int):bit </signature>
    <implementation> CALCisnotnil\_int;</implementation>
  </instantiation>
  </command>
  <command  name="isnil">
    <comment>is a value nil?</comment>
  <instantiation>
    <signature>(v:int):bit </signature>
    <implementation> CALCisnil\_int;</implementation>
  </instantiation>
  </command>
  <command  name="isnotnil">
    <comment>is a value not equal to nil?</comment>
  <instantiation>
    <signature>(v:sht):bit </signature>
    <implementation> CALCisnotnil\_sht;</implementation>
  </instantiation>
  </command>
  <command  name="isnil">
    <comment>is a value nil?</comment>
  <instantiation>
    <signature>(v:sht):bit </signature>
    <implementation> CALCisnil\_sht;</implementation>
  </instantiation>
  </command>
  <command  name="isnotnil">
    <comment>is a value not equal to nil?</comment>
  <instantiation>
    <signature>(v:bit):bit </signature>
    <implementation> CALCisnotnil\_bit;</implementation>
  </instantiation>
  </command>
  <command  name="isnil">
    <comment>is a value nil?</comment>
  <instantiation>
    <signature>(v:bit):bit </signature>
    <implementation> CALCisnil\_bit;</implementation>
  </instantiation>
  </command>
  <command  name="isnotnil">
    <comment>is a value not equal to nil?</comment>
  <instantiation>
    <signature>(v:chr):bit </signature>
    <implementation> CALCisnotnil\_chr;</implementation>
  </instantiation>
  </command>
  <command  name="isnil">
    <comment>is a value nil?</comment>
  <instantiation>
    <signature>(v:chr):bit </signature>
    <implementation> CALCisnil\_chr;</implementation>
  </instantiation>
  </command>
  <command  name="lng">
  <instantiation>
    <signature>(v:void):lng </signature>
    <implementation> CALCnil2lng;</implementation>
  </instantiation>
  <instantiation>
    <signature>(v:str):lng </signature>
    <implementation> CALCstr2lng;</implementation>
  </instantiation>
  <instantiation>
    <signature>(x:dbl):lng </signature>
    <implementation> CALCdbl2lng;</implementation>
  </instantiation>
  <instantiation>
    <signature>(x:flt):lng </signature>
    <implementation> CALCflt2lng;</implementation>
  </instantiation>
  <instantiation>
    <signature>(x:lng):lng </signature>
    <implementation> CALClng2lng;</implementation>
  </instantiation>
  <instantiation>
    <signature>(x:int):lng </signature>
    <implementation> CALCint2lng;</implementation>
  </instantiation>
  <instantiation>
    <signature>(x:sht):lng </signature>
    <implementation> CALCsht2lng;</implementation>
  </instantiation>
  <instantiation>
    <signature>(x:bit):lng </signature>
    <implementation> CALCbit2lng;</implementation>
  </instantiation>
  <instantiation>
    <signature>(x:oid):lng </signature>
    <implementation> CALCoid2lng;</implementation>
  </instantiation>
  </command>
  <command  name="min">
  <instantiation>
    <signature>(l:dbl,r:dbl):dbl </signature>
    <implementation> CALCbinaryMINdbl;</implementation>
  </instantiation>
  </command>
  <command  name="max">
  <instantiation>
    <signature>(l:dbl,r:dbl):dbl </signature>
    <implementation> CALCbinaryMAXdbl;</implementation>
  </instantiation>
  </command>
  <command  name="min">
  <instantiation>
    <signature>(l:lng,r:lng):lng </signature>
    <implementation> CALCbinaryMINlng;</implementation>
  </instantiation>
  </command>
  <command  name="max">
  <instantiation>
    <signature>(l:lng,r:lng):lng </signature>
    <implementation> CALCbinaryMAXlng;</implementation>
  </instantiation>
  </command>
  <command  name="min">
  <instantiation>
    <signature>(l:flt,r:flt):flt </signature>
    <implementation> CALCbinaryMINflt;</implementation>
  </instantiation>
  </command>
  <command  name="max">
  <instantiation>
    <signature>(l:flt,r:flt):flt </signature>
    <implementation> CALCbinaryMAXflt;</implementation>
  </instantiation>
  </command>
  <command  name="min">
  <instantiation>
    <signature>(l:oid,r:oid):oid </signature>
    <implementation> CALCbinaryMINoid;</implementation>
  </instantiation>
  </command>
  <command  name="max">
  <instantiation>
    <signature>(l:oid,r:oid):oid </signature>
    <implementation> CALCbinaryMAXoid;</implementation>
  </instantiation>
  </command>
  <command  name="min">
  <instantiation>
    <signature>(l:int,r:int):int </signature>
    <implementation> CALCbinaryMINint;</implementation>
  </instantiation>
  </command>
  <command  name="max">
  <instantiation>
    <signature>(l:int,r:int):int </signature>
    <implementation> CALCbinaryMAXint;</implementation>
  </instantiation>
  </command>
  <command  name="min">
  <instantiation>
    <signature>(l:sht,r:sht):sht </signature>
    <implementation> CALCbinaryMINsht;</implementation>
  </instantiation>
  </command>
  <command  name="max">
  <instantiation>
    <signature>(l:sht,r:sht):sht </signature>
    <implementation> CALCbinaryMAXsht;</implementation>
  </instantiation>
  </command>
  <command  name="min">
  <instantiation>
    <signature>(l:chr,r:chr):chr </signature>
    <implementation> CALCbinaryMINchr;</implementation>
  </instantiation>
  </command>
  <command  name="max">
  <instantiation>
    <signature>(l:chr,r:chr):chr </signature>
    <implementation> CALCbinaryMAXchr;</implementation>
  </instantiation>
  </command>
  <command  name="newoid">
    <comment>Reserves a range of consecutive 
	unique OIDs; returns the lowest in range.
	equivalent to newoid(0,incr)</comment>
  <instantiation>
    <signature>(incr:int):oid </signature>
    <implementation> CALCnewoidInc;</implementation>
  </instantiation>
  <instantiation>
    <signature>(incr:lng):oid </signature>
    <implementation> CALCnewoidInclng;</implementation>
  </instantiation>
  <instantiation>
    <signature>():oid </signature>
    <implementation> CALCnewoidBase;</implementation>
  </instantiation>
  </command>
  <command  name="not">
  <instantiation>
    <signature>(left:lng):lng </signature>
    <implementation> CALCunarylngNOT;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:int):int </signature>
    <implementation> CALCunaryintNOT;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:sht):sht </signature>
    <implementation> CALCunaryshtNOT;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:chr):chr </signature>
    <implementation> CALCunarychrNOT;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:bit):bit </signature>
    <implementation> CALCunarybitNOT;</implementation>
  </instantiation>
  </command>
  <command  name="oid">
  <instantiation>
    <signature>(v:void):oid </signature>
    <implementation> CALCnil2oid;</implementation>
  </instantiation>
  <instantiation>
    <signature>(v:str):oid </signature>
    <implementation> CALCstr2oid;</implementation>
  </instantiation>
  </command>
  <command  name="or">
  <instantiation>
    <signature>(left:lng,right:lng):lng </signature>
    <implementation> CALCbinaryORlnglng;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:int,right:int):int </signature>
    <implementation> CALCbinaryORintint;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:sht,right:sht):sht </signature>
    <implementation> CALCbinaryORshtsht;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:chr,right:chr):chr </signature>
    <implementation> CALCbinaryORchrchr;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:bit,right:bit):bit </signature>
    <implementation> CALCbinaryORbit;</implementation>
  </instantiation>
  </command>
  <command  name="oid">
    <comment>coercion int to oid</comment>
  <instantiation>
    <signature>(x:int):oid </signature>
    <implementation> CALCint2oid;</implementation>
  </instantiation>
  <instantiation>
    <signature>(x:sht):oid </signature>
    <implementation> CALCsht2oid;</implementation>
  </instantiation>
  <instantiation>
    <signature>(x:lng):oid </signature>
    <implementation> CALClng2oid;</implementation>
  </instantiation>
  <instantiation>
    <signature>(x:oid):oid </signature>
    <implementation> CALCoid2oid;</implementation>
  </instantiation>
  </command>
  <command  name="ptr">
  <instantiation>
    <signature>(v:void):ptr </signature>
    <implementation> CALCnil2ptr;</implementation>
  </instantiation>
  <instantiation>
    <signature>(v:str):ptr </signature>
    <implementation> CALCstr2ptr;</implementation>
  </instantiation>
  <instantiation>
    <signature>(x:lng):ptr </signature>
    <implementation> CALClng2ptr;</implementation>
  </instantiation>
  </command>
  <command  name="rand">
    <comment>return a random number</comment>
  <instantiation>
    <signature>():int </signature>
    <implementation> CALCrandint;</implementation>
  </instantiation>
  </command>
  <command  name="setoid">
    <comment>Equivalent to setoid(1:oid).</comment>
  <instantiation>
    <signature>():oid </signature>
    <implementation> CALCsetoidBase;</implementation>
  </instantiation>
  <instantiation>
    <signature>(base:oid):oid </signature>
    <implementation> CALCsetoidInc;</implementation>
  </instantiation>
  <instantiation>
    <signature>(v:oid):void </signature>
    <implementation> oidSetoidImpl;</implementation>
  </instantiation>
  <instantiation>
    <signature>(v:lng):void </signature>
    <implementation> lngSetoidImpl;</implementation>
  </instantiation>
  <instantiation>
    <signature>(v:int):void </signature>
    <implementation> intSetoidImpl;</implementation>
  </instantiation>
  </command>
  <command  name="str">
  <instantiation>
    <signature>(v:str):str </signature>
    <implementation> CALCstr2str;</implementation>
  </instantiation>
  <instantiation>
    <signature>(v:void):str </signature>
    <implementation> CALCnil2str;</implementation>
  </instantiation>
  <instantiation>
    <signature>(v:bat[:any,:any]):str </signature>
    <implementation> CALCbat2str;</implementation>
  </instantiation>
  <instantiation>
    <signature>(v:chr):str </signature>
    <implementation> CALCchr2str;</implementation>
  </instantiation>
  <instantiation>
    <signature>(v:ptr):str </signature>
    <implementation> CALCptr2str;</implementation>
  </instantiation>
  <instantiation>
    <signature>(v:bit):str </signature>
    <implementation> CALCbit2str;</implementation>
  </instantiation>
  <instantiation>
    <signature>(v:dbl):str </signature>
    <implementation> CALCdbl2str;</implementation>
  </instantiation>
  <instantiation>
    <signature>(v:flt):str </signature>
    <implementation> CALCflt2str;</implementation>
  </instantiation>
  <instantiation>
    <signature>(v:lng):str </signature>
    <implementation> CALClng2str;</implementation>
  </instantiation>
  <instantiation>
    <signature>(v:int):str </signature>
    <implementation> CALCint2str;</implementation>
  </instantiation>
  </command>
  <command  name="sht">
  <instantiation>
    <signature>(v:void):sht </signature>
    <implementation> CALCnil2sht;</implementation>
  </instantiation>
  </command>
  <command  name="str">
  <instantiation>
    <signature>(v:sht):str </signature>
    <implementation> CALCsht2str;</implementation>
  </instantiation>
  </command>
  <command  name="sht">
  <instantiation>
    <signature>(v:str):sht </signature>
    <implementation> CALCstr2sht;</implementation>
  </instantiation>
  </command>
  <command  name="str">
  <instantiation>
    <signature>(v:oid):str </signature>
    <implementation> CALCoid2str;</implementation>
  </instantiation>
  </command>
  <command  name="srand">
    <comment>initialize the rand() function with a seed</comment>
  <instantiation>
    <signature>(seed:int):void </signature>
    <implementation> CALCsrandint;</implementation>
  </instantiation>
  </command>
  <command  name="str">
    <comment>coercion dbl to str</comment>
  <instantiation>
    <signature>(x:dbl):str </signature>
    <implementation> CALCdbl2str;</implementation>
  </instantiation>
  <instantiation>
    <signature>(x:flt):str </signature>
    <implementation> CALCflt2str;</implementation>
  </instantiation>
  <instantiation>
    <signature>(x:lng):str </signature>
    <implementation> CALClng2str;</implementation>
  </instantiation>
  <instantiation>
    <signature>(x:int):str </signature>
    <implementation> CALCint2str;</implementation>
  </instantiation>
  <instantiation>
    <signature>(x:sht):str </signature>
    <implementation> CALCsht2str;</implementation>
  </instantiation>
  </command>
  <command  name="sht">
    <comment>coercion dbl to sht</comment>
  <instantiation>
    <signature>(x:dbl):sht </signature>
    <implementation> CALCdbl2sht;</implementation>
  </instantiation>
  <instantiation>
    <signature>(x:flt):sht </signature>
    <implementation> CALCflt2sht;</implementation>
  </instantiation>
  <instantiation>
    <signature>(x:lng):sht </signature>
    <implementation> CALClng2sht;</implementation>
  </instantiation>
  <instantiation>
    <signature>(x:int):sht </signature>
    <implementation> CALCint2sht;</implementation>
  </instantiation>
  <instantiation>
    <signature>(x:sht):sht </signature>
    <implementation> CALCsht2sht;</implementation>
  </instantiation>
  <instantiation>
    <signature>(x:bit):sht </signature>
    <implementation> CALCbit2sht;</implementation>
  </instantiation>
  <instantiation>
    <signature>(x:oid):sht </signature>
    <implementation> CALCoid2sht;</implementation>
  </instantiation>
  </command>
  <command  name="void">
  <instantiation>
    <signature>(v:lng):void </signature>
    <implementation> CALClng2void;</implementation>
  </instantiation>
  <instantiation>
    <signature>(v:sht):void </signature>
    <implementation> CALCsht2void;</implementation>
  </instantiation>
  <instantiation>
    <signature>(v:int):void </signature>
    <implementation> CALCint2void;</implementation>
  </instantiation>
  <instantiation>
    <signature>(v:void):void </signature>
    <implementation> CALCnil2void;</implementation>
  </instantiation>
  </command>
  <command  name="xor">
  <instantiation>
    <signature>(left:lng,right:lng):lng </signature>
    <implementation> CALCbinaryXORlnglng;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:int,right:int):int </signature>
    <implementation> CALCbinaryXORintint;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:sht,right:sht):sht </signature>
    <implementation> CALCbinaryXORshtsht;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:chr,right:chr):chr </signature>
    <implementation> CALCbinaryXORchrchr;</implementation>
  </instantiation>
  <instantiation>
    <signature>(left:bit,right:bit):bit </signature>
    <implementation> CALCbinaryXORbit;</implementation>
  </instantiation>
  </command>
</module>
<module name="chopper">
  <pattern  name="getTail">
    <comment>return the BUN tail value using the 
	cursor.</comment>
  <instantiation>
    <signature>(b:bat[:any,:any\$1],i:lng):any\$1 </signature>
    <implementation> CHPgetTail;</implementation>
  </instantiation>
  </pattern>
  <pattern  name="getHead">
    <comment>return the BUN head value using the 
	cursor.</comment>
  <instantiation>
    <signature>(b:bat[:any\$1,:any],i:lng):any\$1 </signature>
    <implementation> CHPgetHead;</implementation>
  </instantiation>
  </pattern>
  <pattern  name="hasMoreElements">
    <comment>Produce the next bun for processing.</comment>
  <instantiation>
    <signature>(b:bat[:any\$1,:any\$2]) (\$2:lng,h:any\$1,t:any\$2) </signature>
    <implementation> CHPbunHasMoreElements;</implementation>
  </instantiation>
  </pattern>
  <command  name="hasMoreChunks">
    <comment>Produce the next chunk for processing.</comment>
  <instantiation>
    <signature>(b:bat[:any\$1,:any\$2],size:lng) (\$3:lng,\$4:bat[:any\$1,:any\$2]) </signature>
    <implementation> CHPhasMoreChunks;</implementation>
  </instantiation>
  </command>
  <pattern  name="newIterator">
    <comment>Process the buns one by one.</comment>
  <instantiation>
    <signature>(b:bat[:any\$1,:any\$2]) (\$2:lng,h:any\$1,t:any\$2) </signature>
    <implementation> CHPbunIterator;</implementation>
  </instantiation>
  </pattern>
  <command  name="newChunkIterator">
    <comment> Create an iterator with fixed granule size.
	  The result is a view.</comment>
  <instantiation>
    <signature>(b:bat[:any\$1,:any\$2],size:lng) (\$3:lng,\$4:bat[:any\$1,:any\$2]) </signature>
    <implementation> CHPnewChunkIterator;</implementation>
  </instantiation>
  </command>
</module>
<module name="clients">
  <command  name="clearDebug">
    <comment>Clear the flag in the debugging bitset</comment>
  <instantiation>
    <signature>(flg:int):void </signature>
    <implementation> CLTclearDebug;</implementation>
  </instantiation>
  </command>
  <command  name="getScenario">
    <comment>Retrieve current scenario name</comment>
  <instantiation>
    <signature>():str </signature>
    <implementation> CLTgetScenario;</implementation>
  </instantiation>
  </command>
  <command  name="getLogins">
    <comment>Pseudo bat of client login time</comment>
  <instantiation>
    <signature>():bat[:int,:str] </signature>
    <implementation> CLTLogin;</implementation>
  </instantiation>
  </command>
  <command  name="getUsers">
    <comment>Pseudo bat of users logged in</comment>
  <instantiation>
    <signature>():bat[:int,:str] </signature>
    <implementation> CLTusers;</implementation>
  </instantiation>
  </command>
  <command  name="info">
    <comment>Pseudo bat with client attributes</comment>
  <instantiation>
    <signature>():bat[:int,:str] </signature>
    <implementation> CLTInfo;</implementation>
  </instantiation>
  </command>
  <command  name="quit">
    <comment>Terminate the session for this client</comment>
  <instantiation>
    <signature>():void </signature>
    <implementation> CLTquit;</implementation>
  </instantiation>
  </command>
  <command  name="setScenario">
    <comment>Switch to other scenario handler, 
	return previous one</comment>
  <instantiation>
    <signature>(msg:str):str </signature>
    <implementation> CLTsetScenario;</implementation>
  </instantiation>
  </command>
  <command  name="setDebug">
    <comment>Set the flag in the debugging bitset.
	See configuration file and documentation</comment>
  <instantiation>
    <signature>(flg:int):void </signature>
    <implementation> CLTsetDebug;</implementation>
  </instantiation>
  </command>
  <command  name="setListing">
    <comment>Turn on/off echo of MAL instructions:
	2 - show mal instruction,
	4 - show type resolutoin, 
	8 - show binding information</comment>
  <instantiation>
    <signature>(flg:int):int </signature>
    <implementation> CLTsetListing;</implementation>
  </instantiation>
  </command>
</module>
<module name="const">
The const module provides a box 
abstraction store for global constants.
Between sessions the value of the constants 
is saved on disk in the form of a simple 
mal program, which is scanned and made 
available by opening the box.  A future 
implementation should provide transaction 
support over the box, which would permit 
multiple clients to exchange (scalar) 
information easily.
  <pattern  name="close">
    <comment>Close the constant box </comment>
  <instantiation>
    <signature>():void </signature>
    <implementation> CSTclose;</implementation>
  </instantiation>
  </pattern>
  <pattern  name="discard">
    <comment>Release the const from the box</comment>
  <instantiation>
    <signature>(name:any):void </signature>
    <implementation> CSTdiscard;</implementation>
  </instantiation>
  </pattern>
  <pattern  name="deposit">
    <comment>Enter a new variable into the box</comment>
  <instantiation>
    <signature>(name:any):void </signature>
    <implementation> CSTdeposit;</implementation>
  </instantiation>
  </pattern>
  <pattern  name="destroy">
    <comment>Destroy the box</comment>
  <instantiation>
    <signature>():void </signature>
    <implementation> CSTdestroy;</implementation>
  </instantiation>
  </pattern>
  <pattern  name="hasMoreElements">
    <comment>Locate next element in the box</comment>
  <instantiation>
    <signature>() (\$1:lng,\$2:str) </signature>
    <implementation> CSThasMoreElements;</implementation>
  </instantiation>
  </pattern>
  <pattern  name="newIterator">
    <comment>Locate next element in the box</comment>
  <instantiation>
    <signature>() (\$1:lng,\$2:str) </signature>
    <implementation> CSTnewIterator;</implementation>
  </instantiation>
  </pattern>
  <pattern  name="open">
    <comment>Locate and open the constant box</comment>
  <instantiation>
    <signature>():void </signature>
    <implementation> CSTopen;</implementation>
  </instantiation>
  </pattern>
  <pattern  name="prelude">
    <comment>Initialize the const box</comment>
  <instantiation>
    <signature>():void </signature>
    <implementation> CSTprelude;</implementation>
  </instantiation>
  </pattern>
  <pattern  name="release">
    <comment>Release a new constant value</comment>
  <instantiation>
    <signature>(name:any):void </signature>
    <implementation> CSTrelease;</implementation>
  </instantiation>
  <instantiation>
    <signature>(name:str):void </signature>
    <implementation> CSTrelease;</implementation>
  </instantiation>
  </pattern>
  <pattern  name="releaseAll">
    <comment>Release all variables in the box</comment>
  <instantiation>
    <signature>():void </signature>
    <implementation> CSTreleaseAll;</implementation>
  </instantiation>
  </pattern>
  <pattern  name="toString">
    <comment>Get the string representation 
	of an element in the box</comment>
  <instantiation>
    <signature>(name:any):str </signature>
    <implementation> CSTtoString;</implementation>
  </instantiation>
  </pattern>
  <pattern  name="take">
    <comment>Take a variable out of the box</comment>
  <instantiation>
    <signature>(name:any):any </signature>
    <implementation> CSTtake;</implementation>
  </instantiation>
  </pattern>
</module>
<module name="crackers">
  <command  name="crack">
    <comment>Break the partitions into smaller pieces
	using a join over the tail</comment>
  <instantiation>
    <signature>(b:bat[:int,:int],c:bat[:int,:int]):int </signature>
    <implementation> CRKcrackJoin;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:int,:int],low:int,hgh:int):int </signature>
    <implementation> CRKcrackRange;</implementation>
  </instantiation>
  </command>
  <command  name="dropView">
    <comment>Garbage collect the piece representation.
	Should be a side-effect of dropping the bat!</comment>
  <instantiation>
    <signature>(b:bat[:int,:int]):void </signature>
    <implementation> CRKdropView;</implementation>
  </instantiation>
  </command>
  <command  name="drop">
    <comment>Garbage collect the piece representation</comment>
  <instantiation>
    <signature>(b:bat[:int,:int]):void </signature>
    <implementation> CRKdropPiece;</implementation>
  </instantiation>
  </command>
  <command  name="getPiece">
    <comment>Retrieve a piece of a cracked
	BAT into a known BAT view.</comment>
  <instantiation>
    <signature>(b:bat[:int,:int],crk:bat[:int,:int],piece:int):void </signature>
    <implementation> CRKgetPiece1;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:int,:int],piece:int):bat[:int,:int] </signature>
    <implementation> CRKgetPiece0;</implementation>
  </instantiation>
  </command>
  <command  name="hasMoreElements">
    <comment>Retrieve the next piece of a cracked
	BAT by adjusting the BAT view descriptor.
	It returns the next valid piece id.
	A value zero means 'end-of-sequence'</comment>
  <instantiation>
    <signature>(b:bat[:int,:int]) (a:int,x:bat[:int,:int]) </signature>
    <implementation> CRKhasMoreElements;</implementation>
  </instantiation>
  </command>
  <command  name="info">
    <comment>Print the cracker index administration</comment>
  <instantiation>
    <signature>(b:bat[:int,:int]):void </signature>
    <implementation> CRKinfo;</implementation>
  </instantiation>
  </command>
  <command  name="newIterator">
    <comment>Retrieve the first piece of a cracked
	BAT as a BAT view and also return the
	identity of the next piece.</comment>
  <instantiation>
    <signature>(b:bat[:int,:int]) (a:int,x:bat[:int,:int]) </signature>
    <implementation> CRKnewIterator;</implementation>
  </instantiation>
  </command>
  <command  name="new">
    <comment>Create the index tables for a cracked
	table. Set the minimum granularity</comment>
  <instantiation>
    <signature>(b:bat[:int,:int],granule:int):void </signature>
    <implementation> CRKnewGranule;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:int,:int]):void </signature>
    <implementation> CRKnew;</implementation>
  </instantiation>
  </command>
  <command  name="select">
    <comment>Retrieve the subset using a cracker
	index producing preferably a BATview.</comment>
  <instantiation>
    <signature>(b:bat[:int,:int],l:int,h:int,li:bit,hi:bit):bat[:int,:int] </signature>
    <implementation> CRKselect;</implementation>
  </instantiation>
  </command>
  <command  name="selectPieces">
    <comment>Retrieve identities of all pieces
	that qualify the selection criterion.</comment>
  <instantiation>
    <signature>(b:bat[:int,:int],low:int,hgh:int):bat[:void,:int] </signature>
    <implementation> CRKselectPieces;</implementation>
  </instantiation>
  </command>
</module>
<atommodule name="date">
  <command  name="!=">
    <comment>Equality of two dates</comment>
  <instantiation>
    <signature>(v:date,w:date):bit </signature>
    <implementation> MTIMEdate\_NEQ;</implementation>
  </instantiation>
  </command>
  <command  name="$&lt;$=">
    <comment>Equality of two dates</comment>
  <instantiation>
    <signature>(v:date,w:date):bit </signature>
    <implementation> MTIMEdate\_LE;</implementation>
  </instantiation>
  </command>
  <command  name="$&lt;$">
    <comment>Equality of two dates</comment>
  <instantiation>
    <signature>(v:date,w:date):bit </signature>
    <implementation> MTIMEdate\_LT;</implementation>
  </instantiation>
  </command>
  <command  name="=">
    <comment>Equality of two dates</comment>
  <instantiation>
    <signature>(v:date,w:date):bit </signature>
    <implementation> MTIMEdate\_EQ;</implementation>
  </instantiation>
  </command>
  <command  name="$&gt;$=">
    <comment>Equality of two dates</comment>
  <instantiation>
    <signature>(v:date,w:date):bit </signature>
    <implementation> MTIMEdate\_GE;</implementation>
  </instantiation>
  </command>
  <command  name="$&gt;$">
    <comment>Equality of two dates</comment>
  <instantiation>
    <signature>(v:date,w:date):bit </signature>
    <implementation> MTIMEdate\_GT;</implementation>
  </instantiation>
  </command>
  <command  name="MTIMEdate\_add\_sec\_interval">
    <comment>Add seconds to a date</comment>
  <instantiation>
    <signature>(t:date,s:int):date </signature>
    <implementation> MTIMEdate\_add\_sec\_interval\_wrap;</implementation>
  </instantiation>
  </command>
  <command  name="date\_add\_month\_interval">
    <comment>Add months to a date</comment>
  <instantiation>
    <signature>(t:date,s:int):date </signature>
    <implementation> MTIMEdate\_add\_month\_interval\_wrap;</implementation>
  </instantiation>
  </command>
  <command  name="date\_sub\_sec\_interval">
    <comment>Subtract seconds from a date</comment>
  <instantiation>
    <signature>(t:date,s:int):date </signature>
    <implementation> MTIMEdate\_sub\_sec\_interval\_wrap;</implementation>
  </instantiation>
  </command>
  <command  name="fromstr">
  <instantiation>
    <signature>():date </signature>
    <implementation> date\_fromstr;</implementation>
  </instantiation>
  </command>
  <command  name="isnil">
    <comment>Nil test for date value</comment>
  <instantiation>
    <signature>(v:date):bit </signature>
    <implementation> MTIMEdate\_isnil;</implementation>
  </instantiation>
  </command>
  <command  name="tostr">
  <instantiation>
    <signature>():str </signature>
    <implementation> date\_tostr;</implementation>
  </instantiation>
  </command>
</atommodule>
<atommodule name="daytime">
  <command  name="!=">
    <comment>Equality of two daytimes</comment>
  <instantiation>
    <signature>(v:daytime,w:daytime):bit </signature>
    <implementation> MTIMEdaytime\_NEQ;</implementation>
  </instantiation>
  </command>
  <command  name="$&lt;$=">
    <comment>Equality of two daytimes</comment>
  <instantiation>
    <signature>(v:daytime,w:daytime):bit </signature>
    <implementation> MTIMEdaytime\_LE;</implementation>
  </instantiation>
  </command>
  <command  name="$&lt;$">
    <comment>Equality of two daytimes</comment>
  <instantiation>
    <signature>(v:daytime,w:daytime):bit </signature>
    <implementation> MTIMEdaytime\_LT;</implementation>
  </instantiation>
  </command>
  <command  name="=">
    <comment>Equality of two daytimes</comment>
  <instantiation>
    <signature>(v:daytime,w:daytime):bit </signature>
    <implementation> MTIMEdaytime\_EQ;</implementation>
  </instantiation>
  </command>
  <command  name="$&gt;$=">
    <comment>Equality of two daytimes</comment>
  <instantiation>
    <signature>(v:daytime,w:daytime):bit </signature>
    <implementation> MTIMEdaytime\_GE;</implementation>
  </instantiation>
  </command>
  <command  name="$&gt;$">
    <comment>Equality of two daytimes</comment>
  <instantiation>
    <signature>(v:daytime,w:daytime):bit </signature>
    <implementation> MTIMEdaytime\_GT;</implementation>
  </instantiation>
  </command>
  <command  name="fromstr">
  <instantiation>
    <signature>():daytime </signature>
    <implementation> daytime\_fromstr;</implementation>
  </instantiation>
  </command>
  <command  name="isnil">
    <comment>Nil test for daytime value</comment>
  <instantiation>
    <signature>(v:daytime):bit </signature>
    <implementation> MTIMEdaytime\_isnil;</implementation>
  </instantiation>
  </command>
  <command  name="tostr">
  <instantiation>
    <signature>():str </signature>
    <implementation> daytime\_tostr;</implementation>
  </instantiation>
  </command>
</atommodule>
<module name="enum">
  <pattern  name="create">
    <comment>Associate a value set with an enumerated type.</comment>
  <instantiation>
    <signature>(e:any\$2,src:bat[:any,:any\$1]):bat[:any\$1,:any\$2] </signature>
    <implementation> ENUMcreate;</implementation>
  </instantiation>
  </pattern>
  <pattern  name="decode">
    <comment>Decode a BAT of tail values
	into a new BAT of decoded values</comment>
  <instantiation>
    <signature>(b:bat[:any\$2,:any\$1]):bat[:any\$2,:any] </signature>
    <implementation> ENUMdecode\_multi;</implementation>
  </instantiation>
  <instantiation>
    <signature>(e:any):any </signature>
    <implementation> ENUMdecode;</implementation>
  </instantiation>
  </pattern>
  <pattern  name="destroy">
    <comment>Destroy an enumeration type</comment>
  <instantiation>
    <signature>(map:any):void </signature>
    <implementation> ENUMdestroy;</implementation>
  </instantiation>
  </pattern>
  <pattern  name="encode">
    <comment>Encode a BAT of tail values into 
	a new BAT of encoded values.This action is 
	actually a join operation.</comment>
  <instantiation>
    <signature>(e:any\$2,b:bat[:any\$1,:any]):bat[:any\$1,:any\$2] </signature>
    <implementation> ENUMencode\_multi;</implementation>
  </instantiation>
  <instantiation>
    <signature>(e:any\$1,v:any\$2):any\$1 </signature>
    <implementation> ENUMencode;</implementation>
  </instantiation>
  </pattern>
  <pattern  name="getTable">
    <comment>Return the enumeration BAT</comment>
  <instantiation>
    <signature>(e:any):bat[:any,:any] </signature>
    <implementation> ENUMtable;</implementation>
  </instantiation>
  </pattern>
  <pattern  name="isHistogram">
    <comment>returns whether ENUMtable(tpe) is 
	a histogram on b's head column</comment>
  <instantiation>
    <signature>(tpe:any,b:bat[:any,:any]):bit </signature>
    <implementation> ENUMishisto;</implementation>
  </instantiation>
  </pattern>
  <command  name="isEnum">
    <comment>Returns true iff the bat is 
	used as an enumerated type</comment>
  <instantiation>
    <signature>(tpe:bat[:any,:any]):bit </signature>
    <implementation> isEnum;</implementation>
  </instantiation>
  </command>
  <pattern  name="lower">
    <comment>Encode to the lowest value in the encoded 
	domain that is equal to or larger than v</comment>
  <instantiation>
    <signature>(e:any\$1,v:any):any\$1 </signature>
    <implementation> ENUMlower;</implementation>
  </instantiation>
  </pattern>
  <pattern  name="loadEncoding">
    <comment>Load/activate an enumeration type.</comment>
  <instantiation>
    <signature>(map:any\$1):bat[:any,:any\$1] </signature>
    <implementation> ENUMload;</implementation>
  </instantiation>
  </pattern>
  <pattern  name="setHistogram">
    <comment>registers the fact that ENUMtable(tpe) 
	is a histogram on b's head column</comment>
  <instantiation>
    <signature>(tpe:any\$1,b:bat[:any,:any]):void </signature>
    <implementation> ENUMsethisto;</implementation>
  </instantiation>
  </pattern>
  <pattern  name="upper">
    <comment>Encode to the highest value in 
	the encoded domain that is 
	equal to or less than v</comment>
  <instantiation>
    <signature>(e:any\$1,v:any):any\$1 </signature>
    <implementation> ENUMupper;</implementation>
  </instantiation>
  </pattern>
</module>
<module name="group">
  <command  name="avg">
    <comment>grouped tail average</comment>
  <instantiation>
    <signature>(b:bat[:int,:dbl],e:bat[:int,:any]):bat[:int,:dbl] </signature>
    <implementation> GRPavg\_dbl;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$2,:flt],e:bat[:any\$2,:any]):bat[:any\$2,:flt] </signature>
    <implementation> GRPavg\_flt;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$2,:lng],e:bat[:any\$2,:any]):bat[:any\$2,:lng] </signature>
    <implementation> GRPavg\_lng;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$2,:int],e:bat[:any\$2,:any]):bat[:any\$2,:int] </signature>
    <implementation> GRPavg\_int;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$2,:sht],e:bat[:any\$2,:any]):bat[:any\$2,:sht] </signature>
    <implementation> GRPavg\_sht;</implementation>
  </instantiation>
  </command>
  <command  name="count">
    <comment>grouped count</comment>
  <instantiation>
    <signature>(b:bat[:any\$2,:any],e:bat[:any\$2,:any],nonils:bit):bat[:any\$2,:int] </signature>
    <implementation> GRPaggr\_count;</implementation>
  </instantiation>
  </command>
  <command  name="group">
  <instantiation>
    <signature>(ct:bat[:any\$2,:any],attr:bat[:any\$2,:any\$1]):bat[:any\$2,:oid] </signature>
    <implementation> GRPderive2;</implementation>
  </instantiation>
  <instantiation>
    <signature>(ct:bat[:any\$2,:any],attr:bat[:any\$2,:any\$1]) (map:bat[:any\$1,:oid],grp:bat[:any\$2,:oid]) </signature>
    <implementation> GRPderive;</implementation>
  </instantiation>
  <instantiation>
    <signature>(attr:bat[:any\$2,:any\$1]):bat[:any\$2,:oid] </signature>
    <implementation> GRPgroup2;</implementation>
  </instantiation>
  <instantiation>
    <signature>(attr:bat[:any\$2,:any\$1]) (histo:bat[:any\$1,:int],grp:bat[:any\$2,:oid]) </signature>
    <implementation> GRPgroup;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$1,:any],start:int,incr:int,grpsize:int):bat[:any\$1,:int] </signature>
    <implementation> GRPgroup0;</implementation>
  </instantiation>
  </command>
  <command  name="max">
    <comment>grouped tail maximum</comment>
  <instantiation>
    <signature>(b:bat[:any\$2,:any\$1],e:bat[:any\$2,:any]):bat[:any\$2,:any\$1] </signature>
    <implementation> GRPmax;</implementation>
  </instantiation>
  </command>
  <command  name="min">
    <comment>grouped tail minimum</comment>
  <instantiation>
    <signature>(b:bat[:any\$2,:any\$1],e:bat[:any\$2,:any]):bat[:any\$2,:any\$1] </signature>
    <implementation> GRPmin;</implementation>
  </instantiation>
  </command>
  <command  name="prelude">
  <instantiation>
    <signature>():void </signature>
    <implementation> GRPprelude;</implementation>
  </instantiation>
  </command>
  <command  name="refine">
    <comment>refine the ordering of a tail-ordered 
	 BAT by sub-ordering on the values of a 
	 second bat 'a' (where the heads of a and 
	 b match 1-1).  The effect of this is similar 
	 to (hash-based) GRPderive, with the distinction 
	 that the group ids respect the ordering 
	 of the group values.</comment>
  <instantiation>
    <signature>(b:bat[:any\$2,:any],a:bat[:any\$2,:any]):bat[:any\$2,:oid] </signature>
    <implementation> GRPrefine;</implementation>
  </instantiation>
  </command>
  <command  name="regroup">
    <comment>Performs a regrouping, modifying ct doing a group</comment>
  <instantiation>
    <signature>(ct:bat[:any\$2,:oid],attr:bat[:any\$2,:any]):bat[:any\$2,:oid] </signature>
    <implementation> GRPregroup;</implementation>
  </instantiation>
  </command>
  <command  name="size">
    <comment>grouped count of true values</comment>
  <instantiation>
    <signature>(b:bat[:any\$2,:bit],e:bat[:any\$2,:any]):bat[:any\$2,:int] </signature>
    <implementation> GRPsize;</implementation>
  </instantiation>
  </command>
  <command  name="sum">
    <comment>grouped tail sum</comment>
  <instantiation>
    <signature>(b:bat[:any\$2,:dbl],e:bat[:any\$2,:any]):bat[:any\$2,:dbl] </signature>
    <implementation> GRPsum\_dbl;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$2,:flt],e:bat[:any\$2,:any]):bat[:any\$2,:flt] </signature>
    <implementation> GRPsum\_flt;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$2,:lng],e:bat[:any\$2,:any]):bat[:any\$2,:lng] </signature>
    <implementation> GRPsum\_lng;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$2,:int],e:bat[:any\$2,:any]):bat[:any\$2,:int] </signature>
    <implementation> GRPsum\_int;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any\$2,:sht],e:bat[:any\$2,:any]):bat[:any\$2,:sht] </signature>
    <implementation> GRPsum\_sht;</implementation>
  </instantiation>
  </command>
</module>
<module name="inspect">
  <command  name="getAtoms">
    <comment>Collect a BAT with the atom names</comment>
  <instantiation>
    <signature>():bat[:int,:str] </signature>
    <implementation> INSPECTatom\_names;</implementation>
  </instantiation>
  </command>
  <command  name="getTypeName">
  <instantiation>
    <signature>(v:int):str </signature>
    <implementation> INSPECTtypename;</implementation>
  </instantiation>
  </command>
  <pattern  name="getType">
    <comment>Return the type of a variable (expression)</comment>
  <instantiation>
    <signature>(v:any):int </signature>
    <implementation> INSPECTtype;</implementation>
  </instantiation>
  <instantiation>
    <signature>(mod:str,fcn:str):bat[:str,:str] </signature>
    <implementation> INSPECTsymbolType;</implementation>
  </instantiation>
  </pattern>
  <command  name="getSignature">
    <comment>Returns the function signature(s)</comment>
  <instantiation>
    <signature>(mod:str,fcn:str):bat[:str,:str] </signature>
    <implementation> INSPECTsymbolSignature;</implementation>
  </instantiation>
  </command>
  <command  name="getDefinition">
    <comment>Returns a string representation 
	of a specific function</comment>
  <instantiation>
    <signature>(mod:str,fcn:str):bat[:int,:str] </signature>
    <implementation> INSPECTsymbolDef;</implementation>
  </instantiation>
  <instantiation>
    <signature>():bat[:void,:str] </signature>
    <implementation> INSPECTcurrSymbolDef;</implementation>
  </instantiation>
  </command>
  <pattern  name="getCode">
    <comment>Returns a string representation 
	of the current function 
	with typing information attached</comment>
  <instantiation>
    <signature>():bat[:void,:str] </signature>
    <implementation> INSPECTcodeDump;</implementation>
  </instantiation>
  </pattern>
  <command  name="getFunctions">
    <comment>Map module and function pairs</comment>
  <instantiation>
    <signature>():bat[:str,:str] </signature>
    <implementation> INSPECTfunctionNames;</implementation>
  </instantiation>
  </command>
  <command  name="getCommands">
    <comment>Map module and commands pairs</comment>
  <instantiation>
    <signature>():bat[:str,:str] </signature>
    <implementation> INSPECTcommandNames;</implementation>
  </instantiation>
  </command>
  <command  name="getPatterns">
    <comment>Map module and pattern pairs</comment>
  <instantiation>
    <signature>():bat[:str,:str] </signature>
    <implementation> INSPECTpatternNames;</implementation>
  </instantiation>
  </command>
  <command  name="getModules">
    <comment>Collect bat with all modules loaded</comment>
  <instantiation>
    <signature>():bat[:void,:str] </signature>
    <implementation> INSPECTmoduleNames;</implementation>
  </instantiation>
  </command>
  <pattern  name="getStackTrace">
  <instantiation>
    <signature>():bat[:void,:str] </signature>
    <implementation> INSPECTStkTrace;</implementation>
  </instantiation>
  </pattern>
  <pattern  name="getStackFrame">
    <comment>Collect variable binding of current 
	(n-th) stack frame.</comment>
  <instantiation>
    <signature>():bat[:str,:str] </signature>
    <implementation> INSPECTStkFrame;</implementation>
  </instantiation>
  <instantiation>
    <signature>(i:int):bat[:str,:str] </signature>
    <implementation> INSPECTStkFrameN;</implementation>
  </instantiation>
  </pattern>
  <pattern  name="getStackDepth">
    <comment>Return the depth of the calling stack.</comment>
  <instantiation>
    <signature>():int </signature>
    <implementation> INSPECTStkDepth;</implementation>
  </instantiation>
  </pattern>
  <command  name="help">
    <comment>Collect the comments for a given 
	function pattern</comment>
  <instantiation>
    <signature>(mod:str,fcn:str):bat[:int,:str] </signature>
    <implementation> INSPECThelp2;</implementation>
  </instantiation>
  <instantiation>
    <signature>(k:str):bat[:str,:str] </signature>
    <implementation> INSPECThelp;</implementation>
  </instantiation>
  </command>
  <pattern  name="mdb">
    <comment>Start interactive debugger</comment>
  <instantiation>
    <signature>():void </signature>
    <implementation> mdbToggle;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b:bit):void </signature>
    <implementation> mdbToggle;</implementation>
  </instantiation>
  <instantiation>
    <signature>(c:chr):void </signature>
    <implementation> mdbSetCmd;</implementation>
  </instantiation>
  </pattern>
  <command  name="manual">
    <comment>Produces a XML-formatted manual 
	over all modules loaded.</comment>
  <instantiation>
    <signature>():void </signature>
    <implementation> INSPECTmanual0;</implementation>
  </instantiation>
  <instantiation>
    <signature>(mod:str):void </signature>
    <implementation> INSPECTmanual1;</implementation>
  </instantiation>
  <instantiation>
    <signature>(file:str,mod:str,recursive:int):void </signature>
    <implementation> INSPECTmanual;</implementation>
  </instantiation>
  <instantiation>
    <signature>(file:str,mod:str):void </signature>
    <implementation> INSPECTmanual2;</implementation>
  </instantiation>
  </command>
  <pattern  name="showFunction">
    <comment>Dump the current routine on standard out.</comment>
  <instantiation>
    <signature>():void </signature>
    <implementation> INSPECTshowFunction3;</implementation>
  </instantiation>
  </pattern>
</module>
<module name="io">
  <command  name="export">
    <comment>Export a BAT as ASCII to a file. If the 'filepath' is not absolute, it
 is put into the .../dbfarm/\$DB directory. Success of failure is indicated.</comment>
  <instantiation>
    <signature>(b:bat[:any,:any],filepath:str):bit </signature>
    <implementation> IOexport;</implementation>
  </instantiation>
  </command>
  <pattern  name="ftable">
    <comment>Print an n-ary table to a file.</comment>
  <instantiation>
    <signature>(fp:any,order:int,b1:bat[:any\$1,:any],b:bat[:any\$1,:any]...):void </signature>
    <implementation> IOfotable;</implementation>
  </instantiation>
  <instantiation>
    <signature>(filep:any,b1:bat[:any\$1,:any],b:bat[:any\$1,:any]...):int </signature>
    <implementation> IOftable;</implementation>
  </instantiation>
  </pattern>
  <command  name="import">
    <comment>Import a BAT from an ASCII dump. The new tuples are *inserted* into the
 parameter BAT. You have to create it! Its signature must match the dump,
 else parsing errors will occur and FALSE is returned.</comment>
  <instantiation>
    <signature>(b:bat[:any,:any],filepath:str):bit </signature>
    <implementation> IOimport;</implementation>
  </instantiation>
  </command>
  <command  name="printf">
  <instantiation>
    <signature>(format:str,val:str):int </signature>
    <implementation> IOprint\_formatted\_str;</implementation>
  </instantiation>
  <instantiation>
    <signature>(val:str):int </signature>
    <implementation> IOprint\_str;</implementation>
  </instantiation>
  <instantiation>
    <signature>(format:str,val:dbl):int </signature>
    <implementation> IOprint\_formatted\_dbl;</implementation>
  </instantiation>
  <instantiation>
    <signature>(format:str,val:flt):int </signature>
    <implementation> IOprint\_formatted\_flt;</implementation>
  </instantiation>
  <instantiation>
    <signature>(format:str,val:lng):int </signature>
    <implementation> IOprint\_formatted\_lng;</implementation>
  </instantiation>
  <instantiation>
    <signature>(format:str,val:oid):int </signature>
    <implementation> IOprint\_oid;</implementation>
  </instantiation>
  <instantiation>
    <signature>(format:str,val:sht):int </signature>
    <implementation> IOprint\_formatted\_sht;</implementation>
  </instantiation>
  <instantiation>
    <signature>(format:str,val:int):int </signature>
    <implementation> IOprint\_formatted\_int;</implementation>
  </instantiation>
  <instantiation>
    <signature>(format:str,val:chr):int </signature>
    <implementation> IOprint\_formatted\_chr;</implementation>
  </instantiation>
  <instantiation>
    <signature>(format:str,val:bit):int </signature>
    <implementation> IOprint\_formatted\_bit;</implementation>
  </instantiation>
  </command>
  <pattern  name="printft">
    <comment>Select default format </comment>
  <instantiation>
    <signature>(val:any):int </signature>
    <implementation> IOprint\_ft;</implementation>
  </instantiation>
  </pattern>
  <pattern  name="prompt">
    <comment>Print a MIL value without brackets.</comment>
  <instantiation>
    <signature>(val:any):int </signature>
    <implementation> IOprompt\_val;</implementation>
  </instantiation>
  </pattern>
  <pattern  name="print">
    <comment>Print a MIL value tuple .</comment>
  <instantiation>
    <signature>(val:any):int </signature>
    <implementation> IOprint\_val;</implementation>
  </instantiation>
  <instantiation>
    <signature>(order:int,b:bat[:any\$1,:any],b2:bat[:any\$1,:any]...):int </signature>
    <implementation> IOotable;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b1:bat[:any\$1,:any],b2:bat[:any\$1,:any]...):int </signature>
    <implementation> IOtable;</implementation>
  </instantiation>
  </pattern>
  <pattern  name="table">
    <comment>Print an n-ary table.</comment>
  <instantiation>
    <signature>(order:int,b1:bat[:any\$1,:any],b2:bat[:any\$1,:any]...):int </signature>
    <implementation> IOtotable;</implementation>
  </instantiation>
  <instantiation>
    <signature>(b1:bat[:any\$1,:any],b2:bat[:any\$1,:any]...):int </signature>
    <implementation> IOttable;</implementation>
  </instantiation>
  </pattern>
</module>
<atommodule name="lock">
  <command  name="create">
    <comment>Create an unset lock</comment>
  <instantiation>
    <signature>():lock </signature>
    <implementation> LCKcreate;</implementation>
  </instantiation>
  </command>
  <command  name="destroy">
    <comment>Destroy a lock</comment>
  <instantiation>
    <signature>(l:lock):void </signature>
    <implementation> LCKdestroy;</implementation>
  </instantiation>
  </command>
  <command  name="set">
    <comment>Try to set a lock; if set, 
	block till it is freed</comment>
  <instantiation>
    <signature>(l:lock):void </signature>
    <implementation> LCKset;</implementation>
  </instantiation>
  </command>
  <command  name="tostr">
    <comment>Overloaded atom function</comment>
  <instantiation>
    <signature>(l:lock):void </signature>
    <implementation> lockToStr;</implementation>
  </instantiation>
  </command>
  <command  name="try">
    <comment>Try a lock, if free set it, 
	if not return EBUSY</comment>
  <instantiation>
    <signature>(l:lock):int </signature>
    <implementation> LCKtry;</implementation>
  </instantiation>
  </command>
  <command  name="unset">
    <comment>Unset a lock</comment>
  <instantiation>
    <signature>(l:lock):void </signature>
    <implementation> LCKunset;</implementation>
  </instantiation>
  </command>
</atommodule>
<module name="mal">
  <pattern  name="call">
    <comment>Evaluate a program stored in a BAT</comment>
  <instantiation>
    <signature>(s:bat[:any,:str]):void </signature>
    <implementation> CMDcallBAT;</implementation>
  </instantiation>
  <instantiation>
    <signature>(s:str):void </signature>
    <implementation> CMDcallString;</implementation>
  </instantiation>
  </pattern>
  <pattern  name="include">
    <comment>Merge the instructions stored in the 
	file with the current program</comment>
  <instantiation>
    <signature>(f:str):void </signature>
    <implementation> CMDincludeFile;</implementation>
  </instantiation>
  </pattern>
  <command  name="nextElement">
    <comment>Advances the iterator with a fixed value
	until it becomes $&gt;$= last.</comment>
  <instantiation>
    <signature>(step:dbl,last:dbl) (\$3:bit,\$4:dbl) </signature>
    <implementation> RNGnextElement\_dbl;</implementation>
  </instantiation>
  <instantiation>
    <signature>(step:flt,last:flt) (\$3:bit,\$4:flt) </signature>
    <implementation> RNGnextElement\_flt;</implementation>
  </instantiation>
  <instantiation>
    <signature>(step:lng,last:lng) (\$3:bit,\$4:lng) </signature>
    <implementation> RNGnextElement\_lng;</implementation>
  </instantiation>
  <instantiation>
    <signature>(step:int,last:int) (\$3:bit,\$4:int) </signature>
    <implementation> RNGnextElement\_int;</implementation>
  </instantiation>
  <instantiation>
    <signature>(step:sht,last:sht) (\$3:bit,\$4:sht) </signature>
    <implementation> RNGnextElement\_sht;</implementation>
  </instantiation>
  <instantiation>
    <signature>(step:int,last:chr) (\$3:bit,\$4:chr) </signature>
    <implementation> RNGnextElement\_chr;</implementation>
  </instantiation>
  <instantiation>
    <signature>(step:oid,last:oid) (\$3:bit,\$4:oid) </signature>
    <implementation> RNGnextElement\_oid;</implementation>
  </instantiation>
  </command>
  <command  name="newRange">
    <comment>This routine introduces an iterator
	over a scalar domain.</comment>
  <instantiation>
    <signature>(v:dbl) (\$2:bit,\$3:dbl) </signature>
    <implementation> RNGnewRange\_dbl;</implementation>
  </instantiation>
  <instantiation>
    <signature>(v:flt) (\$2:bit,\$3:flt) </signature>
    <implementation> RNGnewRange\_flt;</implementation>
  </instantiation>
  <instantiation>
    <signature>(v:lng) (\$2:bit,\$3:lng) </signature>
    <implementation> RNGnewRange\_lng;</implementation>
  </instantiation>
  <instantiation>
    <signature>(v:int) (\$2:bit,\$3:int) </signature>
    <implementation> RNGnewRange\_int;</implementation>
  </instantiation>
  <instantiation>
    <signature>(v:sht) (\$2:bit,\$3:sht) </signature>
    <implementation> RNGnewRange\_sht;</implementation>
  </instantiation>
  <instantiation>
    <signature>(v:chr) (\$2:bit,\$3:chr) </signature>
    <implementation> RNGnewRange\_chr;</implementation>
  </instantiation>
  </command>
  <command  name="newRang">
  <instantiation>
    <signature>(v:oid) (\$2:bit,\$3:oid) </signature>
    <implementation> RNGnewRange\_oid;</implementation>
  </instantiation>
  </command>
  <command  name="raise">
    <comment>Raise an exception labelled 
	with a specific message.</comment>
  <instantiation>
    <signature>(msg:str):str </signature>
    <implementation> CMDraise;</implementation>
  </instantiation>
  </command>
  <command  name="source">
    <comment>Execute the program in a (local) file</comment>
  <instantiation>
    <signature>(f:str):void </signature>
    <implementation> CMDevalFile;</implementation>
  </instantiation>
  </command>
</module>
<module name="mapi">
  <command  name="epilogue">
  <instantiation>
    <signature>():void </signature>
    <implementation> mapi\_epilogue;</implementation>
  </instantiation>
  </command>
  <command  name="listen\_ssl">
    <comment>Start the Mapi listener on $&lt;$port$&gt;$ for 
	$&lt;$maxusers$&gt;$ using SSL. $&lt;$keyfile$&gt;$ and 
	$&lt;$certfile$&gt;$ give the path names for files 
	with the server key and certificates in 
	PEM format. For a new client connection 
	MAL procedure $&lt;$cmd$&gt;$(Stream s\_in, Stream s\_out) 
	is called.If no $&lt;$cmd$&gt;$ is specified a new 
	client thread is forked.</comment>
  <instantiation>
    <signature>(port:int,maxusers:int,keyfile:str,certfile:str,cmd:str):int </signature>
    <implementation> MAPIlistenSSL;</implementation>
  </instantiation>
  </command>
  <command  name="listen">
    <comment>Start the Mapi listener on $&lt;$port$&gt;$ for 
	$&lt;$maxusers$&gt;$. For a new client connection 
	MAL procedure $&lt;$cmd$&gt;$(Stream s\_in, Stream s\_out)
	is called.If no $&lt;$cmd$&gt;$ is specified a new 
	client thread is forked.</comment>
  <instantiation>
    <signature>(port:int,maxusers:int,cmd:str):int </signature>
    <implementation> MAPIlisten3;</implementation>
  </instantiation>
  <instantiation>
    <signature>(port:int,maxusers:int):int </signature>
    <implementation> MAPIlisten;</implementation>
  </instantiation>
  <instantiation>
    <signature>(port:lng):int </signature>
    <implementation> MAPIlisten\_port;</implementation>
  </instantiation>
  <instantiation>
    <signature>():int </signature>
    <implementation> MAPIlisten\_default;</implementation>
  </instantiation>
  </command>
  <command  name="prelude">
  <instantiation>
    <signature>():void </signature>
    <implementation> mapi\_prelude;</implementation>
  </instantiation>
  </command>
  <command  name="resume">
    <comment>Resume the interaction with a specific
         client thread</comment>
  <instantiation>
    <signature>(sessionkey:lng):void </signature>
    <implementation> MAPIresume;</implementation>
  </instantiation>
  </command>
  <command  name="suspend">
    <comment>Suspend a client interactiont using a
         user-supplied session key.  The session
         is broken when the timer (in seconds)
         for the reconnect expires.</comment>
  <instantiation>
    <signature>(sessionkey:lng,timeout:lng):void </signature>
    <implementation> MAPIsuspend;</implementation>
  </instantiation>
  </command>
  <command  name="stop">
    <comment>Terminate all sessions of by a client</comment>
  <instantiation>
    <signature>(name:str):bit </signature>
    <implementation> MAPIstopClient;</implementation>
  </instantiation>
  <instantiation>
    <signature>(id:int):bit </signature>
    <implementation> MAPIstop;</implementation>
  </instantiation>
  </command>
  <command  name="trace">
    <comment>Trace (on/off) receipt of messages
         for all users</comment>
  <instantiation>
    <signature>(flag:bit):void </signature>
    <implementation> MAPItrace;</implementation>
  </instantiation>
  <instantiation>
    <signature>(nme:str,flag:bit):void </signature>
    <implementation> MAPItrace2;</implementation>
  </instantiation>
  </command>
</module>
<module name="mil">
The mil module provides a box abstraction to store for global MIL constants.
Between sessions the value of the constants is saved on disk in the form of a
simple mal program, which is scanned and made available by opening the box.
A future implementation should provide transaction support over the box, which
would permit multiple clients to exchange (scalar) information easily.
  <pattern  name="close">
    <comment>Close the MIL constant box </comment>
  <instantiation>
    <signature>():void </signature>
    <implementation> MILclose;</implementation>
  </instantiation>
  </pattern>
  <pattern  name="discard">
    <comment>Release the const from the box</comment>
  <instantiation>
    <signature>(name:any):void </signature>
    <implementation> MILdiscard;</implementation>
  </instantiation>
  </pattern>
  <pattern  name="deposit">
    <comment>Enter a new value into the box</comment>
  <instantiation>
    <signature>(name:any):void </signature>
    <implementation> MILdeposit;</implementation>
  </instantiation>
  </pattern>
  <pattern  name="destroy">
    <comment>Destroy the MIL box</comment>
  <instantiation>
    <signature>():void </signature>
    <implementation> MILdestroy;</implementation>
  </instantiation>
  </pattern>
  <pattern  name="hasMoreElements">
    <comment>Locate next element in the box</comment>
  <instantiation>
    <signature>() (\$1:lng,\$2:str) </signature>
    <implementation> MILhasMoreElements;</implementation>
  </instantiation>
  </pattern>
  <pattern  name="iterator">
    <comment>Locate next element in the box</comment>
  <instantiation>
    <signature>() (\$1:lng,\$2:str) </signature>
    <implementation> MILnewIterator;</implementation>
  </instantiation>
  </pattern>
  <pattern  name="line">
    <comment>Produce comment for tracking
	the MIL code produced</comment>
  <instantiation>
    <signature>(msg:str):void </signature>
    <implementation> MILline;</implementation>
  </instantiation>
  </pattern>
  <pattern  name="open">
    <comment>Locate and open the MIL constant box</comment>
  <instantiation>
    <signature>():void </signature>
    <implementation> MILopen;</implementation>
  </instantiation>
  </pattern>
  <pattern  name="prelude">
    <comment>Initialize the const box</comment>
  <instantiation>
    <signature>():void </signature>
    <implementation> MILprelude;</implementation>
  </instantiation>
  </pattern>
  <pattern  name="release">
    <comment>Release a new constant value</comment>
  <instantiation>
    <signature>(name:any):void </signature>
    <implementation> MILrelease;</implementation>
  </instantiation>
  </pattern>
  <pattern  name="releaseAll">
    <comment>Release all constants</comment>
  <instantiation>
    <signature>():void </signature>
    <implementation> MILreleaseAll;</implementation>
  </instantiation>
  </pattern>
  <pattern  name="toString">
    <comment>Get the string representation 
	of an element in the box</comment>
  <instantiation>
    <signature>(name:any):str </signature>
    <implementation> MILtoString;</implementation>
  </instantiation>
  </pattern>
  <pattern  name="take">
    <comment>Locate and take the typed value</comment>
  <instantiation>
    <signature>(name:str):any </signature>
    <implementation> MILtake;</implementation>
  </instantiation>
  </pattern>
</module>
<module name="mil\_algebra\_procs">
  <function  name="avg">
  <instantiation>
    <signature>(b:bat[:any,:dbl]):dbl;</signature>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any,:flt]):dbl;</signature>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any,:lng]):dbl;</signature>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any,:int]):dbl;</signature>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:any,:sht]):dbl;</signature>
  </instantiation>
  </function>
  <function  name="count\_no\_nil">
  <instantiation>
    <signature>(b:bat[:any,:any]):int;</signature>
  </instantiation>
  </function>
  <function  name="clear">
  <instantiation>
    <signature>(b:bat[:any\$1,:any\$2]):bat[:any\$1,:any\$2];</signature>
  </instantiation>
  </function>
  <function  name="diff">
  <instantiation>
    <signature>(b1:bat[:any\$1,:any\$2],b2:bat[:any\$1,:any\$2]):bat[:any\$1,:any\$2];</signature>
  </instantiation>
  </function>
  <function  name="find\_unescaped\_occurrence">
  <instantiation>
    <signature>(b:str,c:chr):int;</signature>
  </instantiation>
  </function>
  <function  name="intersect">
  <instantiation>
    <signature>(b1:bat[:any\$1,:any\$2],b2:bat[:any\$1,:any\$2]):bat[:any\$1,:any\$2];</signature>
  </instantiation>
  </function>
  <function  name="likeselect">
  <instantiation>
    <signature>(b:bat[:oid,:str],pat:str):bat[:any\$1,:oid];</signature>
  </instantiation>
  </function>
  <function  name="outerjoin">
  <instantiation>
    <signature>(left:bat[:any\$1,:any\$2],right:bat[:any\$2,:any\$3]):bat[:any\$1,:any\$3];</signature>
  </instantiation>
  </function>
  <function  name="project">
  <instantiation>
    <signature>(b:bat[:any\$1,:any]):bat[:any\$1,:void];</signature>
  </instantiation>
  </function>
  <function  name="sort\_ht">
  <instantiation>
    <signature>(B:bat[:any\$1,:any\$2]):bat[:any\$1,:any\$2];</signature>
  </instantiation>
  </function>
  <function  name="tunique">
  <instantiation>
    <signature>(b:bat[:any,:any\$1]):bat[:any\$1,:void];</signature>
  </instantiation>
  </function>
  <function  name="union">
  <instantiation>
    <signature>(b1:bat[:any\$1,:any\$2],b2:bat[:any\$1,:any\$2]):bat[:any\$1,:any\$2];</signature>
  </instantiation>
  </function>
  <function  name="unique">
  <instantiation>
    <signature>(b:bat[:any\$1,:any\$2]):bat[:any\$1,:any\$2];</signature>
  </instantiation>
  </function>
</module>
<module name="mil\_sys\_procs">
  <function  name="dir">
  <instantiation>
    <signature>(substr:str):void;</signature>
  </instantiation>
  <instantiation>
    <signature>():void;</signature>
  </instantiation>
  <instantiation>
    <signature>(b:bat[:int,:str]):void;</signature>
  </instantiation>
  </function>
  <function  name="ls">
  <instantiation>
    <signature>(substr:str):void;</signature>
  </instantiation>
  <instantiation>
    <signature>():void;</signature>
  </instantiation>
  </function>
</module>
<module name="mmath">
  <command  name="atan2">
    <comment>The atan2(x,y) function calculates the 
	arc tangent of the two variables x and y. 
	It is similar to calculating the arc
	tangent of y / x, except that the signs 
	of both arguments are used to determine 
	the quadrant of the result.  The value is 
	returned in radians and is mathematically 
	defined to be between -PI/2 and PI/2 
	(inclusive).</comment>
  <instantiation>
    <signature>(x:dbl,y:dbl):dbl </signature>
    <implementation> MATHbinary\_ATAN2dbl;</implementation>
  </instantiation>
  <instantiation>
    <signature>(x:flt,y:flt):flt </signature>
    <implementation> MATHbinary\_ATAN2flt;</implementation>
  </instantiation>
  </command>
  <command  name="atan">
    <comment>The atan(x) function calculates the 
	arc tangent of x, that is the value 
	whose tangent is x. The value is 
	returned in radians and is mathematically 
	defined to be between -PI/2 and PI/2 
	(inclusive).</comment>
  <instantiation>
    <signature>(x:dbl):dbl </signature>
    <implementation> MATHunary\_ATANdbl;</implementation>
  </instantiation>
  <instantiation>
    <signature>(x:flt):flt </signature>
    <implementation> MATHunary\_ATANflt;</implementation>
  </instantiation>
  </command>
  <command  name="asin">
    <comment>The asin(x) function calculates 
	the arc sine of x, that is the value 
	whose sine is x. The value is returned 
	in radians and is mathematically 
	defined to be between -PI/20 and -PI/2 
	(inclusive).</comment>
  <instantiation>
    <signature>(x:dbl):dbl </signature>
    <implementation> MATHunary\_ASINdbl;</implementation>
  </instantiation>
  <instantiation>
    <signature>(x:flt):flt </signature>
    <implementation> MATHunary\_ASINflt;</implementation>
  </instantiation>
  </command>
  <command  name="acos">
    <comment>The acos(x) function calculates 
	the arc cosine of x, that is the 
	value whose cosine is x. The value 
	is returned in radians and is 
	mathematically defined to be between 
	0 and PI (inclusive).</comment>
  <instantiation>
    <signature>(x:dbl):dbl </signature>
    <implementation> MATHunary\_ACOSdbl;</implementation>
  </instantiation>
  <instantiation>
    <signature>(x:flt):flt </signature>
    <implementation> MATHunary\_ACOSflt;</implementation>
  </instantiation>
  </command>
  <command  name="ceil">
    <comment>The ceil(x) function rounds x upwards 
	to the nearest integer.</comment>
  <instantiation>
    <signature>(y:dbl):dbl </signature>
    <implementation> MATHunary\_CEILdbl;</implementation>
  </instantiation>
  <instantiation>
    <signature>(y:flt):flt </signature>
    <implementation> MATHunary\_CEILflt;</implementation>
  </instantiation>
  </command>
  <command  name="cosh">
    <comment>The cosh() function  returns the 
	hyperbolic cosine of x, which is 
	defined mathematically as 
		(exp(x) + exp(-x)) / 2.</comment>
  <instantiation>
    <signature>(x:dbl):dbl </signature>
    <implementation> MATHunary\_COSHdbl;</implementation>
  </instantiation>
  <instantiation>
    <signature>(x:flt):flt </signature>
    <implementation> MATHunary\_COSHflt;</implementation>
  </instantiation>
  </command>
  <command  name="cos">
    <comment>The cos(x) function returns the cosine 
	of x, where x is given in radians. The 
	return value is between -1 and 1.</comment>
  <instantiation>
    <signature>(x:dbl):dbl </signature>
    <implementation> MATHunary\_COSdbl;</implementation>
  </instantiation>
  <instantiation>
    <signature>(x:flt):flt </signature>
    <implementation> MATHunary\_COSflt;</implementation>
  </instantiation>
  </command>
  <command  name="exp">
    <comment>The exp(x) function returns the value 
	of e (the base of natural logarithms) 
	raised to the power of x.</comment>
  <instantiation>
    <signature>(x:dbl):dbl </signature>
    <implementation> MATHunary\_EXPdbl;</implementation>
  </instantiation>
  <instantiation>
    <signature>(x:flt):flt </signature>
    <implementation> MATHunary\_EXPflt;</implementation>
  </instantiation>
  </command>
  <command  name="finite">
    <comment>The finite(x) function returns true if 
	x is neither infinite nor a 'not-a-number' 
	(NaN) value, and false otherwise.</comment>
  <instantiation>
    <signature>(d:dbl):bit </signature>
    <implementation> math\_unary\_FINITE;</implementation>
  </instantiation>
  </command>
  <command  name="fmod">
    <comment>The fmod(x,y) function computes the 
	 remainder of dividing x by y.
	The return value is x - n * y, where n 
	is the quotient of x / y,
	rounded towards zero to an integer.</comment>
  <instantiation>
    <signature>(y:dbl,x:dbl):dbl </signature>
    <implementation> MATHbinary\_FMODdbl;</implementation>
  </instantiation>
  <instantiation>
    <signature>(y:flt,x:flt):flt </signature>
    <implementation> MATHbinary\_FMODflt;</implementation>
  </instantiation>
  </command>
  <command  name="floor">
    <comment>The floor(x) function rounds x 
	 downwards to the nearest integer.</comment>
  <instantiation>
    <signature>(y:dbl):dbl </signature>
    <implementation> MATHunary\_FLOORdbl;</implementation>
  </instantiation>
  <instantiation>
    <signature>(y:flt):flt </signature>
    <implementation> MATHunary\_FLOORflt;</implementation>
  </instantiation>
  </command>
  <command  name="fabs">
    <comment>The fabs(x) function  returns  the  
	absolute value of the floating-point 
	number x.</comment>
  <instantiation>
    <signature>(y:dbl):dbl </signature>
    <implementation> MATHunary\_FABSdbl;</implementation>
  </instantiation>
  </command>
  <command  name="isinf">
    <comment>The isinf(x) function returns -1 
	 if x represents negative infinity, 
	 1 if x represents positive infinity, 
	 and 0 otherwise.</comment>
  <instantiation>
    <signature>(d:dbl):int </signature>
    <implementation> math\_unary\_ISINF;</implementation>
  </instantiation>
  </command>
  <command  name="isnan">
    <comment>The isnan(x) function returns true 
	if x is 'not-a-number' (NaN), and false 
	otherwise.</comment>
  <instantiation>
    <signature>(d:dbl):bit </signature>
    <implementation> math\_unary\_ISNAN;</implementation>
  </instantiation>
  </command>
  <command  name="log10">
    <comment>The log10(x) function returns 
the base-10 logarithm of x.</comment>
  <instantiation>
    <signature>(x:dbl):dbl </signature>
    <implementation> MATHunary\_LOG10dbl;</implementation>
  </instantiation>
  </command>
  <command  name="log">
    <comment>The log(x) function returns 
the natural logarithm of x.</comment>
  <instantiation>
    <signature>(x:dbl):dbl </signature>
    <implementation> MATHunary\_LOGdbl;</implementation>
  </instantiation>
  </command>
  <command  name="pow">
    <comment>The pow(x,y) function  returns the 
	value of x raised to the power of y.</comment>
  <instantiation>
    <signature>(x:dbl,y:dbl):dbl </signature>
    <implementation> MATHbinary\_POWdbl;</implementation>
  </instantiation>
  <instantiation>
    <signature>(x:flt,y:flt):flt </signature>
    <implementation> MATHbinary\_POWflt;</implementation>
  </instantiation>
  </command>
  <command  name="round">
    <comment>The round(n, m) returns n rounded to m 
	 places to the right of the decimal point;
	 if m is omitted, to 0 places. m can be 
	 negative to round off digits left of the 
	 decimal point. m must be an integer.</comment>
  <instantiation>
    <signature>(x:dbl,y:int):dbl </signature>
    <implementation> MATHbinary\_ROUNDdbl;</implementation>
  </instantiation>
  <instantiation>
    <signature>(x:flt,y:int):flt </signature>
    <implementation> MATHbinary\_ROUNDflt;</implementation>
  </instantiation>
  </command>
  <command  name="sqrt">
    <comment>The sqrt(x) function returns the 
	non-negative square root of x.</comment>
  <instantiation>
    <signature>(y:dbl):dbl </signature>
    <implementation> MATHunary\_SQRTdbl;</implementation>
  </instantiation>
  <instantiation>
    <signature>(y:flt):flt </signature>
    <implementation> MATHunary\_SQRTflt;</implementation>
  </instantiation>
  </command>
  <command  name="sinh">
    <comment>The sinh() function  returns  the  
	hyperbolic sine of x, which is defined 
	mathematically as 
		(exp(x) - exp(-x)) / 2.</comment>
  <instantiation>
    <signature>(x:dbl):dbl </signature>
    <implementation> MATHunary\_SINHdbl;</implementation>
  </instantiation>
  <instantiation>
    <signature>(x:flt):flt </signature>
    <implementation> MATHunary\_SINHflt;</implementation>
  </instantiation>
  </command>
  <command  name="sin">
    <comment>The sin(x) function returns the cosine 
	of x, where x is given in radians. The 
	return value is between -1 and 1.</comment>
  <instantiation>
    <signature>(x:dbl):dbl </signature>
    <implementation> MATHunary\_SINdbl;</implementation>
  </instantiation>
  <instantiation>
    <signature>(x:flt):flt </signature>
    <implementation> MATHunary\_SINflt;</implementation>
  </instantiation>
  </command>
  <command  name="tanh">
    <comment>The tanh() function returns the 
	hyperbolic tangent of x, which is 
	defined mathematically as 
		sinh(x) / cosh(x).</comment>
  <instantiation>
    <signature>(x:dbl):dbl </signature>
    <implementation> MATHunary\_TANHdbl;</implementation>
  </instantiation>
  <instantiation>
    <signature>(x:flt):flt </signature>
    <implementation> MATHunary\_TANHflt;</implementation>
  </instantiation>
  </command>
  <command  name="tan">
    <comment>The tan(x) function returns the 
	tangent of x,
where x is given in radians</comment>
  <instantiation>
    <signature>(x:dbl):dbl </signature>
    <implementation> MATHunary\_TANdbl;</implementation>
  </instantiation>
  <instantiation>
    <signature>(x:flt):flt </signature>
    <implementation> MATHunary\_TANflt;</implementation>
  </instantiation>
  </command>
</module>
<module name="mtime">
  <command  name="add">
    <comment>returns the timestamp that comes 'msecs' 
	(possibly negative) after 'value'.</comment>
  <instantiation>
    <signature>(v:timestamp,msecs:lng):timestamp </signature>
    <implementation> MTIMEtimestamp\_add;</implementation>
  </instantiation>
  </command>
  <command  name="adddays">
    <comment>returns the date after a number 
	of days (possibly negative).</comment>
  <instantiation>
    <signature>(value:date,days:int):date </signature>
    <implementation> MTIMEdate\_adddays;</implementation>
  </instantiation>
  </command>
  <command  name="addmonths">
    <comment>returns the date after a number of 
	months (possibly negative).</comment>
  <instantiation>
    <signature>(value:date,months:int):date </signature>
    <implementation> MTIMEdate\_addmonths;</implementation>
  </instantiation>
  </command>
  <command  name="addyears">
    <comment>returns the date after a number 
	of years (possibly negative).</comment>
  <instantiation>
    <signature>(value:date,years:int):date </signature>
    <implementation> MTIMEdate\_addyears;</implementation>
  </instantiation>
  </command>
  <command  name="current\_time">
  <instantiation>
    <signature>():daytime </signature>
    <implementation> MTIMEcurrent\_time;</implementation>
  </instantiation>
  </command>
  <command  name="current\_date">
  <instantiation>
    <signature>():date </signature>
    <implementation> MTIMEcurrent\_date;</implementation>
  </instantiation>
  </command>
  <command  name="current\_timestamp">
  <instantiation>
    <signature>():timestamp </signature>
    <implementation> MTIMEcurrent\_timestamp;</implementation>
  </instantiation>
  </command>
  <command  name="compute">
    <comment>compute the date from a rule in a given year</comment>
  <instantiation>
    <signature>(r:rule,year:int):date </signature>
    <implementation> MTIMEcompute\_rule\_foryear;</implementation>
  </instantiation>
  </command>
  <command  name="daytime">
    <comment>default time creation with zeroed components</comment>
  <instantiation>
    <signature>(h:int,m:int,s:int):daytime </signature>
    <implementation> MTIMEdaytime3;</implementation>
  </instantiation>
  <instantiation>
    <signature>(h:int,m:int):daytime </signature>
    <implementation> MTIMEdaytime2;</implementation>
  </instantiation>
  <instantiation>
    <signature>(h:int):daytime </signature>
    <implementation> MTIMEdaytime1;</implementation>
  </instantiation>
  </command>
  <command  name="dayname">
    <comment>Returns day name from a number 
	between [1-7], str(nil) otherwise.</comment>
  <instantiation>
    <signature>(day:int):str </signature>
    <implementation> MTIMEday\_to\_str;</implementation>
  </instantiation>
  </command>
  <command  name="daynum">
    <comment>Returns number of day [1-7] from a 
	string or nil if does not match any.</comment>
  <instantiation>
    <signature>(day:str):int </signature>
    <implementation> MTIMEday\_from\_str;</implementation>
  </instantiation>
  </command>
  <command  name="dst">
    <comment>return whether DST holds in the 
	timezone at a certain point of time.</comment>
  <instantiation>
    <signature>(t:timestamp,v:tzone):bit </signature>
    <implementation> MTIMEtimestamp\_inside\_dst;</implementation>
  </instantiation>
  </command>
  <command  name="diff">
    <comment>returns the number of milliseconds 
	between 'val1' and 'val2'.</comment>
  <instantiation>
    <signature>(val1:timestamp,val2:timestamp):lng </signature>
    <implementation> MTIMEtimestamp\_diff;</implementation>
  </instantiation>
  </command>
  <command  name="dayofweek">
    <comment>Returns the current day of the week 
	where 1=sunday, .., 7=saturday</comment>
  <instantiation>
    <signature>(d:date):int </signature>
    <implementation> MTIMEdate\_extract\_dayofweek;</implementation>
  </instantiation>
  </command>
  <command  name="dayofyear">
    <comment>Returns N where d is the Nth day 
	of the year (january 1 returns 1)</comment>
  <instantiation>
    <signature>(d:date):int </signature>
    <implementation> MTIMEdate\_extract\_dayofyear;</implementation>
  </instantiation>
  </command>
  <command  name="diff">
    <comment>returns the number of days 
	between 'val1' and 'val2'.</comment>
  <instantiation>
    <signature>(val1:date,val2:date):int </signature>
    <implementation> MTIMEdate\_diff;</implementation>
  </instantiation>
  </command>
  <command  name="day">
    <comment>extract day from rule.</comment>
  <instantiation>
    <signature>(t:rule):int </signature>
    <implementation> MTIMErule\_extract\_day;</implementation>
  </instantiation>
  </command>
  <command  name="date">
    <comment>extracts date from timestamp in a 
	specific timezone.</comment>
  <instantiation>
    <signature>(t:timestamp,v:tzone):date </signature>
    <implementation> MTIMEtimestamp\_extract\_date;</implementation>
  </instantiation>
  <instantiation>
    <signature>(t:timestamp):date </signature>
    <implementation> MTIMEtimestamp\_extract\_date\_default;</implementation>
  </instantiation>
  </command>
  <command  name="daytime">
    <comment>extracts daytime from timestamp 
	in a specific tzone.</comment>
  <instantiation>
    <signature>(t:timestamp,v:tzone):daytime </signature>
    <implementation> MTIMEtimestamp\_extract\_daytime;</implementation>
  </instantiation>
  <instantiation>
    <signature>(t:timestamp):daytime </signature>
    <implementation> MTIMEtimestamp\_extract\_daytime\_default;</implementation>
  </instantiation>
  </command>
  <command  name="day">
    <comment>extracts day from date </comment>
  <instantiation>
    <signature>(d:date):int </signature>
    <implementation> MTIMEdate\_extract\_day;</implementation>
  </instantiation>
  </command>
  <command  name="daytime">
    <comment>creates a time from (hours,minutes,
	seconds,milliseconds) parameters.</comment>
  <instantiation>
    <signature>(h:int,m:int,s:int,mi:int):daytime </signature>
    <implementation> MTIMEdaytime\_create;</implementation>
  </instantiation>
  <instantiation>
    <signature>(s:str):daytime </signature>
    <implementation> MTIMEdaytime\_fromstr;</implementation>
  </instantiation>
  </command>
  <command  name="date">
    <comment>creates a date from (year,month,day).</comment>
  <instantiation>
    <signature>(yr:int,mo:int,day:int):date </signature>
    <implementation> MTIMEdate\_create;</implementation>
  </instantiation>
  <instantiation>
    <signature>(s:str):date </signature>
    <implementation> MTIMEdate\_fromstr;</implementation>
  </instantiation>
  </command>
  <command  name="end\_dst">
    <comment>extract rule that determines 
	end of DST from tzone.</comment>
  <instantiation>
    <signature>(t:tzone):rule </signature>
    <implementation> MTIMEtzone\_extract\_end;</implementation>
  </instantiation>
  </command>
  <command  name="hours">
    <comment>extracts hour from daytime</comment>
  <instantiation>
    <signature>(h:daytime):int </signature>
    <implementation> MTIMEdaytime\_extract\_hours;</implementation>
  </instantiation>
  </command>
  <command  name="msecs">
    <comment>convert date components to milliseconds</comment>
  <instantiation>
    <signature>(d:int,h:int,m:int,s:int,ms:int):lng </signature>
    <implementation> MTIMEmsecs;</implementation>
  </instantiation>
  </command>
  <command  name="monthname">
    <comment>Returns month name from a number 
	between [1-12], str(nil) otherwise.</comment>
  <instantiation>
    <signature>(month:int):str </signature>
    <implementation> MTIMEmonth\_to\_str;</implementation>
  </instantiation>
  </command>
  <command  name="monthnum">
    <comment>Returns month number [1-12] from a string
	 or nil if does not match any.</comment>
  <instantiation>
    <signature>(month:str):int </signature>
    <implementation> MTIMEmonth\_from\_str;</implementation>
  </instantiation>
  </command>
  <command  name="minutes">
    <comment>extract minutes from rule.</comment>
  <instantiation>
    <signature>(t:rule):int </signature>
    <implementation> MTIMErule\_extract\_minutes;</implementation>
  </instantiation>
  </command>
  <command  name="month">
    <comment>extract month from rule.</comment>
  <instantiation>
    <signature>(t:rule):int </signature>
    <implementation> MTIMErule\_extract\_month;</implementation>
  </instantiation>
  </command>
  <command  name="minutes">
    <comment>extract number of minutes that 
	time zone is offset wrt GMT.</comment>
  <instantiation>
    <signature>(t:tzone):int </signature>
    <implementation> MTIMEtzone\_extract\_minutes;</implementation>
  </instantiation>
  </command>
  <command  name="milliseconds">
    <comment>extracts milliseconds from daytime</comment>
  <instantiation>
    <signature>(d:daytime):int </signature>
    <implementation> MTIMEdaytime\_extract\_milliseconds;</implementation>
  </instantiation>
  </command>
  <command  name="minutes">
    <comment>extracts minutes from daytime</comment>
  <instantiation>
    <signature>(d:daytime):int </signature>
    <implementation> MTIMEdaytime\_extract\_minutes;</implementation>
  </instantiation>
  </command>
  <command  name="month">
    <comment>extracts month from date</comment>
  <instantiation>
    <signature>(d:date):int </signature>
    <implementation> MTIMEdate\_extract\_month;</implementation>
  </instantiation>
  </command>
  <command  name="oldduration">
    <comment>parse the old duration format and 
	return an (estimated) number of days.</comment>
  <instantiation>
    <signature>(format:str):int </signature>
    <implementation> MTIMEoldduration;</implementation>
  </instantiation>
  </command>
  <command  name="olddate">
    <comment>create a date from the old instant 
	format.</comment>
  <instantiation>
    <signature>(format:str):date </signature>
    <implementation> MTIMEolddate;</implementation>
  </instantiation>
  </command>
  <command  name="prelude">
  <instantiation>
    <signature>():void </signature>
    <implementation> MTIMEprelude;</implementation>
  </instantiation>
  </command>
  <command  name="rule">
    <comment>create a DST start/end date rule.</comment>
  <instantiation>
    <signature>(mo:int,d:int,wkday:int,mi:int):rule </signature>
    <implementation> MTIMErule\_create;</implementation>
  </instantiation>
  <instantiation>
    <signature>(s:str):rule </signature>
    <implementation> MTIMErule\_fromstr;</implementation>
  </instantiation>
  </command>
  <command  name="start\_dst">
    <comment>extract rule that determines 
	start of DST from tzone.</comment>
  <instantiation>
    <signature>(t:tzone):rule </signature>
    <implementation> MTIMEtzone\_extract\_start;</implementation>
  </instantiation>
  </command>
  <command  name="seconds">
    <comment>extracts seconds from daytime</comment>
  <instantiation>
    <signature>(d:daytime):int </signature>
    <implementation> MTIMEdaytime\_extract\_seconds;</implementation>
  </instantiation>
  </command>
  <command  name="time\_synonyms">
    <comment>Allow synonyms for the parse format of 
	date/timestamp.</comment>
  <instantiation>
    <signature>(allow:bit):void </signature>
    <implementation> MTIMEsynonyms;</implementation>
  </instantiation>
  </command>
  <command  name="timezone">
    <comment>Test and set the timezone.</comment>
  <instantiation>
    <signature>(name:str):tzone </signature>
    <implementation> MTIMEtimezone;</implementation>
  </instantiation>
  </command>
  <command  name="tzone">
    <comment>create a tzone as an hour difference 
	from GMT and a DST.</comment>
  <instantiation>
    <signature>(mi:int,s:rule,erule:rule):tzone </signature>
    <implementation> MTIMEtzone\_create\_dst;</implementation>
  </instantiation>
  <instantiation>
    <signature>(s:lng):tzone </signature>
    <implementation> MTIMEtzone\_create;</implementation>
  </instantiation>
  <instantiation>
    <signature>(s:int):tzone </signature>
    <implementation> MTIMEtzone\_create;</implementation>
  </instantiation>
  <instantiation>
    <signature>(s:str):tzone </signature>
    <implementation> MTIMEtzone\_fromstr;</implementation>
  </instantiation>
  </command>
  <command  name="timestamp">
    <comment>creates a timestamp from (d:date,dt:daytime) 
	parameters (in the local timezone).</comment>
  <instantiation>
    <signature>(d:date,dt:daytime):timestamp </signature>
    <implementation> MTIMEtimestamp\_create\_default;</implementation>
  </instantiation>
  <instantiation>
    <signature>(d:date,dt:daytime,t:tzone):timestamp </signature>
    <implementation> MTIMEtimestamp\_create;</implementation>
  </instantiation>
  </command>
  <command  name="tzone\_local">
    <comment>get the local tzone; which is used 
	for printing timestamps</comment>
  <instantiation>
    <signature>():tzone </signature>
    <implementation> MTIMEtzone\_get\_local;</implementation>
  </instantiation>
  <instantiation>
    <signature>(t:tzone):void </signature>
    <implementation> MTIMEtzone\_set\_local;</implementation>
  </instantiation>
  </command>
  <command  name="weekofyear">
    <comment>Returns the week number in the year.</comment>
  <instantiation>
    <signature>(d:date):int </signature>
    <implementation> MTIMEdate\_extract\_weekofyear;</implementation>
  </instantiation>
  </command>
  <command  name="weekday">
    <comment>extract weekday from rule.</comment>
  <instantiation>
    <signature>(t:rule):int </signature>
    <implementation> MTIMErule\_extract\_weekday;</implementation>
  </instantiation>
  </command>
  <command  name="year">
    <comment>extracts year from date (nonzero 
	value between -5867411 and +5867411).</comment>
  <instantiation>
    <signature>(d:date):int </signature>
    <implementation> MTIMEdate\_extract\_year;</implementation>
  </instantiation>
  </command>
</module>
<module name="multiplex">
  <pattern  name="script">
    <comment>Generic processor for mutiplexed 
	instructions.</comment>
  <instantiation>
    <signature>(CMD:str,a:any...):any </signature>
    <implementation> CMDmultiplexScript;</implementation>
  </instantiation>
  </pattern>
  <pattern  name="tactics">
    <comment>Tactical optimizer for multiplexed 
	instructions.</comment>
  <instantiation>
    <signature>(CMD:str,a:any...):any </signature>
    <implementation> CMDmultiplexScript;</implementation>
  </instantiation>
  </pattern>
</module>
<module name="optimizer">
  <pattern  name="ARoptimizer">
    <comment>Alias removal optimizer</comment>
  <instantiation>
    <signature>(mod:any,fcn:any):str </signature>
    <implementation> QOTARoptimizerCALL;</implementation>
  </instantiation>
  <instantiation>
    <signature>():str </signature>
    <implementation> QOTARoptimizer;</implementation>
  </instantiation>
  </pattern>
  <pattern  name="CXoptimizer">
    <comment>Common subexpression optimizer</comment>
  <instantiation>
    <signature>(mod:any,fcn:any):str </signature>
    <implementation> QOTCXoptimizerCALL;</implementation>
  </instantiation>
  <instantiation>
    <signature>():str </signature>
    <implementation> QOTCXoptimizer;</implementation>
  </instantiation>
  </pattern>
  <pattern  name="DCoptimizer">
    <comment>Dead code optimizer</comment>
  <instantiation>
    <signature>(mod:any,fcn:any):str </signature>
    <implementation> QOTDCoptimizerCALL;</implementation>
  </instantiation>
  <instantiation>
    <signature>():str </signature>
    <implementation> QOTDCoptimizer;</implementation>
  </instantiation>
  </pattern>
  <pattern  name="RRoptimizer">
    <comment>Reversal idempotency removal</comment>
  <instantiation>
    <signature>(mod:any,fcn:any):str </signature>
    <implementation> QOTRRoptimizerCALL;</implementation>
  </instantiation>
  <instantiation>
    <signature>():str </signature>
    <implementation> QOTRRoptimizer;</implementation>
  </instantiation>
  </pattern>
  <pattern  name="SPoptimizer">
  <instantiation>
    <signature>(mod:any,fcn:any):str </signature>
    <implementation> QOTSPoptimizerCALL;</implementation>
  </instantiation>
  <instantiation>
    <signature>():str </signature>
    <implementation> QOTSPoptimizer;</implementation>
  </instantiation>
  </pattern>
  <pattern  name="debugOptimizers">
  <instantiation>
    <signature>():void </signature>
    <implementation> QOTdebugOptimizers;</implementation>
  </instantiation>
  </pattern>
  <pattern  name="showFlowGraph">
    <comment>Dump the data flow of the function 
	M.F in a format recognizable by the 
	command 'dot' on the file s</comment>
  <instantiation>
    <signature>(M:any,F:any,s:str):void </signature>
    <implementation> CMDshowFlowGraph;</implementation>
  </instantiation>
  </pattern>
</module>
<module name="profiler">
  <command  name="activate">
    <comment>Make the specified counter active.</comment>
  <instantiation>
    <signature>(name:str):void </signature>
    <implementation> CMDactivateProfiler;</implementation>
  </instantiation>
  </command>
  <command  name="clrFilter">
    <comment>Clear the performance trace bit 
	of the selected functions.</comment>
  <instantiation>
    <signature>(mod:str,fcn:str):void </signature>
    <implementation> CMDclrFilterProfiler;</implementation>
  </instantiation>
  </command>
  <command  name="closeStream">
    <comment>Stop sending the event records</comment>
  <instantiation>
    <signature>():void </signature>
    <implementation> closeProfilerStream;</implementation>
  </instantiation>
  </command>
  <command  name="deactivate">
    <comment>Deactivate the counter</comment>
  <instantiation>
    <signature>(name:str):void </signature>
    <implementation> CMDdeactivateProfiler;</implementation>
  </instantiation>
  </command>
  <command  name="getTime">
    <comment>Returns the total microseconds measured 
	while profiling the MAL interpreter</comment>
  <instantiation>
    <signature>(mod:str,fcn:str):bat[:int,:int] </signature>
    <implementation> CMDprofTime;</implementation>
  </instantiation>
  </command>
  <command  name="getCnt">
    <comment>Returns the counts measured while 
	profiling the MAL interpreter</comment>
  <instantiation>
    <signature>(mod:str,fcn:str):bat[:int,:int] </signature>
    <implementation> CMDprofCntModFcn;</implementation>
  </instantiation>
  </command>
  <command  name="openStream">
    <comment>Send the log events to a file </comment>
  <instantiation>
    <signature>(fnme:str):void </signature>
    <implementation> CMDsetProfilerStream;</implementation>
  </instantiation>
  <instantiation>
    <signature>():void </signature>
    <implementation> openProfilerStream;</implementation>
  </instantiation>
  </command>
  <command  name="stop">
    <comment>Stop performance tracing</comment>
  <instantiation>
    <signature>():void </signature>
    <implementation> CMDstopProfiler;</implementation>
  </instantiation>
  </command>
  <command  name="start">
    <comment>Start performance tracing</comment>
  <instantiation>
    <signature>():void </signature>
    <implementation> CMDstartProfiler;</implementation>
  </instantiation>
  </command>
  <command  name="setEndPoint">
    <comment>End performance tracing after mod.fcn</comment>
  <instantiation>
    <signature>(mod:str,fcn:str):void </signature>
    <implementation> CMDendPointProfiler;</implementation>
  </instantiation>
  </command>
  <command  name="setStartPoint">
    <comment>Start performance tracing at mod.fcn</comment>
  <instantiation>
    <signature>(mod:str,fcn:str):void </signature>
    <implementation> CMDstartPointProfiler;</implementation>
  </instantiation>
  </command>
  <command  name="setFilter">
    <comment>Generate an event record for all 
	function calls that satisfy the regular 
	expression mod.fcn. A wildcard (*) can 
	be used as name to identify all</comment>
  <instantiation>
    <signature>(mod:str,fcn:str):void </signature>
    <implementation> CMDsetFilterProfiler;</implementation>
  </instantiation>
  </command>
  <command  name="setNone">
    <comment>Short cut for clrFilter(*,*).</comment>
  <instantiation>
    <signature>():void </signature>
    <implementation> CMDsetNoneProfiler;</implementation>
  </instantiation>
  </command>
  <command  name="setAll">
    <comment>Short cut for setFilter(*,*).</comment>
  <instantiation>
    <signature>():void </signature>
    <implementation> CMDsetAllProfiler;</implementation>
  </instantiation>
  </command>
</module>
<atommodule name="rule">
  <command  name="define">
    <comment>Introduce a synomym timezone rule.</comment>
  <instantiation>
    <signature>(m:int,d:str,w:int,min:int):rule </signature>
    <implementation> MTIMEruleDef2;</implementation>
  </instantiation>
  <instantiation>
    <signature>(m:int,d:str,w:int,h:int,min:int):rule </signature>
    <implementation> MTIMEruleDef1;</implementation>
  </instantiation>
  <instantiation>
    <signature>(m:int,d:int,w:int,h:int,min:int):rule </signature>
    <implementation> MTIMEruleDef0;</implementation>
  </instantiation>
  </command>
  <command  name="fromstr">
  <instantiation>
    <signature>():rule </signature>
    <implementation> rule\_fromstr;</implementation>
  </instantiation>
  </command>
  <command  name="tostr">
  <instantiation>
    <signature>():str </signature>
    <implementation> rule\_tostr;</implementation>
  </instantiation>
  </command>
</atommodule>
<atommodule name="sema">
  <command  name="create">
    <comment>Create an unset sema, with an initial value</comment>
  <instantiation>
    <signature>(init:int):sema </signature>
    <implementation> SEMAcreate;</implementation>
  </instantiation>
  </command>
  <command  name="destroy">
    <comment>Destroy a semaphore</comment>
  <instantiation>
    <signature>(s:sema):void </signature>
    <implementation> SEMAdestroy;</implementation>
  </instantiation>
  </command>
  <command  name="down">
    <comment>Decrement the semaphpore if $&gt;$0; else block</comment>
  <instantiation>
    <signature>(s:sema):void </signature>
    <implementation> SEMAdown;</implementation>
  </instantiation>
  </command>
  <command  name="up">
    <comment>Increment the semaphore</comment>
  <instantiation>
    <signature>(s:sema):void </signature>
    <implementation> SEMAup;</implementation>
  </instantiation>
  </command>
</atommodule>
<module name="status">
  <command  name="cpuStatistics">
    <comment>Global cpu usage information</comment>
  <instantiation>
    <signature>():bat[:str,:int] </signature>
    <implementation> SYScpuStatistics;</implementation>
  </instantiation>
  </command>
  <command  name="gdkThread">
    <comment>Pseudo bat to map thread to name</comment>
  <instantiation>
    <signature>():bat[:int,:str] </signature>
    <implementation> SYSgdkThread;</implementation>
  </instantiation>
  </command>
  <command  name="gdkEnv">
    <comment>Pseudo bat to map thread to name</comment>
  <instantiation>
    <signature>():bat[:str,:str] </signature>
    <implementation> SYSgdkEnv;</implementation>
  </instantiation>
  </command>
  <command  name="ioStatistics">
    <comment>Global IO activity information</comment>
  <instantiation>
    <signature>():bat[:str,:int] </signature>
    <implementation> SYSioStatistics;</implementation>
  </instantiation>
  </command>
  <command  name="mem\_maxsize">
    <comment>set the maximum usable amount of 
	 physical swapspace in KB</comment>
  <instantiation>
    <signature>(v:lng):void </signature>
    <implementation> set\_mem\_maxsize;</implementation>
  </instantiation>
  <instantiation>
    <signature>():lng </signature>
    <implementation> SYSgetmem\_maxsize;</implementation>
  </instantiation>
  </command>
  <command  name="mem\_cursize">
    <comment>the amount of physical swapspace 
	 in KB that is currently in use</comment>
  <instantiation>
    <signature>():lng </signature>
    <implementation> SYSgetmem\_cursize;</implementation>
  </instantiation>
  </command>
  <command  name="memUsage">
    <comment>Get a split-up of how much memory 
	 blocks are in use.</comment>
  <instantiation>
    <signature>(minsize:lng):bat[:str,:lng] </signature>
    <implementation> SYSmem\_usage;</implementation>
  </instantiation>
  </command>
  <command  name="memMap">
    <comment>Print a map of all memory that is in use</comment>
  <instantiation>
    <signature>():void </signature>
    <implementation> SYSmemMap;</implementation>
  </instantiation>
  </command>
  <command  name="memStatistics">
    <comment>Global memory usage information</comment>
  <instantiation>
    <signature>():bat[:str,:int] </signature>
    <implementation> SYSmemStatistics;</implementation>
  </instantiation>
  </command>
  <command  name="vm\_maxsize">
    <comment>set the maximum usable amount 
	of physical swapspace in KB</comment>
  <instantiation>
    <signature>(v:lng):void </signature>
    <implementation> SYSsetvm\_maxsize;</implementation>
  </instantiation>
  <instantiation>
    <signature>():lng </signature>
    <implementation> SYSgetvm\_maxsize;</implementation>
  </instantiation>
  </command>
  <command  name="vm\_cursize">
    <comment>the amount of logical VM space in 
	 KB that is currently in use</comment>
  <instantiation>
    <signature>():lng </signature>
    <implementation> SYSgetvm\_cursize;</implementation>
  </instantiation>
  </command>
  <command  name="vmUsage">
    <comment>Get a split-up of how much virtual 
	 memory blocks are in use.</comment>
  <instantiation>
    <signature>(minsize:lng):bat[:str,:lng] </signature>
    <implementation> SYSvm\_usage;</implementation>
  </instantiation>
  </command>
</module>
<module name="str">
  <command  name="+">
    <comment>Concatenate two strings.</comment>
  <instantiation>
    <signature>(l:str,r:str):str </signature>
    <implementation> STRConcat;</implementation>
  </instantiation>
  </command>
  <command  name="STRprelude">
  <instantiation>
    <signature>():void </signature>
    <implementation> strPrelude;</implementation>
  </instantiation>
  </command>
  <command  name="codeset">
    <comment>Return the locale's codeset</comment>
  <instantiation>
    <signature>():str </signature>
    <implementation> STRcodeset;</implementation>
  </instantiation>
  </command>
  <command  name="chrAt">
    <comment>String array lookup operation.</comment>
  <instantiation>
    <signature>(s:str,index:int):chr </signature>
    <implementation> STRChrAt;</implementation>
  </instantiation>
  <instantiation>
    <signature>(s:str,index:sht):chr </signature>
    <implementation> STRChrAt;</implementation>
  </instantiation>
  <instantiation>
    <signature>(s:str,index:lng):chr </signature>
    <implementation> STRChrAt;</implementation>
  </instantiation>
  </command>
  <command  name="endsWith">
    <comment>Suffix check.</comment>
  <instantiation>
    <signature>(s:str,suffix:str):bit </signature>
    <implementation> STRSuffix;</implementation>
  </instantiation>
  </command>
  <command  name="iconv">
    <comment>String codeset conversion</comment>
  <instantiation>
    <signature>(org:str,fromCs:str,toCs:str):str </signature>
    <implementation> STRIconv;</implementation>
  </instantiation>
  </command>
  <command  name="ltrim">
    <comment>Strip whitespaces from start of a string.</comment>
  <instantiation>
    <signature>(s:str):str </signature>
    <implementation> STRLtrim;</implementation>
  </instantiation>
  </command>
  <command  name="length">
    <comment>Return the length of a string.</comment>
  <instantiation>
    <signature>(s:str):int </signature>
    <implementation> STRLength;</implementation>
  </instantiation>
  </command>
  <command  name="match">
    <comment>POSIX pattern matching against a string</comment>
  <instantiation>
    <signature>(s:str,pat:str):bit </signature>
    <implementation> STRMatch;</implementation>
  </instantiation>
  </command>
  <command  name="nbytes">
    <comment>Return the string length in bytes.</comment>
  <instantiation>
    <signature>(s:str):int </signature>
    <implementation> STRBytes;</implementation>
  </instantiation>
  </command>
  <command  name="rtrim">
    <comment>Strip whitespaces from end of a string.</comment>
  <instantiation>
    <signature>(s:str):str </signature>
    <implementation> STRRtrim;</implementation>
  </instantiation>
  </command>
  <command  name="r\_search">
    <comment>Reverse search for a substring. 
	Returns position, -1 if not found.</comment>
  <instantiation>
    <signature>(s:str,s2:str):int </signature>
    <implementation> STRReverseStrSearch;</implementation>
  </instantiation>
  <instantiation>
    <signature>(s:str,c:chr):int </signature>
    <implementation> STRReverseChrSearch;</implementation>
  </instantiation>
  <instantiation>
    <signature>(s:str,c:str):int </signature>
    <implementation> STRReverseStrSearch;</implementation>
  </instantiation>
  </command>
  <command  name="substitute">
    <comment>Substitute first occurrence of 'src' by 
	'dst'.  Iff repeated = true this is 
	repeated while 'src' can be found in the 
	result string. In order to prevent 
	recursion and result strings of unlimited 
	size, repeating is only done iff src is 
	not a substring of dst.</comment>
  <instantiation>
    <signature>(s:str,src:str,dst:str,rep:bit):str </signature>
    <implementation> STRSubstitute;</implementation>
  </instantiation>
  </command>
  <command  name="search">
    <comment>Search for a substring. Returns 
	 position, -1 if not found.</comment>
  <instantiation>
    <signature>(s:str,s2:str):int </signature>
    <implementation> STRstrSearch;</implementation>
  </instantiation>
  <instantiation>
    <signature>(s:str,c:chr):int </signature>
    <implementation> STRchrSearch;</implementation>
  </instantiation>
  <instantiation>
    <signature>(s:str,c:str):int </signature>
    <implementation> STRstrSearch;</implementation>
  </instantiation>
  </command>
  <command  name="startsWith">
    <comment>Prefix check.</comment>
  <instantiation>
    <signature>(s:str,prefix:str):bit </signature>
    <implementation> STRPrefix;</implementation>
  </instantiation>
  </command>
  <command  name="string">
    <comment>Return substring s[offset..offset+count] 
	of a string s[0..n]</comment>
  <instantiation>
    <signature>(s:str,offset:int,count:int):str </signature>
    <implementation> STRSubString;</implementation>
  </instantiation>
  <instantiation>
    <signature>(s:str,offset:int):str </signature>
    <implementation> STRTail;</implementation>
  </instantiation>
  </command>
  <command  name="str">
    <comment>Noop routine.</comment>
  <instantiation>
    <signature>(s:str):str </signature>
    <implementation> STRtostr;</implementation>
  </instantiation>
  </command>
  <command  name="trim">
    <comment>Strip whitespaces around a string.</comment>
  <instantiation>
    <signature>(s:str):str </signature>
    <implementation> STRStrip;</implementation>
  </instantiation>
  </command>
  <command  name="toUpper">
    <comment>Convert a string to upper case.</comment>
  <instantiation>
    <signature>(s:str):str </signature>
    <implementation> STRUpper;</implementation>
  </instantiation>
  </command>
  <command  name="toLower">
    <comment>Convert a string to lower case.</comment>
  <instantiation>
    <signature>(s:str):str </signature>
    <implementation> STRLower;</implementation>
  </instantiation>
  </command>
  <command  name="unicode">
    <comment>convert a unicode to a character.</comment>
  <instantiation>
    <signature>(wchar:int):str </signature>
    <implementation> STRFromWChr;</implementation>
  </instantiation>
  </command>
  <command  name="unicodeAt">
    <comment>get a unicode character 
	(as an int) from a string position.</comment>
  <instantiation>
    <signature>(s:str,index:int):int </signature>
    <implementation> STRWChrAt;</implementation>
  </instantiation>
  </command>
</module>
<module name="streams">
  <command  name="blocked">
    <comment>open a block based stream</comment>
  <instantiation>
    <signature>(s:str):str </signature>
    <implementation> open\_block\_stream;</implementation>
  </instantiation>
  </command>
  <command  name="close">
  <instantiation>
    <signature>(s:str):void </signature>
    <implementation> stream\_close\_stream;</implementation>
  </instantiation>
  </command>
  <command  name="flush">
    <comment>flush the stream</comment>
  <instantiation>
    <signature>(s:str):void </signature>
    <implementation> stream\_flush\_stream;</implementation>
  </instantiation>
  </command>
  <command  name="openWrite">
    <comment>open ascii file stream for writing</comment>
  <instantiation>
    <signature>(filename:str):str </signature>
    <implementation> stream\_open\_wastream;</implementation>
  </instantiation>
  </command>
  <command  name="openRead">
    <comment>open ascii file stream for reading</comment>
  <instantiation>
    <signature>(filename:str):str </signature>
    <implementation> stream\_open\_rastream;</implementation>
  </instantiation>
  </command>
  <command  name="openWriteBytes">
    <comment>open a file stream for writing</comment>
  <instantiation>
    <signature>(filename:str):str </signature>
    <implementation> stream\_open\_wstream;</implementation>
  </instantiation>
  </command>
  <command  name="openReadBytes">
    <comment>open a file stream for reading</comment>
  <instantiation>
    <signature>(filename:str):str </signature>
    <implementation> stream\_open\_rstream;</implementation>
  </instantiation>
  </command>
  <command  name="readInt">
    <comment>read integer data from the stream</comment>
  <instantiation>
    <signature>(s:str):int </signature>
    <implementation> stream\_read\_int;</implementation>
  </instantiation>
  </command>
  <command  name="readStr">
    <comment>read string data from the stream</comment>
  <instantiation>
    <signature>(s:str):str </signature>
    <implementation> stream\_read\_str;</implementation>
  </instantiation>
  </command>
  <command  name="socketWrite">
    <comment>open ascii socket stream for writing</comment>
  <instantiation>
    <signature>(skt:int,name:str):str </signature>
    <implementation> stream\_socket\_wastream;</implementation>
  </instantiation>
  </command>
  <command  name="socketRead">
    <comment>open ascii socket stream for reading</comment>
  <instantiation>
    <signature>(skt:int,name:str):str </signature>
    <implementation> stream\_socket\_rastream;</implementation>
  </instantiation>
  </command>
  <command  name="socketWriteBytes">
    <comment>open a socket stream for writing</comment>
  <instantiation>
    <signature>(skt:int,name:str):str </signature>
    <implementation> stream\_socket\_wstream;</implementation>
  </instantiation>
  </command>
  <command  name="socketReadBytes">
    <comment>open a socket stream for reading</comment>
  <instantiation>
    <signature>(skt:int,name:str):str </signature>
    <implementation> stream\_socket\_rstream;</implementation>
  </instantiation>
  </command>
  <command  name="writeInt">
    <comment>write data on the stream</comment>
  <instantiation>
    <signature>(s:str,data:int):void </signature>
    <implementation> stream\_write\_int;</implementation>
  </instantiation>
  </command>
  <command  name="writeStr">
    <comment>write data on the stream</comment>
  <instantiation>
    <signature>(s:str,data:str):void </signature>
    <implementation> stream\_write\_string;</implementation>
  </instantiation>
  </command>
</module>
<module name="tablet">
  <pattern  name="dump">
    <comment>Print all pages with header to a stream</comment>
  <instantiation>
    <signature>(s:str,b:bat[:any,:any]...):int </signature>
    <implementation> TABdump;</implementation>
  </instantiation>
  </pattern>
  <pattern  name="display">
    <comment>Display a formatted table</comment>
  <instantiation>
    <signature>(v:bat[:any,:any]...):int </signature>
    <implementation> TABdisplayTable;</implementation>
  </instantiation>
  <instantiation>
    <signature>(v:any...):int </signature>
    <implementation> TABdisplayRow;</implementation>
  </instantiation>
  </pattern>
  <command  name="dump">
    <comment>Dump the bat in ASCII format</comment>
  <instantiation>
    <signature>(names:bat[:void,:str],seps:bat[:void,:str],bats:bat[:void,:BAT],datafile:str,nr:int):void </signature>
    <implementation> CMDtablet\_dump;</implementation>
  </instantiation>
  </command>
  <command  name="firstPage">
    <comment>Produce the first page of output</comment>
  <instantiation>
    <signature>():void </signature>
    <implementation> TABfirstPage;</implementation>
  </instantiation>
  </command>
  <command  name="finish">
    <comment>Free the storage space of the 
	report descriptor</comment>
  <instantiation>
    <signature>():void </signature>
    <implementation> TABfinishReport;</implementation>
  </instantiation>
  </command>
  <command  name="getPage">
    <comment>Produce the i-th page of output</comment>
  <instantiation>
    <signature>(i:int):void </signature>
    <implementation> TABgetPage;</implementation>
  </instantiation>
  </command>
  <command  name="getPageCnt">
    <comment>Return the size in number of pages</comment>
  <instantiation>
    <signature>():void </signature>
    <implementation> TABgetPageCnt;</implementation>
  </instantiation>
  </command>
  <pattern  name="header">
    <comment>Display the minimal header for the table</comment>
  <instantiation>
    <signature>(b:any...):int </signature>
    <implementation> TABheader;</implementation>
  </instantiation>
  </pattern>
  <command  name="input">
    <comment>Load a bat using specific format.</comment>
  <instantiation>
    <signature>(names:bat[:void,:str],seps:bat[:void,:str],types:bat[:void,:str],s:str,nr:int):bat[:str,:BAT] </signature>
    <implementation> CMDtablet\_input;</implementation>
  </instantiation>
  </command>
  <command  name="lastPage">
    <comment>Produce the last page of output</comment>
  <instantiation>
    <signature>():void </signature>
    <implementation> TABlastPage;</implementation>
  </instantiation>
  </command>
  <command  name="load">
    <comment>Load a bat using specific format.</comment>
  <instantiation>
    <signature>(names:bat[:void,:str],seps:bat[:void,:str],types:bat[:void,:str],datafile:str,nr:int):bat[:str,:BAT] </signature>
    <implementation> CMDtablet\_load;</implementation>
  </instantiation>
  </command>
  <command  name="nextPage">
    <comment>Produce the next page of output</comment>
  <instantiation>
    <signature>():void </signature>
    <implementation> TABnextPage;</implementation>
  </instantiation>
  </command>
  <command  name="output">
    <comment>Send the bat to an output stream.</comment>
  <instantiation>
    <signature>(order:bat[:any,:any],seps:bat[:void,:str],bats:bat[:void,:BAT],s:str):void </signature>
    <implementation> CMDtablet\_output;</implementation>
  </instantiation>
  </command>
  <command  name="prevPage">
    <comment>Produce the prev page of output</comment>
  <instantiation>
    <signature>():void </signature>
    <implementation> TABprevPage;</implementation>
  </instantiation>
  </command>
  <pattern  name="page">
    <comment>Display all pages at once without header</comment>
  <instantiation>
    <signature>(b:bat[:any,:any]...):int </signature>
    <implementation> TABpage;</implementation>
  </instantiation>
  </pattern>
  <command  name="setColumnDecimal">
    <comment>Set the scale and precision for 
	numeric values</comment>
  <instantiation>
    <signature>(idx:int,s:int,p:int):void </signature>
    <implementation> TABsetColumnDecimal;</implementation>
  </instantiation>
  </command>
  <command  name="setColumnPosition">
    <comment>Set the character position to use 
	for this field when loading according to 
	fixed (punch-card) layout.</comment>
  <instantiation>
    <signature>(idx:int,f:int,i:int):void </signature>
    <implementation> TABsetColumnPosition;</implementation>
  </instantiation>
  </command>
  <command  name="setColumnWidth">
    <comment>Set the maximal display witdh for 
	a given column. All values exceeding 
	the length are simple shortened
	without any notice.</comment>
  <instantiation>
    <signature>(idx:int,maxwidth:int):void </signature>
    <implementation> TABsetColumnWidth;</implementation>
  </instantiation>
  </command>
  <command  name="setColumnNull">
    <comment>Set the display format for a null 
	value for a given column</comment>
  <instantiation>
    <signature>(idx:int,fmt:str):void </signature>
    <implementation> TABsetColumnNull;</implementation>
  </instantiation>
  </command>
  <command  name="setColumnBracket">
    <comment>Format the brackets around a field</comment>
  <instantiation>
    <signature>(idx:int,lbrk:str,rbrk:str):void </signature>
    <implementation> TABsetColumnBracket;</implementation>
  </instantiation>
  </command>
  <command  name="setColumnName">
    <comment>Set the display name for a given column</comment>
  <instantiation>
    <signature>(idx:int,nme:str):void </signature>
    <implementation> TABsetColumnName;</implementation>
  </instantiation>
  </command>
  <pattern  name="setColumn">
    <comment>Bind i-th output column to a variable</comment>
  <instantiation>
    <signature>(idx:int,v:any):void </signature>
    <implementation> TABsetColumn;</implementation>
  </instantiation>
  </pattern>
  <command  name="setRowBracket">
    <comment>Format the brackets around a row</comment>
  <instantiation>
    <signature>(lbrk:str,rbrk:str):void </signature>
    <implementation> TABsetRowBracket;</implementation>
  </instantiation>
  </command>
  <command  name="setTableBracket">
    <comment>Format the brackets around a table</comment>
  <instantiation>
    <signature>(lbrk:str,rbrk:str):void </signature>
    <implementation> TABsetTableBracket;</implementation>
  </instantiation>
  </command>
  <command  name="setDelimiter">
    <comment>Set the column separator.</comment>
  <instantiation>
    <signature>(sep:str):void </signature>
    <implementation> TABsetDelimiter;</implementation>
  </instantiation>
  </command>
  <command  name="setPivot">
    <comment>The pivot bat identifies the tuples 
	of interest. The only requirement is 
	that all keys mentioned in the pivot
	tail exist in all BAT parameters of 
	the print comment. The pivot also 
	provides control over the order in which
	the tuples are produced.</comment>
  <instantiation>
    <signature>(b:bat[:void,:oid]):void </signature>
    <implementation> TABsetPivot;</implementation>
  </instantiation>
  </command>
  <command  name="setStream">
    <comment>Redirect the output to a stream.</comment>
  <instantiation>
    <signature>(s:str):void </signature>
    <implementation> TABsetStream;</implementation>
  </instantiation>
  </command>
  <pattern  name="setFormat">
    <comment>Initialize a new reporting structure.</comment>
  <instantiation>
    <signature>(b:any...):void </signature>
    <implementation> TABsetFormat;</implementation>
  </instantiation>
  </pattern>
  <command  name="setProperties">
    <comment>Define the set of properties</comment>
  <instantiation>
    <signature>(prop:str):int </signature>
    <implementation> TABsetProperties;</implementation>
  </instantiation>
  </command>
</module>
<module name="thread">
  <pattern  name="exec">
    <comment>Run a function independently</comment>
  <instantiation>
    <signature>(arg:any...):int </signature>
    <implementation> CMDthreadExec;</implementation>
  </instantiation>
  </pattern>
  <pattern  name="isDead">
  <instantiation>
    <signature>(pid:int):bit </signature>
    <implementation> CMDthreadIsDead;</implementation>
  </instantiation>
  </pattern>
  <pattern  name="kill">
    <comment>Kill a specific thread</comment>
  <instantiation>
    <signature>(pid:int):void </signature>
    <implementation> CMDthreadKill;</implementation>
  </instantiation>
  </pattern>
  <pattern  name="suspend">
    <comment>suspend a processing thread</comment>
  <instantiation>
    <signature>(pid:int):void </signature>
    <implementation> CMDthreadSuspend;</implementation>
  </instantiation>
  </pattern>
  <pattern  name="terminate">
    <comment>Attempt a soft kill of a thread</comment>
  <instantiation>
    <signature>(pid:int):void </signature>
    <implementation> CMDthreadTerminate;</implementation>
  </instantiation>
  </pattern>
  <pattern  name="wait">
    <comment>Wait for all threads to be finished</comment>
  <instantiation>
    <signature>(pid:int...):void </signature>
    <implementation> CMDthreadWaitList;</implementation>
  </instantiation>
  <instantiation>
    <signature>():void </signature>
    <implementation> CMDthreadWait;</implementation>
  </instantiation>
  </pattern>
</module>
<atommodule name="timestamp">
  <command  name="!=">
    <comment>Equality of two timestamps</comment>
  <instantiation>
    <signature>(v:timestamp,w:timestamp):bit </signature>
    <implementation> MTIMEtimestamp\_NEQ;</implementation>
  </instantiation>
  </command>
  <command  name="$&lt;$=">
    <comment>Equality of two timestamps</comment>
  <instantiation>
    <signature>(v:timestamp,w:timestamp):bit </signature>
    <implementation> MTIMEtimestamp\_LE;</implementation>
  </instantiation>
  </command>
  <command  name="$&lt;$">
    <comment>Equality of two timestamps</comment>
  <instantiation>
    <signature>(v:timestamp,w:timestamp):bit </signature>
    <implementation> MTIMEtimestamp\_LT;</implementation>
  </instantiation>
  </command>
  <command  name="=">
    <comment>Equality of two timestamps</comment>
  <instantiation>
    <signature>(v:timestamp,w:timestamp):bit </signature>
    <implementation> MTIMEtimestamp\_EQ;</implementation>
  </instantiation>
  </command>
  <command  name="$&gt;$=">
    <comment>Equality of two timestamps</comment>
  <instantiation>
    <signature>(v:timestamp,w:timestamp):bit </signature>
    <implementation> MTIMEtimestamp\_GE;</implementation>
  </instantiation>
  </command>
  <command  name="$&gt;$">
    <comment>Equality of two timestamps</comment>
  <instantiation>
    <signature>(v:timestamp,w:timestamp):bit </signature>
    <implementation> MTIMEtimestamp\_GT;</implementation>
  </instantiation>
  </command>
  <command  name="epoch">
    <comment>unix-time (epoch) support:
	seconds since epoch</comment>
  <instantiation>
    <signature>(t:timestamp):lng </signature>
    <implementation> MTIMEepoch2;</implementation>
  </instantiation>
  <instantiation>
    <signature>():timestamp </signature>
    <implementation> MTIMEepoch;</implementation>
  </instantiation>
  </command>
  <command  name="fromstr">
  <instantiation>
    <signature>():timestamp </signature>
    <implementation> timestamp\_fromstr;</implementation>
  </instantiation>
  </command>
  <command  name="isnil">
    <comment>Nil test for timestamp value</comment>
  <instantiation>
    <signature>(v:timestamp):bit </signature>
    <implementation> MTIMEtimestamp\_isnil;</implementation>
  </instantiation>
  </command>
  <command  name="tostr">
  <instantiation>
    <signature>():str </signature>
    <implementation> timestamp\_tostr;</implementation>
  </instantiation>
  </command>
</atommodule>
<module name="transaction">
  <command  name="alpha">
    <comment>give list of insertions since last commit.</comment>
  <instantiation>
    <signature>(b:bat[:any\$1,:any\$2]):bat[:any\$1,:any\$2] </signature>
    <implementation> TRNtrans\_alpha;</implementation>
  </instantiation>
  </command>
  <pattern  name="abort">
    <comment>abort changes in certain BATs.</comment>
  <instantiation>
    <signature>(c:bat[:any,:any]...):void </signature>
    <implementation> TRNtrans\_abort;</implementation>
  </instantiation>
  <instantiation>
    <signature>():void </signature>
    <implementation> TRNglobal\_abort;</implementation>
  </instantiation>
  </pattern>
  <pattern  name="clean">
    <comment>declare a BAT clean without flushing to disk.</comment>
  <instantiation>
    <signature>(c:bat[:any,:any]...):void </signature>
    <implementation> TRNtrans\_clean;</implementation>
  </instantiation>
  </pattern>
  <pattern  name="commit">
    <comment>commit changes in certain BATs.</comment>
  <instantiation>
    <signature>(c:bat[:any,:any]...):void </signature>
    <implementation> TRNtrans\_commit;</implementation>
  </instantiation>
  <instantiation>
    <signature>():void </signature>
    <implementation> TRNglobal\_commit;</implementation>
  </instantiation>
  </pattern>
  <command  name="delta">
    <comment>give list of deletions since last commit.</comment>
  <instantiation>
    <signature>(b:bat[:any\$1,:any\$2]):bat[:any\$1,:any\$2] </signature>
    <implementation> TRNtrans\_delta;</implementation>
  </instantiation>
  </command>
  <command  name="sync">
    <comment>save all persistent BATs</comment>
  <instantiation>
    <signature>():void </signature>
    <implementation> TRNglobal\_sync;</implementation>
  </instantiation>
  </command>
</module>
<atommodule name="tzone">
  <command  name="fromstr">
  <instantiation>
    <signature>():tzone </signature>
    <implementation> tzone\_fromstr;</implementation>
  </instantiation>
  </command>
  <command  name="str">
  <instantiation>
    <signature>():str </signature>
    <implementation> MTIMEtzone\_tostr;</implementation>
  </instantiation>
  </command>
  <command  name="timestamp">
    <comment>Enhancement of timestamp atom definition</comment>
  <instantiation>
    <signature>(secs:lng):timestamp </signature>
    <implementation> MTIMEtimestamp;</implementation>
  </instantiation>
  </command>
  <command  name="tostr">
  <instantiation>
    <signature>():str </signature>
    <implementation> tzone\_tostr;</implementation>
  </instantiation>
  </command>
</atommodule>
<module name="unix">
  <command  name="getenv">
    <comment>Get the environment variable string.</comment>
  <instantiation>
    <signature>(nme:str):str </signature>
    <implementation> UNIXgetenv;</implementation>
  </instantiation>
  </command>
  <command  name="setenv">
    <comment>Set the environment variable string.</comment>
  <instantiation>
    <signature>(nme:str,val:str):bit </signature>
    <implementation> UNIXsetenv;</implementation>
  </instantiation>
  </command>
</module>
<atommodule name="url">
  <command  name="fromstr">
    <comment>Convert a string to an url. </comment>
  <instantiation>
    <signature>():url </signature>
    <implementation> URLfromString;</implementation>
  </instantiation>
  </command>
  <command  name="getRobotURL">
    <comment>Extract the location of the robot 
	control file</comment>
  <instantiation>
    <signature>(u:url):str </signature>
    <implementation> URLgetRobotURL;</implementation>
  </instantiation>
  </command>
  <command  name="getUser">
    <comment>Extract the user identity from the URL</comment>
  <instantiation>
    <signature>(u:url):str </signature>
    <implementation> URLgetUser;</implementation>
  </instantiation>
  </command>
  <command  name="getQueryArg">
    <comment>Extract argument mappings from the URL</comment>
  <instantiation>
    <signature>(u:url):bat[:str,:str] </signature>
    <implementation> URLgetQueryArg;</implementation>
  </instantiation>
  </command>
  <command  name="getQuery">
    <comment>Extract the query string from the URL</comment>
  <instantiation>
    <signature>(u:url):str </signature>
    <implementation> URLgetQuery;</implementation>
  </instantiation>
  </command>
  <command  name="getProtocol">
    <comment>Extract the protocol from the URL</comment>
  <instantiation>
    <signature>(u:url):str </signature>
    <implementation> URLgetProtocol;</implementation>
  </instantiation>
  </command>
  <command  name="getPort">
    <comment>Extract the port id from the URL</comment>
  <instantiation>
    <signature>(u:url):str </signature>
    <implementation> URLgetPort;</implementation>
  </instantiation>
  </command>
  <command  name="getHost">
    <comment>Extract the server name from the URL</comment>
  <instantiation>
    <signature>(u:url):str </signature>
    <implementation> URLgetHost;</implementation>
  </instantiation>
  </command>
  <command  name="getFile">
    <comment>Extract the last file name of the URL</comment>
  <instantiation>
    <signature>(u:url):str </signature>
    <implementation> URLgetFile;</implementation>
  </instantiation>
  </command>
  <command  name="getExtension">
    <comment>Extract the file extension of the URL</comment>
  <instantiation>
    <signature>(u:url):str </signature>
    <implementation> URLgetExtension;</implementation>
  </instantiation>
  </command>
  <command  name="getDomain">
    <comment>Extract Internet domain from the URL</comment>
  <instantiation>
    <signature>(u:url):str </signature>
    <implementation> URLgetDomain;</implementation>
  </instantiation>
  </command>
  <command  name="getDirectory">
    <comment>Extract directory names from the URL</comment>
  <instantiation>
    <signature>(u:url):bat[:int,:str] </signature>
    <implementation> URLgetDirectory;</implementation>
  </instantiation>
  </command>
  <command  name="getContext">
    <comment>Get the path context of a URL </comment>
  <instantiation>
    <signature>(u:url):str </signature>
    <implementation> URLgetContext;</implementation>
  </instantiation>
  </command>
  <command  name="getContent">
    <comment>Get the URL resource in a local file</comment>
  <instantiation>
    <signature>(u:url):str </signature>
    <implementation> URLgetContent;</implementation>
  </instantiation>
  </command>
  <command  name="getBasename">
    <comment>Extract the URL base file name</comment>
  <instantiation>
    <signature>(u:url):str </signature>
    <implementation> URLgetBasename;</implementation>
  </instantiation>
  </command>
  <command  name="getAnchor">
    <comment>Extract the URL anchor (reference)</comment>
  <instantiation>
    <signature>(u:url):str </signature>
    <implementation> URLgetAnchor;</implementation>
  </instantiation>
  </command>
  <command  name="isaURL">
    <comment>Check conformity of the URL syntax</comment>
  <instantiation>
    <signature>(u:url):bit </signature>
    <implementation> URLisaURL;</implementation>
  </instantiation>
  </command>
  <command  name="newurl">
    <comment>Construct URL from protocol, host,and file</comment>
  <instantiation>
    <signature>(prot:str,host:str,fnme:str):url </signature>
    <implementation> URLnew3;</implementation>
  </instantiation>
  <instantiation>
    <signature>(p:str,h:str,prt:int,f:str):url </signature>
    <implementation> URLnew4;</implementation>
  </instantiation>
  </command>
  <command  name="tostr">
    <comment>Convert url to string equivalent</comment>
  <instantiation>
    <signature>():str </signature>
    <implementation> URLtoString;</implementation>
  </instantiation>
  </command>
  <command  name="url">
    <comment>Create an URL from a string literal</comment>
  <instantiation>
    <signature>(s:str):url </signature>
    <implementation> URLnew;</implementation>
  </instantiation>
  </command>
</atommodule>
</manual>
