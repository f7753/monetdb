# Monet Mil to Mal compiler
# Copyright (c) 2001-2004, CWI. All rights reserved.

#Predefined code segment
#The compiler can not guarantee an accurate compilation,
#because MIL unlike MAL is a dynamically typed language.
#A few guidelines to maximize usefullness.
#- make the type of variables explicit, in particular 'nil'
#- upon advice of M2m to remap identifiers, change it in your program directly
#include "mil_prelude";
	mil.line("setoid(oid(20000000));");
	aa_a := oid(20000000);
	ba_a := setoid(aa_a);
	mil.line("proc doit(str The_mod) : void {");
function doit(The_mod:str):void;
	mil.line("\tvar Fname:=new(oid,str);Fname.col_name(\"function\");");
	Fname := new(nil:oid,nil:str);
	ca_a := bat.setColumn(Fname,"function");
	mil.line("\tvar FnameS:=new(oid,str);FnameS.col_name(\"function\");");
	FnameS := new(nil:oid,nil:str);
	da_a := bat.setColumn(FnameS,"function");
	mil.line("\tvar Ftype:=new(oid,str);Ftype.col_name(\"type\");");
	Ftype := new(nil:oid,nil:str);
	ea_a := bat.setColumn(Ftype,"type");
	mil.line("\tvar Fsig:=new(oid,str);Fsig.col_name(\"signature\");");
	Fsig := new(nil:oid,nil:str);
	fa_a := bat.setColumn(Fsig,"signature");
	mil.line("\tvar Fhelp:=new(oid,str);Fhelp.col_name(\"help\");");
	Fhelp := new(nil:oid,nil:str);
	ga_a := bat.setColumn(Fhelp,"help");
	mil.line("\tvar Fnts:=new(oid,str);");
	Fnts := new(nil:oid,nil:str);
	mil.line("\tvar Mod_fcn:=sdiff(monet_fcntbl.reverse(),Static_fcn).reverse();");
	monet_fcntbl:= mil.take("monet_fcntbl");
	ha_a := reverse(monet_fcntbl);
	Static_fcn:= mil.take("Static_fcn");
	ia_a := sdiff(ha_a,Static_fcn);
	Mod_fcn := reverse(ia_a);
	mil.line("\tMod_fcn.sort()@batloop {");
	ja_a := sort(Mod_fcn);
	mil.line("\t    var addThis:=false;");
barrier	ka_a := bunStream(ja_a,ka_aH,ka_aT);
	addThis := false;
	mil.line("\t    if (not(monet_fcn_mid.exist($t))) {");
	monet_fcn_mid:= mil.take("monet_fcn_mid");
	la_a := exist(monet_fcn_mid,ka_aT);
barrier	ma_a := not(la_a);
	mil.line("\t\taddThis:=true;");
	addThis := true;
	mil.line("\t    } else if (monet_mod_nme.find(monet_fcn_mid.find($t))=The_mod) {");
exit	ma_a;
barrier	na_a := not(ma_a);
	monet_mod_nme:= mil.take("monet_mod_nme");
	oa_a := find(monet_fcn_mid,ka_aT);
	pa_a := find(monet_mod_nme,oa_a);
barrier	qa_a := ==(pa_a,The_mod);
	mil.line("\t\taddThis:=true;");
	addThis := true;
	mil.line("\t    if (addThis) {");
exit	qa_a;
exit	na_a;
barrier	ra_a := addThis;
	mil.line("\t\tvar Tname:=$h;");
	Tname := ka_aH;
	mil.line("\t\tvar Ttype:=help_tpe(monet_fcn_tpe.find($t));");
	monet_fcn_tpe:= mil.take("monet_fcn_tpe");
	sa_a := find(monet_fcn_tpe,ka_aT);
	Ttype := help_tpe(sa_a);
	mil.line("\t\tvar Tsig:=format_fcn_sig($t);");
	Tsig := format_fcn_sig(ka_aT);
	mil.line("\t\tvar Thelp:=\"\";");
	Thelp := "";
	mil.line("\t\tif (monet_fcn_dsc.exist($t)) {");
	monet_fcn_dsc:= mil.take("monet_fcn_dsc");
barrier	ta_a := exist(monet_fcn_dsc,ka_aT);
	mil.line("\t\t\tThelp:=monet_fcn_dsc.find($t);");
	Thelp := find(monet_fcn_dsc,ka_aT);
	mil.line("\t\t} else {");
exit	ta_a;
barrier	ua_a := not(ta_a);
	mil.line("\t\t\tThelp:=\"not available\";");
	Thelp := "not available";
exit	ua_a;
	mil.line("\t\tFname.insert($t,Tname);");
	va_a := insert(Fname,ka_aT,Tname);
	mil.line("\t\tFtype.insert($t,Ttype);");
	wa_a := insert(Ftype,ka_aT,Ttype);
	mil.line("\t\tFsig.insert($t,Tsig);");
	xa_a := insert(Fsig,ka_aT,Tsig);
	mil.line("\t\tFhelp.insert($t,Thelp);");
	ya_a := insert(Fhelp,ka_aT,Thelp);
	mil.line("\t\tFnts.insert($t,sprintf(\"%s %s %s\",Tname,Ttype,Tsig));");
	ab_a := sprintf("%s %s %s",Tname,Ttype,Tsig);
	bb_a := insert(Fnts,ka_aT,ab_a);
	mil.line("\t}");
exit	ra_a;
redo	ka_a;
exit	ka_a;
	mil.line("\tFnts.count().print();");
	cb_a := count(Fnts);
	db_a := print(cb_a);
	mil.line("\tFnts.reverse().sort().reverse()@batloop {");
	eb_a := reverse(Fnts);
	fb_a := sort(eb_a);
	gb_a := reverse(fb_a);
	mil.line("\t\tFnameS.insert($h,Fname.find($h));");
barrier	hb_a := bunStream(gb_a,hb_aH,hb_aT);
	ib_a := find(Fname,hb_aH);
	jb_a := insert(FnameS,hb_aH,ib_a);
redo	hb_a;
exit	hb_a;
	mil.line("\tFnameS.count().print(); table(1,FnameS,Ftype,Fsig,Fhelp);");
	kb_a := count(FnameS);
	lb_a := print(kb_a);
	mb_a := table(1,FnameS,Ftype,Fsig,Fhelp);
	mil.line("\tFname.delete();");
	nb_a := delete(Fname);
	mil.line("\tFnameS.delete();");
	ob_a := delete(FnameS);
	mil.line("\tFtype.delete();");
	pb_a := delete(Ftype);
	mil.line("\tFsig.delete();");
	qb_a := delete(Fsig);
	mil.line("\tFhelp.delete();");
	rb_a := delete(Fhelp);
	mil.line("\tFnts.delete();");
	sb_a := delete(Fnts);
end doit;
	mil.line("var Static_fcn:=monet_fcntbl.reverse().copy();");
	monet_fcntbl:= mil.take("monet_fcntbl");
	tb_a := reverse(monet_fcntbl);
	Static_fcn := copy(tb_a);
	mil.line("printf(\"Module: \\\"Meta\\\"\\n\\n\");");
	ub_a := printf("Module: \"Meta\"\n\n");
	mil.line("doit(\"Meta\");");
	vb_a := doit("Meta");
	mil.line("Static_fcn:=sunion(Static_fcn,monet_fcntbl.reverse());");
	wb_a := reverse(monet_fcntbl);
	Static_fcn := sunion(Static_fcn,wb_a);
	mil.line("var Odmg_mods:=MODULES.select(\"odmgTest\").copy().access(BAT_WRITE).delete(\"Meta\").sort();");
	MODULES:= mil.take("MODULES");
	xb_a := select(MODULES,"odmgTest");
	BAT_WRITE:= mil.take("BAT_WRITE");
	yb_a := copy(xb_a);
	ac_a := access(yb_a,BAT_WRITE);
	bc_a := delete(ac_a,"Meta");
	Odmg_mods := sort(bc_a);
	mil.line("table(Odmg_mods.reverse().col_name(sprintf(\"%i modules\",Odmg_mods.count())));");
	cc_a := count(Odmg_mods);
	dc_a := sprintf("%i modules",cc_a);
	ec_a := reverse(Odmg_mods);
	fc_a := bat.setColumn(ec_a,dc_a);
	gc_a := table(fc_a);
	mil.line("\tvar The_mod:=$h;");
barrier	hc_a := bunStream(Odmg_mods,hc_aH,hc_aT);
	The_mod := hc_aH;
	mil.line("\tprintf(\"\\nModule: \\\"%s\\\"\\n\\n\",The_mod);");
	ic_a := printf("\nModule: \"%s\"\n\n",The_mod);
!ERROR: "	module($h);"
!        								^
! syntax error, unexpected TOK_MODULE.
#Identifer 'col_name' mapped to 'bat.setColumn'
