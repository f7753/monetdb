stdout of test 'ID.1024615` in directory 'tests/BugsViaSourgeforce` itself:


# 16:24:49 >  
# 16:24:49 >  Mtimeout -timeout 60 Mserver "--config=/ufs/niels/data/Linux-i686/etc/MonetDB.conf" --debug=10 --set "monet_mod_path=/ufs/niels/data/Linux-i686/lib/MonetDB" --set "gdk_dbfarm=/ufs/niels/data/Linux-i686/var/MonetDB/dbfarm" --set "sql_logdir=/ufs/niels/data/Linux-i686/var/MonetDB/log" --set mapi_port=46419 --set sql_port=54865 --set monet_prompt= --trace --dbname=mTests_tests_BugsViaSourgeforce  < ID.1024615.milS
# 16:24:49 >  

# Monet Database Server V4.3.19
# Copyright (c) 1993-2004, CWI. All rights reserved.
# Compiled for x86_64-redhat-linux-gnu/64bit; dynamically linked.
# config:/home/mk/monet5/Linux/etc/MonetDB5.conf
# dbfarm:/home/mk/monet5/Linux/var/MonetDB5/dbfarm
# dbname:mTests_tests_BugsViaSourgeforce
# Visit http://monetdb.cwi.nl for further information.
## Monet Mil to Mal compiler
## Copyright (c) 2001-2004, CWI. All rights reserved.
#
## Predefined code segment
##The compiler can not guarantee an accurate compilation,
##because MIL unlike MAL is a dynamically typed language.
##A few guidelines to maximize usefullness.
##- make the type of variables explicit, in particular 'nil'
##- upon advice of M2m to remap identifiers, change it in your program directly
##var b1 := bat(oid,str);
#	b1 := new(:oid,:str);
##b1.reverse().sort().reverse().print();
#	aa_a := reverse(b1,);
#	ba_a := sort(aa_a,);
#	ca_a := reverse(ba_a,);
#	da_a := print(ca_a,);
##b1.access(BAT_WRITE);
#	BAT_WRITE:= mil.take("BAT_WRITE");
#	ea_a := access(b1,BAT_WRITE);
##b1.reverse().sort().reverse().print();
#	fa_a := reverse(b1,);
#	ga_a := sort(fa_a,);
#	ha_a := reverse(ga_a,);
#	ia_a := print(ha_a,);
##var b2 := bat(void,str);
#	b2 := new(:void,:str);
##b2.seqbase(oid(10));
#	ja_a := oid(10);
#	ka_a := bat.setSequenceBase(b2,ja_a);
##b2.reverse().sort().reverse().print();
#	la_a := reverse(b2,);
#	ma_a := sort(la_a,);
#	na_a := reverse(ma_a,);
#	oa_a := print(na_a,);
##b2.access(BAT_WRITE);
#	pa_a := access(b2,BAT_WRITE);
##b2.reverse().sort().reverse().print();
#	qa_a := reverse(b2,);
#	ra_a := sort(qa_a,);
#	sa_a := reverse(ra_a,);
#	ta_a := print(sa_a,);
##var b3 := mirror(b2);
#	b3 := mirror(b2);
##b3.print();
#	ua_a := print(b3,);
##var b4 := b3.reverse().join(b2);
#	va_a := reverse(b3,);
#	b4 := join(va_a,b2);
##b4.print();
#	wa_a := print(b4,);
##b4.reverse().sort().reverse().print();
#	xa_a := reverse(b4,);
#	ya_a := sort(xa_a,);
#	ab_a := reverse(ya_a,);
#	bb_a := print(ab_a,);
##var b2 := bat(void,str);
#	b2 := new(:void,:str);
##b2.seqbase(oid(10));
#	cb_a := oid(10);
#	db_a := bat.setSequenceBase(b2,cb_a);
##var b3 := mirror(b2);
#	b3 := mirror(b2);
##var b4 := b3.reverse().join(b2);
#	eb_a := reverse(b3,);
#	b4 := join(eb_a,b2);
##b4.reverse().sort().reverse().print();
#	fb_a := reverse(b4,);
#	gb_a := sort(fb_a,);
#	hb_a := reverse(gb_a,);
#	ib_a := print(hb_a,);
##Identifer 'seqbase' mapped to 'bat.setSequenceBase'
#
function Admin.main():int;	# 0  (main:int)
    mil.line("var b1 := bat(oid,str);");	# 1 MILline ($1:void)<-($2:str)
    b1 := bbp.new(nil:oid,"nil:str");	# 2 CMDBATnew (b1:bat[:oid,:str])<-($4:oid)($5:str)
    mil.line("b1.reverse().sort().reverse().print();");	# 3 MILline ($6:void)<-($7:str)
    aa_a := bat.reverse(b1);	# 4 BKCreverse (aa_a:bat[:str,:oid])<-(b1:bat[:oid,:str])
    ba_a := algebra.sort(aa_a);	# 5 ALGsort (ba_a:bat[:str,:oid])<-(aa_a:bat[:str,:oid])
    ca_a := bat.reverse(ba_a);	# 6 BKCreverse (ca_a:bat[:oid,:str])<-(ba_a:bat[:str,:oid])
    da_a := io.print(ca_a);	# 7 IOprint_val (da_a:int)<-(ca_a:bat[:oid,:str])
    mil.line("b1.access(BAT_WRITE);");	# 8 MILline ($12:void)<-($13:str)
    BAT_WRITE := mil.take("BAT_WRITE");	# 9 MILtake (BAT_WRITE:any)<-($15:str)
    ea_a := bat.access(b1,BAT_WRITE);	# 10 BKCaccess (ea_a:void)<-(b1:bat[:oid,:str])(BAT_WRITE:any)
    mil.line("b1.reverse().sort().reverse().print();");	# 11 MILline ($17:void)<-($7:str)
    fa_a := bat.reverse(b1);	# 12 BKCreverse (fa_a:bat[:str,:oid])<-(b1:bat[:oid,:str])
    ga_a := algebra.sort(fa_a);	# 13 ALGsort (ga_a:bat[:str,:oid])<-(fa_a:bat[:str,:oid])
    ha_a := bat.reverse(ga_a);	# 14 BKCreverse (ha_a:bat[:oid,:str])<-(ga_a:bat[:str,:oid])
    ia_a := io.print(ha_a);	# 15 IOprint_val (ia_a:int)<-(ha_a:bat[:oid,:str])
    mil.line("var b2 := bat(void,str);");	# 16 MILline ($22:void)<-($23:str)
    b2 := bbp.new(nil:void,"nil:str");	# 17 CMDBATnew (b2:bat[:void,:str])<-($25:void)($5:str)
    mil.line("b2.seqbase(oid(10));");	# 18 MILline ($26:void)<-($27:str)
    ja_a := calc.oid(10);	# 19 CALCint2oid (ja_a:oid)<-($29:int)
    ka_a := bat.setSequenceBase(b2,ja_a);	# 20 BKCsetSequenceBase (ka_a:any)<-(b2:bat[:void,:str])(ja_a:oid)
    mil.line("b2.reverse().sort().reverse().print();");	# 21 MILline ($31:void)<-($32:str)
    la_a := bat.reverse(b2);	# 22 BKCreverse (la_a:bat[:str,:void])<-(b2:bat[:void,:str])
    ma_a := algebra.sort(la_a);	# 23 ALGsort (ma_a:bat[:str,:void])<-(la_a:bat[:str,:void])
    na_a := bat.reverse(ma_a);	# 24 BKCreverse (na_a:bat[:void,:str])<-(ma_a:bat[:str,:void])
    oa_a := io.print(na_a);	# 25 IOprint_val (oa_a:int)<-(na_a:bat[:void,:str])
    mil.line("b2.access(BAT_WRITE);");	# 26 MILline ($37:void)<-($38:str)
    pa_a := bat.access(b2,BAT_WRITE);	# 27 BKCaccess (pa_a:void)<-(b2:bat[:void,:str])(BAT_WRITE:any)
    mil.line("b2.reverse().sort().reverse().print();");	# 28 MILline ($40:void)<-($32:str)
    qa_a := bat.reverse(b2);	# 29 BKCreverse (qa_a:bat[:str,:void])<-(b2:bat[:void,:str])
    ra_a := algebra.sort(qa_a);	# 30 ALGsort (ra_a:bat[:str,:void])<-(qa_a:bat[:str,:void])
    sa_a := bat.reverse(ra_a);	# 31 BKCreverse (sa_a:bat[:void,:str])<-(ra_a:bat[:str,:void])
    ta_a := io.print(sa_a);	# 32 IOprint_val (ta_a:int)<-(sa_a:bat[:void,:str])
    mil.line("var b3 := mirror(b2);");	# 33 MILline ($45:void)<-($46:str)
    b3 := bat.mirror(b2);	# 34 BKCmirror (b3:bat[:void,:void])<-(b2:bat[:void,:str])
    mil.line("b3.print();");	# 35 MILline ($48:void)<-($49:str)
    ua_a := io.print(b3);	# 36 IOprint_val (ua_a:int)<-(b3:bat[:void,:void])
    mil.line("var b4 := b3.reverse().join(b2);");	# 37 MILline ($51:void)<-($52:str)
    va_a := bat.reverse(b3);	# 38 BKCreverse (va_a:bat[:void,:void])<-(b3:bat[:void,:void])
    b4 := algebra.join(va_a,b2);	# 39 ALGjoin (b4:bat[:void,:str])<-(va_a:bat[:void,:void])(b2:bat[:void,:str])
    mil.line("b4.print();");	# 40 MILline ($55:void)<-($56:str)
    wa_a := io.print(b4);	# 41 IOprint_val (wa_a:int)<-(b4:bat[:void,:str])
    mil.line("# next line produced an incorrect error \n");	# 42 MILline ($58:void)<-($59:str)
    mil.line("# ERROR: CMDsort: returned BAT has unexpected head.\n");	# 43 MILline ($60:void)<-($61:str)
    xa_a := bat.reverse(b4);	# 44 BKCreverse (xa_a:bat[:str,:void])<-(b4:bat[:void,:str])
    ya_a := algebra.sort(xa_a);	# 45 ALGsort (ya_a:bat[:str,:void])<-(xa_a:bat[:str,:void])
    ab_a := bat.reverse(ya_a);	# 46 BKCreverse (ab_a:bat[:void,:str])<-(ya_a:bat[:str,:void])
    bb_a := io.print(ab_a);	# 47 IOprint_val (bb_a:int)<-(ab_a:bat[:void,:str])
    mil.line("#mini mil example\n");	# 48 MILline ($66:void)<-($67:str)
    mil.line("var b2 := bat(void,str);");	# 49 MILline ($68:void)<-($69:str)
    b2 := bbp.new(nil:void,"nil:str");	# 50 CMDBATnew (b2:bat[:void,:str])<-($70:void)($71:str)
    mil.line("b2.seqbase(oid(10));");	# 51 MILline ($72:void)<-($73:str)
    cb_a := calc.oid(10);	# 52 CALCint2oid (cb_a:oid)<-($75:int)
    db_a := bat.setSequenceBase(b2,cb_a);	# 53 BKCsetSequenceBase (db_a:any)<-(b2:bat[:void,:str])(cb_a:oid)
    mil.line("var b3 := mirror(b2);");	# 54 MILline ($77:void)<-($46:str)
    b3 := bat.mirror(b2);	# 55 BKCmirror (b3:bat[:void,:void])<-(b2:bat[:void,:str])
    mil.line("var b4 := b3.reverse().join(b2);");	# 56 MILline ($78:void)<-($52:str)
    eb_a := bat.reverse(b3);	# 57 BKCreverse (eb_a:bat[:void,:void])<-(b3:bat[:void,:void])
    b4 := algebra.join(eb_a,b2);	# 58 ALGjoin (b4:bat[:void,:str])<-(eb_a:bat[:void,:void])(b2:bat[:void,:str])
    mil.line("# next line produced an incorrect error \n");	# 59 MILline ($80:void)<-($59:str)
    mil.line("# ERROR: CMDsort: returned BAT has unexpected head.\n");	# 60 MILline ($81:void)<-($61:str)
    fb_a := bat.reverse(b4);	# 61 BKCreverse (fb_a:bat[:str,:void])<-(b4:bat[:void,:str])
    gb_a := algebra.sort(fb_a);	# 62 ALGsort (gb_a:bat[:str,:void])<-(fb_a:bat[:str,:void])
    hb_a := bat.reverse(gb_a);	# 63 BKCreverse (hb_a:bat[:void,:str])<-(gb_a:bat[:str,:void])
    ib_a := io.print(hb_a);	# 64 IOprint_val (ib_a:int)<-(hb_a:bat[:void,:str])
end main;	# 65  
#var b1 := bat(oid,str);
#b1.reverse().sort().reverse().print();
#-----------------#
# t	tmp_28	  # name
# oid	str	  # type
#-----------------#
#-----------------#
# t	tmp_28	  # name
# oid	str	  # type
#-----------------#
#-----------------#
# t	tmp_30	  # name
# void	str	  # type
#-----------------#
#-----------------#
# t	tmp_30	  # name
# void	str	  # type
#-----------------#
#-----------------#
# h	tmp_31	  # name
# void	oid	  # type
#-----------------#
#-----------------#
# h	tmp_30	  # name
# oid	str	  # type
#-----------------#
#-----------------#
# h	tmp_31	  # name
# oid	str	  # type
#-----------------#
#-----------------#
# h	tmp_31	  # name
# oid	str	  # type
#-----------------#

# 22:47:53 >  
# 22:47:53 >  Done.
# 22:47:53 >  

