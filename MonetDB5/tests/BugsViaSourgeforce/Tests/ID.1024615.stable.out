stdout of test 'ID.1024615` in directory 'tests/BugsViaSourgeforce` itself:


# 16:24:49 >  
# 16:24:49 >  Mtimeout -timeout 60 Mserver "--config=/ufs/niels/data/Linux-i686/etc/MonetDB.conf" --debug=10 --set "monet_mod_path=/ufs/niels/data/Linux-i686/lib/MonetDB" --set "gdk_dbfarm=/ufs/niels/data/Linux-i686/var/MonetDB/dbfarm" --set "sql_logdir=/ufs/niels/data/Linux-i686/var/MonetDB/log" --set mapi_port=46419 --set sql_port=54865 --set monet_prompt= --trace --dbname=mTests_tests_BugsViaSourgeforce  < ID.1024615.milS
# 16:24:49 >  

# Monet Database Server V4.3.19
# Copyright (c) 1993-2004, CWI. All rights reserved.
# Compiled for x86_64-redhat-linux-gnu/64bit; dynamically linked.
# config:/home/mk/monet5/Linux/etc/MonetDB5.conf
# dbfarm:/home/mk/monet5/Linux/var/MonetDB5/dbfarm
# dbname:mTests_tests_BugsViaSourgeforce
# Visit http://monetdb.cwi.nl for further information.
## Monet Mil to Mal compiler
#include mil;
#include mil_scenario;
## Copyright (c) 2001-2004, CWI. All rights reserved.
#
## Predefined code segment
##The compiler can not guarantee an accurate compilation,
##because MIL unlike MAL is a dynamically typed language.
##A few guidelines to maximize usefullness.
##- make the type of variables explicit, in particular 'nil'
##- upon advice of M2m to remap identifiers, change it in your program directly
##var b1 := bat(oid,str);
#	b1 := new(:oid,:str);
##b1.reverse().sort().reverse().print();
#	aa_a := reverse(b1,);
#	ba_a := sort(aa_a,);
#	ca_a := reverse(ba_a,);
#	da_a := print(ca_a,);
##b1.access(BAT_WRITE);
#	BAT_WRITE:= mil.take("BAT_WRITE");
#	ea_a := access(b1,BAT_WRITE);
##b1.reverse().sort().reverse().print();
#	fa_a := reverse(b1,);
#	ga_a := sort(fa_a,);
#	ha_a := reverse(ga_a,);
#	ia_a := print(ha_a,);
##var b2 := bat(void,str);
#	b2 := new(:void,:str);
##b2.seqbase(oid(10));
#	ja_a := oid(10);
#	ka_a := bat.setSequenceBase(b2,ja_a);
##b2.reverse().sort().reverse().print();
#	la_a := reverse(b2,);
#	ma_a := sort(la_a,);
#	na_a := reverse(ma_a,);
#	oa_a := print(na_a,);
##b2.access(BAT_WRITE);
#	pa_a := access(b2,BAT_WRITE);
##b2.reverse().sort().reverse().print();
#	qa_a := reverse(b2,);
#	ra_a := sort(qa_a,);
#	sa_a := reverse(ra_a,);
#	ta_a := print(sa_a,);
##var b3 := mirror(b2);
#	b3 := mirror(b2);
##b3.print();
#	ua_a := print(b3,);
##var b4 := b3.reverse().join(b2);
#	va_a := reverse(b3,);
#	b4 := join(va_a,b2);
##b4.print();
#	wa_a := print(b4,);
##b4.reverse().sort().reverse().print();
#	xa_a := reverse(b4,);
#	ya_a := sort(xa_a,);
#	ab_a := reverse(ya_a,);
#	bb_a := print(ab_a,);
##var b2 := bat(void,str);
#	b2 := new(:void,:str);
##b2.seqbase(oid(10));
#	cb_a := oid(10);
#	db_a := bat.setSequenceBase(b2,cb_a);
##var b3 := mirror(b2);
#	b3 := mirror(b2);
##var b4 := b3.reverse().join(b2);
#	eb_a := reverse(b3,);
#	b4 := join(eb_a,b2);
##b4.reverse().sort().reverse().print();
#	fb_a := reverse(b4,);
#	gb_a := sort(fb_a,);
#	hb_a := reverse(gb_a,);
#	ib_a := print(hb_a,);
##Identifer 'seqbase' mapped to 'bat.setSequenceBase'
#
function user.main():int;	# 0  (main:int)
# Monet Mil to Mal compiler 	# 1  ($2:str)
# Copyright (c) 2001-2004, CWI. All rights reserved. 	# 2  ($4:str)
#Predefined code segment 	# 3  ($6:str)
#The compiler can not guarantee an accurate compilation, 	# 4  ($8:str)
#because MIL unlike MAL is a dynamically typed language. 	# 5  ($10:str)
#A few guidelines to maximize usefullness. 	# 6  ($12:str)
#- make the type of variables explicit, in particular 'nil' 	# 7  ($14:str)
#- upon advice of M2m to remap identifiers, change it in your program directly 	# 8  ($16:str)
#use the "mil_schema" for additional support routines 	# 9  ($18:str)
    mil.line("var b1 := bat(oid,str);");	# 10 MILline ($19:void)<-($20:str)
    b1 := bbp.new(nil:oid,"nil:str");	# 11 CMDBATnew (b1:bat[:oid,:str])<-($22:oid)($23:str)
    mil.line("b1.reverse().sort().reverse().print();");	# 12 MILline ($24:void)<-($25:str)
    aa_a := bat.reverse(b1);	# 13 BKCreverse (aa_a:bat[:str,:oid])<-(b1:bat[:oid,:str])
    ba_a := algebra.sortH(aa_a);	# 14 ALGhsort (ba_a:bat[:str,:oid])<-(aa_a:bat[:str,:oid])
    ca_a := bat.reverse(ba_a);	# 15 BKCreverse (ca_a:bat[:oid,:str])<-(ba_a:bat[:str,:oid])
    da_a := io.print(ca_a);	# 16 IOprint_val (da_a:int)<-(ca_a:bat[:oid,:str])
    mil.line("b1.access(BAT_WRITE);");	# 17 MILline ($30:void)<-($31:str)
    BAT_WRITE := mil.take("BAT_WRITE");	# 18 MILtake (BAT_WRITE:any)<-($33:str)
    ea_a := bat.access(b1,BAT_WRITE);	# 19 BKCaccess (ea_a:bat[:oid,:str])<-(b1:bat[:oid,:str])(BAT_WRITE:any)
    mil.line("b1.reverse().sort().reverse().print();");	# 20 MILline ($35:void)<-($25:str)
    fa_a := bat.reverse(b1);	# 21 BKCreverse (fa_a:bat[:str,:oid])<-(b1:bat[:oid,:str])
    ga_a := algebra.sortH(fa_a);	# 22 ALGhsort (ga_a:bat[:str,:oid])<-(fa_a:bat[:str,:oid])
    ha_a := bat.reverse(ga_a);	# 23 BKCreverse (ha_a:bat[:oid,:str])<-(ga_a:bat[:str,:oid])
    ia_a := io.print(ha_a);	# 24 IOprint_val (ia_a:int)<-(ha_a:bat[:oid,:str])
    mil.line("var b2 := bat(void,str);");	# 25 MILline ($40:void)<-($41:str)
    b2 := bbp.new(nil:void,"nil:str");	# 26 CMDBATnew (b2:bat[:void,:str])<-($43:void)($23:str)
    mil.line("b2.seqbase(oid(10));");	# 27 MILline ($44:void)<-($45:str)
    ja_a := calc.oid(10);	# 28 CALCint2oid (ja_a:oid)<-($47:int)
    ka_a := bat.setSequenceBase(b2,ja_a);	# 29 BKCsetSequenceBase (ka_a:bat[:void,:str])<-(b2:bat[:void,:str])(ja_a:oid)
    mil.line("b2.reverse().sort().reverse().print();");	# 30 MILline ($49:void)<-($50:str)
    la_a := bat.reverse(b2);	# 31 BKCreverse (la_a:bat[:str,:void])<-(b2:bat[:void,:str])
    ma_a := algebra.sortH(la_a);	# 32 ALGhsort (ma_a:bat[:str,:void])<-(la_a:bat[:str,:void])
    na_a := bat.reverse(ma_a);	# 33 BKCreverse (na_a:bat[:void,:str])<-(ma_a:bat[:str,:void])
    oa_a := io.print(na_a);	# 34 IOprint_val (oa_a:int)<-(na_a:bat[:void,:str])
    mil.line("b2.access(BAT_WRITE);");	# 35 MILline ($55:void)<-($56:str)
    pa_a := bat.access(b2,BAT_WRITE);	# 36 BKCaccess (pa_a:bat[:void,:str])<-(b2:bat[:void,:str])(BAT_WRITE:any)
    mil.line("b2.reverse().sort().reverse().print();");	# 37 MILline ($58:void)<-($50:str)
    qa_a := bat.reverse(b2);	# 38 BKCreverse (qa_a:bat[:str,:void])<-(b2:bat[:void,:str])
    ra_a := algebra.sortH(qa_a);	# 39 ALGhsort (ra_a:bat[:str,:void])<-(qa_a:bat[:str,:void])
    sa_a := bat.reverse(ra_a);	# 40 BKCreverse (sa_a:bat[:void,:str])<-(ra_a:bat[:str,:void])
    ta_a := io.print(sa_a);	# 41 IOprint_val (ta_a:int)<-(sa_a:bat[:void,:str])
    mil.line("var b3 := mirror(b2);");	# 42 MILline ($63:void)<-($64:str)
    b3 := bat.mirror(b2);	# 43 BKCmirror (b3:bat[:void,:void])<-(b2:bat[:void,:str])
    mil.line("b3.print();");	# 44 MILline ($66:void)<-($67:str)
    ua_a := io.print(b3);	# 45 IOprint_val (ua_a:int)<-(b3:bat[:void,:void])
    mil.line("var b4 := b3.reverse().join(b2);");	# 46 MILline ($69:void)<-($70:str)
    va_a := bat.reverse(b3);	# 47 BKCreverse (va_a:bat[:void,:void])<-(b3:bat[:void,:void])
    b4 := algebra.join(va_a,b2);	# 48 ALGjoin (b4:bat[:void,:str])<-(va_a:bat[:void,:void])(b2:bat[:void,:str])
    mil.line("b4.print();");	# 49 MILline ($73:void)<-($74:str)
    wa_a := io.print(b4);	# 50 IOprint_val (wa_a:int)<-(b4:bat[:void,:str])
    mil.line("# next line produced an incorrect error \n");	# 51 MILline ($76:void)<-($77:str)
    mil.line("# ERROR: CMDsort: returned BAT has unexpected head.\n");	# 52 MILline ($78:void)<-($79:str)
    xa_a := bat.reverse(b4);	# 53 BKCreverse (xa_a:bat[:str,:void])<-(b4:bat[:void,:str])
    ya_a := algebra.sortH(xa_a);	# 54 ALGhsort (ya_a:bat[:str,:void])<-(xa_a:bat[:str,:void])
    ab_a := bat.reverse(ya_a);	# 55 BKCreverse (ab_a:bat[:void,:str])<-(ya_a:bat[:str,:void])
    bb_a := io.print(ab_a);	# 56 IOprint_val (bb_a:int)<-(ab_a:bat[:void,:str])
    mil.line("#mini mil example\n");	# 57 MILline ($84:void)<-($85:str)
    mil.line("var b2 := bat(void,str);");	# 58 MILline ($86:void)<-($87:str)
    b2 := bbp.new(nil:void,"nil:str");	# 59 CMDBATnew (b2:bat[:void,:str])<-($88:void)($89:str)
    mil.line("b2.seqbase(oid(10));");	# 60 MILline ($90:void)<-($91:str)
    cb_a := calc.oid(10);	# 61 CALCint2oid (cb_a:oid)<-($93:int)
    db_a := bat.setSequenceBase(b2,cb_a);	# 62 BKCsetSequenceBase (db_a:bat[:void,:str])<-(b2:bat[:void,:str])(cb_a:oid)
    mil.line("var b3 := mirror(b2);");	# 63 MILline ($95:void)<-($64:str)
    b3 := bat.mirror(b2);	# 64 BKCmirror (b3:bat[:void,:void])<-(b2:bat[:void,:str])
    mil.line("var b4 := b3.reverse().join(b2);");	# 65 MILline ($96:void)<-($70:str)
    eb_a := bat.reverse(b3);	# 66 BKCreverse (eb_a:bat[:void,:void])<-(b3:bat[:void,:void])
    b4 := algebra.join(eb_a,b2);	# 67 ALGjoin (b4:bat[:void,:str])<-(eb_a:bat[:void,:void])(b2:bat[:void,:str])
    mil.line("# next line produced an incorrect error \n");	# 68 MILline ($98:void)<-($77:str)
    mil.line("# ERROR: CMDsort: returned BAT has unexpected head.\n");	# 69 MILline ($99:void)<-($79:str)
    fb_a := bat.reverse(b4);	# 70 BKCreverse (fb_a:bat[:str,:void])<-(b4:bat[:void,:str])
    gb_a := algebra.sortH(fb_a);	# 71 ALGhsort (gb_a:bat[:str,:void])<-(fb_a:bat[:str,:void])
    hb_a := bat.reverse(gb_a);	# 72 BKCreverse (hb_a:bat[:void,:str])<-(gb_a:bat[:str,:void])
    ib_a := io.print(hb_a);	# 73 IOprint_val (ib_a:int)<-(hb_a:bat[:void,:str])
#Identifer 'seqbase' mapped to 'bat.setSequenceBase' 	# 74  ($105:str)
end main;	# 75  
#var b1 := bat(oid,str);
#b1.reverse().sort().reverse().print();
#-----------------#
# t	tmp_28	  # name
# oid	str	  # type
#-----------------#
#-----------------#
# t	tmp_28	  # name
# oid	str	  # type
#-----------------#
#-----------------#
# t	tmp_30	  # name
# void	str	  # type
#-----------------#
#-----------------#
# t	tmp_30	  # name
# void	str	  # type
#-----------------#
#-----------------#
# h	tmp_31	  # name
# void	oid	  # type
#-----------------#
#-----------------#
# h	tmp_30	  # name
# oid	str	  # type
#-----------------#
#-----------------#
# h	tmp_31	  # name
# oid	str	  # type
#-----------------#
#-----------------#
# h	tmp_31	  # name
# oid	str	  # type
#-----------------#

# 22:47:53 >  
# 22:47:53 >  Done.
# 22:47:53 >  

