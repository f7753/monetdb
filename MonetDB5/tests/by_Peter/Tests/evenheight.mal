# Monet Mil to Mal compiler
# Copyright (c) 2001-2004, CWI. All rights reserved.

# Predefined code segment
#The compiler can not guarantee an accurate compilation,
#because MIL unlike MAL is a dynamically typed language.
#A few guidelines to maximize usefullness.
#- make the type of variables explicit, in particular 'nil'
#- upon advice of M2m to remap identifiers, change it in your program directly
function compute_mid(hst:bat[:any,:any], low:any, high:any):void;
#    var members := hst.reverse().select(low,high);
	aa_a := reverse(hst,);
	members := select(aa_a,low,high);
#    var weighed := new(int, members.ttype(), members.count());
	ba_a := getTailType(members,);
	ca_a := count(members,);
	weighed := new(:int,ba_a,ca_a);
#    var mid := nil.cast(hst.htype());
	nil:= mil.take("nil");
	da_a := getHeadType(hst,);
	mid := cast(nil,da_a);
#    var cum := 0;
	cum := 0;
#    members@batloop() {
barrier	ea_a := bunStream(members,ea_aH,ea_aT);
#        cum := cum + $h;
	cum := +(cum,ea_aH);
#        weighed.insert(cum, $t);
	fa_a := insert(weighed,cum,ea_aT);
redo	ea_a;
exit	ea_a;
#    weighed@batloop() {
barrier	ga_a := bunStream(weighed,ga_aH,ga_aT);
#        mid := $t;
	mid := ga_aT;
#        if ($h >= (cum / 2)) break;
	ha_a := /(cum,2);
barrier	ia_a := >=(ga_aH,ha_a);
leave	ga_a;
exit	ia_a;
redo	ga_a;
exit	ga_a;
#    return mid;
	return ja_a :=mid;
end compute_mid;
function range_bat(b:bat[:any,:any], n:int):bat[:any,:any];
#    var      histo := b.histogram().sort(); # sort it!
	ka_a := histogram(b,);
	histo := sort(ka_a,);
#    var     ranges := new(b.ttype(), b.ttype(), (n*4)/3);
	la_a := getTailType(b,);
	ma_a := getTailType(b,);
	na_a := *(n,4);
	oa_a := /(na_a,3);
	ranges := new(la_a,ma_a,oa_a);
#    var    cursize := 0;
	cursize := 0;
#    var items_left := b.count();
	items_left := count(b,);
#    histo@batloop() {
barrier	pa_a := bunStream(histo,pa_aH,pa_aT);
#        var idealsize := items_left/n;
	idealsize := /(items_left,n);
#        if (cursize = 0) {
barrier	qa_a := =(cursize,0);
#            first_h := $h; # the lowest element of the range
	first_h := pa_aH;
exit	qa_a;
#        cursize := cursize + $t;
	cursize := +(cursize,pa_aT);
#        if (cursize >= idealsize) {
barrier	ra_a := >=(cursize,idealsize);
#            if ((cursize - idealsize) <= (idealsize - (cursize- $t))) {
	sa_a := -(cursize,idealsize);
	ta_a := -(cursize,pa_aT);
	ua_a := -(idealsize,ta_a);
barrier	va_a := <=(sa_a,ua_a);
#                items_left := items_left - cursize;
	items_left := -(items_left,cursize);
#	             mid_h := histo.compute_mid(first_h, $h);
	mid_h := compute_mid(histo,first_h,pa_aH);
#                    last_h := $h;
	last_h := pa_aH;
#                   cursize := 0;
	cursize := 0;
exit	va_a;
#            } else {
barrier	wa_a := not(va_a);
#                items_left := items_left - (cursize - $t);
	xa_a := -(cursize,pa_aT);
	items_left := -(items_left,xa_a);
#	             mid_h := histo.compute_mid(first_h, last_h);
	mid_h := compute_mid(histo,first_h,last_h);
#                   first_h := $h;
	first_h := pa_aH;
#                   cursize := $t;
	cursize := pa_aT;
exit	wa_a;
#            ranges.insert(mid_h, last_h);
	ya_a := insert(ranges,mid_h,last_h);
#            n := n - 1;
	n := -(n,1);
exit	ra_a;
#        last_h := $h;
	last_h := pa_aH;
redo	pa_a;
exit	pa_a;
#    return ranges;
	return ab_a :=ranges;
end range_bat;
function convert_val(v:any, rng:any):any;
#        rng@batloop() {
barrier	bb_a := bunStream(rng,bb_aH,bb_aT);
#		if ($t >= v) return $h;
barrier	cb_a := >=(bb_aT,v);
	return db_a :=bb_aH;
exit	cb_a;
redo	bb_a;
exit	bb_a;
#        return nil.cast(v.type());
	nil:= mil.take("nil");
	eb_a := type(v,);
	return fb_a :=cast(nil,eb_a);
end convert_val;
function evenheight(b:bat[:any,:any], n:int):bat[:any,:any];
#        var rng := range_bat(b, n);
	rng := range_bat(b,n);
#        print(rng); # print the range (for debugging purposes)
	gb_a := print(rng);
#        return [convert_val](b, const rng);
	return hb_a :=multiplex.tactics("convert_val",b,rng);
end evenheight;
#var TheSize := 1000;
	TheSize := 1000;
#var def_tpe := new(int,int);
	def_tpe := new(:int,:int);
#var i := 0;
	i := 0;
#while (i<TheSize) { def_tpe.insert(i,rand()); i:+=1; }
barrier	ib_a := true;
barrier	jb_a := <(i,TheSize);
	kb_a := rand();
	lb_a := insert(def_tpe,i,kb_a);
redo	ib_a;
exit	jb_a;
exit	ib_a;
#var a := [str](def_tpe.mark(100000@0)).reverse().mirror();
	mb_a := mark(def_tpe,100000@0);
	nb_a := multiplex.tactics("str",mb_a);
	ob_a := reverse(nb_a,);
	a := mirror(ob_a,);
#var b := a.range_bat(10);
	b := range_bat(a,10);
#var c := [int](b.reverse().mirror());
	pb_a := reverse(b,);
	qb_a := mirror(pb_a,);
	c := multiplex.tactics("int",qb_a);
#var d := [int](b.reverse());
	rb_a := reverse(b,);
	d := multiplex.tactics("int",rb_a);
#print([-](c,d),b.reverse());
	sb_a := multiplex.tactics("-",c,d);
	tb_a := reverse(b,);
	ub_a := print(sb_a,tb_a);
#var aa := a.evenheight(9);
	aa := evenheight(a,9);
#var z1 := new(int,int);
	z1 := new(:int,:int);
#var z2 := new(int,int);
	z2 := new(:int,:int);
#i := 0;
	i := 0;
#while (i<TheSize) { z1.insert(i,rand()); z2.insert(i,i); i:+=1; }
barrier	vb_a := true;
barrier	wb_a := <(i,TheSize);
	xb_a := rand();
	yb_a := insert(z1,i,xb_a);
	ac_a := insert(z2,i,i);
redo	vb_a;
exit	wb_a;
exit	vb_a;
#printf("#~BeginVariableOutput~#\n"); var z1z:=z1.evenheight(8); printf("#~EndVariableOutput~#\n");
	bc_a := printf("#~BeginVariableOutput~#\n");
	z1z := evenheight(z1,8);
	cc_a := printf("#~EndVariableOutput~#\n");
#var z2z:=z2.evenheight(8);
	z2z := evenheight(z2,8);
#quit();
	dc_a := quit();
#Identifer 'htype' mapped to 'getHeadType'
#Identifer 'ttype' mapped to 'getTailType'
