# Monet Mil to Mal compiler
# Copyright (c) 2001-2004, CWI. All rights reserved.

# Predefined code segment
#The compiler can not guarantee an accurate compilation,
#because MIL unlike MAL is a dynamically typed language.
#A few guidelines to maximize usefullness.
#- make the type of variables explicit, in particular 'nil'
#- upon advice of M2m to remap identifiers, change it in your program directly
#var b_int := bat(int,str).insert(1,"1").insert(2,"2").insert(1,"1");
	aa_a := new(:int,:str);
	ba_a := insert(aa_a,1,"1");
	ca_a := insert(ba_a,2,"2");
	b_int := insert(ca_a,1,"1");
#b_int.insert(3,"3").insert(4,"4").insert(5,"5").insert(6,"6");
	da_a := insert(b_int,3,"3");
	ea_a := insert(da_a,4,"4");
	fa_a := insert(ea_a,5,"5");
	ga_a := insert(fa_a,6,"6");
#b_int.insert(3,"3").insert(4,"4").insert(5,"5").insert(6,"6");
	ha_a := insert(b_int,3,"3");
	ia_a := insert(ha_a,4,"4");
	ja_a := insert(ia_a,5,"5");
	ka_a := insert(ja_a,6,"6");
#var b_sht := [sht](b_int.reverse()).reverse();
	la_a := reverse(b_int,);
	ma_a := multiplex.tactics("sht",la_a);
	b_sht := reverse(ma_a,);
#var b_chr := [chr](b_int.reverse()).reverse();
	na_a := reverse(b_int,);
	oa_a := multiplex.tactics("chr",na_a);
	b_chr := reverse(oa_a,);
#var b_str := [str](b_int.reverse()).reverse();
	pa_a := reverse(b_int,);
	qa_a := multiplex.tactics("str",pa_a);
	b_str := reverse(qa_a,);
#var v_oid := bat(void,str).insert(nil,"1").insert(nil,"2").insert(nil,"3");
	nil:= mil.take("nil");
	ra_a := new(:void,:str);
	sa_a := insert(ra_a,nil,"1");
	ta_a := insert(sa_a,nil,"2");
	v_oid := insert(ta_a,nil,"3");
#v_oid.insert(nil,"4").insert(nil,"5").insert(nil,"6").seqbase(1@0);
	ua_a := insert(v_oid,nil,"4");
	va_a := insert(ua_a,nil,"5");
	wa_a := insert(va_a,nil,"6");
	xa_a := bat.setSequenceBase(wa_a,1@0);
#var e_int := bat(int,void).insert(1,nil).insert(3,nil).insert(4,nil).insert(5,nil);
	ya_a := new(:int,:void);
	ab_a := insert(ya_a,1,nil);
	bb_a := insert(ab_a,3,nil);
	cb_a := insert(bb_a,4,nil);
	e_int := insert(cb_a,5,nil);
#e_int.insert(6,nil).insert(7,nil).insert(8,nil).col_name("e_int");
	db_a := insert(e_int,6,nil);
	eb_a := insert(db_a,7,nil);
	fb_a := insert(eb_a,8,nil);
	gb_a := bat.setColumn(fb_a,"e_int");
#var e_sht := [sht](e_int.reverse()).reverse().col_name("e_sht");
	hb_a := reverse(e_int,);
	ib_a := multiplex.tactics("sht",hb_a);
	jb_a := reverse(ib_a,);
	e_sht := bat.setColumn(jb_a,"e_sht");
#var e_chr := [chr](e_int.reverse()).reverse().col_name("e_chr");
	kb_a := reverse(e_int,);
	lb_a := multiplex.tactics("chr",kb_a);
	mb_a := reverse(lb_a,);
	e_chr := bat.setColumn(mb_a,"e_chr");
#var e_str := [str](e_int.reverse()).reverse().col_name("e_str");
	nb_a := reverse(e_int,);
	ob_a := multiplex.tactics("str",nb_a);
	pb_a := reverse(ob_a,);
	e_str := bat.setColumn(pb_a,"e_str");
#var e_oid := [oid](e_int.reverse()).reverse().col_name("e_oid");
	qb_a := reverse(e_int,);
	rb_a := multiplex.tactics("oid",qb_a);
	sb_a := reverse(rb_a,);
	e_oid := bat.setColumn(sb_a,"e_oid");
#var tests := bat(bat,bat);
	tests := new(:bat[:any,:any],:bat[:any,:any]);
#tests.insert(b_int.col_name("b_int"), e_int);
	tb_a := bat.setColumn(b_int,"b_int");
	ub_a := insert(tests,tb_a,e_int);
#tests.insert(b_sht.col_name("b_sht"), e_sht);
	vb_a := bat.setColumn(b_sht,"b_sht");
	wb_a := insert(tests,vb_a,e_sht);
#tests.insert(b_chr.col_name("b_chr"), e_chr);
	xb_a := bat.setColumn(b_chr,"b_chr");
	yb_a := insert(tests,xb_a,e_chr);
#tests.insert(b_str.col_name("b_str"), e_str);
	ac_a := bat.setColumn(b_str,"b_str");
	bc_a := insert(tests,ac_a,e_str);
#tests.insert(v_oid.col_name("v_oid"), e_oid);
	cc_a := bat.setColumn(v_oid,"v_oid");
	dc_a := insert(tests,cc_a,e_oid);
#tests.insert(b_int.sort().col_name("s_int"), e_int);
	ec_a := sort(b_int,);
	fc_a := bat.setColumn(ec_a,"s_int");
	gc_a := insert(tests,fc_a,e_int);
#tests.insert(b_sht.sort().col_name("s_sht"), e_sht);
	hc_a := sort(b_sht,);
	ic_a := bat.setColumn(hc_a,"s_sht");
	jc_a := insert(tests,ic_a,e_sht);
#tests.insert(b_chr.sort().col_name("s_chr"), e_chr);
	kc_a := sort(b_chr,);
	lc_a := bat.setColumn(kc_a,"s_chr");
	mc_a := insert(tests,lc_a,e_chr);
#tests.insert(b_str.sort().col_name("s_str"), e_str);
	nc_a := sort(b_str,);
	oc_a := bat.setColumn(nc_a,"s_str");
	pc_a := insert(tests,oc_a,e_str);
function idx(b:bat[:any,:any]):bat[:any,:any];
#	b.accbuild("index");
	qc_a := accbuild(b,"index");
#	return b;
	return rc_a :=b;
end idx;
#tests.insert(b_int.copy().idx().col_name("i_int"), e_int);
	tests:= mil.take("tests");
	b_int:= mil.take("b_int");
	sc_a := copy(b_int,);
	tc_a := idx(sc_a,);
	uc_a := bat.setColumn(tc_a,"i_int");
	e_int:= mil.take("e_int");
	vc_a := insert(tests,uc_a,e_int);
#tests.insert(b_sht.copy().idx().col_name("i_sht"), e_sht);
	b_sht:= mil.take("b_sht");
	wc_a := copy(b_sht,);
	xc_a := idx(wc_a,);
	yc_a := bat.setColumn(xc_a,"i_sht");
	e_sht:= mil.take("e_sht");
	ad_a := insert(tests,yc_a,e_sht);
#tests.insert(b_chr.copy().idx().col_name("i_chr"), e_chr);
	b_chr:= mil.take("b_chr");
	bd_a := copy(b_chr,);
	cd_a := idx(bd_a,);
	dd_a := bat.setColumn(cd_a,"i_chr");
	e_chr:= mil.take("e_chr");
	ed_a := insert(tests,dd_a,e_chr);
#tests.insert(b_str.copy().idx().col_name("i_str"), e_str);
	b_str:= mil.take("b_str");
	fd_a := copy(b_str,);
	gd_a := idx(fd_a,);
	hd_a := bat.setColumn(gd_a,"i_str");
	e_str:= mil.take("e_str");
	id_a := insert(tests,hd_a,e_str);
function ku(b:bat[:any,:any]):bat[:any,:any];
#	return kunique(b);
	return jd_a :=kunique(b);
end ku;
function mstr(i:int):str;
#	if (isnil(i)) {
barrier	kd_a := isnil(i);
#		return "nil";
	return ld_a :="nil";
exit	kd_a;
#	return str(i);
	return md_a :=str(i);
end mstr;
function mset_print(m:bat[:any,:bat]):void;
#    m@batloop() {
barrier	nd_a := bunStream(m,nd_aH,nd_aT);
#        var h := $h;
	h := nd_aH;
#        var t := $t;
	t := nd_aT;
#        t@batloop() {
barrier	od_a := bunStream(t,od_aH,od_aT);
#            printf("\t%s\t%s\n", mstr(int(h)), mstr(int($t)));
	pd_a := int(h);
	qd_a := mstr(pd_a);
	rd_a := int(od_aT);
	sd_a := mstr(rd_a);
	td_a := printf("\t%s\t%s\n",qd_a,sd_a);
redo	od_a;
exit	od_a;
redo	nd_a;
exit	nd_a;
end mset_print;
function set_print(b:bat[:any,:any]):void;
#    b@batloop() {
barrier	ud_a := bunStream(b,ud_aH,ud_aT);
#        printf("\t%s\t%s\n", mstr(int($h)), mstr(int($t)));
	vd_a := int(ud_aH);
	wd_a := mstr(vd_a);
	xd_a := int(ud_aT);
	yd_a := mstr(xd_a);
	ae_a := printf("\t%s\t%s\n",wd_a,yd_a);
redo	ud_a;
exit	ud_a;
end set_print;
#debugmask(131072);
	be_a := debugmask(131072);
#tests@batloop() {
	tests:= mil.take("tests");
barrier	ce_a := bunStream(tests,ce_aH,ce_aT);
#	printf("\n# test proc {kunique}(%s)\n", $h.bbpname());
	de_a := getName(ce_aH,);
	ee_a := printf("\n# test proc {kunique}(%s)\n",de_a);
#	{ku}($h).mset_print();
	fe_a := group.ku(ce_aH);
	ge_a := mset_print(fe_a,);
redo	ce_a;
exit	ce_a;
#tests@batloop() {
barrier	he_a := bunStream(tests,he_aH,he_aT);
#	printf("\n# test proc {kunique}(%s,%s)\n", $h.bbpname(), $t.bbpname());
	ie_a := getName(he_aH,);
	je_a := getName(he_aT,);
	ke_a := printf("\n# test proc {kunique}(%s,%s)\n",ie_a,je_a);
#	{ku}($h,$t).mset_print();
	le_a := group.ku(he_aH,he_aT);
	me_a := mset_print(le_a,);
redo	he_a;
exit	he_a;
#tests@batloop() {
barrier	ne_a := bunStream(tests,ne_aH,ne_aT);
#	printf("\n# test packed {kunique}(%s)\n", $h.bbpname());
	oe_a := getName(ne_aH,);
	pe_a := printf("\n# test packed {kunique}(%s)\n",oe_a);
#	{kunique}($h).mset_print();
	qe_a := group.kunique(ne_aH);
	re_a := mset_print(qe_a,);
redo	ne_a;
exit	ne_a;
#tests@batloop() {
barrier	se_a := bunStream(tests,se_aH,se_aT);
#	printf("\n# test packed {max}(%s,%s)\n", $h.bbpname(), $t.bbpname());
	te_a := getName(se_aH,);
	ue_a := getName(se_aT,);
	ve_a := printf("\n# test packed {max}(%s,%s)\n",te_a,ue_a);
#	{max}($h,$t).set_print();
	we_a := group.max(se_aH,se_aT);
	xe_a := set_print(we_a,);
redo	se_a;
exit	se_a;
#tests@batloop() {
barrier	ye_a := bunStream(tests,ye_aH,ye_aT);
#	printf("\n# test direct {max}(%s)\n", $h.bbpname());
	af_a := getName(ye_aH,);
	bf_a := printf("\n# test direct {max}(%s)\n",af_a);
#	{max}([int]($h)).set_print();
	cf_a := multiplex.tactics("int",ye_aH);
	df_a := group.max(cf_a);
	ef_a := set_print(df_a,);
redo	ye_a;
exit	ye_a;
#tests@batloop() {
barrier	ff_a := bunStream(tests,ff_aH,ff_aT);
#	printf("\n# test direct {max}(%s,%s)\n", $h.bbpname(), $t.bbpname());
	gf_a := getName(ff_aH,);
	hf_a := getName(ff_aT,);
	if_a := printf("\n# test direct {max}(%s,%s)\n",gf_a,hf_a);
#	{max}([int]($h),$t).set_print();
	jf_a := multiplex.tactics("int",ff_aH);
	kf_a := group.max(jf_a,ff_aT);
	lf_a := set_print(kf_a,);
redo	ff_a;
exit	ff_a;
#quit();
	mf_a := quit();
#Identifer 'col_name' mapped to 'bat.setColumn'
#Identifer 'seqbase' mapped to 'bat.setSequenceBase'
#Identifer 'bbpname' mapped to 'getName'
