# Monet Mil to Mal compiler
# Copyright (c) 2001-2004, CWI. All rights reserved.

# Predefined code segment
#The compiler can not guarantee an accurate compilation,
#because MIL unlike MAL is a dynamically typed language.
#A few guidelines to maximize usefullness.
#- make the type of variables explicit, in particular 'nil'
#- upon advice of M2m to remap identifiers, change it in your program directly
#setoid(oid(20000000));
	aa_a := oid(20000000);
	ba_a := setoid(aa_a);
function xtable_print(,xtable_print:any...):void;
#        var histo := $1.histogram();
	histo := histogram($1,);
#                $2, $1.count(), histo.count(), $1.batsize());
	ca_a := count($1,);
	da_a := count(histo,);
	ea_a := bat.bbpBatSize($1,);
	fa_a := printf("\n# %s (ct: %d elts, %d groups, %d bytes)\n",$2,ca_a,da_a,ea_a);
#        table(histo.col_name("count"), $(3..));
	ga_a := bat.setColumn(histo,"count");
	ha_a := mil.getVarTempRange(3);
	ia_a := table(ga_a,ha_a);
end xtable_print;
function xtable_realloc(b:bat[:any,:any], cap:int):bat[:any,:any];
#        var inf := b.info();
	inf := info(b,);
#        var ht := monet_atomtbl.find(inf.find("head"));
	monet_atomtbl:= mil.take("monet_atomtbl");
	ja_a := find(inf,"head");
	ht := find(monet_atomtbl,ja_a);
#        var tt := monet_atomtbl.find(inf.find("tail"));
	ka_a := find(inf,"tail");
	tt := find(monet_atomtbl,ka_a);
#        var bn := new(ht, tt, cap);
	bn := new(ht,tt,cap);
#        bn.insert(b);
	la_a := insert(bn,b);
#        if (ht = void) bn.seqbase(b.reverse().fetch(0));
barrier	ma_a := =(ht,:void);
	na_a := reverse(b,);
	oa_a := fetch(na_a,0);
	pa_a := bat.setSequenceBase(bn,oa_a);
exit	ma_a;
#        if (tt = void) bn.seqbase(b.fetch(0));
barrier	qa_a := =(tt,:void);
	ra_a := fetch(b,0);
	sa_a := bat.setSequenceBase(bn,ra_a);
exit	qa_a;
#        return bn;
	return ta_a :=bn;
end xtable_realloc;
function xtable_test(title:str, x:bat[:any,:any], y:bat[:any,:any], z:bat[:any,:any]):void;
#                title, x.count(), x.batsize() + y.batsize() + z.batsize());
	ua_a := count(x,);
	va_a := bat.bbpBatSize(y,);
	wa_a := bat.bbpBatSize(z,);
	xa_a := bat.bbpBatSize(x,);
	ya_a := +(va_a,wa_a);
	ab_a := +(xa_a,ya_a);
	bb_a := printf("# xtable_test: %s grouping (%d tuples, %d bytes)\n\n",title,ua_a,ab_a);
#    x.col_name("x"); y.col_name("y"); z.col_name("z");
	cb_a := bat.setColumn(x,"x");
	db_a := bat.setColumn(y,"y");
	eb_a := bat.setColumn(z,"z");
#    print(x.slice(0,7),y,z);
	fb_a := slice(x,0,7);
	gb_a := print(fb_a,y,z);
#    printf("synced(x,y) := %s\n", synced(x,y).str());
	hb_a := isSynced(x,y);
	ib_a := str(hb_a,);
	jb_a := printf("synced(x,y) := %s\n",ib_a);
#    printf("synced(x,z) := %s\n", synced(x,z).str());
	kb_a := isSynced(x,z);
	lb_a := str(kb_a,);
	mb_a := printf("synced(x,z) := %s\n",lb_a);
#    var x1 := CTgroup(x);
	x1 := group(x);
#    x1.xtable_print("CT(x)", x);
	nb_a := xtable_print(x1,"CT(x)",x);
#    var x1y := CTgroup(x1,y);
	x1y := group(x1,y);
#    x1y.xtable_print("CT(x,y)", x, y);
	ob_a := xtable_print(x1y,"CT(x,y)",x,y);
#    var v :=  y.uselect(dbl(2.0),dbl(3.0));
	pb_a := dbl(2.0);
	qb_a := dbl(3.0);
	v := uselect(y,pb_a,qb_a);
#    var xvy := CTsubgroup(x1,y,v);
	xvy := CTsubgroup(x1,y,v);
#    xvy.xtable_print("CT(x,y|v)", x, y);
	rb_a := xtable_print(xvy,"CT(x,y|v)",x,y);
#    var x1yz := CTgroup(x1y,z);
	x1yz := group(x1y,z);
#    x1yz.xtable_print("CT(x,y,z)", x, y, z);
	sb_a := xtable_print(x1yz,"CT(x,y,z)",x,y,z);
end xtable_test;
#var x := new(oid,chr);
	x := new(:oid,:chr);
#x.insert(1@0,'a');
	tb_a := insert(x,1@0,'a');
#x.insert(2@0,'a');
	ub_a := insert(x,2@0,'a');
#x.insert(3@0,'b');
	vb_a := insert(x,3@0,'b');
#x.insert(4@0,'b');
	wb_a := insert(x,4@0,'b');
#x.insert(5@0,'b');
	xb_a := insert(x,5@0,'b');
#x.insert(6@0,'b');
	yb_a := insert(x,6@0,'b');
#x.insert(7@0,'c');
	ac_a := insert(x,7@0,'c');
#x.insert(8@0,'c');
	bc_a := insert(x,8@0,'c');
#var y:= new(oid,dbl);
	y := new(:oid,:dbl);
#y.insert(1@0,dbl(1.0));
	cc_a := dbl(1.0);
	dc_a := insert(y,1@0,cc_a);
#y.insert(2@0,dbl(3.0));
	ec_a := dbl(3.0);
	fc_a := insert(y,2@0,ec_a);
#y.insert(3@0,dbl(2.0));
	gc_a := dbl(2.0);
	hc_a := insert(y,3@0,gc_a);
#y.insert(4@0,dbl(2.0));
	ic_a := dbl(2.0);
	jc_a := insert(y,4@0,ic_a);
#y.insert(5@0,dbl(2.0));
	kc_a := dbl(2.0);
	lc_a := insert(y,5@0,kc_a);
#y.insert(6@0,dbl(3.0));
	mc_a := dbl(3.0);
	nc_a := insert(y,6@0,mc_a);
#y.insert(7@0,dbl(1.0));
	oc_a := dbl(1.0);
	pc_a := insert(y,7@0,oc_a);
#y.insert(8@0,dbl(1.0));
	qc_a := dbl(1.0);
	rc_a := insert(y,8@0,qc_a);
#var z:= new(oid,str);
	z := new(:oid,:str);
#z.insert(1@0,"c");
	sc_a := insert(z,1@0,"c");
#z.insert(2@0,"a");
	tc_a := insert(z,2@0,"a");
#z.insert(3@0,"b");
	uc_a := insert(z,3@0,"b");
#z.insert(4@0,"c");
	vc_a := insert(z,4@0,"c");
#z.insert(5@0,"a");
	wc_a := insert(z,5@0,"a");
#z.insert(6@0,"a");
	xc_a := insert(z,6@0,"a");
#z.insert(7@0,"c");
	yc_a := insert(z,7@0,"c");
#z.insert(8@0,"a");
	ad_a := insert(z,8@0,"a");
#xtable_test("small hash", x, y, z);
	bd_a := xtable_test("small hash",x,y,z);
#x := x.reverse().project().reverse().copy();
	cd_a := reverse(x,);
	dd_a := project(cd_a,);
	ed_a := reverse(dd_a,);
	x := copy(ed_a,);
#y := y.reverse().project().reverse().copy();
	fd_a := reverse(y,);
	gd_a := project(fd_a,);
	hd_a := reverse(gd_a,);
	y := copy(hd_a,);
#z := z.reverse().project().reverse().copy();
	id_a := reverse(z,);
	jd_a := project(id_a,);
	kd_a := reverse(jd_a,);
	z := copy(kd_a,);
#x.seqbase(1@0);
	ld_a := bat.setSequenceBase(x,1@0);
#y.seqbase(1@0);
	md_a := bat.setSequenceBase(y,1@0);
#z.seqbase(1@0);
	nd_a := bat.setSequenceBase(z,1@0);
#xtable_test("small vectorized", x, y, z);
	od_a := xtable_test("small vectorized",x,y,z);
#x.seqbase(oid(nil));
	nil:= mil.take("nil");
	pd_a := oid(nil);
	qd_a := bat.setSequenceBase(x,pd_a);
#y.seqbase(oid(nil));
	rd_a := oid(nil);
	sd_a := bat.setSequenceBase(y,rd_a);
#z.seqbase(oid(nil));
	td_a := oid(nil);
	ud_a := bat.setSequenceBase(z,td_a);
#print("growing tables from 8 to 512k elements...");
	vd_a := print("growing tables from 8 to 512k elements...");
#x := x.xtable_realloc(512*1024);
	wd_a := *(512,1024);
	x := xtable_realloc(x,wd_a);
#y := y.xtable_realloc(512*1024);
	xd_a := *(512,1024);
	y := xtable_realloc(y,xd_a);
#z := z.xtable_realloc(512*1024);
	yd_a := *(512,1024);
	z := xtable_realloc(z,yd_a);
#var i := 17;
	i := 17;
#while((i := i - 1) > 0) {
barrier	ae_a := true;
	i := -(i,1);
barrier	be_a := >(i,0);
#        x.insert(x.copy());
	ce_a := copy(x,);
	de_a := insert(x,ce_a);
#        y.insert(y.copy());
	ee_a := copy(y,);
	fe_a := insert(y,ee_a);
#        z.insert(z.copy());
	ge_a := copy(z,);
	he_a := insert(z,ge_a);
#        print(x.count());
	ie_a := count(x,);
	je_a := print(ie_a);
redo	ae_a;
exit	be_a;
exit	ae_a;
#print("done!");
	ke_a := print("done!");
#x := [oid](x.reverse().mark(oid(1))).reverse();
	le_a := oid(1);
	me_a := reverse(x,);
	ne_a := mark(me_a,le_a);
	oe_a := multiplex.tactics("oid",ne_a);
	x := reverse(oe_a,);
#y := [oid](y.reverse().mark(oid(1))).reverse();
	pe_a := oid(1);
	qe_a := reverse(y,);
	re_a := mark(qe_a,pe_a);
	se_a := multiplex.tactics("oid",re_a);
	y := reverse(se_a,);
#z := [oid](z.reverse().mark(oid(1))).reverse();
	te_a := oid(1);
	ue_a := reverse(z,);
	ve_a := mark(ue_a,te_a);
	we_a := multiplex.tactics("oid",ve_a);
	z := reverse(we_a,);
#y.access(BAT_WRITE);
	BAT_WRITE:= mil.take("BAT_WRITE");
	xe_a := access(y,BAT_WRITE);
#z.access(BAT_WRITE);
	ye_a := access(z,BAT_WRITE);
#y.insert(0@0,dbl(nil));
	af_a := dbl(nil);
	bf_a := insert(y,0@0,af_a);
#z.insert(0@0,str(nil));
	cf_a := str(nil);
	df_a := insert(z,0@0,cf_a);
#y.delete(0@0);
	ef_a := delete(y,0@0);
#z.delete(0@0);
	ff_a := delete(z,0@0);
#xtable_test("big hash", x, y, z);
	gf_a := xtable_test("big hash",x,y,z);
#y := x.mirror().join(y);
	hf_a := mirror(x,);
	y := join(hf_a,y);
#z := x.mirror().join(z);
	if_a := mirror(x,);
	z := join(if_a,z);
#xtable_test("big synced", x, y, z);
	jf_a := xtable_test("big synced",x,y,z);
#x := x.reverse().mark(1@0).reverse();
	kf_a := reverse(x,);
	lf_a := mark(kf_a,1@0);
	x := reverse(lf_a,);
#y := y.reverse().mark(1@0).reverse();
	mf_a := reverse(y,);
	nf_a := mark(mf_a,1@0);
	y := reverse(nf_a,);
#z := z.reverse().mark(1@0).reverse();
	of_a := reverse(z,);
	pf_a := mark(of_a,1@0);
	z := reverse(pf_a,);
#xtable_test("big vectorized", x, y, z);
	qf_a := xtable_test("big vectorized",x,y,z);
#quit();
	rf_a := quit();
#Identifer 'synced' mapped to 'isSynced'
#Identifer 'col_name' mapped to 'bat.setColumn'
#Identifer 'seqbase' mapped to 'bat.setSequenceBase'
#Identifer 'batsize' mapped to 'bat.bbpBatSize'
#Identifer 'CTgroup' mapped to 'group'
