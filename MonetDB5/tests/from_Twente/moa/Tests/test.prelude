# Monet Mil to Mal compiler
# Copyright (c) 2001-2004, CWI. All rights reserved.

# Predefined code segment
#The compiler can not guarantee an accurate compilation,
#because MIL unlike MAL is a dynamically typed language.
#A few guidelines to maximize usefullness.
#- make the type of variables explicit, in particular 'nil'
#- upon advice of M2m to remap identifiers, change it in your program directly
function he_kdiff(b1:bat[:any,:any], b2:bat[:any,:any]):bat[:any,:any];
#  IF ( b2.count() = 0 )
	aa_a := count(b2,);
barrier	ba_a := =(aa_a,0);
#    printf( "WARNING: second BAT is empty, using special kdiff!\n" );
	ca_a := printf("WARNING: second BAT is empty, using special kdiff!\n");
#    return b1.copy();
	return da_a :=copy(b1,);
exit	ba_a;
#  {
barrier	ea_a := not(ba_a);
#    return kdiff(b1, b2);
	return fa_a :=kdiff(b1,b2);
exit	ea_a;
end he_kdiff;
function load_module(mn:str):void;
#  IF ( monet_mod_nme.reverse().exist( mn ) )
	monet_mod_nme:= mil.take("monet_mod_nme");
	ga_a := reverse(monet_mod_nme,);
barrier	ha_a := exist(ga_a,mn);
#  printf( "module %s already loaded\n", mn ); ELSE 
	ia_a := printf("module %s already loaded\n",mn);
exit	ha_a;
barrier	ja_a := not(ha_a);
#    printf( "loading module %s\n", mn );
	ka_a := printf("loading module %s\n",mn);
#    eval( "module(\"" + mn + "\");" );
	la_a := +(mn,"\");");
	ma_a := +("module(\"",la_a);
	na_a := eval(ma_a);
exit	ja_a;
end load_module;
function eq(x:any, y:any):bit;
#PROC eq( any x, any y ): bit {RETURN x = y;}
	return oa_a :==(x,y);
end eq;
function ne(x:any, y:any):bit;
#PROC ne( any x, any y ): bit {RETURN x != y;}
	return pa_a :=!=(x,y);
end ne;
function lt(x:any, y:any):bit;
#PROC lt( any x, any y ): bit {RETURN x < y;}
	return qa_a :=<(x,y);
end lt;
function le(x:any, y:any):bit;
#PROC le( any x, any y ): bit {RETURN x <= y;}
	return ra_a :=<=(x,y);
end le;
function gt(x:any, y:any):bit;
#PROC gt( any x, any y ): bit {RETURN x > y;}
	return sa_a :=>(x,y);
end gt;
function ge(x:any, y:any):bit;
#PROC ge( any x, any y ): bit {RETURN x >= y;}
	return ta_a :=>=(x,y);
end ge;
function str_concat(s:bat[:oid,:str]):str;
#  VAR cur_res := "";
	cur_res := "";
#  VAR first := true;
	first := true;
#  VAR current_oid := nil;
	nil:= mil.take("nil");
	current_oid := nil;
#  VAR res := new( oid, str );
	res := new(:oid,:str);
#  s @ batloop() {
barrier	ua_a := bunStream(s,ua_aH,ua_aT);
#    IF (first)
barrier	va_a := first;
#      current_oid := $h;
	current_oid := ua_aH;
#      first := false;
	first := false;
exit	va_a;
#    IF (current_oid != $h)
barrier	wa_a := !=(current_oid,ua_aH);
#      res.insert( current_oid, cur_res );
	xa_a := insert(res,current_oid,cur_res);
#      cur_res := ""; 
	cur_res := "";
#      current_oid := $h;
	current_oid := ua_aH;
exit	wa_a;
#    cur_res := cur_res + $t;
	cur_res := +(cur_res,ua_aT);
redo	ua_a;
exit	ua_a;
#  IF (first != true)
barrier	ya_a := !=(first,true);
#    res.insert( current_oid, cur_res );
	ab_a := insert(res,current_oid,cur_res);
exit	ya_a;
#  RETURN res;
	return bb_a :=res;
end str_concat;
function sunion(bat1:bat[:any$1,:any$2], bat2:bat[:any$1,:any$2]):bat[:any$1,:any$2];
#    VAR result := new(htype(bat1), ttype(bat1));
	cb_a := getHeadType(bat1);
	db_a := getTailType(bat1);
	result := new(cb_a,db_a);
#    result.insert(bat1);
	eb_a := insert(result,bat1);
#    result.insert(bat2);
	fb_a := insert(result,bat2);
#    RETURN result;
	return gb_a :=result;
end sunion;
function mergecast(bat1:bat[:any$1,:any], bat2:bat[:any,:any$2], val:any$2):bat[:any$1,:any$2];
#      VAR tmp := [exist](const bat2.mirror(),bat1.mirror());
	hb_a := mirror(bat2,);
	ib_a := mirror(bat1,);
	tmp := multiplex.tactics("exist",hb_a,ib_a);
#      RETURN [ifthenelse](tmp,outerjoin(bat1.mirror(),bat2),val);
	jb_a := mirror(bat1,);
	kb_a := outerjoin(jb_a,bat2);
	return lb_a :=multiplex.tactics("ifthenelse",tmp,kb_a,val);
end mergecast;
function concat(bat1:bat[:any$1,:any$2], bat2:bat[:any$1,:any$2]):bat[:any$1,:any$2];
#    VAR result := new(htype(bat1), ttype(bat1));
	mb_a := getHeadType(bat1);
	nb_a := getTailType(bat1);
	result := new(mb_a,nb_a);
#    result.insert(bat1);
	ob_a := insert(result,bat1);
#    result.insert(bat2);
	pb_a := insert(result,bat2);
#    RETURN result;
	return qb_a :=result;
end concat;
function castval(bat1:bat[:any$1,:any$2], val:any$3):bat[:any$1,:any$3];
#    RETURN bat1.project(val);
	return rb_a :=project(bat1,val);
end castval;
function copy_order(xs:bat[:oid,:any], y:bat[:oid,:any$1]):bat[:oid,:any$1];
#  z  := xs.mark(0@0).reverse();  
	sb_a := mark(xs,0@0);
	z := reverse(sb_a,);
#  xy := z.join(y).sort();
	tb_a := join(z,y);
	xy := sort(tb_a,);
#  RETURN z.reverse().join(xy);
	ub_a := reverse(z,);
	return vb_a :=join(ub_a,xy);
end copy_order;
function cast_copy_order(xs:bat[:oid,:any], y:bat[:oid,:any$1]):bat[:void,:any$1];
#  z  := xs.mark(nil).reverse();
	nil:= mil.take("nil");
	wb_a := mark(xs,nil);
	z := reverse(wb_a,);
#  RETURN z.join(y).reverse().mark(0@0).reverse();
	xb_a := join(z,y);
	yb_a := reverse(xb_a,);
	ac_a := mark(yb_a,0@0);
	return bc_a :=reverse(ac_a,);
end cast_copy_order;
function CTOgroup(x:bat[:oid,:any]):bat[:oid,:int];
#  RETURN join( x, x.reverse().kunique().sort().number() );
	cc_a := reverse(x,);
	dc_a := kunique(cc_a,);
	ec_a := sort(dc_a,);
	fc_a := number(ec_a,);
	return gc_a :=join(x,fc_a);
end CTOgroup;
function CTOgroup(x:bat[:oid,:any], y:bat[:oid,:any]):bat[:oid,:int];
#  nx := CTOgroup( x );
	nx := CTOgroup(x);
#  ny := CTOgroup( y );
	ny := CTOgroup(y);
#  RETURN [+]([<<](nx,20),ny).reverse().sort().reverse();
	hc_a := multiplex.tactics("<<",nx,20);
	ic_a := multiplex.tactics("+",hc_a,ny);
	jc_a := reverse(ic_a,);
	kc_a := sort(jc_a,);
	return lc_a :=reverse(kc_a,);
end CTOgroup;
function CTOgroup_last(x:bat[:any$1,:any$2]):bat[:any$1,:int];
#  RETURN x.reverse().sort().reverse().number().sort();
	mc_a := reverse(x,);
	nc_a := sort(mc_a,);
	oc_a := reverse(nc_a,);
	pc_a := number(oc_a,);
	return qc_a :=sort(pc_a,);
end CTOgroup_last;
function CTOgroup_last(x:bat[:oid,:any], y:bat[:oid,:any]):bat[:oid,:int];
#  nx := CTOgroup( x );
	nx := CTOgroup(x);
#  ny := CTOgroup_last( y );
	ny := CTOgroup_last(y);
#  RETURN [+]([<<](nx,20),ny).reverse().sort().reverse();
	rc_a := multiplex.tactics("<<",nx,20);
	sc_a := multiplex.tactics("+",rc_a,ny);
	tc_a := reverse(sc_a,);
	uc_a := sort(tc_a,);
	return vc_a :=reverse(uc_a,);
end CTOgroup_last;
function lexsort_intern(xv:bat[:oid,:any$1], yv:bat[:oid,:any$2]):bat[:any$1,:any$2];
#  cn := CTOgroup_last( xv, yv );
	cn := CTOgroup_last(xv,yv);
#  rel := cn.mark(0@0);
	rel := mark(cn,0@0);
#  x := xv.reverse().join(rel).reverse();
	wc_a := reverse(xv,);
	xc_a := join(wc_a,rel);
	x := reverse(xc_a,);
#  y := yv.reverse().join(rel).reverse();
	yc_a := reverse(yv,);
	ad_a := join(yc_a,rel);
	y := reverse(ad_a,);
#  RETURN join(x.reverse(), y);
	bd_a := reverse(x,);
	return cd_a :=join(bd_a,y);
end lexsort_intern;
function lexsort(XY:bat[:any$1,:any$2]):bat[:any$1,:any$2];
#  xv := XY.mark(0@0).reverse();
	dd_a := mark(XY,0@0);
	xv := reverse(dd_a,);
#  yv := XY.reverse().mark(0@0).reverse();
	ed_a := reverse(XY,);
	fd_a := mark(ed_a,0@0);
	yv := reverse(fd_a,);
#  RETURN lexsort_intern( xv, yv );
	return gd_a :=lexsort_intern(xv,yv);
end lexsort;
#Identifer 'htype' mapped to 'getHeadType'
#Identifer 'ttype' mapped to 'getTailType'
