@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2005 CWI.
@' All Rights Reserved.

@f mal_meo
@a M. Kersten
@* Optimized Materialized Execution 
One of the 'short comings' of the BAT storage engine is that is uses
a simplified look on the size of things. It simply maps huge files into
memory and its opertors mindlessly constructs huge intermediate results.
This design decision was consciously taken. Running into such resource
limits should not be dealt with at all levels of the system, but
properly factored to a level where better control is available.

The infastrucuture has been stabilized enough to move ahead into
tackling these problems at the scheduler level. It is the place
where runtime information becomes available as MAL instruction
properties, e.g. the size of the the BATs being accessed.

To set the stage, consider the following MAL snippet
@example
	r:= select(R, 0, 100000);
	s:= select(S, 0, 200000);
	t:= select(s, 0,30);
	p:= prod(r,s);
	u:= f("something");
	w:= +(p,4);
	v:= sum(w);
@end example
Assume that after this block p is not used anymore.
To reduce resource contention a decision should be taken
at statement p. Let's look at those decisions in more detail.

If the product p is expected to become large, we have to break r and/or s
into pieces, such that their partial result satisfies our limits. 
The chopper module provides the necessary functionality for this.

If p is broken into pieces, then all the following steps in the
flowgraph towards the consumers of p should comprise of 'p-repeatable'
steps and the destination of p has an incremental variant.
Likewise, between the point where the operands are broken into
pieces and consumed, it should have p-repeatable statements.

The latter is easy, we simply replace the product by a nested loop
(no further optimization yet). This will ensure that the prelude 
is not affected.
@example
	r:= select(R, 0, 100000);
	s:= select(S, 0, 200000);
	t:= select(s, 0,30);
barrier (b1,rf):= chopper.newChunkIterator(r,1024);
barrier (b2,sf):= chopper.newChunkIterator(s,1024);
	p:= prod(rf,sf);
	u:= f("something");
	w:= +(p,4);
	v:= sum(w);
redo (b2,sf):= chopper.hasMoreChunks(s,1024);
redo (b1,rf):= chopper.hasMoreChunks(r,1024);
exit b2;
exit b1;
@end example
To make this work, the function f() should be moved out of the way,
e.g. by pushing it out of the loop or be it determined side-effect free.
Moving can be done when there is no interference with the other statements. 
This property often occurs in the optimizer framework and can be checked.

The update statement now also becomes dependent on a partial result and all
code depending on it should be moved into the loop.

@+ Optimization issues
Once a target operation has been isolated for chopping it up
into a loop, it becomes mandatory to find an optimal choice.
This could be focussed on minimizing the number of loop steps
up to minimizing the total footprint of its body.

The first rule to apply is to maximize the volume covered in each
step, which means you find fragment size P and Q, such that 
|r|x|s|/(PxQ) is minimized.
This under the global constraint to leave room for the body to work, which
could be determined  calculating the maximum volume needed.
(is a separate scheduler support routine)
@+ Preliminary results.
The test suite contains a simple test (tst950) that measures
the gross impact of this process. It performs a cross-product
of 1Mx1M bats, which never 
(tst950) the iterator costs about 10 microseconds per step..
@+ Optimizer focus
The first implementation of this optimizer is geared at a SQL front-end.
See for SQL specific optimization rules the corresponding source code,
called sql_optimizer.
@{
@h
#ifndef _MAL_MEO_H
#define _MAL_MEO_H
#include "mal.h"
#include "mal_interpreter.h"    /* for showErrors() */
#include "mal_function.h"
#include "mal_client.h"
#endif
@c
#include "mal_meo.h"
@}
