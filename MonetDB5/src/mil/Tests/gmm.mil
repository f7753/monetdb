#CHANGES TO ORIGINAL:
# seqbase -> setSequenceBase	(**)
# persists(FALSE) -> setTransient
# persists(TRUE) -> setPersistent
# (**) the return value is not necessarily a BAT id anymore.
#line 23 "../../../src/gmm/gmm.mx"
  module(io,alarm,lock,mmath,xtables);
  CONST Nthreads  := 4;
  CONST sessionId := "S" + int(newoid());
  VAR   randomseed;
randomseed := 40;
mem_maxsize(1000000000LL);
vm_maxsize( 2000000000LL);
  PROC init_modgmm():void { 
    VAR curthreads := threadcnt(0);
    IF (curthreads < (Nthreads + 1)) 
	threadcnt( (Nthreads - curthreads) + 1 );
    IF (isnil(randomseed)) randomseed := time();
    srand(randomseed);
  }
  init_modgmm();

  VAR GMMdebuglog := fopen("/ufs/arjen/tmp/GMM.log", "a");
  PROC debug( str msg, ..any.. ):void {
    fprintf( GMMdebuglog, "GMM: " + msg + " @ %s\n", $(2..), trim( ctime() ) );
    fflush( GMMdebuglog );
  }
  debug("Starting gmm.mil session %s", sessionId);

  PROC _x(BAT[any,any::1] x):BAT[void,any::1] {RETURN x.reverse().mark(nil).reverse();}
  PROC nx(BAT[any,any::1] x):BAT[void,any::1] {RETURN x.reverse().mark(oid(0)).reverse();}
  PROC x_(BAT[any::1,any] x):BAT[any::1,void] {RETURN x.mark(nil);}
  PROC xn(BAT[any::1,any] x):BAT[any::1,void] {RETURN x.mark(oid(0));}
  PROC Nseq(int N):BAT[void,int] {
    VAR i := 0; VAR seq := new(void,int);
    seq.setSequenceBase(oid(0));
    WHILE (i<N) { seq.insert(nil,i); i:+=1; }
    RETURN seq;
  }
  PROC randseq(int N):BAT[void,int] {
    VAR i := 0; VAR seq := new(void,int);
    seq.setSequenceBase(oid(0));
    WHILE (i<N) { seq.insert(nil,rand()); i:+=1; }
    RETURN seq;
  }

  # casting bats of bats should have worked with [dbl] but doesn't -- BUG!
  PROC conv2sht(BAT[any::1,any] b):BAT[any::1,sht] {RETURN [sht](b);}
  PROC conv2flt(BAT[any::1,any] b):BAT[any::1,flt] {RETURN [flt](b);}
  PROC conv2dbl(BAT[any::1,any] b):BAT[any::1,dbl] {RETURN [dbl](b);}

  PROC sqrt(flt x):dbl {RETURN sqrt(dbl(x));}
  PROC [sqrt](BAT[any::1,flt] x):BAT[any::1,dbl] {RETURN [sqrt]([dbl](x));}
  PROC log(flt x):dbl {RETURN log(dbl(x));}
  PROC [log](BAT[any::1,flt] x):BAT[any::1,dbl] {RETURN [log]([dbl](x));}


#line 77 "../../../src/gmm/gmm.mx"
  # circumvent parsing problems with [[op]](bat[bat],bat[bat])
  PROC nestedop(str op, bat[any::1,any] x, bat[any::1,any] y):BAT[any::1,any] {
    RETURN [* op](x, y); 
  }
  PROC nestedop(str op, bat[any::1,any] x, bat[any::1,any] y, any z):BAT[any::1,any] {
    RETURN [* op](x, y, z); 
  }
  PROC nestedop(str op, bat[any::1,any::2] x):BAT[any::1,any::2] {
    RETURN [* op](x); 
  }

  PROC square(bat[any::1,any::2] x):BAT[any::1,any::2] {RETURN [*](x, x );}

  #  post@batloop{
  #    VAR p := $t;
  #    p.access(BAT_WRITE);
  #    [:/=](p, s);
  #    p.access(BAT_READ);
  #  }



#line 392 "../../../src/gmm/gmm.mx"
  CONST N := 8;
  CONST C := 8;

  VAR cseq := Nseq( C );
  VAR nseq := Nseq( N );


#line 455 "../../../src/gmm/gmm.mx"
#VAR dict := new( str, str );
#dict.rename(sessionId + "dict");


#line 466 "../../../src/gmm/gmm.mx"
  module(enum);
  PROC init_clustertype(): int {
    VAR tc;
    IF( view_bbp_name().reverse().exist("TCluster" ) ) {
      tc := enum_load( "TCluster" );
    } ELSE {
      tc := enum_create( "TCluster", cseq );
    }
    RETURN tc;
  }
  PROC destroy_clustertype():void {
    enum_drop( TCluster );
    bat("TCluster").setTransient();
  }
  VAR TCluster := init_clustertype();
  cseq := [encode](TCluster,cseq);


#line 499 "../../../src/gmm/gmm.mx"
  PROC coeffName(int i): str { RETURN "Icoeff_" + str(i); }
  PROC newCollection( str cname, int Nimg ): BAT[str,bat] {
    VAR res := new(str,bat).rename(cname);
    VAR I := new( void, str, Nimg );
    I.setSequenceBase(oid(0)).rename( cname + "_I" );
    VAR Ib := new( oid, void, Nimg );
    VAR Ibr:= Ib.reverse();
    Ibr.setSequenceBase(oid(0));
    Ib.rename( cname + "_Ib" );
    VAR Ix := new( void, int, Nimg );
    Ix.setSequenceBase(oid(0));
    Ix.rename( cname + "_Ix" );
    VAR Iy := new( void, int, Nimg );
    Iy.setSequenceBase(oid(0));
    Iy.rename( cname + "_Iy" );
    res.insert( "I", I );
    res.insert( "Ib", Ib );
    res.insert( "Ix", Ix );
    res.insert( "Iy", Iy );
    VAR coeffs := new(int,bat,N).rename(cname + "_Icoeffs" );
    VAR i := 0;
    WHILE (i < N) {
      VAR x_i := new(void,sht,Nimg);
      x_i.setSequenceBase(oid(0));
      x_i.rename( cname + "_" + coeffName(i) );
      coeffs.insert( i, x_i );
      x_i := nil;
      i :+= 1;
    }
    res.insert( "Coeffs", coeffs );
    res.access( BAT_READ );
    RETURN res;
  }
  PROC newCollection( str cname ): BAT[str,bat] {
    RETURN newCollection(cname, 1);
  }


#line 546 "../../../src/gmm/gmm.mx"
PROC paramName(str p,int i): str { 
  RETURN p + "_" + str(i); 
}
PROC renameGMM( bat[str,bat] model, str mname ):void {
  model.rename(mname);
  model@batloop(){
    $t.rename(mname + "_" + $h);
  }
  model.find("Mean")@batloop(){
    $t.rename(mname + "_Mean_" + str($h));
  }
  model.find("Covar")@batloop(){
    $t.rename(mname + "_Covar_" + str($h));
  }
}
PROC newGMM( int Nimg ): BAT[str,bat] {
  VAR model := new(str,bat);
  VAR mImgIdx := new(oid,void,Nimg * C);
  mImgIdx.reverse().setSequenceBase(oid(0));
  mImgIdx.access( BAT_APPEND );
  model.insert("mImgIdx", mImgIdx);
  VAR mCIdx := new(TCluster,void,Nimg * C);
  mCIdx.reverse().setSequenceBase(oid(0));
  mCIdx.access( BAT_APPEND );
  model.insert("mCIdx", mCIdx);
  VAR prior := new(void,flt,Nimg * C);
  prior.setSequenceBase(oid(0));
  prior.access( BAT_APPEND );
  model.insert("Prior", prior);
  VAR mean := new(int,bat,N);
  VAR covar := new(int,bat,N);
  VAR i := 0;
  WHILE (i < N) {
    VAR mean_i := new(void,flt,Nimg*C);
    mean_i.setSequenceBase(oid(0));
    VAR variance_i := new(void,flt,Nimg*C);
    variance_i.setSequenceBase(oid(0));
    mean_i.access( BAT_APPEND );
    variance_i.access( BAT_APPEND );
    mean.insert( i, mean_i );
    covar.insert( i, variance_i );
    mean_i := nil;
    variance_i := nil;
    i :+= 1;
  }
  mean.access( BAT_READ );
  covar.access( BAT_READ );
  model.insert( "Mean", mean );
  model.insert( "Covar", covar );
  VAR init_variances := new(void,flt,Nimg * C);
  init_variances.setSequenceBase(oid(0));
  init_variances.access( BAT_APPEND );
  model.insert("init_variances", init_variances);
  model.access( BAT_READ );
  RETURN model;
}
PROC newGMM( str mname, int Nimg ): BAT[str,bat] {
  VAR gmm := newGMM(Nimg);
  renameGMM(gmm, mname);
  RETURN gmm;
}
PROC newGMM( str mname ): BAT[str,bat] {
  RETURN newGMM( mname, 1 );
}


#line 669 "../../../src/gmm/gmm.mx"
  PROC newImage( BAT[str,str] dict, str theUrl ): oid {
    VAR theImgId;
    bat(dict.find("I")).insert( nil, theUrl );
    theImgId := I.reverse().fetch( I.max );
    RETURN theImgId;
  }



#line 1264 "../../../src/gmm/gmm.mx"
  CONST Niter     := 100;
  CONST MIN_COVAR := 0.005;           # 0.005LL;
  CONST MIN_S     := 1.0e-10;	#1.0E-300LL;
  CONST COVAR_INIT_FRACTION := 0.1;   # 1.0LL/10;

  VAR olde;
  VAR loglikelihood;
  VAR EM_model;
  VAR EM_coll;



#line 1330 "../../../src/gmm/gmm.mx"


#line 1431 "../../../src/gmm/gmm.mx"


#line 1494 "../../../src/gmm/gmm.mx"
    # PROC EM(int Niter, bat[str,bat] EM_coll, bat[str,bat] EM_model):bat[str,bat]
  PROC EM_globalmodel(int Niter): bat[str,bat] {
    
#line 1279 "../../../src/gmm/gmm.mx"
  VAR gmm      := EM_model;

  VAR NImg     := EM_coll.find("I").count;
  VAR Ib       := EM_coll.find("Ib");
  VAR coeffs   := EM_coll.find("Coeffs");

  VAR gmmfinal := newGMM("gmm" + sessionId + "_final", NImg);
  
#line 655 "../../../src/gmm/gmm.mx"
  access( gmmfinal.find("init_variances"), BAT_APPEND );
  access( gmmfinal.find("Prior"), BAT_APPEND );
  access( gmmfinal.find("mImgIdx"), BAT_APPEND );
  access( gmmfinal.find("mCIdx"), BAT_APPEND );
  gmmfinal.find("Mean")@batloop{  access($t, BAT_APPEND); }
  gmmfinal.find("Covar")@batloop{ access($t, BAT_APPEND); }


#line 1286 "../../../src/gmm/gmm.mx"

      # @@modelop(gmmfinal,persists,true)@
  
#line 655 "../../../src/gmm/gmm.mx"
  mmap( gmmfinal.find("init_variances"), STORE_MEM );
  mmap( gmmfinal.find("Prior"), STORE_MEM );
  mmap( gmmfinal.find("mImgIdx"), STORE_MEM );
  mmap( gmmfinal.find("mCIdx"), STORE_MEM );
  gmmfinal.find("Mean")@batloop{  mmap($t, STORE_MEM); }
  gmmfinal.find("Covar")@batloop{ mmap($t, STORE_MEM); }


#line 1288 "../../../src/gmm/gmm.mx"


  VAR mImgIdx  := gmm.find("mImgIdx");
  VAR mCIdx    := gmm.find("mCIdx");
  VAR xcIdx    := join(Ib.reverse, mImgIdx);
  VAR xIdx     := xn(xcIdx).reverse();
  VAR cIdx     := nx(xcIdx);


#line 1496 "../../../src/gmm/gmm.mx"

    VAR iter := 1;
    WHILE (iter < Niter) {
      
#line 1349 "../../../src/gmm/gmm.mx"
  
#line 1331 "../../../src/gmm/gmm.mx"
  
#line 1305 "../../../src/gmm/gmm.mx"
  VAR covar    := gmm.find("Covar");
                  covar := [nestedop]( "dbl", covar);
  
#line 107 "../../../src/gmm/gmm.mx"
  VAR ivariances := new(covar.getType,bat,covar.count);
  {
    VAR ivariances_lock := lock_create();
    covar@ [Nthreads]batloop(){
      VAR _ivariances_result := [inv]($t
	   );
      lock_set(ivariances_lock);
      ivariances.insert($h,_ivariances_result);
      lock_unset(ivariances_lock);
    }
    lock_destroy(ivariances_lock);
  }


#line 1307 "../../../src/gmm/gmm.mx"

                  covar  := nil;
  
#line 130 "../../../src/gmm/gmm.mx"
VAR isqrtdet;

#line 127 "../../../src/gmm/gmm.mx"

#line 167 "../../../src/gmm/gmm.mx"
  {
    VAR isqrtdet_a := ivariances.fetch(0);    VAR isqrtdet_e := ivariances.fetch(4);
    VAR isqrtdet_b := ivariances.fetch(1);    VAR isqrtdet_f := ivariances.fetch(5);
    VAR isqrtdet_c := ivariances.fetch(2);    VAR isqrtdet_g := ivariances.fetch(6);
    VAR isqrtdet_d := ivariances.fetch(3);    VAR isqrtdet_h := ivariances.fetch(7);
    
#line 157 "../../../src/gmm/gmm.mx"
    # perform four operations isqrtdet_a in parallel
    {
      {|
	
#line 147 "../../../src/gmm/gmm.mx"
      # perform two operations isqrtdet_a in parallel
      {
	{|
	   isqrtdet_a := [*](isqrtdet_a,isqrtdet_b).access(BAT_WRITE);
	   isqrtdet_c := [*](isqrtdet_c,isqrtdet_d);
	 |}
	 [:*=](isqrtdet_a,isqrtdet_c);
      }


#line 160 "../../../src/gmm/gmm.mx"

	
#line 147 "../../../src/gmm/gmm.mx"
      # perform two operations isqrtdet_e in parallel
      {
	{|
	   isqrtdet_e := [*](isqrtdet_e,isqrtdet_f).access(BAT_WRITE);
	   isqrtdet_g := [*](isqrtdet_g,isqrtdet_h);
	 |}
	 [:*=](isqrtdet_e,isqrtdet_g);
      }


#line 161 "../../../src/gmm/gmm.mx"

       |}
       [:*=](isqrtdet_a,isqrtdet_e);      
    }


#line 172 "../../../src/gmm/gmm.mx"

    isqrtdet := isqrtdet_a;
  }


#line 127 "../../../src/gmm/gmm.mx"



#line 131 "../../../src/gmm/gmm.mx"



#line 1309 "../../../src/gmm/gmm.mx"

  isqrtdet     := [sqrt](isqrtdet);
  
#line 1227 "../../../src/gmm/gmm.mx"
VAR xs;

#line 1224 "../../../src/gmm/gmm.mx"

#line 1240 "../../../src/gmm/gmm.mx"
  xs := new(coeffs.getType,bat,coeffs.count);
  VAR xs_lock := lock_create();
  coeffs@ [Nthreads]batloop(){
    VAR _xs_result := join( xIdx, $t );
    lock_set(xs_lock);
    xs.insert( $h, _xs_result );
    lock_unset(xs_lock);
  }
  lock_destroy(xs_lock);


#line 1224 "../../../src/gmm/gmm.mx"



#line 1228 "../../../src/gmm/gmm.mx"



#line 1311 "../../../src/gmm/gmm.mx"

  VAR means    := [join]( const cIdx, gmm.find("Mean") );
  VAR ivars    := [join]( const cIdx, ivariances );
  VAR diffs    := [nestedop]("dmahalanobis_i_diagcov",xs,means,ivars);
  
#line 130 "../../../src/gmm/gmm.mx"
VAR dists;

#line 127 "../../../src/gmm/gmm.mx"

#line 167 "../../../src/gmm/gmm.mx"
  {
    VAR dists_a := diffs.fetch(0);    VAR dists_e := diffs.fetch(4);
    VAR dists_b := diffs.fetch(1);    VAR dists_f := diffs.fetch(5);
    VAR dists_c := diffs.fetch(2);    VAR dists_g := diffs.fetch(6);
    VAR dists_d := diffs.fetch(3);    VAR dists_h := diffs.fetch(7);
    
#line 157 "../../../src/gmm/gmm.mx"
    # perform four operations dists_a in parallel
    {
      {|
	
#line 147 "../../../src/gmm/gmm.mx"
      # perform two operations dists_a in parallel
      {
	{|
	   dists_a := [+](dists_a,dists_b).access(BAT_WRITE);
	   dists_c := [+](dists_c,dists_d);
	 |}
	 [:+=](dists_a,dists_c);
      }


#line 160 "../../../src/gmm/gmm.mx"

	
#line 147 "../../../src/gmm/gmm.mx"
      # perform two operations dists_e in parallel
      {
	{|
	   dists_e := [+](dists_e,dists_f).access(BAT_WRITE);
	   dists_g := [+](dists_g,dists_h);
	 |}
	 [:+=](dists_e,dists_g);
      }


#line 161 "../../../src/gmm/gmm.mx"

       |}
       [:+=](dists_a,dists_e);      
    }


#line 172 "../../../src/gmm/gmm.mx"

    dists := dists_a;
  }


#line 127 "../../../src/gmm/gmm.mx"



#line 131 "../../../src/gmm/gmm.mx"



#line 1315 "../../../src/gmm/gmm.mx"

                  xs     := nil;
                  diffs  := nil;
		  means  := nil;
		  ivars  := nil;
		  ivariances := nil;
  VAR isdet    := join( cIdx, isqrtdet );
  VAR act      := [multivariate_gaussian_pdf_diagcov]( dists, isdet, N );
                  dists  := nil;
                  isdet  := nil;


#line 1331 "../../../src/gmm/gmm.mx"

  VAR priors   := join( cIdx, [dbl](gmm.find("Prior")) );
  act          := [*]( act, priors );
  VAR s        {sum}( xIdx.reverse().join(act) );
#  s            := [ [>](s,const MIN_S)? s : const MIN_S ];
#  s            := [ [!=](s,const dbl(0))? s : const 1.0LL ];
  s            := [ [>](s,const MIN_S)? s : const 1.0LL ];
  VAR post     := [/](act,xIdx.join(s));
                  priors := nil;
                  act    := nil;


#line 1349 "../../../src/gmm/gmm.mx"

  
#line 1353 "../../../src/gmm/gmm.mx"
  loglikelihood := [*]([log](s), const -1);
  loglikelihood {sum}(join(Ib,loglikelihood));
                  s      := nil;
  IF (not(isnil(loglikelihood.max)))
    debug("Iter %d, maxLL %lf", iter, loglikelihood.max);
  ELSE
    debug("Iter %d", iter);    
  IF (iter>1) {
    VAR deltall := [abs]([-](loglikelihood, olde));
#print( loglikelihood, olde, deltall );
    VAR converged := [<](deltall, const 1.0LL).uselect(true);
    converged@batloop(){
      debug("Image %3d converged to (local?) maximum of likelihood", $h);
    }
    IF (converged.count > 0) {
      loglikelihood := kdiff( loglikelihood, converged );
      
#line 1386 "../../../src/gmm/gmm.mx"
  VAR restgmm := new(str,bat);

  VAR fff;
  {
    VAR convNewId := oid(gmmfinal.find("mImgIdx").count);
    VAR convIdx   := join(converged.mirror(), mImgIdx);
    
#line 611 "../../../src/gmm/gmm.mx"
{
  VAR fIdx := convIdx.reverse().mark(convNewId).reverse();

  VAR convImgIdx     := join( fIdx, gmm.find("mImgIdx").reverse );
  VAR convCIdx       := join( fIdx, gmm.find("mCIdx").reverse );
        # implementation of batinsert into empty voidbats causes trouble...
        debug("<PROPCHECK1 hkey=%s />",     
          gmmfinal.find("mImgIdx").info.find("hkey"));
  gmmfinal.find("mImgIdx").insert( convImgIdx.reverse );
        debug("<PROPCHECK2 hkey=%s />",    
          gmmfinal.find("mImgIdx").info.find("hkey"));
  gmmfinal.find("mCIdx").insert( convCIdx.reverse );

  gmmfinal.find("Prior").insert( join(fIdx, gmm.find("Prior")) );
  [insert]( gmmfinal.find("Mean"),
            [join](const fIdx, gmm.find("Mean")) );
  [insert]( gmmfinal.find("Covar"),
            [join](const fIdx, gmm.find("Covar")) );

  gmmfinal.find("init_variances").insert( join(fIdx, gmm.find("init_variances")) );
}


#line 1392 "../../../src/gmm/gmm.mx"

    
#line 1376 "../../../src/gmm/gmm.mx"
    IF ( gmmfinal.find("mImgIdx").kunique.count = NImg ) {
      debug("All images converged; break...");
      BREAK;
    }


#line 1393 "../../../src/gmm/gmm.mx"


    VAR nconvIdx  := diff(mImgIdx,convIdx);
    
#line 634 "../../../src/gmm/gmm.mx"
VAR fIdx           := nconvIdx.reverse().mark(oid(0)).reverse();
{
  VAR convImgIdx     := join( fIdx, gmm.find("mImgIdx").reverse );
  VAR convCIdx       := join( fIdx, gmm.find("mCIdx").reverse );
  restgmm.insert( "mImgIdx", convImgIdx.reverse );
  restgmm.insert( "mCIdx",   convCIdx.reverse );

  restgmm.insert( "Prior", join(fIdx, gmm.find("Prior")) );
  restgmm.insert( "Mean",  [join](const fIdx, gmm.find("Mean")) );
  restgmm.insert( "Covar", [join](const fIdx, gmm.find("Covar")) );

  restgmm.insert( "init_variances", join(fIdx, gmm.find("init_variances")) );
}


#line 1396 "../../../src/gmm/gmm.mx"


    fff := fIdx;
  }
  renameGMM(restgmm,"gmm" + sessionId + "_" + str(iter) + "_rest");
  
#line 655 "../../../src/gmm/gmm.mx"
  access( restgmm.find("init_variances"), BAT_READ );
  access( restgmm.find("Prior"), BAT_READ );
  access( restgmm.find("mImgIdx"), BAT_READ );
  access( restgmm.find("mCIdx"), BAT_READ );
  restgmm.find("Mean")@batloop{  access($t, BAT_READ); }
  restgmm.find("Covar")@batloop{ access($t, BAT_READ); }


#line 1401 "../../../src/gmm/gmm.mx"

  gmm         := restgmm;
  restgmm     := nil;

  Ib          := kdiff(Ib, converged);
  VAR iIdx    := nx(Ib); # <new oid, old oid>
  Ib          := xn(Ib);

  VAR oldc    := coeffs; # UGLY: nestedjoin macro makes new variable
  
#line 1224 "../../../src/gmm/gmm.mx"

#line 1240 "../../../src/gmm/gmm.mx"
  coeffs := new(oldc.getType,bat,oldc.count);
  VAR coeffs_lock := lock_create();
  oldc@ [Nthreads]batloop(){
    VAR _coeffs_result := join( iIdx, $t );
    lock_set(coeffs_lock);
    coeffs.insert( $h, _coeffs_result );
    lock_unset(coeffs_lock);
  }
  lock_destroy(coeffs_lock);


#line 1224 "../../../src/gmm/gmm.mx"



#line 1410 "../../../src/gmm/gmm.mx"

                  oldc    := nil;

  xIdx        := join(xIdx, iIdx.reverse);
  VAR newxIdx := xn(xIdx).reverse();
  xIdx        := nx(xIdx);
  post        := join(newxIdx, post);
  cIdx        := join(newxIdx, cIdx);
  cIdx        := join( cIdx, fff.reverse ); # renumber for mCIdx/mImgIdx
                  newxIdx := nil;             
                  fff     := nil;             

  mImgIdx     := gmm.find("mImgIdx");
  mCIdx       := gmm.find("mCIdx");


#line 1369 "../../../src/gmm/gmm.mx"

    }
    
#line 1376 "../../../src/gmm/gmm.mx"
    IF ( gmmfinal.find("mImgIdx").kunique.count = NImg ) {
      debug("All images converged; break...");
      BREAK;
    }


#line 1371 "../../../src/gmm/gmm.mx"

  }
  olde := loglikelihood;


#line 1350 "../../../src/gmm/gmm.mx"



#line 1499 "../../../src/gmm/gmm.mx"

      
#line 1432 "../../../src/gmm/gmm.mx"
   VAR newpr     {sum}( cIdx.reverse().join(post) );
                  newpr := [flt]( newpr );
   VAR newpriors := [/]( newpr,
                         mImgIdx.reverse().join( Ib.reverse().histogram ) );
debug("NP: #post %d, #newpr %d, #newpriors %d, #Ndata %d",
  cIdx.reverse().join(post).count,
  newpr.count,
  newpriors.count,
  Ib.reverse().histogram.count
);

   
#line 1224 "../../../src/gmm/gmm.mx"

#line 1240 "../../../src/gmm/gmm.mx"
  xs := new(coeffs.getType,bat,coeffs.count);
  VAR xs_lock := lock_create();
  coeffs@ [Nthreads]batloop(){
    VAR _xs_result := join( xIdx, $t );
    lock_set(xs_lock);
    xs.insert( $h, _xs_result );
    lock_unset(xs_lock);
  }
  lock_destroy(xs_lock);


#line 1224 "../../../src/gmm/gmm.mx"



#line 1443 "../../../src/gmm/gmm.mx"

   VAR xhc       := [nestedop]( "*", xs, const post );
                  xhc := [nestedop]("flt", xhc);
   
#line 1227 "../../../src/gmm/gmm.mx"
VAR gxhc;

#line 1224 "../../../src/gmm/gmm.mx"

#line 1240 "../../../src/gmm/gmm.mx"
  gxhc := new(xhc.getType,bat,xhc.count);
  VAR gxhc_lock := lock_create();
  xhc@ [Nthreads]batloop(){
    VAR _gxhc_result := join( cIdx.reverse, $t );
    lock_set(gxhc_lock);
    gxhc.insert( $h, _gxhc_result );
    lock_unset(gxhc_lock);
  }
  lock_destroy(gxhc_lock);


#line 1224 "../../../src/gmm/gmm.mx"



#line 1228 "../../../src/gmm/gmm.mx"



#line 1446 "../../../src/gmm/gmm.mx"

   
#line 107 "../../../src/gmm/gmm.mx"
  VAR newc := new(gxhc.getType,bat,gxhc.count);
  {
    VAR newc_lock := lock_create();
    gxhc@ [Nthreads]batloop(){
      VAR _newc_result {sum}($t
	   );
      lock_set(newc_lock);
      newc.insert($h,_newc_result);
      lock_unset(newc_lock);
    }
    lock_destroy(newc_lock);
  }


#line 1447 "../../../src/gmm/gmm.mx"

                  gxhc    := nil;
                  xhc     := nil;
   VAR newmeans  := [nestedop]("/", newc, const newpr);
                  newc    := nil;

   
#line 1224 "../../../src/gmm/gmm.mx"

#line 1240 "../../../src/gmm/gmm.mx"
  means := new(newmeans.getType,bat,newmeans.count);
  VAR means_lock := lock_create();
  newmeans@ [Nthreads]batloop(){
    VAR _means_result := join( cIdx, $t );
    lock_set(means_lock);
    means.insert( $h, _means_result );
    lock_unset(means_lock);
  }
  lock_destroy(means_lock);


#line 1224 "../../../src/gmm/gmm.mx"



#line 1453 "../../../src/gmm/gmm.mx"

   VAR hdiffs    := [nestedop]("-",xs,means);
                  xs      := nil;
                  means   := nil;
   hdiffs        := [square](hdiffs);
   hdiffs	 := [nestedop]("*",hdiffs,const post);
                  hdiffs := [nestedop]("flt", hdiffs);
   
#line 1227 "../../../src/gmm/gmm.mx"
VAR ghdiffs;

#line 1224 "../../../src/gmm/gmm.mx"

#line 1240 "../../../src/gmm/gmm.mx"
  ghdiffs := new(hdiffs.getType,bat,hdiffs.count);
  VAR ghdiffs_lock := lock_create();
  hdiffs@ [Nthreads]batloop(){
    VAR _ghdiffs_result := join( cIdx.reverse, $t );
    lock_set(ghdiffs_lock);
    ghdiffs.insert( $h, _ghdiffs_result );
    lock_unset(ghdiffs_lock);
  }
  lock_destroy(ghdiffs_lock);


#line 1224 "../../../src/gmm/gmm.mx"



#line 1228 "../../../src/gmm/gmm.mx"



#line 1460 "../../../src/gmm/gmm.mx"

   
#line 107 "../../../src/gmm/gmm.mx"
  VAR diffs := new(ghdiffs.getType,bat,ghdiffs.count);
  {
    VAR diffs_lock := lock_create();
    ghdiffs@ [Nthreads]batloop(){
      VAR _diffs_result {sum}($t
	   );
      lock_set(diffs_lock);
      diffs.insert($h,_diffs_result);
      lock_unset(diffs_lock);
    }
    lock_destroy(diffs_lock);
  }


#line 1461 "../../../src/gmm/gmm.mx"

                  ghdiffs := nil;
                  hdiffs  := nil;
   VAR newvars   := [nestedop]("/",diffs,const newpr);
                  diffs   := nil;


#line 1500 "../../../src/gmm/gmm.mx"

      
#line 1471 "../../../src/gmm/gmm.mx"
   
#line 130 "../../../src/gmm/gmm.mx"
VAR minvars;

#line 127 "../../../src/gmm/gmm.mx"

#line 167 "../../../src/gmm/gmm.mx"
  {
    VAR minvars_a := newvars.fetch(0);    VAR minvars_e := newvars.fetch(4);
    VAR minvars_b := newvars.fetch(1);    VAR minvars_f := newvars.fetch(5);
    VAR minvars_c := newvars.fetch(2);    VAR minvars_g := newvars.fetch(6);
    VAR minvars_d := newvars.fetch(3);    VAR minvars_h := newvars.fetch(7);
    
#line 157 "../../../src/gmm/gmm.mx"
    # perform four operations minvars_a in parallel
    {
      {|
	
#line 147 "../../../src/gmm/gmm.mx"
      # perform two operations minvars_a in parallel
      {
	{|
	   minvars_a := [min](minvars_a,minvars_b).access(BAT_WRITE);
	   minvars_c := [min](minvars_c,minvars_d);
	 |}
	 [:min=](minvars_a,minvars_c);
      }


#line 160 "../../../src/gmm/gmm.mx"

	
#line 147 "../../../src/gmm/gmm.mx"
      # perform two operations minvars_e in parallel
      {
	{|
	   minvars_e := [min](minvars_e,minvars_f).access(BAT_WRITE);
	   minvars_g := [min](minvars_g,minvars_h);
	 |}
	 [:min=](minvars_e,minvars_g);
      }


#line 161 "../../../src/gmm/gmm.mx"

       |}
       [:min=](minvars_a,minvars_e);      
    }


#line 172 "../../../src/gmm/gmm.mx"

    minvars := minvars_a;
  }


#line 127 "../../../src/gmm/gmm.mx"



#line 131 "../../../src/gmm/gmm.mx"



#line 1471 "../../../src/gmm/gmm.mx"

   VAR covarsmall    := [<](minvars,const MIN_COVAR);
   VAR covarnil      := [isnil](minvars);
   VAR covarnotsmall := [not]([or](covarsmall,covarnil));
                  covarsmall := nil;
                  covarnil   := nil;
   VAR Ntoosmall     := select(covarnotsmall,false).count;
   IF ( Ntoosmall > 0 ) {
     debug("Covariance too small in %d model(s)", Ntoosmall);
     VAR init_variances := gmm.find("init_variances");
     VAR ccovars   := new( newvars.getType, bat, newvars.count );
     newvars@batloop(){
       VAR cv := [ covarnotsmall ? $t : init_variances ];
       ccovars.insert($h, cv);
     }
     newvars := ccovars;
   }


#line 1501 "../../../src/gmm/gmm.mx"

      iter :+= 1;

      VAR gmmnew := new(str,bat);
      gmmnew.insert( "Prior",  newpriors );
      gmmnew.insert( "Mean",   newmeans );
      gmmnew.insert( "Covar",  newvars );

      gmmnew.insert("mImgIdx", mImgIdx );
      gmmnew.insert("mCIdx",   mCIdx );
      gmmnew.insert("init_variances", gmm.find("init_variances") );
      
#line 655 "../../../src/gmm/gmm.mx"
  access( gmmnew.find("init_variances"), BAT_READ );
  access( gmmnew.find("Prior"), BAT_READ );
  access( gmmnew.find("mImgIdx"), BAT_READ );
  access( gmmnew.find("mCIdx"), BAT_READ );
  gmmnew.find("Mean")@batloop{  access($t, BAT_READ); }
  gmmnew.find("Covar")@batloop{ access($t, BAT_READ); }


#line 1512 "../../../src/gmm/gmm.mx"

      gmmnew.renameGMM("gmm" + sessionId + "_" + str(iter));

      gmm := gmmnew;

      IF (iter = 2) {
        # free memory for globals
        EM_coll  := nil;
        EM_model := nil;
      }
    }
    IF (iter = Niter) {
      debug("Not all images have converged");
      VAR lastId       := oid(gmmfinal.find("mImgIdx").count);
      VAR remainingIdx := gmm.find("mImgIdx");
      
#line 611 "../../../src/gmm/gmm.mx"
{
  VAR fIdx := remainingIdx.reverse().mark(lastId).reverse();

  VAR convImgIdx     := join( fIdx, gmm.find("mImgIdx").reverse );
  VAR convCIdx       := join( fIdx, gmm.find("mCIdx").reverse );
        # implementation of batinsert into empty voidbats causes trouble...
        debug("<PROPCHECK1 hkey=%s />",     
          gmmfinal.find("mImgIdx").info.find("hkey"));
  gmmfinal.find("mImgIdx").insert( convImgIdx.reverse );
        debug("<PROPCHECK2 hkey=%s />",    
          gmmfinal.find("mImgIdx").info.find("hkey"));
  gmmfinal.find("mCIdx").insert( convCIdx.reverse );

  gmmfinal.find("Prior").insert( join(fIdx, gmm.find("Prior")) );
  [insert]( gmmfinal.find("Mean"),
            [join](const fIdx, gmm.find("Mean")) );
  [insert]( gmmfinal.find("Covar"),
            [join](const fIdx, gmm.find("Covar")) );

  gmmfinal.find("init_variances").insert( join(fIdx, gmm.find("init_variances")) );
}


#line 1527 "../../../src/gmm/gmm.mx"

    }
      # @@modelop(gmmfinal,persists,false)@
    RETURN gmmfinal;
  }

    # PROC EM(bat[str,bat] EM_coll, bat[str,bat] EM_model):bat[str,bat]
  PROC EM_globalmodel():bat[str,bat] {
    RETURN EM_globalmodel(Niter);
  }



#line 1557 "../../../src/gmm/gmm.mx"
  CONST Nsamples := 100;
  CONST mu_1 := 5.0LL; CONST sigma_1 := 2.0LL;
  CONST mu_2 := 7.0LL; CONST sigma_2 := 3.0LL;

  PROC mix2g(): dbl {
    IF ( (rand and 15) > 10 ) 
      RETURN ran_gaussian(mu_1,sigma_1);
    ELSE RETURN ran_gaussian(mu_2,sigma_2);
  }

  PROC gen2mix(int Nel):BAT[void,dbl] {
    VAR res := new(void,dbl);
    res.setSequenceBase(oid(0));
    VAR i := 0;
    WHILE (i < Nel) {
      res.insert(nil, mix2g());
      i :+=1; 
    }
    RETURN res;
  }


#line 1591 "../../../src/gmm/gmm.mx"
  PROC [cumsum](BAT[any::1,any] xs): BAT[any::1,lng] {
    VAR res := new(xs.getType,lng,xs.count);
    VAR s := lng(0);
    xs@batloop(){
      s :+= $t;
      res.insert( $h, s );
    }
    RETURN res;
  }

  
#line 1605 "../../../src/gmm/gmm.mx"
  PROC randseq(int Nsamples, bat[int,flt] prior): bat[void,any::1] {
    VAR res := new(oid, prior.getType,Nsamples);
    VAR samp := [lng](randseq(Nsamples));
    VAR cint := [cumsum]( [int]([*](prior, const RAND_MAX)) ).reverse();
    VAR ib := lng(0);
    cint@batloop(){
      VAR ie := $h;
      # a poor man's interval-join
      res.insert(
	[and]( [>](samp,ib), [<=](samp,ie) ).uselect(true).project($t) 
      );
      ib := ie;
    }
    res.order;
    RETURN nx(res).access(BAT_READ);
  }


#line 1601 "../../../src/gmm/gmm.mx"

  
#line 1605 "../../../src/gmm/gmm.mx"
  PROC randseq(int Nsamples, bat[TCluster,flt] prior): bat[void,any::1] {
    VAR res := new(oid, prior.getType,Nsamples);
    VAR samp := [lng](randseq(Nsamples));
    VAR cint := [cumsum]( [int]([*](prior, const RAND_MAX)) ).reverse();
    VAR ib := lng(0);
    cint@batloop(){
      VAR ie := $h;
      # a poor man's interval-join
      res.insert(
	[and]( [>](samp,ib), [<=](samp,ie) ).uselect(true).project($t) 
      );
      ib := ie;
    }
    res.order;
    RETURN nx(res).access(BAT_READ);
  }


#line 1602 "../../../src/gmm/gmm.mx"

  
#line 1605 "../../../src/gmm/gmm.mx"
  PROC randseq(int Nsamples, bat[void,flt] prior): bat[void,any::1] {
    VAR res := new(oid, prior.getType,Nsamples);
    VAR samp := [lng](randseq(Nsamples));
    VAR cint := [cumsum]( [int]([*](prior, const RAND_MAX)) ).reverse();
    VAR ib := lng(0);
    cint@batloop(){
      VAR ie := $h;
      # a poor man's interval-join
      res.insert(
	[and]( [>](samp,ib), [<=](samp,ie) ).uselect(true).project($t) 
      );
      ib := ie;
    }
    res.order;
    RETURN nx(res).access(BAT_READ);
  }


#line 1603 "../../../src/gmm/gmm.mx"



#line 1623 "../../../src/gmm/gmm.mx"
  PROC gmmsamp_diag( int Nsamples, bat[str,bat] gmm ): bat[str,bat] {
    VAR res := new(str,bat,2);
    VAR samples := new(int,bat,N);
    VAR XX;
    nseq@batloop{ 
	XX:= new(void,dbl,Nsamples);
	XX.setSequenceBase(oid(0)); 
	samples.insert($t,XX);
    }
    samples.access(BAT_READ);
    # do it...
    VAR mean := gmm.find("Mean");
    VAR covar := gmm.find("Covar");
    
#line 107 "../../../src/gmm/gmm.mx"
  VAR sigma := new(covar.getType,bat,covar.count);
  {
    VAR sigma_lock := lock_create();
    covar@ [Nthreads]batloop(){
      VAR _sigma_result := [sqrt]($t
	   );
      lock_set(sigma_lock);
      sigma.insert($h,_sigma_result);
      lock_unset(sigma_lock);
    }
    lock_destroy(sigma_lock);
  }


#line 1631 "../../../src/gmm/gmm.mx"


    VAR clusters := randseq(Nsamples, cseq.reverse().join(gmm.find("Prior")));
    clusters@batloop(){
      VAR c := cseq.reverse().find($t);
      [insert]( samples, const $h,
	[ran_gaussian]( [find](mean,c), [find](sigma,c) ) );
    }
    [access](samples,BAT_READ);
    # return structure
    res.insert( "Samples", samples );
    res.insert( "Clusters", clusters );
    RETURN res;
  }
  PROC gmmsamp_diag( int Nsamples, oid theImg, bat[str,bat] gmm ): bat[str,bat] {
    VAR selIdx := gmm.find("mImgIdx").reverse().uselect(theImg).mirror();
    VAR subgmm := new(str,bat);
    
#line 634 "../../../src/gmm/gmm.mx"
VAR fIdx           := selIdx.reverse().mark(oid(0)).reverse();
{
  VAR convImgIdx     := join( fIdx, gmm.find("mImgIdx").reverse );
  VAR convCIdx       := join( fIdx, gmm.find("mCIdx").reverse );
  subgmm.insert( "mImgIdx", convImgIdx.reverse );
  subgmm.insert( "mCIdx",   convCIdx.reverse );

  subgmm.insert( "Prior", join(fIdx, gmm.find("Prior")) );
  subgmm.insert( "Mean",  [join](const fIdx, gmm.find("Mean")) );
  subgmm.insert( "Covar", [join](const fIdx, gmm.find("Covar")) );

  subgmm.insert( "init_variances", join(fIdx, gmm.find("init_variances")) );
}


#line 1648 "../../../src/gmm/gmm.mx"

    RETURN gmmsamp_diag( Nsamples, subgmm );
  }

  PROC randprob(int N):bat[void,dbl] {
    VAR t := randseq(N);
    t := [/]( t, const dbl([lng](t).sum) );
    RETURN t;
  }


#line 1705 "../../../src/gmm/gmm.mx"
PROC initGMM( bat[str,bat] coll ):bat[str,bat] {
  debug("Estimating initial model");
  VAR gmm := new(str,bat);

  VAR I       := coll.find("I");
  VAR Ib      := coll.find("Ib");
  VAR coeffs  := coll.find("Coeffs");

  VAR icIdx   := I.project(1).join(cseq.reverse().project(1).reverse);
  VAR mImgIdx := xn(icIdx);
  VAR mCIdx   := nx(icIdx).reverse();

  gmm.insert( "mImgIdx", mImgIdx );
  gmm.insert( "mCIdx",   mCIdx );


#line 1722 "../../../src/gmm/gmm.mx"
  gmm.insert( "Prior", mImgIdx.reverse().project(1.0 / C ) );


#line 1727 "../../../src/gmm/gmm.mx"
  VAR aSample := new(oid,void,I.count * C).reverse();
   VAR aSampleR:= aSample.revers;
  aSampleR.setSequenceBase(oid(0));
  I.mark(oid(0))@batloop(){
    aSample.insert( Ib.reverse().select($h).sample(C).mark(oid(C * int($t))) );
  }
  gmm.insert( "Mean",
      [reverse]( 
	[join](
	  [reverse](coeffs), 
	  const aSample ))
  );


#line 1741 "../../../src/gmm/gmm.mx"
  
#line 1227 "../../../src/gmm/gmm.mx"
VAR imgcoeffs;

#line 1224 "../../../src/gmm/gmm.mx"

#line 1240 "../../../src/gmm/gmm.mx"
  imgcoeffs := new(coeffs.getType,bat,coeffs.count);
  VAR imgcoeffs_lock := lock_create();
  coeffs@ [Nthreads]batloop(){
    VAR _imgcoeffs_result := join( Ib, $t );
    lock_set(imgcoeffs_lock);
    imgcoeffs.insert( $h, _imgcoeffs_result );
    lock_unset(imgcoeffs_lock);
  }
  lock_destroy(imgcoeffs_lock);


#line 1224 "../../../src/gmm/gmm.mx"



#line 1228 "../../../src/gmm/gmm.mx"



#line 1741 "../../../src/gmm/gmm.mx"

  
#line 107 "../../../src/gmm/gmm.mx"
  VAR Area := new(imgcoeffs.getType,bat,imgcoeffs.count);
  {
    VAR Area_lock := lock_create();
    imgcoeffs@ [Nthreads]batloop(){
      VAR _Area_result {sum}($t
	   );
      lock_set(Area_lock);
      Area.insert($h,_Area_result);
      lock_unset(Area_lock);
    }
    lock_destroy(Area_lock);
  }


#line 1742 "../../../src/gmm/gmm.mx"

            imgcoeffs := nil;
  VAR Ndata := Ib.reverse().histogram;
  
#line 107 "../../../src/gmm/gmm.mx"
  VAR means := new(Area.getType,bat,Area.count);
  {
    VAR means_lock := lock_create();
    Area@ [Nthreads]batloop(){
      VAR _means_result := [/]($t
	
#line 104 "../../../src/gmm/gmm.mx"
,Ndata


#line 112 "../../../src/gmm/gmm.mx"
   );
      lock_set(means_lock);
      means.insert($h,_means_result);
      lock_unset(means_lock);
    }
    lock_destroy(means_lock);
  }


#line 1745 "../../../src/gmm/gmm.mx"

  
#line 1227 "../../../src/gmm/gmm.mx"
VAR alignedmeans;

#line 1224 "../../../src/gmm/gmm.mx"

#line 1240 "../../../src/gmm/gmm.mx"
  alignedmeans := new(means.getType,bat,means.count);
  VAR alignedmeans_lock := lock_create();
  means@ [Nthreads]batloop(){
    VAR _alignedmeans_result := join( Ib.reverse, $t );
    lock_set(alignedmeans_lock);
    alignedmeans.insert( $h, _alignedmeans_result );
    lock_unset(alignedmeans_lock);
  }
  lock_destroy(alignedmeans_lock);


#line 1224 "../../../src/gmm/gmm.mx"



#line 1228 "../../../src/gmm/gmm.mx"



#line 1746 "../../../src/gmm/gmm.mx"

            means := nil;

  VAR diffs := [nestedop]("-",coeffs,alignedmeans);
            alignedmeans := nil;
	    coeffs := nil;
  diffs := [square](diffs);       # deepop?
  
#line 1227 "../../../src/gmm/gmm.mx"
VAR imgdiffs;

#line 1224 "../../../src/gmm/gmm.mx"

#line 1240 "../../../src/gmm/gmm.mx"
  imgdiffs := new(diffs.getType,bat,diffs.count);
  VAR imgdiffs_lock := lock_create();
  diffs@ [Nthreads]batloop(){
    VAR _imgdiffs_result := join( Ib, $t );
    lock_set(imgdiffs_lock);
    imgdiffs.insert( $h, _imgdiffs_result );
    lock_unset(imgdiffs_lock);
  }
  lock_destroy(imgdiffs_lock);


#line 1224 "../../../src/gmm/gmm.mx"



#line 1228 "../../../src/gmm/gmm.mx"



#line 1753 "../../../src/gmm/gmm.mx"

  
#line 107 "../../../src/gmm/gmm.mx"
  VAR tmp := new(imgdiffs.getType,bat,imgdiffs.count);
  {
    VAR tmp_lock := lock_create();
    imgdiffs@ [Nthreads]batloop(){
      VAR _tmp_result {sum}($t
	   );
      lock_set(tmp_lock);
      tmp.insert($h,_tmp_result);
      lock_unset(tmp_lock);
    }
    lock_destroy(tmp_lock);
  }


#line 1754 "../../../src/gmm/gmm.mx"

  
#line 107 "../../../src/gmm/gmm.mx"
  VAR variances := new(tmp.getType,bat,tmp.count);
  {
    VAR variances_lock := lock_create();
    tmp@ [Nthreads]batloop(){
      VAR _variances_result := [/]($t
	
#line 104 "../../../src/gmm/gmm.mx"
,Ndata


#line 112 "../../../src/gmm/gmm.mx"
   );
      lock_set(variances_lock);
      variances.insert($h,_variances_result);
      lock_unset(variances_lock);
    }
    lock_destroy(variances_lock);
  }


#line 1755 "../../../src/gmm/gmm.mx"

            tmp := nil;
	    imgdiffs := nil;
	    Ndata := nil;
  
#line 130 "../../../src/gmm/gmm.mx"
VAR init_variances;

#line 127 "../../../src/gmm/gmm.mx"

#line 167 "../../../src/gmm/gmm.mx"
  {
    VAR init_variances_a := variances.fetch(0);    VAR init_variances_e := variances.fetch(4);
    VAR init_variances_b := variances.fetch(1);    VAR init_variances_f := variances.fetch(5);
    VAR init_variances_c := variances.fetch(2);    VAR init_variances_g := variances.fetch(6);
    VAR init_variances_d := variances.fetch(3);    VAR init_variances_h := variances.fetch(7);
    
#line 157 "../../../src/gmm/gmm.mx"
    # perform four operations init_variances_a in parallel
    {
      {|
	
#line 147 "../../../src/gmm/gmm.mx"
      # perform two operations init_variances_a in parallel
      {
	{|
	   init_variances_a := [+](init_variances_a,init_variances_b).access(BAT_WRITE);
	   init_variances_c := [+](init_variances_c,init_variances_d);
	 |}
	 [:+=](init_variances_a,init_variances_c);
      }


#line 160 "../../../src/gmm/gmm.mx"

	
#line 147 "../../../src/gmm/gmm.mx"
      # perform two operations init_variances_e in parallel
      {
	{|
	   init_variances_e := [+](init_variances_e,init_variances_f).access(BAT_WRITE);
	   init_variances_g := [+](init_variances_g,init_variances_h);
	 |}
	 [:+=](init_variances_e,init_variances_g);
      }


#line 161 "../../../src/gmm/gmm.mx"

       |}
       [:+=](init_variances_a,init_variances_e);      
    }


#line 172 "../../../src/gmm/gmm.mx"

    init_variances := init_variances_a;
  }


#line 127 "../../../src/gmm/gmm.mx"



#line 131 "../../../src/gmm/gmm.mx"



#line 1759 "../../../src/gmm/gmm.mx"

  init_variances := [*]( [/]( init_variances, const N ), 
    const COVAR_INIT_FRACTION );
    # Q: blow up this one here or in the loop???
  init_variances := join(mImgIdx.reverse, init_variances);
  gmm.insert( "init_variances", init_variances );

  VAR covar := new(int,bat,N);
  VAR i := 0;
  WHILE (i < N) {
    covar.insert( i, init_variances );
    i :+= 1;
  }
  gmm.insert( "Covar", covar );

  gmm.renameGMM("gmm" + sessionId + "_init");
  RETURN gmm;
}



#line 1781 "../../../src/gmm/gmm.mx"
PROC test_EM(int Nimg, int M): bat[str,bat] {
  VAR testmodels := new(str,bat);

  debug("Creating collection with M=%d",M);
  VAR imgs := newCollection("imgs" + sessionId, Nimg);
  
#line 663 "../../../src/gmm/gmm.mx"
  imgs.find("Coeffs")@batloop{ setPersistent($t); }
  imgs@batloop(){ setPersistent($t); }


#line 1786 "../../../src/gmm/gmm.mx"

  
#line 663 "../../../src/gmm/gmm.mx"
  imgs.find("Coeffs")@batloop{ mmap($t, STORE_MMAP); }
  imgs@batloop(){ mmap($t, STORE_MMAP); }


#line 1787 "../../../src/gmm/gmm.mx"



#line 1793 "../../../src/gmm/gmm.mx"
           imgs.find("Coeffs").setTransient();
  VAR src_gmm := newGMM("src" + sessionId);
  
#line 655 "../../../src/gmm/gmm.mx"
  setPersistent( src_gmm.find("init_variances") );
  setPersistent( src_gmm.find("Prior") );
  setPersistent( src_gmm.find("mImgIdx") );
  setPersistent( src_gmm.find("mCIdx") );
  src_gmm.find("Mean")@batloop{  setPersistent($t); }
  src_gmm.find("Covar")@batloop{ setPersistent($t); }


#line 1795 "../../../src/gmm/gmm.mx"

  
#line 655 "../../../src/gmm/gmm.mx"
  mmap( src_gmm.find("init_variances"), STORE_MMAP );
  mmap( src_gmm.find("Prior"), STORE_MMAP );
  mmap( src_gmm.find("mImgIdx"), STORE_MMAP );
  mmap( src_gmm.find("mCIdx"), STORE_MMAP );
  src_gmm.find("Mean")@batloop{  mmap($t, STORE_MMAP); }
  src_gmm.find("Covar")@batloop{ mmap($t, STORE_MMAP); }


#line 1796 "../../../src/gmm/gmm.mx"


  
#line 1663 "../../../src/gmm/gmm.mx"
  
#line 663 "../../../src/gmm/gmm.mx"
  imgs.find("Coeffs")@batloop{ access($t, BAT_APPEND); }
  imgs@batloop(){ access($t, BAT_APPEND); }


#line 1663 "../../../src/gmm/gmm.mx"

  
#line 655 "../../../src/gmm/gmm.mx"
  access( src_gmm.find("init_variances"), BAT_APPEND );
  access( src_gmm.find("Prior"), BAT_APPEND );
  access( src_gmm.find("mImgIdx"), BAT_APPEND );
  access( src_gmm.find("mCIdx"), BAT_APPEND );
  src_gmm.find("Mean")@batloop{  access($t, BAT_APPEND); }
  src_gmm.find("Covar")@batloop{ access($t, BAT_APPEND); }


#line 1664 "../../../src/gmm/gmm.mx"

  # some random metadata for now
  imgs.find("I").insert(nil,"http://nowhere.org/noimg_" + str(0) + ".jpg");
  Nseq(M)@batloop(){
    imgs.find("Ib").insert(oid(0),nil);
    imgs.find("Ix").insert(nil, ($t % 44));
    imgs.find("Iy").insert(nil, ($t / 44));
  }
  src_gmm.find("Prior").insert( [flt](randprob(C)) );
  cseq@batloop(){
    # NOTE: was RAND_MAX + 1.0LL
    [insert]( src_gmm.find("Mean"), const nil,
      [/]( randseq(N), const (RAND_MAX + 1.0) / 255).reverse().number.reverse );
    [insert]( src_gmm.find("Covar"), const nil,
      [/]( randseq(N), const (RAND_MAX + 1.0) / 128).reverse().number.reverse );
  }
  src_gmm.find("mImgIdx").insert(_x(cseq).project(const oid(0)).reverse);
  src_gmm.find("mCIdx").insert(_x(cseq).reverse);
    # bug with first insert in table
  src_gmm.find("mImgIdx").reverse().setSequenceBase(oid(0)).reverse();
  src_gmm.find("mCIdx").reverse().setSequenceBase(oid(0)).reverse();
  
#line 655 "../../../src/gmm/gmm.mx"
  access( src_gmm.find("init_variances"), BAT_READ );
  access( src_gmm.find("Prior"), BAT_READ );
  access( src_gmm.find("mImgIdx"), BAT_READ );
  access( src_gmm.find("mCIdx"), BAT_READ );
  src_gmm.find("Mean")@batloop{  access($t, BAT_READ); }
  src_gmm.find("Covar")@batloop{ access($t, BAT_READ); }


#line 1685 "../../../src/gmm/gmm.mx"

  VAR aSampleImg := gmmsamp_diag(M, oid(0), src_gmm);
  {
    VAR imgSamples := [nestedop]( "sht", aSampleImg.find("Samples") );
    [insert](
      imgs.find("Coeffs"),
      imgSamples
    );
    commit;
  }
  
#line 663 "../../../src/gmm/gmm.mx"
  imgs.find("Coeffs")@batloop{ access($t, BAT_READ); }
  imgs@batloop(){ access($t, BAT_READ); }


#line 1695 "../../../src/gmm/gmm.mx"



#line 1798 "../../../src/gmm/gmm.mx"

  src_gmm.find("mImgIdx").reverse().setSequenceBase(oid(0)); # bug??
  src_gmm.find("mCIdx").reverse().setSequenceBase(oid(0));

  # Insert additional images
  VAR imgNr := 1;
  WHILE ( imgNr < Nimg ) {
    
#line 1663 "../../../src/gmm/gmm.mx"
  
#line 663 "../../../src/gmm/gmm.mx"
  imgs.find("Coeffs")@batloop{ access($t, BAT_APPEND); }
  imgs@batloop(){ access($t, BAT_APPEND); }


#line 1663 "../../../src/gmm/gmm.mx"

  
#line 655 "../../../src/gmm/gmm.mx"
  access( src_gmm.find("init_variances"), BAT_APPEND );
  access( src_gmm.find("Prior"), BAT_APPEND );
  access( src_gmm.find("mImgIdx"), BAT_APPEND );
  access( src_gmm.find("mCIdx"), BAT_APPEND );
  src_gmm.find("Mean")@batloop{  access($t, BAT_APPEND); }
  src_gmm.find("Covar")@batloop{ access($t, BAT_APPEND); }


#line 1664 "../../../src/gmm/gmm.mx"

  # some random metadata for now
  imgs.find("I").insert(nil,"http://nowhere.org/noimg_" + str(imgNr) + ".jpg");
  Nseq(M)@batloop(){
    imgs.find("Ib").insert(oid(imgNr),nil);
    imgs.find("Ix").insert(nil, ($t % 44));
    imgs.find("Iy").insert(nil, ($t / 44));
  }
  src_gmm.find("Prior").insert( [flt](randprob(C)) );
  cseq@batloop(){
    # NOTE: was RAND_MAX + 1.0LL
    [insert]( src_gmm.find("Mean"), const nil,
      [/]( randseq(N), const (RAND_MAX + 1.0) / 255).reverse().number.reverse );
    [insert]( src_gmm.find("Covar"), const nil,
      [/]( randseq(N), const (RAND_MAX + 1.0) / 128).reverse().number.reverse );
  }
  src_gmm.find("mImgIdx").insert(_x(cseq).project(const oid(imgNr)).reverse);
  src_gmm.find("mCIdx").insert(_x(cseq).reverse);
    # bug with first insert in table
  src_gmm.find("mImgIdx").reverse().setSequenceBase(oid(0)).reverse();
  src_gmm.find("mCIdx").reverse().setSequenceBase(oid(0)).reverse();
  
#line 655 "../../../src/gmm/gmm.mx"
  access( src_gmm.find("init_variances"), BAT_READ );
  access( src_gmm.find("Prior"), BAT_READ );
  access( src_gmm.find("mImgIdx"), BAT_READ );
  access( src_gmm.find("mCIdx"), BAT_READ );
  src_gmm.find("Mean")@batloop{  access($t, BAT_READ); }
  src_gmm.find("Covar")@batloop{ access($t, BAT_READ); }


#line 1685 "../../../src/gmm/gmm.mx"

  VAR aSampleImg := gmmsamp_diag(M, oid(imgNr), src_gmm);
  {
    VAR imgSamples := [nestedop]( "sht", aSampleImg.find("Samples") );
    [insert](
      imgs.find("Coeffs"),
      imgSamples
    );
    commit;
  }
  
#line 663 "../../../src/gmm/gmm.mx"
  imgs.find("Coeffs")@batloop{ access($t, BAT_READ); }
  imgs@batloop(){ access($t, BAT_READ); }


#line 1695 "../../../src/gmm/gmm.mx"



#line 1805 "../../../src/gmm/gmm.mx"

    imgNr :+= 1;
  }
#  testmodels.insert( "coll",  imgs );
#  testmodels.insert( "src",   src_gmm );

  VAR gmm := initGMM( imgs );
#  testmodels.insert( "init",  gmm );


#line 1816 "../../../src/gmm/gmm.mx"
  debug("EM model training");
  EM_coll  := imgs;
  EM_model := gmm;
    src_gmm := nil;
    imgs := nil;
    gmm  := nil;
    #VAR gmmnew := EM(imgs, gmm);
  VAR gmmnew := EM_globalmodel();
  testmodels.insert( "final", gmmnew );

  # @@imgop(imgs,persists,false)@
  # @@modelop(src_gmm,persists,false)@

  RETURN testmodels;
}
#VAR testmodels := test_EM(128,1320);
#VAR testmodels := test_EM(10,100);



#line 1838 "../../../src/gmm/gmm.mx"
  PROC classify( bat[int,bat] coeffs, bat[str,bat] gmm ): bat[void,TCluster] {
    
#line 1331 "../../../src/gmm/gmm.mx"
  
#line 1305 "../../../src/gmm/gmm.mx"
  VAR covar    := gmm.find("Covar");
                  covar := [nestedop]( "dbl", covar);
  
#line 107 "../../../src/gmm/gmm.mx"
  VAR ivariances := new(covar.getType,bat,covar.count);
  {
    VAR ivariances_lock := lock_create();
    covar@ [Nthreads]batloop(){
      VAR _ivariances_result := [inv]($t
	   );
      lock_set(ivariances_lock);
      ivariances.insert($h,_ivariances_result);
      lock_unset(ivariances_lock);
    }
    lock_destroy(ivariances_lock);
  }


#line 1307 "../../../src/gmm/gmm.mx"

                  covar  := nil;
  
#line 130 "../../../src/gmm/gmm.mx"
VAR isqrtdet;

#line 127 "../../../src/gmm/gmm.mx"

#line 167 "../../../src/gmm/gmm.mx"
  {
    VAR isqrtdet_a := ivariances.fetch(0);    VAR isqrtdet_e := ivariances.fetch(4);
    VAR isqrtdet_b := ivariances.fetch(1);    VAR isqrtdet_f := ivariances.fetch(5);
    VAR isqrtdet_c := ivariances.fetch(2);    VAR isqrtdet_g := ivariances.fetch(6);
    VAR isqrtdet_d := ivariances.fetch(3);    VAR isqrtdet_h := ivariances.fetch(7);
    
#line 157 "../../../src/gmm/gmm.mx"
    # perform four operations isqrtdet_a in parallel
    {
      {|
	
#line 147 "../../../src/gmm/gmm.mx"
      # perform two operations isqrtdet_a in parallel
      {
	{|
	   isqrtdet_a := [*](isqrtdet_a,isqrtdet_b).access(BAT_WRITE);
	   isqrtdet_c := [*](isqrtdet_c,isqrtdet_d);
	 |}
	 [:*=](isqrtdet_a,isqrtdet_c);
      }


#line 160 "../../../src/gmm/gmm.mx"

	
#line 147 "../../../src/gmm/gmm.mx"
      # perform two operations isqrtdet_e in parallel
      {
	{|
	   isqrtdet_e := [*](isqrtdet_e,isqrtdet_f).access(BAT_WRITE);
	   isqrtdet_g := [*](isqrtdet_g,isqrtdet_h);
	 |}
	 [:*=](isqrtdet_e,isqrtdet_g);
      }


#line 161 "../../../src/gmm/gmm.mx"

       |}
       [:*=](isqrtdet_a,isqrtdet_e);      
    }


#line 172 "../../../src/gmm/gmm.mx"

    isqrtdet := isqrtdet_a;
  }


#line 127 "../../../src/gmm/gmm.mx"



#line 131 "../../../src/gmm/gmm.mx"



#line 1309 "../../../src/gmm/gmm.mx"

  isqrtdet     := [sqrt](isqrtdet);
  
#line 1227 "../../../src/gmm/gmm.mx"
VAR xs;

#line 1224 "../../../src/gmm/gmm.mx"

#line 1240 "../../../src/gmm/gmm.mx"
  xs := new(coeffs.getType,bat,coeffs.count);
  VAR xs_lock := lock_create();
  coeffs@ [Nthreads]batloop(){
    VAR _xs_result := join( xIdx, $t );
    lock_set(xs_lock);
    xs.insert( $h, _xs_result );
    lock_unset(xs_lock);
  }
  lock_destroy(xs_lock);


#line 1224 "../../../src/gmm/gmm.mx"



#line 1228 "../../../src/gmm/gmm.mx"



#line 1311 "../../../src/gmm/gmm.mx"

  VAR means    := [join]( const cIdx, gmm.find("Mean") );
  VAR ivars    := [join]( const cIdx, ivariances );
  VAR diffs    := [nestedop]("dmahalanobis_i_diagcov",xs,means,ivars);
  
#line 130 "../../../src/gmm/gmm.mx"
VAR dists;

#line 127 "../../../src/gmm/gmm.mx"

#line 167 "../../../src/gmm/gmm.mx"
  {
    VAR dists_a := diffs.fetch(0);    VAR dists_e := diffs.fetch(4);
    VAR dists_b := diffs.fetch(1);    VAR dists_f := diffs.fetch(5);
    VAR dists_c := diffs.fetch(2);    VAR dists_g := diffs.fetch(6);
    VAR dists_d := diffs.fetch(3);    VAR dists_h := diffs.fetch(7);
    
#line 157 "../../../src/gmm/gmm.mx"
    # perform four operations dists_a in parallel
    {
      {|
	
#line 147 "../../../src/gmm/gmm.mx"
      # perform two operations dists_a in parallel
      {
	{|
	   dists_a := [+](dists_a,dists_b).access(BAT_WRITE);
	   dists_c := [+](dists_c,dists_d);
	 |}
	 [:+=](dists_a,dists_c);
      }


#line 160 "../../../src/gmm/gmm.mx"

	
#line 147 "../../../src/gmm/gmm.mx"
      # perform two operations dists_e in parallel
      {
	{|
	   dists_e := [+](dists_e,dists_f).access(BAT_WRITE);
	   dists_g := [+](dists_g,dists_h);
	 |}
	 [:+=](dists_e,dists_g);
      }


#line 161 "../../../src/gmm/gmm.mx"

       |}
       [:+=](dists_a,dists_e);      
    }


#line 172 "../../../src/gmm/gmm.mx"

    dists := dists_a;
  }


#line 127 "../../../src/gmm/gmm.mx"



#line 131 "../../../src/gmm/gmm.mx"



#line 1315 "../../../src/gmm/gmm.mx"

                  xs     := nil;
                  diffs  := nil;
		  means  := nil;
		  ivars  := nil;
		  ivariances := nil;
  VAR isdet    := join( cIdx, isqrtdet );
  VAR act      := [multivariate_gaussian_pdf_diagcov]( dists, isdet, N );
                  dists  := nil;
                  isdet  := nil;


#line 1331 "../../../src/gmm/gmm.mx"

  VAR priors   := join( cIdx, [dbl](gmm.find("Prior")) );
  act          := [*]( act, priors );
  VAR s        {sum}( xIdx.reverse().join(act) );
#  s            := [ [>](s,const MIN_S)? s : const MIN_S ];
#  s            := [ [!=](s,const dbl(0))? s : const 1.0LL ];
  s            := [ [>](s,const MIN_S)? s : const 1.0LL ];
  VAR post     := [/](act,xIdx.join(s));
                  priors := nil;
                  act    := nil;


#line 1839 "../../../src/gmm/gmm.mx"

    VAR pmax := post.fetch(0);
    VAR res  := pmax.project(const encode(TCluster, post.mirror().fetch(0)));
    post@batloop(){
      VAR pcomp := [<=]($t,pmax);
      res :=  [ pcomp ?  res : const encode(TCluster, $h) ];
      pmax := [ pcomp ? pmax : $t ];
    }
    RETURN res;
  }


#line 1853 "../../../src/gmm/gmm.mx"
  PROC vectostr( BAT[any,dbl] x ): str {
    VAR s := "< ";
    s :+= sprintf( "%4.0lf", x.fetch(0) );
    x.slice(1, x.count - 1)@batloop(){
      s :+= sprintf( ", %4.0lf", $t );
    }
    s :+= " >";
    RETURN s;
  }
  PROC vectostr( BAT[any,flt] x ): str {
    VAR s := "< ";
    s :+= sprintf( "%4.0f", x.fetch(0) );
    x.slice(1, x.count - 1)@batloop(){
      s :+= sprintf( ", %4.0f", $t );
    }
    s :+= " >";
    RETURN s;
  }

  CONST infosep :=
    "------------------------------------------------------------";
  PROC gmminfo( BAT[str,bat] gmm ): BAT[void,str] {
    VAR s := new(void,str).setSequenceBase(oid(0));
    VAR imgidx := gmm.find("mImgIdx").reverse();
    VAR oldimgid := imgidx.fetch(0);
    VAR imgid := oldimgid;
    gmm.find("mImgIdx").kunique.sort@batloop(){
      VAR imgid := $h;
      s.insert( nil, sprintf("-- Img %3d --", imgid) + infosep );

      imgidx.select($h).mirror().join(gmm.find("mCIdx").reverse).reverse().sort@batloop(){
	s.insert( nil, sprintf( "prior[%d]: %.3lf\t", $h, dbl(find(gmm.find("Prior"), $t)) ) +
		       "mean:  " + vectostr([find](gmm.find("Mean" ),$t)) );
	s.insert( nil, "            \tcovar: " +vectostr([find](gmm.find("Covar"),$t)) );
      }
    }
    s.insert( nil, "-------------" + infosep );
    RETURN s;
  }

  PROC printmodel( BAT[str,bat] gmm ): void {
    VAR g := gmminfo(gmm);
    [printf]( g.project("%s\n"), g );
  }
  PROC printmodels( BAT[str,bat] gmma, BAT[str,bat] gmmb ): void {
    VAR ga := gmminfo(gmma);
    VAR gb := gmminfo(gmmb);
    [printf]( const "%s\t|\t%s\n", ga, gb );
  }

#  printmodels( testmodels.find("src"), 
#               testmodels.find("final") );


#line 1909 "../../../src/gmm/gmm.mx"
  PROC sampleQueries(int Nqimg, BAT[str,bat] testmodels):bat[str,bat] {
    VAR qgmm := new(str,bat);
    {
      VAR gmm   := testmodels.find("src");
      VAR qimgs := testmodels.find("coll").find("I").sample(Nqimg);
      VAR qimgidx := join(qimgs.mirror(), gmm.find("mImgIdx"));
      
#line 634 "../../../src/gmm/gmm.mx"
VAR fIdx           := qimgidx.reverse().mark(oid(0)).reverse();
{
  VAR convImgIdx     := join( fIdx, gmm.find("mImgIdx").reverse );
  VAR convCIdx       := join( fIdx, gmm.find("mCIdx").reverse );
  qgmm.insert( "mImgIdx", convImgIdx.reverse );
  qgmm.insert( "mCIdx",   convCIdx.reverse );

  qgmm.insert( "Prior", join(fIdx, gmm.find("Prior")) );
  qgmm.insert( "Mean",  [join](const fIdx, gmm.find("Mean")) );
  qgmm.insert( "Covar", [join](const fIdx, gmm.find("Covar")) );

  qgmm.insert( "init_variances", join(fIdx, gmm.find("init_variances")) );
}


#line 1915 "../../../src/gmm/gmm.mx"

      renameGMM(qgmm,"gmm" + sessionId + "_query");
      
#line 655 "../../../src/gmm/gmm.mx"
  access( qgmm.find("init_variances"), BAT_READ );
  access( qgmm.find("Prior"), BAT_READ );
  access( qgmm.find("mImgIdx"), BAT_READ );
  access( qgmm.find("mCIdx"), BAT_READ );
  qgmm.find("Mean")@batloop{  access($t, BAT_READ); }
  qgmm.find("Covar")@batloop{ access($t, BAT_READ); }


#line 1917 "../../../src/gmm/gmm.mx"

    }
    RETURN qgmm;
  }


#line 1926 "../../../src/gmm/gmm.mx"
  # VAR gmm_q := sampleQueries(4,testmodels);
  # VAR gmm_i := testmodels.find("final");

  PROC RSL( bat[str,bat] gmm_q, bat[str,bat] gmm_i ):void {
    VAR cqciIdx     := join(gmm_q.find("mCIdx").reverse, gmm_i.find("mCIdx"));
    VAR ciIdx	    := nx(cqciIdx);
    VAR cqIdx	    := xn(cqciIdx).reverse();

    VAR gqiIdx      := join(gmm_q.find("mImgIdx").reverse, 
			 join(gmm_q.find("mImgIdx"), cqIdx.reverse));
    VAR giIdx       := nx(gqiIdx);

    VAR qiIdx       := join(gqiIdx, ciIdx);
    VAR qIdx        := xn(qiIdx).reverse();
    VAR iIdx        := nx(qiIdx);


#line 1944 "../../../src/gmm/gmm.mx"
    VAR logpriors_i := [log](gmm_i.find("Prior"));
    VAR covar_i     := gmm_i.find("Covar");
    
#line 130 "../../../src/gmm/gmm.mx"
VAR det_i;

#line 127 "../../../src/gmm/gmm.mx"

#line 167 "../../../src/gmm/gmm.mx"
  {
    VAR det_i_a := covar_i.fetch(0);    VAR det_i_e := covar_i.fetch(4);
    VAR det_i_b := covar_i.fetch(1);    VAR det_i_f := covar_i.fetch(5);
    VAR det_i_c := covar_i.fetch(2);    VAR det_i_g := covar_i.fetch(6);
    VAR det_i_d := covar_i.fetch(3);    VAR det_i_h := covar_i.fetch(7);
    
#line 157 "../../../src/gmm/gmm.mx"
    # perform four operations det_i_a in parallel
    {
      {|
	
#line 147 "../../../src/gmm/gmm.mx"
      # perform two operations det_i_a in parallel
      {
	{|
	   det_i_a := [*](det_i_a,det_i_b).access(BAT_WRITE);
	   det_i_c := [*](det_i_c,det_i_d);
	 |}
	 [:*=](det_i_a,det_i_c);
      }


#line 160 "../../../src/gmm/gmm.mx"

	
#line 147 "../../../src/gmm/gmm.mx"
      # perform two operations det_i_e in parallel
      {
	{|
	   det_i_e := [*](det_i_e,det_i_f).access(BAT_WRITE);
	   det_i_g := [*](det_i_g,det_i_h);
	 |}
	 [:*=](det_i_e,det_i_g);
      }


#line 161 "../../../src/gmm/gmm.mx"

       |}
       [:*=](det_i_a,det_i_e);      
    }


#line 172 "../../../src/gmm/gmm.mx"

    det_i := det_i_a;
  }


#line 127 "../../../src/gmm/gmm.mx"



#line 131 "../../../src/gmm/gmm.mx"



#line 1946 "../../../src/gmm/gmm.mx"

    VAR logdet_i    := [log](det_i);
    VAR ivars_i     := [nestedop]("inv",covar_i);


#line 1955 "../../../src/gmm/gmm.mx"
    VAR qivars_i    := [join](const iIdx, ivars_i);
    VAR covar_q     := gmm_q.find("Covar");
    VAR qvars_q     := [join](const qIdx, covar_q);
    VAR tmp         := [nestedop]("*", qvars_q, qivars_i);
    
#line 130 "../../../src/gmm/gmm.mx"
VAR traces;

#line 127 "../../../src/gmm/gmm.mx"

#line 167 "../../../src/gmm/gmm.mx"
  {
    VAR traces_a := tmp.fetch(0);    VAR traces_e := tmp.fetch(4);
    VAR traces_b := tmp.fetch(1);    VAR traces_f := tmp.fetch(5);
    VAR traces_c := tmp.fetch(2);    VAR traces_g := tmp.fetch(6);
    VAR traces_d := tmp.fetch(3);    VAR traces_h := tmp.fetch(7);
    
#line 157 "../../../src/gmm/gmm.mx"
    # perform four operations traces_a in parallel
    {
      {|
	
#line 147 "../../../src/gmm/gmm.mx"
      # perform two operations traces_a in parallel
      {
	{|
	   traces_a := [+](traces_a,traces_b).access(BAT_WRITE);
	   traces_c := [+](traces_c,traces_d);
	 |}
	 [:+=](traces_a,traces_c);
      }


#line 160 "../../../src/gmm/gmm.mx"

	
#line 147 "../../../src/gmm/gmm.mx"
      # perform two operations traces_e in parallel
      {
	{|
	   traces_e := [+](traces_e,traces_f).access(BAT_WRITE);
	   traces_g := [+](traces_g,traces_h);
	 |}
	 [:+=](traces_e,traces_g);
      }


#line 161 "../../../src/gmm/gmm.mx"

       |}
       [:+=](traces_a,traces_e);      
    }


#line 172 "../../../src/gmm/gmm.mx"

    traces := traces_a;
  }


#line 127 "../../../src/gmm/gmm.mx"



#line 131 "../../../src/gmm/gmm.mx"



#line 1959 "../../../src/gmm/gmm.mx"



#line 1966 "../../../src/gmm/gmm.mx"
    VAR qmeanq      := [join](const qIdx, gmm_q.find("Mean"));
    VAR qmeani	    := [join](const iIdx, gmm_i.find("Mean"));
    VAR diffs       := [nestedop]("-", qmeanq, qmeani);
    diffs           := [square]( diffs );
    diffs	    := [nestedop]("*", diffs, qivars_i);
    
#line 130 "../../../src/gmm/gmm.mx"
VAR Dmaha;

#line 127 "../../../src/gmm/gmm.mx"

#line 167 "../../../src/gmm/gmm.mx"
  {
    VAR Dmaha_a := diffs.fetch(0);    VAR Dmaha_e := diffs.fetch(4);
    VAR Dmaha_b := diffs.fetch(1);    VAR Dmaha_f := diffs.fetch(5);
    VAR Dmaha_c := diffs.fetch(2);    VAR Dmaha_g := diffs.fetch(6);
    VAR Dmaha_d := diffs.fetch(3);    VAR Dmaha_h := diffs.fetch(7);
    
#line 157 "../../../src/gmm/gmm.mx"
    # perform four operations Dmaha_a in parallel
    {
      {|
	
#line 147 "../../../src/gmm/gmm.mx"
      # perform two operations Dmaha_a in parallel
      {
	{|
	   Dmaha_a := [+](Dmaha_a,Dmaha_b).access(BAT_WRITE);
	   Dmaha_c := [+](Dmaha_c,Dmaha_d);
	 |}
	 [:+=](Dmaha_a,Dmaha_c);
      }


#line 160 "../../../src/gmm/gmm.mx"

	
#line 147 "../../../src/gmm/gmm.mx"
      # perform two operations Dmaha_e in parallel
      {
	{|
	   Dmaha_e := [+](Dmaha_e,Dmaha_f).access(BAT_WRITE);
	   Dmaha_g := [+](Dmaha_g,Dmaha_h);
	 |}
	 [:+=](Dmaha_e,Dmaha_g);
      }


#line 161 "../../../src/gmm/gmm.mx"

       |}
       [:+=](Dmaha_a,Dmaha_e);      
    }


#line 172 "../../../src/gmm/gmm.mx"

    Dmaha := Dmaha_a;
  }


#line 127 "../../../src/gmm/gmm.mx"



#line 131 "../../../src/gmm/gmm.mx"



#line 1971 "../../../src/gmm/gmm.mx"


    VAR tmp         := [+](Dmaha,traces);
    tmp             := [+](iIdx.join(logdet_i), tmp);
    VAR compiL	    := [-](iIdx.join(logpriors_i), tmp);
    VAR maxcompiL   {max}(giIdx.reverse().join(compiL));

    VAR compqL	    := [*](join(cqIdx,gmm_q.find("Prior")), maxcompiL);


#line 1983 "../../../src/gmm/gmm.mx"
    VAR imgidx_q    := join( cqIdx, gmm_q.find("mImgIdx").reverse);
    VAR imgidx_i    := join( ciIdx, gmm_i.find("mImgIdx").reverse);
    VAR gimgidx_q   := CTgroup(imgidx_q);
    VAR gimgidx_i   := CTgroup(gimgidx_q, imgidx_i);
   
    VAR RSL         {sum}(join( gimgidx_i.reverse, compqL));

debug("Results ranked");
#      VAR printres  := new(void,str);
#      printres.insert(nil, sprintf( "%3s %3s  %8s\n", "Q", "I", "RSL(Q,I)" ));
#      printres.insert(nil, sprintf( "================\n" ));
#      printres.insert([sprintf]( const "%3d,%3d,%8.lf\n", imgidx_q,imgidx_i, RSL));
#      printres@batloop(){printf("%s",$t);}

#    VAR minRSL      {min}(join(gimgidx_q.reverse, RSL));
}



#line 2009 "../../../src/gmm/gmm.mx"
  PROC L2dist( BAT[any::1,dbl] x, BAT[any::1,dbl] y ): dbl {
    VAR dist := [-](x, y);
    dist := [*](dist, dist);
    dist := dist.sum / dist.count;
    RETURN dist;
  }

  # this is really a fitness-join
  PROC mapnearest( BAT[int,bat] ma, BAT[int,bat] mb ): BAT[int,int] {
    VAR cdist := new(TCluster,bat,C);
    cseq@batloop(){
      VAR csrcoid := $h;
      VAR csrc := $t;
      VAR cdist_c := new(TCluster,dbl);
      cseq@batloop(){
        VAR cnewoid := $h;
	VAR cnew := $t;
	cdist_c.insert( cnew, 
	  L2dist( [find](ma,csrcoid), 
		[find](mb,cnewoid) ) ); 
      }
      cdist.insert( csrc, cdist_c.reverse().order );
    }
    RETURN [fetch](cdist, const 0);
  }

  PROC testclassify( BAT[str,bat] src_gmm, BAT[str,bat] gmmnew ): void {
    VAR c := classify( sampleImg.find("Samples"), gmmnew );
    VAR Nerr := diff(c, sampleImg.find("Clusters")).count;

    VAR Nerrmap := Nerr;
      # don't know setoriented solution yet
      #  VAR cmap := mapnearest( src_gmm.find("Mean"), gmmnew.find("Mean") );
      #  VAR Nerrmap := diff(c.join(cmap.reverse),sampleImg.find("Clusters")).count;
    printf("Estimated # misclassified blocks: %4d (raw: %4d)\n", Nerrmap, Nerr);
  }

  # testclassify(src_gmm, gmmnew);


#line 2052 "../../../src/gmm/gmm.mx"
  PROC dmahalanobis( BAT[void,dbl] x, dbl mu, dbl variance ): BAT[void,dbl] {
    VAR dist := [-](x, const mu);
    dist := [*](dist, dist);
    dist := [/]( dist, const variance );
    RETURN dist;
  }

  PROC mvgpdf( BAT[void,dbl] d, dbl det, int Ndim ): BAT[void,dbl] {
    VAR norm := 1/(pow((2*M_PI), dbl(Ndim)/2) * sqrt(det) );
    VAR p := [exp]( [*]( d, -0.5LL ) );
    RETURN [*]( p, const norm );
  }

  PROC test():void {
    debug( "Testing..." );


#line 2070 "../../../src/gmm/gmm.mx"
    VAR mu := new( int, dbl );
    mu.insert( 1, mu_1 );
    mu.insert( 2, mu_2 );
    # ...
    VAR sigma := new( int, dbl );
    sigma.insert( 1, sigma_1 );
    sigma.insert( 2, sigma_2 );
    # ...


#line 2081 "../../../src/gmm/gmm.mx"
    VAR covar := [*]( sigma, sigma );
    VAR det := prod( covar );
    printf( "Determinant: %lf (%lf)\n", det, sigma_1 * sigma_1 * sigma_2 * sigma_2 );


#line 2087 "../../../src/gmm/gmm.mx"
    VAR x_1 := new( void, dbl ).setSequenceBase(oid(0));
    VAR x_2 := new( void, dbl ).setSequenceBase(oid(0));
    # ...
    VAR i := 0;
    WHILE (i < Nsamples) {
      x_1.insert( nil, ran_gaussian(mu_1,sigma_1) );
      x_2.insert( nil, ran_gaussian(mu_2,sigma_2) );
      # ...
      i :+= 1;
    }


#line 2100 "../../../src/gmm/gmm.mx"
    VAR dist_1 := [dmahalanobis_i_diagcov]( x_1, mu.find(1), covar.find(1) );
    VAR dist_2 := [dmahalanobis_i_diagcov]( x_2, mu.find(2), covar.find(2) );
    # ...
    VAR dist := [+]( dist_1, dist_2 ); # ...


#line 2108 "../../../src/gmm/gmm.mx"
    VAR p := [multivariate_gaussian_pdf_diagcov]( dist, det, 2 );
    # print( x_1, x_2, p );



#line 2114 "../../../src/gmm/gmm.mx"
    VAR thediff := [-]( dmahalanobis(x_1, mu.find(1), covar.find(1) ), dist_1 );
    thediff := [+]( thediff, [-]( dmahalanobis(x_2, mu.find(2), covar.find(2) ), dist_2 ) );
    IF ( thediff.sum > 1e-10LL ) {
      printf( "!ERROR: difference in Mahalanobis distances (%lf)!\n", thediff.sum );
    } ELSE printf( "Mahalanobis distances ok.\n" );
    thediff := [-]( mvgpdf( dist, det, 2 ), p );
    IF ( thediff.sum > 1e-10LL ) {
      printf( "!ERROR: difference in probabilities (%lf)!\n", thediff.sum );
    } ELSE printf( "Probabilities ok.\n" );
  }



#line 2127 "../../../src/gmm/gmm.mx"
  coeffs := nil;
  mImgIdx := nil;
  mCIdx := nil;

#  gmm := nil;
#  gmmnew := nil;

  commit;



#line 2140 "../../../src/gmm/gmm.mx"

  CONST fragsize := 64;
  VAR Nimg := imgFrameNr.count;
  VAR collidx := s_tdict.reverse();

  
#line 2224 "../../../src/gmm/gmm.mx"
  VAR tmBatIds, tmBatIds_Mean, tmBatIds_Covar;


#line 2145 "../../../src/gmm/gmm.mx"

  IF ([startsWith](view_bbp_name,"gmm_trained").uselect(true).count > 0) {
    
#line 2229 "../../../src/gmm/gmm.mx"
  
#line 2219 "../../../src/gmm/gmm.mx"
  tmBatIds       := new(str,str);
  tmBatIds_Mean  := new(int,str);
  tmBatIds_Covar := new(int,str);


#line 2229 "../../../src/gmm/gmm.mx"

  IF (view_bbp_name.reverse().exist("gmm_trained"+"_Prior"))   tmBatIds.insert("Prior",   "gmm_trained"+"_Prior");
  IF (view_bbp_name.reverse().exist("gmm_trained"+"_mCIdx"))   tmBatIds.insert("mCIdx",   "gmm_trained"+"_mCIdx");
  IF (view_bbp_name.reverse().exist("gmm_trained"+"_mImgIdx")) tmBatIds.insert("mImgIdx", "gmm_trained"+"_mImgIdx");
  IF (view_bbp_name.reverse().exist("gmm_trained"+"_init_variances")) 
    tmBatIds.insert("init_variances", "gmm_trained"+"_init_variances");
  nseq@batloop(){
    IF (view_bbp_name.reverse().exist("gmm_trained" + "_Mean_"  + str($t)))
      tmBatIds_Mean.insert( $t, "gmm_trained" + "_Mean_"  + str($t));
    IF (view_bbp_name.reverse().exist("gmm_trained" + "_Covar_" + str($t)))
      tmBatIds_Covar.insert($t, "gmm_trained" + "_Covar_" + str($t));
  }


#line 2147 "../../../src/gmm/gmm.mx"

  } ELSE {
    VAR trainedmodels := newGMM("gmm_trained", Nimg);
    
#line 655 "../../../src/gmm/gmm.mx"
  access( trainedmodels.find("init_variances"), BAT_APPEND );
  access( trainedmodels.find("Prior"), BAT_APPEND );
  access( trainedmodels.find("mImgIdx"), BAT_APPEND );
  access( trainedmodels.find("mCIdx"), BAT_APPEND );
  trainedmodels.find("Mean")@batloop{  access($t, BAT_APPEND); }
  trainedmodels.find("Covar")@batloop{ access($t, BAT_APPEND); }


#line 2150 "../../../src/gmm/gmm.mx"

    
#line 655 "../../../src/gmm/gmm.mx"
  setPersistent( trainedmodels.find("init_variances") );
  setPersistent( trainedmodels.find("Prior") );
  setPersistent( trainedmodels.find("mImgIdx") );
  setPersistent( trainedmodels.find("mCIdx") );
  trainedmodels.find("Mean")@batloop{  setPersistent($t); }
  trainedmodels.find("Covar")@batloop{ setPersistent($t); }


#line 2151 "../../../src/gmm/gmm.mx"

    
#line 655 "../../../src/gmm/gmm.mx"
  mmap( trainedmodels.find("init_variances"), STORE_MMAP );
  mmap( trainedmodels.find("Prior"), STORE_MMAP );
  mmap( trainedmodels.find("mImgIdx"), STORE_MMAP );
  mmap( trainedmodels.find("mCIdx"), STORE_MMAP );
  trainedmodels.find("Mean")@batloop{  mmap($t, STORE_MMAP); }
  trainedmodels.find("Covar")@batloop{ mmap($t, STORE_MMAP); }


#line 2152 "../../../src/gmm/gmm.mx"

    
#line 2194 "../../../src/gmm/gmm.mx"
  # Can be paired with modelfromBatIds(X,tmBatIds)
  
#line 2219 "../../../src/gmm/gmm.mx"
  tmBatIds       := new(str,str);
  tmBatIds_Mean  := new(int,str);
  tmBatIds_Covar := new(int,str);


#line 2195 "../../../src/gmm/gmm.mx"

  tmBatIds.insert( "mCIdx",   trainedmodels.find("mCIdx").info.find("batId") );
  tmBatIds.insert( "mImgIdx", trainedmodels.find("mImgIdx").info.find("batId") );
  tmBatIds.insert( "Prior",   trainedmodels.find("Prior").info.find("batId") );
  tmBatIds.insert( "init_variances", trainedmodels.find("init_variances").info.find("batId") );
  tmBatIds_Mean.insert(  [find]([info](trainedmodels.find("Mean")), const "batId") );
  tmBatIds_Covar.insert( [find]([info](trainedmodels.find("Covar")), const "batId") );


#line 2153 "../../../src/gmm/gmm.mx"

  }
  VAR ii    := 55; # 0;
  WHILE ( (ii*fragsize) < Nimg ) {
    VAR frag_i := bat(collidx.find("keyframes_file")).slice(ii*fragsize,((ii+1)*fragsize) - 1);
    VAR frag_iIdx := frag_i.mark(oid(0)).reverse().join(bat(collidx.find("imgBlock"))).reverse().mark(oid(0)).reverse();

    EM_coll := new(str,bat);
    EM_coll.insert("I",  frag_i);
    EM_coll.insert("Ib", frag_iIdx.join(imgBlock.reverse).reverse);

    VAR coeffs := new(int,bat);
    nseq@batloop(){
      coeffs.insert( $t, frag_iIdx.join(bat(collidx.find("imgBlockCoeff_" + str($t)))) );
    }
    EM_coll.insert("Coeffs", coeffs);
    		coeffs := nil;
    EM_model := initGMM( EM_coll );

    VAR gmm := EM_globalmodel(30); # 30 iterations for starters

    
#line 2208 "../../../src/gmm/gmm.mx"
  # Must be paired with a modelBatIds(tmBatIds,X) in the same context
  trainedmodels := new(str, bat);
  trainedmodels.insert( [bat](tmBatIds) );
  trainedmodels.insert( "Mean", [bat](tmBatIds_Mean) );
  trainedmodels.insert( "Covar", [bat](tmBatIds_Covar) );


#line 2173 "../../../src/gmm/gmm.mx"

    VAR lastId := oid(trainedmodels.find("mImgIdx").count);
    VAR midx := gmm.find("mImgIdx");
    
#line 611 "../../../src/gmm/gmm.mx"
{
  VAR fIdx := midx.reverse().mark(lastId).reverse();

  VAR convImgIdx     := join( fIdx, gmm.find("mImgIdx").reverse );
  VAR convCIdx       := join( fIdx, gmm.find("mCIdx").reverse );
        # implementation of batinsert into empty voidbats causes trouble...
        debug("<PROPCHECK1 hkey=%s />",     
          trainedmodels.find("mImgIdx").info.find("hkey"));
  trainedmodels.find("mImgIdx").insert( convImgIdx.reverse );
        debug("<PROPCHECK2 hkey=%s />",    
          trainedmodels.find("mImgIdx").info.find("hkey"));
  trainedmodels.find("mCIdx").insert( convCIdx.reverse );

  trainedmodels.find("Prior").insert( join(fIdx, gmm.find("Prior")) );
  [insert]( trainedmodels.find("Mean"),
            [join](const fIdx, gmm.find("Mean")) );
  [insert]( trainedmodels.find("Covar"),
            [join](const fIdx, gmm.find("Covar")) );

  trainedmodels.find("init_variances").insert( join(fIdx, gmm.find("init_variances")) );
}


#line 2176 "../../../src/gmm/gmm.mx"

    
#line 2194 "../../../src/gmm/gmm.mx"
  # Can be paired with modelfromBatIds(X,tmBatIds)
  
#line 2219 "../../../src/gmm/gmm.mx"
  tmBatIds       := new(str,str);
  tmBatIds_Mean  := new(int,str);
  tmBatIds_Covar := new(int,str);


#line 2195 "../../../src/gmm/gmm.mx"

  tmBatIds.insert( "mCIdx",   trainedmodels.find("mCIdx").info.find("batId") );
  tmBatIds.insert( "mImgIdx", trainedmodels.find("mImgIdx").info.find("batId") );
  tmBatIds.insert( "Prior",   trainedmodels.find("Prior").info.find("batId") );
  tmBatIds.insert( "init_variances", trainedmodels.find("init_variances").info.find("batId") );
  tmBatIds_Mean.insert(  [find]([info](trainedmodels.find("Mean")), const "batId") );
  tmBatIds_Covar.insert( [find]([info](trainedmodels.find("Covar")), const "batId") );


#line 2177 "../../../src/gmm/gmm.mx"

    commit;

    trainedmodels := nil;
    EM_model := nil;
    EM_coll  := nil;

    gmm := nil;
    midx := nil;

    ii :+= 1;
  }


#line 2338 "../../../src/gmm/gmm.mx"
  fflush( GMMdebuglog );
  # enum_drop( TCluster );
  # fclose( GMMdebuglog );
  # quit;


#line 2346 "../../../src/gmm/gmm.mx"
PROC modelIdx(int N): BAT[str,void] {
  VAR modelidx := new(str,void).reverse().setSequenceBase(oid(0)).reverse();
  VAR seq := Nseq(N).reverse();
  modelidx.insert( "Prior", nil );
  VAR mu := _x([+](seq.project("Mu_"), seq.mirror()));
  VAR covar := _x([+](seq.project("Sigma_"), seq.mirror()));
  modelidx.insert( mu.reverse );
  modelidx.insert( covar.reverse );
  mu := mu.reverse().number.reverse().join(modelidx);
  covar := covar.reverse().number.reverse().join(modelidx);
  RETURN modelidx;
}


