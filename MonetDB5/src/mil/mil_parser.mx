@t M2M, MIL to MAL parser
@a M. L. Kersten
@v 2.0

@* Parsing MIL Version 4 
This module contains a small footprint MIL parser for Monet Version 5.0
to assure backward compatibility. Compatibility is only guaranteed
for the code base known May 2000 and excludes the active database component
as well as some exotic constructs.

Furthermore, this parser assumes availability of a complete MIL block upfront
as a string to be parsed. 

The parser produced is not thread safe, which means that parsing
is encapsulated in a critical section. On single cpu systems this
does not cause too much performance degration, on multi-cpu systems
it may affect throughput when many users issue short (simple) commands.
The quantitative effect is yet unknown.

The stand-alone version of this parser (M2M) can be used 
to check any MIL procedure for syntactic errors.
@+ The lexical analyzer
The lexical analyzer is generated using Flex, the preferred tool in Monet.

The implementation of the lexical analyzer is straightforward:
the input is taken from a client message buffer. It is assumed that
this buffer contains the complete MIL structure to be parsed.
This input buffer may be screwed up in the process, which implies
that front-ends may have to make a copy first.

The lexical analyzer and parser are prefixed with "mil", which ensures that
other language analyzers can safely be added
(provided they run not inparallel). The lexical analyzer should
not maintain a linenumber. This aspect is made explicit in the rules
any way.

The lexical analyser returns simple triples to the parser.
They include the token identifier, the Monet type-id, and a string
representation.

WARNING. This paper performs a single linear scan over the mil code
and immediately produces strings for output. A better solution would have been
to build a parsetree followed by a recursive descend code generation phase.
@h
#ifndef _MIL_PARSER_H
#define _MIL_PARSER_H

#include "gdk.h"

typedef struct YYSRECORD{
	int	token, tpe, len;
	char * 	val;
 } yystype, *yystypeptr;

#define YYSTYPE yystype
extern YYSTYPE yylval;
#define GDKerror(M) 	printf("%s",M) 
#define mapOp(X) (*(X) == '[')
#define setOp(X) (*(X) == '{')
extern char *getOperator(char *nme);

extern const char *yylexname(int Y);
extern void mil_parseError(str msg);
extern void mil_flushbuffer();
extern str mil_lastline();
extern long mil_position();
extern int mil_skipcomment();
extern void mil_push(str s);	/* used in src/mil/M2m.c */
extern int mil_getch();
extern int yylex();
extern char *newName();
extern str getLastHead();
extern str getLastTail();
extern char *emitExpr(char *msg);
extern str glue(str l, str r);
extern str mapid(str n);
extern int ismapped(str n);
extern void showmappings();

extern int constantdeclaration;

extern void resetIds();
extern void pushIterator(str nme);
extern void newId(str nme);
extern void popIterator();
extern void pushBlock(str nme);
extern void popBlock();
extern str getLastIterator();
extern char *bindFcn(str nme);
extern void bindId(str nme);

#endif /* _MIL_PARSER_H */
@l
/*
%option noyylineno
%option never-interactive
%option nomain
*/

D       [0-9]
O       [0-7]
L       [_a-zA-Z]
E       [Ee][-+]?{D}+
S       [\t\n ]*
P       [-!\$%\^\*+|?<>=/\\]
IDENT	{L}({L}|{D})*
OPER	{P}+
%{

#include "mil_parser.h"
@-
The Bison parser generator will produce the table with token names
needed for tracing the parser.
@l
#include "mil_parser.tab.h"

#define RETURN(Y)       { PARSEDEBUG {\
                                THRprintf(GDKerr, "\n%s %s\n", yylexname(Y), yytext);\
                          } return Y; }


#define YY_INPUT(buf,result,max_size)   { int c = mil_getch();\
                           result = (c==0) ? YY_NULL: (buf[0] = (char)c,1);}
#define Symbol(X)       { Vector(X,TYPE_void,0,0); }
#define Vector(X,Y,V,L)	{ yylval.token= X;	\
			yylval.tpe  = Y;	\
			if( V != 0 ) \
			yylval.val = GDKstrdup(V);  	\
			yylval.len = L;	\
			RETURN (X); }
%}

%%
"#"                   { return mil_skipcomment();                              }
("nil"|"NIL")         { Vector(TOK_CONSTANT, TYPE_void, "nil", 3);   }
("proc"|"PROC")       { Symbol(TOK_PROCDEF);                                  }
("undef"|"UNDEF")     { Symbol(TOK_UNDEF);                                    }
("return"|"RETURN")   { Symbol(TOK_RETURN);                                   }
("break"|"BREAK")     { Symbol(TOK_BREAK);                                    }
("while"|"WHILE")     { Symbol(TOK_WHILE);                                    }
("if"|"IF")           { Symbol(TOK_IF);                                       }
("else"|"ELSE")       { Symbol(TOK_ELSE);                                     }
("false"|"FALSE")     { Vector(TOK_CONSTANT, TYPE_bit, "false", 1);        }
("var"|"VAR")         { Symbol(TOK_VAR);                                      }
("const"|"CONST")     { constantdeclaration = 1; Symbol(TOK_CONST);}
("true"|"TRUE")       { Vector(TOK_CONSTANT, TYPE_bit, "true", 1);        }
("module"|"MODULE")   { Symbol(TOK_MODULE);				     }
("any"|"ANY")         { Vector(TOK_ANY, TYPE_int,  "-1", 2);               }
("bat"|"BAT")         { Vector(TOK_BAT,TYPE_bat,"bat",0);		      }
"$("                  { Symbol(TOK_VARTEMP);                                  }
".."                  { Symbol(TOK_RANGETEMP);                                }
"::"                  { Symbol(TOK_ANYNUM);                                   }
("$h"|"$H"|"$head"|"$HEAD") { Vector(TOK_ITERTEMP, TYPE_str, getLastHead(), 1);         }
("$t"|"$T"|"$tail"|"$TAIL") { Vector(TOK_ITERTEMP, TYPE_str, getLastTail(), 1);         }
"$"{D}+               { Vector(TOK_TEMPLATE,TYPE_int,yytext,yyleng);       }
":="                  { Symbol(TOK_ASSIGNMENT);                               }
("[:=]")	|
("[:"{OPER}"=]")	|
("[:"{IDENT}"=]")	|
("["{IDENT}"]")	|
("["{OPER}"]")	| 
("{:=}") 	| 
("{"{OPER}"}")	|
("{"{IDENT}"}")	| 
({IDENT})	      { yytext[yyleng]=0; Vector(TOK_IDENT, TYPE_str, yytext,yyleng);	      }
(":"{IDENT}"=")	|
(":"{OPER}"=")	| 
({OPER}"="?)	{	yytext[yyleng]=0;
			if( !yytext[1] && (yytext[0]=='~' ||
				yytext[0]=='?' || yytext[0]==':')){
				Symbol(yytext[0]);
			} else Vector(TOK_OPERATOR, TYPE_str, yytext,yyleng); 
		}
"(*"                  { Symbol(TOK_DEREF);                                    }
"[*"                  { Symbol(TOK_SETOP);                                    }
"{*"                  { Symbol(TOK_SETAGGR);                                  }
("-")?{D}+"LL"        { Vector(TOK_CONSTANT, TYPE_lng, yytext, yyleng);}
("-")?{D}+            { Vector(TOK_CONSTANT, TYPE_int, yytext, yyleng);}
{D}+"@"{D}+           { Vector(TOK_CONSTANT, TYPE_oid, yytext, yyleng);         }
("-")?{D}+"."{D}+({E})?"LL" |
("-")?"."{D}+({E})?"LL"     |
("-")?{D}+{E}"LL"     { Vector(TOK_CONSTANT, TYPE_dbl,  yytext, yyleng);         }
("-")?{D}+"."{D}+({E})? |
("-")?"."{D}+({E})?     |
("-")?{D}+{E}         { Vector(TOK_CONSTANT, TYPE_flt,  yytext, yyleng);         }
"'"\\0{O}({O})?({O})?"'" {Vector(TOK_CONSTANT, TYPE_chr, yytext, yyleng);        }
\"[^\n"]*\"		{
                        if (yytext[yyleng-1] != '\\') {
				yytext[yyleng]=0;
                                Vector(TOK_CONSTANT, TYPE_str, yytext, yyleng);
                        } else {
				yymore(); 
			}					                     }
\'[^\n\']*\'            { 
                        if (yytext[yyleng-1] != '\\') {
                                Vector(TOK_CONSTANT, TYPE_chr, yytext, yyleng);
                        } else {
                                yymore(); 
                        }                                                     }
"@"                   { Symbol(TOK_ITERATION);                                }
"@"{S}"["                   { Symbol(TOK_ITERATION_PAR);               }
"{|"                  { Symbol(TOK_PARBLOCK);                                 }
"|}"                  { Symbol(TOK_PAREND);                                   }
{S}                   ;
.                     { Symbol(*yytext);                                      }
%%
int mil_skipcomment() { 
	char c; 
	while ((c=input()) && (c != '\n')); 
	return yylex();
}
int yywrap(){ return 1;}

void mil_flushbuffer() {
        YY_FLUSH_BUFFER;
}

str glue(str l, str r){
	str t;
	t= (str) GDKmalloc(strlen(l)+strlen(r)+1);
	t[0]=0;
	strcpy(t,l);
	strcat(t,r);
	return t;
}
@
@- Input management
The parser reads its input from a string buffer space, organized as a
stack to permit easy escapes to "included" MIL programs (module inits).
After parsing the string buffer space is freed by the parser as well.

[These variables should be local to a parsing thread.]
@c
#include "mil_parser.h"

typedef struct _strstack_t {
	str buf, cptr, prevline, nxtline;
	int listing;		
	struct _strstack_t *up;
} strstack;

static strstack  *mil_stack = NULL;

void mil_push(str s) {
	strstack *sp = (strstack*) GDKmalloc(sizeof(strstack));
	sp->listing = 1;
	sp->cptr = sp->nxtline= sp->prevline = sp->buf = s;  
	sp->up = mil_stack;
	mil_stack = sp;
}

int mil_pop() {
	strstack *sp = mil_stack;
	if (mil_stack) {
		mil_stack = sp->up;
		GDKfree(sp->buf);
		GDKfree(sp);
		return 1;
	}
	return 0;
}

@-
The next character is retrieved from the string pool
using the routine mil_getch. The position of the last
newline is retained to gain quick access.
Beware, we first produce the comment line before attempting
the parse.
@c
int mil_getch() {
        char ch, *s = NULL;
	ch = *mil_stack->cptr;

        if (ch == '\n' || (ch && mil_stack->cptr == mil_stack->buf) ){
                if (mil_stack->listing) { 
			printf("#");
			for(s= mil_stack->nxtline; *s && *s!='\n'; s++)
				printf("%c",*s);
                        printf("\n");
                        fflush(stdout);
                }
		mil_stack->prevline= mil_stack->nxtline;
                mil_stack->nxtline = s+1;
        } 
        if (ch) mil_stack->cptr++;
        return ch;
}

@-
For error reporting we have to find the start of the previous line,
which, ofcourse, is easy.
@c
str mil_lastline(){ 
	if( mil_stack->nxtline == 0)
		return mil_stack->prevline;
	return mil_stack->nxtline; 
}
long mil_position()
{
	return (long)(mil_stack->cptr)- (long)mil_stack->nxtline;
}
@-
Long strings are in this version easier to handle, because the input is
already concatenated by the front-end. This means that a string literal may not
extend beyond end-of-line.
REWORKED

@+ The Parser
Unlike Monet V4.3 the client is responsible to collect the
input for parsing in a single string before calling the parser.
Once the input is available parsing runs in a critial section for
a single client thread.

@c
int mil_parse(/*str buf, int listing*//*Stefan: unused!*/){
	return 0;
}

#define MAXDEPTH 64
str iterators[MAXDEPTH];
int itop=0;
str block[MAXDEPTH];
int btop=0;

str getLastIterator(){
	if(itop==0){
		printf("\n#ERROR: no iterators on stack\n");
		return GDKstrdup("unknown");
	}
	return GDKstrdup(iterators[itop-1]);
}
void pushIterator(str nme){
	if( itop== MAXDEPTH){
		GDKfatal("FATAL: iterator depth exceeded\n");
	}
	iterators[itop]= GDKstrdup(nme);
	itop++;
}
void popIterator(){
	if(itop==0){
		printf("\n#ERROR: no iterators on stack\n");
		return;
	}
	itop--;
	if(iterators[itop]){
		GDKfree(iterators[itop]);
		iterators[itop]=0;
	}
}
void resetIterator(){ itop=0;}
void resetBlock(){ btop=0;}
int isIterator(char *nme){
	if( itop==0) return 0;
	return strcmp(nme,iterators[itop-1])==0;
}
void pushBlock(str nme){
	if( btop== MAXDEPTH){
		GDKfatal("FATAL: block depth exceeded\n");
	}
	block[btop]= GDKstrdup(nme);
	btop++;
}
void popBlock(){
	if(btop==0){
		printf("\n#ERROR: no block id on stack\n");
		return;
	}
	btop--;
	if(block[btop]){
		GDKfree(block[btop]);
		block[btop]=0;
	}
}

str getLast(char c){
	char buf[IDLENGTH];
	if(itop==0){
		printf("\n#ERROR: no iterator '%c' on stack\n",c);
		return GDKstrdup("unknown");
	}
	sprintf(buf,"%s%c",iterators[itop-1],c);
	return GDKstrdup(buf);
}
str getLastHead(){ return getLast('H');}
str getLastTail(){ return getLast('T');}

@+ Symbol table
For Monet V 5 there is no automatic resolution of identifiers to
outer or named scopes. Such variables are explicitly bound by a
function take(str nme).
For the M2m compiler this means we have to keep track on the identifiers
introduced in a block and issue a bind operation before using them.
Variables that are introduced at the LHS of an assignment
need not be bound through the BAT binding operation.
@c
typedef struct IDS{
	str nme;
	struct IDS *peer;
} *Ids;

Ids ids;

void resetIds() {ids =0;}

void newId(str nme){
	Ids m;
	m = (Ids) GDKmalloc(sizeof(*m));
	if(m == 0) mil_parseError("Failure to create identifier\n");
	m->peer = ids;
	m->nme = nme;
	ids= m;
}
int fndId(str nme){
	Ids n;
	for(n = ids; n; n= n->peer){
		if(strcmp(n->nme,nme)==0) return 1;
	}
	newId(nme);
	return 0;
}

@-
MIL variable may refer to globals, constants, parameterless functions,
 and persistent BATs. These cases are handled by a pattern in the MIL interpreter,
except for the built-in types, which are expected to exist.
@c
str typeNames[]={"void","bit","chr","sht","bat","int","oid","ptr",
	"flt","dbl","lng","str","url","lock","sema","blob","fstream",
	"decimal","bipipe","tzone","date","daytime","rule","timestamp",0};

void bindId(str nme){
	int i, fnd= 0;
	for( i=0; typeNames[i]; i++)
	if( strcmp(typeNames[i],nme)==0){ fnd++; break;}
	if( ismapped(nme)) return;
	if( *nme =='$') {
		return;
	}
	if( (nme[4]=='T' || nme[4]=='H') && nme[2]=='_') return;
	if( strcmp(nme,"quit") ==0){ printf("\tquit();\n"); return;}

	if(fnd==0 &&  fndId(nme) == 0 && constantdeclaration==0)
	printf("\t%s:= bbp.bind(\"%s\");\n",nme,nme);
}

str multiplexOp[]={"+","++","-","--","/","*","%",">","<","<=",">=","==","!=","and",
	"or","not","void","bit","chr","sht","bat","int","oid","ptr",
        "flt","dbl","lng","str","asin","acos","atan","cos","sin",
	"tan","cosh","sinh","tanh","exp","log","log10","sqrt",
	"ceil","fabs","floor","round","fmod","atan2","pow",0};

char *bindFcn(str nme){
	char buffer[1024];
/*	int i;	*/

	switch(*nme){
	case '[':
		nme[strlen(nme)-1]=0;
/*
		for(i=0; multiplexOp[i];i++)
		if( strcmp(nme+1, multiplexOp[i])==0){
			sprintf(buffer,"%s(",nme+1);
			return GDKstrdup(buffer);
		}
		sprintf(buffer,"multiplex.script(\"%s\",", nme+1);
*/
		sprintf(buffer,"multiplex.tactics(\"%s\",", nme+1);
		break;
	case '{':
		nme[strlen(nme)-1]=0;
		sprintf(buffer,"group.%s(", nme+1);
		break;
	case '(':
		nme[strlen(nme)-1]=0;
		sprintf(buffer,"mil.inplace(\"%s\",", nme+1);
		break;
	default: if(strchr(nme,'(') ) return nme;
		sprintf(buffer,"%s(",nme);
	}
	return GDKstrdup(buffer);
}
char *emitExpr(char *msg){
	if(*msg !='\'' && *msg!='"' && strchr(msg,'(') ){
		char *nme= newName();
		printf("\t%s := %s;\n",nme,msg);
		return nme;
	} 
	return msg;
}
char *emitExpr0(char *msg){
	if( strchr(msg,'(')){
		printf("\t%s;\n",msg);
		return GDKstrdup("XXXX");
	}
	if(*msg !='\'' && *msg!='"' && strchr(msg,'(') ){
		char *nme= newName();
		printf("\t%s := %s;\n",nme,msg);
		return nme;
	} 
	return msg;
}
@+ The Bison Grammar
The grammatica should be context free.
@y
%token_table

%{
#include "mil_parser.h"

#undef yyerror
#define yyerror(X)      { mil_parseError(X);  }

#define YYPRINT(file,tpe,val)	mil_print(file, /*tpe,*//*Stefan: unused!*/ ,val)
int yydebug = 1;
int constantdeclaration = 0;
void debugParser(int i){ yydebug=i; }

yystype accum;
%}

%token TOK_ITERTEMP TOK_TEMPLATE TOK_VARTEMP TOK_RANGETEMP
%token TOK_CONSTANT TOK_ASSIGNMENT TOK_PARBLOCK
%token TOK_PAREND TOK_IDENT TOK_IF TOK_WHILE
%token TOK_BREAK TOK_RETURN TOK_VAR 
%token TOK_CONST TOK_BAT
%token TOK_OPERATOR
%token TOK_SETOP TOK_SETAGGR TOK_PROCDEF
%token TOK_STRING TOK_ITERATION TOK_ITERATION_PAR TOK_ELSE
%token TOK_MODULE 
%token TOK_ANY TOK_UNDEF TOK_DEREF TOK_ANYNUM

%left TOK_ITERATION
%left TOK_ASSIGNMENT TOK_OPERATOR
%left '?' ':'
%%
program:
        MIL_session 
    |   error ';' { yyerrok; yyclearin; return 1; }
    |   /* empty */ ;

MIL_session:
        session
    |   MIL_session session
    ;

session:
        proc_definition {resetIds();}
    |   TOK_MODULE '(' module_list ')' ';'
    |   statement
    ;

statement_seq:
        /* empty */
    |   statement_list
    ;

statement_list:
        statement
    |   statement_list statement
    ;

statement:
        stmt { constantdeclaration = 0;}
    |   varidents ';' { constantdeclaration = 0; }
    ;

stmt: ';'
    |   expression ';'
    |   expression TOK_ITERATION_PAR expression ']' iterator
	{ char local[100];
	  $2.val= newName();
	  pushIterator($2.val);
	  printf("barrier\t%s:= bunStream(%s,%sH,%sT);\n",
		$2.val,$4.val,$2.val,$2.val);
	  sprintf(local,"%sH",$2.val); newId(GDKstrdup(local));
	  sprintf(local,"%sT",$2.val); newId(GDKstrdup(local));
	}
	stmt
	{
	  printf("redo\t%s;\n", $2.val);
	  printf("exit\t%s;\n",$2.val);
	  popIterator();
	}
    |   expression TOK_ITERATION iterator
	{ char local[100];
	  $2.val= newName();
	  pushIterator($2.val);
	  printf("barrier\t%s:= bunStream(%s,%sH,%sT);\n",
		$2.val,$1.val,$2.val,$2.val);
	  sprintf(local,"%sH",$2.val); newId(GDKstrdup(local));
	  sprintf(local,"%sT",$2.val); newId(GDKstrdup(local));
	}
	stmt
	{
	  printf("redo\t%s;\n", $2.val);
	  printf("exit\t%s;\n",$2.val);
	  popIterator();
	}
    |   blk_expression
    |   TOK_RETURN ret_value ';'
	{ printf("\treturn %s;\n", $2.val);}
	/* expression in the while block could be compound !! */
    |   whilestmt '(' 
	{ $2.val= newName();
	  printf("barrier\t%s:= true;\n",$1.val);
	  pushBlock($1.val);
	}
	 term ')' 
	{ printf("barrier\t%s:= %s;\n",$2.val,$4.val); 
	  pushBlock($2.val);
	}
	sequential_block
	{ 
	  printf("redo\t%s;\n", $1.val);
	  popBlock();
	  printf("exit\t%s;\n",$2.val);
	  popBlock();
	  printf("exit\t%s;\n",$1.val);
	}

    |   ifhead stmt
	{ printf("exit\t%s;\n",$1.val); popBlock();}
    |   ifhead stmt TOK_ELSE 
	{ printf("exit\t%s;\n",$1.val); 
	  popBlock();
	  $3.val= newName();
	  pushBlock($3.val);
	   printf("barrier\t%s:= not(%s);\n",$3.val,$1.val);
	}
	stmt
	{ printf("exit\t%s;\n",$3.val); popBlock();}
    |   TOK_BREAK ';'
	{ printf("leave\t%s;\n",getLastIterator()); }
    ;

ifhead: TOK_IF '(' term ')'
	{ $1.val = newName();
	   printf("barrier\t%s:= %s;\n",$1.val,$3.val);
	  pushBlock($1.val);
	  $$=$1;
	}
    ;

whilestmt:
	TOK_WHILE
	{ $$.val= newName();}
    ;

iterator :
	tok_ident '(' ')'
    |	tok_ident
    ;
        
ret_value:
        term
    |   /* empty */
	{ $$.val= GDKstrdup("nil");}
    ;

sequential_block:
        '{' statement_seq '}'
    ;

parallel_block:
        TOK_PARBLOCK 
	{ $1.val= newName(); printf("thread\t%s;\n",$1.val);}
	statement_seq TOK_PAREND
	{ printf("exit\t%s;\n",$1.val);}
    ;

proc_definition:
        TOK_PROCDEF proc_name proc_header stmt
	{ printf("end %s;\n",$2.val); }
    |   TOK_PROCDEF proc_name {printf(");\n");} stmt
	{ printf("end %s;\n",$2.val); }
    |   TOK_PROCDEF proc_name {printf(");\n");} TOK_ASSIGNMENT stmt
	{ printf("end %s;\n",$2.val); }
    |   TOK_PROCDEF proc_name proc_header TOK_ASSIGNMENT stmt
	{ printf("end %s;\n",$2.val); }
    |   TOK_UNDEF tok_ident';'
    ;

proc_name:
        tok_ident
	{
		switch($1.val[0]){
		case '[':
			$1.val[strlen($1.val)-1]=0;
			printf("function multiplex(\"%s\",", $1.val+1);
			$1.val= GDKstrdup("multiplex");
			break;
		case '{':
			$1.val[strlen($1.val)-1]=0;
			printf("function group.%s(", $1.val+1);
			$1.val= GDKstrdup("group");
			break;
		case '(':
			$1.val[strlen($1.val)-1]=0;
			printf("function %s_inplace(", $1.val+1);
			$1.val= GDKstrdup("inplace");
			break;
		default: printf("function %s(",$1.val);
		}
		$$=$1;
	}
    |   TOK_CONSTANT
	{ 
	  if( $1.tpe == TYPE_str)printf("function %s(",$1.val); 
	  else mil_parseError("Operator name not a string literal");
	  $$=$1;}
    |   TOK_OPERATOR
	{ printf("function %s(",$1.val);$$=$1;}
    ;

proc_header:
        '(' mel_header ')' ':' mel_type
	{ printf("):%s;\n",$5.val);}
    |   '(' mel_header ')' 
	{ printf("):void;\n");}
    |    '(' ')' ':' mel_type
	{ printf("):%s;\n",$4.val);}
    |    '(' ')' 
	{ printf("):void;\n");}
    ;

mel_header:
        mel_params ',' mel_range
    |   mel_params 
    |   mel_range
    ;

mel_range:
        TOK_RANGETEMP mel_type TOK_RANGETEMP
	{ newId($1.val); printf(",%s:%s[]",$1.val,$2.val);}
    ;

mel_params:
        mel_type tok_ident
	{newId($2.val); printf("%s:%s",$2.val,$1.val);}
    |	tok_ident
	{newId($1.val); printf("%s:any",$1.val);}
    |   mel_params ',' mel_type tok_ident
	{newId($4.val); printf(", %s:%s",$4.val,$3.val);}
    |   mel_params ',' tok_ident
	{newId($3.val); printf("%s:any",$3.val);}
    ;

mel_type:
        tok_ident 
    |   TOK_BAT
    |   TOK_BAT '[' mel_atom ',' mel_atom ']'
	{ char buf[PATHLENGTH];
	  sprintf(buf,"bat[%s,%s]",$3.val,$5.val);
	  $$.val= GDKstrdup(buf);
	}
    |   mel_any
    ;

mel_atom:
        tok_ident
    | 	TOK_BAT
    |   mel_any
    ;

mel_any:
        TOK_ANY TOK_ANYNUM type_var
	{ char buf[PATHLENGTH];
	  sprintf(buf,"any::%s",$3.val);
	  $$.val= GDKstrdup(buf);
	}
    |   TOK_ANY
	{ $$.val = GDKstrdup("any");
	  /* printf("\n# ERROR: 'any' types should be bound to a type variable\n"); */
	}
    ;

type_var: TOK_CONSTANT
	{
	  if(strlen($1.val)>1){
	  printf("ERROR:type variable should be chosen from [0-9a-zA-Z]\n");
	  }
	}
    ;

blk_expression:
        sequential_block
    |   parallel_block
    ;

expression:
    constant term 
	{ $$.val = emitExpr($2.val); }
    |   constant template TOK_ASSIGNMENT term
	{ newId($2.val); 
	  printf("\t%s := %s;\n", $2.val, $4.val); 
	  $$=$2;}
    |   constant tok_ident TOK_ASSIGNMENT term
	{ newId($2.val); 
	  printf("\t%s := %s;\n", $2.val, $4.val); 
	  $$=$2;}
    ;

constant: TOK_CONST
	| /* empty */
    ;
	
term :
	factor
    |	factor1 TOK_OPERATOR term
	{ char stmt[1024];
	  $1.val = emitExpr($1.val);
	  $3.val = emitExpr($3.val);
	  sprintf(stmt,"%s%s,%s)", bindFcn($2.val),$1.val,$3.val);
	  $$.val=GDKstrdup(stmt);
	}
    |	TOK_OPERATOR term
	{ char stmt[1024];
	  $2.val = emitExpr($2.val);
	  sprintf(stmt,"%s%s)", bindFcn($1.val),$2.val);
	  $$.val=GDKstrdup(stmt);
	}
    |	factor1 tok_ident term
	{ char stmt[1024];
	  $1.val = emitExpr($1.val);
	  $3.val = emitExpr($3.val);
	  sprintf(stmt,"%s%s,%s)", bindFcn($2.val),$1.val,$3.val);
	  $$.val=GDKstrdup(stmt);
	}
    ;

variable_reference:
        template  {$$= $1;}
    |  	tok_ident { $$=$1;} ;

template:
        TOK_TEMPLATE
    |   TOK_ITERTEMP
    |   TOK_VARTEMP expression ')'
	{ char *nme= newName();
	  printf("\t%s := mil.getVarTemp(%s);\n",nme,$2.val);
	  $$.val= nme;
	}
    |   TOK_VARTEMP expression TOK_RANGETEMP ')'
	{ char *nme= newName();
	  printf("\t%s := mil.getVarTempRange(%s);\n",nme,$2.val);
	  $$.val= nme;
	}
    ;


factor: factor1  |TOK_CONSTANT
	;
factor1:
       TOK_STRING
    |   TOK_BAT
    |  	variable_reference
	{$$=$1; bindId($1.val);}
    |   '[' multiplex_expression ']' 
	{ $$= $2;}
    | 	fcn_call
    |   '(' expression ')' { $$= $2;}
    ;
@-
The separator should be limited to ',' and '~' should be
added back as an operator symbol.
@y
multiplex_comma: ',' |  '~'
    ;

multiplex_expression:
      multiplex_term multiplex_comma multiplex_term
	{ $$.val= newName();
	printf("\t%s:= zipper(%s,%s);\n", $$.val, $1.val, $3.val);}
    | multiplex_term
	/* { $$.val= newName();
	printf("\t%s:= M2m.batconstruct1(%s);\n", $$.val, $1.val);}*/
    ;

multiplex_term:
        bat_expression
    |   expression '?' bat_expression ':' 
	{$$.val = newName();
	 printf("\t%s := ifthen(%s,%s);\n",$$.val, $1.val,$3.val);
	}
    |   expression '?' bat_expression ':' expression
	{$$.val = newName();
	 printf("\t%s := ifthenelse(%s,%s,%s);\n",$$.val,
		$1.val,$3.val,$5.val);
	}
    ;

bat_expression:
        expression
     |   /* empty */
	{ $$.val =newName();
	  printf("\t%s:= nil;\n",$$.val);}
    ;

fcn_call: 
	fcn_call_A
    | 	fcn_call '.' tok_ident
	{ char stmt[1024];
	  $1.val= emitExpr($1.val);
	  sprintf(stmt,"%s%s)", bindFcn($3.val),$1.val);
	  $$.val = GDKstrdup(stmt);}
    |	fcn_call '.' fcn_call_B
	{ char stmt[1024], *s;
	  /* move the result of the function into the second call */
	  $1.val = emitExpr($1.val);
	  s= strchr($3.val,'(');
	  if(s==0) printf("unexpected function\n"); 
	  else{
		*s = 0;
		sprintf(stmt,"%s%s,%s", bindFcn($3.val),$1.val,s+1);
	  }
	  $$.val = GDKstrdup(stmt);
	}
    ;

fcn_call_A:
	fcn_target
    |   fcn_call_B
    ;

fcn_call_B:
     	fcn_hdr '(' expr_list ')'
	{ char stmt[1024];
	  sprintf(stmt,"%s%s)", bindFcn($1.val),$3.val);
	  $$.val = GDKstrdup(stmt); }
    |	fcn_hdr '(' ')'
	{ char stmt[1024];
	  sprintf(stmt,"%s)", bindFcn($1.val));
	  $$.val = GDKstrdup(stmt);}
    ;

fcn_hdr: 
       TOK_DEREF factor1 ')'  
	{ char stmt[1024];
	  $2.val =emitExpr($2.val);
	  sprintf(stmt,"mil.deref(%s,",$2.val);
	  $$.val= GDKstrdup(stmt);
	}
    |  TOK_SETOP factor1 ']' 
	{ char stmt[1024];
	  $2.val =emitExpr($2.val);
	  sprintf(stmt,"mil.multiplex_deref(%s,",$2.val);
	  $$.val= GDKstrdup(stmt);
	}
    |  TOK_SETAGGR factor1 '}'
	{ char stmt[1024];
	  $2.val =emitExpr($2.val);
	  sprintf(stmt,"mil.group_deref(%s,",$2.val);
	  $$.val= GDKstrdup(stmt);
	}
    |  TOK_BAT
	{ 
	  $$.val="bat";
	}
    |  TOK_OPERATOR	
	{ $$= $1; }
    |  tok_ident	
	{ $$= $1; }
    ;
 
fcn_target : TOK_CONSTANT 
   |	'[' multiplex_expression ']'  { $$.val= $2.val;}
   |	'(' expression ')'  {$$.val= $2.val;}
   |	variable_reference  {$$=$1; bindId($1.val);}
    ;

expr_list:
     	expression
	{$$.val = emitExpr($1.val);}
    |	expr_list ',' expression
	{ $$.val= emitExpr( glue(glue($1.val,","),$3.val));}
    ;

module_list:
      modident
	/* {printf("use \"kernel/%s\";\n",$1.val);}*/
    | module_list ',' modident
	/* {printf("use \"kernel/%s\";\n",$3.val);}*/
    ;

modident:
        TOK_CONSTANT
    |   tok_ident
    |   TOK_BAT
    ;

varidents:
        TOK_VAR ident_decl
    |   varidents ',' ident_decl
    ;

ident_decl:
        tok_ident 
	{newId($1.val); }
    |   tok_ident TOK_ASSIGNMENT term
 	{newId($1.val); printf("\t%s:= %s;\n",$1.val,$3.val); }
	;
tok_ident: TOK_IDENT
	{ $$.val= mapid($1.val); }
    ;
%%

@-
Display the error information for the current client.
An arrow and state number is printed at the "appropriate" place. 
If no lookahead character is a used and the next character is a newline,
we should also copy the input .
@{
@y
void mil_parseError(str msg){
        static char buf[1024];
        char *s=buf, *t, *l = mil_lastline();
        long i = strlen(GDKERROR);
	strcpy(buf,GDKERROR); s+= i;

        mil_flushbuffer(); /* flush the lexer's buffer */

        *s++ = '"';
        for(t=l; *t && *t!='\n'; t++) {
                /* accidental %s directives in the lastline can
                   crash the vfsprintf later => escape them */
                if (*t == '%') *s++ = '%';
                *s++ = *t;
        }
        *s++ = '"'; *s++ = '\n';

	/* produce the position marker*/
        for(*s++ = '!'; i > 0; i--) *s++ = ' ';
	i = mil_position();
        for(; i > 0; i--) {
                *s++ = (*l != '\t')?' ':'\t';
        }
        *s++ = '^'; *s++ = '\n'; *s = 0;
        if (msg) {
                sprintf(s, "! %s.\n", msg);
        } else {
                sprintf(s, "! "); s += 2;
                if (*s == 0) sprintf(s,"can't help you here, sorry.\n");
        }
        GDKerror(buf);
}

static void mil_print(FILE *f, /*int tpe,*//*Stefan: unused!*/ YYSTYPE v)
{
	if( v.len >0) fprintf(f," %s ", v.val);
}
/* yytname should be known
char *lexname[] = {
 "TOK_ITERTEMP", "TOK_TEMPLATE", "TOK_VARTEMP", "TOK_RANGETEMP",
 "TOK_CONSTANT", "TOK_ASSIGNMENT", "TOK_PARBLOCK",
 "TOK_PAREND", "TOK_IDENT", "TOK_IF", "TOK_WHILE", 
 "TOK_BREAK", "TOK_RETURN", "TOK_VAR", 
 "TOK_CONST", "TOK_BATCAST", 
 "TOK_OPERATOR", "TOK_SETAGGR", "TOK_PROCDEF",
 "TOK_STRING", "TOK_ITERATION", "TOK_ELSE", 
 "TOK_MODULE", 
 "TOK_ANY", "TOK_UNDEF", "TOK_DEREF", "TOK_ANYNUM", 0, };
*/

const char *yylexname(int Y)           
{ 	if (Y >= TOK_ITERTEMP && Y <= TOK_ANYNUM) {
		return yytname[Y-TOK_ITERTEMP];
	} 
	return "char";
}
@+ Utilities
Generation of the Mal code block requires
@c
static char  nameId[3]= {'a','a','a'};
char *newName(){
	char buf[IDLENGTH];
	sprintf(buf,"%c%c_%c", nameId[0],nameId[1],nameId[2]);
	nameId[0]++;
	if( nameId[0]>='z'){
		nameId[0]='a';
		nameId[1]++;
		if( nameId[1]>='z'){
			nameId[1]='a';
			if(nameId[2]>='z'){
				GDKerror("out of temporary variable names\n");
			} else nameId[2]++;
		}
	}
	fndId(GDKstrdup(buf));
	return GDKstrdup(buf);
}
char *getName(int i){
	char buf[IDLENGTH];
	sprintf(buf,"_v%d", i);
	return GDKstrdup(buf);
}

char *getOperator(char *nme){
	int l = strlen(nme);
	str n= GDKmalloc(strlen(nme));
	strncpy(n,nme+1,l-2);
	n[l-1] = 0;
	return n;
}
@}

