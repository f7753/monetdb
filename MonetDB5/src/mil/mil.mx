@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2005 CWI.
@' All Rights Reserved.

@t MIL Scenario implementation
@a M Kersten 
@v 0
@* MIL Scenario implementation
As a first step in supporting user controlled scenarios, 
we provide a little side-step to compile and run
mil statements. The current approach is to simply
dump the user input onto a temporary file to be processed
separately by M2m and subsequently read as a MIL block to
be executed by the MALengine.

The end of the MIL statement to be executed is recognized
by receiving an empty line. This is a rather limited
approach, but avoid building a complex MIL parser at
this stage. Perhaps we can revamp M2m later on to be
included as a small parser.

@h
#include "mal_function.h"
#include "mal_client.h"
#include "mal_session.h"
#include "mal_parser.h"

/* #define MIL_DEBUG*/

mal_export str MILparser(Client c);
mal_export str MILengine(Client c);
@-
The MIL scenario requires the global environment of a
corresponding MAL scenario. How to pass this information around?

@c
#include "mil.h"

str MILreader(Client c){
	stream *f= NULL;
	str dbname= GDKgetenv("gdk_dbname");
	char input[PATHLENGTH];
	char *s;

	snprintf(input,PATHLENGTH,"/tmp/%s%d.mil",dbname,(int) MT_getpid());
#ifdef MIL_DEBUG
	stream_printf(GDKout,"MILparser: start saving MIL program  to %s\n",input);
#endif
	f= open_wastream(input);
	if( f== NULL)
	return throwMessage("MILreader","can not create input file\n");
	c->prompt= GDKstrdup("mil>");
	c->promptlength= strlen(c->prompt);
	while( c->mode > FINISHING && readClient(c)){
		if (currChar(c) == 0) 
			break;
#ifdef MIL_DEBUG
		stream_printf(GDKout,"saving:%s\n", CURRENT(c));
#endif 
		stream_printf(f, "%s", CURRENT(c));
		s = CURRENT(c); 
		while(*s) 
			s++;
		*s= '\n';
		s++; 
		*s=0;
		c->fdin->pos += c->yycur;
	    c->yycur = 0;
	}
#ifdef MIL_DEBUG
	stream_printf(GDKout,"MILparser: finished reading the block\n");
#endif
	stream_flush(f);
	stream_close(f);
	/* if( c->fdin->eof(c->fdin) )  c->mode= FINISHING;*/
	if( c->mode <= FINISHING)
		return throwMessage("MILreader","end of MIL input\n");
	return 0;
}
@-
Now we have a file with the MIL program. This can be processed by the M2m
command. Subsequently it can be readin again into the client buffer for
processing by with the MALparser.
@c
str MILparser(Client c) {
	str dbname= GDKgetenv("gdk_dbname");
	char input[PATHLENGTH];
	char output[PATHLENGTH];
	char cmd[2* PATHLENGTH];
	str msg;

	snprintf(input,PATHLENGTH,"/tmp/%s%d.mil",dbname,(int) MT_getpid());
	snprintf(output,PATHLENGTH,"/tmp/%s%d.mal",dbname,(int) MT_getpid());
	snprintf(cmd, 2*PATHLENGTH,"M2m %s >%s", input,output);
	if( system(cmd) == -1){
#ifdef MIL_DEBUG
	stream_printf(GDKout,"M2m failed:%s\n",cmd);
#endif
		return throwMessage("MILparser","compilation failed\n");
	}
	msg= malLoadScript(c,output);
	if(msg == 0 ) msg= MALparser(c);
/*
	unlink(input);
	unlink(output); */
	return msg;
}
@-
Execution of the MIL program is delegated to the MALengine.
@c
str MILengine(Client c) {
	str msg =MAL_SUCCEED;
	MalStkPtr oldglb= c->glb;

	/* printFunction(GDKout,c->curprg->def,c->listing);*/
	c->glb= 0;
	msg= MALengine(c);
	c->glb= oldglb;
	return msg;
}
@-
Command implementations.
@c
str MILsession(str *ret){
        str msg= MAL_SUCCEED;
        stream_printf(GDKout,"#Continue as MIL session\n");
        msg= setScenario(getClient(),"mil");
        *ret = 0;
        return msg;
}

