@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2005 CWI.
@' All Rights Reserved.
@f dc_scheduler
@a M.L. Kersten
@+ The DataCell scheduler
The DataCell scheduler selects and activitates the pump queries.
In a full blown version, it will use the dependency relationship
and quantitative information.

The first step is to simply activate each pump query and stop.
@mal
command isolate(uname:str,target:str):void
address DCisolate
comment "Pump get the public store of the target for private use.";

command release(target:str):void
address DCrelease
comment "Release control over the connection point.";

command datacell.startPump(nme:str)
address DCstartPump
comment "Activate a specific receptor";

command datacell.stopPump(nme:str)
address DCstopPump
comment "Activate a specific receptor";

command datacell.startScheduler(delay:int)
address DCstartScheduler
comment "Give an overview of the actions taken";

command datacell.stopScheduler()
address DCstopScheduler
comment "Give an overview of the actions taken";

command datacell.schedulerLog():bat[:timestamp,:str]
address DCschedulerLog
comment "Give an overview of the actions taken";

@- Implementation

@h
#ifndef _DC_SCHEDULER_DEF
#define _DC_SCHEDULER_DEF

/* #define DEBUG_DC_SCHEDULER */

#include "mal.h"
#include "mal_client.h"
#include "mal_interpreter.h"
#include "datacell.h"

#endif /* _DC_SCHEDULER_DEF */
@-
@c
#include "dc_compiler.h"
#include "dc_scheduler.h"
#include "../modules/mal/tablet.h"
#include "mal_interpreter.h"
#include "mal_exception.h"
#include "dc_receptor.h"

extern str DCnaiveScheduler();

#define MAXBUF 1024

str
DCschedulerLog(int *ret, str* expr){
	(void) expr; (void) ret;
	return throwMessage("datacell.schedulerLog","nyi");
}
str
DCstartScheduler(int *ret, int* delay){
	(void) ret;
	return DCnaiveScheduler(5, *delay);
}
str
DCstopScheduler(int *ret, str* expr){
	(void) expr; (void) ret;
	return throwMessage("datacell.stopScheduler","nyi");
}
@- Naive scheduling
@c
str
DCnaiveScheduler(int cycles, int delay){
	int i;
	Client c= getClient();
	str msg;
#ifdef DEBUG_DC_SCHEDULER
	stream_printf(GDKerr,"#Start scheduling pumps with delay %d\n",delay);
#endif
	while( cycles-- > 0){
		for(i=0; i< pumpindex; i++)
		if( pumps[i].name  && pumps[i].mal[0] && pumps[i].kind== NUCLEUS){
#ifdef DEBUG_DC_SCHEDULER
		stream_printf(GDKerr,"#Run %s\n",p->name);
		printFunction(GDKout,pumps[i].malblk[0],0);
#endif
			msg= runMAL(c,pumps[i].malblk[0],1,0,0,0);
			if( msg)
				stream_printf(GDKout,"%s",msg);
		}
		MT_sleep_ms(delay);
	}
	return MAL_SUCCEED;
}

@-
The pump operations should access the content of the tables
in a private way. If you isolate the new set of events,
the old tables are being re-used to receive the new events.
Their are simply cleared. Note that this means that the largest
space used in the past is claimed.
@c

str
DCisolate(int *ret, str *uname, str *target){
	DCpump p,u;
	int i,del=0;
	BAT *b;

    (void) ret; 
	u= DClocatePump(*uname);
	if( u == 0)
		return throwMessage("datacell.isolate","Usedby not found\n");
	p= DClocatePump(*target);
	if( p == 0)
		return throwMessage("datacell.isolate","Target pump not found\n");
#ifdef DEBUG_DC_SCHEDULER
		stream_printf(GDKerr,"#%s isolates %s\n",*uname,*target);
		stream_printf(GDKerr,"#counts %d %d\n",
			BATcount(p->public[0]),BATcount(p->private[0]));
#endif
	mal_set_lock(p->lock,"datacellIsolate");
	if( p->usedby && p->usedby != p-pumps){
		mal_unset_lock(p->lock,"datacellIsolate");
		return throwMessage("datacell.isolate","Pump still in use\n");
	}
	if( p->kind == EMITTER) {
		 /* they take care of it */
	} else if(p->usedby ==0 ) {
		del= BATcount(p->public[0]);
		for(i=0; i< p->cols; i++){
			b= p->private[i];
			p->private[i]= p->public[i];
			p->public[i]= b;
			if(del) BATclear(p->private[i]);
		}
	}
	p->usedby= p - pumps;
	mal_unset_lock(p->lock,"datacellIsolate");
#ifdef DEBUG_DC_SCHEDULER
		stream_printf(GDKerr,"#%s\n",log);
#endif
    return MAL_SUCCEED;
}
str
DCrelease(int *ret, str *target){
	DCpump p;

    (void) ret; 
	p= DClocatePump(*target);
	if( p == 0 )
		return throwMessage("datacell.release","Pump not found\n");
#ifdef DEBUG_DC_SCHEDULER
		stream_printf(GDKerr,"#release %s\n",*target);
#endif
	p->usedby = 0;
	if( p->kind== EMITTER && p->lock)
		mal_unset_lock(p->lock,"datacell.release");
    return MAL_SUCCEED;
}

str
DCstartPump(int *ret, str *name)
{	DCpump p;
	str msg= MAL_SUCCEED;

	(void) ret; 
	p= DClocatePump(*name);
	if( p == 0)
		return throwMessage("datacell.startReceptor","unknown host");
	if( p->host == 0 )
		return throwMessage("datacell.startReceptor","unknown host");
	if( p->port < 0 )
		return throwMessage("datacell.startReceptor","unknown port");
#ifdef DEBUG_DCRECEPTOR
	stream_printf(GDKout,"#Activate reception %s at port %d of %s\n",
		p->name,p->port,p->host);
#endif

	if( p->status == -1){
		if( p->kind == RECEPTOR)
			msg= DClistenReceptor(p, NULL);
		else msg= throwMessage("datacell.startPump","NYI");
	}
	p->status=1;
	return msg;
}
str
DCstopPump(int *ret, str *name)
{	DCpump p;

	(void) ret; 
	p= DClocatePump(*name);
	if( p == 0)
		return throwMessage("datacell.startReceptor","unknown host");
	if( p->host == 0 )
		return throwMessage("datacell.startReceptor","unknown host");
	if( p->port < 0 )
		return throwMessage("datacell.startReceptor","unknown port");
#ifdef DEBUG_DCRECEPTOR
	stream_printf(GDKout,"#Deactivate reception %s at port %d of %s\n",
		p->name,p->port,p->host);
#endif

	p->status=0;
	return throwMessage("datacell.stopPump","nyi");
}
