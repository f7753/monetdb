@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2005 CWI.
@' All Rights Reserved.
@f dc_scheduler
@a M.L. Kersten
@+ The DataCell scheduler
The DataCell scheduler selects and activitates the pump queries.
In a full blown version, it will use the dependency relationship
and quantitative information.

The first step is to simply activate each pump query and stop.
@mal
command isolate(uname:str,target:str):void
address DCisolate
comment "Pump get the public store of the target for private use.";

command release(sname:str):void
address DCrelease
comment "Release control over the connection point.";

command datacell.startScheduler(delay:int)
address DCstartScheduler
comment "Give an overview of the actions taken";

command datacell.stopScheduler()
address DCstopScheduler
comment "Give an overview of the actions taken";

command datacell.schedulerLog():bat[:timestamp,:str]
address DCschedulerLog
comment "Give an overview of the actions taken";

@- Implementation

@h
#ifndef _DC_SCHEDULER_DEF
#define _DC_SCHEDULER_DEF

#define DEBUG_DC_SCHEDULER 

#include "mal.h"
#include "mal_client.h"
#include "mal_interpreter.h"
#include "datacell.h"

#endif /* _DC_SCHEDULER_DEF */
@-
@c
#include "dc_compiler.h"
#include "dc_scheduler.h"
#include "../modules/mal/tablet.h"
#include "mal_interpreter.h"
#include "mal_exception.h"

extern str DCnaiveScheduler();

#define MAXBUF 1024

str
DCschedulerLog(int *ret, str* expr){
	(void) expr; (void) ret;
	return throwMessage("datacell.schedulerLog","nyi");
}
str
DCstartScheduler(int *ret, int* delay){
	(void) ret;
	return DCnaiveScheduler(5, *delay);
}
str
DCstopScheduler(int *ret, str* expr){
	(void) expr; (void) ret;
	return throwMessage("datacell.stopScheduler","nyi");
}
@- Naive scheduling
@c
str
DCnaiveScheduler(int cycles, int delay){
	DCpump p;
	Client c= getClient();
	str msg;
#ifdef DEBUG_DC_SCHEDULER
	stream_printf(GDKerr,"#Start scheduling pumps with delay %d\n",delay);
#endif
	while( cycles-- > 0){
		for(p=pumps; p<pumps+pumpindex; p++)
		if( p->name  && p->mal[0] && p->kind== NUCLEUS){
#ifdef DEBUG_DC_SCHEDULER
		stream_printf(GDKerr,"#Run %s\n",p->name);
		printFunction(GDKout,p->malblk[0],0);
#endif
			msg= runMAL(c,p->malblk[0],1,0,0,0);
			if( msg)
				stream_printf(GDKout,"%s",msg);
		}
		MT_sleep_ms(delay);
	}
	return MAL_SUCCEED;
}

@-
The pump operations should access the content of the tables
in a private way. If you isolate the new set of events,
the old tables are being re-used to receive the new events.
Their are simply cleared. Note that this means that the largest
space used in the past is claimed.
@c

str
DCisolate(int *ret, str *uname, str *target){
	DCpump p,u;
	int i,bid,cnt=0;
	BAT *b;
	char log[MAXBUF];

    (void) ret; 
	u= DClocatePump(*uname);
	if( u == 0)
		return throwMessage("datacell.isolate","Usedby not found\n");
	p= DClocatePump(*target);
	if( p == 0)
		return throwMessage("datacell.isolate","Target pump not found\n");
#ifdef DEBUG_DC_SCHEDULER
		stream_printf(GDKerr,"#%s isolates %s\n",*uname,*target);
#endif
	mal_set_lock(p->lock,"datacellIsolate");
	if( p->usedby)
		return throwMessage("datacell.isolate","Pump still in use\n");
	p->usedby= p - pumps;
	for(i=0; i< p->cols; i++){
		bid= p->private[i];
		p->private[i]= p->public[i];
		b= BATdescriptor(bid);
		if( b== NULL)
			return throwMessage("datacell.isolate","Pump BAT disappeared\n");
		if(i== 0) cnt= BATcount(b);
		BATclear(b);
		BBPunfix(b->batCacheid);
		p->public[i]= bid;
	}
	mal_unset_lock(p->lock,"datacellIsolate");
	snprintf(log,MAXBUF,"isolate user=%s target=%s events=%d", 
			*uname, *target,cnt);
#ifdef DEBUG_DC_SCHEDULER
		stream_printf(GDKerr,"#%s\n",log);
#endif
    return MAL_SUCCEED;
}
str
DCrelease(int *ret, str *sname){
	DCpump p;

    (void) ret; (void) *sname;
	p= DClocatePump(*sname);
	if( p == 0)
		return throwMessage("datacell.release","Pump not found\n");
#ifdef DEBUG_DC_SCHEDULER
		stream_printf(GDKerr,"#release %s\n",*sname);
#endif
    return MAL_SUCCEED;
}

