@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2005 CWI.
@' All Rights Reserved.
@f dc_scheduler
@a M.L. Kersten
@+ The DataCell scheduler
The DataCell scheduler selects and activitates the pump queries.
In a full blown version, it will use the dependency relationship
and quantitative information.

The first step is to simply activate each pump query and stop.
@mal
command isolate(sname:str):void
address DCisolate
comment "Make a copy of the connection table available
for private use.";

command release(sname:str):void
address DCrelease
comment "Release control over the connection point.";

command datacell.startScheduler(delay:int)
address DCstartScheduler
comment "Give an overview of the actions taken";

command datacell.stopScheduler()
address DCstopScheduler
comment "Give an overview of the actions taken";

command datacell.schedulerLog():bat[:timestamp,:str]
address DCschedulerLog
comment "Give an overview of the actions taken";

@- Implementation

@h
#ifndef _DC_SCHEDULER_DEF
#define _DC_SCHEDULER_DEF

#define DEBUG_DC_SCHEDULER 

#include "mal.h"
#include "mal_client.h"
#include "mal_interpreter.h"
#include "datacell.h"

#endif /* _DC_SCHEDULER_DEF */
@-
@c
#include "dc_compiler.h"
#include "dc_scheduler.h"
#include "../modules/mal/tablet.h"
#include "mal_interpreter.h"
#include "mal_exception.h"

extern str DCnaiveScheduler();

str
DCschedulerLog(int *ret, str* expr){
	(void) expr; (void) ret;
	return throwMessage("datacell.schedulerLog","nyi");
}
str
DCstartScheduler(int *ret, int* delay){
	(void) ret;
	return DCnaiveScheduler(5, *delay);
}
str
DCstopScheduler(int *ret, str* expr){
	(void) expr; (void) ret;
	return throwMessage("datacell.stopScheduler","nyi");
}
@- Naive scheduling
@c
str
DCnaiveScheduler(int cycles, int delay){
	DCpump p;
	Client c= getClient();
	str msg;
#ifdef DEBUG_DC_SCHEDULER
	stream_printf(GDKerr,"#Start scheduling pumps with delay %d\n",delay);
#endif
	while( cycles-- > 0){
		for(p=pumps; p<pumps+pumpindex; p++)
		if( p->name  && p->mal[0] && p->kind== NUCLEUS){
#ifdef DEBUG_DC_SCHEDULER
		stream_printf(GDKerr,"#Run %s\n",p->name);
		printFunction(GDKout,p->malblk[0],0);
#endif
			msg= runMAL(c,p->malblk[0],1,0,0,0);
			if( msg)
				stream_printf(GDKout,"%s",msg);
		}
		MT_sleep_ms(delay);
	}
	return MAL_SUCCEED;
}

@-
The pump operations should access the content of the pump tables
in a private way.
@c

str
DCisolate(int *ret, str *sname){
	DCpump p;

    (void) ret; (void) *sname;
	p= DClocatePump(*sname);
	if( p == 0)
		return throwMessage("datacell.isolate","Pump not found\n");
#ifdef DEBUG_DC_SCHEDULER
		stream_printf(GDKerr,"#isolate %s\n",*sname);
#endif
    return MAL_SUCCEED;
}
str
DCrelease(int *ret, str *sname){
	DCpump p;

    (void) ret; (void) *sname;
	p= DClocatePump(*sname);
	if( p == 0)
		return throwMessage("datacell.release","Pump not found\n");
#ifdef DEBUG_DC_SCHEDULER
		stream_printf(GDKerr,"#release %s\n",*sname);
#endif
    return MAL_SUCCEED;
}

