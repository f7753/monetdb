@* The streamSource program

This program generates a stream on a particular port.
The controlling parameters are the host (-h), the port id (-p).
The events either come from a pre-cooked ascii file (-f)
or they are generated internally (-N). In the latter case
it assumes integer fields only and the number of columns
should explicity be set (-C).
Sending the events to the DataCell can be batched (-B) or delayed (-D)
a number of milliseconds.
@f dcsource
@c
#include "mal.h"

#ifdef HAVE_UNISTD_H
# include <unistd.h>
#endif
#include  <stdio.h>
#ifdef HAVE_PWD_H
#include  <pwd.h>
#endif

#include  <sys/types.h>

#ifdef HAVE_SYS_SOCKET_H
# include <sys/socket.h>
#endif
#ifdef NATIVE_WIN32
# include <winsock.h>
#endif
#ifdef HAVE_SYS_UN_H
#include <sys/un.h>
#endif

#include  <signal.h>
#include  <string.h>
#include  <memory.h>

#if TIME_WITH_SYS_TIME
# include <sys/time.h>
# include <time.h>
#else
# if HAVE_SYS_TIME_H
#  include <sys/time.h>
# else
#  include <time.h>
# endif
#endif

#if defined(HAVE_WINSOCK_H) && defined(NATIVE_WIN32)
#include <winsock.h>        /* for timeval */
#endif

#include <stream.h>     /* for stream */


#define MAXBUF 1024

FILE *fd;

stream *toServer;

char *connect_to_server(char * hostname, int port)
{
	struct sockaddr_in server;

#ifdef HAVE_SYS_UN_H
	/* struct sockaddr_un userver;*/
#endif
	struct sockaddr *serv;
	size_t servsize;
	int s;

#ifdef HAVE_SYS_UN_H
	/* if (
		   hostname && hostname[0] == '/') {
		if (strlen(hostname) >= sizeof(userver.sun_path)) {
			return "path name too long";
		}
		userver.sun_family = AF_UNIX;
		strncpy(userver.sun_path, hostname, sizeof(userver.sun_path));
		serv = (struct sockaddr *) &userver;
		servsize = sizeof(userver);
	} else
	*/
#endif
	{
		struct hostent *hp;

		hp = gethostbyname(hostname);
		if (hp == NULL) {
			return "gethostbyname failed";
		}
		memset(&server, 0, sizeof(server));
		memcpy(&server.sin_addr, hp->h_addr, hp->h_length);
		server.sin_family = hp->h_addrtype;
		server.sin_port = htons((unsigned short) (port & 0xFFFF));
		serv = (struct sockaddr *) &server;
		servsize = sizeof(server);
	}

	s = socket(serv->sa_family, SOCK_STREAM, IPPROTO_TCP);
	if (s < 0) {
		return "Open socket failed";
	}

	if (connect(s, serv, servsize) < 0) {
#ifdef NATIVE_WIN32
		fprintf(stderr, "!ERROR reconnect: connect: error %d\n", WSAGetLastError());
#else
		perror("!ERROR reconnect: connect");
#endif
		return "Setup connection failed";
	}
	toServer = block_stream(socket_wstream(s, "sensorDump write"));
	if ((toServer) == NULL || stream_errnr(toServer)) {           \
		return "stream closed";
	}

	return NULL;
}

void usage(){
	printf("sensorDump -h <host> -p <port>  -C <columns> -N <tuples> -B <batch> -d <delay>\n");
	printf("-h host name, default localhost\n");
	printf("-p port id \n");
	printf("-C number of columns, default 1\n");
	printf("-N number of generated tuples, default 1\n");
	printf("-B batch size, default 1\n");
	printf("-d delay in milliseconds, default 0\n");
	printf("-t use temporal events \n");
	exit(-1);
}

int main(int argc, char **argv){
	int i,b=1;
	char *err;
	char *host= "localhost"; 
	int port=50000;
	char *fname= "";
	int delay = -1;
	int batch=1,N=1, cols=1, random=1;
	char buf[MAXBUF];

	if( argc== 1) usage();
	for(i=1;i<argc; i++)
	switch( argv[i][1]){
	case 'h':
		host= argv[++i];
		break;
	case 'B': /* batch size */
		b= batch = strtol(argv[++i], 0,0);
		if( batch <=0) {
			printf("Illegal batch %d\n",batch);
			exit(0);
		}
		break;
	case 'C':
		cols= strtol(argv[++i], 0,0);
		break;
	case 'N':
		N= strtol(argv[++i], 0,0);
		break;
	case 'p':
		port= strtol(argv[++i], 0,0);
		break;
	case 'd':
		delay= strtol(argv[++i], 0,0);
		break;
	case 'f':
		fname= argv[++i];
		break;
	case 'r':
		/* generate random number records */
		random=1; 
		break;
	case 't':
		/* generate temporal event records */
		random=0; 
		break;
	case '?':
		usage();
		return -1;
	default:
		printf("Unknown option %s\n",argv[i]);
		return -1;
	}
	if(N)
	printf("sensorDump -h %s -p %d  -N %d -B %d -d %d\n", host,port, N,batch, delay);
	else
	printf("sensorDump -h %s -p %d  -B %d -f %s -d %d\n", host,port, batch, fname,delay);
	if( (err= connect_to_server(host,port)) ){
		printf("FATAL:%s\n",err);
		return -1;
	}

	/* deposit events */
	b = batch;
	if( N && cols>0){
		/* generate an integer NxA event stream */
	
		while(N-->0){
			int i,r;
			r= random? rand(): time(0);
			stream_printf(toServer,"%d",r);
			if( delay<0) printf("%d",r);

			for(i=1;i<cols; i++){
				r= random? rand(): time(0);
				stream_printf(toServer,",%d",r);
				if( delay<0) printf(",%d",r);
			}

			stream_printf(toServer,"\n");
			if( delay<0){
				printf("\nsend it?");
				getchar();
			}
			if( batch){
				if( b<=1){
					stream_flush(toServer);
					if( delay > 0 ){
						printf("\ndelayed nyi sent %d",r);
					}
					b= batch;
				} else b--;
			
			}
		}
		stream_flush(toServer);
	} else {
		fd= fopen(fname,"r");
		if( fd== NULL){
			printf("Could not open file '%s'\n",fname);
			return -1;
		}

		while(fgets(buf,MAXBUF,fd) != 0){
			if( delay <0){
				printf("%s",buf);
				printf("send it?");
				getchar();
			}
			stream_write(toServer,buf,1, strlen(buf));
			if( batch){
				if( b<=1){
					if( batch >1) printf("flushed\n");
					stream_flush(toServer);
					b= batch;
				} else b--;
			
			}
			/* deal with timed delays */
		}
	}
}
