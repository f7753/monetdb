@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2005 CWI.
@' All Rights Reserved.
@f dc_receptor
@a M.L. Kersten
@+ Receptor control

A receptor controls the interaction with external devices
delivering event tuples for processing. It is implemented as
a separate thread of control, which accepts connections
from remote users and issues an acknowledgement using
a hardwired authorization scheme.

Each channel gets a private thread to receive the events
and update a private receptor table. The current 
implementation allows just one device to hook up to an access point.

The events are collected in two tables. The private
table is used to store the events as they arrive over
the communication channel. Statistics are collected on the
inter-arrival time to provide a basis for scheduling
decisions.

The public table is controlled by a pump query.
It is a copy of the private table created when a pump
query is activated and needs its content. 
The benefit of this approach is that the query and
channel manager do not have to regulate their activities
using expensive locking. It is only required at the moment
the private buffer is turned into a public buffer.

The content of the private table is fully controlled by the
receptor thread. The default policy is to discard
all tuples from the binary as soon as
have been stored in the public table.
A more refined scheme can be encoded in a separate 'drain'
query, which is called after the secondary table has been
filled and released to the query thread.

Tuples can be silently droppped when their timeout
expires. This is piggybacked on the transfer of tuples
to the secondary table and when we run into resource
problems.
@mal
command datacell.startReceptor(nme:str)
address DCstartReceptor
comment "Activate a specific receptor";

command datacell.stopReceptor(nme:str)
address DCstopReceptor
comment "Activate a specific receptor";

command datacell.getReceptorStatus(nme:str)
address DCgetReceptorStatus
comment "Display the actual state of a receptor.";

command data.bindReceptor(sname:str,pname:str) 
		(public:bat[:void,:any$1],private:bat[:void,:any$1])
address DCbindReceptor
comment "Provide access to a private version of a column.";

@{
@- Implementation
The implementation is based on the assumption that 
the sensor produces information for a designated collection
of BATs. A separate process is created for each sensor to receive
and analyse the data. 

@h
#ifndef _DCRECEPTOR_DEF
#define _DCRECEPTOR_DEF

#define DEBUG_DCRECEPTOR 

#include "datacell.h"

#endif /* _DCRECEPTOR_DEF */
@c
#include "dc_receptor.h"

#ifndef DC_H
#define DC_H

#define NEW_ARRAY( type, size )	(type*)GDKmalloc((size)*sizeof(type))
#define STREQ(a, b) 		(strcmp(a, b)==0)

#endif /* DC_H */

#include  <sys/types.h>
#ifdef HAVE_SYS_SOCKET_H
# include <sys/socket.h>
#endif
#ifdef HAVE_WIN32
# include <winsock.h>
#endif
#ifdef HAVE_SYS_UN_H
#include <sys/un.h>
#endif

#define SOCKPTR struct sockaddr *
#if HAVE_SOCKLEN_T
#define SOCKLEN socklen_t
#else
#define SOCKLEN int
#endif

#ifdef NATIVE_WIN32
#define s_close(s)	closesocket(s)
#else
#define s_close(s)	close(s)
#endif

#ifdef HAVE_OPENSSL
#include <openssl/ssl.h>
#include <openssl/err.h>
#endif


static int usock = -1;

typedef struct {
    int socket;
    /*str sname; does not work */
} *SensorInfo;

static DCpump channel; /* insecure channel between threads! */

extern str DCstartChannel(DCpump p, bstream *bs);
extern str DClistenReceptor(DCpump p, str *Usockfile);
extern str DClistenThread(SensorInfo sensor);


str
DCgetReceptorStatus(int *ret){
	BAT *bn ;
	int i = DCcontainer(TYPE_int,pumplimit);
	DCpump p;
	oid o= oid_nil;

	bn= BATdescriptor(i);
	BATseqbase(bn,0);
	for(p=pumps; p<pumps+pumplimit; p++)
	if( p->name && p->kind== RECEPTOR ){
		BUNins(bn,&o,&p->status);
	}
	BBPincref(*ret= bn->batCacheid,TRUE);
	BBPunfix(*ret);
	return MAL_SUCCEED;
}

str
DCstartReceptor(int *ret, str *name )
{	DCpump p;
	str msg= MAL_SUCCEED;

	(void) ret; 
	p= DClocatePump(*name);
	if( p == 0)
		return throwMessage("datacell.startReceptor","unknown host");
	if( p->host == 0 )
		return throwMessage("datacell.startReceptor","unknown host");
	if( p->port < 0 )
		return throwMessage("datacell.startReceptor","unknown port");
#ifdef DEBUG_DCRECEPTOR
	stream_printf(GDKout,"#Activate reception %s at port %d of %s\n",
		p->name,p->port,p->host);
#endif

	msg=DClistenReceptor(p, NULL);
	return msg;
}

str
DCstopReceptor(int *ret, str *name )
{	DCpump p;
	str msg= MAL_SUCCEED;

	(void) ret; 
	p= DClocatePump(*name);
	if( p == 0)
		return throwMessage("datacell.startReceptor","unknown host");
#ifdef DEBUG_DCRECEPTOR
	stream_printf(GDKout,"#Stop reception %s port %d of %s\n",
		p->name,p->port,p->host);
#endif
	/* soft termination of the channel */
	return msg;
}

str
DCbindReceptor(int *retpublic, int *retprivate, str *name, str *cname){
	DCpump p;
	int i;

	p= DClocatePump(*name);
	if( p == 0)
		return throwMessage("datacell.bindReceptor","unknown receptor");
	if( p->kind!= RECEPTOR)
		return throwMessage("datacell.bindReceptor","unknown receptor");
#ifdef DEBUG_DCRECEPTOR
	stream_printf(GDKout,"#bindReceptor %s.%s\n",*name,*cname);
#endif
	for(i=0; i < p->cap && p->columns[i]; i++)
	if( strcmp(p->columns[i],*cname) == 0 ){
		BBPincref( *retpublic= p->public[i], TRUE);
		BBPincref( *retprivate= p->private[i], TRUE);
	}
    return MAL_SUCCEED;
}

@-
The process thread for a channel should differentiate between
receptor/emitter and active/passive communication.
@c
str
DClistenReceptor(DCpump p, str *Usockfile)
{
	struct sockaddr_in server;
	int sock = -1;
	SensorInfo     sensor = GDKmalloc(sizeof(SensorInfo));
	channel= p;

#ifdef HAVE_SYS_UN_H
	struct sockaddr_un userver;
#endif
	SOCKLEN length = 0;
	int on = 1;
	int i = 0;
	int pid, *pidp= &pid;
	char msg[512], *usockfile, host[512];

	if (Usockfile == NULL || *Usockfile == 0 || strcmp(*Usockfile, str_nil) == 0)
		usockfile = NULL;
	else {
#ifdef HAVE_SYS_UN_H
		usockfile = GDKstrdup(*Usockfile);
#else
		usockfile = NULL;
		GDKwarning("DClistenReceptor: Unix domain sockets are not supported\n");
#endif
	}

	if (p->port <= 0 && usockfile == NULL) 
		return throwMessage("datacell.listen", 
			"no port or socket file specified\n");

	if (p->port > 0) {
		sock = socket(AF_INET, SOCK_STREAM, 0);
		if (sock < 0)
			return throwMessage("datacell.listen",
				"creation of stream socket failed\n");
@-
Set server port and allow network connections from any workstation.
Bind the socket to the server port.
The port id should be obtained from the Homes file.
@c
		server.sin_family = AF_INET;
		server.sin_addr.s_addr = INADDR_ANY;
		server.sin_port = htons((unsigned short) ((p->port) & 0xFFFF));
		for (i = 0; i < 8; i++)
			server.sin_zero[i] = 0;

		setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, (char *) &on, sizeof on);

		length = (SOCKLEN) sizeof(server);
		if (bind(sock, (SOCKPTR) & server, length) < 0) 
			return throwMessage("datacell.listen",
						"binding to stream socket failed\n");
@-
Get the new information for the server socket and start listening.
@c
		if (getsockname(sock, (SOCKPTR) & server, &length) < 0)
			return throwMessage("datacell.listen",
						"Failed getting socket name\n");
		listen(sock, 1);
	}
#ifdef HAVE_SYS_UN_H
	if (usockfile) {
		usock = socket(AF_UNIX, SOCK_STREAM, 0);
		if (usock < 0) {
			unlink(usockfile);
			return throwMessage("datacell.listen",
						"creation of Unix socket failed\n");
		}
		userver.sun_family = AF_UNIX;
		strncpy(userver.sun_path, usockfile, sizeof(userver.sun_path));

		length = (SOCKLEN) sizeof(userver);
		if (bind(usock, (SOCKPTR) & userver, length) < 0) {
			unlink(usockfile);
			return throwMessage("datacell.listen",
				"binding to Unix socket file failed\n");
		}
		listen(usock, 1);
	}
#endif

#ifdef DEBUG_DCRECEPTOR
		THRprintf(GDKerr, "DClisten:Network started at %d\n", p->port);
#endif
	sensor->socket = sock;

	if( MT_create_thread((MT_Id *)pidp,
		(void (*)(void *))DClistenThread, sensor) <0){
			return throwMessage("datacell.listen", "starting thread failed");
	}
#ifdef HAVE_SYS_UN_H
	if (usockfile)
		unlink(usockfile);
#endif
    if(p->host==0) 
		gethostname(host,(int)512); 
	else strcpy(host, p->host);
	snprintf(msg,(int)512,"#Ready to read sensor data from connection %s:%d\n",
		host,p->port);
	stream_printf(GDKout,"%s",msg);
	return MAL_SUCCEED;
}
@+ The collector
Each sensor once activate is controlled by a separate thread,
which listens to the port until the sensor is released.
If the stream breaks, it will save the data to disk and
also once every 1000 events (to be refined)

The current implementation taps into the ASCII io reader,
which means we are expecting MonetDB tuple format descriptions.
@c
str
DCstartChannel(DCpump p, bstream *bs){
	Tablet as;
	int i,res,k=0;
	Column *fmt;

#ifdef DEBUG_DCRECEPTOR
	stream_printf(GDKout,"#Start sensor reception %s\n",p->name);
#endif
	fmt= as.format= (Column*) GDKmalloc(sizeof(Column) * (MAXEVENTFIELDS+1));
	bzero((char *) fmt,sizeof(Column) * (MAXEVENTFIELDS+1));
	as.offset= 0;
	as.nr_attrs= 0;
	as.nr = (size_t) oid_nil;

	/* construct the read structure */
	/* the first column should be dealt with separately */
	/* it should contain the timestamps */
	for(i=1; i< p->cap && p->columns[i]; i++){
		fmt[k].name = p->columns[i];
		fmt[k].bval = BATdescriptor(p->private[i]);
#ifdef DEBUG_DCRECEPTOR
		stream_printf(GDKerr, "#added field %s\n", fmt[k].name );
#endif
		fmt[k].sep = GDKstrdup((char*)",");
		fmt[k].seplen = (int) strlen( fmt[k].sep );
		fmt[k].adt = fmt[k].bval->ttype;
		fmt[k].type = (char*)getTypeName(fmt[k].adt);
		fmt[k].tostr = &TABLETadt_toStr;
		fmt[k].frstr = &TABLETadt_frStr;
		fmt[k].extra = NULL;
		k++;
	}
	GDKfree(fmt[k-1].sep);
	fmt[k-1].sep = GDKstrdup((char*)"\n");
	fmt[k-1].seplen = (int) strlen( fmt[k-1].sep );
	as.nr_attrs= k; 
	/* here we fork and prepare for reading */
#ifdef DEBUG_DCRECEPTOR
		stream_printf(GDKerr, "#start loading sensor data\n");
#endif
@-
Reading the stream is interleaved with interactions from the
pump scheduler. During the actual parsing of information the
pump scheduler is locked out from accessing the receptor table.
This scheme works under the assumption that the TABLEload_file
is interrupted with each stream_flush from the sensorSource.
@c
	res =1;
	while(res>0 && !stream_errnr(bs->s)){
		bs->eof=0;
		as.nr = ~(size_t) 0;
		res=TABLETload_file(&as, bs);
#ifdef DEBUG_DCRECEPTOR
		stream_printf(GDKerr, "#load %d events\n",res);
#endif
	}
	TABLETdestroy_format(&as);
	return MAL_SUCCEED;
#ifdef DEBUG_DCRECEPTOR
	stream_printf(GDKerr, "#finished receiving data\n");
#endif
}
@-
The listen thread operation now simply opens the connection
and passed control to the file loading.
@c

str
DClistenThread(SensorInfo sensor)
{
	char *msg=0;
	stream *fdin;
	bstream *bs;

#ifdef DEBUG_DCRECEPTOR
	stream_printf(GDKerr, "#Reading thread started\n");
#endif
	do {
		int retval;
		struct timeval tv;
		fd_set fds;
		int msgsock;
		int sock = sensor->socket;

		FD_ZERO(&fds);
		if (sock >= 0)
			FD_SET(sock, &fds);
#ifdef HAVE_SYS_UN_H
		if (usock >= 0)
			FD_SET(usock, &fds);
#endif
		/* Wait up to 0.5 seconds. */
		tv.tv_sec = 0;
		tv.tv_usec = 500;

		/* temporarily use msgsock to record the larger of sock and usock */
		msgsock = sock;
#ifdef HAVE_SYS_UN_H
		if (usock > sock)
			msgsock = usock;
#endif
		retval = select(msgsock + 1, &fds, NULL, NULL, &tv);
		if (retval == 0) {
			/* nothing interesting has happened */
			continue;
		}
		if (retval < 0) {
			if (MT_geterrno() != EINTR) {
				msg= "select failed\n";
				goto error;
			}
			continue;
		}
		if (sock >= 0 && FD_ISSET(sock, &fds)) {
			if ((msgsock = accept(sock, (SOCKPTR) 0, (SOCKLEN *) 0)) < 0) {
				if (MT_geterrno() != EINTR) {
					msg="accept failed\n";
					goto error;
				}
				continue;
			}
#ifdef HAVE_SYS_UN_H
		} else if (usock >= 0 && FD_ISSET(usock, &fds)) {
			if ((msgsock = accept(usock, (SOCKPTR) 0, (SOCKLEN *) 0)) < 0) {
				if (MT_geterrno() != EINTR) {
					msg="accept failed\n";
					goto error;
				}
				continue;
			}
#endif
		} else
			continue;
#ifdef DEBUG_DCRECEPTOR
		stream_printf(GDKerr,"#receptor connection request:accepted\n");
#endif
		fdin = socket_rstream(msgsock, "DataCell receptor input");

		if (fdin == 0 || stream_errnr(fdin)) {
			GDKsyserror("DClisten:fdin problems\n");
			continue;
		}

		fdin = block_stream(fdin);

#ifdef DEBUG_DCRECEPTOR
		stream_printf(GDKerr, "#DClisten:channel accepted %d\n", msgsock);
#endif
		bs = bstream_create(fdin,4*BLOCK);
		/* now read the stream until it is closed */
		msg= DCstartChannel(channel, bs);
#ifdef DEBUG_DCRECEPTOR
		stream_printf(GDKerr, "#DClisten:channel reading finished\n");
#endif
		
	} while (msg== MAL_SUCCEED);
error:
	return throwMessage("datacell.listen",msg);
}

@}
