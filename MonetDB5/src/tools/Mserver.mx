@f Mserver
@a M.L. Kersten, P. Boncz, Niels Nes
@v 5.0
@* The Monet Server
@T
The {\tt Mserver} is the Monet server. It is started by the database
administrator.  The console is primarilly meant to further initialize
the server, such as starting internet listeners.

@+ Manual Page
@T
The Mserver is a multithreaded program. There is one system thread, and for
each service, e.g. a client session or transaction service,
there is one worker thread.

@- Usage
@T
\begin{verbatim}
Mserver { [ -db <db-name> ] [-monetrc <input> ] } [ <mal-script> ]
\end{verbatim}

Since the console has no command-line history nor file name completion,
you are {\em recommended} to use the 
Mclient program for interactive sessions instead.

The options have the following meaning:
\begin{description}
\item[{\tt -db $<$db-name$>$ }]
	open the database {\em db-name}.
\item[{\tt -monetrc $<$input$>$ }]
	where to find the environment settings
\end{description}

@{
@+ Implementation
@h
#ifndef _MSERVER_H_
#define _MSERVER_H_
#include "monet.h"

#endif /* _MSERVER_H_ */
@C
extern "C" {
#include "Mserver.h"
}

void *operator new( size_t size ) {
        void *ptr = GDKmalloc( size );
        return(ptr);
}
void operator delete( void *ptr ) {
        GDKfree( ptr );
}
#if defined(__GNUC__) && defined(__cplusplus)
void *operator new[]( size_t size ) {
        void *ptr = GDKmalloc( size );
        return(ptr);
}
void operator delete[]( void *ptr ) {
        GDKfree( ptr );
}
#endif


@-
The architecture is setup to handle multiple streams of requests.
The first thread started represents the server. It reads from standard input
and writes to standard input. This is also a way to recognize the server
actions. 
To start the server in the background one should use the argument -deamon.
This closes standard input. Direct execution in the background may cause
the server to hang in stdio for input from the terminal.
@ 
The server thread started remains in existence until all other threads die.
The server is stopped by cntrl-D or receiving the quit command.
@

@-
Braindamaged Sun engineers decided to use malloc for allocating an enormous
buffer of 20 bytes in the sunos2.5.5.X thread library, making the tunable 
malloc library totally unusable, since it requires you to do advice before any 
use of malloc().  We hack around it, by using realloc(0,size) in 
gdk/gdk_utils.mx and wrapping malloc in the below dummy function:
@C
static int malloc_init=1;
#ifdef SOLARIS
#ifndef NOMALLOPT
#undef malloc
void* malloc(size_t size) {
	@:mallopt@
	return realloc(0,size);
}
#endif
#endif
@C
int main(int argc, char** argv) {
	char buf[256];
	int status = 1;
@-
We give malloc advice here. Main goal: prevent fragmentation.
We do this by declaring everything below 2K as 'small'. These
values will be drawn from a fixed pools of 400K.
A grain size of 128 bytes is used to keep overhead low.
@= mallopt
	printf("malloc optimize\n");
	if (malloc_init) {
            if (mallopt(M_MXFAST, 192)) {
		fprintf(stderr, "monet: mallopt(M_MXFAST,8192) fails.\n");
	    }
            if (mallopt(M_NLBLKS, 16)) {
		fprintf(stderr, "monet: mallopt(M_NLBLKS,10) fails.\n");
	    }
	    if (mallopt(M_GRAIN, 32)) {
		fprintf(stderr, "monet: mallopt(M_GRAIN,96) fails.\n");
 	    }
	}
	malloc_init=0;
@C

#ifndef NOMALLOPT
	/* @:mallopt@*/
#endif
	monet_init(argc,argv);
@-
At the end of a multi-threaded session we should wait
for all processes to terminate properly.
@C
@-
Peter: for the time being avoid difficult things like dropping everything 
@C
	MT_global_exit(0);  
	return 0; 
}

@}
