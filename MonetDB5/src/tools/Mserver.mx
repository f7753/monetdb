@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2004 CWI.
@' All Rights Reserved.
@'
@' Contributor(s):
@'              Martin Kersten <Martin.Kersten@cwi.nl>
@'              Peter Boncz <Peter.Boncz@cwi.nl>
@'              Niels Nes <Niels.Nes@cwi.nl>
@'              Stefan Manegold  <Stefan.Manegold@cwi.nl>

@f Mserver
@a M.L. Kersten, P. Boncz, Niels Nes, Stefan Manegold, Sjoerd Mullender
@v 5.0
@* The Monet Server
@T
The {\tt Mserver} is the Monet server. It is started by the database
administrator.  The console is primarilly meant to further initialize
the server, such as starting internet listeners.

@+ Manual Page
@T
The Mserver is a multithreaded program. There is one system thread, and for
each service, e.g. a client session or transaction service,
there is one worker thread.
As a default, the Mserver also starts the internet listener thread,
on the port number specified in the parameter file.

@- Usage
@T
\begin{verbatim}
Mserver { [ --dbname <db-name> ] 
          [ --dbfarm <dbfarm> ]
          [ --dbinit <stmt> ]
	  [ -c|--config <config-file> ]
          [ -d|--gdk_debug [value]
	  [ --set [option=value] set option can be given multiple times
                                    to override verious options
        } [ <mal-script> ]
\end{verbatim}

Since the console has no command-line history nor file name completion,
you are {\em recommended} to use the 
Mclient program for interactive sessions instead.

The options have the following meaning:
\begin{description}
\item[{\tt --dbname $<$db-name$>$ }]
	open the database {\em db-name}.
\item[{\tt --config $<$config-file$>$ }]
	where to find the environment settings
\item[{\tt --dbinit $<$stmt$>$ }]
        execute the statement first.

\end{description}

@{
@+ Implementation
@h
#ifndef _MSERVER_H_
#define _MSERVER_H_
#include "monet_options.h"
#include "gdk.h"
#include "mal.h"
#include "mal_session.h"
#include "mal_import.h"
#include "mal_client.h"
#include "mal_function.h"

/* #define MSERVER_DEBUG */
#endif /* _MSERVER_H_ */
@c
#include "Mserver.h"
#include "mal.h"

#ifdef _CRTDBG_MAP_ALLOC
/* Windows only:
   our definition of new and delete clashes with the one if
   _CRTDBG_MAP_ALLOC is defined.
*/
#undef _CRTDBG_MAP_ALLOC
#endif

@-
The architecture is setup to handle multiple streams of requests.
The first thread started represents the server. It reads from standard input
and writes to standard input. This is also a way to recognize the server
actions. 
To start the server in the background one should use the argument -background.
This closes standard input. Direct execution in the background may cause
the server to hang in stdio for input from the terminal.
@ 
The server thread started remains in existence until all other threads die.
The server is stopped by cntrl-D or receiving the quit command.
@

@c
static int malloc_init=1;
@c
extern int optind;
#ifdef NATIVE_WIN32
#include <eh.h>
void Mserver_abort() {
        fprintf(stderr,"\n! Mserver_abort() was called by terminate(). !\n");
        fflush(stderr);
        MT_global_exit(1);
}
#endif
void usage( char *prog ){
        fprintf(stderr, "usage: %s\n", prog);
        fprintf(stderr, "[--dbname database_name ]\n" );
        fprintf(stderr, "[--dbfarm database_directory ]\n" );
        fprintf(stderr, "[--dbinit stmt]\n" );
        fprintf(stderr, "[-d or --debug [debug_level] ]\n" );
        fprintf(stderr, "[-? or --help ]\n" );
        fprintf(stderr, "[-c or --config config_file ]\n" );
        fprintf(stderr, "[-s or --set option=value ]\n" );
        fprintf(stderr, "script+\n" );
        exit(-1);
}

@-
A welcoming message is displayed to inform the user about recent
changes. 
@c
void monet_hello(opt *set, int setlen) {
#ifdef STATIC
    char *linkinfo = "statically";
#else
    char *linkinfo = "dynamically";
#endif
    char *msg = mo_find_option(set, setlen, "monet_welcome");
    if ( msg && strcmp(msg,"yes")==0){
        printf("# Monet Database Server V%s\n", GDKgetenv("gdk_version"));
        printf("# Copyright (c) 1993-2004, CWI. ");
        printf("All rights reserved.\n");
        printf("# Compiled for %s/%dbit; %s linked.\n", 
		GDKgetenv("gdk_arch"), sizeof(ptr)*8, linkinfo );
	printf("# config:%s\n", GDKgetenv("config"));
	printf("# dbfarm:%s\n", GDKgetenv("gdk_dbfarm"));
	printf("# dbname:%s\n", GDKgetenv("gdk_dbname"));
	printf("# Visit http://monetdb.cwi.nl for further information.\n");

    }
}

str absolute_path(str s) {
        if (!MT_path_absolute(s)) {
                str ret = (str)GDKmalloc(strlen(s) + strlen(monet_cwd) + 2);
                sprintf(ret, "%s%c%s", monet_cwd, DIR_SEP, s);
                return ret;
        }
        return GDKstrdup(s);
}

@-
The options obtained during initialization should be maintained as
a global structure for other components to extract information.
@c
void monet_init( opt *set, int setlen)
{
	char *p;
	opt *n = (opt*)malloc(setlen*sizeof(opt));
	int i,j, nlen = 0;

	char buf[BUFSIZ];
	char *dbname = mo_find_option(set, setlen, "gdk_dbname");
	char *dbfarmval = mo_find_option(set, setlen, "gdk_dbfarm");
	char *modpath= mo_find_option(set, setlen, "monet_mod_path");
	char *prefix= mo_find_option(set, setlen, "prefix");
	char *alloc_map = mo_find_option(set, setlen, "gdk_alloc_map");
	char *pf = prefix;

	if( modpath){ strcpy(buf,modpath);
		mo_substitute(set, setlen, buf);
		modpath= strdup(buf);
	}
	if( prefix){ strcpy(buf,prefix);
		mo_substitute(set, setlen, buf);
		pf= strdup(buf);
	}

	if (!n || !dbname || !dbfarmval){
		fprintf(stderr,"Error, no database name or directory\n");
		if (n) free(n);
		return ;
	}

	strcpy(buf, dbfarmval );	
	mo_substitute(set, setlen, buf);

        /* determine Monet's kernel settings. */
	/* IGNORE now if (!GDKinit(dbname, buf,strcasecmp(alloc_map,"yes")==0)) return ;*/
	(void) alloc_map;
	if (!GDKinit(dbname, buf,0)) return ;

@-
Find duplicate entries in the property list and move
them to the front. Actually, this should be done in
monet_options.mx.in
@c
	for(i=0; i<setlen; i++){
		int done = 0;
		for(j=0; j<nlen; j++){
			if (strcmp(n[j].name, set[i].name) == 0){ 
			    	if (n[j].kind < set[i].kind){
					n[j] = set[i];
				}
				done = 1;
				break;
			}
		}
		if (!done){
			n[nlen] = set[i];
			nlen++;
		}
	}
	for(i=0; i<nlen; i++){
		strncpy(buf, n[i].value, BUFSIZ);
		mo_substitute(n, nlen, buf);
		GDKsetenv(n[i].name, buf);
	}
	free(n);

	if ((p=GDKgetenv("gdk_debug")) )
		GDKdebug = strtol(p,NULL,10);
        if ((p=GDKgetenv("gdk_mem_bigsize")) )
                GDK_mem_bigsize = strtol(p,NULL,10);
        if ((p=GDKgetenv("gdk_vm_minsize")) )
                GDK_vm_minsize = strtol(p,NULL,10);

	/* you don;t need the commandline arguments anymore */
	/* mo_free_options(set,setlen); GDK library can not deal with this*/
	/* keep them around until goodbye */
	monet_hello(set,setlen);

	if( mal_init()) return;
	if( pf!=prefix) free(pf);

}

int main(int argc, char** av) {
	char buf[BUFSIZ], *prog = *av;
        opt *set = NULL;
        int i,debug = 0, setlen = 0, listing=0;
	str dbinit= NULL;


@-
We give malloc advice here. Main goal: prevent fragmentation.
We do this by declaring everything below 2K as 'small'. These
values will be drawn from a fixed pools of 400K.
A grain size of 128 bytes is used to keep overhead low.

We do this by declaring everything below 2K as 'small'. These
values will be drawn from a fixed pools of 400K.
A grain size of 128 bytes is used to keep overhead low.
Trivial remark: for dynamically linked executables the mallopt
capabilities depend on the malloc implementation used at run time.

Unlike V4 we ignore the alloc_map advice, which leads to a much
faster system start.
@= mallopt
	if (malloc_init) {
/* for (Red Hat) Linux (6.2) unused and ignored at least as of glibc-2.1.3-15 */
/* for (Red Hat) Linux (8) used at least as of glibc-2.2.93-5 */
            if (mallopt(M_MXFAST, 192)) {
                fprintf(stderr, "monet: mallopt(M_MXFAST,192) fails.\n");
            }
#ifdef M_BLKSZ
            if (mallopt(M_BLKSZ, 8*1024)) {
                fprintf(stderr, "monet: mallopt(M_BLKSZ,8*1024) fails.\n");
            }
#endif
        }
	malloc_init=0;
@c

	static struct option long_options[9] =
             {
               {"config", 1, 0, 'c'},
               {"dbname", 1, 0, 0},
               {"dbfarm", 1, 0, 0},
               {"dbinit", 1, 0, 0},
               {"debug", 2, 0, 'd'},
               {"help", 0, 0, '?'},
               {"set", 1, 0, 's'},
               {"trace", 0, 0, 't'},
               {0, 0, 0, 0}
             };

#ifdef NATIVE_WIN32
        set_terminate( Mserver_abort );
#endif
/* to be activated at some point
        if (setlocale(LC_CTYPE, "") == NULL){
                GDKfatal( "cannot set locale\n");
        }
*/

#ifdef HAVE_MALLOPT
        @:mallopt@
#else
        (void) malloc_init; /* still unused */
#endif

        if (getcwd(monet_cwd, PATHLENGTH-1)  == NULL ){
                perror("pwd");
                GDKfatal("monet_init: could not determine current directory\n");
        }

	if (!(setlen = mo_builtin_settings(&set)) )
		usage(prog);

	while(1){
		int option_index = 0;

		int c = getopt_long( argc, av, "c:d:t::?s:", 
				long_options, &option_index);

		if (c == -1)
			break;

		switch (c){
		case 0:
			if (strcmp(long_options[option_index].name, 
						"dbname") == 0){
				setlen = mo_add_option( &set, setlen, 
					opt_cmdline, "gdk_dbname", optarg );
				break;
			}
			if (strcmp(long_options[option_index].name, 
						"dbfarm") == 0){
				setlen = mo_add_option( &set, setlen, 
					opt_cmdline, "gdk_dbfarm", optarg );
				break;
			}
			if (strcmp(long_options[option_index].name, 
						"dbinit") == 0){
				dbinit = optarg;
				break;
			}
			usage(prog);
			break;
		case 'c':
			if( *optarg!='/' && *optarg !='.') {
				snprintf(buf,BUFSIZ,"%s/%s",monet_cwd,optarg);
				setlen = mo_add_option( &set, setlen, 
					opt_cmdline, "config", buf );
			} else {
				setlen = mo_add_option( &set, setlen, 
					opt_cmdline, "config", optarg );
			}
			break;
		case 'd':
			debug=1;
			if (optarg){ 
				setlen = mo_add_option( &set, setlen, 
					opt_cmdline, "gdk_debug", optarg );
			}
			break;
		case 's': {
			/* should add option to a list */
			char *tmp = strchr(optarg, '=');

			if (tmp){
				*tmp = '\0';
				setlen = mo_add_option( &set, setlen, 
					opt_cmdline, optarg, tmp+1 );
			} else {
				fprintf(stderr, "ERROR: wrong format %s\n", 
					optarg);
			}
		 } break;
		case 't': /* trace option, currently ignored */
			break;
		case '?':
			usage(prog);
		default:
			fprintf( stderr, 
			    "ERROR: getopt returned character code 0%o ??\n",c);
			usage(prog);
		}
	}

	if (!(setlen = mo_system_config(&set, setlen)))
		usage(prog);

	i = 0;
	monet_script = (str*)GDKmalloc( sizeof(str) * (argc+1) );
	monet_script[i] = NULL;
	if( dbinit) {
		monet_script[i] = absolute_path(dbinit);
		monet_script[i+1] = NULL;
		i++;
	}
	while(optind < argc){
		monet_script[i] = absolute_path(av[optind]);
		monet_script[i+1] = NULL;
		optind++;
		i++;
	}

	if (debug)
		mo_print_options(set, setlen);
#ifdef MSERVER_DEBUG
	else	mo_print_options(set,setlen);
#endif
	monet_init(set, setlen);

@-
Time to execute the script files. Start with the init command[todo]
@c
	if( GDKgetenv("mal_listing"))
		sscanf( GDKgetenv("mal_listing"),"%d",&listing);
        for(i=0; monet_script[i]; i++) {
                malImport(mal_clients, monet_script[i], 0, listing);
		GDKfree(monet_script[i]);
		monet_script[i]=0;
        }
	GDKfree(monet_script);
        initClientPrg(mal_clients,"main");
        serveClient(mal_clients);

	assert(0);	/* should not come here */
	MT_global_exit(0);  
	return 0; 
}
@}
