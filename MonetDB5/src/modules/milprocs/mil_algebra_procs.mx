
@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@' 
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@' 
@' The Original Code is the Monet Database System.
@' 
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2004 CWI.
@' All Rights Reserved.
@' 

@f mil_algebra_procs
@a Martin Kersten
@* MIL algebra extensions
MonetDB 5 supports running MIL programs compiled by M2m.
The resulting code needs PROC definitions of version 4, which
are assembled in this package.

We removed the ADDHELP functionality, because
M5 does not use the same catalog infrastructure 
Several procs were removed, because they seemed
to be unnecessary or complicates the handling in M5 
(polymorphic anonymous types)


The mal code was produced using
	M2m --trace=0 mil_algebra_procs.mil
[The trace flag removes the comment lines]

This files contains a patch of the sort_ht operation
to allow for proper cloning
@mal
module mil_algebra_procs;

function clear(b:bat[:any$1,:any$2]):bat[:any$1,:any$2];
	return aa_a :=delete(b);
end clear;
function unique(b:bat[:any$1,:any$2]):bat[:any$1,:any$2];
	return ba_a :=sunique(b);
end unique;
function diff(b1:bat[:any$1,:any$2], b2:bat[:any$1,:any$2]):bat[:any$1,:any$2];
	return ca_a :=sdiff(b1,b2);
end diff;
function intersect(b1:bat[:any$1,:any$2], b2:bat[:any$1,:any$2]):bat[:any$1,:any$2];
	return da_a :=sintersect(b1,b2);
end intersect;
function union(b1:bat[:any$1,:any$2], b2:bat[:any$1,:any$2]):bat[:any$1,:any$2];
	return ea_a :=sunion(b1,b2);
end union;
function project(b:bat[:any$1,:any]):bat[:any$1,:void];
	return fa_a :=project(b,nil);
end project;
function outerjoin(left:bat[:any$1,:any$2], right:bat[:any$2,:any$3]):bat[:any$1,:any$3];
	ga_a := lng(nil);
	return ha_a :=outerjoin(left,right,ga_a);
end outerjoin;
function find_unescaped_occurrence(b:str, c:chr):int;
	idx := search(b,c);
barrier	ia_a := true;
barrier	ja_a := >(idx,0);
	tmp := idx;
barrier	ka_a := true;
	ma_a := -(tmp,1);
barrier	la_a := >=(ma_a,0);
	na_a := string(b,tmp,1);
barrier	oa_a := !=("\\",na_a);
	pa_a := +(tmp,1);
leave	ka_a;
exit	oa_a;
redo	ka_a;
exit	la_a;
exit	ka_a;
	qa_a := -(idx,tmp);
	ra_a := %(qa_a,2);
barrier	sa_a := ==(ra_a,1);
	ta_a := length(b);
	ua_a := -(ta_a,idx);
	va_a := string(b,idx,ua_a);
	tmp := search(va_a,c);
barrier	wa_a := >=(tmp,0);
	idx := +(tmp,idx);
exit	wa_a;
barrier	xa_a := not(wa_a);
	idx := tmp;
leave	ia_a;
exit	xa_a;
exit	sa_a;
barrier	ya_a := not(sa_a);
leave	ia_a;
exit	ya_a;
redo	ia_a;
exit	ja_a;
exit	ia_a;
	return ab_a :=idx;
end find_unescaped_occurrence;
function likeselect(b:bat[:any$1,:str], pat:str):bat[:any$1,:oid];
	idxper := find_unescaped_occurrence(pat,'%');
	idxund := find_unescaped_occurrence(pat,'_');
	bb_a := ==(idxper,-1);
	cb_a := ==(idxund,-1);
barrier	db_a := and(bb_a,cb_a);
	return eb_a :=uselect(b,pat);
exit	db_a;
barrier	fb_a := not(db_a);
barrier	gb_a := ==(idxper,-1);
	idx := idxund;
	isper := false;
exit	gb_a;
barrier	hb_a := not(gb_a);
barrier	ib_a := ==(idxund,-1);
	idx := idxper;
	isper := true;
exit	ib_a;
barrier	jb_a := not(ib_a);
barrier	kb_a := <(idxper,idxund);
	idx := idxper;
	isper := true;
exit	kb_a;
barrier	lb_a := not(kb_a);
	idx := idxund;
	isper := false;
exit	lb_a;
exit	jb_a;
exit	hb_a;
exit	fb_a;
barrier	mb_a := >(idx,0);
	nb_a := string(pat,0,idx);
	ob_a := multiplex.tactics("search",b,nb_a);
	s := select(ob_a,0);
barrier	pb_a := isper;
	qb_a := semijoin(b,s);
	rb_a := multiplex.tactics("length",qb_a);
	sb_a := multiplex.tactics("-",rb_a,s);
	b := multiplex.tactics("string",b,s,sb_a);
exit	pb_a;
barrier	tb_a := not(pb_a);
	ub_a := semijoin(b,s);
	vb_a := multiplex.tactics("length",ub_a);
	wb_a := multiplex.tactics("-",vb_a,s);
	xb_a := multiplex.tactics("+",wb_a,1);
	b := multiplex.tactics("string",b,s,xb_a);
exit	tb_a;
	didMatch := true;
exit	mb_a;
barrier	yb_a := not(mb_a);
	didMatch := false;
exit	yb_a;
barrier	ac_a := true;
	cc_a := +(idx,1);
	dc_a := length(pat);
barrier	bc_a := <(cc_a,dc_a);
	ec_a := length(pat);
	fc_a := -(ec_a,idx);
	pat := string(pat,idx,fc_a);
barrier	gc_a := and(didMatch,isper);
	idxper := find_unescaped_occurrence(pat,'%');
barrier	hc_a := >(idxund,0);
	ic_a := -(idxund,idx);
exit	hc_a;
exit	gc_a;
barrier	jc_a := not(gc_a);
barrier	kc_a := didMatch;
	idxund := find_unescaped_occurrence(pat,'_');
barrier	lc_a := >(idxper,0);
	mc_a := -(idxper,idx);
exit	lc_a;
exit	kc_a;
barrier	nc_a := not(kc_a);
	didMatch := true;
exit	nc_a;
exit	jc_a;
	oc_a := ==(idxper,-1);
	pc_a := ==(idxund,-1);
barrier	qc_a := and(oc_a,pc_a);
	idx := -1;
exit	qc_a;
barrier	rc_a := not(qc_a);
barrier	sc_a := ==(idxper,-1);
	idx := idxund;
	isper := false;
exit	sc_a;
barrier	tc_a := not(sc_a);
barrier	uc_a := ==(idxund,-1);
	idx := idxper;
	isper := true;
exit	uc_a;
barrier	vc_a := not(uc_a);
barrier	wc_a := <(idxper,idxund);
	idx := idxper;
	isper := true;
exit	wc_a;
barrier	xc_a := not(wc_a);
	idx := idxund;
	isper := false;
exit	xc_a;
exit	vc_a;
exit	tc_a;
exit	rc_a;
barrier	yc_a := <(idx,0);
	ad_a := length(pat);
barrier	bd_a := >(ad_a,0);
	cd_a := multiplex.tactics("endsWith",b,pat);
	b := multiplex.tactics("ifthen",cd_a,b);
exit	bd_a;
leave	ac_a;
exit	yc_a;
	dd_a := string(pat,0,idx);
	ed_a := int(nil);
	fd_a := multiplex.tactics("search",b,dd_a);
	s := select(fd_a,0,ed_a);
barrier	gd_a := isper;
	hd_a := semijoin(b,s);
	id_a := multiplex.tactics("length",hd_a);
	jd_a := multiplex.tactics("-",id_a,s);
	b := multiplex.tactics("string",b,s,jd_a);
exit	gd_a;
barrier	kd_a := not(gd_a);
	ld_a := semijoin(b,s);
	md_a := multiplex.tactics("length",ld_a);
	nd_a := multiplex.tactics("-",md_a,s);
	od_a := multiplex.tactics("+",nd_a,1);
	b := multiplex.tactics("string",b,s,od_a);
exit	kd_a;
redo	ac_a;
exit	bc_a;
exit	ac_a;
	return pd_a :=mark(b,nil);
end likeselect;
function tunique(b:bat[:any,:any$1]):bat[:any$1,:void];
	qd_a := reverse(b);
	rd_a := mark(qd_a,nil);
	return sd_a :=kunique(rd_a);
end tunique;
function sort_ht(B:bat[:any$1,:any$2]):bat[:any$1,:any$2];
	td_a := count(B);
	R := new(B,td_a);
	ud_a := kunique(B);
	vd_a := sort(ud_a);
barrier	wd_a := bunStream(vd_a,wd_aH,wd_aT);
	xd_a := reverse(B);
	yd_a := select(xd_a,wd_aH);
	ae_a := sort(yd_a);
barrier	be_a := bunStream(ae_a,be_aH,be_aT);
	ce_a := insert(R,be_aT,be_aH);
redo	be_a := bunStream(ae_a,be_aH,be_aT);
exit	be_a;
redo	wd_a := bunStream(vd_a,wd_aH,wd_aT);
exit	wd_a;
	return de_a :=R;
end sort_ht;
function sum(b:bat[:any,:sht]):sht;
	return ee_a :=sum_sht(b);
end sum;
function prod(b:bat[:any,:sht]):sht;
	return fe_a :=prod_sht(b);
end prod;
function sum(b:bat[:any,:int]):int;
	return ge_a :=sum_int(b);
end sum;
function prod(b:bat[:any,:int]):int;
	return he_a :=prod_int(b);
end prod;
function sum(b:bat[:any,:lng]):lng;
	return ie_a :=sum_lng(b);
end sum;
function prod(b:bat[:any,:lng]):lng;
	return je_a :=prod_lng(b);
end prod;
function sum(b:bat[:any,:flt]):flt;
	return ke_a :=sum_flt(b);
end sum;
function prod(b:bat[:any,:flt]):flt;
	return le_a :=prod_flt(b);
end prod;
function sum(b:bat[:any,:dbl]):dbl;
	return me_a :=sum_dbl(b);
end sum;
function prod(b:bat[:any,:dbl]):dbl;
	return ne_a :=prod_dbl(b);
end prod;
function avg(b:bat[:any,:sht]):dbl;
	cnt := count(b);
barrier	oe_a := ==(cnt,0);
	return pe_a :=dbl(nil);
exit	oe_a;
	qe_a := sum_lng(b);
	re_a := dbl(qe_a);
	se_a := dbl(cnt);
	return te_a :=/(re_a,se_a);
end avg;
function avg(b:bat[:any,:int]):dbl;
	cnt := count(b);
barrier	ue_a := ==(cnt,0);
	return ve_a :=dbl(nil);
exit	ue_a;
	we_a := sum_lng(b);
	xe_a := dbl(we_a);
	ye_a := dbl(cnt);
	return af_a :=/(xe_a,ye_a);
end avg;
function avg(b:bat[:any,:lng]):dbl;
	cnt := count(b);
barrier	bf_a := ==(cnt,0);
	return cf_a :=dbl(nil);
exit	bf_a;
	df_a := sum(b);
	ef_a := dbl(df_a);
	ff_a := dbl(cnt);
	return gf_a :=/(ef_a,ff_a);
end avg;
function avg(b:bat[:any,:flt]):dbl;
	cnt := count(b);
barrier	hf_a := ==(cnt,0);
	return if_a :=dbl(nil);
exit	hf_a;
	jf_a := sum(b);
	kf_a := dbl(jf_a);
	lf_a := dbl(cnt);
	return mf_a :=/(kf_a,lf_a);
end avg;
function avg(b:bat[:any,:dbl]):dbl;
	cnt := count(b);
barrier	nf_a := ==(cnt,0);
	return of_a :=dbl(nil);
exit	nf_a;
	pf_a := sum(b);
	qf_a := dbl(pf_a);
	rf_a := dbl(cnt);
	return sf_a :=/(qf_a,rf_a);
end avg;
function count_no_nil(b:bat[:any,:any]):int;
	return tf_a :=count(b,true);
end count_no_nil;
@- Original code
@mil

#    PROC ADDHELP(str cmd, str aut, str dat, str hlp, str modname) : void {
#        var fid := monet_fcn_nme.select(cmd).kdiff(monet_fcn_aut).reverse().min();
#        monet_fcn_dsc.insert(fid, hlp);
#        monet_fcn_aut.insert(fid, aut);
#        monet_fcn_dat.insert(fid, dat);
#	monet_fcn_mid.insert(fid, monet_mod_nme.reverse().find(modname));
#    }
#
#    ADDHELP("ADDHELP", "boncz", "Feb  6 1996",
#    "provide helpful info on a command (author, date, help-text).", "algebra");

    PROC clear(bat[any::1,any::2] b) : bat[any::1,any::2] {
		return b.delete();
	}
#    ADDHELP("clear", "boncz", "Mar  6 1996",
#        "Backward compatibility. Does a b.delete()", "algebra");



#    PROC semijoin(bat[any::1,any::2] l, bat[any::1,any] r) : bat[any::1,any::2] {
# 		return kintersect(l,r);
#	}
#    ADDHELP("semijoin", "boncz", "Nov  1 1998",
#	    "semijoin is a synonym of kintersect.", "algebra");

    PROC unique(bat[any::1,any::2] b) : bat[any::1,any::2] {
		return sunique(b);
	}
#    ADDHELP("unique", "boncz", "Apr  6 1997",
#            "backward compatibility: use sunique() explicitly.", "algebra");

    PROC diff(bat[any::1,any::2] b1, bat[any::1,any::2] b2)  : bat[any::1,any::2] {
		return sdiff(b1,b2);
   }
#    ADDHELP("diff", "boncz", "Apr  6 1997",
#            "backward compatibility: use sdiff() explicitly.", "algebra");

    PROC intersect(bat[any::1,any::2] b1, bat[any::1,any::2] b2) : bat[any::1,any::2] {
		return sintersect(b1,b2); 
   }
#    ADDHELP("intersect", "boncz", "Apr  6 1997",
#             "backward compatibility: use sintersect() explicitly.", "algebra");

    PROC union(bat[any::1,any::2] b1, bat[any::1,any::2] b2) : bat[any::1,any::2]  {
		return sunion(b1,b2);
   }
#    ADDHELP("union", "boncz", "Feb  6 1996",
#            "backward compatibility: use sunion() explicitly.", "algebra");

    PROC project(bat[any::1,any] b) : bat[any::1,void] {
		return b.project(nil);
    }

#    PROC join (BAT[any::1,any::2] left, BAT[any::2,any::3] right) : BAT[any::1,any::3] {
#		return join(left, right, lng(nil));
#    }

    PROC outerjoin (BAT[any::1,any::2] left, BAT[any::2,any::3] right) : BAT[any::1,any::3] {
		return outerjoin(left, right, lng(nil));
    }

#! DROPPED due to variable argument handling
#!    PROC join(bat[any::1,any::2] l, bat[any::2,any::3] r, str fcn, ..any..) : bat[any::1,any::3] {
#!  		return join(l, r, lng(nil), fcn, $(4..));
#!    }
   
#!DROPPED, seems unnecessary
#!    PROC new( BAT a, BAT b, int sz ) : BAT {
#!        var ht := a.htype();
#!        var tt := b.ttype();
#!        if ((ht = tt) and (ht = void)) {
#!                if (not(isnil(b.reverse().seqbase()))) {
#!                        tt := oid;
#!                } else if (not(isnil(a.seqbase()))) {
#!                        ht := oid;
#!                }
#!        }
#!	var r := new(ht, tt, sz);
#!	if (tt = void) {
#!		if (not(isnil(b.reverse().seqbase()))) {
#!			r.reverse().seqbase( b.reverse().seqbase() );
#!		}
#!	}
#!	if (ht = void) {
#!		if (not(isnil(a.seqbase()))) {
#!			r.seqbase( a.seqbase() );
#!		}
#!	}
#!	return r;
#!    }


#! DROPPED, (theta)joins should be implemented as overloaded
#! comparison operators
#!    PROC join(bat[any::1,any::2] l, bat[any::2,any::3] r, lng estimate, str fcn, ..any..) : bat[any::1,any::3] 
#!    {
#!        if ($0 = 3) {
#!            if (fcn = "=") {
#!                return join(l,r,estimate);
#!            } else if (fcn = "<=") {
#!                return thetajoin(l,r,LE,estimate);
#!            } else if (fcn = "<") {
#!                return thetajoin(l,r,LT,estimate);
#!            } else if (fcn = ">=") {
#!                return thetajoin(l,r,GE,estimate);
#!            } else if (fcn = ">") {
#!                return thetajoin(l,r,GT,estimate);
#!            } else if (fcn = "true") {
#!                return cross(l,r);
#!            }
#!        }
#!        var swapped := false;
#!        if (l.count() < r.count()) {
#!            var swap := l;
#!            l := r.reverse(); r := swap.reverse();
#!            swapped := true;
#!        }
#!	if (isnil(estimate)) estimate := l.count();
#!        var bn := new(l, r, estimate);
#!        l@batloop() {
#!            var h := $h;
#!            var t := $t;
#!            if (swapped) {
#!                r@batloop() if ((*fcn)($h,t,$(5..))) bn.insert(h,$t);
#!            } else {
#!                r@batloop() if ((*fcn)(t,$h,$(5..))) bn.insert(h,$t);
#!            }
#!        }
#!        if (swapped) {
#!            return bn.reverse();
#!        } else {
#!            return bn;
#!        }
#!    }
#    ADDHELP("join", "boncz", "Aug  6 1998",
#            "Returns [left.head,right.tail] where (*fcn)(left.tail,right.head,..params..)", "algebra");

	proc find_unescaped_occurrence(str b, chr c) : int {
		var idx := b.search(c);
		var tmp;
		
		while (idx > 0) {
			# check if this char was escaped
			tmp := idx;
			while ((tmp :-=1) >= 0) {
				if ("\\" != b.string(tmp, 1)) {
					tmp :+= 1;
					break;
				}
			}
			if (((idx - tmp) % 2) = 1) {
				# this was an escaped char, go looking for the next one
				tmp := b.string(idx, b.length() - idx).search(c);
				# if not found, keep it like that, otherwise correct the
				# index with an offset
				if (tmp >= 0) {
					idx := tmp + idx;
				} else {
					idx := tmp;
					# we will not find anything more, break out
					break;
				}
			} else {
				# we found a valid one, break out of the loop!
				break;
			}
		}
		return(idx);
    }
#   ADDHELP("find_unescaped_occurrence", "groffen", "Sep 26 2004",
#   "finds the first occurrence of c that is not escaped by a \\", "algebra");

    # SQL LIKE functionality, vectorized MIL implementation
    PROC likeselect(bat[any::1,str] b, str pat) : bat[any::1,oid]  {
        var s;
		var idxper;
		var idxund;
		var isper;
		var idx;
		var didMatch;
		
		idxper := find_unescaped_occurrence(pat, '%');
		idxund := find_unescaped_occurrence(pat, '_');

        if ((idxper = -1) and (idxund = -1)) {
			# no % or _ found at all, return simple selection on the given
			# string with no hassle of fancy wildcard characters
            return b.uselect(pat);
		} else if (idxper = -1) {
			idx := idxund;
			isper := false;
		} else if (idxund = -1) {
			idx := idxper;
			isper := true;
		} else {
			# idxper can never be equal to idxund at this point
			if (idxper < idxund) {
				idx := idxper;
				isper := true;
			} else {
				idx := idxund;
				isper := false;
			}
		}

		if (idx > 0) {
			s := b.[search](pat.string(0, idx)).select(0);
			if (isper) {
				b := b.[string](s, [-](b.semijoin(s).[length](), s));
			} else {
				b := b.[string](s, [+]([-](b.semijoin(s).[length](), s), 1));
			}
			didMatch := true;
		} else {
			didMatch := false;
		}

		while ((idx :+= 1) < pat.length()) {
			# remove from the search pattern what we have matched so far
            pat := pat.string(idx, pat.length()-idx);

			# find next match for the last matching char (% or _)
			if (didMatch and isper) {
				idxper := find_unescaped_occurrence(pat, '%');
				# correct value of other index
				if (idxund > 0) idxund :-= idx;
			} else if (didMatch) {
				idxund := find_unescaped_occurrence(pat, '_');
				# correct value of other index
				if (idxper > 0) idxper :-= idx;
			} else {
				didMatch := true;
			}
				
			if ((idxper = -1) and (idxund = -1)) {
				idx := -1;
			} else if (idxper = -1) {
				idx := idxund;
				isper := false;
			} else if (idxund = -1) {
				idx := idxper;
				isper := true;
			} else {
				# idxper can never be equal to idxund at this point
				if (idxper < idxund) {
					idx := idxper;
					isper := true;
				} else {
					idx := idxund;
					isper := false;
				}
			}
		
			# is idx is smaller than 0 at this point, then both idxper and
			# idxund are -1
			if (idx < 0) {
				if (pat.length() > 0) {
					b := [endsWith](b,pat).[ifthen](b);
				}
				break;
			}
			
			s := b.[search](pat.string(0, idx)).select(0, int(nil));
			if (isper) {
				b := b.[string](s, [-](b.semijoin(s).[length](), s));
			} else {
				b := b.[string](s, [+]([-](b.semijoin(s).[length](), s), 1));
			}
		}

        return b.mark(nil);
    }
#   ADDHELP("likeselect", "groffen", "Sep 26 2004",
#   "does SQL LIKE select which supports % and _ (also understands escapes)", "algebra");
    

#! DROPPED, arbitrary select operator
#!    PROC mil_select(bat[any::1,any::2] b, str fcn, ..any..) : bat[any::1,any::2] 
#!    {
#!        if ($0 = 3) {
#!            var val := $3;
#!            if (val.type() = b.ttype()) {    
#!                var nilval := nil.cast(val.type()); 
#!                if (fcn = "=") {
#!                    return b.select(val);
#!                } else if (fcn = "<=") {
#!                    return b.select(nilval, val);
#!                } else if (fcn = "<") {
#!                    return b.select(nilval, val, FALSE, FALSE);
#!                } else if (fcn = ">=") {
#!                    return b.select(val, nilval);
#!                } else if (fcn = ">") {
#!                    return b.select(val, nilval, FALSE, FALSE);
#!                } else if (fcn = "like") {
#!                    var bn := likeselect(b, val);
#!                    return b.semijoin(bn);
#!                }
#!            }
#!        }
#!        var bitvector := [*fcn](b,$(3..));
#!        return [ifthen](bitvector,b);
#!    }
#!
#!    PROC mil_select(bat[any::1,any::2] b, str fcn, any::2 lo, any::2 hi) : bat[any::1,any::2] 
#!    {
#!        if (or((fcn = "between"),(fcn = "[in]"))) {
#!            return b.select(lo,hi);
#!        } else if (fcn = "<in]") {
#!            return b.select(lo,hi,FALSE,TRUE);
#!        } else if (fcn = "[in>") {
#!            return b.select(lo,hi,TRUE,FALSE);
#!        } else if (fcn = "<in>") {
#!            return b.select(lo,hi,FALSE,FALSE);
#!        }
#!        var bitvector := [*fcn](b,lo,hi);
#!        return [ifthen](bitvector,b);
#!    }
#!#    ADDHELP("mil_select", "boncz", "Aug  6 1998",
#!#            "Returns all BUNs where (*fcn)(tail,,..params..).", "algebra");
#!
#!    PROC neg_select(bat[any::1,any::2] b, str fcn, ..any..) : bat[any::1,any::2] 
#!    {
#!        if ($0 = 3) {
#!            var val := $3;
#!            if (val.type() = b.ttype()) {    
#!                if (fcn = "!=") {
#!                    return b.mil_select("=", val);
#!                } else if (fcn = ">=") {
#!                    return b.mil_select("<", val);
#!                } else if (fcn = "<=") {
#!                    return b.mil_select(">", val);
#!                } else if (fcn = ">") {
#!                    return b.mil_select("<=", val);
#!                } else if (fcn = "<") {
#!                    return b.mil_select(">=", val);
#!                } else if (fcn = "like") {
#!                    var bn := likeselect(b, val);
#!                    return b.kdiff(bn);
#!                }
#!            }
#!        }
#!        var bitvector := [*fcn](b,$(3..));
#!        return [ifelse](bitvector,b);
#!    }
#!#    ADDHELP("neg_select", "boncz", "Aug  6 1998",
#!#            "Returns all BUNs where not (*fcn)(tail,,..params..)", "algebra");
#!
#!    PROC rev_select(bat[any::1,any::2] b, str fcn, any::2 val) : bat[any::1,any::2] 
#!    {
#!        if (fcn = "=") {
#!            return b.mil_select("=",val);
#!        } else if (fcn = "!=") {
#!            return b.mil_select("!=",val);
#!        } else if (fcn = ">") {
#!            return b.mil_select("<",val);
#!        } else if (fcn = "<") {
#!            return b.mil_select(">",val);
#!        } else if (fcn = "<=") {
#!            return b.mil_select(">=",val);
#!        } else if (fcn = ">=") {
#!            return b.mil_select("<=",val);
#!        }
#!        ERROR("rev_select: unknown predicate %s(%s)\n", fcn, str(val));
#!    }
#    ADDHELP("rev_select", "boncz", "Aug  6 1998",
#            "(value OP column) select rather than (column OP value)","algebra");

    PROC tunique (bat[any,any::1] b) : bat[any::1,void] {
	return b.reverse().mark(nil).kunique();
   }

    PROC sort_ht (bat[any::1,any::2] B) : bat[any::1,any::2] 
    {
#       var R := new(htype(B),ttype(B),count(B));
        var R := new(B,count(B));

        B.kunique().sort()@batloop {
            B.reverse().select($h).sort()@batloop {
                R.insert($t,$h);
            }
        }
        return R;
    }
#    ADDHELP("sort_ht", "manegold", "Dec 17 1998",
#            "sorts a BAT according to its head (primary) and tail values (secondary).\
#             (straight forward hack, not tuned for performance at all, just used for testing.)", "algebra");




    proc sum( bat[any,sht] b ) : sht { return sum_sht(b); }
    proc prod( bat[any,sht] b ) : sht { return prod_sht(b); }




    proc sum( bat[any,int] b ) : int { return sum_int(b); }
    proc prod( bat[any,int] b ) : int { return prod_int(b); }




    proc sum( bat[any,lng] b ) : lng { return sum_lng(b); }
    proc prod( bat[any,lng] b ) : lng { return prod_lng(b); }




    proc sum( bat[any,flt] b ) : flt { return sum_flt(b); }
    proc prod( bat[any,flt] b ) : flt { return prod_flt(b); }




    proc sum( bat[any,dbl] b ) : dbl { return sum_dbl(b); }
    proc prod( bat[any,dbl] b ) : dbl { return prod_dbl(b); }







    proc avg(BAT[any, sht] b) : dbl {
	var cnt := count(b);
        if (cnt = 0) 
	    return dbl(nil);
	return dbl(sum_lng(b))/dbl(cnt);
    }
#    ADDHELP("avg", "manegold", "May 14 2003",
#            "Gives the average of all tail values.", "algebra");




    proc avg(BAT[any, int] b) : dbl {
	var cnt := count(b);
        if (cnt = 0) 
	    return dbl(nil);
	return dbl(sum_lng(b))/dbl(cnt);
    }
#    ADDHELP("avg", "manegold", "May 14 2003",
#            "Gives the average of all tail values.", "algebra");







    proc avg(BAT[any, lng] b) : dbl {
	var cnt := count(b);
        if (cnt = 0) 
	    return dbl(nil);
	return dbl(sum(b))/dbl(cnt);
    }
#    ADDHELP("avg", "manegold", "May 14 2003",
#            "Gives the average of all tail values.", "algebra");




    proc avg(BAT[any, flt] b) : dbl {
	var cnt := count(b);
        if (cnt = 0) 
	    return dbl(nil);
	return dbl(sum(b))/dbl(cnt);
    }
#    ADDHELP("avg", "manegold", "May 14 2003",
#            "Gives the average of all tail values.", "algebra");




    proc avg(BAT[any, dbl] b) : dbl {
	var cnt := count(b);
        if (cnt = 0) 
	    return dbl(nil);
	return dbl(sum(b))/dbl(cnt);
    }
#    ADDHELP("avg", "manegold", "May 14 2003",
#            "Gives the average of all tail values.", "algebra");






    proc count_no_nil(BAT[any,any] b) : int {
		return count(b,TRUE);
    }
#    ADDHELP("count_no_nil", "manegold", "Jun 03 2003",
#    "short-cut for count(b,TRUE)", "algebra");

@-
Dummy C code
@c


