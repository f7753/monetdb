
@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@' 
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@' 
@' The Original Code is the Monet Database System.
@' 
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2004 CWI.
@' All Rights Reserved.
@' 

@f mil_algebra_procs
@a Martin Kersten
@* MIL algebra extensions
MonetDB 5 supports running MIL programs compiled by M2m.
The resulting code needs PROC definitions of version 4, which
are assembled in this package.

We removed the ADDHELP functionality, because
M5 does not use the same catalog infrastructure 
Several procs were removed, because they seemed
to be unnecessary or complicates the handling in M5 
(polymorphic anonymous types)


The mal code was produced using
	M2m --trace=0 mil_algebra_procs.mil
[The trace flag removes the comment lines]

This files contains a patch of the sort_ht operation
to allow for proper cloning
@mal
module mil_algebra_procs;

function clear(b:bat[:any$1,:any$2]):bat[:any$1,:any$2];
	delete(b);
	return b;
end clear;
function unique(b:bat[:any$1,:any$2]):bat[:any$1,:any$2];
	sunique(b);
	return b;
end unique;
function diff(b1:bat[:any$1,:any$2], b2:bat[:any$1,:any$2]):bat[:any$1,:any$2];
	return ca_a :=sdiff(b1,b2);
end diff;
function intersect(b1:bat[:any$1,:any$2], b2:bat[:any$1,:any$2]):bat[:any$1,:any$2];
	return da_a :=sintersect(b1,b2);
end intersect;
function union(b1:bat[:any$1,:any$2], b2:bat[:any$1,:any$2]):bat[:any$1,:any$2];
	return ea_a :=sunion(b1,b2);
end union;
function project(b:bat[:any$1,:any]):bat[:any$1,:void];
	return fa_a :=project(b,nil);
end project;
function outerjoin(left:bat[:any$1,:any$2], right:bat[:any$2,:any$3]):bat[:any$1,:any$3];
	ga_a := lng(nil);
	return ha_a :=outerjoin(left,right,ga_a);
end outerjoin;
function find_unescaped_occurrence(b:str, c:chr):int;
	idx := search(b,c);
barrier	ia_a := true;
barrier	ja_a := >(idx,0);
	tmp := idx;
barrier	ka_a := true;
	ma_a := -(tmp,1);
barrier	la_a := >=(ma_a,0);
	na_a := string(b,tmp,1);
barrier	oa_a := !=("\\",na_a);
	pa_a := +(tmp,1);
leave	ka_a;
exit	oa_a;
redo	ka_a;
exit	la_a;
exit	ka_a;
	qa_a := -(idx,tmp);
	ra_a := %(qa_a,2);
barrier	sa_a := ==(ra_a,1);
	ta_a := length(b);
	ua_a := -(ta_a,idx);
	va_a := string(b,idx,ua_a);
	tmp := search(va_a,c);
barrier	wa_a := >=(tmp,0);
	idx := +(tmp,idx);
exit	wa_a;
barrier	xa_a := not(wa_a);
	idx := tmp;
leave	ia_a;
exit	xa_a;
exit	sa_a;
barrier	ya_a := not(sa_a);
leave	ia_a;
exit	ya_a;
redo	ia_a;
exit	ja_a;
exit	ia_a;
	return ab_a :=idx;
end find_unescaped_occurrence;

function algebra.likeselect(b:bat[:any$1,:str], pat:str):bat[:any$1,:oid];
	pat := substitute(pat,"%_","_%",true);
	pat := substitute(pat,"%%","%",true);
	idxper := find_unescaped_occurrence(pat,'%');
	idxund := find_unescaped_occurrence(pat,'_');
	wasper := false;
	aa_a := ==(idxper,-1);
	ba_a := ==(idxund,-1);
barrier	ca_a := and(aa_a,ba_a);
	return da_a :=uselect(b,pat);
exit	ca_a;
barrier	ea_a := not(ca_a);
barrier	fa_a := ==(idxper,-1);
	idx := idxund;
	isper := false;
exit	fa_a;
barrier	ga_a := not(fa_a);
barrier	ha_a := ==(idxund,-1);
	idx := idxper;
	isper := true;
exit	ha_a;
barrier	ia_a := not(ha_a);
barrier	ja_a := <(idxper,idxund);
	idx := idxper;
	isper := true;
exit	ja_a;
barrier	ka_a := not(ja_a);
	idx := idxund;
	isper := false;
exit	ka_a;
exit	ia_a;
exit	ga_a;
exit	ea_a;
barrier	la_a := true;
	na_a := length(pat);
barrier	ma_a := <(idx,na_a);
barrier	oa_a := wasper;
barrier	pa_a := <(idx,0);
	qa_a := length(pat);
barrier	ra_a := >(qa_a,0);
	sa_a := multiplex.tactics("endsWith",b,pat);
	b := multiplex.tactics("ifthen",sa_a,b);
exit	ra_a;
leave	la_a;
exit	pa_a;
barrier	ta_a := isper;
	ua_a := string(pat,0,idx);
	va_a := int(nil);
	wa_a := multiplex.tactics("search",b,ua_a);
	s := select(wa_a,0,va_a);
	xa_a := multiplex.tactics("+",s,idx);
	b := multiplex.tactics("string",b,xa_a);
exit	ta_a;
barrier	ya_a := not(ta_a);
	ab_a := multiplex.tactics("length",b);
	bb_a := +(idx,1);
	cb_a := multiplex.tactics(">=",ab_a,bb_a);
	b := multiplex.tactics("ifthen",cb_a,b);
	db_a := string(pat,0,idx);
	eb_a := int(nil);
	fb_a := multiplex.tactics("search",b,db_a);
	s := select(fb_a,0,eb_a);
	gb_a := +(idx,1);
	hb_a := multiplex.tactics("+",s,gb_a);
	b := multiplex.tactics("string",b,hb_a);
exit	ya_a;
exit	oa_a;
barrier	ib_a := not(oa_a);
barrier	jb_a := <(idx,0);
	kb_a := multiplex.tactics("==",b,pat);
	b := multiplex.tactics("ifthen",kb_a,b);
leave	la_a;
exit	jb_a;
	lb_a := string(pat,0,idx);
	mb_a := multiplex.tactics("startsWith",b,lb_a);
	b := multiplex.tactics("ifthen",mb_a,b);
barrier	nb_a := isper;
barrier	ob_a := >(idx,0);
	b := multiplex.tactics("string",b,idx);
exit	ob_a;
exit	nb_a;
barrier	pb_a := not(nb_a);
	qb_a := multiplex.tactics("length",b);
	rb_a := +(idx,1);
	sb_a := multiplex.tactics(">=",qb_a,rb_a);
	b := multiplex.tactics("ifthen",sb_a,b);
	tb_a := +(idx,1);
	b := multiplex.tactics("string",b,tb_a);
exit	pb_a;
exit	ib_a;
	wasper := isper;
	ub_a := +(idx,1);
	pat := string(pat,idx);
barrier	vb_a := isper;
	idxper := find_unescaped_occurrence(pat,'%');
barrier	wb_a := >(idxund,0);
	xb_a := -(idxund,idx);
exit	wb_a;
exit	vb_a;
barrier	yb_a := not(vb_a);
	idxund := find_unescaped_occurrence(pat,'_');
barrier	ac_a := >(idxper,0);
	bc_a := -(idxper,idx);
exit	ac_a;
exit	yb_a;
	cc_a := ==(idxper,-1);
	dc_a := ==(idxund,-1);
barrier	ec_a := and(cc_a,dc_a);
	idx := -1;
exit	ec_a;
barrier	fc_a := not(ec_a);
barrier	gc_a := ==(idxper,-1);
	idx := idxund;
	isper := false;
exit	gc_a;
barrier	hc_a := not(gc_a);
barrier	ic_a := ==(idxund,-1);
	idx := idxper;
	isper := true;
exit	ic_a;
barrier	jc_a := not(ic_a);
barrier	kc_a := <(idxper,idxund);
	idx := idxper;
	isper := true;
exit	kc_a;
barrier	lc_a := not(kc_a);
	idx := idxund;
	isper := false;
exit	lc_a;
exit	jc_a;
exit	hc_a;
exit	fc_a;
redo	la_a;
exit	ma_a;
exit	la_a;
	return mc_a :=mark(b,nil);
end likeselect;
function tunique(b:bat[:any,:any$1]):bat[:any$1,:void];
	qd_a := reverse(b);
	rd_a := mark(qd_a,nil);
	return sd_a :=kunique(rd_a);
end tunique;
function sort_ht(B:bat[:any$1,:any$2]):bat[:any$1,:any$2];
	td_a := count(B);
	R := new(B,td_a);
	ud_a := kunique(B);
	vd_a := sort(ud_a);
barrier	(wd_a,wd_aH,wd_aT) := chopper.newIterator(vd_a);
	xd_a := reverse(B);
	yd_a := select(xd_a,wd_aH);
	ae_a := sort(yd_a);
barrier	(be_a,be_aH,be_aT) := chopper.newIterator(ae_a);
	ce_a := insert(R,be_aT,be_aH);
redo	(be_a,be_aH,be_aT) := chopper.hasMoreElements(ae_a);
exit	be_a;
redo	(wd_a,wd_aH,wd_aT) := chopper.hasMoreElements(vd_a);
exit	wd_a;
	return de_a :=R;
end sort_ht;
function avg(b:bat[:any,:sht]):dbl;
	cnt := count(b);
barrier	oe_a := ==(cnt,0);
	return pe_a :=dbl(nil);
exit	oe_a;
	qe_a := sum(b);
	re_a := dbl(qe_a);
	se_a := dbl(cnt);
	return te_a :=/(re_a,se_a);
end avg;
function avg(b:bat[:any,:int]):dbl;
	cnt := count(b);
barrier	ue_a := ==(cnt,0);
	return ve_a :=dbl(nil);
exit	ue_a;
	we_a := sum(b);
	xe_a := dbl(we_a);
	ye_a := dbl(cnt);
	return af_a :=/(xe_a,ye_a);
end avg;
function avg(b:bat[:any,:lng]):dbl;
	cnt := count(b);
barrier	bf_a := ==(cnt,0);
	return cf_a :=dbl(nil);
exit	bf_a;
	df_a := sum(b);
	ef_a := dbl(df_a);
	ff_a := dbl(cnt);
	return gf_a :=/(ef_a,ff_a);
end avg;
function avg(b:bat[:any,:flt]):dbl;
	cnt := count(b);
barrier	hf_a := ==(cnt,0);
	return if_a :=dbl(nil);
exit	hf_a;
	jf_a := sum(b);
	kf_a := dbl(jf_a);
	lf_a := dbl(cnt);
	return mf_a :=/(kf_a,lf_a);
end avg;
function avg(b:bat[:any,:dbl]):dbl;
	cnt := count(b);
barrier	nf_a := ==(cnt,0);
	return of_a :=dbl(nil);
exit	nf_a;
	pf_a := sum(b);
	qf_a := dbl(pf_a);
	rf_a := dbl(cnt);
	return sf_a :=/(qf_a,rf_a);
end avg;
function count_no_nil(b:bat[:any,:any]):lng;
	return tf_a :=count(b,true);
end count_no_nil;
@- Original code
@mil

#    PROC ADDHELP(str cmd, str aut, str dat, str hlp, str modname) : void {
#        var fid := monet_fcn_nme.select(cmd).kdiff(monet_fcn_aut).reverse().min();
#        monet_fcn_dsc.insert(fid, hlp);
#        monet_fcn_aut.insert(fid, aut);
#        monet_fcn_dat.insert(fid, dat);
#	monet_fcn_mid.insert(fid, monet_mod_nme.reverse().find(modname));
#    }
#
#    ADDHELP("ADDHELP", "boncz", "Feb  6 1996",
#    "provide helpful info on a command (author, date, help-text).", "algebra");

    PROC clear(bat[any::1,any::2] b) : bat[any::1,any::2] {
		return b.delete();
	}
#    ADDHELP("clear", "boncz", "Mar  6 1996",
#        "Backward compatibility. Does a b.delete()", "algebra");



#    PROC semijoin(bat[any::1,any::2] l, bat[any::1,any] r) : bat[any::1,any::2] {
# 		return kintersect(l,r);
#	}
#    ADDHELP("semijoin", "boncz", "Nov  1 1998",
#	    "semijoin is a synonym of kintersect.", "algebra");

    PROC unique(bat[any::1,any::2] b) : bat[any::1,any::2] {
		return sunique(b);
	}
#    ADDHELP("unique", "boncz", "Apr  6 1997",
#            "backward compatibility: use sunique() explicitly.", "algebra");

    PROC diff(bat[any::1,any::2] b1, bat[any::1,any::2] b2)  : bat[any::1,any::2] {
		return sdiff(b1,b2);
   }
#    ADDHELP("diff", "boncz", "Apr  6 1997",
#            "backward compatibility: use sdiff() explicitly.", "algebra");

    PROC intersect(bat[any::1,any::2] b1, bat[any::1,any::2] b2) : bat[any::1,any::2] {
		return sintersect(b1,b2); 
   }
#    ADDHELP("intersect", "boncz", "Apr  6 1997",
#             "backward compatibility: use sintersect() explicitly.", "algebra");

    PROC union(bat[any::1,any::2] b1, bat[any::1,any::2] b2) : bat[any::1,any::2]  {
		return sunion(b1,b2);
   }
#    ADDHELP("union", "boncz", "Feb  6 1996",
#            "backward compatibility: use sunion() explicitly.", "algebra");

    PROC project(bat[any::1,any] b) : bat[any::1,void] {
		return b.project(nil);
    }

#    PROC join (BAT[any::1,any::2] left, BAT[any::2,any::3] right) : BAT[any::1,any::3] {
#		return join(left, right, lng(nil));
#    }

    PROC outerjoin (BAT[any::1,any::2] left, BAT[any::2,any::3] right) : BAT[any::1,any::3] {
		return outerjoin(left, right, lng(nil));
    }

#! DROPPED due to variable argument handling
#!    PROC join(bat[any::1,any::2] l, bat[any::2,any::3] r, str fcn, ..any..) : bat[any::1,any::3] {
#!  		return join(l, r, lng(nil), fcn, $(4..));
#!    }
   
#!DROPPED, seems unnecessary
#!    PROC new( BAT a, BAT b, int sz ) : BAT {
#!        var ht := a.htype();
#!        var tt := b.ttype();
#!        if ((ht = tt) and (ht = void)) {
#!                if (not(isnil(b.reverse().seqbase()))) {
#!                        tt := oid;
#!                } else if (not(isnil(a.seqbase()))) {
#!                        ht := oid;
#!                }
#!        }
#!	var r := new(ht, tt, sz);
#!	if (tt = void) {
#!		if (not(isnil(b.reverse().seqbase()))) {
#!			r.reverse().seqbase( b.reverse().seqbase() );
#!		}
#!	}
#!	if (ht = void) {
#!		if (not(isnil(a.seqbase()))) {
#!			r.seqbase( a.seqbase() );
#!		}
#!	}
#!	return r;
#!    }


#! DROPPED, (theta)joins should be implemented as overloaded
#! comparison operators
#!    PROC join(bat[any::1,any::2] l, bat[any::2,any::3] r, lng estimate, str fcn, ..any..) : bat[any::1,any::3] 
#!    {
#!        if ($0 = 3) {
#!            if (fcn = "=") {
#!                return join(l,r,estimate);
#!            } else if (fcn = "<=") {
#!                return thetajoin(l,r,LE,estimate);
#!            } else if (fcn = "<") {
#!                return thetajoin(l,r,LT,estimate);
#!            } else if (fcn = ">=") {
#!                return thetajoin(l,r,GE,estimate);
#!            } else if (fcn = ">") {
#!                return thetajoin(l,r,GT,estimate);
#!            } else if (fcn = "true") {
#!                return cross(l,r);
#!            }
#!        }
#!        var swapped := false;
#!        if (l.count() < r.count()) {
#!            var swap := l;
#!            l := r.reverse(); r := swap.reverse();
#!            swapped := true;
#!        }
#!	if (isnil(estimate)) estimate := l.count();
#!        var bn := new(l, r, estimate);
#!        l@batloop() {
#!            var h := $h;
#!            var t := $t;
#!            if (swapped) {
#!                r@batloop() if ((*fcn)($h,t,$(5..))) bn.insert(h,$t);
#!            } else {
#!                r@batloop() if ((*fcn)(t,$h,$(5..))) bn.insert(h,$t);
#!            }
#!        }
#!        if (swapped) {
#!            return bn.reverse();
#!        } else {
#!            return bn;
#!        }
#!    }
#    ADDHELP("join", "boncz", "Aug  6 1998",
#            "Returns [left.head,right.tail] where (*fcn)(left.tail,right.head,..params..)", "algebra");

	proc find_unescaped_occurrence(str b, chr c) : int {
		var idx := b.search(c);
		var tmp;
		
		while (idx > 0) {
			# check if this char was escaped
			tmp := idx;
			while ((tmp :-=1) >= 0) {
				if ("\\" != b.string(tmp, 1)) {
					tmp :+= 1;
					break;
				}
			}
			if (((idx - tmp) % 2) = 1) {
				# this was an escaped char, go looking for the next one
				tmp := b.string(idx, b.length() - idx).search(c);
				# if not found, keep it like that, otherwise correct the
				# index with an offset
				if (tmp >= 0) {
					idx := tmp + idx;
				} else {
					idx := tmp;
					# we will not find anything more, break out
					break;
				}
			} else {
				# we found a valid one, break out of the loop!
				break;
			}
		}
		return(idx);
    }
#   ADDHELP("find_unescaped_occurrence", "groffen", "Sep 26 2004",
#   "finds the first occurrence of c that is not escaped by a \\", "algebra");

    PROC likeselect(bat[any::1,str] b, str pat) : bat[any::1,oid]  {
        var s;
		var idxper;
		var idxund;
		var isper;
		var idx;
		var wasper;

		# preprocess the pattern, remove redundant % and make sure
		# %_ can be handled by replacing it with _%
		# consider 'bla%_!': this would match anything like /bla.+!/
		# since we match from the left, the _ is matched immediately,
		# after which the ! might not be found.  To circumvent this
		# problem, we replace %_ with _%.  This results in the _ being
		# matched immediately -- which is already was -- and a variable
		# space after it.  This substitution works for the given
		# pattern, as it basically requires at least one char to be
		# between bla and !.
		pat := substitute(pat, "%_", "_%", true);
		pat := substitute(pat, "%%", "%", true);
		
		idxper := find_unescaped_occurrence(pat, '%');
		idxund := find_unescaped_occurrence(pat, '_');

		# force matching without position freedom for the first part
		wasper := false;

        if ((idxper = -1) and (idxund = -1)) {
			# no % or _ found at all, return simple selection on the given
			# string with no hassle of fancy wildcard characters
            return b.uselect(pat);
		} else if (idxper = -1) {
			idx := idxund;
			isper := false;
		} else if (idxund = -1) {
			idx := idxper;
			isper := true;
		} else {
			# idxper can never be equal to idxund at this point
			if (idxper < idxund) {
				idx := idxper;
				isper := true;
			} else {
				idx := idxund;
				isper := false;
			}
		}

		while (idx < pat.length()) {
			if (wasper) {
				# do position free match
				
				# is idx is smaller than 0 at this point, then both idxper and
				# idxund are -1; we only have a tail, so we should see if it
				# matches to complete this search
				if (idx < 0) {
					if (pat.length() > 0) {
						b := b.[endsWith](pat).[ifthen](b);
					}
					break;
				}
				if (isper) {
					s := b.[search](pat.string(0, idx)).select(0, int(nil));
					b := b.[string](s.[+](idx));
				} else {
					b := ((b.[length]()).[>=](idx + 1)).[ifthen](b);
					s := b.[search](pat.string(0, idx)).select(0, int(nil));
					b := b.[string](s.[+](idx + 1));
				}
			} else {
				# do a startsWith match

				# is idx is smaller than 0 at this point, then both idxper and
				# idxund are -1; we only have a tail, so we should see if it
				# matches to complete this search
				if (idx < 0) {
					b := (b.[=](pat)).[ifthen](b);
					break;
				}

				b := (b.[startsWith](pat.string(0, idx))).[ifthen](b);
				if (isper) {
					# shortcut; everything matches with an empty string
					if (idx > 0) b := b.[string](idx);
				} else {
					b := ((b.[length]()).[>=](idx + 1)).[ifthen](b);
					b := b.[string](idx + 1);
				}
			}

			wasper := isper;

			# remove from the search pattern what we have matched so far
			idx :+= 1;	# include the wilcard char!
			pat := pat.string(idx);

			# find next match for the last matching char (% or _)
			if (isper) {
				idxper := find_unescaped_occurrence(pat, '%');
				# correct value of other index
				if (idxund > 0) idxund :-= idx;
			} else {
				idxund := find_unescaped_occurrence(pat, '_');
				# correct value of other index
				if (idxper > 0) idxper :-= idx;
			}

			if ((idxper = -1) and (idxund = -1)) {
				idx := -1;
			} else if (idxper = -1) {
				idx := idxund;
				isper := false;
			} else if (idxund = -1) {
				idx := idxper;
				isper := true;
			} else {
				# idxper can never be equal to idxund at this point
				if (idxper < idxund) {
					idx := idxper;
					isper := true;
				} else {
					idx := idxund;
					isper := false;
				}
			}
		}

        return b.mark(nil);
    }
#   ADDHELP("likeselect", "groffen", "Sep 26 2004",
#   "does SQL LIKE select which supports % and _ (also understands escapes)", "algebra");
    

#! DROPPED, arbitrary select operator
#!    PROC mil_select(bat[any::1,any::2] b, str fcn, ..any..) : bat[any::1,any::2] 
#!    {
#!        if ($0 = 3) {
#!            var val := $3;
#!            if (val.type() = b.ttype()) {    
#!                var nilval := nil.cast(val.type()); 
#!                if (fcn = "=") {
#!                    return b.select(val);
#!                } else if (fcn = "<=") {
#!                    return b.select(nilval, val);
#!                } else if (fcn = "<") {
#!                    return b.select(nilval, val, FALSE, FALSE);
#!                } else if (fcn = ">=") {
#!                    return b.select(val, nilval);
#!                } else if (fcn = ">") {
#!                    return b.select(val, nilval, FALSE, FALSE);
#!                } else if (fcn = "like") {
#!                    var bn := likeselect(b, val);
#!                    return b.semijoin(bn);
#!                }
#!            }
#!        }
#!        var bitvector := [*fcn](b,$(3..));
#!        return [ifthen](bitvector,b);
#!    }
#!
#!    PROC mil_select(bat[any::1,any::2] b, str fcn, any::2 lo, any::2 hi) : bat[any::1,any::2] 
#!    {
#!        if (or((fcn = "between"),(fcn = "[in]"))) {
#!            return b.select(lo,hi);
#!        } else if (fcn = "<in]") {
#!            return b.select(lo,hi,FALSE,TRUE);
#!        } else if (fcn = "[in>") {
#!            return b.select(lo,hi,TRUE,FALSE);
#!        } else if (fcn = "<in>") {
#!            return b.select(lo,hi,FALSE,FALSE);
#!        }
#!        var bitvector := [*fcn](b,lo,hi);
#!        return [ifthen](bitvector,b);
#!    }
#!#    ADDHELP("mil_select", "boncz", "Aug  6 1998",
#!#            "Returns all BUNs where (*fcn)(tail,,..params..).", "algebra");
#!
#!    PROC neg_select(bat[any::1,any::2] b, str fcn, ..any..) : bat[any::1,any::2] 
#!    {
#!        if ($0 = 3) {
#!            var val := $3;
#!            if (val.type() = b.ttype()) {    
#!                if (fcn = "!=") {
#!                    return b.mil_select("=", val);
#!                } else if (fcn = ">=") {
#!                    return b.mil_select("<", val);
#!                } else if (fcn = "<=") {
#!                    return b.mil_select(">", val);
#!                } else if (fcn = ">") {
#!                    return b.mil_select("<=", val);
#!                } else if (fcn = "<") {
#!                    return b.mil_select(">=", val);
#!                } else if (fcn = "like") {
#!                    var bn := likeselect(b, val);
#!                    return b.kdiff(bn);
#!                }
#!            }
#!        }
#!        var bitvector := [*fcn](b,$(3..));
#!        return [ifelse](bitvector,b);
#!    }
#!#    ADDHELP("neg_select", "boncz", "Aug  6 1998",
#!#            "Returns all BUNs where not (*fcn)(tail,,..params..)", "algebra");
#!
#!    PROC rev_select(bat[any::1,any::2] b, str fcn, any::2 val) : bat[any::1,any::2] 
#!    {
#!        if (fcn = "=") {
#!            return b.mil_select("=",val);
#!        } else if (fcn = "!=") {
#!            return b.mil_select("!=",val);
#!        } else if (fcn = ">") {
#!            return b.mil_select("<",val);
#!        } else if (fcn = "<") {
#!            return b.mil_select(">",val);
#!        } else if (fcn = "<=") {
#!            return b.mil_select(">=",val);
#!        } else if (fcn = ">=") {
#!            return b.mil_select("<=",val);
#!        }
#!        ERROR("rev_select: unknown predicate %s(%s)\n", fcn, str(val));
#!    }
#    ADDHELP("rev_select", "boncz", "Aug  6 1998",
#            "(value OP column) select rather than (column OP value)","algebra");

    PROC tunique (bat[any,any::1] b) : bat[any::1,void] {
	return b.reverse().mark(nil).kunique();
   }

    PROC sort_ht (bat[any::1,any::2] B) : bat[any::1,any::2] 
    {
#       var R := new(htype(B),ttype(B),count(B));
        var R := new(B,count(B));

        B.kunique().sort()@batloop {
            B.reverse().select($h).sort()@batloop {
                R.insert($t,$h);
            }
        }
        return R;
    }
#    ADDHELP("sort_ht", "manegold", "Dec 17 1998",
#            "sorts a BAT according to its head (primary) and tail values (secondary).\
#             (straight forward hack, not tuned for performance at all, just used for testing.)", "algebra");




    proc sum( bat[any,sht] b ) : sht { return sum_sht(b); }
    proc prod( bat[any,sht] b ) : sht { return prod_sht(b); }




    proc sum( bat[any,int] b ) : int { return sum_int(b); }
    proc prod( bat[any,int] b ) : int { return prod_int(b); }




    proc sum( bat[any,lng] b ) : lng { return sum_lng(b); }
    proc prod( bat[any,lng] b ) : lng { return prod_lng(b); }




    proc sum( bat[any,flt] b ) : flt { return sum_flt(b); }
    proc prod( bat[any,flt] b ) : flt { return prod_flt(b); }




    proc sum( bat[any,dbl] b ) : dbl { return sum_dbl(b); }
    proc prod( bat[any,dbl] b ) : dbl { return prod_dbl(b); }







    proc avg(BAT[any, sht] b) : dbl {
	var cnt := count(b);
        if (cnt = 0) 
	    return dbl(nil);
	return dbl(sum_lng(b))/dbl(cnt);
    }
#    ADDHELP("avg", "manegold", "May 14 2003",
#            "Gives the average of all tail values.", "algebra");




    proc avg(BAT[any, int] b) : dbl {
	var cnt := count(b);
        if (cnt = 0) 
	    return dbl(nil);
	return dbl(sum_lng(b))/dbl(cnt);
    }
#    ADDHELP("avg", "manegold", "May 14 2003",
#            "Gives the average of all tail values.", "algebra");







    proc avg(BAT[any, lng] b) : dbl {
	var cnt := count(b);
        if (cnt = 0) 
	    return dbl(nil);
	return dbl(sum(b))/dbl(cnt);
    }
#    ADDHELP("avg", "manegold", "May 14 2003",
#            "Gives the average of all tail values.", "algebra");




    proc avg(BAT[any, flt] b) : dbl {
	var cnt := count(b);
        if (cnt = 0) 
	    return dbl(nil);
	return dbl(sum(b))/dbl(cnt);
    }
#    ADDHELP("avg", "manegold", "May 14 2003",
#            "Gives the average of all tail values.", "algebra");




    proc avg(BAT[any, dbl] b) : dbl {
	var cnt := count(b);
        if (cnt = 0) 
	    return dbl(nil);
	return dbl(sum(b))/dbl(cnt);
    }
#    ADDHELP("avg", "manegold", "May 14 2003",
#            "Gives the average of all tail values.", "algebra");






    proc count_no_nil(BAT[any,any] b) : int {
		return count(b,TRUE);
    }
#    ADDHELP("count_no_nil", "manegold", "Jun 03 2003",
#    "short-cut for count(b,TRUE)", "algebra");

@-
Dummy C code
@c
