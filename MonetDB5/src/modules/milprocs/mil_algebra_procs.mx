
@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@' 
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@' 
@' The Original Code is the Monet Database System.
@' 
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2004 CWI.
@' All Rights Reserved.
@' 

@f mil_algebra_procs
@a Martin Kersten
@* MIL algebra extensions
MonetDB 5 supports running MIL programs compiled by M2m.
The resulting code needs PROC definitions of version 4, which
are assembled in this package.

We removed the ADDHELP functionality, because
M5 does not use the same catalog infrastructure 
Several procs were removed, because they seemed
to be unnecessary or complicates the handling in M5 
(polymorphic anonymous types)


The mal code was produced using
	M2m --trace=0 mil_algebra_procs.mil
[The trace flag removes the comment lines]
@mal
module mil_algebra_procs;

function clear(b:bat[:any$1,:any$2]):bat[:any$1,:any$2];
	return aa_a :=delete(b);
end clear;
function unique(b:bat[:any$1,:any$2]):bat[:any$1,:any$2];
	return ca_a :=sunique(b);
end unique;
function diff(b1:bat[:any$1,:any$2], b2:bat[:any$1,:any$2]):bat[:any$1,:any$2];
	return da_a :=sdiff(b1,b2);
end diff;
function intersect(b1:bat[:any$1,:any$2], b2:bat[:any$1,:any$2]):bat[:any$1,:any$2];
	return ea_a :=sintersect(b1,b2);
end intersect;
function union(b1:bat[:any$1,:any$2], b2:bat[:any$1,:any$2]):bat[:any$1,:any$2];
	return fa_a :=sunion(b1,b2);
end union;
function project(b:bat[:any$1,:any]):bat[:any$1,:void];
	return ga_a :=project(b,nil);
end project;
function outerjoin(left:bat[:any$1,:any$2], right:bat[:any$2,:any$3]):bat[:any$1,:any$3];
	ha_a := lng(nil);
	return ia_a :=outerjoin(left,right,ha_a);
end outerjoin;
function find_unescaped_occurrence(b:str, c:chr):int;
	idx := search(b,c);
barrier	ja_a := true;
barrier	ka_a := >(idx,0);
	tmp := idx;
barrier	la_a := true;
	na_a := -(tmp,1);
barrier	ma_a := >=(na_a,0);
	oa_a := string(b,tmp,1);
barrier	pa_a := !=("\\",oa_a);
	qa_a := +(tmp,1);
leave	la_a;
exit	pa_a;
redo	la_a;
exit	ma_a;
exit	la_a;
	ra_a := -(idx,tmp);
	sa_a := %(ra_a,2);
barrier	ta_a := ==(sa_a,1);
	ua_a := length(b);
	va_a := -(ua_a,idx);
	wa_a := string(b,idx,va_a);
	tmp := search(wa_a,c);
barrier	xa_a := >=(tmp,0);
	idx := +(tmp,idx);
exit	xa_a;
barrier	ya_a := not(xa_a);
	idx := tmp;
leave	ja_a;
exit	ya_a;
exit	ta_a;
barrier	ab_a := not(ta_a);
leave	ja_a;
exit	ab_a;
redo	ja_a;
exit	ka_a;
exit	ja_a;
	return bb_a :=idx;
end find_unescaped_occurrence;
function likeselect(b:bat[:any$1,:str], pat:str):bat[:any$1,:oid];
	idxper := find_unescaped_occurrence(pat,'%');
	idxund := find_unescaped_occurrence(pat,'_');
	cb_a := ==(idxper,-1);
	db_a := ==(idxund,-1);
barrier	eb_a := and(cb_a,db_a);
	return fb_a :=uselect(b,pat);
exit	eb_a;
barrier	gb_a := not(eb_a);
barrier	hb_a := ==(idxper,-1);
	idx := idxund;
	isper := false;
exit	hb_a;
barrier	ib_a := not(hb_a);
barrier	jb_a := ==(idxund,-1);
	idx := idxper;
	isper := true;
exit	jb_a;
barrier	kb_a := not(jb_a);
barrier	lb_a := <(idxper,idxund);
	idx := idxper;
	isper := true;
exit	lb_a;
barrier	mb_a := not(lb_a);
	idx := idxund;
	isper := false;
exit	mb_a;
exit	kb_a;
exit	ib_a;
exit	gb_a;
barrier	nb_a := >(idx,0);
	ob_a := string(pat,0,idx);
	pb_a := multiplex.tactics("search",b,ob_a);
	s := select(pb_a,0);
barrier	qb_a := isper;
	rb_a := semijoin(b,s);
	sb_a := multiplex.tactics("length",rb_a);
	tb_a := multiplex.tactics("-",sb_a,s);
	b := multiplex.tactics("string",b,s,tb_a);
exit	qb_a;
barrier	ub_a := not(qb_a);
	vb_a := semijoin(b,s);
	wb_a := multiplex.tactics("length",vb_a);
	xb_a := multiplex.tactics("-",wb_a,s);
	yb_a := multiplex.tactics("+",xb_a,1);
	b := multiplex.tactics("string",b,s,yb_a);
exit	ub_a;
	didMatch := true;
exit	nb_a;
barrier	ac_a := not(nb_a);
	didMatch := false;
exit	ac_a;
barrier	bc_a := true;
	dc_a := +(idx,1);
	ec_a := length(pat);
barrier	cc_a := <(dc_a,ec_a);
	fc_a := length(pat);
	gc_a := -(fc_a,idx);
	pat := string(pat,idx,gc_a);
barrier	hc_a := and(didMatch,isper);
	idxper := find_unescaped_occurrence(pat,'%');
barrier	ic_a := >(idxund,0);
	jc_a := -(idxund,idx);
exit	ic_a;
exit	hc_a;
barrier	kc_a := not(hc_a);
barrier	lc_a := didMatch;
	idxund := find_unescaped_occurrence(pat,'_');
barrier	mc_a := >(idxper,0);
	nc_a := -(idxper,idx);
exit	mc_a;
exit	lc_a;
barrier	oc_a := not(lc_a);
	didMatch := true;
exit	oc_a;
exit	kc_a;
	pc_a := ==(idxper,-1);
	qc_a := ==(idxund,-1);
barrier	rc_a := and(pc_a,qc_a);
	idx := -1;
exit	rc_a;
barrier	sc_a := not(rc_a);
barrier	tc_a := ==(idxper,-1);
	idx := idxund;
	isper := false;
exit	tc_a;
barrier	uc_a := not(tc_a);
barrier	vc_a := ==(idxund,-1);
	idx := idxper;
	isper := true;
exit	vc_a;
barrier	wc_a := not(vc_a);
barrier	xc_a := <(idxper,idxund);
	idx := idxper;
	isper := true;
exit	xc_a;
barrier	yc_a := not(xc_a);
	idx := idxund;
	isper := false;
exit	yc_a;
exit	wc_a;
exit	uc_a;
exit	sc_a;
barrier	ad_a := <(idx,0);
	bd_a := length(pat);
barrier	cd_a := >(bd_a,0);
	dd_a := multiplex.tactics("endsWith",b,pat);
	b := multiplex.tactics("ifthen",dd_a,b);
exit	cd_a;
leave	bc_a;
exit	ad_a;
	ed_a := string(pat,0,idx);
	fd_a := int(nil);
	gd_a := multiplex.tactics("search",b,ed_a);
	s := select(gd_a,0,fd_a);
barrier	hd_a := isper;
	id_a := semijoin(b,s);
	jd_a := multiplex.tactics("length",id_a);
	kd_a := multiplex.tactics("-",jd_a,s);
	b := multiplex.tactics("string",b,s,kd_a);
exit	hd_a;
barrier	ld_a := not(hd_a);
	md_a := semijoin(b,s);
	nd_a := multiplex.tactics("length",md_a);
	od_a := multiplex.tactics("-",nd_a,s);
	pd_a := multiplex.tactics("+",od_a,1);
	b := multiplex.tactics("string",b,s,pd_a);
exit	ld_a;
redo	bc_a;
exit	cc_a;
exit	bc_a;
	return qd_a :=mark(b,nil);
end likeselect;
function tunique(b:bat[:any,:any$1]):bat[:any$1,:void];
	rd_a := reverse(b);
	sd_a := mark(rd_a,nil);
	return td_a :=kunique(sd_a);
end tunique;
function sort_ht(B:bat[:any$1,:any$2]):bat[:any$1,:any$2];
	R := new(B);
	xd_a := kunique(B);
	yd_a := sort(xd_a);
barrier	ae_a := bunStream(yd_a,ae_aH,ae_aT);
	be_a := reverse(B);
	ce_a := select(be_a,ae_aH);
	de_a := sort(ce_a);
barrier	ee_a := bunStream(de_a,ee_aH,ee_aT);
	fe_a := insert(R,ee_aT,ee_aH);
redo	ee_a;
exit	ee_a;
redo	ae_a;
exit	ae_a;
	return ge_a :=R;
end sort_ht;
function sum(b:bat[:any,:sht]):sht;
	return he_a :=sum_sht(b);
end sum;
function prod(b:bat[:any,:sht]):sht;
	return ie_a :=prod_sht(b);
end prod;
function sum(b:bat[:any,:int]):int;
	return je_a :=sum_int(b);
end sum;
function prod(b:bat[:any,:int]):int;
	return ke_a :=prod_int(b);
end prod;
function sum(b:bat[:any,:lng]):lng;
	return le_a :=sum_lng(b);
end sum;
function prod(b:bat[:any,:lng]):lng;
	return me_a :=prod_lng(b);
end prod;
function sum(b:bat[:any,:flt]):flt;
	return ne_a :=sum_flt(b);
end sum;
function prod(b:bat[:any,:flt]):flt;
	return oe_a :=prod_flt(b);
end prod;
function sum(b:bat[:any,:dbl]):dbl;
	return pe_a :=sum_dbl(b);
end sum;
function prod(b:bat[:any,:dbl]):dbl;
	return qe_a :=prod_dbl(b);
end prod;
function avg(b:bat[:any,:sht]):dbl;
	cnt := count(b);
barrier	re_a := ==(cnt,0);
	return se_a :=dbl(nil);
exit	re_a;
	te_a := sum_lng(b);
	ue_a := dbl(te_a);
	ve_a := dbl(cnt);
	return we_a :=/(ue_a,ve_a);
end avg;
function avg(b:bat[:any,:int]):dbl;
	cnt := count(b);
barrier	xe_a := ==(cnt,0);
	return ye_a :=dbl(nil);
exit	xe_a;
	af_a := sum_lng(b);
	bf_a := dbl(af_a);
	cf_a := dbl(cnt);
	return df_a :=/(bf_a,cf_a);
end avg;
function avg(b:bat[:any,:lng]):dbl;
	cnt := count(b);
barrier	ef_a := ==(cnt,0);
	return ff_a :=dbl(nil);
exit	ef_a;
	gf_a := sum(b);
	hf_a := dbl(gf_a);
	if_a := dbl(cnt);
	return jf_a :=/(hf_a,if_a);
end avg;
function avg(b:bat[:any,:flt]):dbl;
	cnt := count(b);
barrier	kf_a := ==(cnt,0);
	return lf_a :=dbl(nil);
exit	kf_a;
	mf_a := sum(b);
	nf_a := dbl(mf_a);
	of_a := dbl(cnt);
	return pf_a :=/(nf_a,of_a);
end avg;
function avg(b:bat[:any,:dbl]):dbl;
	cnt := count(b);
barrier	qf_a := ==(cnt,0);
	return rf_a :=dbl(nil);
exit	qf_a;
	sf_a := sum(b);
	tf_a := dbl(sf_a);
	uf_a := dbl(cnt);
	return vf_a :=/(tf_a,uf_a);
end avg;
function count_no_nil(b:bat[:any,:any]):int;
	return wf_a :=count(b,true);
end count_no_nil;
#Identifer 'htype' mapped to 'getHeadType'
#Identifer 'ttype' mapped to 'getTailType'
@- Original code
@mil

#    PROC ADDHELP(str cmd, str aut, str dat, str hlp, str modname) : void {
#        var fid := monet_fcn_nme.select(cmd).kdiff(monet_fcn_aut).reverse().min();
#        monet_fcn_dsc.insert(fid, hlp);
#        monet_fcn_aut.insert(fid, aut);
#        monet_fcn_dat.insert(fid, dat);
#	monet_fcn_mid.insert(fid, monet_mod_nme.reverse().find(modname));
#    }
#
#    ADDHELP("ADDHELP", "boncz", "Feb  6 1996",
#    "provide helpful info on a command (author, date, help-text).", "algebra");

    PROC clear(bat[any::1,any::2] b) : bat[any::1,any::2] {
		return b.delete();
	}
#    ADDHELP("clear", "boncz", "Mar  6 1996",
#        "Backward compatibility. Does a b.delete()", "algebra");



#    PROC semijoin(bat[any::1,any::2] l, bat[any::1,any] r) : bat[any::1,any::2] {
# 		return kintersect(l,r);
#	}
#    ADDHELP("semijoin", "boncz", "Nov  1 1998",
#	    "semijoin is a synonym of kintersect.", "algebra");

    PROC unique(bat[any::1,any::2] b) : bat[any::1,any::2] {
		return sunique(b);
	}
#    ADDHELP("unique", "boncz", "Apr  6 1997",
#            "backward compatibility: use sunique() explicitly.", "algebra");

    PROC diff(bat[any::1,any::2] b1, bat[any::1,any::2] b2)  : bat[any::1,any::2] {
		return sdiff(b1,b2);
   }
#    ADDHELP("diff", "boncz", "Apr  6 1997",
#            "backward compatibility: use sdiff() explicitly.", "algebra");

    PROC intersect(bat[any::1,any::2] b1, bat[any::1,any::2] b2) : bat[any::1,any::2] {
		return sintersect(b1,b2); 
   }
#    ADDHELP("intersect", "boncz", "Apr  6 1997",
#             "backward compatibility: use sintersect() explicitly.", "algebra");

    PROC union(bat[any::1,any::2] b1, bat[any::1,any::2] b2) : bat[any::1,any::2]  {
		return sunion(b1,b2);
   }
#    ADDHELP("union", "boncz", "Feb  6 1996",
#            "backward compatibility: use sunion() explicitly.", "algebra");

    PROC project(bat[any::1,any] b) : bat[any::1,void] {
		return b.project(nil);
    }

#    PROC join (BAT[any::1,any::2] left, BAT[any::2,any::3] right) : BAT[any::1,any::3] {
#		return join(left, right, lng(nil));
#    }

    PROC outerjoin (BAT[any::1,any::2] left, BAT[any::2,any::3] right) : BAT[any::1,any::3] {
		return outerjoin(left, right, lng(nil));
    }

#! DROPPED due to variable argument handling
#!    PROC join(bat[any::1,any::2] l, bat[any::2,any::3] r, str fcn, ..any..) : bat[any::1,any::3] {
#!  		return join(l, r, lng(nil), fcn, $(4..));
#!    }
   
#!DROPPED, seems unnecessary
#!    PROC new( BAT a, BAT b, int sz ) : BAT {
#!        var ht := a.htype();
#!        var tt := b.ttype();
#!        if ((ht = tt) and (ht = void)) {
#!                if (not(isnil(b.reverse().seqbase()))) {
#!                        tt := oid;
#!                } else if (not(isnil(a.seqbase()))) {
#!                        ht := oid;
#!                }
#!        }
#!	var r := new(ht, tt, sz);
#!	if (tt = void) {
#!		if (not(isnil(b.reverse().seqbase()))) {
#!			r.reverse().seqbase( b.reverse().seqbase() );
#!		}
#!	}
#!	if (ht = void) {
#!		if (not(isnil(a.seqbase()))) {
#!			r.seqbase( a.seqbase() );
#!		}
#!	}
#!	return r;
#!    }


#! DROPPED, (theta)joins should be implemented as overloaded
#! comparison operators
#!    PROC join(bat[any::1,any::2] l, bat[any::2,any::3] r, lng estimate, str fcn, ..any..) : bat[any::1,any::3] 
#!    {
#!        if ($0 = 3) {
#!            if (fcn = "=") {
#!                return join(l,r,estimate);
#!            } else if (fcn = "<=") {
#!                return thetajoin(l,r,LE,estimate);
#!            } else if (fcn = "<") {
#!                return thetajoin(l,r,LT,estimate);
#!            } else if (fcn = ">=") {
#!                return thetajoin(l,r,GE,estimate);
#!            } else if (fcn = ">") {
#!                return thetajoin(l,r,GT,estimate);
#!            } else if (fcn = "true") {
#!                return cross(l,r);
#!            }
#!        }
#!        var swapped := false;
#!        if (l.count() < r.count()) {
#!            var swap := l;
#!            l := r.reverse(); r := swap.reverse();
#!            swapped := true;
#!        }
#!	if (isnil(estimate)) estimate := l.count();
#!        var bn := new(l, r, estimate);
#!        l@batloop() {
#!            var h := $h;
#!            var t := $t;
#!            if (swapped) {
#!                r@batloop() if ((*fcn)($h,t,$(5..))) bn.insert(h,$t);
#!            } else {
#!                r@batloop() if ((*fcn)(t,$h,$(5..))) bn.insert(h,$t);
#!            }
#!        }
#!        if (swapped) {
#!            return bn.reverse();
#!        } else {
#!            return bn;
#!        }
#!    }
#    ADDHELP("join", "boncz", "Aug  6 1998",
#            "Returns [left.head,right.tail] where (*fcn)(left.tail,right.head,..params..)", "algebra");

	proc find_unescaped_occurrence(str b, chr c) : int {
		var idx := b.search(c);
		var tmp;
		
		while (idx > 0) {
			# check if this char was escaped
			tmp := idx;
			while ((tmp :-=1) >= 0) {
				if ("\\" != b.string(tmp, 1)) {
					tmp :+= 1;
					break;
				}
			}
			if (((idx - tmp) % 2) = 1) {
				# this was an escaped char, go looking for the next one
				tmp := b.string(idx, b.length() - idx).search(c);
				# if not found, keep it like that, otherwise correct the
				# index with an offset
				if (tmp >= 0) {
					idx := tmp + idx;
				} else {
					idx := tmp;
					# we will not find anything more, break out
					break;
				}
			} else {
				# we found a valid one, break out of the loop!
				break;
			}
		}
		return(idx);
    }
#   ADDHELP("find_unescaped_occurrence", "groffen", "Sep 26 2004",
#   "finds the first occurrence of c that is not escaped by a \\", "algebra");

    # SQL LIKE functionality, vectorized MIL implementation
    PROC likeselect(bat[any::1,str] b, str pat) : bat[any::1,oid]  {
        var s;
		var idxper;
		var idxund;
		var isper;
		var idx;
		var didMatch;
		
		idxper := find_unescaped_occurrence(pat, '%');
		idxund := find_unescaped_occurrence(pat, '_');

        if ((idxper = -1) and (idxund = -1)) {
			# no % or _ found at all, return simple selection on the given
			# string with no hassle of fancy wildcard characters
            return b.uselect(pat);
		} else if (idxper = -1) {
			idx := idxund;
			isper := false;
		} else if (idxund = -1) {
			idx := idxper;
			isper := true;
		} else {
			# idxper can never be equal to idxund at this point
			if (idxper < idxund) {
				idx := idxper;
				isper := true;
			} else {
				idx := idxund;
				isper := false;
			}
		}

		if (idx > 0) {
			s := b.[search](pat.string(0, idx)).select(0);
			if (isper) {
				b := b.[string](s, [-](b.semijoin(s).[length](), s));
			} else {
				b := b.[string](s, [+]([-](b.semijoin(s).[length](), s), 1));
			}
			didMatch := true;
		} else {
			didMatch := false;
		}

		while ((idx :+= 1) < pat.length()) {
			# remove from the search pattern what we have matched so far
            pat := pat.string(idx, pat.length()-idx);

			# find next match for the last matching char (% or _)
			if (didMatch and isper) {
				idxper := find_unescaped_occurrence(pat, '%');
				# correct value of other index
				if (idxund > 0) idxund :-= idx;
			} else if (didMatch) {
				idxund := find_unescaped_occurrence(pat, '_');
				# correct value of other index
				if (idxper > 0) idxper :-= idx;
			} else {
				didMatch := true;
			}
				
			if ((idxper = -1) and (idxund = -1)) {
				idx := -1;
			} else if (idxper = -1) {
				idx := idxund;
				isper := false;
			} else if (idxund = -1) {
				idx := idxper;
				isper := true;
			} else {
				# idxper can never be equal to idxund at this point
				if (idxper < idxund) {
					idx := idxper;
					isper := true;
				} else {
					idx := idxund;
					isper := false;
				}
			}
		
			# is idx is smaller than 0 at this point, then both idxper and
			# idxund are -1
			if (idx < 0) {
				if (pat.length() > 0) {
					b := [endsWith](b,pat).[ifthen](b);
				}
				break;
			}
			
			s := b.[search](pat.string(0, idx)).select(0, int(nil));
			if (isper) {
				b := b.[string](s, [-](b.semijoin(s).[length](), s));
			} else {
				b := b.[string](s, [+]([-](b.semijoin(s).[length](), s), 1));
			}
		}

        return b.mark(nil);
    }
#   ADDHELP("likeselect", "groffen", "Sep 26 2004",
#   "does SQL LIKE select which supports % and _ (also understands escapes)", "algebra");
    

#! DROPPED, arbitrary select operator
#!    PROC mil_select(bat[any::1,any::2] b, str fcn, ..any..) : bat[any::1,any::2] 
#!    {
#!        if ($0 = 3) {
#!            var val := $3;
#!            if (val.type() = b.ttype()) {    
#!                var nilval := nil.cast(val.type()); 
#!                if (fcn = "=") {
#!                    return b.select(val);
#!                } else if (fcn = "<=") {
#!                    return b.select(nilval, val);
#!                } else if (fcn = "<") {
#!                    return b.select(nilval, val, FALSE, FALSE);
#!                } else if (fcn = ">=") {
#!                    return b.select(val, nilval);
#!                } else if (fcn = ">") {
#!                    return b.select(val, nilval, FALSE, FALSE);
#!                } else if (fcn = "like") {
#!                    var bn := likeselect(b, val);
#!                    return b.semijoin(bn);
#!                }
#!            }
#!        }
#!        var bitvector := [*fcn](b,$(3..));
#!        return [ifthen](bitvector,b);
#!    }
#!
#!    PROC mil_select(bat[any::1,any::2] b, str fcn, any::2 lo, any::2 hi) : bat[any::1,any::2] 
#!    {
#!        if (or((fcn = "between"),(fcn = "[in]"))) {
#!            return b.select(lo,hi);
#!        } else if (fcn = "<in]") {
#!            return b.select(lo,hi,FALSE,TRUE);
#!        } else if (fcn = "[in>") {
#!            return b.select(lo,hi,TRUE,FALSE);
#!        } else if (fcn = "<in>") {
#!            return b.select(lo,hi,FALSE,FALSE);
#!        }
#!        var bitvector := [*fcn](b,lo,hi);
#!        return [ifthen](bitvector,b);
#!    }
#!#    ADDHELP("mil_select", "boncz", "Aug  6 1998",
#!#            "Returns all BUNs where (*fcn)(tail,,..params..).", "algebra");
#!
#!    PROC neg_select(bat[any::1,any::2] b, str fcn, ..any..) : bat[any::1,any::2] 
#!    {
#!        if ($0 = 3) {
#!            var val := $3;
#!            if (val.type() = b.ttype()) {    
#!                if (fcn = "!=") {
#!                    return b.mil_select("=", val);
#!                } else if (fcn = ">=") {
#!                    return b.mil_select("<", val);
#!                } else if (fcn = "<=") {
#!                    return b.mil_select(">", val);
#!                } else if (fcn = ">") {
#!                    return b.mil_select("<=", val);
#!                } else if (fcn = "<") {
#!                    return b.mil_select(">=", val);
#!                } else if (fcn = "like") {
#!                    var bn := likeselect(b, val);
#!                    return b.kdiff(bn);
#!                }
#!            }
#!        }
#!        var bitvector := [*fcn](b,$(3..));
#!        return [ifelse](bitvector,b);
#!    }
#!#    ADDHELP("neg_select", "boncz", "Aug  6 1998",
#!#            "Returns all BUNs where not (*fcn)(tail,,..params..)", "algebra");
#!
#!    PROC rev_select(bat[any::1,any::2] b, str fcn, any::2 val) : bat[any::1,any::2] 
#!    {
#!        if (fcn = "=") {
#!            return b.mil_select("=",val);
#!        } else if (fcn = "!=") {
#!            return b.mil_select("!=",val);
#!        } else if (fcn = ">") {
#!            return b.mil_select("<",val);
#!        } else if (fcn = "<") {
#!            return b.mil_select(">",val);
#!        } else if (fcn = "<=") {
#!            return b.mil_select(">=",val);
#!        } else if (fcn = ">=") {
#!            return b.mil_select("<=",val);
#!        }
#!        ERROR("rev_select: unknown predicate %s(%s)\n", fcn, str(val));
#!    }
#    ADDHELP("rev_select", "boncz", "Aug  6 1998",
#            "(value OP column) select rather than (column OP value)","algebra");

    PROC tunique (bat[any,any::1] b) : bat[any::1,void] {
	return b.reverse().mark(nil).kunique();
   }

    PROC sort_ht (bat[any::1,any::2] B) : bat[any::1,any::2] 
    {
        var R := new(htype(B),ttype(B),count(B));
        B.kunique().sort()@batloop {
            B.reverse().select($h).sort()@batloop {
                R.insert($t,$h);
            }
        }
        return R;
    }
#    ADDHELP("sort_ht", "manegold", "Dec 17 1998",
#            "sorts a BAT according to its head (primary) and tail values (secondary).\
#             (straight forward hack, not tuned for performance at all, just used for testing.)", "algebra");




    proc sum( bat[any,sht] b ) : sht { return sum_sht(b); }
    proc prod( bat[any,sht] b ) : sht { return prod_sht(b); }




    proc sum( bat[any,int] b ) : int { return sum_int(b); }
    proc prod( bat[any,int] b ) : int { return prod_int(b); }




    proc sum( bat[any,lng] b ) : lng { return sum_lng(b); }
    proc prod( bat[any,lng] b ) : lng { return prod_lng(b); }




    proc sum( bat[any,flt] b ) : flt { return sum_flt(b); }
    proc prod( bat[any,flt] b ) : flt { return prod_flt(b); }




    proc sum( bat[any,dbl] b ) : dbl { return sum_dbl(b); }
    proc prod( bat[any,dbl] b ) : dbl { return prod_dbl(b); }







    proc avg(BAT[any, sht] b) : dbl {
	var cnt := count(b);
        if (cnt = 0) 
	    return dbl(nil);
	return dbl(sum_lng(b))/dbl(cnt);
    }
#    ADDHELP("avg", "manegold", "May 14 2003",
#            "Gives the average of all tail values.", "algebra");




    proc avg(BAT[any, int] b) : dbl {
	var cnt := count(b);
        if (cnt = 0) 
	    return dbl(nil);
	return dbl(sum_lng(b))/dbl(cnt);
    }
#    ADDHELP("avg", "manegold", "May 14 2003",
#            "Gives the average of all tail values.", "algebra");







    proc avg(BAT[any, lng] b) : dbl {
	var cnt := count(b);
        if (cnt = 0) 
	    return dbl(nil);
	return dbl(sum(b))/dbl(cnt);
    }
#    ADDHELP("avg", "manegold", "May 14 2003",
#            "Gives the average of all tail values.", "algebra");




    proc avg(BAT[any, flt] b) : dbl {
	var cnt := count(b);
        if (cnt = 0) 
	    return dbl(nil);
	return dbl(sum(b))/dbl(cnt);
    }
#    ADDHELP("avg", "manegold", "May 14 2003",
#            "Gives the average of all tail values.", "algebra");




    proc avg(BAT[any, dbl] b) : dbl {
	var cnt := count(b);
        if (cnt = 0) 
	    return dbl(nil);
	return dbl(sum(b))/dbl(cnt);
    }
#    ADDHELP("avg", "manegold", "May 14 2003",
#            "Gives the average of all tail values.", "algebra");






    proc count_no_nil(BAT[any,any] b) : int {
		return count(b,TRUE);
    }
#    ADDHELP("count_no_nil", "manegold", "Jun 03 2003",
#    "short-cut for count(b,TRUE)", "algebra");

@-
Dummy C code
@c


