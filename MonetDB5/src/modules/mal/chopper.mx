@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@' 
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@' 
@' The Original Code is the Monet Database System.
@' 
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2004 CWI.
@' All Rights Reserved.
@' 
@' Contributor(s):
@' 		Martin Kersten <Martin.Kersten@cwi.nl>
@' 		Peter Boncz <Peter.Boncz@cwi.nl>
@' 		Niels Nes <Niels.Nes@cwi.nl>
@' 		Stefan Manegold  <Stefan.Manegold@cwi.nl>

@f chopper
@v 2.0
@a M.L.Kersten
@* BAT chopper
Processing a complex query involving access to many resources
and with a wide disparity of processing requirements is often
organized as a dataflow problem. 
That is, the operators consume chunks of information to proceed
with a small step in query evaluation.

The routines provided by the chopper module break up 
ordinary BATsa to produce a chunk of information for
further processing.

The smallest granularity is a single BUN, which can be used
to realize an iterator over the BAT elements.
For larger sized chunks, we use a BATview. It provides
read-only access to an underlying BAT. Adjusting the bounds
is cheap, once the BATview descriptor has been constructed.

[todo, they could be used in dataflow interpreter]

@+ BAT iterator

@mal
module chopper;

command batIterator(i:lng,b:bat[:any,:any]):bit 			
address CHPnextElement_lng
comment "A BATloop iterator uses an integer cursor 
	to keep track of its position in the 
	underlying table. The head and tail 
	elements can be obtained using the getHead 
	and getTail functions, which are to be 
	defined for all atomary types.";
pattern batIterator(i:lng,b:bat[:any$1,:any$2],
		h:any$1,t:any$2):bit	
address CHPnextElement
comment "Iterate over the elements of a BAT.";
pattern bunStream(b:bat[:any$1,:any$2],
		h:any$1,t:any$2):lng	
address CHPbunStream
comment "Produce a bun stream for processing.";

command hashloop(i:int,p:ptr,b:bat[:any,:any]):bit			
address CHPhashloop
comment "Iterate over the elements of a BAT 
	using its hash index.Each call we set 
	'i' to denote the next element";
@-
The head and tail values can be extracted using the cursor,
but is often more effective due to overhead involved in
location of the underlying BAT.
The generic solutions are also provided as patterns, because this
trims the number of function signatures in the symbol table.
@mal
pattern getHead(b:bat[:any$1,:any],i:lng):any$1 
address CHPgetHead
comment "return the BUN head value using the 
	cursor.";

pattern getTail(b:bat[:any,:any$1],i:lng):any$1 
address CHPgetTail
comment "return the BUN tail value using the 
	cursor.";
@-
The larger chunks produced are currently static, i.e.
their size is a parameter of the call. Dynamic chunk sizes
are interesting for time-series query processing. (See ...)
[TODO]
command batChunk(b:bat[:any$1,:any$2],size:int)
	(:bit,:bat[:any$1,:any$2]) 			
address CHPnextChunk
comment "TODO";

@+ BAT Iterator Implementation
Part of the code is copied from the V 4.3 bat.mx file.
@= getBATdescriptor
        if( BBPcheck(*@2,"@4")==0)
                return throwMessage("mal.@4","cannot access bat @2 in bbp");
        @3= (BAT*) BBPgetdesc(*@2);
        if( @3 == NULL) { *@1 = 0;
                return throwMessage("mal.@4","cannot access descriptor @2");
        }
        /* reverse descriptor should be loaded */
        if( *@2 <0){ BBPcacheit(@3); @3= BATmirror(@3); }
@-
@= hashiter
        if (b->tvarsized) {
                HASHloop@1(b, b->hhash, idx, v, p)
                        if ((i = ITERATE(v, BUNtvar(b,p), h)) < 0) return i;
        } else {
                HASHloop@1(b, b->hhash, idx, v, p)
                        if ((i = ITERATE(v, BUNtloc(b,p), h)) < 0) return i;
        } break;
@c
#include "mal.h"
#include "mal_interpreter.h"

str CHPhashloop(int *ret, lng *cursor, int *bid)
{
        BAT *b;
	(void) cursor; /* fool compiler */
        @:getBATdescriptor(ret,bid,b,nextElement)@
        return throwMessage("mal.hashloop","not yet implemented");
}
@-
Moving a value from a BUN into a value record, making proper copies
on the way.
@c
ValPtr VALinit(ValPtr d, int tpe, ptr s){
        if (ATOMextern(tpe) == 0) {
                d->vtype= tpe;
                memcpy(&d->val.ival, s, ATOMlen(tpe,s));
        } else
        if (s == 0) {
                GDKerror("VALinit:unsupported init\n");
                d->vtype= TYPE_int;
        } else if( ATOMstorage(tpe) == TYPE_str) {
                d->vtype = TYPE_str;
                d->val.sval = GDKstrdup(s);
                d->len = strLen(s);
        } else {
                d->vtype= tpe;
                d->len = ATOMlen(tpe,s);
                d->val.pval = GDKmalloc(d->len);
                memcpy(d->val.pval, s, d->len);
        }
        return d;
}
@-
In principle, we could add iterators with other range bounds.
@= nextLoop
str CHPnextElement_@1(bit *ret, @1 *cursor, int *bid)
{
	BAT *b;
	int limit;
	@:getBATdescriptor(ret,bid,b,nextElement)@
	limit=  BUNindex(b,BUNlast(b));
	if( *cursor <0)
		*cursor = BUNindex(b,BUNfirst(b));
	else	*cursor = *cursor+1;
	*ret = *cursor < limit;
	return MAL_SUCCEED;
}
@-
@c
	@:nextLoop(lng)@

str CHPnextElement(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	BAT *b;
	lng *cursor;
	bit *ret;
	int *bid;
	int limit;
	BUN p;
	ValPtr head, tail;

	if( pci->argc != 5) stream_printf(GDKout,"CHPnextElement:exception\n");
	ret = (bit *) getArgReference(stk,pci,0);
	cursor = (lng *) getArgReference(stk,pci,1);
	bid = (int *) getArgReference(stk,pci,2);
	head = &stk->stk[pci->argv[3]];
	tail = &stk->stk[pci->argv[4]];

	@:getBATdescriptor(ret,bid,b,nextElement)@
	limit=  BUNindex(b,BUNlast(b));

	if( *cursor <0)
		*cursor = BUNindex(b,BUNfirst(b));
	else	*cursor = *cursor+1;
	*ret = *cursor < limit;

	if( *ret== FALSE) return MAL_SUCCEED;
	/* get head = ... tail = ... */
	p = BUNptr(b,*cursor);
	garbageElement(head);
	garbageElement(tail); 
	VALinit( head, getArgType(mb,pci,3),BUNhead(b,p));
	VALinit( tail, getArgType(mb,pci,4),BUNtail(b,p));
stream_printf(GDKout,"%s",BUNtail(b,p));
	return MAL_SUCCEED;
}
@-
The BUN- and BAT-stream manipulate a long handle, i.e.
the destination variable. It assumes it has been set to
zero as part of runtime stack initialization. Subsequently,
it fetches a bun and returns the increment to the control
variable. If it returns zero the control variable has been reset
to zero and end of stream has been reached.

The head and tail variables may have to be set to the type
extracted from the BAT descriptor. If there occurs a type
error.
@c
str CHPbunStream(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	BAT *b;
	lng *cursor;
	bit *ret = NULL;
	int *bid;
	int limit,tp;
	BUN p;
	ValPtr head, tail;

	if( pci->argc != 4) stream_printf(GDKout,"exception in nextElement\n");
	cursor = (lng *) getArgReference(stk,pci,0);
	bid = (int *) getArgReference(stk,pci,1);
	head = &stk->stk[pci->argv[2]];
	tail = &stk->stk[pci->argv[3]];
	@:getBATdescriptor(ret,bid,b,nextElement)@
	limit=  BUNindex(b,BUNlast(b));

	if( *cursor >=limit){
		*cursor = 0;
		return MAL_SUCCEED;
	} 
	if( *cursor == 0)
		*cursor = BUNindex(b,BUNfirst(b));

/*
stream_printf(GDKout,"head type %s\n", getTypeName(getArgType(mb,pci,2)));
stream_printf(GDKout,"tail type %s\n", getTypeName(getArgType(mb,pci,3)));
*/
	/* get head = ... tail = ... */
	p = BUNptr(b,*cursor);
	garbageElement(head);
	garbageElement(tail); 
	tp = getArgType(mb,pci,2);
	if( tp == TYPE_void  && b->hseqbase!= oid_nil){
		VALinit( head, TYPE_oid, BUNhead(b,p));
		head->vtype= TYPE_void;
	} else 	VALinit( head, tp, BUNhead(b,p));
	VALinit( tail, getArgType(mb,pci,3),BUNtail(b,p));
	*cursor = *cursor+1;
	return MAL_SUCCEED;
}

@-
The fetch operations are all pretty straight forward, provided
you know the underlying type. Often it is cheaper to use
the extended BAT iterator, because then it can re-use the
BAT descriptor.
@c
str CHPgetHead(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	BAT *b;
	lng *cursor;
	int *bid;
	int limit;
	BUN p;
	ValPtr head;
	int r, *ret=&r;

	cursor = (lng *) getArgReference(stk,pci,2);
	bid = (int *) getArgReference(stk,pci,1);
	head = &stk->stk[pci->argv[0]];

	@:getBATdescriptor(ret,bid,b,nextElement)@
	limit=  BUNindex(b,BUNlast(b));
	if( *cursor<0  || *cursor >=limit) {
		return throwMessage("mal.getHead","range error");
	}

	/* get head = ... */
	p = BUNptr(b,*cursor);
	garbageElement(head);
	VALinit( head, getArgType(mb,pci,3),BUNhead(b,p));
	return MAL_SUCCEED;
}
str CHPgetTail(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	BAT *b;
	lng *cursor;
	int *bid;
	int limit;
	BUN p;
	ValPtr tail;
	int r, *ret=&r;

	cursor = (lng *) getArgReference(stk,pci,2);
	bid = (int *) getArgReference(stk,pci,1);
	tail = &stk->stk[pci->argv[0]];

	@:getBATdescriptor(ret,bid,b,nextElement)@
	limit=  BUNindex(b,BUNlast(b));
	if( *cursor<0  || *cursor >=limit) {
		return throwMessage("mal.getTail","range error");
	}

	/* get head = ... */
	p = BUNptr(b,*cursor);
	garbageElement(tail);
	VALinit( tail, getArgType(mb,pci,3),BUNtail(b,p));
	return MAL_SUCCEED;
}
