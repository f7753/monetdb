@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@' 
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@' 
@' The Original Code is the Monet Database System.
@' 
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2004 CWI.
@' All Rights Reserved.
@' 
@' Contributor(s):
@' 		Martin Kersten <Martin.Kersten@cwi.nl>
@' 		Peter Boncz <Peter.Boncz@cwi.nl>
@' 		Niels Nes <Niels.Nes@cwi.nl>
@' 		Stefan Manegold  <Stefan.Manegold@cwi.nl>

@f chopper
@v 2.0
@a M.L.Kersten
@* BAT chopper
In many low level algorithms an iterator is foten used to break a
collection into smaller pieces. Each piece is subsequently processed
by a block.

For very large BATs it may make sense to break it into chunks
and process them separately to solve a query. An iterator pair is
provided to chop a BAT into fixed size elements.
Each chunk is made available as a BATview.
It provides read-only access to an underlying BAT. Adjusting the bounds
is cheap, once the BATview descriptor has been constructed.

The smallest granularity is a single BUN, which can be used
to realize an iterator over the individual BAT elements.
For larger sized chunks, the operators return a BATview. 

All iterators require storage space to administer the
location of the next element. The chopper module uses a simple
lng variable, which also acts as a cursor for barrier statements.

The larger chunks produced are currently static, i.e.
their size is a parameter of the call. Dynamic chunk sizes
are interesting for time-series query processing. (See another module)
@+ BAT iterator

@mal
module chopper;

command newIterator(b:bat[:any$1,:any$2], size:lng)
	(:lng,:bat[:any$1,:any$2])
address CHPnewIterator
comment " Create an iterator with fixed granule size.
	  The result is a view.";

command hasMoreElements(b:bat[:any$1,:any$2], size:lng)
	(:lng, :bat[:any$1,:any$2])
address CHPhasMoreElements
comment "Produce the next chunk for processing.";

pattern newIterator(b:bat[:any$1,:any$2])
	(:lng, h:any$1, t:any$2)
address CHPbunIterator
comment "Process the buns one by one.";

pattern hasMoreElements(b:bat[:any$1,:any$2])
	(:lng, h:any$1, t:any$2)
address CHPbunHasMoreElements
comment "Produce the next bun for processing.";

@-
The head and tail values can also be extracted using the cursor.
It point to the first bun in the chunk under consideration.
It is often more effective due to use the iterator with automatic
extraction of head and tail value; the overhead involved is much less.
@mal
pattern getHead(b:bat[:any$1,:any],i:lng):any$1 
address CHPgetHead
comment "return the BUN head value using the 
	cursor.";

pattern getTail(b:bat[:any,:any$1],i:lng):any$1 
address CHPgetTail
comment "return the BUN tail value using the 
	cursor.";
@-
@{

@+ BAT Iterator Implementation
Part of the code is copied from the V 4.3 bat.mx file.
@= getBATdescriptor
if( *@2 < 0) {
	/* reverse descriptor should be explicitly loaded */
	@3=BATdescriptor(*@2); BBPunfix(*@2);
} else @3= (BAT*) BBPgetdesc(*@2);
if( @3 == NULL) { *@1 = 0;
	return throwMessage("chopper.@4", 
		"cannot access descriptor @2");
}
@-
The routine VALinit is an utility routine to move
a value from a BUN into a value record, making proper copies
on the way.
@c
#include "mal.h"
#include "mal_interpreter.h"

ValPtr VALinit(ValPtr d, int tpe, ptr s){
        if (ATOMextern(tpe) == 0) {
                d->vtype= tpe;
                memcpy(&d->val.ival, s, ATOMlen(tpe,s));
        } else
        if (s == 0) {
                GDKerror("VALinit:unsupported init\n");
                d->vtype= TYPE_int;
        } else if( ATOMstorage(tpe) == TYPE_str) {
                d->vtype = TYPE_str;
                d->val.sval = GDKstrdup(s);
                d->len = strLen(s);
        } else {
                d->vtype= tpe;
                d->len = ATOMlen(tpe,s);
                d->val.pval = GDKmalloc(d->len);
                memcpy(d->val.pval, s, d->len);
        }
        return d;
}
@-
We start with the large chunk iterator.
The definition of the control statements require the same
control variables, which means that the BATview is accessible
to determine how far to advance when the next chunk is retrieved.
The number of elements in the chunk is limited by the granule
size.
@c
str CHPnewIterator(int *res, int *vid, int *bid, int *granule){
	BAT *b, *view;
	int ret=0;
	size_t cnt;
	@:getBATdescriptor(&ret,bid,b,newIterator)@
	if( *vid ){
		@:getBATdescriptor(&ret,vid,view,newIterator)@
		/* it has the correct type, but does it also
		   refer to the same BAT */
	}
	cnt = BATcount(b);
	view= VIEWcreate_(b,TRUE);
	BBPfix(*vid=  view->batCacheid);
	printf("set bat chunk bound to %d - %d \n",
		0, MIN(cnt,(size_t) granule));
	VIEWbounds(view,(size_t) 0, MIN(cnt,(size_t) granule));
	*res = 0 ;
	return MAL_SUCCEED;
}
@-
The hasMoreElements version advances the chunk reader,
which also means that the view descriptor is alread available.
The granule size may differ in each call.
@c
str CHPhasMoreElements(int *res, int *vid, int *bid, int *granule){
	BAT *b, *view;
	int ret=0;
	size_t cnt, i;
	@:getBATdescriptor(&ret,bid,b,hasMoreElements)@
	@:getBATdescriptor(&ret,vid,view,hasMoreElements)@
	cnt = BATcount(b);
	i = *res + BATcount(view);
	printf("set bat chunk bound to %d - %d \n",
		i, i+MIN(cnt-i,(size_t) granule));
	VIEWbounds(view, i, i+MIN(cnt-i,(size_t) granule));
	*res = i;
	return MAL_SUCCEED;
}
@-
The BUN- and BAT-stream manipulate a long handle, i.e.
the destination variable. It assumes it has been set to
zero as part of runtime stack initialization. Subsequently,
it fetches a bun and returns the increment to the control
variable. If it returns zero the control variable has been reset
to zero and end of stream has been reached.
@c
str CHPbunIterator(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	BAT *b;
	lng *cursor;
	bit ret;
	int *bid;
	BUN p;
	ValPtr head, tail;

	cursor = (lng *) getArgReference(stk,pci,0);
	head = &stk->stk[pci->argv[1]];
	tail = &stk->stk[pci->argv[2]];
	bid = (int *) getArgReference(stk,pci,3);

	@:getBATdescriptor(&ret,bid,b,bunIterator)@

	if( BATcount(b) == 0) {
		*cursor = -1;
		return MAL_SUCCEED;
	}
	*cursor = BUNindex(b,BUNfirst(b));

	/* get head = ... tail = ... */
	p = BUNptr(b,*cursor);
	garbageElement(head);
	garbageElement(tail); 
	VALinit( head, getArgType(mb,pci,1),BUNhead(b,p));
	VALinit( tail, getArgType(mb,pci,2),BUNtail(b,p));
	return MAL_SUCCEED;
}
str CHPbunHasMoreElements(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	BAT *b;
	lng *cursor;
	bit ret;
	int *bid;
	int limit;
	BUN p;
	ValPtr head, tail;

	cursor = (lng *) getArgReference(stk,pci,0);
	head = &stk->stk[pci->argv[1]];
	tail = &stk->stk[pci->argv[2]];
	bid = (int *) getArgReference(stk,pci,3);

	@:getBATdescriptor(&ret,bid,b,bunHasMoreElements)@
	limit=  BUNindex(b,BUNlast(b));

	*cursor = *cursor+1;

	/* get head = ... tail = ... */
	p = BUNptr(b,*cursor);
	if( p >= BUNlast(b)){
		*cursor = -1;
		return MAL_SUCCEED;
	}
	garbageElement(head);
	garbageElement(tail); 
	VALinit( head, getArgType(mb,pci,1),BUNhead(b,p));
	VALinit( tail, getArgType(mb,pci,2),BUNtail(b,p));
	return MAL_SUCCEED;
}
@-

@-
The fetch operations are all pretty straight forward, provided
you know the underlying type. Often it is cheaper to use
the extended BAT iterator, because then it can re-use the
BAT descriptor.
@c
str CHPgetHead(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	BAT *b;
	lng *cursor;
	int *bid;
	int limit;
	BUN p;
	ValPtr head;
	int r, *ret=&r;

	cursor = (lng *) getArgReference(stk,pci,2);
	bid = (int *) getArgReference(stk,pci,1);
	head = &stk->stk[pci->argv[0]];

	@:getBATdescriptor(ret,bid,b,getHead)@
	limit=  BUNindex(b,BUNlast(b));
	if( *cursor<0  || *cursor >=limit) {
		return throwMessage("mal.getHead","range error");
	}

	/* get head = ... */
	p = BUNptr(b,*cursor);
	garbageElement(head);
	VALinit( head, getArgType(mb,pci,3),BUNhead(b,p));
	return MAL_SUCCEED;
}
str CHPgetTail(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	BAT *b;
	lng *cursor;
	int *bid;
	int limit;
	BUN p;
	ValPtr tail;
	int r, *ret=&r;

	cursor = (lng *) getArgReference(stk,pci,2);
	bid = (int *) getArgReference(stk,pci,1);
	tail = &stk->stk[pci->argv[0]];

	@:getBATdescriptor(ret,bid,b,getTail)@
	limit=  BUNindex(b,BUNlast(b));
	if( *cursor<0  || *cursor >=limit) {
		return throwMessage("mal.getTail","range error");
	}

	/* get head = ... */
	p = BUNptr(b,*cursor);
	garbageElement(tail);
	VALinit( tail, getArgType(mb,pci,3),BUNtail(b,p));
	return MAL_SUCCEED;
}
@-
@}
