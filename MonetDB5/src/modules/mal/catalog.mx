@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2003 CWI.
@' All Rights Reserved.
@'
@' Contributor(s):
@'              Martin Kersten <Martin.Kersten@cwi.nl>
@'              Peter Boncz <Peter.Boncz@cwi.nl>
@'              Niels Nes <Niels.Nes@cwi.nl>
@'              Stefan Manegold  <Stefan.Manegold@cwi.nl>
@f catalog
@t Monet Catalog
@a Martin Kersten
@v 1
@* Introduction
This document introduces a series of bats and commands that provide access
to information stored within the Monet Version 5 interpreter data structures.
In all cases, the pseudo BAT operation returns a transient BAT that
should be garbage collected after being used.

The main performance drain would be to use a pseudo BAT directly to
successively access it components. This can be avoided by first assigning
the pseudo BAT to a variable.

@mal 
module catalog;

@- MAL interpreter status
The prime scheme to inspect the MAL interpreter status is to use
the MAL debugger. However, in case of automatic exception handling
it helps to be able to obtain BAT versions of the critical information,
such as stack frame table, stack trace,
and the instruction(s) where an exception occurred.
The inspection typically occurs in the exception handling part of the
MAL block.
@mal
pattern getStackDepth():int = CATALOGStkDepth
        comment "Return the depth of the calling stack.";

pattern getStackFrame(i:int):bat[str,str] = CATALOGStkFrameN;
pattern getStackFrame():bat[str,str] = CATALOGStkFrame
	comment "Collect variable binding of current stack frame.";
#pattern getStackTrace():bat[str,str]= CATALOGStkTrace;

@+ MAL modules and scopes inspection
Each module forms a separately named scope. Scopes visible to a user
are relevant for resolving function names.

@mal
command scopeNames() : bat[void,str] = CATALOGscopeNames
        comment "Collect bat with all visible scopes" ;

command symbolNames():bat[str,str] = CATALOGsymbolNames
	comment "Create bat with the module and function pairs";
command patternNames():bat[str,str] = CATALOGpatternNames
	comment "Create bat with the module and pattern pairs";
command commandNames():bat[str,str] = CATALOGcommandNames
	comment "Create bat with the module and commands pairs";
command functionNames():bat[str,str] = CATALOGfunctionNames
	comment "Create bat with the module and function pairs";

pattern symbolDump():bat[void,str] = CATALOGsymbolDump
comment "Returns a string representation of the current function 
with typing information attached";
pattern symbolDefinition():bat[void,str] = CATALOGcurrSymbolDef
comment "Returns a string representation of the current function";
command symbolDefinition(mod:str,fcn:str):bat[int,str] = CATALOGsymbolDef
comment "Returns a string representation of a specific function";

command symbolSignature(mod:str,fcn:str):bat[str,str] = CATALOGsymbolSignature
comment "Returns the signature(s) of a function";

command symbolType(mod:str,fcn:str):bat[str,str] = CATALOGsymbolType
comment "Get the return type of a particular function";

command atomNames():bat[int,str] = CATALOGatom_names
comment "Collect a BAT with the atom names";

@- Display code
A key tool for analysis of the MAL code is being able to dump
any routine, module. For queries, it is also illustrative to display
the flow graph.
@mal
pattern showFunction(M:any,F:any,full:bit,s:str):void = CMDshowFunction1
comment "Dump the routine M.F on the file s. The flag indicates the level
of detail needed";
pattern showFunction(M:any,F:any,full:bit):void = CMDshowFunction2
comment "Dump the routine M.F on standard out. The flag indicates the level
of detail needed";
pattern showFunction(M:any,F:any):void = CMDshowFunction3
comment "Dump the routine M.F on standard out.";
pattern showFunction():void = CMDshowFunction4
comment "Dump the current routine on standard out.";


@+ Implementation
@h
/*
 * The contents of this file are subject to the Monet Public
 * License Version 1.1 (the "License"); you may not use this file
 * except in compliance with the License. You may obtain a copy of
 * the License at 
 * http://www.monetsolutions.com/Download/Licensing/MonetPL-1.1.html
 * 
 * Software distributed under the License is distributed on an "AS
 * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
 * implied. See the License for the specific language governing
 * rights and limitations under the License.
 * 
 * The Original Code is the Monet Database System.
 * 
 * The Initial Developer of the Original Code is CWI.
 * Portions created by CWI are Copyright (C) 1997-2002 CWI.  
 * All Rights Reserved.
 * 
 * Contributor(s): Martin Kersten <Martin.Kersten@cwi.nl>
 *		   Peter Boncz <Peter.Boncz@cwi.nl>
 *		   Niels Nes <Niels.Nes@cwi.nl>
 *		   Stefan Manegold  <Stefan.Manegold@cwi.nl>
 */
#ifdef _CATALOG_H
#endif /* _CATALOG_H*/
@c
#include <stdarg.h>
#include <time.h>
#include "gdk.h"
#include "mal_resolve.h"
#include "mal_client.h"
#include "mal_function.h"

@+ Variables and stack information
The variable information can be turned into a BAT for inspection as well.

@= Pseudo
        if (BBPindex("view_@1_@2") <= 0)
                BATname(b, "@2");
        BATroles(b,"@1","@2");
        BATmode(b,TRANSIENT);
        BATfakeCommit(b);
        *ret = b->batCacheid;

@c

str CATALOGStkDepth(MalBlkPtr m, MalStkPtr s, InstrPtr p)
{       int i=0, *ret= (int*) getArgReference(s,p,0);
        while(s!= 0){
                i++;
                s= s->up;
        }
        *ret= i;
        return MAL_SUCCEED;
}

str CATALOGgetFrame(BAT *b, MalBlkPtr mb, MalStkPtr s,int depth){
	ValPtr v;
	int i;
	char *buf=0;
	if(depth> 0) return CATALOGgetFrame(b,mb,s->up,depth-1);
	if( s!= 0)
	for(i=0 ; i<s->stktop ; i++,v++){
		v= &s->stk[i];
		ATOMformat(v->vtype, VALget(v), &buf);
		BUNins(b,getVarName(mb,i),buf);
	}
	return MAL_SUCCEED;
}
str CATALOGStkFrame(MalBlkPtr m, MalStkPtr s, InstrPtr p)
{	int *ret= (int*) getArgReference(s,p,0);
	BAT *b = BATnew(TYPE_str, TYPE_str, 256);
	if (b == 0) return throwMessage("catalog.stkFrame", "failed to create BAT");
	@:Pseudo(stk,frame)@
	return CATALOGgetFrame(b,m,s,0);
}
str CATALOGStkFrameN(MalBlkPtr m, MalStkPtr s, InstrPtr p)
{	int n, *ret= (int*) getArgReference(s,p,0);
	BAT *b = BATnew(TYPE_str, TYPE_str, 256);

	n= *(int*) getArgReference(s,p,1);
	if(n<0) return throwMessage("catalog.stkFrame", "illegal depth.");
	@:Pseudo(stk,frame)@
	return CATALOGgetFrame(b,m,s,n-1);
}
@+ Symbol table 
Mal symbol table and environment analysis.
@c

str CATALOGscopeNames(int *ret){
	Client c;
	Scope s;
	int i=0;
	BAT *b = BATnew(TYPE_void, TYPE_str, 256);

        if (b == 0) return throwMessage("catalog.scopeNames", "failed to create BAT");
	c= getClient();

	for(s=c->nspace; s; s= s->outer,i++)
		BUNins(b,&int_nil,s->name);

	@:Pseudo(scope,names)@
	return MAL_SUCCEED;
}
str CATALOGsymbolFind(int *ret,int kind)
{	Client c;
	Scope s;
	Symbol t;
	int i;
	BAT *b = BATnew(TYPE_str, TYPE_str, 256);

        if (b == 0) return throwMessage("catalog.symbolFind", "failed to create BAT");
	c= getClient();
	s= c->nspace;
	while(s){
		for(i=0;s && i<MAXSCOPE;i++)
		if( s->subscope[i]){
			for(t= s->subscope[i];t;t=t->peer){
			InstrPtr sig= getSignature(t);
			if( kind && kind != sig->token) continue;
			BUNins(b,sig->modname,sig->fcnname);
			}
		}
		s= s->outer;
	}
	@:Pseudo(symbol,name)@
	return MAL_SUCCEED;
}
str CATALOGsymbolNames(int *ret){ return CATALOGsymbolFind(ret,0); }
str CATALOGfunctionNames(int *ret){ return CATALOGsymbolFind(ret,FUNCTIONsymbol); }
str CATALOGpatternNames(int *ret){ return CATALOGsymbolFind(ret,PATTERNsymbol); }
str CATALOGcommandNames(int *ret){ return CATALOGsymbolFind(ret,COMMANDsymbol); }

str CATALOGsymbolDef(int *ret, str *nme, str *fcn)
{	Symbol s;
	BAT *b = BATnew(TYPE_int, TYPE_str, 256);
        if(b == 0) return throwMessage("catalog.symbolDefinition", "failed to create BAT");
	
	s= findSymbol(*nme,*fcn);
	while(s){
		int i;
		str ps;
		for(i=0;i<s->def->stop;i++){
			ps= instruction2str(s->def, getInstrPtr(s->def,i),0);
			BUNins(b,&i,ps);
			GDKfree(ps);
		}
		s= s->peer;
	}
	@:Pseudo(fcn,stmt)@
	return MAL_SUCCEED;
}
str CATALOGsymbolDump(MalBlkPtr m, MalStkPtr stk, InstrPtr p)
{	int i, *ret= (int*)getArgReference(stk,p,0);
	str ps, cm;
	BAT *b = BATnew(TYPE_void, TYPE_str, 256);
        if(b == 0) return throwMessage("catalog.symbolDump", "failed to create BAT");
	
	for(i=0;i<m->stop;i++){
		ps= instruction2str(m, getInstrPtr(m,i),1);
		BUNins(b,&int_nil,ps);
		GDKfree(ps);
	}
	@:Pseudo(fcn,stmt)@
	return MAL_SUCCEED;
}
str CATALOGcurrSymbolDef(MalBlkPtr m, MalStkPtr stk, InstrPtr p)
{	int i, *ret= (int*)getArgReference(stk,p,0);
	str ps, cm;
	BAT *b = BATnew(TYPE_void, TYPE_str, 256);
        if(b == 0) return throwMessage("catalog.symbolDefinition", "failed to create BAT");
	
	for(i=0;i<m->stop;i++){
		ps= instruction2str(m, getInstrPtr(m,i),0);
		BUNins(b,&int_nil,ps);
		GDKfree(ps);
	}
	@:Pseudo(fcn,stmt)@
	return MAL_SUCCEED;
}
str CATALOGsymbolSignature(int *ret, str *mod, str *fcn)
{	Symbol s;
	str msg;
	str ps,cm;
	BAT *b = BATnew(TYPE_str, TYPE_str, 12);
        if (b == 0) return throwMessage("catalog.symbolSignature", "failed to create BAT");

	s= findSymbol(*mod,*fcn);
	while(s!= NULL){
		msg= s->def->help;
		if( msg && idcmp(s->name,*fcn)==0) {
			ps= instruction2str(s->def, getSignature(s),0);
			BUNins(b,s->name,ps);
			GDKfree(ps);
		}
		s= s->peer;
	}

	@:Pseudo(fcn,sig)@
	return MAL_SUCCEED;
}
str CATALOGsymbolType(int *ret, str *mod, str *fcn) 
{	Symbol s;
	BAT *b = BATnew(TYPE_str, TYPE_str, 256);
        if (b == 0) return throwMessage("catalog.symbolType", "failed to create BAT");

	s= findSymbol(*mod,*fcn);
	while(s!= NULL){
		if( idcmp(s->name,*fcn)==0) {
			str t=malTypeName(getDestType(s->def,getSignature(s)));
			BUNins(b,s->name,t);
			GDKfree(t);
		}
		s= s->peer;
	}
	@:Pseudo(fcn,type)@
	return MAL_SUCCEED;
}

str CATALOGatom_names(int *ret)
{	int i;
	BAT *b = BATnew(TYPE_int, TYPE_str, 256);
        if (b == 0) return throwMessage("catalog.atomNames", "failed to create BAT");

	for(i=0;i<GDKatomcnt;i++) BUNins(b,&i,ATOMname(i));

	@:Pseudo(atom,name)@
	return MAL_SUCCEED;
}
@+ Display routines
@= getFunction
str     modnme= getArgName(mb,p,1);
str     fcnnme= getArgName(mb,p,2);
Scope  scope=NULL;
Symbol s= NULL;
Client c= getClient();

scope = findScope(c->nspace,modnme);
if( scope)
	s= findSymbolInScope(scope,fcnnme);

if( s == NULL)
	GDKerror("@1:Could not find %s.%s\n",modnme,fcnnme);

@c
void CMDshowFunction(MalBlkPtr m, lng flg, stream *f) {
	printFunction(f,m,flg);
}
str CMDshowFunction1(MalBlkPtr mb, MalStkPtr stk, InstrPtr p){
	lng flg= *(lng*) getArgValue(stk,p,3);
	str fname= (str) getArgValue(stk,p,4);
	@:getFunction(showFunction)@
	else { 
		CMDshowFunction(s->def,LIST_MAL_INSTR,GDKout);
	}
	return NULL;
}
str CMDshowFunction2(MalBlkPtr mb, MalStkPtr stk, InstrPtr p){
	lng flg= *(lng*) getArgValue(stk,p,3);
	@:getFunction(showFunction)@
	else { 
		CMDshowFunction(s->def,LIST_MAL_INSTR,GDKout);
	}
	return NULL;
}
str CMDshowFunction3(MalBlkPtr mb, MalStkPtr stk, InstrPtr p){
	@:getFunction(showFunction)@
	else { 
		CMDshowFunction(s->def,(lng) FALSE,GDKout);
	}
	return NULL;
}
str CMDshowFunction4(MalBlkPtr mb, MalStkPtr stk, InstrPtr p){
	CMDshowFunction(mb,(lng) FALSE,GDKout);
	return NULL;
}
