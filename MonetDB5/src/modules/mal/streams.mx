@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2004 CWI.
@' All Rights Reserved.

@f streams
@a Niels Nes
@* An simple interface to streams
All file IO is funneled through the stream library, which
guarantees cross-platform capabilities.
Several protocols are provided, e.g. it can be used to 
open 'non compressed, gzipped, bz2zipped' data files. 
It encapsulates the corresponding library managed in
.../stream.

@mal
atom stream:ptr;

command openReadBytes( filename:str ) :stream
address stream_open_rstream
comment "open a file stream for reading";
command openWriteBytes( filename:str ) :stream
address stream_open_wstream
comment "open a file stream for writing";

command openRead( filename:str ) :stream
address stream_open_rastream
comment "open ascii file stream for reading";
command openWrite( filename:str ) :stream
address stream_open_wastream
comment "open ascii file stream for writing";

command socketReadBytes(skt:int,name:str):stream
address stream_socket_rstream
comment "open a socket stream for reading";
command socketWriteBytes(skt:int,name:str):stream
address stream_socket_wstream
comment "open a socket stream for writing";
command socketRead(skt:int,name:str):stream
address stream_socket_rastream
comment "open ascii socket stream for reading";
command socketWrite(skt:int,name:str):stream
address stream_socket_wastream
comment "open ascii socket stream for writing";

command blocked( s:stream ) :stream
address open_block_stream
comment "open a block based stream";

command writeStr( s:stream, data:str ):void
address stream_write_string
comment "write data on the stream";
command writeInt( s:stream, data:int ):void
address stream_write_int
comment "write data on the stream";
command readStr( s:stream):str
address stream_read_str
comment "read string data from the stream";
command readInt( s:stream):int
address stream_read_int
comment "read integer data from the stream";


command flush( s:stream )
address stream_flush_stream
comment "flush the stream";

command close( s:stream )
address stream_close_stream
comment "close and destroy the stream s";
@-
@{
@h
#ifndef _STREAMS_H_
#define _STREAMS_H_

#include "gdk.h"
#include <blob.h>
#include <io.h>

#endif /*_STREAMS_H_*/
@c
#include "streams.h"
#include "mal_exception.h"


@-
@= open_stream
str stream_open_@1( stream *S, str filename ){
	stream *s;

	if ((s = open_@1( filename )) == NULL || stream_errnr(s)){
		if (s) stream_destroy(s);
		return throwMessage("stream","Could not open file\n");
 	} else {
		*(stream**)S = s;
 		return MAL_SUCCEED;
 	}
 }
@c
@:open_stream(rstream)@
@:open_stream(wstream)@
@:open_stream(rastream)@
@:open_stream(wastream)@

@-
@= open_socket
str stream_socket_@1( stream *S, int *socket, str name ){
	stream *s;

	if ((s = socket_@1( *socket, name )) == NULL || stream_errnr(s)){
		if (s) stream_destroy(s);
		return throwMessage("streams.socket_rstream","failed");
	} else {
		*(stream**)S = s;
		return MAL_SUCCEED;
 	}
 }
@c
@:open_socket(rstream)@
@:open_socket(wstream)@
@:open_socket(rastream)@
@:open_socket(wastream)@

str stream_write_string(int *ret, stream *S, str *data ){
	stream *s = *(stream**)S;
	(void) ret;
	if( S == NULL)
		return throwMessage("streams.writeStr","failed");
	stream_write( s, *data, 1, strlen(*data));
	return MAL_SUCCEED;
}
str stream_write_int(int *ret,  stream *S, int *data ){
	stream *s = *(stream**)S;
	(void) ret;
	if( S == NULL)
		return throwMessage("streams.writeInt","failed");
	stream_writeInt(s,*data);
	return MAL_SUCCEED;
}
#define CHUNK (64*1024)
str stream_read_str( str *res,stream *S){
	stream *s = *(stream**)S;
        size_t len = 0;
        size_t size = CHUNK + 1;
        char *buf, *start;

	if( S == NULL)
		return throwMessage("streams.readStr","failed");
        buf = GDKmalloc(size); start = buf;
        while ((len = stream_read(s, start, 1, CHUNK)) == CHUNK){
                size += CHUNK;
                buf = GDKrealloc(buf, size);
                start = buf + size - CHUNK - 1;
                *start = '\0';
        }
        start += len;
        *start = '\0';
        *res = buf;
	return MAL_SUCCEED;
}
str stream_read_int( int *data, stream *S){
	stream *s = *(stream**)S;
	if( S == NULL)
		return throwMessage("streams.readInt","failed");
	stream_readInt(s,data);
	return MAL_SUCCEED;
}

str stream_flush_stream(int *ret, stream *S ){
	stream *s = *(stream**)S;
	if( S == NULL)
		return throwMessage("streams.flush","failed");
	stream_flush( s );
	(void) ret;
	return MAL_SUCCEED;
}

str stream_close_stream(int *ret, stream *S ){
	stream *s = *(stream**)S;
	if( S == NULL)
		return throwMessage("streams.close","failed");
	stream_close( s );
	stream_destroy( s );
	(void) ret;
	return MAL_SUCCEED;
}

str open_block_stream( stream *S, stream *is ){
	if ((*(stream**)S = block_stream( *(stream**)is )) == NULL)
		return throwMessage("streams.block_stream","failed");
	else {
		return MAL_SUCCEED;
	}
}
@}
