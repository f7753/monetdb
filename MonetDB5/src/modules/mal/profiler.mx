@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@' 
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@' 
@' The Original Code is the Monet Database System.
@' 
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2004 CWI.
@' All Rights Reserved.

@f profiler
@a Martin Kersten
@* Performance Monitor
A key issue in developing fast programs using the Monet database
back-end requires a keen eye on where performance is lost.
Although performance tracking and measurements are highly
application dependent, a simple to use tool makes life
a lot easier.

Inspired by programs like xosview and xload, we
provide a simple Java application that reads a stream
of log events generated by the Monet kernel upon request.

Activation of the performance monitor has a global effect,
i.e. all concurrent actions on the kernel are traced,
but the events are only sent to the client initiated 
the profiler thread.

@+ Monet Event Logger
The Monet Event Logger generates records of each event of
interest indicated by a log filter, i.e. a pattern over
module and function names. 

The log record contents is derived from counters being
(de-)activated. 
A complete list of recognized counters is shown below.

@verbatim
# thread and time since start
profiler.activate("tick");	
# cpu time in nano-seconds 
profiler.activate("cpu");	
# memory allocation information
profiler.activate("memory");
# IO activity
profiler.activate("io"); 
# Module,function,program counter
profiler.activate("pc"); 
# actual MAL instruction executed
profiler.activate("statement");	
@end verbatim
@-
The profiler event can be handled in several ways.
The default strategy is to ship the event record immediately over a stream
to a performance monitor, eg. Mknife.
An alternative strategy is preparation of off-line performance analysis.
For this case the event record is turned into a XML structure and
sent over the stream (most likely linked with a file)
To reduce the  interference of performance measurement with
the experiments, the user can use an event cache, which is
emptied explicitly upon need.
@mal
module profiler;

command activate(name:str)
address CMDactivateProfiler
comment "Make the specified counter active.";

command deactivate(name:str)
address CMDdeactivateProfiler
comment "Deactivate the counter";

command openStream():void 
address openProfilerStream
comment "Sent the events to output stream";
command openStream(fnme:str)
address CMDsetProfilerStream
comment "Send the log events to a file ";
command closeStream():void 
address closeProfilerStream
comment "Stop sending the event records";

command setAll()
address CMDsetAllProfiler
comment "Short cut for setFilter(*,*).";
command setNone()
address CMDsetNoneProfiler
comment "Short cut for clrFilter(*,*).";

command setFilter(mod:str,fcn:str)
address CMDsetFilterProfiler
comment "Generate an event record for all 
	function calls that satisfy the regular 
	expression mod.fcn. A wildcard (*) can 
	be used as name to identify all";

command clrFilter(mod:str,fcn:str)
address CMDclrFilterProfiler
comment "Clear the performance trace bit 
	of the selected functions.";

command setStartPoint(mod:str,fcn:str)
address CMDstartPointProfiler
comment "Start performance tracing at mod.fcn";
command setEndPoint(mod:str,fcn:str)
address CMDendPointProfiler
comment "End performance tracing after mod.fcn";

command start()
address CMDstartProfiler
comment "Start performance tracing";

command stop()
address CMDstopProfiler
comment "Stop performance tracing";

@- 
If Monet is compiled with the profiler option, then it is
possible to analyse the timeings obtained in the context of
a database query itself.
For each instruction executed, the profiler keeps track of the number of calls
and the total time spent in microseconds.
These statistics are accessed on a <module,function> basis.

@mal
command getCnt(mod:str,fcn:str):bat[:int,:int] 
address CMDprofCntModFcn
comment "Returns the counts measured while 
	profiling the MAL interpreter";

command getTime(mod:str,fcn:str):bat[:int,:int] 
address CMDprofTime
comment "Returns the total microseconds measured 
	while profiling the MAL interpreter";

@{
@-
@+ Implementation
The commands merely encapsulate the functionality provided by
mal_profiler, which should be explicitly compiled with the kernel, because
its generates a noticable overhead.
@h
#include "gdk.h"
#include <stdarg.h>
#include <time.h>
#include "mal_stack.h"
#include "mal_resolve.h"
#include "mal_exception.h"
#include "mal_client.h"
#include "mal_profiler.h"

@-
Using the Monet Performance Profiler is constrained by the mal_profiler.
@= checkProfiler
#ifndef MALprofiler
	return throwMessage("profiler.@1:Monet not compiled for performance monitoring");
#endif
@c
#include "profiler.h"

str CMDactivateProfiler(int *res, str *name){
	(void) res; /* fool compiler */
	@:checkProfiler(activate)@
	activateCounter(*name);
	return MAL_SUCCEED;
}

str CMDdeactivateProfiler(int *res, str *name){
	(void) res; /* fool compiler */
	@:checkProfiler(deactivate)@
	deactivateCounter(*name);
	return MAL_SUCCEED;
}

str CMDsetFilterProfiler(int *res, str *mod, str *fcn){
	(void) res; /* fool compiler */
	@:checkProfiler(setFilter)@
	setFilter(getClient()->nspace, *mod, *fcn);
	return MAL_SUCCEED;
}

str CMDsetAllProfiler(int *res){
	str x = GDKstrdup("*");
	str y = GDKstrdup("*");
	(void) res; /* fool compiler */
	return CMDsetFilterProfiler(res, &x, &y);
}
str CMDclrFilterProfiler(int *res, str *mod, str *fcn){
	(void) res; /* fool compiler */
	@:checkProfiler(clrFilter)@
	resetFilter(getClient()->nspace , *mod, *fcn);
	return MAL_SUCCEED;
}
str CMDsetNoneProfiler(int *res){
	str x = GDKstrdup("");
	str y = GDKstrdup("");
	(void) res; /* fool compiler */
	return CMDclrFilterProfiler(res, &x, &y);
}

str CMDsetProfilerStream(int *res, str *fnme){
	(void) res; /* fool compiler */
	@:checkProfiler(setProfiler)@
	setLogFile(getClient()->nspace, *fnme);
	return MAL_SUCCEED;
}

str CMDstartPointProfiler(int *res, str *mod, str *fcn){
	(void) res; /* fool compiler */
	@:checkProfiler(startPoint)@
	setStartPoint(getClient()->nspace, *mod, *fcn);
	return MAL_SUCCEED;
}

str CMDendPointProfiler(int *res, str *mod, str *fcn){
	(void) res; /* fool compiler */
	@:checkProfiler(endPoint)@
	setStartPoint(getClient()->nspace, *mod, *fcn);
	return MAL_SUCCEED;
}

str CMDstopProfiler(int *res){
	Client c= getClient();
	(void) res; /* fool compiler */
	@:checkProfiler(stop)@
	stream_printf(c->fdout,"# Performance profiling stopped\n");
	stopProfiling();
	return MAL_SUCCEED;
}
str CMDstartProfiler(int *res){
	Client c= getClient();
	(void) res; /* fool compiler */
	@:checkProfiler(start)@
	stream_printf(c->fdout,"# Start performance profiling\n");
	startProfiling();
	return MAL_SUCCEED;
}

str CMDprofCntModFcn(int *ret, str *mod, str *fcn){
	*ret= 0;
	(void) mod; (void) fcn; /* fool compiler */
	return throwMessage("profiler.getCnt", "not yet implemented");
}
str CMDprofTime(int *ret, str *mod, str *fcn){
	*ret= 0;
	(void) mod; (void) fcn; /* fool compiler */
	return throwMessage("profiler.getTime", "not yet implemented");
}
@}
