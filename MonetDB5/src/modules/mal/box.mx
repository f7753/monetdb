@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2003 CWI.
@' All Rights Reserved.
@'
@' Contributor(s):
@'              Martin Kersten <Martin.Kersten@cwi.nl>
@'              Peter Boncz <Peter.Boncz@cwi.nl>
@'              Niels Nes <Niels.Nes@cwi.nl>
@'              Stefan Manegold  <Stefan.Manegold@cwi.nl>

@f box
@t MAL constant management
@a Martin Kersten
@v 0.1
@* Constant space management

This module shows the behavior of a simple box of objects.
Objects are stored into the box using deposit() and taken
out with take(). Once you are done, elements can be
removed by name or reference using discard().

A box should be opened before being used. It is typically used
to set-up the list of current users and to perform authorization.
@mal
module box;

pattern open(bname:str):void= BOXopen
comment "Locate the boxant box and open it ";

pattern close(bname:str):void= BOXclose
comment "Close the box ";

pattern destroy(bname:str):void= BOXdestroy
comment "Destroy the box ";

pattern take(bname:str,name:str):any = BOXtake
comment "Locates the typed value in the boxant box";

pattern deposit(bname:str,name:str,v:any):void = BOXdeposit
comment "Enter a new value into the box";

pattern releaseAll(bname:str,):void = BOXreleaseAll
comment "Release all objects for this client";

pattern release(bname:str,name:str,val:any):void = BOXrelease
comment "Release the BAT from the client pool";

pattern release(bname:str,name:str):void = BOXrelease
comment "Release the BAT from the client pool";

pattern toString(bname:str,name:str):str = BOXtoString
comment "Get the string representation of the i-th element in the box";

pattern discard(bname:str,name:str):void = BOXdiscard
comment "Release the BAT from the client pool";

pattern iterator(nme:str):lng = BOXiterator
comment "Locates the next element in the box";
@-
@+ Dummy code 
@h
#ifndef _ITERATOR_H
#define _ITERATOR_H
#endif /* _ITERATOR_H*/
@c
#include "mal_function.h"
#include "mal_box.h"

str BOXopen(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	str name;
	name = (str) getArgValue(stk,pci,1);
	if(openBox(name) != 0) return MAL_SUCCEED;
	return throwMessage("box.open","failed to open box");
}

str BOXclose(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	str name;
	name = (str) getArgValue(stk,pci,1);
	if( closeBox(name /*,FALSE*//*Stefan: unused!*/) ==0) return MAL_SUCCEED;
	return throwMessage("box.close","failed to close box");
}
str BOXdestroy(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	Box box;
	str name;
	@:OpenBox(BOXdestroy)@
	destroyBox(name);
	return MAL_SUCCEED;
}
@-
Access to a box calls for resolving the first parameter
to a named box.
@= OpenBox
	name = (str) getArgValue(stk,pci,1);
	box= findBox(name);
	if( box ==0) 
	return throwMessage("box.@1","box is not open");
@-
@c
str BOXdeposit(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	str name;
	ValPtr v;
	Box box;

	@:OpenBox(BOXdeposit)@
	name = (str) getArgValue(stk,pci,2);
	v = &stk->stk[pci->argv[3]];
	if(depositBox(box,name,v) )
		return throwException(MALEXCEPTION,"box.deposit",
			"failed to deposit '%s' into box",name);
	return MAL_SUCCEED;
}

str BOXtake(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	str name;
	Box box;
	ValPtr v;

	@:OpenBox(BOXtake)@
	name = (str) getArgValue(stk,pci,2);
	v = &stk->stk[pci->argv[0]];
	if(takeBox(box,name,v))
		return throwException(MALEXCEPTION,"box.take",
			"failed to take '%s' from box",name);
	return MAL_SUCCEED;
}

str BOXrelease(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	str name;
	Box box;

	@:OpenBox(BOXrelease)@
	name = (str) getArgValue(stk,pci,2);
	releaseBox(box,name);
	return MAL_SUCCEED;
}

str BOXreleaseAll(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	str name;
	Box box;
	@:OpenBox(BOXreleaseAll)@
	releaseAllBox(box);
	return MAL_SUCCEED;
}

str BOXdiscard(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	str name;
	Box box;

	@:OpenBox(BOXdiscard)@
	name = (str) getArgValue(stk,pci,2);
	if( discardBox(box,name) )
		return throwException(MALEXCEPTION,"box.discard",
			"failed to discard '%s' from box '%s'",
			name, box->name);
	return MAL_SUCCEED;
}

str BOXtoString(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	str name;
	Box box;
	@:OpenBox(BOXtoString)@
	return MAL_SUCCEED;
}

str BOXiterator(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	str name;
        Box box;
        lng *cursor;
        ValPtr v;

        @:OpenBox(BOXiterator)@
        cursor= (lng*) getArgValue(stk,pci,0);
        v= &stk->stk[pci->argv[2]];
        nextBoxElement(box, cursor, v);
	return MAL_SUCCEED;
}
