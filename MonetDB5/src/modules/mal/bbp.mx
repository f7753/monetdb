@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2003 CWI.
@' All Rights Reserved.
@'
@' Contributor(s):
@'              Martin Kersten <Martin.Kersten@cwi.nl>
@'              Peter Boncz <Peter.Boncz@cwi.nl>
@'              Niels Nes <Niels.Nes@cwi.nl>
@'              Stefan Manegold  <Stefan.Manegold@cwi.nl>

@f bbp
@t BAT Buffer Pool
@v 2.0
@a M.L.Kersten, P. Boncz
@* BAT Buffer Pool
The BBP module implements a box interface over the BAT buffer pool.
Furthermore, it provides some functionality for bats in the context
of the Mal interpreter. (The kernel does not know anything about
the runtime context.)

The two predominant approaches to use bbp is to access the BBP
with either bind() or take(). The former merely maps the BAT name
to the object in the bat buffer pool. (In Monet 4 this binding
was implicit in the name resolution scheme)
No guarantees are given on stability and isolation.

A more controlled scheme is to deposit(),take(), release()
and discard() elements.
Any BAT B created can be brought under this scheme with the name N.
The association N->B is only maintained in the box administration
and not reflected in the BAT descriptor.
In particular, taking a  BATobject out of the box leads to a private 
copy to isolate the user from concurrent updates on the underlying store.
Upon releasing it, the updates are merged with the master copy [todo].

The BBP module does not impose any authorization, replication, localization,
or fragmentation policy. 
The default location of the BAT storage is .../dbfarm/bat, which maps
to a directory on the local file system. 

@+ The Box Interface
@mal
module bbp
comment "The bbp module implements the box abstraction over the Bat buffer pool.
It should (future) provide an adequate transaction and versioning support.
It provides a collection of views to inspect the buffer pool status.";

command open():void= CMDbbpopen
comment "Locate the bbp box and open it.";

command close():void= CMDbbpclose
comment "Close the bbp box.";

command destroy():void= CMDbbpdestroy
comment "Destroy the box, which is forbidden for casual users";

pattern take(name:str) : bat[any,any] = CMDbbptake
comment "Load a particular bat from disk and make a private copy";

pattern deposit(name:str,v:bat[any,any]):void = CMDbbpdeposit
comment "Enter a new bat into the bbp box.";

pattern releaseAll():void = CMDbbpreleaseAll
comment "Commit updates and release all bats for this client";

pattern release(name:str,val:bat[any,any]):void = CMDbbprelease
comment "Commit updates and release this BAT.";

pattern toString(name:str):str = CMDbbptoString
comment "Get the string representation of an element in the box";

pattern discard(name:str):void = CMDbbpdiscard
comment "Remove the BAT from the box";

pattern iterator(nme:str):lng = CMDbbpiterator
comment "Locates the next element in the bbp box";

pattern prelude():void = CMDbbpprelude
comment "Initialize the bbp box";

pattern bind(name:str,loc:str):bat = CMDbbpbindDefinition
comment "Relate a logical name to a physical BAT in the buffer pool.";

pattern bind(name:str):bat = CMDbbpbind
comment "Locate the BAT using its logical name, but without
making a local copy. No guarantees
are given for consistent reads.";

pattern getObjects(): bat[int,str] = CMDbbpGetObjects
	comment "View to map a BAT id into its box name";

@+ BAT declarations
A pattern block may be required to make the proper translation to
the BAT library.
@mal

pattern new(ht:any::1, tt:any::2) : bat[any::1,any::2] = CMDBATnew
comment "Creates a new empty transient BAT, with head- and tail-types as indicated.";

pattern new(ht:any::1, tt:any::2, size:int) : bat[any::1,any::2] = CMDBATnew
comment "Creates a new empty BAT, directly allocating for 'size' elements.";

pattern new(ht:any::1, tt:any::2, size:lng) : bat[any::1,any::2] = CMDBATnew
comment "Creates a new empty BAT, directly allocating for 'size' elements.";

@+ Algebraic operators
Those that rely on knowledge of the runtime environment
@mal
command project(b:bat[any::1,any]):bat[any::1,void]= CMDprojectNil
comment "Extract the head of a BAT.";
pattern project( b:bat[any::1,any], val:any::2) :
			bat[any::1, any::2] = CMDproject
comment "Fill the tail column with a constant value.";
@+ BAT iterator

@mal
command batIterator(i:lng,b:bat[any,any]):bit = CMDnextElement_lng
comment "A BATloop iterator uses an integer cursor to keep track of its
        position in the underlying table.
        The head and tail elements can be obtained using the getHead and
        getTail functions, which are to be defined for all atomary types.";

pattern batIterator(i:lng,b:bat[any::1,any::2],h:any::1,t:any::2):bit
        = CMDnextElement
comment "Iterate over the elements of a BAT using a cursor.";

pattern bunStream(b:bat[any::1,any::2],h:any::1,t:any::2):lng
         = CMDbunStream
comment "Produce a stream of buns for subsequent processing.";

command hashloop(i:int, p:ptr, b:bat[any,any]):bit = CMDhashloop
comment "Iterate over the elements of a BAT using its hash index.
Each call we set 'i' to denote the next element";
@-
The head and tail values can be extracted using the cursor,
but is often more effective due to overhead involved in
location of the underlying BAT.
The generic solutions are also provided as patterns, because this
trims the number of function signatures in the symbol table.
@mal
pattern getHead(b:bat[any::1,any],i:lng):any::1 = CMDgetHead
comment "return the BUN head value using the cursor.";

pattern getTail(b:bat[any,any::1],i:lng):any::1 = CMDgetTail
comment "return the BUN tail value using the cursor.";

@- BAT buffer pool
The following list of operations permits inspection of the
buffer pool
@mal
command getHeadType():bat[int,str]= CMDbbpHeadType
	comment "View to map a BAT id into its head type";
command getTailType():bat[int,str]= CMDbbpTailType
	comment "View to map a BAT id into its tail type";
command getNames(): bat[int,str] = CMDbbpNames
	comment "View to map a BAT id into its bbp name";
command getCount(): bat[int,lng] = CMDbbpCount
	comment "View to map a BAT id into its cardinality";
command getRefcnt(): bat[int,int] = CMDbbpRefcnt
	comment "View to map a BAT id into its reference count";
command getLocation(): bat[int,str] = CMDbbpLocation
	comment "View to map a BAT id into its disk location";
command getHeat(): bat[int,int] = CMDbbpHeat
	comment "View to map a BAT id into its heat";
command getDirty(): bat[int,str] = CMDbbpDirty
	comment "View to map a BAT id into its dirty/diffs/clean status";
command getStatus(): bat[int,str] = CMDbbpStatus
	comment "View to map a BAT id into its disk/load status";
command getKind(): bat[int,str] = CMDbbpKind
	comment "View to map a BAT id into its persistency status";

@+ Implementation section
In most cases we pass a BAT identifier, which should be unified
with a BAT descriptor. Upon failure we can simply abort the function.

@= getBATdescriptor
        if( BBPcheck(*@2,"@4")==0) 
		return throwMessage("bbp.@4","cannot access bat @2 in bbp");
        @3=(BAT*) BBPgetdesc(*@2);
        if( @3 == NULL) { *@1 = 0;  
		return throwMessage("bbp.@4","cannot access descriptor @2");
        }
	if( *@2 <0) @3= BATmirror(@3);
@= chkIdentifier
	/* generate exception if string is not an identifier */
        if( isIdentifier(@1))
                return throwMessage( "bbp.@2","identifier expected");

@h

@c
#include "bbp.h"
#include "mal_box.h"
#include "mal_client.h"
#include "mal.h"

str CMDbbpprelude(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	Box box;
	ValRecord vr;
	if( openBox("bbp")) return MAL_SUCCEED;
	return throwMessage( "bbp.prelude","failed to open box");
}
@- Operator implementation
@c
str CMDbbpopen(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	if(openBox("bbp") != 0) return MAL_SUCCEED;
	return throwMessage( "bbp.open","failed to open box");
}

str CMDbbpclose(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	if( closeBox("bbp",TRUE) ==0) return MAL_SUCCEED;
	return throwMessage( "bbp.close","failed to close 'bbp' box");
}
str CMDbbpdestroy(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	Box box;
	@:OpenBox(destroy)@
	if( getClient() != mal_clients)
	return throwMessage( "bbp.destroy","not allowed to destroy 'bbp' box");
	destroyBox("bbp");
	return MAL_SUCCEED;
}
@-
Access to a box calls for resolving the first parameter
to a named box.
@= OpenBox
	box= findBox("bbp");
	if( box ==0) 
	return throwMessage("bbp.@1","box is not open");
@-
@c
str CMDbbpdeposit(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	str name;
	ValPtr v;
	Box box;

	@:OpenBox(deposit)@
	name = (str) getArgValue(stk,pci,1);
	@:chkIdentifier(name,deposit)@
	v = &stk->stk[pci->argv[2]];
	if(depositBox(box,name,v) ) 
	return throwException(MALEXCEPTION,"bbp.deposit",
		"failed to deposit '%s' into box",name);
	return MAL_SUCCEED;
}

str CMDbbpbindDefinition(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	str name, loc;
	Box box;

	@:OpenBox(bind)@
	name = (str) getArgValue(stk,pci,1);
	loc = (str) getArgValue(stk,pci,2);
	@:chkIdentifier(name,bind)@
	@:chkIdentifier(loc,bind)@
	if(bindBAT(box,name,loc) )
	return throwException(MALEXCEPTION,"bbp.bind",
		"failed to bind '%s' ",name);
	return MAL_SUCCEED;
}
str CMDbbpbind(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	str name;
	Box box;
	ValPtr lhs,rhs;
	int i= -1, k;
	char msg[1024];
	BAT *b;

	lhs= &stk->stk[pci->argv[0]];
	name = (str) getArgValue(stk,pci,1);
	@:chkIdentifier(name,bind)@
	box= findBox("bbp");
        if(box && (i= findVariable(box->sym, name))>=0){
		rhs= &box->val->stk[i];
		VALcopy(lhs,rhs);
		if( lhs->vtype == TYPE_bat){
			BAT *b;
			b= (BAT*) BBPgetdesc(lhs->val.bval);
			if( b ) BBPfix(b->batCacheid);
			else return throwMessage("bbp.bind","can not access descriptor");
		}
		return MAL_SUCCEED;
	}
	i= BBPindex(name);
	if(i == 0)
		return throwException(MALEXCEPTION,"bbp.bind",
					"failed to find '%s' in box",name);
	b= (BAT*) BBPgetdesc(i);
	if( b == 0 ) {
		/* Simple ignore the binding if you can;t find the bat */
		return MAL_SUCCEED;
	}
	lhs->vtype = TYPE_bat;
	lhs->val.bval= i;
	BBPfix(b->batCacheid);
	return MAL_SUCCEED;
}

@-
Moving BATs in/out of the box also involves
checking the type already known for possible misfits.
Therefore, we need access to the runtime context.
@c
str CMDbbptake(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	str name;
	Box box;
	ValPtr v;

	@:OpenBox(take)@
	name = (str) getArgValue(stk,pci,1);
	@:chkIdentifier(name,take)@
	v = &stk->stk[pci->argv[0]];
	if(takeBox(box,name,v)) 
	return throwException(MALEXCEPTION,"bbp.take",
			"failed to take '%s' from box",name);
	/* make a private copy for this client session */
	/* use the cheapest copy method */
	printf("bbp.take not yet fully implemented\n");
	return MAL_SUCCEED;
}

str CMDbbprelease(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	str name;
	Box box;

	@:OpenBox(release)@
        name = (str) getArgValue(stk,pci,1);
        releaseBox(box,name);
	/* merge the updates of this BAT with the master copy */
	printf("bbp.release not yet fully implemented\n");
	return MAL_SUCCEED;
}

str CMDbbpreleaseAll(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	Box box;

	@:OpenBox(releaseAll)@
	releaseAllBox(box);
	/* merge the updates with the master copies */
	printf("bbp.releaseAll not yet fully implemented\n");
	return MAL_SUCCEED;
}

str CMDbbpdiscard(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	str name;
	Box box;

	@:OpenBox(discard)@
        name = (str) getArgValue(stk,pci,1);
        if( discardBox(box,name) )
	return throwException(MALEXCEPTION,"bbp.discard",
				"failed to discard '%s' ", name);
	printf("bbp.discard not yet fully implemented\n");
	return MAL_SUCCEED;
}
str CMDbbptoString(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	Box box;
	int i;
	ValPtr v;
	str nme;

	@:OpenBox(toString)@
	nme = (str) getArgValue(stk,pci,1);
	i= findVariable(box->sym,nme);
	if( i <0)
		return throwException(MALEXCEPTION,"bbp.toString",
			"failed to take value '%s' from box",nme);
	v= &box->val->stk[i];
	garbageElement(&stk->stk[pci->argv[0]]);
	if( VALconvert(TYPE_str,v) == ILLEGALVALUE) 
	return throwMessage("bbp.toString","illegal value conversion");
	VALcopy(&stk->stk[pci->argv[0]], v);
	return MAL_SUCCEED;
}

str CMDbbpiterator(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	Box box;
	lng *cursor;
	ValPtr v;

	@:OpenBox(iterator)@
	cursor= (lng*) getArgValue(stk,pci,0);
	v= &stk->stk[pci->argv[1]];
	if( nextBoxElement(box, cursor, v))
		return throwMessage("bbp.iterator","failed");
	return MAL_SUCCEED;
}

@+ BAT enhancements
The code to enhance thekernel
@c
str CMDBATnew(MalBlkPtr m, MalStkPtr s, InstrPtr p){
        int ht, tt, cap=0;
        int *res;

        ht= getArgType(m,p,1);
        tt= getArgType(m,p,2);
        if( p->argc>3)
                cap= *(int *) getArgReference(s,p,3);
        res= (int *) getArgReference(s,p,0);

        return (str) CMDnewBat2(res,&ht,&tt,&cap);
}

str CMDproject (MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
        int *result, *bid, tt;
        ptr *p;
        BAT *b, *bn;

        result= (int*) getArgReference(stk,pci,0);
        bid= (int*) getArgReference(stk,pci,1);
        p= (ptr*) getArgReference(stk,pci,2);
        tt=  getArgType(mb,pci,2);
        @:getBATdescriptor(result,bid,b,project)@
        bn= BATconst(b, tt, p);
        if( bn ) {
               *result = bn->batCacheid;
                return MAL_SUCCEED;
        }
        return throwMessage("mal.project","GDKerror");
}

str CMDprojectNil(int *ret, int *bid){
        BAT *b,*bn;
        @:getBATdescriptor(ret,bid,b,project)@

        bn= BATconst(b,TYPE_void, &int_nil);
        if( bn ) {
               *ret = bn->batCacheid;
                return MAL_SUCCEED;
        }
        return throwMessage("mal.project","GDKerror");
}
@+ BAT Iterator Implementation
Part of the code is copied from the V 4.3 bat.mx file.
@= getBATdescriptor
        if( BBPcheck(*@2,"@4")==0)
                return throwMessage("mal.@4","cannot access bat @2 in bbp");
        @3= (BAT*) BBPgetdesc(*@2);
        if( @3 == NULL) { *@1 = 0;
                return throwMessage("mal.@4","cannot access descriptor @2");
        }
        if(*@2 <0) @3= BATmirror(@3);
@-
@= hashiter
        if (b->tvarsized) {
                HASHloop@1(b, b->hhash, idx, v, p)
                        if ((i = ITERATE(v, BUNtvar(b,p), h)) < 0) return i;
        } else {
                HASHloop@1(b, b->hhash, idx, v, p)
                        if ((i = ITERATE(v, BUNtloc(b,p), h)) < 0) return i;
        } break;
@c
str CMDhashloop(int *ret, lng *cursor, int *bid)
{
        BAT *b;
        @:getBATdescriptor(ret,bid,b,nextElement)@
        return throwMessage("mal.hashloop","not yet implemented");
}
@-
Moving a value from a BUN into a value record, making proper copies
on the way.
@c
ValPtr VALinit(ValPtr d, int tpe, ptr s){
        if (ATOMextern(tpe) == 0) {
                d->vtype= tpe;
                memcpy(&d->val.ival, s, ATOMlen(tpe,s));
        } else
        if (s == 0) {
                GDKerror("VALinit:unsupported init\n");
                d->vtype= TYPE_int;
        } else if( ATOMstorage(tpe) == TYPE_str) {
                d->vtype = TYPE_str;
                d->val.sval = GDKstrdup(s);
                d->len = strLen(s);
        } else {
                d->vtype= tpe;
                d->len = ATOMlen(tpe,s);
                d->val.pval = GDKmalloc(d->len);
                memcpy(d->val.pval, s, d->len);
        }
        return d;
}
@-
In principle, we could add iterators with other range bounds.
@= nextLoop
str CMDnextElement_@1(bit *ret, @1 *cursor, int *bid)
{
	BAT *b;
	int limit;
	@:getBATdescriptor(ret,bid,b,nextElement)@
	limit=  BUNindex(b,BUNlast(b));
	if( *cursor <0)
		*cursor = BUNindex(b,BUNfirst(b));
	else	*cursor = *cursor+1;
	*ret = *cursor < limit;
	return MAL_SUCCEED;
}
@-
@c
	@:nextLoop(lng)@

str CMDnextElement(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	BAT *b;
	lng *cursor;
	bit *ret;
	int *bid;
	int limit;
	BUN p;
	ValPtr head, tail;

	if( pci->argc != 5) stream_printf(GDKout,"CMDnextElement:exception\n");
	ret = (bit *) getArgReference(stk,pci,0);
	cursor = (lng *) getArgReference(stk,pci,1);
	bid = (int *) getArgReference(stk,pci,2);
	head = &stk->stk[pci->argv[3]];
	tail = &stk->stk[pci->argv[4]];

	@:getBATdescriptor(ret,bid,b,nextElement)@
	limit=  BUNindex(b,BUNlast(b));

	if( *cursor <0)
		*cursor = BUNindex(b,BUNfirst(b));
	else	*cursor = *cursor+1;
	*ret = *cursor < limit;

	if( *ret== FALSE) return MAL_SUCCEED;
	/* get head = ... tail = ... */
	p = BUNptr(b,*cursor);
	garbageElement(head);
	garbageElement(tail); 
	VALinit( head, getArgType(mb,pci,3),BUNhead(b,p));
	VALinit( tail, getArgType(mb,pci,4),BUNtail(b,p));
stream_printf(GDKout,"%s",BUNtail(b,p));
	return MAL_SUCCEED;
}
@-
The BUN- and BAT-stream manipulate a long handle, i.e.
the destination variable. It assumes it has been set to
zero as part of runtime stack initialization. Subsequently,
it fetches a bun and returns the increment to the control
variable. If it returns zero the control variable has been reset
to zero and end of stream has been reached.

The head and tail variables may have to be set to the type
extracted from the BAT descriptor. If there occurs a type
error.
@c
str CMDbunStream(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	BAT *b;
	lng *cursor;
	bit *ret;
	int *bid;
	int limit,tp;
	BUN p;
	ValPtr head, tail;

	if( pci->argc != 4) stream_printf(GDKout,"exception in nextElement\n");
	cursor = (lng *) getArgReference(stk,pci,0);
	bid = (int *) getArgReference(stk,pci,1);
	head = &stk->stk[pci->argv[2]];
	tail = &stk->stk[pci->argv[3]];
	@:getBATdescriptor(ret,bid,b,nextElement)@
	limit=  BUNindex(b,BUNlast(b));

	if( *cursor >=limit){
		*cursor = 0;
		return MAL_SUCCEED;
	} 
	if( *cursor == 0)
		*cursor = BUNindex(b,BUNfirst(b));

/*
stream_printf(GDKout,"head type %s\n", malTypeName(getArgType(mb,pci,2)));
stream_printf(GDKout,"tail type %s\n", malTypeName(getArgType(mb,pci,3)));
*/
	/* get head = ... tail = ... */
	p = BUNptr(b,*cursor);
	garbageElement(head);
	garbageElement(tail); 
	tp = getArgType(mb,pci,2);
	if( tp == TYPE_void  && b->hseqbase!= oid_nil){
		VALinit( head, TYPE_oid, BUNhead(b,p));
		head->vtype= TYPE_void;
	} else 	VALinit( head, tp, BUNhead(b,p));
	VALinit( tail, getArgType(mb,pci,3),BUNtail(b,p));
	*cursor = *cursor+1;
	return MAL_SUCCEED;
}

@-
The fetch operations are all pretty straight forward, provided
you know the underlying type. Often it is cheaper to use
the extended BAT iterator, because then it can re-use the
BAT descriptor.
@c
str CMDgetHead(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	BAT *b;
	lng *cursor;
	int *bid;
	int limit;
	BUN p;
	ValPtr head;
	int r, *ret=&r;

	cursor = (lng *) getArgReference(stk,pci,2);
	bid = (int *) getArgReference(stk,pci,1);
	head = &stk->stk[pci->argv[0]];

	@:getBATdescriptor(ret,bid,b,nextElement)@
	limit=  BUNindex(b,BUNlast(b));
	if( *cursor<0  || *cursor >=limit) {
		return throwMessage("mal.getHead","range error");
	}

	/* get head = ... */
	p = BUNptr(b,*cursor);
	garbageElement(head);
	VALinit( head, getArgType(mb,pci,3),BUNhead(b,p));
	return MAL_SUCCEED;
}
str CMDgetTail(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	BAT *b;
	lng *cursor;
	int *bid;
	int limit;
	BUN p;
	ValPtr tail;
	int r, *ret=&r;

	cursor = (lng *) getArgReference(stk,pci,2);
	bid = (int *) getArgReference(stk,pci,1);
	tail = &stk->stk[pci->argv[0]];

	@:getBATdescriptor(ret,bid,b,nextElement)@
	limit=  BUNindex(b,BUNlast(b));
	if( *cursor<0  || *cursor >=limit) {
		return throwMessage("mal.getTail","range error");
	}

	/* get head = ... */
	p = BUNptr(b,*cursor);
	garbageElement(tail);
	VALinit( tail, getArgType(mb,pci,3),BUNtail(b,p));
	return MAL_SUCCEED;
}
@+ BBP status
The BAT buffer pool datastructures describe the memory resident information
on the whereabouts of the BATs. The three predominant tables are made accessible
for inspection. 

The most interesting sysbat for end-users is the BID-> NAME mapping,
because it provides access to the system guaranteed persistent BAT identifier.
@= Pseudo
	if (BBPindex("@1_@2") <= 0)
        	BATname(b, "@2");
        BATroles(b,"@1","@2");
	BATmode(b,TRANSIENT);
	BATfakeCommit(b);
	*ret = b->batCacheid;
	
@c
str CMDbbpGetObjects(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	BAT*    b;
        int     i;
	ValPtr  v;
	Box 	box;
	int	*ret;

	@:OpenBox(getObjects)@
        b= BATnew(TYPE_int,TYPE_str,BBPsize);
        if (b == 0) return throwMessage("bbp.getObjects","GDKerror");
	for(i=0;i<box->sym->vtop;i++){
		v = &box->val->stk[i];
		BUNins(b, &v->val.bval, getVarName(box->sym,i));
	}

	ret = (int *) getArgReference(stk,pci,0);
	@:Pseudo(bbp,objects)@
        return MAL_SUCCEED;
}
str CMDbbpNames( int *ret){       
	BAT*    b;
        int     i;

        b= BATnew(TYPE_int,TYPE_str,BBPsize);
        if (b == 0) return throwMessage("catalog.bbpNames", "failed to create BAT");

	BBPlock("CMDbbpNames");
        for(i=1; i < BBPsize; i++) if (i != b->batCacheid) {
        	if (BBP_logical(i)) { 
			BUNins(b, &i, BBP_logical(i));
        		if (BBP_logical(-i)) {
				int j = -i;
				BUNins(b, &j, BBP_logical(j));
			}
		}
	}
	BBPunlock("CMDbbpNames");
	@:Pseudo(bbp,name)@
        return MAL_SUCCEED;
}
str CMDbbpCount( int *ret){       
	BAT	*b,*bn;
        int     i;
	lng	l;

        b= BATnew(TYPE_int,TYPE_lng,BBPsize);
        if (b == 0) return throwMessage("catalog.bbpCount", "failed to create BAT");

        for(i=1; i < BBPsize; i++) if (i != b->batCacheid) {
        	if (BBP_logical(i)) { 
			bn= BATdescriptor(i);
			if(bn){
				l= BATcount(bn);
				BUNins(b, &i, &l);
				BBPunfix(bn->batCacheid);
			}
		}
	}
	@:Pseudo(bbp,count)@
        return MAL_SUCCEED;
}
@-
The BAT status is redundantly stored in CMDbat_info.
@c
str CMDbbpLocation(int *ret){       
	BAT*    b;
        int     i;

        b= BATnew(TYPE_int,TYPE_str,BBPsize);
        if (b == 0) return throwMessage("catalog.bbpLocation", "failed to create BAT");

	BBPlock("CMDbbpLocation");
        for(i=1; i < BBPsize; i++) if (i != b->batCacheid) {
        	if (BBP_logical(i))
                BUNins(b, &i, BBP_physical(i));
	}
	BBPunlock("CMDbbpLocation");
	@:Pseudo(bbp,location)@
        return MAL_SUCCEED;
}


#define monet_modulesilent (GDKdebug&4096)


str CMDbbpHeat(int *ret){       
	BAT*    b;
        int     i;

        b= BATnew(TYPE_int,TYPE_int,BBPsize);
        if (b == 0) return throwMessage("catalog.bbpHeat", "failed to create BAT");

	BBPlock("CMDbbpHeat");
        for(i=1; i < BBPsize; i++) if (i != b->batCacheid) {
            if (BBP_cache(i) && !monet_modulesilent) {
		int heat = BBP_lastused(i);
                BUNins(b, &i, &heat);
	    } else if (BBP_logical(i)) { 
		int zero = 0;
                BUNins(b, &i, &zero);
	    }
	}
	BBPunlock("CMDbbpHeat");
	@:Pseudo(bbp,heat)@
        return MAL_SUCCEED;
}

@-
The BAT dirty status: dirty => (mem != disk); diffs = not-committed
@c
str CMDbbpDirty(int *ret){       
	BAT*    b;
        int     i;

        b= BATnew(TYPE_int,TYPE_str,BBPsize);
        if (b == 0) return throwMessage("catalog.bbpDirty", "failed to create BAT");

	BBPlock("CMDbbpDirty");
        for(i=1; i < BBPsize; i++) if (i != b->batCacheid) {
        if (BBP_logical(i)){
		BAT *bn = BBP_cache(i);
                BUNins(b, &i, bn?
				BATdirty(bn)?
					"dirty":
					DELTAdirty(bn)?
						"diffs":
						"clean":
				(BBP_status(i)&BBPSWAPPED)?
					"diffs": 
					"clean");
	}}
	BBPunlock("CMDbbpDirty");
	@:Pseudo(bbp,status)@
        return MAL_SUCCEED;
}

@-
The BAT status is redundantly stored in CMDbat_info.
@c
str CMDbbpStatus(int *ret){       
	BAT*    b;
        int     i;

        b= BATnew(TYPE_int,TYPE_str,BBPsize);
        if (b == 0) return throwMessage("catalog.bbpStatus", "failed to create BAT");

	BBPlock("CMDbbpStatus");
        for(i=1; i < BBPsize; i++) if (i != b->batCacheid) {
        if (BBP_logical(i)){
		char *loc = BBP_cache(i)?"load":"disk";
                BUNins(b, &i,loc );
	}}
	BBPunlock("CMDbbpStatus");
	@:Pseudo(bbp,status)@
        return MAL_SUCCEED;
}

str CMDbbpKind(int *ret){       
	BAT*    b;
        int     i;

        b= BATnew(TYPE_int,TYPE_str,BBPsize);
        if (b == 0) return throwMessage("catalog.bbpKind", "failed to create BAT");

	BBPlock("CMDbbpKind");
        for(i=1; i < BBPsize; i++) if (i != b->batCacheid) {
	if (BBP_logical(i)) {
	    char *mode = NULL;
	    if ((BBP_status(i)&BBPDELETED) || !(BBP_status(i)&BBPPERSISTENT)) {
		mode = "transient";
	    } else {
		mode = "persistent";
	    }
	    if (mode) BUNins(b, &i, mode);
	}}
	BBPunlock("CMDbbpKind");
	@:Pseudo(bbp,kind)@
        return MAL_SUCCEED;
}

str CMDbbpRefcnt(int *ret){       
	BAT	 *b;
        int     i;

        b= BATnew(TYPE_int,TYPE_int,BBPsize);
        if (b == 0) return throwMessage("catalog.bbpRefcnt", "failed to create BAT");

	BBPlock("CMDbbpRefcnt");
        for(i=1; i < BBPsize; i++) if (i != b->batCacheid) {
	if (BBP_logical(i)) {
		int refs = BBP_refs(i);
		BUNins(b, &i, &refs);
	}}
	BBPunlock("CMDbbpRefcnt");
	@:Pseudo(bbp,lrefcnt)@
        return MAL_SUCCEED;
}


@-
@= headtailProperty
str CMDbbp@2( int *ret){
        BAT     *b,*bn;
        int     i;

        b= BATnew(TYPE_int,TYPE_str,BBPsize);
        if (b == 0) return throwMessage("catalog.bbp@2", "failed to create BAT");

        for(i=1; i < BBPsize; i++) if (i != b->batCacheid) {
                if (BBP_logical(i)) {
                        bn= BATdescriptor(i);
                        if(bn) BUNins(b, &i, BATatoms[BAT@1(bn)].name);
                }
        }
        @:Pseudo(bbp,@2)@
        return MAL_SUCCEED;
}

@c
        @:headtailProperty(htype,HeadType)@
        @:headtailProperty(ttype,TailType)@

