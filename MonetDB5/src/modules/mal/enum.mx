@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@' 
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@' 
@' The Original Code is the Monet Database System.
@' 
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2004 CWI.
@' All Rights Reserved.
@' 
@' Contributor(s):
@' 		Martin Kersten <Martin.Kersten@cwi.nl>
@' 		Peter Boncz <Peter.Boncz@cwi.nl>
@' 		Niels Nes <Niels.Nes@cwi.nl>
@' 		Stefan Manegold  <Stefan.Manegold@cwi.nl>

@ enum
@a Peter Boncz
@v 1.0
@* Enumeration Datatypes
When large sets of data are stored and memory is short, one 
seeks for memory occupation optimizations.
@-
One way to do this when the ordinality is low, is to substitute
the datatype to a smaller ordinal datatype. For instance, when 
less than 256 different string values occur in an attribute, one 
could store them as a byte. 
@-
This remapping can be encapsulated nicely by introducing an 'enum'
atomic type, that appears to be the original type, but is in fact
stored as something smaller. Encode and decode commands, as well 
as 'tostr' and 'fromstr' ADT functions, can be generated beforehand
and use a mapping table to translate between the two representations. 
@-
Further space optimizations into values smaller than a byte are
impossible in Monet, since all values need to have a unique memory address.
Though it may by a problem to waste memory, one should also realize that 
main-memory databases suffer increasingly when the data representation gets 
more complex. This is obviously true for complex compression schemes, but 
even loading a single byte value is considerably slower on custom CPUs
than loading an entire 32-bit integer. On 64-bits architectures, this 
will even be the case for long 64-bit integers. 
@-
This module implements encodings using 'chr' (1-byte encoding),
and 'sht' (2-byte encoding).
@-
The prototypical use of the enum facility runs as follows.
The user starts with collecting the values of interest in a BAT, say B.
Subsequently, the command enum.create(:NME,B) creates a new type NME,
whose value is taken from the elements stored in B.
By default its underlying indexing type is then set to 'int'.
As soon as a bat of values is associated with the type, its
underlying type changes based on the storage space needed.
The create command will inspect the content of B and creates a 
BAT in the database to represent the values. 
@-
To enable the type checker to analyse the programs upfront, 
the MAL program should 'pre-define' existence of the type
using the instruction 'atom NME:enum'.
@-
Furthermore, the enumerated types are considered ordinary BATs,
whose scope is limited unless they are explicitly made persistent.
Destroying an enumerated type removes its encoding bat and the
information from the GDK atom library, but does not affect the
MAL programs. This implies a runtime error as soon as you
try to encode/decode a value.
@{
@* Module Definition 
@mal
atom enum:int;
module enum;

pattern create(e:any::2, src:bat[any,any::1]): bat[any::1,any::2]= ENUMcreate
comment "Associate a value domain with an enumerated type.";

pattern load(map:any::1):BAT[any,any::1] = ENUMload
comment "Load/activate a previously created enumeration type.";

pattern destroy(map:any):void = ENUMdestroy
comment "Destroy an enumeration type";

pattern encode(e:any::1,v:any::2):any::1 = ENUMencode
comment "Encode a value using a small map";

pattern encode(e:any::2,b:BAT[any::1,any]):BAT[any::1,any::2] = ENUMencode_multi
comment "Encode a BAT of tail values, into a new BAT of encoded values.
This action is actually a join operation.";

pattern lower(e:any::1, v:any::2):any::1 = ENUMlower
comment "Encode to the lowest value in the encoded domain that is 
	equal to or larger than v";

pattern upper(e:any::1, v:any::2):any::1 = ENUMupper
comment "Encode to the highest value in the encoded domain that is 
	equal to or less than v";

pattern decode(e:any):any = ENUMdecode
comment "Decode a value";

pattern decode(b:BAT[any::2,any::1]) : BAT[any::2,any] = ENUMdecode_multi
comment "Decode a BAT of tail values, into a new BAT of decoded values";

pattern getTable(e:any::1) : bat = ENUMtable
comment "Return the enumeration BAT of an enum type";

command isEnum(tpe:bat) : bit = isEnum
comment "Returns true iff the bat is used as an enumerated type";

pattern setHistogram(tpe:any::1, b:BAT[any,any]):void = ENUMsethisto
comment "registers the fact that ENUMtable(tpe) is a histogram on b's head column";

pattern isHistogram(tpe:any,b:BAT[any,any]) : bit = ENUMishisto
comment "returns whether ENUMtable(tpe) is a histogram on b's head column";

@{
@* Implementation
Part of the code is copied from the V 4.3 bat.mx file.
@= getBATdescriptor
        if( BBPcheck(*@2,"@4")==0) 
		return throwMessage("enum.@4","cannot access bat @2 in bbp");
        @3= (BAT*) BBPgetdesc(*@2);
        if( @3 == NULL) { *@1 = 0; 
		return throwMessage("enum.@4","cannot access descriptor @2");
        }
	if( *@2 <0) @3= BATmirror(@3);
@-
Note that we have to build the table with pre-instantiated
function references, because there is no easy way from the GDK layer
to access the enum administration.
@= enumCheck
{	str tname= getTypeName(@1);
	b= (BAT*) BBPgetdesc(BBPindex(tname));
	if( b==0)
	return throwException(MALEXCEPTION,"enum.@2","illegal enum type.");
}
@-
old
     for(xx=0; xx<MAX_ENUM; xx++)
	if (ENUMtpe[xx] == @1) break;
     if ((xx>MAX_ENUM) || ((b=BBPdescriptor(ENUMmap[xx])) == NULL)) {
	return throwException(MALEXCEPTION,"enum.@2","illegal enum type.");
     }
     (void)b;	/* keep compilers happy */
}
@c
#include "gdk.h"
#include "mal_client.h"
#include "io.h"
#include "mal.h"

typedef int (*fcn)();

#define MAX_ENUM 80

bat ENUMmap[MAX_ENUM] = { 0 };
oid ENUMhisto[MAX_ENUM] = { 0 };
int ENUMtpe[MAX_ENUM] = { -1 };

@:block(chr,char)@
@:block(sht,short)@
@:imp(0)@	@:imp(1)@	@:imp(2)@	@:imp(3)@ 	@:imp(4)@
@:imp(5)@	@:imp(6)@	@:imp(7)@	@:imp(8)@ 	@:imp(9)@
@:imp(10)@	@:imp(11)@	@:imp(12)@	@:imp(13)@ 	@:imp(14)@
@:imp(15)@	@:imp(16)@	@:imp(17)@	@:imp(18)@ 	@:imp(19)@
@:imp(20)@	@:imp(21)@	@:imp(22)@	@:imp(23)@ 	@:imp(24)@
@:imp(25)@	@:imp(26)@	@:imp(27)@	@:imp(28)@ 	@:imp(29)@
@:imp(30)@	@:imp(31)@	@:imp(32)@	@:imp(33)@ 	@:imp(34)@
@:imp(35)@	@:imp(36)@	@:imp(37)@	@:imp(38)@ 	@:imp(39)@
@:imp(40)@	@:imp(41)@	@:imp(42)@	@:imp(43)@ 	@:imp(44)@
@:imp(45)@	@:imp(46)@	@:imp(47)@	@:imp(48)@ 	@:imp(49)@
@:imp(50)@	@:imp(51)@	@:imp(52)@	@:imp(53)@ 	@:imp(54)@
@:imp(55)@	@:imp(56)@	@:imp(57)@	@:imp(58)@ 	@:imp(59)@
@:imp(60)@	@:imp(61)@	@:imp(62)@	@:imp(63)@ 	@:imp(64)@
@:imp(65)@	@:imp(66)@	@:imp(67)@	@:imp(68)@ 	@:imp(69)@
@:imp(70)@	@:imp(71)@	@:imp(72)@	@:imp(73)@ 	@:imp(74)@
@:imp(75)@	@:imp(76)@	@:imp(77)@	@:imp(78)@ 	@:imp(79)@

fcn ENUMconv[MAX_ENUM*4+1] = { 
@:def(0)@	@:def(1)@	@:def(2)@	@:def(3)@ 	@:def(4)@
@:def(5)@	@:def(6)@	@:def(7)@	@:def(8)@ 	@:def(9)@
@:def(10)@	@:def(11)@	@:def(12)@	@:def(13)@ 	@:def(14)@
@:def(15)@	@:def(16)@	@:def(17)@	@:def(18)@ 	@:def(19)@
@:def(20)@	@:def(21)@	@:def(22)@	@:def(23)@ 	@:def(24)@
@:def(25)@	@:def(26)@	@:def(27)@	@:def(28)@ 	@:def(29)@
@:def(30)@	@:def(31)@	@:def(32)@	@:def(33)@ 	@:def(34)@
@:def(35)@	@:def(36)@	@:def(37)@	@:def(38)@ 	@:def(39)@
@:def(40)@	@:def(41)@	@:def(42)@	@:def(43)@ 	@:def(44)@
@:def(45)@	@:def(46)@	@:def(47)@	@:def(48)@ 	@:def(49)@
@:def(50)@	@:def(51)@	@:def(52)@	@:def(53)@ 	@:def(54)@
@:def(55)@	@:def(56)@	@:def(57)@	@:def(58)@ 	@:def(59)@
@:def(60)@	@:def(61)@	@:def(62)@	@:def(63)@ 	@:def(64)@
@:def(65)@	@:def(66)@	@:def(67)@	@:def(68)@ 	@:def(69)@
@:def(70)@	@:def(71)@	@:def(72)@	@:def(73)@ 	@:def(74)@
@:def(75)@	@:def(76)@	@:def(77)@	@:def(78)@ 	@:def(79)@
0 };

@= def
	enum@1chrTostr, enum@1chrFromstr, enum@1shtTostr, enum@1shtFromstr,
@= block
int enum@1Tostr(int mapid, str* dst, int* len, @1* src){
	int l; ptr v; 
	BAT *b = BATdescriptor(ENUMmap[mapid]);

	if (*src == @1_nil) {
		v = ATOMnilptr(b->htype);
	} else {
		BUN p = BUNptr(b, 1 + *(unsigned @2*) src); 
		v = BUNhead(b,p);
	}
	if (b->htype != TYPE_str) {
		fcn tostr = BATatoms[b->htype].atomToStr;
		l= (*tostr)(dst, len, v);
		return l;
	}
	l = strLen(v);
	if (*len < l) {
		if (*dst) GDKfree(*dst);
		*dst = (char*) GDKmalloc(*len = l);
	}
	memcpy(*dst, v, l);
	return (l-1);  /* return string length excluding eos */
}
int enum@1Fromstr(int mapid, str src, int* l1, @1** dst){
	unsigned int len= *l1;
	int r, l = 0;
	BUN p; ptr v;
	BAT *b = BATdescriptor(ENUMmap[mapid]);

	if (b->htype != TYPE_str) {
		fcn fromstr = BATatoms[b->htype].atomFromStr;
 		v = (ptr) GDKmalloc(l=32);
		r = (*fromstr)(src, &l, &v);
	} else {
		r = strlen(src); 
		v = src;
	}
	if (len < sizeof(@1)) {
		*dst = (@1*) GDKmalloc(len = sizeof(@1));
	}
	if ((p = SORTfnd(b, v)) != NULL) {
		**(unsigned @2**) dst = BUNindex(b,p)-1;
	} else {
		**dst = @1_nil;
	}
	if (l) GDKfree(v);
	return r;
}
@-
@c
@= imp
	@:template(@1,chr,char)@ @:template(@1,sht,short)@
@= template
static int enum@1@2Tostr(char** dst, int* len, @2* src){
	return enum@2Tostr(@1,dst,len,src);
}
static int enum@1@2Fromstr(@2** src, int* len, str dst){
	return enum@2Fromstr(@1, dst,len, src);
}
@c
int ENUMatom(int i, BAT *h){
	str name= h->batId;
	if (BATcount(h) > 255) {
		ATOMproperty(name, "storage", (GDKfcn) TYPE_sht); 
		ATOMproperty(name, "tostr", ENUMconv[i*4+2]);
		ATOMproperty(name, "fromstr", ENUMconv[i*4+3]);
	} else {
		ATOMproperty(name, "storage", (GDKfcn) TYPE_chr); 
		ATOMproperty(name, "tostr", ENUMconv[i*4]);
		ATOMproperty(name, "fromstr", ENUMconv[i*4+1]);
	}
	ENUMtpe[i] = ATOMindex(name);
	ENUMmap[i] = h->batCacheid;
	BBPfix(h->batCacheid);
	return ENUMtpe[i];
}
str ENUMreload(int *retval, int bid) {
	int i;
	BAT *h;

	@:getBATdescriptor(retval,&bid,h,load)@
	MT_set_lock(mal_contextLock, "ENUMload");
	for(i=0; i<MAX_ENUM; i++) {
		if (ENUMmap[i] == 0) {
			char *name = h->batId;
			if (BATcount(h) > 255) {
				ATOMproperty(name, "storage", (GDKfcn) TYPE_sht); 
				ATOMproperty(name, "tostr", ENUMconv[i*4+2]);
				ATOMproperty(name, "fromstr", ENUMconv[i*4+3]);
			} else {
				ATOMproperty(name, "storage", (GDKfcn) TYPE_chr); 
				ATOMproperty(name, "tostr", ENUMconv[i*4]);
				ATOMproperty(name, "fromstr", ENUMconv[i*4+1]);
			}
			ENUMtpe[i] = ATOMindex(name);
			ENUMmap[i] = h->batCacheid;
			BBPfix(h->batCacheid);
			*retval = h->batCacheid;
			MT_unset_lock(mal_contextLock, "ENUMload");
			return MAL_SUCCEED;
		}
	}
	MT_unset_lock(mal_contextLock, "ENUMload");
	return throwMessage("enum.load"," too many active enum types.");
}

str ENUMcreate(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	BAT *h,*b;
	ptr nil;
	int *retval,hid,bid; str ret;
	int tpe;
	str name;

	retval = (int*) getArgReference(stk,pci,0);
	tpe= getArgType(mb,pci,1);
	bid= *(int*) getArgReference(stk,pci,2);
	name= getTypeName(tpe);
	@:getBATdescriptor(retval,&bid,b,create)@
	h = BAThistogram(b);
	nil = ATOMnilptr(b->htype);
	BUNdelHead(h, nil);
	BATorder(h);
	BATrename(h, name);
/*
	BATmode(h, PERSISTENT);
	BBPsave(h);
*/
	hid= h->batCacheid;
	ret= ENUMreload(retval, hid);
	GDKfree(name);
	return ret;
}
str ENUMload(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	int tpe, *retval;
	str ret;
	str name;

	tpe= getArgType(mb,pci,1);
	name= getTypeName(tpe);
	retval= (int*) getArgReference(stk,pci,0);
	*retval= BBPindex(name);
	if( *retval ==0)
		return throwMessage("enum.load"," encoding BAT does not exist.");
	ret= ENUMreload(retval,*retval);
	GDKfree(name);
	return ret;
}

str ENUMdestroy(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	BAT *b;
	int xx = 0;
	int tpe;

	(void) stk; /* fool compiler */
	tpe= getArgType(mb,pci,1);
	@:enumCheck(tpe, ENUMdestroy)@
	MT_set_lock(mal_contextLock, "ENUMdestroy");
	ATOMdelete(tpe);
	BBPunfix(ENUMmap[xx]);
	ENUMhisto[xx] = 0;
	ENUMmap[xx] = 0;
	ENUMtpe[xx] = 0;
	MT_unset_lock(mal_contextLock, "ENUMdestroy");
	BBPunfix(b->batCacheid);
	return MAL_SUCCEED;
}
@-
The result of an encode/lower/upper step is stored in the 
receiving variable.
@= encoding
	if( ATOMstorage(tpe)== TYPE_chr){
		if (p == NULL) *(chr*) dst = chr_nil; 
		else *(unsigned char*) dst = BUNindex(b,p) - 1;
	} else {
		if (p == NULL) *(sht*) dst = sht_nil; 
		else *(unsigned short*) dst = BUNindex(b,p) - 1;
	}
@c
str ENUMencode(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	BAT *b;
	ptr p,src,dst;
	int tpe;

	tpe= getArgType(mb,pci,1);
	@:enumCheck(tpe,ENUMencode)@
	src= *(ptr*) getArgReference(stk,pci,2);
	dst= (ptr) getArgReference(stk,pci,0);
	p = BUNfnd(b, src);
	@:encoding@
	BBPunfix(b->batCacheid);
	return MAL_SUCCEED;
}
str ENUMlower(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	int tpe;
	BUN p,src,dst;
	BAT *b;
	
	tpe= getArgType(mb,pci,1);
	src= *(ptr*) getArgReference(stk,pci,2);
	dst= (ptr) getArgReference(stk,pci,0);
	@:enumCheck(tpe,ENUMlower)@
	if (!ATOMlinear(b->htype)){
		BBPunfix(b->batCacheid);
	 	return throwMessage("enum.lower"," incompatible source type.");
	}
	if (BAThordered(b)&1) {
		p = SORTfndlast(BATmirror(b), src);
		if (p && p > BUNfirst(b))  p -= BUNsize(b);
		else p = NULL;
	} else {
		BATidx(b, NULL);
		p = (BUN) IDXfndlast(b, src);
		if (p && p > (BUN) b->hidx.first) p = ((BUN*) p)[-1];
		else p = NULL;
	}
	@:encoding@
	BBPunfix(b->batCacheid);
	return MAL_SUCCEED;
} 

str ENUMupper(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	int tpe;
	BUN p,src,dst;
	BAT *b;
	
	tpe= getArgType(mb,pci,1);
	src= *(ptr*) getArgReference(stk,pci,2);
	dst= (ptr) getArgReference(stk,pci,0);
	@:enumCheck(tpe,ENUMlower)@
	if (!ATOMlinear(b->htype)){
		if(b) BBPunfix(b->batCacheid);
	 	return throwException(MALEXCEPTION,"enum.upper",
			"incompatible source type.");
	}
	if (BAThordered(b)&1) {
		p = SORTfndfirst(BATmirror(b), src);
	} else {
		BATidx(b,NULL);
		p = (BUN) IDXfndfirst(b, src);
		if (p) p = *(BUN*) p;
	}
	@:encoding@
	BBPunfix(b->batCacheid);
	return MAL_SUCCEED;
} 

str ENUMdecode(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	int tpe;
	BUN p,src, *dst;
	BAT *b;
	
	tpe= getArgType(mb,pci,1);
	src= *(ptr*) getArgReference(stk,pci,1);
	dst= (ptr) getArgReference(stk,pci,0);
	@:enumCheck(tpe,ENUMlower)@

	if( b->htype != getArgType(mb,pci,0)){
		if(b) BBPunfix(b->batCacheid);
		return throwMessage("enum.decode","incompatible source type");
	}
	if( ATOMstorage(tpe) == TYPE_chr){
		if (*(chr*) src == chr_nil) p = ATOMnilptr(b->htype);
		else p = BUNhead(b, BUNptr(b, 1 + *(unsigned char*)src));
	} else{
		if (*(sht*) src == sht_nil) p = ATOMnilptr(b->htype);
		else p = BUNhead(b, BUNptr(b, 1 + *(unsigned short*)src));
	}
	
	if (b->hvarsized) {
		int l = ATOMlen(b->htype, p); 
		* (ptr*)dst =  (ptr*) GDKmalloc(l);
		memcpy(*(ptr*)dst, p, l);
	} else {
		memcpy(dst, p, ATOMsize(b->htype));
	}
	BBPunfix(b->batCacheid);
	return MAL_SUCCEED;
}


#define HASHfnd_loc(r,b,p) r = BUNfnd(b,p)
#define HASHfnd_var(r,b,p) r = BUNfnd(b,p)

@= encode
{ 	BAT *bn = BATnew(src->htype, tpe, BATcount(src)); 
	BUN p,q,r; int xx;
	unsigned @2 idx;
	
	if (BAThordered(b)&1) {
	    BATloopFast(src, p, q, xx) {
		BUN r = (BUN) SORTfnd@4(b, BUNt@3(src,p));
		if (r == NULL) {
			idx = @1_nil; 
		} else {
			idx = BUNindex(b,r) - 1;
		}
		BUNfastins(bn, BUNhead(src,p), &idx); 
	    } 
	} else {
	    BATloopFast(src, p, q, xx) {
		HASHfnd@4(r, b, BUNt@3(src,p));
		if (r == NULL) {
			idx = @1_nil; 
		} else {
			idx = BUNindex(b,r) - 1;
		}
		BUNfastins(bn, BUNhead(src,p), &idx); 
	    } 
	} 
	*retval = bn->batCacheid;
	bn->tsorted = 0;
	ALIGNsetH(bn, src);
} break;
@c
str ENUMencode_multi(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	BAT *b,*src;
	int bid,*retval;
	int tpe;

	tpe= getArgType(mb,pci,1);
	@:enumCheck(tpe,ENUMencode_multi)@
	bid= *(int*) getArgReference(stk,pci,2);
	retval= (int*) getArgReference(stk,pci,0);
	@:getBATdescriptor(retval,&bid,src,encode)@

	if (src->ttype != b->htype) {
		if(b) BBPunfix(b->batCacheid);
	 	return throwMessage("enum.encode"," incompatible types");
	}
	if (ATOMstorage(tpe) == TYPE_chr) { 
	    switch(ATOMstorage(src->ttype)) {
	    case TYPE_void: 
		return throwMessage("enum.encode"," illegal tail type");
	    case TYPE_chr:	@:encode(chr,char,loc,_chr)@
	    case TYPE_sht:	@:encode(chr,char,loc,_sht)@
	    case TYPE_int:	@:encode(chr,char,loc,_int)@
	    case TYPE_flt:	@:encode(chr,char,loc,_flt)@
	    case TYPE_lng:	@:encode(chr,char,loc,_lng)@
	    case TYPE_dbl:	@:encode(chr,char,loc,_dbl)@
	    default:if(src->tvarsized) {
				@:encode(chr,char,var,_var)#
		    } else {
				@:encode(chr,char,loc,_loc)#
	    }	    }
	} else {
	    switch(ATOMstorage(src->ttype)) {
	    case TYPE_void: 
		if(b) BBPunfix(b->batCacheid);
		return throwMessage("enum.encode"," illegal tail type");
	    case TYPE_chr:	@:encode(sht,short,loc,_chr)@
	    case TYPE_sht:	@:encode(sht,short,loc,_sht)@
	    case TYPE_int:	@:encode(sht,short,loc,_int)@
	    case TYPE_flt:	@:encode(sht,short,loc,_flt)@
	    case TYPE_lng:	@:encode(sht,short,loc,_lng)@
	    case TYPE_dbl:	@:encode(sht,short,loc,_dbl)@
	    default:if(src->tvarsized) {
				@:encode(sht,short,var,_var)#
		    } else {
				@:encode(sht,short,loc,_loc)#
	    }	    }
	}
	BBPunfix(b->batCacheid);
	return MAL_SUCCEED;
} 

@= decode
{	BAT *bn = BATnew(src->htype, b->htype, BATcount(src)); 
	BUN p,q; int xx;
	ptr w,nil = ATOMnilptr(b->htype);
	
	BATloopFast(src, p, q, xx) {
		unsigned @2 *idx = (unsigned @2*) BUNtloc(src,p);
		if (*(@1*) idx == chr_nil) {
			w = nil;
		} else {
			w = BUNhead(b, BUNptr(b, 1 + *idx));
		}
		BUNfastins(bn, BUNhead(src,p), w); 
		
	} 
	*retval = bn->batCacheid;
}
@c
str ENUMdecode_multi(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	BAT *b,*src;
	int *bid,*retval;
	int tpe;

	(void) mb; /* fool compiler */
	bid= (int*) getArgReference(stk,pci,1);
	retval= (int*) getArgReference(stk,pci,0);
	@:getBATdescriptor(retval,bid,src,encode)@
	tpe= src->ttype;
	@:enumCheck(tpe,ENUMencode_multi)@
	if(b) BBPunfix(b->batCacheid);
	if (ATOMstorage(tpe) == TYPE_chr) { 
	    @:decode(chr,char)@
	} else if (ATOMstorage(tpe) == TYPE_sht) { 
	    @:decode(sht,short)@
	} else
	    return throwMessage("enum.decode"," illegal tail type.");
	return MAL_SUCCEED;
}

int ENUMchktpe(int tpe) {
	int i;
	for(i=0; i<MAX_ENUM; i++)
		if (ENUMtpe[i] == tpe) return TRUE;
	return FALSE;
}

int ENUMisTable(BAT *b, int tpe){
	if( b->ttype== tpe)
		return ENUMchktpe(tpe);
	return FALSE;
}
str ENUMtable(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	BAT *b;
	int *retval;
	int tpe;
	str tname;

	tpe= *(int*) getArgReference(stk,pci,1);
	(void) tpe; /* fool user */
	retval= (int*) getArgReference(stk,pci,0);

	tname= getTypeName(getArgType(mb,pci,1));
        b= (BAT*) BBPgetdesc(BBPindex(tname));
        if( b == NULL)
		return throwMessage("enum.getTable","cannot access type table");
	*retval = b->batCacheid;
	return MAL_SUCCEED;
}

str isEnum(bit *ret, int *bid){
	BAT *b;
	int i;
	@:getBATdescriptor(ret,bid,b,isEnum)@
	*ret= FALSE;
	for(i=0; i<MAX_ENUM; i++)
		if (ENUMmap[i] == b->batCacheid) { *ret= TRUE;break;}
	return MAL_SUCCEED;
}

str ENUMsethisto( MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	BAT *b,*column;
	int xx = 0, *retval;
	int tpe,bid;
	str tname;

	tpe= *(int*) getArgReference(stk,pci,1);
	(void) tpe; /* fool compiler */
	bid= *(int*) getArgReference(stk,pci,2);
	retval= (int*) getArgReference(stk,pci,0);

	tname= getTypeName(getArgType(mb,pci,1));
        b= (BAT*) BBPgetdesc(BBPindex(tname));
        if( b == NULL)
		return throwMessage("enum.setHisto","cannot access type table");
	@:getBATdescriptor(retval,&bid,column,sethisto)@
	if (column->halign == 0) {
		column->halign = OIDnew(1);
		column->batDirtydesc = TRUE;
	}
	ENUMhisto[xx] = column->halign;
	BBPunfix(b->batCacheid);
	return MAL_SUCCEED;
}

str ENUMishisto(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	BAT *b,*column;
	int xx, *retval;
	int tpe,*bid;
	str tname;

	tpe= *(int*) getArgReference(stk,pci,1);
	(void) tpe; /* fool compiler */
	bid= (int*) getArgReference(stk,pci,2);
	retval= (int*) getArgReference(stk,pci,0);

	tname= getTypeName(xx= getArgType(mb,pci,1));
        b= (BAT*) BBPgetdesc(BBPindex(tname));
        if( b == NULL)
		return throwMessage("enum.setHisto","cannot access type table");
	@:getBATdescriptor(retval,bid,column,ishisto)@
	*retval = (ENUMhisto[xx] == column->halign);
	BBPunfix(b->batCacheid);
	return MAL_SUCCEED;
}

str ENUMepilogue() {
	int xx;
	for(xx=0; xx<MAX_ENUM; xx++)  {
		if (ENUMmap[xx])  {
			BBPunfix(ENUMmap[xx]);
		}
	}
	return MAL_SUCCEED;
}
@}
