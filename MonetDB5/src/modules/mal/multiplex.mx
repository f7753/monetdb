@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2005 CWI.
@' All Rights Reserved.

@' 

@f multiplex
@a Peter Boncz, Martin Kersten

@* Multiplexed Function Execution 
[WARNING] the semantics of the documentation does not align
with the implementation. For, in search for efficient
operators we assume aligned BATs and the script version does
not respect duplicates in the non-first arguments
[/WARNING]

This module contains the generic implementation of the 
MIL [X]() multiplex operators. 
Multiplex operators provide the possibility of executing any
command "CMD" (or operators or FUNCTIONs) with signature:
@verbatim
CMD(T1,..,Tn) : Tr
@end verbatim
on a series of BATs with corresponding head values 
by putting the command between square brackets, giving the
following corresponding signature:.
@verbatim
[CMD](bat[:any$1,:T1],...,bat[any$1,Tn]) :bat[any$1,Tr]
@end verbatim
and
@verbatim
CMD(T1,...,Tn) : Tr
@end verbatim
Implementation of the multiplex is done by performing the
natural join on all bat-valued parameters, and executing the 
CMD for each combination of matching tuples. All results are 
collected in a result BAT. 
All but one argument may be replaced by a scalar value.

There are two main factors that determine how the multiplex is 
executed: what kind of command is CMD (either function, 'simple'
operator, or 'complex' operator)? and: how easy is it to
construct the natural join on the bat parameters? 

In Monet version 4, most multiplex operators encountered in 
practice dealt with arithmetic and coercions on BAT tails.
This common case has been further optimized in the implementation
of the batcalc module.

MAL does not directly support arbitrary overloading of an
operator to become its multiplex-ed variant. Instead,
a call is made to the PATTERN multiplex.script(CMD,A1,...An)
where CMD is a string literal.
This multiplex module comes with a different type checker,
which enables static type checking of most multiplex operations.

The implementation provided here is meant to retain much of
the multiplex functionality in Version 4.
For each multiplex call for which there does not exist a fast
primitive implementation,
we generate a MAL script on the fly, which is then executed.
Subsequent improvements should come from massaging the MAL code
or to derived a fast C-based implementation.
@mal
module multiplex 
check  CMDmultiplexTypeCheck;

pattern tactics(CMD:str, a:any...):any 
address CMDmultiplexScript
comment "Tactical optimizer for multiplexed 
	instructions.";

pattern script(CMD:str, a:any...):any 
address CMDmultiplexScript
comment "Generic processor for mutiplexed 
	instructions.";

@{
@-
@h
#ifndef _MAL_MULTIPLEX_H_
#define _MAL_MULTIPLEX_H_
#include "mal.h"
#include "mal_interpreter.h"
#include "mal_resolve.h"
#include "mal_client.h"

mal_export int CMDmultiplexTypeCheck(Module scope, MalBlkPtr mb, InstrPtr pci);
mal_export str CMDmultiplexScript(MalBlkPtr m, MalStkPtr s, InstrPtr p);

#endif /* _MAL_MULTIPLEX_H_ */
@}
@+ Static Type Checker
The first step in handling multiplex operators is to 
assure there doesn;t exist a multiplex implementation
for the operation at hand. If it fails, we provide 
a hook for the type-resolver to determine the outcome of a
multiplex call. This simply requires construction of the 
implicit function call and to rely on the type-resolver
to lookup its definition.

The multiplex operator may be turned into a replacement operator
enclosing with ':' and '=', e.g. multiplex(":+=",b,c) adds the b and
c tails and stores it in b. This case is detected by operatorModifier().
@{
@c
#include "multiplex.h"
#define REALLY_REALLY_BIG	2000000000

/*#define DEBUG_MULTIPLEX */
/*#define TRACE_MULTIPLEX  */
static int multiplexDebug = 0; 

static int batcalcTypeCheck(str operator, int type);

str CMDmultiplexDebug(int *ret, int *b){
	(void) ret ; /* still unused */
	(void) multiplexDebug ; /* still unused */
	multiplexDebug= *b;
	return MAL_SUCCEED;
}
int operatorModifier(str name, str fcnname){
	int i, inplace= FALSE;
	if( fcnname[0]==':'){
		i= strlen(fcnname);
		if(fcnname[i-2]== '=') {
			strncpy(name,fcnname+1, i-=2);
			inplace = TRUE;
		} else	strncpy(name,fcnname,i);
		name[i]=0;
	} else strcpy(name,fcnname);
	return inplace;
}
int typeConformance(MalBlkPtr mb, InstrPtr p, int tpe){
	int dt= getDestType(mb,p);
	int rt;
	str dtname, tpename;
	Client c;

	rt= resolveType(dt,tpe);
	if(rt != -1){
		setDestType(mb,p,tpe);
		return rt;
	}
	tpename= getTypeName(tpe);
	dtname= getTypeName(dt);
	if(moduleId(p))
		GDKerror("type conflict in statement %s.%s[%d] %s<>%s\n",
			moduleName(p), functionName(p), getPC(mb,p),
			dtname,tpename);
	else 	GDKerror("type conflict in statement %s[%d] %s<>%s\n",
			functionName(p), getPC(mb,p),
			dtname,tpename);
	GDKfree(tpename);
	GDKfree(dtname);
	c= getClient();
	if( c && c->listing &(LIST_MAL_INSTR))
		printFunction(c->fdout,mb,c->listing);
	return -1;
}

int multiplexType(Module scope, MalBlkPtr mb, InstrPtr pci,
	MalBlkPtr m, InstrPtr p)
{
	int i, k, t, tpe= TYPE_any, tt;
	int first = TRUE, firstbat=FALSE, inplace= FALSE;
	str fcnname;
	char name[1024];

	(void) scope; /* still unused */
	(void) inplace;

#ifdef DEBUG_MULTIPLEX
	if( multiplexDebug ){
		printf("multiplexType on the instruction:\n");
		printInstruction(GDKout,mb,pci,LIST_MAL_ALL);
	}
#endif
	if( !isConstant(mb,pci->argv[1]) || getArgType(mb,pci,1)!=TYPE_str){
		GDKerror("multiplexType:string constant expected in %s[%d]\n",
			getFcnName(mb), getPC(mb,pci));
		return -1;
	}
	fcnname= getVarLiteral(mb,pci->argv[1]);
	inplace = operatorModifier(name,fcnname);
	setFunctionId(p, GDKstrdup(name));
	k = newVariable(m, newTmpName('M',0),TYPE_any);
	p->argv[0]= k;
#ifdef DEBUG_MULTIPLEX
	if( multiplexDebug) 
	printf("multiplex against operator %s (original %s)\n",
		name,functionName(pci));
#endif
@+ Analysis Of The BAT Parameters
Do basic check on parameters. Look at the tail types in order to derive
a function signature in 'p'. Check that all head types correspond. 
Beware that the operand may refer to a polymorphic type, which can
not be resolved before cloneing.
Constants passed into the multiplex operator are a special case.
@c
	for(i=2; i < pci->argc; i++) {
	    t= getArgType(mb,pci,i);
	    if( isaBatType(t) ){
		tt = getTailType(t);
		if (first){
			firstbat= TRUE;
			if( isPolyType(t)){
#ifdef DEBUG_MULTIPLEX
			if( multiplexDebug) 
				printf("multiplex against polymorphic type error\n");
#endif
				return -1;
			}
			if( getHeadType(t) != TYPE_any) {
				first= FALSE;
				tpe= getHeadType(t);
			}
		} else{
@-
Beware, the BAT header types in this case could be a mix of oid and void.
They are conformable in the current implementation with respect to
join compatibility.
A polymorphic type is not allowed anymore at this stage,
@c
			int t2 = getHeadType(t);
			if( !( (tpe == TYPE_void && t2 == TYPE_oid) ||
			       (tpe == TYPE_oid && t2 == TYPE_void) ) ){
				if( t2 != tpe && tpe!= TYPE_any && t2!= TYPE_any)
				GDKerror("multiplexType:BAT head types %d %d"
					"differ in %s[%d]\n",
					t2,tpe,
					 functionName(pci), getPC(mb,pci));
			}
/*
			if( t2== TYPE_any || tpe== TYPE_any)
					GDKerror("multiplexType:%s[%d]: "
					"explicit BAT type required\n",
					 functionName(pci), getPC(mb,pci));
*/
		}
	    } else {
		tt= getArgType(mb,pci,i);
	    }
	    k= newVariable(m,newTmpName('M',i),tt);
	    p= pushArgument(m,p,k);
	}
	pushInstruction(m,p);

	/* resolve the type of the derived function call */
	if( !firstbat){
		GDKerror("multiplexType:%s[%d]: at least one BAT argument required\n",
				 functionName(pci), getPC(mb,pci));
		return -1;
	} 

#ifdef DEBUG_MULTIPLEX
	if(multiplexDebug ){
		printf("Before typeChecker instruction type\n");
		printInstruction(GDKout,m,p,LIST_MAL_ALL);
	}
#endif
	typeChecker(getClient()->nspace,m,p,TRUE);
#ifdef DEBUG_MULTIPLEX
	if(multiplexDebug ){
		printf("After typeChecker instruction type\n");
		printInstruction(GDKout,m,p,LIST_MAL_ALL);
	}
#endif
	if( p->typechk == TYPE_UNKNOWN) {
		/* all tactic choices are turned into their script variant */
		if(idcmp("tactics",functionName(p))==0){
			GDKfree(p->fcnname);
			setFunctionId(p, GDKstrdup("script"));
		}
		return -1;
	}

	tt= getArgType(m,p,0);
	tpe= newBatType(tpe,tt);
	i= typeConformance(mb,pci,tpe);
#ifdef DEBUG_MULTIPLEX
	if( multiplexDebug && i<0){
		printf("Type conformance on %d failed\n",tpe);
		printf("type tt =%s <> bat[%d,%d]\n",
			getTypeName(getDestType(mb,pci)),
			getHeadType(tpe),getTailType(tpe));
		printInstruction(GDKout,m,p,LIST_MAL_ALL);
		printInstruction(GDKout,mb,pci,LIST_MAL_ALL);
	}
#endif
	if(i<0) return -1;
	
	/* re-use old code to resolve the element of the multiplex module */
	fcnname= moduleName(pci);
	setModuleId(pci, NULL);
	/* initialize the instruction further?*/
#ifdef DEBUG_MULTIPLEX
	if(multiplexDebug){
		printf("--> initialize instruction further\n");
		printInstruction(GDKout,mb,pci,LIST_MAL_ALL);
	}
#endif
	/* findFunctionType(scope,mb,pci); Why ? pci has not been changed*/
	pci->token= PATcall;
	pci->fcn = (MALfcn) CMDmultiplexScript;
	setModuleId(pci, fcnname);
	pci->typechk= p->typechk;
#ifdef DEBUG_MULTIPLEX
	if(multiplexDebug){
	printf("--> multiplex instruction\n");
	printInstruction(GDKout,m,p,LIST_MAL_ALL);
	printf("--> modified instruction\n");
	printInstruction(GDKout,mb,pci,LIST_MAL_ALL);
	printf("return code %d\n",i);
	}
#endif
	return i;
}
@}
@+ Tactical optimization
A tactical operator multiplex() looks around in the symbol table
to detect any fast implementation. If it does not work,
then it falls back on the script() approach.

Care should be taken not to fall into a too generic
definition in the kernel. For example, the batcalc routines
accept any type, but can handle only the base types.
This type enforcement is encoded here.
Furthermore, any overloaded function should reside in the
corresponding atom module

Note that this scheme is particular important for polymorphic
routines, because you do not a priori know whether there exists
a fast variant. This way the MIL parser can simply produce
calls to the script case as well
@{
@c
int multiplexTactics(Module scope, MalBlkPtr mb, InstrPtr pci){
	InstrPtr p;
	int i,olderr,oldtpe;
	str operator;
	Client cntxt= getClient();

	(void) scope; /* still unused */
	if( idcmp(functionName(pci),"tactics")) return -1;
	/* look for constant first argument */
	if( !isConstant(mb,pci->argv[pci->retc])) {
		GDKfree(pci->fcnname);
		setFunctionId(pci, GDKstrdup("script"));
		return -1;
	}
	operator = getVarConstant(mb,pci->argv[pci->retc]).val.sval;

	p= copyInstruction(pci);
	if(functionId(p)) GDKfree(p->fcnname);
	if(moduleId(p)) freeModuleName(p);
	setModuleId(p, NULL);
	setFunctionId(p, GDKstrdup(operator));
	delArgument(p,p->retc);
	olderr= mb->errors;
	if( cntxt->errbuf) i= strlen(cntxt->errbuf); else i=0;
@-
Safe the old type of the destination because we may have to restore it later on.
@c
	oldtpe= getArgType(mb,pci,0);
	typeChecker(cntxt->nspace,mb,p,TRUE);
#ifdef DEBUG_MULTIPLEX
	if(multiplexDebug ){
		printf("Tactics typeChecker instruction type\n");
		printInstruction(GDKout,mb,p,LIST_MAL_ALL);
		printf("error= %s type=%d\n",cntxt->errbuf,p->typechk);
	}
#endif
	if( cntxt->errbuf ) cntxt->errbuf[i] =0;
	mb->errors= olderr;
	if(p->typechk == TYPE_UNKNOWN) {
		setFunctionId(pci, GDKstrdup("script"));
		freeInstruction(p);
		setArgType(mb,pci,0,oldtpe);
		return -1;
	}
@-
Applying a multiplex to a bat-of-bats should always be
handled with a script. 
@c
/*
	printInstruction(GDKout,mb,pci,LIST_MAL_ALL);
	printf("tail type %d %d\n",
		 isaBatType(getArgType(mb,pci,2)),
		 getTailType(getArgType(mb,pci,2)) ); */
	if( getTailType(getArgType(mb,pci,2))==TYPE_bat  ){
#ifdef DEBUG_MULTIPLEX
		if( multiplexDebug)
		printf("--> ignored bat-of-bat multiplex\n");
#endif
		setArgType(mb,pci,0,oldtpe);
		setFunctionId(pci, GDKstrdup("script"));
		freeInstruction(p);
		return -1;
	}
@-
Check out type of the operands for use with batcalc
@c
	if( moduleId(p) && idcmp("batcalc",moduleName(p))==0 && 
	   (i=batcalcTypeCheck(operator, 
		getTailType(getArgType(mb,p,0))) ) < 0){
		/* postpone fixation until datatype is fixed */
		/* tobe done */
		setFunctionId(pci, GDKstrdup("script"));
		freeInstruction(p);
		setArgType(mb,pci,0,oldtpe);
		return -1;
	}
	clrInstruction(pci);
	oldmoveInstruction(pci,p);
#ifdef DEBUG_MULTIPLEX
	if( multiplexDebug){
	printf("--> modified trial instruction\n");
	printInstruction(GDKout,mb,p,LIST_MAL_ALL);
	printf("return code %s\n",getTypeName(getArgType(mb,pci,0)));
	}
#endif
	freeInstruction(p);
	return getArgType(mb,pci,0);
}

int CMDmultiplexTypeCheck(Module scope, MalBlkPtr mb, InstrPtr pci)
{
	int i= -1;
	MalBlkPtr m= newMalBlk(MAXVARS,MAXSTMTS);
	InstrPtr p = newInstruction(ASSIGNsymbol);

	if( idcmp("debug",functionName(pci))==0){
		if(moduleId(pci)==0) setModuleId(pci, GDKstrdup("multiplex"));
		pci->fcn= (MALfcn) CMDmultiplexDebug;
		pci->token = CMDcall;
		i= 1;
	}
	if( i<0) i= multiplexTactics(scope,mb,pci);
	if( i<0) i= multiplexType(scope,mb,pci,m,p);
	freeMalBlk(m);
	return i;
}
@}
@+ Generic Version
All multiplex calls can be translated into a batloop variant.
This is considered the generic solution, to be used when the modules
do not provide a fast implementation of the multiplex equivalent.

The call multiplex.script(CMD,A1,...An) introduces the following function:

@verbatim
function CMD000(A1,....,An):bat
	resB:= new(headtype,tailtype);
barrier (mloop,h,t):= newIterator(Ai);
	$1:= bat.find(A1,h);
	$2:= A2;	# in case of constant?
	...
	cr:= mod.CMD($1,...,$n);
	insert(resB,h,cr);
	redo (mloop,h,t):= hasMoreElements(Ai);
end mloop;
	return resB;
end CMD000;
@end verbatim

This script is generated on the fly, because we do not a priori
known the number/type of arguments. 

@{
The algorithm consists of two phases: phase one deals with
collecting the relevant information, phase two is the actual
code construction.
@= malInstr
	q= newInstruction(EXITsymbol);
	pushReturn(m,q,@2);
	pushInstruction(m,q);
@c
str CMDmultiplexScript(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	int i,k,l,mloop,refBat=0,resB,refType,cr,fcnid;
	int nilVar=0 /*, mvar*/;
	str ret= MAL_SUCCEED;
	int hvar,tvar, rIndex=0;
#ifdef DEBUG_MULTIPLEX
	int assignop = FALSE;
#endif
	char name[128],fcnname[128];
	str s= (str) getArgValue(stk,pci,1);
	MalBlkPtr m,m1;
	InstrPtr q,p;
	static int fcnnr;
	/* ValPtr retval;*/


	(void) nilVar; /* fool compiler */
	(void) s; /* fool compiler */
	m1 = newMalBlk(MAXVARS,MAXSTMTS);
	p = newInstruction(ASSIGNsymbol);
	/* perform type analysis  and function resolution */
	i= multiplexType(getClient()->nspace,mb,pci,m1,p);
	if( i<0)
		return throwMessage("multiplex.script", "type error");
	/* get result type of multiplexed operation */
	refType = getArgType(m1,p,0);

#ifdef DEBUG_MULTIPLEX
	if(strcmp(s,functionName(p)) ) assignop= TRUE;
#endif
	m= newMalBlk(MAXVARS,MAXSTMTS);

#ifdef DEBUG_MULTIPLEX
	if(multiplexDebug){
	printf("calling the multiplex script routine\n");
	printf("multiplex against operator %s (%d):%s\n",
		functionName(p),assignop, getTypeName(refType));
	}
#endif
@-
Determine the reference BAT for the loop and make it known
in the new mal block.
@c
	for(i=2; i < pci->argc; i++)
	if( isaBatType( k = getArgType(mb,pci,i) ) ){
		sprintf(name,"A%d",i);
		/* refBat= newVariable(m, GDKstrdup(name),k);*/
		refType = newBatType(getHeadType(k),refType);
		rIndex = i;
		break;
	}

	/* function multiplex(A1,....,An):bat[ht,tt] */
	q= newInstruction(FUNCTIONsymbol);
	sprintf(fcnname,"multiplex%d",fcnnr++);
	setFunctionId(q, GDKstrdup(fcnname));
	fcnid= newVariable(m,GDKstrdup(fcnname), refType);
	pushReturn(m,q,fcnid);
@-
Beware, the operator constant (arg=1) is passed along as well,
because in the end we issue a recursive function call that should
find the actual arguments at the proper place of the callee.
@c
	for(i=1;i<pci->argc;i++){
		sprintf(name,"A%d",i);
		k= newVariable(m, GDKstrdup(name), getArgType(mb,pci,i));
		q= pushArgument(m,q,k);
		if( i== rIndex) refBat = k;
	}
	pushInstruction(m,q);

	/* resB := new(headtype,tailtype */
	q= newInstruction(ASSIGNsymbol);
	q->argc=0;
	resB = newVariable(m,GDKstrdup("resB"),refType);
	pushArgument(m,q,resB);
	setModuleId(q, GDKstrdup("bbp"));
	setFunctionId(q, GDKstrdup("new"));
	i= newTypeVariable(m, getHeadType(refType));
	pushArgument(m,q,i);
	i= newTypeVariable(m, getTailType(refType));
	pushArgument(m,q,i);
	pushInstruction(m,q);
	
/* catch   MALexception and propagate it */
	q= newInstruction(CATCHsymbol);
	k= newVariable(m, GDKstrdup("MALexception"),TYPE_str);
	pushReturn(m,q,k);
	pushInstruction(m,q);
/* propagate exception */
	q= newInstruction(RAISEsymbol);
	pushReturn(m,q,k);
	pushArgument(m,q, newConstant(m,TYPE_str,GDKstrdup("Failed to create bat"),TRUE));
	pushInstruction(m,q);
/* early exit */
	q= newInstruction(RETURNsymbol);
	pushReturn(m,q, getArg(getInstrPtr(mb,0),0));
	pushArgument(m,q,resB);
	pushInstruction(m,q);
/* return to caller */
	@:malInstr(EXIT,k)@	

	/* create nil constant for void-columns */
	if( getHeadType(refType) == TYPE_void){
		q= newInstruction(ASSIGNsymbol);
		setModuleId(q, GDKstrdup("bat"));
		setFunctionId(q, GDKstrdup("setSequenceBase"));
		pushReturn(m,q, newTmpVariable(m,TYPE_any));
		pushArgument(m,q, resB);
		pushArgument(m,q, newConstant(m,TYPE_oid,GDKstrdup("0@0"),TRUE));
		nilVar=newConstant(m,TYPE_void,GDKstrdup("nil"),TRUE);
		pushInstruction(m,q);
	}
	

/* x:= getRole(rb) 
	q= newInstruction(ASSIGNsymbol);
	setModuleId(q, GDKstrdup("bat"));
	setFunctionId(q, GDKstrdup("getRole"));
	x= newVariable(m,GDKstrdup("x"),TYPE_str);
	pushReturn(m,q,x);
	pushArgument(m,q,resB);
	pushInstruction(m,q);
*/

/* setRoles(resB, ..., CMD 
	q= newInstruction(ASSIGNsymbol);
	setModuleId(q, GDKstrdup("bat"));
	setFunctionId(q, GDKstrdup("setRole"));
	pushReturn(m,q newTmpVariable(m,TYPE_any));
	pushArgument(m,q,resB);
	pushArgument(m,q,x);
	pushArgument(m,q, newConstant(m,TYPE_str,GDKstrdup(functionName(p)),FALSE));
	pushInstruction(m,q);
*/

	/* barrier (mloop,h,r):= newIterator(refBat); */
	q= newInstruction(BARRIERsymbol);
	setModuleId(q, GDKstrdup("chopper"));
	setFunctionId(q, GDKstrdup("newIterator"));
	mloop= newVariable(m,GDKstrdup("mloop"),TYPE_lng);
	pushReturn(m,q,mloop);
	hvar= newVariable(m,GDKstrdup("h"),TYPE_any);
	pushReturn(m,q,hvar);
	sprintf(name,"B%d",rIndex);
	tvar= newVariable(m,GDKstrdup(name),TYPE_any);
	pushReturn(m,q,tvar);
	pushArgument(m,q,refBat);
	pushInstruction(m,q);

	/* $1:= bat.find(Ai,h) or constant */
	for(i=2;i<pci->argc;i++)
	if( isaBatType(l= getArgType(mb,pci,i)) && i!= rIndex){
		q= newInstruction(ASSIGNsymbol);
		sprintf(name,"B%d",i);
		pushReturn(m,q,newVariable(m, GDKstrdup(name), getTailType(l)));
		setModuleId(q, GDKstrdup("algebra"));
		sprintf(name,"A%d",i);
		pushArgument(m,q, newVariable(m,GDKstrdup(name),l));
/*
		if( nilVar){
			setFunctionId(q, GDKstrdup("fetch"));
			pushArgument(m,q,mvar);
		} else 
*/ 		{ setFunctionId(q, GDKstrdup("find"));
			pushArgument(m,q,hvar);
		}
		pushInstruction(m,q);
#ifdef TRACE_MULTIPLEX
	q= newInstruction(ASSIGNsymbol);
	pushReturn(m,q, newTmpVariable(m,TYPE_any));
	setFunctionId(q, GDKstrdup("print"));
	pushArgument(m,q,hvar);
	pushInstruction(m,q);
#endif
	}

	/* cr:= mod.CMD($1,...,$n); */
	q= newInstruction(ASSIGNsymbol);
	cr= newVariable(m,GDKstrdup("cr"), getTailType(getArgType(m,p,0)) );
	pushReturn(m,q,cr);
	setModuleId(q, GDKstrdup(moduleName(p)));
	setFunctionId(q, GDKstrdup(functionName(p)));
	for(i=2;i<pci->argc;i++)
	if( isaBatType(getArgType(mb,pci,i)) ){
		sprintf(name,"B%d",i);
		q= pushArgument(m,q,findVariable(m,name));
	} else{
		sprintf(name,"A%d",i);
		q= pushArgument(m,q, findVariable(m,name));
	}
	pushInstruction(m,q);

#ifdef TRACE_MULTIPLEX
	q= newInstruction(ASSIGNsymbol);
	pushReturn(m,q,newTmpVariable(m,TYPE_any));
	setFunctionId(q, GDKstrdup("print"));
	pushArgument(m,q,hvar);
	pushInstruction(m,q);
	q= newInstruction(ASSIGNsymbol);
	pushReturn(m,q,newTmpVariable(m,TYPE_any));
	setFunctionId(q, GDKstrdup("print"));
	pushArgument(m,q,cr);
	pushInstruction(m,q);
#endif


	/* insert(resB,h,cr); */
	q= newInstruction(ASSIGNsymbol);
	setModuleId(q, GDKstrdup("bat"));
	setFunctionId(q, GDKstrdup("insert"));
	pushReturn(m,q,newTmpVariable(m,TYPE_any));
	pushArgument(m,q,resB);
	pushArgument(m,q,hvar);
	pushArgument(m,q,cr);
	pushInstruction(m,q);


/* catch   MALexception and ignore them */
	q= newInstruction(CATCHsymbol);
	k= newVariable(m, GDKstrdup("MALexception"),TYPE_str);
	pushReturn(m,q,k);
	pushInstruction(m,q);

#ifdef TRACE_MULTIPLEX
	/* z:= inspect.symbolDefinition(); print(z); */
	{ int zz= hvar;
	q= newInstruction(ASSIGNsymbol);
	setModuleId(q, GDKstrdup("io"));
	setFunctionId(q, GDKstrdup("print"));
	pushReturn(m,q,newTmpVariable(m,TYPE_any));
	pushArgument(m,q,zz);
	pushInstruction(m,q);
	/* z:= inspect.stkFrame(); print(z) */
	q= newInstruction(ASSIGNsymbol);
	setModuleId(q, GDKstrdup("mdb"));
	setFunctionId(q, GDKstrdup("getStackFrame"));
	zz= newVariable(m,GDKstrdup("stkFrame"),newBatType(TYPE_str,TYPE_str));
	pushReturn(m,q,zz);
	pushInstruction(m,q);
	q= newInstruction(ASSIGNsymbol);
	setModuleId(q, GDKstrdup("io"));
	setFunctionId(q, GDKstrdup("print"));
	pushReturn(m,q,newTmpVariable(m,TYPE_any));
	pushArgument(m,q,zz);
	pushInstruction(m,q);
	}
	
	/* #ignore errors unless you are debugging; */
	q= newInstruction(ASSIGNsymbol);
	pushReturn(m,q,newTmpVariable(m,TYPE_any));
	setFunctionId(q, GDKstrdup("raise"));
	pushArgument(m,q,k);
	pushInstruction(m,q);
#endif
	@:malInstr(EXIT,k)@	
	/* redo (mloop,h,r):= hasMoreElements(refBat); */
	q= newInstruction(REDOsymbol);
	setModuleId(q, GDKstrdup("chopper"));
	setFunctionId(q, GDKstrdup("hasMoreElements"));
	pushReturn(m,q,mloop);
	pushReturn(m,q,hvar); 
	pushReturn(m,q,tvar);
	pushArgument(m,q,refBat);
	pushInstruction(m,q);
	@:malInstr(EXIT,mloop)@	/* redo mloop; */

	q= newInstruction(RETURNsymbol);
	pushReturn(m,q,getArg(getInstrPtr(mb,0), 0));
	pushArgument(m,q,resB);
	pushInstruction(m,q);
	q= newInstruction(ENDsymbol);
	pushReturn(m,q,fcnid);
	pushInstruction(m,q);
@-
It is time to type check the code and request for any optimization.
@c
	chkProgram(getClient()->nspace,m);
	if(m->errors) {
		printf("# ERROR in multiplex function generated\n");
		printFunction(GDKout,m, LIST_MAL_ALL);
	}
#ifdef DEBUG_MULTIPLEX
	if(multiplexDebug){
	printf("# multiplex function generated\n");
	printFunction(GDKout,m, LIST_MAL_ALL);
	fflush(stdout);
	}
#endif
@-
After all the preparatory work has been finished, it is time to
execute the new routine and to return its value. 
Upon exit, we set the return value of the enclosing instruction
and leave it up to the interpreter to deal with exception handling.
@c
	stk->pcup = getPC(mb,pci);
	ret= runMAL(getClient(),m,1,mb,stk,pci);
@-
It is tempting to retain the function in the namespace of
the client. However, this complicates the administration, e.g.
how to detect that a previous instance is already available.
Therefore, we simple remove the temporary function.
@c

	freeMalBlk(m);
	freeMalBlk(m1);
	return ret;
}
@+ Type check
The batcalc operator signatures are quite permissive
with respect to the types they accept. However, only a few
are actually supported and the other leads to a runtime
error. For code squeezing this is not acceptable and we
need a routine to test validity. Actually, this test
should be part of the batcalc module itself.
@c
int batcalcTypeCheck(str operator, int type){
	int tt= getTailType(type);
	int ret = -1;

	switch(tt){
	case TYPE_any: ret= -2; break;
	case TYPE_flt: 
	case TYPE_dbl: if(idcmp("%",operator)==0) {ret= -1; break;}
	case TYPE_str: 
	case TYPE_bit: 
	case TYPE_oid:
	case TYPE_sht:
	case TYPE_int:
	case TYPE_lng: ret= type; 
	}
#ifdef DEBUG_MULTIPLEX
	if( multiplexDebug){
		printf("batcalc type checker %s %d\n", getTypeName(type),ret);
	}
#endif
	return ret;
}

@}
