@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@' 
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@' 
@' The Original Code is the Monet Database System.
@' 
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2004 CWI.
@' All Rights Reserved.
@' 
@' Contributor(s):
@' 		Martin Kersten <Martin.Kersten@cwi.nl>
@' 		Peter Boncz <Peter.Boncz@cwi.nl>
@' 		Niels Nes <Niels.Nes@cwi.nl>
@' 		Stefan Manegold  <Stefan.Manegold@cwi.nl>

@f multiplex
@t The Multiplex Script
@a Peter Boncz, Martin Kersten

@* Multiplexed Function Execution 
This module contains the generic implementation of the 
MIL [X]() multiplex operators. 
Multiplex operators provide the possibility of executing any
command "CMD" (or operators or FUNCTIONs) with signature:
@
CMD(T1,..,Tn) : Tr
@
on a series of BATs with corresponding head values 
by putting the command between square brackets, giving the
following corresponding signature:.
@
[CMD](bat[any::1,T1],...,bat[any::1,Tn]) : bat[any::1,Tr]
@
and
@
CMD(T1,...,Tn) : Tr
@
Implementation of the multiplex is done by performing the
natural join on all bat-valued parameters, and executing the 
CMD for each combination of matching tuples. All results are 
collected in a result BAT. 
All but one argument may be replaced by a scalar value.

There are two main factors that determine how the multiplex is 
executed: what kind of command is CMD (either function, 'simple'
operator, or 'complex' operator)? and: how easy is it to
construct the natural join on the bat parameters? 

In Monet version 4, most multiplex operators encountered in 
practice dealt with arithmetic and coercions on BAT tails.
This common case has been further optimized in the implementation
of the batcalc module.

MAL does not directly support arbitrary overloading of an
operator to become its multiplex-ed variant. Instead,
a call is made to the PATTERN multiplex.script(CMD,A1,...An)
where CMD is a string literal.
This multiplex module comes with a different type checker,
which enables static type checking of most multiplex operations.

The implementation provided here is meant to retain much of
the multiplex functionality in Version 4.
For each multiplex call for which there does not exist a fast
primitive implementation,
we generate a MAL script on the fly, which is then executed.
Subsequent improvements should come from massaging the MAL code
or to derived a fast C-based implementation.

@mal
module multiplex check = CMDmultiplexTypeCheck;

pattern tactics(CMD:str, a:any...):any = CMDmultiplexScript
comment "Tactical optimizer for multiplexed instructions.";

pattern script(CMD:str, a:any...):any = CMDmultiplexScript
comment "Generic processor for mutiplexed instructions.";

@h
#ifndef _MAL_MULTIPLEX_H_
#define _MAL_MULTIPLEX_H_
#include "mal.h"
#include "mal_interpreter.h"
#include "mal_resolve.h"
#include "mal_client.h"

/*#define DEBUG_MULTIPLEX  */
/*#define TRACE_MULTIPLEX   */

mal_export int CMDmultiplexTypeCheck(Scope scope, MalBlkPtr mb, InstrPtr pci);
mal_export str CMDmultiplexScript(MalBlkPtr m, MalStkPtr s, InstrPtr p);

#endif /* _MAL_MULTIPLEX_H_ */

@- Static Type Checker
The first step in handling multiplex operators is to provide 
a hook for the type-resolver to determine the outcome of a
multiplex call. This simply requires construction of the 
implicit function call and to rely on the type-resolver
to lookup its definition.

The multiplex operator may be turned into a replacement operator
enclosing with ':' and '=', e.g. multiplex(":+=",b,c) adds the b and
c tails and stores it in b. This case is detected by operatorModifier();
@c
#include "multiplex.h"
#define REALLY_REALLY_BIG	2000000000
static int multiplexDebug=0;

static int batcalcTypeCheck(str operator, int type);

str CMDmultiplexDebug(int *ret, int *b){
	(void) ret ; /* still unused */
	(void) multiplexDebug ; /* still unused */
	multiplexDebug= *b;
	return MAL_SUCCEED;
}
int operatorModifier(str name, str fcnname){
	int i, inplace= FALSE;
	if( fcnname[0]==':'){
		i= strlen(fcnname);
		if(fcnname[i-2]== '=') {
			strncpy(name,fcnname+1, i-=2);
			inplace = TRUE;
		} else	strncpy(name,fcnname,i);
		name[i]=0;
	} else strcpy(name,fcnname);
	return inplace;
}
int typeConformance(MalBlkPtr mb, InstrPtr p, int tpe){
	int dt= getDestType(mb,p);
	int rt;
	Client c;

	rt= resolveType(dt,tpe);
	if(rt != -1){
		setDestType(mb,p,tpe);
		return rt;
	}
	if(moduleId(p))
		GDKerror("type conflict in statement %s.%s[%d]\n",
			moduleName(p), functionName(p), getPC(mb,p));
	else 	GDKerror("type conflict in statement %s[%d]\n",
			functionName(p), getPC(mb,p));
	c= getClient();
	if( c && c->listing &(LIST_MAL_INSTR))
		printFunction(c->fdout,mb,c->listing);
	return -1;
}

int multiplexType(Scope scope, MalBlkPtr mb, InstrPtr pci,
	MalBlkPtr m, InstrPtr p)
{
	int i, k, t, tpe= TYPE_void, tt;
	int first = TRUE, inplace= FALSE;
	str fcnname;
	char name[1024];

	(void) scope; /* still unused */
	(void) inplace;

#ifdef DEBUG_MULTIPLEX
	printf("multiplexType on the instruction:\n");
	if( multiplexDebug) printInstruction(GDKout,mb,pci,LIST_MAL_ALL);
#endif
	if( !isConstant(mb,pci->argv[1]) || getArgType(mb,pci,1)!=TYPE_str){
		GDKerror("multiplexType:string constant expected in %s[%d]\n",
			getFcnName(mb), getPC(mb,pci));
		return -1;
	}
	fcnname= getVarLiteral(mb,pci->argv[1]);
	inplace = operatorModifier(name,fcnname);
	setFunctionId(p, GDKstrdup(name));
	k = newVariable(m, newTmpName(0),TYPE_any);
	p->argv[0]= k;
#ifdef DEBUG_MULTIPLEX
	if( multiplexDebug) 
	printf("multiplex against operator %s (original %s)\n",
		name,functionName(pci));
#endif
@- Analysis Of The BAT Parameters
Do basic check on parameters. Look at the tail types in order to derive
a function signature in 'p'. Check that all head types correspond. 
Constants passed into the multiplex operator are a special case.
@c
	for(i=2; i < pci->argc; i++) {
	    t= getArgType(mb,pci,i);
	    if( isaBatType(t) ){
		if (first){
			first= FALSE;
			tpe= getHeadType(t);
		} else{
			if( getHeadType(t) != tpe)
			GDKerror("multiplexType:BAT head types differ\n");
		}
		tt = getTailType(t);
	    } else {
		tt= getArgType(mb,pci,i);
	    }
	    k= newVariable(m,newTmpName(i),tt);
	    p= pushArgument(m,p,k);
	}
	pushInstruction(m,p);

	/* resolve the type of the derived function call */
	if( first){
		GDKerror("multiplexType:at least one BAT argument required\n");
		return -1;
	} 

#ifdef DEBUG_MULTIPLEX
	if(multiplexDebug ){
		printf("Before typeChecker instruction type\n");
		printInstruction(GDKout,m,p,LIST_MAL_ALL);
	}
#endif
	typeChecker(getClient()->nspace,m,p);
#ifdef DEBUG_MULTIPLEX
	if(multiplexDebug ){
		printf("After typeChecker instruction type\n");
		printInstruction(GDKout,m,p,LIST_MAL_ALL);
	}
#endif
	if( p->typechk == TYPE_UNKNOWN) {
		/* all tactic choices are turned into their script variant */
		if(idcmp("tactics",functionName(p))==0){
			GDKfree(p->fcnname);
			setFunctionId(p, GDKstrdup("script"));
		}
		return -1;
	}

	tt= getArgType(m,p,0);
	tpe= newBatType(tpe,tt);
	i= typeConformance(mb,pci,tpe);
#ifdef DEBUG_MULTIPLEX
	if( multiplexDebug && i<0){
		printf("Type conformance on %d failed\n",tpe);
		printf("type tt =%d bat[%d,%d]\n",tt, getHeadType(tpe),getTailType(tpe));
		printInstruction(GDKout,m,p,LIST_MAL_ALL);
		printInstruction(GDKout,mb,pci,LIST_MAL_ALL);
	}
#endif
	if(i<0) return -1;
	
	/* re-use old code to resolve the element of the multiplex module */
	fcnname= moduleName(pci);
	setModuleId(pci, NULL);
	/* initialize the instruction further?*/
#ifdef DEBUG_MULTIPLEX
	if(multiplexDebug){
		printf("--> initialize instruction further\n");
		printInstruction(GDKout,mb,pci,LIST_MAL_ALL);
	}
#endif
	/* findFunctionType(scope,mb,pci); Why ? pci has not been changed*/
	pci->token= PATcall;
	pci->fcn = (MALfcn) CMDmultiplexScript;
	setModuleId(pci, fcnname);
	pci->typechk= p->typechk;
#ifdef DEBUG_MULTIPLEX
	if(multiplexDebug){
	printf("--> multiplex instruction\n");
	printInstruction(GDKout,m,p,LIST_MAL_ALL);
	printf("--> modified instruction\n");
	printInstruction(GDKout,mb,pci,LIST_MAL_ALL);
	printf("return code %d\n",i);
	}
#endif
	return i;
}
@- Tactical optimization
A tactical operator multiplex() looks around in the symbol table
to detect any fast implementation. If it does not work,
then it falls back on the script() approach.

Care should be taken not to fall into a too generic
definition in the kernel. For example, the batcalc routines
accept any type, but can handle only the base types.
This type enforcement is encoded here.

Furthermore, any overloaded function should reside in the
corresponding atom module

Note that this scheme is particular important for polymorphic
routines, because you do not a priori know whether there exists
a fast variant. This way the MIL parser can simply produce
calls to the script case as well
@c
int multiplexTactics(Scope scope, MalBlkPtr mb, InstrPtr pci){
	InstrPtr p;
	int i,olderr;
	str operator;
	Client cntxt= getClient();

	(void) scope; /* still unused */
	if( idcmp(functionName(pci),"tactics")) return -1;
	/* look for constant first argument */
	if( !isConstant(mb,pci->argv[pci->retc])) {
		GDKfree(pci->fcnname);
		setFunctionId(pci, GDKstrdup("script"));
		return -1;
	}
	operator = getVarConstant(mb,pci->argv[pci->retc]).val.sval;

	p= copyInstruction(pci);
	if(functionId(p)) GDKfree(p->fcnname);
	if(moduleId(p)) GDKfree(p->modname);
	setModuleId(p, NULL);
	setFunctionId(p, GDKstrdup(operator));
	delArgument(p,p->retc);
	olderr= mb->errors;
	if( cntxt->errbuf) i= strlen(cntxt->errbuf); else i=0;
	typeChecker(cntxt->nspace,mb,p);
#ifdef DEBUG_MULTIPLEX
	if(multiplexDebug ){
		printf("Tactics typeChecker instruction type\n");
		printInstruction(GDKout,mb,p,LIST_MAL_ALL);
	}
#endif
	if( cntxt->errbuf ) cntxt->errbuf[i] =0;
	mb->errors= olderr;
	if(p->typechk == TYPE_UNKNOWN) {
		setFunctionId(pci, GDKstrdup("script"));
		freeInstruction(p);
		return -1;
	}
@-
Check out type of the operands for use with batcalc
@c
	if( moduleId(p) && idcmp("batcalc",moduleName(p))==0 && 
	   (i=batcalcTypeCheck(operator, getArgType(mb,p,0))) < 0){
		/* postpone fixation until datatype is fixed */
		/* tobe done */
		setFunctionId(pci, GDKstrdup("script"));
		freeInstruction(p);
		return -1;
	}
	clrInstruction(pci);
	oldmoveInstruction(pci,p);
#ifdef DEBUG_MULTIPLEX
	if( multiplexDebug){
	printf("--> modified trial instruction\n");
	printInstruction(GDKout,mb,p,LIST_MAL_ALL);
	printf("return code %s\n",getTypeName(getArgType(mb,pci,0)));
	}
#endif
	freeInstruction(p);
	return getArgType(mb,pci,0);
}

int CMDmultiplexTypeCheck(Scope scope, MalBlkPtr mb, InstrPtr pci)
{
	int i= -1;
	MalBlkPtr m= newMalBlk(MAXVARS,MAXSTMTS);
	InstrPtr p = newInstruction(ASSIGNsymbol);

	if( idcmp("debug",functionName(pci))==0){
		if(moduleId(pci)==0) setModuleId(pci, GDKstrdup("multiplex"));
		pci->fcn= (MALfcn) CMDmultiplexDebug;
		pci->token = CMDcall;
		i= 1;
	}
	if( i<0) i= multiplexTactics(scope,mb,pci);
	if( i<0) i= multiplexType(scope,mb,pci,m,p);
	freeMalBlk(m);
	return i;
}
@+ Generic Version
All multiplex calls can be translated into a batloop variant.
This is considered the generic solution, to be used when the modules
do not provide a fast implementation of the multiplex equivalent.

The call multiplex.script(CMD,A1,...An) introduces the following function:
@T
\begin{verbatim}
function CMD000(A1,....,An):bat
	resB:= new(headtype,tailtype);
barrier mloop:= bunStream(Ai,h,t);
	$1:= bat.find(A1,h);
	$2:= A2;	# in case of constant?
	...
	cr:= mod.CMD($1,...,$n);
	insert(resB,h,cr);
catch 	MALexception;
	#ignore errors
end	MALexception;
	redo mloop;
end mloop;
	return resB;
end CMD000;
\end
@
This script is generated on the fly, because we do not a priori
known the number/type of arguments. 

The algorithm consists of two phases: phase one deals with
collecting the relevant information, phase two is the actual
code construction.
@= malInstr
	q= newInstruction(@1symbol);
	q->argv[0]= @2 ;
	if(@1symbol == EXITsymbol) q->barrier= EXITsymbol;
	pushInstruction(m,q);
@c
str CMDmultiplexScript(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	int i,k,l,mloop,refBat=0,resB,refType,cr;
	int nilVar=0 /*, mvar*/;
	str ret= MAL_SUCCEED;
	int hvar,rIndex=0;
#ifdef DEBUG_MULTIPLEX
	int assignop = FALSE;
#endif
	char name[128];
	str s= (str) getArgValue(stk,pci,1);
	MalBlkPtr m,m1;
	InstrPtr q,p;
	static int fcnnr;
	ValPtr retval;


	(void) nilVar; /* fool compiler */
	(void) s; /* fool compiler */
	m1 = newMalBlk(MAXVARS,MAXSTMTS);
	p = newInstruction(ASSIGNsymbol);
	/* perform type analysis  and function resolution */
	i= multiplexType(getClient()->nspace,mb,pci,m1,p);
	if( i<0)
		return throwMessage("multiplex.script", "type error");
	/* get result type of multiplexed operation */
	refType = getArgType(m1,p,0);

#ifdef DEBUG_MULTIPLEX
	if(strcmp(s,functionName(p)) ) assignop= TRUE;
#endif
	m= newMalBlk(MAXVARS,MAXSTMTS);

#ifdef DEBUG_MULTIPLEX
	if(multiplexDebug){
	printf("calling the multiplex script routine\n");
	printf("multiplex against operator %s (%d):%s\n",
		functionName(p),assignop, getTypeName(refType));
	}
#endif
@-
Determine the reference BAT for the loop and make it known
in the new mal block.
@c
	for(i=2; i < pci->argc; i++)
	if( isaBatType( k = getArgType(mb,pci,i) ) ){
		sprintf(name,"A%d",i);
		/* refBat= newVariable(m, GDKstrdup(name),k);*/
		refType = newBatType(getHeadType(k),refType);
		rIndex = i;
		break;
	}

	/* function multiplex(A1,....,An):bat[ht,tt] */
	q= newInstruction(FUNCTIONsymbol);
	sprintf(name,"multiplex%d",fcnnr++);
	setFunctionId(q, GDKstrdup(name));
	q->argv[0]= newVariable(m,GDKstrdup(name), refType);
@-
Beware, the operator constant (arg=1) is passed along as well,
because in the end we issue a recursive function call that should
find the actule arguments at the proper place of the callee.
@c
	for(i=1;i<pci->argc;i++){
		sprintf(name,"A%d",i);
		k= newVariable(m, GDKstrdup(name), getArgType(mb,pci,i));
		q= pushArgument(m,q,k);
		if( i== rIndex) refBat = k;
	}
	pushInstruction(m,q);

	/* resB := new(headtype,tailtype */
	q= newInstruction(ASSIGNsymbol);
	q->argv[0]= resB = newVariable(m,GDKstrdup("resB"),refType);
	setModuleId(q, GDKstrdup("bbp"));
	setFunctionId(q, GDKstrdup("new"));
	q->argv[1]= newTmpVariable(m, getHeadType(refType));
	q->argv[2]= newTmpVariable(m, getTailType(refType));
	q->argc= 3;
	pushInstruction(m,q);
	
	/* create nil constant for void-columns */
	if( getHeadType(refType) == TYPE_void){
		q= newInstruction(ASSIGNsymbol);
		setModuleId(q, GDKstrdup("bat"));
		setFunctionId(q, GDKstrdup("setSequenceBase"));
		q->argv[0]= newTmpVariable(m,TYPE_any);
		q->argv[1]= resB;
		q->argv[2]= newConstant(m,TYPE_oid,GDKstrdup("nil"),TRUE);
		nilVar=newConstant(m,TYPE_void,GDKstrdup("nil"),TRUE);
		q->argc= 3;
		pushInstruction(m,q);
	}
	

/* x:= getRole(rb) 
	q= newInstruction(ASSIGNsymbol);
	setModuleId(q, GDKstrdup("bat"));
	setFunctionId(q, GDKstrdup("getRole"));
	q->argv[0]= x= newVariable(m,GDKstrdup("x"),TYPE_str);
	q->argv[1]= resB;
	q->argc=2;
	pushInstruction(m,q);
*/

/* setRoles(resB, ..., CMD 
	q= newInstruction(ASSIGNsymbol);
	setModuleId(q, GDKstrdup("bat"));
	setFunctionId(q, GDKstrdup("setRole"));
	q->argv[0]= newTmpVariable(m,TYPE_any);
	q->argv[1]= resB;
	q->argv[2]= x;
	q->argv[3]= newConstant(m,TYPE_str,GDKstrdup(functionName(p)),FALSE);
	q->argc=4;
	pushInstruction(m,q);
*/

	/* barrier mloop:= bunStream(refBat,h,rIndex); */
	q= newInstruction(ASSIGNsymbol);
	q->barrier = BARRIERsymbol;
	q->argv[0]= mloop= newVariable(m,GDKstrdup("mloop"),TYPE_lng);
	setModuleId(q, GDKstrdup("bbp"));
	setFunctionId(q, GDKstrdup("bunStream"));
	q->argv[1] = refBat;
	hvar= q->argv[2] = newVariable(m,GDKstrdup("h"),getHeadType(refType));
	sprintf(name,"B%d",rIndex);
	q->argv[3] = newVariable(m,GDKstrdup(name),
		getTailType(getArgType(mb,pci,refBat)));
	q->argc= 4;
	pushInstruction(m,q);

	/* $1:= bat.find(Ai,h) or constant */
	for(i=2;i<pci->argc;i++)
	if( isaBatType(l= getArgType(mb,pci,i)) && i!= rIndex){
		q= newInstruction(ASSIGNsymbol);
		sprintf(name,"B%d",i);
		q->argv[0]= newVariable(m, GDKstrdup(name), getTailType(l));
		setModuleId(q, GDKstrdup("algebra"));
		sprintf(name,"A%d",i);
		q->argv[1]= newVariable(m,GDKstrdup(name),l);
/*
		if( nilVar){
			setFunctionId(q, GDKstrdup("fetch"));
			q->argv[2]= mvar;
		} else */ { setFunctionId(q, GDKstrdup("find"));
			q->argv[2]= hvar;
		}
		q->argc=3;
		pushInstruction(m,q);
#ifdef TRACE_MULTIPLEX
	q= newInstruction(ASSIGNsymbol);
	q->argv[0]= newTmpVariable(m,TYPE_any);
	setFunctionId(q, GDKstrdup("print"));
	q->argv[1] = zv;
	q->argc=2;
	pushInstruction(m,q);
#endif
	}

        /* cr:= mod.CMD($1,...,$n); */
	q= newInstruction(ASSIGNsymbol);
	cr= q->argv[0]= newVariable(m,GDKstrdup("cr"),
			getTailType(getArgType(m,p,0)) );
	setModuleId(q, GDKstrdup(moduleName(p)));
	setFunctionId(q, GDKstrdup(functionName(p)));
	for(i=2;i<pci->argc;i++)
	if( isaBatType(getArgType(mb,pci,i)) ){
		sprintf(name,"B%d",i);
		q= pushArgument(m,q,findVariable(m,name));
	} else{
		sprintf(name,"A%d",i);
		q= pushArgument(m,q, findVariable(m,name));
	}
	pushInstruction(m,q);

#ifdef TRACE_MULTIPLEX
	q= newInstruction(ASSIGNsymbol);
	q->argv[0]= newTmpVariable(m,TYPE_any);
	setFunctionId(q, GDKstrdup("print"));
	q->argv[1] = hvar;
	q->argc=2;
	pushInstruction(m,q);
	q= newInstruction(ASSIGNsymbol);
	q->argv[0]= newTmpVariable(m,TYPE_any);
	setFunctionId(q, GDKstrdup("print"));
	q->argv[1] = cr;
	q->argc=2;
	pushInstruction(m,q);
#endif


        /* insert(resB,h,cr); */
	q= newInstruction(ASSIGNsymbol);
	setModuleId(q, GDKstrdup("bat"));
	setFunctionId(q, GDKstrdup("insert"));
	q->argv[0]= newTmpVariable(m,TYPE_void);
	q->argv[1]= resB;
	q->argv[2]= hvar;
	q->argv[3]= cr;
	q->argc=4;
	pushInstruction(m,q);


	/* catch   MALexception; */
	q= newInstruction(CATCHsymbol);
	q->barrier = CATCHsymbol;
	k= q->argv[0]= newVariable(m, GDKstrdup("MALexception"),TYPE_str);
	pushInstruction(m,q);

#ifdef TRACE_MULTIPLEX
	/* z:= inspect.symbolDefinition(); print(z); */
	{ int zz;
	q= newInstruction(ASSIGNsymbol);
	setModuleId(q, GDKstrdup("io"));
	setFunctionId(q, GDKstrdup("print"));
	q->argv[0]= newTmpVariable(m,TYPE_any);
	q->argv[1]= zz;
	q->argc=2;
	pushInstruction(m,q);
	/* z:= inspect.stkFrame(); print(z) */
	q= newInstruction(ASSIGNsymbol);
	setModuleId(q, GDKstrdup("inspect"));
	setFunctionId(q, GDKstrdup("getStackFrame"));
	q->argv[0]= zz= newTmpVariable(m,newBatType(TYPE_str,TYPE_str));
	q->argc=1;
	pushInstruction(m,q);
	q= newInstruction(ASSIGNsymbol);
	setModuleId(q, GDKstrdup("io"));
	setFunctionId(q, GDKstrdup("print"));
	q->argv[0]= newTmpVariable(m,TYPE_any);
	q->argv[1]= zz;
	q->argc=2;
	pushInstruction(m,q);
	}
	
	/* #ignore errors unless you are debugging; */
	q= newInstruction(ASSIGNsymbol);
	q->argv[0]= newTmpVariable(m,TYPE_any);
	setFunctionId(q, GDKstrdup("raise"));
	q->argv[1] = k;
	q->argc=2;
	pushInstruction(m,q);
#endif
	@:malInstr(EXIT,k)@	/* end  MALexception; */
	@:malInstr(REDO,mloop)@	/* redo mloop; */
	@:malInstr(EXIT,mloop)@	/* redo mloop; */
	q= newInstruction(RETURNsymbol);
	q->argv[0]= resB ;
	q->argv[1]= resB ;
	q->argc=2;
	q->retc=1;
	pushInstruction(m,q);
	@:malInstr(END,0)@/* end function ; */
@-
It is time to type check the code and request for any optimization.
@c
	chkProgram(getClient()->nspace,m);
	if(m->errors) {
		printf("# ERROR in multiplex function generated\n");
		printFunction(GDKout,m, LIST_MAL_ALL);
	}
#ifdef DEBUG_MULTIPLEX
	if(multiplexDebug){
	printf("# multiplex function generated\n");
	printFunction(GDKout,m, LIST_MAL_ALL);
	fflush(stdout);
	}
#endif
@-
After all the preparatory work has been finished, it is time to
execute the new routine and to return its value. 
Upon exit, we set the return value of the enclosing instruction
and leave it up to the interpreter to deal with exception handling.
@c
        retval=  &stk->stk[pci->argv[0]];
        garbageElement(retval);
        ret= runMAL(getClient(),m,mb,stk,pci);
@-
It is tempting to retain the function in the namespace of
the client. However, this complicates the administration, e.g.
how to detect that a previous instance is already available.
Therefore, we simple remove the temporary function.
@c

	freeMalBlk(m);
	freeMalBlk(m1);
	return ret;
}
@- Type check
The batcalc operator signatures are quite permissive
with respect to the types they accept. However, only a few
are actually supported and the other leads to a runtime
error. For code squeezing this is not acceptable and we
need a routine to test validity. Actually, this test
should be part of the batcalc module itself.
@c
int batcalcTypeCheck(str operator, int type){
	int tt= getTailType(type);
	switch(tt){
	case TYPE_any: return -2;
	case TYPE_flt: 
	case TYPE_dbl: if(idcmp("%",operator)==0) return -1;
	case TYPE_oid:
	case TYPE_sht:
	case TYPE_int:
	case TYPE_lng: return type;
	}
	return -1;
}
