@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@' 
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@' 
@' The Original Code is the Monet Database System.
@' 
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2004 CWI.
@' All Rights Reserved.
@' 
@' Contributor(s):
@' 		Martin Kersten <Martin.Kersten@cwi.nl>
@' 		Peter Boncz <Peter.Boncz@cwi.nl>
@' 		Niels Nes <Niels.Nes@cwi.nl>
@' 		Stefan Manegold  <Stefan.Manegold@cwi.nl>

@f atoms
@a M.L. Kersten
@v 1.0
@* User defined atoms
Monet supports definitions of user-defined types. 
This feature is of particular interest to system experts. 
It is not meant for end-users trying to introduce record- or 
struct-like objects in the database. They better decompose
the complex object structure and represent the components in
different BATs.

For the courageous at heart, you may enter the difficult world
of extending the kernel library. This calls for studying the
documentation associated with the atom structures (gdk_atoms),
because you have to develop routines complying with the
signatures required in the GDK library.

Once you have assembled these primitive, you can introduce them
in a running server using a ATOM MODULE definition, which contains
a MAL specification of their signature and calls to the routines
below to register the atom in the kernel.

Each ruler dealing with registering a function performs the necessary
type check, but relies on the user to comply with this signature in
its C-implementation. The ruler calls are part of a module
initialization routine.

A concrete example is the 'blob' datatype (see blob.mx)
@mal
module atoms;

pattern tostr(nme:str):int   
address atomsToStr;
pattern fromstr(nme:str):int 
address atomsFromStr;
pattern nequal(nme:str):int  
address atomsNequal;
pattern hash(nme:str):int    
address atomsHash;
pattern null(nme:str):int    
address atomsNull;
pattern convert(nme:str):int 
address atomsConvert;
pattern put(nme:str):int     
address atomsPut;
pattern del(nme:str):int     
address atomsDel;
pattern length(nme:str):int  
address atomsLength;
pattern heap(nme:str):int    
address atomsHeap;

@{
@c
@+ The Module implementation
@h

#ifndef _MAL_ATOMS
#define _MAL_ATOMS
#include "mal_resolve.h"
#include "mal_stack.h"

#include "mal_function.h"
#define DEBUG_MAL_ATOMS 1
#endif /*  _MAL_ATOMS*/

@c
#include "atoms.h"
str atomsToStr(MalBlkPtr m, MalStkPtr s, InstrPtr p){
	(void) m; (void)s; (void) p; /* fool compiler */
	return throwMessage("atoms.ToStr", "not yet implemented\n");
}
str atomsFromStr(MalBlkPtr m, MalStkPtr s, InstrPtr p){
	(void) m; (void)s; (void) p; /* fool compiler */
	return throwMessage("atoms.fromStr", "not yet implemented\n");
}
str atomsNequal(MalBlkPtr m, MalStkPtr s, InstrPtr p){
	(void) m; (void)s; (void) p; /* fool compiler */
	return throwMessage("atoms.nequal", "not yet implemented\n");
}
str atomsHash(MalBlkPtr m, MalStkPtr s, InstrPtr p){
	(void) m; (void)s; (void) p; /* fool compiler */
	return throwMessage("atoms.hash", "not yet implemented\n");
}
str atomsNull(MalBlkPtr m, MalStkPtr s, InstrPtr p){
	(void) m; (void)s; (void) p; /* fool compiler */
	return throwMessage("atoms.null", "not yet implemented\n");
}
str atomsConvert(MalBlkPtr m, MalStkPtr s, InstrPtr p){
	(void) m; (void)s; (void) p; /* fool compiler */
	return throwMessage("atoms.convert", "not yet implemented\n");
}
str atomsPut(MalBlkPtr m, MalStkPtr s, InstrPtr p){
	(void) m; (void)s; (void) p; /* fool compiler */
	return throwMessage("atoms.put", "not yet implemented\n");
}
str atomsDel(MalBlkPtr m, MalStkPtr s, InstrPtr p){
	(void) m; (void)s; (void) p; /* fool compiler */
	return throwMessage("atoms.del", "not yet implemented\n");
}
str atomsheap(MalBlkPtr m, MalStkPtr s, InstrPtr p){
	(void) m; (void)s; (void) p; /* fool compiler */
	return throwMessage("atoms.heap", "not yet implemented\n");
}
str atomsLength(MalBlkPtr m, MalStkPtr s, InstrPtr p){
	(void) m; (void)s; (void) p; /* fool compiler */
	return throwMessage("atoms.length", "not yet implemented\n");
}
@}
