@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2005 CWI.
@' All Rights Reserved.

@f rsbox
@a Fabian Groffen
@v 1.0
@* ResultSet support box
This module acts as a simple box of ResultSet objects.
A ResultSet is a thin wrapper around a number of BATs that allows
serialising the values in the BATs to the extended MAPI result
format.  This box is able to construct new ResultSets and manages
them from a user perspective.

Normally, objects are stored into the box using {\sc deposit}
and taken out with {\sc take}.  This box however, only knows
{\sc create} and {\sc take}.  ResultSets cannot
be stored, because the only way to create them is by using the
{\sc create} function, which automatically deposits the newly
created ResultSet in the box.  The {\sc release} function allows
to remove a ResultSet from the box.

A box should be opened before being used. It is typically used
to set-up the list of current users and to perform authorization.

The initialisation actions are encapsulated in the prelude
routine called.

The ResultSetBox will perform access control checks upon
{\sc take} operations to ensure a user only has access to his
own ResultSet objects.

The existing functionality of mal_box allows to store and retrieve
items somehow.  In the future we might want to switch to those
supplied tools.  For now we stick with (documented and) simple
elements such as structs and an array.  As a result, we are NOT
thread safe.

@+ The ResultSet atom
A ResultSet is a container for a set of BATs that form together
a result of a user query.  The purpose of the ResultSet is to
hand a uniform interface to both application and foreign client
by defining how to build a ResultSet from BATs and on the other
hand serialising the given BATs in a predefined format.

A ResultSet requires all its associated BATs to be of equal
length and :bat[:void,:any] typed, for this allows efficient
serialisation.

A new empty ResultSet can be obtained by calling the
newResultSet() function.  The state of that ResultSet will be
`uncomplete', which means that BATs can be added as new columns
on that ResultSet, as well as properties of such column can be
set.
The function addColumn(:resultset,:bat[:void,:any],nme:str) will
add the given BAT to the ResultSet as a column with the given
name, if and only if the BAT has the proper length, otherwise
an exception will be thrown.  Note that the name is not required
to be unique due to SQL semantics.  Upon successful addition of
the BAT, the number of the newly added column is returned, which
can be used in future setProperty calls.
The setProperty functionality comes in three flavours.  The first
and most simple form setProperty(:resultset,nme:str,val:str) adds a
name/value pair to the last added column.  The variants
setProperty(:resultset,col:str,nme:str,val:str) and
setProperty(:resultset,col:int,nme:str,val:str) do basically the
same, but use an explicit reference to a column either as name or
number.
The former one is supplied for convenience, but should be avoided
in general use, as it uses a sequential scan to find the right
column, and can result in an undesired update if two columns have
the same name.
All three methods overwrite previous values, if set.  Note that
certain values are created by default, when adding a new column.
These defaults include `length', `name' and `type'.

Before a ResultSet can be serialised, if has to be marked as
`complete'.  Calling setComplete(:resultset) marks the ResultSet
as such and disallows any calls to addColumn or setProperty.
Instead the serialisation functions writeHeader and writeBlock
are enabled.  For convenience, the wrapper function writeNextPart
combines writeHeader and writeBlock such that only the first
call includes the header and all consecutive calls only include
results.  The return value of hasNextPart is an int indicating
whether there is a next part to write using the function
writeNextPart.  The size of the blocks can be set using the
setBlockSize function.

Finally, to properly release a ResultSet and all its associated
resources, the function delete(:resultset) should be
called.  This function frees all associated BAT columns and
properties.

@mal
atom resultset:int;

command addColumn(rs:resultset,b:bat[:void,:any],nme:str):resultset
address RSaddColumn
comment "Add a BAT as column with a name to this ResultSet";
command setProperty(rs:resultset,nme:str,val:str):resultset
address RSsetPropertyLastCol
comment "Sets the given property to the given value on the last added column";
command setProperty(rs:resultset,col:str,nme:str,val:str):resultset
address RSsetPropertyColNme
comment "Sets the given property to the given value on the first
column with the given name";
command setProperty(rs:resultset,col:int,nme:str,val:str):resultset
address RSsetPropertyColNum
comment "Sets the given property to the given value on the given column";
command findColumn(rs:resultset,nme:str):int
address RSfindColumn
comment "Returns the first column that matches the given name";
command setComplete(rs:resultset):resultset
address RSsetComplete
comment "Marks this ResultSet as complete and ready for serialisation";
command writeHeader(rs:resultset):int
address RSwriteHeader
comment "Writes the header of this ResultSet to the given stream";
command writeBlock(rs:resultset,upper:int,lower:int):int
address RSwriteBlock
comment "Writes the results from upper to lower to the stream";
command getLength(rs:resultset):int
address RSgetLength
comment "Returns the size of this ResultSet as number of rows";
command setBlockSize(rs:resultset,size:int):resultset
address RSsetBlockSize
comment "Sets the block size used by writeNextPart";
command hasNextPart(rs:resultset):bit
address RShasNextPart
comment "Returns whether there is another part to write by writeNextPart";
command writeNextPart(rs:resultset):int
address RSwriteNextPart
comment "Writes the next part to the stream.  If it is the first part,
the header will be written to the stream first.  The size of the blocks
is determined by the value supplied via the setBlockSize function.";

# ResultSets themselves should never be serialised to disk.  The
# fromStr and toStr functions merely exist to adhere to the interface
command fromstr():resultset
address RSfromString
comment "Discards the string and does nothing (returns nil)";
command tostr():str
address RStoString
comment "Returns a string indicating this is a ResultSet";

module rsbox
comment "The resultset box implementation provides a store for
query results";

command open():void
address RSBopen
comment "Locate and open the resultset box";
command close():void
address RSBclose
comment "Close the resultset box";
command destroy():void
address RSBdestroy
comment "Destroy the resultset box and all the resultsets it contains";

command create(name:str):resultset
address RSBcreate
comment "Create a new ResultSet and deposit it in the box";

command take(id:str):resultset
address RSBtake
comment "Take a resultset with the given id out of the box";
command deposit(name:str,set:resultset):void 		
address RSBdeposit
comment "Store a new resultset into the box (only there to comply
to the interface, throws an exception, use create instead)";

command releaseAll():void
address RSBreleaseAll
comment "Release all resultsets for this client in the box";
command release(rs:resultset):void
address RSBdelete
comment "Release this ResultSet and all its associated resources from
the box";
command release(id:str):void
address RSBrelease
comment "Release the resultset with the given id";

command discard(id:str):void 		
address RSBrelease
comment "see rsbox.release(id:str)";

command newIterator()(:lng,:resultset)
address RSBiterator
comment "Initialize the iterator over the resultset box";
command hasMoreElements()(:lng,:resultset)
address RSBhasMoreElements
comment "Locate next resultset in the box";

@-
The content of the box consists of result sets.
Their handle is represented by an atom to ease
type analysis of the resultset box operations.
@mal
@{
@-
@+ Implementation
@h
#ifndef _RSBOX_H
#define _RSBOX_H 1

#include "mal.h"
#include "mal_client.h"
#include "mal_interpreter.h"

#define RS_MAX_PROPERTIES	10

typedef struct column_t {
	BAT* bat;				/* BAT that backs this column */
	BUN bun;				/* a walker variable */
	str name;				/* the name/id of this column */
	int(* format) (str*, int*, ptr);	/* formatting used when serialising */
	str properties[RS_MAX_PROPERTIES];	/* an array of properties */
	struct column_t* next;	/* the next column in this list */
} column;

typedef struct resultset_t {
	column* firstColumn;	/* head of the linked list of column */
	unsigned int blocksize;	/* the number of rows per block */
	size_t length;			/* the number of rows in this ResultSet */
	size_t pos;				/* the current row position */
	str id;					/* external reference ID of this ResultSet */
	char complete;			/* whether this ResultSet can be serialised */
	char type;				/* type of result */
	str propertynames[RS_MAX_PROPERTIES];	/* an array of property names */
} resultset;

#define RS_EXTENDED		0	/* JDBC/ODBC format */
#define RS_MONET4		1	/* former BATmultiprintf */
#define RS_RAW			2	/* unstructured character data */
#define	RS_BINARY		3	/* binary data, length known */
#define RS_HTML			4	/* structured (X)(H)TML formatted character data */
#define RS_SAX			5	/* SAX event stream */

typedef struct rsbox_element {
	resultset* rs;
	int clientId;
	/* PRIMARY KEY (rs->name, clientId) */
} element;

#endif
@c
#include "rsbox.h"
#include <stream.h>
#include "mal.h"
#include "mal_exception.h"

/* convenience macros */
#define throw(X, Y)		return(throwMessage(X, Y));
#define throwf(X, Y, Z)	return(throwException(MALEXCEPTION, X, Y, Z));
#define idMatches(X, Y)	((X)->clientId == getClient()->idx && \
	strcmp((X)->rs->id, Y) == 0)
#define resolveHandle(X, Y) \
	if ((tmp = RSBgetResultSet(X, Y)) != MAL_SUCCEED) return(tmp);

/** How many elements we can handle at a time */
#define RSB_MAX_ELEMS	20
/** Array which contains all the elements contained in this Set */
static element* elements[RSB_MAX_ELEMS];

/**
 * Returns the resultset from an element for a given array slot.
 * An exception is thrown if the array slot is empty or out of
 * bounds.
 */
static str RSBgetResultSet(resultset** retval, int* handle) {
	resultset* rs;
	
	if (handle == NULL)
		throw("rsbox.getResultSet", "Handle should not be NULL");
	if (*handle < 0 || *handle > RSB_MAX_ELEMS)
		throw("rsbox.getResultSet", "Handle index out of bounds");
	if (*handle == 0)
		throw("rsbox.getResultSet", "Invalid handle: not initialised");
	if (elements[*handle - 1] == NULL)
		throw("rsbox.getResultSet", "Handle points to an empty slot");

	rs = elements[*handle - 1]->rs;
	if (elements[*handle - 1]->clientId != getClient()->idx)
		throw("rsbox.getResultSet", "Access denied");
	
	*retval = rs;
	return(MAL_SUCCEED);
}

@- Operator implementation
@-
@c
/**
 * Simply open (or create) the box.  We don't need access control, as
 * anyone is allowed to have this box.  Access control is done later
 * on.
 */
str RSBopen(int *ret){
	(void) ret;
	if (openBox("rsbox") == 0)
		throw("rsbox.open", "failed to open box");

	return(MAL_SUCCEED);
}

/**
 * Deposit does not work for a ResultSet box.  Use create instead.
 *
 * @throws exception
 */
str RSBdeposit(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci) {
	(void)mb; (void)stk; (void)pci; /* make compiler happy */
	throw("rsbox.deposit", "Operation not supported: use rsbox.create");
}

/**
 * Create a new ResultSet with the given string as id.  The
 * ResultSet is immediately deposited in the box, and its
 * handle is returned.
 */
str RSBcreate(int* retval, str* name) {
	resultset* rs;
	int i, free = -1;

	/* check the given name is a unique id (and find the first free slot) */
	for (i = 0; i < RSB_MAX_ELEMS; i++) {
		if (elements[i] != NULL) {
			if (idMatches(elements[i], *name))
				throwf(
					"rsbox.create",
					"A ResultSet with id '%s' already exists",
					*name);
		} else {
			/* this is a free slot */
			if (free == -1) {
				/* somehow hide it from other threads (not safe!) */
				elements[i] = GDKmalloc(sizeof(element));
				elements[i]->clientId = getClient()->idx;
				elements[i]->rs = NULL;
				free = i;
			}
		}
	}
	if (free == -1)
		throw("rsbox.create", "No free slots available");

	rs = GDKmalloc(sizeof(resultset));
	/* initialise the values to null */
	memset(rs, 0, sizeof(resultset));
	/* set the id */
	rs->id = GDKstrdup(*name);

	/* store it in the backing array... */
	elements[free]->rs = rs;

	/* and return the index as handle */
	*retval = free + 1;
	return(MAL_SUCCEED);
}

/**
 * Returns for the given id, the corresponding ResultSet handle.
 * Throws an exception if no such ResultSet is found.
 * The actual int returned is the container element array position.
 */
str RSBtake(int* retval, str* id) {
	int i;

	for (i = 0; i < RSB_MAX_ELEMS; i++) {
		if (elements[i] != NULL && idMatches(elements[i], *id)) {
			*retval = i + 1;
			return(MAL_SUCCEED);
		}
	}
	
	throwf("rsbox.take", "No such element with id '%s'", *id);
}

/**
 * Helper function to properly free column structs.  This function
 * uses recursion to properly free all members of the list.
 *
 * @param column the column to free
 */
static str RSBfreeColumn(column* col) {
	int i;
	
	if (col == NULL)
		throw("resultset.freeColumn", "Column should NOT be NULL");
	
	if (col->next != NULL) RSBfreeColumn(col->next);
	BBPunfix(col->bat->batCacheid);
	GDKfree(col->name);
	for (i = 0; i < RS_MAX_PROPERTIES; i++)
		if (col->properties[i] != NULL) GDKfree(col->properties[i]);
	GDKfree(col);

	return(MAL_SUCCEED);
}

/**
 * Releases the given ResultSet and all its associated rescources.
 *
 * @param handle a resultset handle
 */
str RSBdelete(void* retval, int* handle) {
	int i;
	resultset* rs;
	str tmp;
	element* elem;
	(void)retval;	/* make compiler happy */
	
	resolveHandle(&rs, handle);
	
	elem = elements[*handle - 1];
	elements[*handle - 1] = NULL;
	
	/* first free all columns using a recursive function */
	RSBfreeColumn(rs->firstColumn);
	GDKfree(rs->id);
	for (i = 0; i < RS_MAX_PROPERTIES; i++)
		if (rs->propertynames[i] != NULL) GDKfree(rs->propertynames[i]);
		else break;
	/* finally free the struct itself */
	GDKfree(rs);

	GDKfree(elem);
	
	*handle = 0;
	return(MAL_SUCCEED);
}

/**
 * Releases the given ResultSet and all its associated rescources.
 *
 * @param id a resultset id
 */
str RSBrelease(void* retval, str* id) {
	str tmp;
	int handle;
	(void)retval;	/* make compiler happy */

	if ((tmp = RSBtake(&handle, id)) != MAL_SUCCEED) return(tmp);
	return(RSBdelete(NULL, &handle));
}

/**
 * Releases all the ResultSets that are associated to the user.
 */
str RSBreleaseAll() {
	str tmp;
	int i, handle;

	for (i = 0; i < RSB_MAX_ELEMS; i++) {
		if (elements[i] != NULL && elements[i]->clientId == getClient()->idx) {
			handle = i + 1;
			if ((tmp = RSBdelete(NULL, &handle)) != MAL_SUCCEED) return(tmp);
		}
	}

	return(MAL_SUCCEED);
}

/**
 * Increases the cursor by one and returns the next resultset handle,
 * if available.
 *
 * @return ret1 iterator cursor
 * @return ret2 resultset handle
 */
str RSBhasMoreElements(lng* ret1, int* ret2) {
	int pos, handle;

	if (*ret1 + 1 < RSB_MAX_ELEMS) {
		pos = ((int)*ret1) + 1;
		for (; pos < RSB_MAX_ELEMS; pos++) {
			if (elements[pos] != NULL && elements[pos]->clientId == getClient()->idx) {
				handle = pos + 1;
				*ret1 = (lng)pos;
				*ret2 = handle;
				return(MAL_SUCCEED);
			}
		}
	}
	
	/* tell there are no more elements */
	*ret1 = -1;
	*ret2 = 0;
	return(MAL_SUCCEED);
}

/**
 * Iterator thinghy that returns the starting point of an
 * iteration over all ResultSets stored in the box that are
 * owned by the caller.
 *
 * @return ret1 iterator cursor
 * @return ret2 resultset handle
 */
str RSBiterator(lng* ret1, int* ret2) {
	*ret1 = -1;
	return(RSBhasMoreElements(ret1, ret2));
}

/**
 * Closes the complete box.  This operation should checks whether
 * there are ResultSets in the box not owned by the caller.  If
 * this is the case, the ResultSets owned by the caller are removed
 * and an exception is thrown.
 */
str RSBclose() {
	str tmp;
	int i;
	
	if ((tmp = RSBreleaseAll()) != MAL_SUCCEED) return(tmp);
	
	for (i = 0; i < RSB_MAX_ELEMS; i++)
		if (elements[i] != NULL)
			throw("rsbox.close", "Unable to close: there are still ResultSets in the box not owned by you");

	if (closeBox("rsbox", TRUE) != 0)
		throw("rsbox.close", "failed to close box");

	return(MAL_SUCCEED);
}

/**
 * Destroys the complete box.
 */
str RSBdestroy(int *ret){
	return(RSBclose(ret));
}

@-
@+ Implementation of the resultset
@c

/**
 * Small helper function that calculates the max width of the
 * tail value of the given BAT.
 *
 * @param b the BAT to scan the tail from
 * @return the max width of the tail
 */
static str tailWidth(int* retval, BAT* b) {
	BUN p, q;
	int max = 0;

	if (b == NULL)
		throw("resultset.tailWidth", "BAT should not be NULL");

	switch (b->ttype) {
		case TYPE_bit:
			max = 5;	/* false */
		break;
		case TYPE_chr:
			max = 1;
		break;
		case TYPE_oid:
			max = 11;	/* wild guess */
		break;
		case TYPE_sht: {
			lng maxval = 0;
			BATloop(b, p, q) {
				sht *l = (sht*)BUNtail(b, p);
				maxval += *l;
			}
			while (maxval /= 10) max++;
		} break;
		case TYPE_int: {
			lng maxval = 0;
			BATloop(b, p, q) {
				int *l = (int*)BUNtail(b, p);
				maxval += *l;
			}
			while (maxval /= 10) max++;
		} break;
		case TYPE_lng: {
			lng maxval = 0;
			BATloop(b, p, q) {
				lng *l = (lng*)BUNtail(b, p);
				maxval += *l;
			}
			while (maxval /= 10) max++;
		} break;
		case TYPE_flt:
			max = 12;	/* SQL99 max stdout */
		break;
		case TYPE_dbl:
			max = 24;	/* SQL99 max stdout */
		break;
		case TYPE_str:
			BATloop(b, p, q) {
				char *s = BUNtail(b, p);
				int l = strlen(s);

				if (l > max) max = l;
			}
		break;
		case TYPE_ptr: /* C pointer! */
		case TYPE_bat: /* BAT id: index in BBPcache */
		default:
			throw("resultset.tailWidth", "Invalid BAT tail type!");
	}		

	*retval = max;
	return(MAL_SUCCEED);
}


/**
 * Helper function that sets a property for a column.  If the
 * maximum property count is reached, an exception is thrown.
 * When setting the length property, with argument str_nil, the
 * length is automatically determined.  The return
 * value indicates whether a previous value was overwritten.
 * Typical properties are:
 * 	name		name of the column
 *	table		name of the table this column belongs to
 *	schema		name of the schema this column belongs to
 *	digits		digits of this data type
 *	scale		scale of this data type
 *	length		the maximum width of this column
 * Note: the name length is used for width due to historical
 *       (legacy) reasons.
 *
 * @param rs the resultset the column belongs to
 * @param col the column to set the property for
 * @param nme the name of the property
 * @param val the value of the property
 * @return true if there was a previous value, false otherwise
 */
static str RSsetPropertyInternal(
	int* retval,
	resultset* rs,
	column* col,
	str* nme,
	str* val)
{
	int ret = 0, n;

	if (*nme == NULL)
		throw("resultset.setProperty", "Property name should not be NULL");

	for (n = 0; n < RS_MAX_PROPERTIES; n++) {
		if (rs->propertynames[n] == NULL) {
			rs->propertynames[n] = GDKstrdup(*nme);
			break;
		} else if (strcmp(rs->propertynames[n], *nme) == 0) break;
	}
	if (n == RS_MAX_PROPERTIES)
		throwf("resultset.setProperty", "Maximum number of properties already set (%d)", RS_MAX_PROPERTIES);
	
	if (col->properties[n] != NULL) {
		ret = 1;
		GDKfree(col->properties[n]);
	}
	
	if (strcmp("length", *nme) == 0 && strNil(*val)) {
		int width;
		str tmp;
		char* buf = GDKmalloc(sizeof(char) * 10);
		memset(buf, 0, 10);
		if ((tmp = tailWidth(&width, col->bat)) != MAL_SUCCEED) {
			GDKfree(buf);
			return(tmp);
		}
		snprintf(buf, 9, "%d", width);
		col->properties[n] = buf;
	} else {
		col->properties[n] = (*val == NULL ? NULL : GDKstrdup(*val));
	}

	*retval = ret;
	return(MAL_SUCCEED);
}

/**
 * Adds a column to the ResultSet and returns its position in
 * the sequence of columns.  The BAT and name string are taken
 * and freed upon deletion of the ResultSet.
 *
 * @param handle a resultset handle
 * @param bat a :void,:any bat
 * @param nme a string which represents the name of this column
 * @return the modified ResultSet
 */
str RSaddColumn(int* retval, int* handle, int* bat, str* nme) {
	column* col;
	BAT* b;
	int pos = 0;
	resultset* rs;
	str tmp, name = "name";
	
	resolveHandle(&rs, handle);
    if ((b = BATdescriptor(*bat)) == NULL)
        throw("resultset.addColumn", "Cannot access BAT descriptor");
	if (rs->complete)
		throw("resultset.addColumn", "Unable to modify a complete ResultSet");
	if (b->ttype < 0 || b->ttype >= GDKatomcnt)
		throw("resultset.addColumn", "Illegal BAT tail type");

	/* tell the BBP to leave this BAT alone: it's ours! */
	BBPfix(b->batCacheid);

	if ((col = rs->firstColumn) != NULL) {
		/* walk though the linked list till we found the end */
		while (col->next != NULL) {
			pos++;
			col = col->next;
		}
		/* pos is at this point equal to the index of the last column */
		pos++;
		/* check length of BAT and match it with the known length */
		if (rs->length != BATcount(b))
			return(throwMessage("resultset.addColumn", "BATcount does not match those of previous columns"));
		/* add the column */
		col = col->next = GDKmalloc(sizeof(column));
	} else {
		/* this is the first column that is added, take its length as
		 * base for all other columns that get added */
		rs->length = BATcount(b);
		col = rs->firstColumn = GDKmalloc(sizeof(column));
	}
	/* initialise all the values to null */
	memset(col, 0, sizeof(column));
	/* set name */
	col->name = GDKstrdup(*nme);
	col->bat = b;
	col->format = BATatoms[b->ttype].atomToStr;
	/* also add the name to the list of properties */
	if ((tmp = RSsetPropertyInternal(&pos, rs, col, &name, nme)) == MAL_SUCCEED) return(tmp);



	*retval = *handle;
	return(MAL_SUCCEED);
}

/**
 * Sets a property/value pair for the last added column.
 *
 * @param handle a resultset handle
 * @param nme a the name of the property
 * @param val the value of the string
 * @returns whether a previous value was overwritten
 */
str RSsetPropertyLastCol(int* retval, int* handle, str* nme, str* val) {
	column* col;
	resultset* rs;
	str tmp;

	resolveHandle(&rs, handle);
	if (rs->complete)
		throw("resultset.setProperty", "Unable to modify a complete ResultSet");
	if ((col = rs->firstColumn) == NULL)
		throw("resultset.setProperty", "No column added yet");

	/* find reference to last column */
	while (col->next != NULL) col = col->next;

	return(RSsetPropertyInternal(retval, rs, col, nme, val));
}

/**
 * Sets a property/value pair for the column with the given name.
 * Note that this function can result in an unintented update,
 * as column names are not required to be unique.  The first
 * column that matches the name will be updated.
 *
 * @param handle a resultset struct
 * @param col a string representing the name of the column
 * @param nme a the name of the property
 * @param val the value of the string
 * @returns whether a previous value was overwritten
 */
str RSsetPropertyColNme(int* retval, int* handle, str* col, str* nme, str* val) {
	column* column;
	resultset* rs;
	str tmp;
	
	resolveHandle(&rs, handle);
	if (rs->complete)
		throw("resultset.setProperty", "Unable to modify a complete ResultSet");
	if ((column = rs->firstColumn) == NULL)
		throw("resultset.setProperty", "No column added yet");

	do {
		if (strcmp(column->name, *col) == 0) break;
		column = column->next;
	} while (column != NULL);
	if (column == NULL)
		throw("resultset.setProperty", "No such column");

	return(RSsetPropertyInternal(retval, rs, column, nme, val));
}

/**
 * Sets a property/value pair for the xth column.
 *
 * @param handle a resultset struct
 * @param col the sequence number of the column starting from 0
 * @param nme a the name of the property
 * @param val the value of the string
 * @returns whether a previous value was overwritten
 */
str RSsetPropertyColNum(int* retval, int* handle, int* col, str* nme, str* val) {
	column* column;
	int i;
	resultset* rs;
	str tmp;
	
	resolveHandle(&rs, handle);
	if (rs->complete)
		throw("resultset.setProperty", "Unable to modify a complete ResultSet");
	if ((column = rs->firstColumn) == NULL)
		throw("resultset.setProperty", "No column added yet");

	for (i = 0; i < *col; i++) {
		if ((column = column->next) == NULL)
			throw("resultset.setProperty", "Column index out of bounds");
	}

	return(RSsetPropertyInternal(retval, rs, column, nme, val));
}

/**
 * Returns the number of the first column that matches the given
 * name.  Note that duplicate column names are allowed.
 *
 * @param handle a resultset handle
 * @param col a string representing the name of the column
 * @returns the column number or -1 if not found
 */
str RSfindColumn(int* retval, int* handle, str* col) {
	column* column;
	int pos = 0;
	resultset* rs;
	str tmp;
	
	resolveHandle(&rs, handle);
	if ((column = rs->firstColumn) == NULL) {
		*retval = -1;
		return(MAL_SUCCEED);
	}
	do {
		if (strcmp(column->name, *col) == 0) break;
		column = column->next;
		pos++;
	} while (column != NULL);
	if (column == NULL) {
		*retval = -1;
		return(MAL_SUCCEED);
	}

	*retval = pos;
	return(MAL_SUCCEED);
}

/**
 * Marks the given ResultSet as being complete.  A ResultSet which
 * is complete, does not allow new columns to be added or properties
 * to be set.  Instead, it does allow serialisation of the ResultSet.
 * Note that a ResultSet without column is considered to be an error.
 *
 * @param handle a resultset handle
 * @return the same resultset handle
 */
str RSsetComplete(int* retval, int* handle) {
	resultset* rs;
	str tmp;
	
	resolveHandle(&rs, handle);
	if (rs->firstColumn == NULL)
		throw("resultset.setComplete", "ResultSet should contain at least one column");

	rs->complete = (char)1;

	*retval = *handle;
	return(MAL_SUCCEED);
}

/**
 * Writes the header for the ResultSet to the given stream.  Note
 * that the ResultSet should be complete in order for this function
 * to work.
 * This function defines the layout of the protocol.
 *
 * @param handle a resultset handle
 * @param s a stream to write to
 * @returns the number of bytes written
 */
str RSwriteHeader(int* retval, int* handle) {
	int bytes = 0, bt, i;
	stream* s = GDKout;
	resultset* rs;
	column* col;
	str tmp;
	
	resolveHandle(&rs, handle);
	if (!rs->complete)
		throw("resultset.writeHeader", "Unable to serialise a non-complete ResultSet");
	
	/* write start of header */
	if (stream_write(s, "#-\n", 3, 1) != 1) {
		*retval = 0;
		throw("resultset.writeHeader", "Error while writing to the stream");
	}
	bytes += 3;
	/* write single value headers */
@= MX-writeHeaderLineSingleValue
	if ((bt = stream_printf(s, "# " @1 " # %s\n", @2, @3)) <= 0)
		throw("resultset.writeHeader", "Error while writing to the stream");
	bytes += bt;
@c
	@:MX-writeHeaderLineSingleValue("%d", rs->type, "querytype")@
	@:MX-writeHeaderLineSingleValue("%s", rs->id == NULL ? "" : rs->id, "id")@
	@:MX-writeHeaderLineSingleValue("%d", rs->length, "tuplecount")@

	/* serialise the header to the stream */
@= MX-writeHeaderLine
	col = rs->firstColumn;	/* setComplete forces this one to be valid */
	if (stream_write(s, "# ", 2, 1) == 1) {
		bytes += 2;
		while (col != NULL) {
			if ((bt = stream_printf(s, @1, @2)) <= 0)
				throw("resultset.writeHeader", "Error while writing to the stream");
			bytes += bt;
			
			col = col->next;

			/* write column or row separator */
			if (col == NULL) {
				if ((bt = stream_printf(s, "\t# %s\n", @3)) <= 0)
					throw("resultset.writeHeader", "Error while writing to the stream");
				bytes += bt;
			} else {
				if (stream_write(s, ",\t", 2, 1) != 1) {
					*retval = 0;
					throw("resultset.writeHeader", "Error while writing to the stream");
				}
				bytes += 2;
			}
		}
	} else {
		*retval = 0;
		throw("resultset.writeHeader", "Error while writing to the stream");
	}
@c
	/* yeah baby!  dirty as hell! */
	for (i = 0; i < RS_MAX_PROPERTIES; i++) {
		if (rs->propertynames[i] == NULL) break;
		@:MX-writeHeaderLine("%s", col->properties[i] == NULL ? "" : col->properties[i], rs->propertynames[i])@
	}

	*retval = bytes;
	return(MAL_SUCCEED);
}

/**
 * Writes a block of results for the ResultSet to the given stream.
 * The block of results starts from upper (inclusive) to lower
 * (exclusive), and will count (upper - lower) rows.  Note
 * that the ResultSet should be complete in order for this function
 * to work.
 * This function defines the layout of the protocol.
 *
 * @param handle a resultset handle
 * @param s a stream to write to
 * @param upper till which row of the result (exclusive)
 * @param lower from which row of the result (inclusive)
 * @returns the number of bytes written
 */
str RSwriteBlock(int* retval, int* handle, int* upper, int* lower) {
	int bytes = 0;
	column* col;
	resultset* rs;
	str tmp;
	stream* s = GDKout;
	int low = *lower;
	int t, sz, l;
	ptr p;
	char buf[dblStrlen], *addr = buf;   /* use memory from stack */
	
	resolveHandle(&rs, handle);
	if (!rs->complete)
		throw("resultset.writeBlock", "Unable to serialise a non-complete ResultSet");
	if (*lower < 0)
		throwf("resultset.writeBlock", "Lower index out of bounds (%d < 0)", *lower);
	if (*upper > rs->length)
		throwf("resultset.writeBlock", "Upper index out of bounds (%d > ResultSet length)", *upper);
	if (*lower >= *upper)
		throw("resultset.writeBlock", "Lower index should be smaller than upper index");
	
	/* initialise all column BUN pointers */
	col = rs->firstColumn;	/* setComplete forces this one to be valid */
	while (col != NULL) {
		col->bun = (BUN)((char *)BUNfirst(col->bat) + BUNsize(col->bat) * *lower);
		col = col->next;
	}
	/* write the desired block of results */
	for (; low < *upper; low++) {
		col = rs->firstColumn;
		if (stream_write(s, "[ ", 2, 1) != 1) {
			bytes = 0;
			break;
		}
		bytes += 2;
		while (col != NULL) {
			/* write value */
			t = col->bat->ttype;
			p = (ptr)BUNtail(col->bat, col->bun);
			if (col->format && p) {
				if (t != TYPE_bat && t < TYPE_str) {
					sz = dblStrlen;
					l = (*(col->format)) (&addr, &sz, p);

					stream_write(s, buf, l, 1);
					bytes += l;
				} else {
					tmp = NULL;
					sz = 0;
					l = (*(col->format)) (&tmp, &sz, p);

					l = stream_write(s, tmp, l, 1);
					GDKfree(tmp);
					bytes += l;
				}
			} else {
				stream_write(s, "NULL", 1, 4);
				bytes += 4;
			}
/*
			btmp = strlen(BUNtail(col->bat, col->bun));
			if (stream_write(s, BUNtail(col->bat, col->bun), btmp, 1) != 1) {
				bytes = 0;
				break;
			}
			bytes += btmp;
*/			
			/* advance to the next value in the BAT */
			col->bun = BUNnext(col->bat, col->bun);
			col = col->next;

			/* write column or row separator */
			if (col == NULL) {
				if (stream_write(s, "\t]\n", 3, 1) != 1) {
					bytes = 0;
					break;
				}
				bytes += 3;
			} else {
				if (stream_write(s, ",\t", 2, 1) != 1) {
					bytes = 0;
					break;
				}
				bytes += 2;
			}
		}
	}

	/* stream_errnr(s) ? */

	*retval = bytes;
	if (bytes) {
		return(MAL_SUCCEED);
	} else {
		throw("resultset.writeBlock", "Error while writing to the stream");
	}
}

/**
 * Retrieves the length of the ResultSet measured in number of rows.
 *
 * @param handle a resultset handle
 * @returns the number of rows in the ResultSet
 */
str RSgetLength(int* retval, int* handle) {
	resultset* rs;
	str tmp;
	
	resolveHandle(&rs, handle);
	if (!rs->complete)
		throw("resultset.getLength", "Unable to serialise a non-complete ResultSet");
	
	*retval = rs->length;
	return(MAL_SUCCEED);
}

/**
 * Sets the block size as used by writeNextPart.
 *
 * @param handle a resultset handle
 * @param size the size
 * @return the handle
 */
str RSsetBlockSize(int* retval, int* handle, int size) {
	resultset* rs;
	str tmp;
	
	resolveHandle(&rs, handle);
	/* is this useful?  I don't see any problems now
	if (!rs->complete)
		return(throwMessage("resultset.setBlockSize", "Unable to serialise a non-complete ResultSet"));
	*/

	rs->blocksize = size;
	*retval = *handle;
	return(MAL_SUCCEED);
}

/**
 * Returns the number of blocks that can be retrieved using
 * writeNextPart.  The number is based on the current internal
 * position counter and a step size as defined by a setBlockSize
 * call.  If the block size is 0 (default) an infinite block is
 * assumed.
 *
 * @param handle a resultset handle
 * @return the number of times writeNextPart can be called
 */
str RShasNextPart(int* retval, int* handle) {
	resultset* rs;
	str tmp;
	
	resolveHandle(&rs, handle);
	if (!rs->complete)
		throw("resultset.hasNextPart", "Unable to serialise a non-complete ResultSet");

	if (rs->blocksize > 0) {
		*retval = rs->pos < rs->length ? ((rs->length - rs->pos) / rs->blocksize) + 1 : 0;
	} else {
		*retval = rs->pos < rs->length;
	}
	return(MAL_SUCCEED);
}

/**
 * Writes the next part to the stream.  If it is the first part,
 * the header will be written to the stream first.  The size of the
 * blocks is determined by the value supplied via the setBlockSize
 * function.  If the block size is 0 (default) an infinite block is
 * assumed.
 *
 * @param handle a resultset handle
 * @param s a stream to write to
 * @return the number of bytes written
 */
str RSwriteNextPart(int* retval, int* handle) {
	int hbytes = 0, bbytes = 0;
	int upper, lower;
	resultset* rs;
	str tmp;
	
	resolveHandle(&rs, handle);
	if (!rs->complete)
		throw("resultset.writeNextPart", "Unable to serialise a non-complete ResultSet");

	if (rs->pos < rs->length) {
		if (rs->blocksize == 0) {
			/* serialise the whole result */
			lower = rs->pos;
			upper = rs->length;
		} else {
			/* serialise only a block */
			lower = rs->pos;
			upper = rs->pos + rs->blocksize;
			if (upper > rs->length) upper = rs->length;
		}
	} else {
		throw("resultset.writeNextPart", "No next part, all rows already serialised");
	}

	if (rs->pos == 0) {
		/* write header */
		if ((tmp = RSwriteHeader(&hbytes, handle)) != MAL_SUCCEED) return(tmp);
	}

	/* write block of results */
	if ((tmp = RSwriteBlock(&bbytes, handle, &upper, &lower)) != MAL_SUCCEED)
		return(tmp);
	
	*retval = hbytes + bbytes;
	return(MAL_SUCCEED);
}

/**
 * Interface requirement.  The input string is discarded and null
 * is returned.
 *
 * @param val input string
 * @return always null
 */
str RSfromString(str* src, int *len, resultset* retval) {
	(void)src;	/* make compiler happy */
	(void)retval;
	(void)len;
	return(MAL_SUCCEED);
}

/**
 * Interface requirement.  Returns a string indicating the given
 * ResultSet is a ResultSet.
 *
 * @param handle input ResultSet handle
 * @return "ResultSet"
 */
str RStoString(str* retval, int* len, int* handle) {
	(void)handle;	/* make compiler happy */
	/* you can do all kinds of fancy things like telling how much
	 * columns it has, what size it has, and stuff like that...
	 * but that's not worth the work for now
	 */
	*retval = GDKstrdup("ResultSet");
	*len = 9;
	return(MAL_SUCCEED);
}

@}
@}
