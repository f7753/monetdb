@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2003 CWI.
@' All Rights Reserved.
@'
@' Contributor(s):
@'              Martin Kersten <Martin.Kersten@cwi.nl>
@'              Peter Boncz <Peter.Boncz@cwi.nl>
@'              Niels Nes <Niels.Nes@cwi.nl>
@'              Stefan Manegold  <Stefan.Manegold@cwi.nl>

@f optimizer
@t The optimizer support functions
@a Martin Kersten
@v 0.1

@* The optimizer
This module contains the framework for inclusion query transformers, i.e.
C-programs geared at optimizing a piece of MAL.
The query transformer appears at the language level as an ordinary function,
but it is effective only at a specific execution phase.

Each optimizer function has access to the runtime scope of the
routine in which it is called. This can be used to maintain status
information between successive calls. 

@mal
# The routines below are linked with the kernel by default

MODULE optimizer;

pattern CXoptimizer():str = QOTCXoptimizer;
pattern CXoptimizer(mod:any, fcn:any):str = QOTCXoptimizerCALL
comment "Common subexpression optimizer";
pattern ARoptimizer():str = QOTARoptimizer;
pattern ARoptimizer(mod:any, fcn:any):str = QOTARoptimizerCALL
comment "Alias removal optimizer";
pattern DCoptimizer():str = QOTDCoptimizer;
pattern DCoptimizer(mod:any, fcn:any):str = QOTDCoptimizerCALL
comment "Dead code optimizer";
pattern SPoptimizer(mod:any, fcn:any):str = QOTSPoptimizerCALL
coment "Selection push-down optimizer";
pattern SPoptimizer():str = QOTSPoptimizer;
pattern RRoptimizer():str = QOTRRoptimizer;
pattern RRoptimizer(mod:any, fcn:any):str = QOTRRoptimizerCALL
comment "Reversal idempotency removal";

pattern debugOptimizers():void = QOTdebugOptimizers;

pattern showFlowGraph(M:any,F:any,s:str):void = CMDshowFlowGraph
comment "Dump the data flow of the function M.F in a format
recognizable by the command 'dot' on the file s";

@+ Dummy code 
@h
#ifndef _OPTIMIZER_H
#define _OPTIMIZER_H
#endif /* _OPTIMIZER_H*/
@c
#include "optimizer.h"
#include "mal_interpreter.h"
#include "mal_optimizer.h"

str QOTdebugOptimizers(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	(void) stk; /* fool compiler */
	debugOptimizers(getClient(),mb,getPC(mb,pci));
	return NULL;
}
@-
MAL functions can be optimized explicitly using the routines below.
@= QOTC
str QOT@1optimizerCALL(MalBlkPtr mb, MalStkPtr stk, InstrPtr p){
	str	modnme= getArgName(mb,p,1);
	str	fcnnme= getArgName(mb,p,2);
	Scope  scope=NULL;
	Symbol s= NULL;
	Client c= getClient();

	(void) stk; /* fool compiler */
	scope = findScope(c->nspace,modnme);
	if( scope)
		s= findSymbolInScope(scope,fcnnme);

	if( s == NULL)
		GDKerror("@1optimizer:Could not find %s.%s\n",modnme,fcnnme);
	else
		printf("#@1optimizer %s.%s\n",modnme,fcnnme);
	setLifespan(s->def);
	@1optimizer(c,s->def,0);
	if(c->listing) printFunction(GDKout,s->def,c->listing);

	removeInstruction(mb, getPC(mb,p));
	return NULL;
}
str QOT@1optimizer(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	(void)stk; /* fool compiler */
	setLifespan(mb);
	@1optimizer(getClient(),mb, getPC(mb,pci));
	return NULL;
}
@c
	@:QOTC(CX)@
	@:QOTC(AR)@
	@:QOTC(DC)@
	@:QOTC(SP)@
	@:QOTC(RR)@


str CMDshowFlowGraph(MalBlkPtr mb, MalStkPtr stk, InstrPtr p){
        str fname= (str) getArgValue(stk,p,3);
	str     modnme= getArgName(mb,p,1);
	str     fcnnme= getArgName(mb,p,2);
	Scope  scope=NULL;
	Symbol s= NULL;
	Client c= getClient();

	scope = findScope(c->nspace,modnme);
	if( scope)
		s= findSymbolInScope(scope,fcnnme);

	if( s == NULL)
		GDKerror("@1:Could not find %s.%s\n",modnme,fcnnme);
        else {
                showFlowGraph(s->def,stk,fname);
        }
        return NULL;
}

