@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@' 
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@' 
@' The Original Code is the Monet Database System.
@' 
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2004 CWI.
@' All Rights Reserved.
@' 
@' Contributor(s):
@' 		Martin Kersten <Martin.Kersten@cwi.nl>
@' 		Peter Boncz <Peter.Boncz@cwi.nl>
@' 		Niels Nes <Niels.Nes@cwi.nl>
@' 		Stefan Manegold  <Stefan.Manegold@cwi.nl>

@f clients
@a Martin Kersten
@v 0.1
@* Client management

This module contains the primitives to inspect and adjust
the client records maintained during a Mserver session.
A rudimentatry authorization scheme should be provided[todo].
@mal
module clients;

command setListing(flg:int):int
address CLTsetListing
comment "Turn on/off echo of MAL instructions:
	2 - show mal instruction,
	4 - show type resolutoin, 
	8 - show binding information";

command setDebug(flg:int):void
address CLTsetDebug
comment "Set the flag in the debugging bitset.
	See configuration file and documentation";
command clearDebug(flg:int):void
address CLTclearDebug
comment "Clear the flag in the debugging bitset";

#command setPassword(s:str)
#address CLTsetPassword
#comment "Change the password for the client";

command getUsers( ):bat[:int,:str] 
address CLTusers
comment "Pseudo bat of users logged in";
command getLogins( ):bat[:int,:str] 
address CLTLogin
comment "Pseudo bat of client login time";
command info( ):bat[:int,:str] 
address CLTInfo
comment "Pseudo bat with client attributes";

command getScenario():str 
address CLTgetScenario
comment "Retrieve current scenario name";
command setScenario(msg:str):str 
address CLTsetScenario
comment "Switch to other scenario handler, 
	return previous one";

command quit():void
address CLTquit
comment "Terminate the session for this client"'

@-
@{
@+ Monet client data
Portions of the client record can be directly obtained for
backward compatibility. The routine clientInfo provides more
detailed information.
@h
#ifndef _CLIENTS_H
#define _CLIENTS_H
#endif /* _CLIENTS_H*/
@- Module initializaton
The content of this clients table my only be changed by the Administrator
or the client himself
@= authorize
	if( !isAuthorized("Admin"))
		return throwMessage("const.@1","unauthorized access to 'const' box");
@-
@= Pseudo
        if (BBPindex("view_@1_@2") <= 0)
                BATname(b, "@2");
        BATroles(b,"@1","@2");
        BATmode(b,TRANSIENT);
        BATfakeCommit(b);
        *ret = b->batCacheid;


@c
#include "mal.h"
#include "mal_scenario.h"
#include "mal_client.h"

int isAuthorized(str nme){
	Client c;
	if( nme == 0) return 1;
	c= getClient();
	return idcmp(c->user,nme)==0;
}

str CLTsetListing(int *ret, int *flag) {
        Client c;
	(void)ret; /*fool compiler */
        c= getClient();
	*ret = c->listing;
        c->listing = *flag;
        return MAL_SUCCEED;
}

str CLTgetScenario(str *ret){
        Client c = getClient();
        if( c->scenario) *ret = GDKstrdup(c->scenario);
        else *ret= GDKstrdup("nil");
        return MAL_SUCCEED;
}
str CLTsetScenario(str *ret,str *nme){
        Client c = getClient();
        str msg= MAL_SUCCEED;

        msg= setScenario(c,*nme);
        *ret = 0;
        if( msg== NULL) *ret= GDKstrdup(c->scenario);
        return msg;
}

static char* local_itoa(int i){
        static char buf[32];
        sprintf(buf,"%d",i);
        return buf;
}

str CLTInfo(int *ret){       
	Client c= getClient();
	BAT *b = BATnew(TYPE_str, TYPE_str, 12);
        if (b == 0) return throwMessage("catalog.clientInfo", "failed to create BAT");

	BUNins(b,"user", c->user);
	BUNins(b,"password", (c->password?c->password:""));
	BUNins(b,"permission", local_itoa(c->permission));
	BUNins(b,"scenario", c->scenario);
	BUNins(b,"timer", local_itoa(c->timer));
	BUNins(b,"trace", local_itoa(c->itrace));
	@:Pseudo(client,info)@
	return MAL_SUCCEED;
}
str CLTLogin(int *ret){       
	BAT *b = BATnew(TYPE_int, TYPE_str, 12);
	int i;
	char s[26];

        if (b == 0) return throwMessage("catalog.clientLogin", "failed to create BAT");
        for(i=0; i < MAL_MAXCLIENTS; i++)
        if(mal_clients[i].mode== CLAIMED && mal_clients[i].user) {
                time_t logintime=(time_t)mal_clients[i].login;

#ifdef CYGWIN32
                localtime(&logintime);
#else
                struct tm localt;
                localtime_r(&logintime,&localt);
#endif

#ifdef HAVE_CTIME_R3
                asctime_r(&localt,s,26);
#else
#ifdef HAVE_CTIME_R
                asctime_r(&localt,s);
#else
                strcpy(s, "no asctime in WIN32");
#endif
#endif
                s[24]=0;
                BUNins(b, &i, s);
        }

	@:Pseudo(client,login)@
	return MAL_SUCCEED;
}
@-
Produce a list of clients currently logged in
@c
str CLTusers(int *ret){       
	BAT *b = BATnew(TYPE_int, TYPE_str, 12);
	int i;
        if (b == 0) 
		return throwMessage("clients.users", "failed to create BAT");
        for(i=0; i < MAL_MAXCLIENTS; i++)
        if(mal_clients[i].mode== CLAIMED && mal_clients[i].user)
                BUNins(b, &i, mal_clients[i].user);
	@:Pseudo(client,login)@
	return MAL_SUCCEED;
}

str CLTsetDebug(int *ret, int *flg){
	(void)ret; (void) flg; /*fool compiler */
	return throwMessage("clients.setDebug","not yet implemented");
}
str CLTclearDebug(int *ret, int *flg){
	(void)ret; (void) flg; /*fool compiler */
	return throwMessage("clients.clearDebug","not yet implemented");
}
                                                                               
str CLTquit(int *ret) {
        Client c= getClient();
        (void) ret; /* fool compiler */
        c->mode = FINISHING;
        return MAL_SUCCEED;
}

@}
