@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@' 
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@' 
@' The Original Code is the Monet Database System.
@' 
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2004 CWI.
@' All Rights Reserved.
@' 
@' Contributor(s):
@' 		Martin Kersten <Martin.Kersten@cwi.nl>
@' 		Peter Boncz <Peter.Boncz@cwi.nl>
@' 		Niels Nes <Niels.Nes@cwi.nl>
@' 		Stefan Manegold  <Stefan.Manegold@cwi.nl>

@f const
@t MAL constant management
@a Martin Kersten
@v 0.1
@* Constant space management

This module shows the behavior of a simple box of objects.
Objects are stored into the box using deposit() and taken
out with take(). Once you are done, elements can be
removed by name or reference using discard().

A box should be opened before being used. It is typically used
to set-up the list of current users and to perform authorization.

The default constant box is initialized with session values,
such as 'user','dbname', 'dbfarm', and 'dbdir'. These actions
are encapsulated in the prelude routine called.

Furthermore, it implements a simple authorization scheme, 
prohibiting all updates unless issued by the system administrator.
@mal
module const
comment "The const module provides a box abstraction store for global constants.
Between sessions the value of the constants is saved on disk in the form of a
simple mal program, which is scanned and made available by opening the box.
A future implementation should provide transaction support over the box, which
would permit multiple clients to exchange (scalar) information easily.";

pattern open():void= CONSTopen
comment "Locate the constant box and open it";

pattern close():void= CONSTclose
comment "Close the constant box ";

pattern destroy():void= CONSTdestroy
comment "Destroy the box";

pattern take(name:str):any = CONSTtake
comment "Locates the typed value in the constant box";

pattern deposit(name:str,v:any):void = CONSTdeposit
comment "Enter a new value into the constant box";

pattern releaseAll():void = CONSTreleaseAll
comment "Release all constants for this client";

pattern release(name:str,val:any):void = CONSTrelease
comment "Release a new constant value";

pattern release(name:str):void = CONSTrelease
comment "Release a new constant value";

pattern toString(name:str):str = CONSTtoString
comment "Get the string representation of an element in the box";

pattern discard(name:str):void = CONSTdiscard
comment "Release the const from the box";

pattern iterator(nme:str):lng = CONSTiterator
comment "Locates the next element in the constant box";

pattern prelude():void = CONSTprelude
comment "Initialize the const box";

const.prelude();
@-
@+ Implementation
@h
#ifndef _ITERATOR_H
#define _ITERATOR_H
#endif /* _ITERATOR_H*/
@- Module initializaton
The content of this box my only be changed by the Administrator.
@= authorize
	if( !isAuthorized("Admin"))
		return throwMessage("const.@1","unauthorized access to 'const' box");
@-
@= insertBox
	msg = @2;
	insertToBox(box,@1,msg);
	GDKfree(msg);
@c
#include "const.h"
#include "mal.h"
#include "mal_client.h"
#include "mal_interpreter.h"

int isAuthorized(str nme){
	Client c;
	if( nme == 0) return 1;
	c= getClient();
	return idcmp(c->user,nme)==0;
}
str CONSTprelude(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	Box box;
	(void)mb;(void)stk;(void)pci; /* fool compiler*/
	@:authorize(prelude)@
	box= openBox("const");
	if( box== 0) 
		return throwMessage("const.prelude","failed to open box");
	/* if the box was already filled we can skip initialization */
	if( box->sym->vtop == 0){
		insertToBox(box,"user",getClient()->user);
		insertToBox(box,"dbname",GDKgetenv("gdk_dbname"));
		insertToBox(box,"dbfarm",GDKgetenv("gdk_dbfarm"));
		insertToBox(box,"version",GDKgetenv("gdk_version"));
		insertToBox(box,"config",GDKgetenv("gdk_config"));
	/* old bat.mx constants */
		insertToBox(box,"STORE_MEM","0");
		insertToBox(box,"STORE_MMAP","1");
		insertToBox(box,"STORE_COMPR","2");
		insertToBox(box,"BUF_NORMAL","0");
		insertToBox(box,"BUF_RANDOM","1");
		insertToBox(box,"BUF_SEQUENTIAL","2");
		insertToBox(box,"BUF_WILLNEED","3");
		insertToBox(box,"BUF_DONTNEED","4");
		insertToBox(box,"EBUSY","16");
		insertToBox(box,"M_E", "2.7182818284590452354LL");
		insertToBox(box,"M_LOG2E", "1.4426950408889634074LL");
		insertToBox(box,"M_LOG10E", "0.43429448190325182765LL");
		insertToBox(box,"M_LN2", "0.69314718055994530942LL");
		insertToBox(box,"M_LN10", "2.30258509299404568402LL");
		insertToBox(box,"M_PI", "3.14159265358979323846LL");
		insertToBox(box,"M_PI_2", "1.57079632679489661923LL");
		insertToBox(box,"M_PI_4", "0.78539816339744830962LL");
		insertToBox(box,"M_1_PI", "0.31830988618379067154LL");
		insertToBox(box,"M_2_PI", "0.63661977236758134308LL");
		insertToBox(box,"M_2_SQRTPI", "1.12837916709551257390LL");
		insertToBox(box,"M_SQRT2", "1.41421356237309504880LL");
		insertToBox(box,"M_SQRT1_2", "0.70710678118654752440LL");
	}
	return MAL_SUCCEED;
}
@- Operator implementation
@c
str CONSTopen(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	(void)mb;(void)stk;(void)pci; /* fool compiler*/
	@:authorize(open)@
	if(openBox("const.open") != 0) return MAL_SUCCEED;
	return throwMessage("const.open","failed to open box");
}

str CONSTclose(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	(void)mb;(void)stk;(void)pci; /* fool compiler*/
	@:authorize(close)@
	if( closeBox("const" ,TRUE) ==0) return MAL_SUCCEED;
	return throwMessage("const.close","failed to close box");
}
str CONSTdestroy(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	Box box;
	(void)mb;(void)stk;(void)pci; /* fool compiler*/
	@:OpenBox(destroy)@
	destroyBox("const");
	return MAL_SUCCEED;
}
@-
Access to a box calls for resolving the first parameter
to a named box.
@= OpenBox
	@:authorize(@1)@
	box= findBox("const");
	if( box ==0) 
	return throwMessage("const.@1","box is not open");
@-
@c
str CONSTdeposit(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	str name;
	ValPtr v;
	Box box;
	(void)mb; /* fool compiler*/

	@:OpenBox(deposit)@
	name = (str) getArgValue(stk,pci,1);
	v = &stk->stk[pci->argv[2]];
	if(depositBox(box,name,v) )
		return throwException(MALEXCEPTION,"const.deposit",
			"failed to deposit '%s' into box",name);
	return MAL_SUCCEED;
}

str CONSTtake(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	str name;
	Box box;
	ValPtr v;
	(void)mb; /* fool compiler*/

	@:OpenBox(take)@
	name = (str) getArgValue(stk,pci,1);
	v = &stk->stk[pci->argv[0]];
	if(takeBox(box,name,v)) 
		return throwException(MALEXCEPTION,"const.take",
			"failed to take '%s' from box",name);
	return MAL_SUCCEED;
}

str CONSTrelease(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	str name;
	Box box;
	(void)mb; /* fool compiler*/

	@:OpenBox(release)@
        name = (str) getArgValue(stk,pci,1);
        releaseBox(box,name);
	return MAL_SUCCEED;
}

str CONSTreleaseAll(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	Box box;

	(void)mb; (void)stk; (void) pci; /* fool compiler */
	@:OpenBox(release)@
	releaseAllBox(box);
	return MAL_SUCCEED;
}

str CONSTdiscard(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	str name;
	Box box;

	(void)mb; /* fool compiler */
	@:OpenBox(discard)@
        name = (str) getArgValue(stk,pci,1);
        if( discardBox(box,name) == 0)
                return throwException(MALEXCEPTION,"const.discard",
			"failed to discard '%s' from box", name);
	return MAL_SUCCEED;
}
str CONSTtoString(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	Box box;
	int i,len=0;
	ValPtr v;
	str nme,s=0;

	(void)mb; /* fool compiler */
	@:OpenBox(toString)@
	nme = (str) getArgValue(stk,pci,1);
	i= findVariable(box->sym,nme);
	if( i <0) return throwException(MALEXCEPTION,"const.toString",
			"failed to take '%s' from box",nme);

	v= &box->val->stk[i];
	garbageElement(&stk->stk[pci->argv[0]]);

	if( v->vtype== TYPE_str) s= v->val.sval;
	else (*BATatoms[v->vtype].atomToStr)(&s,&len,v);
	if(s== NULL) return throwMessage("const.toString","illegal value");
	VALset(&stk->stk[pci->argv[0]], TYPE_str,s);

	/* if( VALconvert(TYPE_str,v, TRUE) == ILLEGALVALUE) 
		return throwMessage("const.toString","illegal value");
	VALcopy(&stk->stk[pci->argv[0]], v); */
	return MAL_SUCCEED;
}

str CONSTiterator(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	Box box;
	lng *cursor;
	ValPtr v;

	(void)mb; /* fool compiler */
	@:OpenBox(iterator)@
	cursor= (lng*) getArgValue(stk,pci,0);
	v= &stk->stk[pci->argv[1]];
	nextBoxElement(box, cursor, v);
	return MAL_SUCCEED;
}
