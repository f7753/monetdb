@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2003 CWI.
@' All Rights Reserved.
@'
@' Contributor(s):
@'              Martin Kersten <Martin.Kersten@cwi.nl>
@'              Peter Boncz <Peter.Boncz@cwi.nl>
@'              Niels Nes <Niels.Nes@cwi.nl>
@'              Stefan Manegold  <Stefan.Manegold@cwi.nl>

@f ascii_io
@t The ascio io Module
@a Niels Nes
@d 12/01/2001
@* Ascii bulk io Module

A database cannot live with out bulk load/store operations. The ascii io
module can be used bulk load from an ascii file or dump to one. 
The file can plain ascii, gzipped or bzipped, decided by the extention 
(none, gz or bz2).

The load operation is for bulk loading a table, each column will be loaded
into its own bat. The arguments are void-aligned bats describing the
input, ie the name of the column, the tuple seperator and the type.  
The nr argument can be -1 (The input (datafile) is read until the end)
or a maximum.

The dump operation is for dumping a set of bats, which are aligned.
Again with void-aligned arguments, with name (currently not used), 
tuple seperator (the last is the record seperator) and bat to be dumped. 
With the nr argument the dump can be limited (-1 for unlimited).

The output operation is for ordered output. A bat (possibly form the collection)
gives the order. For each element in the order bat the values in the bats are
searched, if all are found they are outputed in the datafile, with the given
seperators.

The scripts from the LOAD part are all there too for backward compatebility
with the old Mload format files. 

The load_format loads the format file, since the old format file was
in a table format it can be loaded with the load command. 

The result from load_format can be used with load_data to load the data
into a set of new bats.

These bats can be made persistent with the make_pesistent script or
merge with existing bats with the merge_data script.

The dump_format scripts dump a format file for a given set of 
to be dumped bats. These bats can be dumped with dump_data.

@mal
module ascii_io;

command load( names:BAT[void,str], seps:BAT[void,str], types:BAT[void,str],
	datafile:str, nr:int ) : BAT[str,bat] = CMDbulk_io_load
comment "Load a bat using specific format.";

command input( names:BAT[void,str], seps:BAT[void,str], types:BAT[void,str],
	s:stream, nr:int ) : BAT[str,bat] = CMDbulk_io_input
comment "Load a bat using specific format.";

command dump(names:BAT[void,str], seps:BAT[void,str], bats:BAT[void,bat],
	datafile:str, nr:int):void = CMDbulk_io_dump 
comment "Dump the bat in ascii format";

command output(order:BAT[any,any], seps:BAT[void,str], bats:BAT[void,bat],
	s:stream):void = CMDbulk_io_output 
comment "Send the bat to an output stream.";
@+ Implementation
@= getBATdescriptor
        if( BBPcheck(*@2,"@4")==0)
                return throwMessage("enum.@4","cannot access bat @2 in bbp");
        @3= (BAT*) BBPgetdesc(*@2);
        if( @3 == NULL) { *@1 = 0;
                return throwMessage("enum.@4","cannot access descriptor @2");
        }
        if( *@2 <0) @3= BATmirror(@3);
@h
#ifndef _BULK_IO2_H_
#define _BULK_IO2_H_

#include <gdk.h>
#include "streams.h"
#include "mal_function.h"

typedef ptr *(*frStr)( void *extra, int type, char *s);
typedef int (*toStr)( void *extra, char **buf, int *len, int type, ptr a);

typedef struct ascii_io_t {
	char* name;
	char* sep;
	int   seplen;
	char* type;
	int   adt;
	BAT*  c;
	BUN   p;
	toStr tostr;
	frStr frstr;
	void* extra;
} ascii_io;

typedef struct ascii_load_t {
	size_t offset;
	size_t nr;
	size_t nr_attrs;
	ascii_io *format;
} ascii;

extern BAT *ASCIIload( BAT *names, BAT *seps, BAT *types, char *datafile, size_t nr );
extern BAT *ASCIIinput( BAT *names, BAT *seps, BAT *types, bstream *s, size_t nr );
extern size_t ASCIIoutput( BAT *order, BAT *seps, BAT *bats, stream *s );
extern void ASCIIdump( BAT *names, BAT *seps, BAT *bats, char *datafile, size_t nr );

/* The low level routines are primarilly used by the SQL front-end.*/
extern int ASCIIcreate_bats( ascii *as );
extern size_t ASCIIassign_BATs( ascii *as, BAT *bats );
extern int ASCIIload_file( ascii *as, bstream *b );
extern BAT *ASCIIcollect_bats( ascii *as );
extern void ASCIIdestroy_format( ascii *as );
extern void ASCIIoutput_file( ascii *as, BAT *order, stream *s );

@+ Default from and to string functions
@h
extern ptr *ASCIIadt_frStr( void *extra, int type, char *s);
extern int ASCIIadt_toStr( void *extra, char **buf, int *len, int type, ptr a);

#endif
@c
#include "ascii_io.h"

#include <string.h>
#include <ctype.h>

static int ascii_io_debug = 0;

ptr bun_tail(BAT *b, size_t nr){
	REGISTER size_t _i = BUNindex((b),BUNfirst((b)));
	return (ptr)BUNtail(b, BUNptr(b,_i+nr));
}


BAT *void_bat_create(int adt, size_t nr) {
	BAT *b = BATnew(TYPE_void,adt,nr);
	BATseqbase(b,0);
	return b;
}

static char *sep_dup( char *sep ){
	size_t len = strlen(sep);
	char *res = GDKmalloc(len+1), *result = res;
	char *end = sep+len;

	while(sep < end){
		if (*sep == '\\'){
			++sep;
			switch(*sep++){
			case 'r': *res++ = '\r'; break;
			case 'n': *res++ = '\n'; break;
			case 't': *res++ = '\t'; break;
			}
		} else {
			*res++ = *sep++; 
		}
	}
	*res = '\0';
	return result;
}

ptr *ASCIIadt_frStr( void *extra, int type, char *s){
        int l = 0;
        ptr *res = NULL;
        if (type == TYPE_str) {
        	if (s == NULL || strcmp(s,"nil") == 0)
        		res = (ptr*)ATOMnil(TYPE_str);
        	else
                	res = (ptr*)GDKstrdup(s);
        } else
                (void) (*BATatoms[type].atomFromStr)(s, &l, (ptr)&res);
        return res;
}

int ASCIIadt_toStr( void *extra, char **buf, int *len, int type, ptr a){
        if (type == TYPE_str){
		char *dst, *src = a;
		int l;
		if (GDK_STRNIL(src)) {
			src = "nil";
		}
		l = strlen(src);
		if (l+3 > *len){
			GDKfree(buf);
			*len = 2*l+3;
			*buf = GDKmalloc( *len );
		}
		dst = *buf;
		dst[0] = '"';
		strncpy(dst+1, src, l);
		dst[l+1] = '"';
		dst[l+2] = 0;
		return l+2;
	} else {
        	return (*BATatoms[type].atomToStr)(buf, len, a);
	}
}

static
size_t create_loadformat( ascii *as, BAT *names, BAT *seps, BAT *types ){
	size_t p;
	size_t nr_attrs = BATcount(names);
	ascii_io *fmt = as->format =  
		(ascii_io*)GDKmalloc(sizeof(ascii_io) * (nr_attrs + 1) );

	as->offset = 0;
	as->nr_attrs = nr_attrs;
	/* assert(as->nr_attrs == nr_attrs); */ /* i.e. it fits */
	for (p=0; p<nr_attrs; p++){
		fmt[p].name = (char*)bun_tail(names, p);
		fmt[p].sep = sep_dup((char*)bun_tail(seps, p));
		fmt[p].seplen = (int) strlen( fmt[p].sep );
		fmt[p].type = (char*)bun_tail(types, p);
		fmt[p].adt = ATOMindex( fmt[p].type );
		fmt[p].tostr = &ASCIIadt_toStr;
		fmt[p].frstr = &ASCIIadt_frStr;
		fmt[p].extra = NULL;
		if (ascii_io_debug)
			stream_printf(GDKerr, "%s\n", fmt[p].name );
	}
	return as->nr_attrs;
}

static
size_t create_dumpformat( ascii *as, BAT *names, BAT *seps, BAT *bats ){
	size_t p;
	size_t nr_attrs = BATcount(bats);
	ascii_io *fmt = as->format =  
		(ascii_io*)GDKmalloc(sizeof(ascii_io) * (nr_attrs + 1) );

	as->offset = 0;
	as->nr_attrs = nr_attrs;
	/* assert(as->nr_attrs == nr_attrs); */ /* i.e. it fits */
	for (p=0; p<nr_attrs; p++){
		BAT *b = (BAT*)BATdescriptor(*(bat*)bun_tail(bats, p));

		if (!b) 
			return -1;
		fmt[p].name = NULL;
		if (names)
			fmt[p].name = (char*)bun_tail(names, p);
		fmt[p].sep = sep_dup((char*)bun_tail(seps, p));
		fmt[p].seplen = (int) strlen( fmt[p].sep );
		fmt[p].type = ATOMname(b->ttype);
		fmt[p].adt = (b)->ttype;
		fmt[p].tostr = &ASCIIadt_toStr;
		fmt[p].frstr = &ASCIIadt_frStr;
		fmt[p].extra = NULL;
	}
	return as->nr_attrs;
}

void ASCIIdestroy_format( ascii *as ){
	size_t p;
	ascii_io *fmt = as->format;

	for (p=0; p<as->nr_attrs; p++){
		if (fmt[p].c) 
			BBPunfix(fmt[p].c->batCacheid);
		GDKfree( fmt[p].sep );
	}
	GDKfree(fmt);
}

size_t ASCIIassign_BATs( ascii *as, BAT *bats ){
	ascii_io *fmt = as->format;
	size_t res = as->nr;
	size_t i;
	for (i=0; i<as->nr_attrs; i++){
		BAT *b = (BAT*)BATdescriptor(*(bat*)bun_tail(bats, i));
		fmt[i].c = (b);
		if (res == ~(size_t)0 || BATcount(fmt[i].c)<res)
			res = BATcount(fmt[i].c);
	}
	as->nr = res;
	return res;
}

static
oid check_BATs( ascii *as ){
	ascii_io *fmt = as->format;
	size_t i;
	size_t cnt = BATcount(fmt[0].c);
	oid base = fmt[0].c->hseqbase;

	if (!BAThdense(fmt[0].c)) return oid_nil;

	for (i=0; i<as->nr_attrs; i++){
		BAT *b = fmt[i].c;
		int offset = BUNindex(b, BUNfirst(b)) + as->offset;

		if (BATcount(b) != cnt ||
		    b->hseqbase != base)
			return oid_nil;

		fmt[i].p = BUNptr(b, offset);
	}
	return base;
}

int ASCIIcreate_bats( ascii *as ){
	ascii_io *fmt = as->format;
	size_t i;

	for (i=0; i<as->nr_attrs; i++){
		fmt[i].c = void_bat_create(fmt[i].adt,as->nr);
	}
	return 0;
}

BAT *ASCIIcollect_bats( ascii *as ){
	BAT *bats = BATnew(TYPE_str,TYPE_bat,as->nr_attrs);
	ascii_io *fmt = as->format;
	size_t i;
	size_t cnt = BATcount(fmt[0].c);

	for (i=0; i<as->nr_attrs; i++){
		BUNins(bats,(ptr)fmt[i].name, (ptr)&fmt[i].c->batCacheid);
		if (cnt != BATcount(fmt[i].c)){
		        GDKerror("Error: counts are not equal\n");
			return NULL;
		}
	}
	return bats;
}

static INLINE
int myisspace(int s ){
	return s == ' ' || s == '\t' || s == '\n';
}

static INLINE
char *strip( char *s, char *e ){
        while(myisspace((int)*s)){
		s++;
	}
	e--;
        while(myisspace((int)*e)){
		e--;
	}
	e++;
	if (e && *e){
		*e = 0;
	}
	return s;
}

static INLINE
int insert_val( ascii_io *fmt, char *s, char *e ){
	ptr *adt;
	oid on = oid_nil;	/* can't use &oid_nil because of the
				   way it's defined */
	adt = fmt->frstr( fmt->extra, fmt->adt, strip(s,e) );
	
	if (!adt){
		GDKerror("%ld not inserted %s\n", (long)adt, s);
		return 1;
	}

	BUNins(fmt->c,&on,adt);
	GDKfree(adt);
	return 0;
}

static char *find_quote(char *str, char quote ){
	while(*str != quote) 
		str++;
	return str;
}
static char *rfind_quote(char *str, char quote ){
	while(*str != quote) 
		str--;
	return str;
}
static char *skip_string(char *str, char quote ){
	int esc = 0;
	while(*str){
		if (*str == '\\' && !esc)
			esc = 1;
		else if (*str == quote && !esc)
			break;
		else
			esc = 0;
		str++;
	}
	if (*str) 
		str++;
	else
		return NULL;
	return str;
}

static INLINE
int insert_line( ascii *as, char *line ){
	int res = 0;
	ascii_io *fmt = as->format;
        char *s,*e = 0, quote = '\"';
	size_t i;
	int quotes = 0;
	int first = 0;
	for( i = 0; i<as->nr_attrs-1 && res == 0; i++){
		first = 1;
		s=line;
		while(*line){
			if (*line == *(fmt[i].sep) && 
			     strncmp( fmt[i].sep, line, fmt[i].seplen) == 0 ){
				e = line; /*strstr( line, fmt[i].sep ); */
				break;
		     	} else if(first && (*line == '\"' || *line == '\'') 
					&& *(line-1) != '\\'){
				quotes = 1;
				quote = *line;
				line++;
				line = skip_string( line, quote );
				if (!line) return -1;
				first = 0;
			} else {
				if (first && !isspace(*line))
					first = 0;
				line++;
			}
		}
		if (e){
			char *end = e;
			if (quotes){
				quotes = 0;
				s = find_quote(s, quote);
				if (!s) return -1;
				s++;
				e = rfind_quote(e, quote);
			}
			*e = 0;
			res |= insert_val( &fmt[i], s, e );
			line = end + fmt[i].seplen;
		} else {
		        GDKerror("Error: missing sep %s line %d field %d\n", fmt->sep, BATcount(fmt->c), i);
			return -1;
		}
		e = 0;
	}
	s=line;
	first = 1;
	while(*line){
		if (*line == *(fmt[as->nr_attrs-1].sep) && 
		     strncmp( fmt[as->nr_attrs-1].sep, line, 
			      fmt[as->nr_attrs-1].seplen) == 0 ){
			e = line; /*strstr( line, fmt[as->nr_attrs-1].sep ); */
			break;
		} else if(first && (*line == '\"' || *line == '\'')
			        && *(line-1) != '\\'){
			quotes = 1;
			quote = *line;
			line++;
			line = skip_string( line, quote );
			if (!line) return -1;
			first = 0;
		} else {
			if (first && !isspace(*line))
				first = 0;
			line++;
		}
	}
	if (!e) e = line;
	if (e){
		char *end = e;
		if (quotes){
			quotes = 0;
			s = find_quote(s, quote);
			if (!s) return -1;
			s++;
			e = rfind_quote(e, quote);
		}
		*e = 0;
		res |= insert_val( &fmt[as->nr_attrs-1], s, e );
		line = end + fmt[as->nr_attrs-1].seplen;
	} else {
		GDKerror("Error: missing sep %s line %d field %d\n", fmt->sep, BATcount(fmt->c), i);
		return -1;
	}
	e = 0;
	return res;
}

static INLINE
int dump_line( char **buf, int *len, ascii_io *fmt, stream *fd, size_t nr_attrs, size_t id ){
	size_t i;
	for( i = 0; i<nr_attrs; i++){
		ascii_io *f = fmt+i;
		char *p = (char*)bun_tail(f->c,id);
		int l = f->tostr( f->extra, buf, len, f->adt, p);
		(void)fd->write( fd, *buf, 1, l );
		(void)fd->write( fd, f->sep, 1, f->seplen );
	}
	return 0;
}

static INLINE
int output_line( char **buf, int *len, ascii_io *fmt, stream *fd, size_t nr_attrs, ptr id ){
	size_t i;
	for( i = 0; i<nr_attrs; i++){
		fmt[i].p = BUNfnd( fmt[i].c, id );
		if (fmt[i].p == 0)
			break;
	}
	if ( i == nr_attrs ){
	    for( i = 0; i<nr_attrs; i++){
		ascii_io *f = fmt+i;
		char *p = BUNtail(f->c, f->p);
		int l = f->tostr(f->extra, buf, len, f->adt, p);
		(void)fd->write( fd, *buf, 1, l );
		(void)fd->write( fd, f->sep, 1, f->seplen );
	    }
	}
	return 0;
}

static INLINE
int output_line_dense( char **buf, int *len, ascii_io *fmt, stream *fd, size_t nr_attrs ){
	size_t i;
	for( i = 0; i<nr_attrs; i++){
		ascii_io *f = fmt+i;
		char *p = BUNtail(f->c, f->p);
		int l = f->tostr(f->extra, buf, len, f->adt, p);
		(void)fd->write( fd, *buf, 1, l );
		(void)fd->write( fd, f->sep, 1, f->seplen );
		f->p = BUNnext( f->c, f->p );
	}
	return 0;
}

static INLINE
int output_line_lookup( char **buf, int *len, ascii_io *fmt, stream *fd, size_t nr_attrs, size_t id ){
	size_t i;
	for( i = 0; i<nr_attrs; i++){
		ascii_io *f = fmt+i;
		char *p = BUNtail(f->c, BUNptr(f->c,id+BUNindex(f->c,BUNfirst(f->c))));
		int l = f->tostr(f->extra, buf, len, f->adt, p);
		(void)fd->write( fd, *buf, 1, l );
		(void)fd->write( fd, f->sep, 1, f->seplen );
	}
	return 0;
}


int ASCIIload_file( ascii *as, bstream *b ){
	int res = 0, eof = 0, done = 0;
	size_t i = 0;
	char *sep = as->format[as->nr_attrs-1].sep;
        int seplen = as->format[as->nr_attrs-1].seplen;

	if (ascii_io_debug)
		stream_printf( GDKerr, "ASCIIload_file\n");

	while(!eof && res == 0 && (as->nr == ~(size_t)0 || i < as->nr)){
		char *s, *end;
		if (bstream_read(b, b->size - (b->len - b->pos)) == 0)
			eof = 1;
		end = b->buf + b->len;
		s = b->buf + b->pos;
		*end = '\0';
		done = 0;
		while( s < end ){
			char *e = strstr( s, sep );
			if (e){
				*e = '\0';
				if ((e-s) <= 1){ /* empty line indicates eof */
					eof = 1;
					break;
				}
				if (insert_line(as, s ) < 0){
					GDKerror("value %s not inserted\n", s);	
					res = -1;
					break;
				}
				s = e + seplen;
				done = 1;
			} else if (eof && s + as->nr_attrs < end){
				if (insert_line(as, s ) < 0){
					GDKerror("value %s not inserted\n", s);	
					res = -1;
					break;
				}
				s = end;
			} else {
				if (!done){ /* nothing found in current buf
					     * ie. need to enlarge 
					     */
					if (bstream_read(b, b->size*16) == 0)
						eof = 1;
					end = b->buf + b->len;
					s = b->buf + b->pos;
					*end = '\0';
					continue;
				}
				break;
			}
			b->pos = (s-b->buf);
			i++;
			if (ascii_io_debug && (i%100000) == 0)
				stream_printf(GDKerr, "inserted %d\n", i);
			if (as->nr != ~(size_t)0 && i >= as->nr)
				break;
		}
	}
	as->nr = i;
	if (res < 0)
		return res;
	return as->nr;
}

static
int dump_file( ascii *as, stream *fd ){
        size_t i = 0;
	int len = BUFSIZ;
	char *buf = GDKmalloc(len);
	for( i=0; i<as->nr; i++ ){
		if (dump_line( &buf, &len, as->format, fd, as->nr_attrs, i )<0){
			GDKfree(buf);
			return -1;
		}
		if (ascii_io_debug && (i%1000000) == 0)
			stream_printf(GDKerr, "dumped %d lines\n", i);
        } 
	GDKfree(buf);
	return 0;
}

static
void output_file_default( ascii *as, BAT *order, stream *fd ){
	int len = BUFSIZ; 
	char *buf = GDKmalloc(len);
	BUN p,q;
        size_t i = 0;
	size_t offset = BUNindex(order, BUNfirst(order)) + as->offset;

	for(q = BUNptr(order, offset+as->nr), p = BUNptr(order, offset);
			p < q; p = BUNnext(order, p))
	{
		ptr h = BUNhead(order, p);
		if(output_line( &buf, &len,as->format, fd, as->nr_attrs, h )<0){
			GDKfree(buf);
			return;
		}
		i++;
		if (ascii_io_debug && (i%1000000) == 0)
			stream_printf(GDKerr, "dumped %lu lines\n", (unsigned long) i);
        } 
	GDKfree(buf);
}

static
void output_file_dense( ascii *as, stream *fd ){
	int len = BUFSIZ; 
	char *buf = GDKmalloc(len);
        size_t i = 0;
	
	for(i=0; i<as->nr; i++){
		if(output_line_dense( &buf, &len, as->format, fd, as->nr_attrs )<0){
			GDKfree(buf);
			return;
		}
		if (ascii_io_debug && (i%1000000) == 0)
			stream_printf(GDKerr, "dumped %lu lines\n", (unsigned long) i);
        } 
	GDKfree(buf);
}

static
void output_file_ordered( ascii *as, BAT *order, stream *fd, oid base ){
	int len = BUFSIZ; 
	char *buf = GDKmalloc(len);
	BUN p,q;
        size_t i = 0;
	size_t offset = BUNindex(order, BUNfirst(order)) + as->offset;

	for(q = BUNptr(order, offset+as->nr), p = BUNptr(order, offset);
			p < q; p = BUNnext(order, p))
	{
		size_t h = *(oid*)BUNhead(order, p) - base;
		if(output_line_lookup( &buf, &len, as->format, fd, as->nr_attrs, h )<0){
			GDKfree(buf);
			return;
		}
		if (ascii_io_debug && (i%1000000) == 0)
			stream_printf(GDKerr, "dumped %lu lines\n", (unsigned long) i);
        } 
	GDKfree(buf);
}

#define SIZE 1*1024*1024
BAT *ASCIIload( BAT *names, BAT *seps, BAT *types, char *datafile, size_t nr ){
	BAT *res;
	stream *s = open_rastream( datafile );
	bstream *b = NULL;

	if (s->errnr){
		GDKerror("could not open file %s\n", datafile );
		return NULL;
	}
	res = ASCIIinput( names, seps, types, b=bstream_create(s, SIZE), nr );
	bstream_destroy(b);
	s->close(s);
	s->destroy(s);
	return res;
}

BAT *ASCIIinput( BAT *names, BAT *seps, BAT *types, bstream *s, size_t nr ){
	BAT *bats = NULL;
	ascii as;

	as.nr_attrs = 0;
	as.nr = nr;
	if (create_loadformat( &as, names, seps, types) != ~(size_t)0 && 
	    ASCIIcreate_bats( &as ) >= 0){
		if (ASCIIload_file( &as, s )>=0)
			bats = ASCIIcollect_bats( &as );
	}
	ASCIIdestroy_format( &as );
	return bats;
}

void ASCIIdump( BAT *names, BAT *seps, BAT *bats, char *datafile, size_t nr ){
	ascii as;

	as.nr_attrs = 0;
	as.nr = nr;
	if (create_dumpformat( &as, names, seps, bats) != ~(size_t)0 && 
	    ASCIIassign_BATs( &as, bats ) != ~(size_t)0){
		stream *s = open_wastream( datafile );
		if (!s->errnr && dump_file( &as, s ) >= 0){
			stream_printf(GDKerr, "saved in %s\n", datafile );
		}
		if (s->errnr){
		 	GDKerror("could not open file %s\n", datafile );
		} else {
			s->close(s);
		}
		s->destroy(s);
	}
	ASCIIdestroy_format( &as );
}

void ASCIIoutput_file( ascii *as, BAT *order, stream *s ){
	oid base = oid_nil;
	if ((base = check_BATs( as )) != oid_nil ){
		if (BAThdense(order) && 
 		    order->hseqbase == base && BATcount(order) == as->nr)
			output_file_dense( as, s );
		else
			output_file_ordered( as, order, s, base );
	} else {
		output_file_default( as, order, s ); 
	}
}

size_t ASCIIoutput( BAT *order, BAT *seps, BAT *bats, stream *s ){
	ascii as;

	as.nr_attrs = 0;
	as.nr = ~(size_t)0;
	if (create_dumpformat( &as, NULL, seps, bats) != ~(size_t)0 && 
	    ASCIIassign_BATs( &as, bats ) != ~(size_t)0){
		ASCIIoutput_file(&as, order, s);
	}
	ASCIIdestroy_format( &as );
	return as.nr;
}

int init_ascii_io(int *debug){
	ascii_io_debug = *debug;
	return GDK_SUCCEED;
}
int ascii_io_load( BAT **bats, BAT *names, BAT* seps, BAT* types, str datafile, int *nr){
	*bats = ASCIIload( names, seps, types, datafile, *nr );
	if (*bats) {
		return GDK_SUCCEED;
	} else {
		return GDK_FAIL;
	}
}
int ascii_io_input( BAT **bats, BAT *names, BAT* seps, BAT* types, void ** s, int *nr){
	bstream *b = NULL;

	*bats = ASCIIinput( names, seps, types, b=bstream_create(*(stream**)s, SIZE), *nr );
	bstream_destroy(b);
	if (*bats) {
		return GDK_SUCCEED;
	} else {
		return GDK_FAIL;
	}
}
int ascii_io_dump( BAT *names, BAT* seps, BAT* bats, str datafile, int *nr){
	ASCIIdump( names, seps, bats, datafile, *nr );
	return GDK_SUCCEED;
}
int ascii_io_output( BAT *order, BAT* seps, BAT* bats, void **s ){
	ASCIIoutput( order, seps, bats, *(stream**)s );
	return GDK_SUCCEED;
}
@+ MAL interface
@c
str CMDbulk_io_load(int *ret, int *nameid, int *sepid, int *typeid,
	str *filename, int *nr){
	BAT *names, *seps, *types, *bn;

	@:getBATdescriptor(ret,nameid,names,bulk_io_load)@
	@:getBATdescriptor(ret,sepid,seps,bulk_io_load)@
	@:getBATdescriptor(ret,typeid,types,bulk_io_load)@

	ascii_io_load( &bn, names, seps, types, *filename, nr);
	if( bn== NULL)
		return throwMessage("bulk_io.load","failed to load");
	BBPfix(*ret);
	*ret= bn->batCacheid;
	return MAL_SUCCEED;
}
str CMDbulk_io_dump(int *ret, int *nameid, int *sepid, int *bids,
	str *filename, int *nr){
	BAT *names, *seps, *bats;

	@:getBATdescriptor(ret,nameid,names,bulk_io_dump)@
	@:getBATdescriptor(ret,sepid,seps,bulk_io_dump)@
	@:getBATdescriptor(ret,bids,bats,bulk_io_dump)@

	ascii_io_dump( names, seps, bats, *filename, nr);
	return MAL_SUCCEED;
}
str CMDbulk_io_input(int *ret, int *nameid, int *sepid, int *typeid,
	stream *s, int *nr){
	BAT *names, *seps, *types, *datafile, *bn;

	@:getBATdescriptor(ret,nameid,names,bulk_io_input)@
	@:getBATdescriptor(ret,sepid,seps,bulk_io_input)@
	@:getBATdescriptor(ret,typeid,types,bulk_io_input)@

	ascii_io_input(&bn,names, seps, types, (void **)s, nr);
	if( bn== NULL)
		return throwMessage("bulk_io.load","failed to load");
	BBPfix(*ret);
	*ret= bn->batCacheid;
	return MAL_SUCCEED;
}
str CMDbulk_io_output(int *ret, int *nameid, int *sepid, int *bids, void **s){
	BAT *names, *seps, *bats;

	@:getBATdescriptor(ret,nameid,names,bulk_io_output)@
	@:getBATdescriptor(ret,sepid,seps,bulk_io_output)@
	@:getBATdescriptor(ret,bids,bats,bulk_io_output)@
	*ret= ascii_io_output(names, seps, bats, s );
	return MAL_SUCCEED;
}


@mil

PROC test_ascii_io() : void := {

    #ascii_io_debug(1);

    fp := fopen ( "format", "w+" );
    fputs( "key,\",\",str\n", fp);
    fputs( "a_io_test,\"\\n\",dbl\n", fp);
    fclose( fp );

    fp := fopen ( "data", "w+" );
    fputs( "test, 0.12345\n", fp);
    fputs( "second line, 9.0\n", fp);
    fclose( fp );

    bats := load_data(load_format("format"),"data",10);
    bats.print;
    a := bats.find("key").reverse().join( bats.find("a_io_test") );
    a.print;
    dump_data(load_format("format"), bats, "data", -1);

    fp := fopen ( "data", "r" );
    s := fgets( fp ); 
    s.print();
    fclose( fp );
}

