@f ascii_io
@t The ascio io Module
@a Niels Nes
@d 12/01/2001
@+
@mal
module ascii_io;

command ascii_io_debug( debug:int ) = ASCII_IOprelude 
	comment "Ascii_io debug control";

command load( names:BAT[void,str], seps:BAT[void,str], types:BAT[void,str],
	datafile:str, nr:int ) : BAT[str,bat] = ASCII_IO_load
comment "Load a bat using specific format.";

command dump(names:BAT[void,str], seps:BAT[void,str], bats:BAT[void,bat],
	datafile:str, nr:int):void = ASCII_IO_dump 
comment "Dump the bat in ascii format";

command output(order:BAT[any,any], seps:BAT[void,str], bats:BAT[void,bat],
	s:stream):void = ASCII_IO_output 
comment "Send the bat to an output stream.";
@-
The remainder should be compiled into a mal procedure to be loaded
from the shared includes.
@h
/*
 * The contents of this file are subject to the Monet Public
 * License Version 1.1 (the "License"); you may not use this file
 * except in compliance with the License. You may obtain a copy of
 * the License at 
 * http://www.monetsolutions.com/Download/Licensing/MonetPL-1.1.html
 * 
 * Software distributed under the License is distributed on an "AS
 * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
 * implied. See the License for the specific language governing
 * rights and limitations under the License.
 * 
 * The Original Code is the Monet Database System.
 * 
 * The Initial Developer of the Original Code is CWI.
 * Portions created by CWI are Copyright (C) 1997-2002 CWI.  
 * All Rights Reserved.
 * 
 * Contributor(s): Martin Kersten <Martin.Kersten@cwi.nl>
 *		   Peter Boncz <Peter.Boncz@cwi.nl>
 *		   Niels Nes <Niels.Nes@cwi.nl>
 *		   Stefan Manegold  <Stefan.Manegold@cwi.nl>
 */

#ifndef _ASCII_IO2_H_
#define _ASCII_IO2_H_

#include "streams.h"
#include "gdk_stream.h"
#include "monet.h"
extern BAT *ASCIIload( BAT *names, BAT *seps, BAT *types, char *datafile, int nr );
extern void ASCIIdump( BAT *names, BAT *seps, BAT *bats, char *datafile, int nr );

#endif
@c

#include <gdk.h>
#include "ascii_io.h"

#include <string.h>
#include <ctype.h>

typedef struct ascii_io_t {
	char* name;
	char* sep;
	int   seplen;
	char* type;
	int   adt;
	BAT*  c;
	BUN   p;
} ascii_io;

typedef struct ascii_load_t {
	int nr;
	int nr_attrs;
	ascii_io *format;
} ascii;

static int ascii_io_debug = 0;

ptr bun_tail(BAT *b, int nr){
	REGISTER int _i = BUNindex((b),BUNfirst((b)));
	return (ptr)BUNtail(b, BUNptr(b,_i+nr));
}


BAT *void_bat_create(int adt, int nr) {
	BAT *b = BATnew(TYPE_void,adt,nr);
	BATseqbase(b,0);
	return b;
}

static
ptr *ADT_fromStr( int type, char *s){
        int l = 0;
        ptr *res = NULL;
        if (type == TYPE_str)
                res = (ptr*)GDKstrdup(s);
        else
                BATatoms[type].atomFromStr(s, &l, (ptr)&res);
        return res;
}

static
int ADT_toStr( char **buf, int *len, int type, ptr a){
        return (int)BATatoms[type].atomToStr( buf, len, a);
}

static char *sep_dup( char *sep ){
	int len = strlen(sep);
	char *res = GDKmalloc(len+1), *result = res;
	char *end = sep+len;

	while(sep < end){
		if (*sep == '\\'){
			++sep;
			switch(*sep++){
			case 'r': *res++ = '\r'; break;
			case 'n': *res++ = '\n'; break;
			case 't': *res++ = '\t'; break;
			}
		} else {
			*res++ = *sep++; 
		}
	}
	*res = '\0';
	return result;
}

static
int create_loadformat( ascii *as, BAT *names, BAT *seps, BAT *types ){
	int p;
	int nr_attrs = BATcount(names);
	ascii_io *fmt = as->format =  
		(ascii_io*)GDKmalloc(sizeof(ascii_io) * (nr_attrs + 1) );

	as->nr_attrs = nr_attrs;
	for (p=0; p<as->nr_attrs; p++){
		fmt[p].name = (char*)bun_tail(names, p);
		fmt[p].sep = sep_dup((char*)bun_tail(seps, p));
		fmt[p].seplen = strlen( fmt[p].sep );
		fmt[p].type = (char*)bun_tail(types, p);
		fmt[p].adt = ATOMindex( fmt[p].type );
		if (ascii_io_debug)
			printf("%s\n", fmt[p].name );
	}
	return as->nr_attrs;
}

static
int create_dumpformat( ascii *as, BAT *names, BAT *seps, BAT *bats ){
	int p;
	int nr_attrs = BATcount(bats);
	ascii_io *fmt = as->format =  
		(ascii_io*)GDKmalloc(sizeof(ascii_io) * (nr_attrs + 1) );

	as->nr_attrs = nr_attrs;
	for (p=0; p<as->nr_attrs; p++){
		BAT *b = (BAT*)BATdescriptor(*(bat*)bun_tail(bats, p));
		fmt[p].name = NULL;
		if (names)
			fmt[p].name = (char*)bun_tail(names, p);
		fmt[p].sep = sep_dup((char*)bun_tail(seps, p));
		fmt[p].seplen = strlen( fmt[p].sep );
		fmt[p].type = ATOMname(b->ttype);
		fmt[p].adt = (b)->ttype;
	}
	return as->nr_attrs;
}

static
void destroy_format( ascii *as ){
	int p;
	ascii_io *fmt = as->format;

	for (p=0; p<as->nr_attrs; p++){
		GDKfree( fmt[p].sep );
	}
	GDKfree(fmt);
}

static
int assign_BATs( ascii *as, BAT *bats ){
	ascii_io *fmt = as->format;
	int res = as->nr;
	int i;
	for (i=0; i<as->nr_attrs; i++){
		BAT *b = (BAT*)BATdescriptor(*(bat*)bun_tail(bats, i));
		fmt[i].c = (b);
		if (res == -1 || BATcount(fmt[i].c)<res)
			res = BATcount(fmt[i].c);
	}
	as->nr = res;
	return res;
}

static
int check_BATs( ascii *as ){
	ascii_io *fmt = as->format;
	int i;
	int cnt = BATcount(fmt[0].c);
	oid base = fmt[0].c->hseqbase;

	if (!BAThdense(fmt[0].c)) return -1;

	for (i=0; i<as->nr_attrs; i++){
		BAT *b = fmt[i].c;
		if (BATcount(fmt[i].c) != cnt ||
		    fmt[i].c->hseqbase != base)
			return -1;

		fmt[i].p = (ptr)BUNfirst(fmt[i].c);
	}
	return base;
}

static
int create_bats( ascii *as ){
	ascii_io *fmt = as->format;
	int i;

	for (i=0; i<as->nr_attrs; i++){
		fmt[i].c = void_bat_create(fmt[i].adt,as->nr);
	}
	return 0;
}

static
BAT *collect_bats( ascii *as ){
	BAT *bats = BATnew(TYPE_str,TYPE_bat,as->nr_attrs);
	ascii_io *fmt = as->format;
	int i;

	for (i=0; i<as->nr_attrs; i++){
		BUNins(bats,(ptr)fmt[i].name, (ptr)&fmt[i].c->batCacheid);
		BBPunfix( fmt[i].c->batCacheid );
	}
	return bats;
}

static INLINE
int myisspace(int s ){
        if (s==(int)' ' || s==(int)'\t' || s==(int)'\n'){
                return 1;
        }
        return 0;
}

static INLINE
char *strip( char *s, char *e ){
        while(myisspace((int)*s)){
		s++;
	}
	e--;
        while(myisspace((int)*e)){
		e--;
	}
	e++;
	if (e && *e){
		*e = 0;
	}
	return s;
}

static INLINE
void insert_val( ascii_io *fmt, char *s, char *e ){
	ptr *adt;
	adt = ADT_fromStr( fmt->adt, strip(s,e) ); 
	BUNins(fmt->c,&int_nil,adt);
	GDKfree(adt);
}

static INLINE
int insert_line( ascii *as, char *line ){
	ascii_io *fmt = as->format;
        char *s,*e = 0;
	int i,quotes = 0;
	for( i = 0; i<as->nr_attrs-1; i++){
		s=line;
		while(*line){
			if (*line == *(fmt[i].sep) && 
			     strncmp( fmt[i].sep, line, fmt[i].seplen) == 0 ){
				e = line; /*strstr( line, fmt[i].sep ); */
				break;
		     	} else if(*line == '\"' && *(line-1) != '\\'){
				quotes = 1;
				line++;
				while( *line && *line!='\"') line++;
				if (*line) line++;
				else return -1;
			} else {
				line++;
			}
		}
		if (e){
			char *end = e;
			if (quotes){
				quotes = 0;
				s = strchr(s, '\"');
				if (!s) return -1;
				s++;
				e = strchr(s, '\"');
			}
			*e = 0;
			insert_val( &fmt[i], s, e );
			line = end + fmt[i].seplen;
		} else {
		        GDKerror("Error: missing sep %s line %d field %d\n", fmt->sep, BATcount(fmt->c), i);
			return -1;
		}
		e = 0;
	}
	s=line;
	while(*line){
		if (*line == *(fmt[as->nr_attrs-1].sep) && 
		     strncmp( fmt[as->nr_attrs-1].sep, line, 
			      fmt[as->nr_attrs-1].seplen) == 0 ){
			e = line; /*strstr( line, fmt[as->nr_attrs-1].sep ); */
			break;
		} else if(*line == '\"' && *(line-1) != '\\'){
			quotes = 1;
			line++;
			while( *line && *line!='\"') line++;
			if (*line) line++;
			else return -1;
		} else {
			line++;
		}
	}
	if (!e) e = line;
	if (e){
		char *end = e;
		if (quotes){
			quotes = 0;
			s = strchr(s, '\"');
			if (!s) return -1;
			s++;
			e = strchr(s, '\"');
		}
		*e = 0;
		insert_val( &fmt[as->nr_attrs-1], s, e );
		line = end + fmt[as->nr_attrs-1].seplen;
	}
	e = 0;
	return 0;
}

static INLINE
int dump_line( char **buf, int *len, ascii_io *fmt, stream *fd, int nr_attrs, int id ){
	int i;
	for( i = 0; i<nr_attrs; i++){
		int l =
		 ADT_toStr(buf, len, fmt[i].adt, (char*)bun_tail(fmt[i].c,id));
		(void)fd->write( fd, *buf, 1, l );
		(void)fd->write( fd, fmt[i].sep, 1, fmt[i].seplen );
	}
	return 0;
}

static INLINE
int output_line( char **buf, int *len, ascii_io *fmt, stream *fd, int nr_attrs, ptr id ){
	int i;
	for( i = 0; i<nr_attrs; i++){
		fmt[i].p = BUNfnd( fmt[i].c, id );
		if (fmt[i].p == 0)
			break;
	}
	if ( i == nr_attrs ){
	    for( i = 0; i<nr_attrs; i++){
		if (fmt[i].adt == TYPE_str){
			char *s = (char*)BUNtail(fmt[i].c, fmt[i].p);
			int l = strlen(s);
			(void)fd->write( fd, "\"", 1, 1 );
			(void)fd->write( fd, s, 1, l );
			(void)fd->write( fd, "\"", 1, 1 );
		} else {
			int l = ADT_toStr(buf, len, fmt[i].adt, 
			(char*)BUNtail(fmt[i].c,fmt[i].p));
			(void)fd->write( fd, *buf, 1, l );
		}
		(void)fd->write( fd, fmt[i].sep, 1, fmt[i].seplen );
	    }
	}
	return 0;
}

static INLINE
int output_line_dense( char **buf, int *len, ascii_io *fmt, stream *fd, int nr_attrs ){
	int i;
	for( i = 0; i<nr_attrs; i++){
		char *p = BUNtail(fmt[i].c, fmt[i].p);
		if (fmt[i].adt == TYPE_str){
			int l = strlen(p);
			(void)fd->write( fd, "\"", 1, 1 );
			(void)fd->write( fd, p, 1, l );
			(void)fd->write( fd, "\"", 1, 1 );
		} else {
			int l = ADT_toStr(buf, len, fmt[i].adt, p);
			(void)fd->write( fd, *buf, 1, l );
		}
		(void)fd->write( fd, fmt[i].sep, 1, fmt[i].seplen );
		fmt[i].p = BUNnext( fmt[i].c, fmt[i].p );
	}
	return 0;
}

static INLINE
int output_line_lookup( char **buf, int *len, ascii_io *fmt, stream *fd, int nr_attrs, int id ){
	int i;
	for( i = 0; i<nr_attrs; i++){
		char *p = BUNtail(fmt[i].c, BUNptr(fmt[i].c,id+BUNindex(fmt[i].c,BUNfirst(fmt[i].c))));
		if (fmt[i].adt == TYPE_str){
			char *s = (char*)p;
			int l = strlen(s);
			(void)fd->write( fd, "\"", 1, 1 );
			(void)fd->write( fd, s, 1, l );
			(void)fd->write( fd, "\"", 1, 1 );
		} else {
			int l = ADT_toStr(buf, len, fmt[i].adt, p);
			(void)fd->write( fd, *buf, 1, l );
		}
		(void)fd->write( fd, fmt[i].sep, 1, fmt[i].seplen );
	}
	return 0;
}


#define SIZE 1*1024*1024
static
int load_file( ascii *as, stream *fd ){
	int eof = 0, p = 0, done = 0, bufsz = SIZE;
	char *buf = GDKmalloc(bufsz+1);
	char *s = buf,*sep = as->format[as->nr_attrs-1].sep;
        int i = 0, seplen = as->format[as->nr_attrs-1].seplen;

	if (ascii_io_debug)
		fprintf( GDKerr, "load_file\n");

	while(!eof && (as->nr < 0|| i < as->nr)){
		int l, size = bufsz-p;
		char *end;
		if ((l=fd->read(fd, buf+p, 1, size )) < size )
			eof = 1;
		end = s + p + l;
		*end = '\0';
		p = l = 0;
		done = 0;
		while( s < end ){
			char *e = strstr( s, sep );
			if (e){
				*e = '\0';
				insert_line(as, s );	
				s = e + seplen;
				done = 1;
			} else if (eof && s + as->nr_attrs < end){
				insert_line(as, s );	
				s = end;
			} else {
				if (!done){ /* nothing found in current buf
					     * ie. need to enlarge 
					     */
					buf = GDKrealloc(buf, (bufsz*=16) +1);
				}
				p = end - s;
				memcpy(buf, s, p );
				break;
			}
			i++;
			if (ascii_io_debug && (i%100000) == 0)
				fprintf(GDKerr, "inserted %d\n", i);
			if (as->nr > 0 && i >= as->nr)
				break;
		}
		s = buf;
	}
	GDKfree(buf);
	as->nr = i;
	return 0;
}

static
int dump_file( ascii *as, stream *fd ){
        int i = 0;
	int len = BUFSIZ;
	char *buf = GDKmalloc(len);
	for( i=0; i<as->nr; i++ ){
		if (dump_line( &buf, &len, as->format, fd, as->nr_attrs, i )<0){
			GDKfree(buf);
			return -1;
		}
		if (ascii_io_debug && (i%1000000) == 0)
			fprintf(GDKerr, "dumped %d lines\n", i);
        } 
	GDKfree(buf);
	return 0;
}

static
int output_file( ascii *as, BAT *order, stream *fd ){
	int len = BUFSIZ; 
	char *buf = GDKmalloc(len);
	BUN p,q;
        int i = 0;
	as->nr = BATcount(order);
	
	BATloop( order, p, q){
		ptr h = BUNhead(order, p);
		if(output_line( &buf, &len,as->format, fd, as->nr_attrs, h )<0){
			GDKfree(buf);
			return -1;
		}
		i++;
		if (ascii_io_debug && (i%1000000) == 0)
			fprintf(stderr, "dumped %d lines\n", i);
        } 
	GDKfree(buf);
	return i;
}

static
int output_file_dense( ascii *as, stream *fd ){
	int len = BUFSIZ; 
	char *buf = GDKmalloc(len);
	BUN p,q;
        int i = 0;
	
	for(i=0; i<as->nr; i++){
		if(output_line_dense( &buf, &len, as->format, fd, as->nr_attrs )<0){
			GDKfree(buf);
			return -1;
		}
		if (ascii_io_debug && (i%1000000) == 0)
			fprintf(stderr, "dumped %d lines\n", i);
        } 
	GDKfree(buf);
	return i;
}

static
int output_file_ordered( ascii *as, BAT *order, stream *fd, int base ){
	int len = BUFSIZ; 
	char *buf = GDKmalloc(len);
	BUN p,q;
        int i = 0;
	
	BATloop( order, p, q){
		oid h = *(oid*)BUNhead(order, p) - base;
		if(output_line_lookup( &buf, &len, as->format, fd, as->nr_attrs, h )<0){
			GDKfree(buf);
			return -1;
		}
		if (ascii_io_debug && (i%1000000) == 0)
			fprintf(stderr, "dumped %d lines\n", i);
        } 
	GDKfree(buf);
	return i;
}
@-
@= getBATdescriptor
        if( BBPcheck(*@2,"@4")==0)
                return throwMessage("ascii_io.@4","cannot access bat @2 in bbp");
        @3= (BAT*) BBPgetdesc(*@2);
        if( @3 == NULL) { *@1 = 0;
                return throwMessage("ascii_io.@4","cannot access descriptor @2");
        }
        if(*@2 <0) @3= BATmirror(@3);

@c

BAT *ASCIIload( BAT *names, BAT *seps, BAT *types, 
		 char *datafile, int nr ){
	BAT *bats = NULL;
	ascii as;

	as.nr_attrs = 0;
	as.nr = nr;
	if (create_loadformat( &as, names, seps, types) >= 0 && 
	    create_bats( &as ) >= 0){
		stream *s = open_rastream( datafile );
		if (!s->errnr && load_file( &as, s )>=0)
			bats = collect_bats( &as );
		if (s->errnr){
		 	GDKerror("could not open file %s\n", datafile );
		} else {
			s->close(s);
		}
		s->destroy(s);
	}
	destroy_format( &as );
	return bats;
}

void ASCIIdump( BAT *names, BAT *seps, BAT *bats, 
	      char *datafile, int nr ){
	ascii as;

	as.nr_attrs = 0;
	as.nr = nr;
	if (create_dumpformat( &as, names, seps, bats) >= 0 && 
	    assign_BATs( &as, bats ) >=  0){
		stream *s = open_wastream( datafile );
		if (!s->errnr && dump_file( &as, s ) >= 0){
			fprintf(GDKerr, "saved in %s\n", datafile );
		}
		if (s->errnr){
		 	GDKerror("could not open file %s\n", datafile );
		} else {
			s->close(s);
		}
		s->destroy(s);
	}
	destroy_format( &as );
}
int ASCIIoutput( BAT *order, BAT *seps, BAT *bats, stream *s ){
	ascii as;
	int base = -1;

	as.nr_attrs = 0;
	as.nr = -1;
	if (create_dumpformat( &as, NULL, seps, bats) >= 0 && 
	    assign_BATs( &as, bats ) >=  0){
		if ((base = check_BATs( &as )) >= 0 ){
			if (BAThdense(order) && 
 			    order->hseqbase == base && BATcount(order) == as.nr)
				output_file_dense( &as, s );
			else
				output_file_ordered( &as, order, s, base );
		} else {
			output_file( &as, order, s ); 
		}
	}
	destroy_format( &as );
	return as.nr;
}

str ASCII_IOprelude(int *ret, int *debug){
	ascii_io_debug = *debug;
	return MAL_SUCCEED;
}
str ASCII_IO_load(int *ret, int *nid, int *sid, int *tid, str *datafile, int *nr)
{	BAT **bats, *names, * seps, * types;
        @:getBATdescriptor(ret,nid,names,load)@
        @:getBATdescriptor(ret,sid,seps,load)@
        @:getBATdescriptor(ret,tid,types,load)@

	*bats = ASCIIload( names, seps, types, *datafile, *nr );
	if (*bats) return MAL_SUCCEED;
	return throwMessage("ascii_io.load","GDKerror");
}
str ASCII_IO_dump(int *ret, int *nid, int *sid, int *bid, str *datafile, int *nr)
{	BAT *names, *seps, *bats;

        @:getBATdescriptor(ret,nid,names,dump)@
        @:getBATdescriptor(ret,sid,seps,dump)@
        @:getBATdescriptor(ret,bid,bats,dump)@

	ASCIIdump( names, seps, bats, *datafile, *nr );
	return MAL_SUCCEED;
}
str ASCII_IO_output(int *ret, int *oid, int *sid, int *bid, ptr *s)
{	BAT *order, *seps, *bats;
        @:getBATdescriptor(ret,oid,order,dump)@
        @:getBATdescriptor(ret,sid,seps,dump)@
        @:getBATdescriptor(ret,bid,bats,dump)@

	ASCIIoutput( order, seps, bats, *(stream**)s );
	return MAL_SUCCEED;
}

@mil
module(ascii_io,io);

#ascii_io_debug(1);

fp := fopen ( "format", "w+" );
fputs( "key,\",\",str\n", fp);
fputs( "a_io_test,\"\\n\",dbl\n", fp);
fclose( fp );

fp := fopen ( "data", "w+" );
fputs( "test, 0.12345\n", fp);
fputs( "second line, 9.0\n", fp);
fclose( fp );

bats := load("format","data",10);
bats := load_data(load_format(path+"/format"), path+"/test100k", 100000);
bats.print;
a := bats.find("key").reverse().join( bats.find("a_io_test") );
a.print;
dump_data(load_format("format"), "data", -1);

fp := fopen ( "data", "r" );
s := fgets( fp ); 
s.print();
fclose( fp );
quit;
