@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Pieces created by CWI are Copyright (C) 1997-2004 CWI.
@' All Rights Reserved.
@'
@' Contributor(s):
@'              Martin Kersten <Martin.Kersten@cwi.nl>
@'              Peter Boncz <Peter.Boncz@cwi.nl>
@'              Niels Nes <Niels.Nes@cwi.nl>
@'              Stefan Manegold  <Stefan.Manegold@cwi.nl>
 
@f crackers
@a Martin Kersten
@* Crackers
This module contains the experimental code to play with cracked tables.
It supports int-based bats for the time being.

A cracker is a logically partitioned bat. The partitions are
administered using separate administration BATs.
The partitions are mostly derived from ordered, tail values.
However, a derived fragmentation based on the (v)oid heads
is foreseen.

Each time we issue a scan against a cracked BAT we split all partitions
accordingly and retain their location. In this process we
re-shuffle BUNs around to produce dense range lists.
It can be used in subsequent scans to speed up the search.

The implementation currently requires all auxillary BATs to
be passed around to the cracker routines. It should be
replaced in the future by a generic administration for
cracked tables.

Furthermore, we keep a copy of the value ranges.
It is the basis for selecting the pieces for subsequent
processing.

[todo] Cracking a BAT should be bounded by either the
number of pieces already obtained or the granularity
of a piece.

[todo] Coalescing pieces to create larger ones. Especially
relevant if you switch partitioning head and tail.

Initial performance indicates around 70 ms processing
overhead on a 1M bat during the first crack operation.
(Athlon 1400, 1Gb)
@mal
module crackers;

command new(b:bat[:int,:int]) 
address CRKnew
comment "Create the index tables for a cracked
	table.";

command info(b:bat[:int,:int])
address CRKinfo
comment "Print the cracker index administration";

command crack(b:bat[:int,:int],low:int,hgh:int) :int
address CRKcrackNaive
comment "Break the partitions into smaller pieces";
@-
A cracker partition is indicated by the index in the cidx
table. It can be used to initialize a BATview to represent
the partition during processing.
@mal
command firstPiece(b:bat[:int,:int])
	(a:int,x:bat[:int,:int])
address CRKfirstPiece
comment "Retrieve the first piece of a cracked
	BAT as a BAT view and also return the
	identity of the next piece.";

command nextPiece(b:bat[:int,:int],
	crk:bat[:int,:int], piece:int)
	:int
address CRKnextPiece
comment "Retrieve the next piece of a cracked
	BAT by adjusting the BAT view descriptor.
	It returns the next valid piece id.
	A value zero means 'end-of-sequence'";

command getPiece(b:bat[:int,:int], piece:int)
	:bat[:int,:int]
address CRKgetPiece0
comment "Retrieve a piece of a cracked
	BAT into a new BAT view.";

command getPiece(b:bat[:int,:int],
	crk:bat[:int,:int], piece:int)
address CRKgetPiece1
comment "Retrieve a piece of a cracked
	BAT into a known BAT view.";

command selectPieces( b:bat[:int,:int],
	low:int, hgh:int)
	:bat[:void,:int]
address CRKselectPieces
comment "Retrieve identities of all pieces
	that qualify the selection criterion.";

command dropPiece(b:bat[:int,:int])
address CRKdropPiece
comment	"Garbage collect the piece representation";
@{
@* Implementation
The implementation is geared at early experimentation
without all the details to make the code robust and
ultra fast.
Furthermore, the administration is purposely maintained in
BATs to exploits the cracker features lated in query processing.

@= getBATdescriptor
        if( BBPcheck(*@2,"@4")==0)
                return throwMessage("crackers.@4","cannot access bat @2 in bbp");
        @3= (BAT*) BBPgetdesc(*@2);
        if( @3 == NULL) { *@1 = 0;
                return throwMessage("crackers.@4","cannot access descriptor @2");
        }
        if( *@2 <0) @3= BATmirror(@3);

@-
The relationships between a table and its cracker index
is locally maintained. 
@h
#ifndef _CRACKERS_H_
#define _CRACKERS_H_


#define LEAF 'L'
#define PHI  'P'		/* broken using a select */
#define DIAMOND  'D'	/* broken using a join */
#define OMEGA  'O'	/* broken using a group */

typedef struct{
	char kind;	/* kind of piece */
	int rng_max;	/* the value ranges */
	int rng_min;	
	int idx_first;	/* the slice boundaries */
	int idx_last;	
	int parent;	/* lineage */
} Piece;

typedef struct{
	int bid;	/* the original bat */
	int freepiece, maxpiece;
	Piece *pieces;
} CrackMap;

extern str initCrackMap(CrackMap *map,int *bid);

#endif /* _CRACKERS_H */
@-
During initialization of the crackers structure we already
shuffle the data around to have a first assessment of
the value ranges supported.
@c
#include "mal.h"
#include "mal_exception.h"
#include "crackers.h"

static CrackMap *crackMap;
static int maxCrackMap;

int findCrackMap(int bid){
	int i;
	for(i=0; i<maxCrackMap; i++)
	if( crackMap[i].bid== bid) return i;
	if( i== maxCrackMap){
		CrackMap *x= (CrackMap*) GDKmalloc(sizeof(CrackMap) * (i+10));
		if(crackMap){
			fprintf(stderr,"reallocate Crackmap\n");
			memcpy(x,crackMap, sizeof(CrackMap)* i);
			GDKfree(crackMap);
		}
		crackMap= x;
		maxCrackMap = i+10;
	}
	/* init the crackmap */
	crackMap[i].bid= bid;
	crackMap[i].pieces = GDKmalloc(sizeof(Piece) *1024);
	crackMap[i].freepiece= 0;
	crackMap[i].maxpiece = 1024;
	return i;
}
void printCrackMapElement(Piece *list, int i, int bid){
	stream_printf(GDKout,"[ %3d %3d, ",i,bid);
	stream_printf(GDKout,"%c, ",list[i].kind);
	stream_printf(GDKout,"%d ",list[i].parent);
	stream_printf(GDKout,"%d, ",list[i].rng_min);
	stream_printf(GDKout,"%d, ",list[i].rng_max);
	stream_printf(GDKout,"%d, ",list[i].idx_first);
	stream_printf(GDKout,"%d, ]\n",list[i].idx_last);
}
void printCrackMap(int bid){
	int i,m;
	m= findCrackMap(bid);
	stream_printf(GDKout,"# idx bid kind parent rng_max rng_min idx_first idx_last # name\n");
	for(i=0;i<crackMap[m].freepiece;i++)
		printCrackMapElement(crackMap[m].pieces,i,bid);
}

str CRKnew(int *cret, int *bid){
	int m;
	(void) cret;
	m= findCrackMap(*bid);
	initCrackMap(crackMap+m, bid);
	stream_printf(GDKout,"crackMap created\n");
	return MAL_SUCCEED;
}
str CRKinfo(int *k, int *bid)
{	
	(void) k;
	printCrackMap(*bid);
	return MAL_SUCCEED;
}
str initCrackMap(CrackMap *map, int *bid){
	BAT *b;
	BUN kmin=NULL, vmin=NULL, kmax=NULL, vmax=NULL;
	BUN p,q;
	int xx;
	int result;
	char buf[128]; /* scratch space */

        @:getBATdescriptor(&result,bid,b,initCrackMap)@
	(void) result;
@-
The target BAT should not be modified by the applications,
otherwise the partitioning scheme becomes void
already. [todo]
@c
	p= BUNfirst(b);
	kmax= kmin= p;
	vmax= vmin= p;
	
	BATloopFast(b,p,q,xx){
		ptr v= BUNhead(b,p);
		if( *(int *)v < *(int *)BUNhead(b,kmin)) kmin = p;
		if( *(int *)v > *(int *)BUNhead(b,kmax)) kmax = p;
		v= BUNtail(b,p);
		if( *(int *)v < *(int *)BUNtail(b,vmin)) vmin = p;
		if( *(int *)v > *(int *)BUNtail(b,vmax)) vmax = p;
	}
@-
Reserve space for the cracker pieces
@c
	map->freepiece= 1;
@-
Initialize the index tables and reshuffle the BUNs
according to the tail value;
@c
	map->pieces[0].rng_min= *(int*)BUNtail(b,vmin);
	map->pieces[0].rng_max= *(int*)BUNtail(b,vmax);
	map->pieces[0].idx_first = BUNindex(b,BUNfirst(b));
	map->pieces[0].idx_last = BUNindex(b,BUNlast(b))-1;
	map->pieces[0].kind = LEAF;
	map->pieces[0].parent = -1;

	assert(BUNsize(b)<128);
	p= BUNfirst(b);
	@:exchange(p,vmin)@
	if( p == vmax) vmax= vmin;
	p= BUNlast(b)- BUNsize(b);
	@:exchange(vmax,p)@
	return MAL_SUCCEED;
}
@-
@= exchange
#ifdef DEBUG
	printf("exchange %d %d\n",BUNindex(b,@1),BUNindex(b,@2));
#endif
	memcpy(buf, @1, BUNsize(b));
	memcpy(@1, @2, BUNsize(b));
	memcpy(@2, buf, BUNsize(b));
@= exchange2
#ifdef DEBUG
	printf("exchange %d %d %d\n",BUNindex(b,@1),
		BUNindex(b,@2),BUNindex(b,@3));
#endif
	memcpy(buf, @1, BUNsize(b));
	memcpy(@1, @3, BUNsize(b));
	memcpy(@3, @2, BUNsize(b));
	memcpy(@2, buf, BUNsize(b));

@- Cracking
The key operation for the cracker infrastructure is to process a scan
efficiently and re-shuffle the tuples in the BAT such that a simple
BATview can be used to denote the subrange of interest to upper layers.
Assume the rane (low,hgh), both inclusive, is needed then all tuples
not qualifying this range should be moved out of the way by effectively
splitting the BAT into three segments.

Two strategies can be considered; a naive exchange shuffle and
pre-scan shuffle.
The naive exchange shuffle works as follows. We simple walk through the table
left to right and move all elements >=low to the right. 
A slightly improved version is to find groups of tuples to move around
as larger chunks.

The pre-scan shuffle reads the table twice. In the first phase we
calculate (for each partition) the number of elements in the range
(low,hgh). In the second phase we move the data into the designated place.
The advantage over the naive shuffle is potential less data writes.

First experiment is a simple partitioning on the tail value.
@= newPiece
	if(crackMap[@1].maxpiece == crackMap[@1].freepiece ){
		printf("too many pieces");
		exit(-1);
	}
	@2 = crackMap[@1].pieces+ crackMap[@1].freepiece;
	crackMap[@1].freepiece++;
@c
str CRKcrackNaive(int *partid, int *bid, int *low, int *hgh)
{	
	BAT *b;
	int result;
	Piece *piece, *npiece;
	int xx;
	ptr p;
	char buf[128]; /* scratch space */
	ptr vmax=0, vmin=0,vm;
	int lim, m,i,l,h, pid= -1;


	if( *(int*) low > *(int*) hgh)
                return throwMessage("crackers.crack","illegal range");
        @:getBATdescriptor(&result,bid,b,CRKcrackNaive)@
	(void) result;
	m= findCrackMap(*bid);
@-
Inspect the value range table to only further crack qualifying fragments.
@c
	
	lim= crackMap[m].freepiece;
#ifdef DEBUG
	printf("search range %d %d [lim=%d]\n",*(int*)low, *(int*) hgh,lim);
#endif
	for(i=0; i< lim; i++){
		if( crackMap[m].pieces[i].kind != LEAF) continue;
		if( crackMap[m].pieces[i].rng_max < *(int*) low) continue;
		if( crackMap[m].pieces[i].rng_min > *(int*) hgh) continue;
		if( *(int*) low <=  crackMap[m].pieces[i].rng_min &&
		    *(int*) hgh >=  crackMap[m].pieces[i].rng_max) {
#ifdef DEBUG
			printf("skip range %d-%d\n",
				crackMap[m].pieces[i].rng_min,
				crackMap[m].pieces[i].rng_max);
#endif
			continue;
		}

		piece = crackMap[m].pieces+i;
		/* set bounds */
		xx= BUNsize(b);
		vmin= (ptr)((char*)BUNptr(b,piece->idx_first)-xx);
		vmax= (ptr)((char*)BUNptr(b,piece->idx_last)+xx);

		vm= BUNtail(b,vmin+xx);
		for(p = (ptr)((char*) vmin+xx); p < vmax; 
			p = (ptr)((char*)p+ xx), 
			vm= (ptr)((char*)vm+xx)) {
			if( *(int *)vm < *(int *)low){
				/* exchange with first low*/
				vmin= (ptr)((char*)vmin+xx);
				if( vmin != p){
					@:exchange(vmin,p)@
				}
			} else
			if( *(int *)vm > *(int *) hgh){
				/* exchange with qualifying tail elm */
				vmax= (ptr)((char*)vmax-xx);
				while( *(int*) BUNtail(b,vmax) >
						*(int*)hgh && vmax>p) 
					vmax= (ptr)((char*)vmax-xx);
				if( vmax != p){
					@:exchange(vmax,p)@
					vm= (ptr)((char*)vm-xx);
					p= (ptr)((char*)p-xx);
@-
The choosen element could also be less then 'low' and an 
exchange operation could be saved. It turned out that
this optimization was not effective when a BUNtail
test was performed. A similar remark holds for having
an additional variable to keep track of the tail value.
@c

				}
			}
		}
@-
For each fragment discovered we have to break it into several pieces
and update the administration BATs. 
@c
		l= BUNindex(b,vmin)+1;
		h= BUNindex(b,vmax)-1;

		if(piece->idx_first == l){
			if( h< piece->idx_last){
#ifdef DEBUG
		printf("left split [%d] %d-%d \n",i,l,h);
#endif
				piece->kind = PHI;
				pid = crackMap[m].freepiece;
				@:newPiece(m,npiece)@
				npiece->rng_min= piece->rng_min;
				npiece->rng_max= *(int*)hgh;
				npiece->idx_first= piece->idx_first;
				npiece->idx_last = h;
				npiece->kind = LEAF;
				npiece->parent=i;
				@:newPiece(m,npiece)@
				npiece->rng_min= *(int*)hgh + 1;
				npiece->rng_max= piece->rng_max;
				npiece->idx_first= h+1;
				npiece->idx_last = piece->idx_last;
				npiece->kind = LEAF;
				npiece->parent=i;
			} 
		} else
		if( piece->idx_last == h){
			if( l>piece->idx_first){
#ifdef DEBUG
		printf("right split [%d] %d-%d \n",i,l,h);
#endif
				/* falls at high end */
				piece->kind= PHI;
				@:newPiece(m,npiece)@
                                npiece->rng_min= piece->rng_min;
                                npiece->rng_max= *(int*) low -1;
                                npiece->idx_first= piece->idx_first;
                                npiece->idx_last = l-1;
                                npiece->kind = LEAF;
                                npiece->parent=i;

				pid = crackMap[m].freepiece;
				@:newPiece(m,npiece)@
                                npiece->rng_min= *(int*) low;
                                npiece->rng_max= piece->rng_max;
                                npiece->idx_first= l;
                                npiece->idx_last = piece->idx_last;
                                npiece->kind = LEAF;
                                npiece->parent=i;
			}
		} else {
#ifdef DEBUG
		printf("middle split [%d] %d-%d \n",i,l,h);
#endif
				piece->kind= PHI;
				@:newPiece(m,npiece)@
                                npiece->rng_min= piece->rng_min;
                                npiece->rng_max= *(int*) low -1;
                                npiece->idx_first= piece->idx_first;
                                npiece->idx_last = l-1;
                                npiece->kind = LEAF;
                                npiece->parent=i;
				pid = crackMap[m].freepiece;
				@:newPiece(m,npiece)@
                                npiece->rng_min= *(int*) low;
                                npiece->rng_max= *(int*) hgh;
                                npiece->idx_first= l;
                                npiece->idx_last = h;
                                npiece->kind = LEAF;
                                npiece->parent=i;
				@:newPiece(m,npiece)@
                                npiece->rng_min= *(int*) hgh+1;
                                npiece->rng_max= piece->rng_max;
                                npiece->idx_first= h+1;
                                npiece->idx_last = piece->idx_last;
                                npiece->kind = LEAF;
                                npiece->parent=i;
		}
	}
@-
If this was the first cracking operation it makes sense to administer
the ranges of the outer partitions as well.
@c
	*partid= pid;
	return MAL_SUCCEED;
}
@- 
The pieces of a cracked BAT are obtained through bat view.
The nextPiece simply changes the dimensions of the BATview
returned previously to represent a cracker piece.
@c
int CRKsetBounds(BAT *b, BAT *view, int mid, int pid){
	int l,h;
	size_t low;
	(void) view; /* fool compiler */

	low= l= crackMap[mid].pieces[pid].idx_first;
	h= crackMap[mid].pieces[pid].idx_last;
#ifdef DEBUG
	printf("set view to new dimension[%d,%d]: %d-%d\n",mid, pid,l,h);
#endif
	view->batBuns->base = BUNptr(b, l-1);
	view->batInserted = BUNptr(b, l);
	view->batHole = view->batDeleted = view->batBuns->base;
	view->batBuns->maxsize = view->batBuns->size =
	view->batBuns->free = BUNptr(b,h+1) - view->batBuns->base;
	view->hsorted = BAThordered(b);
        view->tsorted = BATtordered(b);

        BATkey(view, BAThkey(b));
        BATkey(BATmirror(view), BATtkey(b));
        if (BAThdense(b)) {
                BATseqbase(view, b->hseqbase+l);
        }
        if (BATtdense(b)) {
                BATseqbase(BATmirror(view), b->tseqbase+low);
        }

	if( pid== BATcount(b)) return 0;
	return pid+1;
}
str CRKfirstPiece(int *newpid, int *vid, int *bid) 
{
	BAT *b, *view;
	int m,i,result=0;

        @:getBATdescriptor(&result,bid,b,Piece)@
	(void) result;
	m= findCrackMap(*bid);

	b->batRestricted= BAT_READ;
	view= VIEWcreate_(b,TRUE);
	BBPfix(*vid=  view->batCacheid);

	*newpid= -1;
	for(i=0; i<crackMap[m].freepiece; i++)
	if( crackMap[m].pieces[i].kind == LEAF) {
		*newpid = CRKsetBounds(b,view,m,i);
		break;
	}
	return MAL_SUCCEED;
}
str CRKnextPiece(int *newpid, int *bid, int *vbid, int *pid) 
{
	BAT *b, *vid;
	int m,i, result=0;

        @:getBATdescriptor(&result,bid,b,nextPiece)@
        @:getBATdescriptor(&result,vbid,vid,nextPiece)@
	(void) result;
	m= findCrackMap(*bid);

	/* test validity of pid  [todo] */
	if( *pid >crackMap[m].freepiece ){
		*newpid= 0;
		return MAL_SUCCEED;
	}
	if( *pid<=0 ){
                return throwMessage("crackers.nextPiece",
			"illegal piece");
	}

	for( i= *pid; i< crackMap[m].freepiece; i++)
	if( crackMap[m].pieces[i].kind == LEAF) {
		*newpid = CRKsetBounds(b,vid,m,i);
		return MAL_SUCCEED;
	}
	*newpid= 0;
	return MAL_SUCCEED;
}
@-
Selectively retrieve the pieces from the jigsaw.
@c
str CRKgetPiece0(int *vbid, int *bid, int *piece) 
{
	BAT *b, *vid;
	int  m, result=0;

        @:getBATdescriptor(&result,bid,b,getPiece)@
	CRKfirstPiece( &result, vbid, bid);
        @:getBATdescriptor(&result,&result,vid,getPiece)@
	(void) result;
	m= findCrackMap(*vbid);
	CRKsetBounds(b,vid,m,*piece);
	return MAL_SUCCEED;
}
str CRKgetPiece1(int *newpid, int *bid, int *vbid, int *piece) 
{	int m, result;
	BAT *b, *vid;

        @:getBATdescriptor(&result,bid,b,getPiece)@
        @:getBATdescriptor(&result,vbid,vid,getPiece)@
	(void) result;
	m= findCrackMap(*bid);
	/* test validity of piece */
	CRKsetBounds(b,vid,m,*piece);
	*newpid = 0;
	return MAL_SUCCEED;
}
@-
A common operation is to find all the pieces that
overlap with a range. It can be used for subsequent
iteration and flow-based processing.
@c
str CRKselectPieces(int *result, int *bid, int *low, int *hgh) 
{
	BAT *b;
	int m,i;
	oid o= oid_nil;

	m= findCrackMap(*bid);
	b= BATnew(TYPE_void,TYPE_int,oid_nil);
	for(i=0; i< crackMap[m].freepiece; i++)
	if( crackMap[m].pieces[i].kind == LEAF){
		if( crackMap[m].pieces[i].rng_max < *low) continue;
		if( crackMap[m].pieces[i].rng_min > *hgh) continue;
		BUNins(b,&o,&i);
	}
	BBPfix(*result = b->batCacheid);
	return MAL_SUCCEED;
}

@-
The GDK kernel contains an error wrt garbage collection
of BATview objects. They have to be freed explicitly
@c
str CRKdropPiece(int *newpid, int *bid){
	BAT *b;
	int result=0;
	(void) newpid;
        @:getBATdescriptor(&result,bid,b,dropPiece)@
	(void) result;
	VIEWdestroy(b);
	return MAL_SUCCEED;
} 
@-
Test cases for this experiment are stored under the sequente tst5000
@}
