@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@' 
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@' 
@' The Original Code is the Monet Database System.
@' 
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2004 CWI.
@' All Rights Reserved.
@f reference
@a Martin Kersten
@v 1.0
@+ Online help system
All procedural abstractions may contain a string with commentary text.
This information is retained in the symbol table for subsequent use.
It can be extracted into a BAT for inspection, such as providing
an online help facility.
@mal
module reference;

command help(k:str):bat[:str,:str] 
address CMDhelp
comment "Search the commentary strings for 
	one matching the keyword";
command help(mod:str,fcn:str)
	:bat[:int,:str] 
address CMDhelp2
comment "Collect the comments for a given 
	function pattern";
@- Manual construction
The manual operations ease offline inspection of all the Monet function
definitons.
It purposely generates an XML organized file, because we expect external
tools to massage it further for presentation. The envisioned 
tagging structure becomes
@-
@mal
command manual(file:str,mod:str)
address CMDmanual2
comment "Generate a synopsis of a module";
command manual(file:str,mod:str,recursive:int)
address CMDmanual
comment "Generate a recursive module synopsis";
command manual(mod:str)
address CMDmanual1
comment "Generate a synopsis of a module";
command manual()
address CMDmanual0
comment "Produces a XML-formatted manual 
	over all modules loaded.";

@-
@{
@h
#ifndef _LANGUAGE_H
#define _LANGUAGE_H
#endif /* _LANGUAGE_H*/
@-
@= Pseudo
        if (BBPindex("view_@1_@2") <= 0)
                BATname(b, "@2");
        BATroles(b,"@1","@2");
        BATmode(b,TRANSIENT);
        BATfakeCommit(b);
        *ret = b->batCacheid;

@c

#include "reference.h"
#include "mal.h"
#include "mal_client.h"
#include "mal_function.h"

str CMDraise(str *ret,  str *msg){
	*ret= GDKstrdup(*msg);
	return GDKstrdup(*msg);
}
str CMDmanual(int *ret, str *fname, str *mod,int *recursive){
	stream *fs;
	(void) ret; /* fool compiler */
	fs= open_wastream(*fname);
	if( fs== NULL) return throwMessage("mal.manual","Could not open file\n");
	dumpManualHeader(fs);
	dumpManual(fs, findScope(getClient()->nspace,*mod),*recursive);
	dumpManualFooter(fs);
	return MAL_SUCCEED;
}
str CMDmanual2(int *ret, str *fname, str *mod,int *recursive){
	int r= 0;
	(void) recursive; /* fool compiler */
	return CMDmanual(ret,fname,mod,&r);
}
str CMDmanual1(int *ret, str *mod){
	(void) ret; /* fool compiler */
	dumpManualHeader(GDKout);
	dumpManual(GDKout, findScope(getClient()->nspace,*mod),0);
	dumpManualFooter(GDKout);
	return MAL_SUCCEED;
}
str CMDmanual0(int *ret){
	(void) ret; /* fool compiler */
	dumpManualHeader(GDKout);
	dumpManual(GDKout, getClient()->nspace,1);
	dumpManualFooter(GDKout);
	return MAL_SUCCEED;
}
str CMDhelp(int *ret, str *mod) 
{	Client cntxt= getClient();
	Scope m;
	Symbol s;
	str msg;
	int i;
	BAT *b = BATnew(TYPE_str, TYPE_str, 256);
        if (b == 0) 
		return throwMessage("reference.help", "failed to create BAT");
        return throwMessage("reference.help", "Search by keyword not yet available");

	m= findScope(cntxt->nspace,*mod);
	if(m)
	for(i=0;i<256;i++){
		s= m->subscope[i];
		while(s!= NULL){
			msg= s->def->help;
			if( msg){
				BUNins(b,s->name,msg);
			}
			s= s->peer;
		}
	}
	@:Pseudo(help,Comment)@
	return MAL_SUCCEED;
}
str CMDhelp2(int *ret, str *mod, str *fcn) 
{	Symbol s;
	str msg;

	BAT *b = BATnew(TYPE_str, TYPE_str, 256);
        if (b == 0) 
		return throwMessage("reference.helpComment", "failed to create BAT");

	s= findSymbol(*mod,*fcn);
	while(s!= NULL){
		if(idcmp(s->name,*fcn)==0){
			msg= s->def->help;
			if(msg== NULL) msg= str_nil;
			BUNins(b,s->name,msg);
		}
		s= s->peer;
	}
	@:Pseudo(help,Comment)@
	return MAL_SUCCEED;
}

@-
@}
