@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2005 CWI.
@' All Rights Reserved.

@f mdb
@a Martin Kersten
@v 1
@* The debugger interface
This module provides access to the functionality offered
by the MonetDB debugger and interpreter status.
It is primarilly used in interactive sessions to activate
the debugger at a given point. Furthermore, the instructions
provide the necessary handle to generate information
for post-mortum analysis.

@+ Primary debugging commands
To enable ease of debugging and performance monitoring, the MAL interpreter
comes with a hardwired gdb-like text-based debugger.
A limited set of instructions can be included in the programs themselves,
but beware that debugging has a global effect. Any concurrent user
will be affected by breakpoints being set.
@mal
module mdb;

pattern start(b:bit):void 
address MDBtoggle
comment "Start/stop interactive debugger";
pattern start():void 
address MDBtoggle
comment "Start interactive debugger";

pattern trace():void
address MDBtrace
comment "Run the current function in timer trace mode";

pattern setTrace(b:bit):void
address MDBsetTrace
comment "Turn on/off tracing of current routine";

pattern setTrace(mod:str,fcn:str,b:bit)
address MDBsetTrace2
comment "Turn on/off trace of specific operation";

pattern setBreakpoint(fcn:str)
address MDBsetBreakpoint
comment "Turn on/off breakpoint on instruction in current operation";

pattern clearBreakpoints()
address MDBclrBreakpoints
comment "Remove all breakpoints";

pattern setTimer(b:bit):void
address MDBsetTimer
comment "Turn on/off performance timer for debugger";

@+ Decoding exceptions
The exception message produced by the modules
adhere to the structure:
<variable>:<context>:<reason>.
These components can be extracted for further analysis.
@mal
command getExceptionVariable(s:str):str
address MDBgetExceptionVariable
comment "extract the variable name from the exception message";

command getExceptionReason(s:str):str
address MDBgetExceptionReason
comment "extract the reason from the exception message";

command getExceptionContext(s:str):str
address MDBgetExceptionContext
comment "extract the context string from the exception message";

@+ Display operation code
A key tool for analysis of the MAL code is being able to dump
any routine, module. For queries, it is also illustrative to display
the flow graph. [TODO]
@mal
pattern showFunction():void 
address MDBshowFunction
comment "Dump the current routine on standard out.";
pattern showFunction(M:str,F:str):void 
address MDBshowFunction3
comment "Dump the routine M.F on standard out.";

@+ Interpreter runtime status
The prime scheme to inspect the MAL interpreter status is to use
the MAL debugger directly. However, in case of automatic exception handling
it helps to be able to obtain BAT versions of the critical information,
such as stack frame table, stack trace,
and the instruction(s) where an exception occurred.
The inspection typically occurs in the exception handling part of the
MAL block.

Beware, a large class of internal errors can not easily captured this way.
For example, bus-errors and segmentation faults lead to premature
termination of the process. Similar, creation of the post-mortum
information may fail due to an inconsistent state or insufficient resources.
@mal
pattern getStackDepth():int 
address MDBStkDepth
comment "Return the depth of the calling stack.";

pattern getStackFrame(i:int):bat[:str,:str] 
address MDBStkFrameN;
pattern getStackFrame():bat[:str,:str] 
address MDBStkFrame
comment "Collect variable binding of current (n-th) stack frame.";
pattern getStackTrace():bat[:void,:str]
address MDBStkTrace;

pattern getDefinition():bat[:void,:str] 
address MDBcodeDump
comment "Returns a string representation of the current function 
	with typing information attached";

@-
@{
@+ Implementation
@include prelude.mx
@h
#ifdef _MDB_H
#endif /* _MDB_H*/
@c
#include "gdk.h"
#include <stdarg.h>
#include <time.h>
#include "mal_resolve.h"
#include "mal_client.h"
#include "mal_exception.h"
#include "mal_debugger.h"
#include "mal_interpreter.h"

@-
The primary debugger controls
@c
#define MDBstatus(X) \
	if( stk->cmd && X==0 ) \
		stream_printf(cntxt->fdout,"#Monet Debugger off\n"); \
	else if(stk->cmd==0 && X) \
		stream_printf(cntxt->fdout,"#Monet Debugger on\n"); 

str MDBtoggle(MalBlkPtr mb, MalStkPtr stk, InstrPtr p){
    Client cntxt= getClient();
    int b=0;
    (void) mb; /* still unused */
    if( p->argc==1){
        /* Toggle */
        stk->cmd= stk->cmd? 0: 's';
        cntxt->itrace = cntxt->itrace? 0: 's';
		if(stk->cmd)
			MDBdelay =1; /* wait for real command */
        if( stk->up) stk->up->cmd=  0;
        return MAL_SUCCEED;
    }
    if( p->argc >1){
        b= *(int *) getArgReference(stk,p,1);
    } else b= stk->cmd;
	if(b)
		MDBdelay =1; /* wait for real command */
    MDBstatus(b);
    stk->cmd= b?'n':0;
    if( stk->up) stk->up->cmd=  b?'n':0;
    cntxt->itrace= b?'n':0;
    return MAL_SUCCEED;
}
str MDBtrace(MalBlkPtr mb, MalStkPtr stk, InstrPtr p){
	Client cntxt= getClient();
	cntxt->timer = GDKusec();
	stk->cmd='T';
	cntxt->itrace='T';
	(void)mb; (void) p;
	return MAL_SUCCEED;
}
str MDBsetTrace(MalBlkPtr mb, MalStkPtr stk, InstrPtr p){
    Client cntxt= getClient();
    int b;
    (void) mb; /* still unused */
    b= *(chr *) getArgReference(stk,p,1);
    MDBstatus(b);
    stk->cmd= b?'T':0;
    cntxt->itrace= b? 'T':0;
    return MAL_SUCCEED;
}
str MDBsetTrace2(MalBlkPtr mb, MalStkPtr stk, InstrPtr p){
    Client cntxt= getClient();
    bit b;
    str mod,fcn;
    Symbol s;

    (void) mb; /* still unused */
    mod= *(str *) getArgReference(stk,p,1);
    fcn= *(str *) getArgReference(stk,p,2);
    b= *(bit *) getArgReference(stk,p,3);
    s= findMALSymbol(mod,fcn);
    if( s == 0)
	return throwMessage("mdb.setTrace", "can not find operation");
    MDBstatus(b);
    stk->cmd= b?'T':0;
    cntxt->itrace= b? 'T':0;
    return MAL_SUCCEED;
}
str MDBsetTimer(MalBlkPtr mb, MalStkPtr stk, InstrPtr p){
    Client cntxt= getClient();
    int b;
    (void) mb; /* still unused */
    b= *(chr *) getArgReference(stk,p,1);
    cntxt->timer= b? GDKusec():0;
    return MAL_SUCCEED;
}
str MDBsetBreakpoint(MalBlkPtr mb, MalStkPtr stk, InstrPtr p){
    Client cntxt= getClient();
    str fcn;
    fcn= *(str *) getArgReference(stk,p,1);
    mdbSetBreakpoint(cntxt,mb,p,fcn,'s');
    return MAL_SUCCEED;
}
str MDBclrBreakpoints(MalBlkPtr mb, MalStkPtr stk, InstrPtr p){
    Client cntxt= getClient();
    str fcn;
    (void) mb;
    fcn= *(str *) getArgReference(stk,p,1);
    mdbClrBreakpointName(cntxt,fcn);
    return MAL_SUCCEED;
}

@+ Variables and stack information
The variable information can be turned into a BAT for inspection as well.
@c

static int getStkDepth( MalStkPtr s)
{
	int i = 0;
        while(s!= 0){
                i++;
                s= s->up;
        }
	return i;
}
str MDBStkDepth(MalBlkPtr mb, MalStkPtr s, InstrPtr p)
{       int *ret= (int*) getArgReference(s,p,0);
	(void)mb; /* fool compiler */
        *ret= getStkDepth(s);
        return MAL_SUCCEED;
}

str MDBgetFrame(BAT *b, MalBlkPtr mb, MalStkPtr s,int depth){
	ValPtr v;
	int i;
	char *buf=0;
	if(depth> 0) return MDBgetFrame(b,mb,s->up,depth-1);
	if( s!= 0)
	for(i=0 ; i<s->stktop ; i++,v++){
		v= &s->stk[i];
		ATOMformat(v->vtype, VALget(v), &buf);
		BUNins(b,getVarName(mb,i),buf);
	}
	return MAL_SUCCEED;
}
str MDBStkFrame(MalBlkPtr m, MalStkPtr s, InstrPtr p)
{	int *ret= (int*) getArgReference(s,p,0);
	BAT *b = BATnew(TYPE_str, TYPE_str, 256);
	if (b == 0) return throwMessage("inspect.stkFrame", "failed to create BAT");
	@:Pseudo(view,stk,frame)@
	return MDBgetFrame(b,m,s,0);
}
str MDBStkFrameN(MalBlkPtr m, MalStkPtr s, InstrPtr p)
{	int n, *ret= (int*) getArgReference(s,p,0);
	BAT *b = BATnew(TYPE_str, TYPE_str, 256);

	n= *(int*) getArgReference(s,p,1);
	if(n<0) return throwMessage("inspect.stkFrame", "illegal depth.");
	if(n>=getStkDepth(s)) return throwMessage("inspect.stkFrame", "illegal depth.");
	@:Pseudo(view,stk,frame)@
	return MDBgetFrame(b,m,s,n);
}
str MDBStkTrace(MalBlkPtr m, MalStkPtr s, InstrPtr p)
{	BAT *b = BATnew(TYPE_int, TYPE_str, 256);
	str msg;
	int *ret= (int*) getArgReference(s,p,0);
	int k=0;

	msg= call2str(s->blk, s, getPC(m,p), 1);
	BUNins(b,&k, msg);
	GDKfree(msg);
	for(s=s->up,k++; s!= NULL; s= s->up, k++){
		msg= call2str(s->blk, s, s->pcup, 1);
		BUNins(b,&k, msg);
		GDKfree(msg);
	}
	@:Pseudo(view,stk,trace)@
	return MAL_SUCCEED;
}
@+ Display routines
@c
str MDBshowFunction(MalBlkPtr mb, MalStkPtr stk, InstrPtr p){
	Client c= getClient();
	(void) p; (void) stk;
	printFunction(c->fdout,mb,LIST_INPUT);
	return MAL_SUCCEED;
}
str MDBshowFunction3(MalBlkPtr mb, MalStkPtr stk, InstrPtr p){
	str     modnme= (str) getArgValue(stk,p,1);
	str     fcnnme= (str) getArgValue(stk,p,2);
	Symbol s= NULL;
	Client c= getClient();

	s= findMALSymbol(modnme,fcnnme);
	if( s == NULL)
		GDKerror("@1:Could not find %s.%s\n",modnme,fcnnme);
	else 
		printFunction(c->fdout,s->def,LIST_INPUT);
	(void) mb; /* fool compiler */
	return NULL;
}
@-
It is illustrative to dump the code when you
have encountered an error.
@c
str MDBcodeDump(MalBlkPtr m, MalStkPtr stk, InstrPtr p)
{	int i, *ret= (int*)getArgReference(stk,p,0);
	str ps;
	BAT *b = BATnew(TYPE_int, TYPE_str, 256);
        if(b == 0) return throwMessage("inspect.codeDump", "failed to create BAT");
	
	for(i=0;i<m->stop;i++){
		ps= instruction2str(m, getInstrPtr(m,i),1);
		BUNins(b,&i,ps);
		GDKfree(ps);
	}
	@:Pseudo(view,fcn,stmt)@
	return MAL_SUCCEED;
}

str MDBgetExceptionVariable(str *ret,  str *msg){
	str tail;
	tail = strchr(*msg,':');
	if( tail == 0)
		return throwMessage("inspect.getExceptionVariable",
			"Could not find it\n");
		
	*tail = 0;
	*ret= GDKstrdup(*msg);
	*tail = ':';
	return MAL_SUCCEED;
}
str MDBgetExceptionContext(str *ret,  str *msg){
	str tail, tail2;
	tail = strchr(*msg,':');
	if( tail == 0)
		return throwMessage("inspect.getExceptionContext",
			"Could not find it\n");
	tail2 = strchr(tail+1,':');
	if( tail2 == 0)
		return throwMessage("inspect.getExceptionContext",
			"Could not find it\n");
		
	*tail2 = 0;
	*ret= GDKstrdup(tail+1);
	*tail2 = ':';
	return MAL_SUCCEED;
}
str MDBgetExceptionReason(str *ret,  str *msg){
	str tail;
	tail = strchr(*msg,':');
	if( tail == 0)
		return throwMessage("inspect.getExceptionReason",
			"Could not find it\n");
	tail = strchr(tail+1,':');
	if( tail == 0)
		return throwMessage("inspect.getExceptionReason",
			"Could not find it\n");
		
	*ret= GDKstrdup(tail+1);
	return MAL_SUCCEED;
}

@}
