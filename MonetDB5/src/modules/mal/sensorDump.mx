@-
The remainder contains a small program to simulate a sensor
using a  program that reads a file and sends them over to the server 
at a particular port
@f sensorDump
@c
#include <stdio.h>
#include <stdlib.h>

#ifdef HAVE_UNISTD_H
# include <unistd.h>
#endif
#include  <stdio.h>
#ifdef HAVE_PWD_H
#include  <pwd.h>
#endif
#include  <sys/types.h>

#ifdef HAVE_SYS_SOCKET_H
# include <sys/socket.h>
#endif
#ifdef NATIVE_WIN32
# include <winsock.h>
#endif
#ifdef HAVE_SYS_UN_H
#include <sys/un.h>
#endif

#include  <signal.h>
#include  <string.h>
#include  <memory.h>

#if TIME_WITH_SYS_TIME
# include <sys/time.h>
# include <time.h>
#else
# if HAVE_SYS_TIME_H
#  include <sys/time.h>
# else
#  include <time.h>
# endif
#endif

#include <stream.h>     /* for stream */

#define MAX 1024

FILE *fd;

stream *toServer;

char *connect_to_server(char * hostname, int port)
{
	struct sockaddr_in server;

#ifdef HAVE_SYS_UN_H
	/* struct sockaddr_un userver;*/
#endif
	struct sockaddr *serv;
	size_t servsize;
	int s;

#ifdef HAVE_SYS_UN_H
	/* if (
		   hostname && hostname[0] == '/') {
		if (strlen(hostname) >= sizeof(userver.sun_path)) {
			return "path name too long";
		}
		userver.sun_family = AF_UNIX;
		strncpy(userver.sun_path, hostname, sizeof(userver.sun_path));
		serv = (struct sockaddr *) &userver;
		servsize = sizeof(userver);
	} else
	*/
#endif
	{
		struct hostent *hp;

		hp = gethostbyname(hostname);
		if (hp == NULL) {
			return "gethostbyname failed";
		}
		memset(&server, 0, sizeof(server));
		memcpy(&server.sin_addr, hp->h_addr, hp->h_length);
		server.sin_family = hp->h_addrtype;
		server.sin_port = htons((unsigned short) (port & 0xFFFF));
		serv = (struct sockaddr *) &server;
		servsize = sizeof(server);
	}

	s = socket(serv->sa_family, SOCK_STREAM, IPPROTO_TCP);
	if (s < 0) {
		return "Open socket failed";
	}

	if (connect(s, serv, servsize) < 0) {
#ifdef NATIVE_WIN32
		fprintf(stderr, "!ERROR reconnect: connect: error %d\n", WSAGetLastError());
#else
		perror("!ERROR reconnect: connect");
#endif
		return "Setup connection failed";
	}
	toServer = socket_wastream(s, "sensorDump write");
	if ((toServer) == NULL || stream_errnr(toServer)) {           \
		return "stream closed";
	}

	return NULL;
}

int main(int argc, char **argv){
	int i;
	char *err;
	char *host= "localhost"; int port=0;
	char *fname= "";
	int delay = -1;
	char buf[MAX];

	for(i=1;i<argc; i++)
	switch( argv[i][1]){
	case 'h':
		host= argv[++i];
		break;
	case 'p':
		port= strtol(argv[++i], 0,0);
		break;
	case 'd':
		delay= strtol(argv[++i], 0,0);
		break;
	case 'f':
		fname= argv[++i];
		break;
	default:
		printf("Unknown option %s\n",argv[i]);
		return -1;
	}
	printf("sensorDump -h %s -p %d -f %s -d %d\n", host,port, fname,delay);
	if( (err= connect_to_server(host,port)) ){
		printf("FATAL:%s\n",err);
		return -1;
	}
	fd= fopen(fname,"r");
	if( fd== NULL){
		printf("Could not open file '%s'\n",fname);
		return -1;
	}

	/* set up stream towards server */

	/* deposit events */
	while(fgets(buf,MAX,fd) != 0){
		printf("%s",buf);
		if( delay <0){
			printf("send it?");
			getchar();
		}
		stream_write(toServer,buf,1, strlen(buf));
		stream_flush(toServer);
	}
}
