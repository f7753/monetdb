@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@' 
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@' 
@' The Original Code is the Monet Database System.
@' 
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2004 CWI.
@' All Rights Reserved.

@f sqlcache
@v 0.0
@a M.L.Kersten, N.Nes
@+ SQL cache
The SQL cache module provides the primitives to
keep pre-compiled SQL queries around. 
The cache can be filled using a MAL structure
of the following form:
@T
\begin{verbatim}
function qry001(A1:int):int
comment "select * from t where a> ?";
   ... mal ...
end qry001;
\end{verbatim}

Unlike the other modules, it is permissible to
remove elements from this cache at runtime.
@mal
module sqlcache;

command remove(nme:str):void
address SQLCacheRemove
comment "Locate the cached function and remove it";

command exists(nme:str):bit
address SQLCacheExists
comment "Locate a cached SQL function";

command getDefinition(nme:str):bat[:int,:str]
address SQLCacheGetDefinition
comment"Retrieve the SQL statement for a 
	cache operation";
@-
@{

@+ BAT Iterator Implementation
Part of the code is copied from the V 4.3 bat.mx file.
@= getBATdescriptor
if( *@2 < 0) {
	/* reverse descriptor should be explicitly loaded */
	@3=BATdescriptor(*@2); BBPunfix(*@2);
} else @3= (BAT*) BBPgetdesc(*@2);
if( @3 == NULL) { *@1 = 0;
	return throwMessage("chopper.@4", 
		"cannot access descriptor @2");
}
@-
@c
#include "mal.h"
#include "mal_interpreter.h"
#include "inspect.h"

str SQLCacheExists(bit *res, str *nme){
	Scope scope;
	Symbol s;

	scope= findScope(mal_scope,"sqlcache");
	if( scope == NULL)
		return throwMessage("sqlcache.exists",
			"internal error, sqlcache missing\n");
	s= findSymbolInScope(scope,*nme);
	*res = s != NULL;
	return MAL_SUCCEED;
}
str SQLCacheGetDefinition(int *ret, str *nme){
	Symbol s;
	BAT *b = BATnew(TYPE_int, TYPE_str, 256);
        if(b == 0) 
	return throwMessage("sqlcache.getDefinition", "failed to create BAT");
	
	s= findSymbol("sqlcache",*nme);
	if(s){
		int i;
		str ps;
		for(i=0;i<s->def->stop;i++){
			ps= instruction2str(s->def, getInstrPtr(s->def,i),0);
			BUNins(b,&i,ps+1);
			GDKfree(ps);
		}
	}
        BATmode(b,TRANSIENT);
        BATfakeCommit(b);
        *ret = b->batCacheid;
	return MAL_SUCCEED;
}
str SQLCacheRemove(int *ret, str *nme){
	Scope scope;
	Symbol s;

	(void) ret;
	scope= findScope(mal_scope,"sqlcache");
	if( scope == NULL)
		return throwMessage("sqlcache.remove",
			"internal error, sqlcache missing\n");
	s= findSymbolInScope(scope,*nme);
	if( s == NULL)
		return throwMessage("sqlcache.remove",
			"internal error, sqlcache entry missing\n");
	deleteSymbol(scope,s);
	return MAL_SUCCEED;
}
