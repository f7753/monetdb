@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2003 CWI.
@' All Rights Reserved.
@'
@' Contributor(s):
@'              Martin Kersten <Martin.Kersten@cwi.nl>
@'              Peter Boncz <Peter.Boncz@cwi.nl>
@'              Niels Nes <Niels.Nes@cwi.nl>
@'              Stefan Manegold  <Stefan.Manegold@cwi.nl>

@f mal
@t MAL extensions
@a Martin Kersten
@v 0.1
@* MAL extensions
This module contains enhances to the MAL interpreter layer, such as
iterators over ranges and bats, object management, access to the debugger, ....
This module is loaded directly after the kernel modules and provides
a first abstraction layer. 

Note that the modules located in the kernel directory should not
rely on the MAL datastructures. That's why we have to deal with
some bat operations here.

@mal
# The routines below are linked with the kernel by default

module mal;

command getScenario():str = CMDgetScenario
comment "Retrieve current scenario name";

command setScenario(msg:str):str = CMDsetScenario
comment "Switch to other scenario handler, return previous one";

command raise(msg:str) :str = CMDraise
comment "Raise an exception labelled with a specific message.";

@+ Iterator primitives
Iterators enumerate elements in a collection defined by a few paramaters,
e.g. a lower/upper bound, or a bat. An iterator is initialized in the first
call by recognizing that the control variable lies outside the intended
collection.

@mal

command nextElement(i:flt, first:flt, last:flt, step:flt):bit = fltForloopStep; 
command nextElement(i:dbl, first:dbl, last:dbl, step:dbl):bit = dblForloopStep; 
command nextElement(i:chr, first:chr, last:chr, step:chr):bit = chrForloopStep; 
command nextElement(i:sht, first:sht, last:sht, step:sht):bit = shtForloopStep; 
command nextElement(i:lng, first:lng, last:lng, step:lng):bit = lngForloopStep; 
command nextElement(i:int, first:int, last:int, step:int):bit = intForloopStep
comment "This routine provides an iterator over a scalar domain.
         The step size is dependent on the underlying type."; 

command nextElement(i:chr, first:chr, last:chr):bit = chrForloop; 
command nextElement(i:sht, first:sht, last:sht):bit = shtForloop; 
command nextElement(i:lng, first:lng, last:lng):bit = lngForloop; 
command nextElement(i:int, first:int, last:int):bit = intForloop
comment "This routine provides an iterator over a scalar domain.
         A default, type-specific step size is assumed."; 


@- Monet help system
All procedural abstractions may contain a string with commentary text.
This information is retained in the symbol table for subsequent use.
Often, it is more appropriate to extract the comments into a BAT
for subsequent analysis.
@mal
command help(k:str):bat[str,str] = CMDhelp
comment "Search the commentary strings for one matching the keyword";

command helpComment(mod:str):bat[str,str] = CMDhelpComment
comment "Collect the commentaries for all routines in a given module";
command helpComment(mod:str,fcn:str):bat[int,str] = CMDhelpComment2
comment "Obtain the comments for a given function";
@- Monet Manual construction
The manual operations ease offline inspection of the all the Monet function.
It purposely generates an XML organized file, because we expect external
tools to massage it further for presentation. The envisioned 
tagging structure becomes
@T
\begin{verbatim}
<manual>
  <module>
    <command name=... signature=... binding=...>
       <comment>
       </comment>
    </command>
    <pattern name=... signature=... binding=...>
       <comment>
       </comment>
    </command>
    <function name=... signature=... >
       <comment>
       </comment>
       <body>
       </body>
    </command>
  </module>
</manual>
\end{verbatim}
@-
@mal
command manual(file:str,mod:str)= CMDmanual2
comment "Generate a synopsis of a module";
command manual(file:str,mod:str,recursive:int)= CMDmanual
comment "Generate a synopsis of a module";
command manual(mod:str)= CMDmanual1
comment "Generate a synopsis of a module";
command manual()= CMDmanual0
comment "Produces a XML-formatted manual over all modules loaded.";

@+ MAL inspection
The command below inspect the MAL administration and, therefore,
can not be included in the kernel library.
@mal
pattern getType(v:any) : int = CMDtype
comment "Return the type of a value (expression). Returns an type number.";

command typename(v:int): str = CMDtypename;

@- Monet module code

The time module provides a few abstractions that rely on
knowledge of basic operators such as /(int,int), which
are not known upon load time.
@mal
function timestamp(secs:lng):timestamp
comment "Enhancement of timestamp atom definition";
        d1:=epoch();
        d2:= secs *1000:lng;
        d3:= d1+d2;
	d4:= timestamp(d3);
        return d4;
end timestamp;
function epoch():timestamp
comment "Enhancement of timestamp atom definition";
        d0:= date(1970,1,1);
        d1:=daytime(0,0,0,0);
        d2:=tzone("GMT");
        d4:=timestamp(d0,d1,d2);
	return d4;
end epoch;
#inline
function epoch(t:timestamp):lng
comment "Enhancement of timestamp atom definition";
        e := epoch();
        t0:= lng(t);
        e0:= lng(e);
        d0:= t0/e0;
        d1:= t0/1000:lng;
        return d1;
end epoch;
# rule creation synonyms
function ruleDef(m:int,d:int,w:int,h:int,min:int):rule;
        d0:= h*60;
        d1:= d0+min;
        r:= rule(m,d,w,d1);
        return r;
end ruleDef;
function ruleDef(m:int,d:str,w:int,h:int,min:int):rule;
        dy:= daynum(d);
        d0:= h*60:int;
        d1:= d0+min;
        r:= rule(m,dy,w,d1);
        return r;
end ruleDef;
function ruleDef(m:int,d:str,w:int,min:int):rule;
        dy:= daynum(d);
        r:= rule(m,dy,w,min);
        return r;
end ruleDef;

@-
Some compiled old module load stuff from decimal:
@mal
function divide(b:bat[any::1,decimal], div:decimal, prec:int):bat[any::1,decimal]
comment "Perform the divide operation over a bat of decimals";
#proc divide(bat[any::1,decimal] b, decimal div, int prec) : bat[any::1,decimal] {
	DECIMAL_ZERO:= decimal(0);
	aa_a := =(div,DECIMAL_ZERO);
	ba:= int(div);
	ba_a := isnil(ba);
	ca_a := isnil(prec);
	da_a := or(ba_a,ca_a);
barrier	ea_a:= or(aa_a,da_a);
#        if ((div = DECIMAL_ZERO) or isnil(div) or isnil(prec)) {
	DECIMAL_NIL:= decimal(nil);
	fa_a := project(b,DECIMAL_NIL);
	return fa_a;
#                return project(b, DECIMAL_NIL);
exit	ea_a;
barrier	ga_a:= not(ea_a);
barrier	ha_a:= istenfold(div);
#        } else if (istenfold(div)) {
	ia_a := getprecision(div);
	ja_a := getscale(div);
	ka_a := +(ia_a,ja_a);
	dec:= -(1,ka_a);
#                var dec := 1 - (getprecision(div) + getscale(div));
	la_a := multiplex.tactics("addscale",b,dec);
	ma_a := multiplex.tactics("setprecision",la_a,prec);
	return ma_a;
#                return [setprecision]([addscale](b,dec),prec);
#        }
exit	ha_a;
exit	ga_a;
	na_a := bulkdivide(b,div,prec);
	return na_a;
#        return bulkdivide(b, div, prec); 
end divide;
#    }
# 
function divide(b:bat[any::1,decimal], div:decimal):bat[any::1,decimal];
#    proc divide(bat[any::1,decimal] b, decimal div) : bat[any::1,decimal] {
	DECIMAL_ZERO:= decimal(0);
	oa_a := =(div,DECIMAL_ZERO);
	pa_a := isnil(div);
barrier	qa_a:= or(oa_a,pa_a);
#        if ((div = DECIMAL_ZERO) or isnil(div)) {
	DECIMAL_NIL:= decimal(nil);
	ra_a := project(b,DECIMAL_NIL);
	return ra_a;
#                return project(b, DECIMAL_NIL);
exit	qa_a;
barrier	sa_a:= not(qa_a);
barrier	ta_a:= istenfold(div);
#        } else if (istenfold(div)) {
	ua_a := getprecision(div);
	va_a := getscale(div);
	wa_a := +(ua_a,va_a);
	dec:= -(1,wa_a);
#                var dec := 1 - (getprecision(div) + getscale(div));
	xa_a := multiplex.tactics("addscale",b,dec);
	ya_a := multiplex.tactics("setscale",xa_a,0);
	return ya_a;
#                return [setscale]([addscale](b,dec),0);
#        } 
exit	ta_a;
exit	sa_a;
	ab_a := bulkdivide(b,div);
	return ab_a;
#        return bulkdivide(b, div);
end divide;
#    }
#

@+ Session control
Redirected script evaluations.
@mal
pattern eval(s:str):void= CMDevalString
	comment "Evaluate a string representing a MAL program";
pattern source(f:str):void= CMDevalFile
	comment "Load and executed a (local) file";
@+ Dummy code 
@h
#ifndef _ITERATOR_H
#define _ITERATOR_H
#endif /* _ITERATOR_H*/
@-
@= Pseudo
        if (BBPindex("view_@1_@2") <= 0)
                BATname(b, "@2");
        BATroles(b,"@1","@2");
        BATmode(b,TRANSIENT);
        BATfakeCommit(b);
        *ret = b->batCacheid;

@c
#include <stdarg.h>
#include <time.h>
#include "gdk.h"
#include "mal.h"
#include "mal_session.h"
#include "mal_resolve.h"
#include "mal_client.h"
#include "mal_function.h"

@+ BAT declarations
@c
str CMDgetScenario(str *ret){
	Client c = getClient();
	if( c->scenario) *ret = GDKstrdup(c->scenario);
	else *ret= GDKstrdup("nil");
	return MAL_SUCCEED;
}
str CMDsetScenario(str *ret,str *nme){
	Client c = getClient();
	str msg= MAL_SUCCEED;

	msg= setScenario(c,*nme);
	*ret = 0;
	if( msg== NULL) *ret= GDKstrdup(c->scenario);
	return msg;
}
@+ Exception implementation
@c
str CMDraise(str *ret,  str *msg){
	*ret= GDKstrdup(*msg);
	return GDKstrdup(*msg);
}
@+ Printing
The print commands are implemented as single instruction rules,
because they need access to the calling context.
At a later stage we can look into the issues related to
parsing the format string as part of the initialization phase.
The old method in V4 essentially causes a lot of overhead
because you have to prepare for the worst (e.g. mismatch format
identifier and argument value)
@c
str CMDprint_val(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int tpe = getArgType(mb,pci,1);
	ptr val = (ptr) getArgReference(stk,pci,1);
        stream *fp = GDKout;
	if( val==NULL) {
		ATOMprint(TYPE_str, "nil", GDKout);
		return MAL_SUCCEED;
	}
	if( isaBatType(tpe)){
		BAT *b = BATdescriptor(*(int*)val);
		if( b== NULL) {
			return throwMessage("mal.print","descriptor access failed");
		}
		/* BATprint(b);*/
		BATmultiprintf(GDKout,2,&b,TRUE,0);
		return MAL_SUCCEED;
	}
        stream_printf(fp,"[ ");
	if( tpe == TYPE_str)
		ATOMprint(tpe, *(str*)val, fp);
        else  	ATOMprint(tpe, val, fp);
        stream_printf(fp," ]\n");
	fp->flush(fp);
        return MAL_SUCCEED;
}
str CMDprint_ft(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int tpe = getArgType(mb,pci,1);
	ptr val = (ptr) getArgReference(stk,pci,1);
	if( val==NULL) {
		ATOMprint(TYPE_str, "nil", GDKout);
		return MAL_SUCCEED;
	}
	if( tpe == TYPE_str)
		ATOMprint(TYPE_str, *(str*)val, GDKout);
	else ATOMprint(tpe, val, GDKout);
	GDKout->flush(GDKout);
	return MAL_SUCCEED;
}

str CMDotable( MalBlkPtr mb, MalStkPtr stk, InstrPtr pci, int o, int flg){
        BAT *piv[MAXPARAMS],*b;
        int nbats = 0;
	int tpe,i=1,order=0;
	ptr val;

	if(o){
		order = *(int*) getArgReference(stk,pci,1);
		i++;
	}
	for(; i< pci->argc;i++) {
		tpe = getArgType(mb,pci,i);
		val = (ptr) getArgReference(stk,pci,i);
		if( !isaBatType(tpe)) 
			return throwMessage("mal.otable"," BAT expected");
		b= BATdescriptor(*(int*)val);
		if(b == NULL) return throwMessage("mal.otable","GDKerror");
                piv[nbats++] = b;
        } 
        BATmultiprintf(GDKout, nbats, piv, flg, order);
	GDKout->flush(GDKout);
        return MAL_SUCCEED;
}

str CMDprint_otable( MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	CMDotable(mb,stk,pci,1,TRUE);
        return MAL_SUCCEED;
}

str CMDprint_table( MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	CMDotable(mb,stk,pci,0,FALSE);
        return MAL_SUCCEED;
}

str CMDprint_table_default( MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
        BAT *piv[MAXPARAMS],*b;
        int nbats = 0;
	int tpe,i;
	ptr val;

	for(i=pci->retc; i< pci->argc;i++) {
		tpe = getArgType(mb,pci,i);
		val = (ptr) getArgReference(stk,pci,i);
		if( !isaBatType(tpe)) 
			return throwMessage("mal.print_table_default","BAT expected");
		b= BATdescriptor(*(int*)val);
		if(b == NULL) return throwMessage("mal.print_table_default","GDKerror");
                piv[nbats++] = b;
        } 
        BATmultiprintf(GDKout, i-1, piv, FALSE, 0);
	GDKout->flush(GDKout);
        return MAL_SUCCEED;
}
@- Input redirectionrs
@c
str CMDevalString(MalBlkPtr mb, MalStkPtr stk, InstrPtr p){
	str s;
	Client c= getClient();
	str src;
	str buf=0;
	int len =0;

	s= (str) getArgValue(stk,p,1);
	if(strlen(s)==0) return MAL_SUCCEED;
	src= (str) GDKmalloc(len=strlen(s)+3);
	/* GDK_atom routine requires enclosing quotes */
	strcpy(src,"\"");
	strcat(src,s);
	strcat(src,"\"");
	strFromStr( src, &len, &buf);

	stream_printf(GDKout,"Eval:%s\n",buf);
	evalString(getClient(),buf,FALSE,stk);
	GDKfree(src);
	GDKfree(buf);
	return MAL_SUCCEED;
}
str CMDevalFile(MalBlkPtr mb, MalStkPtr stk, InstrPtr p){
	str s;
	FILE *fd;
	Client c= getClient();
	char buffer[1024];

	s= (str) getArgValue(stk,p,1);
	if( strlen(s)+strlen(c->cwd)+2>=1024){
		return throwMessage("mal.setCwd","Evaluation buffer too small\n");
	}
	buffer[0]=0;
	if( *s != '/'){
		strcpy(buffer,c->cwd);
		strcat(buffer,"/");
	}
	strcat(buffer,s);
	stream_printf(GDKout,"run:%s\n",buffer);
	malImport(getClient(),buffer,0,FALSE);
	return MAL_SUCCEED;
}
str CMDdebug(int *ret, int *flg){
	*ret = GDKdebug;
	if( *flg) GDKdebug = *flg;
	return MAL_SUCCEED;
}
str CMDmanual(int *ret, str *fname, str *mod,int *recursive){
	stream *fs;
	fs= open_wastream(*fname);
	if( fs== NULL) return throwMessage("mal.manual","Could not open file\n");
	dumpManualHeader(fs);
	dumpManual(fs, findScope(getClient()->nspace,*mod),*recursive);
	dumpManualFooter(fs);
	return MAL_SUCCEED;
}
str CMDmanual2(int *ret, str *fname, str *mod,int *recursive){
	int r= 0;
	return CMDmanual(ret,fname,mod,&r);
}
str CMDmanual1(int *ret, str *mod){
	dumpManualHeader(GDKout);
	dumpManual(GDKout, findScope(getClient()->nspace,*mod),0);
	dumpManualFooter(GDKout);
	return MAL_SUCCEED;
}
str CMDmanual0(int *ret){
	dumpManualHeader(GDKout);
	dumpManual(GDKout, getClient()->nspace,1);
	dumpManualFooter(GDKout);
	return MAL_SUCCEED;
}
str CMDsetCwd(str *ret, str *fnme){
	Client c= getClient();
	*ret = c->cwd;
	c->cwd= GDKstrdup(*fnme);
	return MAL_SUCCEED;
}
str CMDhelp(int *ret, str *mod) 
{	Client cntxt= getClient();
	Scope m;
	Symbol s;
	str msg;
	int i;
	BAT *b = BATnew(TYPE_str, TYPE_str, 256);
        if (b == 0) return throwMessage("catalog.help", "failed to create BAT");
        return throwMessage("catalog.help", "Search by keyword not yet available");

	m= findScope(cntxt->nspace,*mod);
	if(m)
	for(i=0;i<256;i++){
		s= m->subscope[i];
		while(s!= NULL){
			msg= s->def->help;
			if( msg){
				BUNins(b,s->name,msg);
			}
			s= s->peer;
		}
	}
	@:Pseudo(help,Comment)@
	return MAL_SUCCEED;
}
str CMDhelpComment(int *ret, str *mod) 
{	Client cntxt= getClient();
	Scope m;
	Symbol s;
	str msg;
	int i;

	BAT *b = BATnew(TYPE_str, TYPE_str, 256);
        if (b == 0) return throwMessage("catalog.helpComment", "failed to create BAT");

	m= findScope(cntxt->nspace,*mod);
	if(m)
	for(i=0;i<256;i++){
		s= m->subscope[i];
		while(s!= NULL){
			msg= s->def->help;
			if(msg== NULL) msg= str_nil;
			BUNins(b,s->name,msg);
			s= s->peer;
		}
	}
	@:Pseudo(help,Comment)@
	return MAL_SUCCEED;
}
str CMDhelpComment2(int *ret, str *mod, str *fcn) 
{	Symbol s;
	str msg;

	BAT *b = BATnew(TYPE_str, TYPE_str, 256);
        if (b == 0) return throwMessage("catalog.helpComment", "failed to create BAT");

	s= findSymbol(*mod,*fcn);
	while(s!= NULL){
		if(idcmp(s->name,*fcn)==0){
			msg= s->def->help;
			if(msg== NULL) msg= str_nil;
			BUNins(b,s->name,msg);
		}
		s= s->peer;
	}
	@:Pseudo(help,Comment)@
	return MAL_SUCCEED;
}

str CMDtypename(str *ret, int *tpe){
        *ret = malTypeName(*tpe);
        return MAL_SUCCEED;
}
str CMDtype(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
        int *ret;
        ret= (int*) getArgReference(stk,pci,0);
        *ret= getArgType(mb,pci,1);
        return MAL_SUCCEED;
}

