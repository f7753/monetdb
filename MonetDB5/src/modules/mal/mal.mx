@f mal
@t MAL extensions
@a Martin Kersten
@v 0.1
@* MAL extensions
This module contains enhances to the MAL interpreter layer, such as
iterators over ranges and bats, object management, access to the debugger, ....
This module is loaded directly after the kernel modules and provides
a first abstraction layer. 

Note that the modules located in the kernel directory should not
rely on the MAL datastructures.

@+ BAT declarations
A pattern block may be required to make the proper translation to
the BAT library.
@mal
# The routines below are linked with the kernel by default

module mal;

command raise(msg:str) :str = CMDraise
comment "Raise an exception labelled with a specific message.";


pattern bat(ht:any::1, tt:any::2) : bat[any::1,any::2] = CMDBATnew
comment "Creates a new empty transient BAT, with head- and tail-types as indicated.";

pattern new(ht:any::1, tt:any::2) : bat[any::1,any::2] = CMDBATnew
comment "Creates a new empty transient BAT, with head- and tail-types as indicated.";

pattern new(ht:any::1, tt:any::2, size:int) : bat[any::1,any::2] = CMDBATnew
comment "Creates a new empty BAT, directly allocating for 'size' elements.";

pattern new(ht:any::1, tt:any::2, size:lng) : bat[any::1,any::2] = CMDBATnew
comment "Creates a new empty BAT, directly allocating for 'size' elements.";

pattern bat(ht:any::1, tt:any::2, size:int) : bat[any::1,any::2] = CMDBATnew
comment "Creates a new empty BAT, directly allocating for 'size' elements.";

@+ Algebraic operators
Those that rely on knowledge of the runtime environment
@mal
command project(b:bat[any::1,any]):bat[any::1,void]= CMDprojectNil
comment "Extract the head of a BAT.";
pattern project( b:bat[any::1,any], val:any::2) :
			bat[any::1, any::2] = CMDproject
comment "Fill the tail column with a constant value.";

@+ Calculation
Coercion of values at the MAL level is supported by the cast
operation.
@mal
command cast(v:any, w:str):str= CMDcast_str
comment "Cast a value to another built-in type.";
command cast(v:any, w:int):int= CMDcast;
command cast(v:any, w:lng):lng= CMDcast;
command cast(v:any, w:sht):sht= CMDcast;
command cast(v:any, w:flt):flt= CMDcast;
command cast(v:any, w:dbl):dbl= CMDcast;
command cast(v:any, w:chr):chr= CMDcast;
command cast(v:any, w:oid):oid= CMDcast;
command cast(v:any, w:bit):bit= CMDcast;
@+ Iterator primitives
This module contains the framework for the construction of iterators.
Iterators enumerate elements in a collection defined by a few paramaters,
e.g. a lower/upper bound, or a bat. An iterator is initialized in the first
call by recognizing that the control variable lies outside the intended
collection.

@mal

command nextElement(i:flt, first:flt, last:flt, step:flt):bit = fltForloopStep; 
command nextElement(i:dbl, first:dbl, last:dbl, step:dbl):bit = dblForloopStep; 
command nextElement(i:chr, first:chr, last:chr, step:chr):bit = chrForloopStep; 
command nextElement(i:sht, first:sht, last:sht, step:sht):bit = shtForloopStep; 
command nextElement(i:lng, first:lng, last:lng, step:lng):bit = lngForloopStep; 
command nextElement(i:int, first:int, last:int, step:int):bit = intForloopStep; 

command nextElement(i:chr, first:chr, last:chr):bit = chrForloop; 
command nextElement(i:sht, first:sht, last:sht):bit = shtForloop; 
command nextElement(i:lng, first:lng, last:lng):bit = lngForloop; 
command nextElement(i:int, first:int, last:int):bit = intForloop; 

@+ BAT iterator
A BATloop iterator uses an integer cursor to keep track of its
position in the underlying table. 
The head and tail elements can be obtained using the getHead and 
getTail functions, which are to be defined for all atomary types.

@mal
command batloop(i:lng,b:bat[any,any]):bit = CMDnextElement_lng
comment "Iterate over the elements of a BAT using a cursor.";

pattern batloop(i:lng,b:bat[any::1,any::2],h:any::1,t:any::2):bit 
	= CMDnextElement
comment "Iterate over the elements of a BAT using a cursor.";

pattern bunStream(b:bat[any::1,any::2],h:any::1,t:any::2):lng
	 = CMDbunStream
comment "Produce a stream of buns for subsequent processing.";

pattern batStream(b:bat[any,any],size:lng,v:bat[any::1,any::2]):lng
        = CMDbatstream
comment "Produce a stream of buns for subsequent processing. Each
of a given fixed size. equivalent to batstream(b,v,slice,1)";

pattern batStream(b:bat[any,any],v:bat[any::1,any::2],size:lng,step:lng):lng
        = CMDbatstream
comment "Produce a stream of buns for subsequent processing. Each
of a given fixed size";

command batSlice(i:int,b:bat[any,any],low:int,high:int):bit = CMDnextSlice
comment "Iterator over all BUNs of b.slice(low,high)";

command hashloop(i:int, p:ptr, b:bat[any,any]):bit = CMDhashloop
comment "Iterate over the elements of a BAT using its hash index.
Each call we set 'i' to denote the next element";
@-
The head and tail values can be extracted using the cursor,
but is often more effective due to overhead involved in
location of the underlying BAT.
The generic solutions are also provided as patterns, because this
trims the number of function signatures in the symbol table.
@mal
pattern getHead(b:bat[any::1,any],i:lng):any::1 = CMDgetHead
comment "return the BUN head value using the cursor.";

pattern getTail(b:bat[any,any::1],i:lng):any::1 = CMDgetTail
comment "return the BUN tail value using the cursor.";

@-
@+ The Monet Debugger interface
To enable ease of debugging and performance monitoring, the MAL interpreter
comes with a hardwired gdb-like text-based debugger.
@mal
pattern mdb(c:chr):void = mdbSetCmd
	comment "Start debugger with command 'c'";
pattern mdb(b:bit):void = mdbToggle
	comment "Start interactive debugger";
pattern mdb():void = mdbToggle
	comment "Start interactive debugger";

command debugmask(i:int):int= CMDdebug
"Return the debug mask. If a MASK is nonzero, set it to that value.";
@+ MAL inspection
The command below inspect the MAL administration and, therefore,
can not be included in the kernel library.
@mal
pattern getType(v:any) : int = CMDtype
comment "Return the type of a value (expression). Returns an type number.";

command typename(v:int): str = CMDtypename;

@- Monet module code

The time module provides a few abstractions that rely on
knowledge of basic operators such as /(int,int), which
are not known upon load time.
@mal
function timestamp(secs:lng):timestamp;
        d1:=epoch();
        d2:= secs *1000:lng;
        d3:= d1+d2;
        return d3;
end timestamp;
function epoch():timestamp
        comment "unix-time (epoch) support: seconds since 1-jan-1970 GMT";
        d0:= date(1970,1,1);
        d1:=daytime(0,0,0,0);
        d2:=tzone("GMT");
        d4:=timestamp(d0,d1,d2);
end epoch;
#inline
function epoch(t:timestamp):lng;
        e := epoch();
        t0:= lng(t);
        e0:= lng(e);
        d0:= t0/e0;
        d1:= t0/1000:lng;
        return d1;
end epoch;
# rule creation synonyms
function rule(m:int,d:int,w:int,h:int,min:int):rule;
        d0:= h*60;
        d1:= d0+min;
        r:= rule(m,d,w,d1);
        return r;
end rule;
function rule(m:int,d:str,w:int,h:int,min:int):rule;
        dy:= daynum(d);
        d0:= h*60:int;
        d1:= d0+min;
        r:= rule(m,dy,w,d1);
        return r;
end rule;
function rule(m:int,d:str,w:int,min:int):rule;
        dy:= daynum(d);
        r:= rule(m,dy,w,min);
        return r;
end rule;

@-
Some compiled old module load stuff from decimal:
@mal
function divide(b:bat[any::1,decimal], div:decimal, prec:int):bat[any::1,decimal];
#proc divide(bat[any::1,decimal] b, decimal div, int prec) : bat[any::1,decimal] {
	DECIMAL_ZERO:= decimal(0);
	aa_a := =(div,DECIMAL_ZERO);
	ba:= int(div);
	ba_a := isnil(ba);
	ca_a := isnil(prec);
	da_a := or(ba_a,ca_a);
barrier	ea_a:= or(aa_a,da_a);
#        if ((div = DECIMAL_ZERO) or isnil(div) or isnil(prec)) {
	DECIMAL_NIL:= decimal(nil);
	fa_a := project(b,DECIMAL_NIL);
	return fa_a;
#                return project(b, DECIMAL_NIL);
end	ea_a;
barrier	ga_a:= not(ea_a);
barrier	ha_a:= istenfold(div);
#        } else if (istenfold(div)) {
	ia_a := getprecision(div);
	ja_a := getscale(div);
	ka_a := +(ia_a,ja_a);
	dec:= -(1,ka_a);
#                var dec := 1 - (getprecision(div) + getscale(div));
	la_a := multiplex.tactics("addscale",b,dec);
	ma_a := multiplex.tactics("setprecision",la_a,prec);
	return ma_a;
#                return [setprecision]([addscale](b,dec),prec);
#        }
end	ha_a;
end	ga_a;
	na_a := bulkdivide(b,div,prec);
	return na_a;
#        return bulkdivide(b, div, prec); 
end function;
#    }
# 
function divide(b:bat[any::1,decimal], div:decimal):bat[any::1,decimal];
#    proc divide(bat[any::1,decimal] b, decimal div) : bat[any::1,decimal] {
	DECIMAL_ZERO:= decimal(0);
	oa_a := =(div,DECIMAL_ZERO);
	pa_a := isnil(div);
barrier	qa_a:= or(oa_a,pa_a);
#        if ((div = DECIMAL_ZERO) or isnil(div)) {
	DECIMAL_NIL:= decimal(nil);
	ra_a := project(b,DECIMAL_NIL);
	return ra_a;
#                return project(b, DECIMAL_NIL);
end	qa_a;
barrier	sa_a:= not(qa_a);
barrier	ta_a:= istenfold(div);
#        } else if (istenfold(div)) {
	ua_a := getprecision(div);
	va_a := getscale(div);
	wa_a := +(ua_a,va_a);
	dec:= -(1,wa_a);
#                var dec := 1 - (getprecision(div) + getscale(div));
	xa_a := multiplex.tactics("addscale",b,dec);
	ya_a := multiplex.tactics("setscale",xa_a,0);
	return ya_a;
#                return [setscale]([addscale](b,dec),0);
#        } 
end	ta_a;
end	sa_a;
	ab_a := bulkdivide(b,div);
	return ab_a;
#        return bulkdivide(b, div);
end function;
#    }
#

@+ Session control
Redirected script evaluations.
@mal
command cwd(s:str):str= CMDsetCwd
	comment "Return the current working directory. Set it to a new one.";
pattern eval(s:str):void= CMDevalString
	comment "Evaluate a string representing a MAL program";
pattern source(f:str):void= CMDevalFile
	comment "Load and executed a (local) file";
@+ Dummy code 
@h
/*
 * The contents of this file are subject to the Monet Public
 * License Version 1.1 (the "License"); you may not use this file
 * except in compliance with the License. You may obtain a copy of
 * the License at 
 * http://www.monetsolutions.com/Download/Licensing/MonetPL-1.1.html
 * 
 * Software distributed under the License is distributed on an "AS
 * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
 * implied. See the License for the specific language governing
 * rights and limitations under the License.
 * 
 * The Original Code is the Monet Database System.
 * 
 * The Initial Developer of the Original Code is CWI.
 * Portions created by CWI are Copyright (C) 1997-2001 CWI.  
 * All Rights Reserved.
 * 
 * Contributor(s): Martin Kersten <Martin.Kersten@cwi.nl>
 */
#ifndef _ITERATOR_H
#define _ITERATOR_H
#endif /* _ITERATOR_H*/
@c
#include <stdarg.h>
#include <time.h>
#include "gdk.h"
#include "mal_resolve.h"
#include "mal_client.h"
#include "mal_function.h"
#include "monet.h"

@+ BAT declarations
@c
str CMDBATnew(MalBlkPtr m, MalStkPtr s, InstrPtr p){
        int ht, tt, cap=0;
	int *res;

        ht= getArgType(m,p,1);
        tt= getArgType(m,p,2);
        if( p->argc>3)
                cap= *(int *) getArgReference(s,p,3);
	res= (int *) getArgReference(s,p,0);

	return (str) CMDnewBat2(res,&ht,&tt,&cap);
}

@+ Exception implementation
@c
str CMDraise(str *ret,  str *msg){
	*ret= GDKstrdup(*msg);
	return GDKstrdup(*msg);
}
str CMDcast_str(str *new, str *src){
	ValRecord vr;
	vr.len=0; vr.vtype=0;
	VALconvert(TYPE_str,&vr,FALSE);
	*new = vr.val.sval;
	return MAL_SUCCEED;
}
str CMDcast(int *new, int *src){
	ValRecord vr;
	vr.len=0; vr.vtype=0;
	VALconvert(TYPE_str,&vr,FALSE);
	memcpy(new,&vr,sizeof(vr.val.lval));
	return MAL_SUCCEED;
}
@+
Algebraic operators
@c
str CMDproject (MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	int *result, *bid, tt;
	ptr *p;
        BAT *b, *bn;

	result= (int*) getArgReference(stk,pci,0);
	bid= (int*) getArgReference(stk,pci,1);
	p= (ptr*) getArgReference(stk,pci,2);
	tt=  getArgType(mb,pci,2);
        @:getBATdescriptor(result,bid,b,project)@
        bn= BATconst(b, tt, p);
        if( bn ) {
               *result = bn->batCacheid;
                return MAL_SUCCEED;
        }
        return throwMessage("mal.project","GDKerror");
}

str CMDprojectNil(int *ret, int *bid){
	BAT *b,*bn;
        @:getBATdescriptor(ret,bid,b,project)@

	bn= BATconst(b,TYPE_void, &int_nil);
        if( bn ) {
               *ret = bn->batCacheid;
                return MAL_SUCCEED;
        }
        return throwMessage("mal.project","GDKerror");
}
@+ BAT Iterator Implementation
Part of the code is copied from the V 4.3 bat.mx file.
@= getBATdescriptor
        if( BBPcheck(*@2,"@4")==0) 
		return throwMessage("mal.@4","cannot access bat @2 in bbp");
        @3= (BAT*) BBPgetdesc(*@2);
        if( @3 == NULL) { *@1 = 0; 
                return throwMessage("mal.@4","cannot access descriptor @2");
	}
	if(*@2 <0) @3= BATmirror(@3);
@-
@= hashiter
	if (b->tvarsized) {
		HASHloop@1(b, b->hhash, idx, v, p)
			if ((i = ITERATE(v, BUNtvar(b,p), h)) < 0) return i;
	} else {
		HASHloop@1(b, b->hhash, idx, v, p)
			if ((i = ITERATE(v, BUNtloc(b,p), h)) < 0) return i;
	} break;
@c
str CMDhashloop(int *ret, lng *cursor, int *bid)
{
	BAT *b;
	@:getBATdescriptor(ret,bid,b,nextElement)@
	return throwMessage("mal.hashloop","not yet implemented");
}

@-
In principle, we could add iterators with other range bounds.
@= nextLoop
str CMDnextElement_@1(bit *ret, @1 *cursor, int *bid)
{
	BAT *b;
	int limit;
	@:getBATdescriptor(ret,bid,b,nextElement)@
	limit=  BUNindex(b,BUNlast(b));
	if( *cursor <0)
		*cursor = BUNindex(b,BUNfirst(b));
	else	*cursor = *cursor+1;
	*ret = *cursor < limit;
	return MAL_SUCCEED;
}
@-
@c
	@:nextLoop(lng)@

str CMDnextElement(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	BAT *b;
	lng *cursor;
	bit *ret;
	int *bid;
	int limit;
	BUN p;
	ValPtr head, tail;

	if( pci->argc != 5) printf("CMDnextElement:exception\n");
	ret = (bit *) getArgReference(stk,pci,0);
	cursor = (lng *) getArgReference(stk,pci,1);
	bid = (int *) getArgReference(stk,pci,2);
	head = &stk->stk[pci->argv[3]];
	tail = &stk->stk[pci->argv[4]];

	@:getBATdescriptor(ret,bid,b,nextElement)@
	limit=  BUNindex(b,BUNlast(b));

	if( *cursor <0)
		*cursor = BUNindex(b,BUNfirst(b));
	else	*cursor = *cursor+1;
	*ret = *cursor < limit;

	if( *ret== FALSE) return MAL_SUCCEED;
	/* get head = ... tail = ... */
	p = BUNptr(b,*cursor);
	garbageElement(head);
	garbageElement(tail); 
	VALinit( head, getArgType(mb,pci,3),BUNhead(b,p));
	VALinit( tail, getArgType(mb,pci,4),BUNtail(b,p));
printf("%s",BUNtail(b,p));
	return MAL_SUCCEED;
}
@-
The BUN- and BAT-stream manipulate a long handle, i.e.
the destination variable. It assumes it has been set to
zero as part of runtime stack initialization. Subsequently,
it fetches a bun and returns the increment to the control
variable. If it returns zero the control variable has been reset
to zero and end of stream has been reached.
@c
str CMDbunStream(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	BAT *b;
	lng *cursor;
	bit *ret;
	int *bid;
	int limit,tp;
	BUN p;
	ValPtr head, tail;

	if( pci->argc != 4) printf("exception in nextElement\n");
	cursor = (lng *) getArgReference(stk,pci,0);
	bid = (int *) getArgReference(stk,pci,1);
	head = &stk->stk[pci->argv[2]];
	tail = &stk->stk[pci->argv[3]];
	@:getBATdescriptor(ret,bid,b,nextElement)@
	limit=  BUNindex(b,BUNlast(b));

	if( *cursor >=limit){
		*cursor = 0;
		return MAL_SUCCEED;
	} 
	if( *cursor == 0)
		*cursor = BUNindex(b,BUNfirst(b));

	/* get head = ... tail = ... */
	p = BUNptr(b,*cursor);
	garbageElement(head);
	garbageElement(tail); 
	tp = getArgType(mb,pci,2);
	if( tp == TYPE_void  && b->hseqbase!= oid_nil){
		VALinit( head, TYPE_oid, BUNhead(b,p));
		head->vtype= TYPE_void;
	} else 	VALinit( head, tp, BUNhead(b,p));
	VALinit( tail, getArgType(mb,pci,3),BUNtail(b,p));
	*cursor = *cursor+1;
	return MAL_SUCCEED;
}
str CMDbatstream(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	return throwMessage("mal.batstream"," not yet implemented");
}

str CMDnextSlice(int *ret, lng *cursor, int *bid, lng *low, lng *high)
{
	BAT *b;
	@:getBATdescriptor(ret,bid,b,nextSlice)@
	if( *cursor > *high){
		*ret = FALSE;
	} else 
	if( *cursor < *low){
		*ret = TRUE;
		*cursor = BUNindex(b,BUNfirst(b));
	} else
		*cursor = *cursor+1;
	return MAL_SUCCEED;
}
@-
The fetch operations are all pretty straight forward, provided
you know the underlying type. Often it is cheaper to use
the extended BAT iterator, because then it can re-use the
BAT descriptor.
@c
str CMDgetHead(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	BAT *b;
	lng *cursor;
	int *bid;
	int limit;
	BUN p;
	ValPtr head;
	int r, *ret=&r;

	cursor = (lng *) getArgReference(stk,pci,2);
	bid = (int *) getArgReference(stk,pci,1);
	head = &stk->stk[pci->argv[0]];

	@:getBATdescriptor(ret,bid,b,nextElement)@
	limit=  BUNindex(b,BUNlast(b));
	if( *cursor<0  || *cursor >=limit) {
		return throwMessage("mal.getHead","range error");
	}

	/* get head = ... */
	p = BUNptr(b,*cursor);
	garbageElement(head);
	VALinit( head, getArgType(mb,pci,3),BUNhead(b,p));
	return MAL_SUCCEED;
}
str CMDgetTail(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	BAT *b;
	lng *cursor;
	int *bid;
	int limit;
	BUN p;
	ValPtr tail;
	int r, *ret=&r;

	cursor = (lng *) getArgReference(stk,pci,2);
	bid = (int *) getArgReference(stk,pci,1);
	tail = &stk->stk[pci->argv[0]];

	@:getBATdescriptor(ret,bid,b,nextElement)@
	limit=  BUNindex(b,BUNlast(b));
	if( *cursor<0  || *cursor >=limit) {
		return throwMessage("mal.getTail","range error");
	}

	/* get head = ... */
	p = BUNptr(b,*cursor);
	garbageElement(tail);
	VALinit( tail, getArgType(mb,pci,3),BUNtail(b,p));
	return MAL_SUCCEED;
}
@+ Basic value operations
Version 4 contained primitives for self-reflection.
@c
str CMDtypename(str *ret, int *tpe){
	*ret = malTypeName(*tpe);
	return MAL_SUCCEED;
}
str CMDtype(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	int *ret;
	ret= (int*) getArgReference(stk,pci,0);
	*ret= getArgType(mb,pci,1);
	return MAL_SUCCEED;
}
@+ Printing
The print commands are implemented as single instruction rules,
because they need access to the calling context.
At a later stage we can look into the issues related to
parsing the format string as part of the initialization phase.
The old method in V4 essentially causes a lot of overhead
because you have to prepare for the worst (e.g. mismatch format
identifier and argument value)
@c
str CMDprint_val(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int tpe = getArgType(mb,pci,1);
	ptr val = (ptr) getArgReference(stk,pci,1);
        FILE *fp = GDKout;
	if( val==NULL) {
		ATOMprint(TYPE_str, "nil", GDKout);
		return MAL_SUCCEED;
	}
	if( isaBatType(tpe)){
		BAT *b = BATdescriptor(*(int*)val);
		if( b== NULL) {
			return throwMessage("mal.print","descriptor access failed");
		}
		/* BATprint(b);*/
		BATmultiprintf(GDKout,2,&b,TRUE,0);
		return MAL_SUCCEED;
	}
        fputs("[ ", fp);
	if( tpe == TYPE_str)
		ATOMprint(tpe, *(str*)val, fp);
        else  	ATOMprint(tpe, val, fp);
        fputs(" ]\n", fp);
        return MAL_SUCCEED;
}
str CMDprint_ft(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int tpe = getArgType(mb,pci,1);
	ptr val = (ptr) getArgReference(stk,pci,1);
	if( val==NULL) {
		ATOMprint(TYPE_str, "nil", GDKout);
		return MAL_SUCCEED;
	}
	if( tpe == TYPE_str)
		ATOMprint(TYPE_str, *(str*)val, GDKout);
	else ATOMprint(tpe, val, GDKout);
	return MAL_SUCCEED;
}

str CMDotable( MalBlkPtr mb, MalStkPtr stk, InstrPtr pci, int o, int flg){
        BAT *piv[MAXPARAMS],*b;
        int nbats = 0;
	int tpe,i=1,order=0;
	ptr val;

	if(o){
		order = *(int*) getArgReference(stk,pci,1);
		i++;
	}
	for(; i< pci->argc;i++) {
		tpe = getArgType(mb,pci,i);
		val = (ptr) getArgReference(stk,pci,i);
		if( !isaBatType(tpe)) 
			return throwMessage("mal.otable"," BAT expected");
		b= BATdescriptor(*(int*)val);
		if(b == NULL) return throwMessage("mal.otable","GDKerror");
                piv[nbats++] = b;
        } 
        BATmultiprintf(GDKout, nbats, piv, flg, order);
        return MAL_SUCCEED;
}

str CMDprint_otable( MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	CMDotable(mb,stk,pci,1,TRUE);
        return MAL_SUCCEED;
}

str CMDprint_table( MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	CMDotable(mb,stk,pci,0,FALSE);
        return MAL_SUCCEED;
}

str CMDprint_table_default( MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
        BAT *piv[MAXPARAMS],*b;
        int nbats = 0;
	int tpe,i;
	ptr val;

	for(i=pci->retc; i< pci->argc;i++) {
		tpe = getArgType(mb,pci,i);
		val = (ptr) getArgReference(stk,pci,i);
		if( !isaBatType(tpe)) 
			return throwMessage("mal.print_table_default","BAT expected");
		b= BATdescriptor(*(int*)val);
		if(b == NULL) return throwMessage("mal.print_table_default","GDKerror");
                piv[nbats++] = b;
        } 
        BATmultiprintf(GDKout, i-1, piv, FALSE, 0);
        return MAL_SUCCEED;
}
@- Input redirectionrs
@c
str CMDevalString(MalBlkPtr mb, MalStkPtr stk, InstrPtr p){
	str s;
	Client c= getClient();
	str src;
	str buf=0;
	int len =0;

	s= (str) getArgValue(stk,p,1);
	if(strlen(s)==0) return MAL_SUCCEED;
	src= (str) GDKmalloc(len=strlen(s)+3);
	/* GDK_atom routine requires enclosing quotes */
	strcpy(src,"\"");
	strcat(src,s);
	strcat(src,"\"");
	strFromStr( src, &len, &buf);

	printf("Eval:%s\n",buf);
	evalString(getClient(),buf,FALSE,stk);
	GDKfree(src);
	GDKfree(buf);
	return MAL_SUCCEED;
}
str CMDevalFile(MalBlkPtr mb, MalStkPtr stk, InstrPtr p){
	str s;
	FILE *fd;
	Client c= getClient();
	char buffer[1024];

	s= (str) getArgValue(stk,p,1);
	if( strlen(s)+strlen(c->cwd)+2>=1024){
		return throwMessage("mal.setCwd","buffer too small");
	}
	buffer[0]=0;
	if( *s != '/'){
		strcpy(buffer,c->cwd);
		strcat(buffer,"/");
	}
	strcat(buffer,s);
	printf("run:%s\n",buffer);
	malImport(getClient(),buffer,FALSE);
	return MAL_SUCCEED;
}
str CMDdebug(int *ret, int *flg){
	*ret = GDKdebug;
	if( *flg) GDKdebug = *flg;
	return MAL_SUCCEED;
}
str CMDsetCwd(str *ret, str *fnme){
	Client c= getClient();
	*ret = c->cwd;
	c->cwd= GDKstrdup(*fnme);
	return MAL_SUCCEED;
}
