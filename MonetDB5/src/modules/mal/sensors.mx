@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2005 CWI.
@' All Rights Reserved.
@f sensors
@a M.L. Kersten
@+ Sensors Event Collector
The sensors module is a simple application module designed to
collect events from streams over an IP and to store them in a
a fixed collection of BATs.

The sensor module was inspired by the toy-story and e-health setting at Philips
and the astronomers reading out their devices causing massive simple
insert statements to be fired at the backend. The target is to
bring MonetDB closer to the sensor field, which communicate
through a network or WIFI devices that aren;t energy limited.
A concrete instance would be a disk-based access point that receives 
connections and handles the events directly.
The recordings are received int tuple load format, i.e. ASCII strings, and
stored in a MonetDB database as groups of BATs for
subsequent filtering, cleaning, and querying.
[Optionally a time stamp is added]

The ultimate implementation foreseen is a web-application
setting as we know them from router maintenance software.
The user has a simple form to administer listening to events at
a particular port. The event record can be described and 
the listening period controlled.

A second form provides a simple filter over a sensor 'logs'
that can be easily filtered for direct inspection. 
A third, free-format SQL form can be used to
related the sensor information.

The implementation is centered around a small sensor catalogue,
which describes the sensors and the events record structure.
Listening to a sensor is explicitly activated and leads to a
dedicated processing thread handling the update request.
The events containers are organized by session start time.
A session is closed by releasing the sensor.

Refinements to consider, (1) sensor events are only aggregated
(2) each sensors implies a group of events, defaults could be
used to fill 
It should be possible to control the capacity of the event containers 
and describe follow-up actions.
Furthermore, the remote access facility of MonetDB should be used
to move the completed event containers to an archive store or
backend server with sufficient capabilities for post-processing.

Experimental setups should consider 10-20 sensors active at
different speeds.
@mal
module sensors;

pattern open():void
address SENopen
comment "Locate and open the sensors box";
pattern close():void
address SENclose
comment "Close the sensors box ";
pattern destroy():void
address SENdestroy
comment "Destroy the sensors box";

command take(sname:str,ename:str):bat[:void,:any]
address SENtake
comment "Return the BAT with collected sensor input";
command take(sname:str,ename:str,winsize:int):bat[:void,:any]
address SENtakeWindow
comment "Return a view over the eventstream using the last 
		winsize elements received";

pattern define(sname:str, ename:str, field:int, val:any):void
address SENdefine
comment "Describes a sensor event, its position in the record
		and its type, a negative field in combination with a :timestamp
		leads to tagging reception of the event";

command releaseAll():void
address SENreleaseAll
comment "Ignore all event notifications";
command release(name:str) :void
address SENrelease
comment "Ignore event from a sensor";
command activate(sensor:str,ip:int):void
address SENactivate
comment "(Re-)Activate event collector at a given IP");
command activate(sensor:str,ip:str):void
address SENactivateIP
comment "(Re-)Activate event collector at a given IP");

command discard(name:str) :void
address SENdiscard
comment "Release a sensor rom the box";

command getSensors():bat[:void,:str]
address SENgetSensors
comment "Retrieve the names of all sensors";
command getEvents():bat[:str,:str]
address SENgetEvents
comment "Retrieve the names of all event streams";

command commit(sname:str):lng
address SENcommit
comment "Commit the events seen sofar, return the count of 
		new committed events";

command prelude()
address SENprelude
comment "Initialize the sensors package";

command dump()
address SENdump
comment "Display the sensors table";

sensors.prelude();
@- Implementation
The implementation is based on the assumption that 
the sensor produces information for a designated collection
of BATs. A separate process is created for each sensor to receive
and analyse the data. 

@include prelude.mx
@h
#ifndef _SENSORS_DEF
#define _SENSORS_DEF

#define DEBUG_SENSORS 

#define MAXEVENTFIELDS 256

#include "mal.h"
#include "mal_client.h"
#include "mal_interpreter.h"

mal_export str SENdrop(str nme);
#endif /* _SENSORS_DEF */
@-
The sensor module uses a global known dictionary to keep track
of the sensors and its properties. This way it becomes easy
to restart sensor input collection between sessions.
@c
#include "sensors.h"
#include "tablet.h"
#include "mal_interpreter.h"
#include "mal_exception.h"

BAT *SEN_id_sname;	/* Sensor name */
BAT *SEN_id_ename;	/* Sensor event name */
BAT *SEN_id_fld;	/* Sensor event position in CSV record */
BAT *SEN_id_tpe;	/* Field type */
BAT *SEN_id_bat;	/* BAT used to store it */
BAT *SEN_id_port;	/* Sensor is active on port */

static BAT *
SEN_create(str hnme, str tnme, int ht, int tt)
{
    BAT *b;
    char buf[128];

    snprintf(buf,128, "sensor_%s_%s", hnme,tnme);
	b= BATdescriptor(BBPindex(buf));
	if( b ) return b;

    b = BATnew(ht, tt, 256);
    if (b == NULL)
        GDKfatal("sensor.create:could not allocate.");

	BATkey(b, TRUE);
    BBPrename(b->batCacheid, buf);
	BATmode(b, PERSISTENT);
	BATcommit(b);
#ifdef DEBUG_SENSORS
	stream_printf(GDKout,"#created %s\n",buf);
#endif
	return b;
}
void
SENinit(){
	mal_set_lock(mal_contextLock, "sensors");
	SEN_id_sname= SEN_create("id","sname",TYPE_int,TYPE_str);
	SEN_id_ename= SEN_create("id","ename",TYPE_int,TYPE_str);
	SEN_id_bat= SEN_create("id","bat",TYPE_int,TYPE_str);
	SEN_id_tpe= SEN_create("id","tpe",TYPE_int,TYPE_str);
	SEN_id_port= SEN_create("id","active",TYPE_int,TYPE_int);
	SEN_id_fld= SEN_create("id","indx",TYPE_int,TYPE_int);
	mal_unset_lock(mal_contextLock, "sensors");
}
@-
Actually SENcommit is not a real transaction, it may fail during
execution. The remainder of the code is set up to compensate for
the situation.
@c
void
SENcommitInternal(){
	mal_set_lock(mal_contextLock, "sensors");
	BATcommit(SEN_id_sname); BATsave(SEN_id_sname);
	BATcommit(SEN_id_ename); BATsave(SEN_id_ename);
	BATcommit(SEN_id_bat); BATsave(SEN_id_bat);
	BATcommit(SEN_id_tpe); BATsave(SEN_id_tpe);
	BATcommit(SEN_id_port); BATsave(SEN_id_port);
	BATcommit(SEN_id_fld); BATsave(SEN_id_fld);
	mal_unset_lock(mal_contextLock, "sensors");
}
str
SENcommit(int *ret, str *sname)
{
	BUN p,q;
	int i;
	BAT *b;
	(void) ret; (void) sname;
	BATloop(SEN_id_sname,p,q){
		if( strcmp(*sname, (str) BUNtail(SEN_id_sname,p))==0){
			i= *(int*)p;
			b= BATdescriptor(BBPindex(BUNtail(SEN_id_bat,BUNfnd(SEN_id_bat,&i))));
			BATcommit(b);
			BBPunfix(b->batCacheid);
		}
	}
	SENcommitInternal();
	return throwMessage("sensors.commit", "commit not yet implemented");
}
@-
Dropping a sensor implies dropping also its event streams
@c
str
SENdrop(str sname)
{
	ptr p;
	int idx;
	str s;

#ifdef DEBUG_SENSORS
	stream_printf(GDKout,"#drop container %s\n",sname);
#endif
	do{
		p= BUNfnd(BATmirror(SEN_id_sname),sname);
		if( p== 0)
			break;
		idx = * (int*) p;
		BUNdelHead(SEN_id_sname,&idx);
		BUNdelHead(SEN_id_ename,&idx);
		BUNdelHead(SEN_id_fld,&idx);
		BUNdelHead(SEN_id_tpe,&idx);
		BUNdelHead(SEN_id_port,&idx);
		/* fetch bat and destroy */
		s = (str) BUNtail(SEN_id_bat, BUNfnd(SEN_id_bat,&idx));
		if( s){
#ifdef DEBUG_SENSORS
			stream_printf(GDKout,"#drop BAT container %s\n",s);
#endif
			BBPdecref(BBPindex(s),TRUE);
			BUNdelHead(SEN_id_bat,&idx);
		}
	} while (1);
	SENcommitInternal();
	return MAL_SUCCEED;
}

str
SENdump(int *ret)
{
	BAT *piv[MAXPARAMS];

	(void) ret;
	piv[0]= SEN_id_sname;
	if( piv[0]==0 )
        return throwMessage("sensors.dump","SEN_id_sname missing");
	piv[1]=SEN_id_ename;
	if( piv[1]==0 )
        return throwMessage("sensors.dump","SEN_id_ename missing");
	piv[2]=SEN_id_fld;
	if( piv[2]==0 )
        return throwMessage("sensors.dump","SEN_id_fld missing");
	piv[3]=SEN_id_tpe;
	if( piv[3]==0 )
        return throwMessage("sensors.dump","SEN_id_tpe missing");
	piv[4]=SEN_id_bat;
	if( piv[4]==0 )
        return throwMessage("sensors.dump","SEN_id_bat missing");
	piv[5]=SEN_id_port;
	if( piv[5]==0 )
        return throwMessage("sensors.dump","SEN_id_port missing");
	
	BATmultiprintf(GDKout, 6+1, piv, 0, 1, 1);
	return MAL_SUCCEED;
}
@- Module initializaton
The content of this box my only be changed by the Administrator.
@= authorize
	/* if( !isAuthorized("Admin"))
		return throwMessage("sensors.@1","unauthorized access to 'sensors' box");*/
@c

int isAuthorized(str nme){
	Client c;
	if( nme == 0) return 1;
	c= getClient();
	return idcmp(c->user,nme)==0;
}
@- Operator implementation
@c
str
SENprelude(int *ret){
	Box box;
	(void) ret;
	box= openBox("sensors");
    if( box== 0)
        return throwMessage("sensors.prelude","failed to open box");
	SENinit();
	return MAL_SUCCEED;
}

str SENopen(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	(void)mb;(void)stk;(void)pci; /* fool compiler*/
	@:authorize(open)@
	if(openBox("sensors") != 0) return MAL_SUCCEED;
	return throwMessage("sensors.open","failed to open sensors box");
}

str SENclose(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	(void)mb;(void)stk;(void)pci; /* fool compiler*/
	@:authorize(close)@
	if( closeBox("sensors" ,TRUE) ==0) return MAL_SUCCEED;
	return throwMessage("sensors.close","failed to close box");
}
str SENdestroy(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	BUN p,q;
	BAT *b;
	Box box;
	(void)mb;(void)stk;(void)pci; /* fool compiler*/
	@:OpenBox(destroy)@
#ifdef DEBUG_SENSORS
	stream_printf(GDKout,"#About to destroy the sensor catalogue\n");
#endif
	mal_set_lock(mal_contextLock, "sensors");
	b= BATcopy(SEN_id_sname);
	BATloop(b,p,q){
		SENdrop((str) BUNtail(b,p));
	}
	BBPunfix(b->batCacheid);

	BBPunfix(SEN_id_sname->batCacheid);
	BBPunfix(SEN_id_ename->batCacheid);
	BBPunfix(SEN_id_tpe->batCacheid);
	BBPunfix(SEN_id_bat->batCacheid);
	BBPunfix(SEN_id_fld->batCacheid);
	BBPunfix(SEN_id_port->batCacheid);
	SEN_id_sname = NULL;
	SEN_id_ename = NULL;
	SEN_id_tpe = NULL;
	SEN_id_bat = NULL;
	SEN_id_port = NULL;
	SEN_id_fld = NULL;
	mal_unset_lock(mal_contextLock, "sensors");
	SENinit();
	return MAL_SUCCEED;
}
@-
Access to a box calls for resolving the first parameter
to a named box.
@= OpenBox
	@:authorize(@1)@
	box= findBox("sensors");
	if( box ==0) 
	return throwMessage("sensors.@1","box is not open");
@-
@c
str SENdefine(MalBlkPtr mb, MalStkPtr stk, InstrPtr pc)
{
	BAT *bn;
	Box box;
	int tpe, *indx,i, zero=0;
	ptr p;
	str sname,ename,tname;

	sname= (str) getArgValue(stk,pc,1);
	ename= (str) getArgValue(stk,pc,2);
	indx= (int *) getArgValue(stk,pc,3);
	tpe=  getArgType(mb,pc,4);
	tname= getTypeName(tpe);

	if( *indx > MAXEVENTFIELDS)
		return throwMessage("sensors.deposit","too many events per sensor");
	if( *indx < 0 && tpe != getTypeIndex("timestamp",9,-1))
		return throwMessage("sensors.deposit",":timestamp expected");
#ifdef DEBUG_SENSORS
	stream_printf(GDKout,"#sensors %s event %s field %d\n",sname,ename, *indx);
#endif
	@:OpenBox(deposit)@

	/* already add an empty container */
	bn= BATnew(TYPE_void,tpe, 256);
	if( bn == NULL ) 
		return throwMessage("sensors.deposit","Could not create event container");
	BATseqbase(bn,0);
	/* update sensor catalog */
	i= (int) BATcount(SEN_id_sname);
	p= BUNins(SEN_id_sname, &i, sname);
	if(p == 0)
		return throwMessage("sensors.deposit","Failed to add element");

	BUNins(SEN_id_ename, &i, ename);
	BUNins(SEN_id_tpe, &i, tname); GDKfree(tname);
	BUNins(SEN_id_bat, &i, BATgetId(bn));
	BUNins(SEN_id_port, &i, &zero);
	BUNins(SEN_id_fld, &i,  (ptr) indx);
	return MAL_SUCCEED;
}
@-
The take() operation returns a view on the last winsize elementso
@c
str
SENtake(int *ret, str *sname, str *ename)
{
	Box box;
	BUN p,q,r,s;
	str bnme;

	(void) ret; 
	@:OpenBox(take)@
	BATloop(SEN_id_sname,p,q){
		if( strcmp(*sname, (str) BUNtail(SEN_id_sname,p))==0){
			BATloop(SEN_id_ename,r,s){
				if( strcmp(*ename, (str) BUNtail(SEN_id_ename,r))==0 ){
					bnme= (str) BUNtail(SEN_id_bat, BUNhead(SEN_id_sname,p));
#ifdef DEBUG_SENSORS
					stream_printf(GDKout,"get stream %s\n",bnme);
#endif
					BBPincref( *ret= BBPindex(bnme), TRUE);
					return MAL_SUCCEED;
				}
			}
		}
	}
	return throwException(MALEXCEPTION,"sensors.take", "Not found");
}
str SENtakeWindow(int *ret, str *sname, str *ename, int *winsize)
{
	Box box;
	(void) ret; (void) sname; (void) ename; (void) winsize;
	@:OpenBox(take)@
	return throwException(MALEXCEPTION,"sensors.take",
		"not yet implemented");
	return MAL_SUCCEED;
}
@-
Releasing a sensor means turning off the capturing of
events.
@c
str SENrelease(int *ret, str *sname){
	Box box;
	int i;
	ptr p,q;
	(void) ret;
	@:OpenBox(release)@
#ifdef DEBUG_SENSORS
	stream_printf(GDKout,"#release event stream %s\n", *sname);
#endif
	p= BUNfnd(BATmirror(SEN_id_sname), *sname);
	if( p == 0)
		return throwException(MALEXCEPTION,"sensors.release",
			"sensor not defined");

	BATloop(SEN_id_sname,p,q)
	if( strcmp(*sname, (str) BUNtail(SEN_id_sname,p))==0){
		i = *(int*)p;
		*(int*) BUNtail(SEN_id_port, BUNfnd(SEN_id_port, &i)) = 0;
	}
	return MAL_SUCCEED;
}
str SENreleaseAll(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	Box box;
	BUN p,q;

	@:OpenBox(release)@
	(void)mb; (void)stk; (void) pci; /* fool compiler */
	BATloop(SEN_id_port,p,q){
		int *port = (int*) BUNtail(SEN_id_port,p);
		*port = 0;
	}
	return MAL_SUCCEED;
}

str SENdiscard(int *ret, str *name){
	Box box;

	(void) ret;
	@:OpenBox(discard)@
	return SENdrop(*name);
}
str
SENgetSensors(int *bid){
	BAT *bn;
	bn= BATcopy(SEN_id_sname);
	if( bn == NULL)
         return throwMessage("sensors.getSensors", "Cannot access descriptor");
	bn= BATmirror(BATkunique(BATmirror(bn)));
	BBPincref(*bid= bn->batCacheid,TRUE);
	return MAL_SUCCEED;
}
str
SENgetEvents(int *bid){
	BAT *bn;
	bn = BATjoin(BATmirror(SEN_id_sname), SEN_id_ename,oid_nil);
#ifdef DEBUG_SENSORS
	stream_printf(GDKout,"#get events\n");
#endif
	*bid= bn->batCacheid;
	BBPincref(*bid,TRUE);
	return MAL_SUCCEED;
}
@-
The key part of the sensors module starts here.
When a sensor is activated, we start an internet thread
listening to the port identified for ASCII values
They are decomposed and stored in the corresponding
BATs. For this we can re-use the ASCII IO stuff.
@c
typedef struct {
	int socket;
	/*str sname; does not work */
} *SensorInfo;
static str sensorName;	/* insecure channel between threads! */

extern str SENstartSensor(str sname, bstream *bs);
extern str SENlisten(str sname, int port, str *Usockfile);
str
SENactivate(int *ret, str *sname, int *port)
{
	char portid[128];
	ptr p,q,t;
	int i;

	(void) ret; 
#ifdef DEBUG_SENSORS
	stream_printf(GDKout,"Activate reception of stream for %s\n",*sname);
#endif
	p= BUNfnd(BATmirror(SEN_id_sname), *sname);
	if( p == 0)
		return throwException(MALEXCEPTION,"sensors.activate",
			"sensor not defined");
	i= *(int*) p;
	p= BUNfnd(SEN_id_port,&i);
	if( p == 0 && (i= *(int*)p )> 0 )
		return throwException(MALEXCEPTION,"sensors.activate",
			"sensor already active");

	snprintf(portid,128,"%d",*port);
	if( SENlisten(GDKstrdup(*sname), *port, NULL) == MAL_SUCCEED){
		BATloop(SEN_id_sname,p,q)
		if( strcmp(BUNtail(SEN_id_sname,p), *sname)== 0){
			i= *(int*) p;
			t= BUNfnd(SEN_id_port,&i);
			if(t)
				*(int*) BUNtail(SEN_id_port,t) = *port;
		}
		return MAL_SUCCEED;
	}
	return throwException(MALEXCEPTION,"sensors.activate",
		"sensor not active");
}
str
SENactivateIP(int *ret, str *sname, str *port)
{
	(void) ret; (void) sname; (void) port;
#ifdef DEBUG_SENSORS
	stream_printf(GDKout,"Activate reception of a stream\n");
#endif
	return throwMessage("sensors.activate",
		"activate not yet implemented");
}
@+ The collector
Each sensor once activate is controlled by a separate thread,
which listens to the port until the sensor is released.
If the stream breaks, it will save the data to disk and
also once every 1000 events (to be refined)

The current implementation taps into the ASCII io reader,
which means we are expecting MonetDB tuple format descriptions.
@c
str
SENstartSensor(str sname, bstream *bs){
	Tablet as;
	int i,k=0;
	BUN p,q;
	Column *fmt;

#ifdef DEBUG_SENSORS
	stream_printf(GDKout,"#Start sensor reception %s\n",sname);
#endif
	fmt= as.format= (Column*) GDKmalloc(sizeof(Column) * MAXEVENTFIELDS+1);
	as.offset= 0;
	as.nr_attrs= 0;
	as.nr = (size_t) oid_nil;
	/* construct the read structure */
	BATloop(SEN_id_sname,p,q)
	if( strcmp(sname, BUNtail(SEN_id_sname,p))==0){
		i = *(int*) p;
		fmt[k].name = (char*)BUNtail(SEN_id_bat, BUNfnd(SEN_id_bat,&i));
		fmt[k].bval = BATdescriptor(BBPindex((char*)BUNtail(SEN_id_bat, BUNfnd(SEN_id_bat,&i))));
#ifdef DEBUG_SENSORS
		stream_printf(GDKerr, "#added field %s\n", fmt[k].name );
#endif
		fmt[k].sep = GDKstrdup((char*)",");
		fmt[k].seplen = (int) strlen( fmt[k].sep );
		fmt[k].adt = *(int*) BUNtail(SEN_id_tpe, BUNfnd(SEN_id_tpe,&i));
		fmt[k].type = (char*)getTypeName(fmt[k].adt);
		fmt[k].tostr = &TABLETadt_toStr;
		fmt[k].frstr = &TABLETadt_frStr;
		fmt[k].extra = NULL;
		k++;
	}
/*
	fmt[k].sep = GDKstrdup((char*)"\n");
	fmt[k].seplen = (int) strlen( fmt[k].sep );
	k++;
*/
	as.nr_attrs= k;
	/* here we fork and prepare for reading */
#ifdef DEBUG_SENSORS
		stream_printf(GDKerr, "#start loading sensor data\n");
#endif
	TABLETload_file(&as, bs);
	TABLETdestroy_format(&as);
	return MAL_SUCCEED;
}
@-
The implementation is a patched version of mapi.mx
@c
#ifndef SEN_H
#define SEN_H

#define NEW_ARRAY( type, size )	(type*)GDKmalloc((size)*sizeof(type))
#define STREQ(a, b) 		(strcmp(a, b)==0)

#endif /* SEN_H */
@c

#include  <sys/types.h>
#ifdef HAVE_SYS_SOCKET_H
# include <sys/socket.h>
#endif
#ifdef HAVE_WIN32
# include <winsock.h>
#endif
#ifdef HAVE_SYS_UN_H
#include <sys/un.h>
#endif

#define SOCKPTR struct sockaddr *
#if HAVE_SOCKLEN_T
#define SOCKLEN socklen_t
#else
#define SOCKLEN int
#endif

#ifdef NATIVE_WIN32
#define s_close(s)	closesocket(s)
#else
#define s_close(s)	close(s)
#endif

#ifdef HAVE_OPENSSL
#include <openssl/ssl.h>
#include <openssl/err.h>
#endif


static int usock = -1;
@-
The listen thread operation now simply opens the connection
and passed control to the file loading.
@c

str
SENlistenThread(SensorInfo sensor)
{
	char *msg=0;
#ifdef DEBUG_SENSORS
	stream_printf(GDKerr, "#sensor reading thread started %s\n", sensorName );
#endif
	do {
		int retval;
		struct timeval tv;
		fd_set fds;
		int msgsock;
		int sock = sensor->socket;

		FD_ZERO(&fds);
		if (sock >= 0)
			FD_SET(sock, &fds);
#ifdef HAVE_SYS_UN_H
		if (usock >= 0)
			FD_SET(usock, &fds);
#endif
		/* Wait up to 0.5 seconds. */
		tv.tv_sec = 0;
		tv.tv_usec = 500;

		/* temporarily use msgsock to record the larger of sock and usock */
		msgsock = sock;
#ifdef HAVE_SYS_UN_H
		if (usock > sock)
			msgsock = usock;
#endif
		retval = select(msgsock + 1, &fds, NULL, NULL, &tv);
		if (retval == 0) {
			/* nothing interesting has happened */
			continue;
		}
		if (retval < 0) {
			if (MT_geterrno() != EINTR) {
				msg= "select failed\n";
				goto error;
			}
			continue;
		}
		if (sock >= 0 && FD_ISSET(sock, &fds)) {
			if ((msgsock = accept(sock, (SOCKPTR) 0, (SOCKLEN *) 0)) < 0) {
				if (MT_geterrno() != EINTR) {
					msg="accept failed\n";
					goto error;
				}
				continue;
			}
#ifdef HAVE_SYS_UN_H
		} else if (usock >= 0 && FD_ISSET(usock, &fds)) {
			if ((msgsock = accept(usock, (SOCKPTR) 0, (SOCKLEN *) 0)) < 0) {
				if (MT_geterrno() != EINTR) {
					msg="accept failed\n";
					goto error;
				}
				continue;
			}
#endif
		} else
			continue;
#ifdef DEBUG_SENSORS
	printf("sensor request:accepted\n");
	fflush(stdout);
#endif
		stream *fdin = socket_rstream(msgsock, "Mserver sensor read");
		bstream *bs;

		if (fdin == 0 || stream_errnr(fdin)) {
			GDKsyserror("SENlisten:fdin problems\n");
			continue;
		}

		fdin = block_stream(fdin);

#ifdef DEBUG_SENSORS
		stream_printf(GDKerr, "#SENlisten:sensor accepted %d\n", msgsock);
#endif
		bs = bstream_create(fdin,4*BLOCK);
		/* now read the stream until it is closed */
		msg= SENstartSensor(sensorName, bs);
#ifdef DEBUG_SENSORS
		stream_printf(GDKerr, "#SENlisten:sensor reading finished\n");
#endif
		
	} while (msg== MAL_SUCCEED);
error:
	return throwMessage("sensors.listen",msg);
}
str
SENlisten(str sname, int port, str *Usockfile)
{
	struct sockaddr_in server;
	int sock = -1;
	SensorInfo     sensor = GDKmalloc(sizeof(SensorInfo));
	sensorName= sname;

#ifdef HAVE_SYS_UN_H
	struct sockaddr_un userver;
#endif
	SOCKLEN length = 0;
	int on = 1;
	int i = 0;
	int pid, *pidp= &pid;
	char msg[512], *usockfile, host[512];

	if (Usockfile == NULL || *Usockfile == 0 || strcmp(*Usockfile, str_nil) == 0)
		usockfile = NULL;
	else {
#ifdef HAVE_SYS_UN_H
		usockfile = GDKstrdup(*Usockfile);
#else
		usockfile = NULL;
		GDKwarning("SENlisten: Unix domain sockets are not supported\n");
#endif
	}

	if (port <= 0 && usockfile == NULL) 
		return throwMessage("sensors.listen", 
			"no port or socket file specified\n");

	if (port > 0) {
		sock = socket(AF_INET, SOCK_STREAM, 0);
		if (sock < 0)
			return throwMessage("sensors.listen",
				"creation of stream socket failed\n");
@-
Set server port and allow network connections from any workstation.
Bind the socket to the server port.
The port id should be obtained from the Homes file.
@c
		server.sin_family = AF_INET;
		server.sin_addr.s_addr = INADDR_ANY;
		server.sin_port = htons((unsigned short) ((port) & 0xFFFF));
		for (i = 0; i < 8; i++)
			server.sin_zero[i] = 0;

		setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, (char *) &on, sizeof on);

		length = (SOCKLEN) sizeof(server);
		if (bind(sock, (SOCKPTR) & server, length) < 0) 
			return throwMessage("sensors.listen",
						"binding to stream socket failed\n");
@-
Get the new information for the server socket and start listening.
@c
		if (getsockname(sock, (SOCKPTR) & server, &length) < 0)
			return throwMessage("sensors.listen",
						"Failed getting socket name\n");
		listen(sock, 1);
	}
#ifdef HAVE_SYS_UN_H
	if (usockfile) {
		usock = socket(AF_UNIX, SOCK_STREAM, 0);
		if (usock < 0) {
			unlink(usockfile);
			return throwMessage("sensors.listen",
						"creation of Unix socket failed\n");
		}
		userver.sun_family = AF_UNIX;
		strncpy(userver.sun_path, usockfile, sizeof(userver.sun_path));

		length = (SOCKLEN) sizeof(userver);
		if (bind(usock, (SOCKPTR) & userver, length) < 0) {
			unlink(usockfile);
			return throwMessage("sensors.listen",
				"binding to Unix socket file failed\n");
		}
		listen(usock, 1);
	}
#endif

#ifdef DEBUG_SENSORS
		THRprintf(GDKerr, "SENlisten:Network started at %d\n", port);
#endif
	sensor->socket = sock;

	if( MT_create_thread((MT_Id *)pidp,
		(void (*)(void *))SENlistenThread, sensor) <0){
			return throwMessage("sensors.listen", "starting thread failed");
	}
#ifdef HAVE_SYS_UN_H
	if (usockfile)
		unlink(usockfile);
#endif
    gethostname(host,(int)512);
	snprintf(msg,(int)512,"#Ready to read sensor data from connection %s:%d\n",host,port);
	stream_printf(GDKout,"%s",msg);
	return MAL_SUCCEED;
}
