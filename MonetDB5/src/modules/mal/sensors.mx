@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2005 CWI.
@' All Rights Reserved.
@f sensors
@a M.L. Kersten
@+ Sensors Event Collector
The sensors module is a simple application module designed to
collect events from an IP and to store them in a
a fixed collection of BATs.

The sensors module can be used in a home-setting to collect
remote sensor readings and store them in a MonetDB database for
subsequent filtering, reduction, and querying.

A sensor emits events on a single channel as CSV-type ascii strings,
which are decoded at the server side and stored in corresponding 
BATs. Optionally a time stamp is added.

The ultimate implementation is a web-application
setting as we know them from router maintenance software.
The user has a simple form to start listening to events at
a particular port and stores the result in collection os bats. 

A second form provides a simple filter over a sensor
to inspect the data. A free-format SQL form can be used to
related the sensor information.

Refinements to consider, (1) sensor events are only aggregated
(2) each sensors implies a group of events, defaults could be
used to fill 
@mal
module sensors;

pattern open():void
address SECopen
comment "Locate and open the sensors box";
pattern close():void
address SECclose
comment "Close the sensors box ";
pattern destroy():void
address SECdestroy
comment "Destroy the sensors box";

command take(sname:str,ename:str,winsize:lng):bat[:void,:any]
address SECtake
comment "Return a view over the eventstream using the last 
		winsize elements received";

command deposit(sname:str, ename:str, indx:int, 
	container:bat[:void,:any]):void
address SECdeposit
comment "Describes a containers that receives events";

command releaseAll():void
address SECreleaseAll
comment "Ignore all event notifications";
command release(name:str) :void
address SECrelease
comment "Ignore event from a sensor";
command activate(sensor:str,ip:str):void
address SECactivate
comment "(Re-)Activate event collector at a given IP");

pattern discard(name:str) :void
address SECdiscard
comment "Release a sensor rom the box";

command getObjects():bat[:str,:str]
address SECgetObjects
comment "Retrieve the names of all event streams";

command commit(sname:str):lng
address SECcommit
comment "Commit the events seen sofar, return the count of 
		new committed events";

command prelude()
address SECprelude
comment "Initialize the sensors package";

command dump()
address SECdump
comment "Display the sensors table";

sensors.prelude();
@- Implementation
The implementation is based on the assumption that 
the sensor produces information for a designated collection
of BATs. A separate process is created for each sensor to receive
and analyse the data. The sensor module should ensure that at any
time there are not two BATs being shared between sensors.

@include prelude.mx
@h
#ifndef _SENSORS_DEF
#define _SENSORS_DEF

#define DEBUG_SENSORS 

#include "mal.h"
#include "mal_client.h"
#include "mal_interpreter.h"

mal_export str SECdrop(str nme);
#endif /* _SENSORS_DEF */
@-
The sensor module uses a global known dictionary to keep track
of the sensors and its properties. This way it becomes easy
to restart sensor input collection between sessions.
@c
#include "sensors.h"

BAT *SEC_id_sname;	/* Sensor group name */
BAT *SEC_id_ename;	/* Sensor event name */
BAT *SEC_id_indx;	/* Sensor event position in CSV */
BAT *SEC_id_bat;	/* BAT used to store it */

static BAT *
SEC_create(str hnme, str tnme, int ht, int tt)
{
    BAT *b;
    char buf[128];

    snprintf(buf,128, "sensor_%s_%s", hnme,tnme);
	b= BATdescriptor(BBPindex(buf));
	if( b ) return b;

    b = BATnew(ht, tt, 256);
    if (b == NULL)
        GDKfatal("sensor.create:could not allocate.");

	BATkey(b, TRUE);
    BBPrename(b->batCacheid, buf);
	BATmode(b, PERSISTENT);
	BATcommit(b);
#ifdef DEBUG_SENSORS
	stream_printf(GDKout,"created %s\n",buf);
#endif
	return b;
}
void
SECinit(){
	mal_set_lock(mal_contextLock, "sensors");
	SEC_id_sname= SEC_create("id","sname",TYPE_int,TYPE_str);
	SEC_id_ename= SEC_create("id","ename",TYPE_int,TYPE_str);
	SEC_id_bat= SEC_create("id","bat",TYPE_int,TYPE_str);
	SEC_id_indx= SEC_create("id","indx",TYPE_int,TYPE_int);
	mal_unset_lock(mal_contextLock, "sensors");
}
@-
Actually SECcommit is not a real transaction, it may fail during
execution. The remainder of the code is set up to compensate for
the situation.
@c
void
SECcommitInternal(){
	mal_set_lock(mal_contextLock, "sensors");
	BATcommit(SEC_id_sname); BATsave(SEC_id_sname);
	BATcommit(SEC_id_ename); BATsave(SEC_id_ename);
	BATcommit(SEC_id_bat); BATsave(SEC_id_bat);
	BATcommit(SEC_id_indx); BATsave(SEC_id_indx);
	mal_unset_lock(mal_contextLock, "sensors");
}
str
SECcommit(int *ret, str *sname)
{
	(void) ret; (void) sname;
	return throwMessage("sensors.commit",
		"commit not yet implemented");
}
@-
Dropping a sensor implies dropping also its event streams
@c
str
SECdrop(str sname)
{
	ptr p;
	int idx;
	str s;

	do{
		p= BUNfnd(BATmirror(SEC_id_sname),sname);
		if( p== 0)
			break;
		idx = * (int*) p;
		BUNdelHead(SEC_id_sname,&idx);
		BUNdelHead(SEC_id_ename,&idx);
		BUNdelHead(SEC_id_indx,&idx);
		/* fetch bat and destroy */
		s = (str) BUNfnd(BATmirror(SEC_id_bat),&idx);
#ifdef SEC_DEBUG
			stream_printf(GDKout,"drop container %s\n",s);
#endif
		BBPdecref(BBPindex(s),TRUE);
	} while (1);
	SECcommitInternal();
	return MAL_SUCCEED;
}

str
SECdump(int *ret)
{
	BAT *piv[MAXPARAMS];

	(void) ret;
	piv[0]= SEC_id_sname;
	if( piv[0]==0 )
        return throwMessage("sensors.dump","SEC_id_sname missing");
	piv[1]=SEC_id_ename;
	if( piv[1]==0 )
        return throwMessage("sensors.dump","SEC_id_ename missing");
	piv[2]=SEC_id_indx;
	if( piv[2]==0 )
        return throwMessage("sensors.dump","SEC_id_indx missing");
	piv[3]=SEC_id_bat;
	if( piv[0]==0 )
        return throwMessage("sensors.dump","SEC_id_bat missing");
	
	BATmultiprintf(GDKout, 4+1, piv, 0, 1, 1);
	return MAL_SUCCEED;
}
@- Module initializaton
The content of this box my only be changed by the Administrator.
@= authorize
	/* if( !isAuthorized("Admin"))
		return throwMessage("sensors.@1","unauthorized access to 'sensors' box");*/
@c
#include "mal_client.h"
#include "mal_interpreter.h"

int isAuthorized(str nme){
	Client c;
	if( nme == 0) return 1;
	c= getClient();
	return idcmp(c->user,nme)==0;
}
@- Operator implementation
@c
str
SECprelude(int *ret){
	Box box;
	(void) ret;
	box= openBox("sensors");
    if( box== 0)
        return throwMessage("sensors.prelude","failed to open box");
	SECinit();
	return MAL_SUCCEED;
}

str SECopen(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	(void)mb;(void)stk;(void)pci; /* fool compiler*/
	@:authorize(open)@
	if(openBox("sensors") != 0) return MAL_SUCCEED;
	return throwMessage("sensors.open","failed to open sensors box");
}

str SECclose(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	(void)mb;(void)stk;(void)pci; /* fool compiler*/
	@:authorize(close)@
	if( closeBox("sensors" ,TRUE) ==0) return MAL_SUCCEED;
	return throwMessage("sensors.close","failed to close box");
}
str SECdestroy(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	Box box;
	(void)mb;(void)stk;(void)pci; /* fool compiler*/
	@:OpenBox(destroy)@
	destroyBox("sensors");
	return MAL_SUCCEED;
}
@-
Access to a box calls for resolving the first parameter
to a named box.
@= OpenBox
	@:authorize(@1)@
	box= findBox("sensors");
	if( box ==0) 
	return throwMessage("sensors.@1","box is not open");
@-
@c
str SECdeposit(int *ret, str *sname, str *ename, int *indx, int *bid)
{
	BAT *bn, *b;
	Box box;
	int i;
	ptr p;

	(void) ret;
	b= BATdescriptor(*bid);
	if( b== NULL)
		return throwMessage("sensors.deposit","Could not open container");

	@:OpenBox(deposit)@

	bn= BATnew(b->htype,b->ttype, 256);
	if( bn == NULL ) 
		return throwMessage("sensors.deposit","Could not create container");
	/* update sensor catalog */
	i= (int) BATcount(b);
	p= BUNins(SEC_id_sname,(ptr)  i, sname);
	p= BUNins(SEC_id_ename, (ptr) i, ename);
	p= BUNins(SEC_id_bat, (ptr) i, bn->batId);
	p= BUNins(SEC_id_indx, (ptr) i,  (ptr) indx);
	return MAL_SUCCEED;
}

str SECtake(int *ret, str *sname, str *ename, int *winsize)
{
	Box box;
	(void) ret; (void) sname; (void) ename; (void) winsize;
	@:OpenBox(take)@
	return throwException(MALEXCEPTION,"sensors.take",
		"not yet implemented");
	return MAL_SUCCEED;
}

str SECrelease(int *ret, str *sname){
	BAT *b;
	Box box;
	(void) ret;
	@:OpenBox(release)@
    if( (b= BATdescriptor(BBPindex(*sname))) == NULL ){
         return throwMessage("sensors.release", "Cannot access descriptor");
    }
	BBPunfix(b->batCacheid);
	return MAL_SUCCEED;
}
str SECreleaseAll(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	Box box;

	(void)mb; (void)stk; (void) pci; /* fool compiler */
	@:OpenBox(release)@
	releaseAllBox(box);
	return MAL_SUCCEED;
}

str SECdiscard(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	str name;
	Box box;

	(void)mb; /* fool compiler */
	@:OpenBox(discard)@
	name = (str) getArgValue(stk,pci,1);
	return SECdrop(name);
}
str
SECgetObjects(int *bid){
	BAT *bn;
	bn = BATjoin(BATmirror(SEC_id_sname), SEC_id_ename,oid_nil);
	*bid= bn->batCacheid;
	BBPincref(*bid,TRUE);
	return MAL_SUCCEED;
}
@-
The key part of the sensors module starts here.
When a sensor is activated, we start an internet thread
listening to the port identified for ascii values
They are decomposed and stored in the corresponding
BATs. For this we can re-use the ascii IO stuff.
@c
str
SECactivate(int *ret, str *sname, str *port)
{
	(void) ret; (void) sname; (void) port;
#ifdef DEBUG_SENSORS
	stream_printf(GDKout,"Activate reception of a stream\n");
#endif
	return throwMessage("sensors.activate",
		"activate not yet implemented");
}
