@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@' 
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@' 
@' The Original Code is the Monet Database System.
@' 
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2004 CWI.
@' All Rights Reserved.
@' 
@' Contributor(s):
@' 		Martin Kersten <Martin.Kersten@cwi.nl>
@' 		Peter Boncz <Peter.Boncz@cwi.nl>
@' 		Niels Nes <Niels.Nes@cwi.nl>
@' 		Stefan Manegold  <Stefan.Manegold@cwi.nl>

@f io
@a N.J. Nes, M.L. Kersten
@d 01/07/1996, 31/01/2002

@* The io Module
@T
This module contains all the file access commands. The implementation
is very simple. All function call the stdio library function.

This module is seperated from the database kernel since some 
servers are not allowed to do file accesses.

{\tt fopen()} opens the file named by filename  and  associates  a
fstream  with  it. {\tt fopen()}  returns  a  pointer to the FILE
structure associated with the fstream. The resulting pointer is needed
by all other io function. So fopen should be called before any other 
function. 

The {\tt fclose()} command closes the associated fstream. The FILE pointer 
given can not be used after calling this function. 

Pipes can be created with {\tt popen()}. This function returns the
identifier to a bidirectional pipe. You can then for instance {\tt fork()}
a new Monet session, passing this identifier.

Both sessions can then use the pipe to open a fstream with {\tt fdpipe()}.
The one end should pass {\tt true} as the {\tt up} parameter, the other
{\tt down}. This function returns a fstream, and can be used in combination
with any of the functions of this module.

The {\tt fflush()} command flushes the buffer of the associated fstream.

{\tt feof()} returns non-zero when EOF has previously been
detected reading the named input fstream, otherwise zero.

{\tt freopen()} substitutes the named file in place  of  the  open
fstream. A flush is first attempted, and then the original
fstream is closed, regardless of whether the open ultimately
succeeds. Failure to flush or close fstream successfully is
ignored. It returns the new FILE pointer.

The {\tt fread()} and {\tt fwrite()} commands read/write a number of bytes 
to or from a associated fstream. The read function returns a string 
containing the result. The write function returns the number of written bytes. 

The {\tt fseek()} function seeks an offset number of bytes form the start, the 
current position, or the end of the fstream.
\footnote{See the mil script file for the correct constants.}
This function returns the number of bytes moved. 

The {\tt fprintf()} function print a variable number of 
arguments using the format string. They return the number of arguments 
printed. 

The {\tt fputs()} places a string on the given output fstream. 
{\tt fgets()} reads a string until an end of line is found form the 
given input fstream. 

Look at the related ANSI-C/POSIX manual pages to get the needed information.
This module uses the blob atom.

@mal
atom module fstream :ptr
comment "Mapping to the FILE descriptor 
	on the Unix platforms. Should be 
	replaced by the stream package 
	primitives on NT";

atom module bipipe :lng;
command popen( ) :bipipe 
address io_popen 
comment "Open a bidirectional pipe. See:man pipe" ;
command fdpipe(b:bipipe,up:bit,mode:str):fstream 
address io_fdpipe 
comment "Open stream in one direction through 
	a pipe.";

module io;
command fopen(filename:str,mode:str):fstream 
address io_fopen 
comment "See:man fopen. Returns fstream, 
	or fstream(nil) on failure.";
command freopen(n:str,m:str,f:fstream):fstream 
address io_freopen 
comment "See:man freopen. Returns fstream, 
	or fstream(nil) on failure.";
command fsize( filename:str ) :int 
address io_fsize 
comment "Return the filesize or -1";
command ferror() :str 
address io_ferror 
comment "returns last error message or nil.";

command fclose( f:fstream ):void 
address io_fclose comment "See:man fclose";
command fflush( f:fstream ):void 
address io_fflush comment "See:man fflush";
command feof( f:fstream ) :bit 
address io_feof comment "See: man feof";
command fread( filep:fstream, nbytes:int ) :blob 
address io_fread 
comment "See:man fread";
command fwrite(fp:fstream,buf:str,bytes:int):void 
address io_fwrite_str 
comment "See:man fwrite";
command fwrite(fp:fstream,buf:blob,bytes:int):void 
address io_fwrite 
comment "See:man fwrite";
command fseek(fp:fstream,pos:int,offset:int):int 
address io_fseek 
comment "See:man fseek";
command ftell( filep:fstream ) :int 
address io_ftell 
comment "See:man ftell";

command fputs(s:str,fp:fstream):void 
address io_fputs 
comment "See:man fputs";
command fgets(fp:fstream ):str 
address io_fgets 
comment "See: man fgets";

command fputc(c:int,filep:fstream ):void 
address io_fputc 
comment "See:man fputs";
command fgetc(filep:fstream ):chr 
address io_fgetc 
comment "See: man fgetc";

@+ Printing 
The polymorphic print commands are collected here.
Watch out, the order of definitions is crucial, because the most
specific should be introduced last.
@mal

pattern print(b1:bat[:any$1,:any], 
		b2:bat[:any$1,:any]...):int 
address IOtable
comment "BATs are printed with '#' for legend 
	lines, and the BUNs on seperate lines 
	between brackets, containing each to 
	comma separated values (head and tail). 
	If multiple BATs are passed for printing, 
	print() performs an implicit natural 
	join, producing a multiattribute table.";

pattern ftable( filep:fstream, 
		b1:bat[:any$1,:any],
		b:bat[:any$1,:any]... ):int
address IOftable 
comment "Print an n-ary table to a file.";

pattern print(order:int,b:bat[:any$1,:any], 
		b2:bat[:any$1,:any]...):int
address IOotable
comment "The same as normal table print, but 
	enforces to use the order of BAT 
	number [1..argc] to do the printing.";

pattern table(b1:bat[:any$1,:any], 
		b2:bat[:any$1,:any]...):int 
address IOttable
comment "Print an n-ary table. Like print,
	but does not print oid column";

pattern table(order:int, b1:bat[:any$1,:any], 
		b2:bat[:any$1,:any]...):int 
address IOtotable
comment "Print an n-ary table.";
pattern ftable(fp:fstream, order:int,
	b1:bat[:any$1,:any], 
	b:bat[:any$1,:any]...)
address IOfotable 
comment "Print an n-ary table to a file.";

pattern print(val:any):int 
address IOprint_val
comment "Print a MIL value tuple .";

pattern prompt(val:any):int 
address IOprompt_val
comment "Print a MIL value without brackets.";
pattern printft(val:any):int 
address IOprint_ft
comment "Select default format ";

pattern fprint(fp:fstream,arg:any...):void 
address io_fprint 
comment "Print a (comma seperated) list ";

pattern fprintf(f:fstream,fm:str,a:any...):void 
address io_fprintf 
comment "See:man fprintf";

@- Formatted printing
The routines that inspect the runtime setting are moved out of this area.
                                                                                
@mal
command printf(format:str,val:bit):int
address IOprint_formatted_bit;
command printf(format:str,val:chr):int
address IOprint_formatted_chr;
command printf(format:str,val:int):int
address IOprint_formatted_int;
command printf(format:str,val:sht):int
address IOprint_formatted_sht;
command printf(format:str,val:oid):int
address IOprint_oid;
command printf(format:str,val:lng):int
address IOprint_formatted_lng;
command printf(format:str,val:flt):int
address IOprint_formatted_flt;
command printf(format:str,val:dbl):int
address IOprint_formatted_dbl;
command printf(val:str):int
address IOprint_str;
command printf(format:str,val:str):int
address IOprint_formatted_str;
@- ASCII import, export
The below commands load and save a BAT from/to an ASCII dump. These
functions are efficient but work only for binary tables. For printing
ASCII n-ary tables you can use the @#print@(bat1,bat2,..) command
from the system.mx module.
@mal
command export(b:bat[:any,:any], filepath:str):bit  = IOexport
comment "Export a BAT as ASCII to a file. If the 'filepath' is not absolute, it
 is put into the .../dbfarm/$DB directory. Success of failure is indicated.";

command import(b:bat[:any,:any], filepath:str) :bit = IOimport
comment "Import a BAT from an ASCII dump. The new tuples are *inserted* into the
 parameter BAT. You have to create it! Its signature must match the dump,
 else parsing errors will occur and FALSE is returned.";

@-
@{
@- MIL initializations 
The constants for the seek function.
@* Example Script
@mil
        const EOF      := -1;
        const SEEK_SET := 0;
        const SEEK_CUR := 1;
        const SEEK_END := 2;
setoid(oid(20000000));
module(io);

fp := fopen ( "test", "w+" );
fwrite( fp, "Dit is een test\n", 17 );
fp := freopen ( "test", "r+", fp );
fread( fp, 17 ).tostr.print;

fseek( fp, 0, 0);
fprintf( fp, "%s %d %c %d %f\n", "test", 10, 'c', 10, 7.0 );

s := "testing again and again\n";

fseek( fp, 0, 0);
fputs( s, fp );
fseek( fp, 0, 0);
s := fgets( fp );

fflush( fp );
fclose( fp );
printf( "%s %d %c %d %f\n", "test", 10, 'c', 10, 7.0 );
printf( "%s\n", s );

quit;
@* Implementation Code

@h
#ifndef _IO_H_
#define _IO_H_

#include <stdio.h>
#include <stdarg.h>
#include "blob.h"
#include "mal.h"
#include "mal_interpreter.h"

extern str IOtableAll(stream *f, MalBlkPtr mb, MalStkPtr stk, 
		  InstrPtr pci, int i, int order, int printhead);
extern str IOprintBoth(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci,int indx,str hd, str tl);

typedef struct {
	int up, down;
} bipipe;

typedef FILE* fstream;

#define fileCheck(fp) if (!fp) \
	return throwMessage( "io.@1","Incorrect file pointer"); 


#endif /* _IO_H_ */

@c
#include <mal_config.h>
#include "io.h"

str io_fclose(int *ret, fstream* filepp ){
   FILE *fp = *(FILE**) filepp; 
   (void) ret; /* fool compiler */
   fileCheck(fp)
   if (fclose(fp) < 0) {
	return throwMessage("io.fclose"," failed");
   }
   return MAL_SUCCEED;
}

str io_fflush(int *ret, fstream *filepp ){
   FILE *fp = *(FILE**) filepp; 
   (void) ret; /* fool compiler */
   fileCheck(fp);
   (void)fflush(fp);
   return MAL_SUCCEED;
}

str io_popen(bipipe **retval){
   if(*retval) GDKfree(*retval);
   *retval= (bipipe*) GDKmalloc(sizeof(bipipe));
   if (pipe((int*) *retval) < 0)
	return throwMessage("io.popen"," failed");
   return MAL_SUCCEED;
}
str io_fdpipe(fstream *retval, bipipe* p, bit *up, str *mode){
   *retval = (fstream) fdopen(up?p->up:p->down, *mode);
   if (*retval == 0) return MAL_SUCCEED;
   return throwMessage("io.fdpipe"," failed");
}

str io_feof( bit *res, fstream *filepp ){
   FILE *fp = *(FILE**) filepp; 
   fileCheck(fp);
   *res = feof(fp)?TRUE:FALSE;
   return MAL_SUCCEED;
}

str io_fopen( fstream *res, str *name, str *mode ){
   *res = fopen(*name,*mode);
   if (!*res) *res = *(fstream*) ATOMnilptr(TYPE_ptr);
   return MAL_SUCCEED;
}

str io_freopen( fstream *res, str *name, str *mode, fstream *filepp ){
   FILE *fp = *(FILE**) filepp; 
   fileCheck(fp);
   *res = freopen(*name,*mode,fp);
   if (!*res) *res = *(fstream*) ATOMnilptr(TYPE_ptr);
   return MAL_SUCCEED;
}

str io_ferror( str *msg) {
   int r = MT_geterrno();
   if (r) {
    	*msg = GDKstrdup(strerror(r));
   } else { 
	*msg = str_nil;
   }
   return MAL_SUCCEED;
}

str io_fread( blob **res, fstream *filepp, int *nbytes ){
   FILE *fp = *(FILE**) filepp; 
   int err = -1;
   str buf;
   fileCheck(fp);
   buf = (str) GDKmalloc( sizeof(int) + *nbytes );
   if ((*res = (blob*) buf) != NULL){
   	err = fread(buf+sizeof(int),1,*nbytes,fp);
   }
   if (err<0){
      if (*res) GDKfree(*res);
      return throwMessage("io.fread"," failed");
   }
   (**res).nitems= err;
   return MAL_SUCCEED;
}

str io_fwrite_str(int *ret, fstream *filepp, str *buf, int *nbytes ){
   FILE *fp = *(FILE**) filepp; 
   int n = strlen(*buf); 
   (void) ret; /* fool compiler */
   fileCheck(fp);
   if (*nbytes < n) n = *nbytes;
   if (fwrite(*buf,1,n,fp) < (size_t) n) {
      return throwMessage("io.fwrite_str"," failed");
   }
   return MAL_SUCCEED;
}

str io_fwrite(int *ret, fstream *filepp, blob **b, int *nbytes ){
   FILE *fp = *(FILE**) filepp; 
   int n = *nbytes;
   str buf = (str) *b;
   (void) ret; /* fool compiler */
   fileCheck(fp);
   if (n> (**b).nitems) {
	n = MAX(0,(**b).nitems);
	GDKerror("io_fwrite:blob contains only %d bytes.\n", (**b).nitems);
   }
   if (fwrite(buf+sizeof(int),1,n,fp) < (size_t) n) {
      return throwMessage("io.fwrite"," failed");
   }
   return MAL_SUCCEED;
}

str io_fseek(int *res, fstream *filepp, int *pos, int *nbytes ){
   FILE *fp = *(FILE**) filepp; 
   fileCheck(fp);
   *res = fseek(fp, (long)*pos, *nbytes);
   if (*res < 0) {
      return throwMessage("io.fseek"," failed");
   }
   return MAL_SUCCEED;
}

str io_ftell(int *res, fstream *filepp ){
   FILE *fp = *(FILE**) filepp; 
   fileCheck(fp);
   *res = ftell(fp);
   if (*res < 0) {
      throwMessage("io.ftell"," failed");
   }
   return MAL_SUCCEED;
}

str io_fsize(int* res, str *filename){
#ifdef HAVE_FSTAT
	struct stat buf;
	if (stat(*filename,&buf))
		*res = -1;
	else
		*res = (int)buf.st_size;
#else
        *res = -1;
#endif
	return MAL_SUCCEED;
}


str io_fprintf(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
   (void) mb;(void) stk; (void)pci; /* fool compiler */
	return throwMessage("io.fprintf"," not yet defined in version-5\n");
}
/*
int io_fprintf(fstream *filepp, str format,  ...){
        va_list ap;
        int ret;
        str s;
 
	fileCheck(*filepp);
        va_start(ap,format);
        ret = monet_sprintf(&s, format, ap);
        va_end(ap);
        if (ret == 0) {
                return throwMessage("io.printf","failed");
        }
        if (fputs(s, *filepp) < 0) {
                GDKfree(s);
                return throwMessage("io.fprintf","failed");
        }
	GDKfree(s);
        return MAL_SUCCEED;
}
*/

str io_fprint(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	(void) mb;(void) stk; (void)pci; /* fool compiler */
	GDKwarning("io_fprint:not defined in version-5\n");
        return MAL_SUCCEED;
}
/*
int io_fprint(fstream *filepp, ...){
        va_list ap;
        ptr val; 
	int type;
 
	fileCheck(*filepp);
        va_start(ap,filepp);

	val = va_arg (ap,ptr);
        if(val){
		type = va_arg(ap,int);
		if (ATOMstorage(type) != TYPE_str)
			fprintf( *filepp, "%s(\"", ATOMname(type) );
		ATOMprint(type, val, *filepp);
		if (ATOMstorage(type) != TYPE_str)
			fprintf( *filepp, "\")" );
		val = va_arg (ap,ptr);
        	while(val){
			type = va_arg(ap,int);
			if (ATOMstorage(type) != TYPE_str)
				fprintf( *filepp, ", %s(\"", ATOMname(type) );
			else
				fprintf( *filepp, ", ");
			ATOMprint(type, val, *filepp);
			if (ATOMstorage(type) != TYPE_str)
				fprintf( *filepp, "\")" );
			val = va_arg (ap,ptr);
		}
	}
        va_end(ap);
        return MAL_SUCCEED;
}
*/


str io_fputs(int *ret, str *s, fstream *filepp ){
   (void) ret; /* fool compiler */
   fileCheck(*filepp);
   if (fputs(*s,*(FILE**)filepp) < 0) {
      return throwMessage("io.fputs"," failed");
   }
   return MAL_SUCCEED;
}

str io_fputc(int *ret,int *c, fstream *filepp ){
   FILE *fp = *(FILE**) filepp; 
   (void) ret; /* fool compiler */
   fileCheck(fp);
   if (fputc(*c, fp) < 0)
      return throwMessage("io.fputs"," failed");
   return MAL_SUCCEED;
}

str io_fgets( str *s, fstream *filepp ){
   FILE *fp = *(FILE**) filepp; 
   fileCheck(fp);
   *s = GDKmalloc( BUFSIZ );
   **s = 0;
   if (fgets(*s, BUFSIZ, fp) <= (char *) 0) {
      if (feof(fp)){
        **s = 0;
      	return MAL_SUCCEED;
      }
      return throwMessage("io.fgets"," failed");
   }
   return MAL_SUCCEED;
}

str io_fgetc( chr *c, fstream *filepp ){
   FILE *fp = *(FILE**) filepp; 
   int ret;
   fileCheck(fp);
   ret = (int)fgetc(fp);
   if (ret <= 0) 
      return throwMessage("io.fgetc"," failed");
   *c = ret;
   return MAL_SUCCEED;
}

@+ Printing
The print commands are implemented as single instruction rules,
because they need access to the calling context.
At a later stage we can look into the issues related to
parsing the format string as part of the initialization phase.
The old method in V4 essentially causes a lot of overhead
because you have to prepare for the worst (e.g. mismatch format
identifier and argument value)
Beware, the types of the objects to be printed should be
obtained from the stack, because the symbol table may actually
allow for any type to be assigned.
@c
str IOprintBoth(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci,int indx,str hd, str tl)
{
	int tpe = getArgType(mb,pci,indx);
	ptr val = (ptr) getArgReference(stk,pci,indx);
        stream *fp = GDKout;
	if( tpe == TYPE_any)
		tpe= stk->stk[pci->argv[indx]].vtype;
	(void)mb;
	if( val==NULL) {
		if(hd) stream_printf(fp,"%s",hd);
		ATOMprint(TYPE_str, "nil", GDKout);
		if(tl) stream_printf(fp,"%s",tl);
		return MAL_SUCCEED;
	}
	if( isaBatType(tpe) || tpe== TYPE_bat){
		BAT *b;
		if( *(int*)val ==0){
			if(hd) stream_printf(fp,"%s",hd);
			ATOMprint(TYPE_str, "nil", GDKout);
			if(tl) stream_printf(fp,"%s",tl);
			return MAL_SUCCEED;
		}
		b = BATdescriptor(*(int*)val);
		if( b== NULL) {
			return throwMessage("io.print","could not access descriptor");
		}
		/* BATprint(b);*/
		BATmultiprintf(GDKout,2,&b,TRUE,0);
		BBPunfix(b->batCacheid);
		return MAL_SUCCEED;
	}
        if(hd) stream_printf(fp,"%s",hd);
	if( ATOMstorage(tpe) == TYPE_str  || ATOMstorage(tpe)> TYPE_str)
		ATOMprint(tpe, *(str*)val, fp);
        else  	ATOMprint(tpe, val, fp);
        if(tl) stream_printf(fp,"%s",tl);
	stream_flush(fp);
        return MAL_SUCCEED;
}
str IOprint_val(MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
        int i;
        if( p->argc==2)
                IOprintBoth(mb,stk,p,1,"[ "," ]\n");
        else {
                IOprintBoth(mb,stk,p,1,"[ ",0);
                for(i=2; i<p->argc-2;i++)
                        IOprintBoth(mb,stk,p,i,", ",0);
                IOprintBoth(mb,stk,p,i,", ", "]\n");
        }
        return MAL_SUCCEED;

}
str IOprint_tables(MalBlkPtr mb, MalStkPtr stk, InstrPtr p){
        IOtableAll(GDKout,mb,stk,p,1,0,FALSE);
        return MAL_SUCCEED;
}

str IOprompt_val(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	return IOprintBoth(mb,stk,pci,1,0,0);
}
str IOprint_ft(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int tpe = getArgType(mb,pci,1);
	ptr val = (ptr) getArgReference(stk,pci,1);
	if( val==NULL) {
		ATOMprint(TYPE_str, "nil", GDKout);
		return MAL_SUCCEED;
	}
	if( tpe == TYPE_str)
		ATOMprint(TYPE_str, *(str*)val, GDKout);
	else ATOMprint(tpe, val, GDKout);
	stream_flush(GDKout);
	return MAL_SUCCEED;
}

@-
The table printing routine implementations rely on the multiprintf.
They merely differ in destination and order prerequisite
@c
str IOtableAll(stream *f, MalBlkPtr mb, MalStkPtr stk, 
		  InstrPtr pci, int i, int order, int printhead)
{
        BAT *piv[MAXPARAMS],*b;
        int nbats = 0;
	int tpe,k=i;
	ptr val;
	for(; i< pci->argc;i++) {
		tpe = getArgType(mb,pci,i);
		val = (ptr) getArgReference(stk,pci,i);
		if( !isaBatType(tpe)) 
			return throwMessage("io.table","BAT expected");
		b= BATdescriptor(*(int*)val);
		if(b == NULL) {
		for(k=0; k< nbats;k++) BBPunfix(piv[k]->batCacheid);
		return throwMessage("io.table","could not access descriptor");
		}
                piv[nbats++] = b;
        } 
	/*if(printhead)*/ nbats++;
        BATmultiprintf(f, nbats, piv, printhead, order);
	stream_flush(f);
	for(k=0; k< nbats-1;k++) BBPunfix(piv[k]->batCacheid);
        return MAL_SUCCEED;
}

str IOotable( MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	int order;
	order = *(int*) getArgReference(stk,pci,1);
	return IOtableAll(GDKout,mb,stk,pci,2,order,TRUE);
}

str IOtable( MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	return IOtableAll(GDKout,mb,stk,pci,1,0,TRUE);
}
str IOfotable( MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	stream *fp;
	int order;

	fp= *(stream **) getArgReference(stk,pci,1);
	order = *(int*) getArgReference(stk,pci,2);
	(void) order; /* fool compiler */
	return IOtableAll(fp,mb,stk,pci,3,1,TRUE);
}

str IOftable( MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	stream *fp;
	fp= *(stream **) getArgReference(stk,pci,1);
	return IOtableAll(fp,mb,stk,pci,2,0,TRUE);
}
str IOttable( MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	return IOtableAll(GDKout,mb,stk,pci,1,0,FALSE);
}
str IOtotable( MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	int order;
	order = *(int*) getArgReference(stk,pci,1);
	(void) order; /* fool compiler */
	return IOtableAll(GDKout,mb,stk,pci,1,0,FALSE);
}

@- Formatter print
The format string is scrutinized using VALsprintf in the GDK library
to avoid that passing a wrong argument (e.g. NULL pointer) kills the server.
The generic printf function is rather expensive. Ideally it should be
replaced by a squeezer into a type-specific function calls.
@-
Formatted print statements are to be broken down into its constituents.
This avoids repeated type checking in most cases.

@= escaped
	switch(*c){
	case 'n': *ret =  stream_printf(fd,"\n");break;
	case 't': *ret =  stream_printf(fd,"\t");break;
	case 'r': *ret =  stream_printf(fd,"\r");break;
	case '\\': *ret =  stream_printf(fd,"\\");break;
	default : *ret = stream_printf(fd,"\\");stream_printf(fd,"%c",*c);
	}
@c
str IOprint_str(int *ret, str *s){
	stream *fd = GDKout; 
	str c;
	if( strNil(*s)) stream_printf(fd,"nil");
	else {
		for(c= *s;*c; c++){
			if( *c=='\\'){
				c++;
				@:escaped@
			} else stream_printf(fd,"%c",*c);
		}
	}
	return MAL_SUCCEED;
}
int formatMarker(str format){
	int i=0;
	str t=format;
	while( (t=strchr(t,'%')) != NULL){
		t++;
		i++;
	}
	return i;
}
@-
Printing format values is limited to a single element each.
This to simplify error handling
@= formatConversion
	for(c= format;*c; c++){
		if( *c=='\\'){
			c++;
			@:escaped@
		} else 
		if( *c== '%'){
			char newformat[1024];
			int i=0;

			if(*(c+1)=='%'){ 
				stream_printf(fd,"%c",*c);
				c++; continue;
			}
			while(*c != '@1' && *c && i<1024)
				 newformat[i++]= *c++;
			newformat[i++]='@1';
			newformat[i]=0;
			if(*c!= '@1') 
			return throwMessage("system.print", " format limitation");
			else  stream_printf(fd,newformat,@2);
		} else stream_printf(fd,"%c",*c);
	}
@-

@= printFormatted
str IOprint_formatted_@1(int *ret, ptr fmt, @1 *s){
	stream *fd = getClient()->fdout;
	char *format;
	str c;
	/* TODO: check format properly !!! including sizes */
	format= *(str *)fmt;
	if( format== NULL) 
		return throwMessage("system.print", "format missing");
	if( formatMarker(format)!=1) 
		return throwMessage("system.print", "too many %%");

	if( *s == @1_nil) return IOprint_formatted_nil(fd,* (str*) fmt, ret);
	@:formatConversion(@2,*s)@
	return MAL_SUCCEED;
}
@-
String nil testing is slightly different.
@c
str IOprint_formatted_nil(stream *fd, str format, int *ret){
	str c;
	for(c= format;*c; c++){
		if( *c=='\\'){
			c++;
			@:escaped@
		} else 
		if( *c== '%'){
			char newformat[1024];
			int i=0;

			if(*(c+1)=='%'){ 
				stream_printf(fd,"%c",*c);
				c++; continue;
			}
			while( !isalpha((int)*c) && *c && i<1024)
				 newformat[i++]= *c++;
			newformat[i++]='s';
			newformat[i]=0;
			stream_printf(fd,newformat,"nil");
		} else stream_printf(fd,"%c",*c);
	}
	return MAL_SUCCEED;
}
str IOprint_formatted_str(int *ret, ptr fmt, str *s){
	stream *fd = getClient()->fdout;
	char *format;
	str c;
	/* TODO: check format properly !!! including sizes */
	format= *(str *)fmt;
	if( format== NULL) 
		return throwMessage("system.print", "format missing");
	if( formatMarker(format)!=1) 
		return throwMessage("system.print", "too many %%");

	if( strNil( *s)) return IOprint_formatted_nil(fd,* (str*) fmt, ret);
	@:formatConversion(s,*s)@
	return MAL_SUCCEED;
}
str IOprint_oid(int *ret, ptr fmt, oid *s){
	stream *fd = getClient()->fdout;
	char *format;
	str msg,c;
	int len =50;
	format= *(str *)fmt;

	if( format== NULL) 
		return throwMessage("system.print", "format missing");
	if( formatMarker(format)!=1) 
		return throwMessage("system.print", "too many %%");

	if( *s == oid_nil) msg = GDKstrdup("nil");
	else { msg = (str) GDKmalloc(len); OIDtoStr(&msg,&len,s);}
	@:formatConversion(s,msg)@
	GDKfree(msg);
	if(*ret == EOF)
		return throwMessage("system.print", "end-of-file error");
	return MAL_SUCCEED;
}
str IOprint_formatted_bit(int *ret, ptr fmt, bit *s){
	stream *fd = getClient()->fdout;
	char *format;
	str msg;
	str c;
	/* TODO: check format properly !!! including sizes */
	format= *(str *)fmt;
	if( format== NULL) 
		return throwMessage("system.print", "format missing");
	if( formatMarker(format)!=1) 
		return throwMessage("system.print", "too many %%");

	if( *s == bit_nil) msg = "nil";
	else if( *s ) msg="true";
	else 	msg="false";
	@:formatConversion(s,msg)@
	if(*ret == EOF)
		return throwMessage("system.print", "end-of-file error");
	return MAL_SUCCEED;
}

 	@:printFormatted(chr,c)@
 	@:printFormatted(sht,d)@
 	@:printFormatted(int,d)@
 	@:printFormatted(lng,d)@
 	@:printFormatted(flt,f)@
 	@:printFormatted(dbl,f)@
@-
@+ Bulk export/loading
To simplify conversion between versions and to interface with other
applications, we use a simple import/export operation.

The conversion routine assumes space in the buffer for storing the result.
@{
@c
@-
A BAT can be saved in Monet format using the export command.
It is of particular use in preparing an ascii version for migration.
The exported file is saved in the context of the directory
where the server was started unless an absolute file name was
presented.
@c
str IOexport(int *ret, int *bid, str *fnme) {
	BAT *b;
	stream  *s = open_wastream(*fnme);
	@:getBATdescriptor(ret,bid,b,export)@
	if (s== NULL || stream_errnr(s) ) {
		*ret = FALSE;
		return throwException(MALEXCEPTION,"bat.export",
			"could not open %s",*fnme);
	}
	BATprintf(s,b);
	stream_close(s);
	stream_destroy(s);
	*ret = TRUE;
	return MAL_SUCCEED;
}

@
The import command reads a single BAT from an ascii file. It assumes
a layout compatible with that produced by print or export.
                                                                                 
@= getBATdescriptor
        if( BBPcheck(*@2,"@4")==0)
                return throwMessage("bat.@4",
                        "cannot access bat @2 in bbp");
        if( *@2 < 0) {
                /* reverse descriptor should be explicitly loaded */
                @3=BATdescriptor(*@2); BBPunfix(*@2);
        } else @3= (BAT*) BBPgetdesc(*@2);
        if( @3 == NULL) { *@1 = 0;
                return throwMessage("bat.@4",
                        "cannot access descriptor @2");
        }
@c
str IOimport(int *ret, int *bid, str *fnme) {
	BAT *b;
	int	(*hconvert)(str, int*, ptr*), (*tconvert)(str, int*, ptr*);
	size_t	bufsize = 2048; /* NIELS:tmp change used to be 1024 */
	char	*base, *cur, *end;
	char	*buf = (char *) GDKmalloc(bufsize);
	ptr	*h = 0, *t = 0;
	int	lh = 0,	lt = 0;
	FILE	*fp = fopen(*fnme, "r");

	@:getBATdescriptor(ret,bid,b,export)@
	hconvert = BATatoms[BAThtype(b)].atomFromStr;
	tconvert = BATatoms[BATttype(b)].atomFromStr;
@-
Open the file. Memory map it to minimize buffering problems.
@c
        if (fp == NULL)
	return throwException(MALEXCEPTION,"bat.import",
		"could not open file %s",fnme);
	else {
		int fn;
	    	struct stat st;
                if ((fn=fileno(fp)) <= 0) {
                        return throwMessage("IOimport","fileno fails\n");
                }
                if (fstat(fn, &st) != 0) {
                        return throwMessage("IOimports","fstat fails\n");
                }

		(void)fclose(fp);
		if (st.st_size <= 0)
                        return throwMessage("IOimports",
				"file empty or fstat broken?\n");
            	base = cur = (char*)MT_mmap(*fnme, MMAP_SEQUENTIAL, 0, st.st_size, NULL);
		end = cur + st.st_size;
                if (cur == (char*) -1) {
                        return throwMessage("IOimport", "MT_mmap failed\n");
                }

	}
@-
Parse a line. Copy it into a buffer. Concat broken lines with a slash.
@c
	while(cur < end) {
		str dst = buf, src = cur, p = strchr(cur, '\n');
		size_t l = p - cur;

		if (!p) {
			p = end;
		} else while(src[l-1] == '\\') {
			@:memcpy@
			dst += l-1; src += l+1;
			if ((p = strchr(src, '\n')) == 0) {
				p = end; break;
			}
			l = p - src;
		}
		@:memcpy@
@-
@= memcpy
		if (buf+bufsize < dst+l) {
		        int len = dst - buf;
			size_t inc = (size_t) ((dst+l) - buf);
			buf = (char*) GDKrealloc((void*) buf, bufsize = MAX(inc,bufsize)*2);
			dst = buf + len;
		}
		memcpy(dst, src, l-1);
@c
		dst[l] = 0;
		cur = p+1;
@-
Parse the line, and insert a BUN.
@c
		for(p = buf; *p && GDKisspace(*p); p++);
		if (*p == '#') continue;
@-
@= parsevalue
	       	for (;*p && ((int) *p) != @2; p++);
		if (*p) for (p++; *p && GDKisspace(*p); p++);
       		if (*p == 0){
			*ret= FALSE;
		       	return throwException(MALEXCEPTION,"bat.import",
				"error in %s",buf);
       		}
       		p += @1(p, @3, @4);			
@c
		@:parsevalue(hconvert, '[', &lh, (ptr *) &h)@
		@:parsevalue(tconvert, 44, &lt, (ptr *)&t)@
		BUNins(b, h, t);
		
@-
Unmap already parsed memory, to keep the memory usage low.
@c
#ifndef WIN32
#define MAXBUF 40*MT_pagesize()
		if ( (unsigned)(cur - base) > MAXBUF) {
			MT_munmap(base, MAXBUF);
			base += MAXBUF;
		}
#endif
	}
@-
Cleanup and exit. Return the filled BAT.
@c
	if (h) GDKfree(h);
	if (t) GDKfree(t);
	GDKfree(buf);
	MT_munmap(base, end-base);
	BBPfix(b->batCacheid);
	*ret = TRUE;
	return MAL_SUCCEED;
}

@}
