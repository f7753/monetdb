@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2003 CWI.
@' All Rights Reserved.
@'
@' Contributor(s):
@'              Martin Kersten <Martin.Kersten@cwi.nl>
@'              Peter Boncz <Peter.Boncz@cwi.nl>
@'              Niels Nes <Niels.Nes@cwi.nl>
@'              Stefan Manegold  <Stefan.Manegold@cwi.nl>

@f io
@t The io Module
@a N.J. Nes, M.L. Kersten
@d 01/07/1996, 31/01/2002

@+ Introduction
@T
This module contains all the file access commands. The implementation
is very simple. All function call the stdio library function.

This module is seperated from the database kernel since some 
servers are not allowed to do file accesses.

{\tt fopen()} opens the file named by filename  and  associates  a
fstream  with  it. {\tt fopen()}  returns  a  pointer to the FILE
structure associated with the fstream. The resulting pointer is needed
by all other io function. So fopen should be called before any other 
function. 

The {\tt fclose()} command closes the associated fstream. The FILE pointer 
given can not be used after calling this function. 

Pipes can be created with {\tt popen()}. This function returns the
identifier to a bidirectional pipe. You can then for instance {\tt fork()}
a new Monet session, passing this identifier.

Both sessions can then use the pipe to open a fstream with {\tt fdpipe()}.
The one end should pass {\tt true} as the {\tt up} parameter, the other
{\tt down}. This function returns a fstream, and can be used in combination
with any of the functions of this module.

The {\tt fflush()} command flushes the buffer of the associated fstream.

{\tt feof()} returns non-zero when EOF has previously been
detected reading the named input fstream, otherwise zero.

{\tt freopen()} substitutes the named file in place  of  the  open
fstream. A flush is first attempted, and then the original
fstream is closed, regardless of whether the open ultimately
succeeds. Failure to flush or close fstream successfully is
ignored. It returns the new FILE pointer.

The {\tt fread()} and {\tt fwrite()} commands read/write a number of bytes 
to or from a associated fstream. The read function returns a string 
containing the result. The write function returns the number of written bytes. 

The {\tt fseek()} function seeks an offset number of bytes form the start, the 
current position, or the end of the fstream.
\footnote{See the mil script file for the correct constants.}
This function returns the number of bytes moved. 

The {\tt fprintf()} function print a variable number of 
arguments using the format string. They return the number of arguments 
printed. 

The {\tt fputs()} places a string on the given output fstream. 
{\tt fgets()} reads a string until an end of line is found form the 
given input fstream. 

Look at the related ANSI-C/POSIX manual pages to get the needed information.
This module uses the blob atom.
@* Module Definition
@mal
atom module fstream : ptr
comment "Mapping to the FILE descriptor on the Unix platforms.
Should be replaced by the stream package primitives on NT";

atom module bipipe : lng;
command popen( ) : bipipe = io_popen 
comment "Open a bidirectional pipe. See: man pipe" ;
command fdpipe(b:bipipe, up:bit, mode:str) : fstream = io_fdpipe 
comment "Open a fstream in one direction through a pipe." ;

module io;
command fopen ( filename:str, mode:str ) : fstream = io_fopen 
comment "See: man fopen. Returns fstream, or fstream(nil) on failure.";
command freopen ( filename:str, mode:str, f:fstream ) : fstream = io_freopen 
comment "See: man freopen. Returns fstream, or fstream(nil) on failure.";
command fsize( filename:str ) : int = io_fsize 
comment "Return the filesize, or -1 when there was some error";
command ferror() : str = io_ferror 
comment "returns last error message. str(nil) if none. ";

command fclose( f:fstream ):void = io_fclose comment "See: man fclose";
command fflush( f:fstream ):void = io_fflush comment "See: man fflush";
command feof( f:fstream ) : bit = io_feof comment "See: man feof";
command fread( filep:fstream, nbytes:int ) : blob = io_fread 
comment "See: man fread";
command fwrite( filep:fstream, buf:str, nbytes:int ):void = io_fwrite_str 
comment "See: man fwrite";
command fwrite( filep:fstream, buf:blob, nbytes:int ):void = io_fwrite 
comment "See: man fwrite";
command fseek( filep:fstream, pos:int, offset:int ) : int = io_fseek 
comment "See: man fseek";
command ftell( filep:fstream ) : int = io_ftell 
comment "See: man ftell";

command fputs( s:str, filep:fstream):void = io_fputs comment "See: man fputs";
command fgets( filep:fstream ): str = io_fgets comment "See: man fgets";

command fputc( c:int, filep:fstream ):void = io_fputc comment "See: man fputs";
command fgetc( filep:fstream ): chr = io_fgetc comment "See: man fgetc";

@+ Printing 
The polymorphic print commands are collected here.
Watch out, the order of definitions is crucial, because the most
specific should be introduced last.
@mal

pattern print(b1:bat[ANY::1,ANY], b2:bat[ANY::1,ANY]...):int = CMDtable
 comment "BATs are printed with '#' for legend lines, and the BUNs on seperate
 lines between brackets, containing each to comma separated values
 (head and tail).
 If multiple BATs are passed for printing, print() performs an implicit
 natural join, producing a multiattribute table.";

pattern ftable( filep:fstream, b1:bat[any::1,any], b:BAT[any::1,any]... ):int
= CMDftable comment "Print an n-ary table to a file.";

pattern print(order:int,b:bat[ANY::1,ANY], b2:bat[ANY::1,ANY]...):int
                                                = CMDotable
 comment "The same as normal table print, but enforces to use the order of
  BAT number [1..argc] to do the printing.";

pattern table(b1:bat[any::1,any], b2:bat[any::1,any]...):int = CMDttable
	comment "Print an n-ary table. Like print(n-ary) but does not print oid column";

pattern table(order:int, b1:bat[any::1,any], b2:bat[any::1,any]...):int 
	= CMDtotable
	comment "Print an n-ary table. Use the ordering of param [1..argc]";
pattern ftable(fp:fstream, order:int,b1:bat[any::1,any], b:BAT[any::1,any]...)
	= CMDfotable 
comment "Print an n-ary table to a file, using order of BAT [1..argc].";

pattern print(val:any):int = CMDprint_val
	comment "Print a MIL value between square brackets.";

pattern prompt(val:any):int = CMDprompt_val
	comment "Print a MIL value without square brackets.";
pattern printft(val:any):int = CMDprint_ft
	comment "Select default format ";

pattern fprint( filep:fstream , arg:any... ):void = io_fprint 
comment "Print a (comma seperated) list of arguments";

pattern fprintf( filep:fstream, format:str, arg:any... ):void = io_fprintf 
comment "See: man fprintf";


@- MIL initializations 
The constants for the seek function.
@* Example Script
@mil
        const EOF      := -1;
        const SEEK_SET := 0;
        const SEEK_CUR := 1;
        const SEEK_END := 2;
setoid(oid(20000000));
module(io);

fp := fopen ( "test", "w+" );
fwrite( fp, "Dit is een test\n", 17 );
fp := freopen ( "test", "r+", fp );
fread( fp, 17 ).tostr.print;

fseek( fp, 0, 0);
fprintf( fp, "%s %d %c %d %f\n", "test", 10, 'c', 10, 7.0 );

s := "testing again and again\n";

fseek( fp, 0, 0);
fputs( s, fp );
fseek( fp, 0, 0);
s := fgets( fp );

fflush( fp );
fclose( fp );
printf( "%s %d %c %d %f\n", "test", 10, 'c', 10, 7.0 );
printf( "%s\n", s );

quit;
@{
@* Implementation Code

@h
#ifndef _IO_H_
#define _IO_H_

#include <stdio.h>
#include <stdarg.h>
#include "blob.h"
#include "mal.h"
#include "mal_interpreter.h"

extern str CMDtableAll(stream *f, MalBlkPtr mb, MalStkPtr stk, 
		  InstrPtr pci, int i, int order, int printhead);
extern str CMDprintBoth(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci,int indx,str hd, str tl);

typedef struct {
	int up, down;
} bipipe;

typedef FILE* fstream;

#define fileCheck(fp) if (!fp) \
	return throwMessage( "io.@1","Incorrect file pointer"); 


#endif /* _IO_H_ */

@c
#include "io.h"

str io_fclose(int *ret, fstream* filepp ){
   FILE *fp = *(FILE**) filepp; 
   (void) ret; /* fool compiler */
   fileCheck(fp)
   if (fclose(fp) < 0) {
	return throwMessage("io.fclose"," failed");
   }
   return MAL_SUCCEED;
}

str io_fflush(int *ret, fstream *filepp ){
   FILE *fp = *(FILE**) filepp; 
   (void) ret; /* fool compiler */
   fileCheck(fp);
   (void)fflush(fp);
   return MAL_SUCCEED;
}

str io_popen(bipipe **retval){
   if(*retval) GDKfree(*retval);
   *retval= (bipipe*) GDKmalloc(sizeof(bipipe));
   if (pipe((int*) *retval) < 0)
	return throwMessage("io.popen"," failed");
   return MAL_SUCCEED;
}
str io_fdpipe(fstream *retval, bipipe* p, bit *up, str *mode){
   *retval = (fstream) fdopen(up?p->up:p->down, *mode);
   if (*retval == 0) return MAL_SUCCEED;
   return throwMessage("io.fdpipe"," failed");
}

str io_feof( bit *res, fstream *filepp ){
   FILE *fp = *(FILE**) filepp; 
   fileCheck(fp);
   *res = feof(fp)?TRUE:FALSE;
   return MAL_SUCCEED;
}

str io_fopen( fstream *res, str *name, str *mode ){
   *res = fopen(*name,*mode);
   if (!*res) *res = *(fstream*) ATOMnilptr(TYPE_ptr);
   return MAL_SUCCEED;
}

str io_freopen( fstream *res, str *name, str *mode, fstream *filepp ){
   FILE *fp = *(FILE**) filepp; 
   fileCheck(fp);
   *res = freopen(*name,*mode,fp);
   if (!*res) *res = *(fstream*) ATOMnilptr(TYPE_ptr);
   return MAL_SUCCEED;
}

str io_ferror( str *msg) {
   int r = MT_geterrno();
   if (r) {
    	*msg = GDKstrdup(strerror(r));
   } else { 
	*msg = str_nil;
   }
   return MAL_SUCCEED;
}

str io_fread( blob **res, fstream *filepp, int *nbytes ){
   FILE *fp = *(FILE**) filepp; 
   int err = -1;
   str buf;
   fileCheck(fp);
   buf = (str) GDKmalloc( sizeof(int) + *nbytes );
   if ((*res = (blob*) buf) != NULL){
   	err = fread(buf+sizeof(int),1,*nbytes,fp);
   }
   if (err<0){
      if (*res) GDKfree(*res);
      return throwMessage("io.fread"," failed");
   }
   (**res).nitems= err;
   return MAL_SUCCEED;
}

str io_fwrite_str(int *ret, fstream *filepp, str *buf, int *nbytes ){
   FILE *fp = *(FILE**) filepp; 
   int n = strlen(*buf); 
   (void) ret; /* fool compiler */
   fileCheck(fp);
   if (*nbytes < n) n = *nbytes;
   if (fwrite(*buf,1,n,fp) < (size_t) n) {
      return throwMessage("io.fwrite_str"," failed");
   }
   return MAL_SUCCEED;
}

str io_fwrite(int *ret, fstream *filepp, blob **b, int *nbytes ){
   FILE *fp = *(FILE**) filepp; 
   int n = *nbytes;
   str buf = (str) *b;
   (void) ret; /* fool compiler */
   fileCheck(fp);
   if (n> (**b).nitems) {
	n = MAX(0,(**b).nitems);
	GDKerror("io_fwrite: blob contains only %d bytes.\n", (**b).nitems);
   }
   if (fwrite(buf+sizeof(int),1,n,fp) < (size_t) n) {
      return throwMessage("io.fwrite"," failed");
   }
   return MAL_SUCCEED;
}

str io_fseek(int *res, fstream *filepp, int *pos, int *nbytes ){
   FILE *fp = *(FILE**) filepp; 
   fileCheck(fp);
   *res = fseek(fp, (long)*pos, *nbytes);
   if (*res < 0) {
      return throwMessage("io.fseek"," failed");
   }
   return MAL_SUCCEED;
}

str io_ftell(int *res, fstream *filepp ){
   FILE *fp = *(FILE**) filepp; 
   fileCheck(fp);
   *res = ftell(fp);
   if (*res < 0) {
      throwMessage("io.ftell"," failed");
   }
   return MAL_SUCCEED;
}

str io_fsize(int* res, str *filename){
#ifdef HAVE_FSTAT
	struct stat buf;
	if (stat(*filename,&buf))
		*res = -1;
	else
		*res = (int)buf.st_size;
#else
        *res = -1;
#endif
	return MAL_SUCCEED;
}


str io_fprintf(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
   (void) mb;(void) stk; (void)pci; /* fool compiler */
	return throwMessage("io.fprintf"," not yet defined in version-5\n");
}
/*
int io_fprintf(fstream *filepp, str format,  ...){
        va_list ap;
        int ret;
        str s;
 
	fileCheck(*filepp);
        va_start(ap,format);
        ret = monet_sprintf(&s, format, ap);
        va_end(ap);
        if (ret == 0) {
                return throwMessage("io.printf","failed");
        }
        if (fputs(s, *filepp) < 0) {
                GDKfree(s);
                return throwMessage("io.fprintf","failed");
        }
	GDKfree(s);
        return MAL_SUCCEED;
}
*/

str io_fprint(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	(void) mb;(void) stk; (void)pci; /* fool compiler */
	GDKwarning("io_fprint: not defined in version-5\n");
        return MAL_SUCCEED;
}
/*
int io_fprint(fstream *filepp, ...){
        va_list ap;
        ptr val; 
	int type;
 
	fileCheck(*filepp);
        va_start(ap,filepp);

	val = va_arg (ap,ptr);
        if(val){
		type = va_arg(ap,int);
		if (ATOMstorage(type) != TYPE_str)
			fprintf( *filepp, "%s(\"", ATOMname(type) );
		ATOMprint(type, val, *filepp);
		if (ATOMstorage(type) != TYPE_str)
			fprintf( *filepp, "\")" );
		val = va_arg (ap,ptr);
        	while(val){
			type = va_arg(ap,int);
			if (ATOMstorage(type) != TYPE_str)
				fprintf( *filepp, ", %s(\"", ATOMname(type) );
			else
				fprintf( *filepp, ", ");
			ATOMprint(type, val, *filepp);
			if (ATOMstorage(type) != TYPE_str)
				fprintf( *filepp, "\")" );
			val = va_arg (ap,ptr);
		}
	}
        va_end(ap);
        return MAL_SUCCEED;
}
*/


str io_fputs(int *ret, str *s, fstream *filepp ){
   (void) ret; /* fool compiler */
   fileCheck(*filepp);
   if (fputs(*s,*(FILE**)filepp) < 0) {
      return throwMessage("io.fputs"," failed");
   }
   return MAL_SUCCEED;
}

str io_fputc(int *ret,int *c, fstream *filepp ){
   FILE *fp = *(FILE**) filepp; 
   (void) ret; /* fool compiler */
   fileCheck(fp);
   if (fputc(*c, fp) < 0)
      return throwMessage("io.fputs"," failed");
   return MAL_SUCCEED;
}

str io_fgets( str *s, fstream *filepp ){
   FILE *fp = *(FILE**) filepp; 
   fileCheck(fp);
   *s = GDKmalloc( BUFSIZ );
   **s = 0;
   if (fgets(*s, BUFSIZ, fp) <= (char *) 0) {
      if (feof(fp)){
        **s = 0;
      	return MAL_SUCCEED;
      }
      return throwMessage("io.fgets"," failed");
   }
   return MAL_SUCCEED;
}

str io_fgetc( chr *c, fstream *filepp ){
   FILE *fp = *(FILE**) filepp; 
   int ret;
   fileCheck(fp);
   ret = (int)fgetc(fp);
   if (ret <= 0) 
      return throwMessage("io.fgetc"," failed");
   *c = ret;
   return MAL_SUCCEED;
}

@+ Printing
The print commands are implemented as single instruction rules,
because they need access to the calling context.
At a later stage we can look into the issues related to
parsing the format string as part of the initialization phase.
The old method in V4 essentially causes a lot of overhead
because you have to prepare for the worst (e.g. mismatch format
identifier and argument value)
@c
str CMDprintBoth(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci,int indx,str hd, str tl)
{
	int tpe = getArgType(mb,pci,indx);
	ptr val = (ptr) getArgReference(stk,pci,indx);
        stream *fp = GDKout;
	if( val==NULL) {
		ATOMprint(TYPE_str, "nil", GDKout);
		return MAL_SUCCEED;
	}
	if( isaBatType(tpe)){
		BAT *b = BATdescriptor(*(int*)val);
		if( b== NULL) {
			return throwMessage("io.print","could not access descriptor");
		}
		/* BATprint(b);*/
		BATmultiprintf(GDKout,2,&b,TRUE,0);
		BBPunfix(b->batCacheid);
		return MAL_SUCCEED;
	}
        if(hd) stream_printf(fp,"%s",hd);
	if( ATOMstorage(tpe) == TYPE_str  || ATOMstorage(tpe)> TYPE_str)
		ATOMprint(tpe, *(str*)val, fp);
        else  	ATOMprint(tpe, val, fp);
        if(tl) stream_printf(fp,"%s",tl);
	stream_flush(fp);
        return MAL_SUCCEED;
}
str CMDprint_val(MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
        int i;
        if( p->argc==2)
                CMDprintBoth(mb,stk,p,1,"[ "," ]\n");
        else {
                CMDprintBoth(mb,stk,p,1,"[ ",0);
                for(i=2; i<p->argc-2;i++)
                        CMDprintBoth(mb,stk,p,i,", ",0);
                CMDprintBoth(mb,stk,p,i,", ", "]\n");
        }
        return MAL_SUCCEED;

}
str CMDprint_tables(MalBlkPtr mb, MalStkPtr stk, InstrPtr p){
        CMDtableAll(GDKout,mb,stk,p,1,0,FALSE);
        return MAL_SUCCEED;
}

str CMDprompt_val(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	return CMDprintBoth(mb,stk,pci,1,0,0);
}
str CMDprint_ft(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int tpe = getArgType(mb,pci,1);
	ptr val = (ptr) getArgReference(stk,pci,1);
	if( val==NULL) {
		ATOMprint(TYPE_str, "nil", GDKout);
		return MAL_SUCCEED;
	}
	if( tpe == TYPE_str)
		ATOMprint(TYPE_str, *(str*)val, GDKout);
	else ATOMprint(tpe, val, GDKout);
	stream_flush(GDKout);
	return MAL_SUCCEED;
}

@-
The table printing routine implementations rely on the multiprintf.
They merely differ in destination and order prerequisite
@c
str CMDtableAll(stream *f, MalBlkPtr mb, MalStkPtr stk, 
		  InstrPtr pci, int i, int order, int printhead)
{
        BAT *piv[MAXPARAMS],*b;
        int nbats = 0;
	int tpe,k=i;
	ptr val;
	for(; i< pci->argc;i++) {
		tpe = getArgType(mb,pci,i);
		val = (ptr) getArgReference(stk,pci,i);
		if( !isaBatType(tpe)) 
			return throwMessage("io.table","BAT expected");
		b= BATdescriptor(*(int*)val);
		if(b == NULL) {
		for(k=0; k< nbats;k++) BBPunfix(piv[k]->batCacheid);
		return throwMessage("io.table","could not access descriptor");
		}
                piv[nbats++] = b;
        } 
	/*if(printhead)*/ nbats++;
        BATmultiprintf(f, nbats, piv, printhead, order);
	stream_flush(f);
	for(k=0; k< nbats-1;k++) BBPunfix(piv[k]->batCacheid);
        return MAL_SUCCEED;
}

str CMDotable( MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	int order;
	order = *(int*) getArgReference(stk,pci,1);
	return CMDtableAll(GDKout,mb,stk,pci,2,order,TRUE);
}

str CMDtable( MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	return CMDtableAll(GDKout,mb,stk,pci,1,0,TRUE);
}
str CMDfotable( MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	stream *fp;
	int order;

	fp= *(stream **) getArgReference(stk,pci,1);
	order = *(int*) getArgReference(stk,pci,2);
	return CMDtableAll(fp,mb,stk,pci,3,1,TRUE);
}

str CMDftable( MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	stream *fp;
	fp= *(stream **) getArgReference(stk,pci,1);
	return CMDtableAll(fp,mb,stk,pci,2,0,TRUE);
}
str CMDttable( MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	return CMDtableAll(GDKout,mb,stk,pci,1,0,FALSE);
}
str CMDtotable( MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	int order;
	order = *(int*) getArgReference(stk,pci,1);
	return CMDtableAll(GDKout,mb,stk,pci,1,0,FALSE);
}

@}
