@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2005 CWI.
@' All Rights Reserved.

@f partitions
@v 0.0
@a M.L.Kersten
@* BAT partition manager
In real-life database applications the BATs tend to grow beyond
the memory size. Although in most situation this does not
provide severe limitations, it helps to be able to see a BAT
as a logical union of BATs. 

For example, the updates of each month could be collected in
separate BATs, while all querying may still focus on the table at large.

A related, but separate issue, is the location of the BAT.

The partition module provides a shared repository of managing
such BAT groups. All elements in a group are assumed 
of type :bat[:void,:any] and the partition represents
a dense oid range. Moreover, all partitions in a group are 
considered pairwise disjoint.


@mal
module partitions;

command open():void
address BPTopen
comment "Locate and open the partition box";
command close():void
address BPTclose
comment "Save and close the partition box ";
command destroy():void
address BPTdestroy
comment "Destroy the partition box";

command take(idx:int):bat[:void,:any]
address BPTtake
comment "Take a partition from the box";

command deposit(b:bat[:void,:any]) :void
address BPTdeposit
comment "Enter a new BAT into the partition box";
command deposit(b:bat[:void,:any$1],p:bat[:void,:any$1]) :void
address BPTdeposit2
comment "Enter a new partition to a group into the partition box";

pattern releaseAll():void
address BPTreleaseAll
comment "Release all partitions in the box";
pattern release(b:bat[:void,:any]) :void
address BPTrelease
comment "Release a single BAT with its partitions from the  box";

pattern toString(idx:int):str
address BPTtoString
comment "Get the string representation of an element in the box";

command discard(name:bat[:void,:any]) :void
address BPTdiscard
comment "Release a BAT variable from the box";

command newIterator()(:int)
address BPTnewIteratorBase
comment "Create an iterator over the partition box";
command hasMoreElements()(:int)
address BPThasMoreElementsBase
comment "Locate next element in the partition box";

command newIterator(b:bat[:void,:any$1]) (:int,:bat[:void,:any$1])
address BPTnewIterator
comment "Create an iterator over the BAT partitions.";

command newIterator(b:bat[:void,:any$1],first:oid,last:oid)
		(:int,:bat[:void,:any$1])
address BPTnewIteratorRng
comment "Create an iterator over the BAT partitions.";

command hasMoreElements(b:bat[:void,:any$1]) (:int, :bat[:void,:any$1])
address BPThasMoreElements
comment "Localize the next partition for processing.";

command hasMoreElements(b:bat[:void,:any$1],first:oid,last:oid) (:int, :bat[:void,:any$1])
address BPThasMoreElementsRng
comment "Localize the next partition for processing.";

command getLastPartition(b:bat[:void,:any$1]):bat[:void,:any$1]
address BPTgetLastPartition
comment "Obtain the last partition for update";

command getRange(b:bat[:void,:any$1])(first:oid,last:oid)
address BPTgetRange
comment "Obtain the oid range for a partition";

command dump()
address BPTdump;

command prelude()
address BPTprelude;

partitions.prelude();
@-
@{

@+ BAT Partition Iterator Implementation
The implementation is organized around a shared box, which should
be saved between session. It is up to other to ensure that BAT
being deleted are also removed from the partition box to avoid
mis-represented information.

The datastructures for the partition table are dynamic arrays
indexed by an integer, which is also returned to the environment
as a handle.
@c
#include "mal.h"
#include "mal_client.h"
#include "mal_interpreter.h"

typedef struct{
	int bid;	/* group bat identifier */
	int pid;	/* group element identifier */
	oid first;	/* lowest oid stored */
	oid last;	/* largest oid stored or nil */
} Partition;

static Partition *partitions;
static int ptop,plimit;

#define INCREMENT 1024
void
BPTresize(int size){
	Partition *p;
	p= GDKmalloc(size * sizeof(Partition));
	if( partitions){
		if( ptop >size) GDKfatal("assertion error in BPTresize");
		memcpy(p, partitions, sizeof(Partition)*ptop);
		GDKfree(partitions);
	} 
	partitions= p;
	partitions[0].bid= -1;
	plimit= size;
}

str BPTdump(){
	stream *fd=GDKout;
	int i;
	stream_printf(fd,"ptop=%d plimit=%d\n",ptop,plimit);
	for(i=0;i<ptop; i++)
	stream_printf(fd,"[%d] bid=%d pid=%d f=%d, l=%d\n",i,
		partitions[i].bid,
		partitions[i].pid,
		partitions[i].first,
		partitions[i].last);
	return MAL_SUCCEED;
}
@- Box administration
The box currently does not carry any client protection.
This should later be added or being provided by the BAT
access.
@c
str
BPTprelude(int *ret){
    Box box;
    box= openBox("partitions");
    if( box== 0)
        return throwMessage("partitions.prelude","failed to open box");
    BPTresize(INCREMENT);
	/* later do a  reload */
	(void) ret;
    return MAL_SUCCEED;
}

str 
BPTopen(){
    if(openBox("partitions") != 0) return MAL_SUCCEED;
    return throwMessage("partitions.open","failed to open partitions box");
}

str 
BPTclose(){
	/* save its content todo*/
    if( closeBox("partitions" ,TRUE) ==0) return MAL_SUCCEED;
    return throwMessage("partitions.close","failed to close box");
}
str 
BPTdestroy(){
    destroyBox("partitions");
    return MAL_SUCCEED;
}

str
BPTtake(int *ret, int *idx){
	if( *idx< 0 || *idx >= ptop)
		return throwMessage("partitions.take","Index out of range");
	*ret = partitions[*idx].pid;
	BBPincref(*ret, TRUE);
	return MAL_SUCCEED;
}
@-
Administration of new partitions.
@c
int BPTfindGrp(int bid){
	int i;
	for(i=0; i<ptop; i++)
	if( partitions[i].bid== bid) return i;
	return -1;
}
int BPTfindPartition(int bid, int pid, oid first){
	int i;
	for(i=0; i<ptop; i++)
	if( partitions[i].bid== bid &&
		partitions[i].pid== pid) {
		/* check for oid overlap */
			if( first < partitions[i].last &&
				partitions[i].last != oid_nil)
					return -2;
			return i;
	}
	return -1;
}
str
BPTdeposit(int *ret, int *bid){
	int idx,i;
	BAT *b;

	b= BATdescriptor(*bid);
	if( b== NULL)
		return throwMessage("partitions.deposit","Can not access descriptor");
	idx= BPTfindGrp(*bid);
	if( idx != -1)
		return throwMessage("partitions.deposit","Duplicate group definition");
	if( ptop == plimit)
		BPTresize(plimit + INCREMENT);
	for(i=0; i<=ptop; i++)
	if( partitions[i].bid == -1) break;
	partitions[i].bid= *bid;
	partitions[i].pid= *bid;
	partitions[i].first= b->hseqbase;
	partitions[i].last= oid_nil;
	if(i>= ptop) {
		ptop=i+1;
		partitions[ptop].bid= -1;
	}
	BBPunfix(*bid);
	(void) ret;
	return MAL_SUCCEED;
}
str
BPTdeposit2(int *ret, int *bid, int *pid){
	int idx,i;
	BAT *b;

	b= BATdescriptor(*pid);
	if( b== NULL)
		return throwMessage("partitions.deposit","Can not access descriptor");
	
	idx= BPTfindPartition(*bid, *pid, b->hseqbase);
	if( idx == -2)
		return throwMessage("partitions.deposit","Partition integrity violation");
	if( idx != -1)
		return throwMessage("partitions.deposit","Partition already known");
	for(i=0; i<ptop; i++)
	if( partitions[i].bid== *bid &&
		partitions[i].last== oid_nil){
		partitions[i].last= b->hseqbase-1; 
		break;
	}

	if( ptop == plimit)
		BPTresize(plimit + INCREMENT);
	for(i=0; i<=ptop; i++)
	if( partitions[i].bid == -1) break;
	partitions[i].bid= *bid;
	partitions[i].pid= *pid;
	partitions[i].first= b->hseqbase;
	partitions[i].last= oid_nil;
	if(i>= ptop) {
		ptop=i+1;
		partitions[ptop].bid= -1;
	}
	BBPunfix(*pid);
	(void) ret;
	return MAL_SUCCEED;
}
str
BPTgetRange(oid *first, oid *last, int *bid){
	int i;
	for(i=0;i<ptop; i++)
	if( partitions[i].pid== *bid ){
		*first = partitions[i].first;
		*last = partitions[i].last;
		return MAL_SUCCEED;
	}
	return throwMessage("partitions.getRange","Partition not known");
}
str
BPTgetLastPartition(int *ret, int *bid){
	int i;
	for(i=0;i<ptop; i++)
	if( partitions[i].bid== *bid &&
		partitions[i].last== oid_nil){
			*ret = partitions[i].pid;
			return MAL_SUCCEED;
	}
	return throwMessage("partitions.getLastPartition","Partition not known");
}
str
BPTdiscard(int *ret, int *bid){
	int i;
	for(i=0; i<ptop; i++)
	if( partitions[i].bid== *bid ||
		partitions[i].pid== *bid) {
		partitions[i].bid= -1;
		partitions[i].pid= -1;
	}
	(void) ret;
	return MAL_SUCCEED;
}
str
BPTdiscardAll(int *ret){
	GDKfree(partitions);
	partitions=0;
	BPTresize(INCREMENT);
	(void) ret;
	return MAL_SUCCEED;
}
str
BPTtoString(int *ret, int *bid){
	(void) ret; (void) bid;
	return throwMessage("partitions.toString","not yet implemented");
}
str
BPTreleaseAll(int *ret, int *bid){
	(void) ret; (void) bid;
	return throwMessage("partitions.release","not yet implemented");
}
str
BPTrelease(int *ret, int *bid){
	(void) ret; (void) bid;
	return throwMessage("partitions.release","not yet implemented");
}
@-
We start with the large chunk iterator.
The definition of the control statements require the same
control variables, which means that the BATview is accessible
to determine how far to advance when the next chunk is retrieved.
The number of elements in the chunk is limited by the granule
size.
@c
str
BPTnewIteratorBase(int *ret){
	*ret = 0;
	if( *ret == ptop) *ret = -1;
	return MAL_SUCCEED;
}
str
BPThasMoreElementsBase(int *ret){
	do{
		*ret = *ret +1;
		if( *ret >= ptop) {
			*ret = -1;
			return MAL_SUCCEED;
		}
	} while( partitions[*ret].bid == -1);
	return MAL_SUCCEED;
}

str 
BPTnewIterator(int *res, int *pid, int *bid){
	int i;
	for(i=0;i<ptop; i++)
	if( partitions[i].bid == *bid ){
		*res = i;
		*pid= partitions[i].pid;
		BBPincref(*pid,TRUE);
		return MAL_SUCCEED;
	}
	return throwMessage("partitions.newIterator","Group not found");
}
str 
BPTnewIteratorRng(int *res, int *pid, int *bid, oid *first, oid *last){
	int i;
	for(i=0;i<ptop; i++)
	if( partitions[i].bid == *bid &&
	 	!(partitions[i].last < *first ||
		 partitions[i].first > *last) ){
		*res = i;
		*pid= partitions[i].pid;
		BBPincref(*pid,TRUE);
		return MAL_SUCCEED;
	}
	return throwMessage("partitions.newIterator","Group not found");
}
str 
BPThasMoreElements(int *res, int *pid, int *bid){
	int i;

	for(i= *res+1;i<ptop; i++)
	if( partitions[i].bid == *bid ){
		*res = i;
		*pid= partitions[i].pid;
		BBPincref(*pid,TRUE);
		return MAL_SUCCEED;
	}
	*res = -1;
	return MAL_SUCCEED;
}
str 
BPThasMoreElementsRng(int *res, int *pid, int *bid, oid *first, oid *last){
	int i;

	for(i= *res+1;i<ptop; i++)
	if( partitions[i].bid == *bid &&
	 	!(partitions[i].last < *first ||
		 partitions[i].first > *last) ){
		*res = i;
		*pid= partitions[i].pid;
		BBPincref(*pid,TRUE);
		return MAL_SUCCEED;
	}
	*res = -1;
	return MAL_SUCCEED;
}
