@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@' 
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@' 
@' The Original Code is the Monet Database System.
@' 
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2004 CWI.
@' All Rights Reserved.
@' 
@' Contributor(s):
@' 		Martin Kersten <Martin.Kersten@cwi.nl>
@' 		Peter Boncz <Peter.Boncz@cwi.nl>
@' 		Niels Nes <Niels.Nes@cwi.nl>
@' 		Stefan Manegold  <Stefan.Manegold@cwi.nl>

@f language
@a Martin Kersten
@v 0.1
@* MAL extensions
This module contains enhances to the MAL interpreter layer, such as
iterators over ranges and bats, object management, access to the debugger, ....
This module is loaded directly after the kernel modules and provides
a first abstraction layer. 

Note that the modules located in the kernel directory should not
rely on the MAL datastructures. That's why we have to deal with
some bat operations here.

The routines below are linked with the kernel by default
@mal
module mal;

command raise(msg:str) :str 
address CMDraise
comment "Raise an exception labelled 
	with a specific message.";

@+ Iterator primitives
Iterators enumerate elements in a collection defined by a few paramaters,
e.g. a lower/upper bound, or a bat. An iterator is initialized in the first
call by recognizing that the control variable lies outside the intended
collection.

@mal
command nextElement(i:flt,f:flt,l:flt,s:flt):bit 
address fltForloopStep; 
command nextElement(i:dbl,f:dbl,l:dbl,s:dbl):bit 
address dblForloopStep; 
command nextElement(i:sht,f:sht,l:sht,s:sht):bit 
address shtForloopStep; 
command nextElement(i:lng,f:lng,l:lng,s:lng):bit 
address lngForloopStep; 
command nextElement(i:int,f:int,l:int,s:int):bit 
address intForloopStep
comment "These routine provide an iterator over 
	a scalar domain. The step size depends 
	on the underlying type."; 

command nextElement(i:chr, f:chr, l:chr ):bit 
address chrForloop; 
command nextElement(i:sht, f:sht, l:sht) :bit 
address shtForloop; 
command nextElement(i:lng, f:lng, l:lng) :bit 
address lngForloop; 
command nextElement(i:int, f:int, l:int) :bit 
address intForloop
comment "This routine provides an iterator
	over a scalar domain. The step size 
	depends on the underlying type."; 
@- Monet help system
All procedural abstractions may contain a string with commentary text.
This information is retained in the symbol table for subsequent use.
Often, it is more appropriate to extract the comments into a BAT
for subsequent analysis.
@mal
command help(k:str):bat[:str,:str] 
address CMDhelp
comment "Search the commentary strings for 
	one matching the keyword";
command help(mod:str,fcn:str)
	:bat[:int,:str] 
address CMDhelp2
comment "Collect the comments for a given 
	function pattern";
@- Monet Manual construction
The manual operations ease offline inspection of the all the Monet function.
It purposely generates an XML organized file, because we expect external
tools to massage it further for presentation. The envisioned 
tagging structure becomes
@-
@mal
command manual(file:str,mod:str)
address CMDmanual2
comment "Generate a synopsis of a module";
command manual(file:str,mod:str,recursive:int)
address CMDmanual
comment "Generate a recursive module synopsis";
command manual(mod:str)
address CMDmanual1
comment "Generate a synopsis of a module";
command manual()
address CMDmanual0
comment "Produces a XML-formatted manual 
	over all modules loaded.";

@+ Macro expansion
Running a script stored in a file is interpreted as
It is typically used to initialize a context, therefore we need
to provide the runtime context. For the call variants we have
to determine an easy way to exchange the parameter/return values.
@mal
command call(s:str):void
address CMDcallString
comment "Evaluate a MAL string program";
pattern call(s:bat[:any,:str]):void
address CMDcallBAT
comment "Evaluate a program stored in a BAT";
command source(f:str):void
address CMDevalFile
comment "Execute the program in a (local) file";
pattern include(f:str):void
address CMDincludeFile
comment "Merge the instructions stored in the 
	file with the current program";
@-
@{
@+ Dummy code 
@h
#ifndef _LANGUAGE_H
#define _LANGUAGE_H
#endif /* _LANGUAGE_H*/
@-
@= Pseudo
        if (BBPindex("view_@1_@2") <= 0)
                BATname(b, "@2");
        BATroles(b,"@1","@2");
        BATmode(b,TRANSIENT);
        BATfakeCommit(b);
        *ret = b->batCacheid;

@c

#include "language.h"
#include "mal.h"
#include "mal_scope.h"
#include "mal_session.h"
#include "mal_resolve.h"
#include "mal_client.h"
#include "mal_interpreter.h"

str CMDraise(str *ret,  str *msg){
	*ret= GDKstrdup(*msg);
	return GDKstrdup(*msg);
}
@+ Printing
The print commands are implemented as single instruction rules,
because they need access to the calling context.
At a later stage we can look into the issues related to
parsing the format string as part of the initialization phase.
The old method in V4 essentially causes a lot of overhead
because you have to prepare for the worst (e.g. mismatch format
identifier and argument value)
@c
str CMDprint_val(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int tpe = getArgType(mb,pci,1);
	ptr val = (ptr) getArgReference(stk,pci,1);
        stream *fp = GDKout;
	if( val==NULL) {
		ATOMprint(TYPE_str, "nil", GDKout);
		return MAL_SUCCEED;
	}
	if( isaBatType(tpe)){
		BAT *b = BATdescriptor(*(int*)val);
		if( b== NULL) {
			return throwMessage("mal.print","descriptor access failed");
		}
		/* BATprint(b);*/
		BATmultiprintf(GDKout,2,&b,TRUE,0);
		return MAL_SUCCEED;
	}
        stream_printf(fp,"[ ");
	if( tpe == TYPE_str)
		ATOMprint(tpe, *(str*)val, fp);
        else  	ATOMprint(tpe, val, fp);
        stream_printf(fp," ]\n");
	stream_flush(fp);
        return MAL_SUCCEED;
}
str CMDprint_ft(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int tpe = getArgType(mb,pci,1);
	ptr val = (ptr) getArgReference(stk,pci,1);
	if( val==NULL) {
		ATOMprint(TYPE_str, "nil", GDKout);
		return MAL_SUCCEED;
	}
	if( tpe == TYPE_str)
		ATOMprint(TYPE_str, *(str*)val, GDKout);
	else ATOMprint(tpe, val, GDKout);
	stream_flush(GDKout);
	return MAL_SUCCEED;
}

str CMDotable( MalBlkPtr mb, MalStkPtr stk, InstrPtr pci, int o, int flg){
        BAT *piv[MAXPARAMS],*b;
        int nbats = 0;
	int tpe,i=1,order=0;
	ptr val;

	if(o){
		order = *(int*) getArgReference(stk,pci,1);
		i++;
	}
	for(; i< pci->argc;i++) {
		tpe = getArgType(mb,pci,i);
		val = (ptr) getArgReference(stk,pci,i);
		if( !isaBatType(tpe)) 
			return throwMessage("mal.otable"," BAT expected");
		b= BATdescriptor(*(int*)val);
		if(b == NULL) return throwMessage("mal.otable","GDKerror");
                piv[nbats++] = b;
        } 
        BATmultiprintf(GDKout, nbats, piv, flg, order);
	stream_flush(GDKout);
        return MAL_SUCCEED;
}

str CMDprint_otable( MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	CMDotable(mb,stk,pci,1,TRUE);
        return MAL_SUCCEED;
}

str CMDprint_table( MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	CMDotable(mb,stk,pci,0,FALSE);
        return MAL_SUCCEED;
}

str CMDprint_table_default( MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
        BAT *piv[MAXPARAMS],*b;
        int nbats = 0;
	int tpe,i;
	ptr val;

	for(i=pci->retc; i< pci->argc;i++) {
		tpe = getArgType(mb,pci,i);
		val = (ptr) getArgReference(stk,pci,i);
		if( !isaBatType(tpe)) 
			return throwMessage("mal.print_table_default","BAT expected");
		b= BATdescriptor(*(int*)val);
		if(b == NULL) return throwMessage("mal.print_table_default","GDKerror");
                piv[nbats++] = b;
        } 
        BATmultiprintf(GDKout, i-1, piv, FALSE, 0);
	stream_flush(GDKout);
        return MAL_SUCCEED;
}
@- Input redirectionrs
@c
str CMDcallString(int *ret, str *s){
	str src;
	str buf=0;
	int len =0;

	(void) ret; /* fool compiler */
	if(strlen(*s)==0) return MAL_SUCCEED;
	src= (str) GDKmalloc(len=strlen(*s)+3);
	/* GDK_atom routine requires enclosing quotes */
	strcpy(src,"\"");
	strcat(src,*s);
	strcat(src,"\"");
	strFromStr( src, &len, &buf);

	callString(getClient(),buf,FALSE);
	GDKfree(src);
	GDKfree(buf);
	return MAL_SUCCEED;
}
str CMDevalFile(int *ret, str *fnme){
	str s = *fnme;
	Client c= getClient();
	char buffer[1024];

	(void) ret; /* fool compiler */
	if( strlen(s)+strlen(c->cwd)+2>=1024){
		return throwMessage("mal.setCwd","Evaluation buffer too small\n");
	}
	buffer[0]=0;
	if( *s != '/'){
		strcpy(buffer,c->cwd);
		strcat(buffer,"/");
	}
	strcat(buffer,s);
	malImport(getClient(),buffer,0,FALSE);
	return MAL_SUCCEED;
}
str CMDcallBAT(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	(void) mb; (void)stk; (void) pci; /* fool compiler */
	return throwMessage("mal.call","Not yet implemented");
}
str CMDincludeFile(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	(void) mb; (void)stk; (void) pci; /* fool compiler */
	return throwMessage("mal.include","Not yet implemented");
}
str CMDdebug(int *ret, int *flg){
	*ret = GDKdebug;
	if( *flg) GDKdebug = *flg;
	return MAL_SUCCEED;
}
str CMDmanual(int *ret, str *fname, str *mod,int *recursive){
	stream *fs;
	(void) ret; /* fool compiler */
	fs= open_wastream(*fname);
	if( fs== NULL) return throwMessage("mal.manual","Could not open file\n");
	dumpManualHeader(fs);
	dumpManual(fs, findScope(getClient()->nspace,*mod),*recursive);
	dumpManualFooter(fs);
	return MAL_SUCCEED;
}
str CMDmanual2(int *ret, str *fname, str *mod,int *recursive){
	int r= 0;
	(void) recursive; /* fool compiler */
	return CMDmanual(ret,fname,mod,&r);
}
str CMDmanual1(int *ret, str *mod){
	(void) ret; /* fool compiler */
	dumpManualHeader(GDKout);
	dumpManual(GDKout, findScope(getClient()->nspace,*mod),0);
	dumpManualFooter(GDKout);
	return MAL_SUCCEED;
}
str CMDmanual0(int *ret){
	(void) ret; /* fool compiler */
	dumpManualHeader(GDKout);
	dumpManual(GDKout, getClient()->nspace,1);
	dumpManualFooter(GDKout);
	return MAL_SUCCEED;
}
str CMDsetCwd(str *ret, str *fnme){
	Client c= getClient();
	*ret = c->cwd;
	c->cwd= GDKstrdup(*fnme);
	return MAL_SUCCEED;
}
str CMDhelp(int *ret, str *mod) 
{	Client cntxt= getClient();
	Scope m;
	Symbol s;
	str msg;
	int i;
	BAT *b = BATnew(TYPE_str, TYPE_str, 256);
        if (b == 0) return throwMessage("catalog.help", "failed to create BAT");
        return throwMessage("catalog.help", "Search by keyword not yet available");

	m= findScope(cntxt->nspace,*mod);
	if(m)
	for(i=0;i<256;i++){
		s= m->subscope[i];
		while(s!= NULL){
			msg= s->def->help;
			if( msg){
				BUNins(b,s->name,msg);
			}
			s= s->peer;
		}
	}
	@:Pseudo(help,Comment)@
	return MAL_SUCCEED;
}
str CMDhelp2(int *ret, str *mod, str *fcn) 
{	Symbol s;
	str msg;

	BAT *b = BATnew(TYPE_str, TYPE_str, 256);
        if (b == 0) return throwMessage("catalog.helpComment", "failed to create BAT");

	s= findSymbol(*mod,*fcn);
	while(s!= NULL){
		if(idcmp(s->name,*fcn)==0){
			msg= s->def->help;
			if(msg== NULL) msg= str_nil;
			BUNins(b,s->name,msg);
		}
		s= s->peer;
	}
	@:Pseudo(help,Comment)@
	return MAL_SUCCEED;
}

@+ MAL iterator code
This module contains the framework for the construction of iterators.
Iterators enumerate elements in a collection defined by a few paramaters,
e.g. a lower/upper bound, or a bat. An iterator is initialized in the first
call by recognizing that the control variable lies outside the intended
collection.

Iterators appear as ordinary function calls in the MAL code and
always return a boolean, to indicate that an element is available for
consumption. Initialization of the iterator representation depends
on its kind.

The state of the iterator should be encoded in its arguments, which
may be modified as a side-effect of calling the iterator.
[we may need to include R/W information in the typing scheme]
@+ Foreach iterators
The most common class of iterators encountered in a programming
environment is the for-loop. It contains a for-loop variable,
a starting point and a limit. Changing the for-loop variable
within the for-loop body is considered bad code and should be avoided
to simplify data-flow analysis.

We assume that the range boundaries comply with the underlying domain.

@= forloopRange
str @1Forloop(bit *res, @1 *i, @1 *first, @1 *last){
        @1 v = *i;
        if( v < *first || v >= *last)
                *i = *first;
        else    *i = ++v;
        *res= *i < *last;
        return MAL_SUCCEED;
}

@= forloopStep
str @1ForloopStep(bit *res, @1 *i, @1 *first, @1 *last, @1 *step){
	@1 v = *i;
	if( v >= *first){
		*i = v + *step;
		if( *i < *last){
			*res= 1;
			return MAL_SUCCEED;
		}
		if( v >= *last){
			*i = *first;
			*res= 0;
			return MAL_SUCCEED;
		} 
		*res= 0;
	} else {
		*i = *first;
		*res= 1;
	}
	return MAL_SUCCEED;
}
@c

@:forloopRange(lng)@
@:forloopRange(chr)@
@:forloopRange(int)@
@:forloopRange(sht)@

@:forloopStep(lng)@
@:forloopStep(int)@
@:forloopStep(sht)@
@:forloopStep(flt)@
@:forloopStep(dbl)@

@-
There are a few atomairy storage types we have to introduce here:
OID, str, void, bit, ptr
@-
@}
