@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2003 CWI.
@' All Rights Reserved.
@'
@' Contributor(s):
@'              Martin Kersten <Martin.Kersten@cwi.nl>
@'              Peter Boncz <Peter.Boncz@cwi.nl>
@'              Niels Nes <Niels.Nes@cwi.nl>
@'              Stefan Manegold  <Stefan.Manegold@cwi.nl>
@f inspect
@t Monet Runtime Inspection
@a Martin Kersten
@v 1
@* Introduction
This document introduces a series of bats and commands that provide access
to information stored within the Monet Version 5 interpreter data structures.
In all cases, the pseudo BAT operation returns a transient BAT that
should be garbage collected after being used.

The main performance drain would be to use a pseudo BAT directly to
successively access it components. This can be avoided by first assigning
the pseudo BAT to a variable.

@mal 
module inspect;

@- MAL interpreter status
The prime scheme to inspect the MAL interpreter status is to use
the MAL debugger. However, in case of automatic exception handling
it helps to be able to obtain BAT versions of the critical information,
such as stack frame table, stack trace,
and the instruction(s) where an exception occurred.
The inspection typically occurs in the exception handling part of the
MAL block.
@mal
pattern getStackDepth():int = INSPECTStkDepth
        comment "Return the depth of the calling stack.";

pattern getStackFrame(i:int):bat[str,str] = INSPECTStkFrameN;
pattern getStackFrame():bat[str,str] = INSPECTStkFrame
	comment "Collect variable binding of current (n-th) stack frame.";
pattern getStackTrace():bat[void,str]= INSPECTStkTrace;

@+ MAL modules and scopes inspection
Each module forms a separately named scope. Scopes visible to a user
are relevant for resolving function names.

@mal
command getModules() : bat[void,str] = INSPECTmoduleNames
        comment "Collect bat with all modules loaded" ;

command getPatterns():bat[str,str] = INSPECTpatternNames
	comment "Create bat with the module and pattern pairs";
command getCommands():bat[str,str] = INSPECTcommandNames
	comment "Create bat with the module and commands pairs";
command getFunctions():bat[str,str] = INSPECTfunctionNames
	comment "Create bat with the module and function pairs";

pattern getCode():bat[void,str] = INSPECTcodeDump
comment "Returns a string representation of the current function 
	with typing information attached";

pattern getDefinition():bat[void,str] = INSPECTcurrSymbolDef
comment "Returns a string representation of the current function";
command getDefinition(mod:str,fcn:str):bat[int,str] = INSPECTsymbolDef
comment "Returns a string representation of a specific function";

command getSignature(mod:str,fcn:str):bat[str,str] = INSPECTsymbolSignature
comment "Returns the signature(s) of a function";

command getType(mod:str,fcn:str):bat[str,str] = INSPECTsymbolType
comment "Get the return type of a particular function";
pattern getType(v:any) : int = INSPECTtype
comment "Return the type of a variable (expression)";
command getTypeName(v:int): str = INSPECTtypename;


command getAtoms():bat[int,str] = INSPECTatom_names
comment "Collect a BAT with the atom names";

command getClients( ): bat[int,str] = INSPECTclients
        comment "Pseudo bat to map client identifiers to their name";
@- Display code
A key tool for analysis of the MAL code is being able to dump
any routine, module. For queries, it is also illustrative to display
the flow graph.
@mal
pattern showFunction():void = INSPECTshowFunction3
comment "Dump the current routine on standard out.";
#pattern showFunction(M:any,F:any):void = INSPECTshowFunction3
#comment "Dump the routine M.F on standard out.";

@+ The Monet Debugger interface
To enable ease of debugging and performance monitoring, the MAL interpreter
comes with a hardwired gdb-like text-based debugger.
@mal
pattern mdb(c:chr):void = mdbSetCmd
        comment "Start debugger with command 'c'";
pattern mdb(b:bit):void = mdbToggle
        comment "Start/stop interactive debugger";
pattern mdb():void = mdbToggle
        comment "Start interactive debugger";

@+ Implementation
@h
#ifdef _INSPECT_H
#endif /* _INSPECT_H*/
@c
#include <stdarg.h>
#include <time.h>
#include "gdk.h"
#include "mal_resolve.h"
#include "mal_client.h"
#include "mal_function.h"
#include "mal_debugger.h"

@+ Variables and stack information
The variable information can be turned into a BAT for inspection as well.

@= Pseudo
        if (BBPindex("view_@1_@2") <= 0)
                BATname(b, "@2");
        BATroles(b,"@1","@2");
        BATmode(b,TRANSIENT);
        BATfakeCommit(b);
        *ret = b->batCacheid;

@c

str INSPECTStkDepth(MalBlkPtr m, MalStkPtr s, InstrPtr p)
{       int i=0, *ret= (int*) getArgReference(s,p,0);
        while(s!= 0){
                i++;
                s= s->up;
        }
        *ret= i;
        return MAL_SUCCEED;
}

str INSPECTgetFrame(BAT *b, MalBlkPtr mb, MalStkPtr s,int depth){
	ValPtr v;
	int i;
	char *buf=0;
	if(depth> 0) return INSPECTgetFrame(b,mb,s->up,depth-1);
	if( s!= 0)
	for(i=0 ; i<s->stktop ; i++,v++){
		v= &s->stk[i];
		ATOMformat(v->vtype, VALget(v), &buf);
		BUNins(b,getVarName(mb,i),buf);
	}
	return MAL_SUCCEED;
}
str INSPECTStkFrame(MalBlkPtr m, MalStkPtr s, InstrPtr p)
{	int *ret= (int*) getArgReference(s,p,0);
	BAT *b = BATnew(TYPE_str, TYPE_str, 256);
	if (b == 0) return throwMessage("inspect.stkFrame", "failed to create BAT");
	@:Pseudo(stk,frame)@
	return INSPECTgetFrame(b,m,s,0);
}
str INSPECTStkFrameN(MalBlkPtr m, MalStkPtr s, InstrPtr p)
{	int n, *ret= (int*) getArgReference(s,p,0);
	BAT *b = BATnew(TYPE_str, TYPE_str, 256);

	n= *(int*) getArgReference(s,p,1);
	if(n<0) return throwMessage("inspect.stkFrame", "illegal depth.");
	@:Pseudo(stk,frame)@
	return INSPECTgetFrame(b,m,s,n-1);
}
str INSPECTStkTrace(MalBlkPtr m, MalStkPtr s, InstrPtr p)
{	BAT *b = BATnew(TYPE_int, TYPE_str, 256);
	str msg;
	Client c= getClient();
	int *ret= (int*) getArgReference(s,p,0);
	int k=0;

	msg= call2str(s->blk, s, getPC(m,p));
	BUNins(b,&k, msg);
	GDKfree(msg);
	for(s=s->up,k++; s!= NULL; s= s->up, k++){
		msg= call2str(s->blk, s, s->pcup);
		BUNins(b,&k, msg);
		GDKfree(msg);
	}
	@:Pseudo(stk,trace)@
	return MAL_SUCCEED;
}
@+ Symbol table 
Mal symbol table and environment analysis.
@c

str INSPECTmoduleNames(int *ret){
	Client c;
	Scope s;
	int i=0;
	BAT *b = BATnew(TYPE_void, TYPE_str, 256);

        if (b == 0) return throwMessage("inspect.moduleNames", "failed to create BAT");
	c= getClient();

	for(s=c->nspace; s; s= s->outer,i++)
		BUNins(b,&int_nil,s->name);

	@:Pseudo(scope,names)@
	return MAL_SUCCEED;
}
str INSPECTsymbolFind(int *ret,int kind)
{	Client c;
	Scope s;
	Symbol t;
	int i;
	BAT *b = BATnew(TYPE_str, TYPE_str, 256);

        if (b == 0) return throwMessage("inspect.symbolFind", "failed to create BAT");
	c= getClient();
	s= c->nspace;
	while(s){
		for(i=0;s && i<MAXSCOPE;i++)
		if( s->subscope[i]){
			for(t= s->subscope[i];t;t=t->peer){
			InstrPtr sig= getSignature(t);
			if( kind && kind != sig->token) continue;
			BUNins(b,moduleName(sig),functionName(sig));
			}
		}
		s= s->outer;
	}
	@:Pseudo(symbol,name)@
	return MAL_SUCCEED;
}
str INSPECTfunctionNames(int *ret){ return INSPECTsymbolFind(ret,FUNCTIONsymbol); }
str INSPECTpatternNames(int *ret){ return INSPECTsymbolFind(ret,PATTERNsymbol); }
str INSPECTcommandNames(int *ret){ return INSPECTsymbolFind(ret,COMMANDsymbol); }
str INSPECTclients(int *ret){
        int i;
        BAT *b = BATnew(TYPE_int, TYPE_str, 256);
        if (b == 0) return throwMessage("catalog.clientNames", "failed to create BAT");

        for(i=0; i < MAL_MAXCLIENTS; i++)
        if(mal_clients[i].mode>= CLAIMED && mal_clients[i].user) {
                BUNins(b, &i, mal_clients[i].user);
        }

        @:Pseudo(client,name)@
        return MAL_SUCCEED;
}

str INSPECTsymbolDef(int *ret, str *nme, str *fcn)
{	Symbol s;
	BAT *b = BATnew(TYPE_int, TYPE_str, 256);
        if(b == 0) return throwMessage("inspect.symbolDefinition", "failed to create BAT");
	
	s= findSymbol(*nme,*fcn);
	while(s){
		int i;
		str ps;
		for(i=0;i<s->def->stop;i++){
			ps= instruction2str(s->def, getInstrPtr(s->def,i),0);
			BUNins(b,&i,ps);
			GDKfree(ps);
		}
		s= s->peer;
	}
	@:Pseudo(fcn,stmt)@
	return MAL_SUCCEED;
}
str INSPECTcodeDump(MalBlkPtr m, MalStkPtr stk, InstrPtr p)
{	int i, *ret= (int*)getArgReference(stk,p,0);
	str ps, cm;
	BAT *b = BATnew(TYPE_int, TYPE_str, 256);
        if(b == 0) return throwMessage("inspect.codeDump", "failed to create BAT");
	
	for(i=0;i<m->stop;i++){
		ps= instruction2str(m, getInstrPtr(m,i),1);
		BUNins(b,&i,ps);
		GDKfree(ps);
	}
	@:Pseudo(fcn,stmt)@
	return MAL_SUCCEED;
}
str INSPECTcurrSymbolDef(MalBlkPtr m, MalStkPtr stk, InstrPtr p)
{	int i, *ret= (int*)getArgReference(stk,p,0);
	str ps, cm;
	BAT *b = BATnew(TYPE_void, TYPE_str, 256);
        if(b == 0) return throwMessage("inspect.symbolDefinition", "failed to create BAT");
	
	for(i=0;i<m->stop;i++){
		ps= instruction2str(m, getInstrPtr(m,i),0);
		BUNins(b,&int_nil,ps);
		GDKfree(ps);
	}
	@:Pseudo(fcn,stmt)@
	return MAL_SUCCEED;
}
str INSPECTsymbolSignature(int *ret, str *mod, str *fcn)
{	Symbol s;
	str msg;
	str ps,cm;
	BAT *b = BATnew(TYPE_str, TYPE_str, 12);
        if (b == 0) return throwMessage("inspect.symbolSignature", "failed to create BAT");

	s= findSymbol(*mod,*fcn);
	while(s!= NULL){
		msg= s->def->help;
		if( msg && idcmp(s->name,*fcn)==0) {
			ps= instruction2str(s->def, getSignature(s),0);
			BUNins(b,s->name,ps);
			GDKfree(ps);
		}
		s= s->peer;
	}

	@:Pseudo(fcn,sig)@
	return MAL_SUCCEED;
}
str INSPECTsymbolType(int *ret, str *mod, str *fcn) 
{	Symbol s;
	BAT *b = BATnew(TYPE_str, TYPE_str, 256);
        if (b == 0) return throwMessage("inspect.symbolType", "failed to create BAT");

	s= findSymbol(*mod,*fcn);
	while(s!= NULL){
		if( idcmp(s->name,*fcn)==0) {
			str t=malTypeName(getDestType(s->def,getSignature(s)));
			BUNins(b,s->name,t);
			GDKfree(t);
		}
		s= s->peer;
	}
	@:Pseudo(fcn,type)@
	return MAL_SUCCEED;
}

str INSPECTatom_names(int *ret)
{	int i;
	BAT *b = BATnew(TYPE_int, TYPE_str, 256);
        if (b == 0) return throwMessage("inspect.atomNames", "failed to create BAT");

	for(i=0;i<GDKatomcnt;i++) BUNins(b,&i,ATOMname(i));

	@:Pseudo(atom,name)@
	return MAL_SUCCEED;
}
@+ Display routines
@= getFunction
str     modnme= getArgName(mb,p,1);
str     fcnnme= getArgName(mb,p,2);
Scope  scope=NULL;
Symbol s= NULL;
Client c= getClient();

scope = findScope(c->nspace,modnme);
if( scope)
	s= findSymbolInScope(scope,fcnnme);

if( s == NULL)
	GDKerror("@1:Could not find %s.%s\n",modnme,fcnnme);

@c
void INSPECTshowFunction(MalBlkPtr m, lng flg, stream *f) {
	printFunction(f,m,flg);
}
str INSPECTshowFunction3(MalBlkPtr mb, MalStkPtr stk, InstrPtr p){
	@:getFunction(showFunction)@
	else { 
		INSPECTshowFunction(s->def,(lng) FALSE,GDKout);
	}
	return NULL;
}

str INSPECTtypename(str *ret, int *tpe){
        *ret = malTypeName(*tpe);
        return MAL_SUCCEED;
}
str INSPECTtype(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
        int *ret;
        ret= (int*) getArgReference(stk,pci,0);
        *ret= getArgType(mb,pci,1);
        return MAL_SUCCEED;
}

