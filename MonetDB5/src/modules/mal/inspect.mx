@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@' 
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@' 
@' The Original Code is the Monet Database System.
@' 
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2004 CWI.
@' All Rights Reserved.

@f inspect
@a Martin Kersten
@v 1
@* Runtime Inspection
This module introduces a series of commands that provide access
to information stored within the interpreter data structures.
In all cases, the pseudo BAT operation returns a transient BAT that
should be garbage collected after being used.

The main performance drain would be to use a pseudo BAT directly to
successively access it components. This can be avoided by first assigning
the pseudo BAT to a variable.

@+ MAL interpreter status
The prime scheme to inspect the MAL interpreter status is to use
the MAL debugger. However, in case of automatic exception handling
it helps to be able to obtain BAT versions of the critical information,
such as stack frame table, stack trace,
and the instruction(s) where an exception occurred.
The inspection typically occurs in the exception handling part of the
MAL block.
@mal
module inspect;
pattern getStackDepth():int 
address INSPECTStkDepth
comment "Return the depth of the calling stack.";

pattern getStackFrame(i:int):bat[:str,:str] 
address INSPECTStkFrameN;
pattern getStackFrame():bat[:str,:str] 
address INSPECTStkFrame
comment "Collect variable binding of current 
	(n-th) stack frame.";
pattern getStackTrace():bat[:void,:str]
address INSPECTStkTrace;

@+ MAL modules and scopes inspection
Each module forms a separately named scope. Scopes visible to a user
are relevant for resolving function names.

@mal
command getModules() :bat[:void,:str] 
address INSPECTmoduleNames
comment "Collect bat with all modules loaded" ;

command getPatterns():bat[:str,:str] 
address INSPECTpatternNames
comment "Map module and pattern pairs";
command getCommands():bat[:str,:str] 
address INSPECTcommandNames
comment "Map module and commands pairs";
command getFunctions():bat[:str,:str] 
address INSPECTfunctionNames
comment "Map module and function pairs";
command getFactories():bat[:str,:str] 
address INSPECTfactoryNames
comment "Map module and function pairs";

pattern getDefinition():bat[:void,:str] 
address INSPECTcodeDump
comment "Returns a string representation 
	of the current function 
	with typing information attached";

command getDefinition(mod:str,fcn:str)
	:bat[:int,:str] 
address INSPECTgetDefinition
comment "Returns a string representation 
	of a specific function";

command getSignature(mod:str,fcn:str)
	:bat[:str,:str] 
address INSPECTgetSignature
comment "Returns the function signature(s)";

pattern getType(v:any) :int 
address INSPECTtype
comment "Return the type of a variable (expression)";
command getTypeName(v:int):str 
address INSPECTtypename;


command getAtomNames():bat[:int,:str] 
address INSPECTatom_names
comment "Collect a BAT with the atom names";
command getAtomSuperNames():bat[:int,:str] 
address INSPECTatom_sup_names
comment "Collect a BAT with the atom names";
command getAtomSizes():bat[:int,:int] 
address INSPECTatom_sizes
comment "Collect a BAT with the atom sizes";

@+ Display code
A key tool for analysis of the MAL code is being able to dump
any routine, module. For queries, it is also illustrative to display
the flow graph. [TODO]
@mal
pattern showFunction():void 
address INSPECTshowFunction
comment "Dump the current routine on standard out.";
pattern showFunction(M:any,F:any):void 
address INSPECTshowFunction3
comment "Dump the routine M.F on standard out.";

@+ Online help system
All procedural abstractions may contain a string with commentary text.
This information is retained in the symbol table for subsequent use.
It can be extracted into a BAT for inspection, such as providing
an online help facility.
@mal
command help(k:str):bat[:str,:str] 
address INSPECThelp
comment "Search the commentary strings for 
	one matching the keyword";
command help(mod:str,fcn:str)
	:bat[:int,:str] 
address INSPECThelp2
comment "Collect the comments for a given 
	function pattern";
@- Manual construction
The manual operations ease offline inspection of all function definitons.
It purposely generates an XML organized file, because we expect external
tools to massage it further for presentation. The envisioned 
tagging structure becomes
@-
@mal
command manual(file:str,mod:str)
address INSPECTmanual2
comment "Generate a synopsis of a module";
command manual(file:str,mod:str,recursive:int)
address INSPECTmanual
comment "Generate a recursive module synopsis";
command manual(mod:str)
address INSPECTmanual1
comment "Generate a synopsis of a module";
command manual()
address INSPECTmanual0
comment "Produces a XML-formatted manual 
	over all modules loaded.";

@+ The Monet Debugger interface
To enable ease of debugging and performance monitoring, the MAL interpreter
comes with a hardwired gdb-like text-based debugger.
@mal
pattern mdb(c:chr):void 
address mdbSetCmd
comment "Start debugger with command 'c'";
pattern mdb(b:bit):void 
address mdbToggle
comment "Start/stop interactive debugger";
pattern mdb():void 
address mdbToggle
comment "Start interactive debugger";
@-
@{
@+ Implementation
@h
#ifdef _INSPECT_H
#endif /* _INSPECT_H*/
@c
#include "gdk.h"
#include <stdarg.h>
#include <time.h>
#include "mal_resolve.h"
#include "mal_client.h"
#include "mal_exception.h"
#include "mal_debugger.h"
#include "mal_interpreter.h"

@+ Variables and stack information
The variable information can be turned into a BAT for inspection as well.

@= Pseudo
        if (BBPindex("view_@1_@2") <= 0)
                BATname(b, "@2");
        BATroles(b,"@1","@2");
        BATmode(b,TRANSIENT);
        BATfakeCommit(b);
        *ret = b->batCacheid;

@c

static int getStkDepth( MalStkPtr s)
{
	int i = 0;
        while(s!= 0){
                i++;
                s= s->up;
        }
	return i;
}
str INSPECTStkDepth(MalBlkPtr mb, MalStkPtr s, InstrPtr p)
{       int *ret= (int*) getArgReference(s,p,0);
	(void)mb; /* fool compiler */
        *ret= getStkDepth(s);
        return MAL_SUCCEED;
}

str INSPECTgetFrame(BAT *b, MalBlkPtr mb, MalStkPtr s,int depth){
	ValPtr v;
	int i;
	char *buf=0;
	if(depth> 0) return INSPECTgetFrame(b,mb,s->up,depth-1);
	if( s!= 0)
	for(i=0 ; i<s->stktop ; i++,v++){
		v= &s->stk[i];
		ATOMformat(v->vtype, VALget(v), &buf);
		BUNins(b,getVarName(mb,i),buf);
	}
	return MAL_SUCCEED;
}
str INSPECTStkFrame(MalBlkPtr m, MalStkPtr s, InstrPtr p)
{	int *ret= (int*) getArgReference(s,p,0);
	BAT *b = BATnew(TYPE_str, TYPE_str, 256);
	if (b == 0) return throwMessage("inspect.stkFrame", "failed to create BAT");
	@:Pseudo(stk,frame)@
	return INSPECTgetFrame(b,m,s,0);
}
str INSPECTStkFrameN(MalBlkPtr m, MalStkPtr s, InstrPtr p)
{	int n, *ret= (int*) getArgReference(s,p,0);
	BAT *b = BATnew(TYPE_str, TYPE_str, 256);

	n= *(int*) getArgReference(s,p,1);
	if(n<0) return throwMessage("inspect.stkFrame", "illegal depth.");
	if(n>=getStkDepth(s)) return throwMessage("inspect.stkFrame", "illegal depth.");
	@:Pseudo(stk,frame)@
	return INSPECTgetFrame(b,m,s,n);
}
str INSPECTStkTrace(MalBlkPtr m, MalStkPtr s, InstrPtr p)
{	BAT *b = BATnew(TYPE_int, TYPE_str, 256);
	str msg;
	int *ret= (int*) getArgReference(s,p,0);
	int k=0;

	msg= call2str(s->blk, s, getPC(m,p), 1);
	BUNins(b,&k, msg);
	GDKfree(msg);
	for(s=s->up,k++; s!= NULL; s= s->up, k++){
		msg= call2str(s->blk, s, s->pcup, 1);
		BUNins(b,&k, msg);
		GDKfree(msg);
	}
	@:Pseudo(stk,trace)@
	return MAL_SUCCEED;
}
@+ Symbol table 
Mal symbol table and environment analysis.
@c

str INSPECTmoduleNames(int *ret){
	Client c;
	Scope s;
	int i=0;
	BAT *b = BATnew(TYPE_void, TYPE_str, 256);

        if (b == 0) return throwMessage("inspect.moduleNames", "failed to create BAT");
	c= getClient();

	for(s=c->nspace; s; s= s->outer,i++)
		BUNins(b,&int_nil,s->name);

	@:Pseudo(scope,names)@
	return MAL_SUCCEED;
}
str INSPECTsymbolFind(int *ret,int kind)
{	Client c;
	Scope s;
	Symbol t;
	int i;
	BAT *b = BATnew(TYPE_str, TYPE_str, 256);

        if (b == 0) return throwMessage("inspect.symbolFind", "failed to create BAT");
	c= getClient();
	s= c->nspace;
	while(s){
		for(i=0;s && i<MAXSCOPE;i++)
		if( s->subscope[i]){
			for(t= s->subscope[i];t;t=t->peer){
			InstrPtr sig= getSignature(t);
			if( kind && kind != sig->token) continue;
			BUNins(b,moduleName(sig),functionName(sig));
			}
		}
		s= s->outer;
	}
	@:Pseudo(symbol,name)@
	return MAL_SUCCEED;
}
str INSPECTfactoryNames(int *ret){ return INSPECTsymbolFind(ret,FACTORYsymbol); }
str INSPECTfunctionNames(int *ret){ return INSPECTsymbolFind(ret,FUNCTIONsymbol); }
str INSPECTpatternNames(int *ret){ return INSPECTsymbolFind(ret,PATTERNsymbol); }
str INSPECTcommandNames(int *ret){ return INSPECTsymbolFind(ret,COMMANDsymbol); }

str INSPECTgetDefinition(int *ret, str *nme, str *fcn)
{	Symbol s;
	BAT *b = BATnew(TYPE_int, TYPE_str, 256);
        if(b == 0) return throwMessage("inspect.getDefinition", 
					"failed to create BAT");
	
	s= findSymbol(*nme,*fcn);
	while(s){
		int i;
		str ps;
		for(i=0;i<s->def->stop;i++){
			ps= instruction2str(s->def, getInstrPtr(s->def,i),0);
			BUNins(b,&i,ps+1);
			GDKfree(ps);
		}
		s= s->peer;
	}
	@:Pseudo(fcn,stmt)@
	return MAL_SUCCEED;
}
str INSPECTcodeDump(MalBlkPtr m, MalStkPtr stk, InstrPtr p)
{	int i, *ret= (int*)getArgReference(stk,p,0);
	str ps;
	BAT *b = BATnew(TYPE_int, TYPE_str, 256);
        if(b == 0) return throwMessage("inspect.codeDump", "failed to create BAT");
	
	for(i=0;i<m->stop;i++){
		ps= instruction2str(m, getInstrPtr(m,i),1);
		BUNins(b,&i,ps);
		GDKfree(ps);
	}
	@:Pseudo(fcn,stmt)@
	return MAL_SUCCEED;
}
str INSPECTcurrSymbolDef(MalBlkPtr m, MalStkPtr stk, InstrPtr p)
{	int i, *ret= (int*)getArgReference(stk,p,0);
	str ps;
	BAT *b = BATnew(TYPE_void, TYPE_str, 256);
        if(b == 0) return throwMessage("inspect.currDefinition", 
					"failed to create BAT");
	
	for(i=0;i<m->stop;i++){
		ps= instruction2str(m, getInstrPtr(m,i),0);
		BUNins(b,&int_nil,ps);
		GDKfree(ps);
	}
	@:Pseudo(fcn,stmt)@
	return MAL_SUCCEED;
}
str INSPECTgetSignature(int *ret, str *mod, str *fcn)
{	Symbol s;
	str ps;
	BAT *b = BATnew(TYPE_str, TYPE_str, 12);
        if (b == 0) return throwMessage("inspect.getSignature", 
					"failed to create BAT");

	s= findSymbol(*mod,*fcn);
        if (s == 0) 
		return throwMessage("inspect.getSignature", 
			"failed to find <module>.<function>");

	while(s!= NULL){
		if( idcmp(s->name,*fcn)==0) {
			char *i, *o;
			ps= instruction2str(s->def, getSignature(s),0);
			i= strchr(ps,'(');
			if(i == 0) continue;
			*i=0; i++;
			o= strchr(i,')');
			if(o == 0) continue;
			*o= 0; o++;
			if(*o== '(') o++;
			if(strchr(o,')')) *strchr(o,'(')= 0;
			if(strchr(o,';')) *strchr(o,';')= 0;
			BUNins(b,i,o);
			GDKfree(ps);
		}
		s= s->peer;
	}

	@:Pseudo(input,result)@
	return MAL_SUCCEED;
}
str INSPECTsymbolType(int *ret, str *mod, str *fcn) 
{	Symbol s;
	BAT *b = BATnew(TYPE_str, TYPE_str, 256);
        if (b == 0) return throwMessage("inspect.getType", 
					"failed to create BAT");

	s= findSymbol(*mod,*fcn);
        if (s == 0) 
		return throwMessage("inspect.getSignature", 
			"failed to find <module>.<function>");
	while(s!= NULL){
		if( idcmp(s->name,*fcn)==0) {
			str t=getTypeName(getDestType(s->def,getSignature(s)));
			BUNins(b,s->name,t);
			GDKfree(t);
		}
		s= s->peer;
	}
	@:Pseudo(fcn,type)@
	return MAL_SUCCEED;
}

str INSPECTatom_names(int *ret)
{	int i;
	BAT *b = BATnew(TYPE_int, TYPE_str, 256);
        if (b == 0) return throwMessage("inspect.getAtomNames", 
					"failed to create BAT");

	for(i=0;i<GDKatomcnt;i++) BUNins(b,&i,ATOMname(i));

	@:Pseudo(atom,name)@
	return MAL_SUCCEED;
}
str INSPECTatom_sup_names(int *ret)
{	int i;
	BAT *b = BATnew(TYPE_int, TYPE_str, 256);
        if (b == 0) return throwMessage("inspect.getAtomSuperNames", 
			"failed to create BAT");

	for(i=0;i<GDKatomcnt;i++) BUNins(b,&i,ATOMname(i));

	@:Pseudo(atom,sup_name)@
	return MAL_SUCCEED;
}
str INSPECTatom_sizes(int *ret)
{	int i;
	size_t s;
	BAT *b = BATnew(TYPE_int, TYPE_int, 256);
        if (b == 0) return throwMessage("inspect.getAtomSizes",
		"failed to create BAT");

	for(i=0;i<GDKatomcnt;i++) {
		s= ATOMsize(i);
		BUNins(b,&i,&s);
	}

	@:Pseudo(atom,size)@
	return MAL_SUCCEED;
}
@+ Display routines
@c
str INSPECTshowFunction(MalBlkPtr mb, MalStkPtr stk, InstrPtr p){
	Client c= getClient();
	(void) p; (void) stk;
	printFunction(c->fdout,mb,LIST_INPUT);
	return MAL_SUCCEED;
}
str INSPECTshowFunction3(MalBlkPtr mb, MalStkPtr stk, InstrPtr p){
	str     modnme= getArgName(mb,p,1);
	str     fcnnme= getArgName(mb,p,2);
	Scope  scope=NULL;
	Symbol s= NULL;
	Client c= getClient();

	scope = findScope(c->nspace,modnme);
	if( scope)
		s= findSymbolInScope(scope,fcnnme);

	if( s == NULL)
		GDKerror("@1:Could not find %s.%s\n",modnme,fcnnme);
	else 
		printFunction(c->fdout,s->def,LIST_INPUT);
	(void) stk; /* fool compiler */
	return NULL;
}

str INSPECTtypename(str *ret, int *tpe){
        *ret = getTypeName(*tpe);
        return MAL_SUCCEED;
}
str INSPECTtype(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
        int *ret;
        ret= (int*) getArgReference(stk,pci,0);
        *ret= getArgType(mb,pci,1);
        return MAL_SUCCEED;
}
@-
@= Pseudo
        if (BBPindex("view_@1_@2") <= 0)
                BATname(b, "@2");
        BATroles(b,"@1","@2");
        BATmode(b,TRANSIENT);
        BATfakeCommit(b);
        *ret = b->batCacheid;

@c

str INSPECTraise(str *ret,  str *msg){
	*ret= GDKstrdup(*msg);
	return GDKstrdup(*msg);
}
str INSPECTmanual(int *ret, str *fname, str *mod,int *recursive){
	stream *fs;
	(void) ret; /* fool compiler */
	fs= open_wastream(*fname);
	if( fs== NULL) return throwMessage("mal.manual","Could not open file\n");
	dumpManualHeader(fs);
	dumpManual(fs, findScope(getClient()->nspace,*mod),*recursive);
	dumpManualFooter(fs);
	return MAL_SUCCEED;
}
str INSPECTmanual2(int *ret, str *fname, str *mod,int *recursive){
	int r= 0;
	(void) recursive; /* fool compiler */
	return INSPECTmanual(ret,fname,mod,&r);
}
str INSPECTmanual1(int *ret, str *mod){
	(void) ret; /* fool compiler */
	dumpManualHeader(GDKout);
	dumpManual(GDKout, findScope(getClient()->nspace,*mod),0);
	dumpManualFooter(GDKout);
	return MAL_SUCCEED;
}
str INSPECTmanual0(int *ret){
	(void) ret; /* fool compiler */
	dumpManualHeader(GDKout);
	dumpManual(GDKout, getClient()->nspace,1);
	dumpManualFooter(GDKout);
	return MAL_SUCCEED;
}
str INSPECThelp(int *ret, str *mod) 
{	Client cntxt= getClient();
	Scope m;
	Symbol s;
	str msg;
	int i;
	BAT *b = BATnew(TYPE_str, TYPE_str, 256);
        if (b == 0) 
		return throwMessage("reference.help", "failed to create BAT");
        return throwMessage("reference.help", "Search by keyword not yet available");

	m= findScope(cntxt->nspace,*mod);
	if(m)
	for(i=0;i<256;i++){
		s= m->subscope[i];
		while(s!= NULL){
			msg= s->def->help;
			if( msg){
				BUNins(b,s->name,msg);
			}
			s= s->peer;
		}
	}
	@:Pseudo(help,Comment)@
	return MAL_SUCCEED;
}
str INSPECThelp2(int *ret, str *mod, str *fcn) 
{	Symbol s;
	str msg;

	BAT *b = BATnew(TYPE_str, TYPE_str, 256);
        if (b == 0) 
		return throwMessage("reference.helpComment", "failed to create BAT");

	s= findSymbol(*mod,*fcn);
	while(s!= NULL){
		if(idcmp(s->name,*fcn)==0){
			msg= s->def->help;
			if(msg== NULL) msg= str_nil;
			BUNins(b,s->name,msg);
		}
		s= s->peer;
	}
	@:Pseudo(help,Comment)@
	return MAL_SUCCEED;
}

@}
