@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2003 CWI.
@' All Rights Reserved.
@'
@' Contributor(s):
@'              Martin Kersten <Martin.Kersten@cwi.nl>
@'              Peter Boncz <Peter.Boncz@cwi.nl>
@'              Niels Nes <Niels.Nes@cwi.nl>
@'              Stefan Manegold  <Stefan.Manegold@cwi.nl>

@f mapi
@a N.J. Nes P. Boncz M. Kersten
@t Monets Simple Internet Interface
@v 1.1

This module contains a simple interface for setting up
internet connections and to initialize a client session.
Without loading this interface, Monet runs in administrator
mode. The information about activitated listeners can be
obtained with the 'inspect' module.

Clients may initialize a private listener to implement
specific services. For example, in an OLTP environment
it may make sense to have a listener for each transaction
type, which simply parses a sequence of transaction parameters.

The information about open listeners is maintain in global tables.
They behave as views on the actual state.
No protection is currently possible against malicious users changing them. 

Authorization of access to the server is handled as part
of the client record initialization phase.
@mal
module mapi;

command listen():int  = MAPIlisten_default
	comment "Start a Mapi server with the default settings.";
command listen(port:lng):int  = MAPIlisten_port
	comment "Start a Mapi server with the default settings.";
command listen(port:int, maxusers:int):int = MAPIlisten
	comment "Start a Mapi server.";

command stop(id:int):bit = MAPIstop
	comment "Terminate a specific client identified by index
		in the client table.";
command stop(name:str):bit = MAPIstopClient
	comment "Terminate all sessions held by a client";

command suspend(sessionkey:lng,timeout:lng):void= MAPIsuspend
	comment "Suspend a client interactiont using a user-supplied session key. 
		The session is broken when the timer (in seconds) for the 
		reconnect expires.";

command resume(sessionkey:lng):void = MAPIresume
	comment "Resume the interaction with a specific client thread";

command trace(nme:str, flag:bit):void = MAPItrace2
	comment "Trace (on/off) receipt of all messages from a specific user";
command trace(flag:bit):void = MAPItrace
	comment "Trace (on/off) receipt of messages for all users";

@h

#ifndef MAPI_H
#define MAPI_H

#define MAPIPORT	50000
#define MAPIMAXUSERS 	5

#define DEBUG_MAPI	1 

#endif /* MAPI_H */
@c
#include "mapi.h"
#include "mal_client.h"
#include  <sys/socket.h> 

#define SOCKPTR struct sockaddr *

static int mapiSpy= 1;

void MAPIlistenThread(int sock)
{
	int 	msgsock= -1;
	do {
#ifdef DEBUG_MAPI
		printf("wait for next connection\n");
		fflush(stdout);
#endif
       		msgsock = accept(sock, (SOCKPTR) 0, (size_t *)0);
		if (msgsock == -1) {
			if (MT_geterrno() != EINTR) {
				GDKsyserror("monetServer: accept failed\n");
				return ;
	    		}
		} else if (msgsock > 0) {
			int i;
			stream *fdin= block_stream(socket_rstream(msgsock,"Mserver mapi read"));
			stream *fdout= socket_wastream(msgsock,"Mserver mapi write");
			char *command= (char*) GDKmalloc(BLOCK),*s;
			char *user = command, *passwd= NULL;
			int skey=0;

#ifdef DEBUG_MAPI_2
			printf("mapi:About to read block\n");
			fflush(stdout);
#endif
			/* Get at most 1 BLOCK with identity information*/
			if( (i= fdin->read(fdin,command,1,BLOCK)) < 0){
				GDKerror("Block size error in mapi.mx\n");
				printf("%d [%d] bytes read:%s\n",i,BLOCK,command);
				fflush(stdout);
				continue;
			}
#ifdef DEBUG_MAPI_2
			printf("mapi:Client accepted %s\n", command);
			fflush(stdout);
#endif
			scheduleClient(command,msgsock,fdin,fdout);
		}
	} while (1);
}


str MAPIlisten(int *ret, int *port, int *maxusers){
	struct sockaddr_in server;
	int 	sock;
#ifdef AIX
	size_t 	length;
#else
	int 	length;
#endif
	int    	on = 1;
	int 	msgsock;
	int	i = 0;
	pid_t	pid;
	char 	msg[512];
	char 	host[512];

	sock = socket(AF_INET, SOCK_STREAM, 0);
	if (sock < 0) {
		return throwMessage("mapi.listen", "creation of socket failed");
	}
@-
Set server port and allow internet connections from any workstation.
Bind the socket to the server port.
The port id is obtained from the Monet configuration file.
@c
	if (*port == 0)
		*port = MAPIPORT;
#ifdef DEBUG_MAPI
	THRprintf(GDKerr, "start at %d\n", *port);
#endif
	server.sin_family = AF_INET;
	server.sin_addr.s_addr = INADDR_ANY;
	server.sin_port = htons((unsigned short)((*port)&0xFFFF));
   	for (i=0;i<8;i++)
	    server.sin_zero[i]=0;
 
	setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, (char*) &on, sizeof on);

	length = sizeof(server);
	if (bind(sock, (SOCKPTR)&server, length) < 0) {
		return throwException(MALEXCEPTION,"mapi.listen",
			"binding to socket (%d) failed", *port);
	}
@-
Get the new information for the server socket and start listening.
@c
	if (getsockname(sock, (SOCKPTR)&server, &length) < 0) {
		return throwMessage("mapi.listen", "error getting socket name");
	}
	listen(sock, *maxusers); 

	if( MT_create_thread((MT_Id *)&pid, MAPIlistenThread, (void*) sock) <0){
		return throwMessage("mapi.listen", "starting thread failed");
	}
#ifdef DEBUG_MAPI
	THRprintf(GDKerr, "Internet started at %d\n", server.sin_port);
#endif
	gethostname(host,512);
	{int i;
	snprintf(msg,512,"#Ready to accept connections on %s:",host);
	i= strlen(msg);
	snprintf(msg+i,512-i,"%d\n",*port);
	}
	stream_printf(GDKout,"%s",msg);
	*ret = TRUE;
	return MAL_SUCCEED;
}

str MAPIlisten_default(int *ret){
	int port = MAPIPORT;
	int maxusers = MAPIMAXUSERS;
	return MAPIlisten(ret, &port, &maxusers);
}
str MAPIlisten_port(int *ret, int *pid){
	int port = *pid;
	int maxusers = MAPIMAXUSERS;
	return MAPIlisten(ret, &port, &maxusers);
}
@-
An internet connection may be terminated from the server console.
And killing the administrator this way is prohibited.
@c
str MAPIstop(int *ret, int *id) {
	return stopClientIndex(getClient(), *id);
}

str MAPIstopClient(int *ret, str *nme) {
	return stopClient(getClient(), *nme);
}
str MAPIsuspendClient(int *ret, int *skey, int *timeout) {
	return suspendClient(getClient(), *skey, *timeout);
}
str MAPIresumeClient(int *ret, int *skey) {
	return resumeClient(getClient(), *skey);
}
@-
It is advisable to trace the interactions of clients on the server
side. At least as far as it concerns requests received.
The kernel supports this 'spying' behavior with a file descriptor
field in the client record.
@c
str MAPItrace2(int *ret, str *nme,int *flg){
	traceClient(*nme,*flg);
	return MAL_SUCCEED;
}

str MAPItrace(int *res, int *flg){
	traceAllClients(*flg);
	mapiSpy = *flg;
	return MAL_SUCCEED;
}
str MAPIsuspend(int *res, int *skey, int *timeout){
	return MAL_SUCCEED;
}
str MAPIresume(int *res, int *skey){
	return MAL_SUCCEED;
}
