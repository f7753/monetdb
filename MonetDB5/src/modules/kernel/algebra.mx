@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2003 CWI.
@' All Rights Reserved.
@'
@' Contributor(s):
@'              Martin Kersten <Martin.Kersten@cwi.nl>
@'              Peter Boncz <Peter.Boncz@cwi.nl>
@'              Niels Nes <Niels.Nes@cwi.nl>
@'              Stefan Manegold  <Stefan.Manegold@cwi.nl>

@f algebra
@a Peter Boncz, Martin Kersten, Niels Nes
@v 2.0
@t BAT Algebra

@* Introduction
This modules contains the most common algebraic BAT manipulation 
commands. We call them @#algebra@, because all operations take
values as parameters, and produce new result values, but  
@%do not modify their parameters@.
@
@* Module Definition 
Unlike the previous Monet versions, we reduce the number
of functions returning a BAT reference. This was previously needed
to simplify recursive bat-expression and manage reference counts.
In the current version we return only a BAT identifier when a new
bat is being created.
@-
All parameters to the modules are passed by reference.
In particular, this means that
string values are passed to the module layer as (str *)
and we have to de-reference them before entering the gdk library.
This calls for knowlegde on the underlying BAT typs`s
@= derefStr
        if( @1->@2type== TYPE_str) @3 = *(str *)@3;
@
We split between selections that return one value, and selections 
that return a BAT.
@+ Value Selections
[Somehow we need this next marker to force Mx to produce good output]
@-

@mal
module algebra;

command exist(b:bat[any::1,any], h:any::1) : bit = CMDexist
comment "Returns whether 'h' occurs as a head value in b.";

command exist(b:bat[any::1,any::2], h:any::1, t:any::2) : bit = CMDexistBUN
comment "Returns true when 'h,t' occurs as a bun in b.";

command find(b:bat[any::1,any::2], h:any::1): any::2 = CMDfind
comment "Returns the tail value 't' for which some [h,t] BUN exists in b.
 If no such BUN exists, an error occurs." ;

command position(b:bat[any::1,any], val:any::1) : int = CMDposition
comment "Returns the BAT position e [0.. b.count> of a 'val' in the 
head column of b.  It gives an error if 'val' does not occur in b. ";
 
command position(b:bat[any::1,any::2], val:any::1, tval:any::2) : int = CMDpositionBUN
comment "Returns the BAT position e [0.. b.count> of a 'val' in the 
head column of b.  It gives an error if 'val' does not occur in b. ";
 
command fetch(b:bat[any,any::1], x:oid) : any::1 = CMDfetchoid
comment "Returns the tail value of the BUN at the x-th position with 0 <= x < b.count";
command fetch(b:bat[any,any::1], x:lng) : any::1 = CMDfetch
comment "Returns the tail value of the BUN at the x-th position with 0 <= x < b.count";

@+ BAT Selections
@- positional select
@mal
command fetch(b:bat[any::1,any::2], s:bat[int, any] ) : 
				bat[any::1,any::2] = CMDfetchbat
comment "Returns a positional selection of b by the integer head values of s";
command fetch(b:bat[any::1,any::2], s:bat[lng, any] ) : 
				bat[any::1,any::2] = CMDfetchbat
comment "Returns a positional selection of b by the integer head values of s";
command fetch(b:bat[any::1,any::2], s:bat[oid, any]) : 
				bat[any::1,any::2] = CMDfetchbat
comment "Returns a positional selection of b by the oid head values of s";
@- range select
@mal
command select (b:bat[any::1,any::2], low:any::2, high:any::2) : 
				bat[any::1, any::2] = CMDselect
comment "Select all BUNs of a BAT that have tail values: {v| low <= v <= high}.
NIL boundary values have a special meaning.
+ low  == nil means: no lower bound
+ high == nil means: no upper bound.

NOTE 1: you should cast the nil to the appropriate type, e.g. int(nil)
        in order to cirumvent type clashes.
NOTE 2: as the 'nil' element has no clear place in the ordered domain 
        of values, tuples with 'nil values are NEVER returned by the 
        range select.";
@- unary range select
@mal
command uselect (b:bat[any::1,any::2], low:any::2, high:any::2) : 
				bat[any::1, void] = CMDuselect
comment "Select on tail, returning only the head values. 
 SEE ALSO: select(bat,low,high).";
@- value select
@mal
command select ( b:bat[any::1,any::2], value:any::2) :
                                bat[any::1, any::2] = CMDselect1
comment "Select all BUNs of a BAT with a certain tail value. Selection
 on NIL is also possible (it should be properly casted, e.g.: int(nil)).";
@- unary value select
@mal
command uselect ( b:bat[any::1,any::2], value:any::2) : 
				bat[any::1, void] = CMDuselect1
comment "Value select, but returning only the head values.
 SEE ALSO: select(bat,val)";
@mal
command fragment ( b:bat[any::1,any::2], 
	hlow:any::1, hhigh:any::1,
	tlow:any::2, thigh:any::2 ) : 
				bat[any::1,any::2] = CMDfragment
comment "Select both on head and tail range.";
command slice(b:bat[any::1,any::2], x:int, y:int) : 
				bat[any::1,any::2] =CMDslice
comment "Return the slice with the BUNs at position x till y.";
@- random selection 
@mal
command sample ( b:bat[any::1,any::2], num:int ) : 
				bat[any::1,any::2] = CMDsample
comment "Produce a random selection of size 'num' from the input BAT.";
@- substring select 
@mal
command like ( b:bat[any::1, str], substr:str) :  
				bat[any::1, str] = CMDlike
comment "Selects all elements from the input BAT that have 'substr'
as substring in the tail.";
@+ BAT copying
@mal
command copy( b:bat[any::1,any::2]) : 
				bat[any::1, any::2] = CMDcopy
comment "Returns physical copy of a BAT.";
@- sorted copy
@mal
command sort( b:bat[any::1,any::2]) : 
				bat[any::1, any::2] = CMDsort
comment "Returns a copy of a BAT sorted on the head column.";

#command sort_ht( b:bat[any::1,any::2]) : bat[any::1, any::2] = CMDsort_ht
#comment "Returns a lexicographically sorted copy of a BAT.";
@- vertical projection
This operation has been moved to module mal, because it requires access
the type identifier for the second argument.
to the context.
#pattern project( b:bat[any::1,any], val:any::2) : 
				#bat[any::1, any::2] = CMDproject
#comment "Fill the tail column with a constant value.";
@+ Sets
@T
Sets in Monet can be viewed in two ways:
\begin{itemize} 
\item by looking at both colums of a BAT together (Set-, or s-operators).
\item by looking at the head column only (Key- or k-operators).
\end{itemize} 
For this reason, all standard set operations come in two flavors:
\begin{itemize}
\item k-{\tt operand}, which look only at the head column.
\item s-{\tt operand} series, that look at the whole BUN.
\end{itemize}
@

@T
Operands provided are:
\begin{itemize}
\item {\tt [s,k]unique} (bat[any::1,any::2]) : bat[any::1,any::2]\\
produces a copy of the bat, with double elimination
\item {\tt [s,k]union}(bat[any::1,any::2],bat[any::1,any::2]) : bat[any::1,any::
2]\\
bat union.
\item {\tt [s,k]diff}(bat[any::1,any::2],bat[any::1,any::2]) : bat[any::1,any:
:2]\\
bat difference.
\item {\tt [s,k]intersection}(bat[any::1,any::2],bat[any::1,any::2]) : bat[any:
:1,any::2]\\
bat intersection.
\end{itemize}
Implementations typically take two forms: if the input relation(s) is/are
ordered, a merge-algorithm is used. Otherwise, hash-indices are produced
on demand for the hash-based algorithms.
\\
The {\tt [k,s]intersect(l,r)} operations result in all BUNs of {\tt l} that 
are also in {\tt r}. They do not do double-elimination over the {\tt l} BUNs.
\\
The {\tt [k,s]diff(l,r)} operations result in all BUNs of {\tt l} that are
not in {\tt r}. They do not do double-elimination over the {\tt l} BUNs.
\\
The {\tt [k,s]union(l,r)} operations result in all BUNs of l that are  
not in {\tt r}, plus all BUNs of {\tt r}. They do not do double-elimination 
over the {\tt l} nor {\tt r} BUNs.
\\
Operations with double-elimination can be formed by performing 
{\tt [k,s]unique(l)} on their operands.
\\
The {\tt kintersect(l,r)} is used also as implementation for the 
{\tt semijoin()}.

@- bun-unique elements
@mal
command unique (b:bat[any::1,any::2] ) : bat[any::1,any::2] = CMDsunique; 
command sunique (b:bat[any::1,any::2] ) : bat[any::1,any::2] = CMDsunique
comment "Select unique tuples from the input BAT. Double elimination is 
 done over BUNs as a whole (head and tail). 
 Result is a BAT with real set() semantics.";
@- head-unique elements
@mal
command kunique ( b:bat[any::1,any::2] ) : bat[any::1,any::2] = CMDkunique
comment "Select unique tuples from the input BAT. Double elimination is done
 only looking at the head column. Result is a BAT with hkeyed() == true.";

command tunique ( b:bat[any::1,any::2] ) : bat[any::1,any::2] = CMDtunique
comment "Select unique tail tuples from the input BAT. equivalent to
	revers().kunique() ";

@- bun-intersecting elements
@mal
command intersect ( left:bat[any::1,any::2], right:bat[any::1,any::2]) : 
				bat[any::1,any::2] = CMDsintersect; 
command sintersect ( left:bat[any::1,any::2], right:bat[any::1,any::2]) : 
				bat[any::1,any::2] = CMDsintersect
comment "Returns the intersection taken over *both* columns of two BATs.
 Results in all BUNs of 'left' that are also in 'right'. Does *not* do 
 double-elimination over the 'left' BUNs, If you want this, use:
 'sintersect(left.sunique,right.sunique)' or: 'sintersect(left,right).sunique'.";

@- head-intersecting elements (a.k.a. semijoin)
@mal
command semijoin( left:bat[any::1,any::2], right:bat[any::1,any] ) :
				bat[any::1,any::2] = CMDsemijoin
comment "Returns the intersection taken over only the *head* columns of 
two BATs. Results in all BUNs of 'left' that are also in 'right'. Does *not* do 
 double-elimination over the 'left' BUNs, If you want this, use:
 'kintersect(left.kunique,right.kunique)' or: 'kintersect(left,right).kunique'.";

command semijoin( left:bat[void,any::2], right:bat[oid,any] ) :
				bat[oid,any::2] = CMDsemijoin
comment "patch to enable semijoin over void/oid columns";

command kintersect ( left:bat[any::1,any::2], right:bat[any::1,any] ) :
				bat[any::1,any::2] = CMDsemijoin
comment "Returns the intersection taken over only the *head* columns of 
two BATs. Results in all BUNs of 'left' that are also in 'right'. Does *not* do 
 double-elimination over the 'left' BUNs, If you want this, use:
 'kintersect(left.kunique,right.kunique)' or: 'kintersect(left,right).kunique'.";
@- bun-differing elements
@mal
command diff ( left:bat[any::1,any::2], right:bat[any::1,any::2] ) : 
				bat[any::1,any::2] = CMDsdiff; 
command sdiff ( left:bat[any::1,any::2], right:bat[any::1,any::2] ) : 
				bat[any::1,any::2] = CMDsdiff
comment "Returns the difference taken over *both* columns of two BATs.  
 Results in all BUNs of 'left' that are *not* in 'right'. Does *not* do
 double-elimination over the 'left' BUNs, If you want this, use:
 'sdiff(left.sunique,right.sunique)' or: 'sdiff(left,right).sunique'.";
@- head-differing elements
@mal
command kdiff ( left:bat[any::1,any::2], right:bat[any::1,any] ) :
				bat[any::1,any::2] = CMDkdiff
comment "Returns the difference taken over only the *head* columns of two BATs. 
 Results in all BUNs of 'left' that are *not* in 'right'. Does *not* do
 double-elimination over the 'left' BUNs, If you want this, use:
 'kdiff(left.kunique,right.kunique)' or: 'kdiff(left,right).kunique'.";
@- union on bun
@mal
command union ( left:bat[any::1,any::2], right:bat[any::1,any::2]) : 
				bat[any::1,any::2] = CMDsunion; 
command sunion ( left:bat[any::1,any::2], right:bat[any::1,any::2]) : 
				bat[any::1,any::2] = CMDsunion
comment "Returns the union of two BATs; looking at both columns of both BATs. 
 Results in all BUNs of 'left' that are  not in 'right', plus all BUNs 
 of 'right'. *no* double-elimination is done. If you want this, do: 
 'sunion(left.sunique,right.sunique)' or: 'sunion(left,right).sunique'.";
@- union on head
@mal
command kunion ( left:bat[any::1,any::2], right:bat[any::1,any::2]):bat[any::1,any::2] = CMDkunion
comment "Returns the union of two BATs; looking at head-columns only. 
 Results in all BUNs of 'left' that are  not in 'right', plus all BUNs 
 of 'right'. *no* double-elimination is done. If you want this, do: 
 'kunion(left.kunique,right.kunique)' or: 'sunion(left,right).kunique'.";
@+ Joins
The core of every relational engine.
Signature Changed: Output tail type incorrect because of soid to coid switch. 

@- join(projected out join columns)
The join collection provided by the GDK kernel.
Note that joins over void columns are handled as if they are oids.
@mal
command join( left:bat[any::1,any::2], right:bat[any::2,any::3]) :
                               bat[any::1,any::3] = CMDjoin
comment "Returns all BUNs, consisting of a head-value from 'left' and
a tail-value from 'right' for which there are BUNs in 'left'
and 'right' with equal tail- resp. head-value (i.e. the join
columns are projected out).";

command join( left:bat[any::1,void], right:bat[oid,any::3]) :
                               bat[any::1,any::3] = CMDjoin;
command join( left:bat[any::1,oid], right:bat[void,any::3]) :
                               bat[any::1,any::3] = CMDjoin;

command fetchjoin ( left:BAT[any::1,any::2],right:BAT[any::2,any::3] ) :
                    BAT[any::1,any::3] = CMDfetchjoin
comment "Hook directly into the fetch implementation of the join.";

command mergejoin (left:BAT[any::1,any::2], right:BAT[any::2,any::3]) :
                    BAT[any::1,any::3] = CMDmergejoin
comment "Hook directly into the merge implementation of the join.";

command hashjoin ( left:BAT[any::1,any::2], right:BAT[any::2,any::3]) :
                    BAT[any::1,any::3] = CMDhashjoin
comment "Hook directly into the hash implementation of the join.";

command indexjoin ( left:BAT[any::1,any::2], right:BAT[any::2,any::3]) :
                    BAT[any::1,any::3] = CMDindexjoin
comment "Hook directly into the index implementation of the join.";

@- Outer Join
@mal
command outerjoin( outer:bat[any::1,any::2], inner:bat[any::2,any::3]) :
                                bat[any::1,any::3] = CMDouterjoin
comment "Returns all the result of a join, plus the BUNS formed NIL in
the tail and the head-values of 'outer' whose tail-value does
not match an head-value in 'inner'.";

@- { <,<=,=,>=,> } Join
@mal
command thetajoin( left:bat[any::1,any::2], right:bat[any::2,any::3], 
		opname:str) : bat[any::1,any::3] = CMDthetajoin
comment "Theta join on for 'mode' in { LE, LT, EQ, GT, GE }.
JOIN_EQ is just the same as join(). All other options do merge
algorithms; either using the fact that they are ordered()
already (left on tail, right on head), or by using/creating
binary search trees on the join columns. ";
@- Theta Join with inner columns
@mal
command theta ( inner_result:bat[any::2,any::2], 
		outer_result:bat[any::1,any::3],
		left:bat[any::1,any::2], 
		right:bat[any::2,any::3], opname:str ) 
				= CMDtheta
comment "Theta join, just as simple thetajoin(l,r); the difference
is that it returns two values, which are added to the first params
'inner_result' and 'outer_result'; 'inner_result' gets all matching
inner tuples, 'outer_result' the other two (what would have the
result of thetajoin(l,r)).";
@- Band Join (approximate match)
@mal
command bandjoin( outer:bat[any::1,any::2], 
		   inner:bat[any::2,any::3],
		   minus:any::2 , plus:any::2 ) : 
				bat[any::1,any::3] = CMDbandjoin
comment "This is a join() for which the predicate is that two BUNs match if
the left-tail value is within the range [right-head - minus,
right-head + plus]
Works only for the builtin numerical types, and their derivates.";
@+ OID Introducing Commands
For relational processing, some operators are necessary to produce newly 
initiated OID columns, for representing n-ary (intermediary) relations. 

@- OID head column
@mal
command mark( b:bat[any::1,any] ) : bat[any::1,oid] = CMDmark_default
comment "Produces a new BAT with fresh unique OIDs in the tail.";

command mark( b:bat[any::1,any],base:void ): bat[any::1,oid] = CMDmark_default
comment "Produces a new BAT with fresh unique OIDs in the tail.";

command mark( b:bat[any::1,any], base:oid ) : bat[any::1,oid] = CMDmark
comment "Produces a new BAT with fresh unique dense sequense of OIDs in the tail
 that starts at base (i.e. [base,base+1,..base+b.count()-1] ).";
@- number tail column
@mal
command number( b:bat[any::1,any] ) : bat[any::1,int]  = CMDnumber
comment "Produces a new BAT with identical head column, and consecutively
increasing integers (starting with 0) in the tail column.";

@+ BAT fragmentation commands
Various operations for splitting BATs into useful fragments.

@- Hash Split
The commands below is temporarilly postponed
command hashsplit ( b:bat[any::1,any::2] , buckects:int ) :
			 	bat[int,bat[any::1,any::2]] = CMDhashsplit
comment "Split a BAT on tail column according (hash-value MOD buckets).
Returns a recursive BAT, containing the fragments in the tail,
their bucket number in the head.";

command uhashsplit ( b:bat[any::1,any::2], buckets:int ) :
			 	bat[int,bat[any::1,any::2]] = CMDuhashsplit
comment "Same as hashsplit, but only collect the head values in the fragments";
@- Range Split
command rangesplit ( b:bat[any::1,any::2], ranges:int ) : 
				bat[any::2,bat[any::1,any::2]] = CMDrangesplit
comment "Split a BAT on tail column in 'ranges' equally sized
consecutive ranges. Returns a recursive BAT, containing the
fragments in the tail, the higher-bound of the range in the head.
The higher bound of the last range is 'nil'.";

command urangesplit ( b:bat[any::1,any::2], ranges:int ) : 
				bat[any::2,bat[any::1,void]] = CMDurangesplit
comment "Same as rangesplit, but only collect the head values in the fragments" ;

@+ Common BAT Aggregates
These operations examine a BAT, and compute some simple aggregate result 
over it.
@- BAT size
@mal
command count( b:bat[any,any] ) : int = CMDcount
comment "Return the number of elements currently in a BAT.";
command count ( b:bat[any,any], ignore_nils:bit ) : int = CMDcount_nil
comment "Return the number of elements currently in a BAT
ignores BUNs with nil-tail iff ignore_nils==TRUE.";
command topN ( b:bat[any,any], top:lng ) : int = CMDtopN
comment "Trim all but the top N tuples.";
@- Histogram on Tail 
@mal
command histogram ( b:bat[any,any::2]) : bat[any::2,int] = CMDhistogram
comment "Produce a BAT containing the histogram of the tail values.
 bat.histogram() ::= {count}(bat.reverse)";

@-
command out of order right now. Should become an optimization pattern
group.count -> histogram(bat.reverse)
command {count} ( b:bat[any::2,any]) : 
				bat[any::2,int] = CMDhistogram_rev
comment "Count the number of groups.
 It has fast implementation: histogram(bat.reverse)";

@- Default Min and Max
@T
Implementations a generic Min and Max routines get declared first. The 
{\tt min()} and {\tt max()} routines below catch any tail-type. 
The type-specific routines defined later are faster, and will 
override these any implementations.
@mal
command card ( b:bat[any,any] ) : lng = CMDcard
comment "Return the cardinality of the BAT tail values.";

command size ( b:bat[any,any] ) : int = CMDBATsize
comment "Return the current size (in number of elements) of a BAT.";

@- Default Min and Max
@T
Implementations a generic Min and Max routines get declared first. The
{\tt min()} and {\tt max()} routines below catch any tail-type.
The type-specific routines defined later are faster, and will
override these any implementations.

@- minimum tail value
@mal
command min(b:bat[any::1,any::2]): any::2 = CMDminany
	comment "Give the lowest tail value. Error on empty BATs.";

command max(b:bat[any::1,any::2]): any::2 = CMDmaxany
	comment "Give the highest tail value. Error on empty BATs.";
@+ Type-Specific Sum, Prod, Max and Min
@T
For X $\in$ \{ sht,int,flt,dbl,lng \},  we define (using the {\em aggregate}
macro):
\begin{itemize}
\item command sum(bat[any,X] : X, 
\item command prod(bat[any,X] : X, and 
\item command max(bat[any,X] : X, and 
\item command min(bat[any,X] : X. 
\end{itemize}
@-
@= sum_definition
command sum (b:bat[any,@1] ) : @2 = CMDsum_@1_@2 
	comment "Gives the sum of all tail values";
command prod(b:bat[any,@1] ) : @2 = CMDprod_@1_@2 
	comment "Gives the produc of all tail values";
@mal
@:sum_definition(uchr,uchr)@
@:sum_definition(uchr,sht)@
@:sum_definition(uchr,int)@
@:sum_definition(uchr,lng)@
@:sum_definition(sht,sht)@
@:sum_definition(sht,int)@
@:sum_definition(sht,lng)@
@:sum_definition(int,int)@
@:sum_definition(int,lng)@
@:sum_definition(lng,lng)@
@:sum_definition(flt,flt)@
@:sum_definition(flt,dbl)@
@:sum_definition(dbl,dbl)@
@-
@= aggregate_definition
command @1 ( b:bat[any,@2] ) : @2 = CMD@1_@2 comment @3;
@= aggregate
@:aggregate_definition(@1,uchr,@2)@
@:aggregate_definition(@1,sht,@2)@
@:aggregate_definition(@1,int,@2)@
@:aggregate_definition(@1,flt,@2)@
@:aggregate_definition(@1,dbl,@2)@
@:aggregate_definition(@1,lng,@2)@

@mal
@:aggregate(max,"Give the highest tail value. Error on empty BATs.")@
@:aggregate(min,"Give the lowest tail value. Error on empty BATs.")@

@+ Exented selection predicates
For SQL convenience we provide a serie of interval selectors.
@mal
# Extend select to the cases where we can ignore nils altogether
function between(b:bat[any::1,any::2], l:any::2, h:any::2):bat[any::1,any::2];
	k:= select(b,l,h);
	return k;
end between;
# between Close Open interval
function betweenCO(b:bat[any::1,any::2], l:any::2, h:any::2):bat[any::1,any::2];
	t:= select(b,l,h);
	tr:= reverse(t);
	z:= delete(tr,h);
	zr:= reverse(z);
	return t;
end betweenCO;
function betweenOC(b:bat[any::1,any::2], l:any::2, h:any::2):bat[any::1,any::2];
	t:= select(b,l,h);
	tr:= reverse(t);
	z:= delete(tr,l);
	zr:= reverse(z);
	return t;
end betweenOC;
function betweenOO(b:bat[any::1,any::2], l:any::2, h:any::2):bat[any::1,any::2];
	t:= select(b,l,h);
	tr:= reverse(t);
	z:= delete(tr,l);
	z:= delete(z,h);
	zr:= reverse(z);
	return t;
end betweenOO;
@+ Modeling With Properties
@T
The Monet kernel performs {\em run-time optimizations}. To choose between
alternaticve algorithms in a sensible way, it maintains knowledge about 
each BAT, sometimes as a {\em BAT property}, sometimes as two
{\em column properties} for each column (head and tail)
of a BAT. An example of the former is {\em size(bat) : int}
(which gives the number of BUNs in a BAT), an example
of the latter is {\tt ordered(column) : bit}, indicating 
whether the column contains its valued stored in ascending order.
The convention is to use a BAT as operand also for the column
properties; which then is supposed to be valid for the head
column ({\tt ordered(BAT)}). Tail columns can be described by 
using the mirror BAT with the minus operator ({\tt ordered(-BAT)}).

@- Column Properties
@T
\begin{description}
\item[{\tt ordered(BAT) : bit}] 
	TRUE if the head column is stored in ascending order, else FALSE.
\item[{\tt keyed(BAT) : bit}] 
	TRUE if no duplicates are present in the head column, else FALSE.
\item[{\tt idx(BAT) : bit}] 
	TRUE if a binary index tree search accelerator is present on 
	the head column of the BAT, else FALSE.
\item[{\tt hashtab(BAT) : bit}] presence of hash table on the head column of 
	a BAT. TRUE if a bucket-chained hash table search accelerator is 
	present on the head column of the BAT, else FALSE.
\item[{\tt subcol(BAT, BAT) : bit}] 
	TRUE if the bag of all values in the head column of the left BAT is
	a bag-subset of the bag of all values in the head column of the 
	right BAT, else FALSE. 
\item[{\tt sync(BAT) : oid}] 
	Sync-OID on the head column of a BAT. A sync-OID denotes some unique
	sequence of values. If two columns have the same sync-OID, then they
	are guaranteed to contain the same values, in the same sequence.
\end{description}

@- BAT properties
@T
\begin{description}
\item[{\tt size(BAT) : int}] 
	The (estimated) length of a column.
\item[{\tt unique(BAT) : int}] 
	The (estimated) number of distinct values in one column.
\item[{\tt subset(BAT, BAT) : bit}] 
	TRUE if the left BAT is a subset of the BUNs of the right BAT, 
	else FALSE.
\item[{\tt setunique(BAT) : bit}] 
	TRUE if the BAT contains no duplicate BUNs, else FALSE.
\end{description}

@- Property Propagation Rules
@T
At database creation time, the properties of the BATs in the database
can be derived directly from the database schema.

When queries are executed, they will produce {\em intermediate results},
which in terms are operands for further execution. Hence it is necessary
to {\em propagate properties} from the operands of an algebraic operator,
to its result. 

This process can be captured by having a series of {\em propagation rules} 
for each algebraic operand. Since each algebraic operands may apply
different strategies, according to different status in its operand properties, 
each algebraic operator may have different propagation rules with these 
different situations as conditions.

@* Command Implementations in C
This module contains just a wrapper implementations; since all described 
operations are part of the GDK kernel.

@-
The BAT identifiers passed through this module may indicate
that the 'reverse' view applies. This should be taken into
account while resolving them.
@= getBATdescriptor
        if( BBPcheck(*@2,"@4")==0) 
                return throwMessage("algebra.@4", "cannot access bat @2 in bbp");
        @3= (BAT*) BBPgetdesc(*@2);
        if( @3 == NULL) { *@1 = 0; 
                return throwMessage("algebra.@4", "cannot access descriptor @2");
	}
	if( *@2 <0){ /* BAT reverse */ @3 = BATmirror(@3); }
@+ BAT sum operation
The sum aggregate only works for int and float fields.
The routines below assumes that the caller knows what type
is large enough to prevent overflow.

@= sum_implementation
str CMDsum_@1_@2(@2* res, int *bid) {
	BAT *b;
        BUN p,q;
        int xx;
        @2 result=@3;

	@:getBATdescriptor(res,bid,b,sum)@
        BATcheck(b,"BATsum_@1_@2");
        BATloopFast(b, p, q, xx) {
                @1 *value = (@1*) BUNtloc(b, p);
                if (*value == @1_nil) {
                        result = @2_nil; break;
                } else {
                        result += *value;
                }
        }
        *res = result;
        return MAL_SUCCEED;
}

@= prod_implementation
int CMDprod_@1_@2(@2* res, BAT *b) {
        BUN p,q;
        int xx;
        @2 result=@3;

        BATcheck(b,"BATprodInt");
        BATloopFast(b, p, q, xx) {
                @1 *value = (@1*) BUNtloc(b, p);
                if (*value == @1_nil) {
                        result = @2_nil; break;
                } else {
                        result *= *value;
                }
        }
        *res = result;
        return GDK_SUCCEED;
}


@h
#ifndef ALGEBRA_H
#define ALGEBRA_H

#include <gdk.h>
#include "../atoms/uchr.h"
#include "mal_function.h"

mal_export ptr BATmax( BAT *b, ptr res );
mal_export ptr BATmin( BAT *b, ptr res );

#endif

@c
#include "algebra.h"


@:sum_implementation(uchr,uchr,0)@
@:sum_implementation(uchr,sht,0)@
@:sum_implementation(uchr,int,0)@
@:sum_implementation(uchr,lng,0)@
@:sum_implementation(sht,sht,0)@
@:sum_implementation(sht,int,0)@
@:sum_implementation(sht,lng,0)@
@:sum_implementation(int,int,0)@
@:sum_implementation(int,lng,0)@
@:sum_implementation(lng,lng,0)@
@:sum_implementation(flt,flt,0.0)@
@:sum_implementation(flt,dbl,0.0)@
@:sum_implementation(dbl,dbl,0.0)@

@:prod_implementation(uchr,uchr,1)@
@:prod_implementation(uchr,sht,1)@
@:prod_implementation(uchr,int,1)@
@:prod_implementation(uchr,lng,1)@
@:prod_implementation(sht,sht,1)@
@:prod_implementation(sht,int,1)@
@:prod_implementation(sht,lng,1)@
@:prod_implementation(int,int,1)@
@:prod_implementation(int,lng,1)@
@:prod_implementation(lng,lng,1)@
@:prod_implementation(flt,flt,1.0)@
@:prod_implementation(flt,dbl,1.0)@
@:prod_implementation(dbl,dbl,1.0)@
@-
@= aggregate_implementation
str CMDmin_@1(@1* result, int *bid) {
        BAT *b;
        @:getBATdescriptor(result,bid,b,min)@
        if( BATmin(b, result)) return MAL_SUCCEED;
        return throwMessage("algebra.min", "GDKerror");
}
str CMDmax_@1(@1* result, int *bid) {
        BAT *b;
        @:getBATdescriptor(result,bid,b,max)@
        if( BATmax(b, result)) return  MAL_SUCCEED;
        return throwMessage("algebra.max", "GDKerror");
}
@c
@:aggregate_implementation(uchr)@
@:aggregate_implementation(sht)@
@:aggregate_implementation(int)@
@:aggregate_implementation(flt)@
@:aggregate_implementation(dbl)@
@:aggregate_implementation(lng)@

str CMDminany(ptr result, int *bid) {
        BAT *b;
	int res;
        @:getBATdescriptor(&res,bid,b,minany)@
        if (!ATOMlinear(b->ttype))
            return throwMessage("CMDminANY","atom cannot be ordered linearly\n");
        if (ATOMvarsized(b->ttype)){
            *(ptr*) result = BATmin(b, NULL);
	    return MAL_SUCCEED;
	}
        if (BATmin(b, result)) {
            if (b->ttype == TYPE_bat)
                *(bat*) result = BBPdescriptor(*(bat*) result)->batCacheid;
            return MAL_SUCCEED;
        }
        return throwMessage("algebra.min", "GDKerror");
}
str CMDmaxany(ptr result, int *bid) {
        BAT *b;
	int res;
        @:getBATdescriptor(&res,bid,b,maxany)@
        if (!ATOMlinear(b->ttype))
            return throwMessage("CMDminANY","atom cannot be ordered linearly\n");
        if (ATOMvarsized(b->ttype)){
            *(ptr*) result = BATmax(b, NULL);
	    return MAL_SUCCEED;
	}
        if (BATmax(b, result)) {
            if (b->ttype == TYPE_bat)
                *(bat*) result = BBPdescriptor(*(bat*) result)->batCacheid;
            return MAL_SUCCEED;
        }
        return throwMessage("algebra.max", "GDKerror");
}


str CMDtopN(int *res, int *bid, lng *top) {
        if (BBPcheck(*bid, "BATsize")) {
                BAT *b = (BAT*) BBPgetdesc(*bid);
                if (b == NULL) {
                        *res = int_nil;
                } else 
			BATtopN(b, *top);
        }
        return MAL_SUCCEED;
}
str CMDBATsize(int *res, int *bid) {
        if (BBPcheck(*bid, "BATsize")) {
                BAT *b = (BAT*) BBPgetdesc(*bid);
                if (b == NULL) {
                        *res = int_nil;
                } else if (BBP_cache(*bid)) {
                        *res = BATcount(b);
                } else {
                        /* BAT not loaded */
                        *res = (b->batBuns->free - 
			(b->batHole - b->batBuns->base))/BUNsize(b) - 1;
                }
        }
        return MAL_SUCCEED;
}

str CMDcard(int *result, int *bid) {
	BAT *b,*bn;
	@:getBATdescriptor(result,bid,b,card)@
	bn = (BAT*) BATkunique(BATreverse(b));
	if(bn == NULL){
		return throwMessage("algebra.card", "GDKerror");
	}
	*result= BATcount(bn);
	return MAL_SUCCEED;
}

str CMDBATminimum(ptr *result, int *bid) {
	BAT *b;

	@:getBATdescriptor(result,bid,b,min)@
	if (!ATOMlinear(b->ttype)) 
		return throwException(MALEXCEPTION,"algebra.min",
			"'%s' lacks linear order",
					ATOMname(b->ttype));
	if (ATOMvarsized(b->ttype)) {
		*(ptr*) result = BATmin(b, NULL);
		if( *(ptr*) result ) return MAL_SUCCEED; 
		return throwMessage("algebra.min", "GDKerror");
	}
	if (BATmin(b, result)) {
		if (b->ttype == TYPE_bat) 
			*(int*) result = BBPdescriptor(*(int*) result)->batCacheid;
		return MAL_SUCCEED;
	}
	return throwMessage("algebra.min", "GDKerror");
}
str CMDBATmaximum(ptr *result, int *bid) {
	BAT *b;

	@:getBATdescriptor(result,bid,b,max)@
	if (!ATOMlinear(b->ttype)) 
		return throwException(MALEXCEPTION,"algebra.max",
			"'%s' lacks linear order",
				ATOMname(b->ttype));
	if (ATOMvarsized(b->ttype)) {
		*(ptr*) result = BATmax(b, NULL);
		if( *(ptr*) result ) return MAL_SUCCEED; 
		return throwMessage("algebra.max", "GDKerror");
	}
	if (BATmax(b, result)) {
		if (b->ttype == TYPE_bat) 
			*(int*) result = BBPdescriptor(*(int*) result)->batCacheid;
		return MAL_SUCCEED;
	}
	return throwMessage("algebra.max", "GDKerror");
}
str CMDselect1(int *result, int *bid, ptr value) {
	BAT *b, *bn;
	@:getBATdescriptor(result,bid,b,select)@
	@:derefStr(b,t,value)@
	bn = (BAT*) BATselect(b, value, 0);
	if( bn ) {
		*result = bn->batCacheid;
		return MAL_SUCCEED;
	}
	return throwMessage("algebra.select", "GDKerror");
}

str CMDuselect1(int *result, int *bid, ptr value) {
	BAT *b, *bn;
	@:getBATdescriptor(result,bid,b,uselect)@
	@:derefStr(b,t,value)@
	bn = (BAT*) BATuselect(b, value, 0);
	if( bn ) {
		*result = bn->batCacheid;
		return MAL_SUCCEED;
	}
	return throwMessage("algebra.uselect", "GDKerror");
}

str CMDselect(int *result, int *bid, ptr low, ptr high) {
	BAT *b, *bn;
	@:getBATdescriptor(result,bid,b,select)@
	@:derefStr(b,t,low)@
	@:derefStr(b,t,high)@
	bn = (BAT*) BATselect(b, low, high);
	if( bn ) {
		*result = bn->batCacheid;
		return MAL_SUCCEED;
	}
	return throwMessage("algebra.select", "GDKerror");
}
str CMDuselect(int *result, int *bid, ptr low, ptr high) {
	BAT *b, *bn;
	@:getBATdescriptor(result,bid,b,uselect)@
	@:derefStr(b,t,low);@
	@:derefStr(b,t,high);@
	bn = (BAT*) BATuselect(b, low, high);
	if( bn ) {
		*result = bn->batCacheid;
		return MAL_SUCCEED;
	}
	return throwMessage("algebra.uselect", "GDKerror");
}
str CMDfragment(int *result, int *bid, 
		ptr hlow, ptr hhigh, ptr tlow, ptr thigh) 
{
	BAT *b, *bn;
	@:getBATdescriptor(result,bid,b,fragment)@
	@:derefStr(b,h,hlow);@
	@:derefStr(b,h,hhigh);@
	@:derefStr(b,t,tlow);@
	@:derefStr(b,t,thigh);@
	bn = (BAT*) BATrestrict(b, hlow, hhigh, tlow, thigh);
	if( bn ) {
		*result = bn->batCacheid;
		return MAL_SUCCEED;
	}
	return throwMessage("algebra.fragment", "GDKerror");
}

static int operatorCode(str opname){
	if(idcmp(opname,"EQ")==0) return 0;
	if(idcmp(opname,"LT")==0) return -1;
	if(idcmp(opname,"LE")==0) return -2;
	if(idcmp(opname,"GT")==0) return 1;
	if(idcmp(opname,"GE")==0) return 2;
	GDKerror("Illegal operator code, EQ assumed\n");
	return 0;
}
str CMDthetajoin(int *result, int *lid, int *rid, str *opname) {
	BAT *left, *right, *bn;
	int opc= operatorCode(*opname);
	@:getBATdescriptor(result,lid,left,thetajoin)@
	@:getBATdescriptor(result,rid,right,thetajoin)@
	bn = (BAT*) BATthetajoin(left, right, opc);
	if( bn ) {
		*result = bn->batCacheid;
		return MAL_SUCCEED;
	}
	return throwMessage("algebra.thetajoin", "GDKerror");
}
str CMDtheta(int *iid, int *oi, int *lid, int *rid, str *opname) {
	BAT *inner,*outer, *left, *right;
	int result, opc= operatorCode(*opname);
	@:getBATdescriptor(&result,iid,inner,theta)@
	@:getBATdescriptor(&result,oi,outer,theta)@
	@:getBATdescriptor(&result,lid,left,theta)@
	@:getBATdescriptor(&result,rid,right,theta)@
	BATtheta(inner, outer, left, right, opc);
	return MAL_SUCCEED;
}
str CMDbandjoin(int *result, int *lid, int *rid, ptr *minus, ptr *plus) {
	BAT *left, *right, *bn;
	@:getBATdescriptor(result,lid,left,bandjoin)@
	@:getBATdescriptor(result,rid,right,bandjoin)@
	bn = (BAT*) BATbandjoin(left, right, minus, plus);
	if( bn ) {
		*result = bn->batCacheid;
		return MAL_SUCCEED;
	}
	return throwMessage("algebra.bandjoin", "GDKerror");
}

@-
Let cut this text down with some Mx macro's
@= unary
str CMD@1(int *result, int *bid) {
	BAT *b,*bn;
	@:getBATdescriptor(result,bid,b,@1)@
	*result = 0;
	bn = (BAT*) @2(b);
	if( bn ) {
		*result = bn->batCacheid;
		return MAL_SUCCEED;
	}
	return throwMessage("algebra.@1", "GDKerror");
}
@= unaryint
str CMD@1(int *result, int *bid) {
	BAT *b;
	*result = 0;
	@:getBATdescriptor(result,bid,b,@1)@
	*result = (int) @2(b);
	return MAL_SUCCEED;
}
@= binary
str CMD@1(int *result, int *lid, int *rid) {
	BAT *left, *right,*bn;
	*result = 0;
	@:getBATdescriptor(result,lid,left,@1)@
	@:getBATdescriptor(result,rid,right,@1)@
	bn = (BAT*) @2(left, right);
	if( bn ) {
		*result = bn->batCacheid;
		return MAL_SUCCEED;
	}
	return throwMessage("algebra.@1", "GDKerror");
}
@= binaryint
str CMD@1(int *result, int* bid, int *param) {
	BAT *b, *bn;
	*result = 0;
	@:getBATdescriptor(result,bid,b,@1)@
	bn = @2(b, *param);
	if( bn ) {
		*result = bn->batCacheid;
		return MAL_SUCCEED;
	}
	return throwMessage("algebra.@1", "GDKerror");
}
@c
@:unaryint(count, BATcount)@
@:unary(histogram, BAThistogram)@
@:unary(sort, BATsort)@
@:unary(number, BATnumber)@
@:unary(copy, BATcopy)@
@:unary(kunique, BATkunique)@
@:unary(sunique, BATsunique)@
@:binary(join, BATjoin)@
@:binary(semijoin, BATsemijoin)@
@:binary(outerjoin, BATouterjoin)@
@:binary(sunion, BATsunion)@
@:binary(kunion, BATkunion)@
@:binary(sintersect, BATsintersect)@
@:binary(intersect, BATsintersect)@
@:binary(kintersect, BATkintersect)@
@:binary(sdiff, BATsdiff)@
@:binary(kdiff, BATkdiff)@
@:binaryint(sample, BATsample)@

str CMDcount_nil(int *result, int *bid, bit *ignore_nils) {
	BAT *b;
	@:getBATdescriptor(result,bid,b,count_nil)@
	if (*ignore_nils)
	      *result = (int) BATcount_no_nil(b);
	else
	      *result = (int) BATcount(b);
	return MAL_SUCCEED;
}


str CMDfetchjoin(int *result, int *lid, int *rid) {
	BAT *left, *right,*bn;
	int rfetch,lfetch;

	@:getBATdescriptor(result,lid,left,fetchjoin)@
	@:getBATdescriptor(result,rid,right,fetchjoin)@

	rfetch = (BAThdense(right) && ATOMstorage(left->ttype) <= TYPE_int);
	lfetch = (BATtdense(left) && ATOMstorage(right->htype) <= TYPE_int);
	if (lfetch && !(rfetch && BATcount(left) < BATcount(right))) {
		bn= BATfetchjoin(left, right);
	} else if (rfetch) 
		bn= BATmirror(BATfetchjoin(BATmirror(right), BATmirror(left)));

	if( bn ) {
		*result = bn->batCacheid;
		return MAL_SUCCEED;
	}
	return throwMessage("algebra.fetchjoin", "can not perform a fetchjoin");
}
str CMDhashjoin(int *result, int *lid, int *rid) {
	BAT *left, *right,*bn;
	int lsize,rsize;

	@:getBATdescriptor(result,lid,left,hashjoin)@
	@:getBATdescriptor(result,rid,right,hashjoin)@

	lsize = left->batBuns->size + (left->hheap.base?left->hheap.size:0) +
                                 (left->theap.base?left->theap.size:0);
	rsize = right->batBuns->size + (right->hheap.base?right->hheap.size:0) +
                                 (right->theap.base?right->theap.size:0);

	if (rsize < lsize) 
		bn= BATmirror(BAThashjoin(BATmirror(right), BATmirror(left)));
	else	bn= BAThashjoin(left, right);

	if( bn ) {
		*result = bn->batCacheid;
		return MAL_SUCCEED;
	}
	return throwMessage("algebra.hashjoin", "can not perform a hashjoin");
}

str CMDmergejoin(int *result, int *lid, int *rid) {
	BAT *left, *right,*bn;
	int lsize,rsize;

	@:getBATdescriptor(result,lid,left,mergejoin)@
	@:getBATdescriptor(result,rid,right,mergejoin)@
	if ( !((BATtordered(left)&1)||(BAThordered(right)&1)) ) 
		return throwMessage( "algebra.mergejoin",
			"neither left nor right bat is ordered.\n" );

	if ( (left->ttype==TYPE_void) || (right->htype==TYPE_void) ) 
		return throwMessage( "algebra.mergejoin",
			"Cannot perform mergejoin on void fields.\n" );
	bn= BATmergejoin(left,right);
	if( bn ) {
		*result = bn->batCacheid;
		return MAL_SUCCEED;
	}
	return throwMessage("algebra.mergejoin", "can not perform a mergejoin");
}

str CMDindexjoin(int *result, int *lid, int *rid) {
	BAT *left, *right,*bn;
	int lsize,rsize;

	@:getBATdescriptor(result,lid,left,indexjoin)@
	@:getBATdescriptor(result,rid,right,indexjoin)@

	bn= BATthetajoin(left,right, JOIN_EQ);
	if( bn ) {
		*result = bn->batCacheid;
		return MAL_SUCCEED;
	}
	return throwMessage("algebra.indexjoin", "can not perform a indexjoin");
}
str CMDtunique(int *result, int *bid) {
	BAT *b,*bn;
	@:getBATdescriptor(result,bid,b,tunique)@
	*result = 0;
	bn = (BAT*) BATkunique(BATreverse(b));
	if( bn ) {
		*result = bn->batCacheid;
		return MAL_SUCCEED;
	}
	return throwMessage("algebra.tunique", "GDKerror");
}

str CMDmark(int *result, int *bid, oid *base){
	BAT *b, *bn;
	@:getBATdescriptor(result,bid,b,mark)@
	bn= BATmark(b, *base);
	if( bn ) {
		*result = bn->batCacheid;
		return MAL_SUCCEED;
	}
	return throwMessage("algebra.mark", "GDKerror");
}
str CMDmark_default(int *result, int *bid){
	oid base;
	BAT *b;
	@:getBATdescriptor(result,bid,b,mark)@
	base = OIDnew(BATcount(b));
	return CMDmark(result, bid, &base);
}
str CMDhashsplit(int *result, int *bid, int *nfrag){
	BAT *b, *bn;
	@:getBATdescriptor(result,bid,b,hashsplit)@
	bn= BAThashsplit(b, *nfrag, FALSE);
	if( bn ) {
		*result = bn->batCacheid;
		return MAL_SUCCEED;
	}
	return throwMessage("algebra.hashsplit", "GDKerror");
}
str CMDuhashsplit(int *result, int *bid, int *nfrag){
	BAT *b, *bn;
	@:getBATdescriptor(result,bid,b,uhashsplit)@
	bn= BAThashsplit(b, *nfrag, TRUE);
	if( bn ) {
		*result = bn->batCacheid;
		return MAL_SUCCEED;
	}
	return throwMessage("algebra.uhashsplit", "GDKerror");
}
str CMDrangesplit(int *result, int *bid, int *nfrag){
	BAT *b, *bn;
	@:getBATdescriptor(result,bid,b,rangesplit)@
	bn= BATrangesplit(b, *nfrag, FALSE);
	if( bn ) {
		*result = bn->batCacheid;
		return MAL_SUCCEED;
	}
	return throwMessage("algebra.rangesplit", "GDKerror");
}
str CMDurangesplit(int *result, int *bid, int *nfrag){
	BAT *b, *bn;
	@:getBATdescriptor(result,bid,b,urangesplit)@
	bn= BATrangesplit(b, *nfrag, TRUE);
	if( bn ) {
		*result = bn->batCacheid;
		return MAL_SUCCEED;
	}
	return throwMessage("algebra.urangesplit", "GDKerror");
}

str CMDhistogram_rev(int *result, int *bid) {
	BAT *b, *bn;
	@:getBATdescriptor(result,bid,b,histogram)@
	bn =BAThistogram(BATmirror(b));
	if( bn ) {
		*result = bn->batCacheid;
		return MAL_SUCCEED;
	}
	return throwMessage("algebra.histogram", "GDKerror");
} 


@- Substring Select
The string pattern matching routine has been added. It should be
dynamically linked.
A simple string matcher is included. It should be refined later on
@c
INLINE int like(x, y, ylen)
str x, y;
int ylen;
{
        char *r;
        if (*x == (char )NULL) {
                return 0;
        }
        for (r = x+strlen(x)-ylen; x <= r; x++) {
                int ok = 1;
                char *s = x;
                char *q;
                for (q = y; *q; q++, s++)
                    if (*q != tolower(*s)) {
                        ok = 0; break;
                    }
                if (ok){
			return 1;
		}
        }
        return 0;
}

str CMDlike(int *ret, int *bid, str *k) {
	BAT *c, *b, *bn;
	str	t,s;
	BUN	u, v;
	int 	xx, yy=0;
	@:getBATdescriptor(ret,bid,b,like)@
        c = BATnew(BAThtype(b), TYPE_str, BATcount(b)/10);
	t = GDKstrdup(*k);

	for(s=t; *s; s++,yy++)
		*s = tolower(*s);
	
	if (b->hvarsized) {
	    BATloopFast(b, u, v, xx) 
		if (like(BUNtvar(b, u), t, yy)) 
		    BUNfastins(c, BUNhvar(b, u), BUNtvar(b, u));
	} else {
	    BATloopFast(b, u, v, xx) 
		if (like(BUNtvar(b, u), t, yy)) 
		    BUNfastins(c, BUNhloc(b, u), BUNtvar(b, u));
	}
	c->hsorted = BAThordered(b);
	c->tsorted = BATtordered(b);
	GDKfree(t);
	*ret = c->batCacheid;
	return MAL_SUCCEED;
}

@- BAT slice
@c
str CMDslice(int *ret, bat *bid, int *start, int *end){
	BAT *b, *br;
	@:getBATdescriptor(ret,bid,b,slice)@
	br = BATslice(b, *start, *end);
	if( br != NULL){
		*ret= br->batCacheid;
		return MAL_SUCCEED;
	}
	*ret =0;
	return throwMessage("algebra.slice", "GDKerror");
}

@- BUN Get/Fetch
@c
str CMDposition(int *retval, int *bid, ptr val){
	BAT *b;
	ptr p,v;

	@:getBATdescriptor(retval,bid,b,position)@
	@:derefStr(b,h,val)@
	v = BUNfnd(b, val);
        if (v == 0) 
                return throwMessage("algebra.position", " item not found");
        *retval = BUNindex(b, v)- BUNindex(b, BUNfirst(b));
        return MAL_SUCCEED;
}
str CMDpositionBUN(int *retval, int *bid, ptr val, ptr tval){
	BAT *b;
	ptr v;

	@:getBATdescriptor(retval,bid,b,position)@
	@:derefStr(b,h,val)@
	@:derefStr(b,t,tval)@
	v = BUNlocate(b, val, tval);
        if (v == 0) 
                return throwMessage("algebra.position", " item not found");
        *retval = BUNindex(b, v)- BUNindex(b, BUNfirst(b));
        return MAL_SUCCEED;
}

str CMDfetchbat(int * ret, int *bid, int *sid){
	BAT *b, *s, *bn;
	@:getBATdescriptor(ret,bid,b,fetch)@
	@:getBATdescriptor(ret,sid,s,fetch)@

	bn= BATfetch(b, s);
	if( bn ) {
		*ret = bn->batCacheid;
		return MAL_SUCCEED;
	}
	return throwMessage("algebra.fetchbat", "GDKerror");
}

str doCMDfetch(ptr ret, BAT *b, lng *pos){
	lng i = *pos;
        if ((i < 0) || (i >= BATcount(b)))
                return throwMessage("algebra.fetch", " idx out of range");
        i += BUNindex(b, BUNfirst(b));
	@:putTail(BUNptr(b,i))@
@= putTail
	if (b->theap.base) {
	    ptr _src = BUNtvar(b,@1); /*b->theap.base + *(var_t*) BUNtloc(b,@1);*/
	    int _len = ATOMlen(b->ttype, _src);
	    ptr _dst = GDKmalloc(_len);
	    memcpy(_dst, _src, _len);
	    *(ptr*) ret = _dst;
	} else {
	    int _s = ATOMsize(ATOMtype(b->ttype));
	    if (ATOMvarsized(b->ttype)) {
		memcpy(*(ptr*) ret=GDKmalloc(_s), BUNtloc(b, @1), _s);
	    } else if (b->ttype == TYPE_bat) {
		bat bid = *(bat*) BUNtloc(b, @1);
		*(bat*) ret = bid;
		BBPfix(bid);
	    } else if (_s == 4) {
		*(int*) ret = *(int*) BUNtail(b, @1);
	    } else if (_s == 1) {
		*(chr*) ret = *(chr*) BUNtail(b, @1);
	    } else if (_s == 2) {
		*(sht*) ret = *(sht*) BUNtail(b, @1);
	    } else if (_s == 8) {
		*(lng*) ret = *(lng*) BUNtail(b, @1);
	    } else {
		memcpy(ret, BUNtloc(b, @1), _s);
	    }
	}
@c
        return MAL_SUCCEED;
}
str CMDfetchoid(int * ret, int *bid, oid *pos){
	BAT *b;
	@:getBATdescriptor(ret,bid,b,fetchoid)@

	if( b->hseqbase == oid_nil)
		return throwMessage("algebra.fetchoid",
			"void lookup on uninitialized column");
	return doCMDfetch((ptr) ret,b,(((ptr)*pos)-b->hseqbase));
}

str CMDfetch(ptr ret, int *bid, lng *pos){
	BAT *b;
	int result;

	@:getBATdescriptor(&result,bid,b,fetch);
	return doCMDfetch(ret,b,pos);
}
str CMDexist(bit *ret, int *bid, ptr val){ 
	BAT *b;
	BUN q;
	int result;

	@:getBATdescriptor(&result,bid,b,exist);
	@:derefStr(b,h,val)@
	q = BUNfnd(b, val);
	*ret = q?1:0;
        return MAL_SUCCEED;
}
str CMDexistBUN(bit *ret, int *bid, ptr val, ptr tval){ 
	BAT *b;
	BUN q;
	int result;

	@:getBATdescriptor(&result,bid,b,exist);
	@:derefStr(b,h,val)@
	@:derefStr(b,t,tval)@
	q = BUNlocate(b, val, tval);
	*ret = q?1:0;
        return MAL_SUCCEED;
}

str CMDfind(ptr ret, int *bid, ptr val){ 
	BAT *b;
	ptr p;
	BUN q;
	int result;

	@:getBATdescriptor(&result,bid,b,find);
	@:derefStr(b,h,val)@
	q = BUNfnd(b, val);
	if (q == NULL)
		return throwMessage("algebra.find", "value not found");
	@:putTail(q)@
        return MAL_SUCCEED;
}
