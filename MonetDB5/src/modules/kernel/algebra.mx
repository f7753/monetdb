@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2004 CWI.
@' All Rights Reserved.
@'
@' Contributor(s):
@' 		Martin Kersten <Martin.Kersten@cwi.nl>
@' 		Peter Boncz <Peter.Boncz@cwi.nl>
@' 		Niels Nes <Niels.Nes@cwi.nl>
@' 		Stefan Manegold  <Stefan.Manegold@cwi.nl>

@f algebra
@a Peter Boncz, Martin Kersten, Niels Nes
@v 2.0
@* BAT Algebra
This modules contains the most common algebraic BAT manipulation
commands. We call them @#algebra@, because all operations take
values as parameters, and produce new result values, but 
@%do not modify their parameters@.
@
Unlike the previous Monet versions, we reduce the number
of functions returning a BAT reference. This was previously needed
to simplify recursive bat-expression and manage reference counts.
In the current version we return only a BAT identifier when a new
bat is being created.
@-
All parameters to the modules are passed by reference.
In particular, this means that
string values are passed to the module layer as (str *)
and we have to de-reference them before entering the gdk library.
This calls for knowlegde on the underlying BAT typs`s
@= derefStr
if( @1->@2type== TYPE_str) @3 = *(str *)@3;
@
We split between selections that return one value, and selections
that return a BAT.
@+ Value Selections
@mal
module algebra;

command exist(b:bat[:any$1,:any], h:any$1):bit 
address ALGexist
comment "Returns whether 'h' occurs as a head 
	value in b.";

command exist(b:bat[:any$1,:any$2], 
		h:any$1, t:any$2):bit 
address ALGexistBUN
comment "Returns true when 'h,t' occurs as a 
	bun in b.";

command find(b:bat[:any$1,:any$2], 
	h:any$1):any$2 
address ALGfind
comment "Returns the tail value 't' for which 
	some [h,t] BUN exists in b.  If no such
	BUN exists, an error occurs." ;

command position(b:bat[:any$1,:any],
		v:any$1):int
address ALGposition
comment "Returns BAT position [0.. b.count]
	of 'v' in the head column of b. It
	Return an error if 'v' does not exist.";

command position(b:bat[:any$1,:any$2], 
		val:any$1, tval:any$2) :int 
address ALGpositionBUN
comment "Returns the position of the value pair
	 It returns an error if 'val' does not 
	exist.";

command fetch(b:bat[:any,:any$1], x:oid) :any$1 
address ALGfetchoid
comment "Returns the tail value of the BUN at 
	 x-th position with 0 <= x < b.count";
command fetch(b:bat[:any,:any$1], x:lng) :any$1 
address ALGfetch
comment "Returns the tail value of the BUN at 
	 x-th position with 0 <= x < b.count";

@+ BAT Selections
@- positional select
@mal
command fetch(b:bat[:any$1,:any$2], 
		s:bat[:int,:any])
	:bat[:any$1,:any$2] 
address ALGfetchbat
comment "Returns a positional selection of b 
	by the integer head values of s";
command fetch(b:bat[:any$1,:any$2],
		s:bat[:lng,:any] ) 
	:bat[:any$1,:any$2] 
address ALGfetchbat
comment "Returns a positional selection of b 
	by the integer head values of s";
command fetch(b:bat[:any$1,:any$2],
		s:bat[:oid,:any]) 
	:bat[:any$1,:any$2] 
address ALGfetchbat
comment "Returns a positional selection of b 
	by the oid head values of s";
@- Range selections
@mal
command select(b:bat[:any$1,:any$2], low:any$2, 
	high:any$2) :bat[:any$1,:any$2] 
address ALGselect
comment "Select all BUNs that have tail 
	values: {v| low <= v <= high}.
NIL boundary values have a special meaning.
+ low  == nil means: no lower bound
+ high == nil means: no upper bound.
NOTE 1: you should cast the nil to the 
	appropriate type, e.g. int(nil) in 
	order to cirumvent type clashes.
NOTE 2: as the 'nil' element has no clear place 
	in the ordered domain of values, tuples 
	with 'nil' values are NEVER returned by 
	the range select.";

command select(b:bat[:any$1,:any$2], low:any$2, 
	high:any$2, li:bit, hi:bit) :bat[:any$1,:any$2] 
address ALGselectInclusive
comment "Select all BUNs that have tail 
	values: {v| low <{=} v <{=} high}.
	Boundary inclusion is indicated separately.
	NIL boundary values have a special meaning.
	+ low  == nil means: no lower bound
	+ high == nil means: no upper bound.";

command select(b:bat[:any$1,:any$2],value:any$2)
		:bat[:any$1,:any$2] 
address ALGselect1
comment "Select all BUNs of a BAT with a certain 
	tail value. Selection on NIL is also 
	possible (it should be properly casted, 
	e.g.:int(nil)).";

command fragment ( b:bat[:any$1,:any$2],
		hlow:any$1, hhigh:any$1,
		tlow:any$2, thigh:any$2 ) 
	:bat[:any$1,:any$2] 
address ALGfragment
comment "Select both on head and tail range.";
command slice(b:bat[:any$1,:any$2], 
	x:int, y:int) :bat[:any$1,:any$2] 
address ALGslice
comment "Return the slice with the BUNs at 
	position x till y.";
@- Select and project
@mal
command uselect(b:bat[:any$1,:any$2], 
		low:any$2, high:any$2) 
	:bat[:any$1,:void] 
address ALGuselect
comment "Select on tail, returning only the head 
	values. SEE ALSO: select(bat,low,high).";
command uselect(b:bat[:any$1,:any$2], 
	value:any$2) :bat[:any$1,:void] 
address ALGuselect1
comment "Value select, but returning only the 
	head values. SEE ALSO:select(bat,val)";
@- Random sampling
@mal
command sample ( b:bat[:any$1,:any$2], num:int ) 
		:bat[:any$1,:any$2] 
address ALGsample
comment "Produce a random selection of size 'num' 
	from the input BAT.";
@- Substring selection
@mal
command like(b:bat[:any$1,:str], substr:str) 
	:bat[:any$1,:str] 
address ALGlike
comment "Selects all elements that have 
	'substr' as in the tail.";
@+ BAT copying
@mal
command copy( b:bat[:any$1,:any$2]) 
	:bat[:any$1,:any$2] 
address ALGcopy
comment "Returns physical copy of a BAT.";
@- sorted copy
@mal
command sort( b:bat[:any$1,:any$2]) 
	:bat[:any$1,:any$2] 
address ALGsort
comment "Returns a BAT copy sorted on 
	the head column.";

#command sort_ht( b:bat[:any$1,:any$2]) 
#		:bat[:any$1,:any$2] 
#address ALGsort_ht
#comment "Returns a lexicographically sorted copy.";
@- vertical projection
This operation has been moved to module mal, because it requires access
the type identifier for the second argument.
to the context.
pattern project( b:bat[:any$1,:any], val:any$2) :bat[:any$1,:any$2] 
address ALGproject
comment "Fill the tail column with a constant value.";
@+ Sets
@T
Sets in Monet can be viewed in two ways:
\begin{itemize}
\item by looking at both colums of a BAT together (Set-, or s-operators).
\item by looking at the head column only (Key- or k-operators).
\end{itemize}
For this reason, all standard set operations come in two flavors:
\begin{itemize}
\item k-{\tt operand}, which look only at the head column.
\item s-{\tt operand} series, that look at the whole BUN.
\end{itemize}
@

@T
Operands provided are:
\begin{itemize}
\item {\tt [s,k]unique} (bat[:any$1,:any$2]) :bat[:any$1,:any$2]\\
produces a copy of the bat, with double elimination
\item {\tt [s,k]union}(bat[:any$1,:any$2],bat[:any$1,:any$2]) :bat[:any$1,:any$
2]\\
bat union.
\item {\tt [s,k]diff}(bat[:any$1,:any$2],bat[:any$1,:any$2]) :bat[:any$1,:any$2]\\
bat difference.
\item {\tt [s,k]intersection}(bat[:any$1,:any$2],bat[:any$1,:any$2]) :bat[:any$1,:any$2]\\
bat intersection.
\end{itemize}
Implementations typically take two forms: if the input relation(s) is/are
ordered, a merge-algorithm is used. Otherwise, hash-indices are produced
on demand for the hash-based algorithms.
\\
The {\tt [k,s]intersect(l,r)} operations result in all BUNs of {\tt l} that
are also in {\tt r}. They do not do double-elimination over the {\tt l} BUNs.
\\
The {\tt [k,s]diff(l,r)} operations result in all BUNs of {\tt l} that are
not in {\tt r}. They do not do double-elimination over the {\tt l} BUNs.
\\
The {\tt [k,s]union(l,r)} operations result in all BUNs of l that are 
not in {\tt r}, plus all BUNs of {\tt r}. They do not do double-elimination
over the {\tt l} nor {\tt r} BUNs.
\\
Operations with double-elimination can be formed by performing
{\tt [k,s]unique(l)} on their operands.
\\
The {\tt kintersect(l,r)} is used also as implementation for the
{\tt semijoin()}.

@- bun-unique elements
@mal
command unique (b:bat[:any$1,:any$2] ) 
		:bat[:any$1,:any$2] 
address ALGsunique;
command sunique (b:bat[:any$1,:any$2] ) 
		:bat[:any$1,:any$2] 
address ALGsunique
comment "Select unique tuples from the input BAT.
	Double elimination is done over BUNs as 
	a whole (head and tail).  Result is a BAT 
	with real set() semantics.";
@- head-unique elements
@mal
command kunique ( b:bat[:any$1,:any$2] ) 
		:bat[:any$1,:any$2] 
address ALGkunique
comment "Select unique tuples from the input BAT.
	Double elimination is done only looking 
	at the head column. Result is a BAT with
	property hkeyed() == true.";

command tunique ( b:bat[:any$1,:any$2] ) 
		:bat[:any$1,:any$2] 
address ALGsunique
comment "Select unique tail tuples from the BAT.
	Equivalent to revers().kunique() ";

@- bun-intersecting elements
@mal
command intersect ( left:bat[:any$1,:any$2], 
		   right:bat[:any$1,:any$2]) 
		:bat[:any$1,:any$2] 
address ALGsintersect;
command sintersect ( left:bat[:any$1,:any$2], 
		right:bat[:any$1,:any$2]) 
		:bat[:any$1,:any$2] 
address ALGsintersect
comment "Returns the intersection taken over 
	*both* columns of two BATs. Results in 
	all BUNs of 'left' that are also in 
	'right'. Does *not* do double-elimination 
	over the 'left' BUNs, If you want this, 
	use:
	 'sintersect(left.sunique,right.sunique)' 
	or: 'sintersect(left,right).sunique'.";

@- head-intersecting elements (a.k.a. semijoin)
@mal
command semijoin( left:bat[:any$1,:any$2], 
		right:bat[:any$1,:any] ) 
		:bat[:any$1,:any$2] 
address ALGsemijoin
comment "Returns the intersection taken over only 
	the *head* columns of two BATs. Results in 
	all BUNs of 'left' that are also in 'right'. 
	Does *not* do double-elimination over the 
	'left' BUNs, If you want this, use:
	 'kintersect(left.kunique,right.kunique)' 
	or: 'kintersect(left,right).kunique'.";

command semijoin( left:bat[:void,:any$2], 
		  right:bat[:oid,:any] ) 
		:bat[:oid,:any$2] 
address ALGsemijoin
comment "Patch to enable semijoin over void/oid columns";

command kintersect( left:bat[:any$1,:any$2], 
		     right:bat[:any$1,:any] ) 
		:bat[:any$1,:any$2] 
address ALGsemijoin
comment "Returns the intersection taken over only 
	the *head* columns of two BATs. Results in 
	all BUNs of 'left' that are also in 'right'.
	Does *not* do double-elimination over the 
	'left' BUNs, If you want this, use:
	 'kintersect(left.kunique,right.kunique)' 
	or: 'kintersect(left,right).kunique'.";
@- bun-differing elements
@mal
command diff( left:bat[:any$1,:any$2], 
		right:bat[:any$1,:any$2] ) 
		:bat[:any$1,:any$2] 
address ALGsdiff;
command sdiff( left:bat[:any$1,:any$2], 
		right:bat[:any$1,:any$2] ) 
		:bat[:any$1,:any$2] 
address ALGsdiff
comment "Returns the difference taken over 
	*both* columns of two BATs. Results in 
	all BUNs of 'left' that are *not* in 
	'right'. Does *not* do double-elimination 
	over the 'left' BUNs, If you want this, 
	use:
	     'sdiff(left.sunique,right.sunique)' 
	or: 'sdiff(left,right).sunique'.";
@- head-differing elements
@mal
command kdiff ( left:bat[:any$1,:any$2], 
		right:bat[:any$1,:any] ) 
		:bat[:any$1,:any$2] 
address ALGkdiff
comment "Returns the difference taken over only 
	the *head* columns of two BATs.  Results 
	in all BUNs of 'left' that are *not* in 
	'right'. Does *not* do double-elimination 
	over the 'left' BUNs, If you want this, use:
	 'kdiff(left.kunique,right.kunique)' 
	or: 'kdiff(left,right).kunique'.";
@- union on bun
@mal
command union ( left:bat[:any$1,:any$2], 
		right:bat[:any$1,:any$2]) 
		:bat[:any$1,:any$2] 
address ALGsunion;
command sunion ( left:bat[:any$1,:any$2], 
		right:bat[:any$1,:any$2]) 
		:bat[:any$1,:any$2] 
address ALGsunion
comment "Returns the union of two BATs; looking 
	at both columns of both BATs. Results in 
	all BUNs of 'left' that are  not in 
	'right', plus all BUNs of 'right'. 
	*no* double-elimination is done. If you 
	want this, do:
	 'sunion(left.sunique,right.sunique)' 
	or: 'sunion(left,right).sunique'.";
@- union on head
@mal
command kunion ( left:bat[:any$1,:any$2], 
		right:bat[:any$1,:any$2])
		:bat[:any$1,:any$2] 
address ALGkunion
comment "Returns the union of two BATs; looking 
	at head-columns only. Results in all BUNs 
	of 'left' that are  not in 'right', plus 
	all BUNs of 'right'. 
	*no* double-elimination is done. If you 
	want this, do:
	'kunion(left.kunique,right.kunique)' 
	or: 'sunion(left,right).kunique'.";
@+ Joins
The core of every relational engine.
Signature Changed: Output tail type incorrect because of soid to coid switch.

@- join(projected out join columns)
The join collection provided by the GDK kernel.
Note that joins over void columns are handled as if they are oids.
@mal
command cross(left:bat[:any$1,:any$2],
	right:bat[:$any3,:$any4])
	:bat[:any$1,:any$4]
address ALGcross
comment "Returns the cross product";
	
command join( left:bat[:any$1,:any$2], 
		right:bat[:any$2,:any$3])
		:bat[:any$1,:any$3] 
address ALGjoin
comment "Returns all BUNs, consisting of a 
	head-value from 'left' and a tail-value 
	from 'right' for which there are BUNs 
	in 'left' and 'right' with equal tail- 
	resp. head-value (i.e. the join
	columns are projected out).";

command join( left:bat[:any$1,:void], 
		right:bat[:oid,:any$3])
		:bat[:any$1,:any$3] 
address ALGjoin;
command join( left:bat[:any$1,:oid], 
		right:bat[:void,:any$3])
		:bat[:any$1,:any$3] 
address ALGjoin;

command join( left:bat[:any$1,:any$2], 
		right:bat[:any$2,:any$3],
		estimate:lng)
		:bat[:any$1,:any$3] 
address ALGjoinestimate;
command join( left:bat[:any$1,:void], 
		right:bat[:oid,:any$3],
		estimate:lng)
		:bat[:any$1,:any$3] 
address ALGjoinestimate;
command join( left:bat[:any$1,:oid], 
		right:bat[:void,:any$3],
		estimate:lng)
		:bat[:any$1,:any$3] 
address ALGjoinestimate;

command fetchjoin ( left:bat[:any$1,:any$2],
		right:bat[:any$2,:any$3] )
		:bat[:any$1,:any$3] 
address ALGfetchjoin
comment "Hook directly into the fetch 
	implementation of the join.";

command mergejoin (left:bat[:any$1,:any$2], 
		right:bat[:any$2,:any$3])
		:bat[:any$1,:any$3] 
address ALGmergejoin
comment "Hook directly into the merge 
	implementation of the join.";

command hashjoin ( left:bat[:any$1,:any$2], 
		right:bat[:any$2,:any$3])
		:bat[:any$1,:any$3] 
address ALGhashjoin
comment "Hook directly into the hash 
	implementation of the join.";

command indexjoin ( left:bat[:any$1,:any$2], 
		right:bat[:any$2,:any$3])
		:bat[:any$1,:any$3] 
address ALGindexjoin
comment "Hook directly into the index 
	implementation of the join.";

@- Outer Join
@mal
command outerjoin( outer:bat[:any$1,:any$2], 
		inner:bat[:any$2,:any$3]) 
		:bat[:any$1,:any$3] 
address ALGouterjoin
comment "Returns all the result of a join, 
	plus the BUNS formed NIL in the tail 
	and the head-values of 'outer' whose 
	tail-value does not match an head-value 
	in 'inner'.";
command outerjoin( outer:bat[:any$1,:any$2], 
		inner:bat[:any$2,:any$3],
		estimate:lng) 
		:bat[:any$1,:any$3] 
address ALGouterjoinestimate

@- Theta Join
@mal
command thetajoin( left:bat[:any$1,:any$2], 
		right:bat[:any$2,:any$3],
		opname:str) :bat[:any$1,:any$3] 
address ALGthetajoin
comment "Theta join on for 'mode' in { LE, LT, 
	EQ, GT, GE }.  JOIN_EQ is just the same 
	as join(). All other options do merge
	algorithms. either using the fact that 
	they are ordered() already (left on tail, 
	right on head), or by using/creating
	binary search trees on the join columns. ";
command thetajoin( left:bat[:any$1,:any$2], 
		right:bat[:any$2,:any$3],
		opname:str,estimate:lng) 
		:bat[:any$1,:any$3] 
address ALGthetajoinEstimate
@- Theta Join with inner columns
@mal
command theta ( inner_result:bat[:any$2,:any$2],
		outer_result:bat[:any$1,:any$3],
		left:bat[:any$1,:any$2],
		right:bat[:any$2,:any$3], opname:str )
				
address ALGtheta
comment "Theta join, just as simple thetajoin(l,r), the difference
is that it returns two values, which are added to the first params
'inner_result' and 'outer_result', 'inner_result' gets all matching
inner tuples, 'outer_result' the other two (what would have the
result of thetajoin(l,r)).";
@- Band Join (approximate match)
@mal
command bandjoin( outer:bat[:any$1,:any$2],
		   inner:bat[:any$2,:any$3],
		   minus:any$2 , plus:any$2 ) 
		:bat[:any$1,:any$3] 
address ALGbandjoin
comment "This is a join() for which the predicate 
	is that two BUNs match if the left-tail 
	value is within the range [right-head - 
	minus, right-head + plus]. Works only for 
	the builtin numerical types, and their 
	derivates.";
@+ OID Introducing Commands
For relational processing, some operators are necessary to produce newly
initiated OID columns, for representing n-ary (intermediary) relations.

@- OID head column
@mal
command mark( b:bat[:any$1,:any] ) :bat[:any$1,:oid] 
address ALGmark_default
comment "Produces a new BAT with fresh unique OIDs 
	in the tail.";

command mark( b:bat[:any$1,:any],g:bat[:oid,:oid] )
		:bat[:any$1,:oid] 
address ALGmark_grp
comment "Produces a new BAT with fresh unique OIDs 
	in the tail on a group basis.";

command mark( b:bat[:any$1,:any], base:oid ) 
		:bat[:any$1,:oid] 
address ALGmark
comment "Produces a new BAT with fresh unique dense 
	sequense of OIDs in the tail that starts 
	at base (i.e. [base,..base+b.count()-1] ).";
@- number tail column
@mal
command number( b:bat[:any$1,:any] ) 
		:bat[:any$1,:int]  
address ALGnumber
comment "Produces a new BAT with identical head 
	column, and consecutively increasing 
	integers (start at 0) in the tail column.";

@+ BAT fragmentation commands
Various operations for splitting BATs into useful fragments.

@- Hash Split
The commands below is temporarilly postponed
command hashsplit( b:bat[:any$1,:any$2] ,
		   buckects:int ) 
		:bat[:int,bat[:any$1,:any$2]] 
address ALGhashsplit
comment "Split a BAT on tail column according 
	(hash-value MOD buckets). Returns a 
	recursive BAT, containing the fragments 
	in the tail, their bucket number in the 
	head.";

command uhashsplit ( b:bat[:any$1,:any$2], 
		buckets:int ) 
		:bat[:int,bat[:any$1,:any$2]] 
address ALGuhashsplit
comment "Same as hashsplit, but only collect the 
	head values in the fragments";
@- Range Split
command rangesplit ( b:bat[:any$1,:any$2], 
		ranges:int ) 
		:bat[:any$2,bat[:any$1,:any$2]] 
address ALGrangesplit
comment "Split a BAT on tail column in 'ranges' 
	equally sized consecutive ranges. Returns
	a recursive BAT, containing the fragments 
	in the tail, the higher-bound of the range 
	in the head. The higher bound of the last 
	range is 'nil'.";

command urangesplit( b:bat[:any$1,:any$2], 
		ranges:int ) 
		:bat[:any$2,bat[:any$1,:void]] 
address ALGurangesplit
comment "Same as rangesplit, but only collect 
	the head values in the fragments" ;

@+ Common BAT Aggregates
These operations examine a BAT, and compute some simple aggregate result
over it.
@- BAT size
@mal
command count( b:bat[:any,:any] ) :lng 
address ALGcount_bat
comment "Return the current size (in number of 
	elements) in a BAT.";
command count ( b:bat[:any,:any], ignore_nils:bit )
	:int 
address ALGcount_nil
comment "Return the number of elements currently 
	in a BAT
ignores BUNs with nil-tail iff ignore_nils==TRUE.";
command topN ( b:bat[:any,:any], top:lng ) :int 
address ALGtopN
comment "Trim all but the top N tuples.";
@- Histogram on Tail
@mal
command histogram ( b:bat[:any,:any$2]) 
		:bat[:any$2,:int] 
address ALGhistogram
comment "Produce a BAT containing the histogram 
	of the tail values.  bat.histogram() 
	@= {count}(bat.reverse)";

@-
command out of order right now. Should become an optimization pattern
group.count -> histogram(bat.reverse)
command {count} ( b:bat[:any$2,:any]) :bat[:any$2,int] 
address ALGhistogram_rev
comment "Count the number of groups.
 It has fast implementation: histogram(bat.reverse)";

@- Default Min and Max
@T
Implementations a generic Min and Max routines get declared first. The
{\tt min()} and {\tt max()} routines below catch any tail-type.
The type-specific routines defined later are faster, and will
override these any implementations.
@mal
command card ( b:bat[:any,:any] ) :lng 
address ALGcard
comment "Return the cardinality of the BAT 
	tail values.";
@- 
@T
Implementations a generic Min and Max routines get declared first. The
{\tt min()} and {\tt max()} routines below catch any tail-type.
The type-specific routines defined later are faster, and will
override these any implementations.

@- 
@mal
command min(b:bat[:any$1,:any$2]):any$2 
address ALGminany
comment "Give the lowest tail value. Error 
	on empty BATs.";

command max(b:bat[:any$1,:any$2]):any$2 
address ALGmaxany
comment "Give the highest tail value. Error 
	on empty BATs.";
@+ Type-Specific Sum, Prod, Max and Min
@T
For X $\in$ \{ sht,int,flt,dbl,lng \},  we define (using the {\em aggregate}
macro):
\begin{itemize}
\item command sum(bat[:any,X] : X,
\item command prod(bat[:any,X] : X, and
\item command max(bat[:any,X] : X, and
\item command min(bat[:any,X] : X.
\end{itemize}
@-
@= sum_definition
command sum (b:bat[:any,:@1] ) :@2 
address ALGsum_@1_@2
comment "Gives the sum of all tail values";
command prod(b:bat[:any,:@1] ) :@2 
address ALGprod_@1_@2
comment "Gives the produc of all tail values";
@mal
@:sum_definition(uchr,uchr)@
@:sum_definition(uchr,sht)@
@:sum_definition(uchr,int)@
@:sum_definition(uchr,lng)@
@:sum_definition(sht,sht)@
@:sum_definition(sht,int)@
@:sum_definition(sht,lng)@
@:sum_definition(int,int)@
@:sum_definition(int,lng)@
@:sum_definition(lng,lng)@
@:sum_definition(flt,flt)@
@:sum_definition(flt,dbl)@
@:sum_definition(dbl,dbl)@
@-
@= aggregate_definition
command @1 ( b:bat[:any,:@2] ) :@2 
address ALG@1_@2 comment @3;
@= aggregate
@:aggregate_definition(@1,uchr,@2)@
@:aggregate_definition(@1,sht,@2)@
@:aggregate_definition(@1,int,@2)@
@:aggregate_definition(@1,flt,@2)@
@:aggregate_definition(@1,dbl,@2)@
@:aggregate_definition(@1,lng,@2)@

@mal
@:aggregate(max,"Give the highest tail value. Error on empty BATs.")@
@:aggregate(min,"Give the lowest tail value. Error on empty BATs.")@

@+ Exented selection predicates
For SQL convenience we provide a serie of interval selectors.
@mal
# Extend select to the cases where we 
# can ignore nils altogether
function between(b:bat[:any$1,:any$2], l:any$2, h:any$2) :bat[:any$1,:any$2];
	k:= select(b,l,h);
	return k;
end between;
# between Close Open interval
function betweenCO(b:bat[:any$1,:any$2], l:any$2, h:any$2):bat[:any$1,:any$2];
	t:= select(b,l,h);
	tr:= reverse(t);
	delete(tr,h);
	zr:= reverse(tr);
	return t;
end betweenCO;
function betweenOC(b:bat[:any$1,:any$2], l:any$2, h:any$2):bat[:any$1,:any$2];
	t:= select(b,l,h);
	tr:= reverse(t);
	delete(tr,l);
	zr:= reverse(tr);
	return t;
end betweenOC;
function betweenOO(b:bat[:any$1,:any$2], l:any$2, h:any$2):bat[:any$1,:any$2];
	t:= select(b,l,h);
	tr:= reverse(t);
	delete(tr,l);
	delete(tr,h);
	zr:= reverse(tr);
	return t;
end betweenOO;
@+ Modeling With Properties
@T
The Monet kernel performs {\em run-time optimizations}. To choose between
alternaticve algorithms in a sensible way, it maintains knowledge about
each BAT, sometimes as a {\em BAT property}, sometimes as two
{\em column properties} for each column (head and tail)
of a BAT. An example of the former is {\em size(bat) :int}
(which gives the number of BUNs in a BAT), an example
of the latter is {\tt ordered(column) :bit}, indicating
whether the column contains its valued stored in ascending order.
The convention is to use a BAT as operand also for the column
properties; which then is supposed to be valid for the head
column ({\tt ordered(BAT)}). Tail columns can be described by
using the mirror BAT with the minus operator ({\tt ordered(-BAT)}).

@- Column Properties
@T
\begin{description}
\item[{\tt ordered(BAT) :bit}]
	TRUE if the head column is stored in ascending order, else FALSE.
\item[{\tt keyed(BAT) :bit}]
	TRUE if no duplicates are present in the head column, else FALSE.
\item[{\tt idx(BAT) :bit}]
	TRUE if a binary index tree search accelerator is present on
	the head column of the BAT, else FALSE.
\item[{\tt hashtab(BAT) :bit}] presence of hash table on the head column of
	a BAT. TRUE if a bucket-chained hash table search accelerator is
	present on the head column of the BAT, else FALSE.
\item[{\tt subcol(BAT, BAT) :bit}]
	TRUE if the bag of all values in the head column of the left BAT is
	a bag-subset of the bag of all values in the head column of the
	right BAT, else FALSE.
\item[{\tt sync(BAT) :oid}]
	Sync-OID on the head column of a BAT. A sync-OID denotes some unique
	sequence of values. If two columns have the same sync-OID, then they
	are guaranteed to contain the same values, in the same sequence.
\end{description}

@- BAT properties
@T
\begin{description}
\item[{\tt size(BAT) :int}]
	The (estimated) length of a column.
\item[{\tt unique(BAT) :int}]
	The (estimated) number of distinct values in one column.
\item[{\tt subset(BAT, BAT) :bit}]
	TRUE if the left BAT is a subset of the BUNs of the right BAT,
	else FALSE.
\item[{\tt setunique(BAT) :bit}]
	TRUE if the BAT contains no duplicate BUNs, else FALSE.
\end{description}

@- Property Propagation Rules
@T
At database creation time, the properties of the BATs in the database
can be derived directly from the database schema.

When queries are executed, they will produce {\em intermediate results},
which in terms are operands for further execution. Hence it is necessary
to {\em propagate properties} from the operands of an algebraic operator,
to its result.

This process can be captured by having a series of {\em propagation rules}
for each algebraic operand. Since each algebraic operands may apply
different strategies, according to different status in its operand properties,
each algebraic operator may have different propagation rules with these
different situations as conditions.
@{
@* Command Implementations in C
@h
#ifndef ALGEBRA_H
#define ALGEBRA_H

#include <gdk.h>
#include "../atoms/uchr.h"
#include "mal_function.h"
#endif

@c
#include "algebra.h"

extern ptr BATmin(BAT *b, ptr aggr);
extern ptr BATmax(BAT *b, ptr aggr);

@+ BAT sum operation
The sum aggregate only works for int and float fields.
The routines below assumes that the caller knows what type
is large enough to prevent overflow.

@= sum_implementation
int CMDsum_@1_@2(@2* res, BAT *b) {
	BUN p,q;
	int xx;
	@2 result=@3;

	BATcheck(b,"BATsumInt");
	BATloopFast(b, p, q, xx) {
		@1 *value = (@1*) BUNtloc(b, p);
		if (*value == @1_nil) {
			result = @2_nil; break;
		} else {
			result += *value;
		}
	}
	*res = result;
	return GDK_SUCCEED;
}

@+ BAT prod[uct] operation
The prod[uct] aggregate only works for int and float fields.
The routines below assumes that the caller knows what type
is large enough to prevent overflow.

@= prod_implementation
int CMDprod_@1_@2(@2* res, BAT *b) {
	BUN p,q;
	int xx;
	@2 result=@3;

	BATcheck(b,"BATprodInt");
	BATloopFast(b, p, q, xx) {
		@1 *value = (@1*) BUNtloc(b, p);
		if (*value == @1_nil) {
			result = @2_nil; break;
		} else {
			result *= *value;
		}
	}
	*res = result;
	return GDK_SUCCEED;
}
@+ Minimum and Maximum
The routines @`BATmin@5(b) and @`BATmax@5(b) compute the minimum and
maximum value of the tail column of a BAT.
Aggregate values are calculated just before they are requested by
the user. They are not maintained continuously, because we expect
them to be used sparsely.

@= aggregate_implementation
int CMDmin_@1(@1* result, BAT *b) {
	return BATmin(b, result)?GDK_SUCCEED:GDK_FAIL;
}
int CMDmax_@1(@1* result, BAT *b) {
	return BATmax(b, result)?GDK_SUCCEED:GDK_FAIL;
}
@= atomaggr
    if (s > 0 && !(BATtordered(b)&1)) {
	char* nil = BATatoms[t].atomNull;
	BUN p,q;
	int xx;
        BATloopFast(b, p, q, xx) {
            x = (ptr) BUNt@2(b, p);
            if (@3_CMP(x, nil, @4) == 0) {
                v = nil; break;
            }
            if (@3_@5(x, v, @4)) {
                v = x; 
            }
        }	
    }
    if (aggr) {
       memcpy(aggr, x=v, ATOMsize(t));
    } else {
       /* alloc new space and copy the atom into it */
       s = ATOMlen(t, v);
       memcpy(x = (ptr) GDKmalloc(s), v, s);
   } 
@= voidaggr
    if (aggr) {
        *(oid *) aggr = *(oid *) (x=v);
    } else {
        /* alloc new space and copy the atom into it */
        memcpy(x = (ptr) GDKmalloc(sizeof(oid)), v, s);
    } 
@= aggrmin
    v = (s == 0)?ATOMnilptr(t):BUNtail(b, BUNfirst(b));
    @:@5aggr(@1,@2,@3,@4,LT)@
@= aggrmax
    v = (s == 0)?ATOMnilptr(t):BUNtail(b, BUNlast(b)-BUNsize(b));
    @:@5aggr(@1,@2,@3,@4,GT)@

@= BATaggr
ptr BAT@1(BAT *b, ptr aggr) {
	int t;
	size_t s; 
	ptr v, x;

	BATcheck(b, "BAT@1"); 
	s = BATcount(b);	
	t = b->ttype;
	if (BATtvoid(b)) {
	    @:aggr@1(chr,loc,simple,chr,void)@ 
	} else {
	    switch(ATOMstorage(t)) {
	    case TYPE_chr: @:aggr@1(uchr,loc,simple,uchr,atom)@ break;
	    case TYPE_sht: @:aggr@1(sht,loc,simple,sht,atom)@ break;
	    case TYPE_int: @:aggr@1(int,loc,simple,int,atom)@ break;
	    case TYPE_flt: @:aggr@1(flt,loc,simple,flt,atom)@ break;
	    case TYPE_dbl: @:aggr@1(dbl,loc,simple,dbl,atom)@ break;
	    case TYPE_lng: @:aggr@1(lng,loc,simple,lng,atom)@ break;
	    default: if (b->tvarsized) {
			   @:aggr@1(chr,var,atom,t,atom)@ break;
		     } else {
			   @:aggr@1(chr,loc,atom,t,atom)@ break;
	    }        }
	}
	return x;
}
@c
@:BATaggr(min)@
@:BATaggr(max)@

@:sum_implementation(uchr,uchr,0)@
@:sum_implementation(uchr,sht,0)@
@:sum_implementation(uchr,int,0)@
@:sum_implementation(uchr,lng,0)@
@:sum_implementation(sht,sht,0)@
@:sum_implementation(sht,int,0)@
@:sum_implementation(sht,lng,0)@
@:sum_implementation(int,int,0)@
@:sum_implementation(int,lng,0)@
@:sum_implementation(lng,lng,0)@
@:sum_implementation(flt,flt,0.0)@
@:sum_implementation(flt,dbl,0.0)@
@:sum_implementation(dbl,dbl,0.0)@

@:prod_implementation(uchr,uchr,1)@
@:prod_implementation(uchr,sht,1)@
@:prod_implementation(uchr,int,1)@
@:prod_implementation(uchr,lng,1)@
@:prod_implementation(sht,sht,1)@
@:prod_implementation(sht,int,1)@
@:prod_implementation(sht,lng,1)@
@:prod_implementation(int,int,1)@
@:prod_implementation(int,lng,1)@
@:prod_implementation(lng,lng,1)@
@:prod_implementation(flt,flt,1.0)@
@:prod_implementation(flt,dbl,1.0)@
@:prod_implementation(dbl,dbl,1.0)@

@:aggregate_implementation(uchr)@
@:aggregate_implementation(sht)@
@:aggregate_implementation(int)@
@:aggregate_implementation(flt)@
@:aggregate_implementation(dbl)@
@:aggregate_implementation(lng)@

int CMDminany(ptr result, BAT *b) {
	if (!ATOMlinear(b->ttype)) 
	    return GDKerror("CMDminANY: atom '%s' cannot be ordered linearly\n",
			ATOMname(b->ttype));
	if (ATOMvarsized(b->ttype)) 
	    return (*(ptr*) result = BATmin(b, NULL))?GDK_SUCCEED:GDK_FAIL;
	if (BATmin(b, result)) {
	    if (b->ttype == TYPE_bat) 
		*(BAT**) result = BATdescriptor(*(bat*) result);
	    return GDK_SUCCEED;
	}
	return GDK_FAIL;
}
int CMDmaxany(ptr result, BAT *b) {
	if (!ATOMlinear(b->ttype)) 
	    return GDKerror("CMDmaxANY: atom '%s' cannot be ordered linearly\n",
			ATOMname(b->ttype));
	if (ATOMvarsized(b->ttype)) 
	    return (*(ptr*) result = BATmax(b, NULL))?GDK_SUCCEED:GDK_FAIL;
	if (BATmax(b, result)) {
	    if (b->ttype == TYPE_bat) 
		*(BAT**) result = BATdescriptor(*(bat*) result);
	    return GDK_SUCCEED;
	}
	return GDK_FAIL;
}

@c
int CMDselect1(BAT **result, BAT* b, ptr value) {
	return (*result = BATselect(b, value, 0))?GDK_SUCCEED:GDK_FAIL;
}
int CMDuselect1(BAT **result, BAT* b, ptr value) {
	return (*result = BATuselect(b, value, 0))?GDK_SUCCEED:GDK_FAIL;
}
int CMDselect(BAT **result, BAT *b, ptr low, ptr high) {
	return (*result = BATselect(b, low, high))?GDK_SUCCEED:GDK_FAIL;
}
int CMDuselect(BAT **result, BAT *b, ptr low, ptr high) {
	return (*result = BATuselect(b, low, high))?GDK_SUCCEED:GDK_FAIL;
}
int CMDselect_(BAT **result, BAT *b, ptr low, ptr high, bit* l_in, bit* h_in) {
	int tt = b->ttype;
	ptr nil = ATOMnilptr(tt);
	if (*l_in == bit_nil && ATOMcmp(tt, low, nil)) {
		GDKerror("select: flag 'l_in' must not be NIL, unless boundary 'low' is NIL\n");
		return GDK_FAIL;
	}
	if (*h_in == bit_nil && ATOMcmp(tt, high, nil)) {
		GDKerror("select: flag 'h_in' must not be NIL, unless boundary 'high' is NIL\n");
		return GDK_FAIL;
	}
	return (*result = BATselect_(b, low, high, *l_in, *h_in))?GDK_SUCCEED:GDK_FAIL;
}
int CMDuselect_(BAT **result, BAT *b, ptr low, ptr high, bit* l_in, bit* h_in) {
	int tt = b->ttype;
	ptr nil = ATOMnilptr(tt);
	if (*l_in == bit_nil && ATOMcmp(tt, low, nil)) {
		GDKerror("uselect: flag 'l_in' must not be NIL, unless boundary 'low' is NIL\n");
		return GDK_FAIL;
	}
	if (*h_in == bit_nil && ATOMcmp(tt, high, nil)) {
		GDKerror("uselect: flag 'h_in' must not be NIL, unless boundary 'high' is NIL\n");
		return GDK_FAIL;
	}
	return (*result = BATuselect_(b, low, high, *l_in, *h_in))?GDK_SUCCEED:GDK_FAIL;
}
int CMDfragment(BAT **result, BAT *b, ptr hlow, ptr hhigh, ptr tlow, ptr thigh) 
{
	return (*result = BATrestrict(b, hlow, hhigh, tlow, thigh))?
		GDK_SUCCEED:GDK_FAIL;
}
int CMDthetajoin(BAT **result, BAT *left, BAT *right, int *mode, lng *estimate) {
	return (*result = BATthetajoin(left, right, *mode, (*estimate == lng_nil)?oid_nil:(size_t)*estimate))?
		GDK_SUCCEED:GDK_FAIL;
}
int CMDtheta(BAT *inner, BAT *outer, BAT *left, BAT *right, int *mode) {
	BATtheta(inner, outer, left, right, *mode);
	return GDK_SUCCEED;
}
int CMDbandjoin(BAT **result, BAT *left, BAT *right, ptr minus, ptr plus) {
	return (*result = BATbandjoin(left, right, minus, plus))?
		GDK_SUCCEED:GDK_FAIL;
}

@-
Let cut this text down with some Mx macro's
@= unary
int CMD@1(BAT **result, BAT *b) {
	return (*result = @2(b))?GDK_SUCCEED:GDK_FAIL;
}
@= unaryint
int CMD@1(int *result, BAT *b) {
	*result = @2(b);
	return GDK_SUCCEED;
}
@= binary
int CMD@1(BAT **result, BAT *left, BAT* right) {
	return (*result = @2(left, right))?GDK_SUCCEED:GDK_FAIL;
}
@= binaryestimate
int CMD@1(BAT **result, BAT *left, BAT* right, lng *estimate) {
	return (*result = @2(left, right, *estimate==lng_nil?(size_t)oid_nil:(size_t)*estimate))?GDK_SUCCEED:GDK_FAIL;
}
@= binaryint
int CMD@1(BAT **result, BAT* b, int *param) {
	return (*result = @2(b, *param))?GDK_SUCCEED:GDK_FAIL;
}
@c
@:unaryint(count, BATcount)@
@:unary(histogram, BAThistogram)@
@:unary(sort, BATsort)@
@:unary(sort_rev, BATsort_rev)@
@:unary(number, BATnumber)@
@:unary(copy, BATcopy)@
@:unary(kunique, BATkunique)@
@:unary(sunique, BATsunique)@
@:binary(semijoin, BATsemijoin)@
@:binary(cross, BATcross)@
@:binaryestimate(join, BATjoin)@
@:binaryestimate(outerjoin, BATouterjoin)@
@:binary(sunion, BATsunion)@
@:binary(kunion, BATkunion)@
@:binary(sintersect, BATsintersect)@
@:binary(kintersect, BATkintersect)@
@:binary(sdiff, BATsdiff)@
@:binary(kdiff, BATkdiff)@
@:binaryint(sample, BATsample)@

int CMDcount_nil(int *result, BAT *b, bit *ignore_nils) {
	if (*ignore_nils)
		*result = (int) BATcount_no_nil(b);
	else
		*result = (int) BATcount(b);
	return GDK_SUCCEED;
}

int CMDgroup(BAT **result, BAT *b, int *start, int *incr, int *grpsize) {
        return (*result = BATgroup(b, *start, *incr, *grpsize))?GDK_SUCCEED:GDK_FAIL;
}

int CMDproject(BAT** res, BAT *b, ptr p, int t) {
	return (*res=BATconst(b, t, p))?GDK_SUCCEED:GDK_FAIL;
}

int CMDmark_grp(BAT** res, BAT *b, BAT *g){
	return (*res=BATmark_grp(b, g))?GDK_SUCCEED:GDK_FAIL;
}

int CMDmark(BAT** res, BAT *b, oid *base){
	return (*res=BATmark(b, *base))?GDK_SUCCEED:GDK_FAIL;
}
int CMDmark_default(BAT** res, BAT *b){
	oid base = OIDnew(BATcount(b));
	return CMDmark(res, b, &base);
}
int CMDhashsplit(BAT **res, BAT *b, int *nfrag){
	return (*res=BAThashsplit(b, *nfrag, FALSE))?GDK_SUCCEED:GDK_FAIL;
}
int CMDuhashsplit(BAT **res, BAT *b, int *nfrag){
	return (*res=BAThashsplit(b, *nfrag, TRUE))?GDK_SUCCEED:GDK_FAIL;
}
int CMDrangesplit(BAT **res, BAT *b, int *nfrag){
	return (*res=BATrangesplit(b, *nfrag, FALSE))?GDK_SUCCEED:GDK_FAIL;
}
int CMDurangesplit(BAT **res, BAT *b, int *nfrag){
	return (*res=BATrangesplit(b, *nfrag, TRUE))?GDK_SUCCEED:GDK_FAIL;
}

int CMDhistogram_rev(BAT **bn, BAT *b) {
	return CMDhistogram(bn, BATmirror(b));
} 


@- Substring Select
The string pattern matching routine has been added. It should be
dynamically linked.
A simple string matcher is included. It should be refined later on
@c
INLINE int like(char *x, char *y, int ylen)
{
        char *r;
        if (x == (char *)NULL) {
                return 0;
        }
        for (r = x+strlen(x)-ylen; x <= r; x++) {
                int ok = 1;
                char *s = x;
                char *q;
                for (q = y; *q; q++, s++)
                    if (*q != tolower(*s)) {
                        ok = 0; break;
                    }
                if (ok) return 1;
        }
        return 0;
}

int CMDlike(BAT **ret, BAT* b, str s) {
        BAT	*c = BATnew(BAThtype(b), TYPE_str, BATcount(b)/10);
	str	t = GDKstrdup(s);
	BUN	u, v;
	int 	xx, yy=0;

	if( c == NULL ) return GDK_FAIL;
	for(s=t; *s; s++,yy++)
		*s = tolower(*s);
	
	if (b->hvarsized) {
	    BATloopFast(b, u, v, xx) 
		if (like(BUNtvar(b, u), t, yy)) 
		    if (BUNfastins(c, BUNhvar(b, u), BUNtvar(b, u)) == NULL) {
			BBPreclaim(c);
			return GDK_FAIL;
		    }
	} else {
	    BATloopFast(b, u, v, xx) 
		if (like(BUNtvar(b, u), t, yy)) 
		    if (BUNfastins(c, BUNhloc(b, u), BUNtvar(b, u)) == NULL) {
			BBPreclaim(c);
			return GDK_FAIL;
		    }
	}
	c->hsorted = BAThordered(b);
	c->tsorted = BATtordered(b);
	*ret = c;
	return GDK_SUCCEED;
}

@- BAT slice
@c
int CMDslice(BAT **retval, BAT *b, int *start, int *end){
	/* the internal BATslice requires exclusive end */
	if (*start < 0){
                GDKerror("CMDslice: start position of slice should >= 0\n");
                return GDK_FAIL;
        }
		
	return (*retval = BATslice(b, (size_t)*start, (size_t)*end+1))?
			GDK_SUCCEED:GDK_FAIL;
}

@- BUN Get/Fetch
@c
int CMDposition(int *retval, BAT *b, ptr val){
	ptr p = (b->htype == TYPE_bat)?(ptr) &((BAT*) val)->batCacheid:val;
	ptr v = BUNfnd(b, p);
        if (v == 0) {
                GDKerror("CMDposition: item not found\n");
                return GDK_FAIL;
        }
        *retval = BUNindex(b, v)- BUNindex(b, BUNfirst(b));
        return GDK_SUCCEED;
}
int CMDpositionBUN(int *retval, BAT *b, ptr val, ptr tval){
	ptr p = (b->htype == TYPE_bat)?(ptr) &((BAT*) val)->batCacheid:val;
	ptr o = (b->ttype == TYPE_bat)?(ptr) &((BAT*) tval)->batCacheid:tval;
	ptr v = BUNlocate(b, p,o);
        if (v == 0) {
                GDKerror("CMDposition: item not found\n");
                return GDK_FAIL;
        }
        *retval = BUNindex(b, v)- BUNindex(b, BUNfirst(b));
        return GDK_SUCCEED;
}

int CMDfetchbat(BAT** ret, BAT *b, BAT *s){
	return (*ret = BATfetch(b, s))?GDK_SUCCEED:GDK_FAIL;
}

static int doCMDfetch(ptr ret, BAT *b, size_t i){
        if (i >= BATcount(b)) {
                GDKerror("CMDfetch: idx out of range\n");
                return GDK_FAIL;
        }
        i += BUNindex(b, BUNfirst(b));
	@:putTail(BUNptr(b,i))@
@= putTail
	if (b->theap.base) {
	    ptr _src = BUNtvar(b,@1);/*b->theap.base + *(var_t*) BUNtloc(b,@1);*/
	    int _len = ATOMlen(b->ttype, _src);
	    ptr _dst = GDKmalloc(_len);
	    memcpy(_dst, _src, _len);
	    *(ptr*) ret = _dst;
	} else {
	    int _s = ATOMsize(ATOMtype(b->ttype));
	    if (ATOMvarsized(b->ttype)) {
		memcpy(*(ptr*) ret=GDKmalloc(_s), BUNtloc(b, @1), _s);
	    } else if (b->ttype == TYPE_bat) {
		bat bid = *(bat*) BUNtloc(b, @1);
		*(BAT**) ret = BATdescriptor(bid);
	    } else if (_s == 4) {
		*(int*) ret = *(int*) BUNtail(b, @1);
	    } else if (_s == 1) {
		*(chr*) ret = *(chr*) BUNtail(b, @1);
	    } else if (_s == 2) {
		*(sht*) ret = *(sht*) BUNtail(b, @1);
	    } else if (_s == 8) {
		*(lng*) ret = *(lng*) BUNtail(b, @1);
	    } else {
		memcpy(ret, BUNtloc(b, @1), _s);
	    }
	}
@c
        return GDK_SUCCEED;
}

int CMDfetch(ptr ret, BAT *b, int *pos){
	return doCMDfetch(ret, b, (size_t) *pos);
}

int CMDfetchoid(ptr ret, BAT *b, oid *pos){
	if (b->hseqbase == oid_nil) {
                GDKerror("CMDfetchoid: void lookup on uninitialized column.\n");
                return GDK_FAIL;
        }
	return doCMDfetch(ret, b, (size_t) (*pos - b->hseqbase));
}

int CMDexist(bit *ret, BAT* b, ptr val){ 
	ptr p = (b->htype == TYPE_bat)?(ptr) &((BAT*) val)->batCacheid:val;
	BUN q = BUNfnd(b, p);
	*ret = q?1:0;
        return GDK_SUCCEED;
}
int CMDexistBUN(bit *ret, BAT* b, ptr val, ptr tval){ 
	ptr p = (b->htype == TYPE_bat)?(ptr) &((BAT*) val)->batCacheid:val;
	ptr o = (b->ttype == TYPE_bat)?(ptr) &((BAT*) tval)->batCacheid:tval;
	BUN q = BUNlocate(b, p, o);
	*ret = q?1:0;
        return GDK_SUCCEED;
}

int CMDfind(ptr ret, BAT* b, ptr val){ 
	ptr p = (b->htype == TYPE_bat)?(ptr) &((BAT*) val)->batCacheid:val;
	BUN q = BUNfnd(b, p);
	if (q == NULL) {
		GDKerror("CMDfind: value not found.\n");
		return GDK_FAIL;
	}
	@:putTail(q)@
        return GDK_SUCCEED;
}
@}

@- Wrapper
The remainder of this file contains the wrapper around the V4 code base

The BAT identifiers passed through this module may indicate
that the 'reverse' view applies. This should be taken into
account while resolving them.
@= getBATdescriptor
        if( BBPcheck(*@2,"@4")==0)
                return throwMessage("algebra.@4", "cannot access bat @2 in bbp");
        @3= (BAT*) BBPgetdesc(*@2);
        if( @3 == NULL) { *@1 = 0;
                return throwMessage("algebra.@4", "cannot access descriptor @2");
	}
	if( *@2 <0){ /* BAT reverse */ @3 = BATmirror(@3); }
@+ BAT sum operation
The sum aggregate only works for int and float fields.
The routines below assumes that the caller knows what type
is large enough to prevent overflow.

@= ALGsum_implementation
str ALGsum_@1_@2(@2* res, int *bid) {
	BAT *b;
	@:getBATdescriptor(res,bid,b,sum)@
	CMDsum_@1_@2(res,b);
        return MAL_SUCCEED;
}

@= ALGprod_implementation
str ALGprod_@1_@2(@2* res, int *bid) {
	BAT *b;
	@:getBATdescriptor(res,bid,b,sum)@
	CMDprod_@1_@2(res,b);
        return MAL_SUCCEED;
}
@c
#include "../atoms/uchr.h"
#include "mal_function.h"

@:ALGsum_implementation(uchr,uchr,0)@
@:ALGsum_implementation(uchr,sht,0)@
@:ALGsum_implementation(uchr,int,0)@
@:ALGsum_implementation(uchr,lng,0)@
@:ALGsum_implementation(sht,sht,0)@
@:ALGsum_implementation(sht,int,0)@
@:ALGsum_implementation(sht,lng,0)@
@:ALGsum_implementation(int,int,0)@
@:ALGsum_implementation(int,lng,0)@
@:ALGsum_implementation(lng,lng,0)@
@:ALGsum_implementation(flt,flt,0.0)@
@:ALGsum_implementation(flt,dbl,0.0)@
@:ALGsum_implementation(dbl,dbl,0.0)@

@:ALGprod_implementation(uchr,uchr,1)@
@:ALGprod_implementation(uchr,sht,1)@
@:ALGprod_implementation(uchr,int,1)@
@:ALGprod_implementation(uchr,lng,1)@
@:ALGprod_implementation(sht,sht,1)@
@:ALGprod_implementation(sht,int,1)@
@:ALGprod_implementation(sht,lng,1)@
@:ALGprod_implementation(int,int,1)@
@:ALGprod_implementation(int,lng,1)@
@:ALGprod_implementation(lng,lng,1)@
@:ALGprod_implementation(flt,flt,1.0)@
@:ALGprod_implementation(flt,dbl,1.0)@
@:ALGprod_implementation(dbl,dbl,1.0)@
@-
@= ALGaggregate_implementation
str ALGmin_@1(@1* res, int *bid) {
        BAT *b;
	int result;
	(void) result;
        @:getBATdescriptor(&result,bid,b,min)@
        if( CMDmin_@1(res,b)) return MAL_SUCCEED;
        return throwMessage("algebra.min", "GDKerror");
}
str ALGmax_@1(@1* res, int *bid) {
        BAT *b;
	int result;
	(void) result;
        @:getBATdescriptor(&result,bid,b,max)@
        if( CMDmax_@1(res,b)) return MAL_SUCCEED;
        return throwMessage("algebra.max", "GDKerror");
}
@c
@:ALGaggregate_implementation(uchr)@
@:ALGaggregate_implementation(sht)@
@:ALGaggregate_implementation(int)@
@:ALGaggregate_implementation(flt)@
@:ALGaggregate_implementation(dbl)@
@:ALGaggregate_implementation(lng)@

str ALGminany(ptr result, int *bid) {
        BAT *b;
	int res;
	(void) res;
        @:getBATdescriptor(&res,bid,b,minany)@
	if( CMDminany(result,b) == GDK_SUCCEED)
		return MAL_SUCCEED;
        return throwMessage("algebra.min", "GDKerror");
}
str ALGmaxany(ptr result, int *bid) {
        BAT *b;
	int res = 0;
	(void) res; /* fool compiler */
        @:getBATdescriptor(&res,bid,b,maxany)@
	if( CMDmaxany(result,b)== GDK_SUCCEED)
            return MAL_SUCCEED;
        return throwMessage("algebra.max", "GDKerror");
}


str ALGtopN(int *res, int *bid, lng *top) {
        if (BBPcheck(*bid, "BATsize")) {
                BAT *b = (BAT*) BBPgetdesc(*bid);
                if (b == NULL) {
                        *res = int_nil;
                } else
			(void) BATtopN(b, *top);
        }
        return MAL_SUCCEED;
}

str ALGcard(int *result, int *bid) {
	BAT *b,*bn;
	@:getBATdescriptor(result,bid,b,card)@
	bn = (BAT*) BATkunique(BATreverse(b));
	if(bn == NULL){
		return throwMessage("algebra.card", "GDKerror");
	}
	*result= BATcount(bn);
	return MAL_SUCCEED;
}

str ALGBATminimum(ptr *result, int *bid) {
	BAT *b;
	@:getBATdescriptor(result,bid,b,min)@
	BATmin(b,result);
	return MAL_SUCCEED;
}
str ALGBATmaximum(ptr *result, int *bid) {
	BAT *b;

	@:getBATdescriptor(result,bid,b,max)@
	BATmax(b,result);
	return MAL_SUCCEED;
}

str ALGselect1(int *result, int *bid, ptr value) {
	BAT *b, *bn = NULL;
	@:getBATdescriptor(result,bid,b,select)@
	@:derefStr(b,t,value)@
	CMDselect1(&bn,b,value);
	if( bn ) {
		*result = bn->batCacheid;
		return MAL_SUCCEED;
	}
	return throwMessage("algebra.select", "GDKerror");
}

str ALGuselect1(int *result, int *bid, ptr value) {
	BAT *b, *bn= NULL;
	@:getBATdescriptor(result,bid,b,uselect)@
	@:derefStr(b,t,value)@
	CMDuselect1(&bn,b,value);
	if( bn ) {
		*result = bn->batCacheid;
		return MAL_SUCCEED;
	}
	return throwMessage("algebra.uselect", "GDKerror");
}

str ALGselect(int *result, int *bid, ptr low, ptr high) {
	BAT *b, *bn= NULL;
	@:getBATdescriptor(result,bid,b,select)@
	@:derefStr(b,t,low)@
	@:derefStr(b,t,high)@
	CMDselect(&bn,b,low,high);
	if( bn ) {
		*result = bn->batCacheid;
		return MAL_SUCCEED;
	}
	return throwMessage("algebra.select", "GDKerror");
}
str ALGuselect(int *result, int *bid, ptr low, ptr high) {
	BAT *b, *bn= NULL;
	@:getBATdescriptor(result,bid,b,uselect)@
	@:derefStr(b,t,low);@
	@:derefStr(b,t,high);@
	CMDuselect(&bn,b,low,high);
	if( bn ) {
		*result = bn->batCacheid;
		return MAL_SUCCEED;
	}
	return throwMessage("algebra.uselect", "GDKerror");
}
str ALGselectInclusive(int *result, int *bid, ptr low, ptr high, bit *lin, bit *rin) {
	BAT *b, *bn= NULL;
	@:getBATdescriptor(result,bid,b,select)@
	@:derefStr(b,t,low)@
	@:derefStr(b,t,high)@
	CMDselect_(&bn,b,low,high,lin,rin);
	if( bn ) {
		*result = bn->batCacheid;
		return MAL_SUCCEED;
	}
	return throwMessage("algebra.select", "GDKerror");
}
str ALGuselectInclusive(int *result, int *bid, ptr low, ptr high, bit *lin, bit *rin) {
	BAT *b, *bn= NULL;
	@:getBATdescriptor(result,bid,b,uselect)@
	@:derefStr(b,t,low);@
	@:derefStr(b,t,high);@
	CMDuselect_(&bn,b,low,high,lin,rin);
	if( bn ) {
		*result = bn->batCacheid;
		return MAL_SUCCEED;
	}
	return throwMessage("algebra.uselect", "GDKerror");
}

str ALGfragment(int *result, int *bid,
		ptr hlow, ptr hhigh, ptr tlow, ptr thigh)
{
	BAT *b, *bn= NULL;
	@:getBATdescriptor(result,bid,b,fragment)@
	@:derefStr(b,h,hlow);@
	@:derefStr(b,h,hhigh);@
	@:derefStr(b,t,tlow);@
	@:derefStr(b,t,thigh);@
	CMDfragment(&bn,b,hlow,hhigh,tlow,thigh);
	if( bn ) {
		*result = bn->batCacheid;
		return MAL_SUCCEED;
	}
	return throwMessage("algebra.fragment", "GDKerror");
}

static int operatorCode(str opname){
	if(idcmp(opname,"EQ")==0) return 0;
	if(idcmp(opname,"LT")==0) return -1;
	if(idcmp(opname,"LE")==0) return -2;
	if(idcmp(opname,"GT")==0) return 1;
	if(idcmp(opname,"GE")==0) return 2;
	GDKerror("Illegal operator code, EQ assumed\n");
	return 0;
}
str ALGthetajoinEstimate(int *result, int *lid, int *rid, str *opname,lng *estimate) {
	BAT *left, *right, *bn= NULL;
	int opc= operatorCode(*opname);
	@:getBATdescriptor(result,lid,left,thetajoin)@
	@:getBATdescriptor(result,rid,right,thetajoin)@
	CMDthetajoin(&bn,left,right,&opc,estimate);
	if( bn ) {
		*result = bn->batCacheid;
		return MAL_SUCCEED;
	}
	return throwMessage("algebra.thetajoin", "GDKerror");
}
str ALGthetajoin(int *result, int *lid, int *rid, str *opname) {
	return ALGthetajoinEstimate(result,lid,rid,opname,&lng_nil);
}

str ALGtheta(int *iid, int *oi, int *lid, int *rid, str *opname) {
	BAT *ib, *ob, *lb, *rb;
	int opc= operatorCode(*opname);
	int result;
	(void) result;
	@:getBATdescriptor(&result,iid,ib,theta)@
	@:getBATdescriptor(&result,oi,ob,theta)@
	@:getBATdescriptor(&result,lid,lb,theta)@
	@:getBATdescriptor(&result,rid,rb,theta)@
	BATtheta(ib,ob,lb,rb,opc);
	return MAL_SUCCEED;
}
str ALGbandjoin(int *result, int *lid, int *rid, ptr *minus, ptr *plus) {
	BAT *left, *right, *bn= NULL;
	@:getBATdescriptor(result,lid,left,bandjoin)@
	@:getBATdescriptor(result,rid,right,bandjoin)@
	CMDbandjoin(&bn, left, right, minus, plus);
	if( bn ) {
		*result = bn->batCacheid;
		return MAL_SUCCEED;
	}
	return throwMessage("algebra.bandjoin", "GDKerror");
}

@-
Let cut this text down with some Mx macro's
@= ALGunary
str ALG@1(int *result, int *bid) {
	BAT *b,*bn;
	@:getBATdescriptor(result,bid,b,@1)@
	*result = 0;
	bn = @2(b);
	if( bn ) {
		*result = bn->batCacheid;
		return MAL_SUCCEED;
	}
	return throwMessage("algebra.@1", "GDKerror");
}
@= ALGunaryint
str ALG@1(int *result, int *bid) {
	BAT *b;
	*result = 0;
	@:getBATdescriptor(result,bid,b,@1)@
	*result = @2(b);
	return MAL_SUCCEED;
}
@= ALGbinary
str ALG@1(int *result, int *lid, int *rid) {
	BAT *left, *right,*bn= NULL;
	*result = 0;
	@:getBATdescriptor(result,lid,left,@1)@
	@:getBATdescriptor(result,rid,right,@1)@
	 CMD@1(&bn,left, right);
	if( bn ) {
		*result = bn->batCacheid;
		return MAL_SUCCEED;
	}
	return throwMessage("algebra.@1", "GDKerror");
}
@= ALGbinaryint
str ALG@1(int *result, int* bid, int *param) {
	BAT *b, *bn= NULL;
	*result = 0;
	@:getBATdescriptor(result,bid,b,@1)@
	CMD@1(&bn,b, param);
	if( bn ) {
		*result = bn->batCacheid;
		return MAL_SUCCEED;
	}
	return throwMessage("algebra.@1", "GDKerror");
}
@= ALGbinaryestimate
str ALG@1estimate(int *result, int *lid, int *rid, lng *estimate) {
	BAT *left, *right,*bn=NULL;
	*result = 0;
	@:getBATdescriptor(result,lid,left,@1)@
	@:getBATdescriptor(result,rid,right,@1)@
	CMD@1(&bn,left, right, estimate);
	if( bn ) {
		*result = bn->batCacheid;
		return MAL_SUCCEED;
	}
	return throwMessage("algebra.@1", "GDKerror");
}
str ALG@1(int *result, int* bid, int *param) {
	return ALG@1estimate(result,bid,param,&lng_nil);
}
@c
@:ALGunary(count_bat)@
@:ALGunary(histogram)@
@:ALGunary(sort)@
@:ALGunary(number)@
@:ALGunary(copy)@
@:ALGunary(kunique)@
@:ALGunary(sunique)@
@:ALGbinary(cross)@
@:ALGbinaryestimate(join)@
@:ALGbinaryestimate(outerjoin)@
@:ALGbinary(semijoin)@
@:ALGbinary(sunion)@
@:ALGbinary(kunion)@
@:ALGbinary(sintersect)@
@:ALGbinary(kintersect)@
@:ALGbinary(sdiff)@
@:ALGbinary(kdiff)@
@:ALGbinaryint(sample)@

str ALGcount_nil(int *result, int *bid, bit *ignore_nils) {
	BAT *b;
	@:getBATdescriptor(result,bid,b,count_nil)@
	CMDcount_nil(result,b,ignore_nils);
	return MAL_SUCCEED;
}

str ALGproject(int *result, int *bid, ptr p,int *t) {
	BAT *b, *bn= NULL;
	@:getBATdescriptor(result,bid,b,project)@
	CMDproject(&bn,b,p,*t);
	if( bn ) {
		*result = bn->batCacheid;
		return MAL_SUCCEED;
	}
	return throwMessage("algebra.project", 
		"can not perform a projection");
}

str ALGmark_grp(int *result, int *bid, int *gid) {
	BAT *b, *g, *bn= NULL;
	@:getBATdescriptor(result,bid,b,mark)@
	@:getBATdescriptor(result,gid,g,mark)@
	if( CMDmark_grp(&bn,b,g)== GDK_SUCCEED){
		*result = bn->batCacheid;
		return MAL_SUCCEED;
	}
	return throwMessage("algebra.mark", 
		"marking group failed");
}
str ALGmark(int *result, int *bid, oid *base) {
	BAT *b,  *bn= NULL;
	@:getBATdescriptor(result,bid,b,mark)@
	if( CMDmark(&bn,b,base)== GDK_SUCCEED){
		*result = bn->batCacheid;
		return MAL_SUCCEED;
	}
	return throwMessage("algebra.mark", 
		"marking group failed");
}
str ALGmark_default(int *result, int *bid) {
	BAT *b,  *bn= NULL;
	@:getBATdescriptor(result,bid,b,mark)@
	if( CMDmark_default(&bn,b)== GDK_SUCCEED){
		*result = bn->batCacheid;
		return MAL_SUCCEED;
	}
	return throwMessage("algebra.mark", 
		"marking group failed");
}
str ALGhashsplit(int *result, int *bid, int *nfrag){
	BAT *b, *bn= NULL;
	@:getBATdescriptor(result,bid,b,hashsplit)@
	CMDhashsplit(&bn,b,nfrag);
	if( bn ) {
		*result = bn->batCacheid;
		return MAL_SUCCEED;
	}
	return throwMessage("algebra.hashsplit", "GDKerror");
}
str ALGuhashsplit(int *result, int *bid, int *nfrag){
	BAT *b, *bn= NULL;
	@:getBATdescriptor(result,bid,b,uhashsplit)@
	CMDuhashsplit(&bn, b, nfrag);
	if( bn ) {
		*result = bn->batCacheid;
		return MAL_SUCCEED;
	}
	return throwMessage("algebra.uhashsplit", "GDKerror");
}
str ALGrangesplit(int *result, int *bid, int *nfrag){
	BAT *b, *bn= NULL;
	@:getBATdescriptor(result,bid,b,rangesplit)@
	CMDrangesplit(&bn, b, nfrag);
	if( bn ) {
		*result = bn->batCacheid;
		return MAL_SUCCEED;
	}
	return throwMessage("algebra.rangesplit", "GDKerror");
}
str ALGurangesplit(int *result, int *bid, int *nfrag){
	BAT *b, *bn= NULL;
	@:getBATdescriptor(result,bid,b,urangesplit)@
	CMDurangesplit(&bn, b, nfrag);
	if( bn ) {
		*result = bn->batCacheid;
		return MAL_SUCCEED;
	}
	return throwMessage("algebra.urangesplit", "GDKerror");
}
str ALGhistogram_rev(int *result, int *bid) {
	BAT *b, *bn= NULL;
	@:getBATdescriptor(result,bid,b,histogram)@
	CMDhistogram(&bn,b);
	if( bn ) {
		*result = bn->batCacheid;
		return MAL_SUCCEED;
	}
	return throwMessage("algebra.histogram", "GDKerror");
}

str ALGlike(int *ret, int *bid, str *k) {
	BAT *b, *bn= NULL;
	@:getBATdescriptor(ret,bid,b,like)@
	CMDlike(&bn, b,*k);
	if( bn ) {
		*ret = bn->batCacheid;
		return MAL_SUCCEED;
	}
	return throwMessage("algebra.like", "GDKerror");
}

str ALGslice(int *ret, bat *bid, int *start, int *end){
	BAT *b, *bn=NULL;
	@:getBATdescriptor(ret,bid,b,slice)@
	CMDslice(&bn,b,start,end);
	if( bn != NULL){
		*ret= bn->batCacheid;
		return MAL_SUCCEED;
	}
	*ret =0;
	return throwMessage("algebra.slice", "GDKerror");
}
@- BUN Get/Fetch
@c
str ALGposition(int *retval, int *bid, ptr val){
	BAT *b;

	@:getBATdescriptor(retval,bid,b,position)@
	@:derefStr(b,h,val)@
	CMDposition(retval,b,val);
        return MAL_SUCCEED;
}
str ALGpositionBUN(int *retval, int *bid, ptr val, ptr tval){
	BAT *b;

	@:getBATdescriptor(retval,bid,b,position)@
	@:derefStr(b,h,val)@
	@:derefStr(b,t,tval)@
	CMDpositionBUN(retval,b,val,tval);
        return MAL_SUCCEED;
}

str doALGfetch(ptr ret, BAT *b, lng *pos){
        lng i = *pos;
        if ((i < 0) || (i >= BATcount(b)))
                return throwMessage("algebra.fetch", " idx out of range");
        i += BUNindex(b, BUNfirst(b));
        @:putTail(BUNptr(b,i))@
@= putTail
        if (b->theap.base) {
            ptr _src = BUNtvar(b,@1); /*b->theap.base + *(var_t*) BUNtloc(b,@1);*/
            int _len = ATOMlen(b->ttype, _src);
            ptr _dst = GDKmalloc(_len);
            memcpy(_dst, _src, _len);
            *(ptr*) ret = _dst;
        } else {
            int _s = ATOMsize(ATOMtype(b->ttype));
            if (ATOMvarsized(b->ttype)) {
                memcpy(*(ptr*) ret=GDKmalloc(_s), BUNtloc(b, @1), _s);
            } else if (b->ttype == TYPE_bat) {
                bat bid = *(bat*) BUNtloc(b, @1);
                *(bat*) ret = bid;
                BBPfix(bid);
            } else if (_s == 4) {
                *(int*) ret = *(int*) BUNtail(b, @1);
            } else if (_s == 1) {
                *(chr*) ret = *(chr*) BUNtail(b, @1);
            } else if (_s == 2) {
                *(sht*) ret = *(sht*) BUNtail(b, @1);
            } else if (_s == 8) {
                *(lng*) ret = *(lng*) BUNtail(b, @1);
            } else {
                memcpy(ret, BUNtloc(b, @1), _s);
            }
        }
@c
        return MAL_SUCCEED;
}

str ALGfetchoid(int * ret, int *bid, oid *pos){
	BAT *b;
	@:getBATdescriptor(ret,bid,b,fetchoid)@
	CMDfetchoid(ret,b,pos);
	return MAL_SUCCEED;
}

str ALGfetch(ptr ret, int *bid, lng *pos){
	BAT *b;
	int result= 0;
	(void) result; /* fool compiler */

	@:getBATdescriptor(&result,bid,b,fetch);
	return doALGfetch(ret,b,pos);
}
str ALGfetchbat(int * ret, int *bid, int *sid){
        BAT *b, *s, *bn= NULL;
        @:getBATdescriptor(ret,bid,b,fetch)@
        @:getBATdescriptor(ret,sid,s,fetch)@
                                                                                
        bn= BATfetch(b, s);
        if( bn ) {
                *ret = bn->batCacheid;
                return MAL_SUCCEED;
        }
        return throwMessage("algebra.fetchbat", "GDKerror");

}

str ALGexist(bit *ret, int *bid, ptr val){
	BAT *b;
	int result= 0;
	(void) result; /* fool compiler */

	@:getBATdescriptor(&result,bid,b,exist);
	@:derefStr(b,h,val)@
	CMDexist(ret,b,val);
        return MAL_SUCCEED;
}
str ALGexistBUN(bit *ret, int *bid, ptr val, ptr tval){
	BAT *b;
	int result= 0;
	(void) result; /* fool compiler */

	@:getBATdescriptor(&result,bid,b,exist);
	@:derefStr(b,h,val)@
	@:derefStr(b,t,tval)@
	CMDexistBUN(ret,b,val,tval);
        return MAL_SUCCEED;
}

str ALGfind(ptr ret, int *bid, ptr val){
	BAT *b;
	int result= 0;
	(void) result; /* fool compiler */

	@:getBATdescriptor(&result,bid,b,find);
	@:derefStr(b,h,val)@
	CMDfind(ret,b,val);
        return MAL_SUCCEED;
}
str ALGfetchjoin(int *result, int *lid, int *rid) {
        BAT *left, *right,*bn=0;
        int rfetch,lfetch;
                                                                                
        @:getBATdescriptor(result,lid,left,fetchjoin)@
        @:getBATdescriptor(result,rid,right,fetchjoin)@
                                                                                
        rfetch = (BAThdense(right) && ATOMstorage(left->ttype) <= TYPE_int);
        lfetch = (BATtdense(left) && ATOMstorage(right->htype) <= TYPE_int);
        if (lfetch && !(rfetch && BATcount(left) < BATcount(right))) {
                bn= BATfetchjoin(left, right,lng_nil);
        } else if (rfetch)
                bn= BATmirror(BATfetchjoin(BATmirror(right), BATmirror(left),lng_nil));
                                                                                
        if( bn ) {
                *result = bn->batCacheid;
                return MAL_SUCCEED;
        }
	return throwMessage("algebra.fetchjoin", "can not perform a fetchjoin");
}
str ALGhashjoin(int *result, int *lid, int *rid) {
	BAT *left, *right,*bn;
	int lsize,rsize;

	@:getBATdescriptor(result,lid,left,hashjoin)@
	@:getBATdescriptor(result,rid,right,hashjoin)@

	lsize = left->batBuns->size + (left->hheap.base?left->hheap.size:0) +
                                 (left->theap.base?left->theap.size:0);
	rsize = right->batBuns->size + (right->hheap.base?right->hheap.size:0) +
                                 (right->theap.base?right->theap.size:0);

	if (rsize < lsize)
		bn= BATmirror(BAThashjoin(BATmirror(right), BATmirror(left),lng_nil));
	else	bn= BAThashjoin(left, right,lng_nil);

	if( bn ) {
		*result = bn->batCacheid;
		return MAL_SUCCEED;
	}
	return throwMessage("algebra.hashjoin", "can not perform a hashjoin");
}

str ALGmergejoin(int *result, int *lid, int *rid) {
	BAT *left, *right,*bn;

	@:getBATdescriptor(result,lid,left,mergejoin)@
	@:getBATdescriptor(result,rid,right,mergejoin)@
	if ( !((BATtordered(left)&1)||(BAThordered(right)&1)) )
		return throwMessage( "algebra.mergejoin",
			"neither left nor right bat is ordered.\n" );

	if ( (left->ttype==TYPE_void) || (right->htype==TYPE_void) )
		return throwMessage( "algebra.mergejoin",
			"Cannot perform mergejoin on void fields.\n" );
	bn= BATmergejoin(left,right,lng_nil);
	if( bn ) {
		*result = bn->batCacheid;
		return MAL_SUCCEED;
	}
	return throwMessage("algebra.mergejoin", "can not perform a mergejoin");
}

str ALGindexjoin(int *result, int *lid, int *rid) {
	BAT *left, *right,*bn;

	@:getBATdescriptor(result,lid,left,indexjoin)@
	@:getBATdescriptor(result,rid,right,indexjoin)@

	bn= BATthetajoin(left,right, JOIN_EQ, lng_nil);
	if( bn ) {
		*result = bn->batCacheid;
		return MAL_SUCCEED;
	}
	return throwMessage("algebra.indexjoin", "can not perform a indexjoin");
}

@}
