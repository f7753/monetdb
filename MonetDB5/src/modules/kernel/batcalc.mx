@f batcalc
@t BAT accummulate instructions
@a M.L. Kersten
@* Introduction
Many applications require extension of the basic calculator and
mathematic functions to work on BAT arguments. Although the
MAL multiplex module contains a command ('multiplex.script')
to generate the necessary code, it is often much more efficient to 
use one of the dedidacted batcalc functions introduced below.

The operators supported are limited to the built-in fixed length
atoms, because they permit ease of storage of the operation result.
Variable sized atoms, especially user defined, may require more
administrative activities.
Furthermore, the operands involved are assumed to be aligned,
so as to assure the fastest possible join evaluation.

Optimal processing performance is further obtained when the operators
can work as 'accumulators', for then we do not pay the price
of space allocation for a new intermediate. It may imply a BATcopy
before the accummulator function is being called.
A new BAT is of course created when the result of a function does not fit 
the accumulator.

The implementation does not take into account possible overflows
caused by the operators. However, the operators respect the NIL
semantics.

In addition to arithmetic and comparison operators, casting and
mathematical functions are directly supported.

@mal
module batcalc;

@- Basic arithmetic
The first group of functions provide abstractions over the
binary operators +,/,-,*, and %. Both on (BAT,BAT) and (BAT,CST)
operands.
@= calcGrp
#command CMD000(l:bat[lng,lng],r:bat[lng,lng]):bat[lng,lng]= CMD000;

command @1(b:bat[any::1,any::2], cst:any::2):bat[any::1,any::2] = CMDbat@3cst
comment "(BAT,Constant) calculator function with new BAT result";

command @1(a:bat[any::1,any::2],b:bat[any::1,any::2], 
	   cst:any::2): bat[any::1,any::2] = CMDbataccum@3cst
comment "(BAT,Constant) calculator function with accumulator BAT result";

command @1(b:bat[any::1,any::2], c:bat[any::1,any::2]):bat[any::1,any::2] 
	= CMDbat@3
comment "Binary BAT calculator function with new BAT result";

command @1(a:bat[any::1,any::2],b:bat[any::1,any::2], 
	     c:bat[any::1,any::2]):bat[any::1,any::2] = CMDbataccum@3
comment "Binary BAT calculator function with accumulator BAT result";

@-
@= calculations
	@:calcGrp(@1,lng,@2)@
@-
We need instantiations for the accumulator code,
but should limit modulo functions to integer-based types.
@mal
	@:calcGrp(%,oid,MOD)@
	@:calcGrp(%,sht,MOD)@
	@:calcGrp(%,int,MOD)@
	@:calcGrp(%,lng,MOD)@
@mal
	@:calculations(/,DIV)@
	@:calculations(*,MUL)@
	@:calculations(-,MIN)@
	@:calculations(+,ADD)@
@-
@= unary
command -(b:bat[any::1,@1]):bat[any::1,@1] = CMDunaryMIN
comment "Unary minus over the tail of the bat";

command --(b:bat[any::1,@1]):bat[any::1,@1] = CMDunaryMINMIN
comment "Unary minus over the tail of the bat";

command ++(b:bat[any::1,@1]):bat[any::1,@1] = CMDunaryPLUSPLUS
comment "Unary minus over the tail of the bat";

#command -(a:bat[any::1,@1],b:bat[any::1,@1]):bat[any::1,@1] 
	#= CMDunaryAccumMIN comment "Unary - over the tail of the bat";

#command --(a:bat[any::1,@1],b:bat[any::1,@1]):bat[any::1,@1] 
	#= CMDunaryAccumMINMIN comment "Unary -- over the tail of the bat";
#
#command ++(a:bat[any::1,@1],b:bat[any::1,@1]):bat[any::1,@1] 
	#= CMDunaryAccumPLUSPLUS comment "Unary ++ over the tail of the bat";
@mal
@:unary(oid)@
@:unary(int)@
@:unary(lng)@
@:unary(sht)@
@:unary(flt)@
@:unary(dbl)@

@- Comparison routines
The command signatures are similar to those above, producing a bit result.
@= comparison
command @1(b:bat[any::1,@2],c:bat[any::1,@2]): bat[any::1,bit]= CMDcmp@3;
command @1(a:bat[any::1,bit],b:bat[any::1,@2],
	   c:bat[any::1,@2]): bat[any::1,bit]= CMDcmpaccum@3;
command @1(b:bat[any::1,@2],cst:@2): bat[any::1,bit]= CMDcmp@3cst;
command @1(a:bat[any::1,bit],b:bat[any::1,@2],cst:@2): bat[any::1,bit]
	= CMDcmpaccum@3cst;

@= compareGrp
	@:comparison(<,@1,LT)@
	@:comparison(==,@1,EQ)@
	@:comparison(!=,@1,NEQ)@
	@:comparison(>,@1,GT)@
	@:comparison(<=,@1,LE)@
	@:comparison(>=,@1,GE)@
@mal
	@:compareGrp(bit)@
	@:compareGrp(dbl)@
	@:compareGrp(flt)@
	@:compareGrp(oid)@
	@:compareGrp(sht)@
	@:compareGrp(int)@
	@:compareGrp(lng)@

	@:comparison(and,bit,AND)@
	@:comparison(or,bit,OR)@
@- Boolean operations
The command signature can mostly be borrowed from the arithmetic.

@mal
command not(b:bat[any::1,bit]):bat[any::1,bit] = CMDbitbatNOT
comment "Return a new BAT with the negated tail";

command not(a:bat[any::1,bit],b:bat[any::1,bit]):bat[any::1,bit] 
	= CMDbitbataccumNOT
comment "Return a BAT with the negated tail";

command ifthenelse(b:bat[any::1,bit],e:any::2, t:bat[any::1,any::2]): bat[any::1,any::2] = CMDifThenElseCst1
comment "If-then-else operation to assemble a conditional result ";

command ifthenelse(b:bat[any::1,bit], t:bat[any::1,any::2], e:any::2): bat[any::1,any::2] = CMDifThenElseCst2
comment "If-then-else operation to assemble a conditional result ";

command ifthen(b:bat[any::1,bit], t:bat[any::1,any::2]): bat[any::1,any::2] = CMDifThen
comment "Ifthen operation to assemble a conditional result ";

command ifthenelse(b:bat[any::1,bit], t:bat[any::1,any::2], e:bat[any::1,any::2]): bat[any::1,any::2] = CMDifThenElse
comment "If-then-else operation to assemble a conditional result ";

@-
@= ifthenGrp
command fill(v:@1,b:bat[any,any::1]): bat[@1,any::1] = CMDfillhead_@1
comment "Fill the head with a constant.";

command fill(b:bat[any::1,any], v:@1): bat[any::1,@1] = CMDfilltail_@1
comment "Fill the tail with a constant.";

command ifthen(b:bat[any::1,bit], v:@1): bat[any::1,@1] = CMDifThenCst_@1
comment "Ifthen operation to assemble a conditional result ";

command ifthenelse(b:bat[any::1,bit], v:@1,w:@1): bat[any::1,@1] = CMDifThenElseCst_@1
comment "Ifthen operation to assemble a conditional result ";
@mal
	@:ifthenGrp(bit)@
	@:ifthenGrp(chr)@
	@:ifthenGrp(str)@
	@:ifthenGrp(oid)@
	@:ifthenGrp(int)@
	@:ifthenGrp(sht)@
	@:ifthenGrp(lng)@
	@:ifthenGrp(flt)@
	@:ifthenGrp(dbl)@

@- Coercion routines
The coercion routines over BATs can not easily speed up using
an accumulator approach, because they often require enlarged storage space. 
Nevertheless, the implementation provided here are much faster compared
to theVersion 4.3 implementation.

@= coercion
command @2(b:bat[any::1,@1]):bat[any::1,@2] = CMDconvert@1_@2
comment "Coerce an @1 tail to a bat with a @2 tail.";
@-
@= coerceList
	@:coercion(@1,dbl)@
	@:coercion(@1,flt)@
	@:coercion(@1,sht)@
	@:coercion(@1,int)@
	@:coercion(@1,lng)@
@mal
	@:coerceList(sht)@
	@:coerceList(int)@
	@:coerceList(lng)@
	@:coerceList(flt)@
	@:coerceList(dbl)@

command int(b:bat[any::1,str]):bat[any::1,int] = CMDconvertstr_int
comment "Coerce an str tail to a bat with a int tail.";

@- Scientific routines
The mmath functions are also overloaded to provide for
the fast execution of expanded code blocks.

@= scienceFcn
command @1(x:bat[any::1,dbl])  :bat[any::1,dbl] = CMDscience_@1;
@= scienceFcnBinary
command @1(x:bat[any::1,dbl],y:@2)  :bat[any::1,dbl] = CMDscience_@1;
@-
@mal
	@:scienceFcn(asin)@
	@:scienceFcn(acos)@
	@:scienceFcn(atan)@
	@:scienceFcn(cos)@
	@:scienceFcn(sin)@
	@:scienceFcn(tan)@
	@:scienceFcn(cosh)@
	@:scienceFcn(sinh)@
	@:scienceFcn(tanh)@
	@:scienceFcn(exp)@
	@:scienceFcn(log)@
	@:scienceFcn(log10)@
	@:scienceFcn(sqrt)@
	@:scienceFcn(ceil)@
	@:scienceFcn(fabs)@
	@:scienceFcn(floor)@
	@:scienceFcnBinary(round,int)@
	@:scienceFcnBinary(fmod,dbl)@
	@:scienceFcnBinary(atan2,dbl)@
	@:scienceFcnBinary(pow,dbl)@
@-
@- Implementation
@h
/*
 * The contents of this file are subject to the Monet Public
 * License Version 1.1 (the "License"); you may not use this file
 * except in compliance with the License. You may obtain a copy of
 * the License at 
 * http://www.monetsolutions.com/Download/Licensing/MonetPL-1.1.html
 * 
 * Software distributed under the License is distributed on an "AS
 * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
 * implied. See the License for the specific language governing
 * rights and limitations under the License.
 * 
 * The Original Code is the Monet Database System.
 * 
 * The Initial Developer of the Original Code is CWI.
 * Portions created by CWI are Copyright (C) 1997-2002 CWI.  
 * All Rights Reserved.
 * 
 * Contributor(s): Martin Kersten <Martin.Kersten@cwi.nl>
 */
#include "gdk.h"
#include "math.h"
#include "mal_squeezer.h"
#include "mal_client.h"

@-
The accumulator operators are relatively straight forward,
when the target BAT is known and we only have to deal with
fixed-sized types. 
@= batinit
	s@1= BUNsize(@2);
	p@1= (str) (BUNfirst(@2)+@2->tloc);
@-
@= accum
	while( p1 < hend ){
		/* this code is better as x?nil:y  */
		if(*(@1 *)p2 == @1_nil || *(@1*)p3 == @1_nil)
			*(@1*)p1= @1_nil;
		else *(@1*)p1= * (@1*) p2 @2 *(@1 *) p3;
		p1+= s1; p2+= s2; p3+= s3;
	}
@-
This code could be further improved by factoring
out occurrences of the nil-tst on the constant provided.
This has been left out.
@= accumCst
	while( p1 < hend ){
		if(*(@1 *)p2 == @1_nil || *(@1*)cst == @1_nil)
			*(@1*)p1= @1_nil;
		else *(@1*)p1 = *(@1*) p2 @2 *(@1 *) cst;
		p1+= s1; p2+= s2;
	}
@-
The following utility extracts the BATdescriptor
@= getBATdescriptor
        if( BBPcheck(*@2,"@4")==0) 
		return throwMessage("batcalc.@4", "cannot access bat @2 in bbp");
        @3= (BAT*) BBPgetdesc(*@2);
        if( @3 == NULL) { *@1 = 0; 
		return throwMessage("batcalc.@4", "cannot access descriptor @2");
	}
        if( *@2 <0){ /* BAT reverse */ @3 = BATmirror(@3); }
@-
A general assumption in all cases is the bats are synchronized on their
head column. This is not checked and may be mis-used to deploy the
implementation for shifted window arithmetic as well.
@= chkSize
	if( BATcount(@1) != BATcount(@2) )
	return throwMessage("batcalc.@3", "requires bats of identical size");
@= tstBat
if( bn== NULL) {*ret= 0; 
	return throwMessage("batcalc.@1", "can not create bat");}
@-
@c
@-
The code block below heavily uses the MX code expansion involved,
but in essence the structure is relatively simple.
The BAT loops to cover the cases for arithmetic are
collected in bataccum<operator>. Initialization of the
two primary command structures are dealt with in the CMD* alternatives.
The similar code base is produced for dealing with a constant argument. 
@= arithmeticImpl
str bataccum@1(BAT *dst, BAT *left, BAT *right)
{	int s1,s2,s3;
	ptr p1,p2,p3, hend;

	@:batinit(1,dst)@
	@:batinit(2,left)@
	@:batinit(3,right)@
	hend = (str) BUNlast(dst);
	switch(BATttype(dst)){
	case TYPE_flt: @:accum(flt,@2)@ break;
	case TYPE_dbl: @:accum(dbl,@2)@ break;
	case TYPE_oid: @:accum(oid,@2)@ break;
	case TYPE_sht: @:accum(sht,@2)@ break;
	case TYPE_int: @:accum(int,@2)@ break;
	case TYPE_lng: @:accum(lng,@2)@ break;
	default: throwMessage("batcalc.@1", "unexpected type");
	}
	return MAL_SUCCEED;
}

str CMDbat@1(int *ret, int *l, int *r)
{	BAT *dst, *left, *right;

	@:getBATdescriptor(ret,l,left,CMDbat@1)@
	@:getBATdescriptor(ret,r,right,CMDbat@1)@

	@:chkSize(left,right,CMDbat@1)@

	dst= BATcopy(left);
	BBPfix(*ret = dst->batCacheid);
	return bataccum@1(dst,left,right);
}

str CMDbataccum@1(int *ret, int *d, int *l, int *r)
{	BAT *dst, *left, *right;

	@:getBATdescriptor(ret,d,dst,CMDbataccum@1)@
	@:getBATdescriptor(ret,l,left,CMDbataccum@1)@
	@:getBATdescriptor(ret,r,right,CMDbataccum@1)@

	@:chkSize(dst,left,CMDbataccum@1)@
	@:chkSize(dst,right,CMDbataccum@1)@

	BBPfix(*ret = dst->batCacheid);
	return bataccum@1(dst,left,right);
}
str CMDbataccum@1cst(int *ret, int *r, int *l, void *cst)
{	BAT *dst, *left;
	int s1,s2;
	ptr p1,p2, hend;

	@:getBATdescriptor(ret,r,dst,CMDbataccum@1)@
	@:getBATdescriptor(ret,l,left,CMDbataccum@1)@
	@:chkSize(dst,left,CMDbataccum@1)@
	BBPfix(*ret = dst->batCacheid);
	@:batinit(1,dst)@
	@:batinit(2,left)@
	hend = (str) BUNlast(dst);

	switch(BATttype(left)){
	case TYPE_flt: @:accumCst(flt,@2)@ break;
	case TYPE_dbl: @:accumCst(dbl,@2)@ break;
	case TYPE_oid: @:accumCst(oid,@2)@ break;
	case TYPE_sht: @:accumCst(sht,@2)@ break;
	case TYPE_int: @:accumCst(int,@2)@ break;
	case TYPE_lng: @:accumCst(lng,@2)@ break;
	default: return throwMessage("batcalc.@1", "unexpected type");
	}
	return MAL_SUCCEED;
}

str CMDbat@1cst(int *ret, int *l, void *cst)
{	BAT *dst, *left;
	int d;

	@:getBATdescriptor(ret,l,left,CMDbat@1)@
	dst= BATcopy(left);
	d= dst->batCacheid;
	return CMDbataccum@1cst(ret, &d,l,cst);
}
@c
#include "batcalc.h"

	@:arithmeticImpl(ADD,+)@
	@:arithmeticImpl(MIN,-)@
	@:arithmeticImpl(MUL,*)@
	@:arithmeticImpl(DIV,/)@

@-  Modulo arithmetic
The Modulo function doesn;t work on all types. Therefore we 
define here the necessary implementations separately by copying
the arithmeticImpl block and removing elements not required.
@c
str bataccumMOD(BAT *dst, BAT *left, BAT *right)
{	int s1,s2,s3;
	ptr p1,p2,p3, hend;

	@:batinit(1,dst)@
	@:batinit(2,left)@
	@:batinit(3,right)@
	hend = (str) BUNlast(dst);
	switch(BATttype(dst)){
	case TYPE_oid: @:accum(oid,%)@ break;
	case TYPE_sht: @:accum(sht,%)@ break;
	case TYPE_int: @:accum(int,%)@ break;
	case TYPE_lng: @:accum(lng,%)@ break;
	default: return throwMessage("batcalc.MOD", "unexpected type");
	}
	return MAL_SUCCEED;
}

str CMDbatMOD(int *ret, int *l, int *r)
{	BAT *dst, *left, *right;

	@:getBATdescriptor(ret,l,left,CMDbatMOD)@
	@:getBATdescriptor(ret,r,right,CMDbatMOD)@

	@:chkSize(left,right,CMDbatMOD)@

	dst= BATcopy(left);
	BBPfix(*ret = dst->batCacheid);
	return bataccumMOD(dst,left,right);
}

str CMDbataccumMOD(int *ret, int *d, int *l, int *r)
{	BAT *dst, *left, *right;

	@:getBATdescriptor(ret,d,dst,CMDbataccumMOD)@
	@:getBATdescriptor(ret,l,left,CMDbataccumMOD)@
	@:getBATdescriptor(ret,r,right,CMDbataccumMOD)@

	@:chkSize(dst,left,CMDbataccumMOD)@
	@:chkSize(dst,right,CMDbataccumMOD)@

	BBPfix(*ret = dst->batCacheid);
	return bataccumMOD(dst,left,right);
}
str CMDbataccumMODcst(int *ret, int *r, int *l, void *cst)
{	BAT *dst, *left;
	int s1,s2;
	ptr p1,p2, hend;

	@:getBATdescriptor(ret,r,dst,CMDbataccumMOD)@
	@:getBATdescriptor(ret,l,left,CMDbataccumMOD)@
	@:chkSize(dst,left,CMDbataccumMOD)@
	BBPfix(*ret = dst->batCacheid);
	@:batinit(1,dst)@
	@:batinit(2,left)@
	hend = (str) BUNlast(dst);

	switch(BATttype(left)){
	case TYPE_oid: @:accumCst(oid,%)@ break;
	case TYPE_sht: @:accumCst(sht,%)@ break;
	case TYPE_int: @:accumCst(int,%)@ break;
	case TYPE_lng: @:accumCst(lng,%)@ break;
	default : return throwMessage("batcalc.Mod", "unexpected type");
	}
	return MAL_SUCCEED;
}

str CMDbatMODcst(int *ret, int *l, void *cst)
{	BAT *dst, *left;

	@:getBATdescriptor(ret,l,left,CMDbatMOD)@
	dst= BATcopy(left);
	return CMDbataccumMODcst(ret, &dst->batCacheid,l,cst);
}
@- Implementation of unary operations
@= accumUnary
	while( p1 < hend ){
		/* this code is better as x?nil:y  */
		if(*(@1 *)p2 == @1_nil )
			*(@1*)p1= @1_nil;
		else *(@1*)p1= @2 *(@1 *) p2;
		p1+= s1; p2+= s2; 
	}
@-
Unary accummulators are only indirectly called. They can not
always be defined without signature clashes, eg. -(batA,batC).
@= unary_impl
str CMDunaryAccum@1(int *ret,int *did, int *bid){
	BAT *b,*dst;
	int s1,s2;
	ptr p1,p2, hend;
	
	@:getBATdescriptor(ret,did,dst,CMDunaryAccum@1)@
	@:getBATdescriptor(ret,bid,b,CMDunaryAccum@1)@
	@:batinit(1,dst)@
	@:batinit(2,b)@
	hend = (str) BUNlast(dst);
	switch(BATttype(dst)){
	case TYPE_oid: @:accumUnary(oid,@2)@ break;
	case TYPE_sht: @:accumUnary(sht,@2)@ break;
	case TYPE_int: @:accumUnary(int,@2)@ break;
	case TYPE_lng: @:accumUnary(lng,@2)@ break;
	case TYPE_flt: @:accumUnary(flt,@2)@ break;
	case TYPE_dbl: @:accumUnary(dbl,@2)@ break;
	default: return throwMessage("batcalc.MIN", "unexpected type");
	}
	*ret= dst->batCacheid;
	return MAL_SUCCEED;
}
str CMDunary@1(int *ret, int *bid){
	BAT *b,*dst;
	
	@:getBATdescriptor(ret,bid,b,CMDunary@1)@
	dst= BATcopy(b);
	return CMDunaryAccum@1(ret,&dst->batCacheid,bid);
}
@c
@:unary_impl(MIN,-)@
@:unary_impl(MINMIN,--)@
@:unary_impl(PLUSPLUS,++)@

@- Implementation of comparisons
The structure of this code is copied from the arithmetic scheme.
@= cmpLoop
	while( p2 < hend ){
		/* this code is better as x?nil:y */
		if(*(@1 *)p2 == @1_nil || *(@1*)p3 == @1_nil)
			*(bit*)p1= bit_nil;
		else *(bit*)p1= * (@1*) p2 @2 *(@1 *) p3;
		p1+= s1; p2+= s2; p3+= s3;
	}
@-
@= cmpLoopCst
	while( p1 < hend ){
		if(*(@1 *)p2 == @1_nil || *(@1*)cst == @1_nil)
			*(bit*)p1= bit_nil;
		else *(bit*)p1 = *(@1*) p2 @2 *(@1 *) cst;
		p1+= s1; p2+= s2;
	}
@= compareImpl
str compareaccum@1(BAT *dst, BAT *left, BAT *right){
	int s1,s2,s3;
	ptr p1,p2,p3, hend;

	@:batinit(1,dst)@
	@:batinit(2,left)@
	@:batinit(3,right)@
	hend = (str) BUNlast(left);

	switch(BATttype(dst)){
	case TYPE_bit: @:cmpLoop(bit,@2)@ break;
	case TYPE_flt: @:cmpLoop(flt,@2)@ break;
	case TYPE_dbl: @:cmpLoop(dbl,@2)@ break;
	case TYPE_oid: @:cmpLoop(oid,@2)@ break;
	case TYPE_sht: @:cmpLoop(sht,@2)@ break;
	case TYPE_int: @:cmpLoop(int,@2)@ break;
	case TYPE_lng: @:cmpLoop(lng,@2)@ break;
	default: return throwMessage("batcalc.@1", "unexpected type");
	}
	return MAL_SUCCEED;
}
str CMDcmp@1(int *ret, int *l, int *r)
{	BAT *dst, *left, *right;
	int s1,xx;
	ptr p1, hend;
	bit bn= bit_nil;
	BUN p,q;

	@:getBATdescriptor(ret,l,left,CMDcompare@1)@
	@:getBATdescriptor(ret,r,right,CMDcompare@1)@

	@:chkSize(left,right,CMDcompare@1)@

	dst= BATnew(BAThtype(left),TYPE_bit, BATcount(left));

	s1= BUNsize(dst);
	p1= BUNfirst(dst);
	 
	BATloopFast(left,p,q,xx){
		ptr h= BUNhead(left,p);
		bunfastins_nocheck(dst,p1,h,&bn,s1);
		p1+= s1;
	}
	dst->hsorted= BAThordered(left);
	BBPfix(*ret = dst->batCacheid);
	return compareaccum@1(dst,left,right);
}

str CMDcmpaccum@1(int *ret, int *d, int *l, int *r)
{	BAT *dst, *left, *right;

	@:getBATdescriptor(ret,d,dst,CMDbcompareaccum@1)@
	@:getBATdescriptor(ret,l,left,CMDcompareaccum@1)@
	@:getBATdescriptor(ret,r,right,CMDcompareaccum@1)@

	@:chkSize(dst,left,CMDcompareaccum@1)@
	@:chkSize(dst,right,CMDcompareaccum@1)@

	BBPfix(*ret = dst->batCacheid);
	return compareaccum@1(dst,left,right);
}
@= cmpCstImpl
str CMDcmpaccum@1cst(int *ret, int *r, int *l, void *cst)
{	BAT *dst, *left;
	int s1,s2;
	ptr p1,p2, hend;

	@:getBATdescriptor(ret,r,dst,CMDbataccum@1)@
	@:getBATdescriptor(ret,l,left,CMDbataccum@1)@
	@:chkSize(dst,left,CMDbataccum@1)@
	BBPfix(*ret = dst->batCacheid);
	@:batinit(1,dst)@
	@:batinit(2,left)@
	hend = (str) BUNlast(dst);

	switch(BATttype(left)){
	case TYPE_bit: @:cmpLoopCst(bit,@2)@ break;
	case TYPE_flt: @:cmpLoopCst(flt,@2)@ break;
	case TYPE_dbl: @:cmpLoopCst(dbl,@2)@ break;
	case TYPE_oid: @:cmpLoopCst(oid,@2)@ break;
	case TYPE_sht: @:cmpLoopCst(sht,@2)@ break;
	case TYPE_int: @:cmpLoopCst(int,@2)@ break;
	case TYPE_lng: @:cmpLoopCst(lng,@2)@ break;
	default :return throwMessage("batcalc.@1","unexpected type");
	}
	return MAL_SUCCEED;
}

str CMDcmp@1cst(int *ret, int *l, void *cst)
{	BAT *dst, *left;
	int s1,d,xx;
	ptr p1, hend;
	bit bn= bit_nil;
	BUN p,q;

	@:getBATdescriptor(ret,l,left,CMDcompare@1)@

	dst= BATnew(BAThtype(left),TYPE_bit, BATcount(left));

	s1= BUNsize(dst);
	p1= BUNfirst(dst);
	 
	BATloopFast(left,p,q,xx){
		ptr h= BUNhead(left,p);
		bunfastins_nocheck(dst,p1,h,&bn,s1);
		p1+= s1;
	}
	dst->hsorted= BAThordered(left);
	
	return CMDcmpaccum@1cst(ret,&dst->batCacheid,l,cst);
}

@-
@c
	@:compareImpl(GE,>=)@
	@:compareImpl(LE,<=)@
	@:compareImpl(GT,>)@
	@:compareImpl(LT,<)@
	@:compareImpl(EQ,==)@
	@:compareImpl(NEQ,!=)@
	@:cmpCstImpl(GE,>=)@
	@:cmpCstImpl(LE,<=)@
	@:cmpCstImpl(GT,>)@
	@:cmpCstImpl(LT,<)@
	@:cmpCstImpl(EQ,==)@
	@:cmpCstImpl(NEQ,!=)@

@- Implementations of boolean operators
The code base is straightforward.
@-
The expanded code for the binary and boolean operations.
@c
	@:compareImpl(AND,&&)@
	@:compareImpl(OR,||)@
	@:cmpCstImpl(AND,&&)@
	@:cmpCstImpl(OR,||)@

str CMDbitbataccumNOT(int *ret, int *d, int *l)
{	BAT *dst, *left;
	int s1,s2;
	ptr p1,p2, hend;
	bit bn= bit_nil;

	@:getBATdescriptor(ret,d,dst,CMDbitbataccum@1)@
	@:getBATdescriptor(ret,l,left,CMDbitbataccum@1)@

	@:chkSize(dst,left,CMDbitbataccum@1)@
	@:batinit(1,left);
	@:batinit(2,dst);
	hend = (str) BUNlast(left);
	while( p1 < hend ){
		/* this code is better as x?nil:y */
		if(*(bit *)p1 == bit_nil )
			*(bit*)p2 = bit_nil;
		else *(bit*) p2 =  ! * (bit*) p1;
		p1+= s1; p2+= s2; 
	}

	BBPfix(*ret = dst->batCacheid);
	return MAL_SUCCEED;
}
str CMDbitbatNOT(int *ret, int *l)
{	BAT *dst, *left;
	int s1,xx,d;
	ptr p1, hend;
	bit bn= bit_nil;
	BUN p,q;

	@:getBATdescriptor(ret,l,left,CMDcompare@1)@

	dst= BATnew(BAThtype(left),TYPE_bit, BATcount(left));

	s1= BUNsize(dst);
	p1= BUNfirst(dst);
	 
	BATloopFast(left,p,q,xx){
		ptr h= BUNhead(left,p);
		bunfastins_nocheck(dst,p1,h,&bn,s1);
		p1+= s1;
	}
	dst->hsorted= BAThordered(left);
	d= dst->batCacheid;
	return CMDbitbataccumNOT(ret,&d,l);
}

@- Implementation of coercions
The coercion code can not be improved much, because we do not have
the space to re-use. Therefore, the code block is actually a hardwired
version of a bunstream() operation. It runs, however, about 5-times
faster then [lng](b) in Version 4.
@c
BAT *newBATresult(BAT *b, int tpe){
	BAT *bn;
	if( BAThvoid(b)){
		bn= BATnew(TYPE_void, tpe, BATcount(b));
		BATseqbase(bn,b->hseqbase);
	} else bn= BATnew(b->htype, tpe, BATcount(b));
	return bn;
}
@-
@= coercionImpl
str CMDconvert@1_@2(int *ret, int *bid){
	BAT *b,*bn;
	int xx;
	BUN p,q;
	ptr h,t;
	@1 x;
	@2 y;

	@:getBATdescriptor(ret,bid,b,CMDconvert@1)@

	bn= newBATresult(b, TYPE_@2);
	@:tstBat(CMDconvert@1)@

	BATloopFast(b, p, q, xx) {
		ptr h = BUNhead(b,p);
		x= *(@1 *) BUNtail(b,p);
		y= x== @1_nil? @2_nil: x;
		bunfastins(bn, h, &y);
	}
	BBPfix( *ret= bn->batCacheid);
	return MAL_SUCCEED;
}
@= coercionImpList
	@:coercionImpl(@1,sht)@
	@:coercionImpl(@1,int)@
	@:coercionImpl(@1,lng)@
	@:coercionImpl(@1,flt)@
	@:coercionImpl(@1,dbl)@
@c
	@:coercionImpList(sht)@
	@:coercionImpList(int)@
	@:coercionImpList(lng)@
	@:coercionImpList(flt)@
	@:coercionImpList(dbl)@
str CMDconvertstr_int(int *ret, int *bid){
	BAT *b,*bn;
	int xx;
	BUN p,q;
	ptr h,t;
	str x;
	int y;

	@:getBATdescriptor(ret,bid,b,CMDconvertstr_int)@

	bn= newBATresult(b, TYPE_int);
	@:tstBat(CMDconvertstr_int)@

	BATloopFast(b, p, q, xx) {
		ptr h = BUNhead(b,p);
		x= (str) BUNtail(b,p);
		y= x== str_nil? int_nil: strtol(x,NULL,0);
		bunfastins(bn, h, &y);
	}
	BBPfix( *ret= bn->batCacheid);
	return MAL_SUCCEED;
}
@- Implementations of scientific functions
@c
	@:scienceFcnImpl(asin)@
	@:scienceFcnImpl(acos)@
	@:scienceFcnImpl(atan)@
	@:scienceFcnImpl(cos)@
	@:scienceFcnImpl(sin)@
	@:scienceFcnImpl(tan)@
	@:scienceFcnImpl(cosh)@
	@:scienceFcnImpl(sinh)@
	@:scienceFcnImpl(tanh)@
	@:scienceFcnImpl(exp)@
	@:scienceFcnImpl(log)@
	@:scienceFcnImpl(log10)@
	@:scienceFcnImpl(sqrt)@
	@:scienceFcnImpl(ceil)@
	@:scienceFcnImpl(fabs)@
	@:scienceFcnImpl(floor)@
	@:scienceBinaryImpl(round,int)@
	@:scienceBinaryImpl(fmod,dbl)@
	@:scienceBinaryImpl(atan2,dbl)@
	@:scienceBinaryImpl(pow,dbl)@
@-
@= scienceFcnImpl
str CMDscience_@1(int *ret, int *bid){
	BAT *b,*bn;
	int xx;
	BUN p,q;

	@:getBATdescriptor(ret,bid,b,CMDscience_@1)@

	bn= newBATresult(b, TYPE_dbl);
	@:tstBat(CMDscience_@1)@
	BATloopFast(b, p, q, xx) {
		ptr h = BUNhead(b,p);
		dbl t = *(dbl*) BUNtail(b,p);
		dbl x= t== dbl_nil? dbl_nil:@1(t);
		bunfastins(bn, h, &x);
	}
	BBPfix( *ret= bn->batCacheid);
	return MAL_SUCCEED;
}
@= scienceBinaryImpl
str CMDscience_@1(int *ret, int *bid, @2 *d){
	BAT *b,*bn;
	int xx;
	BUN p,q;

	@:getBATdescriptor(ret,bid,b,CMDscience_@1)@

	bn= newBATresult(b, TYPE_dbl);
	@:tstBat(CMDscience_@1)@

	BATloopFast(b, p, q, xx) {
		ptr h = BUNhead(b,p);
		dbl t = *(dbl*) BUNtail(b,p);
		dbl x= t== dbl_nil? dbl_nil:@1(t, *d);
		bunfastins(bn, h, &x);
	}
	BBPfix( *ret= bn->batCacheid);
	return MAL_SUCCEED;
}
@- IfThenElse
The conditional multiplex operations .
@c
str CMDifThen(int *ret, int *iid, int *tid){
	BAT *ib, *tb, *bn;
	int xx;
	BUN p,q;
	bit bnil= bit_nil;

	@:getBATdescriptor(ret,iid,ib,CMDifThen)@
	@:getBATdescriptor(ret,tid,tb,CMDifThen)@
	@:chkSize(ib,tb,CMDifThen)@

	bn= BATnew(BAThtype(ib),BATttype(tb),BATcount(ib));
	@:tstBat(CMDifThen)@

	BATloopFast(ib, p, q, xx) {
		ptr h = BUNhead(ib,p);
		ptr t = BUNtail(ib,p);
		int idx = BUNindex(ib,p);

		if( *(bit*) t== bit_nil) {
			bunfastins(bn, h, &bnil);
		} else
		if( *(bit*) t ) {
			t= BUNtail(tb,BUNptr(tb,idx));
			bunfastins(bn, h, t);
		} 
	}
	BBPfix( *ret= bn->batCacheid);
	return MAL_SUCCEED;
}
@-
The constant versions are typed by the parser
@= ifthencstImpl
str CMDifThenCst_@1(int *ret, int *iid, ptr *eid){
	BAT *ib, *bn;
	int xx;
	BUN p,q;
	@1 bnil= @1_nil;

	@:getBATdescriptor(ret,iid,ib,CMDifThen_@1)@

	bn= BATnew(BAThtype(ib),TYPE_@1,BATcount(ib));
	@:tstBat(CMDifThenCst_@1)@
	BATloopFast(ib, p, q, xx) {
		ptr h = BUNhead(ib,p);
		ptr t = BUNtail(ib,p);

		if( *(bit*) t== bit_nil) {
			bunfastins(bn, h, &bnil);
		} else
		if( *(bit*) t ) {
			bunfastins(bn, h, eid);
		} 
	}
	BBPfix( *ret= bn->batCacheid);
	return MAL_SUCCEED;
}
str CMDifThenElseCst_@1(int *ret, int *iid, ptr *tid, ptr *eid){
	BAT *ib, *bn;
	int xx;
	BUN p,q;
	@1 bnil= @1_nil;

	@:getBATdescriptor(ret,iid,ib,CMDifThen_@1)@

	bn= BATnew(BAThtype(ib),TYPE_@1,BATcount(ib));
	@:tstBat(CMDifThenElseCst_@1)@
	BATloopFast(ib, p, q, xx) {
		ptr h = BUNhead(ib,p);
		ptr t = BUNtail(ib,p);

		if( *(bit*) t== bit_nil) {
			bunfastins(bn, h, &bnil);
		} else
		if( *(bit*) t ) {
			bunfastins(bn, h, tid);
		} else {
			bunfastins(bn, h, eid);
		} 
	}
	BBPfix( *ret= bn->batCacheid);
	return MAL_SUCCEED;
}
str CMDfilltail_@1(int *ret, int *iid, ptr *val){
	BAT *ib, *bn;
	int xx;
	BUN p,q;
	@1 bnil= @1_nil;

	@:getBATdescriptor(ret,iid,ib,CMDfilltail_@1)@

	bn= BATnew(BAThtype(ib),TYPE_@1,BATcount(ib));
	@:tstBat(CMDfilltail_@1)@
	BATloopFast(ib, p, q, xx) {
		ptr v = BUNhead(ib,p);
		bunfastins(bn, v, val);
	}
	BBPfix( *ret= bn->batCacheid);
	return MAL_SUCCEED;
}
str CMDfillhead_@1(int *ret,ptr *val, int *iid){
	BAT *ib, *bn;
	int xx;
	BUN p,q;
	@1 bnil= @1_nil;

	@:getBATdescriptor(ret,iid,ib,CMDfillhead_@1)@

	bn= BATnew(BAThtype(ib),TYPE_@1,BATcount(ib));
	@:tstBat(fillhead_@1)@
	BATloopFast(ib, p, q, xx) {
		ptr v = BUNtail(ib,p);
		bunfastins(bn, val,v);
	}
	BBPfix( *ret= bn->batCacheid);
	return MAL_SUCCEED;
}
@-
@c
	@:ifthencstImpl(int)@
	@:ifthencstImpl(sht)@
	@:ifthencstImpl(lng)@
	@:ifthencstImpl(oid)@
	@:ifthencstImpl(flt)@
	@:ifthencstImpl(dbl)@
	@:ifthencstImpl(str)@
	@:ifthencstImpl(chr)@
	@:ifthencstImpl(bit)@

str CMDifThenElse(int *ret, int *iid, int *tid,int *eid){
	BAT *ib, *tb, *eb, *bn;
	int xx;
	BUN p,q;
	bit bnil= bit_nil;

	@:getBATdescriptor(ret,iid,ib,CMDifThen)@
	@:getBATdescriptor(ret,tid,tb,CMDifThen)@
	@:getBATdescriptor(ret,eid,eb,CMDifThen)@
	@:chkSize(ib,tb,CMDifThenElse)@
	@:chkSize(ib,eb,CMDifThenElse)@

	bn= BATnew(BAThtype(ib),BATttype(tb),BATcount(ib));
	@:tstBat(ifThenElse)@
	BATloopFast(ib, p, q, xx) {
		ptr h = BUNhead(ib,p);
		ptr t = BUNtail(ib,p);
		int idx = BUNindex(ib,p);

		if( *(bit*) t== bit_nil) {
			bunfastins(bn, h, &bnil);
		} else
		if( *(bit*) t ) {
			t= BUNtail(tb,BUNptr(tb,idx));
			bunfastins(bn, h, t);
		} else{
			t= BUNtail(eb,BUNptr(eb,idx));
			bunfastins(bn, h, t);
		}
	}
	BBPfix( *ret= bn->batCacheid);
	return MAL_SUCCEED;
}
str CMDifThenElseCst1(int *ret, int *iid, ptr *val,int *eid){
	BAT *ib, *eb, *bn;
	int xx;
	BUN p,q;
	ptr nilptr;
	int tpe;

	@:getBATdescriptor(ret,iid,ib,CMDifThen)@
	@:getBATdescriptor(ret,eid,eb,CMDifThen)@
	@:chkSize(ib,eb,CMDifThenElse)@

	tpe= BATttype(eb);
	nilptr= ATOMnilptr(tpe);
	bn= BATnew(BAThtype(ib),tpe,BATcount(ib));
	@:tstBat(CMDifThenElseCst1)@
	BATloopFast(ib, p, q, xx) {
		ptr h = BUNhead(ib,p);
		ptr t = BUNtail(ib,p);
		int idx = BUNindex(ib,p);

		if( ATOMcmp(tpe, t, nilptr)==0 ){
			bunfastins(bn, h, t);
		} else
		if( *(bit*) t ) {
			bunfastins(bn, h, val);
		} else{
			t= BUNtail(eb,BUNptr(eb,idx));
			bunfastins(bn, h, t);
		}
	}
	BBPfix( *ret= bn->batCacheid);
	return MAL_SUCCEED;
}
str CMDifThenElseCst2(int *ret, int *iid, int *tid,ptr *val){
	BAT *ib, *tb, *bn;
	int xx;
	BUN p,q;
	ptr nilptr;
	int tpe;

	@:getBATdescriptor(ret,iid,ib,CMDifThen)@
	@:getBATdescriptor(ret,tid,tb,CMDifThen)@
	@:chkSize(ib,tb,CMDifThenElse)@
 
	tpe= BATttype(tb);
	nilptr= ATOMnilptr(tpe);
	bn= BATnew(BAThtype(ib),tpe,BATcount(ib));
	@:tstBat(CMDifThenElseCst2)@
	BATloopFast(ib, p, q, xx) {
		ptr h = BUNhead(ib,p);
		ptr t = BUNtail(ib,p);
		int idx = BUNindex(ib,p);

		if( ATOMcmp(tpe, t, nilptr)==0 ){
			bunfastins(bn, h, t);
		} else
		if( *(bit*) t ) {
			t= BUNtail(tb,BUNptr(tb,idx));
			bunfastins(bn, h, t);
		} else{
			bunfastins(bn, h, val);
		}
	}
	BBPfix( *ret= bn->batCacheid);
	return MAL_SUCCEED;
}

@+ Test environment
Here follows a sample of the code that can easily
be derived from MAL.

int catchError(str msg){ return 0;}

BAT *cmd000(BAT *A2, BAT *A3){
/* dump the symbol table */
	BAT *rB=0;
	BUN rBq;
	lng mloop=0;
	lng h=0,t=0;
	lng B2=0;
	lng B3=0;
	lng cr=0;
	int limit=0;
	str exception=0;

/* ensure access, handled by MAL layer as well */
	BBPfix(A2->batCacheid);
	BBPfix(A3->batCacheid);

/*d:= new(lng,lng); */
	rB= BATnew(TYPE_lng,TYPE_lng,BATcount(A2));
/* barrier mloop:= bunStream(b,h,t); */
Lmloop:
	/* expanded code for bunStream  init should be factored out of loop*/
	limit= BUNindex(A2, BUNlast(A2));
	if(mloop >=limit) {mloop=0; goto Emloop;}
	rBq= BUNptr(A2,mloop);
	h= *(lng*) BUNhead(A2,rBq);
	t= *(lng*) BUNtail(A2,rBq);
	mloop++;

/* B2:= find(b,h); */
	B2= *(lng*) BUNfnd(A2,&h);
/* B3:= find(c,h); */
	B3= *(lng*) BUNfnd(A3,&h);
/* cr:= B2+B3; */
	if( B2== lng_nil || B3== lng_nil) 
		cr= lng_nil;
	else	cr= B2+B2;
/* insert(d,h,cr);*/
	BUNfastins(rB,&h,&cr);
/* catch GDKerror; */
CGDKerror:;
	if( !catchError("GDKerror")) goto EGDKerror;
/* leave mloop; */
	goto Emloop;
/* end GDKerror */
EGDKerror:;
/* redo Lmloop; */
	goto Lmloop;
/* end mloop */
Emloop:;
/* garbage collect and adjust referenceing */
	BBPunfix(A2->batCacheid);
	BBPunfix(A3->batCacheid);
	return rB;
}

str CMD000(int *ret, int *l, int *r){
	BAT *left, *right, *bn;
	lng t0,t1;
printf("calling CMD000\n");
	if( BBPcheck(*l,"CMD000")==0) return GDK_FAIL;
	left= (BAT*) BBPgetdesc(*l);
	if( left== NULL){ *ret= 0; return GDK_FAIL; }
        if( *l <0){ /* BAT reverse */ left = BATmirror(left); }

	if( BBPcheck(*r,"CMD000")==0) return GDK_FAIL;
	right= (BAT*) BBPgetdesc(*r);
	if( right== NULL){ *ret= 0; return GDK_FAIL; }
        if( *r <0){ /* BAT reverse */ right = BATmirror(right); }
	
printf("name %s %s\n",left->batId,right->batId);
	t0= GDKusec();
	cmd000(left,right);
	t1= GDKusec();
	printf("execution time for CMD000 %d\n",t1-t0);
	return MAL_SUCCEED;
}
