@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2003 CWI.
@' All Rights Reserved.
@'
@' Contributor(s):
@'              Martin Kersten <Martin.Kersten@cwi.nl>
@'              Peter Boncz <Peter.Boncz@cwi.nl>
@'              Niels Nes <Niels.Nes@cwi.nl>
@'              Stefan Manegold  <Stefan.Manegold@cwi.nl>

@f system
@t System Information BATs and basic IO
@a M.L. Kersten, P. Boncz, N.Nes
@v 2.0
@* Introduction
This document introduces a series of bats that provide access
to information stored within the Monet Version 5 internal data structures.
In all cases, the pseudo BAT operation returns a transient BAT that
should be garbage collected after being used.

The main performance drain would be to use a pseudo BAT directly to
successively access it components. This can be avoided by first assigning
the pseudo BAT to a variable.

In addition, this module contains the primitives for printing on the
client stdout channel. Additional file-directed IO is maintained in
the io module.

@* Module Definition 
The system primitives have been taken over from version 4.
@mal
module system;

@-
The properties of the Client record can be obtained for inspection.
Only the listing property can be dynamically set.
@mal
command set_client_prompt(s:str):void= SYSsetPrompt
	comment "Change the prompt for the current user.";
command set_client_listing(b:bit):void= SYSsetListing
	comment "Turn on/off echoing of MAL instructions";
command quit():void= SYSquit
	comment "Terminate the server"'
command exit():void= SYSquit
	comment "Terminate the server"'

command kill(n:int):void =SYSkill
	comment "remove a client instance";
command mem_cursize() : lng = SYSgetmem_cursize
 	comment "the amount of physical swapspace in KB that is currently in use";
command mem_maxsize() : lng = SYSgetmem_maxsize
 	comment "the maximum usable amount of physical swapspace in KB (target only)";
command mem_maxsize(v:lng) : void = set_mem_maxsize
 	comment "set the maximum usable amount of physical swapspace in KB";
command vm_cursize() : lng = SYSgetvm_cursize
 	comment "the amount of logical VM space in KB that is currently in use";
command vm_maxsize() : lng = SYSgetvm_maxsize
 	comment "the maximum usable amount of logical VM space in KB (target only)";
command vm_maxsize(v:lng) : void = SYSsetvm_maxsize
 	comment "set the maximum usable amount of physical swapspace in KB";
@- Printing 
The routines that inspect the runtime setting are moved out of this area.

@mal
command printf(format:str,val:bit):int = SYSprint_formatted_bit;
command printf(format:str,val:chr):int = SYSprint_formatted_chr;
command printf(format:str,val:int):int = SYSprint_formatted_int;
command printf(format:str,val:sht):int = SYSprint_formatted_sht;
command printf(format:str,val:oid):int = SYSprint_oid;
command printf(format:str,val:lng):int = SYSprint_formatted_lng;
command printf(format:str,val:flt):int = SYSprint_formatted_flt;
command printf(format:str,val:dbl):int = SYSprint_formatted_dbl;
command printf(val:str):int = SYSprint_str;
command printf(format:str,val:str):int = SYSprint_formatted_str;
@{
@* Implementation Code
@h
/*
 * The contents of this file are subject to the Monet Public
 * License Version 1.1 (the "License"); you may not use this file
 * except in compliance with the License. You may obtain a copy of
 * the License at 
 * http://www.monetsolutions.com/Download/Licensing/MonetPL-1.1.html
 * 
 * Software distributed under the License is distributed on an "AS
 * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
 * implied. See the License for the specific language governing
 * rights and limitations under the License.
 * 
 * The Original Code is the Monet Database System.
 * 
 * The Initial Developer of the Original Code is CWI.
 * Portions created by CWI are Copyright (C) 1997-2001 CWI.  
 * All Rights Reserved.
 * 
 * Contributor(s): Martin Kersten <Martin.Kersten@cwi.nl>
 *		   Peter Boncz <Peter.Boncz@cwi.nl>
 *		   Niels Nes <Niels.Nes@cwi.nl>
 *		   Stefan Manegold  <Stefan.Manegold@cwi.nl>
 */

#ifndef _SYS_H_
#define _SYS_H_
#endif
@c
#include <stdarg.h>
#include <time.h>
#include "gdk.h"
#include "mal_stack.h"
#include "mal_resolve.h"
#include "mal_squeezer.h"
#include "mal_client.h"

#ifdef HAVE_SYS_TIMES_H
# include <sys/times.h>
#include <stream.h>
#endif
 
str SYSsetListing(int *ret, int *flag) {
	Client c;
	c= getClient();
	c->listing = *flag >0;
	return MAL_SUCCEED;
}
str SYSsetPrompt(int *ret, str *prompt) {
	Client c;
	c= getClient();
	c->prompt = GDKstrdup(*prompt);
	c->promptlength = strlen(c->prompt);
	return MAL_SUCCEED;
}
str SYSkill(int *ret, int *k) {
	Client c;
	c= getClient();
	return throwMessage("system.kill", "not yet implemented");
}
str SYSquit(int *ret) {
	Client c;
	c= getClient();
	c->fdin->close(c->fdin);
	c->fdin= NULL;
	c->mode = FINISHING;
	return MAL_SUCCEED;
}

str SYSgetmem_cursize(lng *num) {
	*num = GDKmem_cursize();
	return MAL_SUCCEED;
}
str SYSgetmem_maxsize(lng *num) {
	*num = GDKmem_maxsize();
	return MAL_SUCCEED;
}
str set_mem_maxsize(lng *num) {
	GDK_mem_maxsize = *num;
	return MAL_SUCCEED;
}
str SYSgetvm_cursize(lng *num) {
	*num = GDKvm_cursize();
	return MAL_SUCCEED;
}
str SYSgetvm_maxsize(lng *num) {
	*num = GDKvm_maxsize();
	return MAL_SUCCEED;
}
str SYSsetvm_maxsize(lng *num) {
	GDK_vm_maxsize= *num;
	return MAL_SUCCEED;
}

@-
The format string is scrutinized using VALsprintf in the GDK library
to avoid that passing a wrong argument (e.g. NULL pointer) kills the server.
The generic printf function is rather expensive. Ideally it should be
replaced by a squeezer into a type-specific function calls.
@-
Formatted print statements are to be broken down into its constituents.
This avoids repeated type checking in most cases.

@= escaped
	switch(*c){
	case 'n': *ret =  stream_printf(fd,"\n");break;
	case 't': *ret =  stream_printf(fd,"\t");break;
	case 'r': *ret =  stream_printf(fd,"\r");break;
	case '\\': *ret =  stream_printf(fd,"\\");break;
	default : *ret = stream_printf(fd,"\\");stream_printf(fd,"%c",*c);
	}
@c
str SYSprint_str(int *ret, str *s){
	stream *fd = GDKout; 
	str c;
	if( strNil(*s)) stream_printf(fd,"nil");
	else {
		for(c= *s;*c; c++){
			if( *c=='\\'){
				c++;
				@:escaped@
			} else stream_printf(fd,"%c",*c);
		}
	}
	return MAL_SUCCEED;
}
int formatMarker(str format){
	int i=0;
	str t=format;
	while( (t=strchr(t,'%')) != NULL){
		t++;
		i++;
	}
	return i;
}
@-
Printing format values is limited to a single element each.
This to simplify error handling
@= formatConversion
	for(c= format;*c; c++){
		if( *c=='\\'){
			c++;
			@:escaped@
		} else 
		if( *c== '%'){
			char newformat[1024];
			int i=0;

			if(*(c+1)=='%'){ 
				stream_printf(fd,"%c",*c);
				c++; continue;
			}
			while(*c != '@1' && *c && i<1024)
				 newformat[i++]= *c++;
			newformat[i++]='@1';
			newformat[i]=0;
			if(*c!= '@1') 
			return throwMessage("system.print", " format limitation");
			else  stream_printf(fd,newformat,@2);
		} else stream_printf(fd,"%c",*c);
	}
@-

@= printFormatted
str SYSprint_formatted_@1(int *ret, ptr fmt, @1 *s){
	stream *fd = getClient()->fdout;
	char *format;
	str c;
	/* TODO: check format properly !!! including sizes */
	format= *(str *)fmt;
	if( format== NULL) 
		return throwMessage("system.print", "format missing");
	if( formatMarker(format)!=1) 
		return throwMessage("system.print", "too many %%");

	if( *s == @1_nil) return SYSprint_formatted_nil(fd,* (str*) fmt, ret);
	@:formatConversion(@2,*s)@
	return MAL_SUCCEED;
}
@-
String nil testing is slightly different.
@c
str SYSprint_formatted_nil(stream *fd, str format, int *ret){
	str c;
	for(c= format;*c; c++){
		if( *c=='\\'){
			c++;
			@:escaped@
		} else 
		if( *c== '%'){
			char newformat[1024];
			int i=0;

			if(*(c+1)=='%'){ 
				stream_printf(fd,"%c",*c);
				c++; continue;
			}
			while( !isalpha(*c) && *c && i<1024)
				 newformat[i++]= *c++;
			newformat[i++]='s';
			newformat[i]=0;
			stream_printf(fd,newformat,"nil");
		} else stream_printf(fd,"%c",*c);
	}
	return MAL_SUCCEED;
}
str SYSprint_formatted_str(int *ret, ptr fmt, str *s){
	stream *fd = getClient()->fdout;
	char *format;
	str c;
	/* TODO: check format properly !!! including sizes */
	format= *(str *)fmt;
	if( format== NULL) 
		return throwMessage("system.print", "format missing");
	if( formatMarker(format)!=1) 
		return throwMessage("system.print", "too many %%");

	if( strNil( *s)) return SYSprint_formatted_nil(fd,* (str*) fmt, ret);
	@:formatConversion(s,*s)@
	return MAL_SUCCEED;
}
str SYSprint_oid(int *ret, ptr fmt, oid *s){
	stream *fd = getClient()->fdout;
	char *format;
	str msg,c;
	int len =50;
	format= *(str *)fmt;

	if( format== NULL) 
		return throwMessage("system.print", "format missing");
	if( formatMarker(format)!=1) 
		return throwMessage("system.print", "too many %%");

	if( *s == oid_nil) msg = GDKstrdup("nil");
	else { msg = (str) GDKmalloc(len); OIDtoStr(&msg,&len,s);}
	@:formatConversion(s,msg)@
	GDKfree(msg);
	if(*ret == EOF)
		return throwMessage("system.print", "end-of-file error");
	return MAL_SUCCEED;
}
str SYSprint_formatted_bit(int *ret, ptr fmt, bit *s){
	stream *fd = getClient()->fdout;
	char *format;
	str msg;
	str c;
	/* TODO: check format properly !!! including sizes */
	format= *(str *)fmt;
	if( format== NULL) 
		return throwMessage("system.print", "format missing");
	if( formatMarker(format)!=1) 
		return throwMessage("system.print", "too many %%");

	if( *s == bit_nil) msg = "nil";
	else if( *s ) msg="true";
	else 	msg="false";
	@:formatConversion(s,msg)@
	if(*ret == EOF)
		return throwMessage("system.print", "end-of-file error");
	return MAL_SUCCEED;
}

 	@:printFormatted(chr,c)@
 	@:printFormatted(sht,d)@
 	@:printFormatted(int,d)@
 	@:printFormatted(lng,d)@
 	@:printFormatted(flt,f)@
 	@:printFormatted(dbl,f)@

str print_mem_map() {
        MT_alloc_print();
        return MAL_SUCCEED;
}
@-
If we don;t have an implementation at hand, we simple generate
an error message.
@c
str SYStobedefined(){
	return throwMessage("system.tobedefined", "function not (yet) implemented");
}
@
@}
