@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2003 CWI.
@' All Rights Reserved.
@'
@' Contributor(s):
@'              Martin Kersten <Martin.Kersten@cwi.nl>
@'              Peter Boncz <Peter.Boncz@cwi.nl>
@'              Niels Nes <Niels.Nes@cwi.nl>
@'              Stefan Manegold  <Stefan.Manegold@cwi.nl>

@f system
@t System Information BATs and basic IO
@a M.L. Kersten, P. Boncz, N.Nes
@v 2.0
@* Introduction
This document introduces a series of bats that provide access
to information stored within the Monet Version 5 internal data structures.
In all cases, the pseudo BAT operation returns a transient BAT that
should be garbage collected after being used.

The main performance drain would be to use a pseudo BAT directly to
successively access it components. This can be avoided by first assigning
the pseudo BAT to a variable.

In addition, this module contains the primitives for printing on the
client stdout channel. Additional file-directed IO is maintained in
the io module.

@* Module Definition 
The system primitives have been taken over from version 4.
@mal
module system;

@-
The properties of the Client record can be obtained for inspection.
Only the listing property can be dynamically set.
@mal
command cwd(s:str):str= SYSsetCwd
        comment "Return the current working directory. Set it to a new one.";
command quit():void= SYSquit
	comment "Terminate the server"'
command exit():void= SYSquit
	comment "Terminate the server"'

@- Kernel Performance Statistics
The BATs created below are rather expensive views over the
GDK kernel. They have been retained for backward compatibility.

@mal
command cpuStatistics() : bat[str,int] = SYScpuStatistics
	comment "Global cpu usage information";
command memStatistics(): bat[str,int] = SYSmemStatistics
	comment "Global memory usage information";
command ioStatistics(): bat[str,int] = SYSioStatistics
	comment "Global IO activity information";
command bbpStatistics(): bat[str,int] = SYSbbpStatistics
	comment "Global BBP usage information";
command memMap() : void = SYSmemMap
        comment "print a map of all memory that is in use";
@-
@T
For each 64KB block in the first 3GB of the virtual memory {\tt mem_printmap()} prints a character:
\begin{verbatim}
0-9 - thread stack space of thread <num>
B - in use for a large BAT heap (i.e. anonymous virtual memory).
b - free (last usage was B)
S - in use for a malloc block
s - free (last usage was S)
P - in use for the BBP array (i.e. anonymous virtual memory)
p - free (last usage was P)
M - in use as memory mapped region
m - free (last usage was M)
C - in use as MIL context buffer (i.e. anonymous virtual memory)
c - free (last usage was M)
\end{verbatim}
On Linux, the malloc library appears to be using anonymous virtual memory, which goes unetected.
If you want to see all your memory in the map, lower the gdk\_mmap threshold in monet.conf to a
low value (say 64KB).
@-
@mal
command vmUsage(minsize:lng) : bat[str,lng] = SYSvm_usage
        comment "Get a split-up of how much virtual memory blocks are in use.";
command memUsage(minsize:lng) : bat[str,lng] = SYSmem_usage
        comment "Get a split-up of how much memory blocks are in use.";
@-
@T
Some explanation of what mem_usage() and vm_usage() display:
\begin{verbatim}
> mem_usage.print;
#------------------------------#
# BAT:                 tmp_42  #
# (str)                (lng)   #
#------------------------------#
[ "buns/car_category",  400012 ] 100.000 string offsets
[ "buns/car_town",      400012 ] idem
[ "buns/car_class",     400012 ] idem
[ "tail/car_category",  266244 ] string tail heap
[ "tail/car_town",      266244 ] idem
[ "tail/car_class",     266244 ] idem
[ "_tot/buns",         1322996 ] the three bun heaps
[ "_tot/tail",          967762 ] the three tail heaps
[ "_tot/head",           70984 ] negligable
[ "_tot/bbp",            98866 ] BBP metadata structure
[ "_tot/mil",           102400 ] MIL interpreter stack space
[ "_tot/found",        2590144 ] buns+head+tail+bbp+mil
[ "_tot/malloc_heap",  2956048 ] in malloc heap
[ "_tot/malloc",       2956048 ] total consumed via malloc
[ "_tot/valloc",        201266 ] total consumed via virtualalloc
[ "_tot/mem",          3157314 ] total RAM+swap-file consumption

>
> vm_usage.print;
#------------------------------#
# BAT:               tmp_42    #
# (str)              (lng)     #
#------------------------------#
[ "_tot/bbp",        50331648  ] 50MB reserved (100KB claimed)
[ "_tot/mil",        16777216  ] 16MB reserved (100KB claimed)
[ "_tot/found",      67108864  ] bbp+mil
[ "_tot/vm",         71244560  ] total address space consumption
>
\end{verbatim}
@- MAL runtime status 
@mal
command gdkEnv( ): bat[str,str] = SYSgdkEnv
	comment "Pseudo bat to map thread to name";
command gdkThread( ): bat[int,str] = SYSgdkThread
	comment "Pseudo bat to map thread to name";

command mem_cursize() : lng = SYSgetmem_cursize
 	comment "the amount of physical swapspace in KB that is currently in use";
command mem_maxsize() : lng = SYSgetmem_maxsize
 	comment "the maximum usable amount of physical swapspace in KB (target only)";
command mem_maxsize(v:lng) : void = set_mem_maxsize
 	comment "set the maximum usable amount of physical swapspace in KB";
command vm_cursize() : lng = SYSgetvm_cursize
 	comment "the amount of logical VM space in KB that is currently in use";
command vm_maxsize() : lng = SYSgetvm_maxsize
 	comment "the maximum usable amount of logical VM space in KB (target only)";
command vm_maxsize(v:lng) : void = SYSsetvm_maxsize
 	comment "set the maximum usable amount of physical swapspace in KB";
@- Printing 
The routines that inspect the runtime setting are moved out of this area.

@mal
command printf(format:str,val:bit):int = SYSprint_formatted_bit;
command printf(format:str,val:chr):int = SYSprint_formatted_chr;
command printf(format:str,val:int):int = SYSprint_formatted_int;
command printf(format:str,val:sht):int = SYSprint_formatted_sht;
command printf(format:str,val:oid):int = SYSprint_oid;
command printf(format:str,val:lng):int = SYSprint_formatted_lng;
command printf(format:str,val:flt):int = SYSprint_formatted_flt;
command printf(format:str,val:dbl):int = SYSprint_formatted_dbl;
command printf(val:str):int = SYSprint_str;
command printf(format:str,val:str):int = SYSprint_formatted_str;
@{
@* Implementation Code
@h
#ifndef _SYS_H_
#define _SYS_H_
#endif
@-

@= Pseudo
        if (BBPindex("view_@1_@2") <= 0)
                BATname(b, "@2");
        BATroles(b,"@1","@2");
        BATmode(b,TRANSIENT);
        BATfakeCommit(b);
        *ret = b->batCacheid;
@c
#include <stdarg.h>
#include <time.h>
#include "gdk.h"
#include "mal_stack.h"
#include "mal_resolve.h"
#include "mal_function.h"
#include "mal_client.h"

#ifdef HAVE_SYS_TIMES_H
# include <sys/times.h>
#include <stream.h>
#endif
 
str SYSquit(int *ret) {
	Client c= getClient();
	c->mode = FINISHING;
	return MAL_SUCCEED;
}

str SYSgetmem_cursize(lng *num) {
	*num = GDKmem_cursize();
	return MAL_SUCCEED;
}
str SYSgetmem_maxsize(lng *num) {
	*num = GDKmem_maxsize();
	return MAL_SUCCEED;
}
str set_mem_maxsize(lng *num) {
	GDK_mem_maxsize = *num;
	return MAL_SUCCEED;
}
str SYSgetvm_cursize(lng *num) {
	*num = GDKvm_cursize();
	return MAL_SUCCEED;
}
str SYSgetvm_maxsize(lng *num) {
	*num = GDKvm_maxsize();
	return MAL_SUCCEED;
}
str SYSsetvm_maxsize(lng *num) {
	GDK_vm_maxsize= *num;
	return MAL_SUCCEED;
}
str SYSsetCwd(str *ret, str *fnme){
        Client c= getClient();
        *ret = c->cwd;
        c->cwd= GDKstrdup(*fnme);
        return MAL_SUCCEED;
}

@-
The format string is scrutinized using VALsprintf in the GDK library
to avoid that passing a wrong argument (e.g. NULL pointer) kills the server.
The generic printf function is rather expensive. Ideally it should be
replaced by a squeezer into a type-specific function calls.
@-
Formatted print statements are to be broken down into its constituents.
This avoids repeated type checking in most cases.

@= escaped
	switch(*c){
	case 'n': *ret =  stream_printf(fd,"\n");break;
	case 't': *ret =  stream_printf(fd,"\t");break;
	case 'r': *ret =  stream_printf(fd,"\r");break;
	case '\\': *ret =  stream_printf(fd,"\\");break;
	default : *ret = stream_printf(fd,"\\");stream_printf(fd,"%c",*c);
	}
@c
str SYSprint_str(int *ret, str *s){
	stream *fd = GDKout; 
	str c;
	if( strNil(*s)) stream_printf(fd,"nil");
	else {
		for(c= *s;*c; c++){
			if( *c=='\\'){
				c++;
				@:escaped@
			} else stream_printf(fd,"%c",*c);
		}
	}
	return MAL_SUCCEED;
}
int formatMarker(str format){
	int i=0;
	str t=format;
	while( (t=strchr(t,'%')) != NULL){
		t++;
		i++;
	}
	return i;
}
@-
Printing format values is limited to a single element each.
This to simplify error handling
@= formatConversion
	for(c= format;*c; c++){
		if( *c=='\\'){
			c++;
			@:escaped@
		} else 
		if( *c== '%'){
			char newformat[1024];
			int i=0;

			if(*(c+1)=='%'){ 
				stream_printf(fd,"%c",*c);
				c++; continue;
			}
			while(*c != '@1' && *c && i<1024)
				 newformat[i++]= *c++;
			newformat[i++]='@1';
			newformat[i]=0;
			if(*c!= '@1') 
			return throwMessage("system.print", " format limitation");
			else  stream_printf(fd,newformat,@2);
		} else stream_printf(fd,"%c",*c);
	}
@-

@= printFormatted
str SYSprint_formatted_@1(int *ret, ptr fmt, @1 *s){
	stream *fd = getClient()->fdout;
	char *format;
	str c;
	/* TODO: check format properly !!! including sizes */
	format= *(str *)fmt;
	if( format== NULL) 
		return throwMessage("system.print", "format missing");
	if( formatMarker(format)!=1) 
		return throwMessage("system.print", "too many %%");

	if( *s == @1_nil) return SYSprint_formatted_nil(fd,* (str*) fmt, ret);
	@:formatConversion(@2,*s)@
	return MAL_SUCCEED;
}
@-
String nil testing is slightly different.
@c
str SYSprint_formatted_nil(stream *fd, str format, int *ret){
	str c;
	for(c= format;*c; c++){
		if( *c=='\\'){
			c++;
			@:escaped@
		} else 
		if( *c== '%'){
			char newformat[1024];
			int i=0;

			if(*(c+1)=='%'){ 
				stream_printf(fd,"%c",*c);
				c++; continue;
			}
			while( !isalpha(*c) && *c && i<1024)
				 newformat[i++]= *c++;
			newformat[i++]='s';
			newformat[i]=0;
			stream_printf(fd,newformat,"nil");
		} else stream_printf(fd,"%c",*c);
	}
	return MAL_SUCCEED;
}
str SYSprint_formatted_str(int *ret, ptr fmt, str *s){
	stream *fd = getClient()->fdout;
	char *format;
	str c;
	/* TODO: check format properly !!! including sizes */
	format= *(str *)fmt;
	if( format== NULL) 
		return throwMessage("system.print", "format missing");
	if( formatMarker(format)!=1) 
		return throwMessage("system.print", "too many %%");

	if( strNil( *s)) return SYSprint_formatted_nil(fd,* (str*) fmt, ret);
	@:formatConversion(s,*s)@
	return MAL_SUCCEED;
}
str SYSprint_oid(int *ret, ptr fmt, oid *s){
	stream *fd = getClient()->fdout;
	char *format;
	str msg,c;
	int len =50;
	format= *(str *)fmt;

	if( format== NULL) 
		return throwMessage("system.print", "format missing");
	if( formatMarker(format)!=1) 
		return throwMessage("system.print", "too many %%");

	if( *s == oid_nil) msg = GDKstrdup("nil");
	else { msg = (str) GDKmalloc(len); OIDtoStr(&msg,&len,s);}
	@:formatConversion(s,msg)@
	GDKfree(msg);
	if(*ret == EOF)
		return throwMessage("system.print", "end-of-file error");
	return MAL_SUCCEED;
}
str SYSprint_formatted_bit(int *ret, ptr fmt, bit *s){
	stream *fd = getClient()->fdout;
	char *format;
	str msg;
	str c;
	/* TODO: check format properly !!! including sizes */
	format= *(str *)fmt;
	if( format== NULL) 
		return throwMessage("system.print", "format missing");
	if( formatMarker(format)!=1) 
		return throwMessage("system.print", "too many %%");

	if( *s == bit_nil) msg = "nil";
	else if( *s ) msg="true";
	else 	msg="false";
	@:formatConversion(s,msg)@
	if(*ret == EOF)
		return throwMessage("system.print", "end-of-file error");
	return MAL_SUCCEED;
}

 	@:printFormatted(chr,c)@
 	@:printFormatted(sht,d)@
 	@:printFormatted(int,d)@
 	@:printFormatted(lng,d)@
 	@:printFormatted(flt,f)@
 	@:printFormatted(dbl,f)@

str memMap() {
        MT_alloc_print();
        return MAL_SUCCEED;
}
@-
If we don;t have an implementation at hand, we simple generate
an error message.
@c
str SYStobedefined(){
	return throwMessage("system.tobedefined", "function not (yet) implemented");
}
@
@c
static int clk = 0;
static struct tms state;

str SYScpuStatistics(int *ret) {
	int     i;
	struct tms newst;
	BAT *b;
 
 
	b = BATnew(TYPE_str, TYPE_int, 32);
	if ( b == 0) return throwMessage("catalog.gdkCpu", "failed to create BAT");
	if( clk == 0) {
		clk= time(0);
		times(&state);
	}
	times(&newst);
	/* store counters, ignore errors */
	i = time(0) - clk;
	b = BUNins(b, "elapsed", &i);
	i= newst.tms_utime *1000/HZ ;
	b = BUNins(b, "user", &i);
	i= (newst.tms_utime - state.tms_utime)*1000/HZ;
	b = BUNins(b, "elapuser", &i);
	i = newst.tms_stime *1000/HZ;
	b = BUNins(b, "system", &i);
	i = (newst.tms_stime - state.tms_stime)*1000/HZ;
	b = BUNins(b, "elapsystem", &i);

	state = newst; 
	@:Pseudo(gdk,cpu)@
	return MAL_SUCCEED;
}
@-
Same observations as to SYScpuStatistics()
@c
static void *memincr=NULL;
str SYSmemStatistics(int *ret) {
	struct mallinfo m;
	BAT *b;
	int i;
	m = MT_mallinfo();
 
	b = BATnew(TYPE_str, TYPE_int, 32);
	if ( b == 0) return throwMessage("catalog.memStatistics", "failed to create BAT");

	/* store counters, ignore errors */
	if (memincr == NULL) {
		memincr = (char*)sbrk(0);
	}
	i= ((char*) sbrk(0) -  (char*) memincr);
 
	memincr = (char*) sbrk(0);
        b = BUNins(b, "memincr", &i);
        i = m.arena; b = BUNins(b, "arena", &i);
        i = m.ordblks; b = BUNins(b, "ordblks", &i);
        i = m.smblks; b = BUNins(b, "smblks", &i);
        i = m.hblkhd; b = BUNins(b, "hblkhd", &i);
        i = m.hblks; b = BUNins(b, "hblks", &i);
        i = m.usmblks; b = BUNins(b, "usmblks", &i);
        i = m.fsmblks; b = BUNins(b, "fsmblks", &i);
        i = m.uordblks; b = BUNins(b, "uordblks", &i);
        i = m.fordblks; b = BUNins(b, "fordblks", &i);
	@:Pseudo(gdk,mem)@
	return MAL_SUCCEED;
}
@= heap
sz = HEAP@1size(@2);
if (sz > *minsize) {
	sprintf(buf, "@3/%s", s); 
	BUNins(bn, buf, &sz);
} @3 += sz; tot += sz;
@c

str SYSmem_usage(int *ret, lng *minsize) {
	lng buns=0, hhsh=0, thsh=0, hind=0, tind=0, head=0, tail=0, hacc=0, tacc=0, tot=0, n=0, sz;
	BAT *bn = BATnew(TYPE_str, TYPE_lng, 2*BBPsize);
	char buf[1024];
	bat i;

	BBPlock("SYSmem_usage");
	for(i=1; i <BBPsize; i++) { 
		BAT *b = BBP_cache(i);
		str s = BBP_logical(i);
		if (s == NULL) {
			continue;
		}
		sz = 0;
		if (BBP[i].cache)  sz += sizeof(BATstore);
		if (BBP[i].nme[0]) n += strLen(BBP[i].nme[0]);
		if (BBP[i].nme[1]) n += strLen(BBP[i].nme[1]);
		if (BBP[i].path) n += strLen(BBP[i].path);
		if (b) sz += sizeof(BAT); /* mirror */
			
		if (sz > *minsize) {
			sprintf(buf, "desc/%s", s); 
			BUNins(bn, buf, &sz);
		} tot += (lng) sz;

		if (b == NULL || VIEWparent(b)) {
			continue;
		}
		@:heap(mem,b->batBuns,buns)@
		@:heap(mem,b->hhash_heap,hhsh)@
		@:heap(mem,b->thash_heap,thsh)@
		@:heap(mem,b->hidx_heap,hind)@
		@:heap(mem,b->tidx_heap,tind)@
		@:heap(mem,&b->hheap,head)@
		@:heap(mem,&b->theap,tail)@
		@:heap(mem,&b->haccelerator,hacc)@
		@:heap(mem,&b->taccelerator,tacc)@
	} 
	/* totals per category */
	if (buns) BUNins(bn, "_tot/buns", &buns);
	if (head) BUNins(bn, "_tot/head", &head);
	if (tail) BUNins(bn, "_tot/tail", &tail);
	if (hhsh) BUNins(bn, "_tot/hhsh", &hhsh);
	if (thsh) BUNins(bn, "_tot/thsh", &thsh);
	if (hind) BUNins(bn, "_tot/hind", &hind);
	if (tind) BUNins(bn, "_tot/tind", &tind);
	if (hacc) BUNins(bn, "_tot/hacc", &hacc);
	if (tacc) BUNins(bn, "_tot/tacc", &tacc);

	/* special area 1: BBP rec */
	sz = BBPlimit*sizeof(BBPrec) + n;
	if (sz) BUNins(bn, "_tot/bbp", &sz);
	tot += sz;

/* special area 2: monet context records 
	DEPRICATED
	sz = monet_cntxtmax*sizeof(CntxtRec);
	if (sz) BUNins(bn, "_tot/mil", &sz);
*/
	tot += sz;
	if (tot) BUNins(bn, "_tot/found", &tot);
	sz = GDKmem_heapsize();
	if (sz) BUNins(bn, "_tot/sbrk", &sz);
/*	compilation errors !
	if (GDK_mem_cursize) BUNins(bn, "_tot/valloc", &GDK_mem_cursize);

*/
	sz = GDKmem_heapinuse();
	if (sz) BUNins(bn, "_tot/malloc", &sz);
	sz = sz + GDK_mem_cursize - tot;
	if (sz) BUNins(bn, "_tot/malloc_unknown", &sz);
	sz = GDKmem_cursize();
	if (sz) BUNins(bn, "_tot/all", &sz);
	BBPunlock("SYSmem_usage");

	*ret = bn->batCacheid;
	return MAL_SUCCEED;
}

str SYSmemMap() {
        MT_alloc_print();
        return MAL_SUCCEED;
}


str SYSvm_usage(int *ret, lng *minsize) {
	lng buns=0, hhsh=0, thsh=0, hind=0, tind=0, head=0, tail=0, hacc=0, tacc=0, tot=0, sz;
	BAT *bn = BATnew(TYPE_str, TYPE_lng, 2*BBPsize);
	char buf[1024];
	bat i;

	BBPlock("SYSvm_usage");
	for(i=1; i <BBPsize; i++) {
		BAT *b = BBP_cache(i);
		str s = BBP_logical(i);
		if (s == NULL || b == NULL || VIEWparent(b)) {
			continue;
		}
		@:heap(vm,b->batBuns,buns)@
		@:heap(vm,b->hhash_heap,hhsh)@
		@:heap(vm,b->thash_heap,thsh)@
		@:heap(vm,b->hidx_heap,hind)@
		@:heap(vm,b->tidx_heap,tind)@
		@:heap(vm,&b->hheap,head)@
		@:heap(vm,&b->theap,tail)@
		@:heap(vm,&b->haccelerator,hacc)@
		@:heap(vm,&b->taccelerator,tacc)@
	} 
	/* totals per category */
	if (buns) BUNins(bn, "_tot/buns", &buns);
	if (head) BUNins(bn, "_tot/head", &head);
	if (tail) BUNins(bn, "_tot/tail", &tail);
	if (hhsh) BUNins(bn, "_tot/hhsh", &hhsh);
	if (thsh) BUNins(bn, "_tot/thsh", &thsh);
	if (hind) BUNins(bn, "_tot/hind", &hind);
	if (tind) BUNins(bn, "_tot/tind", &tind);
	if (hacc) BUNins(bn, "_tot/hacc", &hacc);
	if (tacc) BUNins(bn, "_tot/tacc", &tacc);

	/* special area 1: BBP rec */
	sz = BBPmaxsize*sizeof(BBPrec);
	if (sz) BUNins(bn, "_tot/bbp", &sz);
	tot += sz;

	/* special area 2: monet context records  DEPRICATE
	sz = monet_cntxtlim*sizeof(CntxtRec);
	if (sz) BUNins(bn, "_tot/mil", &sz);
	tot += sz;
	if (tot) BUNins(bn, "_tot/found", &tot);
	*/

	/* look at sbkr() to determine how much we missed */
	sz = GDKvm_cursize();
	if (sz) BUNins(bn, "_tot/all", &sz);
	sz -= tot;
	tot = GDKvm_heapsize();
	if (sz) BUNins(bn, "_tot/sbrk", &tot);
	BBPunlock("SYSvm_usage");

	*ret = bn->batCacheid;
	return MAL_SUCCEED;
}

@-
Additional information on the process utilization is given by
the io command. The following information is obtained.
 
@T
\begin{tabular}{| l| l|}\hline
maxrss     &the maximum resident set size utilized (in kilobytes).\\
minflt     &the number of page faults serviced without any I/O\\
	 &activity; here I/O activity is avoided by "reclaiming" a\\
 
	 &activity; here I/O activity is avoided by "reclaiming" a\\
	 &page frame from the list of pages awaiting reallocation.\\
majflt     &the number of page faults serviced that required I/O\\
	 &activity.\\
nswap      &the number of times a process was "swapped" out of main\\
	 &memory\\
inblock    &the number of times the file system had to perform input.\\
oublock    &the number of times the file system had to perform output.\\
nvcsw      &the number of times a context switch resulted due to a\\
	 &process voluntarily giving up the processor before its\\
	 &time slice was completed (usually to await availability of\\
	 &a resource).\\
nivcsw     &the number of times a context switch resulted due to a\\
	 &higher priority process becoming runnable or because the\\
	 &current process exceeded its time slice.\\
\end{tabular}
@
The resource statistics are collected in a BAT. It can then
be queried. A default listing is produced by the command @%usagecmd@.
(which should be moved to Monet)
 
The BAT grows. It should be compacted.
@c
#ifdef HAVE_SYS_RESOURCE_H
# include <sys/resource.h>
#endif
 
str SYSioStatistics(int *ret) {
	struct rusage ru;
	int i;
	BAT *b;
 
	getrusage(RUSAGE_SELF, &ru);
	b = BATnew(TYPE_str, TYPE_int, 32);
	if (b == 0) return throwMessage("catalog.ioStatistics", "failed to create BAT");
 
	/* store counters, ignore errors */
	i = ru.ru_maxrss; BUNins(b, "maxrss", &i); 
	i = ru.ru_minflt; BUNins(b, "minflt", &i);
	i = ru.ru_majflt; BUNins(b, "majflt", &i);
	i = ru.ru_nswap; BUNins(b, "nswap", &i);
	i = ru.ru_inblock; BUNins(b, "inblock", &i);
	i = ru.ru_oublock; BUNins(b, "oublock", &i);
	i = ru.ru_nvcsw; BUNins(b, "nvcsw", &i);
	i = ru.ru_nivcsw; BUNins(b, "ninvcsw", &i);

	@:Pseudo(gdk,io)@
	return MAL_SUCCEED;
}

str SYSbbpStatistics(int *ret) {
	int 	pbat = 0;
	int	pdisk = 0;
	int	pheat = 0; 
	int	i,tmp=0,per=0; 
	BAT	*b;

	b = BATnew(TYPE_str, TYPE_int, 32);
	if (b == 0) return throwMessage("catalog.bbpStatistics", "failed to create BAT");

	for (i = 1; i < BBPsize; i++) {
		if (BBP_logical(i)) {
			pbat++; 
			if (BBP_cache(i)) {
				pheat += BBPheat(i); 
				if (BBP_cache(i)->batPersistence == PERSISTENT)
					per++;
				else tmp++;
			} else {
				pdisk++; 
			}
		}
	}
	b = BUNins(b, "bats", &pbat);
	b = BUNins(b, "tmpbats", &tmp);
	b = BUNins(b, "perbats", &per);
	b = BUNins(b, "ondisk", &pdisk);
	b = BUNins(b, "todisk", &BBPout);
	b = BUNins(b, "fromdisk", &BBPin);

	@:Pseudo(gdk,bbp)@
	return MAL_SUCCEED;
}

str SYSgdkEnv(int *ret){
	BAT *b = BATcopy(GDKenv);
	@:Pseudo(gdk,env)@
        return MAL_SUCCEED;
}

str SYSgdkThread(int *ret){       
	BAT*    b;
        int     i;

        b= BATnew(TYPE_int,TYPE_str,THREADS);
        if (b == 0) return throwMessage("catalog.gdkThread", "failed to create BAT");

        for(i=0; i < THREADS; i++)
	if( GDKthreads[i].pid) {
                BUNins(b, &GDKthreads[i].tid, GDKthreads[i].name);
	}
	@:Pseudo(gdk,thread)@
        return MAL_SUCCEED;
}
@}
