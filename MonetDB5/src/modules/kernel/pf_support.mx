@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@' 
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@' 
@' The Original Code is the Monet Database System.
@' 
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2004 CWI.
@' All Rights Reserved.
@' 
@' Contributor(s):
@' 		Martin Kersten <Martin.Kersten@cwi.nl>
@' 		Peter Boncz <Peter.Boncz@cwi.nl>
@' 		Niels Nes <Niels.Nes@cwi.nl>
@' 		Stefan Manegold  <Stefan.Manegold@cwi.nl>

@f pf_support
@a Stefan Manegold
@v 1.0
@t MIL primitives to support the XQuery front-end "Pathfinder"

@* Introduction
This modules provides new MIL primitives to support the XQuery
implementation on to of MonetDB within the "Pathfinder" project.
@
@* Module Definition 
@mal
module pf_support;

command mark_grp(b:bat[any$1,oid],
	g:bat[oid,oid])
	:bat[any$1,oid] 
address CMDmark_grp
comment "\"grouped mark\": Produces a new BAT with per group a locally unique dense
 ascending sequense of OIDs in the tail. The tail of the first BAT (b)
 identifies the group that each BUN of b belongs to. The second BAT (g)
 represents the group extend, i.e., the head is the unique list of group IDs
 from b's tail. The tail of g gives for each group the base value for the new
 OID sequence.";
@-
@= getBATdescriptor
        if( BBPcheck(*@2,"@4")==0)
                return throwMessage("bat.@4",
                        "cannot access bat @2 in bbp");
        @3= (BAT*) BBPgetdesc(*@2);
        if( @3 == NULL) { *@1 = 0;
                return throwMessage("bat.@4",
                        "cannot access descriptor @2");
        }
        /* reverse descriptor should be loaded */
        if( *@2 <0){ BBPcacheit(@3); @3= BATmirror(@3); }
@-
@* Module Implementation
@h
#ifndef PF_SUPPORT_H
#define PF_SUPPORT_H

#include "gdk.h"
#endif
@c
#include "pf_support.h"

@= mark_grp_loop3
{	BUN p, q;
	int xx;
	BATloopFast(b, p, q, xx) {
		oid n = oid_nil;
		BUN w;
		ptr v = BUNt@2(b, p);

		BUNfnd@3(w, gc, v);
		if (w) {
			oid *m = (oid*) BUNtloc(gc, w);
			if (*m != oid_nil) {
				n = (*m)++;
			}
		}
		if (n == oid_nil) {
			tsdk = 0;
		}
		bunfastins_nocheck(bn, r, BUNh@1(b, p), &n, yy); 
		r += yy; 
	}
}
@= mark_grp_loop2
	if (gc->htype==TYPE_void) {
		@:mark_grp_loop3(@1,@2,VOID)@
	} else {
		@:mark_grp_loop3(@1,@2,OID)@
	}
@= mark_grp_loop1
	if (b->ttype==TYPE_void) {
		@:mark_grp_loop2(@1,var)@
	} else {
		@:mark_grp_loop2(@1,loc)@
	}
@= mark_grp_loop
{	BUN r = BUNfirst(bn);
	int yy = BUNsize(bn);
	if (b->hvarsized) {
		@:mark_grp_loop1(var)@
	} else {
		@:mark_grp_loop1(loc)@
	}
}

@c
BAT *BATmark_grp(BAT *b, BAT *g) {
        BAT *bn, *gc;
	int tsdk;

        BATcheck(b, "BATmark_grp");
        BATcheck(g, "BATmark_grp");
	ERRORcheck((b->ttype!=TYPE_void) && (b->ttype!=TYPE_oid),
	           "BATmark_grp: tail of BAT b must be oid.\n");
	ERRORcheck((g->htype!=TYPE_void) && (g->htype!=TYPE_oid),
	           "ERRORcheck: head of BAT g must be oid.\n");
	ERRORcheck((g->ttype!=TYPE_oid),
	           "BATmark_grp: tail of BAT g must be oid.\n");

	tsdk = ((BATcount(g) == 1) || (BATcount(b) == 0));
	gc = batcopy(g, g->htype, g->ttype, TRUE);
	if (gc == NULL) return NULL;
	bn = BATnew(b->htype, TYPE_oid, BATcount(b));
	if (bn == NULL) {
		BBPreclaim(gc);
		return NULL;
	}

	@:mark_grp_loop@

	ALIGNsetH(bn,b);
	bn->hsorted = BAThordered(b);
	bn->hdense = BAThdense(b);
	BATkey(bn, (b->hkey!=0));
	bn->tsorted = (tsdk?GDK_SORTED:0);
	bn->tdense = tsdk;
	BATkey(BATmirror(bn), tsdk);

	BBPreclaim(gc);
        return bn;
bunins_failed:
	BBPreclaim(gc);
	BBPreclaim(bn);
	return NULL;
}

@- Wrappers
The wrappers to re-use Monet 4 code base
@c
#include "mal_exception.h"

str CMDmark_grp(int* res, int *bid, int *gid){
	BAT *r, *b, *g;
        @:getBATdescriptor(&res,bid,b,mark_grp)@
        @:getBATdescriptor(&res,gid,g,mark_grp)@
	r=BATmark_grp(b, g);
	if( r) BBPfix(*res= r->batCacheid);
	else throwMessage("mark_grp","error in group marking");
	return MAL_SUCCEED;
}

