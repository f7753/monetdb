@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2005 CWI.
@' All Rights Reserved.

@' 
@' Contributor(s):
@' 		Martin Kersten <Martin.Kersten@cwi.nl>
@' 		Peter Boncz <Peter.Boncz@cwi.nl>
@' 		Niels Nes <Niels.Nes@cwi.nl>
@' 		Stefan Manegold  <Stefan.Manegold@cwi.nl>

@f pcl
@a N. Nes
@* Performance Counters Library
@T

             PCL - The Performance Counter Library
                   Version 2.2, January 2003

PCL (The Performance Counter Library) is a common interface to access
in a portable way performance counters built into modern
microprocessors. PCL supports query for functionality, start and stop
of counters, and reading the current values out of the
counters. Performance counting can be done in user mode, system, and
user-or-system mode. Functions are callable from C, C++, Fortran, and
Java.

Currently, the following systems are supported:

  -  Linux 2.x.x with Intel Pentium/PPro/Pentium II/Pentium III/Pentium 4
  -  Linux 2.x.x with AMD Athlon/Duron
  -  IBM AIX 4.x >= 4.3 with PowerPC 604, 604e, Power3, Power3-II
  -  SUN Solaris 2.x, Solaris 7, 8 with UltraSPARC I,II, III
  -  Digital Unix with Alpha 21164, 21264
  -  Cray T3E with Alpha 21164
  -  SGI IRIX with R10000, R12000

The homepage of PCL can be found at

    http://www.fz-juelich.de/zam/PCL/

were you can find the source and a detailed description of PCL
including a description of performance counters on various
microprocessors.

TODO

add pcl_cpu_info! (void,str bat) (max counters?)
later add low level api

@+ Module Definition
@mal
module pcl;

command start(events:bat[int,any],  mode:int) = CMDpclstart
  comment "start counting the given events";

command stop(events:bat[int,any] ) : bat[int,lng] = CMDpclstop
  comment "stop counting and return the counts for the given events.";

command start_rates(rates:bat[int,any] , mode:int) = CMDpclstart_rates
  comment "start counting the events needed for the given rates";

command stop_rates(rates:bat[int,any] ) : bat[int,dbl] = CMDpclstop_rates
  comment "stop event counters and return the requested rates.";

command query(events:bat[int,any] , mode:int ) : bat[int,int] = CMDpclquery
  comment "query for existing events";

command try(events:bat[int,any] , mode:int ) :bit = CMDpcltry
  comment "try wheter the events could be started together on this CPU";

command init():void = CMDpclinit;

pcl.init();
  
@{
@+ Implementation
@c
#include "gdk.h"

#ifndef HAVE_LIBPCL

bat *
pcl_init()
{
	return NULL;
}

void
pcl_exit()
{
}

int
pcl_info(BAT **result)
{
	*result = NULL;
	return GDK_SUCCEED;
}

int
pcl_start(BAT *event, int *mode)
{
	(void) event;
	(void) mode;
	return GDK_SUCCEED;
}

int
pcl_start_rates(BAT *event, int *mode)
{
	(void) event;
	(void) mode;
	return GDK_SUCCEED;
}

int
pcl_stop(BAT **result, BAT *event)
{
	(void) event;
	*result = NULL;
	return GDK_SUCCEED;
}

int
pcl_stop_rates(BAT **result, BAT *event)
{
	(void) event;
	*result = NULL;
	return GDK_SUCCEED;
}

int
pcl_query(BAT **result, BAT *event, int *mode)
{
	(void) event;
	(void) mode;
	*result = NULL;
	return GDK_SUCCEED;
}

int
pcl_try(bit *result, BAT *event, int *mode)
{
	(void) event;
	(void) mode;
	*result = FALSE;
	return GDK_SUCCEED;
}

int
pcl_eventname(str *result, int *event)
{
	(void) event;
	*result = str_nil;
	return GDK_SUCCEED;
}
#else

#include <pcl.h>

static PCL_DESCR_TYPE pcl_desc;

bat *
pcl_init()
{
	if (PCLinit(&pcl_desc) != PCL_SUCCESS) {
		GDKwarning("couldn't initialize pcl library\n");
	}
	return NULL;
}

void
pcl_exit()
{
	if (PCLexit(pcl_desc) != PCL_SUCCESS) {
		GDKwarning("couldn't free pcl library resources\n");
	}
}

int
pcl_info(BAT **result)
{
	int res;
	char mhz[16], ncounters[16];
	PCL_PROCESSOR_INFO info;

	res = PCL_driver_info(&info);
	if (res != PCL_SUCCESS) {
		GDKwarning("pcl_info failed with %d\n", res);
		*result = NULL;
		return GDK_FAIL;
	}
	*result = BATnew(TYPE_str, TYPE_str, 5);
	if (*result == NULL)
		return GDK_FAIL;
	BUNins(*result, "vendor", info.vendor);
	BUNins(*result, "family", info.family);
	BUNins(*result, "model", info.model);
	snprintf(mhz, 16, "%d", info.mhz);
	BUNins(*result, "mhz", mhz);
	snprintf(ncounters, 16, "%d", info.ncounters);
	BUNins(*result, "ncounters", ncounters);
	return GDK_SUCCEED;
}

int
pcl_start(BAT *event, int *mode)
{
	int clist[PCL_MAX_EVENT_PER_CALL];
	int res, i = 0;
	BUN p, q;

	if (BATcount(event) > PCL_MAX_EVENT_PER_CALL) {
		GDKwarning("Can only use %d events per call\n", PCL_MAX_EVENT_PER_CALL);
		return GDK_FAIL;
	}
	BATloop(event, p, q) {
		int ev = *(int *) BUNhloc(event, p);

		if (PCL_EVENT_IS_INT(ev)) {
			clist[i] = ev;
			i++;
		}
	}
	res = PCLstart(pcl_desc, clist, i, *mode);
	if (res != PCL_SUCCESS) {
		GDKwarning("pcl_start failed with %d\n", res);
		return GDK_FAIL;
	}
	return GDK_SUCCEED;
}

int
pcl_start_rates(BAT *event, int *mode)
{
	int clist[PCL_MAX_EVENT_PER_CALL];
	int res, i = 0;
	BUN p, q;

	if (BATcount(event) > PCL_MAX_EVENT_PER_CALL) {
		GDKwarning("Can only use %d events per call\n", PCL_MAX_EVENT_PER_CALL);
		return GDK_FAIL;
	}
	BATloop(event, p, q) {
		int ev = *(int *) BUNhloc(event, p);

		if (!PCL_EVENT_IS_INT(ev)) {
			clist[i] = ev;
			i++;
		}
	}
	res = PCLstart(pcl_desc, clist, i, *mode);
	if (res != PCL_SUCCESS) {
		GDKwarning("pcl_start_rates failed with %d\n", res);
		return GDK_FAIL;
	}
	return GDK_SUCCEED;
}

int
pcl_stop(BAT **result, BAT *event)
{
	PCL_CNT_TYPE ilist[PCL_MAX_EVENT_PER_CALL];
	PCL_FP_CNT_TYPE flist[PCL_MAX_EVENT_PER_CALL];
	int res, i = 0;
	size_t cnt = BATcount(event);
	BUN p, q;

	if (cnt > PCL_MAX_EVENT_PER_CALL) {
		GDKwarning("Can only use %d events per call\n", PCL_MAX_EVENT_PER_CALL);
		return GDK_FAIL;
	}
	res = PCLstop(pcl_desc, ilist, flist, cnt);
	if (res != PCL_SUCCESS) {
		GDKwarning("pcl_stop failed with %d\n", res);
		return GDK_FAIL;
	}
	*result = BATnew(TYPE_int, TYPE_lng, cnt);
	if (*result == NULL)
		return GDK_FAIL;
	BATloop(event, p, q) {
		int ev = *(int *) BUNhloc(event, p);

		if (PCL_EVENT_IS_INT(ev)) {
			lng h = ilist[i];

			BUNins(*result, &ev, &h);
		}
		i++;
	}
	return GDK_SUCCEED;
}

int
pcl_stop_rates(BAT **result, BAT *event)
{
	PCL_CNT_TYPE ilist[PCL_MAX_EVENT_PER_CALL];
	PCL_FP_CNT_TYPE flist[PCL_MAX_EVENT_PER_CALL];
	int res, i = 0;
	size_t cnt = BATcount(event);
	BUN p, q;

	if (cnt > PCL_MAX_EVENT_PER_CALL) {
		GDKwarning("Can only use %d events per call\n", PCL_MAX_EVENT_PER_CALL);
		return GDK_FAIL;
	}
	res = PCLstop(pcl_desc, ilist, flist, cnt);
	if (res != PCL_SUCCESS) {
		GDKwarning("pcl_stop_rates failed with %d\n", res);
		return GDK_FAIL;
	}
	*result = BATnew(TYPE_int, TYPE_dbl, cnt);
	if (*result == NULL)
		return GDK_FAIL;
	BATloop(event, p, q) {
		int ev = *(int *) BUNhloc(event, p);

		if (!PCL_EVENT_IS_INT(ev)) {
			dbl h = flist[i];

			BUNins(*result, &ev, &h);
		}
		i++;
	}
	return GDK_SUCCEED;
}

int
pcl_query(BAT **result, BAT *event, int *mode)
{
	int res;
	size_t cnt = BATcount(event);
	int clist;
	BUN p, q;

	*result = BATnew(TYPE_int, TYPE_int, cnt);
	if (*result == NULL)
		return GDK_FAIL;
	BATloop(event, p, q) {
		int ev = *(int *) BUNhloc(event, p);

		clist = ev;
		res = PCLquery(pcl_desc, &clist, 1, *mode);
		BUNins(*result, &ev, &res);
	}
	return GDK_SUCCEED;
}

int
pcl_try(bit *result, BAT *event, int *mode)
{
	int i = 0, res;
	int clist[PCL_MAX_EVENT_PER_CALL];
	BUN p, q;

	if (BATcount(event) > PCL_MAX_EVENT_PER_CALL) {
		GDKwarning("Can only use %d events per call\n", PCL_MAX_EVENT_PER_CALL);
		return GDK_FAIL;
	}
	BATloop(event, p, q) {
		int ev = *(int *) BUNhloc(event, p);

		clist[i] = ev;
		i++;
	}
	res = PCLquery(pcl_desc, clist, i, *mode);
	if (res == PCL_SUCCESS)
		*result = TRUE;
	else
		*result = FALSE;
	return GDK_SUCCEED;
}

int
pcl_eventname(str *result, int *event)
{
	str res = (str) PCLeventname(*event);

	if (res == NULL) {
		*result = str_nil;
	} else {
		*result = GDKstrdup(res);
		/* free(res); */
	}
	return GDK_SUCCEED;
}
#endif

@-
The MAL wrappers around the V4 library
@c
extern int pcl_start(BAT *event, int *mode);
extern int pcl_start_rates(BAT *event, int *mode);
extern int pcl_stop(BAT **result, BAT *event);
extern int pcl_stop_rates(BAT **result, BAT *event);
extern int pcl_query(BAT **result, BAT *event, int *mode);
extern int pcl_try(bit *result, BAT *event, int *mode);

str CMDpclstart(int *ret, int *bid, int *mode){
	BAT *b;
	(void) ret;
    if( (b= BATdescriptor(*bid)) == NULL ){
         return throwMessage("pcl.start", "Cannot access descriptor");
    }

	pcl_start(b,mode);
	BBPunfix(b->batCacheid);
	return MAL_SUCCEED;
}
str CMDpclstart_rates(int *ret, int *bid, int *mode){
	BAT *b;
	(void) ret;
    if( (b= BATdescriptor(*bid)) == NULL ){
         return throwMessage("pcl.start", "Cannot access descriptor");
    }
	pcl_start_rates(b,mode);
	BBPunfix(b->batCacheid);
	return MAL_SUCCEED;
}
str  CMDpclstop(int *ret, int *bid)
	BAT *b;
    if( (b= BATdescriptor(*bid)) == NULL ){
         return throwMessage("pcl.stop", "Cannot access descriptor");
    }

	pcl_stop(&b,event);
	BBPincref(*ret= b->batCacheid,TRUE);
	BBPunfix(*ret);
	return MAL_SUCCEED;
}
str  CMDpclstop_rates(int *ret, int *bid, int *eid)
	BAT *b, *event;
    if( (b= BATdescriptor(*bid)) == NULL ){
         return throwMessage("pcl.stop", "Cannot access descriptor");
    }
    if( (event= BATdescriptor(*eid)) == NULL ){
         return throwMessage("pcl.stop", "Cannot access descriptor");
    }
	pcl_stop_rates(&b,event);
	BBPincref(*ret= b->batCacheid,TRUE);
	BBPunfix(*ret);
	return MAL_SUCCEED;
}
str  CMDpclquery(int *ret, int *eid, int *mode)
	BAT *b;
    if( (b= BATdescriptor(*eid)) == NULL ){
         return throwMessage("pcl.stop", "Cannot access descriptor");
    }
	pcl_query(&b,NULL,mode);
	BBPincref(*ret= b->batCacheid,TRUE);
	BBPunfix(*ret);
	return MAL_SUCCEED;
}
str  CMDpcltry(int *ret, int *eid,int *mode)
	BAT *b;
    if( (b= BATdescriptor(*eid)) == NULL ){
         return throwMessage("pcl.stop", "Cannot access descriptor");
    }
	pcl_query(&b,NULL,mode);
	return MAL_SUCCEED;
}
@-
The V4 implementation code
@c

int pcl_start(BAT *event, int *mode){ return GDK_SUCCEED; }
int pcl_start_rates(BAT *event, int *mode){ return GDK_SUCCEED; }

int pcl_stop(BAT **result, BAT *event){ 
	*result = NULL; 
	return GDK_SUCCEED; 
}

int pcl_stop_rates(BAT **result, BAT *event){ 
	*result = NULL; 
	return GDK_SUCCEED; 
}

int pcl_query(BAT **result, BAT *event, int *mode){ 
	*result = NULL; 
	return GDK_SUCCEED; 
}

int pcl_try(bit *result, BAT *event, int *mode){ 
	*result = FALSE; 
	return GDK_SUCCEED; 
}
#else

#include <pcl.h>

static PCL_DESCR_TYPE pcl_desc;

/* not needed in V5
bat* pcl_init(){
	if (PCLinit(&pcl_desc) != PCL_SUCCESS){
		GDKwarning("couldn't initialize pcl library\n");
	}
	return NULL;
}

void pcl_exit(){
	if (PCLexit(pcl_desc) != PCL_SUCCESS){
		GDKwarning("couldn't free pcl library resources\n");
	}
}
*/

int pcl_start(BAT *event, int *mode){
	int clist[PCL_MAX_EVENT_PER_CALL];
	int res, i = 0;
	BUN p,q;

	if (BATcount(event) > PCL_MAX_EVENT_PER_CALL){
		GDKwarning("Can only start %d events per call\n", 
			PCL_MAX_EVENT_PER_CALL);
		return GDK_FAIL;
	}
	BATloop(event,p,q){
		int ev = *(int*)BUNhloc(event,p);
		if (PCL_EVENT_IS_INT(ev)){
			clist[i] = ev;
			i++;
		}
	}
	res = PCLstart(pcl_desc, clist, i, *mode);
	if (res != PCL_SUCCESS){
		GDKwarning("pcl_start failed with %d\n", res);
		return GDK_FAIL;
	}
	return GDK_SUCCEED;
}

int pcl_start_rates(BAT *event, int *mode){
	int clist[PCL_MAX_EVENT_PER_CALL];
	int res, i = 0;
	BUN p,q;

	if (BATcount(event) > PCL_MAX_EVENT_PER_CALL){
		GDKwarning("Can only start %d events per call\n", 
			PCL_MAX_EVENT_PER_CALL);
		return GDK_FAIL;
	}
	BATloop(event,p,q){
		int ev = *(int*)BUNhloc(event,p);
		if (!PCL_EVENT_IS_INT(ev)){
			clist[i] = ev;
			i++;
		}
	}
	res = PCLstart(pcl_desc, clist, i, *mode);
	if (res != PCL_SUCCESS){
		GDKwarning("pcl_start failed with %d\n", res);
		return GDK_FAIL;
	}
	return GDK_SUCCEED;
}

int pcl_stop(BAT **result, BAT *event){
	PCL_CNT_TYPE ilist[PCL_MAX_EVENT_PER_CALL];
	PCL_FP_CNT_TYPE flist[PCL_MAX_EVENT_PER_CALL];
	int res, i = 0;
	size_t cnt = BATcount(event);
	BUN p,q;

	if (cnt > PCL_MAX_EVENT_PER_CALL){
		GDKwarning("Can only start %d events per call\n", 
			PCL_MAX_EVENT_PER_CALL);
		return GDK_FAIL;
	}
	res = PCLstop(pcl_desc, ilist, flist, cnt);
	if (res != PCL_SUCCESS){
		return GDK_FAIL;
	}
	*result = BATnew(TYPE_int, TYPE_lng, cnt);
	BATloop(event,p,q){
		int ev = *(int*)BUNhloc(event,p);
		if (PCL_EVENT_IS_INT(ev)){
			lng h = ilist[i];
			BUNins(*result, &ev, &h);
		}
		i++;
	}
	return GDK_SUCCEED;
}

int pcl_stop_rates(BAT **result, BAT *event){
	PCL_CNT_TYPE ilist[PCL_MAX_EVENT_PER_CALL];
	PCL_FP_CNT_TYPE flist[PCL_MAX_EVENT_PER_CALL];
	int res, i = 0;
	size_t cnt = BATcount(event);
	BUN p,q;

	if (cnt > PCL_MAX_EVENT_PER_CALL){
		GDKwarning("Can only start %d events per call\n", 
			PCL_MAX_EVENT_PER_CALL);
		return GDK_FAIL;
	}
	res = PCLstop(pcl_desc, ilist, flist, cnt);
	if (res != PCL_SUCCESS){
		return GDK_FAIL;
	}
	*result = BATnew(TYPE_int, TYPE_dbl, cnt);
	BATloop(event,p,q){
		int ev = *(int*)BUNhloc(event,p);
		if (!PCL_EVENT_IS_INT(ev)){
			dbl h = flist[i];
			BUNins(*result, &ev, &h);
		}
		i++;
	}
	return GDK_SUCCEED;
}

int pcl_query(BAT **result, BAT *event, int *mode){
	int res;
	size_t cnt = BATcount(event);
	int clist;
	BUN p,q;

	*result = BATnew(TYPE_int,TYPE_int,cnt);
	BATloop(event,p,q){
		int ev = *(int*)BUNhloc(event,p);
		clist = ev;
		res = PCLquery(pcl_desc, &clist, 1, *mode);
		BUNins(*result, &ev, &res);
	}
	return GDK_SUCCEED;
}

int pcl_try(bit *result, BAT *event, int *mode){
	int i = 0, res;
	int clist[PCL_MAX_EVENT_PER_CALL];
	BUN p,q;

	if (BATcount(event) > PCL_MAX_EVENT_PER_CALL){
		GDKwarning("Can only start %d events per call\n", 
			PCL_MAX_EVENT_PER_CALL);
		return GDK_FAIL;
	}
	BATloop(event,p,q){
		int ev = *(int*)BUNhloc(event,p);
		clist[i] = ev;
		i++;
	}
	res = PCLquery(pcl_desc, clist, i, *mode);
	if (res == PCL_SUCCESS)
	 	*result = TRUE;
	else
	 	*result = FALSE;
	return GDK_SUCCEED;
}
#endif

@mil

PROC test_pcl() :void := {
  names := bat(str,void);
  names.insert("PCL_L1CACHE_MISS",  nil);
  names.insert("PCL_L1DCACHE_MISS", nil);
  names.insert("PCL_L1ICACHE_MISS", nil);

  available := pcl_query(pcl_events.reverse.project(nil).reverse,1).select(0);

  L1MISS_EVENTS := pcl_events.reverse.semijoin(available).reverse.semijoin(names);
  L1MISS_EVENTS.print;

  events := L1MISS_EVENTS.reverse.project(nil).reverse();
  pcl_start(events,1);
  counts := pcl_stop(events);
  counts.print;
}

@}
