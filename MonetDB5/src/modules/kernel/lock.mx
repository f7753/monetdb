@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@' 
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@' 
@' The Original Code is the Monet Database System.
@' 
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2004 CWI.
@' All Rights Reserved.
@' 
@' Contributor(s):
@' 		Martin Kersten <Martin.Kersten@cwi.nl>
@' 		Peter Boncz <Peter.Boncz@cwi.nl>
@' 		Niels Nes <Niels.Nes@cwi.nl>
@' 		Stefan Manegold  <Stefan.Manegold@cwi.nl>

@f lock
@v 1.0
@a Peter Boncz
@* Lightweight Lock Module
This module provides simple SMP lock and thread functionality
as already present in the Monet system.

@mal
atom module lock:ptr;

command create() :lock 
address LCKcreate
comment "Create an unset lock";
command set(l:lock) 
address LCKset
comment "Try to set a lock; if set, 
	block till it is freed";
command try(l:lock) :int 
address LCKtry
comment "Try a lock, if free set it, 
	if not return EBUSY";
command unset(l:lock) 
address LCKunset
comment "Unset a lock";
command destroy(l:lock) 
address LCKdestroy
comment "Destroy a lock";
command tostr(l:lock) 
address lockToStr
comment "Overloaded atom function";

@- semaphores
@mal
atom module sema:ptr;

command create(init:int ) :sema 
address SEMAcreate
comment "Create an unset sema, with an initial value";
command down(s:sema) 
address SEMAdown
comment "Decrement the semaphpore if >0; else block";
command up(s:sema) 
address SEMAup
comment "Increment the semaphore";
command destroy(s:sema) 
address SEMAdestroy
comment "Destroy a semaphore";
@{
@+ Implementation
@c
#include <gdk.h>
typedef ptr lock;
typedef ptr sema;
typedef ptr monet_lock;
typedef ptr monet_sema;

int create_lock(monet_lock *l){
	*l = MT_create_lock();
	return GDK_SUCCEED;
}

int set_lock(monet_lock *l){
	MT_set_lock((MT_Lock) *l, "set_lock");
	return GDK_SUCCEED;
}

int try_lock(int* res, monet_lock* l){
	*res = MT_try_lock((MT_Lock) *l)?EBUSY:0;
	return GDK_SUCCEED;
}

int unset_lock(monet_lock *l){
	MT_unset_lock((MT_Lock) *l, "unset_lock");
	return GDK_SUCCEED;
}

int destroy_lock(monet_lock *l){
	MT_destroy_lock((MT_Lock) *l);
	return GDK_SUCCEED;
}

int create_sema(monet_sema *s, int *init){
	*s = MT_create_sema(*init);
	return GDK_SUCCEED;
}

int up_sema(monet_sema *s){
	MT_up_sema((MT_Sema) *s, "up_sema");
	return GDK_SUCCEED;
}


int down_sema(monet_sema *s){
	MT_down_sema((MT_Sema) *s, "down_sema");
	return GDK_SUCCEED;
}

int destroy_sema(monet_sema *s){
	MT_destroy_sema((MT_Sema) *s);
	return GDK_SUCCEED;
}
@}
@- Wrapping
The old code base is wrapped to ease update propagation.
@c
#include "mal.h"
int lockToStr(char **dst, int *len, ptr *src){
	(void)len; /* fool compiler */
	(void)src; /* fool compiler */
	if( src == ptr_nil){
		strcpy(*dst,"nil");
		return 3;
	}
	/* sprintf(*dst,"%o", (ptr)*src);*/
	sprintf(*dst,"redo lockToStr");
	return strlen(*dst);
}

str LCKcreate(monet_lock *l){
	create_lock( l);
	return MAL_SUCCEED;
}
str LCKset(int *res, monet_lock *l){
	set_lock(l);
	*res=1;
	return MAL_SUCCEED;
}
str LCKtry(int *res, monet_lock *l){
	try_lock(res, l);
	return MAL_SUCCEED;
}
str LCKunset(int *res, monet_lock *l){
	unset_lock(l);
	*res=1;
	return MAL_SUCCEED;
}
str LCKdestroy(int *res, monet_lock *l){
	destroy_lock(l);
	*res=1;
	return MAL_SUCCEED;
}

str SEMAcreate(monet_sema *res, int *init){
	create_sema(res, init);
	return MAL_SUCCEED;
}
str SEMAup(int *res, monet_sema *s){
	up_sema(s);
	*res=1;
	return MAL_SUCCEED;
}
str SEMAdown(int *res, monet_sema *s){
	down_sema(s);
	*res=1;
	return MAL_SUCCEED;
}
str SEMAdestroy(int *res, monet_sema *s){
	destroy_sema(s);
	*res =1;
	return MAL_SUCCEED;
}

@}
