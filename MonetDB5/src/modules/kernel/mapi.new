@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2003 CWI.
@' All Rights Reserved.
@'
@' Contributor(s):
@'              Martin Kersten <Martin.Kersten@cwi.nl>
@'              Peter Boncz <Peter.Boncz@cwi.nl>
@'              Niels Nes <Niels.Nes@cwi.nl>
@'              Stefan Manegold  <Stefan.Manegold@cwi.nl>

@f mapi
@a N.J. Nes P. Boncz M. Kersten
@t Monets Simple Internet Interface
@v 1.1

This module contains a simple interface for setting up
internet connections and to initialize a client session.
Without loading this interface, Monet runs in administrator
mode. The information about activitated listeners is stored in 
a few tables view_mapi_owner, view_mapi_port, view_mapi_maxusers,
and view_mapi_users.

Clients may initialize a private listener to implement
specific services. For example, in an OLTP environment
it may make sense to have a listener for each transaction
type, which simply parses a sequence of transaction parameters.

The information about open listeners is maintain in global tables.
They behave as views on the actual state.
No protection is currently possible against malicious users changing them. 

Authorization of access to the server is handled as part
of the client record initialization phase.
@mal
module mapi;

command listen():int  = MAPIlisten_default
	comment "Start a Mapi server with the default settings.";
command listen(port:lng):int  = MAPIlisten_port
	comment "Start a Mapi server with the default settings.";
command listen(port:int, maxusers:int):int = MAPIlisten
	comment "Start a Mapi server.";
command stop(port:int):bit = MAPIstop
	comment "Terminate a listener owned by the client";
command stop(name:str):bit = MAPIstopClient
	comment "Terminate a client";

command trace(nme:str, flag:bit):void = MAPItrace2
	comment "Trace (on/off) receipt of all messages from a specific user";
command trace(flag:bit):void = MAPItrace
	comment "Trace (on/off) receipt of messages for all users";

# initialization code
#function main():void;
	#vm1:bat[int,int]:= bat(5:int,11:int);
	#bat.setName(vm1,"view_mapi_owner");
	#bat.setRoles(vm1,"mapi","owner");

	#vm2:bat[int,int]:= bat(5:int,5:int);
	#bat.setName(vm2,"view_mapi_port");
	#bat.setRoles(vm2,"mapi","port");

	#vm3:bat[int,int]:= bat(5:int,5:int);
	#bat.setName(vm3,"view_mapi_maxusers");
	#bat.setRoles(vm3,"mapi","maxusers");

	#vm4:bat[int,int]:= bat(5:int,5:int);
	#bat.setName(vm4,"view_mapi_users");
	#bat.setRoles(vm4,"mapi","users");

	#vm5:bat[int,int]:= bat(5:int,5:int);
	#bat.setName(vm5,"view_mapi_timeout");
	#bat.setRoles(vm5,"mapi","timeout");
#end main;
	
@h
/*
 * The contents of this file are subject to the Monet Public
 * License Version 1.1 (the "License"); you may not use this file
 * except in compliance with the License. You may obtain a copy of
 * the License at 
 * http://www.monetsolutions.com/Download/Licensing/MonetPL-1.1.html
 * 
 * Software distributed under the License is distributed on an "AS
 * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
 * implied. See the License for the specific language governing
 * rights and limitations under the License.
 * 
 * The Original Code is the Monet Database System.
 * 
 * The Initial Developer of the Original Code is CWI.
 * Portions created by CWI are Copyright (C) 1997-2001 CWI.  
 * All Rights Reserved.
 * 
 * Contributor(s): Martin Kersten <Martin.Kersten@cwi.nl>
 *		   Peter Boncz <Peter.Boncz@cwi.nl>
 *		   Niels Nes <Niels.Nes@cwi.nl>
 */

#ifndef MAPI_H
#define MAPI_H

#define MAPIPORT	50000
#define MAPIMAXUSERS 	5

#define DEBUG_MAPI	1

#endif /* MAPI_H */
@c
#include "mapi.h"
#include "mal_client.h"
#include  <sys/socket.h> 

#define SOCKPTR struct sockaddr *

static int mapiSpy= 1;
void connect_error(stream *in, stream *out, int sock)
{
        close_stream(in);
        close_stream(out);
        close(sock);
}

void MAPIlistenThread(int sock)
{
	int 	msgsock;
	do {
#ifdef AIX
       		msgsock = accept(sock, 0, (size_t)0);
#else
       		msgsock = accept(sock, 0, (int *)0);
#endif

		if (msgsock == -1) {
			if (MT_geterrno() != EINTR) {
				GDKsyserror("monetServer: accept failed\n");
				return ;
	    		}
		} else if (msgsock > 0) {
			int i,l,debug;
			stream *fin, *fout;
			char *user, *passwd, buf[BUFSIZ+1];

			fout = socket_wstream( msgsock, "Mserver 5.0" );
			fin = socket_rstream( msgsock, "Mserver 5.0" );
			if ((i = fin->read(fin, buf, 1, BUFSIZ)) >= BUFSIZ)
				return connect_error(fin, fout, msgsock);
			buf[i] = 0;
			if( DEBUG_MAPI) 
				stream_printf(GDKout,"connect 1:%s\n",buf);
			/* expect api(mal,<debug level>); */
			l = strlen("api(mal,");
			if (i > l+1 )
				debug = strtol(buf+l,NULL,10);

			i=snprintf(buf, BUFSIZ, "login\n" );
			stream_printf(fout, buf, 1, i);
			fout->flush(fout);

			if ((i = fin->read(fin, buf, 1, BUFSIZ)) >= BUFSIZ)
				return connect_error(fin, fout, msgsock);
			buf[i] = 0;
			if( DEBUG_MAPI) 
				stream_printf(GDKout,"connect 2:%s\n",buf);
			/* expect login(user,passwd); */
			l = strlen("login(");
			if (i > l+1 ){
				char *s, *e = strchr(buf+l,',');
				if (!e) return connect_error(fin, fout, msgsock);
				*e = 0;
				s = e+1; /* skip comma */
				e = strrchr(s, ')');
				if (!e) return connect_error(fin, fout, msgsock);
				*e = 0;
				user = GDKstrdup(buf+l);
				passwd = GDKstrdup(s);
			} else {
				return connect_error(fin, fout, msgsock);
			}


		if( DEBUG_MAPI) 
			THRprintf(GDKerr, "mapi:Client accepted %s\n", user);
		scheduleClient(user, fin,fout);
		if( mapiSpy) traceClient(user, mapiSpy);
	}
	} while (1);
}


str MAPIlisten(int *ret, int *port, int *maxusers){
	struct sockaddr_in server;
	int 	sock;
#ifdef AIX
	size_t 	length;
#else
	int 	length;
#endif
	int    	on = 1;
	int 	msgsock;
	int	i = 0;
	pid_t	pid;
	char 	msg[512];
	char 	host[512];

	sock = socket(AF_INET, SOCK_STREAM, 0);
	if (sock < 0) {
		return throwMessage("mapi.listen", "creation of socket failed");
	}
@-
Set server port and allow internet connections from any workstation.
Bind the socket to the server port.
The port id is obtained from the Monet configuration file.
@c
	if (*port == 0)
		*port = MAPIPORT;
	if( DEBUG_MAPI)
		THRprintf(GDKerr, "start at %d\n", *port);
	server.sin_family = AF_INET;
	server.sin_addr.s_addr = INADDR_ANY;
	server.sin_port = htons((unsigned short)((*port)&0xFFFF));
   	for (i=0;i<8;i++)
	    server.sin_zero[i]=0;
 
	setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, (char*) &on, sizeof on);

	length = sizeof(server);
	if (bind(sock, (SOCKPTR)&server, length) < 0) {
		return throwException(MALEXCEPTION,"mapi.listen",
			"binding to socket (%d) failed", *port);
	}
@-
Get the new information for the server socket and start listening.
@c
	if (getsockname(sock, (SOCKPTR)&server, &length) < 0) {
		return throwMessage("mapi.listen", "error getting socket name");
	}
	listen(sock, *maxusers); 

	if( MT_create_thread((MT_Id *)&pid, MAPIlistenThread, (void*) sock) <0){
		return throwMessage("mapi.listen", "starting thread failed");
	}
	if( DEBUG_MAPI)
		THRprintf(GDKerr, "Internet started at %d\n", server.sin_port);
	gethostname(host,512);
	{int i;
	snprintf(msg,512,"#Ready to accept connections on %s:",host);
	i= strlen(msg);
	snprintf(msg+i,512-i,"%d\n",*port);
	}
	stream_printf(GDKout,"%s",msg);
	*ret = TRUE;
	return MAL_SUCCEED;
}

str MAPIlisten_default(int *ret){
	int port = MAPIPORT;
	int maxusers = MAPIMAXUSERS;
	return MAPIlisten(ret, &port, &maxusers);
}
str MAPIlisten_port(int *ret, int *pid){
	int port = *pid;
	int maxusers = MAPIMAXUSERS;
	return MAPIlisten(ret, &port, &maxusers);
}
@-
An internet connection may be terminated by the owner of the process only.
@c
str MAPIstop(int *ret, int *pid)
{
	printf("kill process %d\n",*pid);
	return MAL_SUCCEED;
}

str MAPIstopClient(int *ret, str *nme)
{
	printf("kill process for client %s\n",*nme);
	return MAL_SUCCEED;
}
@-
It is advisable to trace the interactions of clients on the server
side. At least as far as it concerns requests received.
The kernel supports this 'spying' behavior with a file descriptor
field in the client record.
@c
str MAPItrace2(str *nme,int *flg){
	traceClient(*nme,*flg);
	return MAL_SUCCEED;
}

str MAPItrace(int *flg){
	traceAllClients(*flg);
	mapiSpy = *flg;
	return MAL_SUCCEED;
}
