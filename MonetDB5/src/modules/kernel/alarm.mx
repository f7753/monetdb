@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@' 
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@' 
@' The Original Code is the Monet Database System.
@' 
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2004 CWI.
@' All Rights Reserved.
@' 
@' Contributor(s):
@' 		Martin Kersten <Martin.Kersten@cwi.nl>
@' 		Peter Boncz <Peter.Boncz@cwi.nl>
@' 		Niels Nes <Niels.Nes@cwi.nl>
@' 		Stefan Manegold  <Stefan.Manegold@cwi.nl>

@f alarm
@a M.L. Kersten, P. Boncz
@t Timers and Timed Interrupts

@* Introduction
@T
This module handles various signalling/timer functionalities.
The Monet interface supports two timer commands: {\tt alarm} and {\tt sleep}.
Their argument is the number of seconds to wait before the timer goes off. 
The {\tt sleep} command blocks till the alarms goes off.
The {\tt alarm} command continues directly, executes off a MIL
string when it goes off.
The parameterless routines {\tt time} and {\tt ctime} provide access to
the cpu clock. They return an integer and string, respectively.

@* Module Definition
@mal
module alarm;

command sleep(secs:int):void = CLKsleep comment "sleep X secs";
command alarm(secs:int, action:str):void = CLKsetalarm 
comment "execute action in X secs";
command timers() :bat[:str,:str] = CLKtimers
comment "give a list of all active timers";
command usec() :lng = CLKusec
comment "return cpu microseconds info";
command time() :int = CLKtime comment "time in millisecs";
command epoch() :int = CLKepoch comment "current time as unix epoch";
command ctime() :str = CLKctime comment "current time as a string";
command prelude():void= CLKprelude comment "Initialize alarm module";
command epilogue():void= CLKepilogue comment "Finalize alarm module";

prelude();

@{
@* Implementation
@+ The Clock Interupt Generator
A clock event generator, called @%timer@, has been added to the kernel.
It accepts a message @%CLKsetalarm(sec, usec)@, which generates an alarm
after the time indicated.
The timer maintains a small stack of timing events sorted in priority of 
firing.
The top contains the next timer event to go off.
The timer is disabled when no timer events are outstanding.
@h
/*
 * The contents of this file are subject to the Monet Public
 * License Version 1.1 (the "License"); you may not use this file
 * except in compliance with the License. You may obtain a copy of
 * the License at 
 * http://www.monetsolutions.com/Download/Licensing/MonetPL-1.1.html
 * 
 * Software distributed under the License is distributed on an "AS
 * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
 * implied. See the License for the specific language governing
 * rights and limitations under the License.
 * 
 * The Original Code is the Monet Database System.
 * 
 * The Initial Developer of the Original Code is CWI.
 * Portions created by CWI are Copyright (C) 1997-2002 CWI.  
 * All Rights Reserved.
 * 
 * Contributor(s): Martin Kersten <Martin.Kersten@cwi.nl>
 *		   Peter Boncz <Peter.Boncz@cwi.nl>
 */

#include "mal.h"
#ifdef HAVE_SYS_SIGNAL_H
# include <sys/signal.h> 
#endif
#define MAXtimer                200

typedef struct {
	str action;	/* MAL action (as a string) */
	MT_Sema sema;	/* barrier */
	int alarm_time;	/* time when the alarm goes off */
} monet_timer_t;

@c
#include "alarm.h"
#include "mal_function.h"

static monet_timer_t            timer[MAXtimer]; 
static int                      timerTop = 0; 
@
@- 
The timer is awakened by a clock interrupt. The interrupt granularity 
is OS-dependent. The timer should be initialized as long as there
are outstanding timer events.
@c
void CLKinitTimer(int sec, int usec){
	int i = sec - time(0);
	(void) usec; /* fool compiler */
	TRGDEBUG THRprintf(GDKerr, "CLKinitTimer: set timer to %d secs \n", i); 
        alarm(i);
}
@- 
A new alarm is pushed onto the stack using @%CLKalarm@.
The parameter is the real-time value to be approximated.
@c
#ifdef SIGALRM
MT_Sema CLKalarm(int t, str action){
        int     j;
        int     k; 
 
	TRGDEBUG THRprintf(GDKerr, "CLKalarm: push %d \n", t); 
        if (timerTop == MAXtimer) {
                return throwMessage("alarm.alarm", "timer stack overflow"); 
        }
        for (j = 0; j < timerTop; j++) {
                if (timer[j].alarm_time > t) break; 
        }
        for (k = timerTop; k > j; k--) {
                timer[k] = timer[k-1]; 
        }
        timer[k].alarm_time = t; 
	if (action) {
		timer[k].action = GDKstrdup(action);
	} else {
        	timer[k].action = 0;
        	timer[k].sema = MT_create_sema(0);
	}
        if (k == timerTop++) {
                CLKinitTimer(t, 0); /* set it sooner */ 
        }
        return timer[k].sema; 
}
#endif
@- 
Once a timer interrupt occurs, we should inspect the timer queue and
emit a notify signal.
@c
#ifdef SIGALRM
static RETSIGTYPE CLKsignal(int nr){
	int k=timerTop;
        int t; 
	(void)nr; /* fool compiler */
 
	if (signal(SIGALRM, CLKsignal) == SIG_ERR) {
		GDKsyserror("CLKsignal: call failed\n");
	}
	TRGDEBUG THRprintf(GDKerr, "alarm signal (timeTop=%d)\n", timerTop); 
        if (timerTop == 0) {
                return; 
        }
        t = time(0); 
        while (k-- && t >= timer[k].alarm_time){
	    if (timer[k].action) {
		TRGDEBUG THRprintf(GDKerr, "eval(%s)\n", timer[k].action); 
		GDKwarning("Timer action not activated");
		/* monet_eval(timer[k].action,&restype);*/
		GDKfree(timer[k].action);
	    } else {
		MT_up_sema(timer[k].sema, "CLKsignal");
	    }
	    timerTop--;
        }
        if (timerTop > 0) {
                CLKinitTimer(timer[timerTop-1].alarm_time, 0); 
        }
}
#endif

str CLKprelude(){
#ifdef SIGALRM
        (void) signal(SIGALRM, (void (*)()) CLKsignal);
	return MAL_SUCCEED;
#else
	return throwMessage("alarm.prelude", "SIGALRM not set");
#endif
}

str CLKepilogue(){
#ifdef SIGALRM
	int k;
#if !(defined(LINUX) || defined(WIN32) || defined(CYGWIN32) || defined(__MACH__))
        (void) signal(SIGALRM,SIG_IGN);
#endif
	for (k = 0; k < timerTop; k++) {
		if (timer[k].action) GDKfree(timer[k].action);
	}
	return MAL_SUCCEED;
#else
	return throwMessage("alarm.epilogue", "SIGALRM not set");
#endif
}

str CLKusec(int *ret){
        *ret= GDKusec();
        return MAL_SUCCEED;
}


str CLKsleep(int *res,int *secs)
{
	(void) res; /* fool compiler */

        if (*secs < 0) {
                return throwMessage("alarm.sleep", "negative delay");
        } else {
		MT_sleep_ms(*secs *1000);
/*
		MT_Sema s = CLKalarm(*secs+time(0), 0);
		(void)CLKprelude();
                MT_down_sema(s, "CLKsleep"); */ /* block on this */
/*
		MT_destroy_sema(s);
*/
        }
        return MAL_SUCCEED;
}
 
str CLKsetalarm(int *res, int *secs, str *action){
	(void) res; /* fool compiler */
        if (*secs < 0) {
                return throwMessage("alarm.setalarm", "negative delay");
        } else {
#ifdef SIGALRM
                (void) CLKalarm(*secs+time(0), *action);
#else
		return throwMessage("alarm.setalarm", "SIGALRM not set");
#endif
        }
        return MAL_SUCCEED;
}
@-
Problem with CLKtimers is that they use static buffers that
may be overwritten under parallel processing.
Therefore, the code below is dangerous (!) and the re-entrant code
should be used. 
@c
str CLKtimers(int *res) {
	char buf[27];
	int k;
	BAT *retval = BATnew(TYPE_str, TYPE_str, timerTop);
	BATroles(retval, "alarm", "action");
	for (k = 0; k < timerTop; k++) {
#ifdef HAVE_CTIME_R3
		ctime_r((time_t *) &timer[k].alarm_time,buf,26); 
#else
#ifdef HAVE_CTIME_R
		ctime_r((time_t *) &timer[k].alarm_time,buf); 
#else
		ctime((time_t *) &timer[k].alarm_time); 
#endif
#endif
		if( buf)
		BUNins(retval, buf, 
			timer[k].action? timer[k].action:"barrier");
        }
	*res= retval->batCacheid;
	return MAL_SUCCEED;
}

str CLKctime(str *retval){
	time_t t = time(0);
#ifdef HAVE_CTIME_R3
	char buf[128];
	*retval = GDKstrdup((char*)ctime_r(&t, buf, 26));
#else
#ifdef HAVE_CTIME_R
	char buf[128];
	*retval = GDKstrdup((char*)ctime_r(&t, buf));
#else
	*retval = GDKstrdup((char*)ctime(&t));
#endif
#endif
	return MAL_SUCCEED;
}

str CLKepoch(int *res) {
	*res = time(0);
	return MAL_SUCCEED;
}

str CLKtime(int *res){
	*res = GDKms();
	return MAL_SUCCEED;
}
@}
