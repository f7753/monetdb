@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@' 
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@' 
@' The Original Code is the Monet Database System.
@' 
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2004 CWI.
@' All Rights Reserved.
@' 
@' Contributor(s):
@' 		Martin Kersten <Martin.Kersten@cwi.nl>
@' 		Peter Boncz <Peter.Boncz@cwi.nl>
@' 		Niels Nes <Niels.Nes@cwi.nl>
@' 		Stefan Manegold  <Stefan.Manegold@cwi.nl>

@f calc
@a N.J. Nes, P. Boncz, M. Kersten, A. de Vries
@v 2.0
@t The Arithmetics Module
@* Introduction
@T
This module implements the arithmetic operations on the built-in types,
{\tt chr}, {\tt sht}, {\tt int}, {\tt flt}, {\tt dbl} and {\tt lng}.
All combinations are implemented. Limited combinations are implemented
for {\tt bit}, {\tt oid} and {\tt str}. 

\begin{description}
\item[binary operators]
The implemented operators are first of all all comparison that return a 
TRUE/FALSE value ({\tt bit} values), i.e. 
{\tt $<=$}, {\tt $<$}, {\tt $==$}, {\tt $!=$}, {\tt $>=$}, and {\tt $>=$}.

The module also implements the operators {\tt +}, {\tt -}, {\tt *} and {\tt /}. 
The rules for the return types operators is as follows.

\begin{enumerate}
\item If one of the input types is a floating point the result will be a
floating point. 
\item The largest type of the input types is taken. 
\end{enumerate}

The {\tt max} and {\tt min} functions return the maximum and minimum of 
the two input parameters.

\item[unary operators]
This module also implements the unary {\tt abs}() function, which calculates 
the absolute value of the given input parameter, as well as the {\tt -} unary
operator. 

The {\tt inv} unary operation calculates the inverse of the input value. 
An error message is given when the input value is zero.

\item[bitwise operators]
For integers there are some additional operations. The {\tt $%$} operator
implements the congruent modulo operation. The {\tt $<<$} and {\tt $>>$} 
are the left and right bit shift. The {\tt or}, {\tt and}, {\tt xor} and 
{\tt not} for integers are implemented as bitwise boolean operations. 

\item[boolean operators]
The {\tt or}, {\tt and}, {\tt xor} and {\tt not} for the bit atomic type 
in MIL (this corresponds to what is normally called boolean)
are implemented as the logic operations.

\item[random numbers]
This module also contains the rand and srand functions. The {\tt srand}() 
function initializes the random number generator using a seed value. The 
subsequent calls to {\tt rand}() are pseudo random numbers (with the same 
seed the sequence can be repeated).
\end{description}

{\bf The general interpretation for the NIL value is "unknown".
This semantics mean that any operation that receives at least one NIL 
value, will produce a NIL value in the output for sure.} 

The only exception to this rule are the "==" and "!=" equality 
test routines (it would otherwise become rather difficult to test 
whether a value is nil). 

The collection of type conversion routines are included here as well.

@* Module Definition
Most of the primitives are defined here. 
A heuristic is to organize the routines along the types 
(int,lng,sht,bit,oid,flt,...) to reduce number of checks
at function resoluton.
@= mal_isnil
	command isnil(v:@1) : bit = CALCisnil_@1
	comment "is a value nil?";
@-
[Mx bug, space required here]

@mal
module calc;

	@:mal_isnil(any)@
	@:mal_isnil(chr)@
	@:mal_isnil(bit)@
	@:mal_isnil(sht)@
	@:mal_isnil(int)@
	@:mal_isnil(oid)@
	@:mal_isnil(flt)@
	@:mal_isnil(lng)@
	@:mal_isnil(dbl)@
	@:mal_isnil(str)@

@- comparisons { <, <=, ==, !=, >=, > } 
@T 
The {\tt mel\_comp\_ops} Mx macro implements the mel interface to the
arithmetic operations. Note that comparison operators with unequal
operands are already supported in the kernel, but are not nearly as fast,
(because they have to convert values on the fly).  
A heuristic is to organize the routines along the types 
(int,lng,sht,bit,oid,flt,...) to reduce number of checks
at function resoluton. The least interesting one is pushed
first onto the symbol table stack.
Default case excluded for the time being
        @:mal_comp_ops(any::1,any)@
@= mal_eq_ops
	command ==(left:@1, right:@2) : bit = CALCcompEQ@1@2;
	command !=(left:@1, right:@2) : bit = CALCcompNEQ@1@2;
@= mal_comp_ops
	@:mal_eq_ops(@1,@2)@
	command <(left:@1, right:@2) : bit = CALCcompLT@1@2;
	command <=(left:@1, right:@2) : bit = CALCcompLE@1@2;
	command >=(left:@1, right:@2) : bit = CALCcompGE@1@2;
	command >(left:@1, right:@2) : bit = CALCcompGT@1@2;
	command between(val:@1, low:@1, high:@1) : bit = CALCcompBetween@1;
@mal

        @:mal_comp_ops(oid,oid)@
        @:mal_comp_ops(flt,flt)@
        @:mal_comp_ops(flt,dbl)@
        @:mal_comp_ops(dbl,dbl)@

        @:mal_comp_ops(chr,chr)@
        @:mal_comp_ops(chr,sht)@
        @:mal_comp_ops(chr,int)@
        @:mal_comp_ops(chr,lng)@

        @:mal_eq_ops(bit,chr)@
        @:mal_eq_ops(bit,sht)@
        @:mal_eq_ops(bit,int)@
        @:mal_eq_ops(bit,lng)@

        @:mal_comp_ops(sht,chr)@
        @:mal_comp_ops(sht,sht)@
        @:mal_comp_ops(sht,int)@
        @:mal_comp_ops(sht,lng)@

        @:mal_comp_ops(int,chr)@
        @:mal_comp_ops(int,sht)@
        @:mal_comp_ops(int,int)@
        @:mal_comp_ops(int,lng)@

        @:mal_comp_ops(lng,chr)@
        @:mal_comp_ops(lng,sht)@
        @:mal_comp_ops(lng,int)@
        @:mal_comp_ops(lng,lng)@

        @:mal_comp_ops(str,str)@

@- computation of { +, -, *, /, % }
@T 
The {\tt mel\_calc\_ops} Mx macro implements the mel interface to the
arithmetic operations.  The macro expects three parameters, two input
atomic types and a result type. 
@mal
	command %(left:chr, right:int) : int = CALCbinaryMODchrint;
	command %(left:sht, right:int) : int = CALCbinaryMODshtint;
	command %(left:int, right:int) : int = CALCbinaryMODintint;
	command %(left:lng, right:int) : int = CALCbinaryMODlngint;
	command %(left:lng, right:lng) : lng = CALCbinaryMODlnglng;
	command %(left:int, right:chr) : chr = CALCbinaryMODintchr;
	command %(left:int, right:sht) : sht = CALCbinaryMODintsht;
@= mal_calc_ops
	command +(left:@1, right:@2) : @3 = CALCbinaryADD@1@2; 
	command -(left:@1, right:@2) : @3 = CALCbinarySUB@1@2;
	command *(left:@1, right:@2) : @3 = CALCbinaryMUL@1@2;
	command /(left:@1, right:@2) : @3 = CALCbinarycheckDIV@1@2;
@-
The coercions described below ensure that there is never any information loss.
@mal

	@:mal_calc_ops(flt,chr,flt)@
	@:mal_calc_ops(flt,sht,flt)@
	@:mal_calc_ops(flt,int,flt)@
	@:mal_calc_ops(flt,lng,flt)@
	@:mal_calc_ops(flt,flt,flt)@
	@:mal_calc_ops(flt,dbl,dbl)@

	@:mal_calc_ops(dbl,chr,dbl)@
	@:mal_calc_ops(dbl,sht,dbl)@
	@:mal_calc_ops(dbl,int,dbl)@
	@:mal_calc_ops(dbl,lng,dbl)@
	@:mal_calc_ops(dbl,flt,dbl)@
	@:mal_calc_ops(dbl,dbl,dbl)@

	@:mal_calc_ops(oid,oid,oid)@

	@:mal_calc_ops(chr,chr,chr)@
	@:mal_calc_ops(chr,sht,sht)@
	@:mal_calc_ops(chr,int,int)@
	@:mal_calc_ops(chr,lng,lng)@
	@:mal_calc_ops(chr,flt,flt)@
	@:mal_calc_ops(chr,dbl,dbl)@

	@:mal_calc_ops(sht,chr,sht)@
	@:mal_calc_ops(sht,sht,sht)@
	@:mal_calc_ops(sht,int,int)@
	@:mal_calc_ops(sht,lng,lng)@
	@:mal_calc_ops(sht,flt,flt)@
	@:mal_calc_ops(sht,dbl,dbl)@

	@:mal_calc_ops(int,chr,int)@
	@:mal_calc_ops(int,sht,int)@
	@:mal_calc_ops(int,int,int)@
	@:mal_calc_ops(int,lng,lng)@
	@:mal_calc_ops(int,flt,flt)@
	@:mal_calc_ops(int,dbl,dbl)@

	@:mal_calc_ops(lng,chr,lng)@
	@:mal_calc_ops(lng,sht,lng)@
	@:mal_calc_ops(lng,int,lng)@
	@:mal_calc_ops(lng,lng,lng)@
	@:mal_calc_ops(lng,flt,flt)@
	@:mal_calc_ops(lng,dbl,dbl)@

@- binary  operations { max, min, }
@= mal_binary_ops
   	command max(l:@1, r:@1) : @1 = CALCbinaryMAX@2; 
   	command min(l:@1, r:@1) : @1 = CALCbinaryMIN@2;
@-
@mal
	@:mal_binary_ops(chr,chr)@
	@:mal_binary_ops(sht,sht)@
	@:mal_binary_ops(int,int)@
	@:mal_binary_ops(oid,oid)@
	@:mal_binary_ops(flt,flt)@
	@:mal_binary_ops(lng,lng)@
	@:mal_binary_ops(dbl,dbl)@

@- unary operations { abs, inv }
The unary operators include coercion routines for built-in types
@= mal_unary_ops
   	command abs(x:@1) : @1 = CALCunary@1ABS comment "absolute value";
   	command inv(x:@1) : @1 = CALCunarycheck@1INV comment "inverse value (1/x)";
   	command -(x:@1) : @1 = CALCunary@1NEG comment "negative value";
@-
@mal
	@:mal_unary_ops(dbl)@
	@:mal_unary_ops(flt)@
	@:mal_unary_ops(chr)@
	@:mal_unary_ops(sht)@
	@:mal_unary_ops(int)@
	@:mal_unary_ops(lng)@

@-
Coercion functions are typical used in multiplex calls.
@= mal_coercion
   	command @1(x:@2): @1 = CALC@22@1 comment "coercion @2 to @1";
@= scalar_coercion
	@:mal_coercion(@1,oid)@
	@:mal_coercion(@1,bit)@
	@:mal_coercion(@1,sht)@
	@:mal_coercion(@1,int)@
	@:mal_coercion(@1,lng)@
	@:mal_coercion(@1,flt)@
	@:mal_coercion(@1,dbl)@
@mal
	@:mal_coercion(bit,bit)@
	@:mal_coercion(bit,sht)@
	@:mal_coercion(bit,int)@
	@:mal_coercion(bit,lng)@
	@:mal_coercion(bit,flt)@
	@:mal_coercion(bit,dbl)@

	@:scalar_coercion(lng)@
	@:scalar_coercion(int)@
	@:scalar_coercion(sht)@

	@:mal_coercion(oid,oid)@
	@:mal_coercion(oid,lng)@
	@:mal_coercion(oid,sht)@
	@:mal_coercion(oid,int)@

	@:mal_coercion(flt,flt)@
	@:mal_coercion(flt,dbl)@
	@:mal_coercion(flt,sht)@
	@:mal_coercion(flt,int)@
	@:mal_coercion(flt,lng)@

	@:mal_coercion(dbl,dbl)@
	@:mal_coercion(dbl,flt)@
	@:mal_coercion(dbl,sht)@
	@:mal_coercion(dbl,int)@
	@:mal_coercion(dbl,lng)@

	@:mal_coercion(str,sht)@
	@:mal_coercion(str,int)@
	@:mal_coercion(str,lng)@
	@:mal_coercion(str,flt)@
	@:mal_coercion(str,dbl)@

	@:mal_coercion(chr,chr)@
	@:mal_coercion(chr,sht)@
	@:mal_coercion(chr,int)@
	@:mal_coercion(chr,lng)@

	@:mal_coercion(ptr,int)@
	@:mal_coercion(ptr,lng)@

@- boolean { or, xor, and, not }
@mal
	command or(left:bit, right:bit) : bit = CALCbinaryORbit;
	command and(left:bit, right:bit) : bit = CALCbinaryANDbit;
	command xor(left:bit, right:bit) : bit = CALCbinaryXORbit;
	command not(left:bit) : bit = CALCunarybitNOT ;
	command ifthenelse(b:bit, t:any::1, f:any::1) : any::1 = CALCswitchbit;

@- bitwise operations
Cardinal numerical types (inclusing {\tt chr} can be regarded as a bit
array. Specific operations work with this interpretation.
@= mal_bitwise_ops
	command or(left:@1, right:@1) : @1 = CALCbinaryOR@1@1;
	command and(left:@1, right:@1) : @1 = CALCbinaryAND@1@1;
	command xor(left:@1, right:@1) : @1 = CALCbinaryXOR@1@1;
	command not(left:@1) : @1 = CALCunary@1NOT;
	command <<(left:@1,right:int) : @1 = CALCbinaryLSH@1int;
	command >>(left:@1, right:int) : @1 = CALCbinaryRSH@1int;
@mal
	@:mal_bitwise_ops(chr)@
	@:mal_bitwise_ops(sht)@
	@:mal_bitwise_ops(int)@
	@:mal_bitwise_ops(lng)@

@- random numbers
@mal
	command rand () : int = CALCrandint
	comment "return a random number";
	command srand(seed:int) :void = CALCsrandint
	comment "initialize the rand() function with a seed";
@+ Type coercions
The Monet kernel contains a few built-in atomic types together
with useful functions. 
Those accessible at the MAL command level are introduced below.

@= convertCmd
command @1(v:str):@1 = CALCstr2@1;
command str(v:@1):str = CALC@12str;
command @1(v:void) : @1 = CALCnil2@1;

@mal
@:convertCmd(oid)@
@:convertCmd(sht)@
@:convertCmd(int)@
@:convertCmd(lng)@
@:convertCmd(flt)@
@:convertCmd(dbl)@
@:convertCmd(bit)@
@:convertCmd(ptr)@
@:convertCmd(bat)@
@:convertCmd(chr)@

command str(v:void) :str = CALCnil2str;
command void(v:void) :void = CALCnil2void;
command void(v:int) :void = CALCint2void;
command void(v:sht) :void = CALCsht2void;
command void(v:lng) :void = CALClng2void;

command setoid(v:int)= intSetoidImpl;
command setoid(v:lng)= lngSetoidImpl;
command setoid(v:oid)= oidSetoidImpl;
@-
We should also deal with superflous operations, such as int(v:int).
This is a noop operation that should ideally be filtered out with
the code squeezer. [TODO]
@+ OID utility functions
@mal
command newoid() : oid = CALCnewoidBase
comment "Generate a new oid. Equivalent to newoid(0,1)";

command newoid(incr:int) : oid = CALCnewoidInc
comment "Reserves a range of consecutive unique OIDs; returns the 
lowest in range. equivalent to newoid(0,incr)";

command setoid(base:oid) : oid = CALCsetoidInc
comment "Sets the oid range of consecutive unique OIDs; returns the 
lowest in range.";

command setoid() : oid = CALCsetoidBase
comment "Equivalent to setoid(1:oid).";

@+ Example script 
The following example MIL script will do each operation in the
calc module. It can be used for testing and the M2m compiler.

@mil
setoid(oid(20000000));
chr1 := 'a';
chr2 := 'c';
sht1 := sht(2);
sht2 := sht(5);
int1 := 5;
int2 := 2;
flt1 := 2.5;
flt2 := 5.4;
dbl1 := dbl(-2.500001);	       # may also need string since float is default
dbl2 := dbl(54.00456789);      # real and is less significant	
lng1 := lng("-9000000000000"); # string needed because lng doesn't fit in an
lng2 := lng("5400456789");     # int
oid1 := oid(int1);
oid2 := oid(int2);

@:mil_comp_ops('a','z')@
@:mil_comp_ops(sht1,sht2)@
@:mil_comp_ops(int1,int2)@
@:mil_comp_ops(flt1,flt2)@
@:mil_comp_ops(dbl1,dbl2)@
@:mil_comp_ops("abcde","abcdf")@

@:mil_calc_ops(chr1,chr2)@
@:mil_calc_ops(chr1,sht2)@
@:mil_calc_ops(chr1,int2)@
@:mil_calc_ops(chr1,lng2)@
@:mil_calc_ops(chr1,flt2)@
@:mil_calc_ops(chr1,dbl2)@

@:mil_calc_ops(sht1,chr2)@
@:mil_calc_ops(sht1,sht2)@
@:mil_calc_ops(sht1,int2)@
@:mil_calc_ops(sht1,lng2)@
@:mil_calc_ops(sht1,flt2)@
@:mil_calc_ops(sht1,dbl2)@

@:mil_calc_ops(int1,chr2)@
@:mil_calc_ops(int1,sht2)@
@:mil_calc_ops(int1,int2)@
@:mil_calc_ops(int1,lng2)@
@:mil_calc_ops(int1,flt2)@
@:mil_calc_ops(int1,dbl2)@

@:mil_calc_ops(lng1,chr2)@
@:mil_calc_ops(lng1,sht2)@
@:mil_calc_ops(lng1,int2)@
@:mil_calc_ops(lng1,lng2)@
@:mil_calc_ops(lng1,flt2)@
@:mil_calc_ops(lng1,dbl2)@

@:mil_calc_ops(flt1,chr2)@
@:mil_calc_ops(flt1,sht2)@
@:mil_calc_ops(flt1,int2)@
@:mil_calc_ops(flt1,lng2)@
@:mil_calc_ops(flt1,flt2)@
@:mil_calc_ops(flt1,dbl2)@

@:mil_calc_ops(dbl1,chr2)@
@:mil_calc_ops(dbl1,sht2)@
@:mil_calc_ops(dbl1,int2)@
@:mil_calc_ops(dbl1,lng2)@
@:mil_calc_ops(dbl1,flt2)@
@:mil_calc_ops(dbl1,dbl2)@

@:mil_calc_ops(oid1,oid2)@

max(sht1,sht2).print;
max(int1,int2).print;
max(lng1,lng2).print;
max(flt1,flt2).print;
max(dbl1,dbl2).print;

min(sht1,sht2).print;
min(int1,int2).print;
min(flt1,flt2).print;
min(dbl1,dbl2).print;
min(lng1,lng2).print;

abs(sht2).print;
abs(int2).print;
abs(flt2).print;
abs(dbl2).print;
abs(lng2).print;

@:mil_calc_ops(oid1,oid2)@
max(oid1,oid2).print;
min(oid1,oid2).print;

inv(sht2).print;
inv(int2).print;
inv(flt2).print;
inv(dbl2).print;
inv(lng2).print;

(int1% int2).print;
(int1<<int2).print;
(int1>>int2).print;

(int1 or  int2).print;
(int1 and int2).print;
(int1 xor int2).print;
not(int2).print;

bit1 := true;
bit2 := false;
(bit1 or  bit2).print;
(bit1 and bit2).print;
(bit1 xor bit2).print;
not(bit2).print;

srand( 1234 );
rand().print;
quit;

@T
The {\tt mil\_comp\_ops} implements the mil example script comparison 
operations.  It gets two parameters which are the operants for the operations.

@= mil_comp_ops
 (@1 < @2).print;  (@2 < @1).print;  (@1 < @1).print;
(@1 <= @2).print; (@2 <= @1).print; (@1 <= @1).print;
 (@1 = @2).print;  (@2 = @1).print;  (@1 = @1).print;
(@1 >= @2).print; (@2 >= @1).print; (@1 >= @1).print;
 (@1 > @2).print;  (@2 > @1).print;  (@1 > @1).print;
@

@T
The {\tt mil\_calc\_ops} implements the mil example script arithmetic 
operations.  It gets two parameters which are the operants for the operations.

@= mil_calc_ops
(@1 + @2).print;
(@1 - @2).print;
(@1 * @2).print;
(@1 / @2).print;
@

@{
@* Implementation
The implementation below differs from the pre-V5 implementation in
that all strings and pointers are passed by reference, rather than
by value. Since it is unclear in the module implementation whether
such references are static or refer to dynamic allocated space,
we have to be conservative. All deallocation calls should be prepared
and handled by the environment.
For this module this won't be a problem, because we do not change
the string representations.
@h
#ifndef __calc_H__
#define __calc_H__

#include "gdk.h"

#endif /* __calc_H__ */
@}

@{
@c
#include "stdlib.h"
#include "calc.h"
#include "mal.h"
#include "mal_function.h"

/* third param indicates return value if one of the params is nil */ 
@:c_comp_ops(<,LT)@
@:c_comp_ops(<=,LE)@
@:c_comp_ops(==,EQ)@
@:c_comp_ops(!=,NEQ)@
@:c_comp_ops(>=,GE)@
@:c_comp_ops(>,GT)@

@:c_calc_ops(chr,chr,chr)@
@:c_calc_ops(chr,sht,sht)@
@:c_calc_ops(chr,int,int)@
@:c_calc_ops(chr,lng,lng)@
@:c_calc_ops(chr,flt,flt)@
@:c_calc_ops(chr,dbl,dbl)@

@:c_calc_ops(sht,chr,sht)@
@:c_calc_ops(sht,sht,sht)@
@:c_calc_ops(sht,int,int)@
@:c_calc_ops(sht,lng,lng)@
@:c_calc_ops(sht,flt,flt)@
@:c_calc_ops(sht,dbl,dbl)@

@:c_calc_ops(int,chr,int)@
@:c_calc_ops(int,sht,int)@
@:c_calc_ops(int,int,int)@
@:c_calc_ops(int,lng,lng)@
@:c_calc_ops(int,flt,flt)@
@:c_calc_ops(int,dbl,dbl)@

@:c_calc_ops(lng,chr,lng)@
@:c_calc_ops(lng,sht,lng)@
@:c_calc_ops(lng,int,lng)@
@:c_calc_ops(lng,lng,lng)@
@:c_calc_ops(lng,flt,flt)@
@:c_calc_ops(lng,dbl,dbl)@

@:c_calc_ops(flt,chr,flt)@
@:c_calc_ops(flt,sht,flt)@
@:c_calc_ops(flt,int,flt)@
@:c_calc_ops(flt,lng,flt)@
@:c_calc_ops(flt,flt,flt)@
@:c_calc_ops(flt,dbl,dbl)@

@:c_calc_ops(dbl,chr,dbl)@
@:c_calc_ops(dbl,sht,dbl)@
@:c_calc_ops(dbl,int,dbl)@
@:c_calc_ops(dbl,lng,dbl)@
@:c_calc_ops(dbl,flt,dbl)@
@:c_calc_ops(dbl,dbl,dbl)@

@:c_calc_ops(oid,oid,oid)@

#define calc_abs(s) ((s)>0)?(s):-(s)
@:calc_unop(ABS,calc_abs,chr)@
@:calc_unop(ABS,calc_abs,sht)@
@:calc_unop(ABS,calc_abs,int)@
@:calc_unop(ABS,calc_abs,flt)@
@:calc_unop(ABS,calc_abs,dbl)@
@:calc_unop(ABS,calc_abs,lng)@

#define calc_inv(s) (1/(s))
@:check_unop(INV,calc_inv,chr)@
@:check_unop(INV,calc_inv,sht)@
@:check_unop(INV,calc_inv,int)@
@:check_unop(INV,calc_inv,flt)@
@:check_unop(INV,calc_inv,dbl)@
@:check_unop(INV,calc_inv,lng)@

#define calc_neg(s) (-(s))
@:calc_unop(NEG,calc_neg,chr)@
@:calc_unop(NEG,calc_neg,sht)@
@:calc_unop(NEG,calc_neg,int)@
@:calc_unop(NEG,calc_neg,flt)@
@:calc_unop(NEG,calc_neg,dbl)@
@:calc_unop(NEG,calc_neg,lng)@

@:any_binary_minmax(MIN,<=)@
@:any_binary_minmax(MAX,>)@

#define calc_max(s1,s2) ((s1)>(s2))?(s1):(s2)
@:calc_macrobinop(MAX,calc_max,chr)@
@:calc_macrobinop(MAX,calc_max,sht)@
@:calc_macrobinop(MAX,calc_max,int)@
@:calc_macrobinop(MAX,calc_max,oid)@
@:calc_macrobinop(MAX,calc_max,flt)@
@:calc_macrobinop(MAX,calc_max,dbl)@
@:calc_macrobinop(MAX,calc_max,lng)@

#define calc_min(s1,s2) ((s1)<(s2))?(s1):(s2)
@:calc_macrobinop(MIN,calc_min,chr)@
@:calc_macrobinop(MIN,calc_min,sht)@
@:calc_macrobinop(MIN,calc_min,int)@
@:calc_macrobinop(MIN,calc_min,oid)@
@:calc_macrobinop(MIN,calc_min,flt)@
@:calc_macrobinop(MIN,calc_min,dbl)@
@:calc_macrobinop(MIN,calc_min,lng)@

@:calc_binop(MOD,%,chr,int,int)@
@:calc_binop(MOD,%,sht,int,int)@
@:calc_binop(MOD,%,int,int,int)@
@:calc_binop(MOD,%,lng,int,int)@
@:calc_binop(MOD,%,lng,lng,lng)@
@:calc_binop(MOD,%,int,chr,chr)@
@:calc_binop(MOD,%,int,sht,sht)@

@:c_bitwise_ops(chr)@
@:c_bitwise_ops(sht)@
@:c_bitwise_ops(int)@
@:c_bitwise_ops(lng)@

@:c_shift_ops(chr)@
@:c_shift_ops(sht)@
@:c_shift_ops(int)@

str CALCbinaryRSHlngint(lng *ret, lng *val, int *shift) {
    if (*val == lng_nil || *shift == int_nil) {
	*ret = lng_nil;
    } else {
	*ret = *val >> *shift; 
    }
    return MAL_SUCCEED;
}
str CALCbinaryLSHlngint(lng *ret, lng *val, int *shift) {
    if (*val == lng_nil || *shift == int_nil) {
	*ret = lng_nil;
    } else {
	*ret = *val << *shift;
    }
    return MAL_SUCCEED;
}
str CALCbinaryANDbit(bit *retval, bit *v1, bit *v2){
    if (*v1 == FALSE || *v2 == FALSE) {
	*retval = FALSE;
    } else if (*v1 == bit_nil || *v2 == bit_nil) {
	*retval = bit_nil;
    } else {
	*retval = TRUE;
    }
    return MAL_SUCCEED;
}
str CALCbinaryORbit(bit *retval, bit *v1, bit *v2){
    if (*v1 && *v1 != bit_nil) {
	*retval = TRUE;
    } else if (*v2 && *v2 != bit_nil) {
	*retval = TRUE;
    } else if (*v1 == bit_nil || *v2 == bit_nil) {
	*retval = bit_nil;
    } else {
	*retval = *v1 || *v2;
    }
    return MAL_SUCCEED;
}
str CALCbinaryXORbit(bit *retval, bit *v1, bit *v2){
    if (*v1 == bit_nil || *v2 == bit_nil) {
	*retval = bit_nil;
    } else {
	*retval = ((*v1 && *v2 == FALSE) || (*v1 == FALSE && *v2));
    }
    return MAL_SUCCEED;
}
str CALCunarybitNOT(bit *retval, bit *value){
    if (*value == bit_nil) {
	*retval = bit_nil;
    } else {
	*retval = (*value)?FALSE:TRUE;
    }
    return MAL_SUCCEED;
}
str CALCswitchbit(ptr retval, bit *b, ptr v1, ptr v2) {
/* register ptr p; */
	(void) retval; (void) b; (void) v1; (void)v2;/* fool compiler */
	return throwMessage("ifthenelse","not yet implemented\n");
/*
    if (*b == bit_nil) {
	return MAL_SUCCEED;
	p = ATOMnilptr(tpe);
    } else if (*b) {
	p = v1;
    } else {
	p = v2;
    }
    if (ATOMextern(tpe)) {
	*(ptr**) retval = ATOMdup(tpe, p);
    } else {
	memcpy(retval, p, ATOMsize(tpe)); 
    }
    return MAL_SUCCEED;
*/
}

str CALCrandint( int *res ){
    *res = rand();
    return MAL_SUCCEED;
}

str CALCsrandint( int *seed ){
    srand( *seed );
    return MAL_SUCCEED;
}

@T
The {\tt c\_comp} and {\tt c\_comp_ops} macros implement the mil comparison 
operations.

@= any_binary_minmax
str CALCbinary@1any(ptr ret, ptr v1, int t, ptr v2){
	int (*cmp)(ptr,ptr) = BATatoms[t].atomCmp;
	ptr src, nil = ATOMnilptr(t);
	if ((*cmp)(v1, nil) == 0 || (*cmp)(v2, nil) == 0) {
		src = nil;
	} else {
		src = ((*cmp)(v1, v2) @2 0)?v1:v2;
	}
	if (ATOMextern(t)) {
		int s = ATOMlen(t, src);
		str buf = *(str*) ret = (char*) GDKmalloc(s);
		memcpy(buf, src, s);
	} else {
		memcpy(ret, src, ATOMsize(t));
	}
	return MAL_SUCCEED;
}

@= c_comp_op
str CALCcomp@4@2@3(bit *retval, @2 *v1, @3 *v2){
	if (*v1 == @2_nil || *v2 == @3_nil) {
		*retval = bit_nil;
	} else {
		*retval = *v1 @1 *v2;	
	}
	return MAL_SUCCEED;
}
@= c_comp_ops
        @:c_comp_op(@1,oid,oid,@2)@
        @:c_comp_op(@1,flt,flt,@2)@
        @:c_comp_op(@1,flt,dbl,@2)@
        @:c_comp_op(@1,dbl,dbl,@2)@

        @:c_comp_op(@1,chr,chr,@2)@
        @:c_comp_op(@1,chr,sht,@2)@
        @:c_comp_op(@1,chr,int,@2)@
        @:c_comp_op(@1,chr,lng,@2)@

        @:c_comp_op(@1,bit,chr,@2)@
        @:c_comp_op(@1,bit,sht,@2)@
        @:c_comp_op(@1,bit,int,@2)@
        @:c_comp_op(@1,bit,lng,@2)@

        @:c_comp_op(@1,sht,chr,@2)@
        @:c_comp_op(@1,sht,sht,@2)@
        @:c_comp_op(@1,sht,int,@2)@
        @:c_comp_op(@1,sht,lng,@2)@

        @:c_comp_op(@1,int,chr,@2)@
        @:c_comp_op(@1,int,sht,@2)@
        @:c_comp_op(@1,int,int,@2)@
        @:c_comp_op(@1,int,lng,@2)@

        @:c_comp_op(@1,lng,chr,@2)@
        @:c_comp_op(@1,lng,sht,@2)@
        @:c_comp_op(@1,lng,int,@2)@
        @:c_comp_op(@1,lng,lng,@2)@

str CALCcomp@2strstr(bit *retval, str *s1, str *s2){
	if (strNil(*s1) || strNil(*s2)) {
		*retval = bit_nil; 
	} else {
		*retval = (strcmp(*s1,*s2) @1 0);
	}
	return MAL_SUCCEED;
}
str CALCcomp@2any(bit *retval, ptr *v1, int tpe, ptr *v2){
	int (*cmp)(ptr,ptr) = BATatoms[tpe].atomCmp;
	ptr nil = ATOMnilptr(tpe);

	if ((*cmp)(*v1, nil) == 0 || (*cmp)(*v2, nil) == 0) {
		*retval = bit_nil; 
	} else {
		*retval = ((*cmp)( *v1, *v2) @1 0);
	}
	return MAL_SUCCEED;
}
@c
@:c_between_op(chr)@
@:c_between_op(sht)@
@:c_between_op(int)@
@:c_between_op(oid)@
@:c_between_op(flt)@
@:c_between_op(dbl)@
@:c_between_op(lng)@
str CALCcompBetweenstr(bit *retval, str *val, str *low, str *high){
	int val_nil = strNil(*val);
	int low_nil = strNil(*low);
	int high_nil = strNil(*high);

	if (val_nil || (low_nil && high_nil)) {
		*retval = bit_nil;
	} else if (low_nil) {
		*retval = (strcmp(*val,*high) <= 0);
	} else if (high_nil) {
		*retval = (strcmp(*low,*val) <= 0);
	} else {
		*retval = (strcmp(*low,*val) <= 0 && strcmp(*val,*high) <= 0);
	}
	return MAL_SUCCEED;
}
str CALCcompBetweenany(bit *retval, ptr *val, int tpe, ptr *low, ptr *high){
	int (*cmp)(ptr,ptr) = BATatoms[tpe].atomCmp;
	ptr nilptr = ATOMnilptr(tpe);
	int val_nil = ((*cmp)(*val,nilptr) == 0);
	int low_nil = ((*cmp)(*low,nilptr) == 0);
	int high_nil = ((*cmp)(*high,nilptr) == 0);

	if (val_nil || (low_nil && high_nil)) {
		*retval = bit_nil;
	} else if (low_nil) {
		*retval = ((*cmp)(*val,*high) <= 0);
	} else if (high_nil) {
		*retval = ((*cmp)(*low,*val) <= 0);
	} else {
		*retval = ((*cmp)(*low,*val) <= 0 && (*cmp)(*val,*high) <= 0);
	}
	return MAL_SUCCEED;
}

@= c_isnil
str CALCisnil_@1(bit *retval, @1 val) {
	*retval = (val == @1_nil);
	return MAL_SUCCEED;
}
str CALCnil2@1(@1 *retval, ptr val){
	(void) val;/* fool compiler */
	memcpy(retval, ATOMnilptr(TYPE_@1), ATOMsize(TYPE_@1));
	return MAL_SUCCEED;
}
@c
@:c_isnil(bit)@
@:c_isnil(chr)@
@:c_isnil(sht)@
@:c_isnil(int)@
@:c_isnil(oid)@
@:c_isnil(flt)@
@:c_isnil(lng)@
@:c_isnil(dbl)@
@:c_isnil(ptr)@
@:c_isnil(bat)@

str CALCisnil_str(bit *retval, str *val) {
	*retval = (*val == str_nil);
	return MAL_SUCCEED;
}
str CALCstr2nil(str *retval, str *val) {
	(void)val; /* fool compiler */
	*retval = ATOMnilptr(TYPE_str);
	return MAL_SUCCEED;
}

str CALCisnil_any(bit *retval, ptr *val, int tpe) {
	ptr nilval = ATOMnilptr(tpe);
	*retval = (ATOMcmp(tpe, nilval, *val) == 0);
	return MAL_SUCCEED;
}
@= c_between_op
str CALCcompBetween@1(bit *retval, @1 *v, @1 *low, @1 *high){
	if (*v == @1_nil || (*low == @1_nil && *high == @1_nil)) {
		*retval = bit_nil;
	} else if (*low == @1_nil) {
		*retval = (*v <= *high);
	} else if (*high == @1_nil) {
		*retval = (*low <= *v);
	} else {
		*retval = (*low <= *v) && (*v <= *high);	
	}
	return MAL_SUCCEED;
}
@T
The {\tt c\_calc\_ops} implement the arithmetic operations on the given type.
The {\tt c\_calc\_ops} macro gets three arguments, two input types and a 
result type. 

@= c_calc_ops
@:calc_binop(ADD,+,@1,@2,@3)@
@:calc_binop(SUB,-,@1,@2,@3)@
@:calc_binop(MUL,*,@1,@2,@3)@
@:check_binop(DIV,/,@1,@2,@3)@
@

@= calc_unop
str CALCunary@3@1(@3 *res , @3 *a ) {
#ifdef DEBUG
	printf( "CALCunary@3@1\n");
#endif
   if (*a == @3_nil) {
       *res = @3_nil;
   } else {   
       *res = @2 (*a);
   }
   return(MAL_SUCCEED);
}
@

@= check_unop
str CALCunarycheck@3@1(@3 *res , @3 *a ) {
#ifdef DEBUG
	printf( "CALCunary@3@1\n");
#endif
   if (*a == 0 || *a == @3_nil) {
	*res = @3_nil;
   } else {
   	*res = @2 (*a);
   }
   return(MAL_SUCCEED);
}
@

@= calc_binop
str CALCbinary@1@3@4(@5 *res, @3 *a, @4 *b ) {
#ifdef DEBUG
	printf( "CALCbinary@1@3@4\n");
#endif
   if (*a == @3_nil || *b == @4_nil) {
	*res = @5_nil;
   } else {
   	*res = ((@5)(*a)) @2 ((@5)(*b));
   }
   return(MAL_SUCCEED);
}
@

@= check_binop
str CALCbinarycheck@1@3@4(@5 *res, @3 *a, @4 *b ) {
#ifdef DEBUG
	printf( "CALCbinarycheck@1@3@4\n");
#endif
   if (*a == @3_nil || *b == 0 || *b == @4_nil) {
	*res = @5_nil;
   } else {
   	*res = ((@5)(*a)) @2 ((@5)(*b));
   }
   return(MAL_SUCCEED);
}
@


@= c_bitwise_ops
@:calc_binop(OR,|,@1,@1,@1)@
@:calc_binop(AND,&,@1,@1,@1)@
@:calc_binop(XOR,^,@1,@1,@1)@
@:calc_unop(NOT,~,@1)@

@= c_shift_ops
@:calc_binop(LSH,<<,@1,int,@1)@
@:calc_binop(RSH,>>,@1,int,@1)@

@= calc_macrobinop
str CALCbinary@1@3(@3 *res , @3 *a, @3 *b ) {
#ifdef DEBUG
	printf( "CALCbinary@1@3\n");
#endif
   if (*a == @3_nil || *b == @3_nil) {
	*res = @3_nil;
   } else {
   	*res = @2 (*a,*b);
   }
   return(MAL_SUCCEED);
}
@
Coercions do not check on information loss
@= mal_coercion_impl2
str CALC@22@1(@1 *res, @2 *a)
{
	char buf[1024];
	sprintf(buf,"%@3",*a);
	*res = (@1) GDKstrdup(buf);
	return MAL_SUCCEED;
}
@-
@= mal_coercion_impl
str CALC@22@1(@1 *res, @2 *a)
{
	*res= (@1) *a;
	return MAL_SUCCEED;
}
@-
@c
	@:mal_coercion_impl(bit,bit)@
	@:mal_coercion_impl(bit,sht)@
	@:mal_coercion_impl(bit,int)@
	@:mal_coercion_impl(bit,lng)@
	@:mal_coercion_impl(bit,flt)@
	@:mal_coercion_impl(bit,dbl)@

	@:mal_coercion_impl(lng,oid)@
	@:mal_coercion_impl(lng,chr)@
	@:mal_coercion_impl(lng,bit)@
	@:mal_coercion_impl(lng,sht)@
	@:mal_coercion_impl(lng,int)@
	@:mal_coercion_impl(lng,lng)@
	@:mal_coercion_impl(lng,flt)@
	@:mal_coercion_impl(lng,dbl)@

	@:mal_coercion_impl(sht,oid)@
	@:mal_coercion_impl(sht,bit)@
	@:mal_coercion_impl(sht,chr)@
	@:mal_coercion_impl(sht,sht)@
	@:mal_coercion_impl(sht,int)@
	@:mal_coercion_impl(sht,lng)@
	@:mal_coercion_impl(sht,flt)@
	@:mal_coercion_impl(sht,dbl)@

	@:mal_coercion_impl(int,oid)@
	@:mal_coercion_impl(int,bit)@
	@:mal_coercion_impl(int,chr)@
	@:mal_coercion_impl(int,ptr)@
	@:mal_coercion_impl(int,sht)@
	@:mal_coercion_impl(int,int)@
	@:mal_coercion_impl(int,lng)@
	@:mal_coercion_impl(int,flt)@
	@:mal_coercion_impl(int,dbl)@

	@:mal_coercion_impl(oid,oid)@
	@:mal_coercion_impl(oid,lng)@
	@:mal_coercion_impl(oid,sht)@
	@:mal_coercion_impl(oid,int)@

	@:mal_coercion_impl(flt,flt)@
	@:mal_coercion_impl(flt,dbl)@
	@:mal_coercion_impl(flt,sht)@
	@:mal_coercion_impl(flt,int)@
	@:mal_coercion_impl(flt,lng)@

	@:mal_coercion_impl(dbl,dbl)@
	@:mal_coercion_impl(dbl,flt)@
	@:mal_coercion_impl(dbl,sht)@
	@:mal_coercion_impl(dbl,int)@
	@:mal_coercion_impl(dbl,lng)@

	@:mal_coercion_impl(chr,chr)@
	@:mal_coercion_impl(chr,sht)@
	@:mal_coercion_impl(chr,int)@
	@:mal_coercion_impl(chr,lng)@

	@:mal_coercion_impl(ptr,int)@

str CALClng2ptr(ptr *res, lng *a)
{
	(void) res; (void) a; /* fool compiler */
	return MAL_SUCCEED;
}
str CALCptr2lng(lng *res, ptr *a)
{
	(void) res; (void) a; /* fool compiler */
	return MAL_SUCCEED;
}
@-
Old stuff, probably wrong
	@:mal_coercion_impl2(str,sht,d)@
	@:mal_coercion_impl2(str,int,d)@
	@:mal_coercion_impl2(str,lng,D)@
	@:mal_coercion_impl2(str,flt,f)@
	@:mal_coercion_impl2(str,dbl,f)@
@+ The Coercion implementation
The conversion routines are relatively easy to define.
@= convertImpl

str CALCstr2@1(@1 *ret, str *val){
	int l = sizeof(@1);
	(void) @1FromStr(*val, &l, &ret);
	return MAL_SUCCEED;
}
str CALC@12str(str *ret, @1 *val){
	int l=0;

	if(*ret) l=strlen(*ret);
	(void) @1ToStr(ret,&l,val);
	return MAL_SUCCEED;
}
str @1FromvoidImpl(@1 *ret, void *val){
	(void) val; /* fool compiler */
	memcpy(ret, ATOMnilptr(TYPE_@1), ATOMsize(TYPE_@1));
	return MAL_SUCCEED;
}
@-
Strings have to be dealt with differently, because
we recieve a pointer to the string directly.
To make it work properly, we need a call be reference
in those places where we leave a result behind.
@c
str voidFromStrImpl(void *ret, str val){
	(void) val; /* fool compiler */
	memcpy(ret, ATOMnilptr(TYPE_void), ATOMsize(TYPE_void));
	return MAL_SUCCEED;
}
str CALCnil2str(str *ret, void *val){
	(void) val; /* fool compiler */
	*ret = ATOMnilptr(TYPE_str);
	return MAL_SUCCEED;
}
str CALCstr2oid(oid *ret, str *val){
	int l = strlen(*val);
	(void) OIDfromStr(*val, &l, (ptr) ret);
	return MAL_SUCCEED;
}
str CALCoid2str(str *ret, oid *val){
	int l= sizeof(oid);
	(void) OIDtoStr(ret,&l, val);
	return MAL_SUCCEED;
}
str CALCnil2void(oid *ret, ptr *val){
	(void) val; /* fool compiler */
	*ret = oid_nil;
	return MAL_SUCCEED;
}
str CALClng2void(oid *ret, lng *val){
	*ret = *val;
	return MAL_SUCCEED;
}
str CALCsht2void(oid *ret, sht *val){
	*ret = *val;
	return MAL_SUCCEED;
}
str CALCint2void(oid *ret, int *val){
	*ret = *val;
	return MAL_SUCCEED;
}
str oidFromoidImpl(oid *ret, oid *val){
	*ret= *val;
	return MAL_SUCCEED;
}
str oidFromvoidImpl(oid *ret, void *val){
	(void) val; /* fool compiler */
	memcpy(ret, ATOMnilptr(TYPE_oid), ATOMsize(TYPE_oid));
	return MAL_SUCCEED;
}
@:convertImpl(sht)@
@:convertImpl(int)@
@:convertImpl(lng)@
@:convertImpl(flt)@
@:convertImpl(dbl)@
@:convertImpl(bit)@
@:convertImpl(ptr)@
@:convertImpl(bat)@
@:convertImpl(chr)@
@-
@= setoidCode
str @1SetoidImpl(str *ret, @1 *v){
	(void) ret; /* fool compiler */
	OIDbase(*v);
	return MAL_SUCCEED;
}
@c
@:setoidCode(oid)@
@:setoidCode(lng)@
@:setoidCode(int)@
@-
Type conversion template. Only allowed then no information is lost.

@= coercionImpl
str @1From@2Impl(@1 *res, @2 *val){
	*res = *val;
	return MAL_SUCCEED;
}
@c
@:coercionImpl(lng,oid)@
@:coercionImpl(lng,int)@
@:coercionImpl(lng,sht)@
@:coercionImpl(lng,bit)@
@:coercionImpl(int,sht)@
@:coercionImpl(int,bit)@
@:coercionImpl(dbl,flt)@
@:coercionImpl(oid,lng)@
@:coercionImpl(oid,int)@
@:coercionImpl(oid,sht)@

str shtFromlngImpl(sht *res, lng *val){
	/* perform a range check !! */
	if( *val<0 ||*val >255)
		return throwMessage("calc.coercion", "error lng->sht");
	*res = *val;
	return MAL_SUCCEED;
}
str shtFromintImpl(sht *res, int *val){
	/* perform a range check !! */
	if( *val<0 ||*val >255)
		return throwMessage("calc.coercion", "error int->sht");
	*res = *val;
	return MAL_SUCCEED;
}

@+ Value, Types and Variables
The routines below implement the OID utility functions.
@c
str CALCnewoidBase(oid *res){
	*res= OIDnew(1);
	return MAL_SUCCEED;
}
str CALCnewoidInc(oid *res, int *inc){
	if( *inc <=0)
		*res= OIDnew(1);
	else{
		*res= OIDnew(*inc);
	}
	return MAL_SUCCEED;
}
str CALCsetoidBase(oid *res){
	*res= OIDbase(1);
	return MAL_SUCCEED;
}
str CALCsetoidInc(oid *res,oid *inc){
	*res= OIDbase(*inc);
	return MAL_SUCCEED;
}
@}
