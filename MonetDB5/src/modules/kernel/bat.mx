@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2004 CWI.
@' All Rights Reserved.
@'
@' Contributor(s):
@' 		Martin Kersten <Martin.Kersten@cwi.nl>
@' 		Peter Boncz <Peter.Boncz@cwi.nl>
@' 		Niels Nes <Niels.Nes@cwi.nl>
@' 		Stefan Manegold  <Stefan.Manegold@cwi.nl>

@f bat
@v 2.0
@a Peter Boncz, M.L. Kersten
@* Binary Association Tables
@T
This module contains the commands and patterns to manage Binary
Association Tables (BATs). The relational operations you can execute
on BATs have the form of a neat algebra, described in algebra.mx

But a database system needs more that just this algebra, since often it
is crucial to do table-updates (this would not be permitted in a strict
algebra).

All commands needed for BAT updates, property management,
search accellerator management, basic I/O, persistency, and storage options
can be found in this module.

Type parameters are represented by short integers. The MAL frontend
defines constants to simplify the mapping from type identifier to value.

All parameters to the modules are passed by reference.
In particular, this means that string values are passed to the module
layer as (str *)
and we have to de-reference them before entering the gdk library.
(Actual a design error in gdk to differentiate passing int/str)
This calls for knowlegde on the underlying BAT typs`s
@= derefStr
{int _tpe= ATOMstorage(@1->@2type);
 if( _tpe == TYPE_str || _tpe > TYPE_str )
 { if(@3== 0 || *(str*)@3==0) @3= str_nil;
   else @3 = *(str *)@3; 
}}
@-
The code speaks for itself
@mal

module bat;

command bat(ht:int, tt:int) :bat[:any,:any] 
address BKCnewBat
comment "Creates a new empty transient BAT with 
	head- and tail-types as indicated.";

command bat(ht:int, tt:int, size:int) 
		:bat[:any,:any] 
address BKCnewBATint
comment "Creates a new empty BAT, directly 
	allocating for 'size' elements.";

command bat(ht:int, tt:int, size:lng) 
	:bat[:any,:any] 
address BKCnewBATlng
comment "Creates a new empty BAT, directly 
	allocating for 'size' elements.";

command reverse(b:bat[:any$1,:any$2]) 
		:bat[:any$2,:any$1] 
address BKCreverse
comment "Returns the reverse view of a BAT (head 
	is tail and tail is head). BEWARE  no 
	copying is involved; input and output 
	refer to the same object!";

command mirror(b:bat[:any$1,:any]) 
		:bat[:any$1,:any$1] 
address BKCmirror
comment "Returns the head-mirror image of a BAT 
	(two head columns).";

command convert(b:bat[:any$1,:any$2] ) 
	:bat[:any$1,:any$2] 
address BKCconvert
comment "Convert the contents of a BAT from 
	little-endian to big-endian and vice versa.
	 THIS command SHOULD NOT BE USED FROM MAL!
	DANGEROUS! DEBUGGING PURPOSES ONLY!";

command order(b:bat[:any$1,:any$2]) 
		:bat[:any$1,:any$2] 
address BKCorder
comment "Sorts the BAT itself, in place. ";

command revert(b:bat[:any$1,:any$2]) 
		:bat[:any$1,:any$2] 
address BKCrevert
comment "Puts all BUNs in a BAT in reverse order.
	(Belongs to the BAT sequence module)";

@+ BAT properties
@T
Properties of BATs not necessarily require loading the BAT completely.
The BAT identifier can be used to access the descriptors.
These properties can be inspected with the {\tt info(BAT[:any,:any]) :bat[str,str] } c
ommand:
{\small
\begin{verbatim}
> car_age.info.print;
#---------------------------------#
# BAT:               tmp_31       #
# (str)              (str)        #
#---------------------------------#
[ "batId",           "car_age"    ] # logical bat name
[ "batCacheid",      "26"         ] # BBP index
[ "batParentid",     "0"          ] # set if a BAT is a view
[ "head",            "void"       ] # physical head-type
[ "tail",            "int"        ] # physical tail-type
[ "batPersistence",  "persistent" ] # transient/session/persistent
[ "batRestricted",   "updatable"  ] # read-only/append-only/updatable
[ "batDirty",        "clean"      ] # clean/dirty
[ "batRefcnt",       "1"          ] # physical refcount
[ "batLRefcnt",      "1"          ] # logical refcount (total)
[ "batPlevel",       "1"          ] # logical refcount (persistent part)
[ "batSet",          "0"          ] # [head,tail] combinations are unique
[ "batCopiedtodisk", "1"          ] # has been saved or not
\end{verbatim}
}

Per column, a number of properties are kept. We only show the head-properties; the tail properties
have the first character of their named replaced by 't' ({\tt sorted}, {\tt tdense}, etc.):
{\small
\begin{verbatim}
[ "hsorted",         "1"          ] # column is known to be sorted
[ "hdense",          "1"          ] # column is known to be densely ascended
[ "hseqbase",        "0@0"        ] # if densely ascending (i.e. 0@0, 1@0, @,0, ...):first value
[ "hacctype",        "null"       ] # name of user-defined accelerator
[ "hindex",          "absent"     ] # name of built-in accelerator:hash or index (T-tree)
\end{verbatim}
}

As described in the @[<a href="www/gdk.html#mod_1_3_0">GDK Technical Reference</a>@,
BATs store their data in one to five heaps, of which at least one called {\tt batBuns}
is present always. For each column type that is {\em variable-sized} - like {\tt str} - another
heap might be present ({\tt hheap} and {\tt theap}). If a column has a user-defined search
accelerator, more heaps may be present (({\tt haccelerator} and {\tt taccelerator}).

{\small
\begin{verbatim}
[ "batBuns.free",    "400004"     ] # occupied size in bytes
[ "batBuns.size",    "400012"     ] # allocated size in bytes
[ "batBuns.maxsize", "400012"     ] # reserver virtual memory in bytes
[ "batBuns.storage", "malloced"   ] # malloced/mmap/priv
\end{verbatim}
}

Properties steer the algorithms that Monet uses to execute algebra command. For instance,
the {\tt find(bat[:any\$1,:any\$2] b, :any\$1) :any\$2} that looks up a tail value by head,
uses binary search if and only if the head column is sorted (in other cases, hash-lookup
and scan are execution options).

Sometimes new (extension) code contains bugs in the property management, leaving false
properties on produced BATs. You can imagine that later on, this leads to additional
bugs, as e,g, the binary search algorithms will yield erroneous results on a non-sorted
sequence.

[OBSOLETE]
To make problem detection easier, the MIL interpreter contains property checking code,
that is set with via the  {\tt debugmask(int)} command:
\begin{description}
\item[2] {\tt debugmask(debugmask() and 2)} causes that all properties on
newly created BATs to be checked. You must realize that finding out that a column is sorted
({\tt hsorted/tsorted}) costs a full scan, and finding out that it contains unique values
({\tt hkeyed/tkeyed}) costs a full scan plus the creation of a full hash index. 
\item[8] {\tt debugmask(debugmask() and 8)} causes that all properties on
{\bf all} BATs handled by the MIL interpreter to be checked. This will catch all property errors.
\end{description}

By default, both bits in the {\tt debugmask} are off, which gives fastest performance.

@mal
command info ( b:bat[:any,:any]) :bat[:str,:str] 
address BKCinfo
comment "Produce a BAT containing info about a BAT 
	in [attribute,value] format. It contains 
	all properties of the BAT record. See the 
	BAT documentation in GDK for more information.";

command getCapacity(b:bat[:any,:any]):lng 
address BKCgetCapacity
comment "Returns the current allocation size (in 
	max number of elements) of a BAT.";

command getHeadType(b:bat[:any,:any] ) :str 
address BKCgetHeadType
comment "Returns the type of the head column of 
	a BAT, as an integer type number.";

command getTailType( b:bat[:any,:any] ) :str 
address BKCgetTailType 
comment "Returns the type of the tail column of 
	a BAT, as an integer type number.";

command getRole ( bid:bat[:any,:any] ) :str 
address BKCgetRole
comment "Returns the rolename of the head column 
	of a BAT.";

command setKey( b:bat[:any$1,:any$2], mode:bit) 
		:bat[:any$1,:any$2] 
address BKCsetkey
comment "Sets the 'key' property of the head 
	column to 'mode'. In 'key' mode, the kernel 
	will silently block insertions that cause 
	a duplicate entries in the head column.
	 KNOWN BUG:when 'key' is set to TRUE, this 
	function does not automatically eliminate 
	duplicates. Use b := b.kunique;";

command isaKey( b:bat[:any,:any]) :bit 
address BKCgetKey
comment "return whether the head column of a BAT 
	is unique (key).";

command setSet( b:bat[:any$1,:any$2], mode:bit) 
	:bat[:any$1,:any$2] 
address BKCsetSet
comment "Sets the 'set' property on this BAT to 
	'mode'. In 'set' mode, the kernel will 
	silently block insertions that cause a 
	duplicate BUN [head,tail] entries
	in the BAT.
	KNOWN BUG:when 'set' is set to TRUE, this 
	function does not automatically
	 eliminate duplicates. Use b := b.sunique;
	 Returns the BAT itself.";

command isaSet( b:bat[:any,:any]) :bit = BKCisaSet
comment "return whether the BAT mode is set to unique.";

command setAccess( b:bat[:any$1,:any$2], mode:str) 
	:bat[:any$1,:any$2] 
address BKCsetAccess
comment "Try to change the update access priviliges 
	to this BAT. Mode:
	 r[ead-only]      - allow only read access.
	 a[append-only]   - allow reads and update.
	 w[riteable]      - allow all operations.
	BATs are updateable by default. On making 
	a BAT readonly, all subsequent updates 
	fail with an error message.Returns the 
	BAT itself.";

command setAppendMode( b:bat[:any$1,:any$2])
		:bat[:any$1,:any$2] 
address BKCsetAppendMode
comment "Change access privilige of BAT to 
	append only";

command setReadMode( b:bat[:any$1,:any$2]) 
	:bat[:any$1,:any$2] 
address BKCsetReadMode
comment "Change access privilige of BAT to 
	read only";

command setWriteMode( b:bat[:any$1,:any$2])
	:bat[:any$1,:any$2] 
address BKCsetWriteMode
comment "Change access privilige of BAT to 
	read and write";

command getAccess( b:bat[:any,:any]):chr 
address BKCgetAccess
comment "return the access mode attached to 
	this BAT as a character.";

command hasAppendMode( b:bat[:any,:any]):bit 
address BKChasAppendMode
comment "return true if to this BAT is 
	append only.";

command hasWriteMode( b:bat[:any,:any]):bit 
address BKChasWriteMode
comment "return true if to this BAT is read 
	and write.";

command hasReadMode( b:bat[:any,:any]):bit 
address BKChasReadMode
comment "return true if to this BAT is 
	read only.";


command getSequenceBase( b:bat[:void,:any]):oid 
address BKCgetSequenceBase
comment "Get the sequence base for the void 
	column of a BAT.";
command getSequenceBase( b:bat[:oid,:any]):oid 
address BKCgetSequenceBase;

command setSequenceBase( b:bat[:void,:any$1], 
		seqbase:oid):int
address BKCsetSequenceBase
comment "Set the sequence base for the void 
	column of a BAT.";
command setSequenceBase( b:bat[:oid,:any$1], 
	seqbase:oid):int
address BKCsetSequenceBase;

command setSorted(b:bat[:any,:any]) :bit 
address BKCsetSorted
comment "Assure BAT is ordered on head.";

command isSorted(b:bat[:any,:any]) :bit 
address BKCisSorted
comment "Returns whether a BAT is ordered on head or not.";
command isSortedReverse(b:bat[:any,:any]) :bit 
address BKCisSortedReverse
comment "Returns whether a BAT is ordered on head or not.";

command getBatSize(b:bat[:any,:any]) :str 
address BKCbatsize_str;
command getBatSize(b:bat[:any,:any]) :int 
address BKCbatsize
comment "A version of BATsize that does 
	not require loading the BAT.";

@- BAT updates
Update commands come in many disguises.  Note that we don;t return
the BAT id, but merely a success/failure code.
@mal
command insert(b:bat[:any$1,:oid], 
		src:bat[:any$1,:void])
	:bat[:any$1,:any$2] 
address BKCinsert_bat
comment "Insert all BUNs of the second BAT 
	into the first. This case should be 
	removed, because it is a hack for SQL";

command insert(b:bat[:any$1,:any$2], 
		src:bat[:any$1,:any$2])
		:void 
address BKCinsert_bat
comment "Insert all BUNs of the second BAT 
	into the first.";

command insert(b:bat[:any$1,:any$2], 
		h:any$1, t:any$2)
	:void 
address BKCinsert_bun
comment "Insert one BUN[h,t] in a BAT.";

command insert(b:bat[:void,:any$1],
		v:any$1):void 
address BKCinsert_void_bun
comment "Insert a value in a 'void' bat";

command replace(b:bat[:any$1, :any$2], 
		src:bat[:any$1,:any$2])
	:bat[:any$1,:any$2] 
address BKCreplace_bat
comment "Perform replace for all BUNs of 
	the second BAT into the first.";

command replace(b:bat[:any$1, :any$2], 
		h:any$1, t:any$2)
	:bat[:any$1,:any$2] 
address BKCreplace_bun
comment "Replace the tail value of one BUN 
	that has some head value.";

# The SQL append/replace commands

command append( i:bat[:oid,:any$1],
		u:bat[:oid,:any$1])
	:bat[:oid,:any$1]
address BKCoid_bat_append_oid_bat_wrap
comment "append the content of u to i 
	(renumbers u-oids' to unique numbers)";

command append(i:bat[:oid,:any$1], u:any$1):bat[:oid,:any$1]
address BKCoid_bat_append_val_wrap
comment "append the value u to i";

command append( i:bat[:void,:any$1], 
		u:bat[:void,:any$1] )
	:bat[:void,:any$1]
address BKCbat_append_void_bat_wrap
comment "append the content of u to i";

command append( i:bat[:void,:any$1], 
		u:bat[:oid,:any$1])
	:bat[:void,:any$1]
address BKCbat_append_oid_bat_wrap
comment "append the content of u to i";

command append( i:bat[:void,:any$1], 
		u:any$1)
	:bat[:void,:any$1]
address BKCbat_append_val_wrap
comment "append the value u to i";

command append(i:bat[:oid,:void], 
		u:bat[:oid,:void])
	:bat[:oid,:void]
address BKCbat_append_oidvoid_bat_wrap
comment "Special case append for empty bats,
	 works around impossible void,void case";

command replace( o:bat[:void,:any$1], 
		d:bat[:oid,:any$1])
	:bat[:void,:any$1]
address BKCbat_replace_oid_bat_wrap
comment "inplace replace values on the 
	given locations";

#end SQL enhancement

command destroy(b:bat[:any,:any]):void
address BKCdestroy;
command destroy(s:str,immediately:bit):void 
address BKCdestroy_bat
comment "Schedule bat for removal upon session 
	commit";

command delete(b:bat[:any$1, :any$2], 
		h:any$1, t:any$2)
	:void 
address BKCdelete_bun
comment "Delete one specific BUN.";

command delete(b:bat[:any$1, :any$2], 
		h:any$1)
	:void 
address BKCdelete_head
comment "Delete all BUNs with a certain head 
	value.";

command clear(b:bat[:any$1, :any$2]) :void 
address BKCdelete_all
comment "Delete all BUNs in a BAT.";

command delete(b:bat[:any$1, :any$2]) :void 
address BKCdelete_all
comment "Delete all BUNs in a BAT.";

command delete(b:bat[:any$1, :any$2], 
		src:bat[:any$1,:any])
	:void 
address BKCdelete_bat_head
comment "Delete from the first BAT all BUNs 
	with a head value that is in the 
	second.";

command deleteBuns(b:bat[:any$1, :any$2], 
		src:bat[:any$1,:any$2])
	:void 
address BKCdelete_bat_bun
comment "Delete from the first BAT all BUNs 
	with a corresponding BUN in the second.";

command getAlpha(b:bat[:any$1,:any$2])
	:bat[:any$1,:any$2] 
address BKCgetAlpha
comment "Obtain the list of BUNs added";
command getDelta(b:bat[:any$1,:any$2])
	:bat[:any$1,:any$2] 
address BKCgetDelta
comment "Obtain the list of BUNs deleted";
@- BAT I/O, Persistency
@T
The BAT Buffer Pool (BBP) manages all known BATs. It administers
their logical and physical names and a reference count. BATs can
either be {\em persistent} or {\em transient}. The BBP also manages
swapping on a BAT level:a BAT is either loaded entirely or not.
MAL variables of type {\tt bat} can either be loaded or not. When
the Monet server is started, all BATs are swapped out. If an unloaded
bat-variable is used as an operand in a command, it is automatically
loaded.  The BBP applies a simple but effective LRU based swapping
algorithm. BATs have a {\em heat}, which drops over time, and is
increased when a BAT is used by some command.  If the size of the
allocated arena gets to be large, BATs may be swapped out.

Note, we should move old-fashioned mil operator definitions
into a separate module.

@mal
command setName ( b:bat[:any$1,:any$2] , 
		s:str) 
	:bat[:any$1,:any$2] 
address BKCsetName
comment "Give a logical name to a BAT. ";

command getName ( b:bat[:any,:any]) :str 
address BKCgetBBPname
comment "Gives back the logical name of a BAT.";

command setRole( b:bat[:any$1,:any$2], 
		h:str, t:str)
	:bat[:any$1,:any$2]
address BKCsetRole
comment "Give a logical name to the columns of 
	a BAT.";

command setColumn( b:bat[:any$1,:any$2],
		t:str)
	:bat[:any$1,:any$2] 
address BKCsetColumn
comment "Give a logical name to the tail column 
	of a BAT.";
command setColumn( b:bat[:any$1,:any$2],
		h:str, t:str)
	:bat[:any$1,:any$2]
address BKCsetColumns
comment "Give both columns of a BAT a new name.";


command isTransient( b:bat[:any,:any]) :bit 
address BKCisTransient;
command setTransient( b:bat[:any,:any]) :bit 
address BKCsetTransient
comment "Make the BAT transient.  Returns 
	boolean which indicates if the
BAT administration has indeed changed.";

command isPersistent( b:bat[:any,:any]) :bit 
address BKCisPersistent;
command setPersistent( b:bat[:any,:any]) :bit 
address BKCsetPersistent
comment "Make the BAT persistent.  Returns 
	boolean which indicates if the
BAT administration has indeed changed.";

command save(nme:bat[:any,:any]) :bit 
address BKCsave2;

command save(nme:str) :bit 
address BKCsave
comment "Save a BAT to storage, if it was 
	loaded and dirty.  Returns whether 
	IO was necessary.  Please realize that 
	calling this function violates the 
	atomic commit protocol!!";


command load(name:str) :bat[:any,:any] 
address BKCload
comment "Load a particylar bat from disk";

command unload(name:str) :bit 
address BKCunload
comment "Swapout a BAT to disk. Transient BATs 
	can also be swapped out. Returns 
	whether the unload indeed happened. ";

command isCached(b:bat[:any,:any]):bit 
address BKCisCached
comment "Bat is stored in main memory.";

command setHot(name:str) :void 
address BKChot
comment "Makes a BAT very hot for the BBP. The 
	chance of being chosen for swapout is 
	small, afterwards.  Returns the BAT itself.";

command heat(name:str) :lng 
address BKCheat
comment "Return the current BBP heat (LRU stamp)";

command setCold(nme:str) :void 
address BKCcold
comment "Makes a BAT very cold for the BBP. The 
	chance of being choses for swapout is big,
	afterwards.  Returns the BAT itself.";

command setCold(b:bat[:any,:any]) :void 
address BKCcoldBAT;
command setHot(b:bat[:any,:any]) :void 
address BKChotBAT;

@- Heap Specific Commands
@T
BATs are stored in memory in a number of Heap objects. A heap is nothing
more than a contiguous range of memory. Bats are saved to disk by just writing
away their image. This approach without pointer swizzling makes it possible
to either load an image into an alloced range of memory (STORE\_MEM), or
memory-map (STORE\_MMAP) an image into virtual memory.

The heap images of a BAT are stored in the {\tt $MONETHOME/dbfarm/$DB/bat/}
directory.  For each bat X, the following heaps are stored:
\begin{description}
\item[X.buns] an array with all the fixed-size parts of all BUNs.
\item[X.hheap] if the head column contains a variable sized atoms (e.g. str),
then the fixed-size part of a BUN contains an integer byte-offset into
the heap. String values themself are stored in this the X.hheap.
\item[X.theap] similar to X.hheap, but for the tail column.
\item[X.hacc]. On each column, you might create {\em persistent accelerator
structures}. Monet has two builtin accelerators (index and hash), but they
are normally constructed on the fly. They are transient. Only hash-tables
you can be made persistent. User-defined accelerators are always persistent.
Only one persistent accelerator can exist per head column. It is stored in
the X.hacc heap.
\item[X.tacc] similar to X.hacc, but for the tail column.
\end{description}

Each of these heaps can be {\bf compressed} using the unix {\tt compress}
utility forming a X.ext.Z file. Monet wil automatically decompress it
upon load. Compressed heaps cannot be memory mapped.

A final file present for each t in the BAT directory is:
\begin{description}
\item[X.desc] the BAT descriptor. Stores most of the properties of a BAT.
\end{description}
@
For more technical information on BATs, we refer to the
@[<a href="http://www.cwi.nl/~monet/www/scw/gdk/470_pseudo.html">GDK</a>@
documentation.
@mal
command mmap(b:bat[:any,:any], 
		buns_mode:int, 
		hheap_mode:int, 
		theap_mode:int,
		hacc_mode:int, 
		tacc_mode:int) 
	:bit 
address BKCmmap
comment "For each individual heap, you can 
	change the allocation mode to either 
	STORE_MEM or STORE_MMAP. Passing an 
	int(nil) means:no change.  Changing a 
	dirty STORE_MEM heap into STORE_MMAP, 
	will cause a BAT save (this has to 
	happen before the heap can be mapped 
	into virtual memory). These modes are 
persistent. ";

command mmap(b:bat[:any,:any], mode:int):bit 
address BKCmmap2
comment "Alias for mmap(b,mode,mode,mode,
	mode,mode)";

command madvise(b:bat[:any,:any], 
		buns_mode:int, 
		hheap_mode:int, 
		theap_mode:int,
		hacc_mode:int, 
		tacc_mode:int) 
	:bit 
address BKCmadvise
comment "Modern Operating Systems allow users 
	to influence the buffer management
	policy of virtual memory. This is a 
	crucial feature for database systems,
	and eliminates the need to reimplement 
	the OS in a database buffer manager.
	The supported flags are BUF_NORMAL 
	(the normal adaptive kernel algorithm),
	BUF_RANDOM (no page prefetching), 
	BUF_SEQUENTIAL (prefetch and swapout),
	BUF_WILLNEED (load everything with prefetch), 
	BUF_DONTNEED (swapout).
	These buffer management modes are not 
	persistent. 
	Returns the BAT operated upon.";

command madvise(b:bat[:any,:any], 
		mode:int):bit 
address BKCmadvise2
comment "alias for madvise(b,mode,mode,mode,
	mode,mode)";

@- BAT Accelerators
@T
[WILL BECOME OBSOLETE]
Search accelerators are datastructures that are used to speed up
access to data in BATs. Monet comes with the builtin accelerators
{\tt index}, meaning binary tree index, and {\tt hash} meaning
bucket-chained hash table. The extension facilities of Monet allow
more accelerators to be defined by users. Exanples are the {\tt rtree}
and {\tt datavector}.

{\small
\begin{verbatim}
>monet_acctbl.print;
#-------------------------#
# h             | t       #
#-------------------------#
[ "hash",         1       ]
[ "index",        2       ]
\end{verbatim}
}
@
More info on how to write new search accelerators can be found in the
@[<a href="../mel.html">MEL documentation</a>@.
@mal
command accbuild(b:bat[:any,:any], acctype:int):bit 
address BKCaccbuild_std
comment "Build an accelerator on the head column of b. The builtin accelerator
 types index and hash will be created as transient accelerators. They
 will not be saved on disk. User-defined accelerators must always be
 persistent." ;

command accbuild(b:bat[:any,:any], acctype:int, param:ptr):int 
address BKCaccbuild
comment "like accbuild(bat[:any,:any] b, int acctype), but with a parameter that
 is provide to the specific accelerator build routine.";

command accdestroy(b:bat[:any,:any], 
	acctype:int) 
address BKCaccdestroy
comment "Destroy the accelerator of type 
	'acctype'  that is present on
	the head-type of b.";

command accpresent(b:bat[:any,:any] ) :int 
address BKCaccpresent
comment "Returns the accelerator type of the 
	*persistent* accelerator present on 
	the head column of b. Note that index 
	and hash accelerators are generally 
	*not* persistent, and will not be 
	returned by this function!";
 
command hasHash(b:bat[:any,:any]):bit 
address BKChasHash;
command setHash(b:bat[:any,:any],prop:bit):bit 
address BKCsetHash;
command hasIndex(b:bat[:any,:any]):bit 
address BKChasIndex;
command setIndex(b:bat[:any,:any],prop:bit):bit 
address BKCsetIndex;

@- Synced BATs
The binary model of Monet has important advantages when working in
main-memory. Tables are thin and very efficiently processed. The binary
model gives rise, however, to a larger-than-normal number of join
and semijoin operations. Relations are split up in vertical parts that
are very much related to each other. Then, for instance, multiple
similar semijoins occur on different vertical parts. By equipping the
kernel with knowledge about the correspondence of these parts, we
can greatly limit the amount of work to be done.

When two BATs effectively contain the same sequence of head elements,
we call them 'synced'. This is implemented by storing a very large
OID for each column. An update to the column destroys this OID.
By comparing two OIDs the Monet kernel can very quickly decide that
two columns are exactly equal. All BAT algebra operations propagate
these 'sync' OIDs with their own propagation rules.
@mal
command isSynced (b1:bat[:any,:any], b2:bat[:any,:any]) :bit = BKCisSynced
comment "Tests whether two BATs are synced or not. ";

@- Constants
The following constants have not been integrated in the code base
@mal
#Constants have been added to mal/const.mx prelude
#    STORE_MEM   := 0;     # load into GDKmalloced memory
#    STORE_MMAP  := 1;     # mmap() into virtual memory
#    STORE_COMPR := 2;     # currently not implemented this way
#    BUF_NORMAL    := 0;   # No further special treatment
#    BUF_RANDOM    := 1;   # Expect random page references
#    BUF_SEQUENTIAL:= 2;   # Expect sequential page references
#    BUF_WILLNEED  := 3;   # Will need these pages
#    BUF_DONTNEED  := 4;   # Don't need these pages

@{
@{
@* Implementation Code
In Version 5, we are not going to support recursive BATs.
It is up to the programmer to translate a bat into a
bat-name or batCacheid

@= batconvert
	(BAT@2type(@1) == TYPE_bat)?&((BAT*)@2)->batCacheid:@2

@-
At this stage of the game, we should translate
the arguments of BATnew into types.
Beware, a void column type is turned into a virtual oid type immediately
by setting the sequential base.
@+ Minimum and Maximum
The routines @`BATmin_@5(b) and @`BATmax_@5(b) compute the minimum and
maximum value of the tail column of a BAT.
Aggregate values are calculated just before they are requested by
the user. They are not maintained continuously, because we expect
them to be used sparsely.
@-
@= atomaggr
    if (s > 0 && !(BATtordered(b)&1)) {
        char* nil = BATatoms[t].atomNull;
        BUN p,q;
        int xx;
        BATloopFast(b, p, q, xx) {
            x = (ptr) BUNt@2(b, p);
            if (@3_CMP(x, nil, @4) == 0) {
                v = nil; break;
            }
            if (@3_@5(x, v, @4)) {
                v = x;
            }
        }
    }
    if (aggr) {
       memcpy(aggr, x=v, ATOMsize(t));
    } else {
       /* alloc new space and copy the atom into it */
       s = ATOMlen(t, v);
       memcpy(x = (ptr) GDKmalloc(s), v, s);
   }
@= voidaggr
    if (aggr) {
        *(oid *) aggr = *(oid *) (x=v);
    } else {
        /* alloc new space and copy the atom into it */
        memcpy(x = (ptr) GDKmalloc(sizeof(oid)), v, s);
    }
@= aggrmin
    v = (s == 0)?ATOMnilptr(t):BUNtail(b, BUNfirst(b));
    @:@5aggr(@1,@2,@3,@4,LT)@
@= aggrmax
    v = (s == 0)?ATOMnilptr(t):BUNtail(b, BUNlast(b)-BUNsize(b));
    @:@5aggr(@1,@2,@3,@4,GT)@

@= BATaggr
ptr BAT@1(BAT *b, ptr aggr) {
        int t;
        size_t s;
        ptr v, x;

        BATcheck(b, "BAT@1");
        s = BATcount(b);
        t = b->ttype;
        if (BATtvoid(b)) {
            @:aggr@1(chr,loc,simple,chr,void)@
        } else {
            switch(ATOMstorage(t)) {
            case TYPE_chr: @:aggr@1(chr,loc,simple,chr,atom)@ break;
            case TYPE_sht: @:aggr@1(sht,loc,simple,sht,atom)@ break;
            case TYPE_int: @:aggr@1(int,loc,simple,int,atom)@ break;
            case TYPE_flt: @:aggr@1(flt,loc,simple,flt,atom)@ break;
            case TYPE_dbl: @:aggr@1(dbl,loc,simple,dbl,atom)@ break;
            case TYPE_lng: @:aggr@1(lng,loc,simple,lng,atom)@ break;
            default:if (b->tvarsized) {
                           @:aggr@1(chr,var,atom,t,atom)@ break;
                     } else {
                           @:aggr@1(chr,loc,atom,t,atom)@ break;
            }        }
        }
        return x;
}

@h
#ifndef _BAT_H_
#define _BAT_H_

#include <gdk.h>
#include <mal.h>

mal_export str BKCsetRole(int *r, int *bid, str *hname, str *tname);

#endif /*_BAT_H_*/
@-
to be included at a later stage
            case TYPE_uchr: @:aggr@1(uchr,loc,simple,uchr,atom)@ break;
@c
#include "bat.h"
#include <stream.h>
#include "mal_function.h"

@:BATaggr(min)@
@:BATaggr(max)@

@= batconvert
	(BAT@2type(@1) == TYPE_bat)?(BUN)&((BAT*)@2)->batCacheid:(BUN)@2

@+ Information Functions
@c

int CMDnew_lng(BAT **ret, int *ht, int *tt, lng *cap){
	if (*cap < 0)
		*cap = 0;
	*ret = BATnew(*ht, *tt, (size_t) *cap);
	return (*ret)?GDK_SUCCEED:GDK_FAIL;
}

int CMDnew(BAT **ret, int *ht, int *tt, int *cap){
	if (*cap < 0)
		*cap = 0;
	*ret = BATnew(*ht, *tt, (size_t) *cap);
	return (*ret)?GDK_SUCCEED:GDK_FAIL;
}

int CMDnew_default(BAT **ret, int *ht, int *tt){
	int default_size = 0;
	return CMDnew(ret, ht, tt, &default_size);
}

int CMDreverse(BAT **ret, BAT *b){
	*ret = BATmirror(b);
	BBPfix(b->batCacheid);
	return GDK_SUCCEED;
} 

int CMDmirror(BAT **ret, BAT *b){
	BAT *v = *ret = VIEWcombine(b);
	if (b->batRestricted == BAT_WRITE) {
		*ret = BATrcopy(v);
		BBPreclaim(v);
	}
	return (*ret)?GDK_SUCCEED:GDK_FAIL;
}

int CMDconvert(BAT **ret, BAT *b){
	if (BATconvert(*ret = b,CONV_HTON) == NULL)
	BBPfix(b->batCacheid);
	return GDK_SUCCEED;
}

int CMDrevert(BAT **ret, BAT *b){
	if (BATrevert(*ret = b) == NULL)
		return GDK_FAIL;
	BBPfix(b->batCacheid);
	return GDK_SUCCEED;
}

int CMDorder(BAT **ret, BAT *b){
	if (BATorder(*ret = b) == NULL)
		return GDK_FAIL;
	BBPfix(b->batCacheid);
	return GDK_SUCCEED;
}

int CMDorder_rev(BAT **ret, BAT *b){
	if (BATorder_rev(*ret = b) == NULL)
		return GDK_FAIL;
	BBPfix(b->batCacheid);
	return GDK_SUCCEED;
}

int CMDinsert_bun(BAT **r, BAT *b, ptr h, ptr t) {
	if (BUNins(*r=b, @:batconvert(b,h)@, @:batconvert(b,t)@) == NULL)
		return GDK_FAIL;
	BBPfix(b->batCacheid);
	return GDK_SUCCEED;
} 

int CMDinsert_bat(BAT **r, BAT *b, BAT *s){
	if (BATins(*r=b,s) == NULL)
		return GDK_FAIL;
	BBPfix(b->batCacheid);
	return GDK_SUCCEED;
} 

int CMDreplace_bun(BAT **r, BAT *b, ptr h, ptr t) {
	if (BUNreplace(*r=b, @:batconvert(b,h)@, @:batconvert(b,t)@) == NULL)
		return GDK_FAIL;
	BBPfix(b->batCacheid);
	return GDK_SUCCEED;
} 

int CMDreplace_bat(BAT **r, BAT *b, BAT *s){
	if (BATreplace(*r=b,s) == NULL)
		return GDK_FAIL;
	BBPfix(b->batCacheid);
	return GDK_SUCCEED;
} 

int CMDdelete_bun(BAT **r, BAT *b, ptr h, ptr t) {
	if (BUNdel(*r=b,h,t) == NULL)
		return GDK_FAIL;
	BBPfix(b->batCacheid);
	return GDK_SUCCEED;
} 

int CMDdelete_head(BAT **r, BAT *b, ptr h) {
	if (BUNdelHead(*r=b, @:batconvert(b,h)@) == NULL)
		return GDK_FAIL;
	BBPfix(b->batCacheid);
	return GDK_SUCCEED;
} 

int CMDdelete_all(BAT **r, BAT *b) {
	if (BATclear(*r=b) == NULL) 
		return GDK_FAIL;
	BBPfix(b->batCacheid);
	return GDK_SUCCEED;
} 

int CMDdelete_bat_bun(BAT **r, BAT *b, BAT *s){
	if (BATdel(*r=b,s) == NULL)
		return GDK_FAIL;
	BBPfix(b->batCacheid);
	return GDK_SUCCEED;
} 

int CMDdelete_bat_head(BAT **r, BAT *b, BAT *s){
	if (BATdelHead(*r=b,s) == NULL)
		return GDK_FAIL;
	BBPfix(b->batCacheid);
	return GDK_SUCCEED;
} 


/* descriptors may be unloaded by BBPtrim, so secure them with a hotfix while in use */
static BAT* lock_desc(bat bid) {
	BBPfix(bid);
	return (BAT*) BBPgetdesc(bid);
}

static void unlock_desc(bat bid) {
	BBPunfix(bid);
}

int CMDcount_bat(lng *res, int *bid) {
	if (BBPcheck((bat) *bid, "CMDcount_bat")) {
		BAT *b = lock_desc((bat) *bid);
		if (b == NULL) {
			*res = lng_nil;
		} else if (BBP_cache((bat) *bid)) {
			*res = (lng) BATcount(b);  
		} else {
			/* BAT not loaded */
			*res = (lng) ((b->batBuns->free - (b->batHole - b->batBuns->base))/BUNsize(b) - 1);
		}
		unlock_desc(*bid);
	}
	return GDK_SUCCEED;
}

int CMDcapacity(lng *res, int *bid) {
	if (BBPcheck((bat) *bid, "CMDcapacity")) {
		BAT *b = lock_desc((bat) *bid);
		if (b == NULL) {
			*res = lng_nil;
		} else {
			*res = (lng) BATcapacity(b);
		}
		unlock_desc(*bid);
	}
	return GDK_SUCCEED;
}

int CMDhead(str *res, int *bid) {
	if (BBPcheck((bat) *bid, "CMDhead")) {
		str ret = str_nil;
		BAT *b = lock_desc((bat) *bid);
		if (b) {
			ret = *bid > 0 ? b->hatom : b->tatom;
		}
		*res = GDKstrdup(ret);
		unlock_desc(*bid);
	} else {
		*res = GDKstrdup(str_nil);
	}
	return GDK_SUCCEED;
}

int CMDtail(str *res, int *bid) {
	if (BBPcheck((bat) *bid, "CMDtail")) {
		str ret = str_nil;
		BAT *b = lock_desc((bat) *bid);
		if (b) {
			ret = *bid > 0 ? b->tatom : b->hatom;
		}
		*res = GDKstrdup(ret);
		unlock_desc(*bid);
	} else {
		*res = GDKstrdup(str_nil);
	}
	return GDK_SUCCEED;
}

int CMDsetkey(BAT **result, BAT *input, bit *param) {
	BATkey(*result=input, *param?BOUND2BTRUE:FALSE);
	BBPfix(input->batCacheid);
        return GDK_SUCCEED;
}

int CMDsetset(BAT **result, BAT *input, bit *param) {
	BATset(*result=input, *param?BOUND2BTRUE:FALSE);
	BBPfix(input->batCacheid);
        return GDK_SUCCEED;
}

int CMDordered(bit *result, BAT *input) {
        *result = BATordered(input)?1:0;
        return GDK_SUCCEED;
}

int CMDordered_rev(bit *result, BAT *input) {
        *result = BATordered_rev(input)?1:0;
        return GDK_SUCCEED;
}

int CMDgetkey(bit *ret, BAT *b) {
	/* we must take care of the special case of a nil column (TYPE_void,seqbase=nil) 
         * such nil columns never set hkey (and BUNins will never invalidate it if set) yet
         * a nil column of a BAT with <= 1 entries does not contain doubles => return TRUE.
         */
	if (BATcount(b) <= 1) {
		*ret = TRUE;
	} else {
		if (!b->hkey) {
			BATpropcheck(b, BATPROPS_ALL);
		}
		*ret = b->hkey?TRUE:FALSE;
	}
	return GDK_SUCCEED;
}

int CMDpersists(BAT **r, BAT *input, bit *param) {
	BATmode(*r=input, (*param == TRUE)?PERSISTENT:(*param == FALSE)?TRANSIENT:SESSION);
	BBPfix(input->batCacheid);
        return GDK_SUCCEED;
}

int CMDdestroy(bit *res, str input, bit *immediately) {
        int bid = BBPindex(input);
        *res = FALSE;
        if (bid ) {
                BBPfix(bid);
		if (BBPindex(input) == bid) {
			BAT *b = BBPquickdesc(ABS(bid), FALSE);
			if (*immediately == FALSE) {
				b->batKeeparound = 1;
				b->batDirtydesc = 1;
			}
			BATmode(b, TRANSIENT);
			*res = TRUE;
		}
                BBPunfix(bid);
        }
        return GDK_SUCCEED;
}

int CMDresurrect(bit *r, str nme) {
        *r = BBPresurrect(nme);
        return GDK_SUCCEED;
}

int CMDsetaccess(BAT **r, BAT *input, int *param) {
	bat oldCacheid = input->batCacheid;
	*r = BATsetaccess(input, *param);
	if ((*r)->batCacheid == oldCacheid) {
		BBPfix(oldCacheid);
	}
        return GDK_SUCCEED;
}

int CMDgetaccess(int *r, BAT *input) {
	*r = BATgetaccess(input);
        return GDK_SUCCEED;
}

static char* pre(str s1,str s2){
	static char buf[64];
	snprintf(buf, 64, "%s%s", s1, s2);
	return buf;
}
static char* local_itoa(ssize_t i){
	static char buf[32];
	snprintf(buf, 32, SSZFMT, i);
	return buf;
}
static char* local_utoa(size_t i){
	static char buf[32];
	snprintf(buf, 32, SZFMT, i);
	return buf;
}

#define COLLISION 6

void HASHinfo(BAT *bn, Hash *h, str s){
	hash_t	i;
	hash_t	j;
	size_t	cnt[COLLISION + 2];
	size_t	largebuckets = 0;
	size_t	largetot = 0;
	char	buf[32];
 
	BUNins(bn, pre(s,"type"), ATOMname(h->type));
	BUNins(bn, pre(s,"mask"), local_utoa(h->mask));
	BUNins(bn, pre(s,"lim"), local_utoa(h->lim));
 
	for (i = 0; i <= COLLISION + 1; i++) {
		cnt[i] = 0;
	}
	for (i = 0; i <= h->mask; i++) {
		if (h->hash[i] == 0) {
			cnt[0]++;
		} else if (h->hash[i] > h->lim) {
			GDKerror("HASHinfo: hash consistency problem %d\n", i);
		} else if ((j = HASHlist(h, h->hash[i])) <= COLLISION +1) {
			cnt[j]++;
		} else {
			largebuckets++;
			largetot += j;
		}
	}
 
	for (i = 0; i <= COLLISION+1; i++)
	if( cnt[i]) {
		BUNins(bn, pre(s,local_utoa(i)), local_utoa(cnt[i]));
	}
	snprintf(buf, 32, SZFMT " on " SZFMT, largetot, largebuckets);
	BUNins(bn, pre(s,"collision"), buf);
}

static void infoHeap(BAT *bn, Heap *hp, str nme){
	char buf[1024], *p = buf;

	while(*nme) *p++ = *nme++;
	strcpy(p, "free");
        BUNins(bn, buf, local_utoa(hp->free ));
	strcpy(p, "size");
        BUNins(bn, buf, local_utoa(hp->size));
	strcpy(p, "maxsize");
        BUNins(bn, buf, local_utoa(hp->maxsize));
	strcpy(p, "storage");
        BUNins(bn, buf, (hp->base==NULL)?"absent":(hp->storage==STORE_MMAP)?
		(hp->filename?"memory mapped":"anonymous vm"):
		(hp->storage==STORE_PRIV)?"private map":"malloced");
	strcpy(p, "filename");
        BUNins(bn, buf, hp->filename?hp->filename:"no file");
	strcpy(p, "offset");
        BUNins(bn, buf, local_utoa(hp->offset));
}

static char *oidtostr( oid i ){
	int len = 32;
	static char bf[32];
	char *p = bf;

	(void)OIDtoStr(&p, &len, &i);
	return bf;
}

int CMDinfo(BAT **retval, BAT *b){
	BAT *bn;
	char mode[1024], *access;
 
	if (!(bn = BATnew(TYPE_str,TYPE_str, 128)))
		return GDK_FAIL;
	*retval = bn;
 
	if (b->batPersistence == PERSISTENT) {
		strcpy(mode, "persistent");
	} else if (b->batPersistence == SESSION) {
		strcpy(mode, "session");
	} else if (b->batPersistence == TRANSIENT) {
		strcpy(mode, "transient");
	} else {
		strcpy(mode, "unknown");
	} 

	switch(b->batRestricted) {
	case BAT_READ:         access="read-only";        break;
	case BAT_WRITE:        access="updatable";        break;
	case BAT_APPEND:       access="append-only";      break;
	default:               access="unknown";
	}
 
        BUNins(bn, "version", local_itoa(b->GDKversion));
        BUNins(bn, "batId", b->batId );
        BUNins(bn, "batCacheid", local_itoa(b->batCacheid));
        BUNins(bn, "batParentid", local_itoa(b->batParentid));
        BUNins(bn, "batSharecnt", local_itoa(b->batSharecnt));
        BUNins(bn, "head", ATOMname(b->htype));
        BUNins(bn, "tail", ATOMname(b->ttype));
        BUNins(bn, "batPersistence", mode);
        BUNins(bn, "batRestricted", access);
        BUNins(bn, "batRefcnt", local_itoa(BBP_refs(b->batCacheid)));
        BUNins(bn, "batLRefcnt", local_itoa(BBP_lrefs(b->batCacheid)));
        BUNins(bn, "batDirty", BATdirty(b)?"dirty":"clean");
        BUNins(bn, "batSet", local_itoa(b->batSet));
        BUNins(bn, "void_tid", local_itoa(b->void_tid));
        BUNins(bn, "void_cnt", local_itoa(b->void_cnt));
 
        BUNins(bn, "hsorted", local_itoa(BAThordered(b)));
        BUNins(bn, "hident",  b->hident);
	BUNins(bn, "hdense", local_itoa(BAThdense(b)));
	BUNins(bn, "hseqbase", oidtostr(b->hseqbase));
        BUNins(bn, "hkey", local_itoa(b->hkey));
        BUNins(bn, "hloc", local_itoa(b->hloc));
        BUNins(bn, "hvarsized", local_itoa(b->hvarsized));
        BUNins(bn, "halign", local_utoa(b->halign));
        BUNins(bn, "halignflushed", local_utoa(b->halignflushed));
 
        BUNins(bn, "tident", b->tident);
	BUNins(bn, "tdense", local_itoa(BATtdense(b)));
	BUNins(bn, "tseqbase", oidtostr(b->tseqbase));
        BUNins(bn, "tsorted", local_itoa(BATtordered(b)));
        BUNins(bn, "tkey", local_itoa(b->tkey));
        BUNins(bn, "tloc", local_itoa(b->tloc));
        BUNins(bn, "tvarsized", local_itoa(b->tvarsized));
        BUNins(bn, "talign", local_utoa(b->talign));
        BUNins(bn, "talignflushed", local_utoa(b->talignflushed));
 
        BUNins(bn, "batInserted", local_utoa(BUNindex(b, b->batInserted)));
        BUNins(bn, "batDeleted", local_utoa(BUNindex(b, b->batDeleted)));
        BUNins(bn, "batHole", local_utoa(BUNindex(b, b->batHole)));
        BUNins(bn, "top", local_utoa(BUNindex(b, (BUN) ((char *) Bunbase(b) + b->batBuns->free))));
        BUNins(bn, "batStamp", local_itoa(b->batStamp));
        BUNins(bn, "lastUsed", local_itoa(BBP_lastused(b->batCacheid)));
        BUNins(bn, "keepAround", local_itoa(b->batKeeparound));
	BUNins(bn, "curStamp", local_itoa(BBPcurstamp()));
        BUNins(bn, "batCopiedtodisk", local_itoa(b->batCopiedtodisk));
        BUNins(bn, "batDirtydesc", b->batDirtydesc?"dirty":"clean");
 
        BUNins(bn, "batDirtybuns", b->batDirtybuns?"dirty":"clean");
	infoHeap(bn, b->batBuns, "batBuns.");

        BUNins(bn, "hheapdirty", b->hheapdirty?"dirty":"clean");
	infoHeap(bn, &b->hheap, "hheap.");

        BUNins(bn, "theapdirty", b->theapdirty?"dirty":"clean");
	infoHeap(bn, &b->theap, "theap.");

        BUNins(bn, "hacctype", ACCname(b->hacctype));
        BUNins(bn, "haccdirty", b->haccdirty?"dirty":"clean");
        BUNins(bn, "haccCopiedtodisk", local_itoa(b->haccCopiedtodisk));
	infoHeap(bn, &b->haccelerator, "haccelerator.");

        BUNins(bn, "tacctype", ACCname(b->tacctype));
        BUNins(bn, "taccdirty", b->taccdirty?"dirty":"clean");
        BUNins(bn, "taccCopiedtodisk", local_itoa(b->taccCopiedtodisk));
	infoHeap(bn, &b->taccelerator, "taccelerator.");
 
        /* dump index information */
        if (b->hhash_heap) {
                HASHinfo(bn, &b->hhash, "hhash->");
        }
        if (b->thash_heap) {
                HASHinfo(bn, &b->thash, "thash->");
        }
        BUNins(bn, "head_index", b->hidx_heap?"present":"absent");
        BUNins(bn, "tail_index", b->tidx_heap?"present":"absent");
 
	return GDK_SUCCEED;
}

#define ROUND_UP(x,y) ((y)*(((x)+(y)-1)/(y)))

int CMDbatsize(int *tot, BAT *b){
	size_t blksize = MT_pagesize();
	size_t size = ROUND_UP(sizeof(BATstore),blksize);

	if (!VIEWparent(b)) {
		size_t cnt = BATcapacity(b);
		size += ROUND_UP(b->batBuns->size, blksize);
		if (b->hheap.base) size += ROUND_UP(b->hheap.size, blksize);
		if (b->theap.base) size += ROUND_UP(b->theap.size, blksize);
		if (b->haccelerator.base) size += ROUND_UP(b->haccelerator.size, blksize);
		if (b->taccelerator.base) size += ROUND_UP(b->taccelerator.size, blksize);
		if (b->hhash_heap) size += ROUND_UP(sizeof(hash_t) * cnt, blksize);
		if (b->thash_heap) size += ROUND_UP(sizeof(hash_t) * cnt, blksize);
		if (b->hidx_heap) size += ROUND_UP(sizeof(BUN) * cnt, blksize);
		if (b->tidx_heap) size += ROUND_UP(sizeof(BUN) * cnt, blksize); 
	}
	*tot = size;
	return GDK_SUCCEED;
}

int CMDbatsize_str(int *tot, str batname){
	bat bid = BBPindex(batname);
	BAT *b = bid?(BAT*) BBPgetdesc(bid):NULL;

	if (b == NULL) {
		GDKerror("CMDbatsize(%s): no such bat.\n", batname);
		return GDK_FAIL;
	}
	return CMDbatsize(tot, b);
}

@+ Synced BATs
@c
int CMDsynced(bit *ret, BAT *b1, BAT *b2){
	*ret = ALIGNsynced(b1,b2)?1:0;
	return GDK_SUCCEED;
}

@+ BBP Management, IO
@c
int CMDroles(BAT **r, BAT *b, str hname, str tname){
	BATroles(*r=b, hname, tname);
	BBPfix(b->batCacheid);
	return GDK_SUCCEED;
}

int CMDrename(bit *retval, BAT *b, str s){
	int ret = BATname(b,s);
	*retval = FALSE;
        if (ret == 1) {
                GDKerror("CMDrename: identifier expected: %s\n",s);
		return GDK_FAIL;
        } else if (ret == BBPRENAME_ILLEGAL) {
                GDKerror("CMDrename: illegal temporary name: '%s'\n", s);
		return GDK_FAIL;
        } else if (ret == BBPRENAME_LONG) {
                GDKerror("CMDrename: name too long: '%s'\n", s);
		return GDK_FAIL;
        } else if (ret != BBPRENAME_ALREADY) {
		*retval = TRUE;
	}
	return GDK_SUCCEED;
}

int CMDname(str *retval, BAT *b){
	*retval = GDKstrdup(BBPname(b->batCacheid));
	return GDK_SUCCEED;
}

int CMDunload(bit *res, str input) {
        bat bid = ABS(BBPindex(input));
	*res = FALSE;
        if (bid > 0) {
		BAT *b;
		BBPfix(bid);
		b = BBP_cache(bid);
		if (b) {
			if (b->batPersistence == SESSION) BATmode(b, TRANSIENT);
			BBPcold(bid); /* will trigger unload of also persistent bats */
		}
		*res = BBPunfix(bid) == 0;
	}
        return GDK_SUCCEED;
}

int CMDhot(str input) {
	BBPhot(BBPindex(input));
	return GDK_SUCCEED;
}

int CMDcold(str input) {
	BBPcold(BBPindex(input));
	return GDK_SUCCEED;
}

int CMDheat(int *res, str input) {
	int bid = BBPindex(input);
	if (bid) {
		*res = BBP_lastused(bid) & 0x7fffffff;
	}
	return GDK_SUCCEED;
}

int CMDsave(bit *res, str input) {
	bat bid = BBPindex(input);
	BAT *b;
	*res = FALSE;
	if (bid ) {
		BBPfix(bid);
		b = BBP_cache(bid);
		if (b && BATdirty(b)) { 
			if (BBPsave(b) == 0) *res = TRUE;
		}
		BBPunfix(bid);
	}
        return GDK_SUCCEED;
}


@= change_heap
{	int mode = (@2).storage;
	if (mode == STORE_MMAP && (@2).filename == NULL) 
		mode = STORE_MEM;  
	if ((@2).base == NULL || *@1 == int_nil || *@1 == mode) {
		*@1 = -1;
	}
}
@c
int CMDmmap(BAT **r, BAT *b, int *bns, int *hhp, int *thp, int *hacc, int *tacc){
	@:change_heap(bns,(*b->batBuns))@
	@:change_heap(hhp,b->hheap)@
	@:change_heap(thp,b->theap)@
	@:change_heap(hacc,b->haccelerator)@
	@:change_heap(tacc,b->taccelerator)@
	if (BATmmap(*r=b, *bns, *hhp, *thp, *hacc, *tacc) == 0) {
	        BBPfix(b->batCacheid);
		return GDK_SUCCEED;
	}
	return GDK_FAIL;
}

int CMDmadvise(BAT **r, BAT *b, int *bns, int *hhp, int *thp, 
		 	        int *hacc, int *tacc)
{
	BBPfix(b->batCacheid);
	return BATmadvise(*r=b, (*bns==int_nil)?-1:*bns, 
		(*hhp==int_nil)?-1:*hhp, (*thp==int_nil)?-1:*thp, 
		(*hacc==int_nil)?-1:*hacc, (*tacc==int_nil)?-1:*tacc)?GDK_FAIL:GDK_SUCCEED;
}

@+ Accelerator Control
@c
int CMDaccbuild(BAT *b, int* acc, ptr param, int dummy){
	(void) dummy;
	ACCbuild(*acc, b, &b->haccelerator, param); 
	return GDK_SUCCEED;
}
int CMDaccbuild_std(BAT *b, int* acc){
	return CMDaccbuild(b, acc, NULL, 0);	
}

int CMDaccdestroy(BAT *b, int *acc) {
	ACCdestroy(*acc, b, &b->haccelerator);
	return GDK_SUCCEED;
}

int CMDaccpresent(int *retval, BAT* b) {
	*retval = 0;
	if (b->hacctype) {
	    int (*check)(Heap*, BAT*) = BATaccelerators[b->hacctype].accRepair;
	    if (check == NULL || (*check)(&b->haccelerator,b) == GDK_SUCCEED) {
		*retval = b->hacctype;
 	    }
	}
	return GDK_SUCCEED;
}

/* ITERATIONS ARE DEFINED ELSEWHERE */

int CMDget_seqbase(oid *o, BAT *b){
	*o = b->hseqbase;
	return GDK_SUCCEED;
}

int CMDset_seqbase(BAT **r, BAT *b, oid* o){
	BATseqbase(*r = b, *o);
	BBPfix(b->batCacheid);
	return GDK_SUCCEED;
}
@}
@}
@- Wrapping
The remainder contains the wrapper code over the version 4
@+ Information Functions
In most cases we pass a BAT identifier, which should be unified
with a BAT descriptor. Upon failure we can simply abort the function.

@= getBATdescriptor
	if( BBPcheck(*@2,"@4")==0)
                return throwMessage("bat.@4", 
			"cannot access bat @2 in bbp");
	@3= (BAT*) BBPgetdesc(*@2);
	if( @3 == NULL) { *@1 = 0;
                return throwMessage("bat.@4", 
			"cannot access descriptor @2");
	}
	if(*@2 <0) @3 = BATmirror(@3);
@= getBATdescriptor2
	if( BBPcheck(*@2,"@4")== 0 )
                return throwMessage("bat.@4", 
			"cannot access bat @2 in bbp");
	@3= (BAT*) BBPgetdesc(*@2);
	if( @3 == NULL) { *@1 = 0;
                return throwMessage("bat.@4", 
			"cannot access descriptor @2");
	}
	if(*@2 <0) @3 = BATmirror(@3);
@-

@c
#include <gdk.h>
#include <mal.h>

str BKCnewBATint(int *res, int *ht, int *tt, int *cap){
	BAT *b;
	if( CMDnew(&b,ht,tt, cap) == GDK_SUCCEED){
		BBPincref(b->batCacheid,TRUE);
		*res= b->batCacheid;
		return MAL_SUCCEED;
	}
	return  throwMessage("bat.new", 
			"GDKerror in BAT construction");
}
str BKCnewBATlng(int *res, int *ht, int *tt){
	BAT *b;
	lng cap =0;
	if( CMDnew_lng(&b,ht,tt,&cap) == GDK_SUCCEED){
		BBPincref(b->batCacheid,TRUE);
		*res= b->batCacheid;
		return MAL_SUCCEED;
	}
	return  throwMessage("bat.new", 
			"GDKerror in BAT construction");

}
str BKCnewBat(int *res, int *ht, int *tt){
	size_t cap=0;
	return BKCnewBATint(res,ht,tt,&cap);
}
str BKCreverse(int *ret, int *bid){
	BAT *b, *bn= NULL;
	@:getBATdescriptor(ret,bid,b,reverse)@
	CMDreverse(&bn,b);
	*ret= bn->batCacheid;
	BBPfix(bn->batCacheid);
	return MAL_SUCCEED;
}

str BKCmirror(int *ret, int *bid){
	BAT *b, *bn = NULL;
	@:getBATdescriptor(ret,bid,b,mirror)@
	if( CMDmirror(&bn, b)== GDK_SUCCEED){
                BBPfix(b->batCacheid);
                *ret = bn->batCacheid;
                return MAL_SUCCEED;
        }
	*ret = 0;
	return throwMessage("bat.mirror", "GDKerror");
}

str BKCconvert(int *ret, int *bid){
	BAT *b, *bn=NULL;
	@:getBATdescriptor(ret,bid,b,convert)@
	CMDconvert(&bn,b);
	return MAL_SUCCEED;
}

str BKCrevert(int *ret, int *bid){
	BAT *b, *bn =NULL;
	(void) bn;
	@:getBATdescriptor(ret,bid,b,revert)@
	if( CMDrevert(&bn,b) == GDK_SUCCEED)
		return MAL_SUCCEED;
	return throwMessage("bat.revert","GDKerror");
}

str BKCorder(int *ret, int *bid){
	BAT *b, *bn = NULL;
	@:getBATdescriptor(ret,bid,b,order)@
	if( CMDorder(&bn,b) == GDK_SUCCEED)
		return MAL_SUCCEED;
	return throwMessage("bat.order","GDKerror");
}
str BKCorder_rev(int *ret, int *bid){
	BAT *b, *bn = NULL;
	@:getBATdescriptor(ret,bid,b,order_rev)@
	if( CMDorder_rev(&bn,b) == GDK_SUCCEED)
		return MAL_SUCCEED;
	return throwMessage("bat.order","GDKerror");
}
@-
Insertions into the BAT may involve void types (=no storage required)
These cases should actually be captured during BUNins, because they
may emerge internally as well.
@= void_insertbun
if (b->@1type == TYPE_void && *(oid*) @1 != oid_nil &&
    *(oid*) @1 != (b->@1seqbase + BUNgetpos(b, BUNlast(b))))
{
printf("val %d seqbase %d pos %d\n", *(oid*)@1,
	b->@1seqbase,  BUNgetpos(b, BUNlast(b)) );
      return throwMessage("bat.insert", " insert non-nil values in a void column.");
}
@c
str BKCinsert_void_bun(int *r, int *bid, ptr t) {
	BAT *b;
	oid h= oid_nil;
	@:getBATdescriptor2(r,bid,b,insert)@
	@:derefStr(b,t,t)@
	BUNins(b,(ptr)&h, @:batconvert(b,t)@);
	return MAL_SUCCEED;
}

str BKCinsert_bun(int *r, int *bid, ptr h, ptr t) {
	BAT *b;
	@:getBATdescriptor2(r,bid,b,insert)@
	@:derefStr(b,h,h)@
	@:derefStr(b,t,t)@
	BUNins(b, @:batconvert(b,h)@, @:batconvert(b,t)@);
	return MAL_SUCCEED;
}

str BKCinsert_bat(int *r, int *bid, int *sid){
	BAT *b, *s, *bn= NULL;
	@:getBATdescriptor2(r,bid,b,insert)@
	@:getBATdescriptor2(r,sid,s,insert)@
	CMDinsert_bat(&bn, b,s);
	(void) bn;
	return MAL_SUCCEED;
}

str BKCreplace_bun(int *r, int *bid, ptr h, ptr t) {
	BAT *b, *bn =NULL;
	@:getBATdescriptor2(r,bid,b,replace)@
	@:derefStr(b,h,h)@
	@:derefStr(b,t,t)@
	CMDreplace_bun(&bn,b,h,t);
	*r = bn->batCacheid;
	return MAL_SUCCEED;
}

str BKCreplace_bat(int *r, int *bid, int *sid){
	BAT *b,*s, *bn= NULL;
	@:getBATdescriptor2(r,bid,b,replace)@
	@:getBATdescriptor2(r,sid,s,replace)@
	return CMDreplace_bat(&bn,b,s)== GDK_SUCCEED?
		MAL_SUCCEED:
		throwMessage("bat.replace_bat", "GDKerror");
}
str BKCdelete_bun(int *r, int *bid, ptr h, ptr t) {
	BAT *b, *bn=NULL;
	(void) bn;
	@:getBATdescriptor2(r,bid,b,delete)@
	@:derefStr(b,h,h)@
	@:derefStr(b,t,t)@
	if(CMDdelete_bun(&bn,b,h,t) == GDK_SUCCEED)
		return MAL_SUCCEED;
	return throwMessage("bat.delete_buns", "GDKerror");
}

str BKCdelete_head(int *r, int *bid, ptr h) {
	BAT *b,*bn= NULL;
	(void) bn;
	@:getBATdescriptor2(r,bid,b,delete)@
	@:derefStr(b,h,h)@
	if( CMDdelete_head(&bn,b,h) == GDK_SUCCEED)
		return MAL_SUCCEED;
	return throwMessage("bat.delete_head", "GDKerror");
}

str BKCdelete_all(int *r, int *bid) {
	BAT *b, *bn = NULL;
	(void) bn;
	@:getBATdescriptor2(r,bid,b,delete)@
	if( CMDdelete_all(&bn,b) == GDK_SUCCEED)
		return MAL_SUCCEED;
	return throwMessage("bat.delete_all", "GDKerror");
}

str BKCdelete_bat_bun(int *r, int *bid, int *sid){
	BAT *b,*s, *bn = NULL;
	(void) bn;
	@:getBATdescriptor2(r,bid,b,delete)@
	@:getBATdescriptor2(r,sid,s,delete)@
	if( CMDdelete_bat_bun(&bn,b,s) == GDK_SUCCEED)
		return MAL_SUCCEED;
	return throwMessage("bat.delete_bat_buns", "GDKerror");
}

str BKCdelete_bat_head(int *r, int *bid, int *sid){
	BAT *b,*s, *bn = NULL;
	(void) bn;
	@:getBATdescriptor2(r,bid,b,delete)@
	@:getBATdescriptor2(r,sid,s,delete)@
	if( CMDdelete_bat_head(&bn,b,s) == GDK_SUCCEED)
		return MAL_SUCCEED;
	return throwMessage("bat.delete_bat_heads", "GDKerror");
}
str BKCdestroy_bat(bit *r,str *input, bit *immediately) {
	CMDdestroy(r, *input, immediately);
	return MAL_SUCCEED;
}
str BKCdestroy(bit *r,int *bid) {
	bit immediately= TRUE;
	BAT *b;
	str nme;
	@:getBATdescriptor2(r,bid,b,destroy)@
	nme= BBPname(b->batCacheid);
	return BKCdestroy_bat(r,&nme,&immediately);
}

/* The SQL frontend uses void-head bats */
void bun_inplace(BAT *b, oid id, ptr val )
{
	BUN p = NULL;
	BUN oldInserted = b->batInserted;

        assert(b->htype == TYPE_void);
        assert(b->hseqbase == 0);
        assert(BATcount(b) > id);


	b->batInserted = NULL;
	BUNfndVOID(p, b, (ptr)&id);
        assert(p >= b->batInserted); /* we don't want delete/ins */
	(void) BUNinplace(b, p, (ptr)&id, val);
	b->batInserted = oldInserted;
}

size_t void_delete_bat( BAT *b, BAT *d, int delta){
	size_t nr = 0;
	BUN r,s;
	ptr nil = ATOMnilptr(b->ttype);

        if (delta) {
            for (r = d->batInserted; r < BUNlast(d); r = BUNnext(d, r)) {
                oid delid = *(oid*)BUNtail(d,r);
                bun_inplace(b,  delid, nil);
                nr++;
            }
        } else {
            BATloop(d, r, s){
                oid delid = *(oid*)BUNtail(d,r);
                bun_inplace(b,  delid, nil);
                nr++;
            }
        }
	return nr;
}
size_t void_insert_delta( BAT *b, BAT *u ){
        size_t nr = 0;
        BUN r;
        oid nil = oid_nil;

        for (r = u->batInserted; r < BUNlast(u); r = BUNnext(u, r)) {
                BUNins(b,  (ptr)&nil, BUNtail(u,r));
                nr++;
        }
        return nr;
}

size_t void_replace_delta( BAT *b, BAT *u){
        size_t nr = 0;
        BUN r;

        for (r = u->batInserted; r < BUNlast(u); r = BUNnext(u, r)) {
                oid updid = *(oid*)BUNhead(u,r);
                ptr val = BUNtail(u,r);
                bun_inplace(b,  updid, val);
                nr++;
        }
        return nr;
}

size_t void_replace_bat( BAT *b, BAT *u){
	size_t nr = 0;
	BUN r,s;

	BATloop(u, r, s){
		oid updid = *(oid*)BUNhead(u,r);
		ptr val = BUNtail(u,r);
		bun_inplace(b,  updid, val);
		nr++;
	}
	return nr;
}


size_t void_insert_bat( BAT *b, BAT *u){
	size_t nr = 0;
	BUN r,s;
	oid nil = oid_nil;

	BATloop(u, r, s){
		BUNins(b,  (ptr)&nil, BUNtail(u,r));
		nr++;
	}
	return nr;
}

size_t void_append_bat( BAT *b, BAT *u){
        size_t sz = BUNsize(u);
	size_t sbase = b->hseqbase + BATcount(b);
	BATseqbase(u, sbase);
	BATins(b, u);
	return sz;
}
str BKCbat_append_void_bat_wrap( int *r, int *bid, int *uid )
{
	BAT *i, *u;
	@:getBATdescriptor2(r,bid,i,append)@
	@:getBATdescriptor2(r,uid,u,append)@
	void_append_bat( i, u );
	BBPfix(i->batCacheid);
	*r = i->batCacheid;
	return MAL_SUCCEED;
}

str BKCbat_append_oid_bat_wrap( int *r, int *bid, int *uid )
{
	BAT *i, *u;
	@:getBATdescriptor2(r,bid,i,append)@
	@:getBATdescriptor2(r,uid,u,append)@
	void_insert_bat( i, u );
	BBPfix(i->batCacheid);
	*r = i->batCacheid;
	return MAL_SUCCEED;
}

str BKCbat_append_oidvoid_bat_wrap( int *r, int *bid, int *uid )
{
	BAT *i, *u;
	@:getBATdescriptor2(r,bid,i,append)@
	@:getBATdescriptor2(r,uid,u,append)@
	assert(BATcount(i)==0 && BATcount(u) == 0);
	BBPfix(i->batCacheid);
	*r = i->batCacheid;
	return MAL_SUCCEED;
}

str BKCoid_bat_append_oid_bat_wrap( int *res, int *bid, int *uid )
{
	BUN r=0,s;
        oid o;
	BAT *i, *u;
	@:getBATdescriptor2(r,bid,i,append)@
	@:getBATdescriptor2(r,uid,u,append)@
	
	assert(i->htype == TYPE_oid && u->htype == TYPE_oid);
	BATmax(BATmirror(i),&o);
	o++;
	BATloop(u, r, s){
		oid h = *(oid*)BUNhead(u,r) + o;
		BUNins(i, &h,  BUNtail(u,r));
        }
	BBPfix(i->batCacheid);
	*res = i->batCacheid;
	return MAL_SUCCEED;
}

str BKCoid_bat_append_val_wrap( int *r, int *bid, ptr u)
{
        oid o;
	BAT *i;
	@:getBATdescriptor2(r,bid,i,append)@

	assert(i->htype == TYPE_oid);
	BATmax(BATmirror(i),&o);
	o++;
	@:derefStr(i,t,u)@
	BUNins( i, (ptr) & o, u );
	BBPfix(i->batCacheid);
	*r = i->batCacheid;
	return MAL_SUCCEED;
}


str BKCbat_append_val_wrap( int *r, int *bid, ptr u)
{
	BAT *i;
	oid h;
	@:getBATdescriptor2(r,bid,i,append)@
	h = i->hseqbase + BATcount(i);
	@:derefStr(i,t,u)@
	BUNins( i, (ptr) & h, u );
	BBPfix(i->batCacheid);
	*r = i->batCacheid;
	return MAL_SUCCEED;
}

str BKCbat_replace_oid_bat_wrap( int *r, int *bod, int *did )
{
	BAT *o, *d;
	@:getBATdescriptor2(r,bod,o,replace)@
	@:getBATdescriptor2(r,did,d,replace)@
	void_replace_bat( o, d );
	BBPfix(o->batCacheid);
	*r = o->batCacheid;
	return MAL_SUCCEED;
}
/*end of SQL enhancement */

str BKCgetAlpha(int *r, int *bid) {
	BAT *b,*c;
	@:getBATdescriptor(r,bid,b,getInserted)@
	BBPfix(b->batCacheid);
	c= BATalpha(b);
	*r = c->batCacheid;
	return MAL_SUCCEED;
}
str BKCgetDelta(int *r, int *bid) {
	BAT *b,*c;
	@:getBATdescriptor(r,bid,b,getInserted)@
	BBPfix(b->batCacheid);
	c= BATdelta(b);
	*r = c->batCacheid;
	return MAL_SUCCEED;
}
str BKCgetCapacity(lng *res, int *bid) {
	CMDcapacity(res,bid);
	return MAL_SUCCEED;
}

str BKCgetHeadType(str *res, int *bid) {
	CMDhead(res,bid);
	return MAL_SUCCEED;
}
str BKCgetTailType(str *res, int *bid) {
	CMDtail(res,bid);
	return MAL_SUCCEED;
}
str BKCgetRole(str *res, int *bid) {
	BAT *b;
	@:getBATdescriptor(res,bid,b,getType)@
	*res = GDKstrdup((*bid > 0)?b->hident:b->tident);
	return MAL_SUCCEED;
}

str BKCsetkey(int *res, int *bid, bit *param) {
	BAT *b, *bn = NULL;
	(void)bn;
	@:getBATdescriptor(res,bid,b,setkey)@
	CMDsetkey(&bn,b,param);
	*res = b->batCacheid;
        return MAL_SUCCEED;
}

str BKCsetSet(int *res, int *bid, bit *param) {
	BAT *b, *bn = NULL;
	(void) bn;
	@:getBATdescriptor(res,bid,b,setSet)@
	CMDsetset(&bn,b,param);
	*res = b->batCacheid;
        return MAL_SUCCEED;
}
str BKCisaSet(int *res, int *bid) {
	BAT *b;
	@:getBATdescriptor(res,bid,b,setSet)@
	*res = b->batSet;
        return MAL_SUCCEED;
}

str BKCsetSorted(bit *res, int *bid) {
	BAT *b;
	@:getBATdescriptor(res,bid,b,isSorted)@
	CMDordered(res,b);
        *res = BATordered(b)?1:0;
        return MAL_SUCCEED;
}
str BKCisSorted(bit *res, int *bid) {
	BAT *b;
	@:getBATdescriptor(res,bid,b,isSorted)@
        *res = BATordered(b)?1:0;
        return MAL_SUCCEED;
}
str BKCisSortedReverse(bit *res, int *bid) {
        BAT *b;
        @:getBATdescriptor(res,bid,b,isSorted)@
        *res = BATordered_rev(b)?1:0;
        return MAL_SUCCEED;
}
@-
We must take care of the special case of a nil column (TYPE_void,seqbase=nil)
such nil columns never set hkey (and BUNins will never invalidate it if set) yet
a nil column of a BAT with <= 1 entries does not contain doubles => return TRUE.
@c

str BKCgetKey(bit *ret, int *bid) {
	BAT *b;
	@:getBATdescriptor(ret,bid,b,setPersistence)@
	CMDgetkey(ret,b);
	return MAL_SUCCEED;
}

str BKCsetPersistent(int *res, int *bid) {
	BAT *b, *bn= NULL;
	bit param= 1;
	@:getBATdescriptor(res,bid,b,setPersistence)@
	CMDpersists(&bn,b,&param);
	*res = TRUE;
        return MAL_SUCCEED;
}
str BKCisPersistent(int *res, int *bid) {
	BAT *b;
	@:getBATdescriptor(res,bid,b,setPersistence)@
	*res= (b->batPersistence == PERSISTENT)? TRUE:FALSE;
        return MAL_SUCCEED;
}
str BKCsetTransient(int *res, int *bid) {
	BAT *b;
	@:getBATdescriptor(res,bid,b,setTransient)@
	BATmode(b, TRANSIENT);
	*res= TRUE;
        return MAL_SUCCEED;
}
str BKCisTransient(bit *res, int *bid) {
	BAT *b;
	@:getBATdescriptor(res,bid,b,setTransient)@
	*res= b->batPersistence == TRANSIENT;
        return MAL_SUCCEED;
}
@-
@= accessMode
str BKCset@1(int *res, int *bid) {
	BAT *b, *bn = NULL;
	int param=@2;
	(void) bn;
	@:getBATdescriptor(res,bid,b,set@1)@
	CMDsetaccess(&bn,b,&param);
        return MAL_SUCCEED;
}
str BKChas@1(bit *res, int *bid) {
	BAT *b;
	@:getBATdescriptor(res,bid,b,set@1)@
	*res = BATgetaccess(b)=='@3';
        return MAL_SUCCEED;
}
@-
@c
	@:accessMode(WriteMode,0,w)@
	@:accessMode(ReadMode,1,r)@
	@:accessMode(AppendMode,2,a)@

str BKCsetAccess(int *res, int *bid, str *param) {
	BAT *b,*bn = NULL;
	int m;
	(void) bn;
	@:getBATdescriptor(res,bid,b,setAccess)@
	switch(*param[0]){
	case 'r':m= 1; break;
	case 'a':m= 2; break;
	case 'w':m= 0; break;
	default:
		*res = 0;
		return throwMessage("bat.setAccess", " illegal access mode");
	}
	CMDsetaccess(&bn,b,&m);
	*res = b->batCacheid;
        return MAL_SUCCEED;
}

str BKCgetAccess(char *res, int *bid) {
	BAT *b;
	@:getBATdescriptor(res,bid,b,getAccess)@
	switch(BATgetaccess(b)){
	case 1: *res= 'r'; break;
	case 2: *res= 'a'; break;
	case 0: *res= 'w'; break;
	}
        return MAL_SUCCEED;
}

@- Property management
All property operators should ensure exclusive access to the BAT
descriptor.
@c
str BKCinfo(int *retval, int *bid){
	BAT *bn = NULL, *b;

	@:getBATdescriptor(retval,bid,b,getAccess)@
	if( b== 0) return throwMessage("BKCinfo","no such bat.\n");
	if( CMDinfo(&bn,b) == GDK_SUCCEED){
		*retval = bn->batCacheid;
		return MAL_SUCCEED;
	}
	return throwMessage("BKCinfo","GDKerror");
}

#define ROUND_UP(x,y) ((y)*(((x)+(y)-1)/(y)))

str BKCbatsize(int *tot, int *bid){
	BAT *b;
	@:getBATdescriptor(tot,bid,b,batsize)@
	return MAL_SUCCEED;
}

str BKCbatsize_str(int *tot, str batname){
        bat bid = BBPindex(batname);
        if (bid == 0) {
                return throwMessage("BKCbatsizes","no such bat.\n");
        }
        return BKCbatsize(tot, &bid);
}
@+ Synced BATs
@c
str BKCisSynced(bit *ret, int *bid1, int *bid2){
	BAT *b1, *b2;
	@:getBATdescriptor(ret,bid1,b1,isSynced)@
	@:getBATdescriptor(ret,bid2,b2,isSynced)@
	CMDsynced(ret,b1,b2);
	return MAL_SUCCEED;
}
@+ Role Management
@c
str BKCsetRole(int *r, int *bid, str *hname, str *tname){
	BAT *b;
	@:getBATdescriptor(r,bid,b,setRole)@
	if(*hname== 0) return throwMessage("bat.setRole", "head name missing");
	if(*tname== 0) return throwMessage("bat.setRole", "tail name missing");
	BATroles(b, *hname, *tname);
	*r= b->batCacheid;
	BBPfix(b->batCacheid);
	return MAL_SUCCEED;
}
str BKCsetColumn(int *r, int *bid, str *tname){
	BAT *b;
	@:getBATdescriptor(r,bid,b,setColumn)@
	if(*tname==0) return throwMessage("bat.setColumn", "column name missing");
	BBPfix(b->batCacheid);
	BATroles(b, b->hident,*tname);
	*r= b->batCacheid;
	return MAL_SUCCEED;
}
str BKCsetColumns(int *r, int *bid, str *hname, str *tname){
        BAT *b;
        @:getBATdescriptor(r,bid,b,setColumns)@
        BATroles(b, *hname, *tname);
        *r= b->batCacheid;
        BBPfix(b->batCacheid);
        return MAL_SUCCEED;
}


str BKCsetName(bit *retval, int *bid, str *s){
	BAT *b;
	@:getBATdescriptor(retval,bid,b,setName)@
	CMDrename(retval, b, *s);
	return MAL_SUCCEED;
}

str BKCgetBBPname(str *retval, int *bid){
	BAT *b;
	@:getBATdescriptor(retval,bid,b,getBBPname)@
	*retval = GDKstrdup(BBPname(b->batCacheid));
	return MAL_SUCCEED;
}

str BKCunload(bit *res, str *input) {
	CMDunload(res, *input);
        return MAL_SUCCEED;
}
str BKCisCached(int *res, int *bid) {
	BAT *b;
	@:getBATdescriptor(res,bid,b,isCached)@
	*res = 0;
	return throwMessage("bat.isCached", "not yet implemented");
}
str BKCload(int *res, str *input) {
	bat bid= BBPindex(*input);
	*res = bid;
        if( bid) return MAL_SUCCEED;
	return throwMessage("bat.unload", " file name missing");
}

str BKChot(int *res, str *input) {
	(void)res; /* fool compiler */
	BBPhot(BBPindex(*input));
	return MAL_SUCCEED;
}

str BKCcold(int *res, str *input) {
	(void)res; /* fool compiler */
	BBPcold(BBPindex(*input));
	return MAL_SUCCEED;
}
str BKCcoldBAT(int *res, int *bid) {
	BAT *b;
	(void)res; (void)bid; /* fool compiler */
	@:getBATdescriptor(res,bid,b,isCached)@
	BBPcold(b->batCacheid);
	return MAL_SUCCEED;
}
str BKCheat(int *res, str *input) {
	int bid = BBPindex(*input);
	if (bid) {
		*res = BBP_lastused(bid) & 0x7fffffff;
	}
 	return throwMessage("bat","heat not yet implemented\n");
 }
str BKChotBAT(int *res, int *bid) {
	BAT *b;
	(void)res; /* fool compiler */
	@:getBATdescriptor(res,bid,b,isCached)@
	BBPhot(b->batCacheid);
	return MAL_SUCCEED;
}
str BKCsave(bit *res, str *input) {
	CMDsave(res, *input);
        return MAL_SUCCEED;
}
str BKCsave2(bit *res, int *bid) {
	BAT *b;
	@:getBATdescriptor2(res,bid,b,save)@
	
	if (b && BATdirty(b)) {
		if (BBPsave(b) == 0) *res = TRUE;
	}
	BBPunfix(*bid);
        return MAL_SUCCEED;
}

@c
str BKCmmap(int *res, int *bid, int *bns, int *hhp, int *thp,
			int *hacc, int *tacc)
{	BAT *b, *bn = NULL;
	(void) bn;
	@:getBATdescriptor(res,bid,b,mmap)@
	if( CMDmmap(&bn,b,bns,hhp,thp,hacc,tacc) == GDK_SUCCEED){
		*res= TRUE;
		return MAL_SUCCEED;
	}
	*res= FALSE;
	return throwMessage("bat.mmap", " failed");
}
str BKCmmap2(int *res, int *bid, int *bns){
	return BKCmmap(res,bid,bns,bns,bns,bns,bns);
}

str BKCmadvise(int *res, int *bid, int *bns, int *hhp, int *thp,
		 	        int *hacc, int *tacc)
{	BAT *b;
	@:getBATdescriptor(res,bid,b,madvice)@
	*res= BATmadvise(b, (*bns==int_nil)?-1:*bns,
		(*hhp==int_nil)?-1:*hhp, (*thp==int_nil)?-1:*thp,
		(*hacc==int_nil)?-1:*hacc,
		(*tacc==int_nil)?-1:*tacc);
	if( *res) return throwMessage("bat.madvise", " failed");
	return MAL_SUCCEED;
}
str BKCmadvise2(int *res,  int *bid, int *mode){
	return BKCmadvise(res,bid,mode,mode,mode,mode,mode);
}

@+ Accelerator Control
@c
str BKCaccbuild(int *ret, int *bid, int* acc, ptr *param){
	BAT *b;
	int dummy = 0;
	@:getBATdescriptor(ret,bid,b,accbuild)@
	CMDaccbuild(b,acc, *param, dummy);
	*ret= TRUE;
	return MAL_SUCCEED;
	/* return throwMessage("Accelerator","Obsolete functionality");*/
}
str BKCaccbuild_std(int *ret, int *bid, int* acc){
	ptr n= NULL;
	BKCaccbuild(ret,bid, acc, &n);
	return MAL_SUCCEED;
	/* return throwMessage("Accelerator","Obsolete functionality");*/
}

str BKCaccdestroy(int *ret, int *bid, int *acc) {
	BAT *b;
	@:getBATdescriptor(ret,bid,b,accdestroy)@
	CMDaccdestroy(b,acc);
	*ret = TRUE;
	return MAL_SUCCEED;
	/* return throwMessage("Accelerator","Obsolete functionality");*/
}

str BKCaccpresent(int *ret, int *bid) {
	BAT *b;
	@:getBATdescriptor(ret,bid,b,accpresent)@
	CMDaccpresent(ret,b);
	return MAL_SUCCEED;
	/* return throwMessage("Accelerator","Obsolete functionality");*/
}


str BKChasHash(bit *ret, int *bid) {
	BAT *b;
	(void)ret; /* fool compiler */
	@:getBATdescriptor(ret,bid,b,hasHash)@
	*ret = b->hacctype == 1;
	return MAL_SUCCEED;
}
str BKCsetHash(bit *ret, int *bid, bit *prop) {
	BAT *b;
	(void)ret; (void) prop; /* fool compiler */
	@:getBATdescriptor(ret,bid,b,setHash)@
	BAThash(b,0);
	return MAL_SUCCEED;
}
str BKChasIndex(bit *ret, int *bid) {
	BAT *b;
	@:getBATdescriptor(ret,bid,b,hasIndex)@
	*ret = b->hacctype == 2;
	return throwMessage("bat.hasIndex", " not yet implemented");
}
str BKCsetIndex(bit *ret, int *bid, bit *prop) {
	BAT *b;
	(void) prop; /* fool compiler */
	@:getBATdescriptor(ret,bid,b,setIndex)@
	return throwMessage("bat.setIndex", " not yet implemented");
}

str BKCsetSequenceBase(int *r, int *bid, oid* o){
	BAT *b;
	@:getBATdescriptor(r,bid,b,seqbase)@
	BATseqbase(b, *o);
	return MAL_SUCCEED;
}
str BKCgetSequenceBase(oid *r, int *bid){
	BAT *b;
	@:getBATdescriptor(r,bid,b,seqbase)@
	*r = b->hseqbase;
	return MAL_SUCCEED;
}
@}
@}
