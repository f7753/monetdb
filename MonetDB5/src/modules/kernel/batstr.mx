@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2005 CWI.
@' All Rights Reserved.

@f batstr
@a M.L. Kersten
@* String multiplexes
[TODO: property propagations]
The collection of routines provided here are map operations
for the atom string primitives. 

In line with the batcalc module, we assume that
if two bat operands are provided that they are already
aligned on the head. Moreover, the head of the BATs
are limited to :void, which can be cheaply realized using
the GRPsplit operation.
@mal
module batstr;
command str(b:bat[:void,:str]):bat[:void,:str]
address STRbattostr
comment "Identity mapping for string bats";

command length( s:bat[:void,:str] ) :bat[:void,:int]
address STRbatLength
comment "Return the length of a string.";

command bytes( s:bat[:void,:str] ) :bat[:void,:int]
address STRbatBytes
comment "Return the string length in bytes.";

command chrAt( s:bat[:void,:str], index:bat[:void,:int]) :bat[:void,:chr]
address STRbatChrAt
comment "String array lookup operation.";

command match(b:bat[:void,:str], pat:str):bat[:void,:bit]
address STRbatmatchCst
comment "POSIX pattern matching against a string BAT";

command ==( l:bat[:void,:str], r:str) :bat[:void,:bit]
address STRbatEqualCst
comment "Equate a bat of strings against a singleton";

command ==( l:bat[:void,:str], r:bat[:void,:str]) :bat[:void,:bit]
address STRbatEqual
comment "Equate a bat of strings against each other";

command toLower( s:bat[:void,:str] ) :bat[:void,:str]
address STRbatLower
comment "Convert a string to lower case.";
command toUpper( s:bat[:void,:str] ) :bat[:void,:str]
address STRbatUpper
comment "Convert a string to upper case.";

command trim( s:bat[:void,:str] ) :bat[:void,:str]
address STRbatStrip
comment "Strip whitespaces around a string.";
command ltrim( s:bat[:void,:str] ) :bat[:void,:str]
address STRbatLtrim
comment "Strip whitespaces from start of a string.";
command rtrim( s:bat[:void,:str] ) :bat[:void,:str]
address STRbatRtrim
comment "Strip whitespaces from end of a string.";

command startsWith(s:bat[:void,:str],prefix:bat[:void,:str]):bat[:void,:str]
address STRbatPrefix
comment "Prefix check.";
command endsWith( s:bat[:void,:str], suffix:bat[:void,:str] ) :bat[:void,:bit]
address STRbatSuffix
comment "Suffix check.";

command search( s:bat[:void,:str], c:bat[:void,:str] ) :bat[:void,:int]
address STRbatstrSearch
comment "Search for a substring. Returns position, -1 if not found.";

command r_search( s:bat[:void,:str], c:bat[:void,:str] ) :bat[:void,:int]
address STRbatRstrSearch
comment "Reverse search for a substring. Returns position, -1 if not found.";

command +( l:bat[:void,:str], r:bat[:void,:str]) :bat[:void,:str]
address STRbatConcat
comment "Concatenate two strings.";

command string(b:bat[:void,:str],offset:bat[:void,:int]) :bat[:void,:str]
address STRbatTail
comment "Return the tail s[offset..n] of a string s[0..n].";

command unicodeAt(s:bat[:void,:str], index:bat[:void,:int]) :bat[:void,:int]
address STRbatWChrAt
comment "get a unicode character (as an int) from a string position.";

@-
not now
command string(s:bat[:void,:str],offset:int,count:int):bat[:void:str]
address STRbatSubString
comment "Return substring s[offset..offset+count] of a string s[0..n]";

command unicode(wchar:bat[:void,:int]) :bat[:void,:str]
address STRbatFromWChr
comment "convert a unicode to a character.";

comment "Return the locale's codeset";
command iconv(org:bat[:void,:str],fromCs:bat[:void,:str],
		toCs:bat[:void,:str]):bat[:void,:str]
address STRIbatconv
comment "String codeset conversion";

command search( s:bat[:void,:str], c:bat[:void,:chr] ) :bat[:void,:int]
address STRbatchrSearch
comment "Search for a character. Returns position, -1 if not found.";

command r_search( s:bat[:void,:str], c:bat[:void,:chr] ) :bat[:void,:int]
address STRReverseChrSearch
comment "Reverse search for a char. Returns position, -1 if not found.";

command substitute(s:bat[:void,:str],src:bat[:void,:str],dst:bat[:void,:str],rep:bat[:void,:bit]):bat[:void,:str]
address STRbatSubstitute
comment "Substitute first occurrence of 'src' by
	'dst'.  Iff repeated = true this is
	repeated while 'src' can be found in the
	result string. In order to prevent
	recursion and result strings of unlimited
	size, repeating is only done iff src is
	not a substring of dst.";

@+ Implementation
@c
#include <gdk.h>
#include "ctype.h"
#include <string.h>
#include "mal_exception.h"
#include "str.h"
#include <regex.h>

#ifdef HAVE_LANGINFO_H
#include <langinfo.h>
#endif
#ifdef HAVE_ICONV_H
#include <iconv.h>
#endif

#define prepareOperand(X,Y,Z) \
	if( (X= BATdescriptor(*Y)) == NULL ) \
	    return throwMessage("batstr." Z, "Cannot access descriptor");
#define prepareOperand2(X,Y,A,B,Z) \
	if( (X= BATdescriptor(*Y)) == NULL ) \
	    return throwMessage("batstr." Z, "Cannot access descriptor"); \
	if( (A= BATdescriptor(*B)) == NULL ){\
		BBPunfix(X->batCacheid); \
	    return throwMessage("batstr."Z, "Cannot access descriptor"); \
	}
#define prepareResult(X,Y,T,Z) \
	X= BATnew(Y->htype,T,BATcount(Y)); \
	if( Y->htype== TYPE_void) \
		BATseqbase(X, Y->hseqbase); \
	Y->hsorted=X->hsorted; \
	if( X == NULL){ \
	    BBPunfix(Y->batCacheid); \
	    return throwMessage("batstr." Z, "no space available "); \
	}
#define prepareResult2(X,Y,A,T,Z) \
	X= BATnew(Y->htype,T,BATcount(Y)); \
	if( Y->htype== TYPE_void) \
		BATseqbase(X, Y->hseqbase); \
	Y->hsorted=X->hsorted; \
	if( X == NULL){ \
	    BBPunfix(Y->batCacheid); \
	    BBPunfix(A->batCacheid); \
	    return throwMessage("batstr." Z, "no space available "); \
	}
#define finalizeResult(X,Y,Z) \
	BBPincref(*X = Y->batCacheid,TRUE);\
	BBPunfix(*X);\
	BBPunfix(Z->batCacheid);
@= BATint
str STRbat@1(int *ret, int *l)
{   BAT *bn, *b;
	BUN p,q;
	int xx;
	@3 x;
	int y, *yp = &y;

	prepareOperand(b,l,"@1");
	prepareResult(bn,b,TYPE_int,"@1");

	BATloopFast(b, p, q, xx) {
	    ptr h = BUNhead(b,p);
	    x= (@3) BUNtail(b,p);
		if(x== 0 || *x == 0 || strcmp(x,@3_nil)== 0)
			y= int_nil;
		else @2(yp,x);
	    bunfastins(bn, h, yp);
	}
	finalizeResult(ret,bn,b);
	return MAL_SUCCEED;
bunins_failed:
	BBPunfix(b->batCacheid);
	BBPunfix(bn->batCacheid);
	return throwMessage("batstr.==", "bunins failed");
}

@c
	@:BATint(Length,strLength,str)@
	@:BATint(Bytes,strBytes,str)@
@= BATstr
str STRbat@1(int *ret, int *l)
{   BAT *bn, *b;
	BUN p,q;
	int xx;
	@3 x;
	@4 y, *yp = &y;

	prepareOperand(b,l,"@1");
	prepareResult(bn,b,TYPE_@4,"@1");

	BATloopFast(b, p, q, xx) {
	    ptr h = BUNhead(b,p);
	    x= (@3) BUNtail(b,p);
		if(x== 0 || *x == 0 || strcmp(x,@3_nil)== 0)
			y= @4_nil;
		else @2(yp,x);
	    bunfastins(bn, h, *yp);
	}
	finalizeResult(ret,bn,b);
	return MAL_SUCCEED;
bunins_failed:
	BBPunfix(b->batCacheid);
	BBPunfix(bn->batCacheid);
	return throwMessage("batstr.==", "bunins failed");
}
@c
	@:BATstr(Lower,strLower,str,str)@
	@:BATstr(Upper,strUpper,str,str)@
	@:BATstr(Strip,strStrip,str,str)@
	@:BATstr(Ltrim,strLtrim,str,str)@
	@:BATstr(Rtrim,strRtrim,str,str)@
@-
@c
str STRbatEqualCst(int *ret, int *l,str *cst)
{   BAT *bn, *b;
	BUN p,q;
	int xx;
	str x;
	bit y;

	prepareOperand(b,l,"==");
	prepareResult(bn,b,TYPE_bit,"==");
	BATloopFast(b, p, q, xx) {
	    ptr h = BUNhead(b,p);
	    x= (str) BUNtail(b,p);
		if(x== 0 || *x == 0 || strcmp(x,str_nil)== 0)
			y= bit_nil;
		else y= strcmp(x,*cst)==0;
	    bunfastins(bn, h, &y);
	}
	finalizeResult(ret,bn,b);
	return MAL_SUCCEED;
bunins_failed:
	BBPunfix(b->batCacheid);
	BBPunfix(bn->batCacheid);
	return throwMessage("batstr.==", "bunins failed");
}
@-
A general assumption in all cases is the bats are synchronized on their
head column. This is not checked and may be mis-used to deploy the
implementation for shifted window arithmetic as well.
@= chkSize
	if( BATcount(@1) != BATcount(@2) )
	return throwMessage("batcalc.@3", "requires bats of identical size");
@c
str STRbatEqual(int *ret, int *l, int *r)
{   BAT *bn, *left, *right;
	BUN o,p,q;
	int xx,yy;

	prepareOperand2(left,l,right,r,"==");
	@:chkSize(left,right,CMDcompare@1)@
	prepareResult2(bn,left,right,TYPE_bit,"==");

	o = BUNfirst(left);
	p = BUNfirst(right);
	q = BUNlast(right);
	xx = BUNsize(left);
	yy = BUNsize(right);
	while(p<q) {
		bit y = TRUE;
	    ptr h = BUNhead(left,o);
	    ptr tl = BUNtail(left,o);
	    ptr tr = BUNtail(right,p);
	if(tl == 0 || tr == 0 || strcmp(tl,tr) != 0)
		y = FALSE;
	    bunfastins(bn, h, &y);
	o += xx;
	p += yy;
	}
	BBPunfix(right->batCacheid);
	finalizeResult(ret,bn,left);
	return MAL_SUCCEED;

bunins_failed:
	BBPunfix(left->batCacheid);
	BBPunfix(right->batCacheid);
	BBPunfix(*ret);
	return throwMessage("batstr.==", "bunins failed");
}
@= binarySTR
str STRbat@1(int *ret, int *l, int *r)
{   BAT *bn, *left, *right;
	BUN o,p,q;
	int xx,yy;
	@2 v, *vp= &v;

	prepareOperand2(left,l,right,r,@4);
	@:chkSize(left,right,CMDcompare@1)@
	prepareResult2(bn,left,right,TYPE_@2,@4);

	o = BUNfirst(left);
	p = BUNfirst(right);
	q = BUNlast(right);
	xx = BUNsize(left);
	yy = BUNsize(right);
	while(p<q) {
	    ptr h = BUNhead(left,o);
	    ptr tl = BUNtail(left,o);
	    ptr tr = BUNtail(right,p);
		@3(vp, tl, tr);
		bunfastins(bn, h, vp);
		o += xx;
		p += yy;
	}
	BBPunfix(right->batCacheid);
	finalizeResult(ret,bn,left);
	return MAL_SUCCEED;

bunins_failed:
	BBPunfix(left->batCacheid);
	BBPunfix(right->batCacheid);
	BBPunfix(*ret);
	return throwMessage("batstr.==", "bunins failed");
}
@= binarySTRint
str STRbat@1(int *ret, int *l, int *cst)
{   BAT *bn, *left;
	BUN p,q;
	int xx;
	@2 v, *vp= &v;

	prepareOperand(left,l,@4);
	prepareResult(bn,left,TYPE_@2,@4);

	p = BUNfirst(left);
	q = BUNlast(left);
	xx = BUNsize(left);
	while(p<q) {
	    ptr h = BUNhead(left,p);
	    ptr tl = BUNtail(left,p);
		@3(vp, tl, cst);
		bunfastins(bn, h, vp);
		p += xx;
	}
	finalizeResult(ret,bn,left);
	return MAL_SUCCEED;

bunins_failed:
	BBPunfix(left->batCacheid);
	BBPunfix(*ret);
	return throwMessage("batstr.==", "bunins failed");
}
@c
	@:binarySTR(Prefix,bit, strPrefix,"prefix")@
	@:binarySTR(Suffix,bit, strSuffix,"suffix")@
	@:binarySTR(strSearch,int, strStrSearch,"search")@
	@:binarySTR(RstrSearch,int, strReverseStrSearch,"r_search")@
	@:binarySTRint(Tail,str,strTail,"tail")@
@-
	@:binarySTRint(ChrAt,int,strChrAt,"chrAt")@

str STRbatConcat(int *ret, int *l, int *r)
{   BAT *bn, *left, *right;
	BUN o,p,q;
	int xx,yy;
	str v, *vp= &v;

	prepareOperand2(left,l,right,r,"+");
	@:chkSize(left,right,STRconcat)@
	prepareResult2(bn,left,right,TYPE_str,"+");

	o = BUNfirst(left);
	p = BUNfirst(right);
	q = BUNlast(right);
	xx = BUNsize(left);
	yy = BUNsize(right);
	while(p<q) {
	    ptr h = BUNhead(left,o);
	    ptr tl = BUNtail(left,o);
	    ptr tr = BUNtail(right,p);
		strConcat(vp, tl, tr, TYPE_str);
		bunfastins(bn, h, v);
		o += xx;
		p += yy;
	}
	BBPunfix(right->batCacheid);
	finalizeResult(ret,bn,left);
	return MAL_SUCCEED;

bunins_failed:
	BBPunfix(right->batCacheid);
	BBPunfix(left->batCacheid);
	BBPunfix(*ret);
	return throwMessage("batstr.==", "bunins failed");
}

str
STRbattostr(int *ret, int *bid){
	BBPincref(*ret= *bid,TRUE);
	return MAL_SUCCEED;
}

str STRbatmatchCst(int  *ret, int *bid, str *pat){
	regex_t prg;
	BAT *b, *bn;
	int tpe,xx;
	BUN p,q;
	ptr nilptr;
	int error= regcomp(&prg, *pat, REG_EXTENDED | REG_NOSUB);
	if( error<0)
		return throwMessage("str.match",
				"Compilation of regular expression failed");

	prepareOperand(b,bid,"match");
	bn= BATnew(BAThtype(b), TYPE_bit, BATcount(b));

	tpe= BATttype(b);
	nilptr= ATOMnilptr(tpe);
	BATloopFast(b, p, q, xx) {
		ptr h = BUNhead(b,p);
		ptr t = BUNtail(b,p);

		if( ATOMcmp(tpe, t, nilptr)==0 ){
			bunfastins(bn, h, t);
		} else {
			bit match=  regexec(&prg,t,0,0,0)==0;
			bunfastins(bn, h, &match);
		}
	}
bunins_failed:
	BBPincref( *ret= bn->batCacheid,TRUE);
	BBPunfix(b->batCacheid);
	return MAL_SUCCEED;
}

@}
