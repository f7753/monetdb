@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2003 CWI.
@' All Rights Reserved.
@'
@' Contributor(s):
@'              Martin Kersten <Martin.Kersten@cwi.nl>
@'              Peter Boncz <Peter.Boncz@cwi.nl>
@'              Niels Nes <Niels.Nes@cwi.nl>
@'              Stefan Manegold  <Stefan.Manegold@cwi.nl>

@f uchr
@t The uchr module
@a Niels Nes
@v 1.0
@* Introduction
@T
The uchr atom is just a chr but uses numerical string representations.


@* Implementation

@+ MEL definition
@mal
atom module uchr:chr;
command fromstr() = uchr_fromstr;
command tostr()   = uchr_tostr;

command uchr(s:str):uchr = uchr_createStr;
command uchr(i:int):uchr = uchr_createInt;
command uchr(i:sht):uchr = uchr_createSht;
command uchr(i:lng):uchr = uchr_createLng;

command uchrInit():void= uchrInit;
uchrInit();
@+ C implementation
@c
/* #define DEBUG */

@h
#ifndef _UCHR_H
#define _UCHR_H
typedef unsigned char uchr;

#define uchr_nil ((uchr)chr_nil)
@-
Type-mappers for convenience
@= HT_bunfastins_typemap
#define @1@2_bunfastins_nocheck_noinc(b, p, h, t) @1@3_bunfastins_nocheck_noinc(b, p, h, t)
#define @1@2_bunfastins_nocheck(b, p, h, t, s)    @1@3_bunfastins_nocheck(b, p, h, t, s)
#define @1@2_bunfastins(b, h, t) @1@3_bunfastins_nocheck_noinc(b, h, t)
#define @2@1_bunfastins_nocheck_noinc(b, p, h, t) @3@1_bunfastins_nocheck_noinc(b, p, h, t)
#define @2@1_bunfastins_nocheck(b, p, h, t, s)    @3@1_bunfastins_nocheck(b, p, h, t, s)
#define @2@1_bunfastins(b, h, t) @3@1_bunfastins_nocheck_noinc(b, h, t)
@h
@:HT_bunfastins_typemap(void,uchr,chr)@
@:HT_bunfastins_typemap(oid,uchr,chr)@
@:HT_bunfastins_typemap(chr,uchr,chr)@
@:HT_bunfastins_typemap(sht,uchr,chr)@
@:HT_bunfastins_typemap(int,uchr,chr)@
@:HT_bunfastins_typemap(lng,uchr,chr)@
@:HT_bunfastins_typemap(any,uchr,chr)@
extern int TYPE_uchr;
#endif
@c
#include "uchr.h"
#include "gdk.h"
#include "mal.h"

int TYPE_uchr;
@- Atom commands
@c

str uchrInit(int *ret){
	TYPE_uchr= ATOMindex("uchr");
	return MAL_SUCCEED;
}
int uchr_fromstr(str uchrStr, int *len, uchr** c) {
	char *end = NULL;
	char *p= uchrStr;

#ifdef DEBUG
	printf("* uchr_fromstr:\n");
	printf("  - uchrStr: %s\n",(uchrStr!=NULL?uchrStr:"null"));
	printf("  - *len: %d\n",*len);
#endif

	if (!*c){
		*c = (uchr*)GDKmalloc(sizeof(uchr));
	} else if (*len < sizeof(uchr)){
		GDKfree(*c);
		*c = GDKmalloc(sizeof(uchr));
		*len = sizeof(uchr);
	}

	while(GDKisspace(*p)) p++;
	if (p[0] == 'n' && p[1] == 'i' && p[2] == 'l') {
		char **sc = (char**)c;
		**sc = chr_nil;
		p += 3;
	} else {
		**c = (uchr)strtol(p, &p, 10);
	}


#ifdef DEBUG
	printf("  = *c: %d\n", (int)**c);
	printf("  = *len: %d\n",*len);
#endif

	return end-uchrStr;
}

int uchr_tostr(char **uchrStr, int *len, uchr *c) {

#ifdef DEBUG
	printf("* uchr_tostr:\n");
	printf("  - *len: %d\n",*len);
	printf("  - c: %s\n",(c!=NULL?c:"null"));
#endif

	/* allocate and fill a new string */
	
	if (*len < 4) {
		GDKfree(*uchrStr);
		*uchrStr = GDKmalloc(4);
		*len = 4;
	}
	if( *c== chr_nil){
		strcpy(*uchrStr,"nil");
		return 3;
	}
	snprintf(*uchrStr, *len,"%u",(int)*c);

#ifdef DEBUG
	printf("  = *uchrStr: %s\n",*uchrStr);
	printf("  = *len: %d\n",*len);
#endif
	return strlen(*uchrStr);
}

str uchr_createLng(uchr *ret, lng *i){
	*ret= *i;
	return MAL_SUCCEED;
}

str uchr_createSht(uchr *ret, sht *i){
	*ret= *i;
	return MAL_SUCCEED;
}

str uchr_createInt(uchr *ret, int *i){
	*ret= *i;
	return MAL_SUCCEED;
}

str uchr_createStr(uchr *ret, str *s){
	int i = strtol(*s,NULL,0);
	*ret= i;
	return MAL_SUCCEED;
}
@mil
var b := new(int, uchr);
b.insert(1,uchr(1));
