@a N.J. Nes, M.L. Kersten
@v 1.1
@t The "string" module

@* Introduction
@T
Strings can be created in many ways. Already in the built-in operations
each atom can be cast to a string using the str(atom) mil command.
The string module gives the possiblity of construction string as a
substring of the a given string (s). There are two such construction functions.
The first is the substring from some position (offset) until the end of
the string. The second start again on the given offset position but only
copies count number of bytes. The functions fail when the position and
count fall out of bounds. A negative position indicates that the position is
computed from the end of the source string.

The strings can be compared using the "=" and "!=" operators.

The operator "+" concatenates a string and an atom. The atom will be
converted to a string using the atom to string c function. The
string and the result of the conversion are concatenated to form a new
string. This string is returned.

The length function returns the length of the string. The length is
the number of characters in the string.

chrAt() returns the character at position index in the string s. The
function will fail when the index is out of range. The range is
from 0 to length(s)-1.

The startWith and endsWith functions test if the string s starts with or
ends with the given prefix or suffix.

The toLower and toUpper functions cast the string to lower or upper case
characters.

The search(str,chr) function searches for the first occurrence of a 
charachter from the begining of the string. The search(chr,str) searches
for the last occurence (or first from the end of the string). The last
search function locates the possition of first occurence of the string s2 
in string s. All search functions return -1 when the search failed.
Otherwise the position is returned.

All string functions fail when an incorrect string (.NULL pointer) is given.
In the current implementation, a fail is signaled by returning nil, since
this facilitates the use of the string module in bulk operations.

@* Module Definition
@mal
module str;

command str(s:str):str = CMDstr
	comment "Noop routine.";
command string( s:str, offset:int ) : str = STRTail
	comment "Return the tail s[offset..n] of a string s[0..n].";
command string( s:str, offset:int, count:int) : str = STRSubString
	comment "Return substring s[offset..offset+count] of a string s[0..n]";
command +( l:str, r:str) : str = STRConcat
	comment "Concatenate two strings.";
command length( s:str ) : int = STRLength
	comment "Return the length of a string.";
command chrAt( s:str, index:lng) : chr = STRChrAt
	comment "String array lookup operation.";
command chrAt( s:str, index:sht) : chr = STRChrAt
	comment "String array lookup operation.";
command chrAt( s:str, index:int) : chr = STRChrAt
	comment "String array lookup operation.";

command startsWith( s:str, prefix:str ) : bit = STRPrefix
        comment "Prefix check.";
command endsWith( s:str, suffix:str ) : bit = STRSuffix
        comment "Suffix check.";

command toLower( s:str ) : str = STRLower
        comment "Convert a string to lower case.";
command toUpper( s:str ) : str = STRUpper
        comment "Convert a string to upper case.";

command search( s:str, c:chr ) : int = STRChrSearch
	comment "Search for a character. Returns position, -1 if not found.";
command r_search( s:str, c:chr ) : int = STRReverseChrSearch
	comment "Reverse search for a char. Returns position, -1 if not found.";
command search( s:str, s2:str) : int = STRStrSearch
	comment "Search for a substring. Returns position, -1 if not found.";
command r_search( s:str, s2:str ) : int = STRReverseStrSearch
	comment "Reverse search for a substring. 
	Returns position, -1 if not found.";
command trim( s:str ) : str = STRStrip
	comment "Strip whitespaces around a string.";
command ltrim( s:str ) : str = STRLtrim
	comment "Strip whitespaces from start of a string.";
command rtrim( s:str ) : str = STRRtrim
	comment "Strip whitespaces from end of a string.";
command substitute( s:str, src:str, dst:str, repeated:bit) : str = STRSubstitute
	comment "Substitute first occurrence of substring 'src' by 'dst'.
         Iff repeated = true this is repeated while 'src' can be found in 
	 the result string. In order to prevent recursion and result strings 
	 of unlimited size, repeating is only done iff src is not a substring 
	of dst.";


@* Example script
The following script is used for testing the string module. 

@mil
setoid(oid(20000000));

i1 := "This is a test";
i2 := "of the str atomic type";

(("concat an int "+1)+" with a string "+i1+(" with an dbl "+dbl(1.0))).print; 
(("concat an int "+1) + " with a string").print; 

length( i1 ).print;
sres := (i1 + " ") + i2;
sres.print;
len := length(sres);
string( sres, 10).print;
string( sres, -10).print;
string( sres, 10, len - 10 ).print;
string( sres, 10, 10 ).print;
string( sres, -10, 10 ).print;
string( sres, -10, 20 ).print;
string( sres, 10, len).print;
string( sres, len, 10).print;
string( sres, -(len), 10).print; 
string( sres, -(len + 5), 10).print; 
chrAt( sres, 5 ).print;
chrAt( sres, -3).print;
chrAt( sres, len + 20).print;
chrAt( sres, len).print;
chrAt( sres, len - 1).print;
chrAt( sres, 0).print;
startsWith( i2, "of the" ).print;
startsWith( i2, i2 ).print;
startsWith( i2, "k" ).print;
endsWith( i2, "type" ).print;
endsWith( i2, i2 ).print;
endsWith( i2, "k" ).print;
toLower( i1 ).print;
toUpper( i1 ).print;
search( "Hello this is a test for search", 'a' ).print;
r_search( "Hello this is a test for search", 'a' ).print;
search( "Hello this is a test for search", "ar" ).print;
r_search( "Hello this is a test for search", "ar" ).print;
search( "Hello this is a test for search", "is" ).print;
r_search( "Hello this is a test for search", "is" ).print;
search( "Hello this is a test for search", "Hello" ).print;
r_search( "Hello this is a test for search", "Hello" ).print;
search( "Hello this is a test for search", "arch" ).print;
r_search( "Hello this is a test for search", "arch" ).print;
search( "Hello this is a test for search", "xxx" ).print;
r_search( "Hello this is a test for search", "yyy" ).print;


trim("   f ").print;
trim("abc").print;
trim("   x").print;
trim("x   ").print;
trim("").print;
trim(str(nil)).print;
quit;

@{
@* Implementation Code
@h
#ifndef __string_H__
#define __string_H__

#include "str.h"

#endif /* __string_H__ */
@}

@{
@c
/*
 * The contents of this file are subject to the Monet Public
 * License Version 1.1 (the "License"); you may not use this file
 * except in compliance with the License. You may obtain a copy of
 * the License at 
 * http://www.monetsolutions.com/Download/Licensing/MonetPL-1.1.html
 * 
 * Software distributed under the License is distributed on an "AS
 * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
 * implied. See the License for the specific language governing
 * rights and limitations under the License.
 * 
 * The Original Code is the Monet Database System.
 * 
 * The Initial Developer of the Original Code is CWI.
 * Portions created by CWI are Copyright (C) 1997-2002 CWI.  
 * All Rights Reserved.
 * 
 * Contributor(s): Martin Kersten <Martin.Kersten@cwi.nl>
 *		   Niels Nes <Niels.Nes@cwi.nl>
 */

#include <gdk.h>
#include "ctype.h"
#include "str.h"
#include <string.h>
#include "monet.h"

#define RETURN_NIL_IF(b,t) \
	if (b) {\
	   if (ATOMextern(t)) {\
	      *(ptr*) res = (ptr) ATOMnil(t);\
	   } else {\
	      memcpy(res, ATOMnilptr(t), ATOMsize(t));\
 	   }\
	   return MAL_SUCCEED; \
	}

#ifdef MAX
#undef MAX
#endif
#define MAX(x, y) ((x) > (y) ? (x) : (y))

#ifdef MIN
#undef MIN
#endif
#define MIN(x, y) ((x) < (y) ? (x) : (y))

str CMDstr(str *res, str *src){
	*res = GDKstrdup(*src);
	return MAL_SUCCEED;
}
str STRConcat(str *res, str *val1, str *val2){
	str s,t;
	ptr val;
	int l1, l2 ;

	s = *val1;
	t = *val2;

	if( strNil(s)|| strNil(t)) {
		*res= GDKstrdup(str_nil);
		return MAL_SUCCEED;
	}
	l1 = strlen(s);
	l2 = strlen(t);
	*res = (str) GDKmalloc(l1+l2+1);
	memcpy(*res, s, l1);
	memcpy(*res + l1, t, l2);
	(*res)[l1+l2] = '\0';
	return MAL_SUCCEED;
}

str STRLength( int *res, str *arg1 ){
	str s= *arg1;
	RETURN_NIL_IF(strNil(s),TYPE_int);

	*res = strlen(s);
	return MAL_SUCCEED;
}

str STRTail( str *res, str *arg1, int *offset){
	str s = *arg1;
	int l;
	RETURN_NIL_IF(strNil(s)||*offset==int_nil,TYPE_str);
   	l = strlen(s);
	if (*offset >= 0) {
		if (l < (*offset)) {
			*res = GDKstrdup("");
			return MAL_SUCCEED;
		}
		l = l - *offset;
		*res = (char*)GDKmalloc( l+1 );
		strncpy( *res, s+(*offset), l );
		(*res)[l] = 0;
	} else {
		int len = MIN(-(*offset), l);
		*res = GDKmalloc(len + 1);
		l -= len;
		strncpy(*res, s + l, len);
		(*res)[len] = 0;
	} 
	return MAL_SUCCEED;
}

str STRSubString( str *res, str *arg1, int *offset, int *length ){
	str s= *arg1;
	int l, len;
	RETURN_NIL_IF(strNil(s)||*offset==int_nil||*length==int_nil,TYPE_str);
	if (*length < 0) {
		*res = GDKstrdup("");
		return MAL_SUCCEED;
	}
   	l = strlen(s);
	if (*offset >= 0) {
		if (l < *offset) {
			*res = GDKstrdup("");
			return MAL_SUCCEED;
		}
		len = MIN(*length, l - *offset);
 		*res = (char*)GDKmalloc( len+1 );
		strncpy( *res, s+(*offset), len );
		(*res)[len] = 0;
	} else {
		int o = l + *offset;
		len = MIN(l - o, *length);
		if (o < 0) {
			len -= -o;
			o = 0;	
		}
		*res = (char *)GDKmalloc(len + 1);
		strncpy(*res, s + o, len);
		(*res)[len] = 0;
	}
	return MAL_SUCCEED;
}

str STRChrAt( chr *res, str *arg1, int *at ){
	str s= *arg1;
	int l;
	RETURN_NIL_IF(strNil(s)||*at==int_nil,TYPE_chr);
   	l = strlen(s);
	RETURN_NIL_IF(l<=(*at)||(*at)<0, TYPE_chr);
	*res = s[*at];
	return MAL_SUCCEED;
}

str STRPrefix( bit *res, str *arg1, str *arg2 ){
	str s= *arg1, prefix= *arg2;
	int pl, i;

	RETURN_NIL_IF(strNil(s)||strNil(prefix),TYPE_bit);
   	pl = strlen(prefix);
	if ((int)strlen(s)<pl){
		*res = 0;
		return MAL_SUCCEED;
	}
	*res = 1;
	for (i=0; i<pl; i++){
	   	if(s[i] != prefix[i]){
			*res = 0;
			return MAL_SUCCEED;
		}
	}
	return MAL_SUCCEED;
}

str STRSuffix( bit *res, str *arg1, str *arg2 ){
	str s= *arg1, suffix = *arg2;
	int i, sl, sul;
	RETURN_NIL_IF(strNil(s)||strNil(suffix),TYPE_bit);
   	sl = strlen(s);
   	sul = strlen(suffix);

	if (sl<sul){
		*res = 0;
		return MAL_SUCCEED;
	}
	*res = 1;
	for (i=0; i<sul; i++){
	   	if(s[sl-1-i] != suffix[sul-1-i]){
			*res = 0;
			return MAL_SUCCEED;
		}
	}
	return MAL_SUCCEED;
}

str STRLower( str *res, str *arg1 ){
	str s= *arg1;
	int l, i;
	RETURN_NIL_IF(strNil(s),TYPE_str);
   	l = strlen(s);
	*res = (char*)GDKmalloc(l+1);
	for(i = 0; i<l; i++)
		(*res)[i] = (char)tolower((char)s[i]);
	(*res)[l] = 0;
	return MAL_SUCCEED;
}

str STRUpper( str *res, str *arg1 ){
	str s= *arg1;
	int l, i;
	RETURN_NIL_IF(strNil(s),TYPE_str);
   	l = strlen(s);
	*res = (char*)GDKmalloc(l+1);
	for(i = 0; i<l; i++)
		(*res)[i] = (char)toupper((char)s[i]);
	(*res)[l] = 0;
	return MAL_SUCCEED;
}

str STRChrSearch( int *res, str *arg1, chr *c ){
	str s= *arg1;
	char *p;
	RETURN_NIL_IF(strNil(s)||*c==chr_nil,TYPE_int);
	if ((p = strchr( s, (int)*c )) != 0)
		*res = p-s;
	else 
		*res = -1;
	return MAL_SUCCEED;
}

str STRReverseChrSearch( int *res, str *arg1, chr *c ){
	str s= *arg1;
	char *p;
	RETURN_NIL_IF(strNil(s)||*c==chr_nil,TYPE_int);
	if ((p = strrchr( s, (int)*c )) != 0)
		*res = p-s;
	else 
		*res = -1;
	return MAL_SUCCEED;
}

str STRStrSearch( int *res, str *arg1, str *arg2 ){
	str s= *arg1, s2= *arg2;
	char *p;
	RETURN_NIL_IF(strNil(s)||strNil(s2),TYPE_int);
	if ((p = strstr( s, s2 )) != 0)
		*res = p-s;
	else 
		*res = -1;
	return MAL_SUCCEED;
}

str STRReverseStrSearch( int *res, str *arg1, str *arg2 ){
	str s= *arg1, s2= *arg2;
	int len, slen;
	char *p, *q;
	int i;

	RETURN_NIL_IF(strNil(s)||strNil(s2),TYPE_int);
	
	*res = -1;
	len = strlen(s);
	slen = strlen(s2);
	for(p = s + len - slen; p >= s; p--) {
	    for(i = 0, q = p; i < slen && *q == s2[i]; i++, q++)
		;
	    if (i == slen) {
		*res = p - s;
		break;
	    }
	}
	
	return MAL_SUCCEED;
}

str STRStrip(str *res, str *arg1) {
	str s= *arg1;
	str start = s;
	int len;

	while (GDKisspace(*start))
		start++;

	/* Remove the trailing spaces.  Make sure not to pass the start */
	/* pointer in case a string only contains spaces.               */
	s = start + strlen(start);
	while (s > start && GDKisspace(*(s - 1)))
		s--;

	len = s - start + 1;
	*res = GDKmalloc(len);
	memcpy(*res, start, len - 1);
	(*res)[len - 1] = '\0';
	return MAL_SUCCEED;
}

str STRLtrim(str *res, str *arg1) {
	str s= *arg1;
	RETURN_NIL_IF(strNil(s), TYPE_str);
	while (GDKisspace(*s))
	   	s++;
	*res = GDKstrdup(s);
	return MAL_SUCCEED;
}

str STRRtrim(str *res, str *arg1) {
	str s= *arg1;
	int len = strlen(s);

	RETURN_NIL_IF(strNil(s), TYPE_str);
        while(len > 0 && GDKisspace(s[len-1])) len--;
	*res = GDKmalloc(len+1);
  	memcpy(*res, s, len);
  	(*res)[len] = '\0';
	return MAL_SUCCEED;
}

str STRSubstitute(str *res, str *arg1, str *arg2, str *arg3, bit *g) {
	str s= *arg1, src=*arg2, dst= *arg3;
	int repeat = *g, lsrc = strlen(src), ldst = strlen(dst);
	int l = strLen(s), n = l + ldst;
	str buf, fnd, end; 

	if (repeat && ldst > lsrc) {
		n = (ldst*l)/lsrc; /* max length */
	}
	buf = *res = (str) GDKmalloc(n);
	end = buf + l; 
	fnd = buf;
	strcpy(buf, s);
	do {
		fnd = strstr((fnd < buf)?buf:fnd, src);
		if (!fnd) break; 
		memmove(fnd+ldst, fnd+lsrc, end-fnd);
		memcpy(fnd, dst, ldst);
		end += ldst - lsrc;
		fnd += ldst - 1; 
	} while(repeat);

	return MAL_SUCCEED;
}

str STRSubstitute2(str *res, str s, str src, str dst, bit *g) {
	int repeat = *g, lsrc = strlen(src), ldst = strlen(dst);
	int l = strLen(s), n = l + ldst;
	str buf, fnd, end; 

	if (repeat && strstr(dst,src)) {
		repeat = FALSE; /* result would become unbounded */ 
	}
	if (repeat && ldst > lsrc) {
		n = (ldst*l)/lsrc; /* max length */
	}
	buf = *res = (str) GDKmalloc(n);
	end = buf + l; 
	fnd = buf;
	strcpy(buf, s);
	do {
		fnd = strstr((fnd < buf)?buf:fnd, src);
		if (!fnd) break; 
		memmove(fnd+ldst, fnd+lsrc, end-fnd);
		memcpy(fnd, dst, ldst);
		end += ldst - lsrc;
		fnd -= lsrc-1; /* we can actually do better */
	} while(repeat);

	return MAL_SUCCEED;
}
@
@}
