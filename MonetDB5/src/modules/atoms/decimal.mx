@f decimal
@t Decimal Module
@a Peter Boncz, Martin van Dinther
@v 1.0

@+ Introduction
@T
This module introduces the decimal atom to monet. Decimals are intended to
represent highly complex decimal numbers in a flexible way. Decimal 
numbers consist of a {\em sign}, {\em number} and {\em scale} in the following
format: 
\begin{verbatim}
format:  ['-'|'+'] number [ 'E' ['-'|'+'] scale ]
    or:  ['-'|'+'] [ number ] '.' number [ 'E' ['-'|'+'] scale ]
\end{verbatim}
where 
\begin{description}
\item[number] is an integer consisting of maximally 16384 digits. Float notation with a dot 
is also allowed (e.g. 42.3E15 = 423E14).
\item[scale] an integer from the range [-16384,16384].  If omitted, its default value is 0.
\item[precision] is the number of digits of which {\bf number} consists.
\item[value] the value of a decimal is the number multiplied by 10 to the power of the scale.
\end{description}

The interface with operations on decimals is inspired on the java.math.BigDecimal class.

Examples (small numbers for convenience):
\begin{verbatim}
  42        = 42
 -10        = -10
 127E11     = 12700000000000
-776E2      = -77600
-103E-10    = -0.0000000103
\end{verbatim}

Computations with decimals return a decimal that has a precision that is the
maximum of each of the decimal parameters of the operator. When reducing precision,
we use truncation.

In the implementation, specific care was taken in order to make bulk operations
(like hash-join and sorting) fast, as one of the foreseeable applications of 
decimal columns is their use as foreign key on tables imported from another DBMS
(for imported tables, as in Monet we would preferably use the oid type as key).

@+ Definition
#Internal routines necessary for the atom implementation



@- construction
@mal
atom module decimal;
#command  tostr()= decimal_tostr;
#command  fromstr()= decimal_fromstr;
#command  comp()= decimal_compare;
#command  hash()= decimal_hash;
#command  null()= decimal_null;
#command  convert()= decimal_convert;
#command  length()= decimal_length;
#command  put()= decimal_put;
#command  del()= decimal_del;
#command  heap()= decimal_heap;
#command  check()= HEAP_check;
@-
The compare() atom routines should become visible at the mal layer
as well.
@mal
command =(v:decimal,w:decimal):bit = CMDdecimal_EQ
	comment "Equality of two decimals";
command !=(v:decimal,w:decimal):bit = CMDdecimal_NEQ
	comment "Equality of two decimals";
command <(v:decimal,w:decimal):bit = CMDdecimal_LT
	comment "Equality of two decimals";
command <=(v:decimal,w:decimal):bit = CMDdecimal_LE
	comment "Equality of two decimals";
command >(v:decimal,w:decimal):bit = CMDdecimal_GT
	comment "Equality of two decimals";
command >=(v:decimal,w:decimal):bit = CMDdecimal_GE
	comment "Equality of two decimals";

command isnil(v:decimal):bit = CMDdecimal_isnil
	comment "Nil test for decimal value";
command decimal (value:void) : decimal = decimal_from_nil
     comment "Translates a nil into a decimal.";

command decimal (value:str) : decimal = decimal_from_str
     comment "Translates an integer into a decimal.";

command decimal (value:int) : decimal = decimal_from_int
     comment "Translates an integer into a decimal.";

command decimal (value:lng) : decimal = decimal_from_lng
     comment "Translates a long into a decimal.";

command decimal (value:flt) : decimal  = decimal_from_flt
     comment "Create a decimal from a float value.";

command decimal (value:dbl) : decimal  = decimal_from_dbl
     comment "Create a decimal from a double value.";

@- decomposition
@mal
command dbl ( value:decimal) : dbl = decimal_to_dbl
     comment "Return the value of a decimal as a double (return dbl(nil) on overflow).";

command flt ( value:decimal ) : flt = decimal_to_flt
     comment "Return the value of a decimal as a float (return flt(nil) on overflow).";

command int (value:decimal) : int = decimal_to_int
     comment "Return the truncated value of a decimal as an integer (return int(nil) on overflow).";

command lng (value:decimal) : lng = decimal_to_lng
     comment "Return the truncated value of a decimal as a long (return lng(nil) on overflow).";

command str (d:decimal, format:str ) : str = decimal_format
     comment "Formats a decimal in a fixed-width string (truncated, if necessary).
      format = [ '+' ] ( N1 | ( N1 '.' N2 ) | ( '.' N2 ) ) [ 'E' N3 ]
       with: Nx = a number of the form [0-9]+ (possibly starting with 0)
      where: N1 = is the number of digits before the comma (default = 0)
             N2 = is the number of digits after the comma (default = 1)
             N3 = the number of digits to use for the scale (default = 2)
      A zero will be printed with only one zero digit (left space-padded), unless N1 has a 
      leading zero, in which case a zero-padded number of width N1 is produced. 
      If the plus at start is specified, positive numbers start with a plus. ";

@- arithmetic
All operators return a result decimal whose value is exactly the value of the operator, 
when applied to the value of both decimal arguments. Only for division this is not possible; 
as an infinite precision would in some cases be needed to describe an exact result. division
therefore truncates the result to a precision specified by the caller.
The result of all operator are always normalized by deleting all leading and trailing zeros 
(and adapting the scale correspondingly).
@mal
command +(val1:decimal,val2:decimal) : decimal = decimal_plus
     "Returns a decimal whose value is extactly (val1 + val2).";

command -(val1:decimal,val2:decimal)  : decimal = decimal_minus
     "Returns a decimal whose value is exactly (val1 - val2).";

command - (value:decimal) : decimal = decimal_negative
     "Returns a decimal whose value is -1 * value, with equal scale and precision as 'value'.";

command abs(value:decimal) : decimal = decimal_abs
     comment "Returns a decimal whose value is the absolute value of this number.";

command *(val1:decimal, val2:decimal) : decimal = decimal_multiply
     "Returns a decimal whose value is exactly (val1 * val2).";

command /(val1:decimal, val2:decimal) : decimal = decimal_divide_default
     "Returns a decimal whose value is val1 DIV val2, (scale=0) like in C integer division. 
      This operator can implement MOD as MOD(x,y) = x - y*DIV(d,y). 
      Use the tertiary divide(dum,div,prec) command for dividing with arbitrary precision. 
      Division by zero returns decimal(nil).";

command divide(val1:decimal, val2:decimal, precision:int) : decimal = decimal_divide
     comment "Returns a decimal whose value is (val1 / val2), truncated to a specified precision.
      Division by zero returns decimal(nil).";

command pow(val1:decimal, val2:int, precision:int) : decimal = decimal_pow
     comment "Raises a decimal to the power of some integer.
      The precision argument determines the maximum precision of the result ." ;

command pow(val1:decimal, val2:int) : decimal = decimal_pow_default
     comment "Raises a decimal to the power of some integer.
      The precision of the result is the precision of the decimal .";

@- misc
@mal
command getprecision(value:decimal) : int  = decimal_get_precision
     comment "Returns the precision of this number .";

command setprecision(value:decimal, precision:int) : decimal  = decimal_set_precision
     comment "Return the same number but with a different precision; i.e. truncated or zero-padded .";

command getscale(value:decimal) : int  = decimal_get_scale
     comment "Returns the scale of this number ";

command setscale(value:decimal, scale:int) : decimal  = decimal_set_scale
     comment "Normalize the number of a decimal by setting the scale to a fixed value.
      This is compensated by making the number shorted (by truncation) or by enlarging
      it with trailing zeros .";

command addscale(value:decimal, delta:int) : decimal = decimal_movedot
     comment "Return a  decimal with the same number as value, but with scale = value.scale + delta.
      This can be seen as shifting the dot in the floating-point value of the decimal
      to the left (delta < 0) or right (delta > 0) .";

@- internal
These commands are internal to the procedures in the load section. 
@mal
command divide(b:bat[any::1,decimal], d:decimal, p:int ) : bat[any::1,decimal] = decimal_bulkdivide
	comment "Perform the divide operation over a bat of decimals";
command divide(b:bat[any::1,decimal], d:decimal) : bat[any::1,decimal] = decimal_bulkdivide_default
	 comment "Perform the divide operation over a bat of decimals";

command istenfold(d:decimal) : bit = decimal_istenfold
	comment "returns whether decimal is an exact multiple of 10 .";
command decimal_minrepeat(x:int) : void = decimal_setminrepeat
	comment "set number of repeating characters after which to condense decimals .";

command decimal_prelude():void= decimal_prelude;
command decimal_epilogue():void = decimal_epilogue;

decimal_prelude();
@+ Test
The below MIL script stress-tests all operations on decimals, as well as the performance 
of grouping, sort and join on decimal columns. 
@mil
module(xtables,alarm,decimal,mmath);

decimal_minrepeat(20);

@- logical test
@mil
var   dec_nil := decimal("nil");
var  dec_zero := decimal("-0000000000000000000000000000000000E-8989");
var  dec_tiny := decimal("+0.000000000000000000000000001122");
var  nec_tiny := decimal("-11220000000000E-40");
var dec_small := decimal(2244);
var nec_small := decimal("-22440000000000E-10");
var   dec_num := decimal("+4488E15");
var   nec_num := decimal("-44880000000000E5"); 
var   dec_big := decimal("+1122E40");
var   nec_big := decimal("-11220000000000E30"); 
var  dec_huge := decimal("+22440000000000E9000");
var  nec_huge := decimal("-2244E9010");

var dec_bat := new(str,decimal,10);
dec_bat.insert("dec_nil", dec_nil);
dec_bat.insert("dec_zero", dec_zero);
dec_bat.insert("dec_tiny", dec_tiny);
dec_bat.insert("nec_tiny", nec_tiny);
dec_bat.insert("dec_small", dec_small);
dec_bat.insert("nec_small", nec_small);
dec_bat.insert("dec_num", dec_num);
dec_bat.insert("nec_num", nec_num);
dec_bat.insert("dec_big", dec_big);
dec_bat.insert("nec_big", nec_big);
dec_bat.insert("dec_huge", dec_huge);
dec_bat.insert("nec_huge", nec_huge);

# test conversion to simple scalars
var dec_prc := [getprecision](dec_bat);
var dec_scl := [getscale](dec_bat);
var dec_flt := [flt](dec_bat);
var dec_int := [int](dec_bat);
var dec_lng := [lng](dec_bat);
var dec_dbl := [dbl](dec_bat);

print(dec_bat.col_name("value"), 
      dec_prc.col_name("precision"), 
      dec_scl.col_name("scale"));

print(dec_bat.col_name("value"), 
      dec_int.col_name("int"), 
      dec_lng.col_name("lng"));

print(dec_bat.col_name("value"), 
      dec_flt.col_name("flt"), 
      dec_dbl.col_name("dbl"));

# test reverse conversion
print(dec_bat.col_name("decimal"), 
      [decimal](dec_int).col_name("from_int"), 
      [decimal](dec_lng).col_name("from_lng"));

print(dec_bat.col_name("decimal"), 
      [decimal](dec_flt).col_name("from_flt"));

print(dec_bat.col_name("decimal"), 
      [decimal](dec_dbl).col_name("from_dbl"));

# test set_scale and set_precision
print(dec_bat.col_name("decimal"), 
      [setscale](dec_bat,0).col_name("setscale(0)"),
      [setscale](dec_bat,10).col_name("setscale(10)"),
      [setscale](dec_bat,[-](dec_scl,5)).col_name("setscale(-5)"));

print(dec_bat.col_name("decimal"), 
      [setprecision](dec_bat,0).col_name("setprecision(0)"),
      [setprecision](dec_bat,10).col_name("setprecision(10)"),
      [setprecision](dec_bat,[-](dec_prc,5)).col_name("setprecision(-5)"));

print(dec_bat.col_name("decimal"), 
      [addscale](dec_bat,-5).col_name("addscale(-5)"),
      [addscale](dec_bat,5).col_name("addscale(5)"));

# test binary operators
var dec_zero := project(dec_bat.reverse,0@0).reverse;
var dec_cart := join(dec_zero.reverse,dec_zero);
var dec_bat1 := dec_cart.reverse.mark(0@0).reverse;
var dec_bat2 := dec_cart.mark(0@0).reverse;
var dec_raise := [-]([getprecision](dec_bat1),10);
var dec_prec := [-]([getprecision](dec_bat1),1);

print(dec_bat1.col_name("decimal1"),
      dec_raise.col_name("raise"),
      [pow](dec_bat1,dec_raise).col_name("pow"));

print(dec_bat1.col_name("decimal1"),
      dec_raise.col_name("raise"),
      dec_prec.col_name("precision"),
      [pow](dec_bat1,dec_raise,dec_prec).col_name("pow"));

print(dec_bat1.col_name("decimal1"),
      dec_bat2.col_name("decimal2"),
      [*](dec_bat1,dec_bat2).col_name("*"));

print(dec_bat1.col_name("decimal1"),
      dec_bat2.col_name("decimal2"),
      [/](dec_bat1,dec_bat2).col_name("/"));

print(dec_bat1.col_name("decimal1"),
      dec_bat2.col_name("decimal2"),
      [divide](dec_bat1,dec_bat2,10).col_name("divide"));

print(dec_bat1.col_name("decimal1"),
      dec_bat2.col_name("decimal2"),
      dec_prec.col_name("precision"),
      [divide](dec_bat1,dec_bat2,dec_prec).col_name("divide"));

print(dec_bat1.col_name("decimal1"),
      dec_bat2.col_name("decimal2"),
      [+](dec_bat1,dec_bat2).col_name("+"));

print(dec_bat1.col_name("decimal1"),
      dec_bat2.col_name("decimal2"),
      [-](dec_bat1,dec_bat2).col_name("-"));

print(dec_bat1.col_name("decimal1"),
      dec_bat2.col_name("decimal2"),
      [=](dec_bat1,dec_bat2).col_name("="));

print(dec_bat1.col_name("decimal1"),
      dec_bat2.col_name("decimal2"),
      [!=](dec_bat1,dec_bat2).col_name("!="));

print(dec_bat1.col_name("decimal1"),
      dec_bat2.col_name("decimal2"),
      [<](dec_bat1,dec_bat2).col_name("<"));

print(dec_bat1.col_name("decimal1"),
      dec_bat2.col_name("decimal2"),
      [<=](dec_bat1,dec_bat2).col_name("<="));

print(dec_bat1.col_name("decimal1"),
      dec_bat2.col_name("decimal2"),
      [>](dec_bat1,dec_bat2).col_name(">"));

print(dec_bat1.col_name("decimal1"),
      dec_bat2.col_name("decimal2"),
      [>=](dec_bat1,dec_bat2).col_name(">="));

# test unary operators
var dec_abs := [abs](dec_bat);
var dec_neg := [-](dec_bat);

print(dec_bat.col_name("decimal"),
      [isnil](dec_bat).col_name("isnil"),
      dec_abs.col_name("[abs]"),
      dec_neg.col_name("[-]"));

# test sorting
dec_bat.reverse.sort.reverse.col_name("sorted dec").print;
dec_abs.reverse.sort.reverse.col_name("sorted abs(dec)").print;

# test hash-join
dec_abs.join(dec_abs.reverse).print;


@- performance test
compare group, join and sort int vs decimal for 10.000, 100.000 and 1M tuples 
@mil
proc pow(int base, int raise) : int {
    return int(pow(dbl(base),dbl(raise)));
}
proc int(int i) : int return i;

proc arith_perftest(bat[any::1,any::2] b, any::2 div, str s) {
  var t := time, reduce := [/](b,div); printf("[/](%s) = %dms\n", s, time-t);
  t := time; printf("join(%s=%d) = %d ms\n", s, join(b,b.reverse).count, time - t);
  t := time; printf("group(%s=%d) = %d ms\n", s, CTgroup(reduce).tunique.count, time - t);
  t := time; printf("[*](%s=%d) = %d ms\n", s, [*](b,div).count, time - t);
  t := time; printf("[-](%s=%d) = %d ms\n", s, [-](b,b).count, time - t);
  t := time; printf("[+](%s=%d) = %d ms\n", s, [+](b,b).count, time - t);
  if (b.count < 1000000) {
     t := time; printf("[pow](%s=%d) = %d ms\n", s, [pow](b,[int](reduce)).count, time - t);
     t := time; b.reverse.sort; printf("sort(%s) = %d ms\n", s, time - t);
  }
}

var i := 10000;
var int_10K  := new(void,int,10000);
while((i :-= 1) >= 0) {
        int_10K.insert(nil,i);
}
int_10K.seqbase(0@0);

printf("#~BeginVariableOutput~#\n"); arith_perftest(int_10K, 101, "int_10K"); printf("#~EndVariableOutput~#\n");

var dec_10K := [decimal](int_10K);
printf("#~BeginVariableOutput~#\n"); arith_perftest(dec_10K, decimal("101"), "dec_10K"); printf("#~EndVariableOutput~#\n");

var int_100K := new(void,int,100000);
while((i :+= 1) < 10) {
        var base := (9 - i) * 10000;
        int_100K.insert([+](int_10K,base));
}
int_100K.seqbase(0@0);

printf("#~BeginVariableOutput~#\n"); arith_perftest(int_100K, 1001, "int_100K"); printf("#~EndVariableOutput~#\n");

var dec_100K := [decimal](int_100K);
printf("#~BeginVariableOutput~#\n"); arith_perftest(dec_100K, decimal("1001"), "dec_100K"); printf("#~EndVariableOutput~#\n");

var int_1M := new(void,int,1000000);
while((i :-= 1) >= 0) {
        var base := i * 100000;
        int_1M.insert([+](int_100K,base));
}
int_1M.seqbase(0@0);

printf("#~BeginVariableOutput~#\n"); arith_perftest(int_1M, 10001, "int_1M"); printf("#~EndVariableOutput~#\n");

var dec_1M := [decimal](int_1M);
printf("#~BeginVariableOutput~#\n"); arith_perftest(dec_1M, decimal("10001"), "dec_1M"); printf("#~EndVariableOutput~#\n");

quit;
@{
@+ Implementation
@T
There were three important design aspects for the decimal atom:
\begin{description}
\item[fixed or variable-size]
as the decimal type is intended to solve all our problems with large numbers,
the upper limit of the decimal size that can be stored should be high. Implementing
decimals as fixed-size atoms therefore would yield a very large object, that
in general will not be used fully. Hence the choice for a variable-size atom.

\item[binary or decimal storage]
we chose to represent decimals in 4-bits (i.e. 2 digits per byte) as this is both 
reasonably compact and facilitates implementation of operators that are digit-oriented.
Examples of such operators are: parsing from a string input and formatting to string 
output, and substring operators (for instance those that modify the precision of a number).
It is also much easier with decimal storage to implement clear rules about the precision 
that is delivered by the various arithmetic operators.
Downside is the performance of computation operators (like *, /, -, +). An alternative
would have been storage in an array of binary integers. This would perform better
on the arithmetic side, but much worse on the digit-oriented tasks. Import time of
decimals from string was deemed to be very important, hence the choice for
a digit-oriented representation.  

\item[join efficiency]
decimals will be often used as join columns on imported tables. This means that sorting, 
merge-join and hash-join should run quickly.  These operations in turn depend on the 
efficiency of the ADT compare and hash operators. To achieve efficiency, we implemented
decimal-compare and decimal-hash such that they work on 32-bits integers at-a-time. Decimals 
are stored in an array of integers, where the first integer in the array holds the 
digits with highest significance, etc, and within each integer, the four highest bits hold 
the highest significant digit, etc.  This storage regime makes it possible to use integer 
comparison when comparing decimals of the same precision; comparing 8 digits at a time.
\end{description}
@h
/*
 * The contents of this file are subject to the Monet Public
 * License Version 1.1 (the "License"); you may not use this file
 * except in compliance with the License. You may obtain a copy of
 * the License at 
 * http://www.monetsolutions.com/Download/Licensing/MonetPL-1.1.html
 * 
 * Software distributed under the License is distributed on an "AS
 * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
 * implied. See the License for the specific language governing
 * rights and limitations under the License.
 * 
 * The Original Code is the Monet Database System.
 * 
 * The Initial Developer of the Original Code is CWI.
 * Portions created by CWI are Copyright (C) 1997-2002 CWI.  
 * All Rights Reserved.
 * 
 * Contributor(s): Peter Boncz <Peter.Boncz@cwi.nl>
 */

#ifndef _DECIMAL_H_
#define _DECIMAL_H_

#include "mal_function.h"
#include "mal_box.h"

typedef struct {
	int scale:16, negative:1, precision:15;
	unsigned int num[1]; /* array of digits: 2-digits-per-byte = 8-digits-per-integer */
	/* array extends beyond boundary */
} decimal;

extern str decimal_prelude();
extern str decimal_epilogue();
extern str decimal_minus(decimal **ret, decimal **v1input, decimal **vinput2);

#endif /* _DECIMAL_H_ */

@-
@T
Valid numbers have minimally 1 and maximally 16384 digits.  The valid scales are between 
[-16384,16384]. There are two special values:
\begin{description}
\item[zero = +0e-32768] in order to simplify many operators, trailing zeros are removed from 
decimal numbers (in that case, the number of digits is an indicator fo the value of a decimal). 
This has as a consequence that a zero number would not be perimitted. Hence zero is treated as 
a special case. Whenever a zero value decimal has to be produced, it is normalized to one canonical 
form: the smallest possible positive number. This representation of zero has the benefit of that 
zero does not have to be treated as a special case in the comparison operator.

\item[nil = -0xAe32767] this representation as a negative number with precision 1 consisting of
a single false digit of value 10 and an impossibly high scale, forces the nil value to be smaller
than any other decimal (again avoiding having to treat it as a special case in the compare). 
\end{description}
@c
#include "decimal.h" 

/* lookup tables that avoid having to divide and mod by 10 all the time */
char mult_table[10*16], plus_table[10*16], minus_table[10*16], div_table[9*128];
short val_table[10000]; /* 4-digit shorts with numbers from 0000 to 9999 */

#define PRECISION_MAX	16384
#define SCALE_MAX	16384
#define SCALE_MIN	(-16384)
#define HI(x)		LO((x)>>4)
#define LO(x)		((x)&15)
#define MULT(x,y)	mult_table[((x)<<4)+(y)]
#define MULT10(x)	(((x) << 3) + ((x) << 1))
#define ADD(x,y)	plus_table[((x)<<4)+(y)]
#define MINUS(x,y)	minus_table[((x)<<4)+(y)]
#define DIV(x,y)	div_table[(((y)-1)<<7)+(x)]
#define NUM(d,x)	(d)->num[(x) >> 3]
#define POS(x)		((7 - ((x) & 7)) << 2)
#define MASK(x)		(15 << POS(x))
#define GETNUM(d,x)	LO((NUM(d,x) & MASK(x)) >> POS(x))
#define SETNUM(d,x,y)	NUM(d,x) = ((y) << POS(x)) | (NUM(d,x) & ~MASK(x)) 
#define ISNIL(d)	((d)->scale > SCALE_MAX) 
#define ISZERO(d)	((d)->num[0] == 0) 

/* number of ints in num field */
#define NUMLEN(x)       ((((x)-1) >> 3) + 1)

/* total size in bytes of allocated structure */
#define TOTLEN(x) (sizeof(decimal)+((NUMLEN(MAX(MIN(PRECISION_MAX,(x)),1))-1)<<2))

#define DECIMAL_AVGSIZE 12

/* materialized constants */
decimal *decimal_nil = NULL, *decimal_one, *decimal_zero; 
decimal *decimal_int_min, *decimal_int_max; 
decimal *decimal_lng_min, *decimal_lng_max;
decimal *decimal_flt_min, *decimal_flt_max;
decimal *decimal_dbl_min, *decimal_dbl_max; 
int decimal_minrepeat = 2000000000;

/* 10-folds are recognized by a leading one and all trailing zeros */
static INLINE
int ISTENFOLD(decimal *d) {
	unsigned int *src = d->num;
	unsigned int *dst = src + NUMLEN(d->precision);
	
	if (*src == (1 << 28)) do {
		if (++src == dst) return 1;
	} while(*src == 0);
	return 0;
}

@- debugging
The Monet debug mask 131072 enables decimal debugging, which will print the
input and output parameters of all relevant decimal routines, and also check
them for corruption.
@c
char decimal_global_buf[1024];
#define DECIMAL_DEBUG(d,t,c)	if (GDKdebug&131072) decimal_debug(d,t,c)
#define FORMAT(f,s)		((sprintf(decimal_global_buf,f,s)||1)?decimal_global_buf:NULL)

void decimal_debug(decimal* d, str tag, int check) {
	int x=0, y, precision = d->precision, scale = d->scale;

	if (tag) {
		printf("%s=", tag);	
	}
	/* try to print it as good as you can */
	if (ISNIL(d)) {
		printf("nil\n"); x = 1;
		precision = 1;
	} else if (ISZERO(d)) {
		printf("0\n"); x = 1;
		precision = 1;
	} else {
		char buf[128], *t = buf, *s = t;
		if (precision == 0 || precision > PRECISION_MAX) {
			GDKerror("decimal_debug: illegal precision %d.\n", d->precision);
			if (precision) precision = 8;
		}
		if (scale < SCALE_MIN || scale > SCALE_MAX) {
			GDKerror("decimal_debug: illegal scale %d.\n", scale);
			scale = 0;
		}
		if (precision+8 > 128)  {
			t = s = (str) GDKmalloc(d->precision+8);
		}
		if (d->negative) {
			*s++ = '-';
		}
		for(x = 0; x < precision; x++) {
			int val = GETNUM(d,x);
			*s++ = "0123456789ABCDEF"[GETNUM(d,x)];
		} x = 0;
		if (scale != 0) {
			sprintf(s, "E%d", scale);
		} else {
			*s = 0;
		} puts(t);
		if (buf != t) GDKfree(t);
		x = 0;
	}
	for(y = 0; y < d->precision; y++) {
		if (GETNUM(d,0)) break;
	}
	/* do the checking */	
	if (check) {
		if (ISZERO(d) && y < d->precision) {
			GDKerror("decimal_debug: leading zeros in nonzero value.\n");
		}
		if (ISZERO(d) && d->precision != 1) {
			GDKerror("decimal_debug: zero has illegal precision.\n");
		}
		if (ISZERO(d) && d->scale != 2*SCALE_MIN) {
			GDKerror("decimal_debug: zero has illegal scale.\n");
		}
		for(y = NUMLEN(precision) << 2; x < y; x++) {
                        int z = GETNUM(d,x); /* z >= 0 due to GETNUM impl. */
                        if (x >= d->precision ? z != 0 : z > 9) {
				GDKerror("decimal_debug: garbage %d at position %d.\n", z, x);
			} 
		}
	}
}
@- Initialization

@-
decimal_create() is the vanilla routine that allocates a new empty decimal
with a given precision, scale and sign. It is implemented by decimal_alloc,
that can also create the decimal in a preallocated buffer.
@c
int TYPE_decimal;

#define decimal_create(precision, scale, sign) decimal_alloc(precision, scale, sign, NULL, NULL)
decimal* decimal_alloc(int precision, int scale, int sign, decimal *d, int *size) {
	int len = TOTLEN(precision);

	if (d && *size < len) {
		if(*size) GDKfree(d); d = NULL; 
	} 
	if (d == NULL) {
 		d = (decimal*) GDKmalloc(len);
		if (size) *size = len;
	} 
	if (scale < SCALE_MIN || scale >  SCALE_MAX || 
	    precision < 0 || precision > PRECISION_MAX)
	{
		/* generate a nil */
		*d = *decimal_nil;
	} else if (precision == 0) {
		/* generate a zero */
		d->num[0] = 0; 
		d->precision = 1; 
		d->scale =  2*SCALE_MIN;
		d->negative = 0; 	
	} else {
		/* generate an decimal with empty number, and set fields */
                unsigned int *src = d->num;
                unsigned int *dst = src + NUMLEN(precision);
		d->precision = precision;
		d->scale = scale;	
		d->negative = sign; 
		while(src < dst) *src++ = 0;
	}
	return d;
}

@-
Remove both leading and optionally the trailing zeros into a new decimal d (d==v is allowed). 
The new decimal may be optionally truncated or enlarged (padded with trailing zeros), if
so specified in the third parameter. When trailing zeros have to be deleted, we do this in
one go and adapt the scale accordingly (10 becomes 1E1).  A special case caught here is the 0 
value, which is required to have precision 1 and sign positive (this will override a given 
minimum precision parameter).
@c
static INLINE
void decimal_normalize(decimal* d, decimal *v, int offset, int fixed_precision, int del_trailing){
	int x = offset, precision, first_nonzero=0, last_nonzero=v->precision;

	DECIMAL_DEBUG(v, "decimal_normalize() input", 0);

	/* find the first nonzero digit from the start */
	for(first_nonzero=0; first_nonzero < v->precision; first_nonzero++) {
		if (GETNUM(v,first_nonzero) != 0) break;
	}

	/* find the last nonzero digit from the end */
	if (del_trailing)
	for(x=first_nonzero; x < v->precision; x++) {
		if (GETNUM(v,x) != 0) last_nonzero=x+1;
	}

	/* determine the new precision */
	precision = offset + last_nonzero - first_nonzero;
	if (fixed_precision && fixed_precision < precision) {
		last_nonzero += fixed_precision - precision;
		precision = fixed_precision;
	} 

	/* copy the first precision nonzero digits */
	for(x=offset; x < precision; x++) {
		SETNUM(d,x,GETNUM(v,first_nonzero+x-offset));
	}

	/* pad the total rest of d with zeros (for consistency) */
	for(; x < d->precision; x++) {
		SETNUM(d,x,0);
	}

	/* fill in the fields */	
	if (precision == 0) {
		*d = *decimal_zero;
	} else { 
		/* d->precision can be > precision; rest is then padded by 0s */
		d->negative = v->negative;
		d->scale = v->scale + (v->precision - last_nonzero);
		d->precision = precision;
		if (fixed_precision > precision && !del_trailing) {
			d->scale -= fixed_precision - precision;
			d->precision = fixed_precision;
		}
	}
	DECIMAL_DEBUG(d, "decimal_normalize() result", 0);
}

@-
decimal_copy() delivers a new decimal based on a parameter but with a decimal precision.
For adapting the precision it relies on decimal_normalize(), but it does some checking beforehand.
@c
decimal *decimal_copy(decimal *v, int precision) {
	decimal *d = decimal_create(precision, 0, 0);

	DECIMAL_DEBUG(v, FORMAT("decimal_copy(precision=%d) input", precision), 0);

	if (ISNIL(v) || precision < 0 || precision > PRECISION_MAX) {
		*d = *decimal_nil;
	} else if (precision == 0) {
		*d = *decimal_zero;
	} else {
		decimal_normalize(d, v, 0, precision, FALSE);
	}

	DECIMAL_DEBUG(d, FORMAT("decimal_copy(precision=%d) result", precision), 0);
	return d;
}

@- ADT functions
The below ADT function implementations are required when adding a new atom type to Monet.
@c
int decimal_fromstr(str buf, int *len, decimal **ret) {
	int comma = 0, scale = 0, sign = 0, precision = 0, started = 0, scale_neg = 0; 
	int c, x = (int) sizeof(int), pos, repeat = 0, *rp = &repeat;
	char *base=buf, *cur=buf, *dst, *last=NULL, cpy[PRECISION_MAX];

	dst=cpy;
	
	/* scan number string and copy the relevant parts to cpy */
	if (*cur == '-' || (*cur == '+')) {
		sign = (*cur == '-'); 
		cur++; base++;
	} 
	while(*cur) {
		if (repeat > 0) {
			repeat--;
		} else {
			c = *cur++;
		}
		if (c == '(') {
			pos = intFromStr(cur, &x, &rp); cur += pos; 
			if (pos == 0 || repeat < 0 || decimal_minrepeat > repeat ||
			    strncmp(cur, " times ",7) || !GDKisdigit(cur[7]) || cur[8] != ')') 
			{
				dst = cpy; break; /* syntax error */ 
			}
			c = cur[7]; cur += 8; 
		} else if (comma == 0 && c == '.') {
			comma = 1;
		} else {
			if (!GDKisdigit(c)) { 
				cur--; break; 
			}
			if (comma) {
				comma++;  /* correct scale for each digit after the comma */
			}
			if (!started) {
				if (c == '0') {
					continue; /* ignore leading zeros */
				} else {
					started = 1;
				}
			} 
			if ((dst - cpy) < PRECISION_MAX) {
				*dst++ = c; /* copy digit into buffer */
				if (c != '0') {
					last = dst;
				}
			}
			precision++;
		}
	} 
	if (comma) comma--; 

	if (cur <= base) {
		precision = -1; /* will force a nil decimal */
	} else if ((c == 'E' || c == 'e')) { 
		/* scan the E part */	
		if (*(++cur) == '-') { cur++; scale_neg=1; }
		else if (*cur == '+') cur++;
		while(GDKisdigit(*cur)) {
			if (scale-comma <= SCALE_MAX) {
				scale = (*cur - '0') + MULT10(scale);
			} cur++;
		}
		if (scale_neg) scale = -scale;
	}	
	if (!started && cur > base) {
		if (precision > 0) precision = 0; /* force zero */ 
		cpy[0] = '0';
	} 
/* delete trailing zeros 
	else if (last && precision > 0) {
		precision -= dst - last;
		comma -= dst - last;
	}
*/
	
	/* allocate the decimal. invalid parameters will produce a nil */
	*ret =  decimal_alloc(precision, scale-comma, sign, *ret, len);
	if (!ISNIL(*ret)) {
		for(x=0; x < precision; x++) {
			SETNUM((*ret),x,cpy[x]-'0'); 
		}
	}
	DECIMAL_DEBUG(*ret, FORMAT("decimal_fromstr(%s) result",buf), 1);
	return cur-buf;
}

int decimal_tostr(str *buf, int *len, decimal *v) {
	if (*len < v->precision+7) {
		if (*buf && *len) GDKfree(*buf);
		*buf = (str) GDKmalloc(*len = v->precision+7);
	} 
	if (ISNIL(v)) {
		strcpy(*buf, "nil");
	} else if (ISZERO(v)) {
		strcpy(*buf, "0");
	} else {
		int x, val, lastval=-1, repeat=0; 
		str s = *buf;

		if (v->negative) {
			*s++ =  '-';
		}
		for(x = 0; x < v->precision; x++, repeat++) {
			val = GETNUM(v,x) + '0';
			if (val != lastval) {
				if (repeat > decimal_minrepeat) {
					s -= repeat;
					sprintf(s, "(%d times %c)", repeat, lastval);
					s += strlen(s);
				}
				lastval = val; repeat = 0;
			}
			*s++ = val;
		}
		if (repeat > decimal_minrepeat) {
			s -= repeat;
			sprintf(s, "(%d times %c)", repeat, lastval);
			s += strlen(s);
		}
		if (v->scale != 0) {
			sprintf(s, "E%d", v->scale);
		} else {
			*s = 0;
		}
	}
	DECIMAL_DEBUG(v, FORMAT("decimal_tostr(->%s) input",*buf), 1);
	return strlen(*buf);
}

str decimal_setminrepeat(int *ret, int *x) {
	if(*x>0) decimal_minrepeat = *x;
	return MAL_SUCCEED;
}

/* Format a decimal in a string a a float with a fixed number of digits before and after the comma. */
str decimal_format(str *ret, decimal **dinput, str *formatinput) {
	decimal *d= *dinput;
	str format = *formatinput;
	chr start = ' ', pad = ' ', *s = format;	
	int n1=0, n2=0, n3=0, x, y=0;

	/* scan the format string */
	if (*s == '+') {
		start = '+'; s++;
	}
	if (*s == '.') {
		n1 = 1;
	} else {
		if (*s == '0') pad = '0';
		if (!GDKisdigit(*s)) {
			n1 = -1;
		} else do {
			n1 = (*s++ - '0') +  MULT10(n1);
		} while(GDKisdigit(*s));
	}
	if (*s == '.') {
		s++;
		if (!GDKisdigit(*s)) {
			n2 = -1;
		} else do {
			n2 = (*s++ - '0') +  MULT10(n2);
		} while(GDKisdigit(*s));
	} else {
		n2 = 0;
	}
	if (*s == 'e' || *s == 'E') {
		s++;
		if (!GDKisdigit(*s)) {
			n3 = -1;
		} else do {
			n3 = (*s++ - '0') +  MULT10(n3);
		} while(GDKisdigit(*s));
	} else {
		n3 = 2;
	}

	/* check && alloc if ok */
	if (n1 < 0 || n2 < 0 || (n1+n2) == 0 || (n1+n2) > PRECISION_MAX || n3 <= 0 || n3 > 9) {
		return throwException(MALEXCEPTION,"decimal.print",
		  	"illegal format '%s'.\n", format);
	}
	s = (*ret) = (str) GDKmalloc(1+n1+1+n2+2+n3+1);

	/* format the decimal */
	if (ISNIL(d)) {
		for(x=0; x<n1+n2-1; x++) {
			*s++ = ' ';
		}
		strcpy(s, "nil");
	} else {
		if (ISZERO(d) && pad == ' ') {
			for(x=0; x<n1-1; x++) {
				*s++ = ' ';
			}
			strcpy(s, "0");
			y = 0;
		} else {
			*s++ = (d->negative)?'-':start;
			for(x=0; x<n1; x++) {
				int num = (x<d->precision)?GETNUM(d,x):0;
				*s++ = num + '0';
			} 
		}
		if (n2) {
			*s++ = '.';
			for(; x<n1+n2; x++) {
				int num = (x<d->precision)?GETNUM(d,x):0;
				*s++ = num + '0';
			}
		}
		if (!ISZERO(d)) {
			y = d->scale + d->precision - n1;
		}
		if (y) {
			char f[5];
			f[0] = '%'; f[1] = '0'; f[2] = '0'+n3; 
			f[3] = 'd'; f[4] = 0;
			*s++ = 'E';
			*s++ = (y > 0)?'-':'+';
			sprintf(s, f, y);
		} else {
			*s = 0;
		}
	}
	return MAL_SUCCEED;
}

@-
Hash and compare are made fast by implementing them as integer operations. That is, they 
look at the digit string as if it as an array of integers. In fact, each integer contains
8 digits. The digits are placed in such a way that integer comparison can be used to compare
8 digits substrings (by placing the first digit in the highest 4-bits of the integer, etc).

Hash and compare are tricky as we need ensure that numbers with the same *value* are
seen as equal and get the same hash value. Note that 10E1 == 100E0, etc. This behavior 
is obtained by adding precision and base as start hash value (i.e. the number of digits 
before the comma, which is both 2 for 10E1 and 100).  Important to know is that we ensure 
that a decimal has never leading zeros (except for the 0 value, which is always represented 
with scale=0, precision=1 and negative=0), So, equal numbers have the same starting digit
string, but may only differ by trailing zeros. The hash function ignores series of zero 
digits, hence is immune for such differences. The compare function adds imaginary zeros at 
the shorter digit string to obtain the same effect.
@c
int decimal_hash(decimal *d) {
	unsigned int *src = d->num;
	unsigned int *dst = src + NUMLEN(d->precision);
	hash_t y = d->precision + d->scale;
	
	while(src < dst) {
		int val = *src++;
		if (val) {
			unsigned int x = ((val & (15 << 28)) >> 28);
			x = MULT10(x) + ((val & (15 << 24)) >> 24);
			x = MULT10(x) + ((val & (15 << 20)) >> 20);
			x = MULT10(x) + ((val & (15 << 16)) >> 16);
			x = MULT10(x) + ((val & (15 << 12)) >> 12);
			x = MULT10(x) + ((val & (15 << 8)) >> 8);
			x = MULT10(x) + ((val & (15 << 4)) >> 4);
			x = MULT10(x) + ((val & 15));
			y ^= mix_int(x);
		}
	} 
	if (d->negative) y = ~y;
	DECIMAL_DEBUG(d, FORMAT("decimal_hash(->%d) input", y), 1);
	return y;
}

int decimal_compare(decimal *v1, decimal *v2) {
	unsigned int d1 = v1->precision + v1->scale;
	unsigned int d2 = v2->precision + v2->scale;
	int res = 0;

	if (v2->negative != v1->negative) {
		res = 1;
	} else if (d1 != d2) {
		res = d1 - d2;
	} else {
		unsigned int *p1 = v1->num;
		unsigned int *p2 = v2->num; 
		unsigned int *q1 = p1 + NUMLEN(v1->precision);
		unsigned int *q2 = p2 + NUMLEN(v2->precision);
	
		while(p1 < q1 || p2 < q2) {
			d1 = (p1 < q1)?*p1:0;
			d2 = (p2 < q2)?*p2:0;
			p1++; p2++;
			if (d1 < d2) {
				res = -1; break;
			} else if (d1 > d2) {
				res = 1; break;
			}
		} 
	}
	if (v1->negative) {
		res = -res;
	}
	DECIMAL_DEBUG(v1, FORMAT("decimal_compare(->%d) left", res), 1);
	DECIMAL_DEBUG(v2, FORMAT("decimal_compare(->%d) right", res), 1);
	return res; 
}

decimal* decimal_null() {
	if (decimal_nil == NULL) {
		decimal_prelude();
	}
	return decimal_nil;
}

int decimal_length(decimal *d) {
	return TOTLEN(d->precision);
}
 
void decimal_convert(decimal *d, int dummy) {
	int *src = (int*) d, *dst = (int*) (((char*) d) + TOTLEN(d->precision));
	short *s = (short*) d;
	s[0] = short_int_SWAP(s[0]);
	s[1] = short_int_SWAP(s[1]);
	while(++src < dst) {
		*src = normal_int_SWAP(*src);
	}
}

int decimal_heap(Heap* h,int capacity) {
	HEAP_initialize_compact(h, capacity*DECIMAL_AVGSIZE, 0, 0, (int (*)(ptr)) decimal_length);
	return(0);
}

void decimal_del(Heap* h, int* index) {
	HEAP_free(h,*index);
}

void decimal_put(Heap* h, int* bun, decimal* val) {
	int *dst, len = TOTLEN(val->precision);
	int *src = (unsigned int*) val;
	int *end = (int*) (((char*) src) + len);
	dst = (int*) (h->base + (*bun = HEAP_malloc(h, len)));
	while(src < end) *dst++ = *src++;
}

@- operator implementations
@c
str decimal_prelude() {
	int x, y, z, r, s=0;
	Box box;

	if (decimal_nil) {
		return MAL_SUCCEED;
	}
	TYPE_decimal= ATOMindex("decimal");
	if( TYPE_decimal == GDKatomcnt)
		GDKerror("Decimal type information missing");
	decimal_nil = decimal_create(2,0,0);
	decimal_nil->scale = 32767; 
	decimal_nil->negative = 1;
	SETNUM(decimal_nil,0,10);
	BATatoms[TYPE_decimal].atomToStr=  (int(*)()) decimal_tostr;
	BATatoms[TYPE_decimal].atomFromStr= (int(*)()) decimal_fromstr;
	BATatoms[TYPE_decimal].atomCmp= (int(*)()) decimal_compare;
	BATatoms[TYPE_decimal].atomHash= (unsigned int(*)()) decimal_hash;
	BATatoms[TYPE_decimal].atomNull= decimal_nil;
	BATatoms[TYPE_decimal].atomConvert= (void(*)()) decimal_convert;
	BATatoms[TYPE_decimal].atomLen= (int(*)()) decimal_length;
	BATatoms[TYPE_decimal].atomPut= (void(*)()) decimal_put;
	BATatoms[TYPE_decimal].atomDel= (int(*)())decimal_del;
	BATatoms[TYPE_decimal].atomHeap= (int(*)())decimal_heap;
	BATatoms[TYPE_decimal].atomHeapCheck= HEAP_check;
	BATatoms[TYPE_decimal].storage= TYPE_decimal;
	BATatoms[TYPE_decimal].linear= 1;
	BATatoms[TYPE_decimal].size= 4;
	BATatoms[TYPE_decimal].align= 4;
	BATatoms[TYPE_decimal].varsized= 1;


	/* setup the lookup tables; our alorithms never do %10 and /10 (expensive operators) */
	for(x=0; x < 10; x++) {
		for(y=0; y < 10; y++) {
			/* val_table contains 4-digit substring representing [0-9999] */
			for(z=0; z < 10; z++) {
				for(r=0; r < 10; r++,s++) {
					val_table[s] = (r<<12)|(z<<8)|(y<<4)|x;
				}
			} z = (x<<4)+y; 

			/* mult_table contains HI and LO result of [0-9] * [0-9] */
			r = x*y;
			mult_table[z] = (r/10)<<4 | r%10;

			/* plus-table contains HI and LO result of [0-9] + [0-9] */
			plus_table[z] = ((x+y)/10)<<4 | (x+y)%10;

			/* minus_table contains HI and LO result of [0-9] - [0-9] */
			minus_table[z] = ((x-y)<0)?(1<<4)+10+x-y:x-y;
		}
		/* div_table contains HI and LO result of [0-9] / [1-9] normalized to [1-9] */
		if (x > 0) {
			for(y=0; y < 100; y++) {
				int div = y/x;
				div_table[((x-1)<<7)+y] = MAX(MIN(div,9),1); 
			}
		}
	}

	/* nil is a normally impossible value; compare identifies it as the smallest decimal */
        decimal_nil = decimal_create(2,0,0);
        decimal_nil->scale = 2*SCALE_MAX-1;
        decimal_nil->negative = 1;
        SETNUM(decimal_nil,0,10);


	decimal_zero = decimal_create(0,0,0);
	decimal_one = decimal_create(1,0,0);
	SETNUM(decimal_one,0,1);

	/* create decimals representing the maximum and minimum values of scalar types */
	decimal_fromstr("-2147483648", &y, &decimal_int_min);
	decimal_int_max = decimal_copy(decimal_int_min, decimal_int_min->precision);
	decimal_int_max->negative = 0;

	decimal_fromstr("-3.402823466E+38F", &y, &decimal_flt_min);
	decimal_flt_max = decimal_copy(decimal_flt_min, decimal_flt_min->precision);
	decimal_flt_max->negative = 0;

	decimal_fromstr("-9223372036854775808", &y, &decimal_lng_min);
	decimal_lng_max = decimal_copy(decimal_lng_min, decimal_lng_min->precision);
	decimal_lng_max->negative = 0;

	decimal_fromstr("-1.7976931348623157E+308", &y, &decimal_dbl_min);
	decimal_dbl_max = decimal_copy(decimal_dbl_min, decimal_dbl_min->precision);
	decimal_dbl_max->negative = 0;

	box= openBox("decimal");
	if( box== 0)
                return throwMessage("decimal.prelude","failed to open box");
        if( box->sym->vtop == 0){
	decimal **d;
	ValRecord vr;

	vr.vtype= TYPE_decimal;
	vr.len=0;
	vr.val.pval = 0;
	d=(decimal**) &vr.val.pval;

	decimal_fromstr("nil",&vr.len,d);
	depositBox(box,"DECIMAL_NIL",&vr); 
	decimal_fromstr("0",&vr.len,d);
	depositBox(box,"DECIMAL_ZERO",&vr); 
	decimal_fromstr("2.7182818284590452354",&vr.len,d);
	depositBox(box,"DECIMAL_E",&vr); 
	decimal_fromstr("1.4426950408889634074",&vr.len,d);
	depositBox(box,"DECIMAL_LOG2E",&vr); 
	decimal_fromstr("0.43429448190325182765",&vr.len,d);
	depositBox(box,"DECIMAL_LOG10E",&vr); 
	decimal_fromstr("0.69314718055994530942",&vr.len,d);
	depositBox(box,"DECIMAL_LN2",&vr); 
	decimal_fromstr("2.30258509299404568402",&vr.len,d);
	depositBox(box,"DECIMAL_LN10",&vr); 
	decimal_fromstr("3.14159265358979323846",&vr.len,d);
	depositBox(box,"DECIMAL_PI",&vr); 
	decimal_fromstr("1.57079632679489661923",&vr.len,d);
	depositBox(box,"DECIMAL_PI_2",&vr); 
	decimal_fromstr("0.78539816339744830962",&vr.len,d);
	depositBox(box,"DECIMAL_PI_4",&vr); 
	decimal_fromstr("0.31830988618379067154",&vr.len,d);
	depositBox(box,"DECIMAL_1_PI",&vr); 
	decimal_fromstr("0.63661977236758134308",&vr.len,d);
	depositBox(box,"DECIMAL_2_PI",&vr); 
	decimal_fromstr("1.12837916709551257390",&vr.len,d);
	depositBox(box,"DECIMAL_2_SQRTPI",&vr); 
	decimal_fromstr("1.41421356237309504880",&vr.len,d);
	depositBox(box,"DECIMAL_SQRT2",&vr); 
	decimal_fromstr("0.70710678118654752440",&vr.len,d);
	depositBox(box,"DECIMAL_SQRT1_2",&vr); 
 	}

	return MAL_SUCCEED;
}

str decimal_epilogue(){
	GDKfree(decimal_nil);
	GDKfree(decimal_zero);
	GDKfree(decimal_one);
	GDKfree(decimal_int_min);
	GDKfree(decimal_int_max);
	GDKfree(decimal_flt_min);
	GDKfree(decimal_flt_max);
	GDKfree(decimal_lng_max);
	GDKfree(decimal_lng_min);
	GDKfree(decimal_dbl_min);
	GDKfree(decimal_dbl_max);
	decimal_nil = NULL;
	return MAL_SUCCEED;
}

/* Translates a long into a decimal (no overflow possible). */
str decimal_from_lng(decimal **ret, lng* val) {
	if (*val == lng_nil) {
		*ret = decimal_create(-1,0,0);
	} else if (*val == (lng)0) {
		*ret = decimal_create(0,0,0);
	} else {
		int x = 0, y = 0, rest, precision = 0, sign = 0;
		sht num[PRECISION_MAX/4];
		lng l = *val;
		decimal *d;

		*(int*) num = 0;
		if (l < 0) {
			sign = TRUE; l = -l;
		}
		if (l == 0) {
			precision = 1;
		} else {
			while(l > 0) {
				lng div = l / 10000; /* uhff1 */ 
				rest = l - div*10000;
				num[y++] = val_table[rest]; /* uhff2 */
				l = div;
		        }
			precision = y-- << 2;
			if (rest < 10) {
				precision -= 3; x = 12;
			} else if (rest < 100) {
				precision -= 2; x = 8; 
			} else if (rest < 1000) {
				precision--; x = 4;
			} 
		}
		d = *ret = decimal_create(precision,0,sign);
		for(precision=0; precision < d->precision; precision++) {
			int val = (num[y] & (15<<x)) >> x;
			SETNUM(d,precision, val); 
			if ((x += 4) > 12) { x = 0; y--; } 
		}
	}
	DECIMAL_DEBUG(*ret, FORMAT("decimal_from_lng(%lld) result", *val), 1);
	return MAL_SUCCEED;
}

str decimal_from_str(decimal **ret, str *val){
	int len=0;
	if( strcmp(*val,"nil")==0){
		*ret = decimal_copy(decimal_nil,1);
		return MAL_SUCCEED;
	}
	decimal_fromstr(*val,&len,ret);
	return MAL_SUCCEED;
}
str decimal_from_nil(decimal **ret, int* val) {
	*ret = decimal_copy(decimal_nil,1);
	return MAL_SUCCEED;
}
/* Create a decimal with an integer value (no overflow possible). */
str decimal_from_int(decimal **ret, int* val) {
	lng l = (*val == int_nil)?lng_nil:*val;
	return decimal_from_lng(ret, &l);
}

/* Translates a double into a decimal and a certain precision. */
str decimal_from_dbl(decimal **ret, dbl *val) {
	if (*val == dbl_nil) {
		*ret = decimal_create(-1,0,0);
	} else if (*val == 0.0) {
		*ret = decimal_create(0,0,0);
	} else {
		char buf[64];
		int zero = 0;
		sprintf(buf, "%g", *val);
		decimal_fromstr(buf, &zero, ret);
	}
	return MAL_SUCCEED;
}

/* Create a decimal from a float value and a certain precision. */
str decimal_from_flt(decimal **ret, flt* val){
	if (*val == flt_nil) {
		*ret = decimal_create(-1,0,0);
	} else if (*val == 0.0) {
		*ret = decimal_create(0,0,0);
	} else {
		char buf[32];
		int zero = 0;
		sprintf(buf, "%g", *val);
		decimal_fromstr(buf, &zero, ret);
	}
	return MAL_SUCCEED;
}

lng long_value(decimal *val, int digits, int padding) {
	lng l = 0;
	int x;

	for(x=0; x < digits; x++) {
		l = GETNUM(val,x) + MULT10(l);
	}
	for(x=0; x < padding; x++) {
		l = MULT10(l);
	}
	return (val->negative)?-l:l;
}

/* Return the truncated value of a decimal as a long (return lng(nil) on overflow). */
str decimal_to_lng(lng *ret, decimal **valinput) {
	decimal *val= *valinput;
	if (ISNIL(val) || decimal_compare(val, decimal_lng_max) >= 0 ||
                          decimal_compare(val, decimal_lng_min) < 0) 
	{
		*ret = lng_nil;
	} else {
		int padding = 0, digits = val->precision;
		if (val->scale < 0) {
			digits += val->scale;
		} else {
			padding = val->scale;
		}
		*ret = long_value(val, digits, padding);
	}
	DECIMAL_DEBUG(val, FORMAT("decimal_to_lng(->%lld) result", *ret), 1);
	return MAL_SUCCEED;
}

/* Return the truncated value of a decimal as an integer (return int(nil) on overflow). */
str decimal_to_int(int *ret, decimal **valinput) {
	decimal *val = *valinput;
	if (ISNIL(val) || decimal_compare(val, decimal_int_max) >= 0 ||
                          decimal_compare(val, decimal_int_min) < 0) 
	{
		*ret = int_nil;
	} else {
		lng l;
		decimal_to_lng(&l, valinput);
		*ret = (int) l;
	}
	return MAL_SUCCEED;
}

dbl pow10_table[8] = 
    { 1.0, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, 10000000.0 };

/* Return the value of a decimal as a double (return dbl(nil) on overflow). */
str decimal_to_dbl(dbl *ret, decimal **valinput) {
	decimal *val = *valinput;
	if (ISNIL(val) || decimal_compare(val, decimal_dbl_max) >= 0 ||
                          decimal_compare(val, decimal_dbl_min) < 0)  
	{
		*ret = dbl_nil;
	} else {
		int scale = val->scale + val->precision - MIN(val->precision,18);
                int itr = ABS(scale);
		dbl value = (dbl) long_value(val, MIN(18,val->precision), 0);
                dbl scl = pow10_table[itr&7];

                for(itr>>=3; itr; itr--) {
                        scl *= 100000000.0;
                }
                if (scale < 0) {
                        value /= scl;
                } else {
                        value *= scl;
                }
		*ret = value;
	}
	DECIMAL_DEBUG(val, FORMAT("decimal_to_dbl(->%f) result", *ret), 1);
	return MAL_SUCCEED;
}

/* Return the value of a decimal as a double (return flt(nil) on overflow). */
str decimal_to_flt(flt* ret, decimal **valinput) {
	decimal *val = *valinput;
	if (ISNIL(val) || decimal_compare(val, decimal_flt_max) >= 0 ||
                          decimal_compare(val, decimal_flt_min) < 0) 
	{
		*ret = flt_nil;
	} else {
		dbl d;
		decimal_to_dbl(&d, valinput); /* no overflow possible */
		*ret = (flt) d;
	}
	return MAL_SUCCEED;
}
@- Comparison
The bunch of atomary operators needed for comparisons
@= compareImpl
str CMD@3_@1(int *ret, @3 **v, @3 **w){
	if( ISNIL(*v) || ISNIL(*w))
		*ret= bit_nil;
	else	*ret = @3_compare(*v,*w) @2 0;
	return MAL_SUCCEED;
}
@= compareAll
	@:compareImpl(EQ,==,@1)@
	@:compareImpl(NEQ,!=,@1)@
	@:compareImpl(LT,<,@1)@
	@:compareImpl(LE,<=,@1)@
	@:compareImpl(GT,>,@1)@
	@:compareImpl(GE,>=,@1)@

@c
	@:compareAll(decimal)@
str CMDdecimal_isnil(int *ret, decimal **v){
	*ret= ISNIL(*v);
	return MAL_SUCCEED;
}
@- misc operators
@c
/* Returns a decimal whose value is -1 * value. */
str decimal_negative(decimal **ret, decimal **valinput) {
	decimal *val= *valinput;
	DECIMAL_DEBUG(val, "decimal_negative() val", 1);

	if (ISNIL(val) || ISZERO(val)) {
		(*ret) = decimal_copy(val, val->precision);
	} else {
		*ret = decimal_create(val->precision, 0, 0);
		decimal_normalize(*ret, val, 0, val->precision, TRUE);
		(*ret)->negative = !(*ret)->negative;
	}
	DECIMAL_DEBUG(*ret, "decimal_negative() result", 1);
	return MAL_SUCCEED;
}

/* Returns a decimal whose value is the absolute value of this number. */
str decimal_abs(decimal **ret, decimal **valinput) {
	decimal *val= *valinput;

	DECIMAL_DEBUG(val, "decimal_abs() val", 1);

	if (ISNIL(val) || ISZERO(val)) {
		(*ret) = decimal_copy(val, val->precision);
	} else {
		*ret = decimal_create(val->precision, 0, 0);
		decimal_normalize(*ret, val, 0, val->precision, TRUE);
		(*ret)->negative = 0;
	}
	DECIMAL_DEBUG(*ret, "decimal_abs() result", 1);
	return MAL_SUCCEED;
}

/* Return the same number but with a different scale. */
str decimal_set_scale(decimal **ret, decimal **valinput, int *scale) {
	decimal *val= *valinput;
        int delta = (ISNIL(val) || ISZERO(val)) ? 0 : val->scale - *scale;
        DECIMAL_DEBUG(val, FORMAT("decimal_set_scale(%d) input", *scale), 1);

        *ret = decimal_copy(val, MAX(0, val->precision + delta));

        DECIMAL_DEBUG(*ret, FORMAT("decimal_set_scale(%d) result", *scale), 1);
        return MAL_SUCCEED;
}

str decimal_movedot(decimal **ret, decimal **valinput, int *delta) {
	decimal *val = *valinput;
	DECIMAL_DEBUG(val, FORMAT("decimal_movedot(%d) input", *delta), 1);

	if (ISZERO(val)) {
		*ret = decimal_copy(decimal_zero, 1);
	} else if (ISNIL(val) || (val->scale + *delta) < SCALE_MIN || (val->scale + *delta) > SCALE_MAX) {
		*ret = decimal_copy(decimal_nil, 1);
	} else {
		*ret = decimal_copy(val, val->precision);
		(*ret)->scale += *delta;
	}
	DECIMAL_DEBUG(*ret, FORMAT("decimal_movedot(%d) result", *delta), 1);
	return MAL_SUCCEED;
}

/* Return the same number but with a different precision (truncated or zero-padded). */
str decimal_set_precision(decimal **ret, decimal **valinput, int *precision) {
	decimal *val = *valinput;
	int delta = (ISNIL(val) || ISZERO(val)) ? 0 : *precision;
	DECIMAL_DEBUG(val, FORMAT("decimal_set_precision(%d) input", *precision), 1);

	*ret = decimal_copy(val, delta);

	DECIMAL_DEBUG(*ret, FORMAT("decimal_set_precision(%d) result", *precision), 1);
	return MAL_SUCCEED;
}

/* Returns the scale of this number. */
str decimal_get_scale(int *ret, decimal **valinput) {
	decimal *val = *valinput;
	*ret = ISNIL(val) ? int_nil : ISZERO(val) ? 0 : val->scale;

	DECIMAL_DEBUG(val, FORMAT("decimal_get_scale(scale->%d) input", *ret), 1);
	return MAL_SUCCEED;
}

/* Returns the precision of this number. */
str decimal_get_precision(int *ret, decimal **valinput) {
	decimal *val= *valinput;
	*ret = ISNIL(val)? int_nil : val->precision;

	DECIMAL_DEBUG(val, FORMAT("decimal_get_precision(precision->%d) input", *ret), 1);
	return MAL_SUCCEED;
}

/* Returns whether the decimal is an exact tenfold */
str decimal_istenfold(bit *ret, decimal **valinput) {
	decimal *val = *valinput;
	*ret = ISNIL(val)?bit_nil:ISTENFOLD(val);
	return MAL_SUCCEED;
}

@- arithmetic
@T
Computer hardware does not provide builtin support for arbitrarly large numbers.
The iterative algorithms employed here stem directly from Peter's primary school. 

@- plus and minus
@T
plus and minus algorithms assume positive numbers. Other cases are handled 
as follows:
\begin{verbatim}
   -x + -y => -decimal_plus(x,y)     -x - -y => -decimal_minus(x,y);
    x + -y => decimal_minus(x,y)      x - -y => decimal_plus(x,y)
   -x +  y => decimal_minus(y,x)     -x -  y => decimal_plus(-x,-y)
\end{verbatim} 
@c
/* auxiliary function: assumes equal sign and scale and no overflow */
static INLINE
void decimal_simple_inc(decimal* v1, decimal* v2) {
	int x = v1->precision, y = v2->precision, rest=0;

	DECIMAL_DEBUG(v1, "decimal_simple_inc() acc", 0);
	DECIMAL_DEBUG(v2, "decimal_simple_inc() val", 0);

	for(x--, y--; y >= 0; x--, y--) {
		int r1 = ADD(GETNUM(v1,x),GETNUM(v2,y));
		int r2 = ADD(LO(r1), rest);
		SETNUM(v1,x,LO(r2));
		rest = HI(r1) + HI(r2);
	}
	for(; rest && x >= 0; x--) {
		int r2 = ADD(GETNUM(v1,x), rest);
		SETNUM(v1,x,LO(r2));
		rest = HI(r2);
	}
	DECIMAL_DEBUG(v1, "decimal_simple_inc() acc", 0);
}

/* auxiliary function: assumes equal sign and scale and no overflow */
static INLINE
void decimal_simple_dec(decimal* v1, decimal* v2) {
	int x = v1->precision, y = v2->precision, rest=0;

	DECIMAL_DEBUG(v1, "decimal_simple_dec() acc", 0);
	DECIMAL_DEBUG(v2, "decimal_simple_dec() val", 0);

	for(x--, y--; y >= 0; x--, y--) {
		int r1 = MINUS(GETNUM(v1,x),GETNUM(v2,y));
		int r2 = MINUS(LO(r1), rest);
		SETNUM(v1,x,LO(r2));
		rest = HI(r1) + HI(r2);
	}
	for(; rest && x >= 0; x--) {
		int r2 = MINUS(GETNUM(v1,x), rest);
		SETNUM(v1,x,LO(r2));
		rest = HI(r2);
	}
	DECIMAL_DEBUG(v1, "decimal_simple_dec() acc", 0);
}

/* Returns a decimal whose value is (val1 + val2). */
str decimal_plus(decimal **ret, decimal **v1input, decimal **v2input) {
	decimal *v1= *v1input, *v2= *v2input;
	decimal *tmp, *tot, *v3 = NULL;
	str x;

	DECIMAL_DEBUG(v1, "decimal_plus() left", 1);
	DECIMAL_DEBUG(v2, "decimal_plus() right", 1);

	/* special cases */
	if (ISNIL(v1) || ISNIL(v2)) {
		*ret = decimal_copy(decimal_nil, 1);
		return MAL_SUCCEED;
	} 
	if (ISZERO(v1)) {
		*ret = decimal_copy(v2, v2->precision);
		return MAL_SUCCEED;
	} 
	if (ISZERO(v2)) {
		*ret = decimal_copy(v1, v1->precision);
		return MAL_SUCCEED;
	} 

	/* enforce same sign; different signs is handled by minus */
	if (v1->negative && !v2->negative) {
		tmp = v2; v2 = v1; v1 = tmp;
	}
	if (v2->negative && !v1->negative) {
		tmp = decimal_copy(v2, v2->precision);
		tmp->negative = 0;		 
		x = decimal_minus(ret, &v1, &tmp);
		GDKfree(tmp);
		return x;
	}
	/* enforce same scale */
	if (v2->scale < v1->scale) {
		tmp = v2; v2 = v1; v1 = tmp;
	}
	if (v2->scale > v1->scale) {
		v2 = v3 = decimal_copy(v2, v2->precision + v2->scale - v1->scale );
	}
	if (v2->precision > v1->precision) {
		tmp = v2; v2 = v1, v1 = tmp;
	}
	/* check for nil  and overflow */
	tot = *ret = decimal_create(v1->precision+1, v1->scale, v1->negative);
	if (!ISNIL(tot)) {
		/* accumulate using simple addition */
		decimal_normalize(tot,v1,1,v1->precision+1,FALSE);
		decimal_simple_inc(tot,v2);
		decimal_normalize(tot,tot,0,0,TRUE);
	}
	if (v3) GDKfree(v3);	
	DECIMAL_DEBUG(*ret, "decimal_plus() result", 1);
	return MAL_SUCCEED;
}

/* Returns a decimal whose value is (val1 - val2). */
str decimal_minus(decimal **ret, decimal **v1input, decimal **v2input) {
	decimal *v1= *v1input, *v2= *v2input;
	decimal *tmp, *v3 = NULL;
	str x; int xi, negative = v1->negative;

	DECIMAL_DEBUG(v1, "decimal_minus() left", 1);
	DECIMAL_DEBUG(v2, "decimal_minus() right", 1);

	/* special cases */
	if (ISNIL(v1) || ISNIL(v2)) {
		*ret = decimal_copy(decimal_nil, 1);
		return MAL_SUCCEED;
	} else if (ISZERO(v1)) {
		*ret = decimal_copy(v2, v2->precision);
		(*ret)->negative = !(*ret)->negative;
		return MAL_SUCCEED;
	} else if (ISZERO(v2)) {
		*ret = decimal_copy(v1, v1->precision);
		return MAL_SUCCEED;
	} 

	/* enforce same sign; different signs is handled by minus */
	if (v1->negative && !v2->negative) {
		tmp = v2; v2 = v1; v1 = tmp;
	}
	if (v2->negative && !v1->negative) {
		tmp = decimal_copy(v2, v2->precision);
		tmp->negative = 0;		 
		x = decimal_plus(ret, &v1, &tmp);
		if (x == MAL_SUCCEED && negative && ISZERO(*ret)==0 && ISNIL(*ret)==0)  {
			(*ret)->negative = !(*ret)->negative;
		}
		GDKfree(tmp);
		return x;
	}
	/* enforce same scale */
	if (v2->scale < v1->scale) {
		tmp = v2; v2 = v1; v1 = tmp; negative = !negative;
	}
	if (v2->scale > v1->scale) {
		v2 = v3 = decimal_copy(v2, v2->precision + v2->scale - v1->scale);
	}
	/* minus without overflow by subtracting the smaller from the bigger number */
	xi = decimal_compare(v1,v2);
	if ((v1->negative == 0 && xi < 0) || (v1->negative != 0 && xi > 0)) {
		tmp = v2; v2 = v1; v1 = tmp; negative = !negative;
	}
	*ret = decimal_copy(v1, v1->precision);
	decimal_simple_dec(*ret,v2);
	(*ret)->negative = negative;
	decimal_normalize(*ret,*ret,0,0,TRUE);

	if (v3) GDKfree(v3);	
	DECIMAL_DEBUG(*ret, "decimal_minus() result", 1);
	return MAL_SUCCEED;
}

@- multiply 
@c
/* Returns a decimal whose value is (val1 * val2). */
str decimal_multiply(decimal **ret, decimal **v1input, decimal **v2input) {
	decimal *v1= *v1input, *v2= *v2input;
	int v1_precision=v1->precision, v2_precision=v2->precision, x;
	decimal *tot, *tmp;

	DECIMAL_DEBUG(v1, "decimal_multiply() left", 0);
	DECIMAL_DEBUG(v2, "decimal_multiply() right", 0);

	/* check special cases */
	if (ISZERO(v1) || ISZERO(v2)) {
		*ret = decimal_create(0,0,0);
		return MAL_SUCCEED;
	} else if (ISTENFOLD(v1) && (v2->scale+v1->precision+v1->scale) <= SCALE_MAX) {
		*ret = decimal_copy(v2, v2->precision);
		(*ret)->negative = v1->negative^v2->negative;
		(*ret)->scale += v1->scale + v1->precision - 1;
		return MAL_SUCCEED;
	} else if (ISTENFOLD(v2) && (v1->scale+v2->precision+v1->scale) <= SCALE_MAX) {
		*ret = decimal_copy(v1, v1->precision);
		(*ret)->negative = v1->negative^v2->negative;
		(*ret)->scale += v2->scale + v2->precision - 1;
		return MAL_SUCCEED;
	}
	
	/* during multiplication we do not waste time with trailing zeros */
	while(--v1_precision >= 0) {
		if (GETNUM(v1,v1_precision)) break; /* find last nonzero digit in v1 */
	}
	while(--v2_precision >= 0) {
		if (GETNUM(v2,v2_precision)) break; /* find last nonzero digit in v2 */
	}
	v1_precision++; v2_precision++;
	tot = *ret = decimal_create(v1_precision+v2_precision,
					(v1->scale+v1->precision-v1_precision) + 
					(v2->scale+v2->precision-v2_precision), 
					v1->negative^v2->negative);
	/* check for overflow */
	if (ISNIL(v1) || ISNIL(v2) || ISNIL(tot)) {
		*tot = *decimal_nil;
		return MAL_SUCCEED;
	} 

	/* multiply with smallest=v1 below and biggest=v2 above */
	if (v1_precision > v2_precision) {
		int swap = v1_precision; v1_precision = v2_precision; v2_precision = swap;
		tmp = v2; v2 = v1; v1 = tmp; /* swap if necessary */
	}

	/* for each digit in the lower number, we multiply the above number by that digit 
         * in tmp -- each time with one more trailing zero, and add tmp to tot (initially 0).
         */
	tmp = decimal_create(v1_precision+v2_precision,0,0);
	x = v1_precision;

	while(--x >= 0) {
		int z, y, f = GETNUM(v1,x), rest = 0;
		if (f == 0) {
			continue; /* optimization: just skip zeros */
		}
		z = tmp->precision;
		y = x + v2_precision;

		while(--z > y) {
			SETNUM(tmp, z, 0);
		}
		y = v2_precision;
		while(--y >= 0) {
			int r1 = MULT(f, GETNUM(v2,y)); /* HI(r1) is at most 8 (9*9) */
			int r2 = ADD(LO(r1), rest);     /* HI(r2) is at most 1 (9+9) */
 			SETNUM(tmp, z, LO(r2)); z--;
			rest = HI(r1) + HI(r2); 	/* no overflow: at most 9 (8+1) */
		}
		SETNUM(tmp, z, rest); z--;
		decimal_simple_inc(tot, tmp); 
	}
	decimal_normalize(tot,tot,0,0,TRUE);

	GDKfree(tmp);
	DECIMAL_DEBUG(*ret, "decimal_multiply() result", 1);
	return MAL_SUCCEED;
}


@- divide
Uses a multiplication table containing div*1,.., div*9 to speed up matching.
@c
static INLINE
void decimal_mult_table(decimal* div, decimal* mult[10]) {
	int i, len=TOTLEN(div->precision+1);
	char *p = (char*) GDKmalloc(i = 10*len);
	memset(p, 0, i);
	mult[0] = decimal_alloc(div->precision+1, div->scale, div->negative, (decimal*) p, &len);
	for(i=1; i<10; i++) {
		decimal_simple_inc(mult[0], div);
		mult[i] = (decimal*) (p += len);
		decimal_normalize(mult[i],mult[0],0,0,FALSE);
	} 
}

#define CONCAT_DIGIT(dst, src, y) { /* append a digit from src[y] to dst */\
		int pos = y, val = (pos < src->precision)?GETNUM(src,pos):0;\
		if (val || dst->precision) {\
			SETNUM(dst, dst->precision, val);\
			dst->precision++;\
		}}

/* the guts of the "staartdeling" implementation of division */
static INLINE
void decimal_divide_intern(decimal *tot, decimal *num, decimal *div, decimal* mult[], int precision) {
	decimal *chunk = mult[0];
	int digit, factor=GETNUM(div,0), head, cmp, z, y, x = NUMLEN(chunk->precision); 

	/* set chunk to zero */
	while(--x >= 0) chunk->num[x] = 0; 
	chunk->precision = 0;
	head = chunk->num[-1];

	/* incremental division by multiplication and subtraction */	
	x = -1; y= 0; z = precision; 
	while(TRUE) {
		/* add digits to chunk till it has as many significant digits as div */
		if (chunk->precision < div->precision) {
			if (++x >= z) break;
			SETNUM(tot, x, 0); 
			CONCAT_DIGIT(chunk, num, y++);
			continue;
		} 
		/* if the significant digits are equal, one more must make chunk > div */
		digit = GETNUM(chunk,0);
		cmp = decimal_compare(chunk,div);
		if (div->negative?(cmp > 0):(cmp < 0)) {
			if (++x >= z) break;
			SETNUM(tot, x, 0); 
			CONCAT_DIGIT(chunk, num, y++);
			digit = GETNUM(chunk,1) + MULT10(digit); 
		} 
		/* guess the divisor factor by looking at the first digits */ 
		digit = DIV(digit,factor);
		while(TRUE) {
			cmp = decimal_compare(chunk,mult[digit]);
			if (div->negative?(cmp <= 0):(cmp >= 0)) break;
			digit--; 
		}
		/* this is it! overwrite last zero with digit */
		SETNUM(tot, x, digit); 

		/* subtract digit*div from chunk */ 
		decimal_simple_dec(chunk, mult[digit]);
		decimal_normalize(chunk,chunk,0,0,FALSE);
		if (ISZERO(chunk)) chunk->num[-1] = head; /* hack to restore chunk fields */
 	} 
	decimal_normalize(tot,tot,0,0,TRUE);
}

/* Returns a decimal whose value is (val1 / val2) (division by zero return decimal(nil)). */
str decimal_divide(decimal **ret, decimal **numinput, decimal **divinput, int *precision) {
	decimal *num= *numinput, *div= *divinput;
	int p = MIN(MAX(0,div->precision + *precision),PRECISION_MAX);
	int s = (num->scale-div->scale) + (num->precision-p); 
	decimal *mult[10];
	
	DECIMAL_DEBUG(num, "decimal_divide() num", 1);
	DECIMAL_DEBUG(div, "decimal_divide() div", 1);

	/* check special cases */
	if (ISNIL(num) || ISNIL(div) || ISZERO(div)) {
		*ret = decimal_copy(decimal_nil,1);
		return MAL_SUCCEED;
	} else if (ISZERO(num)) {
		*ret = decimal_copy(decimal_zero,1);
		return MAL_SUCCEED;
	} else if (ISTENFOLD(div) && (s-div->precision) > SCALE_MIN) {
		*ret = decimal_copy(num, *precision); 
		if (ISZERO(*ret) == 0 && ISNIL(*ret) == 0) {
			(*ret)->negative = num->negative^div->negative;
			(*ret)->scale = (num->precision+num->scale+1)-(div->precision+div->scale+*precision);
		}
		return MAL_SUCCEED;
	}
	/* alloc decimal */
	*ret = decimal_create(p, s,  num->negative^div->negative);

	/* create chunk and multiplication table in one memory alloc */
	decimal_mult_table(div, mult);

	/* do the work */
	decimal_divide_intern(*ret, num, div, mult, p);

	/* cleanup */
	GDKfree(mult[0]); 
	DECIMAL_DEBUG(*ret, "decimal_divide() result", 1);
	return MAL_SUCCEED;
}

/* default division measures how many times div goes into num */
str decimal_divide_default(decimal **ret, decimal **num, decimal **div) {
	int precision = MAX(0,((*num)->precision+(*num)->scale) - 
		((*div)->precision+(*div)->scale));
	return decimal_divide(ret, num, div, &precision);
}

@-
@= getBATdescriptor
        if( BBPcheck(*@2,"@4")==0)
                return throwMessage("decimal.@4","cannot access bat @2 in bbp");
        @3= (BAT*) BBPgetdesc(*@2);
        if( @3 == NULL) { *@1 = 0;
                return throwMessage("decimal.@4","cannot access descriptor @2");
        }
        if( *@2 <0){ /* BAT reverse */ @3 = BATmirror(@3); }
@-
Bulkdivide divides all values in a bat by the same divisor.
It gains efficiency by avoiding copying the decimals into the BAT (it writes
directly into it) and by constructing the multiplication table only once.
@c
str decimal_bulkdivide(int* ret, int* bid, decimal **divinput, int *prec) {
	BAT *b;
	decimal *div= *divinput;
	int xx, yy = 10;
	BAT *bn;
	BAT *bm ;
	decimal *mult[10];
	BUN p, q;
	Heap hp;
	
	@:getBATdescriptor(ret,bid,b,bulkdivide)@
	xx = BATcount(b);
	bn = BATnew(b->htype, TYPE_int, xx);
	*ret = bn->batCacheid;
	bm = BATmirror(bn);

	/* create space for decimals */
	if (prec) {
		yy = MIN(div->precision+MAX(1,*prec)-1,PRECISION_MAX)+1;
	} else if (xx) {
		decimal *d = (decimal*) BUNtvar(b,BUNfirst(b));
		yy = TOTLEN(d->precision+1);
	}
	HEAP_initialize_compact(&hp, MAX(10,xx)*yy, 0, 0, (int (*)(ptr)) decimal_length);

	/* create chunk and multiplication table just once for all invocations */
	decimal_mult_table(div, mult);

	bn->tsorted = 0;
	BATloopFast(b, p, q, xx) {
		decimal *src = (decimal*) BUNtvar(b,p);
		int divprc = prec?yy:src->precision;
		int zero = ISZERO(src);
		int nil = ISNIL(src);
		int len = (zero || nil)?sizeof(decimal):TOTLEN(divprc);
		int idx = HEAP_malloc(&hp, len);
		decimal *dst = (decimal*) (hp.base + idx);

		BUNfastins(bn, BUNhead(b,p), &idx);

		/* compute the division */
		if (nil) {
			*dst = *decimal_nil;
		} else if (zero) {
			*dst = *decimal_zero;
		} else {
			((int*) ((char*) dst + len))[-1] = 0; /* zero tail that may not be written */
			dst->precision = divprc;
			dst->scale = (src->scale-div->scale) + (src->precision-divprc); 
			dst->negative = src->negative^div->negative;
			decimal_divide_intern(dst, src, div, mult, divprc);
		}
	}
	/* trickily place the heap as tailheap into the bat */
	bn->ttype = bm->htype = TYPE_decimal;
	bn->tvarsized = bm->hvarsized = 1;
	bn->theap = hp;
	strcpy(bn->tatom, "decimal");
	ALIGNsetH(bn, b);

	/* cleanup */
	GDKfree(mult[0]);
	return MAL_SUCCEED;
}

str decimal_bulkdivide_default(int *ret, int *bid, decimal **div) {
	return decimal_bulkdivide(ret, bid, div, NULL);
}

@- power
@c
#define DEC_PRECISION(d,x) { d->scale += (d->precision - x); d->precision = x; }

/* Raises a decimal to some (integer) power. precision determines the maximum precision of the result. */
str decimal_pow(decimal **ret, decimal **dinput, int *i, int *p) {
	decimal *d= *dinput;
	int x, y, z, nfactors=0, factor[32], raise = *i, precision = *p;
	decimal *cache[32], *tmp, *tot = d;

	/* handle special cases */
	if (ISNIL(d) || raise == int_nil || precision == int_nil || 
            ((d->precision+d->scale) > 0 && raise*(d->precision+d->scale) > SCALE_MAX)) 
	{
		*ret = decimal_copy(decimal_nil,1);
		return MAL_SUCCEED;
	} else if ((d->precision+d->scale) < 0 && raise*(d->precision+d->scale) < SCALE_MIN) { 
		*ret = decimal_copy(decimal_zero,1);
		return MAL_SUCCEED;
	} else if (raise == 0) {
		*ret = decimal_copy(decimal_one,precision);
		return MAL_SUCCEED;
	} else if (raise == 1) {
		*ret = decimal_copy(d,precision);
		return MAL_SUCCEED;
	} else if (raise < 0) {
		/* handle negative power as one divided by power */
		str ret_value;
		raise = -raise;
		if ((ret_value=decimal_pow(&tot, dinput, &raise, &precision)) == MAL_SUCCEED) {
		    ret_value = decimal_divide(ret, &decimal_one, &tot, p); 
		    GDKfree(tot);
		}
		return ret_value;
	}

	/* algorithm uses squaring of intermediates results; needs log2(n) multiplications */
	y = *(int*) d; /* backup header of d */

	/* take the multiplication precision as end_precision/2 + 2 */
	z = MIN(precision, (precision >> 1) + 2); 

	/* establish which factors are required */
	for(x=0; raise; x++) {
		if (raise&1) {
		 	factor[nfactors++] = x;
		}
		raise = (raise >> 1) & ~(1<<31);
	}
	raise = factor[nfactors-1];

	/* compute all powers of two up till the highest required factor by succesive x*x */
	cache[0] = d;
	DEC_PRECISION(cache[0],z);
	for(x=1; x <= raise; x++) {
		decimal_multiply(cache+x, &cache[x-1], &cache[x-1]);
		DEC_PRECISION(cache[x],z);
	}
	
	/* multiply all required factors to get the result */
	tot = cache[factor[0]];
	tmp = NULL;
	for(x=1; x < nfactors; x++) {
		decimal_multiply(&tot, &tot, &cache[factor[x]]);
		DEC_PRECISION(tot,precision);
		if (tmp) GDKfree(tmp);
		tmp = tot;
	}

	/* free all cached factors */
	for(x=1; x <= raise; x++) {
		if (cache[x] != tot) GDKfree(cache[x]);
	}
	*(int*) d = y; /* restore backup */
	decimal_normalize(*ret = tot, tot, 0, precision, TRUE);
	return MAL_SUCCEED;
}

str decimal_pow_default(decimal **ret, decimal **d, int *raise) {
	int precision = (*d)->precision;
	return decimal_pow(ret, d, raise, &precision); 
}
@}
@}
