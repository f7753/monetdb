@f x100core
@a Peter Boncz, Niels Nes, Martin Kersten
@v 0.1 
@* X100 Execution Primitives
@T
This module contains the vectorized implementation of a majority of
BAT kernel operators. Vectors are currently implemented as BAT(void,type),
which makes integration with the remainder of Monet quite easy.

The code base is optimized for speed on modern processors. Furthermore,
much of the administrative overhead with BATs is removed.

At an abstract level, the vectorized code consists of three basic commands:
\begin{itemize}
\item {\bf aggr(res,grp,param,N}: 
increment a field in an aggregate result array: res[grp[i]] = AGGR\_INC(res[grp[i]], p[i]).
The first parameter N is the vector length (in this case the size of grp and param). 
\item {\bf map(res, p1, p2..,N)} Apply a function over all parameters (which may be vectors or single values), 
filling the result vector: res[i] = ANY\_FCN(p1[i], p2[i],..). All non-aggregate functions have a map implementation,
for each permutation of signatures where parameters can be either constants or vectors (including the variant with all constants).
\item {\bf select(res,..params..,N)}: Like a map, but the result is a vector of those positions where the boolean 
function evaluated to true: res[i] = i; i += BOOL\_FCN(p1[i], p2[i],..). The return value is the number of values selected.
An all-constant-parameter version of select implementations is not relevant, of course.
\end{itemize}
All functions may get an additional extra parameter, which is a selection vector.
In this case, the operation is only executed on those vector indices pointed to 
by uidx selection vector. 

@+ MAL interface
The original x100 instruction set is cast into the MAL language framework.
For type analysis we have introduced the concept of a collection type 
vec[type], which is semantically identical to a bat[void,type].
In this implementation, we use this equivalence at parsing time to recast it.
(later a distinguishing property should be introduced)

Note that the vectors are always bounded by size. For the time being 
it is up to the programmer to ensure that the size for the vector
operation is properly choosen.
No streaming behavior is assumed.

The atomary types should be moved to the atoms module.
@mal
#atom module uchr:chr;	# unsigned char
atom module schr:chr;	# signed char
atom module usht:int;	# unsigned short
atom module ssht:int;	# signed short
atom module uint:int;	# unsigned int
atom module sint:int;	# signed int
atom module ulng:lng;	# unsigned long long
atom module slng:lng;	# signed long long
atom module uidx:lng;	# size_t

module x100;
# the cast operators, just a few to get going
command uidx(i:lng):uidx = cast_lng_uidx;
command uidx(i:int):uidx = cast_int_uidx;
command uint(i:lng):uint = cast_lng_uint;
command uint(i:int):uint = cast_int_uint;

command lng(i:uidx):lng = cast_uidx_lng;
command int(i:uidx):int = cast_uidx_int;
command lng(i:uint):lng = cast_uint_lng;
command int(i:uint):int = cast_uint_int;
@-
The x100 commands description uses the type signature to distinguish
alternative implementations. This way the command name is much shorter
then in those used in the implementation.

The primitives are limited to those with a corresponding implementation
in a BAT. This means that not all x100 types are immediately supported,
due to alignment issues. This is resolved once the type definitions
are properly handled.
@mal

pattern newVector(tpe:any::1, cap:lng):bat[void,any::1]= CMDx100new
comment "create a vector for type 'tpe'.";

command aggr_count(res:vec[uint], grp:vec[uint]):void 
	= aggr_count_uint_col_default_wrap;
command aggr_count(res:vec[uint], grp:vec[uint], N:lng):void 
	= aggr_count_uint_col_wrap;
command aggr_count(res:vec[uint], grp:vec[uint], sel:vec[uint]):void 
	= aggr_count_uint_col_sel_default_wrap;
command aggr_count(res:vec[uint], grp:vec[uint], sel:vec[uint], N:lng):void 
	= aggr_count_uint_col_sel_wrap
comment "Count the number of elements per group for those selected.";
@-
The collect() operator extracts the row identifiers for qualifying tuples.
@= collectDef
command collect(res:vec[@1], coll:vec[@1], N:lng):lng= collect_@1_col_wrap;
command collect(res:vec[@1], coll:vec[@1]):lng= collect_@1_col_default_wrap;
command collect(res:vec[@1], coll:vec[@1], sel:vec[@1], N:lng):lng= collect_@1_col_sel_wrap
comment "Collect the indices of the valid tuples based on a particular column";

@mal
@:collectDef(uint)@
@-
The selectors are geared towards simple predicates of the from Col Op Cst.
Operations over constants could be filtered out by the optimizer using
symbolic evaluation.
@= defBinary
command @3(res:vec[@2],col:vec[@2],val:@2,sel:vec[@2],N:lng): lng
	= select_@1_@2_col_@2_val_sel_wrap;
command @3(res:vec[@2],col:vec[@2],val:@2,N:lng): lng
	= select_@1_@2_col_@2_val_wrap;

command @3(res:vec[@2],col:vec[@2],val:vec[@2],N:lng): lng
	= select_@1_@2_col_@2_col_wrap;
command @3(res:vec[@2],col:vec[@2],val:vec[@2],sel:vec[@2],N:lng): lng
	= select_@1_@2_col_@2_col_sel_wrap
comment "select all tuples that qualify col < val.";
@mal
@:defBinary(le,uint,<=)@
@:defBinary(ge,uint,<=)@
@:defBinary(lt,uint,<)@
@:defBinary(gt,uint,>)@
@:defBinary(eq,uint,==)@
@:defBinary(ne,uint,!=)@

@:defBinary(le,flt,<=)@
@:defBinary(ge,flt,<=)@
@:defBinary(lt,flt,<)@
@:defBinary(gt,flt,>)@
@:defBinary(le,dbl,<=)@
@:defBinary(ge,dbl,<=)@
@:defBinary(lt,dbl,<)@
@:defBinary(gt,dbl,>)@
@-
The collection of binary arithmetic operators.
@= mathBinary
command @1(res:@5,col1:@3,col2:@4): lng
	= map_@2_@3_val_@4_val_wrap;
command @1(res:vec[@5],col1:vec[@3],col2:vec[@4],N:lng): lng
	= map_@2_@3_col_@4_col_wrap;
command @1(res:vec[@5],col1:vec[@3],col2:vec[@4],sel:vec[uint],N:lng): lng
	= map_@2_@3_col_@4_col_sel_wrap;

command @1(left:@3,right:@3):@3 = map_@2_@3_wrap;


@= mathUnary
command @1(res:vec[@3],col1:vec[@3],N:lng): lng
	= map_@2_@3_col_wrap;
command @1(res:vec[@3],col1:vec[@3],sel:vec[uint],N:lng): lng
	= map_@2_@3_col_sel_wrap;

@mal
@:mathBinary(+,add,uint,uint,uint)@
@:mathBinary(-,sub,uint,uint,uint)@
@:mathBinary(/,div,uint,uint,uint)@
@:mathBinary(*,mul,uint,uint,uint)@
@:mathUnary(-,neg,uint)@
@-
The fetch operations perform an indirect selection
@= fetchBinary
command fetch(res:vec[@2],col1:vec[@1],col2:vec[@2],N:lng): lng
	= map_fetch_@1_col_@2_col_wrap;
command fetch(res:vec[@2],col1:vec[@1],col2:vec[@2],sel:vec[uint],N:lng): lng
	= map_fetch_@1_col_@2_col_sel_wrap;
@mal
@:fetchBinary(uidx,uidx)@
@-
@= aggrOperations
command @1(res:vec[@2],col1:vec[@2],grp:vec[@2],N:lng):lng
= aggr_@1_@2_col_uidx_col_wrap;
command @1(res:vec[@2],col1:vec[@2],grp:vec[@2],sel:vec[uint],N:lng):lng
= aggr_@1_@2_col_uidx_col_sel_wrap
comment "Aggregate over a group to produce the '@1' per element.";

command @1(col:vec[@2]):@2 = aggr_@1_@2_col_wrap
comment "Single group aggregation without selection";
@mal
@:aggrOperations(max,uint)@
@:aggrOperations(min,uint)@

@= groupOperations
command directgrp(res:vec[@1],col1:vec[@1],col2:vec[@2],
	val:vec[@3], sel:vec[@1], N:int)
	= map_directgrp_@1_col_@2_col_@3_val_sel_wrap;
command directgrp(res:vec[@1],col1:vec[@1],col2:vec[@2],
	val:vec[@3], N:int)
	= map_directgrp_@1_col_@2_col_@3_val_wrap;
@mal
@:groupOperations(uidx,uchr,uint)@
@-
@= aggr4Operations
command  aggr4_count(r0:vec[uidx], r1:vec[uidx], r2:vec[uidx], r3:vec[uidx], 
	grp:vec[uidx],sel:vec[uidx],N:lng):void 
	=  aggr4_count_uidx_col_multicursor_sel_wrap
comment "Count the number of elements per group for those selected.";

command  aggr4_count(r0:vec[uidx], r1:vec[uidx], r2:vec[uidx], r3:vec[uidx], 
	grp:vec[uidx],N:lng):void 
	=  aggr4_count_uidx_col_multicursor_wrap
comment "Count the number of elements per group for those selected.";
@mal
@:aggr4Operations@
@-
TODO
@=indextile
command map_indextile_@1_val_@2_val_@3_val_wrap(res:uidx,pos:uidx, 
	Mult:uidx, Domain:uidx, N:int) 
		= map_indextile_@1_val_@2_val_@3_val_wrap
comment "";

@:indextile(uidx,uidx,uidx)@
@:indextile(uidx,uidx,dbl)@
@+ Engine
@T
This is it: all what used to be MIL. The "engine" macro, using either the "impl" or "decl" parameter, 
is used to instantiate all implementations, as well as the function lookup table (see below).

Some types and operators are still disabled to keep compilation fast.

@= engine
	@:cardinal(@1,uchr,ulng)@
	@:cardinal(@1,uint,ulng)@
	@:cardinal(@1,uidx,ulng)@
	@:floating(@1,flt,dbl)@
	@:floating(@1,dbl,dbl)@
	@:@1_grp(uchr)@
@
	@:cardinal(@1,usht,ulng)@
	@:cardinal(@1,ulng,ulng)@
	@:cardinal(@1,schr,slng)@
	@:cardinal(@1,ssht,slng)@
	@:cardinal(@1,sint,slng)@
	@:cardinal(@1,slng,slng)@

@= cast_ops
	@:@1_castop(@2,uchr)@
	@:@1_castop(@2,uint)@
	@:@1_castop(@2,uidx)@
	@:@1_castop(@2,flt)@
	@:@1_castop(@2,dbl)@
@
	@:@1_castop(@2,usht)@
	@:@1_castop(@2,ulng)@
	@:@1_castop(@2,schr)@
	@:@1_castop(@2,ssht)@
	@:@1_castop(@2,sint)@
	@:@1_castop(@2,slng)@

@= type_ops
	@:@1_fetchop(@2)@
	@:cast_ops(@1,@2)@
	@:@1_boolop_binary(<=,le,@2,@2)@
	@:@1_boolop_binary(>,gt,@2,@2)@
	@:@1_boolop_binary(<,lt,@2,@2)@
	@:@1_boolop_binary(>=,ge,@2,@2)@
	@:@1_boolop_binary(=,eq,@2,@2)@
	@:@1_boolop_binary(!=,ne,@2,@2)@
@

@= arith_ops
	@:@1_op_binary(*,mul,@2,@2,@2)@
	@:@1_op_binary(/,div,@2,@2,@2)@
	@:@1_op_binary(+,add,@2,@2,@2)@
	@:@1_op_binary(-,sub,@2,@2,@2)@
	@:@1_aggrop(sum,sum,@2,@3)@
	@:@1_op_unary(-,neg,@2,@2)@
	@:@1_aggrop(min,min,@2,@2)@
	@:@1_aggrop(max,max,@2,@2)@
@
	@:@1_op_unary(dec,dec,@2,@2)@
	@:@1_op_unary(abs,ABS,@2,@2)@
	@:@1_op_unary(inc,inc,@2,@2)@

@= floating
	@:type_ops(@1,@2)@
	@:arith_ops(@1,@2,@3)@
@
	@:@1_op_binary(pow,pow,dbl,dbl,dbl)@
	@:@1_op_unary(sin,sin,dbl,dbl)@
	@:@1_op_unary(asin,asin,dbl,dbl)@
	@:@1_op_unary(cos,cos,dbl,dbl)@
	@:@1_op_unary(acos,acos,dbl,dbl)@
	@:@1_op_unary(tan,tan,dbl,dbl)@
	@:@1_op_unary(atan,atan,dbl,dbl)@
	@:@1_op_unary(exp,exp,dbl,dbl)@
	@:@1_op_unary(log,log,dbl,dbl)@
	@:@1_op_unary(log10,log10,dbl,dbl)@

@= cardinal
	@:type_ops(@1,@2)@
	@:arith_ops(@1,@2,@3)@
@
	@:@1_op_binary(<<,bitshl,@2,@2,@2)@
	@:@1_op_binary(>>,bitshr,@2,@2,@2)@
	@:@1_op_binary(&,bitand,@2,@2,@2)@
	@:@1_op_binary(|,bitor,@2,@2,@2)@

@+ Basic Functors
These are defined as macros, since we do not want function calls (brrr!@#..) in our inner loop.

@= def
#undef @1
#define @1@2 @3
@h
#include <gdk.h>
#include <mtime.h>
#include <math.h>

@:def(uchr,, unsigned char)@
@:def(schr,, signed char)@
@:def(usht,, unsigned short)@
@:def(ssht,, signed short)@
@:def(uint,, unsigned int)@
@:def(sint,, signed int)@
@:def(ulng,, unsigned long long)@
@:def(slng,, signed long long)@

@:def(uidx,, size_t)@
@c
#include "x100core.h"
/*
#include "x100_engine.h"
 #include "x100.h"*/

#define RESTRICT
#ifdef RESTRICT
#define __r  __restrict__
#else
#define __r
#endif


@:def(eq, (x, y), ((x) == (y)))@
@:def(ne, (x, y), ((x) != (y)))@
@:def(gt, (x, y), ((x) > (y)))@
@:def(lt, (x, y), ((x) < (y)))@
@:def(ge, (x, y), ((x) >= (y)))@
@:def(le, (x, y), ((x) <= (y)))@
@:def(and, (x, y), ((x) && (y)))@
@:def(or, (x, y), ((x) || (y)))@

@:def(directgrp, (x, y, z), ((x) + (((uidx) (y)) << (z))))@
@:def(not, (x), !(x))@

@:def(mul, (x, y), ((x) * (y)))@
@:def(div, (x, y), ((x) / (y)))@
@:def(sub, (x, y), ((x) - (y)))@
@:def(add, (x, y), ((x) + (y)))@
@:def(neg, (x), (-(x)))@
@:def(inc, (x), (x + 1))@
@:def(dec, (x), (x - 1))@
@:def(bitshl, (x, y), (x) << (y))@
@:def(bitshr, (x, y), (x) >> (y))@
@:def(bitand, (x, y), (x) & (y))@
@:def(bitor, (x, y), (x) | (y))@
@:def(bitxor, (x, y), (x) ^ (y))@
@:def(bitnot, (x), ~(x))@
@:def(sum, (x, y), ((x) + (y)))@
@:def(min, (x, y), ((x) < (y) ? (x) : (y)))@
@:def(max, (x, y), ((x) > (y) ? (x) : (y)))@
@c
size_t
aggr_count_uint_col(size_t n, uint * __r res, uint * __r grp, uint * __r sel)
{
	@:impl(res[grp[i]]++)@
	return 0;
}
static size_t
aggr4_count_uidx_col_multicursor(size_t n, uidx * __r res0, uidx * __r res1, uidx * __r res2, uidx * __r res3, uidx * __r grp, uidx * __r sel)
{
	@:impl4(res0[grp[i]]++, res1[grp[i]]++, res2[grp[i]]++, res3[grp[i]]++)@
	return 0;
}

size_t
aggr4_count_uidx_col(size_t n, uidx * __r res0, uidx * __r grp, uidx * __r memchunk, uidx * __r sel)
{
	uidx m = *memchunk;
	uidx *res1 = res0 + m;
	uidx *res2 = res1 + m;
	uidx *res3 = res2 + m;

	if (n > 0)
		return aggr4_count_uidx_col_multicursor(n, res0, res1, res2, res3, grp, sel);
	/* calculate final result as aggregate over 4 partials */
	for (n = 0; n < m; n++) {
		res0[n] += res1[n] + res2[n] + res3[n];
	}
	return 0;
}

@-
SelectCol can be used to collect the indices of a column with
non-zero result.
@= collectIndex
size_t select__@1_col(size_t n, @1*__r res, @1*__r col1, @1*__r sel) {
	size_t ret = 0;
	@:impl(if (col1[i]) res[ret++] = i)@
	return ret; 
}
@c
@:collectIndex(uint)@
@-

@= indextile
size_t map_indextile_uidx_val_uidx_val_@1_val(size_t n, @1 *res, uidx *Pos, uidx *Mult, @1 *Domain) {
        uidx pos = *Pos, domain = *Domain, mult = *Mult, off = 0;
        if (mult == 1) {
                uidx i = pos % domain;

                while (off+domain-i < n) {
			uidx d = (domain + off) - i; 
			@1 m = i;
                        while(off+4 < d) { /* hand-unroll loop with double increments */
				res[off] = m; res[off+1] = m+1; res[off+2] = m+2; res[off+3] = m+3;
				off += 4; m += 4;
			}
                        while(off < d) res[off++] = m++;
                        i = 0;
                }
                while(off < n) res[off++] = i++;
        } else {
                uidx l = pos / mult, i = pos - mult*l;
                @1 k = l % domain;
                while (off+mult-i < n) {
                        while(i++ < mult) res[off++] = k;
                        if (++k == domain) k = 0;
                        i = 0;
                }
                while (off < n) res[off++] = k;
        }
        return off;
}
@c
@:indextile(uidx)@
@:indextile(dbl)@

@:engine(impl)@
@+ Type checking
The x100pure implementation uses its own simplified type checker.
The definitions are collected here to simplify code manipulation to
both V5 and X100pure easier.

/* filtered out */
FcnMap x100_fcnmap[] = {
	{ "uidx", "aggr_count_uidx_col", (ExprFcn) aggr_count_uidx_col, },
	{ "uidx", "aggr4_count_uidx_col", (ExprFcn) aggr4_count_uidx_col, },
	{ "uidx", "select__uint_col,uidx", (ExprFcn) select__uint_col, },
	{ "uidx", "map_indextile_uidx_val_uidx_val_uidx_val",  (ExprFcn) map_indextile_uidx_val_uidx_val_uidx_val, },
	{ "dbl", "map_indextile_uidx_val_uidx_val_dbl_val",  (ExprFcn) map_indextile_uidx_val_uidx_val_dbl_val, },
	@:engine(decl)@
	NULL, NULL,
};

@= decl_op_unary
	{ "@4", "map_@1_@3_col", (ExprFcn) map_@2_@3_col, },
	{ "@4", "map_@1_@3_val", (ExprFcn) map_@2_@3_val, },

@= decl_castop
	@:decl_op_unary(@1,to@1,@2,@1)@

@= decl_op_binary
	{ "@5", "map_@1_@3_col_@4_col", (ExprFcn) map_@2_@3_col_@4_col, },
	{ "@5", "map_@1_@3_col_@4_val", (ExprFcn) map_@2_@3_col_@4_val, },
	{ "@5", "map_@1_@3_val_@4_col", (ExprFcn) map_@2_@3_val_@4_col, },
	{ "@5", "map_@1_@3_val_@4_val", (ExprFcn) map_@2_@3_val_@4_val, },

@= decl_boolop_binary
	@:decl_op_binary(@1,@2,@3,@4,uidx)@
	{ "uidx", "select_@1_@3_col_@4_col", (ExprFcn) select_@2_@3_col_@4_col, },
	{ "uidx", "select_@1_@3_val_@4_col", (ExprFcn) select_@2_@3_val_@4_col, },
	{ "uidx", "select_@1_@3_col_@4_val", (ExprFcn) select_@2_@3_col_@4_val, },

@= decl_grp
	{ "uidx", "map_directgrp_uidx_col_@1_col_uint_val", (ExprFcn) map_directgrp_uidx_col_@1_col_uint_val, }, 

@= decl_aggrop
	{ "@4", "aggr_@1_@3_col_uidx_col", (ExprFcn) aggr_@1_@3_col_uidx_col, },
	{ "@4", "aggr4_@1_@3_col_uidx_col", (ExprFcn) aggr4_@1_@3_col_uidx_col, },

@= decl_fetchop
/*
	{ "@1", "map_fetch_uidx_col_@1_col", (ExprFcn) map_fetch_uidx_col_@1_col, },
	{ "@1", "map_fetch_dbl_col_@1_col", (ExprFcn) map_fetch_dbl_col_@1_col, },

@= decl_mergesumop
	{ "@4", "aggr_@1_@3_col_uidx_col", (ExprFcn) aggr_@1_@3_col_uidx_col, },

@= decl_sum14op
	{ "@4", "aggr_@1_@3_col_uidx_col", (ExprFcn) aggr_@1_@3_col_uidx_col, },

@+ Macro Implementations

The main loop is explicitly unrolled 8 times, as compiler like this best still.
Normally, the body is the same, but we allow to use 2, 4, or 8 different bodies (e.g. multi-cursor) also.
@= impl
	@:impl2(@1,@1)@
@= impl2
	@:impl4(@1,@2,@1,@2)@
@= impl4
	@:impl8(@1,@2,@3,@4,@1,@2,@3,@4)@
@= impl8
	uidx i=0, j=0; /* >99% of the execution time should be in these 6 lines */
	if (sel) {
		#pragma noprefetch
		for(j=0; j+8 < n; j+= 8){
			i = sel[j+0]; @1; 
			i = sel[j+1]; @2; 
			i = sel[j+2]; @3; 
			i = sel[j+3]; @4; 
			i = sel[j+4]; @1; 
			i = sel[j+5]; @2; 
			i = sel[j+6]; @3; 
			i = sel[j+7]; @4; 
		}
		for(; j<n; j++) { i = sel[j]; @1; }
	} else {
		#pragma noprefetch
		while(i+8 < n){
			@1; i++;
			@2; i++;
			@3; i++;
			@4; i++;
			@1; i++;
			@2; i++;
			@3; i++;
			@4; i++;
		}
		for(; i<n; i++) { @1; }
	}
@= impl1
	uidx i, j; /* >99% of the execution time should be in these 6 lines */
	if (sel) {
		#pragma noprefetch
		for(j=0; j<n; j++) { i = sel[j]; @1; }
	} else {
		#pragma noprefetch
		for(i=0; i<n; i++) { @1; }
	}
@
	@:impl(@1)@
@= impl_op_unary
	size_t map_@2_@3_col(size_t n, @4*__r res, @3*__r col1, uidx*__r sel) {
		@:impl1(res[i] = @2(col1[i]))@
		return n;
	}
	size_t map_@2_@3_val(size_t n, @4*__r res, @3*__r val1) {
  		*res = @2(*val1);
		return 1;
	}
@= impl_castop
	#ifndef to@1
	#define to@1(x) ((@1) (x))
	#endif
	@:impl_op_unary(@1,to@1,@2,@1)@
@= impl_op_binary
	size_t map_@2_@3_col_@4_col(size_t n, @5*__r res, @3*__r col1, @4*__r col2, uidx*__r sel) {
		@:impl1(res[i] = @2(col1[i],col2[i]))@
		return n;
	}
	size_t map_@2_@3_val_@4_col(size_t n, @5*__r res, @3*__r val1, @4*__r col2, uidx*__r sel) {
		@:impl1(res[i] = @2(*val1,col2[i]))@
		return n;
	}
	size_t map_@2_@3_col_@4_val(size_t n, @5*__r res, @3*__r col1, @4*__r val2, uidx*__r sel) {
		@:impl1(res[i] = @2(col1[i],*val2))@
		return n;
	}
	size_t map_@2_@3_val_@4_val(size_t n, @5*__r res, @3*__r val1, @4*__r val2) {
		*res = @2(*val1,*val2);
		return 1;
	}
@= impl_boolop_binary
	@:impl_op_binary(@1,@2,@3,@4,uidx)@
	size_t select_@2_@3_col_@4_col(size_t n, uidx*__r res, @3*__r col1, @4*__r col2, uidx*__r sel) {
		size_t ret = 0;
		@:impl(if (@2(col1[i], col2[i])) res[ret++] = i)@
		return ret; 
	}
	size_t select_@2_@3_col_@4_val(size_t n, uidx*__r res, @3*__r col1, @4*__r val2, uidx*__r sel) {
		size_t ret = 0;
		@4 v = *val2;
		@:impl(if (@2(col1[i], v)) res[ret++] = i)@
		return ret; 
	}
	size_t select_@2_@3_val_@4_col(size_t n, uidx*__r res, @3*__r val1, @4*__r col2, uidx*__r sel) {
		size_t ret = 0;
		@3 v = *val1;
		@:impl(if (@2(v, col2[i])) res[ret++] = i)@
		return ret; 
	}
@= impl_grp
	size_t map_directgrp_uidx_col_@1_col_uint_val(size_t n, uidx*__r res, uidx*__r col1, @1*__r col2, uint*__r  val3, uidx*__r  sel) {
		int sh = *val3;
		@:impl1(res[i] = directgrp(col1[i], col2[i], sh))@
		return n; 
	}
@= impl_aggrop
	size_t aggr_@1_@3_col_uidx_col(size_t n, @4*__r res, @3*__r  col1, uidx*__r  grp, uidx*__r  sel) {
		@:impl1(res[grp[i]] = @1(res[grp[i]],col1[i]))@
		return 0;
	}
	static size_t aggr4_@1_@3_col_uidx_col_multicursor(size_t n, @4*__r res0, @4*__r  res1, @4*__r  res2, @4*__r  res3, @3*__r  col1, uidx*__r  grp, uidx*__r  sel) {
		@:impl4(res0[grp[i]] = @1(res0[grp[i]],col1[i]), res1[grp[i]] = @1(res1[grp[i]],col1[i]), res2[grp[i]] = @1(res2[grp[i]],col1[i]), res3[grp[i]] = @1(res3[grp[i]],col1[i]))@
		return 0;
	}
	size_t aggr4_@1_@3_col_uidx_col(size_t n, @4*__r res0, @3*__r col1, uidx*__r grp, uidx*__r memchunk, uidx*__r sel) {
		uidx m = *memchunk;
		@4* res1 = res0 + m;
		@4* res2 = res1 + m;
		@4* res3 = res2 + m;
		if (n > 0) return aggr4_@1_@3_col_uidx_col_multicursor(n, res0, res1, res2, res3, col1, grp, sel);
		/* calculate final result as aggregate over 4 partials */
		for(n=0; n<m; n++) {
			res0[n] = @2(@2(@2(res0[n],res1[n]),res2[n]),res3[n]);
		} 
		return 0;
	}
@= impl_fetchBase
	size_t map_fetch_@1_col_@2_col(size_t n, @2*__r res, @1*__r col1, @2*__r val2, uidx*__r sel) {
		@:impl1(res[i] = val2[(uidx) col1[i]])@
		return 0;
	}
@= impl_fetchop
	@:impl_fetchBase(dbl,@1)@
	@:impl_fetchBase(uidx,@1)@

@- Experimental Code (turned off)
@
; printf("%lu %d\n", (long) val2, col1[i]))
@= group_op
	gid = grp[i]; 			
	if (gid != cgid){	
		res[cgid] += cur;  	
		cur = 0;		
	}
	cgid = gid;
	cur += col1[i];

@= impl_mergesumop
	size_t aggr_@1_@3_col_uidx_col(size_t n, @4*__r  res, @3*__r  col1, uidx*__r  grp, uidx*__r  sel) {
	uidx i = 0, j = 0; /* >99% of the execution time should be in these 6 lines */
	if (n==0) return n;
	if (sel) {
		uidx gid, cgid = grp[sel[0]];
		@3 cur = col1[sel[0]];
		j = 1;
		#pragma noprefetch
		while(j+8 < n){
			i = sel[j]; @:group_op@
			i = sel[j+1]; @:group_op@
			i = sel[j+2]; @:group_op@
			i = sel[j+3]; @:group_op@
			i = sel[j+4]; @:group_op@
			i = sel[j+5]; @:group_op@
			i = sel[j+6]; @:group_op@
			i = sel[j+7]; @:group_op@
			j += 8;
		}
		for(; j<n; j++) { i = sel[j]; @:group_op@ }
		res[cgid] += cur;  	
	} else {
		uidx gid, cgid = grp[0];
		@3 cur = col1[0];
		i = 1;
		#pragma noprefetch
		for(; i+8 < n;){
			@:group_op@ i++;
			@:group_op@ i++;
			@:group_op@ i++;
			@:group_op@ i++;
			@:group_op@ i++;
			@:group_op@ i++;
			@:group_op@ i++;
			@:group_op@ i++;
		}
		for(; i<n; i++) { @:group_op@ }
		res[cgid] += cur;  	
	}
	return 0;
	}
@= impl_sum14op
	size_t aggr_@1_@3_col_uidx_col(size_t n, @4*__r  res, @3*__r  col1, uidx*__r  grp, uidx*__r  sel) {
	uidx i = 0, j = 0; /* >99% of the execution time should be in these 6 lines */
	if (n==0) return n;
	if (sel) {
		@4 cur = 0;
		#pragma noprefetch
		for(j=0; j+14 < n; j+= 14){
			i = sel[j]; cur += col1[i];
			i = sel[j+1]; cur += col1[i];
			i = sel[j+2]; cur += col1[i];
			i = sel[j+3]; cur += col1[i];
			i = sel[j+4]; cur += col1[i];
			i = sel[j+5]; cur += col1[i];
			i = sel[j+6]; cur += col1[i];
			i = sel[j+7]; cur += col1[i];
			i = sel[j+8]; cur += col1[i];
			i = sel[j+9]; cur += col1[i];
			i = sel[j+10]; cur += col1[i];
			i = sel[j+11]; cur += col1[i];
			i = sel[j+12]; cur += col1[i];
			i = sel[j+13]; cur += col1[i];
			res[grp[i]] = cur;
			cur = 0;
		}
	} else {
		#pragma noprefetch
		for(i=0; i+14 < n; i += 14){
			@4 cur = 0;
			for(j=0;j<7;j++){
				cur += col1[i+j] + col1[i+j+7];
			}
			res[grp[i]] = cur;
		}
	}
	return 0;
	}

@+ MAL wrapper implementation 
The wrapper implementation is set up to minimize impact on the x100 engine
code structure. A more tight coupling would be possible, but not sensibly at
this stage of the game.

@c
str
CMDx100new(MalBlkPtr m, MalStkPtr s, InstrPtr p)
{
	int ht = TYPE_void, tt, cap = 0;
	int *res;

	tt = getArgType(m, p, 1);
	if (p->argc > 2)
		cap = *(int *) getArgReference(s, p, 2);
	res = (int *) getArgReference(s, p, 0);

	return (str) CMDnewBat2(res, &ht, &tt, &cap);
}

@-
The arguments to the wrapper are BAT identifiers, which should be translated
into the start of a vector. Note that this code base assumes that all
vector limits are properly set and maintained.

@= getBATdescriptor
        if( BBPcheck(*@2,"@4")==0)
                return throwMessage("x100.@4", "cannot access bat @2 in bbp");
        @3= (BAT*) BBPgetdesc(*@2);
        if( @3 == NULL) { *@1 = 0;
                return throwMessage("x100.@4", "cannot access descriptor @2");
        }
        if( *@2 <0){ /* BAT reverse */ @3 = BATmirror(@3); }

@c
#include "mal_function.h"

str
aggr_count_uint_col_sel_wrap(int *ret, int *resBid, int *grpBid, int *selBid, lng *N)
{
	BAT *resBat, *grpBat, *selBat;
	ptr resStart, grpStart, selStart;

	@:getBATdescriptor(ret, resBid, resBat, aggr_count_uid_col)@
	@:getBATdescriptor(ret, grpBid, grpBat, aggr_count_uid_col)@
	if (*selBid) {
		@:getBATdescriptor(ret, selBid, selBat, aggr_count_uid_col)@
		selStart = BUNtloc(selBat, BUNfirst(selBat));
	} else
		selStart = 0;

	resStart = BUNtloc(resBat, BUNfirst(resBat));
	grpStart = BUNtloc(grpBat, BUNfirst(grpBat));

	if (aggr_count_uint_col(*N, resStart, grpStart, selStart))
		return throwMessage("x100", "aggr_count_uint_col error\n");
	return MAL_SUCCEED;
}

str
aggr_count_uint_col_wrap(int *ret, int *resBid, int *grpBid, lng *N)
{
	int selBid = 0;

	return aggr_count_uint_col_sel_wrap(ret, resBid, grpBid, &selBid, N);
}

str
aggr_count_uint_col_default_wrap(int *ret, int *resBid, int *grpBid)
{
	int selBid = 0;
	BAT *grpBat;
	lng N = 0;

	@:getBATdescriptor(ret, grpBid, grpBat, aggr_count_uid_col)@
	N = BATcount(grpBat);
	return aggr_count_uint_col_sel_wrap(ret, resBid, grpBid, &selBid, &N);
}

str
aggr_count_uint_col_sel_default_wrap(int *ret, int *resBid, int *grpBid, int *selBid)
{
	lng N = 0;
	BAT *grpBat;

	@:getBATdescriptor(ret, grpBid, grpBat, aggr_count_uid_col)@
	N = BATcount(grpBat);
	return aggr_count_uint_col_sel_wrap(ret, resBid, grpBid, selBid, &N);
}

@-
The collect indices operator.
@= filter
if( *selBid){
	@:getBATdescriptor(ret,selBid,selBat,@1)@
	selStart= BUNtloc(selBat, BUNfirst(selBat));
} else selStart= 0;
@c
str
collect_uint_col_sel_wrap(lng *ret, int *resBid, int *colBid, int *selBid, lng *N)
{
	BAT *resBat, *colBat, *selBat;
	ptr resStart, colStart, selStart;

	@:getBATdescriptor(ret, resBid, resBat, aggr_count_uid_col)@
	@:getBATdescriptor(ret, colBid, colBat, aggr_count_uid_col)@
	@:filter(aggr_count_uid_col)@

	resStart = BUNtloc(resBat, BUNfirst(resBat));
	colStart = BUNtloc(colBat, BUNfirst(colBat));

	*ret = select__uint_col(*N, resStart, colStart, selStart);
	return MAL_SUCCEED;
}

str
collect_uint_col_default_wrap(lng *ret, int *resBid, int *colBid)
{
	int selBid = 0;
	lng N;
	BAT *colBat;

	@:getBATdescriptor(ret, colBid, colBat, aggr_count_uid_col)@
	N = BATcount(colBat);
	collect_uint_col_sel_wrap(ret, resBid, colBid, &selBid, &N);
	return MAL_SUCCEED;
}

str
collect_uint_col_wrap(lng *ret, int *resBid, int *colBid, lng *N)
{
	int selBid = 0;

	collect_uint_col_sel_wrap(ret, resBid, colBid, &selBid, N);
	return MAL_SUCCEED;
}

@-
The binary operator group
@= selectOperation
str select_@1_@2_col_@2_col_sel_wrap(lng *ret, int *resBid, int *colBid, int * valBid, int *selBid, lng *N){

	BAT *resBat, *colBat, *valBat, *selBat;
	ptr resStart, colStart, valStart, selStart;

	@:getBATdescriptor(ret,resBid,resBat,x100.@3)@
	@:getBATdescriptor(ret,colBid,colBat,x100.@3)@
	@:getBATdescriptor(ret,valBid,valBat,x100.@3)@
	@:filter(x100.@3)@

	resStart= BUNtloc(resBat, BUNfirst(resBat));
	colStart= BUNtloc(colBat, BUNfirst(colBat));
	valStart= BUNtloc(valBat, BUNfirst(valBat));
	*ret= select_@1_@2_col_@2_col(*N, resStart, colStart, valStart, selStart);

	return MAL_SUCCEED;
}
str select_@1_@2_col_@2_col_wrap(lng *ret, int *resBid, int *colBid, int * valBid, lng *N){
	int selBid =0;
	return select_@1_@2_col_@2_col_sel_wrap(ret,resBid, 
				colBid, valBid,&selBid,N);
}
str select_@1_@2_col_@2_val_sel_wrap(lng *ret, int *resBid, int *colBid, @2 * val, int *selBid, lng *N){

	BAT *resBat, *colBat, *selBat;
	ptr resStart, colStart, selStart;

	@:getBATdescriptor(ret,resBid,resBat,x100.@3)@
	@:getBATdescriptor(ret,colBid,colBat,x100.@3)@
	@:filter(x100.@3)@

	resStart= BUNtloc(resBat, BUNfirst(resBat));
	colStart= BUNtloc(colBat, BUNfirst(colBat));
	*ret= select_@1_@2_col_@2_val(*N, resStart, colStart, val, selStart);
	BATtopN(resBat,*ret);

	return MAL_SUCCEED;
}
str select_@1_@2_col_@2_val_wrap(lng *ret, int *resBid, int *colBid, @2 * val, lng *N){
	int selBid=0;
	return select_@1_@2_col_@2_val_sel_wrap(ret,resBid,colBid,val,&selBid,N);
}
@c
@:selectOperation(le, uint, <=)@
@:selectOperation(ge, uint, >=)@
@:selectOperation(lt, uint, <)@
@:selectOperation(gt, uint, >)@
@:selectOperation(eq, uint, ==)@
@:selectOperation(ne, uint, !=)@

@:selectOperation(le, flt, <=)@
@:selectOperation(ge, flt, >=)@
@:selectOperation(lt, flt, <)@
@:selectOperation(gt, flt, >)@
@:selectOperation(le, dbl, <=)@
@:selectOperation(ge, dbl, >=)@
@:selectOperation(lt, dbl, <)@
@:selectOperation(gt, dbl, >)@

@-
Most of the operators we have to deal with are arithmetic once.
@= mapBinaryOperator
str map_@2_@3_col_@4_col_sel_wrap(lng *ret, int *resBid, int *col1Bid, int *col2Bid, int *selBid, lng *N){
	BAT *resBat, *col1Bat, *col2Bat, *selBat;
	ptr resStart, col1Start, col2Start, selStart;

	@:getBATdescriptor(ret,resBid,resBat,x100.@1)@
	@:getBATdescriptor(ret,col1Bid,col1Bat,x100.@1)@
	@:getBATdescriptor(ret,col2Bid,col2Bat,x100.@1)@
	@:filter(x100.@1)@

	resStart= BUNtloc(resBat, BUNfirst(resBat));
	col1Start= BUNtloc(col1Bat, BUNfirst(col1Bat));
	col2Start= BUNtloc(col2Bat, BUNfirst(col2Bat));
	*ret= map_@2_@3_col_@4_col(*N, resStart, col1Start, col2Start, selStart);
	return MAL_SUCCEED;
}
str map_@2_@3_col_@4_col_wrap(lng *ret, int *resBid, int *col1Bid, int *col2Bid, lng *N){
	int selBid=0;
	return map_@2_@3_col_@4_col_sel_wrap(ret,resBid,col1Bid,col2Bid,&selBid,N);
}
str map_@2_@3_val_@4_val_wrap(lng *ret, @3 *resStart, @3 *col1Start, @3 *col2Start){
	lng N;
	map_@2_@3_val_@4_val(N,resStart,col1Start,col2Start);
	return MAL_SUCCEED;
}
str map_@2_@3_wrap(@3 *ret, @3 *lhs, @3 *rhs){
	*ret = *lhs @1 *rhs;
	return MAL_SUCCEED;
}
@= mapUnaryOperator
str map_@2_@3_col_sel_wrap(lng *ret, int *resBid, int *col1Bid, int *selBid, lng *N){
	BAT *resBat, *col1Bat, *selBat;
	ptr resStart, col1Start, selStart;

	@:getBATdescriptor(ret,resBid,resBat,x100.@1)@
	@:getBATdescriptor(ret,col1Bid,col1Bat,x100.@1)@
	@:filter(x100.@1)@

	resStart= BUNtloc(resBat, BUNfirst(resBat));
	col1Start= BUNtloc(col1Bat, BUNfirst(col1Bat));
	*ret= map_@2_@3_col(*N, resStart, col1Start, selStart);
	return MAL_SUCCEED;
}
str map_@2_@3_col_wrap(lng *ret, int *resBid, int *col1Bid, lng *N){
	int selBid=0;
	return map_@2_@3_col_sel_wrap(ret,resBid,col1Bid,&selBid,N);
}

str map_@2_@3_val_sel_wrap(lng *ret, int *resBid, int *val, int *selBid, lng *N){
	BAT *resBat, *selBat;
	ptr resStart, selStart;

	@:getBATdescriptor(ret,resBid,resBat,x100.@1)@
	@:filter(x100.@1)@

	resStart= BUNtloc(resBat, BUNfirst(resBat));
	*ret= map_@2_@3_col(*N, resStart, val, selStart);
	return MAL_SUCCEED;
}
str map_@2_@3_val_wrap(lng *ret, int *resBid, int *val, lng *N){
	int selBid=0;
	return map_@2_@3_val_sel_wrap(ret,resBid,val,&selBid,N);
}
@c
@:mapBinaryOperator(+, add, uint, uint)@
@:mapBinaryOperator(-, sub, uint, uint)@
@:mapBinaryOperator(/, div, uint, uint)@
@:mapBinaryOperator(*, mul, uint, uint)@
@:mapUnaryOperator(-, neg, uint)@
@:mapUnaryOperator(touchr, touchr, uint)@

@-
The fetch operators.
@= fetchOperation
str map_fetch_@1_col_@2_col_sel_wrap(lng *ret, int *resBid, int *col1Bid, int *col2Bid, int *selBid, int *N){
	BAT *resBat, *col1Bat, *col2Bat, *selBat;
	ptr resStart, col1Start, col2Start, selStart;

	@:getBATdescriptor(ret,resBid,resBat,x100.fetch)@
	@:getBATdescriptor(ret,col1Bid,col1Bat,x100.fetch)@
	@:getBATdescriptor(ret,col2Bid,col2Bat,x100.fetch)@
	@:filter(x100.fetch)@

	resStart= BUNtloc(resBat, BUNfirst(resBat));
	col1Start= BUNtloc(col1Bat, BUNfirst(col1Bat));
	col2Start= BUNtloc(col2Bat, BUNfirst(col2Bat));
	map_fetch_@1_col_@2_col(*N, resStart, col1Start, col2Start, selStart);
	return MAL_SUCCEED;
}
str map_fetch_@1_col_@2_col_wrap(lng *ret, int *resBid, int *col1Bid, int *col2Bid, int *N){
	int selBid=0;
	return map_fetch_@1_col_@2_col_sel_wrap(ret,resBid,col1Bid,col2Bid,&selBid,N);
}
@c
@:fetchOperation(dbl, uidx)@
@:fetchOperation(dbl, dbl)@

@:fetchOperation(uidx, uidx)@
@:fetchOperation(uidx, dbl)@

@-
Aggregation in the x100 setup is always organized by groups.
@= aggrOperation
str aggr_@1_@3_col_uidx_col_sel_wrap(int *ret, int *resBid, int *col1Bid, uidx *grpBid, uidx *selBid, lng *N){
	BAT *resBat, *col1Bat, *grpBat, *selBat;
	ptr resStart, col1Start, grpStart, selStart;

	@:getBATdescriptor(ret,resBid,resBat,x100.@1)@
	@:getBATdescriptor(ret,col1Bid,col1Bat,x100.@1)@
	@:getBATdescriptor(ret,grpBid,grpBat,x100.@1)@
	@:filter(x100.@1)@

	resStart= BUNtloc(resBat, BUNfirst(resBat));
	col1Start= BUNtloc(col1Bat, BUNfirst(col1Bat));
	grpStart= BUNtloc(grpBat, BUNfirst(grpBat));
	aggr_@1_@3_col_uidx_col(*N, resStart, col1Start, grpStart, selStart);
	return MAL_SUCCEED;
}
str aggr_@1_@3_col_uidx_col_wrap(int *ret, int *resBid, int *col1Bid, uidx *grpBid, lng *N){
int selBid=0;
	return aggr_@1_@3_col_uidx_col_sel_wrap(ret,resBid,col1Bid,grpBid,&selBid,N);
}
str aggr_@1_@3_col_wrap(@3 *ret, int *colBid){
	BAT *colBat;
	int max;
	@:getBATdescriptor(ret,colBid,colBat,x100.@1)@
	if( colBat) {
		BAT@1(colBat, &max);
		*ret = max;
	} else return throwMessage("x100.max","could not find BAT.");
	return MAL_SUCCEED;
}
@c
@:aggrOperation(max, max, uint)@
@:aggrOperation(min, min, uint)@
@- directGrp
str map_directgrp_@1_col_@2_col_@3_val_sel_wrap(int *ret,
		int *resBid, int *col1Bid, 
		int *col2Bid, int *valBid, int *selBid, int *N) {
	BAT *resBat, *col1Bat, *col2Bat, *valBat, *selBat;
	ptr resStart, col1Start, col2Start, valStart, selStart;

	@:getBATdescriptor(ret,resBid,resBat,x100.directgrp)@
	@:getBATdescriptor(ret,col1Bid,col1Bat,x100.directgrp)@
	@:getBATdescriptor(ret,col2Bid,col2Bat,x100.directgrp)@
	@:getBATdescriptor(ret,valBid,valBat,x100.directgrp)@
	@:filter(x100.directgrp)@

	resStart= BUNtloc(resBat, BUNfirst(resBat));
	col1Start= BUNtloc(col1Bat, BUNfirst(col1Bat));
	valStart= BUNtloc(valBat, BUNfirst(valBat));
	map_directgrp_@1_col_@2_col_@3_val(*N, resStart, col1Start, 
				col2Start, valStart, selStart);
	return MAL_SUCCEED;
}
str map_directgrp_@1_col_@2_col_@3_val_wrap(
		int *ret, int *resBid, int *col1Bid, 
		int *col2Bid, int *valBid, int *N) {
	int selBid=0;
	return map_directgrp_@1_col_@2_col_@3_val_sel_wrap(
		ret, resBid, col1Bid, col2Bid, valBid, &selBid,N);
}
@c
@:directGrp(uidx, uchr, uint)@

@-
@= aggr4_count
str aggr4_count_uidx_col_multicursor_sel_wrap(int *ret,
		int *res0Bid, int *res1Bid,  int *res2Bid, int *res3Bid,
		int *grpBid, int *selBid, int *N) {
	BAT *res0Bat, *res1Bat, *res2Bat, *res3Bat, *grpBat, *selBat;
	ptr res0Start, res1Start, res2Start, res3Start,grpStart, selStart;

	@:getBATdescriptor(ret,res0Bid,res0Bat,x100.aggr4_count)@
	@:getBATdescriptor(ret,res1Bid,res1Bat,x100.aggr4_count)@
	@:getBATdescriptor(ret,res2Bid,res2Bat,x100.aggr4_count)@
	@:getBATdescriptor(ret,res3Bid,res3Bat,x100.aggr4_count)@
	@:getBATdescriptor(ret,grpBid,grpBat,x100.aggr4_count)@
	@:filter(x100.aggr4_count)@

	res0Start= BUNtloc(res0Bat, BUNfirst(res0Bat));
	res1Start= BUNtloc(res1Bat, BUNfirst(res1Bat));
	res2Start= BUNtloc(res2Bat, BUNfirst(res2Bat));
	res3Start= BUNtloc(res3Bat, BUNfirst(res3Bat));
	grpStart= BUNtloc(grpBat, BUNfirst(grpBat));

	aggr4_count_uidx_col_multicursor(*N, res0Start, res1Start, 
			res2Start, res3Start, grpStart, selStart);
	return MAL_SUCCEED;
}
str aggr4_count_uidx_col_multicursor_wrap(int *ret,
		int *res0Bid, int *res1Bid,  int *res2Bid, int *res3Bid,
		int *grpBid, int *N) {
	int selBid=0;
	return aggr4_count_uidx_col_multicursor_sel_wrap(
		ret, res0Bid, res1Bid, res2Bid, res3Bid, grpBid, &selBid, N);
}
str aggr4_count_uidx_col_sel_wrap(int *ret, int *res0Bid, 
		int *grpBid, int *memBid, int *selBid, int *N) {
	BAT *res0Bat, *memBat, *grpBat, *selBat;
	ptr res0Start, memStart,grpStart, selStart;

	@:getBATdescriptor(ret,res0Bid,res0Bat,x100.aggr4_count)@
	@:getBATdescriptor(ret,memBid,memBat,x100.aggr4_count)@
	@:getBATdescriptor(ret,grpBid,grpBat,x100.aggr4_count)@
	@:filter(x100.aggr4_count)@

	res0Start= BUNtloc(res0Bat, BUNfirst(res0Bat));
	memStart= BUNtloc(memBat, BUNfirst(memBat));
	grpStart= BUNtloc(grpBat, BUNfirst(grpBat));

	aggr4_count_uidx_col(*N, res0Start, grpStart, memStart, selStart);
	return MAL_SUCCEED;
}
str aggr4_count_uidx_col_wrap(int *ret, int *res0Bid, 
		int *grpBid, int *memBid, int *N) {
	int selBid=0;
	return aggr4_count_uidx_col_sel_wrap(
		ret, res0Bid, grpBid, memBid, &selBid, N);
}
@c
@:aggr4_count@
@- 
Casting ordinary types into the x100 types.
@c

@= castImpl
str cast_@1_@2(@2 *res, @1 *val){
	*res= *val;
	return MAL_SUCCEED;
}
@c
@:castImpl(lng, uidx)@
@:castImpl(int, uidx)@
@:castImpl(lng, uint)@
@:castImpl(int, uint)@
@:castImpl(uidx, lng)@
@:castImpl(uidx, int)@
@:castImpl(uint, lng)@
@:castImpl(uint, int)@
