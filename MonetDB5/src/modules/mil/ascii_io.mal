# Monet Mil to Mal compiler
# Copyright (c) 2001-2004, CWI. All rights reserved.

# Predefined code segment
#The compiler can not guarantee an accurate compilation,
#because MIL unlike MAL is a dynamically typed language.
#A few guidelines to maximize usefullness.
#- make the type of variables explicit, in particular 'nil'
#- upon advice of M2m to remap identifiers, change it in your program directly
function load_format(fmt:str):bat[:str,:bat];
#	var names := new(void,str); names.seqbase(oid(0));
	names := new(:void,:str);
	aa_a := oid(0);
	ba_a := bat.setSequenceBase(names,aa_a);
#	var seps := new(void,str); seps.seqbase(oid(0));
	seps := new(:void,:str);
	ca_a := oid(0);
	da_a := bat.setSequenceBase(seps,ca_a);
#	var types := new(void,str); types.seqbase(oid(0));
	types := new(:void,:str);
	ea_a := oid(0);
	fa_a := bat.setSequenceBase(types,ea_a);
#	names.insert(nil,"names");seps.insert(nil,",");types.insert(nil,"str");
	ga_a := insert(names,nil,"names");
	ha_a := insert(seps,nil,",");
	ia_a := insert(types,nil,"str");
#	names.insert(nil,"seps");seps.insert(nil,",");types.insert(nil,"str");
	ja_a := insert(names,nil,"seps");
	ka_a := insert(seps,nil,",");
	la_a := insert(types,nil,"str");
#	names.insert(nil,"types");seps.insert(nil,"\n");types.insert(nil,"str");
	ma_a := insert(names,nil,"types");
	na_a := insert(seps,nil,"\n");
	oa_a := insert(types,nil,"str");
#	return load(names, seps, types, fmt, 1000);
	return pa_a :=load(names,seps,types,fmt,1000);
end load_format;
function load_data(fmt:bat[:str,:bat], data:str, nr:int):bat[:str,:bat];
#	var names := fmt.find("names");
	names := find(fmt,"names");
#	var seps := fmt.find("seps");
	seps := find(fmt,"seps");
#	var types := fmt.find("types");
	types := find(fmt,"types");
#	return load(names, seps, types, data, nr);
	return qa_a :=load(names,seps,types,data,nr);
end load_data;
function make_persistent(bats:bat[:str,:bat]):void;
#	if (bats.exist("key")){
barrier	ra_a := exist(bats,"key");
#		var keybat := bats.find("key");
	keybat := find(bats,"key");
#		var nbats := bats.diff(bats.reverse.select("key").reverse);
	sa_a := reverse(bats);
	ta_a := select(sa_a,"key");
	ua_a := reverse(ta_a);
	nbats := diff(bats,ua_a);
#		nbats@batloop(){
barrier	va_a := bunStream(nbats,va_aH,va_aT);
#			var b := keybat.reverse().join($t);
	wa_a := reverse(keybat,);
	b := join(wa_a,va_aT);
#			b.rename($h);
	xa_a := bat.setName(b,va_aH);
#			b.persists(true);
	ya_a := persists(b,true);
#			if (b.count() > 1000000) {
	ab_a := count(b,);
barrier	bb_a := >(ab_a,1000000);
#				b.mmap(STORE_MMAP);
	STORE_MMAP := mil.take(STORE_MMAP);
	cb_a := mmap(b,STORE_MMAP);
exit	bb_a;
redo	va_a;
exit	va_a;
exit	ra_a;
#	} else {
barrier	db_a := not(ra_a);
#		bats@batloop(){
barrier	eb_a := bunStream(bats,eb_aH,eb_aT);
#			$t.rename($h);
	fb_a := bat.setName(eb_aT,eb_aH);
#			$t.persists(true);
	gb_a := persists(eb_aT,true);
#			if ($t.count() > 1000000) {
	hb_a := count(eb_aT,);
barrier	ib_a := >(hb_a,1000000);
#				$t.mmap(STORE_MMAP);
	jb_a := mmap(eb_aT,STORE_MMAP);
exit	ib_a;
redo	eb_a;
exit	eb_a;
exit	db_a;
end make_persistent;
function merge_data(bats:bat[:str,:bat]):void;
#	if (bats.exist("key")){
barrier	kb_a := exist(bats,"key");
#		var keybat := bats.find("key");
	keybat := find(bats,"key");
#		var nbats := bats.diff(bats.reverse.select("key").reverse);
	lb_a := reverse(bats);
	mb_a := select(lb_a,"key");
	nb_a := reverse(mb_a);
	nbats := diff(bats,nb_a);
#		nbats@batloop(){
barrier	ob_a := bunStream(nbats,ob_aH,ob_aT);
#			var b := keybat.reverse().join($t);
	pb_a := reverse(keybat,);
	b := join(pb_a,ob_aT);
#			var o := bat($h);
	o := bat(ob_aH);
#			o.insert(b);
	qb_a := insert(o,b);
redo	ob_a;
exit	ob_a;
exit	kb_a;
#	} else {
barrier	rb_a := not(kb_a);
#		bats@batloop(){
barrier	sb_a := bunStream(bats,sb_aH,sb_aT);
#			var o := bat($h);
	o := bat(sb_aH);
#			o.insert($t);
	tb_a := insert(o,sb_aT);
redo	sb_a;
exit	sb_a;
exit	rb_a;
end merge_data;
function dump_seps(bats:bat[:void,:bat]):bat[:void,:str];
#	var seps := new(void,str); seps.seqbase(oid(0));
	seps := new(:void,:str);
	ub_a := oid(0);
	vb_a := bat.setSequenceBase(seps,ub_a);
#	var id := 0;
	id := 0;
#	var cnt := bats.count - 1;
	wb_a := count(bats);
	cnt := -(wb_a,1);
#	bats@batloop(){
barrier	xb_a := bunStream(bats,xb_aH,xb_aT);
#		if (id != cnt) {
barrier	yb_a := !=(id,cnt);
#			seps.insert(nil,",");
	ac_a := insert(seps,nil,",");
exit	yb_a;
#		} else {
barrier	bc_a := not(yb_a);
#			seps.insert(nil,"\n");
	cc_a := insert(seps,nil,"\n");
exit	bc_a;
redo	xb_a;
exit	xb_a;
#	return seps;
	return dc_a :=seps;
end dump_seps;
function bat_ttype(b:bat[:any,:any]):str;
#	return monet_atomtbl.reverse.find(b.ttype);
	monet_atomtbl := mil.take(monet_atomtbl);
	ec_a := getTailType(b);
	fc_a := reverse(monet_atomtbl);
	return gc_a :=find(fc_a,ec_a);
end bat_ttype;
function dump_format(bats:bat[:void,:bat], fmt:str):bat[:str,:bat];
#	bats := [~bats].seqbase(oid(0));
	hc_a := 0@0:oid;
	ic_a := zipper(hc_a,bats);
	jc_a := oid(0);
	bats := bat.setSequenceBase(ic_a,jc_a);
#	var names := [bbpname](bats);
	names := multiplex.tactics("getName",bats);
#	var seps  := dump_seps(bats);
	seps := dump_seps(bats);
#	var types := [bat_ttype](bats);
	types := multiplex.tactics("bat_ttype",bats);
#	var fmtbats:= new(void,bat); fmtbats.seqbase(oid(0));
	fmtbats := new(:void,:bat[:any,:any]);
	kc_a := oid(0);
	lc_a := bat.setSequenceBase(fmtbats,kc_a);
#	fmtbats.insert(nil,names);
	mc_a := insert(fmtbats,nil,names);
#	fmtbats.insert(nil,seps);
	nc_a := insert(fmtbats,nil,seps);
#	fmtbats.insert(nil,types);
	oc_a := insert(fmtbats,nil,types);
#	var nms := new(void,str); nms.seqbase(oid(0));
	nms := new(:void,:str);
	pc_a := oid(0);
	qc_a := bat.setSequenceBase(nms,pc_a);
#	seps := new(void,str); seps.seqbase(oid(0));
	seps := new(:void,:str);
	rc_a := oid(0);
	sc_a := bat.setSequenceBase(seps,rc_a);
#	nms.insert(nil,"names");seps.insert(nil,",");
	tc_a := insert(nms,nil,"names");
	uc_a := insert(seps,nil,",");
#	nms.insert(nil,"seps");seps.insert(nil,",");
	vc_a := insert(nms,nil,"seps");
	wc_a := insert(seps,nil,",");
#	nms.insert(nil,"types");seps.insert(nil,"\n");
	xc_a := insert(nms,nil,"types");
	yc_a := insert(seps,nil,"\n");
#	dump(nms, seps, fmtbats, fmt, 1000);
	ad_a := dump(nms,seps,fmtbats,fmt,1000);
#	nms.insert(nil,"bats"); 
	bd_a := insert(nms,nil,"bats");
#	fmtbats.insert(nil,bats);
	cd_a := insert(fmtbats,nil,bats);
#	return nms.reverse.join(fmtbats);
	dd_a := reverse(nms);
	return ed_a :=join(dd_a,fmtbats);
end dump_format;
function dump_data(fmt:bat[:str,:bat], data:str, cnt:int):void;
#	var names := fmt.find("names");
	names := find(fmt,"names");
#	var seps := fmt.find("seps");
	seps := find(fmt,"seps");
#	if (fmt.exist("bats")){
barrier	fd_a := exist(fmt,"bats");
#		bats := fmt.find("bats");
	bats := find(fmt,"bats");
exit	fd_a;
#	} else {
barrier	gd_a := not(fd_a);
#		bats := [load](names);
	bats := multiplex.tactics("load",names);
exit	gd_a;
#	dump( names, seps, bats, data, cnt );
	hd_a := dump(names,seps,bats,data,cnt);
end dump_data;
function dump_data(fmt:bat[:str,:bat], bats:bat[:str,:bat], data:str, cnt:int):void;
#	var names := fmt.find("names");
	names := find(fmt,"names");
#	var seps := fmt.find("seps");
	seps := find(fmt,"seps");
#	dump( names, seps, names.join(bats).reverse().mark().reverse(), data, cnt );
	id_a := join(names,bats);
	jd_a := reverse(id_a,);
	kd_a := mark(jd_a,);
	ld_a := reverse(kd_a,);
	md_a := dump(names,seps,ld_a,data,cnt);
end dump_data;
function import(b:bat[:any,:any], filename:str):bat[:any,:any];
#	var names := new(void,str).seqbase(0@0);
	nd_a := new(:void,:str);
	names := bat.setSequenceBase(nd_a,0@0);
#	names.insert(oid(nil),"head");
	od_a := oid(nil);
	pd_a := insert(names,od_a,"head");
#	names.insert(oid(nil),"tail");
	qd_a := oid(nil);
	rd_a := insert(names,qd_a,"tail");
#	var seps := new(void,str).seqbase(0@0);
	sd_a := new(:void,:str);
	seps := bat.setSequenceBase(sd_a,0@0);
#	seps.insert(oid(nil),",");
	td_a := oid(nil);
	ud_a := insert(seps,td_a,",");
#	seps.insert(oid(nil),"\n");
	vd_a := oid(nil);
	wd_a := insert(seps,vd_a,"\n");
#	var types := new(void,str).seqbase(0@0);
	xd_a := new(:void,:str);
	types := bat.setSequenceBase(xd_a,0@0);
#	types.insert(oid(nil),b.reverse.bat_ttype);
	yd_a := oid(nil);
	ae_a := reverse(b);
	be_a := bat_ttype(ae_a);
	ce_a := insert(types,yd_a,be_a);
#	types.insert(oid(nil),b.bat_ttype);
	de_a := oid(nil);
	ee_a := bat_ttype(b);
	fe_a := insert(types,de_a,ee_a);
#	var bats := load( names, seps, types, filename, -1);
	bats := load(names,seps,types,filename,-1);
#	b.insert (bats.find("head").reverse.join(bats.find("tail")));
	ge_a := find(bats,"head");
	he_a := find(bats,"tail");
	ie_a := reverse(ge_a);
	je_a := join(ie_a,he_a);
	ke_a := insert(b,je_a);
#	return b;
	return le_a :=b;
end import;
function export(b:bat[:any,:any], filename:str):void;
#	var hb := b.mark(0@0).reverse;
	me_a := mark(b,0@0);
	hb := reverse(me_a);
#	var tb := b.reverse.mark(0@0).reverse;
	ne_a := reverse(b);
	oe_a := mark(ne_a,0@0);
	tb := reverse(oe_a);
#	var names := new(void,str).seqbase(0@0);
	pe_a := new(:void,:str);
	names := bat.setSequenceBase(pe_a,0@0);
#	names.insert(oid(nil),"head");
	qe_a := oid(nil);
	re_a := insert(names,qe_a,"head");
#	names.insert(oid(nil),"tail");
	se_a := oid(nil);
	te_a := insert(names,se_a,"tail");
#	var seps := new(void,str).seqbase(0@0);
	ue_a := new(:void,:str);
	seps := bat.setSequenceBase(ue_a,0@0);
#	seps.insert(oid(nil),",");
	ve_a := oid(nil);
	we_a := insert(seps,ve_a,",");
#	seps.insert(oid(nil),"\n");
	xe_a := oid(nil);
	ye_a := insert(seps,xe_a,"\n");
#	var bats := new(void,bat).seqbase(0@0);
	af_a := new(:void,:bat[:any,:any]);
	bats := bat.setSequenceBase(af_a,0@0);
#	bats.insert(oid(nil), hb);
	bf_a := oid(nil);
	cf_a := insert(bats,bf_a,hb);
#	bats.insert(oid(nil), tb);
	df_a := oid(nil);
	ef_a := insert(bats,df_a,tb);
#	dump( names, seps, bats, filename, b.count());
	ff_a := count(b,);
	gf_a := dump(names,seps,bats,filename,ff_a);
end export;
#Identifer 'rename' mapped to 'bat.setName'
#Identifer 'seqbase' mapped to 'bat.setSequenceBase'
#Identifer 'bbpname' mapped to 'getName'
#Identifer 'ttype' mapped to 'getTailType'
