# This version reflects changes needed by MIL5 
proc load_format( str fmt ) : BAT[str,BAT] := {
	var names := new(void,str); names.seqbase(oid(0));
	var seps := new(void,str); seps.seqbase(oid(0));
	var types := new(void,str); types.seqbase(oid(0));
	names.insert(nil,"names");seps.insert(nil,",");types.insert(nil,"str");
	names.insert(nil,"seps");seps.insert(nil,",");types.insert(nil,"str");
	names.insert(nil,"types");seps.insert(nil,"\n");types.insert(nil,"str");
	return load(names, seps, types, fmt, 1000);
}

proc load_data( BAT[str,BAT] fmt, str data, int nr ) : BAT[str,BAT] := {
	var names := fmt.find("names");
	var seps := fmt.find("seps");
	var types := fmt.find("types");
	return load(names, seps, types, data, nr);
}

proc make_persistent( BAT[str,BAT] bats ) := {
	if (bats.exist("key")){
		var keybat := bats.find("key");
		var nbats := bats.diff(bats.reverse.select("key").reverse);
		nbats@batloop(){
			var b := keybat.reverse().join($t);
			b.rename($h);
			b.persists(true);
			if (b.count() > 1000000) {
				b.mmap(STORE_MMAP);
			}
		}
	} else {
		bats@batloop(){
			$t.rename($h);
			$t.persists(true);
			if ($t.count() > 1000000) {
				$t.mmap(STORE_MMAP);
			}
		}
	}
}

proc merge_data( BAT[str,BAT] bats ) := {
	if (bats.exist("key")){
		var keybat := bats.find("key");
		var nbats := bats.diff(bats.reverse.select("key").reverse);
		nbats@batloop(){
			var b := keybat.reverse().join($t);
			var o := bat($h);
			o.insert(b);
		}
	} else {
		bats@batloop(){
			var o := bat($h);
			o.insert($t);
		}
	}
}

proc dump_seps( BAT[void,BAT] bats ) : BAT[void,str] := {
	var seps := new(void,str); seps.seqbase(oid(0));
	var id := 0;
	var cnt := bats.count - 1;
	bats@batloop(){
		if (id != cnt) {
			seps.insert(nil,",");
		} else {
			seps.insert(nil,"\n");
		}
		id += 1;
	}
	return seps;
}

proc bat_ttype( bat b ) : str := {
	return monet_atomtbl.reverse.find(b.ttype);
}

proc dump_format( BAT[void,BAT] bats, str fmt ) : BAT[str,BAT] := {
	bats := [~bats].seqbase(oid(0));
	var names := [bbpname](bats);
	var seps  := dump_seps(bats);
	var types := [bat_ttype](bats);
	var fmtbats:= new(void,bat); fmtbats.seqbase(oid(0));
	fmtbats.insert(nil,names);
	fmtbats.insert(nil,seps);
	fmtbats.insert(nil,types);

	var nms := new(void,str); nms.seqbase(oid(0));
	seps := new(void,str); seps.seqbase(oid(0));
	nms.insert(nil,"names");seps.insert(nil,",");
	nms.insert(nil,"seps");seps.insert(nil,",");
	nms.insert(nil,"types");seps.insert(nil,"\n");
	dump(nms, seps, fmtbats, fmt, 1000);
	nms.insert(nil,"bats"); 
	fmtbats.insert(nil,bats);
	return nms.reverse.join(fmtbats);
}

proc dump_data( BAT[str,BAT] fmt, str data, int cnt) := {
	var names := fmt.find("names");
	var seps := fmt.find("seps");
	var bats;
	if (fmt.exist("bats")){
		bats := fmt.find("bats");
	} else {
		bats := [load](names);
	}
	dump( names, seps, bats, data, cnt );
}

proc dump_data( BAT[str,BAT] fmt, BAT[str,BAT] bats, str data, int cnt) := {
	var names := fmt.find("names");
	var seps := fmt.find("seps");
	
	dump( names, seps, names.join(bats).reverse().mark().reverse(), data, cnt );
}

proc import( BAT[any,any] b, str filename ) : BAT[any,any] {

	var names := new(void,str).seqbase(0@0);
	names.insert(oid(nil),"head");
	names.insert(oid(nil),"tail");
	var seps := new(void,str).seqbase(0@0);
	seps.insert(oid(nil),",");
	seps.insert(oid(nil),"\n");
	var types := new(void,str).seqbase(0@0);
	types.insert(oid(nil),b.reverse.bat_ttype);
	types.insert(oid(nil),b.bat_ttype);

	var bats := load( names, seps, types, filename, -1);
	b.insert (bats.find("head").reverse.join(bats.find("tail")));
	return b;
}

proc export( BAT[any,any] b, str filename ) {
	var hb := b.mark(0@0).reverse;
	var tb := b.reverse.mark(0@0).reverse;

	var names := new(void,str).seqbase(0@0);
	names.insert(oid(nil),"head");
	names.insert(oid(nil),"tail");
	var seps := new(void,str).seqbase(0@0);
	seps.insert(oid(nil),",");
	seps.insert(oid(nil),"\n");
	var bats := new(void,bat).seqbase(0@0);
	bats.insert(oid(nil), hb);
	bats.insert(oid(nil), tb);

	dump( names, seps, bats, filename, b.count());
}
