@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2005 CWI.
@' All Rights Reserved.

@f mil
@a Martin Kersten
@v 0.1
@* MIL support box
This module implements the links necessary to run
a MIL program against the version 5 kernel.
In particular, this calls for name resolution into
either a global variable, or access to a BAT.
The box contains all constants defined in the original
MIL modules.
@mal
module mil
comment "The mil module provides a box abstraction
	to store for global MIL constants.
	Between sessions the value of the constants 
	is saved on disk in the form of a simple 
	MAL program, which is scanned and made 
	available by opening the box. A future 
	implementation should provide transaction 
	support over the box, which would permit 
	multiple clients to exchange (scalar) 
	information easily.";

pattern open():void
address MILopen
comment "Locate and open the MIL constant box";
pattern close():void
address MILclose
comment "Close the MIL constant box ";
pattern destroy():void
address MILdestroy
comment "Destroy the MIL box";
pattern take(name:str):any 
address MILtake
comment "Locate and take the typed value";
pattern deposit(name:any) :void 		
address MILdeposit
comment "Enter a new value into the box";

pattern releaseAll():void 
address MILreleaseAll
comment "Release all constants";
pattern release(name:any) :void 		
address MILrelease
comment "Release a new constant value";
pattern toString(name:any):str 
address MILtoString
comment "Get the string representation 
	of an element in the box";
pattern discard(name:any) :void 		
address MILdiscard
comment "Release the const from the box";
pattern iterator() (:lng,:str)
address MILnewIterator
comment "Locate next element in the box";
pattern hasMoreElements()(:lng,:str)
address MILhasMoreElements
comment "Locate next element in the box";

pattern prelude():void 
address MILprelude
comment "Initialize the const box";

pattern line(msg:str):void
address MILline
comment "Produce comment for tracking
	the MIL code produced";

include "mil_insert";
include "mil_algebra_procs";
include "mil_system_procs";

mil.prelude();

#theta join operator encoding
EQ :=0;
LT :=-1;
LE :=-2;
GT :=1;
GE :=2;

STORE_MEM :=0;
STORE_MMAP :=1;
STORE_COMPR :=2;

BUF_NORMAL :=0;
BUF_RANDOM :=1;
BUF_SEQUENTIAL :=2;
BUF_WILLNEED :=3;
BUF_DONTNEED :=4;
EBUSY :=16;

BAT_READ   := 1; # allow only read access.
BAT_APPEND := 2; # allow reads and insertions.
BAT_WRITE  := 0; # allow reads, insertions, and updates.

M_E :=2.7182818284590452354LL;
M_LOG2E :=1.4426950408889634074LL;
M_LOG10E :=0.43429448190325182765LL;
M_LN2 :=0.69314718055994530942LL;
M_LN10 :=2.30258509299404568402LL;
M_PI :=3.14159265358979323846LL;
M_PI_2 :=1.57079632679489661923LL;
M_PI_4 :=0.78539816339744830962LL;
M_1_PI :=0.31830988618379067154LL;
M_2_PI :=0.63661977236758134308LL;
M_2_SQRTPI :=1.12837916709551257390LL;
M_SQRT2 :=1.41421356237309504880LL;
M_SQRT1_2 :=0.70710678118654752440LL;

mil.deposit(EQ);
mil.deposit(LT);
mil.deposit(LE);
mil.deposit(GT);
mil.deposit(GE);
mil.deposit(STORE_MEM);
mil.deposit(STORE_MMAP);
mil.deposit(STORE_COMPR);
mil.deposit(BUF_NORMAL);
mil.deposit(BUF_RANDOM);
mil.deposit(BUF_SEQUENTIAL);
mil.deposit(BUF_WILLNEED);
mil.deposit(BUF_DONTNEED);
mil.deposit(EBUSY);
mil.deposit(BAT_READ);
mil.deposit(BAT_APPEND);
mil.deposit(BAT_WRITE);
mil.deposit(M_E);
mil.deposit(M_LOG2E);
mil.deposit(M_LOG10E);
mil.deposit(M_LN2);
mil.deposit(M_LN10);
mil.deposit(M_PI);
mil.deposit(M_PI_2);
mil.deposit(M_PI_4);
mil.deposit(M_1_PI);
mil.deposit(M_2_PI);
mil.deposit(M_2_SQRTPI);
mil.deposit(M_SQRT2);
mil.deposit(M_SQRT1_2);
@-
@{
@+ Implementation
@h
#ifndef _ITERATOR_H
#define _ITERATOR_H
#endif /* _ITERATOR_H*/
@- Module initializaton
The content of this box my only be changed by the Administrator.
@= authorize
	if( !isAuthorized("Admin"))
		return throwMessage("const.@1","unauthorized access to 'mil' box");
@-
@= insertBox
	msg = @2;
	insertToBox(box,@1,msg);
	GDKfree(msg);
@c
#include "mil.h"
#include "streams.h"

#include "mal_utils.h"
#include "mal.h"
#include "mal_client.h"
#include "mal_interpreter.h"

int isAuthorized(str nme){
	Client c;
	if( nme == 0) return 1;
	c= getClient();
	return idcmp(c->user,nme)==0;
}
str MILprelude(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	Box box;
	(void)mb;(void)stk;(void)pci; /* fool compiler*/
	@:authorize(prelude)@
	box= openBox("mil");
	if( box== 0) 
		return throwMessage("mil.prelude","failed to open box");
	/* if the box was already filled we can skip initialization */
	if( box->sym->vtop == 0){
	/* old bat.mx and algebra.mx constants */
	}
	return MAL_SUCCEED;
}
@- Operator implementation
@c
str MILopen(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	(void)mb;(void)stk;(void)pci; /* fool compiler*/
	if(openBox("mil.open") != 0) return MAL_SUCCEED;
	return throwMessage("mil.open","failed to open box");
}

str MILclose(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	(void)mb;(void)stk;(void)pci; /* fool compiler*/
	if( closeBox("mil" ,TRUE) ==0) return MAL_SUCCEED;
	return throwMessage("mil.close","failed to close box");
}
str MILdestroy(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	Box box;
	(void)mb;(void)stk;(void)pci; /* fool compiler*/
	@:OpenBox(destroy)@
	destroyBox("mil");
	return MAL_SUCCEED;
}
@-
Access to a box calls for resolving the first parameter
to a named box.
@= OpenBox
	box= findBox("mil");
	if( box ==0) 
	return throwMessage("mil.@1","box is not open");
@-
@c
str MILdeposit(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	str name;
	ValPtr v;
	Box box;

	@:authorize(@1)@
	@:OpenBox(deposit)@
	name = (str) getArgName(mb,pci,1);
	v = &stk->stk[pci->argv[1]];
	if(depositBox(box,name,v) )
		return throwException(MALEXCEPTION,"mil.deposit",
			"failed to deposit '%s' into box",name);
	return MAL_SUCCEED;
}
@-
We first have to take the element from the constant box.
If we fail, the name could refer to a BAT
@c
str MILtake(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	str name;
	Box box;
	ValPtr v;
	int tpe;

	@:OpenBox(take)@
	name = * (str*) getArgReference(stk,pci,1);
	tpe = (int) getArgType(mb,pci,0);
	(void)tpe;
	v = &stk->stk[pci->argv[0]];
	if(takeBox(box,name,v,tpe)) {
		return throwException(MALEXCEPTION,"mil.take",
			"failed to take '%s' from box",name);
	} 
	/* also keep the copy in the variable */
	VALcopy(&stk->stk[pci->argv[1]],v);
	return MAL_SUCCEED;
}

str MILrelease(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	str name;
	Box box;
	(void)stk; /* fool compiler*/

	@:OpenBox(release)@
        name = (str) getArgName(mb,pci,1);
        releaseBox(box,name);
	return MAL_SUCCEED;
}

str MILreleaseAll(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	Box box;

	(void)mb; (void)stk; (void) pci; /* fool compiler */
	@:OpenBox(release)@
	releaseAllBox(box);
	return MAL_SUCCEED;
}

str MILdiscard(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	str name;
	Box box;

	(void)stk; /* fool compiler */
	@:OpenBox(discard)@
        name = (str) getArgName(mb,pci,1);
        if( discardBox(box,name) == 0)
                return throwException(MALEXCEPTION,"mil.discard",
			"failed to discard '%s' from box", name);
	return MAL_SUCCEED;
}
str MILtoString(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	Box box;
	int i,len=0;
	ValPtr v;
	str nme,s=0;

	(void)mb; /* fool compiler */
	@:OpenBox(toString)@
	nme = (str) getArgValue(stk,pci,1);
	i= findVariable(box->sym,nme);
	if( i <0) return throwException(MALEXCEPTION,"mil.toString",
			"failed to take '%s' from box",nme);

	v= &box->val->stk[i];
	garbageElement(&stk->stk[pci->argv[0]]);

	if( v->vtype== TYPE_str) s= v->val.sval;
	else (*BATatoms[v->vtype].atomToStr)(&s,&len,v);
	if(s== NULL) return throwMessage("mil.toString","illegal value");
	VALset(&stk->stk[pci->argv[0]], TYPE_str,s);

	/* if( VALconvert(TYPE_str,v, TRUE) == ILLEGALVALUE) 
		return throwMessage("mil.toString","illegal value");
	VALcopy(&stk->stk[pci->argv[0]], v); */
	return MAL_SUCCEED;
}

str MILnewIterator(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	Box box;
	lng *cursor;
	ValPtr v;

	(void)mb; /* fool compiler */
	@:OpenBox(iterator)@
	cursor= (lng*) getArgValue(stk,pci,0);
	v= &stk->stk[pci->argv[1]];
	nextBoxElement(box, cursor, v);
	return MAL_SUCCEED;
}
str MILhasMoreElements(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	Box box;
	lng *cursor;
	ValPtr v;

	(void)mb; /* fool compiler */
	@:OpenBox(iterator)@
	cursor= (lng*) getArgValue(stk,pci,0);
	v= &stk->stk[pci->argv[1]];
	nextBoxElement(box, cursor, v);
	return MAL_SUCCEED;
}

str MILline(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	str nme;
	int len;
	(void) mb; /* fool compiler */
	nme = (str) getArgValue(stk,pci,1);
	unquote(nme);
	len=strlen(nme);
	stream_printf(GDKout,"#%s%s",nme,(nme[len-1]=='\n'?"":"\n"));
        stream_flush(GDKout);
	return MAL_SUCCEED;
}
@}
