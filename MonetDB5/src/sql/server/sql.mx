@f sql
@t SQL Scenario implementation
@a M Kersten 
@v 0
@* SQL Scenario implementation
The SQL scenario imlementation is a derivative of the MAL session scenario.
In particular, the end of the SQL statement to be executed is recognized
by receiving a semicolon directly followed by an empty line. 

It is also the first version that uses state records.
They are initialized as part of the initialization phase of 
the scenario. The routines to be used are explicitly named.

The main issues to deal after parsing it to clean out the
Admin.main function from any information added erroneously.
Ideally this involves resetting the state of the client
'main' function, i.e. the symbol table is reset and any
instruction added should be cleaned. Beware that the instruction
table may have grown in size.

@mal
module sql;

command sql():void = SQLlanguage
comment "Switch to processing SQL statements";

command header(i:int) = SQLheader
comment "Generate a table header for an SQL frontend";
command column(i:any, v:str,t:str) = SQLcolumnsingle;
command column(b:bat, v:str,t:str) = SQLcolumn
comment "Rename a table column";

pattern output(a:any...)= SQLoutput;
pattern output(a:bat[any,any]...)= SQLoutputBats
comment "Overloading of the core print routines to obtain proper layout";

@- The SQL multi-version catalog
This module also contains the definitions for managing an SQL database schema in
version 5.  It is an adaptation of the original V4.3 code base. 

The original wrapper code is retained, because it makes it
easier to later re-use part of the catalog code in a separately.
@mal
command sqlType(sqlname:str, digits:int, scale:int, radix:int, name:str):void 
	= sql_type_wrap 
comment "Add a new sql type";

command sqlAggr(name:str, imp:str, atp:str, rtp:str):void = sql_aggr_wrap
comment "Add a new sql aggregate function";

command sqlFunc(name:str, imp:str, tp1:str, tp2:str, tp3:str, rtp:str):void
		= sql_func_wrap
comment "Add a new sql function";

command createCatalog( debug:int ) : void = mvc_create_wrap
comment "Create multi version catalog";

command destroyCatalog() = mvc_destroy_wrap
comment "Destroy multi version catalog";

command login( user:str, passwd:str ):str= mvc_login_wrap
comment "Database login";

command status( ) : int = mvc_status_wrap
comment "Return the status of the last mvc operation";

#command type( ) : int = mvc_type_wrap
#comment "return the type of the last mvc operation";

command commit( chain:int, name:str ) : int = mvc_commit_wrap
comment "Commit transaction/savepoint and chain";

command rollback( chain:int, name:str ) : int = mvc_rollback_wrap
comment "Rollback transaction/savepoint and chain";

command release( name:str ) : int = mvc_release_wrap
comment "Release the savepoint";

command setISOlevel( level:int ) : int = mvc_set_iso_level_wrap
comment "Change the isolation level";

command bindSchema( sname:str ) :  void = mvc_bind_schema_wrap
comment "Locate the schema and make it the current one";

command bindTable(tname:str ) = mvc_bind_table_wrap
comment "Locate the table in the current schema and make it the focus";

command bindColumn( cname:str ) = mvc_bind_column_wrap
comment "Locate the column in the current table and make it the focus";

command bindKey(s:str, t:str, kname:str ):ptr = mvc_bind_key_wrap
comment "Bind table key with name, kname";

command bindUbat(sname:str, tname:str, cname:str, access:int ) : 
		BAT[any::1,any::2] = mvc_bind_ubat_wrapREAD
comment "Bind bat with the updates to tname.cname with specific access mode";

command bindObat(sname:str, tname:str, access:int) : 
		BAT[any::1,any::2] = mvc_bind_obat_wrap
comment "Bind the oid bat, tname.OI with specific access modeD";

command bindDbat(sname:str, tname:str, access:int) : 
		BAT[any::1,any::2] = mvc_bind_dbat_wrap
comment "Bind the table deletes bat, tname.delete with specific access modes";

command bind(sname:str, tname:str, cname:str, access:int ):BAT[any::1,any::2] 
	= mvc_bind_wrap
comment "Bind the bat tname.cname into the focus with specific access mode";

command dropSchema( name:str ) = mvc_drop_schema_wrap
comment "Drop schema";

command createSchema( name:str, auth:str) : void = mvc_create_schema_wrap 
comment "Create schema";

command dropTable(name:str,  cascade:bit ) = mvc_drop_table_wrap 
comment "Drop table from a schema";

command createTable(name:str, temp:int):void = mvc_create_table_wrap
comment "Create table in current schema";

command createView( name:str, sql:str) = mvc_create_view_wrap 
comment "Create view within the current schema";

command dropColumn( name:str ) = mvc_drop_column_wrap 
comment "Drop column from a table in a schema";

command createColumn( name:str, type:str,digits:int,scale:int,seqnr:int ) :int
	= mvc_create_column_wrap
comment "Create column within the current table";

command setNotNull(flg:int) = mvc_null_wrap
comment "Set current column (not) null";

command default(val:str ) = mvc_default_wrap
comment "Set current column default value";

command createKey(name:str,kt:int,skey:bat,fk:bat):void = mvc_create_key_wrap
comment "Create a (compound) table key";

#command createForeignKey( nme:str, kt:str, ft:str, fk:str ) 
		#= mvc_create_fkey_wrap
#comment "Create a table key";

#command keyAddColumn( s:str, t:str, k:sql_key, c:sql_column ) = mvc_key_add_column_wrap
#comment "Key add column";

command exportTable(s:stream, order:bat, bats:bat, sep:str, rsep:str) =
		mvc_export_wrap
comment "Export a table (in order) to stream s with the 
given tuple and record seperators (sep/rsep)";

command importTable( s:stream, tname:str, 
	sep:str, rsep:str, nr:int) : str = mvc_import_table_wrap
comment "Import a table from stream s with the given 
tuple and record seperators (sep/rsep)";

command importTable(tname:str, fname:bat[void,str], 
	sep:str, rsep:str, nr:int) : int = mvc_input_table_wrap
comment "Import table from multiple files with the given 
tuple and record seperators (sep/rsep)";

#command exportSchema( s:stream ) = mvc_export_schema_wrap
#comment "Export the schema info of the current transaction";

#command renumber(b1:bat[oid,any::1],o:oid):bat[oid,any::1] = CMDrenumber
#comment "renumber the bat using the offset o.";

#command insert(b:bat[void,any::1],u:bat[void,any::1]):bat[void,any::1] =
	#CMDbatappendoidbat 
#comment "append the contents of u to b.";
#command replace(b:bat[void,any::1],u:bat[void,any::1]):bat[void,any::1] =
	#CMDbatreplaceoidbat 
#comment "inplace replace values on the give locations.";
@h
/*
 * The contents of this file are subject to the MonetDB Public
 * License Version 1.0 (the "License"); you may not use this file
 * except in compliance with the License. You may obtain a copy of
 * the License at 
 * http://monetdb.cwi.nl/Legal/MonetDBPL-1.0.html
 * 
 * Software distributed under the License is distributed on an "AS
 * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
 * implied. See the License for the specific language governing
 * rights and limitations under the License.
 * 
 * The Original Code is the Monet Database System.
 * 
 * The Initial Developer of the Original Code is CWI.
 * Portions created by CWI are Copyright (C) 1997-2002 CWI.  
 * All Rights Reserved.
 * 
 * Contributor(s): Martin Kersten <Martin.Kersten@cwi.nl>
 */
#ifndef _SQL_SCENARIO
#define _SQL_SCENARIO
#include "mal_session.h"


/* #define _SQL_SCENARIO_DEBUG  */
mal_export str SQLexitClient(Client c);
mal_export str SQLinitClient(Client c);
mal_export str SQLexit(Client c);
mal_export str SQLinit(Client c);

mal_export str SQLparser(Client c);
mal_export str SQLengine(Client c);
#endif /* _SQL_SCENARIO */

@c
#include "sql.h"
#include "mal_function.h"
#include "sql_mvc.h"
#include "context.h"
#include "statement.h"
#include "sqlexecute.h"
#include "sql_codegen.h"

@+ Scenario routines
Consume input and concatenate it until you find a ';<nl>' combination.
@c
str SQLinit(Client c){
	mvc_init(0);
	return MAL_SUCCEED;
}
str SQLexit(Client c){
	mvc_exit();
	return MAL_SUCCEED;
}
str SQLinitClient(Client c){
	context *lc;
	int i;
	mvc *m;
	str schema;

	lc = c->state[PARSER];
	if( lc == 0){
		m= mvc_create(0);
		/* replace user name with client record setting later on */
		schema= mvc_login(m,"monetdb","monetdb");
		if( !schema){
			return throwMessage("SQLparser","No schema defined\n");
		}
		lc = NEW(context);
		sql_init_context(lc,c->fdout,0, default_catalog_create());
		mvc_catalog_create(m,lc);
		c->state[PARSER] = lc;
		c->state[OPTIMIZE]=m;
		m->btop= 0;
	} else m = c->state[OPTIMIZE];
	for(i=0;i< m->btop; i++)
		mvc_clear_binding(m,i);
	m->btop = 0;
	
	return MAL_SUCCEED;
}
str SQLexitClient(Client c){
	int i;
	mvc *m;
	context *lc;

	lc = c->state[PARSER];
	m = (mvc *) c->state[OPTIMIZE];
	if(lc && m){
		mvc_destroy(m);
		/*sql_exit_context(lc); not completely needed*/
		/* files are already closed */
		        catalog_destroy(lc->cat);
		lc->cat = NULL;

		if (lc->sql != NULL)
			_DELETE(lc->sql);
		lc->sql = NULL;
		_DELETE(lc->yytext);

	}
	clrScenario(c);
	return MAL_SUCCEED;
}
str SQLlanguage(str *ret){
        str msg= MAL_SUCCEED;
        stream_printf(GDKout,"#Continue as SQL session\n");
        msg= setScenario(getClient(),"sql");
        *ret = 0;
        return msg;
}
str SQLreader(Client c){
	char * prev;
	int cnt, oldcnt,eof;
#ifdef _SQL_SCENARIO_DEBUG
	printf("SQLparser: start reading SQL block\n");
#endif
	if( c->mode <= FINISHING)
		return throwMessage("SQLreader","end of SQL input\n");
	c->prompt= GDKstrdup("sql>");
	c->promptlength= strlen(c->prompt);
	c->nxt=c->input;
	oldcnt= cnt=0;
	while( c->mode > FINISHING && (eof=readClient(c,c->prompt))){
		cnt +=strlen(c->input+oldcnt);
		if( cnt==oldcnt ) break;
		if( c->input[cnt-1]==';') break;
		/* add the newline before reading the next part */
		c->input[cnt]= '\n';
		c->input[cnt+1]= 0;
		c->nxt= c->input+cnt;
		oldcnt=cnt;
	}
	c->input[cnt]= '\n';
	c->input[cnt+1]= 0;
	c->nxt=c->input;

#ifdef _SQL_SCENARIO_DEBUG
	printf("SQL blk:%s\n",c->input);
#endif
	if(eof==0) {
		c->mode= FINISHING;
		return throwMessage("SQLreader","end of SQL input\n");
	}
	return 0;
}
@-
The SQL block is stored in the client input buffer, from which it
can be parsed by the SQL parser. The client structure contains
a small table of bounded tables. This should be reset before we
parse a new statement sequence.
@-
Before we parse the sql statement, we look for any variable settings
for specific commands.
The most important one is to prepare code to be handled by the debugger.
The current analysis is simple and fulfills our short-term needs.
A future version may analyse the parameter settings in more detail.
@c

#define skip() while(*c->nxt && isspace(*c->nxt) ) c->nxt++;
#define tst(X) (strncmp(c->nxt,(X),strlen(X))==0 && isspace(c->nxt[strlen(X)]))

int SQLsetEnvironment(Client c){
	do{
		skip();
		if( tst("quit") || tst("exit")){
			mvc_exit();
			InstrPtr q;
			c->nxt+= 5;
			q= newInstruction(ASSIGNsymbol);
			q->modname= GDKstrdup("system");
			q->fcnname= GDKstrdup("quit");
			pushInstruction(c->curprg->def,q);
			return 0;
		} else
		if( tst("set")|| tst("SET") ){
			c->nxt += 3;
			skip();
			if(tst("debug") ){
				InstrPtr q;
				c->nxt+= 6;
				q= newInstruction(ASSIGNsymbol);
				q->fcnname= GDKstrdup("showFunction");
				pushInstruction(c->curprg->def,q);
				q= newInstruction(ASSIGNsymbol);
				q->fcnname= GDKstrdup("mdb");
				q= pushArgument(c->curprg->def,q,
					     newConstant(c->curprg->def,TYPE_bit,
						       GDKstrdup("true"),0));
				pushInstruction(c->curprg->def,q);
				return 1;
			}
			if(tst("trace") ){
				c->listing = (c->listing & LIST_INPUT) | LIST_MAL_INSTR;
				c->nxt+=6;
				return 0;
			}
			if(tst("explain") ){
				c->listing = (c->listing & LIST_INPUT) | LIST_MAL_ALL;
				c->nxt+=8;
				return 0;
			}
			if(tst("notrace") ){
				c->listing &= LIST_INPUT;
				c->nxt+=6;
				return 0;
			}
		} else break;
	} while(1);
	return 0;
}
str SQLparser(Client c) {
	str msg=0, w;
	stmt *s;
	int i,debug=0, err=0;
	context *lc;
	int stop,vtop;
	MalBlkRecord oldstate;

	oldstate= *c->curprg->def;
#ifdef _SQL_SCENARIO_DEBUG
	printf("SQL start compilation \n");
#endif
	debug= SQLsetEnvironment(c);
	lc= ((context*)c->state[PARSER]);
	s= sqlexecute(lc, c->nxt, &err);
	if( s== NULL && lc->errstr && *lc->errstr){
		stream_printf(c->fdout,"#%s\n",lc->errstr);
		*lc->errstr=0;
		msg= throwMessage("SQLparser","Parser errors\n");
	}
	while( s) { int i=1;
		sql2MAL((mvc*)c->state[OPTIMIZE], c->curprg->def, s, lc);
		w= lc->buf-1;
#ifdef _SQL_SCENARIO_DEBUG
		printf("continue parser from:%s", w);
#endif
		stmt_destroy(s);
		s= sqlexecute(c->state[PARSER], w, &err);
		if( s== NULL && lc->errstr && *lc->errstr){
			stream_printf(c->fdout,"#%s\n",lc->errstr);
			*lc->errstr=0;
			msg= throwMessage("SQLparser","Parser errors\n");
		}
	} 
	/* turn off debugger */
	if(debug){
		InstrPtr q;
		q= newInstruction(ASSIGNsymbol);
		q->fcnname= GDKstrdup("mdb");
		q= pushArgument(c->curprg->def,q,
			     newConstant(c->curprg->def,TYPE_bit,
				       GDKstrdup("false"),0));
		pushInstruction(c->curprg->def,q);
	}
	pushEndInstruction(c->curprg->def);
	chkProgram(c->nspace, c->curprg->def);
	if( c->curprg->def->errors){
		showErrors(c);
		/* restore the state */
		if( c->listing)
			printFunction(c->fdout,c->curprg->def, c->listing);
		resetInstructions(c->curprg->def,oldstate.stop);
		resetVariables(c->curprg->def, c->glb, oldstate.vtop);
		c->curprg->def->errors=0;
		msg= throwMessage("SQLparser","Semantic errors\n");
	}
#ifdef _SQL_SCENARIO_DEBUG
	if(msg) printf("SQL finished:%s\n",msg);
#endif
	c->fdout->flush(c->fdout);
		
	return msg;
}
@-
Execution of the SQL program is delegated to the MALengine.
@c
str SQLengine(Client c) {
	str msg =MAL_SUCCEED;
	MalStkPtr oldglb= c->glb;

	if( c->curprg->def->errors)
		return throwMessage("SQLengine","Program contains errors\n");
#ifdef _SQL_SCENARIO_DEBUG
	printf("Ready to execute SQL statement\n");
#endif
	c->glb= 0;
	msg= MALengine(c);
	c->glb= oldglb;
	return msg;
}
@-
The SQL front-end required some IO utilities, that may go beyond the
primitives avaiable in the io.mx module.
@c
str SQLheader(int *ret,int *i){
	/*return throwMessage("SQLheader","Not yet defined\n");*/
	return MAL_SUCCEED;
}

str SQLcolumn(int *ret, int *bid, str *v, str *t){
	CMDsetRole(ret,bid,t,v);
	return MAL_SUCCEED;
}
str SQLcolumnsingle(int *ret, int *cnr, str *v, str *t){
	/* do nothing for the time being, later, package it as a table */
	return MAL_SUCCEED;
}

str SQLoutput(MalBlkPtr mb, MalStkPtr stk, InstrPtr p){
	int i;
	if( p->argc==2)
		CMDprintBoth(mb,stk,p,1,"[ "," ]\n");
	else {
		CMDprintBoth(mb,stk,p,1,"[ ",0);
		for(i=2; i<p->argc-2;i++)
			CMDprintBoth(mb,stk,p,i,", ",0);
		CMDprintBoth(mb,stk,p,i,", ", "]\n");
	}
	return MAL_SUCCEED;
}
str SQLoutputBats(MalBlkPtr mb, MalStkPtr stk, InstrPtr p){
        CMDtableAll(GDKout,mb,stk,p,1,0,FALSE);
	return MAL_SUCCEED;
}
