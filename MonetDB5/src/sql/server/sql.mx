@f sql
@t SQL Scenario implementation
@a M Kersten 
@v 0
@* SQL Scenario implementation
The SQL scenario imlementation is a derivative of the MAL session scenario.
In particular, the end of the SQL statement to be executed is recognized
by receiving an empty line. 

It is also the first version that uses state records.
They are initialized as part of the initialization phase of 
the scenario. The routines to be used are explicitly named.

The main issues to deal after parsing it to clean out the
Admin.main function from any information added erroneously.
Ideally this involves resetting the state of the client
'main' function, i.e. the symbol table is reset and any
instruction added should be cleaned. Beware that the instruction
table may have grown in size.

@= restoreState
        if( c->listing)
                printFunction(c->fdout,c->curprg->def, c->listing);
        resetInstructions(c->curprg->def,oldstate.stop);
        resetVariables(c->curprg->def, c->glb, oldstate.vtop);
	c->curprg->def->errors=0;

@mal
module sql;

command init()= SQLparserInit
comment "Initialize the SQL parser context";
@h
/*
 * The contents of this file are subject to the MonetDB Public
 * License Version 1.0 (the "License"); you may not use this file
 * except in compliance with the License. You may obtain a copy of
 * the License at 
 * http://monetdb.cwi.nl/Legal/MonetDBPL-1.0.html
 * 
 * Software distributed under the License is distributed on an "AS
 * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
 * implied. See the License for the specific language governing
 * rights and limitations under the License.
 * 
 * The Original Code is the Monet Database System.
 * 
 * The Initial Developer of the Original Code is CWI.
 * Portions created by CWI are Copyright (C) 1997-2002 CWI.  
 * All Rights Reserved.
 * 
 * Contributor(s): Martin Kersten <Martin.Kersten@cwi.nl>
 */
#ifndef _SQL_SCENARIO
#define _SQL_SCENARIO
#include "mal_session.h"


/* #define _SQL_SCENARIO_DEBUG */

mal_export str SQLparser(Client c);
mal_export str SQLengine(Client c);
#endif /* _SQL_SCENARIO */

@c
#include "sql.h"
#include "mal_function.h"
#include "mal_milscenario.h"
#include "sql_mvc.h"
#include "context.h"
#include "statement.h"
#include "sqlexecute.h"
#include "sql_codegen.h"

str SQLreader(Client c){
	char * prev;
	int cnt, oldcnt,eof;
#ifdef _SQL_SCENARIO_DEBUG
	printf("SQLparser: start reading SQL block\n");
#endif
	if( c->mode <= FINISHING)
		return throwMessage("SQLreader","end of SQL input\n");
	c->prompt= GDKstrdup("sql>");
	c->promptlength= strlen(c->prompt);
	c->nxt=c->input;
	oldcnt= cnt=0;
	while( c->mode > FINISHING && (eof=readClient(c,c->prompt))){
		cnt +=strlen(c->input+oldcnt);
		if( cnt==oldcnt ) break;
		/* add the newline */
		c->input[cnt]= '\n';
		c->input[cnt+1]= 0;
		c->nxt= c->input+cnt;
		oldcnt=cnt;
	}
	c->input[cnt]= '\n';
	c->input[cnt+1]= 0;
	c->nxt=c->input;

#ifdef _SQL_SCENARIO_DEBUG
	printf("SQL blk:%s\n",c->input);
#endif
	if(eof==0) {
		c->mode= FINISHING;
		return throwMessage("SQLreader","end of SQL input\n");
	}
	return 0;
}
@-
The SQL block is stored in the client input buffer, from which it
can be parsed by the SQL parser. The client structure contains
a small table of bounded tables. This should be reset before we
parse a new statement sequence.
@c
str SQLparserInit(int *ret){
	Client c= getClient();
	context *lc;
	int i;
	mvc *m;
	str schema;

	lc = c->state[PARSER];
	if( lc == 0){
		mvc_init(0);
		m= mvc_create(0);
		/* replace user name with client record setting later on */
		schema= mvc_login(m,"monetdb","monetdb");
		if( !schema){
			return throwMessage("SQLparser","No schema defined\n");
		}
		lc = NEW(context);
		sql_init_context(lc,c->fdout,0, default_catalog_create());
		mvc_catalog_create(m,lc);
		c->state[PARSER] = lc;
		c->state[OPTIMIZE]=m;
		m->btop= 0;
	} else m = c->state[OPTIMIZE];
	for(i=0;i< m->btop; i++)
		mvc_clear_binding(m,i);
	m->btop = 0;
	
	return MAL_SUCCEED;
}
@-
Before we parse the sql statement, we look for any variable settings
for specific commands.
The most important one is to prepare code to be handled by the debugger.
The current analysis is simple and fulfills our short-term needs.
A future version may analyse the parameter settings in more detail.
@c

#define skip() while(*c->nxt && isspace(*c->nxt) ) c->nxt++;
#define tst(X) (strncmp(c->nxt,(X),strlen(X))==0 && isspace(c->nxt[strlen(X)]))

int SQLsetEnvironment(Client c){
	do{
		skip();
		if( tst("quit") || tst("exit")){
			mvc_exit();
			InstrPtr q;
			c->nxt+= 5;
			q= newInstruction(ASSIGNsymbol);
			q->modname= GDKstrdup("system");
			q->fcnname= GDKstrdup("quit");
			pushInstruction(c->curprg->def,q);
			return 0;
		} else
		if( tst("set")|| tst("SET") ){
			c->nxt += 3;
			skip();
			if(tst("debug") ){
				InstrPtr q;
				c->nxt+= 6;
				q= newInstruction(ASSIGNsymbol);
				q->fcnname= GDKstrdup("showFunction");
				pushInstruction(c->curprg->def,q);
				q= newInstruction(ASSIGNsymbol);
				q->fcnname= GDKstrdup("mdb");
				q= pushArgument(c->curprg->def,q,
					     newConstant(c->curprg->def,TYPE_bit,
						       GDKstrdup("true"),0));
				pushInstruction(c->curprg->def,q);
				return 1;
			}
			if(tst("trace") ){
				c->listing = (c->listing & LIST_INPUT) | LIST_MAL_INSTR;
				c->nxt+=6;
				return 0;
			}
			if(tst("explain") ){
				c->listing = (c->listing & LIST_INPUT) | LIST_MAL_ALL;
				c->nxt+=8;
				return 0;
			}
			if(tst("notrace") ){
				c->listing &= LIST_INPUT;
				c->nxt+=6;
				return 0;
			}
		} else break;
	} while(1);
	return 0;
}
str SQLparser(Client c) {
	str msg=0, w;
	stmt *s;
	int i,debug=0, err=0;
	context *lc;
	int stop,vtop;
	MalBlkRecord oldstate;

	SQLparserInit(&i);
	oldstate= *c->curprg->def;
#ifdef _SQL_SCENARIO_DEBUG
	printf("SQL start compilation \n");
#endif
	debug= SQLsetEnvironment(c);
	lc= ((context*)c->state[PARSER]);
	s= sqlexecute(lc, c->nxt, &err);
	if( s== NULL && lc->errstr && *lc->errstr){
		stream_printf(c->fdout,"#%s\n",lc->errstr);
		*lc->errstr=0;
		msg= throwMessage("SQLparser","Parser errors\n");
	}
	while( s) { int i=1;
		sql2MAL((mvc*)c->state[OPTIMIZE], c->curprg->def, s, lc);
		w= lc->buf-1;
#ifdef _SQL_SCENARIO_DEBUG
		printf("continue parser from:%s", w);
#endif
		stmt_destroy(s);
		s= sqlexecute(c->state[PARSER], w, &err);
		if( s== NULL && lc->errstr && *lc->errstr){
			stream_printf(c->fdout,"#%s\n",lc->errstr);
			*lc->errstr=0;
			msg= throwMessage("SQLparser","Parser errors\n");
		}
	} 
	/* turn off debugger */
	if(debug){
		InstrPtr q;
		q= newInstruction(ASSIGNsymbol);
		q->fcnname= GDKstrdup("mdb");
		q= pushArgument(c->curprg->def,q,
			     newConstant(c->curprg->def,TYPE_bit,
				       GDKstrdup("false"),0));
		pushInstruction(c->curprg->def,q);
	}
	chkProgram(c->nspace, c->curprg->def);
	if( c->curprg->def->errors){
		showErrors(c);
		@:restoreState@
		msg= throwMessage("SQLparser","Semantic errors\n");
	}
#ifdef _SQL_SCENARIO_DEBUG
	if(msg) printf("SQL finished:%s\n",msg);
#endif
	c->fdout->flush(c->fdout);
		
	return msg;
}
@-
Execution of the SQL program is delegated to the MALengine.
@c
str SQLengine(Client c) {
	str msg =MAL_SUCCEED;
	MalStkPtr oldglb= c->glb;

	if( c->curprg->def->errors)
		return throwMessage("SQLengine","Program contains errors\n");
#ifdef _SQL_SCENARIO_DEBUG
	printf("Ready to execute SQL statement\n");
#endif
	c->glb= 0;
	msg= MALengine(c);
	c->glb= oldglb;
	return msg;
}
