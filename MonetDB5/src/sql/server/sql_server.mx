@f sql_server
@a N.J. Nes, M.L. Kersten
@* The SQL multi-version catalog
This module contains the definitions for managing an SQL database schema in
version 5.  It is an adaptation of the original V4.3 code base. 

The original wrapper code is retained, because it makes it
easier to later re-use part of the catalog code in a separately.
@mal
module mvc;

command sqlType(sqlname:str, digits:int, scale:int, radix:int, name:str):void 
	= sql_type_wrap 
comment "Add a new sql type";

command sqlAggr(name:str, imp:str, atp:str, rtp:str):void = sql_aggr_wrap
comment "Add a new sql aggregate function";

command sqlFunc(name:str, imp:str, tp1:str, tp2:str, tp3:str, rtp:str):void
		= sql_func_wrap
comment "Add a new sql function";

command init(debug:int):void = mvc_init_wrap
comment "Initialize the global catalog";

command finish() = mvc_finish_wrap
comment "Cleanup the global catalog";

command createCatalog( debug:int ) : void = mvc_create_wrap
comment "Create multi version catalog";

command destroy() = mvc_destroy_wrap
comment "Destroy multi version catalog";

command login( user:str, passwd:str ):str= mvc_login_wrap
comment "Database login";

command status( ) : int = mvc_status_wrap
comment "Return the status of the last mvc operation";

command type( ) : int = mvc_type_wrap
comment "return the type of the last mvc operation";

command commit( chain:int, name:str ) : int = mvc_commit_wrap
comment "Commit transaction/savepoint and chain";

command rollback( chain:int, name:str ) : int = mvc_rollback_wrap
comment "Rollback transaction/savepoint and chain";

command release( name:str ) : int = mvc_release_wrap
comment "Release the savepoint";

command setISOlevel( level:int ) : int = mvc_set_iso_level_wrap
comment "Change the isolation level";

command bindSchema( sname:str ) :  void = mvc_bind_schema_wrap
comment "Locate the schema and make it the current one";

command bindTable(tname:str ) = mvc_bind_table_wrap
comment "Locate the table in the current schema and make it the focus";

command bindColumn( cname:str ) = mvc_bind_column_wrap
comment "Locate the column in the current table and make it the focus";

command bindKey(s:str, t:str, v:str ) = mvc_bind_key_wrap
comment "Bind key, t.(cols)";

command bindUbatWrite(sname:str, tname:str, cname:str) : 
		BAT[any::1,any::2] = mvc_bind_ubat_wrapWRITE
comment "Bind bat with the updates to tname.cname";
command bindUbat(sname:str, tname:str, cname:str ) : 
		BAT[any::1,any::2] = mvc_bind_ubat_wrapREAD
comment "Bind bat with the updates to tname.cname";

command bindObatWrite(sname:str, tname:str) : 
		BAT[any::1,any::2] = mvc_bind_obat_wrapWRITE
comment "Bind the oid bat, tname.OID";
command bindObat(sname:str, tname:str) : 
		BAT[any::1,any::2] = mvc_bind_obat_wrapREAD
comment "Bind the oid bat, tname.OID";

command bindDbatWrite(sname:str, tname:str) : 
		BAT[any::1,any::2] = mvc_bind_dbat_wrapWRITE
comment "Bind the table deletes bat, tname.deletes";
command bindDbat(sname:str, tname:str) : 
		BAT[any::1,any::2] = mvc_bind_dbat_wrapREAD
comment "Bind the table deletes bat, tname.deletes";

command bind(sname:str, tname:str, cname:str, access:int ):BAT[any::1,any::2] 
	= mvc_bind_wrap
comment "Bind the bat, tname.cname";

command bindWrite(sname:str, tname:str, cname:str):BAT[any::1,any::2] = mvc_bind_wrapWRITE
comment "Bind the bat, tname.cname";

command bind(sname:str, tname:str, cname:str):BAT[any::1,any::2] = mvc_bind_wrapREAD
comment "Bind the bat, tname.cname";


command dropSchema( name:str ) = mvc_drop_schema_wrap
comment "Drop schema";

command createSchema( name:str, auth:str) : void = mvc_create_schema_wrap 
comment "Create schema";

command dropTable(name:str,  cascade:bit ) = mvc_drop_table_wrap 
comment "Drop table from a schema";

command createTable(name:str, temp:int):void = mvc_create_table_wrap
comment "Create table in current schema";

command createView( name:str, sql:str) = mvc_create_view_wrap 
comment "Create view within the current schema";

command dropColumn( name:str ) = mvc_drop_column_wrap 
comment "Drop column from a table in a schema";

command createColumn( name:str, type:str,digits:int,scale:int,seqnr:int ) :int
	= mvc_create_column_wrap
comment "Create column within the current table";

command setNull(col:int,flg:int ) = mvc_null_wrap
comment "Set current column not null";

command default(val:str ) = mvc_default_wrap
comment "Set current column default value";

#command createKey( s:str, t:str, col:str, kt:int) = mvc_create_key_wrap
#comment "Create a table key";

#command createForeignKey( s:str, t:str, col:str, kt:str, ft:str, fk:str ) 
		#= mvc_create_fkey_wrap
#comment "Create a table key";

#command keyAddColumn( s:str, t:str, k:sql_key, c:sql_column ) = mvc_key_add_column_wrap
#comment "Key add column";

command export(s:stream, order:bat, bats:bat, sep:str, rsep:str) =
		mvc_export_wrap
comment "export a table (in order) to stream s with the 
given tuple and record seperators (sep/rsep)";

command importTable( s:stream, tname:str, 
	sep:str, rsep:str, nr:int) : int = mvc_import_table_wrap
comment "import a table from stream s with the given 
tuple and record seperators (sep/rsep)";
command inputTable(tname:str, fname:bat[void,str], 
	sep:str, rsep:str, nr:int) : int = mvc_input_table_wrap
comment "import table from multiple files with the given 
tuple and record seperators (sep/rsep)";

#command exportSchema( s:stream ) = mvc_export_schema_wrap
#comment "Export the schema info of the current transaction";

#command renumber(b1:bat[oid,any::1],o:oid):bat[oid,any::1] = CMDrenumber
#comment "renumber the bat using the offset o.";

#command insert(b:bat[void,any::1],u:bat[void,any::1]):bat[void,any::1] =
	#CMDbatappendoidbat 
#comment "append the contents of u to b.";
#command replace(b:bat[void,any::1],u:bat[void,any::1]):bat[void,any::1] =
	#CMDbatreplaceoidbat 
#comment "inplace replace values on the give locations.";
@-
The SQL front-end uses the stream packages to communicate with the
backend. The formatting requests and printing is encapsulated in MIL programs,
which are replaced here with C-versions.
@mal
module sql_server;
command header(i:int) = SQL_header;
command column(i:any, v:str,t:str) = SQL_columnsingle;
command column(b:bat, v:str,t:str) = SQL_column;
pattern output(a:any...)= SQL_output;
pattern output(a:bat[any,any]...)= SQL_outputBats;
@-
The implementation of the IO assumes delivery to the client standard output.
@h
#ifndef _SQL_SERVER_
#define _SQL_SERVER_
#include "sql_codegen.h"
#endif /* _SQL_SERVER_ */
@-
@c
#include "sql_server.h"

str SQL_header(int *ret,int *i){
	/*return throwMessage("SQL_header","Not yet defined\n");*/
	return MAL_SUCCEED;
}

str SQL_column(int *ret, int *bid, str *v, str *t){
	CMDsetRole(ret,bid,t,v);
	return MAL_SUCCEED;
}
str SQL_columnsingle(int *ret, int *cnr, str *v, str *t){
	/* do nothing for the time being, later, package it as a table */
	return MAL_SUCCEED;
}

str SQL_output(MalBlkPtr mb, MalStkPtr stk, InstrPtr p){
	int i;
	if( p->argc==2)
		CMDprintBoth(mb,stk,p,1,"[ "," ]\n");
	else {
		CMDprintBoth(mb,stk,p,1,"[ ",0);
		for(i=2; i<p->argc-2;i++)
			CMDprintBoth(mb,stk,p,i,", ",0);
		CMDprintBoth(mb,stk,p,i,", ", "]\n");
	}
	return MAL_SUCCEED;
}
str SQL_outputBats(MalBlkPtr mb, MalStkPtr stk, InstrPtr p){
        CMDtableAll(GDKout,mb,stk,p,1,0,FALSE);
	return MAL_SUCCEED;
}
@mil
ALL OLD STUFF

module(alarm);
module(xtables);
module(aggrX3);
module(monettime);
module(mmath);
module(decimal);
module(mapi); # mapi_listen 

const QPARSE := 1;
const QTABLE := 2;
const QUPDATE := 3;
const QDATA := 4;
const QHEADER := 5;
const QDEBUG := 5;

mvc_init(int(monet_environment.find("sql_debug")));

proc initialize(int debug) {
	# change to sql statements !!
	var myc := mvc_create(debug);
	var schema := mvc_admin_login(myc);
	
	if (schema != ""){
		user_name := mvc_bind( myc, schema, "users", "name", 1);
		user_name.access(BAT_WRITE);
		if (user_name.count() = 0){
			mvc_create_user( myc, "monetdb", "monetdb", "MonetDB Admin", "sys", 0);
			# probably needs priv's too 
			mvc_commit( myc, 0, "");
		}
	}
	mvc_destroy( myc );
}

proc input( mvc myc, Stream Input, str tname, BAT fnames, str Sep, str rSep, int sz ):={
	var s := Input;
	if (fnames.count() > 0){
		fnames@batloop(){
			f := iconv($t, "UTF-8", codeset());
			s := open_rastream(f);
			
			mvc_import_table( myc, s, tname, Sep, rSep, sz );
			stream_close(s);
		}
	} else {
		mvc_import_table( myc, s, tname, Sep, rSep, sz );
	}
}

proc ascii_io_output( bat Order, bat bats, Stream Output, str Sep ) : int := {
	var Max := bats.reverse.max();
	var seps := [ bats ~ const Sep];
	seps.access(BAT_WRITE);
	seps.replace(Max, "\n");

	seps := seps.reverse.mark(oid(0));
	bats := bats.reverse.mark(oid(0));
	return output( Order, seps.reverse, bats.reverse, Output );
}

proc output_header( Stream Output, int nrcols ) : void := {
	stream_writeInt( Output, 0 ); # write not done.
	stream_writeInt( Output, QHEADER ); # type TABLE.
	stream_writeInt( Output, nrcols ); # NR columns.
}

proc output_column( Stream Output, str name, str tpe ) : void := {
	var p := name + "," + tpe + "\n";
	stream_write( Output, p);
}

proc server_output( Stream Output, any Order, any val, ..any.. ) : void := {
	stream_writeInt( Output, 0 ); # write not done.
	stream_writeInt( Output, QTABLE ); # type TABLE.
	stream_writeInt( Output, 1 ); # NR records.

	cnt := $0;
	var p := str(val);
	if (type(val) = str)
		p := "\"" + val + "\"";
	var id := 3;
	while(id < cnt ){
		if (type($(id+1)) != str)
 			p := p + "\t" + str($(id+1));
		else
 			p := p + "\t\"" + str($(id+1)) + "\"";
		id :+= 1;
	}
 	p := p + "\n"; 
	stream_write( Output, p);
	stream_flush( Output );
}

proc server_output( Stream Output, bat[oid,any] Order,  ..bat[oid,any]..) : void := {
	var cnt := Order.count();
	stream_writeInt( Output, 0 ); # write not done.
	stream_writeInt( Output, QTABLE ); # type TABLE.
	stream_writeInt( Output, cnt ); # NR records.
	
	cnt := $0;
	var bats := new(oid,bat);
	var id := 0;
	while((id + 2) < cnt ){
		bats.insert(oid(id), $(id+3));
		id :+= 1;
	}
	ascii_io_output(Order, bats, Output, "\t");
	stream_flush( Output );
}


proc new_quit() := {
	mvc_exit();
	eval("old_quit;");
}

proc get_sql_port() := {
	if (monet_environment.exist("sql_port")){
		return int(monet_environment.find("sql_port"));
	}
	var port := 45123;
	var sqlport := getenv("SQLPORT");
	if (length(sqlport) > 0){
		port := int(sqlport);
	}
	return port;
}

renameFUNC("quit", "old_quit");
renameFUNC("new_quit", "quit");

mapi_listen(int(monet_environment.find("sql_port")), 5, "SQLclient").fork();
