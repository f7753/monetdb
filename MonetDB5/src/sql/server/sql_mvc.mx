@f sql_mvc
@a N.J. Nes, M.L. Kersten
@* The SQL multi-version catalog
@h
#ifndef _MVC_H_
#define _MVC_H_

/*
 * The contents of this file are subject to the MonetDB Public
 * License Version 1.0 (the "License"); you may not use this file
 * except in compliance with the License. You may obtain a copy of
 * the License at 
 * http://monetdb.cwi.nl/Legal/MonetDBPL-1.0.html
 * 
 * Software distributed under the License is distributed on an "AS
 * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
 * implied. See the License for the specific language governing
 * rights and limitations under the License.
 * 
 * The Original Code is the Monet Database System.
 * 
 * The Initial Developer of the Original Code is CWI.
 * Portions created by CWI are Copyright (C) 1997-2002 CWI.  
 * All Rights Reserved.
 * 
 * Contributor(s): Martin Kersten <Martin.Kersten@cwi.nl>
 *		   Niels Nes <Niels.Nes@cwi.nl>
 */

#include "mal_function.h"
#include "mal_client.h"
#include <context.h>
#include <gdk.h>
#include <mem.h>
#include "../parser/catalog.h"
#include <stdarg.h>
#include "sql_logger.h"
#include <statement.h>
#include <types.h>
#include <ascii_io.h>
#include <sqlexecute.h>

#define ISO_READ_UNCOMMITED 1
#define ISO_READ_COMMITED   2
#define ISO_READ_REPEAT	    3
#define ISO_SERIALIZABLE    4

#ifndef QUERY_H
#define QUERY_H

typedef enum sql_query_t {
        QEND = 0,
        QPARSE = 1,
        QRESULT = 2,
        QTABLE = 3,
        QUPDATE = 4,
        QDATA = 5,
        QCREATE = 6,
        QDEBUG = 7
} sql_query_t;

#endif /* QUERY_H */

typedef int sqlid;

/* todo change the sql_schema/sql_table/sql_column such that it only contains
 * operational data (access rules and times and bids)
 *
 * name bats using schema_table_column etc.
 * 
 * support multiple db's using multiple servers, requires a shallow connection setup
 * server, which communicates using shmem or pipes. 
 */

typedef struct sql_kc {
	struct sql_column *c;
	int trunc; /* 0 not truncated, >0 colum is truncated */
} sql_kc;

/* fkey consists of two of these */
typedef struct sql_key { /* pkey, ukey, fkey */
	sqlid id;
	char *name; 	/* constraint name */
	key_type type; /* pkey, ukey, fkey */
	struct list *columns; /* list of sql_kc */
	struct sql_table *t;

	oid bid; /* bid for index(void,oid) or hash (void,int) */
	int wtime; 
	int rtime; 
	int flag;
} sql_key;

typedef struct sql_ukey { /* pkey, ukey */
	sql_key k;
	list *keys;
} sql_ukey;

typedef struct sql_fkey { /* fkey */
	sql_key k;
	struct sql_ukey *rkey; /* only set for fkey and rkey */
} sql_fkey;

typedef struct sql_column {
	sqlid id;
	char *name;
	sql_subtype *type;
	int colnr;

	char *def;
	int null;

	oid bid;
	oid ubid;     /* bat with updates */
	int wtime; 
	int rtime; 
	int flag;

	struct sql_table *t;

} sql_column;

typedef struct sql_table {
	sqlid id;
	char *name;
	int type;
	char *query;
	struct list *columns;
	struct list *dcolumns;
	sql_column *ncolumn;
	sql_ukey *pkey;
	struct list *keys; 	/* all keys (primary,unique and foreign) */
	sql_key *nkey;
	struct list *dkeys;	/* list of dropped keys, not used jet */

	oid obid;     /* bat with oids */
	oid dbid;     /* bat with deletes */
	int wtime; 
	int rtime; 
	int flag;

	struct sql_schema *s;
} sql_table;

typedef struct sql_schema {
	sqlid id;
	char *name;
	char *auth;

	int wtime; 
	int rtime; 
	int flag;

	list *tables;
	list *dtables;
	sql_table *ntable;
} sql_schema;

typedef struct sql_trans {
	char *name;
	int stime; /* transaction time stamp (aka start time) */
	int rtime;
	int wtime;
	int level; 
	int type;
	ssize_t status;

	sql_schema *schema;
	list *schemas;
	list *dschemas;
	sql_schema *nschema;
	struct bm *bm;

	list *keys; /* need a place to keep keys during the foreing key
		       initialization */

	struct sql_trans *parent; /* multilevel transaction support */
} sql_trans;


typedef struct res_col {
        char *name;
        sql_subtype *type;
        bat b;
        int mtype;
        ptr *p;
} res_col;

typedef struct res_table {
        int id;
        int nr_cols;
        int cur_col;
        res_col *cols;
        bat order;
        struct res_table *next;
} res_table;

@-
The state of the compilation phase is administered in a state vector.
Given that declarations are never nested recursively, we can use an
accumulator approach. The state of the accumulated is reflected in
the mvc structure and involves direct access to schema, table, column,
and key structure. Updates to these references are clearly indicated
in the mvc command structures.
@h
#define MAXBIND 20
typedef struct mvcbinding{
	str	column, table;
	int	index;
} mvcbinding;

typedef struct MVC {
	int debug;
	sql_schema *currSchema;
	sql_table *currTable;
	sql_column *currColumn;
	sql_key *currKey;
	sql_trans *currtrans;
	sql_trans *trans;
	int user_id;
	int role_id;
	int privileges;
	char *user;
	char *role;
	int btop;
	mvcbinding binding[MAXBIND];

        int type;
        ssize_t status;
        int result_id;
        res_table *results;

} mvc;


extern sql_schema *find_schema(sql_trans *t, char *sname);
extern sql_table *find_table(sql_schema * s, char *tname);
extern sql_column *find_column(sql_table * t, char *cname);

extern void mvc_init(int debug);
extern void mvc_exit();

extern mvc *mvc_create( int debug );
extern void mvc_destroy( mvc *c );
extern char *mvc_login(mvc *m, char *user, char *passwd);

extern ssize_t mvc_status( mvc *c );
extern int mvc_type( mvc *c );
extern int mvc_showResult( mvc *c );

/* since Savepoints and transactions related the 
 * statement commit function includes the savepoint creation.
 * And rollbacks can be eigther full or until a given savepoint. 
 * The special statement_release can be used to release savepoints. 
 */
extern int mvc_commit( mvc *c, int chain, char *name );
extern int mvc_rollback( mvc *c, int chain, char *name );
extern int mvc_release( mvc *c, char *name );
extern int mvc_set_iso_level(mvc * m, int level);

extern BAT *mvc_bind( mvc *c, char *sname, char *tname, char *cname, int access );
extern BAT *mvc_bind_ubat( mvc *c, char *sname, char *tname, char *cname, int access );
extern BAT *mvc_bind_obat( mvc *c, char *sname, char *tname, int access );
extern BAT *mvc_bind_dbat( mvc *c, char *sname, char *tname, int access );
extern BAT *mvc_bind_kbat(  mvc *c, char *sname, char *tname, char *key, int access );


extern sql_schema *mvc_bind_schema( mvc *c, char *sname );
extern sql_table *mvc_bind_table( mvc *c, sql_schema *s, char *tname );
extern sql_column *mvc_bind_column( mvc *m, sql_table *t, char *cname );
extern sql_key *mvc_bind_key( mvc *m, sql_table *t, char *kname);

extern void mvc_drop_schema( mvc *c, char *name );
extern sql_schema *mvc_create_schema( mvc *c, char *name, char *auth);
extern void mvc_drop_table( mvc *c, sql_schema *s, char *name, bit cascade );
extern sql_table *mvc_create_view( mvc *c, sql_schema *s, char *name, char *sql);
extern sql_table *mvc_create_table(mvc *c, sql_schema *s, char *name, int type);
extern void mvc_drop_column( mvc *c, sql_table *t, char *name );
extern sql_column *mvc_create_column(mvc * m, sql_table *t, char *name,
	       char *sqltype, int type_digits, int type_scale, int seqnr);
extern sql_column *mvc_null(mvc * m, sql_column * col, int flag);
extern sql_column *mvc_default( mvc *c, sql_column *col, char *val );

extern sql_key *mvc_create_key( mvc *m, char *sname,
                        char *tname, char *kname, int kt, 
                        BAT *columns, sql_key *fk );
extern void mvc_drop_key( mvc *c, sql_table *t, char *kname );

extern int mvc_result_table( mvc *c, int nr_cols, BAT *order );
extern int mvc_result_row( mvc *c, int nr_cols );
extern int mvc_result_column( mvc *c, char *name, char *typename, int digits, int scale, BAT *b);
extern int mvc_result_value( mvc *c, char *name, char *typename, int digits, int scale, ptr *p, int mtype);

extern int mvc_export_result( mvc *c, stream *s, int res_id );
extern int mvc_export_table( mvc *c, stream *s, int res_id, int offset, int nr, char *sep, char *rsep);
extern ssize_t mvc_import_table( mvc *c, stream *s, char *tname, char *sep, char *rsep, int nr);

extern void mvc_export(stream * s, BAT * order, BAT * bats, char *sep,
		char *rsep);
#endif /*__MVC_H_*/
@-
The internal administration of the SQL compilation and execution state
is administered by a state descriptor accessible in each phase.
Failure to find the state descriptor aborts the session.
		_client->state[PARSER]= NEW(context);
		sql_init_context(_client->state[PARSER],0,0,
				 default_catalog_create()); 
@= getContext
{	Client _client= getClient();
	if(_client == NULL ){
		return throwMessage("mvc","Can not access client record");
	} 
	if( _client->state[PARSER] == NULL){
		return throwMessage("mvc","PARSER not initialized\n");
	}
	if( _client->state[OPTIMIZE] == NULL){
		str schema;
		context *lc = _client->state[PARSER];

printf("Re-establish context for client not expected\n");
		_client->state[OPTIMIZE] == mvc_create(0);
		schema = mvc_login( _client->state[OPTIMIZE], 
				"monetdb", "monetdb" );
		if( !schema)
		return throwMessage("getContext","unknown schema for monetdb\n");

/* default_catalog_create (lc, _client->state[OPTIMIZE]);
getschemas(@1,lc,lc->cat, "default-schema", "default-user");
*/

	}
	@1= ((mvc *) _client ->state[OPTIMIZE]);
}
@= setContext
{	Client _client = getClient();
	if(_client == NULL || _client ->state[OPTIMIZE]== 0 ){
		return throwMessage("mvc","Can not get access to @2 state");
	} 
	((mvc *) _client ->state[OPTIMIZE])= @1;
}
@c
#include "mal_scenario.h"
#include "sql_mvc.h"

str mvc_create_wrap(int *ret, int *debug ){
	mvc *res;
	res = mvc_create( *debug );
	@:setContext(res,mvc)@
	return MAL_SUCCEED;
}

str mvc_destroy_wrap(int *ret ){
	mvc *c;
	@:getContext(c,mvc)@
	mvc_destroy( c );
	@:setContext((mvc*)0,mvc)@
	return MAL_SUCCEED;
}

str mvc_login_wrap(str *r, str *user, str *passwd  ){
	mvc *c;
	@:getContext(c,mvc)@
	*r = mvc_login( c, *user, *passwd );
	if (*r != 0)
		return throwException(MALEXCEPTION,"mvc_login_wrap","error");
	return MAL_SUCCEED;
}

str mvc_status_wrap(int* res ){
	mvc *c;
	@:getContext(c,mvc)@
	*res = mvc_status( c );
	return MAL_SUCCEED;
}

str mvc_type_wrap(int *res ){
	mvc *m;
	@:getContext(m,mvc)@
	*res = mvc_type( m );
	return MAL_SUCCEED;
}

str mvc_commit_wrap(int* res, int* chain, str *name){
	mvc *m;
	@:getContext(m,mvc)@
	*res = mvc_commit( m, *chain, *name );
	return MAL_SUCCEED;
}

str mvc_rollback_wrap(int *res, int *chain, str *name ){
	mvc *m;
	@:getContext(m,mvc)@
	*res = mvc_rollback( m, *chain, *name );
	return MAL_SUCCEED;
}

str mvc_release_wrap(int *res, str *name ){
	mvc *m;
	@:getContext(m,mvc)@
	*res = mvc_release( m, *name );
	return MAL_SUCCEED;
}

str mvc_set_iso_level_wrap(int *res, int *level ){
	mvc *m;
	@:getContext(m,mvc)@
	*res = mvc_set_iso_level( m, *level );
	return MAL_SUCCEED;
}

str mvc_bind_wrap(int *bid, str *sname, str *tname, str *cname, int *access){
	mvc *c;
	BAT *b;
	@:getContext(c,mvc)@

	b= mvc_bind( c, *sname, *tname, *cname, *access );
	if (b){
		*bid= b->batCacheid;
		return MAL_SUCCEED;
	}
	return throwException(MALEXCEPTION,"mvc_bind_wrap","error");
}

str mvc_bind_ubat_wrap(int *ret, str *sname, str *tname, str *cname, int *access ){
	mvc *c;
	BAT *b;
	@:getContext(c,mvc)@
	b = mvc_bind_ubat( c, *sname, *tname, *cname, *access );
	if (b){
		*ret= b->batCacheid;
		return MAL_SUCCEED;
	}
	return throwException(MALEXCEPTION,"mvc_bind_ubat_wrap","error");
}
str mvc_bind_ubat_wrapWRITE(int *bid, str *sname, str *tname, str *cname){
	int i=1;
	return mvc_bind_ubat_wrap(bid, sname, tname, cname, &i);
}
str mvc_bind_ubat_wrapREAD(int *bid, str *sname, str *tname, str *cname){
	int i=0;
	return mvc_bind_ubat_wrap(bid, sname, tname, cname, &i);
}

str mvc_bind_obat_wrap(int *ret, str *sname, str *tname, int *access ){
	mvc *c;
	BAT *b;
	@:getContext(c,mvc)@
	b = mvc_bind_obat( c, *sname, *tname, *access );
	if (b){
		*ret= b->batCacheid;
		return MAL_SUCCEED;
	}
	return throwException(MALEXCEPTION,"mvc_bind_obat_wrap","error");
}

str mvc_bind_dbat_wrap(int *ret, str *sname, str *tname, int *access ){
	mvc *c;
	BAT *b;
	@:getContext(c,mvc)@
	b = mvc_bind_dbat( c, *sname, *tname, *access );
	if (b){
		*ret= b->batCacheid;
		return MAL_SUCCEED;
	}
	return throwException(MALEXCEPTION,"mvc_bind_dbat_wrap","error");
}
str mvc_bind_schema_wrap(int *ret, str *sname){
	mvc *c;
	@:getContext(c,mvc)@
	c->currSchema= mvc_bind_schema( c, *sname );
	return MAL_SUCCEED;
}

str mvc_bind_table_wrap(int *ret, str *tname){
	mvc *c;
	sql_schema *s;
	@:getContext(c,mvc)@
	s= c->currSchema;
	if( s== NULL) return throwMessage("bindTable","Schema not in focus");
	c->currTable = mvc_bind_table( c, s, *tname);
	return MAL_SUCCEED;
}

str mvc_bind_column_wrap(int *ret, str *col){
	mvc *c;
	sql_table *t;
	@:getContext(c,mvc)@

	t= c->currTable;
	if( t== NULL) return throwMessage("bindColumn","Table focus not found");

	c->currColumn= mvc_bind_column(c,t,*col);
	return MAL_SUCCEED;
}

str mvc_bind_key_wrap(int *ret, str *sname, str *tname, str *kname){
	mvc *c;
	sql_schema *s;
	sql_table *t;
	@:getContext(c,mvc)@

	s= find_schema(c->trans,*sname);
	if( s== NULL) return throwMessage("bindKey","Schema not found");

	t= find_table(s,*tname);
	if( t== NULL) return throwMessage("bindKey","Table not found");

	mvc_bind_key( c, t, *kname);
	return MAL_SUCCEED;
}


str mvc_create_schema_wrap(int *ret, str *name, str *auth){
	mvc *c;
	@:getContext(c,mvc)@
	c->currSchema = mvc_create_schema( c, *name, *auth );
	return MAL_SUCCEED;
}

str mvc_drop_schema_wrap(int *ret, str *name){
	mvc *c;
	@:getContext(c,mvc)@
	mvc_drop_schema( c, *name );
	c->currSchema = NULL;
	c->currTable = NULL;
	c->currColumn = NULL;
	c->currKey = NULL;
	return MAL_SUCCEED;
}

str mvc_create_table_wrap(int *ret, str *name, bit* temp){
	mvc *c;
	sql_schema *s;
	@:getContext(c,mvc)@

	s= c->currSchema;
	if( s== NULL) return throwMessage("createTable","Schema not found");

	c->currTable = mvc_create_table( c, s, *name, *temp );
	return MAL_SUCCEED;
}

str mvc_create_view_wrap(int *ret, str *name, str *sql){
	mvc *c;
	sql_schema *s;
	@:getContext(c,mvc)@

	s= c->currSchema;
	if( s== NULL) return throwMessage("createView","Schema not found");

	c->currTable= mvc_create_view( c, s, *name, *sql );
	return MAL_SUCCEED;
}

str mvc_drop_table_wrap(int *ret, str *name, bit* cascade){
	mvc *c;
	sql_schema *s;
	@:getContext(c,mvc)@

	s= c->currSchema;
	if( s== NULL) return throwMessage("dropTable","Schema not found");

	mvc_drop_table( c, s, *name, *cascade );
	c->currTable = NULL;
	c->currColumn = NULL;
	c->currKey = NULL;
	return MAL_SUCCEED;
}


str mvc_create_column_wrap(int *ret, str *name, str *type, int *digits, int *scale, int *seqnr){
	mvc *c;
	sql_schema *s;
	sql_table *t;
	@:getContext(c,mvc)@

	s= c->currSchema;
	if( s== NULL) return throwMessage("createColumn","Schema not found");

	t= c->currTable;
	if( t== NULL) return throwMessage("createColumn","Table not found");

	c->currColumn= mvc_create_column( c, t, *name, *type,*digits,*scale, *seqnr );
	return MAL_SUCCEED;
}

str mvc_drop_column_wrap(int *ret, str *name){
	mvc *c;
	sql_schema *s;
	sql_table *t;
	@:getContext(c,mvc)@

	s= c->currSchema;
	if( s== NULL) return throwMessage("createColumn","Schema not found");

	t= c->currTable;
	if( t== NULL) return throwMessage("createColumn","Table not found");

	mvc_drop_column( c, t, *name );
	c->currColumn= NULL;
	c->currKey= NULL;
	return MAL_SUCCEED;
}

str mvc_null_wrap(int *ret, int *flg){
	mvc *c;
	sql_schema *s;
	sql_table *t;
	sql_column *sc;
	@:getContext(c,mvc)@ 
	s= c->currSchema;
	if( s== NULL) return throwMessage("notNull","Schema not found");

	t= c->currTable;
	if( t== NULL) return throwMessage("notNull","Table not found");

	sc= c->currColumn;
	if( sc== NULL) return throwMessage("notNull","Column not found");

	mvc_null( c, sc, *flg);
	return MAL_SUCCEED;
}

str mvc_default_wrap(int *ret, str *val){
	mvc *c;
	sql_schema *s;
	sql_table *t;
	sql_column *sc;
	@:getContext(c,mvc)@

	s= c->currSchema;
	if( s== NULL) return throwMessage("notNull","Schema not found");

	t= c->currTable;
	if( t== NULL) return throwMessage("notNull","Table not found");

	sc= c->currColumn;
	if( sc== NULL) return throwMessage("notNull","Column not found");
	mvc_default( c, sc, *val );
	return MAL_SUCCEED;
}
@-
The recurring structure to handle bat descriptors
@= getBATdescriptor
        if( BBPcheck(*@2,"@4")==0)
                return throwMessage("algebra.@4", "cannot access bat @2 in bbp");
        @3= (BAT*) BBPgetdesc(*@2);
        if( @3 == NULL) { *@1 = 0;
                return throwMessage("algebra.@4", "cannot access descriptor @2");
        }
        if( *@2 <0){ /* BAT reverse */ @3 = BATmirror(@3); }
@-
@c
str mvc_create_key_wrap( int *ret, str *name, int *kt, int *bid, int *fk){
	mvc *c;
	sql_schema *s;
	sql_table *t;
	BAT *columns, *fkcols;
	@:getContext(c,mvc)@

	s= c->currSchema;
	if( s== NULL) return throwMessage("notNull","Schema not found");
	t= c->currTable;
	if( t== NULL) return throwMessage("notNull","Table not found");

	@:getBATdescriptor(ret,bid,columns,mvc_create_key_wrap)@
	if( *fk != bat_nil){
		@:getBATdescriptor(ret,fk,fkcols,mvc_create_key_wrap)@
	}

        if (*fk == int_nil){
                mvc_create_key(c, s->name, t->name, *name, *kt, columns, NULL);
        } else {
                mvc_create_key(c, s->name, t->name, *name, *kt, columns, NULL/*WRONG*/);
        }
	*ret =0;
        return MAL_SUCCEED;
}

str mvc_export_wrap(int *ret, stream *s, int *border, int *bids, str *sep, str *rsep ){
	BAT *order, *bats;
	@:getBATdescriptor(ret,border,order,mvc_export_wrap)@
	@:getBATdescriptor(ret,bids,bats,mvc_export_wrap)@
	mvc_export( *(stream**)s, order, bats, *sep, *rsep );
	return MAL_SUCCEED;
}

str mvc_import_table_wrap(int *ret, stream *s, str *tname , str *sep, str *rsep, int *sz ){
	mvc *c;
	@:getContext(c,mvc)@
	*ret= mvc_import_table( c, *(stream**)s, *tname, *sep, *rsep, *sz );
	return MAL_SUCCEED;
}
/* code of the old mvc.input proc */
str mvc_input_table_wrap(int *ret, str *tname, int *fid, str *sep, str *rsep, int *sz ){
	mvc *c;
	BAT *b;
	stream *s;
	int i;

	@:getContext(c,mvc)@
	s= getClient()->fdin;
	@:getBATdescriptor(ret,fid,b,mvc_input_wrap)@
	if( BATcount(b)>0){
		char *fname, *fnew;
		ptr p,q; int xx;
		BATloopFast(b,p,q,xx){
		fname= (char *)BUNtail(b,p);
printf("input comming from %s\n",fname);
		if( *fname==0) continue;
		char *codes=0, *target= "UTF-8";
		STRcodeset(&codes);
		STRIconv(&fnew,&fname,&codes,&target);
		s= open_rastream(fname);
		*ret = mvc_import_table( c, (stream*)s, *tname, *sep, *rsep, *sz );
		close_stream(s);
		}
	} else /* read from standard input */
	*ret = mvc_import_table( c, *(stream**)s, *tname, *sep, *rsep, *sz );
	return MAL_SUCCEED;
}

@c
/* multi version catalog */

/* 
 * TODO 
 *
 * insert/delete/update should return ERROR (or success). Client side
 * should handle the result
 *
 * use mmap copy
 *
 * come up with a multifile log system (so a seperate thread could
 * Do the atomic bat commits).
 */


#define TR_OLD 0
#define TR_NEW 1

static int 		mvc_debug = 0;
static MT_Lock 	  	mvc_lock = NULL;
static struct logger 	*logger = NULL;
static sql_trans 	*gtrans = NULL;

static sql_schema *bootstrap_create_schema(mvc * m, char *name, char *auth);
static sql_table *bootstrap_create_table(mvc * m, sql_schema *s, char *name, int type);
static sql_column *bootstrap_create_column(mvc * m, sql_table *t, char *name,
		       char *sqltype, int type_digits, int type_scale, int seqnr);
/* current time stamps model is simple. Two time stamps per column, 
   one for reads and writes. 
 */

static int transaction_id = 0;

static int stamp = 1;

static int timestamp()
{
	return stamp++;
}

static int key_cmp(sql_key *k, sqlid*id)
{
	if (k && id && k->id == *id)
		return 0;
	return 1;
}

static ptr bun_find(BAT *b, ptr v){
	BUN p = BUNfnd(b,v);
	if (p)
		return BUNtail(b,p);
	return NULL;
}

static BAT *bat_lcopy(BAT *b){
        BAT *nb = BATcopy(b);
        bat_destroy(b);
        BATfakeCommit(nb);
        return nb;
}


static BAT *sys_bat( struct bm *bm, char *name ) {
        oid lbid = bm_find_bat(bm, name);
        BAT *b = bm_lbid2bat(bm, lbid);

        if (!bm_lbid2mode(bm, lbid)) {
                if (mvc_debug)
                        fprintf(stderr, "sys_bat %s\n", name );
                b = bat_lcopy(b);
                bm_new_bat(bm, lbid, b->batCacheid);
        }
        return b;
}

static BAT *col_bind( sql_trans * tr, oid lbid, sql_column *c, int access )
{
	BAT *b = bm_lbid2bat(tr->bm, lbid);
	if (access && !bm_lbid2mode(tr->bm, lbid)) {	/* first write ie. need to copy */
		if (mvc_debug)
                        fprintf(stderr, "new bat for column %s.%s\n",
                                c->t->name, c->name );
		b = bat_lcopy(b);
		c->wtime = c->t->wtime = c->t->s->wtime = tr->wtime = tr->stime;
		bm_new_bat(tr->bm, lbid, b->batCacheid);
	}
	return b;
}

static BAT *bind_bat(sql_trans * tr, sql_column * c, int access )
{
	return col_bind(tr, c->bid, c, access);
}

static BAT *bind_ubat( sql_trans *tr, sql_column *c, int access )
{
	return col_bind(tr, c->ubid, c, access);
}

static BAT *tab_bind( sql_trans * tr, oid lbid, sql_table *t, int access )
{
	BAT *b = bm_lbid2bat(tr->bm, lbid);
	if (access && !bm_lbid2mode(tr->bm, lbid)) {	/* first write ie. need to copy */
		b = bat_lcopy(b);
		t->wtime = t->s->wtime = tr->wtime = tr->stime;
		bm_new_bat(tr->bm, lbid, b->batCacheid);
	}
	return b;
}

static BAT *bind_obat( sql_trans *tr, sql_table *t, int access )
{
	return tab_bind(tr, t->obid, t, access);
}

static BAT *bind_dbat( sql_trans *tr, sql_table *t, int access )
{
	return tab_bind(tr, t->dbid, t, access);
}
static BAT *bind_key( sql_trans *tr, sql_key *k, int access )
{
        return tab_bind(tr, k->bid, k->t, access);
}

static void kc_destroy(sql_kc * kc)
{
	_DELETE(kc);
}

static void key_destroy(sql_key * k)
{
	if (k->name) _DELETE(k->name);
	list_destroy(k->columns);
}

static void column_destroy(sql_column * c)
{
	_DELETE(c->name);
	_DELETE(c->type);
	_DELETE(c->def);
	_DELETE(c);
}

static void table_destroy(sql_table * t)
{
	_DELETE(t->name);
	_DELETE(t->query);

	if (t->keys){
		list_destroy(t->keys);
	}
	if (t->dkeys){
		list_destroy(t->dkeys);
	}
	list_destroy(t->columns);
	if (t->dcolumns){
		list_destroy(t->dcolumns);
	}
	_DELETE(t);
}

static void schema_destroy(sql_schema * s)
{
	_DELETE(s->name);
	_DELETE(s->auth);

	list_destroy(s->tables);
	if (s->dtables){
		list_destroy(s->dtables);
	}
	_DELETE(s);
}

static sql_trans *trans_destroy(sql_trans *t)
{
	sql_trans *res = t->parent;

	if (t->name) _DELETE(t->name); 

	list_destroy(t->schemas);
	if (t->dschemas){
		list_destroy(t->dschemas);
	}
	if (t->keys) list_destroy(t->keys);
	t->schema = NULL;
	bm_destroy(t->bm);
	_DELETE(t);
	return res;
}

static node *find_key_node(sql_table * t, char *kname)
{
	node *n;
	if (t->keys) for (n = t->keys->h; n; n = n->next) {
		sql_key *k = n->data;
		/* check if names match */
		if (strcmp(kname, k->name) == 0) {
			return n;
		}
	}
	return NULL;
}

static sql_key *find_key(sql_table * t, char *kname)
{
	node *n = find_key_node(t, kname );
	if (n) return n->data;
	return NULL;
}

static node *find_column_node(sql_table * t, char *cname)
{
	node *n;
	for (n = t->columns->h; n; n = n->next) {
		sql_column *c = n->data;
		/* check if names match and if its not an internal column */
		if (strcmp(cname, c->name) == 0 && c->colnr >=0) {
			return n;
		}
	}
	return NULL;
}

sql_column *find_column(sql_table * t, char *cname)
{
        node *n = find_column_node(t, cname );
        if (n) return n->data;
        return NULL;
}


static
node *find_table_node(sql_schema * s, char *tname)
{
	node *n;
	for (n = s->tables->h; n; n = n->next) {
		sql_table *t = n->data;
		if (strcmp(tname, t->name) == 0) {
			return n;
		}
	}
	return NULL;
}
sql_table *find_table(sql_schema * s, char *tname)
{
	node *n = find_table_node( s, tname );
	if (n) return n->data;
	return NULL;
}

static
node *find_schema_node(sql_trans *t, char *sname)
{
	node *n;
	for (n = t->schemas->h; n; n = n->next) {
		sql_schema *s = n->data;
		if (strcmp(sname, s->name) == 0) {
			return n;
		}
	}
	return NULL;
}
sql_schema *find_schema(sql_trans *t, char *sname)
{
	node *n = find_schema_node( t, sname );
	if (n) return n->data;
	return NULL;
}

static void update_table_bat( BAT *b, BAT *ub, BAT *db)
{
	if (BATcount(ub)){
		void_replace_bat(b, ub);
	}
	if (BATcount(db)){
		void_delete_bat(b, db,0);
	}
}

static void load_keycolumn(sql_trans *tr, BAT * columns, BUN j, sql_key *k )
{
	sql_kc *kc = NEW(sql_kc);
	BAT *kc_col = sys_bat(tr->bm, "keycolumns_column");
	BAT *kc_trunc = sys_bat(tr->bm, "keycolumns_trunc");
	ptr lid = BUNhead(columns, j);
	char *name = bun_find(kc_col, lid);
	int trunc = *(int*)bun_find(kc_trunc, lid);
	sql_column *c = find_column(k->t, name);
	assert(c);

	kc->c = c;
	kc->trunc = trunc;
	list_append(k->columns,kc);

	bat_destroy(kc_col);
	bat_destroy(kc_trunc);
}

static sql_key *load_key(sql_trans *tr, BAT * keys, BUN j, sql_table *t)
{
	char bname[BUFSIZ];
	int ccnt;
	BAT *cols, *rcols;
	BAT *key_id = sys_bat(tr->bm, "keys_id");
	BAT *key_tpe = sys_bat(tr->bm, "keys_type");
	BAT *key_name = sys_bat(tr->bm, "keys_name");
	BAT *key_rkey = sys_bat(tr->bm, "keys_rkey");
	BAT *kc_id = sys_bat(tr->bm, "keycolumns_id");
	BAT *kc_nr = sys_bat(tr->bm, "keycolumns_nr");
	ptr lid = BUNhead(keys, j);
	int ktype = *(int*) bun_find(key_tpe, lid);
	char *name = (char*) bun_find(key_name, lid);
	sql_key *nk = (ktype!=fkey)?(sql_key*)NEW(sql_ukey)
				:(sql_key*)NEW(sql_fkey);
	char keychar = (ktype==fkey)?'F':'K';
	BUN p,q;

	nk->id = *(sqlid*) bun_find(key_id, lid);
	nk->type = ktype;
	nk->name = _strdup(name);
	nk->columns = list_create((fdestroy)&kc_destroy);
	nk->t = t;
	nk->rtime = nk->wtime = 0;
	nk->flag = TR_OLD;
	snprintf(bname, BUFSIZ, "%c_%s_%s", keychar, t->name, nk->name );
	nk->bid = bm_find_bat(tr->bm, bname);

	if (ktype == ukey || ktype == pkey){
		sql_ukey *uk = (sql_ukey*)nk;
		uk -> keys = NULL;

		if (ktype == pkey)
			t->pkey = uk;
	} else {
		sql_fkey *fk = (sql_fkey*)nk;
		fk -> rkey = NULL;
	}

	cols = BATselect(kc_id, (ptr) & nk->id, (ptr) & nk->id);
	rcols = BATsemijoin(kc_nr, cols);
	bat_destroy(cols);
	cols = BATmirror(rcols);
	rcols = BATsort(cols);
	bat_destroy(cols);
	cols = BATmirror(rcols);

	ccnt = BATcount(cols);
	if (ccnt) {
		BATloop(cols,p,q)
			load_keycolumn(tr, cols, p, nk);
	}
	bat_destroy(cols);

	if (ktype == fkey){
		sql_fkey *fk = (sql_fkey*)nk;
		sqlid rkey = *(sqlid*) bun_find(key_rkey, lid);
		node *n = list_find(tr->keys, &rkey, (fcmp)&key_cmp);

		assert(n);
		if (n){
			sql_ukey *uk = n->data;
			fk->rkey = uk;
			if (!uk->keys) uk->keys = list_create(NULL);
			list_append(uk->keys, fk);
		} else {
			list_append(tr->keys, fk);
		}
	} else { /* could be a set of rkeys */
		sql_ukey *uk = (sql_ukey*)nk;
		BAT *keys = BATselect(key_rkey, (ptr) & nk->id, (ptr) & nk->id);

		BATloop(keys,p,q){
			sqlid fkey = *(sqlid*) BUNhead(keys, p);
			node *n = list_find(tr->keys, &fkey, (fcmp)&key_cmp);
			if (n){
				sql_fkey *fk = n->data;
				if (!uk->keys) uk->keys = list_create(NULL);
				list_append(uk->keys, fk);
				fk->rkey = uk;
			}
		}
		list_append(tr->keys, nk);
		BBPreclaim(keys);
	}
	bat_destroy(key_id);
	bat_destroy(key_tpe);
	bat_destroy(key_name);
	bat_destroy(key_rkey);
	bat_destroy(kc_id);
	bat_destroy(kc_nr);
	return nk;
}

static sql_column *load_column(sql_trans *tr, sql_table *t, BAT * columns, BUN j)
{
	char name[BUFSIZ], *tpe;
	sql_column *c = NEW(sql_column);
	ptr lid = BUNhead(columns, j);
	int sz,d;
	BAT *column_id = sys_bat(tr->bm, "columns_id");
	BAT *column_name = sys_bat(tr->bm, "columns_name");
	BAT *column_type = sys_bat(tr->bm, "columns_type");
	BAT *column_type_digits = sys_bat(tr->bm, "columns_type_digits");
	BAT *column_type_scale = sys_bat(tr->bm, "columns_type_scale");
	BAT *column_default = sys_bat(tr->bm, "columns_default");
	BAT *column_null = sys_bat(tr->bm, "columns_null");
	BAT *column_number = sys_bat(tr->bm, "columns_number");

	c->id = *(sqlid*) bun_find(column_id, lid);
	c->name = _strdup((char *) bun_find(column_name, lid));
	tpe = (char *) bun_find(column_type, lid);
	sz = *(int*)bun_find(column_type_digits, lid);
	d =  *(int*)bun_find(column_type_scale, lid);
	c->type = sql_bind_subtype(tpe,sz,d);
	c->def = _strdup((char *) bun_find(column_default, lid));
	c->null = *(bit *) bun_find(column_null, lid);
	c->colnr = *(int *) bun_find(column_number, lid);
	c->t = t;
	c->wtime = c->rtime = 0;
	c->flag = TR_OLD;

	snprintf(name, BUFSIZ, "%s_%s", t->name, c->name );
	c->bid = bm_find_bat(tr->bm, name);

	snprintf(name, BUFSIZ, "U_%s_%s", t->name, c->name );
	c->ubid = bm_find_bat(tr->bm, name);

        if (mvc_debug)
                fprintf(stderr, "\t\tload column %s\n", c->name);

	if (c->bid && c->ubid){
		BAT *ub = bm_lbid2bat(tr->bm, c->ubid);
		BAT *db = bm_lbid2bat(tr->bm, t->dbid);
		if (BATcount(ub) || BATcount(db)){
			BAT *b = bind_bat(tr, c, 1);
			update_table_bat(b, ub, db);
			bat_destroy(b);
		}
		bat_destroy(ub);
		bat_destroy(db);
	}

	bat_destroy(column_id);
	bat_destroy(column_name);
	bat_destroy(column_type);
	bat_destroy(column_type_digits);
	bat_destroy(column_type_scale);
	bat_destroy(column_default);
	bat_destroy(column_null);
	bat_destroy(column_number);
	return c;
}

static sql_table *load_table(sql_trans *tr, sql_schema *s, BAT * tables, BUN j)
{
	char name[BUFSIZ];
	sql_table *t = NEW(sql_table);
	ptr lid = BUNhead(tables, j);
	BAT *cols, *rcols, *keys;
	BUN p,q;
	int ccnt;
	BAT *column_table = sys_bat(tr->bm, "columns_table_id");
	BAT *column_number = sys_bat(tr->bm, "columns_number");
	BAT *key_table = sys_bat(tr->bm, "keys_table_id");
	BAT *table_id = sys_bat(tr->bm, "tables_id");
	BAT *table_names = sys_bat(tr->bm, "tables_name");
	BAT *table_queries = sys_bat(tr->bm, "tables_query");
	BAT *table_types = sys_bat(tr->bm, "tables_type");

	t->id = *(sqlid*) bun_find(table_id, lid);
	t->name = _strdup(bun_find(table_names, lid));
	t->query = _strdup(bun_find(table_queries, lid));
	t->type = *(int*) bun_find(table_types, lid);
	t->wtime = t->rtime = 0;
	t->flag = TR_OLD;
	t->pkey = NULL;
	t->keys = NULL;
	t->dkeys = NULL;
	t->nkey = NULL;
	t->s = s;

	snprintf(name, BUFSIZ, "D_%s", t->name );
	t->dbid = bm_find_bat(tr->bm, name);

	snprintf(name, BUFSIZ, "O_%s", t->name );
	t->obid = bm_find_bat(tr->bm, name);

	t->columns = list_create((fdestroy)&column_destroy);
	t->dcolumns = NULL;
	t->ncolumn = NULL;

	cols = BATselect(column_table, (ptr) & t->id, (ptr) & t->id);
	rcols = BATsemijoin(column_number, cols);
	bat_destroy(cols);
	cols = BATmirror(rcols);
	rcols = BATsort(cols);
	bat_destroy(cols);
	cols = BATmirror(rcols);

	if (mvc_debug)
                fprintf(stderr, "\tload table %s\n", t->name);

	if (t->type != tt_view) {
		BATloop (cols,p,q)
			list_append(t->columns, load_column(tr, t, cols, p));
	}
	bat_destroy(cols);

	keys = BATselect(key_table, (ptr) & t->id, (ptr) & t->id);
	ccnt = BATcount(keys);
	if (t->type != tt_view && ccnt) {
		t->keys = list_create((fdestroy)&key_destroy);
		BATloop(keys,p,q)
			list_append(t->keys, load_key(tr, keys, p, t));
	}
	bat_destroy(keys);
	bat_destroy(key_table);
	bat_destroy(column_table);
	bat_destroy(column_number);
	bat_destroy(table_id);
	bat_destroy(table_names);
	bat_destroy(table_queries);
	bat_destroy(table_types);
	return t;
}

static sql_schema *load_schema(sql_trans *tr, BAT * schemas, BUN j)
{
	sql_schema *s = NEW(sql_schema);
	ptr lid = BUNhead(schemas, j);
	BAT *tables;
	BUN p,q;
	BAT *schema_names = sys_bat(tr->bm, "schemas_name");
	BAT *schema_auths = sys_bat(tr->bm, "schemas_authorization");
	BAT *table_schema = sys_bat(tr->bm, "tables_schema_id");

	s->id = *(sqlid*) bun_find(schemas, lid);
	s->name = _strdup(bun_find(schema_names, lid));
	s->auth = _strdup(bun_find(schema_auths, lid));
	s->tables = list_create((fdestroy)&table_destroy);
	s->dtables = NULL;
	s->ntable = NULL;
	s->wtime = s->rtime = 0;
	s->flag = TR_OLD;

        if (mvc_debug)
                fprintf(stderr, "load schema %s\n", s->name);

	tables = BATselect(table_schema, (ptr) & s->id, (ptr) & s->id);
	BATloop(tables,p,q)
		list_append(s->tables, load_table(tr, s, tables, p));

	bat_destroy(tables);
	bat_destroy(table_schema);
	bat_destroy(schema_auths);
	bat_destroy(schema_names);
	return s;
}

static sql_trans *load_trans(struct bm *bm)
{
	sql_trans *t = NEW(sql_trans);
	BUN p,q;
	BAT *schema_ids = sys_bat(bm, "schemas_id");

	t->name = NULL;
	t->wtime = t->rtime = 0;
	t->stime = timestamp();
	t->level = ISO_SERIALIZABLE;
	t->status = 0;
	t->type = 0;
	t->parent = NULL;
	t->bm = bm;

	t->schemas = list_create((fdestroy)&schema_destroy);
	t->dschemas = NULL;
	t->nschema = NULL;
	t->keys = list_create(NULL);

        if (mvc_debug)
                fprintf(stderr, "load trans\n");

	BATloop(schema_ids,p,q)
		list_append(t->schemas, load_schema(t, schema_ids, p));

	list_destroy(t->keys);
	t->keys = list_create(NULL);
	bat_destroy(schema_ids);

	return t;
}

static sql_kc *kc_dup(sql_trans *tr, sql_table *t, sql_kc *kc)
{
	sql_kc *nkc = NEW(sql_kc);
	sql_column *c = find_column(t,kc->c->name); 
	assert(c);
	nkc->c = c;
	nkc->trunc = kc->trunc;
	return nkc;
}

static sql_key *key_dup(sql_trans *tr, sql_key *k, sql_table *t)
{
	sql_key *nk = (k->type!=fkey)?(sql_key*)NEW(sql_ukey)
				:(sql_key*)NEW(sql_fkey);
	node *n;

	nk->id = k->id;
	nk->type = k->type;
	nk->name = _strdup(k->name);
	nk->columns = list_create((fdestroy)&kc_destroy);
	nk->t = t;
	nk->rtime = nk->wtime = 0;
	nk->flag = TR_OLD;
	nk->bid = k->bid;

	if (nk->type != fkey){
		sql_ukey *tk = (sql_ukey*)nk;
		tk -> keys = NULL;

		if (nk->type == pkey)
			t->pkey = tk;
	} else {
		sql_fkey *tk = (sql_fkey*)nk;
		tk -> rkey = NULL;
	}

	for(n = k->columns->h; n; n = n->next){
		sql_kc *okc = n->data;
		list_append(nk->columns, kc_dup(tr, t, okc));
	}

	if (nk->type == fkey){
		sql_fkey *fk = (sql_fkey*)nk;
		sql_fkey *ok = (sql_fkey*)k;
		node *n;
		assert( ok->rkey );
		n = list_find(tr->keys, &ok->rkey->k.id, (fcmp)&key_cmp);
		assert(n);
		if (n){
			sql_ukey *uk = n->data;
			fk->rkey = uk;
			if (!uk->keys) uk->keys = list_create(NULL);
			list_append(uk->keys, fk);
		} else {
			list_append(tr->keys, fk);
		}
	} else { /* could be a set of rkeys */
		sql_ukey *uk = (sql_ukey*)nk;
		sql_ukey *ok = (sql_ukey*)k;
		node *m;
		if (ok->keys) for(m=ok->keys->h; m; m = m -> next){
			sql_fkey *ofk = m->data;
			node *n = list_find(tr->keys, &ofk->k.id, (fcmp)&key_cmp);
			if (n){
				sql_fkey *fk = n->data;
				if (!uk->keys) uk->keys = list_create(NULL);
				list_append(uk->keys, fk);
				fk->rkey = uk;
			}
		}
		list_append(tr->keys, nk);
	}
	return nk;
}

static sql_column *column_dup(sql_table *t, sql_column * s)
{
	sql_column *c = NEW(sql_column);
	c->id = s->id;
	c->name = _strdup(s->name);
	c->type = sql_dup_subtype(s->type);
	c->def = _strdup(s->def);
	c->null = s->null;
	c->colnr = s->colnr;
	c->bid = s->bid;
	c->ubid = s->ubid;
	c->wtime = c->rtime = 0;
	c->flag = TR_OLD;
	c->t = t;
	return c;
}

static sql_table *table_dup(sql_trans *tr, sql_schema *s, sql_table * ot)
{
	node *n;
	sql_table *t = NEW(sql_table);
	t->id = ot->id;
	t->name = _strdup(ot->name);
	t->type = ot->type;
	t->query = _strdup(ot->query);
	t->columns = list_create((fdestroy)&column_destroy);
	t->dcolumns = NULL;
	t->ncolumn = NULL;
	t->dbid = ot->dbid;
	t->obid = ot->obid;

	t->pkey = NULL;
	t->keys = NULL;
	t->dkeys = NULL;
	t->nkey = NULL;

	t->wtime = t->rtime = 0;
	t->flag = TR_OLD;
	t->s = s;

	for (n = ot->columns->h; n; n = n->next) {
		sql_column *c = n->data;
		list_append(t->columns, column_dup(t, c));
	}
	if (ot->keys){
		t->keys = list_create((fdestroy)&key_destroy);
	       	for (n = ot->keys->h; n; n = n->next) {
			sql_key *k = n->data;
			list_append(t->keys, key_dup(tr,k,t));
		}
	}
	return t;
}

static sql_schema *schema_dup(sql_trans *tr, sql_schema * os)
{
	node *n;
	sql_schema *s = NEW(sql_schema);
	s->id = os->id;
	s->name = _strdup(os->name);
	s->auth = _strdup(os->auth);
	s->tables = list_create((fdestroy)&table_destroy);
	s->dtables = NULL;
	s->ntable = NULL;
	s->wtime = s->rtime = 0;
	s->flag = TR_OLD;

	for (n = os->tables->h; n; n = n->next) {
		sql_table *ot = n->data;
		if (ot->type != tt_temp && ot->type != tt_session)
			list_append(s->tables, table_dup(tr, s, ot));
	}
	return s;
}


static sql_trans *trans_dup(sql_trans *ot, char *newname ){
	node *n;
	sql_trans *t = NEW(sql_trans);

	t->wtime = t->rtime = 0;
	t->stime = timestamp();
	t->level = ot->level;
	t->status = 0;
	t->type = 0;
	t->parent = ot;
	t->bm = bm_dup(ot->bm);

	t->schemas = list_create((fdestroy)&schema_destroy);
	t->dschemas = NULL;
	t->nschema = NULL;
	t->keys = list_create(NULL);
	if (newname)
		t->name = _strdup(newname);
	else 
		t->name = NULL;

	for (n = ot->schemas->h; n; n = n->next) {
		list_append(t->schemas, schema_dup(t, n->data));
	}
	return t;
}

static BAT *mvc_bat( struct bm *bm, char *name, int type)
{
	BAT *b = NULL;
	bat id = bm_find_bat(bm, name);

	if (mvc_debug)
		fprintf(stderr, "mvc_bat %s bid %d\n", name, id);

	if (id == 0) {
                if (mvc_debug)
                        fprintf(stderr, "mvc_bat created %s bid %d\n", name,id);
		b = BATnew( TYPE_void, type, BUFSIZ );
		BATseqbase(b,0);
		bm_add_bat(bm, b->batCacheid, name, 0 /* do not use a transaction id */);
	} else {
		if (mvc_debug)
                        fprintf(stderr, "mvc_bat loaded %s bid %d\n", name, id);
                b = bm_lbid2bat(bm, id);
                if (!bm_lbid2mode(bm, id)){
                        b = bat_lcopy(b);
                        bm_new_bat(bm, id, b->batCacheid);
  
		}
	}
	return b;
}

static void mvc_init_schema( struct bm *bm )
{
	BAT *sql_schema_id = mvc_bat(bm, "schemas_id", TYPE_int);
	BAT *sql_schema_name = mvc_bat(bm, "schemas_name", TYPE_str);
	BAT *sql_schema_auth = mvc_bat(bm, "schemas_authorization", TYPE_str);
	BAT *U_schema_id = mvc_bat(bm, "U_schemas_id", TYPE_int);
	BAT *U_schema_name = mvc_bat(bm, "U_schemas_name", TYPE_str);
	BAT *U_schema_auth = mvc_bat(bm, "U_schemas_authorization", TYPE_str);
	BAT *D_sql_schema = mvc_bat(bm, "D_schemas", TYPE_oid);
	BAT *O_sql_schema = mvc_bat(bm, "O_schemas", TYPE_oid);

	update_table_bat(sql_schema_id, U_schema_id, D_sql_schema);
	update_table_bat(sql_schema_name, U_schema_name, D_sql_schema);
	update_table_bat(sql_schema_auth, U_schema_auth, D_sql_schema);

	bat_destroy(sql_schema_id);
	bat_destroy(sql_schema_name);
	bat_destroy(sql_schema_auth);
	bat_destroy(U_schema_id);
	bat_destroy(U_schema_name);
	bat_destroy(U_schema_auth);
	bat_destroy(D_sql_schema);
	bat_destroy(O_sql_schema);
}

static void mvc_init_table( struct bm *bm )
{
	BAT *sql_table_id = mvc_bat(bm, "tables_id", TYPE_int);
	BAT *sql_table_name = mvc_bat(bm, "tables_name", TYPE_str);
	BAT *sql_table_schema = mvc_bat(bm, "tables_schema_id", TYPE_int);
	BAT *sql_table_query = mvc_bat(bm, "tables_query", TYPE_str);
	BAT *sql_table_type = mvc_bat(bm, "tables_type", TYPE_int);
	BAT *U_table_id = mvc_bat(bm, "U_tables_id", TYPE_int);
	BAT *U_table_name = mvc_bat(bm, "U_tables_name", TYPE_str);
	BAT *U_table_schema = mvc_bat(bm, "U_tables_schema_id", TYPE_int);
	BAT *U_table_query = mvc_bat(bm, "U_tables_query", TYPE_str);
	BAT *U_table_type = mvc_bat(bm, "U_tables_type", TYPE_int);
	BAT *D_sql_table = mvc_bat(bm, "D_tables", TYPE_oid);
	BAT *O_sql_table = mvc_bat(bm, "O_tables", TYPE_oid);

	update_table_bat(sql_table_id, U_table_id, D_sql_table);
	update_table_bat(sql_table_name, U_table_name, D_sql_table);
	update_table_bat(sql_table_schema, U_table_schema, D_sql_table);
	update_table_bat(sql_table_query, U_table_query, D_sql_table);
	update_table_bat(sql_table_type, U_table_type, D_sql_table);

	bat_destroy(sql_table_id);
	bat_destroy(sql_table_name);
	bat_destroy(sql_table_schema);
	bat_destroy(sql_table_query);
	bat_destroy(sql_table_type);
	bat_destroy(U_table_id);
	bat_destroy(U_table_name);
	bat_destroy(U_table_schema);
	bat_destroy(U_table_query);
	bat_destroy(U_table_type);
	bat_destroy(D_sql_table);
	bat_destroy(O_sql_table);
}

static void mvc_init_column( struct bm *bm )
{
	BAT *sql_column_id = mvc_bat(bm, "columns_id", TYPE_int);
	BAT *sql_column_name = mvc_bat(bm, "columns_name", TYPE_str);
	BAT *sql_column_type = mvc_bat(bm, "columns_type", TYPE_str);
	BAT *sql_column_type_digits = mvc_bat(bm, "columns_type_digits", TYPE_int);
	BAT *sql_column_type_scale = mvc_bat(bm, "columns_type_scale", TYPE_int);
	BAT *sql_column_table = mvc_bat(bm, "columns_table_id", TYPE_int);
	BAT *sql_column_default = mvc_bat(bm, "columns_default", TYPE_str);
	BAT *sql_column_null = mvc_bat(bm, "columns_null", TYPE_bit);
	BAT *sql_column_number = mvc_bat(bm, "columns_number", TYPE_int);
	BAT *U_column_id = mvc_bat(bm, "U_columns_id", TYPE_int);
	BAT *U_column_name = mvc_bat(bm, "U_columns_name", TYPE_str);
	BAT *U_column_type = mvc_bat(bm, "U_columns_type", TYPE_str);
	BAT *U_column_type_digits = mvc_bat(bm, "U_columns_type_digits", TYPE_int);
	BAT *U_column_type_scale = mvc_bat(bm, "U_columns_type_scale", TYPE_int);
	BAT *U_column_table = mvc_bat(bm, "U_columns_table_id", TYPE_int);
	BAT *U_column_default = mvc_bat(bm, "U_columns_default", TYPE_str);
	BAT *U_column_null = mvc_bat(bm, "U_columns_null", TYPE_bit);
	BAT *U_column_number = mvc_bat(bm, "U_columns_number", TYPE_int);
	BAT *D_sql_column = mvc_bat(bm, "D_columns", TYPE_oid);
	BAT *O_sql_column = mvc_bat(bm, "O_columns", TYPE_oid);

	update_table_bat(sql_column_id, U_column_id, D_sql_column);
	update_table_bat(sql_column_name, U_column_name, D_sql_column);
	update_table_bat(sql_column_type, U_column_type, D_sql_column);
	update_table_bat(sql_column_type_digits, U_column_type_digits, D_sql_column);
	update_table_bat(sql_column_type_scale, U_column_type_scale, D_sql_column);
	update_table_bat(sql_column_table, U_column_table, D_sql_column);
	update_table_bat(sql_column_default, U_column_default, D_sql_column);
	update_table_bat(sql_column_null, U_column_null, D_sql_column);
	update_table_bat(sql_column_number, U_column_number, D_sql_column);

	bat_destroy(sql_column_id);
	bat_destroy(sql_column_name);
	bat_destroy(sql_column_type);
	bat_destroy(sql_column_type_digits);
	bat_destroy(sql_column_type_scale);
	bat_destroy(sql_column_table);
	bat_destroy(sql_column_default);
	bat_destroy(sql_column_null);
	bat_destroy(sql_column_number);
	bat_destroy(U_column_id);
	bat_destroy(U_column_name);
	bat_destroy(U_column_type);
	bat_destroy(U_column_type_digits);
	bat_destroy(U_column_type_scale);
	bat_destroy(U_column_table);
	bat_destroy(U_column_default);
	bat_destroy(U_column_null);
	bat_destroy(U_column_number);
	bat_destroy(D_sql_column);
	bat_destroy(O_sql_column);

}


static void mvc_init_key( struct bm *bm )
{
	BAT *key_id = mvc_bat(bm, "keys_id", TYPE_int);
	BAT *key_table = mvc_bat(bm, "keys_table_id", TYPE_int);
	BAT *key_tpe = mvc_bat(bm, "keys_type", TYPE_int);
	BAT *key_name = mvc_bat(bm, "keys_name", TYPE_str);
	BAT *key_rkey = mvc_bat(bm, "keys_rkey", TYPE_int);
	BAT *U_key_id = mvc_bat(bm, "U_keys_id", TYPE_int);
	BAT *U_key_table = mvc_bat(bm, "U_keys_table_id", TYPE_int);
	BAT *U_key_tpe = mvc_bat(bm, "U_keys_type", TYPE_str);
	BAT *U_key_name = mvc_bat(bm, "U_keys_name", TYPE_int);
	BAT *U_key_rkey = mvc_bat(bm, "U_keys_rkey", TYPE_int);
	BAT *D_key = mvc_bat(bm, "D_keys", TYPE_oid);
	BAT *O_key = mvc_bat(bm, "O_keys", TYPE_oid);

	BAT *kc_id = mvc_bat(bm, "keycolumns_id", TYPE_int);
	BAT *kc_col = mvc_bat(bm, "keycolumns_column", TYPE_str);
	BAT *kc_trunc = mvc_bat(bm, "keycolumns_trunc", TYPE_int);
	BAT *kc_nr = mvc_bat(bm, "keycolumns_nr", TYPE_int);
	BAT *U_kc_id = mvc_bat(bm, "U_keycolumns_id", TYPE_int);
	BAT *U_kc_col = mvc_bat(bm, "U_keycolumns_column", TYPE_str);
	BAT *U_kc_trunc = mvc_bat(bm, "U_keycolumns_trunc", TYPE_int);
	BAT *U_kc_nr = mvc_bat(bm, "U_keycolumns_nr", TYPE_int);
	BAT *D_kc = mvc_bat(bm, "D_keycolumns", TYPE_oid);
	BAT *O_kc = mvc_bat(bm, "O_keycolumns", TYPE_oid);

	update_table_bat(key_id, U_key_id, D_key);
	update_table_bat(key_table, U_key_table, D_key);
	update_table_bat(key_tpe, U_key_tpe, D_key);
	update_table_bat(key_name, U_key_name, D_key);
	update_table_bat(key_rkey, U_key_rkey, D_key);
	/* key_updaterule = mvc_bat(bm, "keys_updaterule", TYPE_int); */
	/* key_deleterule = mvc_bat(bm, "keys_deleterule", TYPE_int); */
	/* key_deferrability = mvc_bat(bm, "keys_deferrability", TYPE_int); */

	update_table_bat(kc_id, U_kc_id, D_kc);
	update_table_bat(kc_col, U_kc_col, D_kc);
	update_table_bat(kc_trunc, U_kc_trunc, D_kc);
	update_table_bat(kc_nr, U_kc_nr, D_kc);

	bat_destroy(key_id);
	bat_destroy(key_table);
	bat_destroy(key_tpe);
	bat_destroy(key_name);
	bat_destroy(key_rkey);
	bat_destroy(U_key_id);
	bat_destroy(U_key_table);
	bat_destroy(U_key_tpe);
	bat_destroy(U_key_name);
	bat_destroy(U_key_rkey);
	bat_destroy(D_key);
	bat_destroy(O_key);

	bat_destroy(kc_id);
	bat_destroy(kc_col);
	bat_destroy(kc_trunc);
	bat_destroy(kc_nr);
	bat_destroy(U_kc_id);
	bat_destroy(U_kc_col);
	bat_destroy(U_kc_trunc);
	bat_destroy(U_kc_nr);
	bat_destroy(D_kc);
	bat_destroy(O_kc);
}

static void mvc_init_type( struct bm *bm )
{
	node *n = NULL;

	BAT *type_sqlname = mvc_bat(bm, "types_sqlname", TYPE_str);
	BAT *type_digits = mvc_bat(bm, "types_digits", TYPE_int);
	BAT *type_scale = mvc_bat(bm, "types_scale", TYPE_int);
        BAT *type_radix = mvc_bat(bm, "types_radix", TYPE_int);
	BAT *type_systemname = mvc_bat(bm, "types_systemname", TYPE_str);
	BAT *U_type_sqlname = mvc_bat(bm, "U_types_sqlname", TYPE_str);
	BAT *U_type_digits = mvc_bat(bm, "U_types_digits", TYPE_int);
	BAT *U_type_scale = mvc_bat(bm, "U_types_scale", TYPE_int);
        BAT *U_type_radix = mvc_bat(bm, "U_types_radix", TYPE_int);
	BAT *U_type_systemname = mvc_bat(bm, "U_types_systemname", TYPE_str);
	BAT *D_type = mvc_bat(bm, "D_types", TYPE_oid);
	BAT *O_type = mvc_bat(bm, "O_types", TYPE_oid);

	for (n = types->h; n; n = n->next) {
		oid nil = oid_nil;
		sql_type *t = n->data;

		BUNins(type_sqlname, &nil, t->sqlname);
		BUNins(type_digits, &nil, &t->digits);
		BUNins(type_scale, &nil, &t->scale);
                BUNins(type_radix, &nil, &t->radix);
		BUNins(type_systemname, &nil, t->name);
	}

	bat_destroy(type_sqlname);
	bat_destroy(type_digits);
	bat_destroy(type_scale);
	bat_destroy(type_radix);
	bat_destroy(type_systemname);
	bat_destroy(U_type_sqlname);
	bat_destroy(U_type_digits);
	bat_destroy(U_type_scale);
        bat_destroy(U_type_radix);
	bat_destroy(U_type_systemname);
	bat_destroy(D_type);
	bat_destroy(O_type);
}

void mvc_init(int debug)
{
        struct bm *bm = NULL;
        char *logdir = GDKgetenv("sql_logdir");
        char *dbname = GDKgetenv("gdk_dbname");

        assert(logdir && dbname);

        mvc_debug = debug;
        if (mvc_debug)
                fprintf(stderr, "mvc_init logdir %s%c%s\n", logdir, DIR_SEP, dbname);

        parser_init(debug);

        bm = bm_create(debug);
        logger = logger_create(mvc_debug, logdir, dbname, bm);

	mvc_init_schema(bm);
	mvc_init_table(bm);
	mvc_init_column(bm);
	mvc_init_key(bm);
	mvc_init_type(bm);

	mvc_lock = MT_create_lock();

	MT_set_lock(mvc_lock, "mvc_init");

	gtrans = load_trans(bm);

	MT_unset_lock(mvc_lock, "mvc_init");

	if (!find_schema(gtrans, "sys")){
		sql_schema *s;
		sql_table *t;
		mvc *m = mvc_create(mvc_debug);

		s = bootstrap_create_schema(m, "sys", "sqladmin");
		t = bootstrap_create_table (m, s, "schemas", tt_system);
		bootstrap_create_column(m, t, "id", "MEDIUMINT",0,0,0);
		bootstrap_create_column(m, t, "name", "VARCHAR",0,0,1);
		bootstrap_create_column(m, t, "authorization", "VARCHAR",0,0,2);

		t = bootstrap_create_table(m, s, "tables", tt_system);
		bootstrap_create_column(m, t, "id", "MEDIUMINT",0,0,0);
		bootstrap_create_column(m, t, "name", "VARCHAR",0,0,1);
		bootstrap_create_column(m, t, "schema_id", "MEDIUMINT",0,0,2);
		bootstrap_create_column(m, t, "query", "VARCHAR",0,0,3);
		bootstrap_create_column(m, t, "type", "MEDIUMINT",0,0,4);

		t = bootstrap_create_table(m, s, "columns", tt_system);
		bootstrap_create_column(m, t, "id", "MEDIUMINT", 0, 0, 0);
		bootstrap_create_column(m, t, "name", "VARCHAR", 0, 0, 1);
		bootstrap_create_column(m, t, "type", "VARCHAR", 0, 0, 2);
		bootstrap_create_column(m, t, "type_digits", "MEDIUMINT", 0, 0, 3);
		bootstrap_create_column(m, t, "type_scale", "MEDIUMINT", 0, 0,4);
		bootstrap_create_column(m, t, "table_id", "MEDIUMINT", 0, 0,5);
		bootstrap_create_column(m, t, "default", "VARCHAR", 0, 0, 6);
		bootstrap_create_column(m, t, "null", "BOOL", 0, 0, 7);
		bootstrap_create_column(m, t, "number", "MEDIUMINT", 0, 0, 8);

		t = bootstrap_create_table(m, s, "keys", tt_system);
		bootstrap_create_column(m, t, "id", "MEDIUMINT",0,0, 0);
		bootstrap_create_column(m, t, "table_id", "MEDIUMINT",0,0, 1);
		bootstrap_create_column(m, t, "type", "MEDIUMINT",0,0, 2);
		bootstrap_create_column(m, t, "name", "MEDIUMINT",0,0, 3);
		bootstrap_create_column(m, t, "rkey", "MEDIUMINT",0,0, 4);

		t = bootstrap_create_table(m, s, "keycolumns", tt_system);
		bootstrap_create_column(m, t, "id", "MEDIUMINT",0,0, 0);
		bootstrap_create_column(m, t, "column", "VARCHAR",0,0, 1);
		bootstrap_create_column(m, t, "trunc", "MEDIUMINT",0,0, 2);
		bootstrap_create_column(m, t, "nr", "MEDIUMINT",0,0, 3);

		t = bootstrap_create_table (m, s, "types", tt_system);
		bootstrap_create_column(m, t, "sqlname", "VARCHAR",0,0, 0);
		bootstrap_create_column(m, t, "digits", "MEDIUMINT",0,0, 1);
		bootstrap_create_column(m, t, "scale", "MEDIUMINT",0,0, 2);
                bootstrap_create_column(m, t, "radix", "MEDIUMINT",0,0, 2);

		bootstrap_create_column(m, t, "systemname", "VARCHAR",0,0, 3);

		/* now the authorisation related tables */
		t = mvc_create_table(m, s, "users", tt_system );
		mvc_create_column(m, t, "name", "VARCHAR",0,0, 0 );
		mvc_create_column(m, t, "passwd", "VARCHAR",0,0, 1 );
		mvc_create_column(m, t, "fullname", "VARCHAR",0,0, 2 );
		mvc_create_column(m, t, "default_schema", "MEDIUMINT",0,0, 3 );

		t = mvc_create_table(m, s, "auths", tt_system );
		mvc_create_column(m, t, "id", "MEDIUMINT",0,0, 0 );
		mvc_create_column(m, t, "name", "VARCHAR",0,0, 1 );
		mvc_create_column(m, t, "grantor", "MEDIUMINT",0,0, 2 );
		mvc_create_column(m, t, "privileges", "MEDIUMINT",0,0, 3 );

		t = mvc_create_table(m, s, "user_role", tt_system );
		mvc_create_column(m, t, "login_id", "MEDIUMINT",0,0, 0 );
		mvc_create_column(m, t, "role_id", "MEDIUMINT",0,0, 1 );

		t = mvc_create_table(m, s, "table_privileges", tt_system );
		mvc_create_column(m, t, "table_id", "MEDIUMINT",0,0, 0 );
		mvc_create_column(m, t, "auth_id", "MEDIUMINT",0,0, 1 );
		mvc_create_column(m, t, "privileges", "MEDIUMINT",0,0, 2 );

		t = mvc_create_table(m, s, "column_privileges", tt_system );
		mvc_create_column(m, t, "column_id", "MEDIUMINT",0,0, 0 );
		mvc_create_column(m, t, "auth_id", "MEDIUMINT",0,0, 1 );
		mvc_create_column(m, t, "privileges", "MEDIUMINT",0,0, 2 );

                /* add monetdb user */
                sql_create_user(m, "monetdb", "monetdb", "MonetDB Admin", "sys", 0);
		mvc_create_schema(m, "default-schema", "sqladmin");

		m->trans->schema = s;
		mvc_commit(m, 0, NULL);
		mvc_destroy(m);
	}
}

int mvc_set_user( mvc *m, char *user )
{
	BUN p;
	int res = 0;
	BAT *auth_name = BATmirror(mvc_bind(m, "sys", "auths", "name", 0 ));

	if (mvc_debug)
		fprintf(stderr, "mvc_set_user %s\n", user);

	if ((p=BUNfnd(auth_name, user)) != NULL){
		ptr lid = BUNtail(auth_name,p);
		BAT *auth_id = mvc_bind(m, "sys", "auths", "id", 0 );
		int id = *(int*)BUNtail(auth_id, BUNfnd(auth_id, lid));
		BAT *auth_priv = mvc_bind(m, "sys", "auths", "privileges", 0 );
		int priv = *(int*)BUNtail(auth_priv, BUNfnd(auth_priv, lid));
		m->user_id = m->role_id = id;
		m->user = _strdup(user);
		m->privileges = priv;
		res = 1;
	}
	bat_destroy(auth_name);
	return res;
}

char *mvc_login(mvc *m, char *user, char *passwd)
{
	char *schema = NULL;
	BAT *name_user = BATmirror(mvc_bind(m, "sys", "users", "name", 0 ));
	BUN p;

	if (mvc_debug)
		fprintf(stderr, "mvc_login %s\n", user);

	if ((p=BUNfnd(name_user, user)) != NULL){
		ptr userid = BUNtail(name_user, p);
		BAT *user_pwd = mvc_bind(m, "sys", "users", "passwd", 0 );
		char *pwd = BUNtail(user_pwd, BUNfnd(user_pwd, userid));
		
		if (strcmp(passwd, pwd) == 0){
			BAT *user_ds = mvc_bind(m, "sys", "users", "default_schema", 0 );
			BAT *id_schema = BATmirror(mvc_bind(m, "sys", "schemas", "id", 0 ));
			BAT *schema_name = mvc_bind(m, "sys", "schemas", "name", 0 );
			ptr schema_id = BUNtail(user_ds, BUNfnd(user_ds, userid)); 
			ptr lid = BUNtail(id_schema,BUNfnd(id_schema, schema_id));
			schema = BUNtail(schema_name,BUNfnd(schema_name, lid));
			if (mvc_set_user(m, user)){ 
				schema = _strdup(schema);
			} else { /* only set schema if user is found */
				schema = NULL;
			}
			bat_destroy(id_schema);
			bat_destroy(schema_name);
			bat_destroy(user_ds);
		}
		bat_destroy(user_pwd);
	}
	bat_destroy(name_user);

	if (!schema)
		return NULL;

	m->trans->schema = find_schema(m->trans, schema);
	if (!m->trans->schema) {
		_DELETE(schema);
		return NULL;
	}
	return schema;
}


void mvc_exit()
{

	if (mvc_debug)
		fprintf(stderr, "mvc_exit\n");

	logger_exit(logger); 
	logger_destroy(logger); 
	parser_exit();

	trans_destroy(gtrans);
}

mvc *mvc_create(int debug)
{
	mvc *m = NEW(mvc);

	if (debug)
		fprintf(stderr, "mvc_create\n");

	MT_set_lock(mvc_lock, "mvc_create");

	m->debug = debug;
	m->role_id = m->user_id = -1;
	m->role = m->user = NULL;
	m->privileges = 0;
	m->trans = NULL;
	m->trans = trans_dup(gtrans,NULL);
        m->status = 0;
        m->type = QPARSE;

        m->result_id = 0;
        m->results = NULL;

	MT_unset_lock(mvc_lock, "mvc_create");
	return m;
}

ssize_t mvc_status(  mvc *m ){
        int res = m->status;

        m->status = 0;
        return res;
}


int mvc_type( mvc *m ){
        int res = m->status;
        m->status = 0;
	m->type= QPARSE;
        return res;
}

static void create_key(sql_trans * ctr, sql_schema * gs, sql_table *gt, sql_key *gk )
{
	char keychar = (gk->type==fkey)?'F':'K';
	char bname[BUFSIZ];
	BAT *b = bm_lbid2bat( ctr->bm, gk->bid );

	snprintf(bname, BUFSIZ, "%c_%s_%s", keychar, gt->name, gk->name );
	gk->bid = log_bat_persists(logger, b, bname); 
	bat_destroy(b);
}

static void create_column(sql_trans * ctr, sql_schema * gs, sql_table *gt, sql_column *gc )
{
	char bname[BUFSIZ];
	BAT *b = bm_lbid2bat( ctr->bm, gc->bid);
	BAT *u = bm_lbid2bat( ctr->bm, gc->ubid);

	gc->rtime = gs->rtime;
	gc->wtime = gs->wtime;

	snprintf(bname, BUFSIZ, "%s_%s", gt->name, gc->name );
	gc->bid = log_bat_persists(logger, b, bname); 
	bat_destroy(b);

	snprintf(bname, BUFSIZ, "U_%s_%s", gt->name, gc->name );
	gc->ubid = log_bat_persists(logger, u, bname); 
	bat_destroy(u);
}

static void rollforward_table(sql_trans * ctr, sql_schema * gs, sql_table * ct)
{
	sql_trans *gtr = ctr->parent;
	sql_table *gt = find_table(gs, ct->name);
	node *n, *m;

	assert(list_length(gt->columns) == list_length(ct->columns));

	n = ct->columns->h;
	m = gt->columns->h;
	if (n && m) {
		BAT *db = bm_lbid2bat( ctr->bm, ct->dbid );
		BAT *ob = bm_lbid2bat( ctr->bm, ct->obid );

                gt->rtime = ct->rtime;
                gt->wtime = ct->wtime;

		do { 
			sql_column *cc = n->data;
			sql_column *oc = m->data;

			BAT *ins = bm_lbid2bat( ctr->bm, cc->bid);
			BAT *ups = bm_lbid2bat( ctr->bm, cc->ubid);
			BAT *gob = bind_bat(gtr, oc, 1);

                	oc->rtime = cc->rtime;
                	oc->wtime = cc->wtime;

			/* forward inserts */
			if (ins->batInserted < BUNlast(ins)) {
				void_insert_delta(gob, ins);
				log_bat(logger, oc->bid, gob);
			}
			bat_destroy(ins);

			if (ups->batInserted < BUNlast(ups)) {
				BAT *oub = bind_ubat(gtr, oc, 1);
				void_insert_delta(oub, ups);
				void_replace_delta(gob, ups);
				log_bat(logger, oc->ubid, oub);
				bat_destroy(oub);
			}

			if (db->batInserted < BUNlast(db)) {
				void_delete_bat(gob, db, 1);
			}

			bat_destroy(gob);
			bat_destroy(ups);

			n = n->next;
			m = m->next;
		} while (n && m);

		if (db->batInserted < BUNlast(db)) {
			BAT *odb = bind_dbat(gtr, gt, 1);
			void_insert_delta(odb, db);
			log_bat(logger, gt->dbid, odb);
			bat_destroy(odb);
		}
		bat_destroy(db);

		if (ob->batInserted < BUNlast(ob)) {
			BAT *oob = bind_obat(gtr, gt, 1);
			void_insert_delta(oob, ob);
			log_bat(logger, gt->obid, oob);
			bat_destroy(oob);
		}
		bat_destroy(ob);
	}
	for(; n; n = n->next){
		sql_column *c = n->data;
		create_column( ctr, gs, gt, column_dup(gt, c) );
	}
	if (ct->nkey){
		for (n = ct->keys->h; n->data != ct->nkey; n = n->next);

		for (; n; n = n->next) {
			sql_key *ck = n->data;
			create_key( ctr, gs, gt, key_dup(ctr,ck,gt) );
		}
	}
}
static void create_keys(sql_trans * tr, sql_schema * s, sql_table * t)
{
	node *n;

	if (t->keys) for (n = t->keys->h; n; n = n->next) {
		sql_key *k = n->data;
		create_key( tr, s, t, k);
	}
}

static void create_columns(sql_trans * tr, sql_schema * s, sql_table * t)
{
	node *n;

	for (n = t->columns->h; n; n = n->next) {
		sql_column *c = n->data;
		create_column( tr, s, t, c);
	}
}

static void drop_keys(sql_trans * tr, sql_table * t)
{
	node *n;

	if (t->keys) for (n = t->keys->h; n; n = n->next) {
		sql_key *k = n->data;

		if (k->bid){
			log_bat_transient(logger, k->bid); 
		}
	}
}

static void drop_columns(sql_trans * tr, sql_table * t)
{
	node *n;

	for (n = t->columns->h; n; n = n->next) {
		sql_column *c = n->data;

		log_bat_transient(logger, c->bid); 
		log_bat_transient(logger, c->ubid); 
	}
}

static void mvc_forward_create_table(sql_trans * tr, sql_schema * ns,
				     sql_table * nt)
{
	nt->wtime = ns->wtime;
	nt->rtime = ns->rtime;

	if (nt->type != tt_view){
		char name[BUFSIZ];
		BAT *o = bm_lbid2bat(tr->bm, nt->obid);
		BAT *d = bm_lbid2bat(tr->bm, nt->dbid);

		snprintf(name, BUFSIZ, "O_%s", nt->name );
		nt->obid = log_bat_persists(logger, o, name); 
		bat_destroy(o);

		snprintf(name, BUFSIZ, "D_%s", nt->name );
		nt->dbid = log_bat_persists(logger, d, name); 
		bat_destroy(d);

		create_columns(tr, ns, nt);
		create_keys(tr, ns, nt);
	}
}

static void rollforward_tables(sql_trans *tr, sql_schema * s)
{
	sql_trans *gtr = tr->parent;
	node *n;
	sql_schema *os = find_schema(gtr, s->name);

	/* delete the dropped tables */
	if (s->dtables) for (n = s->dtables->h; n; n = n->next) {	
		sql_table *t = n->data;
		sql_table *ot = find_table(os, t->name);

		if (t->type != tt_view){
			log_bat_transient(logger, t->obid); 
			log_bat_transient(logger, t->dbid); 
		} 

		drop_keys(tr, t);
		drop_columns(tr, t);

		list_remove_data(os->tables, ot);
		table_destroy(ot);
	}
	/* changes to the existing tables */
	for (n = s->tables->h; n && n->data != s->ntable; n = n->next) {	
		sql_table *t = n->data;
		
		if (t->wtime && t->flag == TR_OLD)
			rollforward_table(tr, os, t);
	}
	/* add the new tables */
	for (; n; n = n->next) {	
		sql_table *nt, *ot = n->data;

		if (ot->type != tt_temp && ot->type != tt_session){
			mvc_forward_create_table(tr, os, nt = table_dup(gtr, os, ot));
			list_append(os->tables, nt);
		}
	}
}

static void rollforward_schemas(sql_trans *tr)
{
	/* bm_rollforward(tr->bm, tr->parent->bm); */
	node *n;

	/* delete the dropped schemas */
	if (tr->dschemas) for (n = tr->dschemas->h; n; n = n->next) {	
		sql_schema *s = n->data;
		sql_schema *os = find_schema(tr->parent, s->name);

		/* TODO move to the removed list if not top trans */
		list_remove_data(tr->parent->schemas, os);
		schema_destroy(os);
	}
	/* changes to the existing schemas */
	for (n = tr->schemas->h; n && n->data != tr->nschema; n = n->next) {	
		sql_schema *s = n->data;
		if (s->flag == TR_OLD)
			rollforward_tables(tr, s);
	}
	/* add the new schemas */
	for (; n; n = n->next) {	
		sql_schema *ns = schema_dup(tr, n->data);

		if (tr->parent == gtrans){
			node *m;

			/* add the new tables */
			for (m = ns->tables->h; m; m = m->next) {
				sql_table *nt = m->data;
				mvc_forward_create_table(tr, ns, nt);
			}
			list_append(tr->parent->schemas, ns);
		}
	}
	list_destroy(tr->keys);
	tr->keys = list_create(NULL);
}


static int validate_tables(sql_schema * s, sql_schema * os)
{
	/* bm_validate(tr->bm, tr->parent->bm); */
	node *n, *o, *p;

	for (n = s->tables->h; n; n = n->next) {
		sql_table *t = n->data;
		sql_table *ot = find_table(os, t->name);

		if (ot || (t->wtime == 0 && t->rtime == 0)) {
			for (o = t->columns->h, p = ot->columns->h;
			     o && p; o = o->next, p = p->next) {
				sql_column *c = o->data;
				sql_column *oc = p->data;
				/* t wrote, ie. check read and write time */
				/* read or write after t's write */
				if (c->wtime &&
				    (c->wtime < oc->rtime
				     || c->wtime < oc->wtime)) {
					return 0;
				}
				/* commited write before t's read */
				if (c->rtime && c->rtime < oc->wtime) {
					return 0;
				}
			}
		}
	}
	return 1;
}

static int validate(sql_trans *tr)
{
	node *n;
	/* depends on the iso level */

	/* since we protect usage through private copies both the iso levels
	   read uncommited and read commited always succeed.
	 */
	if (tr->level == ISO_READ_UNCOMMITED
	    || tr->level == ISO_READ_COMMITED)
		return 1;

	/* If only 'inserts' occurred on the read bats the repeatable reads
	   iso level can continue */

	/* the hard case */
	for (n = tr->schemas->h; n; n = n->next) {
		sql_schema *s = n->data;
		sql_schema *os = find_schema(tr->parent, s->name);
		if (os || (s->wtime == 0 && s->rtime == 0)) {
                        if (!validate_tables(s, os)) return 0;
                }

	}
	return 1;
}

/* 
 * mvc_commit implements the last two phases (out of 3) of 
 * optimistic concurrency control. The first phase, ie. read phase 
 * starts when the transaction is started (aka with any sql statement) 
 * and ends with mvc_commit. The validation phase checks the timestamps 
 * to see if a commit could succeed. Then the write phase makes 
 * the changes global.
 *
 * Commit will first forward the changes to the schema, ie.
 * leaving out the temp tables and adding the new tables directly.
 * 
 * After that the changes to existing tables are forwarded.
 */

int mvc_commit(mvc * m, int chain, char *name)
{
	char *schema = NULL;
	sql_trans *tr = m->trans;
	int level = (chain)?tr->level:ISO_SERIALIZABLE;
	int res = -1;

	assert(tr);
	if (m->debug)
		fprintf(stderr, "mvc_commit\n");


	/* savepoint then simply make a copy of the current transaction */
	if (name && name[0] != '\0'){
		if (m->debug)
			fprintf(stderr, "mvc_savepoint\n");
		schema = _strdup(m->trans->schema->name);
		assert(schema);
		m->trans = trans_dup(m->trans, name);
		m->trans->schema = find_schema(m->trans, schema);
		_DELETE(schema);
		return 0;
	}

	/* if there is nothing to commit reuse the current transaction */
	if (tr->wtime == 0) {
		if (m->debug)
			fprintf(stderr, "no changes\n");
		tr->stime = timestamp();
		return 0;
	}

	MT_set_lock(mvc_lock, "mvc_commit");

	/* validation phase */
	if (validate(tr)) {
		/* write phase */
		if (m->debug)
			fprintf(stderr, "forwarding changes\n");
		log_tstart(logger);
		rollforward_schemas(tr);
		log_tend(logger);
		if (m->debug)
			fprintf(stderr, "done forwarding changes\n");
		res = QPARSE;
	}

	MT_unset_lock(mvc_lock, "mvc_commit");

	tr = m->trans;
	assert(tr->schema);
	schema = _strdup(tr->schema->name);
	assert(schema);
	while(tr->parent) 
		tr = trans_destroy(tr);

	m->trans = trans_dup(tr,NULL);
	m->trans->level = level;
	m->type = res;
	m->trans->schema = find_schema(m->trans, schema);
	_DELETE(schema);
	return res;
}

int mvc_rollback(mvc * m, int chain, char *name)
{
	int res = 0;
	int level = (chain)?m->trans->level:ISO_SERIALIZABLE;
	sql_trans *tr = m->trans;

	if (m->debug)
		fprintf(stderr, "mvc_rollback\n");

	if (name && name[0] != '\0'){
		while(tr->name && strcmp(tr->name,name) != 0)
	       		tr = trans_destroy(tr);
		m->trans = tr; /* restart at savepoint */
	} else {
		while(tr->parent) 
	       		tr = trans_destroy(tr);
		m->trans = trans_dup(tr,NULL);
	}
	m->trans->level = level;
	m->type = QPARSE;
	return res;
}

/* release all savepoints up including the given named savepoint 
 * but keep the current changes.
 * */
int mvc_release(mvc * m, char *name)
{
        int res = QPARSE;
        sql_trans *tr = m->trans;
        sql_trans *p = tr->parent;

        while(p->name && strcmp(p->name, name) != 0)
                p = trans_destroy(p);

        tr->parent = p;
        m->trans = tr; /* restart at savepoint */
        m->type = res;
        return res;
}

int mvc_set_iso_level(mvc * m, int level)
{
	int res = mvc_commit(m,1,NULL);
	m->trans->level = level;
	m->type= res;
	return res;
}

static void clean_table_result(res_table *t)
{
        int i;
        for(i=0; i<t->nr_cols; i++){
                res_col *c = t->cols+i;
                if (c->b){
                        BBPtransient(c->b, FALSE);
                } else {
                        _DELETE(c->p);
                }
                _DELETE(c->name);
        }
        if (t->order)
                BBPtransient(t->order, FALSE);
        _DELETE(t->cols);
        _DELETE(t);
}

static void clean_result( mvc *m, res_table *t)
{
        res_table *r = m->results;
        if (r == t){
                m->results = t->next;
        } else {
                for( ; r; r = r->next){
                        if (r->next == t){
                                r->next = t->next;
                                break;
                        }
                }
        }
        clean_table_result(t);
}

void mvc_destroy(mvc * m)
{
	sql_trans *tr;

        if (m->results){
                res_table *r = m->results, *t;
                for(t=r; t; t=r){
                        r = t->next;
                        clean_table_result(t);
                }
        }
        tr = m->trans;
        while(tr->parent) tr = trans_destroy(tr);
        _DELETE(m);
}

BAT *mvc_bind(mvc * m, char *sname, char *tname, char *cname, int access)
{
	sql_trans *tr = m->trans;
	BAT *b = NULL;
	sql_schema *s = find_schema(tr, sname);
	sql_table *t = find_table(s, tname);
	sql_column *c;

	if (m->debug)
		fprintf(stderr, "mvc_bind %s.%s(%d)\n", tname, cname, access);

	/* TODO check for access */

	assert(t);

	c = find_column(t, cname);
	b = bind_bat(tr, c, access);

	c->rtime = t->rtime = s->rtime = tr->rtime = tr->stime;
	assert(b->htype == TYPE_void && b->hseqbase == 0);
	return b;
}

BAT *mvc_bind_ubat(mvc * m, char *sname, char *tname, char *cname, int access )
{
	sql_trans *tr = m->trans;
	BAT *b = NULL;
	sql_schema *s = find_schema(tr, sname);
	sql_table *t = find_table(s, tname);
	sql_column *c;

	if (m->debug)
		fprintf(stderr, "mvc_bind_ubat %s.%s\n", tname, cname);

	/* TODO check for access */

	assert(t);

	c = find_column(t, cname);
	b = bind_ubat(tr, c, access);

	c->rtime = t->rtime = tr->rtime = tr->stime;
	return b;
}

BAT *mvc_bind_obat(mvc * m, char *sname, char *tname, int access )
{
	sql_trans *tr = m->trans;
	BAT *b = NULL;
	sql_schema *s = find_schema(tr, sname);
	sql_table *t = find_table(s, tname);

	if (m->debug)
		fprintf(stderr, "mvc_bind_obat %s.oid\n", tname );

	/* TODO check for access */

	assert(t);
	b = bind_obat(tr, t, access);

	t->rtime = tr->rtime = tr->stime;
	assert(b->htype == TYPE_void && b->hseqbase == 0);
	return b;
}

BAT *mvc_bind_dbat(mvc * m, char *sname, char *tname, int access )
{
	sql_trans *tr = m->trans;
	BAT *b = NULL;
	sql_schema *s = find_schema(tr, sname);
	sql_table *t = find_table(s, tname);

	if (m->debug)
		fprintf(stderr, "mvc_bind_dbat %s.deletes\n", tname );

	/* TODO check for access */

	assert(t);
	b = bind_dbat(tr, t, access);

	t->rtime = tr->rtime = tr->stime;
	assert(b->htype == TYPE_void && b->hseqbase == 0);
	return b;
}

BAT *mvc_bind_kbat(mvc * m, char *sname, char *tname, char *kname, int access )
{
	sql_trans *tr = m->trans;
	BAT *b = NULL;
	sql_schema *s = find_schema(tr, sname);
	sql_table *t = find_table(s, tname);
	sql_key *k = find_key(t, kname);

	if (m->debug)
		fprintf(stderr, "mvc_bind_kbat %s.%s\n", tname, kname );

	/* TODO check for access */

	assert(t);
	b = bind_key(tr, k, access);

	t->rtime = tr->rtime = tr->stime;
	assert(b->htype == TYPE_void && b->hseqbase == 0);
	return b;
}

sql_schema *mvc_bind_schema(mvc * m, char *sname )
{
	sql_trans *tr = m->trans;
	sql_schema *s = find_schema(tr, sname);
	if (!s)
		return NULL;
	s->rtime = tr->rtime;

	if (m->debug)
		fprintf(stderr, "mvc_bind_schema %s\n", sname );

	return s;
}

sql_table *mvc_bind_table(mvc * m, sql_schema *s, char *tname )
{
	sql_table *t = find_table(s, tname);
	if (!t)
		return NULL;
	t->rtime = s->rtime;

	if (m->debug)
		fprintf(stderr, "mvc_bind_table %s.%s\n", s->name, tname );

	return t;
}

sql_column *mvc_bind_column(mvc * m, sql_table * t, char *cname )
{
	sql_column *c = find_column(t, cname);
	if (!c)
		return NULL;
	c->rtime = t->rtime;

	if (m->debug)
		fprintf(stderr, "mvc_bind_column %s.%s\n", t->name, cname );

	return c;
}


sql_key *mvc_bind_key(mvc * m, sql_table * t, char *kname )
{
	sql_key *k = find_key(t, kname);
	if (!k)
		return NULL;
	k->rtime = t->rtime;

	if (m->debug)
		fprintf(stderr, "mvc_bind_key %s.%s\n", t->name, kname );

	return k;
}

static void sys_drop_kc(sql_trans *tr, sql_key *k, sql_kc *kc ){
	sql_table *syskc = find_table(find_schema(tr, "sys"), "keycolumns");
	BAT *b, *r;
	oid rid = 0;

	/* drop from sys keys */
	b = bind_bat(tr, find_column(syskc, "id"), 1);
	r = BATmirror(b);
	rid = *(oid*)BUNtail(r, BUNfnd(r, (ptr) & k->id ));
	bun_inplace(b, rid, ATOMnilptr(b->ttype)); BBPunfix(b->batCacheid);
	b = bind_bat(tr, find_column(syskc, "column"), 1);
	bun_inplace(b, rid, ATOMnilptr(b->ttype)); BBPunfix(b->batCacheid);
	b = bind_bat(tr, find_column(syskc, "trunc"), 1);
	bun_inplace(b, rid, ATOMnilptr(b->ttype)); BBPunfix(b->batCacheid);
	b = bind_bat(tr, find_column(syskc, "nr"), 1);
	bun_inplace(b, rid, ATOMnilptr(b->ttype)); BBPunfix(b->batCacheid);
	b = bind_dbat(tr, syskc, 1);
	BUNins(b, ATOMnilptr(TYPE_void), (ptr) & rid); BBPunfix(b->batCacheid);

	syskc->wtime = tr->stime;
}

static void sys_drop_key(sql_trans *tr, sql_key *k ){
	node *n;
	sql_table *syskey = find_table(find_schema(tr, "sys"), "keys");
	BAT *b, *r;
	oid rid = 0;

	/* drop from sys keys */
	b = bind_bat(tr, find_column(syskey, "id"), 1);
	r = BATmirror(b);
	rid = *(oid*)BUNtail(r, BUNfnd(r, (ptr) & k->id ));
	bun_inplace(b, rid, ATOMnilptr(b->ttype)); BBPunfix(b->batCacheid);
	b = bind_bat(tr, find_column(syskey, "table_id"), 1);
	bun_inplace(b, rid, ATOMnilptr(b->ttype)); BBPunfix(b->batCacheid);
	b = bind_bat(tr, find_column(syskey, "name"), 1);
	bun_inplace(b, rid, ATOMnilptr(b->ttype)); BBPunfix(b->batCacheid);
	b = bind_bat(tr, find_column(syskey, "rkey"), 1);
	bun_inplace(b, rid, ATOMnilptr(b->ttype)); BBPunfix(b->batCacheid);
	b = bind_dbat(tr, syskey, 1);
	BUNins(b, ATOMnilptr(TYPE_void), (ptr) & rid); BBPunfix(b->batCacheid);

	for (n = k->columns->h; n; n = n->next) {
		sql_kc *kc = n->data;
		sys_drop_kc(tr, k, kc);
	}
	syskey->wtime = tr->stime;
}

static void sys_drop_column(sql_trans *tr, sql_column *col ){
	sql_table *syscolumn = find_table(find_schema(tr, "sys"), "columns");
	BAT *b, *r;
	oid rid = 0;

	/* drop from sys columns */
	b = bind_bat(tr, find_column(syscolumn, "id"), 1);
	r = BATmirror(b);
	rid = *(oid*)BUNtail(r, BUNfnd(r, (ptr) & col->id ));
	bun_inplace(b, rid, ATOMnilptr(b->ttype)); BBPunfix(b->batCacheid);
	b = bind_bat(tr, find_column(syscolumn, "table_id"), 1);
	bun_inplace(b, rid, ATOMnilptr(b->ttype)); BBPunfix(b->batCacheid);
	b = bind_bat(tr, find_column(syscolumn, "name"), 1);
	bun_inplace(b, rid, ATOMnilptr(b->ttype)); BBPunfix(b->batCacheid);
	b = bind_bat(tr, find_column(syscolumn, "type"), 1);
	bun_inplace(b, rid, ATOMnilptr(b->ttype)); BBPunfix(b->batCacheid);
	b = bind_bat(tr, find_column(syscolumn, "type_digits"), 1);
	bun_inplace(b, rid, ATOMnilptr(b->ttype)); BBPunfix(b->batCacheid);
	b = bind_bat(tr, find_column(syscolumn, "type_scale"), 1);
	bun_inplace(b, rid, ATOMnilptr(b->ttype)); BBPunfix(b->batCacheid);
	b = bind_bat(tr, find_column(syscolumn, "default"), 1);
	bun_inplace(b, rid, ATOMnilptr(b->ttype)); BBPunfix(b->batCacheid);
	b = bind_bat(tr, find_column(syscolumn, "null"), 1);
	bun_inplace(b, rid, ATOMnilptr(b->ttype)); BBPunfix(b->batCacheid);
	b = bind_bat(tr, find_column(syscolumn, "number"), 1);
	bun_inplace(b, rid, ATOMnilptr(b->ttype)); BBPunfix(b->batCacheid);
	b = bind_dbat(tr, syscolumn, 1);
	BUNins(b, ATOMnilptr(TYPE_void), (ptr) & rid); BBPunfix(b->batCacheid);

	syscolumn->wtime = tr->stime;
}

static void sys_drop_keys(sql_trans * tr, sql_table * t)
{
	node *n;

	if (t->keys) for (n = t->keys->h; n; n = n->next) {
		sql_key *k = n->data;
		sys_drop_key(tr, k);
	}
}
static void sys_drop_columns(sql_trans * tr, sql_table * t)
{
	node *n;

	for (n = t->columns->h; n; n = n->next) {
		sql_column *c = n->data;
		sys_drop_column(tr, c);
	}
}

static void sys_drop_table(sql_trans * tr, sql_table *t)
{
	sql_table *systable = find_table(find_schema(tr, "sys"), "tables");
	BAT *b, *r;
	oid rid = 0;

	/* drop from sys tables */
	b = bind_bat(tr, find_column(systable, "id"), 1);
	r = BATmirror(b);
	rid = *(oid*)BUNtail(r, BUNfnd(r, (ptr) & t->id ));
	bun_inplace(b, rid, ATOMnilptr(b->ttype)); BBPunfix(b->batCacheid);
	b = bind_bat(tr, find_column(systable, "schema_id"), 1);
	bun_inplace(b, rid, ATOMnilptr(b->ttype)); BBPunfix(b->batCacheid);
	b = bind_bat(tr, find_column(systable, "name"), 1);
	bun_inplace(b, rid, ATOMnilptr(b->ttype)); BBPunfix(b->batCacheid);
	b = bind_bat(tr, find_column(systable, "type"), 1);
	bun_inplace(b, rid, ATOMnilptr(b->ttype)); BBPunfix(b->batCacheid);
	b = bind_bat(tr, find_column(systable, "query"), 1);
	bun_inplace(b, rid, ATOMnilptr(b->ttype)); BBPunfix(b->batCacheid);
	b = bind_dbat(tr, systable, 1);
	BUNins(b, ATOMnilptr(TYPE_void), (ptr) & rid); BBPunfix(b->batCacheid);

	sys_drop_keys(tr, t);
	if (t->type != tt_view)
		sys_drop_columns(tr, t);

	systable->wtime = tr->stime;
}

static void sys_drop_tables(sql_trans * tr, sql_schema * s)
{
	node *n;

	for (n = s->tables->h; n; n = n->next) {
		sql_table *t = n->data;

		sys_drop_table(tr, t);
	}
}


sql_schema *bootstrap_create_schema(mvc * m, char *name, char *auth)
{
	sql_trans *tr = m->trans;
	sql_schema *s = NEW(sql_schema);
	
	BAT *b;
	oid rid;

	if (m->debug)
		fprintf(stderr, "bootstrap_create_schema %s %s\n", name, auth);

	s->id = OIDnew(1);
	s->name = _strdup(name);
	s->auth = _strdup(auth);
	s->flag = TR_NEW;

	s->tables = list_create((fdestroy)&table_destroy);
	s->dtables = NULL;
	s->ntable = NULL;
	if (!tr->nschema) tr->nschema = s;
	list_append(tr->schemas, s);

	b = sys_bat(m->trans->bm, "schemas_id");
	rid = BATcount(b);
	BUNins(b, (ptr) & rid, (ptr) & s->id); BBPunfix(b->batCacheid);
	b = sys_bat(m->trans->bm, "schemas_name");
	BUNins(b, (ptr) & rid, (ptr) s->name); BBPunfix(b->batCacheid);
	b = sys_bat(m->trans->bm, "schemas_authorization");
	BUNins(b, (ptr) & rid, (ptr) s->auth); BBPunfix(b->batCacheid);

	s->wtime = tr->wtime = tr->stime;
	return s;
}

sql_schema *mvc_create_schema(mvc * m, char *name, char *auth)
{
	sql_trans *tr = m->trans;
	sql_schema *s = NEW(sql_schema);

	sql_table *sysschema = find_table(find_schema(tr, "sys"), "schemas");
	BAT *b;
	oid rid = 0;

	if (m->debug)
		fprintf(stderr, "mvc_create_schema %s %s\n", name, auth);

	s->id = OIDnew(1);
	s->name = _strdup(name);
	s->auth = _strdup(auth);
	s->flag = TR_NEW;

	s->tables = list_create((fdestroy)&table_destroy);
	s->dtables = NULL;
	s->ntable = NULL;
	if (!tr->nschema) tr->nschema = s;
	list_append(tr->schemas, s);

	b = bind_bat(tr, find_column(sysschema, "id"), 1);
	rid = BATcount(b);
	BUNins(b, (ptr) & rid, (ptr) & s->id); BBPunfix(b->batCacheid);
	b = bind_bat(tr, find_column(sysschema, "name"), 1);
	BUNins(b, (ptr) & rid, (ptr) s->name); BBPunfix(b->batCacheid);
	b = bind_bat(tr, find_column(sysschema, "authorization"), 1);
	BUNins(b, (ptr) & rid, (ptr) s->auth); BBPunfix(b->batCacheid);

	sysschema->wtime = s->wtime = tr->wtime = tr->stime;
        m->type = QCREATE;
	return s;
}

void mvc_drop_schema(mvc * m, char *sname)
{
	sql_trans *tr = m->trans;
	node *n = find_schema_node(tr, sname);
	sql_schema *s = n->data; 

	sql_table *sysschema = find_table(find_schema(tr, "sys"), "schemas");
	BAT *b;
	oid rid = 0;

	if (m->debug)
		fprintf(stderr, "mvc_drop_schema %s\n", sname);

	/* drop from sys schema */
	b = bind_bat(tr, find_column(sysschema, "id"), 1);
	rid = *(oid*)BUNhead(b, BUNfnd(BATmirror(b), (ptr) & s->id ));
	bun_inplace(b, rid, ATOMnilptr(b->ttype)); BBPunfix(b->batCacheid);
	b = bind_bat(tr, find_column(sysschema, "name"), 1);
	bun_inplace(b, rid, ATOMnilptr(b->ttype)); BBPunfix(b->batCacheid);
	b = bind_bat(tr, find_column(sysschema, "authorization"), 1);
	bun_inplace(b, rid, ATOMnilptr(b->ttype)); BBPunfix(b->batCacheid);
	b = bind_dbat(tr, sysschema, 1);
	BUNins(b, ATOMnilptr(TYPE_void), (ptr) & rid); BBPunfix(b->batCacheid);
	sys_drop_tables(tr, s);

	if (s->flag == TR_NEW) {
		if (tr->nschema == s){
			if (n->next)
				tr->nschema = n->next->data;
			else
				tr->nschema = NULL;
		}
		list_remove_data(tr->schemas, s);
		schema_destroy(s);
	} else {
		if (!tr->dschemas) 
			tr->dschemas = 
				list_create((fdestroy)&schema_destroy);
		list_move_data(tr->schemas, tr->dschemas, s);
	}
	sysschema->wtime = s->wtime = tr->wtime = tr->stime;
}

static sql_table *create_table_intern( mvc *m, char *name, int type)
{
	sql_table *t = NEW(sql_table);

	t->id = OIDnew(1);
	t->name = _strdup(name);
	t->type = type;
	t->query = NULL;
	t->flag = TR_NEW;
	t->columns = list_create((fdestroy)&column_destroy);
	t->dcolumns = NULL;
	t->ncolumn = NULL;
	t->pkey = NULL;
	t->keys = NULL;
	t->dkeys = NULL;
	t->nkey = NULL;
	t->obid = 0;
	t->dbid = 0;
	return t;
}

sql_key *mvc_create_key( mvc * m, char *sname, char *tname, char *name, int kt, BAT *columns, sql_key *rkey )
{ 
/* can only have keys between persistent tables */
	char bname[BUFSIZ];
	BUN p,q;
	int nr, cnt = BUFSIZ, neg = -1;
	sql_trans *tr = m->trans;
	sql_schema *s = find_schema(tr, sname);
	sql_table *t = find_table(s, tname);
	sql_key *nk = (kt!=fkey)?(sql_key*)NEW(sql_ukey)
				:(sql_key*)NEW(sql_fkey);
	sql_table *syskey = find_table(find_schema(tr, "sys"), "keys");
	sql_table *syskc = find_table(find_schema(tr, "sys"), "keycolumns");
	BAT *b;
	oid rid = 0;
	node *n;

	if (m->debug)
		fprintf(stderr, "mvc_create_key %s %d %ld\n",
		 t->name, kt, (long)rkey);

	if (t->type == tt_temp && t->type == tt_session)
		return NULL;

	nk->id = OIDnew(1);
	nk->type = kt;
	assert(name);
	nk->name = _strdup(name);
	nk->columns = list_create((fdestroy)&kc_destroy);
	nk->t = t;

	BATloop(columns, p, q){
		char *name = BUNhead(columns,p);
		int trunc = *(int*)BUNtail(columns,p);
		sql_kc *kc = NEW(sql_kc);
		sql_column *c = find_column(t,name);
		assert(c);
		kc->c = c;
		kc->trunc = trunc;
		list_append(nk->columns, kc);
	}

	if (nk->type != fkey){
		/* create void,int bat to keep the hash values */
		BAT *b = BATnew( TYPE_void, TYPE_int, cnt );
		sql_ukey *uk = (sql_ukey*)nk;
		uk -> keys = NULL;

		BATseqbase(b,0);
		snprintf(bname, BUFSIZ, "K_%s_%s", nk->t->name, nk->name );
		nk->bid = bm_add_bat(tr->bm, b->batCacheid, bname, 0);
		bat_destroy(b);

		if (nk->type == pkey)
			t->pkey = uk;
	} else {
		BAT *b = BATnew( TYPE_void, TYPE_oid, cnt );
		sql_fkey *fk = (sql_fkey*)nk;
		sql_ukey *uk = (sql_ukey*)rkey;

		BATseqbase(b,0);
		snprintf(bname, BUFSIZ, "F_%s_%s", nk->t->name, nk->name );
		nk->bid = bm_add_bat(tr->bm, b->batCacheid, bname, 0);
		bat_destroy(b);

		fk -> rkey = uk;
		if (!uk->keys) uk->keys = list_create(NULL);
		list_append(uk->keys, fk);
	}

	if (!t->nkey) t->nkey = nk;
	if (!t->keys)
		t->keys = list_create((fdestroy)&key_destroy);
	list_append(t->keys, nk);

	b = bind_bat(tr, find_column(syskey, "id"), 1);
	rid = BATcount(b);
	BUNins(b, (ptr) & rid, (ptr) & nk->id); bat_destroy(b);
	b = bind_bat(tr, find_column(syskey, "table_id"), 1);
	BUNins(b, (ptr) & rid, (ptr) & t->id); bat_destroy(b);
	b = bind_bat(tr, find_column(syskey, "name"), 1);
	BUNins(b, (ptr) & rid, (ptr) nk->name); bat_destroy(b);
	b = bind_bat(tr, find_column(syskey, "type"), 1);
	BUNins(b, (ptr) & rid, (ptr) & nk->type); bat_destroy(b);
	b = bind_bat(tr, find_column(syskey, "rkey"), 1);
	if (nk->type == fkey)
		BUNins(b, (ptr) & rid, (ptr) & ((sql_fkey*)nk)->rkey->k.id); 
	else
		BUNins(b, (ptr) & rid, (ptr) & neg); 
	bat_destroy(b);
	for (nr = 0, n=nk->columns->h; n; n = n->next, nr++){
		sql_kc *kc = n->data;
		
		b = bind_bat(tr, find_column(syskc, "id"), 1);
		rid = BATcount(b);
		BUNins(b, (ptr) & rid, (ptr) & nk->id); bat_destroy(b);
		b = bind_bat(tr, find_column(syskc, "column"), 1);
		BUNins(b, (ptr) & rid, (ptr) kc->c->name); bat_destroy(b);
		b = bind_bat(tr, find_column(syskc, "trunc"), 1);
		BUNins(b, (ptr) & rid, (ptr) & kc->trunc); bat_destroy(b);
		b = bind_bat(tr, find_column(syskc, "nr"), 1);
		BUNins(b, (ptr) & rid, (ptr) & nr); bat_destroy(b);
	}

	syskey->wtime = syskc->wtime = tr->stime;
        m->type = QCREATE;
	return nk;
}

void mvc_drop_key(mvc * m, sql_table *t, char *name)
{
	sql_trans *tr = m->trans;
	node *n = find_key_node(t, name);
	sql_key *k = n->data;

	if (m->debug)
		fprintf(stderr, "mvc_drop_key %s %s\n", t->name, name);

	if (t->type != tt_temp && t->type != tt_session)
		sys_drop_key(tr, k);

	if (k->flag == TR_NEW) {
		if (t->nkey == k){
			if (n->next)
				t->nkey = n->next->data;
			else
				t->nkey = NULL;
		}
		list_remove_data(t->keys, k);
		key_destroy(k);
	} else {
		if (!t->dkeys) 
			t->dkeys = list_create((fdestroy)&key_destroy);
		list_move_data(t->keys, t->dkeys, k);
	}

	k->wtime = t->wtime = tr->wtime = tr->stime;
}

static sql_table *bootstrap_create_table(mvc * m, sql_schema *s, char *name, int type)
{
	char bname[BUFSIZ];
	sql_trans *tr = m->trans;
	sql_table *t = create_table_intern(m, name, type);

	BAT *b;
	oid rid;

	t->query = _strdup("");
	t->s = s;
	if (!s->ntable) s->ntable = t;
	list_append(s->tables, t);

	snprintf(bname, BUFSIZ, "O_%s", t->name );
	t->obid = bm_find_bat(tr->bm, bname);

	snprintf(bname, BUFSIZ, "D_%s", t->name );
	t->dbid = bm_find_bat(tr->bm, bname);
	assert(t->obid && t->dbid);

	b = sys_bat(m->trans->bm, "tables_id");
	rid = BATcount(b);
	BUNins(b, (ptr) & rid, (ptr) & t->id); BBPunfix(b->batCacheid);
	b = sys_bat(m->trans->bm, "tables_schema_id");
	BUNins(b, (ptr) & rid, (ptr) & s->id); BBPunfix(b->batCacheid);
	b = sys_bat(m->trans->bm, "tables_name");
	BUNins(b, (ptr) & rid, (ptr) t->name); BBPunfix(b->batCacheid);
	b = sys_bat(m->trans->bm, "tables_type");
	BUNins(b, (ptr) & rid, (ptr) & t->type); BBPunfix(b->batCacheid);
	b = sys_bat(m->trans->bm, "tables_query");
	BUNins(b, (ptr) & rid, (ptr) t->query); BBPunfix(b->batCacheid);

	t->wtime = s->wtime = tr->wtime = tr->stime;
	return t;
}

sql_table *mvc_create_table(mvc * m, sql_schema *s, char *name, int type)
{
	char bname[BUFSIZ];
	sql_trans *tr = m->trans;
	sql_table *t = create_table_intern(m, name, type);
	int cnt = BUFSIZ;
	BAT *o = BATnew( TYPE_void, TYPE_oid, cnt );
	BAT *d = BATnew( TYPE_void, TYPE_oid, cnt );

	sql_table *systable = find_table(find_schema(tr, "sys"), "tables");
	BAT *b;
	oid rid = 0;

	BATseqbase(o, 0);
	BATseqbase(d, 0);

	if (m->debug)
		fprintf(stderr, "mvc_create_table %s %s %d\n", 
		 s->name, name, type);

	t->query = _strdup("");
	t->s = s;
	if (!s->ntable) s->ntable = t;
	list_append(s->tables, t);

	snprintf(bname, BUFSIZ, "O_%s", t->name );
	t->obid = bm_add_bat(tr->bm, o->batCacheid, bname, 0);
	bat_destroy(o);
	snprintf(bname, BUFSIZ, "D_%s", t->name );
	t->dbid = bm_add_bat(tr->bm, d->batCacheid, bname, 0);
	bat_destroy(d);

	if (t->type != tt_temp && t->type != tt_session){
		b = bind_bat(tr, find_column(systable, "id"), 1);
		rid = BATcount(b);
		BUNins(b, (ptr)&rid, & t->id ); BBPunfix(b->batCacheid);
		b = bind_bat(tr, find_column(systable, "schema_id"), 1);
		BUNins(b, (ptr)&rid, & s->id ); BBPunfix(b->batCacheid);
		b = bind_bat(tr, find_column(systable, "name"), 1);
		BUNins(b, (ptr)&rid, t->name ); BBPunfix(b->batCacheid);
		b = bind_bat(tr, find_column(systable, "type"), 1);
		BUNins(b, (ptr)&rid, & t->type ); BBPunfix(b->batCacheid);
		b = bind_bat(tr, find_column(systable, "query"), 1);
		BUNins(b, (ptr)&rid, t->query ); BBPunfix(b->batCacheid);
		systable->wtime = tr->stime;
	}

	t->wtime = s->wtime = tr->wtime = tr->stime;
        m->type = QCREATE;
	return t;
}


sql_table *mvc_create_view(mvc * m, sql_schema *s, char *name, char *sql)
{
	sql_trans *tr = m->trans;
	sql_table *t = create_table_intern(m, name, tt_view);

	sql_table *systable = find_table(find_schema(tr, "sys"), "tables");
	BAT *b;
	oid rid = 0;

	if (m->debug)
		fprintf(stderr, "mvc_create_view %s %s %s\n", 
		 s->name, name, sql);

	t->query = _strdup(sql);
	if (!s->ntable) s->ntable = t;
	list_append(s->tables, t);

	b = bind_bat(tr, find_column(systable, "id"), 1);
	rid = BATcount(b);
	BUNins(b, (ptr)&rid, & t->id ); BBPunfix(b->batCacheid);
	b = bind_bat(tr, find_column(systable, "schema_id"), 1);
	BUNins(b, (ptr)&rid, & s->id ); BBPunfix(b->batCacheid);
	b = bind_bat(tr, find_column(systable, "name"), 1);
	BUNins(b, (ptr)&rid, t->name ); BBPunfix(b->batCacheid);
	b = bind_bat(tr, find_column(systable, "type"), 1);
	BUNins(b, (ptr)&rid, & t->type ); BBPunfix(b->batCacheid);
	b = bind_bat(tr, find_column(systable, "query"), 1);
	BUNins(b, (ptr)&rid, t->query ); BBPunfix(b->batCacheid);

	systable->wtime = t->wtime = s->wtime = tr->wtime = tr->stime;
        m->type = QCREATE;
	return t;
}

void mvc_drop_table(mvc * m, sql_schema *s, char *name, bit cascade)
{
	sql_trans *tr = m->trans;
	node *n = find_table_node(s, name );
	sql_table *t = n->data;

	if (m->debug)
		fprintf(stderr, "mvc_drop_table %s %s\n", s->name, name);

	if (t->type != tt_temp && t->type != tt_session)
		sys_drop_table(tr, t);

	if (t->flag == TR_NEW) {
		if (s->ntable == t){
			if (n->next)
				s->ntable = n->next->data;
			else
				s->ntable = NULL;
		}
		list_remove_data(s->tables, t);
		table_destroy(t);
	} else {
		if (!s->dtables) 
			s->dtables = list_create((fdestroy)&table_destroy);
		list_move_data(s->tables, s->dtables, t);
                t->wtime = tr->stime;
	}
	/* TODO cascade, ie. remove al references to this table */
	s->wtime = tr->wtime = tr->stime;
}

static sql_column *bootstrap_create_column(mvc * m, sql_table *t, char *name,
		       char *sqltype, int type_digits, int type_scale, int seqnr )
{
	char bname[BUFSIZ];
	sql_trans *tr = m->trans;
	sql_column *col = NEW(sql_column);

	BAT *b;
	oid rid;

	col->id = OIDnew(1);
	col->name = _strdup(name);
	col->type = sql_bind_subtype(sqltype, type_digits, type_scale);
	col->def = _strdup("");
	col->null = 1;
	col->colnr = seqnr;
	col->rtime = 0;
	col->flag = TR_NEW;
	col->t = t;
	if (!t->ncolumn) t->ncolumn = col;
	list_append(t->columns, col);

	snprintf(bname, BUFSIZ, "%s_%s", col->t->name, col->name );
	col->bid = bm_find_bat(tr->bm, bname);

	snprintf(bname, BUFSIZ, "U_%s_%s", col->t->name, col->name );
	col->ubid = bm_find_bat(tr->bm, bname);
	assert(col->bid && col->ubid);

	b = sys_bat(m->trans->bm, "columns_id");
	rid = BATcount(b);
	BUNins(b, (ptr) & rid, (ptr) & col->id); BBPunfix(b->batCacheid);
	b = sys_bat(m->trans->bm, "columns_table_id");
	BUNins(b, (ptr) & rid, (ptr) & t->id); BBPunfix(b->batCacheid);
	b = sys_bat(m->trans->bm, "columns_name");
	BUNins(b, (ptr) & rid, (ptr) col->name); BBPunfix(b->batCacheid);
	b = sys_bat(m->trans->bm, "columns_type");
	BUNins(b, (ptr) & rid, (ptr) col->type->type->sqlname); BBPunfix(b->batCacheid);
	b = sys_bat(m->trans->bm, "columns_type_digits");
	BUNins(b, (ptr) & rid, (ptr) & col->type->digits); BBPunfix(b->batCacheid);
	b = sys_bat(m->trans->bm, "columns_type_scale");
	BUNins(b, (ptr) & rid, (ptr) & col->type->scale); BBPunfix(b->batCacheid);
	b = sys_bat(m->trans->bm, "columns_default");
	BUNins(b, (ptr) & rid, (ptr) col->def); BBPunfix(b->batCacheid);
	b = sys_bat(m->trans->bm, "columns_null");
	BUNins(b, (ptr) & rid, (ptr) & col->null); BBPunfix(b->batCacheid);
	b = sys_bat(m->trans->bm, "columns_number");
	BUNins(b, (ptr) & rid, (ptr) & col->colnr); BBPunfix(b->batCacheid);

	col->wtime = t->wtime = tr->wtime = tr->stime;

	return col;
}

static sql_column *mvc_create_column_bat(mvc * m, sql_table *t, char *name,
		       char *sqltype, int type_digits, int type_scale, int seqnr, BAT *bb, BAT *u)
{
	char bname[BUFSIZ];
	sql_trans *tr = m->trans;
	sql_column *col = NEW(sql_column);

	sql_table *syscolumn = find_table(find_schema(tr, "sys"), "columns");
	BAT *b;
	oid rid = 0;

	assert(bb && u);

	col->id = OIDnew(1);
	col->name = _strdup(name);
	col->type = sql_bind_subtype(sqltype, type_digits, type_scale);
	col->def = _strdup("");
	col->null = 1;
	col->colnr = seqnr;
	col->rtime = 0;
	col->flag = TR_NEW;
	col->t = t;
	if (!t->ncolumn) t->ncolumn = col;
	list_append(t->columns, col);

	snprintf(bname, BUFSIZ, "%s_%s", col->t->name, col->name );
	col->bid = bm_add_bat(tr->bm, bb->batCacheid, bname, 0);

	snprintf(bname, BUFSIZ, "U_%s_%s", col->t->name, col->name );
	col->ubid = bm_add_bat(tr->bm, u->batCacheid, bname, 0);

	col->wtime = t->wtime = tr->wtime = tr->stime;
	if (t->type == tt_temp || t->type == tt_session)
		return col;

	b = bind_bat(tr, find_column(syscolumn, "id"), 1);
	rid = BATcount(b);
	BUNins(b, (ptr) & rid, (ptr) & col->id); BBPunfix(b->batCacheid);
	b = bind_bat(tr, find_column(syscolumn, "table_id"), 1);
	BUNins(b, (ptr) & rid, (ptr) & t->id); BBPunfix(b->batCacheid);
	b = bind_bat(tr, find_column(syscolumn, "name"), 1);
	BUNins(b, (ptr) & rid, (ptr) col->name); BBPunfix(b->batCacheid);
	b = bind_bat(tr, find_column(syscolumn, "type"), 1);
	BUNins(b, (ptr) & rid, (ptr) col->type->type->sqlname); BBPunfix(b->batCacheid);
	b = bind_bat(tr, find_column(syscolumn, "type_digits"), 1);
	BUNins(b, (ptr) & rid, (ptr) & col->type->digits); BBPunfix(b->batCacheid);
	b = bind_bat(tr, find_column(syscolumn, "type_scale"), 1);
	BUNins(b, (ptr) & rid, (ptr) & col->type->scale); BBPunfix(b->batCacheid);
	b = bind_bat(tr, find_column(syscolumn, "default"), 1);
	BUNins(b, (ptr) & rid, (ptr) col->def); BBPunfix(b->batCacheid);
	b = bind_bat(tr, find_column(syscolumn, "null"), 1);
	BUNins(b, (ptr) & rid, (ptr) & col->null); BBPunfix(b->batCacheid);
	b = bind_bat(tr, find_column(syscolumn, "number"), 1);
	BUNins(b, (ptr) & rid, (ptr) & col->colnr); BBPunfix(b->batCacheid);

	syscolumn->wtime = tr->stime;
        m->type = QCREATE;
	return col;
}

sql_column *mvc_create_column(mvc * m, sql_table *t, char *name,
		       char *sqltype, int type_digits, int type_scale, int seqnr)
{

	sql_column *res = NULL;
	sql_subtype *tpe = sql_bind_subtype(sqltype, type_digits, type_scale);

	char *typename;
	int type, cnt = BUFSIZ;
	BAT *u, *b;

	if (!tpe) return NULL;

 	typename = tpe->type->name;
 	type = ATOMindex(typename);
	b = BATnew( TYPE_void, type, cnt );
 	u = BATnew( TYPE_oid, type, cnt );

	if (m->debug)
		fprintf(stderr, "mvc_create_column %s %s %s %d\n", t->name,
		       name, sqltype, seqnr);

	BATseqbase(b,0);
	res = mvc_create_column_bat(m, t, name, sqltype, type_digits, type_scale, seqnr, b, u);
	bat_destroy(b);
	bat_destroy(u);

	sql_subtype_destroy(tpe);

	return res;
}

void mvc_drop_column(mvc * m, sql_table *t, char *name)
{
	sql_trans *tr = m->trans;
	node *n = find_column_node(t, name);
	sql_column *col = n->data;

	if (m->debug)
		fprintf(stderr, "mvc_drop_column %s %s\n", t->name, name);

	if (t->type != tt_temp && t->type != tt_session)
		sys_drop_column(tr, col);

	if (col->flag == TR_NEW) {
		if (t->ncolumn == col){
			if (n->next)
				t->ncolumn = n->next->data;
			else
				t->ncolumn = NULL;
		}
		list_remove_data(t->columns, col);
		column_destroy(col);
	} else {
		if (!t->dcolumns) 
			t->dcolumns = list_create((fdestroy)&column_destroy);
		list_move_data(t->columns, t->dcolumns, col);
	}

	col->wtime = t->wtime = tr->wtime = tr->stime;
}

sql_column * mvc_null(mvc * m, sql_column * col, int isnull)
{
	sql_trans *tr = m->trans;

	if (m->debug)
		fprintf(stderr, "mvc_null %s %d\n", col->name, isnull);

        if (col->null != isnull){
                sql_table *syscolumn = find_table(find_schema(tr, "sys"), "columns");
                BAT *b, *r;
                oid rid = 0;

                /* replace null value in sys columns */
                b = bind_bat(tr, find_column(syscolumn, "id"), 1);
                r = BATmirror(b);
                rid = *(oid*)BUNtail(r, BUNfnd(r, (ptr) & col->id ));
                BBPunfix(b->batCacheid);
                b = bind_bat(tr, find_column(syscolumn, "null"), 1);
                bun_inplace(b, rid, &isnull);
                BBPunfix(b->batCacheid);

                if (col->flag != TR_NEW) {
                        b = bind_ubat(tr, find_column(syscolumn, "null"), 1);
                        BUNins(b, (ptr) & rid, (ptr) & isnull);
                        BBPunfix(b->batCacheid);
                }
                col->null = isnull;
                col->wtime = tr->wtime = tr->stime;
        }

	return col;
}

sql_column * mvc_default(mvc * m, sql_column * col, char *val)
{
	sql_trans *tr = m->trans;

	if (m->debug)
		fprintf(stderr, "mvc_default %s %s\n", col->name, val);

        if (strcmp(col->def, val) != 0){
                sql_table *syscolumn = find_table(find_schema(tr, "sys"), "columns");
                BAT *b, *r;
                oid rid = 0;

                /* replace default value in sys columns */
                b = bind_bat(tr, find_column(syscolumn, "id"), 1);
                r = BATmirror(b);
                rid = *(oid*)BUNtail(r, BUNfnd(r, (ptr) & col->id ));
                BBPunfix(b->batCacheid);
                b = bind_bat(tr, find_column(syscolumn, "default"), 1);
                bun_inplace(b, rid, val);
                BBPunfix(b->batCacheid);

                if (col->flag != TR_NEW) {
                        b = bind_ubat(tr, find_column(syscolumn, "default"), 1);
                        BUNins(b, (ptr) & rid, (ptr) val);
                        BBPunfix(b->batCacheid);
                }
                _DELETE(col->def);
                col->def = _strdup(val);
                col->wtime = tr->wtime = tr->stime;
        }
	return col;
}


void mvc_export(stream * s, BAT * order, BAT * bats, char *sep, char *rsep)
{
	oid nil = oid_nil;
	char buf[BUFSIZ];
	size_t i, cnt = BATcount(bats);
	BAT *seps = BATnew( TYPE_void, TYPE_str, cnt );
	BATseqbase(seps,0);

	for (i = 0; i < cnt - 1; i++) {
		BUNins(seps, (ptr) &nil, (ptr) &sep);
	}
	BUNins(seps, (ptr) &nil, (ptr) &rsep);

        i = snprintf(buf, BUFSIZ, "%ld\n", (long)BATcount(order));
	s->write(s, buf, i, 1);
	ASCIIoutput(order, seps, bats, s);
	BBPreclaim(seps);
}

int mvc_import_table( mvc *m, stream *s, char *tname, 
		char *sep, char *rsep, int sz)
{
	BUN p;
	oid nil = oid_nil;
	size_t nr = 0, cnt = 0; 
	oid newid;
	sql_column *col;
	sql_trans *tr = m->trans;
	node *n;
	sql_table *t = find_table(tr->schema, tname);
	BAT *bats, *nmes, *seps, *tpes, *inss, *b;
	bstream *bs = bstream_create(s, 1<<10);

	if (!t){
		GDKerror("table %s not found\n", tname );
		tr->status = -1;
		return -1;
	}
	if (!s || s->errnr){
		GDKerror("stream not open %d\n", s->errnr );
		tr->status = -1;
		return  -1;
	}

	bats = BATnew( TYPE_void, TYPE_bat, BUFSIZ );
	BATseqbase(bats,0);

	nmes = BATnew( TYPE_void, TYPE_str, BUFSIZ );
	BATseqbase(nmes,0);

	seps = BATnew( TYPE_void, TYPE_str, BUFSIZ );
	BATseqbase(seps,0);

	tpes = BATnew( TYPE_void, TYPE_str, BUFSIZ );
	BATseqbase(tpes,0);

	/* TODO: change should load into multiple bats 
	 * requires a bat_set layer which is not implemented jet!
	 */
	for (n = t->columns->h; n && n->next; n = n->next, nr++) 
	{
		col = n->data;

		b = bind_bat(tr, col, 1);
		BUNins(bats, (ptr)&nil, (ptr)&(b->batCacheid));
		BUNins(nmes, (ptr)&nil, BBPname(b->batCacheid));
		BUNins(seps, (ptr)&nil, sep);
		BUNins(tpes, (ptr)&nil, ATOMname(b->ttype));
		BBPunfix(b->batCacheid);
	}
	if (n){
		col = n->data;
		b = bind_bat(tr, col, 1);
		BUNins(bats, (ptr)&nil, (ptr)&(b->batCacheid));
		BUNins(nmes, (ptr)&nil, BBPname(b->batCacheid));
		BUNins(seps, (ptr)&nil, rsep);
		BUNins(tpes, (ptr)&nil, ATOMname(b->ttype));
		BBPunfix(b->batCacheid);
	}
	inss = ASCIIinput( nmes, seps, tpes, bs, sz);
	bstream_destroy(bs);
	if (!inss)
		return -1;
	for (n = t->columns->h, p = BUNfirst(inss);
		n &&  p < BUNlast(inss);
		n = n->next, nr++, p += BUNsize(inss) ){
		BAT *ba, *in; 
		col = n->data;

		ba = bind_bat(tr, col, 1);
		in = BATdescriptor(*(bat*)BUNtail(inss, p));

		assert (strcmp(BBPname(ba->batCacheid), BUNhead(inss,p)) == 0 );

		cnt = BATcount(in);
		if (BATcount(ba) == 0){
			bm_new_bat(tr->bm, col->bid, in->batCacheid);
		} else {
			void_append_bat(ba,in);
		}
		BBPunfix(ba->batCacheid);
		BBPunfix(in->batCacheid);
	} 
	b = bind_obat(tr, t, INS);
	newid = OIDnew(cnt);
	nr = cnt;
	for(;cnt;cnt--, newid++)
		BUNins(b, (ptr)&nil, (ptr)&newid );
	BBPunfix(b->batCacheid);

        BBPreclaim(inss);
        BBPreclaim(bats);
        BBPreclaim(nmes);
        BBPreclaim(seps);
        BBPreclaim(tpes);
        tr->status = nr;
        return nr;
}
/* roles can be defineed
 * on the 'top (aka catalog) layer' and on the schema layer
sql_role *mvc_create_role( mvc *m, sql_schema *s, char *name, int grantor )
{
        sql_trans *tr = m->trans;
        sql_role *role = NEW(sql_role);

        role -> id = 0;
        role -> name = _strdup(name);
        role -> grantor = grantor;
        role -> flag = TR_NEW;

        if (!s->nrole) s->nrole = role;
        list_append(s->roles, role);

        s->wtime = tr->wtime = tr->stime;
        m->type = QCREATE;
        return role;
}

sql_role *mvc_drop_role( mvc *m, sql_schema *s, char *name)
{
        sql_trans *tr = m->trans;
        node *n = find_role_node(s, name );
        sql_role *r = n->data;

        if (m->debug)
                fprintf(stderr, "mvc_drop_role %s %s\n", s->name, name);

        if (r->flag == TR_NEW) {
                if (s->nrole == r){
                        if (n->next)
                                s->nrole = n->next->data;
                        else
                                s->nrole = NULL;
                }
                list_remove_data(s->roles, r);
                role_destroy(r);
        } else {
                if (!s->droles)
                        s->droles = list_create((fdestroy)&role_destroy);
                list_move_data(s->roles, s->droles, r);
        }
        s->wtime = tr->wtime = tr->stime;
}
*/

@= dec_tostr
	char buf[32];
	@1 v = *(@1*)a;
	int scale = (int)extra, cur = 31, neg = (v<0)?1:0, i, done = 0;
	int l;

	if (v<0) v = -v;

	buf[cur--] = 0;
	if (scale){
		for(i=0; i<scale; i++){
			buf[cur--] = (v%10) + '0';
			v /= 10;
		}
		buf[cur--] = '.';
	}
	while(v){
		buf[cur--] = (v%10) + '0';
		v /= 10;
		done = 1;
	}
	if (!done)
		buf[cur--] = '0';
	if (neg)
		buf[cur--] = '-';
	l = (32-cur-1);
	if (*len < l){
		if (*Buf) GDKfree(*Buf);
		*len = l+1;
		*Buf = GDKmalloc(*len);
	}
	strcpy(*Buf, buf+cur+1);
	return l-1;
@c

int dec_tostr( void *extra, char **Buf, int *len, int type, ptr a){
	/* support dec map to sht, int and lng */
	if (type == TYPE_sht){
		@:dec_tostr(sht)@
	} else if (type == TYPE_int){
		@:dec_tostr(int)@
	} else if (type == TYPE_lng){
		@:dec_tostr(lng)@
	} else {
		GDKwarning("Decimal cannot be mapped to %s\n", ATOMname(type));
	}
}

@= dec_frstr
	sql_subtype *t = (sql_subtype*)extra;

	int i, neg = 0;
	char *p = s;
	@1 *r;
	@1 res = 0;
	if (*s == '-'){
		neg = 1;
		s++;
	} else if (*s == '+'){ 
		neg = 0;
		s++;
	}
	for( i = 0; i < (t->digits-t->scale) && *s != '.'; i++, s++){
		if (!*s || *s < '0' || *s > '9' ){
			GDKerror("decimal wrong format (%s)", p);
			return NULL;
		}
		res *= 10;
		res += (*s-'0');
	}
	if (*s){
		if (*s != '.'){
			GDKerror("decimal wrong format (%s)", p);
			return NULL;
		}
		s++;
		for( i = 0; *s && i < t->scale; i++, s++){
			if (*s < '0' || *s > '9' ){
				GDKerror("decimal wrong format (%s)", p);
				return NULL;
			}
			res *= 10;
			res += (*s-'0');
		}
	}
	if (*s){
		GDKerror("decimal wrong format (%s)", p);
		return NULL;
	}
 	r = (@1*)GDKmalloc(sizeof(@1));
	if (neg)
		*r = -res;
	else
		*r = res;
	return (ptr*)r;
@c

ptr *dec_frstr( void *extra, int type, char *s){
	/* support dec map to sht, int and lng */
	if (type == TYPE_sht){
		@:dec_frstr(sht)@
	} else if (type == TYPE_int){
		@:dec_frstr(int)@
	} else if (type == TYPE_lng){
		@:dec_frstr(lng)@
	} else {
		GDKwarning("Decimal cannot be mapped to %s\n", ATOMname(type));
	}
}


static res_table *mvc_result_table_( mvc *m, int nr_cols )
{
	int res_id = m->result_id++;
	res_table *t = NEW(res_table);
	t->id = res_id;
	t->nr_cols = nr_cols;
	t->cur_col = 0;
	t->cols = NEW_ARRAY(res_col,nr_cols);
	t->order = 0;

	t->next = m->results;
	m->results = t;
	return t;
}

int mvc_result_row( mvc *m, int nr_cols )
{
	res_table *t = mvc_result_table_(m, nr_cols);

	return t->id;
}

int mvc_result_table( mvc *m, int nr_cols, BAT *order )
{
	res_table *t = mvc_result_table_(m, nr_cols);

	t->order = order->batCacheid;
	BBPpersistent(t->order, FALSE);
	return t->id;
}

static res_col *mvc_result_value_( mvc *m, char *name, char *typename, int digits, int scale ){
	sql_subtype *tpe = sql_bind_subtype(typename, digits, scale);
	res_table *t = m->results;
	res_col *c = t->cols+t->cur_col;

	c->name = _strdup(name);
	c->type = tpe;
	c->b = 0;
	c->p = NULL;
	c->mtype = TYPE_bat;
	t->cur_col++;
	return c;
}

int mvc_result_column( mvc *m, char *name, char *typename, int digits, int scale, BAT *b){
	res_col *c = mvc_result_value_(m, name, typename, digits, scale);

	c->b = b->batCacheid;
	BBPpersistent(c->b, FALSE);
	return 0;
}

int mvc_result_value( mvc *m, char *name, char *typename, int digits, int scale, ptr *p, int mtype){
	res_col *c = mvc_result_value_(m, name, typename, digits, scale);

	c->mtype = mtype;
	c->p = ATOMdup(mtype,p); 
	return 0;
}

static res_table *find_export_table( mvc *m, int res_id ){
	res_table *r = m->results;
	for( ; r; r = r->next){
		if (r->id == res_id)
			return r;
	}
	return NULL;
}

int mvc_export_result( mvc *m, stream *s, int res_id )
{
	int i;
	res_table *t = find_export_table(m, res_id);
	
	stream_writeInt( s, QRESULT );
	stream_writeInt( s, t->nr_cols );
	stream_writeInt( s, t->id );
	
	for (i = 0; i < t->nr_cols; i++) 
	{
		res_col *c = t->cols+i;
		s->write(s, c->name, strlen(c->name), 1);
		s->write(s, ",", 1, 1);
		s->write(s, c->type->type->sqlname, 
				strlen(c->type->type->sqlname), 1);
		s->write(s, "\n", 1, 1);
	}
	s->flush(s);
	return 0;
}

static int mvc_export_row( mvc *m, stream *s, res_table *t, char *sep, char *rsep) 
{
	int i;

	stream_writeInt( s, QTABLE );
	stream_writeInt( s, 1 );

	for (i = 0; i < t->nr_cols; i++) 
	{
		res_col *c = t->cols+i;
		if (i != 0)
			s->write(s, sep, strlen(sep), 1);

		if (c->type->type->scale == SCALE_FIX){
			char *buf = NULL;
			int len = 0;
			int l = dec_tostr((void*)c->type->scale, &buf, &len,
					c->mtype, c->p);
			s->write(s, buf, l, 1);
			_DELETE(buf);
		} else { 
			char *buf = NULL;
			int len = 0;
			int l = (*BATatoms[c->mtype].atomToStr)(&buf, &len, c->p);
			s->write(s, buf, l, 1);
			_DELETE(buf);
		}
	}
	clean_result(m, t);
	s->write(s, rsep, strlen(rsep), 1);
	s->flush(s);
	return 0;
}

int mvc_export_table( mvc *m, stream *s, int res_id, int offset, int nr, char *sep, char *rsep)
{
	ascii as;
        ascii_io *fmt;
	res_table *t = find_export_table(m, res_id);
	size_t i, cnt;
	int clean = 0;
	BAT *order = NULL;

	if (!t) 
		return -1;

	if (!t->order)
		return mvc_export_row(m, s, t, sep, rsep);

	order = BATdescriptor(t->order);
	cnt = nr;
	if (cnt < 0){
 		cnt = BATcount(order);
		clean = 1;
	}
	if (offset >= BATcount(order))
		cnt = 0;
	if (offset + cnt > BATcount(order))
		cnt = BATcount(order)-offset;

	stream_writeInt( s, QTABLE );
	stream_writeInt( s, cnt );
	
	if (cnt <= 0){
		s->flush(s);
		return 0;
	}
	as.nr_attrs = t->nr_cols;
	as.nr = cnt;
	as.offset = offset;
	fmt = as.format =
                (ascii_io*)GDKmalloc(sizeof(ascii_io) * (as.nr_attrs + 1) );

	memset(fmt, 0, (as.nr_attrs+1)*sizeof(ascii_io));

	for (i = 0; i < t->nr_cols; i++) 
	{
		res_col *c = t->cols+i;
		if (!c->b) 
			break;

		fmt[i].c = BATdescriptor(c->b);
		fmt[i].name = NULL;
                fmt[i].sep = (i<(t->nr_cols-1))?_strdup(sep):_strdup(rsep);
                fmt[i].seplen = (int) strlen( fmt[i].sep );
		fmt[i].type = ATOMname(fmt[i].c->ttype);
		fmt[i].adt = fmt[i].c->ttype;
                fmt[i].tostr = &ASCIIadt_toStr;
                fmt[i].frstr = &ASCIIadt_frStr;
                fmt[i].extra = NULL;
		if (c->type->type->scale == SCALE_FIX){
			fmt[i].tostr = &dec_tostr;
			fmt[i].frstr = &dec_frstr;
			fmt[i].extra = (void*)c->type->scale;
		}
	}
	if (i == t->nr_cols){
		ASCIIoutput_file(&as, order, s);
	}
	BBPunfix(order->batCacheid);
	ASCIIdestroy_format( &as );
	s->flush( s );
	if (clean)
		clean_result(m, t);
	return 0;
}
