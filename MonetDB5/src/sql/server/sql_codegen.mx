@f sql_codegen
@t SQL to MAL code generation.
@a N. Nes, M. Kersten
@+ MAL Code generation
[TODO, check code generation, in particular the assignment of
the result to the proper variable]

This module contains the actions to construct a MAL program, ready for
optimization and execution by the Monet V5 kernel.

The code base is modelled directly after its MIL variant, replacing
each IO request by instructions to initialize the corresponding MAL data
structure.
To speed up the compilation, we may consider keeping a cache of pre-compiled
statements.

MAL extensions needed. A temporary variable used as an argument
should be printed (done). Consider replacing modname/fcnname by
an integer constant and a global lookup table. This should
reduce the cost to prepare MAL statements significantly.

A dummymodules is needed to load properly.
@-
@h

/*
 * The contents of this file are subject to the MonetDB Public
 * License Version 1.0 (the "License"); you may not use this file
 * except in compliance with the License. You may obtain a copy of
 * the License at 
 * http://monetdb.cwi.nl/Legal/MonetDBPL-1.0.html
 * 
 * Software distributed under the License is distributed on an "AS
 * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
 * implied. See the License for the specific language governing
 * rights and limitations under the License.
 * 
 * The Original Code is the Monet Database System.
 * 
 * The Initial Developer of the Original Code is CWI.
 * Portions created by CWI are Copyright (C) 1997-2002 CWI.  
 * All Rights Reserved.
 * 
 * Contributor(s): Martin Kersten <Martin.Kersten@cwi.nl>
 *		   Niels Nes <Niels.Nes@cwi.nl>
 */

#ifndef _SQL2MAL_H
#define _SQL2MAL_H

#include "atom.h"
#include "mem.h"
#include "statement.h"
#include "gdk.h"
#include "mal_function.h"
#include "sql_mvc.h"

mal_export int sql2MAL(mvc *m, MalBlkPtr mb, stmt *s, context *sql);
#endif /* _SQL2MAL_H */
@c
#include "sql_codegen.h"

@+ MAL code support
To simplify construction of the MAL program use the following
macros

@= newStmt
	q= newInstruction(ASSIGNsymbol);
	q->modname= (@1)? GDKstrdup(@1): 0;
	q->fcnname= (@2)? GDKstrdup(@2): 0;
	getDestVar(q)= newTmpVariable(mb,TYPE_any);
	pushInstruction(mb,q);
	s->nr= getDestVar(q);	/* might be dropped altogether */
@= newStmtId
	q= newInstruction(ASSIGNsymbol);
	q->modname= (@2)? GDKstrdup(@2): 0;
	q->fcnname= (@3)? GDKstrdup(@3): 0;
	getDestVar(q)= newVariable(mb,@1,TYPE_any);
	pushInstruction(mb,q);
@= pushInt
	{int _t; char bufi[BUFSIZ];
		snprintf(bufi,BUFSIZ,"%d",@1);
		 _t= newConstant(mb,TYPE_int,GDKstrdup(bufi),TRUE); 
		q= pushArgument(mb,q,_t);
	}
@= pushStr
	{int _t; _t= newConstant(mb,TYPE_str,GDKstrdup(@1),TRUE); 
		q= pushArgument(mb,q,_t);}
@= pushBit
	{int _t; _t= newConstant(mb,TYPE_bit,GDKstrdup(@1),TRUE); 
		q= pushArgument(mb,q,_t);}
@= pushNilType
	{int _n,_t; 
	 	_t= newConstant(mb,getTypeIndex(@1),GDKstrdup("nil"),TRUE); 
		q= pushArgument(mb,q,_t);}
@= pushNil
	{int _n,_t; 
	 	_t= newConstant(mb,TYPE_any,GDKstrdup("nil"),TRUE); 
		q= pushArgument(mb,q,_t);}
@= pushType
	{int _t; _t= findVariable(mb,@1); 
	if( _t == -1 ) _t= newVariable(mb,@1,TYPE_any);
		q= pushArgument(mb,q,_t);}
@-
The type of previous instructions can be obtained from the MAL block
@= getTailType
	{ @1= getTailType(getVarType(mb,@2));}
@= getType
	{ @1= getVarType(mb,@2);}
@-
The return types should be carefully tuned. Vid types are differently handled.
	setVarType(mb,q->argv[0],newBatType(
	(ht==TYPE_void?TYPE_oid:ht),
	(tt==TYPE_void?TYPE_oid:tt)));

@= setType
	setVarType(mb,q->argv[0],@1);
@= setReturnType
	setVarType(mb,q->argv[0],newBatType(@1,@2));
@= setReturn
	getDestVar(q)= @1;
@= getReturn
	@1= getDestVar(q);
@= pushArgId
	q= pushArgumentId(mb,q,@1);
@= pushArg
	q= pushArgument(mb,q,@1);
@= newVar
	@1= newVariable(m, @2, TYPE_any);
@= newTmp
	@1= newTmpVariable(m, TYPE_any);

@+ MAL initialization
Many instructions have a more or less fixed structure, therefore
they can be assembled in a pre-compiled block. Each time we need it,
a copy can be extraced and included in the MAL block

The SQL block received is compiled into a MAL block surrounded
by calls to handle timing and tracing.

@= enterSQLblock
	@:newStmt("sql","beforeAction")@

@= afterSQLblock
	@:newStmt("sql","afterAction")@
@-

The catalog relations should be maintained in a MAL box, which
provides the handle for transaction management.
@-
The atoms produced by the parser should be converted back into
MAL constants. Ideally, this should not be necessary when the
parser keeps the string representation around.

@c
static
int constantAtom(MalBlkPtr mb, atom *a, context *sql){
	char buf[BUFSIZ];
	int tp;

	switch (a->type){
	case int_value: snprintf(buf, BUFSIZ, "%d", a->data.ival); 
		tp= TYPE_int;
		break;
	case string_value: snprintf(buf, BUFSIZ, "%s", a->data.sval); 
		tp= TYPE_str;
		break;
	case float_value: 
		snprintf(buf, BUFSIZ, "%fLL", a->data.dval); 
			/* float/double requires string as 
			 * else dbl(0.1), will first be a float and
			 * then converted to dbl, which results in the
			 * wrong value */ 
		tp= TYPE_flt;
		break;
	case general_value:
@-
General values are easy to deal with. They require the underlying type
library to be loaded, which always contains a routine to convert
a string value to its internal represenation. We merely have to re-introduce
the enclosing brackets expected by the MAL layer and deal with possible
overflow.
@c
			if (a->data.sval){
				int len = strlen(a->data.sval)+4;
				if( len > BUFSIZ-4){
				    str buf2= (str) GDKmalloc(len);
				    snprintf(buf2,len,"\"%s\"", a->data.sval);
				    len= newConstant(mb,TYPE_str,buf2,TRUE);
				    GDKfree(buf2);
				    return len;
				}
				snprintf(buf, BUFSIZ, "\"%s\"", a->data.sval );
				tp = TYPE_str;
			} else {
				snprintf(buf, BUFSIZ, "nil");
				tp = TYPE_void;
			}
			break;
	}
	if( sql->debug &8) fwrite( buf, 1, strlen(buf), stderr);

	return newConstant(mb, tp, GDKstrdup(buf), TRUE);
}
@-
Instructions are encapsulated with time code.
@= SQLprelude
        if (sql->debug&2){
		/* t0:= time(); printf(" %d ",t0); */
		@:newStmtId("t0","alarm","usec")@
		@:newStmt("io","printf")@
		@:pushStr(" %d ")@
		@:pushArgId("t0")@
        }

@= SQLpostlude
        if (sql->debug&2){
		/* t1 := time();t1:= t1-t0; printf(" %d ",t1);printf("%d\n",nr);*/
		@:newStmt("t1","alarm","usec")@
		@:newStmtId("t1","calc","-")@
		@:pushArgId("t1")@
		@:pushArgId("t0")@
		@:newStmt("io","printf")@
		@:pushStr(" %d ")@
		@:pushArgId("t1")@
		@:newStmt("io","printf")@
		@:pushStr(" %d \n")@
		@:pushArgId("nr")@
        }
@-
The dump_header produces a sequence of instructions for
the front-end to prepare presentation of a result table.
@c
void dump_header(MalBlkPtr mb, stmt *s, list *l ){
        node *n;
	InstrPtr q;
	int old;

        for (n=l->h; n; n = n->next){
                char *name ;
                s = n->data;
		old= s->nr;	/* s is mis-used in next macro */
		name= column_name(s);
                sql_subtype *type = tail_type(s);

		@:newStmt("sql","column")@
		@:pushArg(old)@
		@:pushStr((name)?name:"")@
		@:pushStr((type)?type->type->sqlname:"")@
		s->nr= old;
        }
}



@+ Binding utilities
To speed up processing, we keep track of the last table bindings
in the client mvc structure.
@c
void mvc_clear_binding(mvc *mvc, int i){
	if( mvc->binding[i].column) GDKfree(mvc->binding[i].column);
	mvc->binding[i].column = 0;
	if( mvc->binding[i].table) GDKfree(mvc->binding[i].table);
	mvc->binding[i].column = 0;
}

void mvc_add_binding(mvc *m, str col, str tab, int k){
	int i;
	if( m->btop == MAXBIND) {
		mvc_clear_binding(m,0);
		for(i=0;i<MAXBIND-1; i++) m->binding[i]= m->binding[i+1];
		m->binding[i].table = 0; m->binding[i].column = 0;
		m->btop--;
	}
	m->binding[m->btop].table = GDKstrdup(tab);
	m->binding[m->btop].column = GDKstrdup(col);
	m->binding[m->btop].index = k;
	m->btop++;

}
int mvc_fnd_binding(mvc *m, str col, str tab){
	int i;
	for(i=0;i< m->btop;i++)
	if( strcmp(col, m->binding[i].column)==0 &&
	    strcmp(tab, m->binding[i].table)==0)
		return m->binding[i].index;
	return 0;
}
int sql2MAL(mvc *m, MalBlkPtr mb, stmt *s, context *sql){
    InstrPtr q;
    int k,k2,k3;

    char buf[BUFSIZ+1];
    node *n;

    if (s){
    	if (s->nr > 0) return s->nr;	/* stmt already handled */


	switch(s->type){
	case st_none: break;
	case st_release: 
		@:SQLprelude@
		@:newStmt("sql","release")@
		@:pushStr(s->op1.sval)@
		@:SQLpostlude@
		break;
	case st_commit: {
		char *name = s->op2.sval;
		@:SQLprelude@
		@:newStmt("sql","commit")@
		@:pushInt(s->op1.ival)@
		@:pushStr(name?name:"")@
		@:SQLpostlude@
	} break;
	case st_rollback: {
		char *name = s->op2.sval;
		@:SQLprelude@
		@:newStmt("sql","rollback")@
		@:pushInt(s->op1.ival)@
		@:pushStr(name?name:"")@
		@:SQLpostlude@
	} break;
	case st_schema: {
		@:SQLprelude@
		schema *sc = s->op1.schema;
		@:newStmt("sql","bindSchema")@
		@:pushStr(sc->name)@
		@:SQLpostlude@
	} break;
	case st_table: {
		int sc = sql2MAL(m,mb, s->op1.stval, sql);
		table *t = s->op2.tval;
		@:SQLprelude@
		@:newStmt("sql","bindTable")@
		@:pushArg(sc)@
		@:pushStr(t->name)@
		@:SQLpostlude@
	} break;
	case st_column: {
		int t = sql2MAL(m,mb, s->op1.stval, sql);
		column *c = s->op2.cval;
		@:SQLprelude@
		@:newStmt("sql","bindColumn")@
		@:pushArg(t)@
		@:pushStr(c->name)@
		@:SQLpostlude@
	} break;
	case st_key: {
		int t = sql2MAL(m,mb, s->op1.stval, sql);
		key *k = s->op2.kval;
		node *cc;

		@:SQLprelude@
		@:newStmt("sql","bindKey")@
		@:pushArg(t)@
		@:pushStr(k->name)@
		@:SQLpostlude@
	} break;
	case st_create_schema: {
		schema *schema = s->op1.schema;
		@:SQLprelude@
		@:newStmt("sql","createSchema")@
		@:pushStr(schema->name)@
		@:pushStr(schema->auth)@
		@:SQLpostlude@
	} break;
	case st_drop_schema: {
		@:SQLprelude@
		@:newStmt("sql","dropSchema")@
		@:pushStr(s->op1.schema->name)@
		@:SQLpostlude@
	} break;
	case st_create_table: {
		int sc = sql2MAL(m,mb, s->op1.stval, sql);
		table *t = s->op2.tval;
		@:SQLprelude@
		if (t->sql){
			@:newStmt("sql","createView")@
			@:pushStr(t->name)@
			@:pushStr(t->sql)@
		} else {
			@:newStmt("sql","createTable")@
			@:pushStr(t->name)@
			@:pushInt(t->type)@
		}
		@:SQLpostlude@
	} break;
	case st_drop_table: {
		int sc = sql2MAL(m,mb, s->op1.stval, sql);
		@:SQLprelude@
		@:newStmt("sql","dropTable")@
		@:pushStr(s->op2.sval)@
		@:pushBit((s->flag==0)?"false":"true")@
		@:SQLpostlude@
	} break;
	case st_create_column: {
		int t = sql2MAL(m,mb, s->op1.stval, sql);
		column *c = s->op2.cval;
		@:SQLprelude@
		@:newStmt("sql","createColumn")@
		@:pushStr(c->name)@
		@:pushStr(c->tpe->type->sqlname)@
		@:pushInt(c->tpe->digits)@
		@:pushInt(c->tpe->scale)@
		@:pushInt(c->colnr)@
		@:SQLpostlude@
	} break;
	case st_null: {
		int c = sql2MAL(m,mb, s->op1.stval, sql);
		@:SQLprelude@
		/* the column context is already known */
		@:newStmt("sql","setNotNull")@
		@:pushInt(0)@
		@:SQLpostlude@
	} break;
	case st_default: {
		int c = sql2MAL(m,mb, s->op1.stval, sql);
		int d = sql2MAL(m,mb, s->op2.stval, sql);
		@:SQLprelude@
		@:newStmt("calc","str")@
		@:pushArg(d)@
		@:getReturn(d)@
		@:newStmt("sql","mvc_default")@
		@:pushArg(c)@
		@:pushArg(d)@
		@:SQLpostlude@
	} break;
	/* todo: change to simple mvc_create_key(key, list_of_string); */
	case st_create_key: {
		node *n;
		key *ky = s->op1.kval;
		int r;
		str sv;
		@:SQLprelude@
		@:newStmt("bbp","new")@
		@:pushArgId("str")@
		@:pushArgId("int")@
		@:getReturn(r)@
		for(n=ky->columns->h; n; n=n->next){
			kc *kc= n->data;
			@:newStmt("bat","insert")@
			@:pushArg(r)@
			@:pushStr(kc->c->name)@
			@:pushInt(kc->trunc)@
		}
		if (s->flag == fkey){
			int ft = sql2MAL(m,mb, s->op2.stval, sql);
			@:newStmt("sql","createKey")@
			/* @:pushStr(ky->t->schema->name)@
			@:pushStr(ky->t->name)@ */
			sv= (ky->name)?ky->name:"";
			@:pushStr(sv)@
			@:pushInt(ky->type)@
			@:pushArg(r)@
			@:pushArg(ft)@
		} else {
			@:newStmt("sql","createKey")@
			/* @:pushStr(ky->t->schema->name)@
			@:pushStr(ky->t->name)@ */
			sv= (ky->name)?ky->name:"";
			@:pushStr(sv)@
			@:pushInt(ky->type)@
			@:pushArg(r)@
			@:pushNil@
		}
		@:SQLpostlude@
	} break;
	case st_create_role:{
		@:SQLprelude@
		@:newStmt("sql","createRole")@
		@:pushStr(s->op1.sval)@
		@:pushInt(s->flag)@
		@:SQLpostlude@
	} break;
	case st_drop_role:{
		@:SQLprelude@
		@:newStmt("sql","dropRole")@
		@:pushStr(s->op1.sval)@
		@:SQLpostlude@
	} break;
	case st_grant_role:{
		@:SQLprelude@
		@:newStmt("sql","grantRole")@
		@:pushStr(s->op1.sval)@
		@:pushStr(s->op2.sval)@
		@:SQLpostlude@
	} break;
	case st_revoke_role:{
		@:SQLprelude@
		@:newStmt("sql","revokeRole")@
		@:pushStr(s->op1.sval)@
		@:pushStr(s->op2.sval)@
		@:SQLpostlude@
	} break;
	case st_select: {
		int l = sql2MAL(m,mb, s->op1.stval, sql);
		int r = sql2MAL(m,mb, s->op2.stval, sql);

		@:SQLprelude@
		if (s->op2.stval->nrcols >= 1){
			char *op = "=";
			switch(s->flag){
			case cmp_equal: op = "="; break;
			case cmp_notequal: op = "!="; break;
			case cmp_lt: op = "<"; break;
			case cmp_lte: op = "<="; break;
			case cmp_gt: op = ">"; break;
			case cmp_gte: op = ">="; break;
			default:
				GDKerror("Unknown operator");
	  		} 
			@:newStmt("multiplex","tactics")@
			@:pushStr(op)@
			@:pushArg(l)@
			@:pushArg(r)@
			@:getReturn(k)@
			@:newStmt("algebra","select")@
			@:pushArg(k)@
			@:pushBit("true")@
		} else {
		switch(s->flag){
		case cmp_equal:{
			int t1,t2;
			@:getTailType(t1,l)@
			@:getType(t2,r)@
			/* change void into type */
			if( t2==0) {
				str nme= malTypeName(t1);
				@:newStmt("calc",nme)@
				@:pushArg(r)@
				@:getReturn(r)@
				GDKfree(nme);
			}
			@:newStmt("algebra","uselect")@
			@:pushArg(l)@
			@:pushArg(r)@
			@:SQLpostlude@
			break;
			}
		case cmp_notequal:{
			int t1,t2;
			@:getTailType(t1,l)@
			@:getType(t2,r)@
			/* change void into type */
			if( t2==0) {
				str nme= malTypeName(t1);
				@:newStmt("calc",nme)@
				@:pushArg(r)@
				@:getReturn(r)@
				GDKfree(nme);
			}
			@:newStmt("algebra","uselect")@
			@:pushArg(l)@
			@:pushArg(r)@
			@:getReturn(k)@
			@:newStmt("algebra","kdiff")@
			@:pushArg(l)@
			@:pushArg(k)@
			break;
		}
		case cmp_lt:
		/* rewrite [in> to expanded format */
			@:newStmt("calc",tail_type(s)->type->name)@
			@:pushNilType(tail_type(s)->type->name)@
			@:getReturn(k)@

			@:newStmt("algebra","select")@
			@:pushArg(l)@
			@:pushArg(k)@
			@:pushArg(r)@
			@:getReturn(k2)@

			@:newStmt("batcalc","oid")@
			@:pushArg(k2)@
			@:getReturn(k2)@

			@:newStmt("bat","reverse")@
			@:pushArg(k2)@
			@:getReturn(k2)@

			@:newStmt("bat","setWriteMode")@
			@:pushArg(k2)@
			@:getReturn(k2)@

			@:newStmt("bat","delete")@
			@:pushArg(k2)@
			@:pushArg(k)@
			@:getReturn(k2)@

			@:newStmt("bat","delete")@
			@:pushArg(k2)@
			@:pushArg(r)@
			@:getReturn(k2)@

			@:newStmt("bat","reverse")@
			@:pushArg(k2)@
			@:getReturn(k2)@

			break;
		case cmp_lte:
			@:newStmt("calc",tail_type(s)->type->name)@
			@:pushNilType(tail_type(s)->type->name)@
			@:getReturn(k)@

			@:newStmt("algebra","uselect")@
			@:pushArg(l)@
			@:pushArg(k)@
			@:pushArg(r)@
			@:SQLpostlude@
			break;
		case cmp_gt:
		/* rewrite <in] to expanded format */
			@:newStmt("calc",tail_type(s)->type->name)@
			@:pushNilType(tail_type(s)->type->name)@
			@:getReturn(k)@

			@:newStmt("algebra","select")@
			@:pushArg(l)@
			@:pushArg(r)@
			@:pushArg(k)@
			@:getReturn(k2)@

			@:newStmt("batcalc","oid")@
			@:pushArg(k2)@
			@:getReturn(k2)@

			@:newStmt("bat","reverse")@
			@:pushArg(k2)@
			@:getReturn(k2)@

			@:newStmt("bat","setWriteMode")@
			@:pushArg(k2)@
			@:getReturn(k2)@

			@:newStmt("bat","delete")@
			@:pushArg(k2)@
			@:pushArg(k)@
			@:getReturn(k2)@

			@:newStmt("bat","delete")@
			@:pushArg(k2)@
			@:pushArg(r)@
			@:getReturn(k2)@

			@:newStmt("bat","reverse")@
			@:pushArg(k2)@
			@:getReturn(k2)@

			break;
		case cmp_gte: 
			@:newStmt("calc",tail_type(s)->type->name)@
			@:pushNilType(tail_type(s)->type->name)@
			@:getReturn(k)@

			@:newStmt("algebra","uselect")@
			@:pushArg(l)@
			@:pushArg(r)@
			@:pushArg(k)@
			break;
		default:
			GDKerror("SQL2MAL: error impossible\n");
	  	} 
		}
		@:SQLpostlude@
	} break;
	case st_select2: {
		int l = sql2MAL(m,mb, s->op1.stval, sql);
		int r1 = sql2MAL(m,mb, s->op2.stval, sql);
		int r2 = sql2MAL(m,mb, s->op3.stval, sql);
		@:SQLprelude@
		switch(s->flag){
		case cmp_equal:
			@:newStmt("algebra","select")@
			@:pushArg(l)@
			@:pushArg(r1)@
			@:pushArg(r2)@
			break;
		case cmp_notequal: 
			@:newStmt("algebra","select")@
			@:pushArg(l)@
			@:pushArg(r1)@
			@:pushArg(r2)@
			@:getReturn(k)@

			@:newStmt("algebra","kdiff")@
			@:pushArg(l)@
			@:pushArg(k)@
			break;
		}
		@:SQLpostlude@
	} break;
	case st_like: {
		int l = sql2MAL(m,mb, s->op1.stval, sql);
		int r = sql2MAL(m,mb, s->op2.stval, sql);
		@:SQLprelude@
		@:newStmt("algebra","likeselect")@
		@:pushArg(l)@
		@:pushArg(r)@
		@:SQLpostlude@
	} break;
	case st_semijoin: {
		int l = sql2MAL(m,mb, s->op1.stval, sql);
		int r = sql2MAL(m,mb, s->op2.stval, sql);
		@:SQLprelude@
		@:newStmt("algebra","semijoin")@
		@:pushArg(l)@
		@:pushArg(r)@
		@:SQLpostlude@
	} break;
	case st_diff: {
		int l = sql2MAL(m,mb, s->op1.stval, sql);
		int r = sql2MAL(m,mb, s->op2.stval, sql);
		@:SQLprelude@
		@:newStmt("algebra","kdiff")@
		@:pushArg(l)@
		@:pushArg(r)@
		@:SQLpostlude@
	} break;
	case st_intersect: {
		int l = sql2MAL(m,mb, s->op1.stval, sql);
		int r = sql2MAL(m,mb, s->op2.stval, sql);
		@:SQLprelude@
		@:newStmt("algebra","sintersect")@
		@:pushArg(l)@
		@:pushArg(r)@
		@:SQLpostlude@
	} break;
	case st_union: {
		int l = sql2MAL(m,mb, s->op1.stval, sql);
		int r = sql2MAL(m,mb, s->op2.stval, sql);
		@:SQLprelude@
		@:newStmt("algebra","kunion")@
		@:pushArg(l)@
		@:pushArg(r)@
		@:SQLpostlude@
	} break;
	case st_outerjoin:
	case st_join: {
		int l = sql2MAL(m,mb, s->op1.stval, sql);
		int r = sql2MAL(m,mb, s->op2.stval, sql);
		char *jt = "join";
		@:SQLprelude@
		if (s->type == st_outerjoin)
			jt = "outerjoin";
		switch(s->flag){
		case cmp_equal:
			@:newStmt("algebra",jt)@
			@:pushArg(l)@
			@:pushArg(r)@
			@:SQLpostlude@
			break;
		case cmp_notequal:
			@:newStmt("algebra",jt)@
			@:pushArg(l)@
			@:pushArg(r)@
			@:pushStr("!=")@
			@:SQLpostlude@
			break;
		case cmp_lt:
			@:newStmt("algebra",jt)@
			@:pushArg(l)@
			@:pushArg(r)@
			@:pushStr("<")@
			@:SQLpostlude@
			break;
		case cmp_lte: 
			@:newStmt("algebra",jt)@
			@:pushArg(l)@
			@:pushArg(r)@
			@:pushStr("<=")@
			@:SQLpostlude@
			break;
		case cmp_gt: 
			@:newStmt("algebra",jt)@
			@:pushArg(l)@
			@:pushArg(r)@
			@:pushStr(">")@
			@:SQLpostlude@
			break;
		case cmp_gte: 
			@:newStmt("algebra",jt)@
			@:pushArg(l)@
			@:pushArg(r)@
			@:pushStr(">=")@
			@:SQLpostlude@
			break;
		case cmp_all: /* aka cross table */
			@:newStmt("bat","reverse")@
			@:pushArg(r)@
			@:getReturn(k)@

			@:newStmt("algebra","project")@
			@:pushArg(k)@
			@:pushInt(0)@
			@:getReturn(k)@

			@:newStmt("bat","reverse")@
			@:pushArg(k)@
			@:getReturn(k)@

			@:newStmt("algebra","project")@
			@:pushArg(l)@
			@:pushInt(0)@
			@:getReturn(k2)@

			@:newStmt("algebra","join")@
			@:pushArg(k2)@
			@:pushArg(k)@
			@:SQLpostlude@
			break;
		default:
			GDKerror("SQL2MAL: error impossible\n");
	  	} 
	break;
	}
	case st_bat:
	case st_ubat: {
		char *type = (s->type==st_bat)?"":"Ubat";
		char buf[256];

		@:SQLprelude@
		if( s->op1.cval->table->type == tt_view){
			sql2MAL(m,mb, s->op1.cval->s, sql);
		} else {
			char *hname = NULL;
			int k;
                        if (s->h->type == st_basetable){
                                hname = s->h->op1.tval->name;
                        }
			snprintf(buf,256,"bind%s",type);
			@:newStmt("sql",buf)@
			@:pushStr(s->op1.cval->table->schema->name)@
			@:pushStr(s->op1.cval->table->name)@
			@:pushStr(s->op1.cval->name)@
			@:pushInt(s->flag)@
			@:getReturn(k)@

			/* Get type information from catalog */
			BAT *b= mvc_bind(m, 
			s->op1.cval->table->schema->name, 
			s->op1.cval->table->name,
			s->op1.cval->name,0);
			if(b)
			@:setReturnType(b->htype,b->ttype)@
                        
			if( s->flag >RDONLY) {
				@:newStmt("bat","setWriteMode")@
				@:pushArg(k)@
			} 
			@:SQLpostlude@

		}
	} break;
	case st_dbat:
	case st_obat: {
		char type = (s->type==st_dbat)?'D':'O';
		int k;
		@:SQLprelude@
		snprintf(buf,BUFSIZ,"bind%cbat", type);
		@:newStmt("sql",buf)@
		@:pushStr(s->op1.tval->schema->name)@
		@:pushStr(s->op1.tval->name)@
		@:pushInt(s->flag)@
		@:getReturn(k)@
		if( s->flag >RDONLY) {
			@:newStmt("bat","setWriteMode")@
			@:pushArg(k)@
		}
		@:SQLpostlude@
	} break;
	case st_reverse: {
		int l = sql2MAL(m,mb, s->op1.stval, sql);
		@:SQLprelude@
		@:newStmt("bat","reverse")@
		@:pushArg(l)@
		@:SQLpostlude@
	} 	break;
	case st_count: {
		int l = sql2MAL(m,mb, s->op1.stval, sql);
		@:SQLprelude@
		@:newStmt("bat","count")@
		@:pushArg(l)@
		@:SQLpostlude@
	} 	break;
	case st_const: {
		int l = sql2MAL(m,mb, s->op1.stval, sql);
		int r = sql2MAL(m,mb, s->op2.stval, sql);
		@:SQLprelude@
		@:newStmt("bat","project")@
		@:pushArg(l)@
		@:pushArg(r)@
		@:SQLpostlude@
	} 	break;
	case st_mark: {
		int l = sql2MAL(m,mb, s->op1.stval, sql);
		char *tname = NULL;
		@:SQLprelude@

                if (s->t && s->t->type == st_basetable){
                        tname = s->t->op1.tval->name;
                }

		@:SQLprelude@
		if (s->op2.stval){
			int r = sql2MAL(m,mb, s->op2.stval, sql);
			@:newStmt("bat","reverse")@
			@:pushArg(l)@
			@:getReturn(k)@

			@:newStmt("calc","oid");
			@:pushArg(r)@
			@:getReturn(k2)@

			@:newStmt("algebra","mark");
			@:pushArg(k)@
			@:pushArg(k2)@
			@:getReturn(k)@

			@:newStmt("bat","reverse");
			@:pushArg(k)@
		} else if (s->flag >= 0){
			@:newStmt("bat","reverse")@
			@:pushArg(l)@
			@:getReturn(k)@

			@:newStmt("calc","oid");
			@:pushInt(s->flag)@
			@:getReturn(k2)@

			@:newStmt("algebra","mark");
			@:pushArg(k)@
			@:pushArg(k2)@
			@:getReturn(k)@

			@:newStmt("bat","reverse");
			@:pushArg(k)@
		} else {
			@:newStmt("bat","reverse")@
			@:pushArg(l)@
			@:getReturn(k)@

			@:newStmt("algebra","mark");
			@:pushArg(k)@
			@:getReturn(k)@

			@:newStmt("bat","reverse");
			@:pushArg(k)@
		}
		@:SQLpostlude@
	} 	break;
	case st_group: {
		int l = sql2MAL(m,mb, s->op1.stval, sql);
		@:SQLprelude@
		@:newStmt("group","group")@
		@:pushArg(l)@
		@:SQLpostlude@
	} 	break;
	case st_group_ext: {
		int l = sql2MAL(m,mb, s->op1.stval, sql);
		@:SQLprelude@
		@:newStmt("algebra","tunique")@
		@:pushArg(l)@
		@:getReturn(k)@
		@:newStmt("bat","mirror")@
		@:pushArg(k)@
		@:SQLpostlude@
	} 	break;
	case st_derive: {
		int l = sql2MAL(m,mb, s->op1.stval, sql);
		int r = sql2MAL(m,mb, s->op2.stval, sql);
		@:SQLprelude@
		@:newStmt("group","group")@
		@:pushArg(l)@
		@:pushArg(r)@
		@:SQLpostlude@
	} 	break;
	case st_unique: {
		int l = sql2MAL(m,mb, s->op1.stval, sql);
		@:SQLprelude@
		if (s->op2.gval){
			int g = sql2MAL(m,mb, s->op2.gval->grp, sql);

			@:newStmt("group","group")@
			@:pushArg(g)@
			@:pushArg(l)@
			@:getReturn(k)@

			@:newStmt("algebra","tunique")@
			@:pushArg(k)@
			@:getReturn(k2)@

			@:newStmt("algebra","mirror")@
			@:pushArg(k2)@
			@:getReturn(k2)@

			@:newStmt("algebra","semijoin")@
			@:pushArg(l)@
			@:pushArg(k2)@
		} else {
			@:newStmt("bat","reverse")@
			@:pushArg(l)@
			@:getReturn(k)@
			@:newStmt("algebra","kunique")@
			@:pushArg(k)@
			@:getReturn(k)@
			@:newStmt("bat","reverse")@
			@:pushArg(k)@
		}
		@:SQLpostlude@
	} 	break;
	case st_limit: {
		int l = sql2MAL(m,mb, s->op1.stval, sql);
		int k;

		@:SQLprelude@
		@:newStmt("calc","-")@
		@:pushArg(l)@
		@:pushInt(1)@
		@:getReturn(k)@

		@:newStmt("bat","slice")@
		@:pushInt(0)@
		@:pushArg(k)@
		@:SQLpostlude@
		break;
	}
	case st_order: {
		int l = sql2MAL(m,mb, s->op1.stval, sql);
		@:SQLprelude@
		@:newStmt("bat","reverse")@
		@:pushArg(l)@
		@:getReturn(k)@

		@:newStmt("algebra","sort")@
		@:pushArg(k)@
		@:getReturn(k)@
		@:newStmt("bat","reverse")@
		@:pushArg(k)@
		@:SQLpostlude@
	} 	break;
	case st_reorder: {
		int l = sql2MAL(m,mb, s->op1.stval, sql);
		int r = sql2MAL(m,mb, s->op2.stval, sql);
		@:SQLprelude@
		@:newStmt("group","refine")@
		@:pushArg(l)@
		@:pushArg(r)@
		@:SQLpostlude@
		/* s->flag?"desc":"asc"); */
	} 	break;
	case st_op: {
		@:SQLprelude@
		@:newStmt(0,s->op4.funcval->imp)@
		@:SQLpostlude@
		break;
	}
	case st_unop: {
		int l = sql2MAL(m,mb, s->op1.stval, sql);
		@:SQLprelude@
		if (s->op1.stval->nrcols){
			@:newStmt("multiplex","tactics")@
			@:pushStr(s->op4.funcval->imp)@
			@:pushArg(l)@
		} else {
			@:newStmt(0, s->op4.funcval->imp)@
			@:pushArg(l)@
		}
		@:SQLpostlude@
	} 	break;
	case st_binop: {
		int l = sql2MAL(m,mb, s->op1.stval, sql);
		int r = sql2MAL(m,mb, s->op2.stval, sql);
		@:SQLprelude@
		if (s->op1.stval->nrcols || s->op2.stval->nrcols ){
		  	if (!s->op1.stval->nrcols){
				/* "s%d := [s%d ~ s%d];\n", n, r, l ); */
				@:newStmt("batcalc","zipper")@
				@:pushArg(r)@
				@:pushArg(l)@
				l = getDestVar(q);
		  	}
		  	if (!s->op2.stval->nrcols){
				@:newStmt("batcalc","zipper")@
				@:pushArg(l)@
				@:pushArg(r)@
				r = getDestVar(q);
		  	}
			@:newStmt("multiplex","tactics")@
			@:pushStr(s->op4.funcval->imp)@
			@:pushArg(l)@
			@:pushArg(r)@
		} else  {
			@:newStmt("multiplex", "tactics")@
			@:pushStr(s->op4.funcval->imp)@
			@:pushArg(l)@
			@:pushArg(r)@
		}
		@:SQLpostlude@
	} 	break;
	case st_triop: {
		stmt *op1 = s->op1.lval->h->data;
		stmt *op2 = s->op1.lval->h->next->data;
		stmt *op3 = s->op1.lval->h->next->next->data;
		int r1 = sql2MAL(m,mb, op1, sql);
		int r2 = sql2MAL(m,mb, op2, sql);
		int r3 = sql2MAL(m,mb, op3, sql);
		@:SQLprelude@
		if (op1->nrcols || op2->nrcols || op3->nrcols){
			int l = 0;
			if (op1->nrcols) l = r1;
			if (op2->nrcols) l = r2;
			if (op3->nrcols) l = r3;
		  	if (!op1->nrcols){
				@:newStmt("batcalc","zipper")@
				@:pushArg(l)@
				@:pushArg(r1)@
				r1= getDestVar(q);
		  	}
		  	if (!op2->nrcols){
				@:newStmt("batcalc","zipper")@
				@:pushArg(l)@
				@:pushArg(r2)@
				r2= getDestVar(q);
		  	}
		  	if (!op3->nrcols){
				@:newStmt("batcalc","zipper")@
				@:pushArg(l)@
				@:pushArg(r3)@
				r3= getDestVar(q);
		  	}
			@:newStmt("multiplex","tactics")@
			@:pushStr(s->op4.funcval->imp)@
			@:pushArg(r1)@
			@:pushArg(r2)@
			@:pushArg(r3)@
		} else {
			@:newStmt(0,s->op4.funcval->imp)@
			@:pushArg(r1)@
			@:pushArg(r2)@
			@:pushArg(r3)@
		}
		@:SQLpostlude@
	} 	break;
	case st_aggr: {
		int l = sql2MAL(m,mb, s->op1.stval, sql);

		@:SQLprelude@
		if (s->op3.gval){
			int g = sql2MAL(m,mb, s->op3.gval->grp, sql);
			int e = sql2MAL(m,mb, s->op3.gval->ext, sql);
			@:newStmt("multiplex","group")@
			@:pushStr(s->op4.aggrval->imp)@
			@:pushArg(l)@
			@:pushArg(g)@
			@:pushArg(e)@
		} else {
			@:newStmt(0,s->op4.aggrval->imp)@
			@:pushArg(l)@
		}
		@:SQLpostlude@
	} 	break;
	case st_atom: {
		int k;
		@:SQLprelude@
		k= constantAtom(mb,s->op1.aval,sql);
		@:newStmt(0,0)@
		@:pushArg(k)@
		@:SQLpostlude@
	} break;
	case st_insert: {
		int l = sql2MAL(m,mb, s->op1.stval, sql);
		int r = sql2MAL(m,mb, s->op2.stval, sql);
		@:SQLprelude@
		if (s->op2.stval->nrcols){
			@:newStmt("bat","setWriteMode")@
			@:pushArg(s->nr)@
			@:newStmt("bat","insert")@
			@:pushArg(l)@
			@:pushArg(r)@
		} else {
			@:newStmt("bat","insert")@
			@:pushArg(l)@
			@:pushArg(r)@
		}
		@:SQLpostlude@
	} break;
	case st_append:{
                int l = sql2MAL(m, mb, s->op1.stval, sql );
                int r = sql2MAL(m, mb, s->op2.stval, sql );
                if (s->op2.stval->nrcols){
                        @:newStmt("bat","setWriteMode")@
                        @:pushArg(s->nr)@
                        @:newStmt("bat","append")@
                        @:pushArg(l)@
                        @:pushArg(r)@
                } else {
                        @:newStmt("bat","append")@
                        @:pushArg(l)@
                        @:pushArg(r)@
                }
                @:SQLpostlude@

	} break;
	case st_replace: {
		int l = sql2MAL(m,mb, s->op1.stval, sql);
		int r = sql2MAL(m,mb, s->op2.stval, sql);
		int k;
		@:SQLprelude@
		@:newStmt("bat","setWriteMode")@
		@:pushArg(l)@
		@:newStmt("bat","replace")@
		@:pushArg(l)@
		@:pushArg(r)@
		@:SQLpostlude@
	} break;
	case st_alias:
	case st_column_alias: {
		s->nr= sql2MAL(m,mb, s->op1.stval,sql);
	} break;
	case st_set: {
		for (n = s->op1.lval->h; n; n = n->next ){
			sql2MAL(m,mb, n->data, sql);
		}
	} break;
	case st_sets: {
		for(n = s->op1.lval->h; n; n->next ){
			list *l = n->data;
			node *ml = l->h;
			while(ml){
				sql2MAL(m,mb, ml->data,sql);
				ml = ml->next;
			}
		}
	} break;
	case st_copyfrom: {
		node *m = s->op2.lval->h;
		char *tsep = m->data;
		char *rsep = m->next->data;
		int k;

		@:SQLprelude@
		@:newStmt("bbp","new")@
		@:pushArgId("void")@
		@:pushArgId("str")@
		@:getReturn(k)@

		if( s->op3.lval){
			node *n;
			for(n= s->op3.lval->h; n; n= n->next){
				char *file= n->data;
				@:newStmt("bat","insert")@
				@:pushArg(k)@
				@:pushNil@
				@:pushStr(file)@
			}
		}
		@:newStmt("sql","importTable")@
		@:pushStr(s->op1.tval->name)@
		@:pushArg(k)@
		@:pushStr(tsep)@
		@:pushStr(rsep)@
		@:pushInt(s->flag)@
		@:SQLpostlude@
	} break;
	case st_ordered: {
		int l =  sql2MAL(m,mb, s->op1.stval, sql);
		sql2MAL(m,mb, s->op2.stval,sql);
		s->nr = l;
	} break;
	case st_output: {
		stmt *order = NULL; int flg=0;
		stmt *lst = s->op1.stval;
		int nr= sql2MAL(m,mb, lst, sql);

		if (lst->type == st_ordered){
			order = lst->op1.stval; 
			lst = lst->op2.stval; 
			flg=1;
		}
		if (lst->type == st_list){
			list *l = lst->op1.lval;

			n = l->h;
			if (n){
			  if (!order){
			    order = n->data;
			  }
			}
			/* first rename the columns for better output*/
			dump_header(mb,s,l);
			@:newStmt("sql","output")@
			if( flg){ @:pushArg(order->nr)@ }

			while(n){
				stmt *r;
				r = n->data;
				@:pushArg(r->nr)@
				n = n->next;
			}
		} else {
			@:newStmt("sql","print")@
			@:pushStr("not a valid output list\n")@
		}
	} break;
	case st_list: {
		for( n = s->op1.lval->h; n; n = n->next ){
			sql2MAL(m,mb, n->data, sql);
		}
	} break;

        /* todo */
        case st_basetable:
        case st_grant:
        case st_revoke:
        case st_ptable:
        case st_pivot:
                printf("not implemented stmt\n");
                assert(0);


	}
/*	if (s->nr == 0) s->nr = mb->stop;*/
    }
    return s->nr;
}

