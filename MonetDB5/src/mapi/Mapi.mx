@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2002 CWI.
@' All Rights Reserved.
@'
@' Contributor(s):
@'              Martin Kersten <Martin.Kersten@cwi.nl>
@'              Niels Nes <Niels.Nes@cwi.nl>
@'              Stefan Manegold <Stefan.Manegold@cwi.nl>
@'              Peter Boncz <Peter.Boncz@cwi.nl>
@f Mapi
@a M.L. Kersten
@v 2.0
@d August 2003
@* The Monet Application Programming Interface

The easiest way to extend the functionality of Monet is to construct
an independent Monet application, which communicates with a
running server using a database driver with a simple API and a textual protocol.
The effectivness of such an approach has been demonstrated by the wide
use of database API implementations, such as Perl DBI, PHP ADO, ODBC,...

The database driver implementation given in this document is 
focussed on developing applications in C/C++. The command collection 
have been chosen to align with common practice, i.e. queries follow
a prepare,execute,and fetch_row paradigm. An example of a mini
application below illustrates the main operations.
@T
#include <mapi.h>

#define die(X) {mapi_explain(X,stdout); exit(-1); }

main(int argc, char *argv){
	Mapi	*dbh;

	dbh= mapi_connect("localhost:50001","guest",0,"sql");
	if(mapi_error(dbh)) die(dbh);

	if( mapi_query(dbh,"create table emp(name varchar,age int)")) die(dbh);

	if( mapi_query(dbh,"insert into emp values(\"John\", 23)") ) die(dbh);

	if( mapi_query(dbh,"insert into emp values(\"Mary\", 22)") ) die(dbh);

	if( mapi_query("select * from emp") ) die(stmt);

	while( mapi_fetch_row(dbh)){
		char *nme = mapi_fetch_field(dbh,0);
		char *age = mapi_fetch_field(dbh,1);
		printf("person %s age %s\n", nme, age);
	}

	mapi_disconnect(dbh);
}
@-
The mapi_connect() operation establishes a communication channel
with a running server on the local machine. The user identification
is the ubiguitous guest, for whome we do not require a password.
The query language interface is "sql". Alternatives are the lower
level languages "mil" and "mal". Future versions are expected to
recognize also "xcore" and "xquery".

Errors on the interaction can be captured using mapi_error(), possibly
followed by a request to dump a short error message explanation on a
standard file location. It has been abstracted away in a macro.

Provided we can establish a connection, the interaction proceeds as
in many similar application development packages. Queries are shipped
for execution using mapi_query() and an answer table can be consumed
one row at a time. In many cases these functions suffice.

The tabular data exchange model is premarily meant to support sql
(mil,mal) For xml and xcore the engine is expected to generate
a Xpat-like token stream from which the application can built
the internal representatio of the document.

@+ Mapi library
The routines to build a Monet application are grouped in the library
Monet Application Programming Interface, or Mapi.

The protocol information is stored in a Mapi interface descriptor (mid),
which should be passed to the library routines in most cases.
The application can set up several channels with the same or a different
Monet server. It is the programmers responsibility not to mix the
descriptors in retrieving the results.

The application may be multi-threaded as long as the user respects
the individual connections represented by the database handlers.

The interface assumes a cautious user, who understands and has experience
with the Monet programming model. In particular, syntax errors may easily
lead to synchronization errors. It should also be clear that references
returned by the API point directly into the administrative structures of Mapi.
This means that they are valid only for a short period, mostly between
successive mapi_fetch_row commands.
A defensive programming style is adviced.
Upon an error, the routine mapi_explain gives information about the context of
the failed call, include the expression shipped and any response received.

@T
\begin{description}

\item[Mapi mapi_connect(char *host, int port, char *username, char *password, 
char *lang)]:
Setup a connection with a Monet server at a {\em host}:{\em port} and
login with {\em username} and {\em password}. If host == NULL, the
local host is accessed. If username == NULL, the username of the
owner of the client application containing the Mapi code is used.
If password == NULL, the password is ommited.
The preferred query language is any of \{sql,mil,mal,xcore,xquery\}\\
The command returns a structure with administration about the interconnect.
It also contains an explanation when connection to the server fails.

\item[Mapi mapi_dup(Mapi mid)]:
Setup a second communication channel using the parameter setting of
the previous on. 
\item[int mapi_disconnect(Mapi mid)]:
Terminates the session described by {\em mid}. Subsequent use 
of the channel represented by this descriptor leads to a failure.

\item[MapiMsg mapi_query(Mapi mid, char *Command)]:
This routine sends the Command to the database server represented by mid.
It is one of the most common operations. 
If Command is zero it takes the last query string kept around.
It returns zero upon success, otherwise it indicates a failure of the request.
The command response is buffered for consumption, e.g. mapi_fetch_row();

\item[MapiMsg mapi_query_array(Mapi mid, char *Command, char **argv)]:
This routine sends the Command to the database server replacing
the placeholders by the string arguments presented. The default placeholder
is the question mark (?), but also ':identifier' markers are recognized.

\item[ int mapi_num_fields(Mapi mid)]:
Return the number of fields in the current row.

\item[ int mapi_num_rows(Mapi mid)]:
Return the number of rows in the last select call. [ no guarantee given]
A -1 is returned if this information is not available.

\item[ int mapi_rows_affected(Mapi mid)]:
Called after a database update (INSERT/DELETE/REPLACE)
to determine the number of rows affected
by the command.

\item[ int mapi_fetch_row(Mapi mid)]:
This routine retrieves a row line from the server.
The text retrieved is kept around in a buffer linked with the session
descriptor from which selective fields can be extracted.
It returns the number of fields.
A zero is returned upon encountering end of sequence 
or error. This can be analysed in using mapi_error().

\item[ int mapi_fetch_row_all(Mapi mid)]:
All rows are cached at the client side first. Subsequent calls
to either mapi_fetch_row() and mapi_fetch_row_all() will take
the row from the cache. The number or rows cached 
can be obtained using mapi_rows_affected().
The value returned is the same as for mapi_fetch_row().

\item[ char **mapi_fetch_array(Mapi mid)]:
Returns an array of string pointers to the individual fields.
A zero is returned upon encountering end of sequence 
or error. This can be analysed in using mapi_error().

\item[ char *mapi_fetch_field(Mapi mid, int fnr)]:
Returns a pointer a C-string representation of the value returned.
A zero is returned upon encountering an error;
This can be analysed in using mapi_error().

\item [MapiMsg mapi_finish(Mapi mid)]:
This routine is used in the rare cases that consumption of the 
tuple stream produced should be prematurely terminated. It is automatically
called when a new query is shipped to the database.

\item [MapiMsg mapi_prepare(Mapi mid, char **Command)];
\item [int mapi_execute(Mapi mid, char **Command)];
\item [int mapi_execute_array(Mapi mid, char **Command, char **argv)];

\item [MapiMsg mapi_bind(Mapi mid, int varnr, int type, void *val);
Describe the type and location of the next parameter in a query template.
The types recognized are {SQL_INT, SQL_CHAR, SQL_VARCHAR, SQL_FLOAT, 
SQL_DOUBLE, SQL_TIME, SQL_DATE}.
The pointer should permit a dereference to gain access to the value.
The binding operations should be performed after the mapi_execute command.
Subsequently all rows being fetched also involve delivery of the field
values in the C-variables using proper conversion. For variable length
strings a pointer is set into the cache.

\item[ MapiMsg mapi_cache_limit(Mapi mid, int maxrows)]:
A limited number of tuples are pre-fetched after each execute().
If maxrows is negative, all rows will be fetched before the
application is permitted to continue. The previous cache size is
returned.

\item [MapiMsg mapi_reset(Mapi mid)];
Reset the row pointer to the first row in the row cache.
This is mostly used in combination with fetching all tuples at once.

\item[char * mapi_quote(char *name)]:
Strings in the database should be surrounded by double quotes and
escape of the charactes \n,\t,...
\item[char * mapi_unquote(char *name)]:
The reverse action of mapi_quote(), turning the database representation
into a C-representation. The storage space is dynamically created and
should be freed after use.

\item [MapiMsg mapi_ping(Mapi mid)]:
Test avalability of the server. Returns zero upon success.

\end{description}

The remaining operations are wrappers around the datastructures
maintained. Note that column properties are derived from the
table output returned from the server. 
\begin{description}
\item[ char *mapi_get_name(Mapi mid, int fnr)]:
\item[ char *mapi_get_table(Mapi mid, int fnr)]:
\item[ int mapi_get_type(Mapi mid, int fnr)]:
\item[ int mapi_get_len(Mapi mid, int fnr)]:

\item[ char *mapi_get_host(Mapi mid)]:
\item[ char *mapi_get_user(Mapi mid)]:
\item[ char *mapi_get_lang(Mapi mid)]:
\item[ char *mapi_get_server(Mapi mid)]:

\item[ char **mapi_list_fields(Mapi mid, char  *tablename)]:


\item[MapiMsg mapi_error(Mapi mid)]:
Returns the last error code or 0 if there is no error.

\item[char *mapi_error_str(Mapi mid)]:
Returns a pointer to the last error message.

\item[MapiMsg mapi_explain(Mapi mid, FILE *fd)]:
Writes the error message obtained from Monet to a file.

\item[MapiMsg mapi_stat(Mapi mid)]:
Retrieves a table with statistics on the use of the Mapi interface.
(illustrate)

%\item[int mapi_timeout(Mapi mid, int timeout)]:
%Sets the time out time in milli seconds for all subsequent
%Mapi commands. Default value is 0, wait indefinitely.

\item [char **mapi_tables(Mapi mid)]:
Returns a list of accessible database tables.

\item [char **mapi_fields(Mapi mid)]:
Returns a list of accessible tables fields. This can also be obtained
by inspecting the field descriptor returned by mapi_fetch_field.

\end{description}
@

@- Error message
@T
The Mapi interface calls return one of the following codes.\\

\begin{tabular}{l l}
MOK  & No error \\
MERROR  & Mapi internal error.\\
\end{tabular}
@
@{
@+ Implementation
@h

#include  <stdio.h>
#include  <stream.h>

#include  <sys/types.h>
#ifdef HAVE_SYS_SOCKET_H
# include <sys/socket.h>
#endif
#ifdef HAVE_WINSOCK_H
# include <winsock.h>
#endif

#ifdef AIX
#define SOCKPTR struct sockaddr *
#define SOCKLEN size_t
#else
#ifdef __sgi
#define SOCKPTR void *
#define SOCKLEN int
#else
#define SOCKPTR struct sockaddr *
#if HAVE_SOCKLEN_T
#define SOCKLEN socklen_t
#else
#define SOCKLEN int
#endif
#endif
#endif

#ifdef NATIVE_WIN32
#define s_close closesocket
#else
#define s_close close
#endif

#define NAMELEN	256
#define ERRLEN	1024
#define MAPIBLKSIZE 256	/* minimum buffer shipped */
#define REPLYBUFFER MAPIBLKSIZE*1024*32	/* seems large enough */
#define QRYLEN	32*MAPIBLKSIZE 
				
#define SQL_AUTO	0	/* automatic type detection */
#define SQL_INT		1
#define SQL_CHAR	2
#define SQL_VARCHAR	3	
#define SQL_FLOAT	4
#define SQL_DOUBLE	5
#define SQL_TIME	6
#define SQL_DATE	7

typedef int MapiMsg;

#define MOK	0
#define MERROR	-1
#define MTIMEOUT	-2

#define COUNT(M,X)	(M)->counts[X]++;
#define PROMPTBEG		'\001'	/* start prompt bracket */
#define PROMPTEND		'\002'	/* end prompt bracket */

typedef struct{
	char tablename[NAMELEN];
	char columnname[NAMELEN];
	int  colwidth;
	void *binding;		/* to application variable */
	int  type;
	int  precision;
	int  scale;
	int  isnull;		/* global table property */
} MapiField;

typedef struct {
	int rowlimit;	/* maximal number of rows to cache */
	int limit;	/* current storage space limit */
	int writer;	/* current maximal storage */
	int reader; /* what has been consumed so far */
	int  *cnt;	/* actual number of fields in each row */
	char **rows;	/* string representation of rows received */
	char ***anchors;/* corresponding field pointers */
} MapiRowBuf;

typedef struct {
	char server[NAMELEN];	/* server welcome message */
	char hostname[NAMELEN];
	int  port;
	char username[NAMELEN];
	char password[NAMELEN];
	char lang[NAMELEN];
	char prompt[NAMELEN];
	int  counts[20];	/* statistics maintained */


	int everything;
	int trace;		/* Trace Mapi interaction */
	int error;		/* Error occurred */
	char *errorstr;	/* pointer to constant string */

	int active;		/* set when not all rows have been received */
	char *qrytail;	/* free space in querytext */
	char *querytext; 

	int	fieldcnt;	/* the table report section */
	int	rows_affected;	/* mostly unknown */
	int 	maxfields;
	MapiField *fields;
	MapiRowBuf cache;

	stream *from, *to;
} MapiStruct, *Mapi;


#define mapi_error(x)	((x)->error)
#define Metext(x)	((x)->errorstr)

#ifdef __cplusplus
extern "C" {
#endif

#ifdef _MSC_VER
#ifndef LIBMAPI
#define mapi_export extern __declspec(dllimport) 
#else
#define mapi_export extern __declspec(dllexport) 
#endif
#else
#define mapi_export extern 
#endif

mapi_export MapiMsg mapi_bind(Mapi mid, int fnr, int type, void *ptr) ;
mapi_export MapiMsg mapi_query(Mapi mid,char *cmd);
mapi_export Mapi mapi_connect(char *host, int port, char *username,
	 char *password, char *lang);
mapi_export MapiMsg mapi_disconnect(Mapi mid);
mapi_export MapiMsg mapi_finish(Mapi mid);
mapi_export MapiMsg mapi_stat(Mapi mid);
mapi_export MapiMsg mapi_explain(Mapi mid, FILE *fd);
mapi_export MapiMsg mapi_reset_cache(Mapi mid);
mapi_export int mapi_timeout(Mapi mid, int time);
mapi_export char * mapi_fetch_line(Mapi mid);
mapi_export int mapi_fetch_row(Mapi mid);
mapi_export char *mapi_fetch_field(Mapi mid, int fnr);
mapi_export char **mapi_fetch_field_array(Mapi mid);
mapi_export int mapi_num_fields(Mapi mid);
mapi_export int mapi_num_rows(Mapi mid);
mapi_export int mapi_rows_affected(Mapi mid);
mapi_export char *mapi_get_host(Mapi mid);
mapi_export char *mapi_get_user(Mapi mid);
mapi_export char *mapi_get_lang(Mapi mid);
mapi_export char *mapi_get_server(Mapi mid);

static void promptMonet(Mapi mid);
static Mapi mapi_new();
static int mapi_get_row(Mapi mid) ;
static void mapi_check_query(Mapi mid, char *qry);
static void  mapi_extend_cache(Mapi mid);
static int mapi_extend_fields(Mapi mid);
static int mapi_slice_row(Mapi mid);

#ifdef __cplusplus
}
#endif

@
@+ Mapi functions.
The Monet application interface commands are described below.
They have been developed to ease interaction.

@c
#include   "Mapi.h"
#include  <gdk.h>

#include  <stdio.h>
#include  <sys/types.h>
#include  <sys/socket.h>

#include  <signal.h>
#include  <string.h>
#include  <memory.h>

#if TIME_WITH_SYS_TIME
# include <sys/time.h>
# include <time.h>
#else
# if HAVE_SYS_TIME_H
#  include <sys/time.h>
# else
#  include <time.h>
# endif
#endif

/* Used in mapi_stat:
   #events Mcommands[i] are counted in counts[i]: */
char *Mcommands[]={
	"Unknown command",
	"mapi_connect",
	"mapi_disconnect",
	"Msend",
	"Mquery",
	"Mfetch",
	"Mget",
	"Mbatch",
	"--  total   --",
	"Mbatchreset",
	"____",
	"mapi_explain",
	"Mreset",
	"mapi_timeout",
	"-- internal --",	/* low level routines */
	"mapi_bind",
	"Mfield",
	"mapi_query",
	"mapi_finish",
	"mapi_get_row",
	0};


@+ Channel constructor
The first call of an application is to establish a connection with
an already server. The username and password are sent as part of
the initialization sequence.
Future versions may be allowed to set the username and will also
provide a secure socket layer support.
@c
Mapi mapi_new() {
	Mapi m;
	m = (Mapi) malloc(sizeof(MapiStruct));
	assert(m);
        m->querytext= (char *) malloc(MAPIBLKSIZE);
	assert(m->querytext);
	m->qrytail= m->querytext;

	m->trace = 1;
	m->everything = 1;
	m->error= MOK;
	strcpy(m->hostname,"localhost");

	m->maxfields = 64;
	m->fields = (MapiField *) malloc( 64 * sizeof(MapiField));
	assert(m->fields);
	m->cache.rowlimit= 100;
	m->cache.limit= 0;
	m->cache.writer= 0;
	m->cache.reader= -1;
	return m;
}

Mapi Mdup(Mapi mid) {
	Mapi m;
	assert(mid);
	COUNT(mid,10);
	m= mapi_new();
	if( mid){
		m->to= mid->to;
		m->from= mid->from;
		strcpy(m->hostname, mid->hostname);
		strcpy(m->username, mid->username);
		strcpy(m->password, mid->password);
		strcpy(m->prompt, mid->prompt);
		m->port= mid->port;
	}
	return m;
}
static
int mapi_setError(Mapi mid, char *msg){
	assert(mid);
	mid->error = MERROR;
	mid->errorstr = msg;
}
Mapi mapi_connect_ssl(char *host, int port, char *username, char *password, char *lang) {
	Mapi mid = mapi_connect(host,port,username,password,lang);
	mapi_setError(mid,"SSL connections not yet supported");
	return mid;
}
Mapi mapi_connect(char *host, int port, char *username, char *password, char *lang) {
	struct hostent *hp;
	struct sockaddr_in server;
	int s;
	char *defport;
	Mapi mid;

	mid= mapi_new();
	mid->trace=1;

	COUNT(mid,1);
	if(host) strcpy(mid->hostname,host); 
	
	if(port) mid->port = port; 
	else {
	    if((defport = getenv("MONETPORT"))!=(char*)NULL && 
	       ((mid->port=atoi(defport))!=0) && 
	       errno != ERANGE)
		errno= errno; /* no error */
	    else {      
		mapi_setError(mid, "Illegal or unknown port number"); 
		return(mid);
	   }
	}
	
	if(username) strcpy(mid->username,username);
	/* ReDO else strcpy(mid->username,cuserid((char*)NULL));*/

	if(password) strcpy(mid->password,password);
	else strcpy(mid->password,"");
	
	hp = gethostbyname(mid->hostname);
	if(!hp) {
	    mapi_setError(mid,"gethostbyname failed");
	    return(mid);
	}
	memset(&server, 0, sizeof(server));
	memcpy(&server.sin_addr, hp->h_addr, hp->h_length);
	
	server.sin_family = hp->h_addrtype;
	server.sin_port   = htons((unsigned short)(mid->port&0xFFFF));
	
	s=socket(AF_INET, SOCK_STREAM, 0);
	if(s<0) {
	    mapi_setError(mid,"Open socket failed");
	    return(mid);
	}

	if(connect(s,(struct sockaddr *)&server, sizeof(server))<0) {
	    perror("! Mapi.mapi_connect: ");
	    mapi_setError(mid,"Setup connection failed");
	    return(mid);
	}
	
	mid->from = socket_rastream(s,"Mapi client read");
	if( mid->from->errnr){
	    mapi_setError(mid,"Cannot open socket for reading");
	    return(mid);
	}
	mid->to = socket_wastream(s,"Mapi client write");
	if( mid->to->errnr){
	    mapi_setError(mid,"Cannot open socket for writing ");
	    return(mid);
	}

	/* default prompt */
	strcpy(mid -> prompt,">");
	
	{ char buf[MAPIBLKSIZE];
	  char c= EOF;
	  int ret,i=0;
	  snprintf(buf, MAPIBLKSIZE,"%s:%s\n",
		username, (password?password:""));
	  if(mid->trace){
			printf("sending first request [%d]:%s",MAPIBLKSIZE,buf);
			fflush(stdout);
	  }
	  ret= mid->to->write(mid->to,buf,1,MAPIBLKSIZE);
	  mid->to->flush(mid->to);
	  if( ret != MAPIBLKSIZE){
	    mapi_setError(mid,"Could not send initial byte sequence");
	    return(mid);
	  }
	/* consume the welcome message from the server */
	  while( !((mid->from->read(mid->from,(char*)&c,1,1)==1 && c == PROMPTBEG) || (c == EOF)) ) { 
		if(i< NAMELEN-1) mid->server[i++]= c;
		if(mid->from->errnr) {c= EOF; break;}
	  }
	  if( i) mid->server[i]= 0;
	  if(mid->trace) printf("welcome:%s\n",mid->server);
	  if (c == EOF) {
	    /* perror("! mapi_connect: "); */
	    mapi_setError(mid,"Setup connection for user failed");
	    return(mid);
	  }

	  promptMonet(mid);
          if(mid->trace) printf("connection established\n");
	  if( lang==0 || strcmp(lang,"mal")==0) return mid;

	  snprintf(buf,MAPIBLKSIZE,"%s();",lang);
	  if( mapi_error(mid)) return mid;
	  if( mid->trace) printf("send scenario initializer %s\n", buf);
	  mapi_query(mid,buf);
          return mid;
	}
}
@-
Once the start of the prompt string (\0001) has been recognized, the rest should
be eaten away. It is stored in the prompt buffer for possible subsequent display.
@c
void promptMonet(Mapi mid) {
        int i=0;
	char c;

	assert(mid);
	if( mid->trace) printf("promptMonet:");
        while( mid->from->read(mid->from,(char*)&c,1,1) == 1) {
		if(c==PROMPTEND) break; 
		if( i<NAMELEN-1) { mid->prompt[i]=c; i++;}
	}
        mid->prompt[i] = '\0';
	mid->active = 0;
	mid->from->read(mid->from,(char*)&c,1,1); /* skip newline  as well*/
	if( mid->trace) printf("%s\n", mid->prompt);
}

@
Disconnection from the server leads to removal of the
Mapi structure. Subsequent access may lead to a crash.
@c
MapiMsg mapi_disconnect(Mapi mid) {
	assert(mid);
	COUNT(mid,2);
	(void) mid->from->close(mid->from);
	(void) mid->to->close(mid->to);
	(void) free(mid);
	return MOK;
}
@
@-
To synchronize on a prompt, the low level routine mapi_finish can be used.
It disgards all output received.
@c
MapiMsg mapi_finish(Mapi mid) {
	assert(mid);
	if( mid->active)
	while(mapi_fetch_line(mid))  mid->cache.reader++;
	return mid->error;
}

MapiMsg mapi_bind(Mapi mid, int fnr, int type, void *ptr) {
	assert(mid);
	COUNT(mid,16);
	if( fnr <0 || fnr>mid->fieldcnt )
		return mapi_setError(mid,"Illegal field number");
	if( fnr >= mid->fieldcnt) mapi_extend_fields(mid);
	mid->fields[fnr].binding= ptr;
	if( type>=0 && type <= SQL_DATE)
		mid->fields[fnr].type= type;
	else	mapi_setError(mid,"Illegal SQL type identifier");
	return MOK;
}
@-
The routine mapi_check_query appends the semicolon and new line if needed.
Furthermore, it ensures that no 'false' newlines are sent to the server,
because this may lead to a synchronization error easily.
@c
static void mapi_check_query(Mapi mid, char *qry) {
	int i;
	char *c;

	assert(mid);
	i= strlen(qry)-1;
	for(c=qry;*c; c++){
		if( *c == '\n'){
		mapi_setError(mid,"Newline in query string not allowed");
		*c= ' ';
		}
	}
	c--;
	return;
}

MapiMsg mapi_timeout(Mapi mid, int time) {
	assert(mid);
	COUNT(mid,14);
	if( mid->trace) printf("Set timeout to %d\n", time);
	return MOK;
}

MapiMsg mapi_explain(Mapi mid, FILE *fd) { 
	assert(mid);
	COUNT(mid,11);
	fprintf(fd,"mapi  = %s\@%s:%d\n",
		mid->username, mid->hostname, mid->port);
	fprintf(fd,"query = %s", mid->querytext);
	if( mid->error) 
	fprintf(fd,"error = %s\n",mid->errorstr);
}
@-
The statistics gathered should become available as a cached table.
@c
MapiMsg mapi_stat(Mapi mid) {
 	int i;
	char buf[MAPIBLKSIZE];

	assert(mid);
	COUNT(mid,13);
	mapi_reset_cache(mid);

	mid->counts[8]=0;
	for(i=0; Mcommands[i]; i++){
		snprintf(buf, MAPIBLKSIZE,"[ %15s,\t%d ]", Mcommands[i], mid->counts[i]);
		printf("%s\n",buf);
		if( i< 8) mid->counts[8] += mid->counts[i];
	}
	return MOK;
}
@-
The routine mapi_query is one of the most heavily used ones.
It sends a complete Monet statement for execution
(i.e., ending in a newline; possibly including additional newlines).
Interaction with the server is speed-up using block based interaction.
The query is retained in the Mapi structure to repeated shipping.
@c
MapiMsg mapi_execute(Mapi mid) {
	int k,size;
	char *cmd;
	COUNT(mid,18);

	cmd= mid->querytext;
	size =strlen(cmd)+1 /* null byte */;
	/* perform binding */

	mapi_reset_cache(mid);
        if (mid->trace) {
                printf("mapi_query:%d:%s",size, cmd);
        }
        if (mid->from->errnr || mid->to->errnr) {
                return mapi_setError(mid, "communication line broken");
        }
	if( size > MAPIBLKSIZE){
		char hdr[MAPIBLKSIZE] = "#blocks:%d\n";
		sprintf(hdr,"#blocks:%d\n", (size-1)/MAPIBLKSIZE+1);
		if( mid->trace)
			printf("mapi_query:multiple blocks: %d\n",
				 (size-1)/MAPIBLKSIZE+1);
		if( mid->to->write(mid->to,hdr, 1, MAPIBLKSIZE) != MAPIBLKSIZE){
			mid->to->flush(mid->to);
			return mapi_setError(mid, "write error on stream");
		}
		mid->to->flush(mid->to);
	}
	for(k=0; k<size; k+= MAPIBLKSIZE) 
	if( mid->to->write(mid->to,cmd+k, 1, MAPIBLKSIZE) != MAPIBLKSIZE ){
		mid->to->flush(mid->to);
                return mapi_setError(mid, "write error on stream");
	}
	mid->to->flush(mid->to);
        return MOK;
}

MapiMsg mapi_query(Mapi mid, char* cmd) {
	int len= strlen(cmd);
	if( cmd==0){
	} else {
		if( mid->querytext) free(mid->querytext);
		mid->querytext= (char*) malloc( len+1);
		assert(mid->querytext);
		strcpy(mid->querytext,cmd);
	} 
	mapi_check_query(mid,cmd);
	return (mapi_execute(mid) || mapi_fetch_line(mid)==0);
}
@-
The routine mapi_fetch_line forms the basic interaction with the server.
It simply retrieves the next line and stores it in the row cache.
The field anchor structure is prepared for subsequent use by
mapi_fetch_row.
The content received is analysed further by mapi_getRow()
@c
MapiMsg mapi_reset_cache(Mapi mid){
	mapi_finish(mid);
	mid->rows_affected = 0;
	mid->active= 1;
	mid->cache.reader= -1;
	mid->cache.writer= 0;
}
static 
void  mapi_extend_cache(Mapi mid){
	int incr, newsize, oldsize= mid->cache.writer;
	char **newrows, ***anchors;
	int *fldcnt;
	/* extend row cache */
	if( oldsize == mid->cache.rowlimit ){
		mapi_setError(mid,"Row cache limit reached");
	}
	incr = oldsize /10;
	newsize = oldsize + (incr <100? 100: incr);
	if( newsize >mid->cache.rowlimit && mid->cache.rowlimit>0)
		newsize = mid->cache.rowlimit;

	newrows = (char **) malloc(newsize * sizeof(char**));
	assert(newrows);
	memset(newrows,0, newsize * sizeof(char **));
	if( oldsize){
		memcpy(newrows, mid->cache.rows, oldsize*sizeof(char**));
		free(mid->cache.rows);
	}
	mid->cache.rows= newrows;

	anchors = (char ***) malloc(newsize * sizeof (char **));
	assert(anchors);
	memset(anchors, 0, newsize * sizeof( char **));
	if( oldsize) {
		memcpy(anchors, mid->cache.anchors, oldsize*sizeof(char*));
		free(mid->cache.anchors);
	}
	mid->cache.anchors= anchors;
	fldcnt= (int *) malloc( newsize * sizeof(int));
	assert(fldcnt);
	memset(fldcnt,0, newsize * sizeof(int));
	if( oldsize){
		memcpy(fldcnt, mid->cache.cnt, oldsize *sizeof(int));
		free(mid->cache.cnt);
	}
	mid->cache.cnt = fldcnt;

	mid->cache.limit= newsize;
}

char * mapi_fetch_line(Mapi mid){
	char *l,ch= EOF,*reply,*newbuf;
	int replylength;
	static int lastsize;
	int n=0;        

	if(mid->cache.writer>0 && mid->cache.reader< mid->cache.writer)
		return mid->cache.rows[++mid->cache.reader];

	mid->error = MOK;
	replylength= lastsize>0?lastsize:MAPIBLKSIZE;
	reply = (char *) malloc(replylength);
	assert(reply);
	reply[0]=0;
	/* manage the row cache space first */
	if( mid->cache.writer >= mid->cache.limit)
		mapi_extend_cache(mid);
	mid->cache.rows[mid->cache.writer++]= reply;

        while ( mid->from->read(mid->from,(char*)&ch,1,1) == 1) {
		if( ch == -1) mid->from->errnr= EOF;
		if( ch == '\n') break;
		if( ch== PROMPTBEG){
			promptMonet(mid);
			return 0;
		}
                if (mid->from->errnr) {
                        mapi_setError(mid, "Connection terminated");
			return 0;
		}
                if (!isprint(ch) && !isspace(ch)) {
                        mapi_setError(mid, "Unrecognized character");
			return 0;
		}
                if( n == replylength){
			replylength= n + MAPIBLKSIZE;
			newbuf= (char *) malloc(replylength);
			assert(newbuf);
			strncpy(newbuf,reply,n);
			free(reply);
			reply = newbuf;
			mid->cache.rows[mid->cache.writer-1]= reply;
                }
		reply[n++] = ch;
		ch = EOF;
        }
	if( ch == -1) { mapi_setError(mid, "connection broken"); return 0;}
        reply[n]=0;
	if( mid->trace) printf("mapi_fetch_line:%s\n", reply);
        
	if( n> lastsize ) lastsize = n; 
	if( n> MAPIBLKSIZE && n<lastsize *0.9) lastsize = 0.9 *lastsize;
        return mid->cache.rows[mid->cache.reader+1];
}
@-
The routine mapi_get_row retrieves lines from the channel until
it finds either a valid row, or encounters an error.
In passing, it interprets comment lines to detect table headers.
It returns with 0 upon encountering the prompt
(MOK) or an error. The row cache buffer is extended until the limit
is reached.
@c
static
void mapi_header(Mapi mid, char *line){
	char *tag= "name", *c;
	if( mid->trace) printf("mapi_header:%s\n",line);
	c= strrchr(line,'#');
	if( c == 0 || c==line ) return;

	*line = '['; 	/* fake a value row */
	*c = ']';
	
	mapi_slice_row(mid);

	c++; while(*c && *c == ' ') c++;
	if(*c) tag= c;

	if(strcmp("name",tag)==0){
	}
	if(strcmp("type",tag)==0){
	}
}

static 
int mapi_get_row(Mapi mid) {
	char *reply=0;

	COUNT(mid,19);
	mid->error = MOK;

	while(mid->active || mid->cache.reader < mid->cache.writer ){
		if( mid->active){
			reply= mapi_fetch_line(mid);
			if( reply == 0) return MERROR;
		} else reply = mid->cache.rows[++mid->cache.reader];
		
		switch(reply[0]){
		case '!': {
			/* concatenate the error messages */
			char *olderr= mid->errorstr;
			char *newerr;
			newerr= (char*) malloc(strlen(olderr)+strlen(reply)+2);
			assert(newerr);
			strcpy(newerr,olderr);
			strcat(newerr,reply);
			if( mid->errorstr) free(mid->errorstr);
			mid->errorstr= newerr;
			mid->error = MERROR;
			continue;
			} break;
		case '#':
			mapi_header(mid,reply);
		case '[':
		default:
			return MOK;
		}
		if( mid->everything) break;
	} 
        return MOK;
}
@-
Unquoting of a string is done in place. It returns the start
of the unquoted part section.
@c
static
void unquote(char *msg, char **start, char **next){
	char *p= msg, *s;
	char quote;

	while(*p && isspace(*p)) p++;
	*start =p;
	quote= *p;
	if( quote=='\'' || quote=='"'){
		/* get quoted string */
		p++; *start=p;
		s= p;
		while(*p != quote){
			if(*p=='\\') {
				p++;
				switch(*p){
				/* later
				case '0': case '1': case '2': case '3': case '4':
				case '5': case '6': case '7': case '8': case '9':
				*/
				case 'n': *s= '\n'; break;
				case 't': *s= '\t'; break;
				case 'r': *s= '\r'; break;
				case 'f': *s= '\f'; break;
				case '\\': *s= '\\'; break;
				default: *s =*p;
				}
				p++;
			} else *s++ = *p++;
		}
		*p = 0;
	} else {
		while( *p && (*p != ',' && *p != ']')) p++;
		for( s= p-1; s > *start && *s == ' '; s--);
		if( s>= *start && s< p-1) *s=0;
		if( *p==0) { *next = p; return;}
		*p = 0;
	}
	*next = ++p;
}
char *mapi_unquote(char *msg){
	char *start, *next;
	int size;
	unquote(msg, &start,&next);
	return start;
}
char *mapi_quote(char *msg){
	int len= sizeof(msg)*3;
	char *s= (char*) malloc(len);
	char *t=s,*v= s+ len;
	for(; *msg && t<v; t++){
		switch(*msg){
		case '\n': *t++= '\\'; *t= 'n'; break;
		case '\t': *t++= '\\'; *t= 't'; break;
		case '\\': *t++= '\\'; *t= '\\'; break;
		default:
			*t= *msg++;
		}
		/* also deal with binaries */
	}
	*t=0;
	return s;
}
@-
The low level routine mapi_slice_row breaks the last row received into pieces
and binds the field descriptors with their location. All escaped characters
are immediately replaced, such that we end with a list of C-strings.
It overwrites the contents of the row buffer, because de-escaping
only reduces the size.
It also silently extends the field descriptor table.
@c
static
int mapi_extend_fields(Mapi mid)
{
	/* extend the field table */
	int nm= mid->maxfields +32;
	MapiField *nf= (MapiField *) malloc(nm * sizeof(MapiField));
	assert(nf);
	memcpy(nf, mid->fields, mid->maxfields * sizeof(MapiField));
	memset(nf,0,  nm* sizeof(MapiField));
	if( mid->fields) free(mid->fields);
	mid->fields= nf;
	mid->maxfields= nm;
}
static 
void mapi_extend_anchor(Mapi mid){
        int cr= mid->cache.reader;
	char **ac= mid->cache.anchors[cr], **acnew=0;
	if( ac == 0 || mid->maxfields> mid->cache.cnt[cr]){
		acnew= (char **)malloc(sizeof(char*)* mid->maxfields);
		assert(acnew);
		mid->cache.anchors[cr]= acnew;
		memcpy(acnew,ac, sizeof(char*)*mid->cache.cnt[cr]);
		memset(ac, 0, sizeof(char*)*mid->cache.cnt[cr]);
	}
	if(ac) free(ac);
}
static
int mapi_slice_row(Mapi mid) {
        char *start;
        char *p;
        int single, i, cr= mid->cache.reader;

	p= mid->cache.rows[cr];
        if( p== NULL ) return mapi_setError(mid,"Current row missing");
	single = *p == '[';
	if(single) p++;

	mapi_extend_anchor(mid);
        i=0;
	do{
		if( i== mid->maxfields ) {
			if(mapi_extend_fields(mid)) return mid->error;
			mapi_extend_anchor(mid);
		}
		unquote(p, &start, &p);
		mid->cache.anchors[cr][i++] = start;
		while(*p && *p=='\t' && *p != ']') p++;
        } while(!single && *p && *p != ']');
	if( mid->fieldcnt <i) mid->fieldcnt=i;
	mid->cache.cnt[mid->cache.reader-1]= i;
       return i;
}
@-
The rows presented are broken down into pieces to
simplify access later on.
@c
int mapi_fetch_row(Mapi mid){
	if( mapi_get_row(mid)== MOK)
		return mapi_slice_row(mid);
	return 0;
}
int mapi_fetch_row_all(Mapi mid){
	return MERROR;
}

char *mapi_fetch_field(Mapi mid, int fnr){
	assert(mid);
	int cr= mid->cache.reader;
	if( fnr >=0 ){
		/* slice if needed */
		if( mid->cache.cnt[cr]==0)
			mapi_slice_row(mid);
		if( fnr < mid->cache.cnt[cr]==0)
			return mid->cache.anchors[cr][fnr];
	}
	mapi_setError(mid,"Illegal field number");
	return 0;
}
char **mapi_fetch_field_array(Mapi mid){
	assert(mid);
	int cr= mid->cache.reader;
	if( mid->cache.cnt[cr]==0)
		mapi_slice_row(mid);
	return mid->cache.anchors[cr];
}

int mapi_num_fields(Mapi mid){ return mid->fieldcnt;}
int mapi_num_rows(Mapi mid){ return mid->rows_affected;}

char *mapi_get_name(Mapi mid, int fnr) { 
	if( fnr >=0 && fnr <mid->fieldcnt) {
		if( mid->fields[fnr].columnname[0] == 0)
		snprintf(mid->fields[fnr].columnname, NAMELEN, "column_%d",fnr);
		return mid->fields[fnr].columnname;
	}
	mapi_setError(mid,"Illegal field number");
	return 0;
}
char *mapi_get_table(Mapi mid, int fnr) { 
	if( fnr >=0 && fnr <mid->fieldcnt) {
		if( mid->fields[fnr].tablename[0] == 0)
		snprintf(mid->fields[fnr].tablename, NAMELEN, "table_%d",fnr);
		return mid->fields[fnr].tablename;
	}
	mapi_setError(mid,"Illegal field number");
	return 0;
}
int mapi_rows_affected(Mapi mid) { return mid->rows_affected;}
char *mapi_get_host(Mapi mid) { return mid->hostname;}
char *mapi_get_user(Mapi mid) { return mid->username;}
char *mapi_get_lang(Mapi mid) { return mid->lang;}
char *mapi_get_server(Mapi mid) { return mid->server;}
@-
int mapi_get_type(Mapi mid, int fnr) { return mid->name;}
int mapi_get_len(Mapi mid, int fnr) { return mid->name;}

@}
