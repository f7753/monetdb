@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2005 CWI.
@' All Rights Reserved.

@f mal_strengthReduction
@a M. Kersten
@* Factorization
The strength reduction optimizer walks its way through a program
and moves instructions out of loops.

This optimizer requires knowledge on the what blocks are real
iterators and which are merely conditional blocks. In the latter
case you don;t want to do strength reduction, because you
are not sure the block will be entered.

@{
@h
#ifndef _MAL_STRENGTHREDUCTION_
#define _MAL_STRENGTHREDUCTION_
#include "mal_optimizer.h"

/* #define DEBUG_MAL_STRENGTHREDUCTION     show partial result */

mal_export str SRoptimizer(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);

#endif
@c
#include "mal_strengthReduction.h"
#include "mal_interpreter.h"    /* for showErrors() */

@+ Strength reduction implementation
Strength reduction of the code is defensive. 
This first shot assumes a single loop, so we do not have to
maintain a complex administration. We simply split the code
into two sections. Those that should do Before and  Within the loop.
@c
str SRoptimizer(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{	int i,j,k,n,se/*,moves*/;
    InstrPtr p;
	int bk, ik, b, blk, blkstart;
    InstrPtr *before,*within;
    (void) pci; (void) stk;  /* to fool compilers */

    before= (InstrPtr *) alloca((mb->ssize+1) * sizeof(InstrPtr));
    within= (InstrPtr *) alloca((mb->ssize+1) * sizeof(InstrPtr));
	/*for(moves=1; moves>0; ) {*/
	bk=0; ik=0; blk=0; blkstart=0;
    for(i=0;i<mb->stop;i++) before[i]= within[i]= 0;
	before[bk++]= getInstrPtr(mb,0); /* to become a factory */

    for(i=1; i<mb->stop-1; i++){
        p= getInstrPtr(mb,i);
		if( blockStart(p)){
			if( blkstart==0) blkstart = i;
			within[ik++]= p;
			blk++;
			continue;
		} 
		if( blockExit(p) ) {
			blk--;
			if( blk== 0 ) blkstart= 0;
			/* move the saved instruction into place */
#ifdef _DEBUG_MAL_OPTIMIZER
			stream_printf(GDKout, "combine both %d %d\n",bk,ik);
#endif
			/* moves += ik;*/
			for( k=0; k< ik; k++)
				before[bk++]= within[k];
			ik= 0;
			before[bk++]= p;
			continue;
		}
		/* inside a block we have to do the work */
		se= p->barrier!=0;
		for(k=p->retc; k< p->argc; k++){
@-
You have to check if it was already assigned before
@c
			if( !isConstant(mb,getArg(p,k))  )
			for(j=i-1;j>=0;j--){
				InstrPtr q= getInstrPtr(mb,j);
				se++;
				for(n=0;n<q->retc; n++)
				if( getArg(q,n)== getArg(p,k)) {
					se= blk;
					goto noreduction;
				}
				if( blockStart(p))
					break;
			}
@-
But also look ahead if you are inside a block to check
if the variable is overwritten, because they you can not move
@c
		}
		b= blk;
		if( blk ) 
		for(j=i+1;j<mb->stop;j++){
			InstrPtr q= getInstrPtr(mb,j);
			for(k=0; k<p->retc; k++){
				for(n=0;n<q->retc; n++)
				if( getArg(q,n)== getArg(p,k)) {
					se= blk;
					goto noreduction;
				}
			}
			if( blockStart(q))
				b++;
			if( blockExit(q))
				b--;
			if( b<blk) break;
		}
		noreduction:
#ifdef _DEBUG_MAL_OPTIMIZER
		stream_printf(GDKout, "move %d to stack %s\n",i, (se?"within":"before"));
		printInstruction(GDKout, mb, p, LIST_MAL_ALL);
#endif
		if( se==0) before[bk++]=p;
		else within[ik++]= p;
	}
	for( k=0; k< ik; k++)
		before[bk++]= within[k];
	before[bk++]= getInstrPtr(mb,i);
	GDKfree(mb->stmt);
	mb->stmt = (InstrPtr *) GDKmalloc((mb->ssize)*sizeof(InstrPtr));
	mb->stop = 0;
	
	for(i=0;i<bk;i++)
		pushInstruction(mb,before[i]);
	/*}*/
	if(pci) 
		removeInstruction(mb,pci);
	optimizerCheck(mb,"strengthReduction");
    /* remove the SRoptimizer request */
    return NULL;
}
@}
