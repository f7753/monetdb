@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2005 CWI.
@' All Rights Reserved.

@f mal_strengthReduction
@a M. Kersten
@* Factorization
The strength reduction optimizer walks its way through a program
and moves instructions out of loops.

This optimizer requires knowledge on the what blocks are real
iterators and which are merely conditional blocks. In the latter
case you don;t want to do strength reduction, because you
are not sure the block will be entered.

@{
@h
#ifndef _MAL_STRENGTHREDUCTION_
#define _MAL_STRENGTHREDUCTION_
#include "mal_optimizer.h"

/* #define DEBUG_MAL_STRENGTHREDUCTION     show partial result */

mal_export str SRoptimizer(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);

#endif
@c
#include "mal_factorize.h"
#include "mal_interpreter.h"    /* for showErrors() */

@+ Strength reduction implementation
Strength reduction of the code is defensive. 
This first shot assumes a single loop, so we do not have to
maintain a complex administration. We simply split the code
into 3 sections. Those that should do Before, Within, and
After the loop.
@c
str SRoptimizer(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{	int i,j,k,n,se;
    InstrPtr p;
	int bk=0, ik=0,blk=0, blkstart=0;
    int *varused;
    InstrPtr *before,*within;
    (void) pci; (void) stk;  /* to fool compilers */

    varused= alloca(mb->vtop * sizeof(int));
    for(i=0;i<mb->vtop;i++) varused[i]=0;

	/* add parameters to use list */
	p= getInstrPtr(mb,0);
	for(i=0; i<p->argc; i++)
		varused[i]=1;

    before= (InstrPtr *) alloca(mb->stop * sizeof(int));
    within= (InstrPtr *) alloca(mb->stop * sizeof(int));
    for(i=0;i<mb->stop;i++) before[i]= within[i]= 0;

	before[bk++]= getInstrPtr(mb,0); /* to become a factory */
    for(i=1; i<mb->stop-1; i++){
        p= getInstrPtr(mb,i);
		if( blockStart(p)){
			if( blkstart==0) blkstart = i;
			within[ik++]= p;
			blk++;
			continue;
		} 
		if( blockExit(p) ) {
			blk--;
			if( blk== 0 ) blkstart= 0;
			/* move the saved instruction into place */
			for( k=0; k< ik; k++)
				before[bk++]= within[k];
			ik= 0;
			before[bk++]= p;
			continue;
		}
		/* inside a block we have to do the work */
		se= p->barrier!=0;
		for(k=p->retc; k< p->argc; k++){
			if( !isConstant(mb,getArg(p,k)) )
			for(j=i;j>=blkstart;j--){
				InstrPtr q= getInstrPtr(mb,j);
				for(n=0;n<q->retc; n++)
				if( getArg(q,n)== getArg(p,k)) {
					se++;
					goto noreduction;
				}
			}
		}
		noreduction:
		if( se==0) before[bk++]=p;
		else within[ik++]= p;
	}
	for( k=0; k< ik; k++)
		before[bk++]= within[k];
	GDKfree(mb->stmt);
	mb->stmt = (InstrPtr *) GDKmalloc((mb->stop)*sizeof(InstrPtr));
	mb->stop = 0;
	
	for(i=0;i<bk;i++)
		pushInstruction(mb,before[i]);
    /* remove the SRoptimizer request */
    return NULL;
}
@}
