@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2005 CWI.
@' All Rights Reserved.

@f mal_peephole
@a M. Kersten
@* Peephole optimization
Recursive descend query compilers easily miss opportunities
for better code generation, because limite context is retained
or lookahead available. The peephole optimizer is
built around such recurring patterns and compensates
for the compilers 'mistakes'.
@{
@h
#ifndef _MAL_PEEPHOLE_
#define _MAL_PEEPHOLE_
#include "mal_optimizer.h"

/* #define DEBUG_MAL_PEEPHOLE     show partial result */

mal_export str PHoptimizer(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);

#define match(X,M,F) ( (X) && functionId(X) && strcmp(functionId(X),F)==0 && \
	moduleId(X) && strcmp(moduleId(X),M)==0)
#endif
@c
#include "mal_peephole.h"
#include "mal_namespace.h"
#include "mal_interpreter.h"    /* for showErrors() */

@- 
The SQL frontend heavily relies on a pivot table, which
is a generated oid sequence. Unfortunately, this
is not seen and the pattern '$i := calc.oid(0@@0); $j:= algebra.markT($k,$i);'
occurs often. This can be replaced with '$j:= algebra.markT($k)';

Another example of a 2-way instruction sequence produced is then
'$j:= algebra.markT($k); $l:= bat.reverse($j);',
which can be replaced by '$l:= algebra.markH($k);'.

In all cases we should ensure that the intermediates dropped are not
used for other purposes as well.

The type of a variable may have to be reset when you change
the program structure.
@c
str
PHoptimizer(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	InstrPtr p,q,r, *old;
	int i,limit,doit,aropt=0;
	long clk= GDKusec();

#ifdef DEBUG_MAL_PEEPHOLE
	stream_printf(GDKout,"Peephole optimizer started\n");
#endif
	(void) stk; (void) pci;
	do{
		doit=0; aropt=0;
		setLifespan(mb);
		limit= mb->stop;
		old = mb->stmt;
		newMalBlkStmt(mb,mb->stop);
		for(i=0;i<limit; i++){
			p= old[i]; 
			q= i<limit-1? old[i+1]: 0;
			if( 
				getVar(mb,getArg(p,0))->endLifespan== i+1 &&
				match(p,"calc","oid") &&
				isConstant(mb,getArg(p,1)) &&
				strcmp(getVarLiteral(mb,getArg(p,1)),"0@0")== 0
			   ){
					if( match(q,"algebra","markT") ||
						match(q,"algebra","markH") )
					{
#ifdef DEBUG_MAL_PEEPHOLE
				printf("PEEPHOLE 0\n");
				printInstruction(GDKout,mb,p,LIST_MAL_ALL);
				printInstruction(GDKout,mb,q,LIST_MAL_ALL);
#endif
						freeInstruction(p);
						q->argc--;
						pushInstruction(mb,q);
						i++; doit++;
					}
			} else
			if( 
				getVar(mb,getArg(p,0))->endLifespan== i+1 &&
				match(p,"algebra","markT") &&
				match(q,"bat","reverse") 
			){ 
#ifdef DEBUG_MAL_PEEPHOLE
				printf("PEEPHOLE 1\n");
				printInstruction(GDKout,mb,p,LIST_MAL_ALL);
				printInstruction(GDKout,mb,q,LIST_MAL_ALL);
#endif

				getArg(q,1)= getArg(p,1);
				setModuleId(q,putName("algebra",7));
				setFunctionId(q,putName("markH",5));
				pushInstruction(mb,q);
				freeInstruction(p);
				i++; doit++;
			} else
			if( q && match(p,"algebra","markH") &&
				match(q,"algebra","join") 
			){
#ifdef DEBUG_MAL_PEEPHOLE
				printf("PEEPHOLE 2\n");
				printInstruction(GDKout,mb,p,LIST_MAL_ALL);
				printInstruction(GDKout,mb,q,LIST_MAL_ALL);
#endif
				if( getArg(p,1)== getArg(q,2) ){
					r= newInstruction(ASSIGNsymbol);
					getArg(r,0)= getArg(q,0);
					pushArgument(mb,r,getArg(q,2));
					freeInstruction(q);
					pushInstruction(mb,p);
					pushInstruction(mb,r);
					i++; doit++; aropt++;
				} else
					pushInstruction(mb,p);
			} else
				pushInstruction(mb,p);
		}
		GDKfree(old);
		if( aropt) {
			chkProgram(getClient()->nspace,mb);
			setLifespan(mb);
			ARoptimizer(mb,0,0);
		}
		if( doit){
			stream_printf(GDKout,"PEEPHOLE %d\n",doit);
			printFunction(GDKout,mb,LIST_MAL_ALL);
		}
	} while(doit);
#ifdef DEBUG_MAL_PEEPHOLE
	printFunction(GDKout,mb,LIST_MAL_ALL);
#endif
	optimizerCheck(mb,"mal.peephole",1,GDKusec()-clk);
	return MAL_SUCCEED;
}
