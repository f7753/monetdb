@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2005 CWI.
@' All Rights Reserved.

@f mal_costmodel
@a M. L. Kersten
@+ The MAL costmodel
Cost models form the basis for many optimization decisions.
The cost parameters are typically the size of the (intermediate)
results and response time. Alternatively, they are running
aggregates, e.g. max memory and total execution time,
obtained from a simulated run.

The cost model implementation is collected here and is 
expected to grow to several calculators, each geared at a particular
subset of MAL or focussed to support a particular frontend.

The RMcalculator works its way through a MAL program in search for
relational operators and estimates their result size. 
The operations taken into account are @{reverse, select, join, mark,
uselect, kdiff,cross@}
The estimated size is left behind as property RMcost, to avoid overwriting
information produced by the front-end compiler.

Ideally the BAT variable comes with a histogram property
to make accurate prediction, otherwise the following heuristics are used.
@{
@+ Implementation section
@h
#ifndef _MAL_COSTMODEL_H_
#define _MAL_COSTMODEL_H_

/* #define DEBUG_MAL_COSTMODEL */

#include "mal.h"
#include <math.h>
#include "mal_macro.h"
#include "mal_interpreter.h"
#include "mal_client.h"
#include "mal_namespace.h"

#define getProps(Y) mb->var[Y]->props

mal_export void RMcalculator( MalBlkPtr mb);
mal_export int getCost(MalBlkPtr mb, int varid);
#endif /* _MAL_COSTMODEL_H_ */
@-
@c
#include "mal_costmodel.h"

static void fixPropertySet(MalBlkPtr mb, int dst){
	if( mb->var[dst]->props == 0) 
		mb->var[dst]->props = newPropertySet();
}
static void RMcpyProperty(MalBlkPtr mb, str srcnme, int src, str dstnme, int dst){
    Property pr;

    if( getProps(src) == NULL) return;

    pr= fndProperty(getProps(src), srcnme);
    if( pr) {
		fixPropertySet(mb,dst);
		setProperty( getProps(dst), dstnme, pr->val.vtype, VALptr(&pr->val));
	}
}

#define getVarCost(Y) (fndProperty(mb->var[Y]->props,"RMcost")?\
		(int*) getPropertyValue(mb->var[Y]->props,"RMcost"):\
		(int*)getPropertyValue(mb->var[Y]->props,"count") )

@-
The cost formula are repetative
@= newCost
		c1 = getVarCost(getArg(p,@1));
		if( c1 == NULL) continue;
		k= @2;
		fixPropertySet(mb, getArg(p,0));
		setProperty(getProps(getArg(p,0)),"RMcost", TYPE_int, &k);
@= newCost2
		c1 = getVarCost(getArg(p,@1));
		c2 = getVarCost(getArg(p,@2));
		if( c1 == NULL) continue;
		if( c2 == NULL) continue;
		k= (@3);
		fixPropertySet(mb, getArg(p,0));
		setProperty(getProps(getArg(p,0)),"RMcost", TYPE_int, &k);
@c
void RMcalculator( MalBlkPtr mb){
    int i,j, *c, *c1, *c2,k;
    InstrPtr p;

    for(i=0;i<mb->stop; i++){
        p= getInstrPtr(mb,i);
        if(moduleId(p) && idcmp(moduleName(p),"algebra")==0){
            if(functionId(p) && idcmp(functionName(p),"mark")==0) {
				@:newCost(1, *c1)@
			} else
            if(functionId(p) && idcmp(functionName(p),"kdiff")==0){
				@:newCost2(1,2, *c1-*c2 < 0 ? 0: *c1- *c2)@
            } else
            if(functionId(p) && idcmp(functionName(p),"join")==0){
				@:newCost2(1,2, *c1<*c2? *c1: *c2)@
            } else
            if(functionId(p) && idcmp(functionName(p),"uselect")==0){
				@:newCost(1, *c1>100? *c1/2: *c1)@
            } else
            if(functionId(p) && idcmp(functionName(p),"cross")==0){
				@:newCost2(1,2, ( log((double)*c1) + log((double)*c2) > log(INT_MAX) ? INT_MAX: *c1 * *c2) )@
            } else
            if(functionId(p) && idcmp(functionName(p),"tunique")==0){
				@:newCost(1, *c1<50? *c1: *c1/10)@
            } else
            if(functionId(p) && ( idcmp(functionName(p),"sort")==0 ||
				idcmp(functionName(p),"sort_reverse")==0 )
			){
				@:newCost(1, *c1)@
            }

        } else if (moduleId(p) && idcmp(moduleName(p),"bat")==0){
            if(functionId(p) && idcmp(functionName(p),"reverse")==0){
				@:newCost(1, *c1)@
			} else
            if(functionId(p) && idcmp(functionName(p),"mirror")==0){
				@:newCost(1, *c1)@
			}
        } else if (moduleId(p) && idcmp(moduleName(p),"group")==0){
            if(functionId(p) && idcmp(functionName(p),"group")==0){
				@:newCost(1, *c1/10)@
			} else {
				@:newCost(1, *c1)@
			}
        } else if (moduleId(p) && idcmp(moduleName(p),"multiplex")==0){
            if(functionId(p) && idcmp(functionName(p),"script")==0){
				if( getVarCost(getArg(p,1)) ){
					@:newCost(1, *c1)@
				} else {
					@:newCost(2, *c1)@
				}
			}
        } else if (moduleId(p) && idcmp(moduleName(p),"aggrX3")==0){
            if( functionId(p) && (idcmp(functionName(p),"sum")==0 ||
                idcmp(functionName(p),"min")==0 ||
                idcmp(functionName(p),"max")==0 ||
                idcmp(functionName(p),"avg")==0) ){
				@:newCost(2, *c1)@
			}
        } else {
			/* propagate count to RMcost */
			for(j=0;j<p->retc; j++){
				if( (c = (int*)getVarCost(p->argv[j])) )
					setProperty(getProps(p->argv[j]), "RMcost", TYPE_int, c);
			}
		}
	}
}
@-
The cost will be used in many places to make decisions.
Access should be fast.
@c
int getCost(MalBlkPtr mb, int varid){
	int c;
	c= * (getVarCost(varid));
	return c;
}
@}
