@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2005 CWI.
@' All Rights Reserved.

@f mal_singleton
@a M. Kersten
@* Singleton set reduction
Singleton set reduction creates a copy of a MAL program
using a symbolic evaluation when an variable is known
to be produce a single tuple.
During this evaluation, we may create more singleton sets, 
leading to a ripple effect through the code.

The algorithm assumes that each singleton set destination variable
can be safely be replaced by the tuple pair.
Also, when we encounter a non-optimizable instruction we
can safely construct a new table with a single instance.

The approach taken is to only replace instructions when
the variables remains empty under all invocations.
@{
@h
#ifndef _MAL_SINGLETON_
#define _MAL_SINGLETON_
#include "mal_optimizer.h"

#define DEBUG_MAL_SINGLETON     /* show partial result */

mal_export str SSevaluate(MalBlkPtr mb, int cnt, int *vars);
#endif
@c
#include "mal_singleton.h"
#include "mal_interpreter.h"    /* for showErrors() */
#include "mal_builder.h"
#include "mal_namespace.h"

@-
When we run into an instruction that can not be optimized,
we have to rebuild the singleton set as an ordinary BAT.
@c
typedef struct {
	int vidx;
	int hidx;
	int htpe;
	int tidx;
	int ttpe;
} SStuple;

void SSrebuildSet(MalBlkPtr mb, int sidx, int hidx, int tidx){
	InstrPtr p;
	int tpe;

	p= newStmt(mb, putName("bbp",3), putName("new",3));
	p->argv[0]=sidx;
	tpe= getVarType(mb,hidx);
	if( tpe== TYPE_oid) tpe= TYPE_void;
	pushArgument(mb,p,newTmpVariable(mb,tpe));
	tpe= getVarType(mb,tidx);
	pushArgument(mb,p,newTmpVariable(mb,tpe));
	pushInt(mb,p,1);

	p= newStmt(mb, putName("bat",3), putName("insert",3));
	pushArgument(mb,p,sidx);
	pushArgument(mb,p,hidx);
	pushArgument(mb,p,tidx);
}

int SSalias(int idx, int top, SStuple *tuples){
	int i;
	for( i=0; i<top; i++)
	if( tuples[i].vidx== idx) return i;
	return -1;
}

void SSnewTuple(MalBlkPtr mb, int vidx, int *top, SStuple *tuples){
		tuples[*top].vidx= vidx;
		tuples[*top].htpe= getHeadType(getVarType(mb,vidx));
		tuples[*top].hidx= newTmpVariable(mb, tuples[*top].htpe);
		setVarUsed(mb, tuples[*top].hidx,TRUE);
		setVarInitialized(mb, tuples[*top].hidx);
		tuples[*top].ttpe= getTailType(getVarType(mb,vidx));
		tuples[*top].tidx= newTmpVariable(mb, tuples[*top].ttpe);
		setVarUsed(mb, tuples[*top].tidx,TRUE);
		setVarInitialized(mb, tuples[*top].tidx);
		*top = *top +1;
}

str
SSevaluate(MalBlkPtr mb, int cnt, int *vars){
	long clk= GDKusec();
	int i,j=0,k,limit,doAR=0;
	InstrPtr p;
	InstrPtr *old;
	SStuple *tuples;
	int top=0;

	tuples = alloca(mb->stop * sizeof(SStuple));
	limit= mb->stop;
	old= mb->stmt;

@-
Prepare the list of tuple aliases using allocation of
variables on the stack.
@c
	for(i=0; i<cnt; i++)
		SSnewTuple(mb,vars[i], &top, tuples);
#ifdef DEBUG_MAL_SINGLETON
	stream_printf(GDKout,"START SINGLETON OPTIMIZER %d:",cnt);
	for(i=0;i<top; i++) stream_printf(GDKout,"[%d,%d,%d] ",
		vars[i], tuples[i].hidx, tuples[i].tidx);
	stream_printf(GDKout,"\n");
	printFunction(GDKout,mb,LIST_MAL_ALL);
	stream_printf(GDKout,"START OPTIMIZER ");
#endif
	newMalBlkStmt(mb,mb->stop);

	for( i=0; i< limit; i++){
		p= old[i];
		/* decode operations */
		if( getName("bat",3) == moduleId(p)){
			if( getName("insert",6)== functionId(p) ||
				getName("delete",6)== functionId(p) ||
				getName("append",6)== functionId(p) ){
					/* use insert tuple instead of bat ?*/
				if( p->argc==3 && (k = SSalias(getArg(p,2),top,tuples)) >=0){
				} 
			} else 
			if( getName("reverse",7)== functionId(p) &&
				(k = SSalias(getArg(p,1), top, tuples) >=0 ) ){
				/* revert the tuple */
			} 
		} else
		if( getName("algebra",7)== moduleId(p)){
			if( getName("markH",5)== functionId(p) &&
				(k= SSalias(getArg(p,1),top,tuples)) >=0 ){
				setModuleId(p,NULL);
				setFunctionId(p,NULL);
				SSnewTuple(mb,getArg(p,0), &top, tuples);
				p->argc=0;
				pushReturn(mb,p, tuples[top-1].hidx);
				tuples[top-1].tidx= tuples[k].tidx;
				pushReturn(mb,p, tuples[k].tidx);
				p->retc=2;
				pushVoid(mb,p);
				pushArgument(mb,p, tuples[k].tidx);
				p->token= ASSIGNsymbol;
				p->fcn= NULL;
				doAR++;
			} else
			if( getName("markT",5)== functionId(p) &&
				(k= SSalias(getArg(p,1),top,tuples)) >=0 ){
				setModuleId(p,NULL);
				setFunctionId(p,NULL);
				SSnewTuple(mb,getArg(p,0), &top, tuples);
				p->argc=0;
				pushReturn(mb,p, tuples[top-1].hidx);
				pushReturn(mb,p, tuples[top-1].tidx);
				p->retc=2;
				pushArgument(mb,p, tuples[k].hidx);
				pushVoid(mb,p);
				p->token= ASSIGNsymbol;
				p->fcn= NULL;
				doAR++;
			} else
			if( getName("join",4)== functionId(p) ){
				int k1 = SSalias(getArg(p,1),top,tuples);
				int k2 = SSalias(getArg(p,2),top,tuples);
				if( k1 >= 0 && k2 >= 0){
					if( tuples[k2].htpe == TYPE_void &&
					    tuples[k1].htpe == TYPE_void){
						printf("MERGE VOID JOIN \n");
						setModuleId(p,NULL);
						setFunctionId(p,NULL);
						SSnewTuple(mb,getArg(p,0), &top, tuples);
						p->argc=0;
						pushReturn(mb,p, tuples[top-1].hidx);
						pushReturn(mb,p, tuples[top-1].tidx);
						p->retc=2;
						pushArgument(mb,p, tuples[k1].hidx);
						pushArgument(mb,p, tuples[k2].tidx);
						p->token= ASSIGNsymbol;
						p->fcn= NULL;
					}
				} else
				if( k1 >= 0 ){
				} else
				if( k2 >= 0 ) {
				} 
				/* just push instruction */
			} else
/*
				getName("kunion",6)== functionId(p) ||
				getName("join",4)== functionId(p) ||
				getName("fetchjoin",9)== functionId(p) ||
				getName("mergejoin",9)== functionId(p) ||
				getName("indexjoin",9)== functionId(p) ||
				getName("hashjoin",8)== functionId(p) ||
				getName("cartesianproduct",16)== functionId(p) ||
				getName("union",5)== functionId(p) ){
*/
			if( getName("count",5)== functionId(p)  &&
				( k= SSalias(getArg(p,1),top,tuples)) >= 0){
				/* count propagation */
				setModuleId(p,NULL);
				setFunctionId(p,NULL);
				p->argc=1;
				p->token= ASSIGNsymbol;
				pushArgument(mb,p, newConstant(mb,TYPE_lng,GDKstrdup("1"),FALSE));
			}
		} else 
		if( getName("datacell",8)== moduleId(p)){
			if( getName("bindReceptor",12) &&
				(k = SSalias(getArg(p,0),top,tuples)) >= 0){
					setFunctionId(p,putName("bindReceptorTuple",17));
					getArg(p,0) = tuples[k].hidx;
					setArgument(mb,p,1,tuples[k].tidx);
					p->retc++;
			} else
			if( getName("keep",4) &&
				(k = SSalias(getArg(p,3),top,tuples)) >= 0){
				getArg(p,3)= tuples[k].tidx;
			}
		} else {
			/* check for any target alias */
			for( j=0; j< p->retc; j++)
			for( k=0; k<top; k++)
			if( getArg(p,j) == tuples[k].vidx){
				getArg(p,j)= tuples[k].hidx;
				setArgument(mb,p,j+1, tuples[k].tidx);
				p->retc++;
			}
		}
		pushInstruction(mb,p);
	}
	GDKfree(old);
	if( doAR) {
#ifdef DEBUG_MAL_SINGLETON
		printf("MID STAGE doAR=%d\n",doAR);
		printFunction(GDKout,mb,LIST_MAL_ALL);
		for(i=0;i<top; i++) stream_printf(GDKout,"[%d,%d:%s,%d:%s] ",
			tuples[i].vidx, 
			tuples[i].hidx, getTypeName(tuples[i].htpe),
			tuples[i].tidx, getTypeName(tuples[i].ttpe));
		stream_printf(GDKout,"\n");
#endif
		ARoptimizer(mb,0,0);
		/*DCoptimizer(mb,0,0);*/
	}

	optimizerCheck(mb,"mal.emptyset",1,GDKusec()-clk);
#ifdef DEBUG_MAL_SINGLETON
	printf("FINAL STAGE SINGLETON errors=%d\n",mb->errors);
	printFunction(GDKout,mb,LIST_MAL_ALL);
#endif
	return MAL_SUCCEED;
}
