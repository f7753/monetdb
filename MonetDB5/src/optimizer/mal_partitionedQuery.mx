@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2005 CWI.
@' All Rights Reserved.

@f mal_partitionedQuery
@a M. Kersten
@* Partition query processing
Limitations on the addressing space in older PCs and the need
for distributed storage makes that BATs ideally should be 
looked upon as a union of smaller BATs. However, this view calls
for extensive more mAL programming effort, especially when it comes to
avoiding work using semantic knowledge.

The partitionedQuery optimizer deals with a large fragment of the
problem space. It assumes that the partitioned BATs
are all of type :bat[:void,:any]. The header is a key
and each partition is responsible for a dense range.
This means we can use the minimum and maximum oid as a
range constraint in our optimizations decisions.

The optimizer is designed incrementally. The focus is
on supporting the SQL front-end. In particularly, the
operators considered is a limited subset of MAL. Occurrence
of an operator outside this set terminates the optimizer
step with a failure.

The partition optimizer relies on a module that keeps
track of the partitions associated with BATs and which
also provide filtering capabilities to avoid work.

The partition optimizer takes a MAL program, instruction range
and a list of variables to produce a plan that incrementally produces
the desired result. 

@{
@h
#ifndef _MAL_PARTITIONED_
#define _MAL_PARTITIONED_
#include "mal_optimizer.h"

#define DEBUG_MAL_PARTITIONED     /* show partial result */
mal_export str BPToptimizer(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);

#endif
@c
#include "mal_partitionedQuery.h"
#include "mal_interpreter.h"    /* for showErrors() */
extern int BPTfindGrp(int bid);
extern str BPTreplacement(MalBlkPtr mb, int first, int last, int varid);

str 
BPToptimizer(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	int i,tpe,limit;
	(void) stk; (void) pci;

#ifdef DEBUG_MAL_PARTITIONED
	stream_printf(GDKout,"BPToptimizer\n");
	printFunction(GDKout,mb,LIST_MAL_ALL);
#endif

	limit= mb->vtop;
	for( i=0; i< limit; i++){
		tpe= getVarType(mb,i);
	if( isaBatType(tpe) && getHeadType(tpe)==TYPE_void ){
		BPTreplacement(mb,1,mb->stop-1,i);
	}
	}
	return throwMessage("optimizer.partitionedQuery","not yet implemented");
}
@-
The first implementation takes a query block and replaces the first
bat variable with its partitioned equivalent.
@c
str
BPTreplacement(MalBlkPtr mb, int first, int last, int varid){
	InstrPtr *old,p;
	int i,limit,actions=0;
	int idx= -1,bid= -1;
	long clk= GDKusec();

	setLifespan(mb);
	old= mb->stmt;
	limit= mb->stop;
	newMalBlkStmt(mb,limit+10);
#ifdef DEBUG_MAL_PARTITIONED
		stream_printf(GDKout,"variable replacement '%s'", getVarName(mb,varid));
		stream_printf(GDKout," instructions %d-%d ", first,last);
		stream_printf(GDKout," lifespan %d-%d\n", mb->var[varid]->beginLifespan,
			mb->var[varid]->endLifespan);
#endif
	/* copy prelude into place */
	for(i=0;i<first; i++)
		pushInstruction(mb,old[i]);
	for(i=first;i<last; i++){
		if( i == mb->var[varid]->beginLifespan){
			actions++;
			/* barrier (idx,bid):= partitions.newIterator(var); */
			p= newInstruction(ASSIGNsymbol);
			setModuleId(p,GDKstrdup("partitions"));
			setFunctionId(p,GDKstrdup("newIterator"));
			p->barrier= BARRIERsymbol;
			idx= p->argv[0]= newTmpVariable(mb,TYPE_int);
			bid= p->argv[1]= newTmpVariable(mb,getVarType(mb,varid));
			p->retc=2;
			p->argv[2]= varid;
			p->argc=3;
			pushInstruction(mb,p);
		}
		pushInstruction(mb,old[i]);
	}
	if(idx>=0 && bid>=0){
		/* finalize the loop */
			/* redo (idx,bid):= partitions.hasMoreElements(var); */
			p= newInstruction(ASSIGNsymbol);
			setModuleId(p,GDKstrdup("partitions"));
			setFunctionId(p,GDKstrdup("hasMoreElements"));
			p->barrier= REDOsymbol;
			p->argv[0]= idx;
			p->argv[1]= bid;
			p->retc=2;
			p->argv[2]= varid;
			p->argc=3;
			pushInstruction(mb,p);
			/* exit (idx,bid) */
			p= newInstruction(EXITsymbol);
			p->barrier= EXITsymbol;
			p->argv[0]= idx;
			p->argv[1]= bid;
			p->retc=2;
			p->argc=2;
			pushInstruction(mb,p);
	}
	/* copy rest of program into place */
	for(i=last;i<limit; i++)
		pushInstruction(mb,old[i]);
	GDKfree(old);
	optimizerCheck(mb,"BPTreplacement",actions,GDKusec()-clk);
	return MAL_SUCCEED;
}
