@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2005 CWI.
@' All Rights Reserved.

@f mal_emptyset
@a M. Kersten
@* Emptyset reduction
Empty set reduction creates a copy of a MAL program
using a symbolic evaluation when an variable is known
to be empty under all circumstances.
During this evaluation, we may create
more empty BATs, leading to a ripple effect through
the code.

The approach taken is to only replace instructions when
the variables remains empty under all invocations.
@{
@h
#ifndef _MAL_EMPTYSET_
#define _MAL_EMPTYSET_
#include "mal_optimizer.h"

#define DEBUG_MAL_EMPTYSET     /* show partial result */

mal_export str ESevaluate(MalBlkPtr mb, int cnt, int *vars);
#endif
@c
#include "mal_emptyset.h"
#include "mal_interpreter.h"    /* for showErrors() */
#include "mal_namespace.h"

str
ESevaluate(MalBlkPtr mb, int cnt, int *vars){
	long clk= GDKusec();
	char *empty;
	int i,j;
	InstrPtr p;
	Module scope= getClient()->nspace;

#ifdef DEBUG_MAL_EMPTYSET
	stream_printf(GDKout,"START emptyset optimizer %d\n",cnt);
	for(i=0;i<cnt; i++) stream_printf(GDKout,",%d ",vars[i]);
	stream_printf(GDKout,"\n");
#endif

	empty= alloca(mb->vtop);
	for(i=0;i< mb->vtop; i++) empty[i]=0;
	for(i=0; i<cnt; i++) empty[vars[i]]=1;

	setLifespan(mb);
	for( i=0; i< mb->stop; i++){
		p= getInstrPtr(mb,i);
		for( j=0; j< p->retc; j++)
		if( empty[getArg(p,j)] && getVar(mb,getArg(p,j))->updLifespan > 1 ) {
#ifdef DEBUG_MAL_EMPTYSET
			stream_printf(GDKout,"reject emptyset %d\n",getArg(p,j));
#endif
			empty[getArg(p,j)]= 0;
		}
	}
	for( i=0; i< mb->stop; i++){
		p= getInstrPtr(mb,i);
		for( j=p->retc; j< p->argc; j++)
		if( empty[getArg(p,j)]  ){
			/* decode operations */
			if( getName("algebra",7)== moduleId(p)){
				if( getName("kdiff",5)== functionId(p) && j== p->argc-1){
					setModuleId(p,NULL);
					setFunctionId(p,NULL);
					p->argc=2;
					typeChecker(scope,mb,p,TRUE);
					ARoptimizer(mb,0,p);
					break;
				} else
				if( getName("join",4)== functionId(p) ){
					if(getVar(mb,getArg(p,0))->updLifespan == 1 )
						empty[getArg(p,0)]= 1;
				}
			} else
			if( getName("bat",7)== moduleId(p)){
				if( getName("reverse",7)== functionId(p) &&
					getVar(mb,getArg(p,0))->updLifespan == 1 )
					empty[getArg(p,0)]= 1;
			}
		}
	}
	DCoptimizer(mb,0,0);

	optimizerCheck(mb,"mal.emptyset",1,GDKusec()-clk);
#ifdef DEBUG_MAL_EMPTYSET
		printf("FINAL STAGE errors=%d\n",mb->errors);
		printFunction(GDKout,mb,LIST_MAL_ALL);
#endif
	return MAL_SUCCEED;
}
