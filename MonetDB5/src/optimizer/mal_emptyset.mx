@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2005 CWI.
@' All Rights Reserved.

@f mal_emptyset
@a M. Kersten
@* Emptyset reduction
Empty set reduction creates a copy of a MAL program
using a symbolic evaluation when an variable is known
to be empty under all circumstances.
During this evaluation, we may create
more empty BATs, leading to a ripple effect through
the code.

The approach taken is to only replace instructions when
the variables remains empty under all invocations.
@{
@h
#ifndef _MAL_EMPTYSET_
#define _MAL_EMPTYSET_
#include "mal_optimizer.h"

#define DEBUG_MAL_EMPTYSET     /* show partial result */

mal_export str ESevaluate(MalBlkPtr mb, int cnt, int *vars);
#endif
@c
#include "mal_emptyset.h"
#include "mal_interpreter.h"    /* for showErrors() */
#include "mal_builder.h"
#include "mal_namespace.h"

str
ESevaluate(MalBlkPtr mb, int cnt, int *vars){
	long clk= GDKusec();
	char *empty;
	int i,j,limit,doAR=0;
	InstrPtr p;

#ifdef DEBUG_MAL_EMPTYSET
	stream_printf(GDKout,"START emptyset optimizer %d\n",cnt);
	for(i=0;i<cnt; i++) stream_printf(GDKout,",%d ",vars[i]);
	stream_printf(GDKout,"\n");
#endif

	empty= alloca(mb->vtop);
	for(i=0;i< mb->vtop; i++) empty[i]=0;
	for(i=0; i<cnt; i++) empty[vars[i]]=1;

	setLifespan(mb);
	for( i=0; i< mb->stop; i++){
		p= getInstrPtr(mb,i);
		for( j=0; j< p->retc; j++)
		if( empty[getArg(p,j)] && getVar(mb,getArg(p,j))->updLifespan > 1 ) {
#ifdef DEBUG_MAL_EMPTYSET
			stream_printf(GDKout,"reject emptyset %d\n",getArg(p,j));
#endif
			empty[getArg(p,j)]= 0;
		}
	}
	limit= mb->stop;
	for( i=0; i< limit; i++){
		p= getInstrPtr(mb,i);
		for( j=p->retc; j< p->argc; j++)
		if( empty[getArg(p,j)]  ){
			/* decode operations */
			if( getName("algebra",7)== moduleId(p)){
				if( getName("kdiff",5)== functionId(p) && j== p->argc-1){
					setModuleId(p,NULL);
					setFunctionId(p,NULL);
					p->argc=2;
					p->token= ASSIGNsymbol;
					doAR++;
					break;
				} else
				if( getName("insert",6)== functionId(p) ||
					getName("delete",6)== functionId(p) ||
					getName("append",6)== functionId(p) ){
					if( j == 2) {
						/* you don;t add anything */
						setModuleId(p,NULL);
						setFunctionId(p,NULL);
						p->argc=2;
						p->token= ASSIGNsymbol;
						doAR++;
						break;
					}
				} else 
				if( getName("exist",4)== functionId(p) ){
					/* always false */
					setModuleId(p,NULL);
					setFunctionId(p,NULL);
					p->argc=1;
					p->token= ASSIGNsymbol;
					pushBit(mb, p,"false");
					doAR++;
					break;
				} else 
				if( getName("select",6)== functionId(p) ||
					getName("uselect",7)== functionId(p) ||
					getName("like",4)== functionId(p) ||
					getName("sortH",5)== functionId(p) ||
					getName("sortT",5)== functionId(p) ||
					getName("sortHT",6)== functionId(p) ||
					getName("sortTH",6)== functionId(p) ||
					getName("unique",6)== functionId(p) ||
					getName("sunique",7)== functionId(p) ||
					getName("kunique",7)== functionId(p) ||
					getName("tunique",7)== functionId(p) ||
					getName("intersect",9)== functionId(p) ||
					getName("sintersect",10)== functionId(p) ||
					getName("kintersect",10)== functionId(p) ||
					getName("fragment",8)== functionId(p) ){
					/* result is empty */
					if(getVar(mb,getArg(p,0))->updLifespan == 1 )
						empty[getArg(p,0)] = 1;
				} else 
				if( getName("diff",4)== functionId(p) ||
					getName("kdiff",5)== functionId(p) ||
					getName("semijoin",8)== functionId(p) ){
					/* always empty */
					setModuleId(p,NULL);
					setFunctionId(p,NULL);
					p->argc=2;
					p->token= ASSIGNsymbol;
					doAR++;
					break;
				} else 
				if( getName("sunion",6)== functionId(p) ||
					getName("kunion",6)== functionId(p) ||
					getName("join",4)== functionId(p) ||
					getName("fetchjoin",9)== functionId(p) ||
					getName("mergejoin",9)== functionId(p) ||
					getName("indexjoin",9)== functionId(p) ||
					getName("hashjoin",8)== functionId(p) ||
					getName("cartesianproduct",16)== functionId(p) ||
					getName("union",5)== functionId(p) ){
					/* always identity */
					setModuleId(p,NULL);
					setFunctionId(p,NULL);
					p->argc=2;
					p->token= ASSIGNsymbol;
					if( j==2) p->argv[1]= p->argv[2];
					doAR++;
					break;
				} 
				/* CONTINUE WITH THETA JOIN */
			} else
			if( getName("bat",7)== moduleId(p)){
				if( getName("reverse",7)== functionId(p) &&
					getVar(mb,getArg(p,0))->updLifespan == 1 )
					empty[getArg(p,0)]= 1;
			}
		}
	}
	if( doAR) {
		ARoptimizer(mb,0,0);
		DCoptimizer(mb,0,0);
	}

	optimizerCheck(mb,"mal.emptyset",1,GDKusec()-clk);
#ifdef DEBUG_MAL_EMPTYSET
		printf("FINAL STAGE errors=%d\n",mb->errors);
		printFunction(GDKout,mb,LIST_MAL_ALL);
#endif
	return MAL_SUCCEED;
}
