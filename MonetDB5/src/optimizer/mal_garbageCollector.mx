@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2005 CWI.
@' All Rights Reserved.

@f mal_garbageCollector
@a M. Kersten
@* Garbage collection
The GCoptimizer removes all BATs that are at their end of
life to make room for new ones.
This optimizer should not be called when the scheduler
intends to keep intermediates around for re-use.

The algorithm is straight forward. After each instruction
we check whether BAT arguments are needed in the future.
If not, we inject a statement to release them.
This should be done carefully, because the instruction
may be part of a loop.
If the variable is defined inside the loop, we can
safely remove it. 
If it is outside the loop, we still have be careful,

A variable can only be released in the scope in which
it is introduced. This means we need an overview of
the scope nesting and maintain a list of variables
still to be garbage collected.

We don;t have to worry about pre-mature return from the
function, because this will trigger garbage collection
anyway.

@{
@h
#ifndef _MAL_GARBAGE_
#define _MAL_GARBAGE_
#include "mal_optimizer.h"

/* #define DEBUG_MAL_GARBAGE     show partial result */

mal_export str GCoptimizer(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);

#endif
@c
#include "mal_factorize.h"
#include "mal_interpreter.h"    /* for showErrors() */

@= releaseBAT
	q= newInstruction(ASSIGNsymbol);
	setModuleId(q,"bbp");
	setFunctionId(q,GDKstrdup("garbage"));
	pushArgument(mb,q,getArg(p,j));
	pushInstruction(mb,q);
	typeChecker(s,mb,q,TRUE);
@c
str GCoptimizer(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{   int i,j,k,limit,done;
    InstrPtr p, q, *stmt;
	VarPtr v;
	Client cntxt= getClient();
	Module s = cntxt->nspace;
	int  top=0, blk=1, actions=0;
	long clk= GDKusec();

    (void) pci; (void) stk;  /* to fool compilers */

	stmt= (InstrPtr *) GDKmalloc( mb->ssize * sizeof(InstrPtr));
	memcpy(stmt, mb->stmt,  mb->ssize * sizeof(InstrPtr));
	limit= mb->stop;

	/* move to stable start */
	mb->stop = 0;
    for(i=0; i<limit; i++){
        p= stmt[i];
		pushInstruction(mb,p);
		for(j= p->retc; j<p->argc; j++){
			v= getVar(mb,getArg(p,j));
			/* avoid duplicate releases */
			done = 0;
			for(k=j-1;k>=p->retc;k--)
			if( getArg(p,j)== getArg(p,k)) done++;

			if( done==0 && v->endLifespan == i && isaBatType(getArgType(mb,p,j)) ){
/* 			printf("remove the variable %s at %d\n", getArgName(mb,p,j),i);*/
				if( getVarScope(mb,getArg(p,j)) == blk){
					@:releaseBAT()@
					actions++;
				}
			}
		}
		if( blockStart(p)){
			blk++;
            if( top <MAXDEPTH-2){
            } else {
                mb->errors++;
                return throwMessage("optimizer.garbageCollector",
					"Too deeply nested MAL program\n");
            }
        }
        if( blockExit(p))
            if( top > 0) {
                top--;
		}

    }
#ifdef DEBUG_MAL_GARBAGE
	{	
    if( cntxt->debugOptimizer){
    stream_printf(GDKout,"Garbage collected BAT variables \n");
	printFunction(GDKout,mb, LIST_MAL_ALL);
    stream_printf(GDKout,"End of GCoptimizer\n");
    }}
#endif
	GDKfree(stmt);
	if(pci) 
		removeInstruction(mb,pci);
	optimizerCheck(mb,"garbageCollector",actions, GDKusec()-clk);
    return NULL;
}
@}
