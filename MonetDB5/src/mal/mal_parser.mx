@a M. L. Kersten
@v 1.1

@* Monet Assembler Language
As of Version 5.0 the primary interface for interaction with the Monet kernel
is based on a simple, assembler-like language called MAL. 

The language reflects the virtual machine architecture around the
gdk library and has been designed for speed of interpretation,
ease of analysis, and ease of compilation by applications.

This module contains a small footprint MAL parser for Monet Version 5.
The parser (and its target language) are designed for speed of analysis.
For, parsing is a dominant cost-factor in applications interfering with
Monet. For the language design it means that look-ahead and ambiguity
should be avoided where possible. At the same time the language should
remain 'readable' to enable ease of debugging.

This parser assumes availability of a complete MAL block upfront
as a string to be parsed and executed on behalf of a client. 
Unike Monet V4, no module management operations are allowed within the
context of a procedure. They are considered global commands.

The syntax layout of a MAL program consists of a module name,
a list of import commands, a list of function/ruler/handler
definitions and concludes with the statements to be executed as
the main body of the program.  All components are optional.
A commentary may appear anywhere a statement is expected.

The parser produced is intended to be thread safe.

The stand-alone version of this parser (Mal) can be used 
to check any MAL procedure for syntactic errors in a front-end.

@+ The lexical analyzer
The implementation of the lexical analyzer is straightforward:
the input is taken from a client input buffer. It is assumed that
this buffer contains the complete MIL structure to be parsed.

@h
/*
 * The contents of this file are subject to the Monet Public
 * License Version 1.1 (the "License"); you may not use this file
 * except in compliance with the License. You may obtain a copy of
 * the License at http://www.monetsolutions.com/Download/Licensing/MonetPL-1.1.
html
 * 
 * Software distributed under the License is distributed on an "AS
 * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
 * implied. See the License for the specific language governing
 * rights and limitations under the License.
 * 
 * The Original Code is the Monet Database System.
 * 
 * The Initial Developer of the Original Code is CWI.
 * Portions created by CWI are Copyright (C) 1997-2002 CWI.  
 * All Rights Reserved.
 * 
 * Contributor(s): Martin Kersten <Martin.Kersten@cwi.nl>
 */
#ifndef _MAL_PARSER_H
#define _MAL_PARSER_H

#include "mal_import.h"

mal_export int parseMal(Client cntxt);
mal_export void debugParser(int i);

#endif /* _MAL_PARSER_H */

@- lexical utilities
Before a line is parsed we check for a request to echo it.
This command should be executed at the beginning of a parse
request and each time we encounter EOL.
@c
#include "mal_parser.h"
#include "mal_resolve.h"
#include "mal_linker.h"

#define MAXERRORS 100
#define FATALINPUT MAXERRORS+1
#define NL(X) ((X)=='\n' || (X)=='\r')

int echoInput(Client cntxt){
	if (cntxt->listing) { 
		char *c= cntxt->nxt;
		fputs("#",cntxt->fdout);
		while(*c && !NL(*c)){
			fputc(*c++,cntxt->fdout);
		}
		fputc('\n', cntxt->fdout);
		fflush(cntxt->fdout);
	}
}
#define nextChar(X)  (*(X)->nxt?*(X)->nxt++:0)
#define currChar(X)	*(X)->nxt

INLINE
void skipComment(Client cntxt) { 
	char c; 
	cntxt->nxt++;
	while (c = *cntxt->nxt) {
		if(c== '\n') return;
		if(c== '\r') return;
		cntxt->nxt++;
	}
}
INLINE
void skipSpace(Client cntxt){
	char c; 
	while ((c= *cntxt->nxt) && isspace(c))cntxt->nxt++;
}
INLINE
void advance(Client cntxt, int length){
	cntxt->nxt += length;
	skipSpace(cntxt);
}
@-
The most recurring situation is to recognize identifiers.
This process is split into a few steps to simplify subsequent
construction and comparison.
IdLength searches the end of an identifier without changing
the cursor into the input pool.
IdCopu subsequently prepares a GDK string for inclusion in the
instruction datastructures.

Note that keyword() favors lowercase keywords. This avoids
conversion cost and safes about 20% on lexical analysis.
@c
short opCharacter[256];
short idCharacter[256];
int initParser(){
	int i;
	for(i=0;i<256;i++) idCharacter[i]= isalpha(i);
	for(i=0;i<256;i++)
	switch(i){
	case '-': case '!': case '\\': case '$': case '%':
	case '^': case '*': case '~': case '+': case '&':
	case '|': case '<': case '>': case '=': case '/':
	case ':': opCharacter[i]=1; 
	}
	idCharacter['_']=1;
	idCharacter[TMPMARKER]=1;
}
int idLength(Client cntxt){
	int l;
	str s= cntxt->nxt;
	if( !idCharacter[*s] ) return 0;
	l=1; s++;
	while(idCharacter[*s] || isdigit(*s) ) { s++; l++; }
	return l;
}
str idCopy(Client cntxt, int length){
	str s= GDKmalloc(length+1);
	if( s== 0) GDKfatal("FATAL:idCopy:");
	strncpy(s,cntxt->nxt,length);
	s[length]=0;
	advance(cntxt,length);
	return s;
}
int keyword(Client cntxt, str kw, int length){
	int i;
	if( currChar(cntxt) == *kw &&
		strncmp(cntxt->nxt,kw,length)==0 &&
		!idCharacter[cntxt->nxt[length]] ){
		advance(cntxt,length);
		return 1;
	}
	/* check for captialized versions */
	for(i=0;i<length;i++)
	if( tolower(cntxt->nxt[i]) != kw[i]) return 0;
	if( !idCharacter[cntxt->nxt[length]] ){
		advance(cntxt,length);
		return 1;
	}
	return 0;
}
@-
Keyphrase testing is limited to a few characters only
(check manually). To speed this up we use a pipelined and
inline macros.
@c
int keyphrase(Client cntxt, str kw, int length){
	if( strncmp(cntxt->nxt,kw,length)==0 ){
		advance(cntxt,length);
		return 1;
	}
	return 0;
}
INLINE
int keyphrase1(Client cntxt, str kw){
	if( *cntxt->nxt == *kw){
		advance(cntxt,1);
		return 1;
	}
	return 0;
}
INLINE
int keyphrase2(Client cntxt, str kw){
	if( cntxt->nxt[0] == kw[0] &&
	    cntxt->nxt[1] == kw[1]){
		advance(cntxt,2);
		return 1;
	}
	return 0;
}
@-
A similar approach is used for string literals.
Beware, string lengths returned include the
brackets. They are eaten away in strCopy.
@c
int stringLength(Client cntxt){
	int l=0;
	str s= cntxt->nxt;
	if( *s != '"') return 0;
	s++;
	while( *s ){
		if( *s == '"' && *(s-1) != '\\') break;
		l++;
		s++;
	}
	return l+2;
}
str strCopy(Client cntxt, int length){
	str s= GDKmalloc(length-1);
	if( s== 0) GDKfatal("FATAL:strCopy:");
	strncpy(s,cntxt->nxt+1,length-2);
	s[length-2] = 0;
	advance(cntxt,length);
	return s;
}
@-
And a similar approach is used for operator names.
A lookup table is considered, because it generally is
faster then a non-dense switch.
@c
int operatorLength(Client cntxt){
	int l=0;
	str s;
	for( s= cntxt->nxt ; *s; s++)
	if( opCharacter[*s] ) l++; else return l;
	return l;
}
str operatorCopy(Client cntxt, int length){
	return idCopy(cntxt,length);
}
@-
For error reporting we may have to find the start of the previous line,
which, ofcourse, is easy given the client buffer.
The remaining functions are self-explanatory.
@c
str lastline(Client cntxt){ 
	str s = cntxt->nxt;
	if( NL(*s)) s++;
	while(s && s > cntxt->input && !NL(*s)) s--;
	if( NL(*s)) s++;
	return s;
}
int position(Client cntxt)
{	str s = lastline(cntxt);
	return (int)(cntxt->nxt)- (int)s;
}
void resetInput(Client cntxt) {
        *cntxt->nxt = 0;
}
@-
Upon encountering an error we skip to the nearest semicolon,
or comment terminated by a new line
@c
INLINE
void skipToEnd(Client cntxt){
	char c;
	while ((c = *cntxt->nxt) && c != ';') nextChar(cntxt); 
	if( c== ';') cntxt->nxt++;
}
void parseEndStmt(Client cntxt){
	char c;
	skipSpace(cntxt);
	if( *cntxt->nxt != ';')
		parseError(cntxt,"';' expected\n");
	skipToEnd(cntxt);
}
@-
The lexical analyser for numeric constants is a little more complex.
Aside from getting its length, we need an indication of its type.
We could also rebuild the constant directly, but that is already
handled by newConstant. So be lazy for the time being.
@c
int cstLength(Client cntxt, int *type)
{	int i=0;
	str s= cntxt->nxt;

	if( *s=='f' && strncmp(s,"false",5)==0 && !isalnum(*(s+5)) ){
		*type = TYPE_bit;
		return 5;
	}
	if( *s== 't' && strncmp(s,"true",4)==0 && !isalnum(*(s+4)) ){
		*type = TYPE_bit;
		return 4;
	}
	if( *s== 'n' && strncmp(s,"nil",3)==0 && !isalnum(*(s+3)) ){
		*type = TYPE_void;
		return 3;
	}
	*type = TYPE_int;
	if( *s == '-') { i++; s++;}
	if( ! isdigit(*s)) {
		if( *s!= '.') return 0;
	} 
	while( isdigit(*s)) { i++; s++;}
	if( *s == '.'){ i++; s++; 
		while( isdigit(*s)) { i++; s++;}
		*type= TYPE_flt;
	} 
	if( *s == 'e' || *s == 'E'){ i++; s++;
		if( *s== '-' || *s== '+') s++;
		*type = TYPE_dbl;
		while( isdigit(*s)) { i++; s++;}
	} 
	if( *s == '@'){ i++; s++;
		*type= TYPE_oid;
		while( isdigit(*s)) { i++; s++;}
	} 
	if( *s == 'L' && *(s+1)=='L'){
		if( *type== TYPE_int) {i+=2; *type = TYPE_lng;}
		if( *type== TYPE_flt) {i+=2; *type = TYPE_dbl;}
	}
	return i;
}
str cstCopy(Client cntxt, int i){ return idCopy(cntxt,i);}

@-
Identifiers used as arguments or targets of assignments may be
qualified with a type. The type should be known before-hand,
which essential requires the corresponding module to be loaded first.

The type qualifier can handle array definitions as well. Upon first
encounter they are added as a special type to the atomary type
table.
@c
int typeQualifier(Client cntxt)
{	
	str hd = 0, tl =0;
	int i= TYPE_any, ht,tt;

	if( *cntxt->nxt!=':') return -1;

	cntxt->nxt++;
	skipSpace(cntxt);
	switch(*cntxt->nxt){
	case 'b': if( keyphrase(cntxt,"bit",3) ) return TYPE_bit;
		if( strncmp(cntxt->nxt,"bat[",4)==0){
			/* parse bat[type,type] */

			advance(cntxt,4);
			if( (hd= idCopy(cntxt,idLength(cntxt))) &&
			    nextChar(cntxt)==',' &&
			    (tl= idCopy(cntxt,idLength(cntxt))) ){
				ht = getTypeIndex(hd);
				tt = getTypeIndex(tl);
				i= newBatType(ht,tt);
			}
			if( nextChar(cntxt) !=']')
				parseError(cntxt,"']' expected\n");
			if( hd ) GDKfree(hd);
			if( tl ) GDKfree(tl);
			return i;
		} 
	default:
		if( (hd=idCopy(cntxt,idLength(cntxt))) ){
			ht= getTypeIndex(hd);
			if( hd) GDKfree(hd);
			/* parse the array bound */
			if( currChar(cntxt)=='['){
				int cl,tpe,size;
				str v;
				advance(cntxt,1);
				cl= cstLength(cntxt,&tpe);
				if( cl==0 || tpe != TYPE_int)
				parseError("integer constant expected\n");
				v=cstCopy(cntxt,cl);
				size= (int) strtol(v,NULL,0);
				ht= malAtomArray(ht,size);
				if(currChar(cntxt)!=']')
					parseError(cntxt,"array ']' expected\n");
				nextChar(cntxt);
			}
			return ht;
		} 
		parseError(cntxt,"<type identifier> expected\n");
	}
	return -1;
}
@-
Character constants may be escaped.
@c
str charCst(Client cntxt)
{	int i;
	str v;
	if( *cntxt->nxt!='\'') return 0;
	v= cntxt->nxt; v++;
	i= 1;
	if( *v == '\\') { v++; i++;
		if( isdigit(*v)) { i++; v++;}
		if( isdigit(*v)) { i++; v++;}
		if( isdigit(*v)) { i++; v++;}
	} else v++;
	if( *v != '\'') 
		return (str) parseError(cntxt,"'\'' expected\n");
	v= strCopy(cntxt,i+2);
	return v;
}
@+ The Parser
Unlike Monet V4.3 the client is responsible to collect the
input for parsing in a single string before calling the parser.
Once the input is available parsing runs in a critial section for
a single client thread.

The parser uses the rigid structure of the language to speedup
analysis. In particular, each input line is translated into
a MAL instruction record as quickly as possible. Its context is
manipulated during the parsing process, by keeping the  curPrg,
curBlk, and curInstr variables.

The language does not support '#include' style commands, which
means we do not need a stack to keep track of the parsing context.

The language statements of the parser are gradually introduced, with
the overall integration framework last.
The convention is to return a zero when an error has been
reported or when the structure can not be recognized.
Furthermore, we assume that blancs have been skipped before entering.
@- Module statement.
The module and import commands have immediate effect.
The module statement switches the location for symbol table update
to a specific named area. The effect is that all definitions may become
globally known (?) and symbol table should be temporarilly locked
for updates by concurrent users.
@T
moduleStmt : [ATOM] MODULE modname [':' type]| [ATOM] id [':' type]\\
modname    : identifier | string \\
@-
An atom statement does not introduce a new module.
@= parsePath
	if( x = idLength(cntxt)) modname= idCopy(cntxt,x); else
	if( y = stringLength(cntxt)) modname= strCopy(cntxt,y);
	if( modname==0)
		return parseError(cntxt,"<module path> expected\n");
@c
int parseModule(Client cntxt, int atomary)
{	
	str modname=0;
	int x,y,tpe;

	if( ! keyword(cntxt,"module",6) ){
		if(atomary &&  idLength(cntxt) >0){
			/* parse: ATOM id:type */
			modname= idCopy(cntxt,idLength(cntxt));
			if( currChar(cntxt)==':') {
				tpe= typeQualifier(cntxt);
			} else tpe= TYPE_int;
			malAtomDefinition(modname,tpe);
			GDKfree(modname);
			skipToEnd(cntxt);
			return 1;
		} else 	
		if(atomary) return parseError(cntxt,"'module' expected\n");
		return 0;
	}
	@:parsePath@
@-
Atom storage may be defined in terms of an existing type.
@c
	if( atomary ) { 
		if( strrchr(modname,'/') ){
			GDKfree(modname);
			return parseError(cntxt,"<atom name> expected\n");
		}
		if( currChar(cntxt)==':') {
			tpe= typeQualifier(cntxt);
		} else tpe= TYPE_int;
		/* test for arrays TODO */
		malAtomDefinition(modname,tpe);
	}
	if( findScope(cntxt->nspace,modname) != NULL)
		cntxt->curprg->def->errors  = FATALINPUT;
	else	cntxt->nspace = fixateScope(cntxt->nspace, modname);
	if( atomary) cntxt->nspace->isAtomModule = TRUE;
	GDKfree(modname);
	@:typeInfo@
	skipToEnd(cntxt);
	return 1;
}
@- Import statement
An import statement is immediately taken into effect. This
calls for temporary switching the input for a particular client.
The administration for this is handled by malImport.
@T
importStmt : IMPORT identifier \\
	   : IMPORT string\\
@c
int parseImport(Client cntxt)
{	MalBlkPtr curBlk = 0;
	Symbol curPrg = 0;
	InstrPtr curInstr=0;
	str modname=0;
	int x,y;

	if( ! keyword(cntxt,"use",3)) return 0;

	@:parsePath@

	malImport(cntxt,modname, cntxt->listing);
	GDKfree(modname);
	skipToEnd(cntxt);
	return 1;
}
@- Definition
The definition statements share a lot in common, which calls for factoring
out the code in a few text macros. Upon encountering a definition, we
initialize a MAL instruction container. We should also check for
non-terminated definitions.
@T
defineStmt : FUNCTION
	: COMMAND functionHdr [COMMENT string] ';'
	: HANDLER
	: RULER functionHdr [COMMENT string] ';'

Beware, a function signature f(a1..an):(b1..bn) is parsed in such a way that
the symbol table and stackframe contains the sequence
f,a1..an,b1..bn. This slightly complicates the implementation
of the return statement.

Note, the function name could be mod.fcn, which calls for storing
the function definition in a particular module instead of the current one.
@= closingBracket
	if( nextChar(cntxt) != ')') {
		freeInstruction(curInstr);
		return (MalBlkPtr) parseError(cntxt,"')' expected\n");
	}
@= fcnHeader
	l = operatorLength(cntxt);
	if( l == 0) l = idLength(cntxt);
	if( l == 0) return (MalBlkPtr) parseError(cntxt,
				"<identifier> |<operator> expected\n");

	fnme = idCopy(cntxt,l);

	if( currChar(cntxt) == '.'){
		nextChar(cntxt);
		modnme= fnme;
		l= operatorLength(cntxt);
		if( l == 0) l = idLength(cntxt);
		if( l == 0) return (MalBlkPtr) parseError(cntxt,
					"<identifier> |<operator> expected\n");
		fnme = idCopy(cntxt,l);
		/*parseError(cntxt,"module redirection nyi\n");*/
	}
	if( nextChar(cntxt) != '(') {
		GDKfree(fnme);
		return (MalBlkPtr)parseError(cntxt,
			"function header '(' expected\n");
	}
	skipSpace(cntxt);
	/* curPrg = cntxt->curprg;
	curBlk = curPrg->def;
	curInstr = getInstrPtr(curBlk,0); */

	/* temporary suspend capturing statements in main block */
	cntxt->backup = cntxt->curprg;
	cntxt->curprg = newFunction(fnme);

	curPrg = cntxt->curprg;
	curBlk = curPrg->def;
	curInstr = getInstrPtr(curBlk,0);
	if( curInstr->modname) GDKfree(curInstr->modname);
	curInstr->modname = modnme== 0? GDKstrdup(cntxt->nspace->name):modnme;

	/* get calling parameters */
	ch= currChar(cntxt);
	while( ch !=')' && ch && !NL(ch)){
		str arg;
		@:binding@
		pushArgument(curBlk,curInstr, newVariable(curBlk,arg,type));
		skipSpace(cntxt);
		/* the last argument may be variable length */
		if( keyphrase(cntxt,"...",3) ){
			curInstr->varargs++;
			break;
		}
		skipSpace(cntxt);
		if( (ch=currChar(cntxt)) != ',') {
			if( ch==')') break;
			return (MalBlkPtr) parseError(cntxt,"',' expected\n");
		} else nextChar(cntxt); 
		skipSpace(cntxt);
		ch = currChar(cntxt);
	}
	@:closingBracket@
/*
The return type is either a single type or multiple return type structure.
We simply keep track of the number of arguments added and
during the final phase reshuffle the return values to the beginning (?)
*/
	skipSpace(cntxt);
	if( currChar(cntxt) != ':') {
		/* default */
		setVarType(curBlk,0,TYPE_any);
	} else { 
		if( *(cntxt->nxt+1) =='('){
			int retc= curInstr->argc, i1,i2=0;
			int newarg[MAXARG];
			nextChar(cntxt); 
			/* parse multi-target result */
			nextChar(cntxt);skipSpace(cntxt);
			ch= currChar(cntxt);
			while( ch !=')' && ch && !NL(ch)){
				str arg;
				@:binding@
				pushArgument(curBlk,curInstr, 
					newVariable(curBlk,arg,type));
				skipSpace(cntxt);
				if( (ch=currChar(cntxt)) != ',') {
					if( ch==')') break;
					return (MalBlkPtr) parseError(cntxt,
							"',' expected\n");
				} else nextChar(cntxt); 
				skipSpace(cntxt);
				ch = currChar(cntxt);
			}
			/* re-arrange the parameters, results first*/
			for(i1= retc; i1<curInstr->argc; i1++)
				newarg[i2++]= curInstr->argv[i1];
			curInstr->retc= curInstr->argc-retc;
			for(i1= 1; i1<retc; i1++)
				newarg[i2++]= curInstr->argv[i1];
			curInstr->argc= i2;
			for(; i2<MAXARG; i2++) newarg[i2]= 0;
			for(i1=0; i1<MAXARG; i1++) 
				curInstr->argv[i1] = newarg[i1];
			@:closingBracket@
		} else {
			nextChar(cntxt); skipSpace(cntxt);
			type= melType(cntxt,curInstr);
			@:propList@
			setVarType(curBlk,0,type);
		}
	}
	
@-
The common theme in definitions is to parse the argument list.
@T
functionHdr: fcnName '(' [ binding \{',' binding\}] ')' ':' type\\
@
@= binding
	l = idLength(cntxt);
	arg = idCopy(cntxt,l);
	if( nextChar(cntxt) != ':')
		return (MalBlkPtr) parseError(cntxt,"':' expected\n");
	skipSpace(cntxt);
	type= melType(cntxt,curInstr);
	@:propList@
@-
MAL variables are statically/dynamically typed.
Function and procedure arguments should always be typed.
We do not permit polymorphism at this interpretation level.

The type information maintained simplifies analysis of 
BAT results. If the underlying type is not known, then it
may be replaced once during execution of a MAL instruction
typically as a side-effect of calling a bat-returning function.

We should also allow for variable argument lists. However, they
may only appear in rules, because the calling context is necessary
to resolve the actual argument list. Furthermore, we can not 
assume much about the resulting type structure.
@T
melType	: melElm [propList] | bat '[' melElm ',' melElm ']' [propList]\\
melElm  : identifier | any ['::'digit]\\
propList : '\{' identifier [ ',' identifier] '\}'\\
@-
Variables will later be extended with a property list to enable
squeezers to make decisions. An example is :(int, key, notnull) for
a column of a BAT.

@= propList
	if( keyphrase1(cntxt,"{")) {
		do{
			l = idLength(cntxt);
			advance(cntxt,l);
		} while( keyphrase1(cntxt,","));
		if( !keyphrase1(cntxt,"}") )
			/* return (MalBlkPtr) */
			parseError(cntxt,"'}' expected\n");
		skipSpace(cntxt);
	}
@= melElement
	if( keyword(cntxt,"any",3)){
		type = TYPE_any;
		if( keyphrase2(cntxt,"::")){
			if( !isdigit(currChar(cntxt)) ){
				parseError(cntxt,"[1-9] expected\n");
			} else {
				int k= nextChar(cntxt) - '0';
				setAnyTailIndex(type,k);
			}
		}
		curInstr->polymorphic = TRUE;
	} else {
		char x;
		skipSpace(cntxt);
		l = idLength(cntxt);
		x = cntxt->nxt[l];
		cntxt->nxt[l]= 0;
		type= getTypeIndex(cntxt->nxt);
		if( type == TYPE_any)
			parseError(cntxt,"Type identifier expected\n");
		cntxt->nxt[l]= x;
		cntxt->nxt += l;
	}
	skipSpace(cntxt);
@-
@c
int melType(Client cntxt, InstrPtr curInstr){
	int type= TYPE_any;
	int l;

	if( keyword(cntxt,"bat",3)){
		if( keyphrase1(cntxt,"[")){
			int ht,tt;
			@:melElement@ ht = type;
			if( nextChar(cntxt) !=','){
				parseError(cntxt,"',' expected\n");
				return TYPE_any;
			}
			skipSpace(cntxt);
			@:melElement@ tt = type;
			type = malAnyBatType(ht,tt);
			if( !keyphrase1(cntxt,"]")){
				parseError(cntxt,"']' expected\n");
			}
		} else {
			type = malAnyBatType(TYPE_any,TYPE_any);
			curInstr->polymorphic = TRUE;
		}
	} else{
		@:melElement@
	}
	skipSpace(cntxt);
	return type;
}
@-
Most functions are (dynamically) linked with the kernel.

@= externalFcn
	if( keyphrase1(cntxt,"=")){
		str nme;
		int i;
		skipSpace(cntxt);
		i = idLength(cntxt);
		if( i==0){
			parseError(cntxt,"<identifier> expected\n");
			return 0;
		}
		nme = idCopy(cntxt,i);
		if( curInstr->modname) GDKfree(curInstr->modname);
		curInstr->modname = GDKstrdup(cntxt->nspace->name);
		curInstr->fcn = getAddress(nme);
		curBlk->binding = nme;
		if( cntxt->nspace->isAtomModule) 
			malAtomProperty(curBlk,curInstr);
	} else return (MalBlkPtr) parseError(cntxt,"'=' expected\n");
@-
Each procedure definition opens a structure in which the
information is gathered. The enclosing module is statically
determined.

A proc-header translates into a single MAL instruction.
Since no recursive rules are included, we can stick to
using a single global variable to accummulate the
properties.

The external commands and rules come with a short
help information.

@= helpInfo
	skipSpace(cntxt);
	if( keyphrase(cntxt,"comment",7)){
		skipSpace(cntxt);
		if( l= stringLength(cntxt)){
			curBlk->help = strCopy(cntxt,l);
		} else parseError(cntxt,"<string> expected\n");
	} 
	skipToEnd(cntxt);
@-
Module components may include a function reference overruling
the built-in type resolver. The user-defined type resolver is called
instead.
@= typeInfo
	skipSpace(cntxt);
	if( keyphrase(cntxt,"check",5)){
		int l;
		skipSpace(cntxt);
		if( keyphrase(cntxt,"=",1)==0){
			parseError(cntxt,"'=' expected\n");
		} else{
			skipSpace(cntxt);
			if( l= idLength(cntxt)){
				str nme = idCopy(cntxt,l);
				cntxt->nspace->typeChecker = getAddress(nme);
				GDKfree(nme);
			} else parseError(cntxt,"<identifier> expected\n");
		}
	} 
@c
MalBlkPtr parseCommandPattern(Client cntxt, int kind){
	MalBlkPtr curBlk = 0;
	Symbol curPrg = 0;
	InstrPtr curInstr=0;
	int l;
	str fnme=0, modnme=0, arg=0;
	char ch;
	int type;

	@:fcnHeader@
	getInstrPtr(curBlk,0)->token= kind;
	curPrg->kind = kind;
	insertSymbol(cntxt->nspace,curPrg);
	trimMalBlk(curBlk);
	chkProgram(cntxt->nspace,curBlk);
	resetClientPrg(cntxt);
	skipSpace(cntxt);
	@:externalFcn@
	@:helpInfo@
	showErrors(cntxt);
	if(curBlk && cntxt->listing) 
		printFunction(stdout, curBlk);
	return curBlk;
}

MalBlkPtr parseFunction(Client cntxt){
	MalBlkPtr curBlk = 0;
	Symbol curPrg = 0;
	InstrPtr curInstr=0;
	int l;
	str fnme=0, modnme=0;
	char ch;
	int type, kind= FUNCTIONsymbol;

	if( ! keyword(cntxt,"function",8) ) return 0;
	@:fcnHeader@
	@:helpInfo@
	return curBlk;
}

@-
Commands, functions, rulers, barriers and catch blocks all end
with a labeled end-statement. The routine below checks for
misalignment of the closing statements.
Any instruction parsed after the function block is considered an
error.
@c
int parseEnd(Client cntxt)
{	MalBlkPtr curBlk = 0;
	Symbol curPrg = 0;
	InstrPtr curInstr=0;
	int i,l,showit=0;
	str v;

	if( keyword(cntxt,"end",3)){
		curPrg = cntxt->curprg;
		curBlk = curPrg->def;	
		l = idLength(cntxt);
		if(l==0) l= operatorLength(cntxt);
		if(l== strlen(curPrg->name) &&
		   strncmp(cntxt->nxt, curPrg->name,l)==0){
			advance(cntxt,l);
                        pushEndInstruction(curBlk);
			closeClientPrg(cntxt,TRUE);
			showit= TRUE;
		} else {
			i = findVariableLength(curBlk,cntxt->nxt,l);
			if( i<0) {
				v= idCopy(cntxt,l);
				i= newVariable(curBlk, v, TYPE_str);
			} else advance(cntxt,l);
			curInstr = newInstruction(ENDsymbol);
			curInstr->argv[0]= i;
			pushInstruction(curBlk,curInstr);
		}
		skipToEnd(cntxt);
		if(showit && cntxt->listing) printFunction(stdout, curBlk);
		return 1;
	}
	return 0;
}
@-
The control statements are :
@T
cntrl	: (CATCH | REDO | LEAVE | RAISE | RETURN) identifier\\
@= endparseCntrl
	pushInstruction(curBlk, curInstr);
	skipToEnd(cntxt);
	return 1;
@= parseCntrl
int parse@3(Client cntxt)
{	InstrPtr curInstr;
	MalBlkPtr curBlk;
	Symbol curPrg;
	str arg,v;
	int lt,i,l,z=0;

	if( ! keyword(cntxt,@1,@2)) return 0;
	curPrg = cntxt->curprg;
	curBlk = curPrg->def;	
	curInstr= newInstruction(@3symbol);
	l = idLength(cntxt);
	if( l == 0){
		if( @3symbol != RETURNsymbol ){
			parseError(cntxt,"'return (' expected\n");
			@:endparseCntrl@
		}
		if( currChar(cntxt) != '('){
			parseError(cntxt,"'(' or 'identifier' expected\n");
			@:endparseCntrl@
		}
		nextChar(cntxt); skipSpace(cntxt);
		z++; /* parse multiple return arguments */
		@:parseArguments@
		curInstr->retc= curInstr->argc;
		@:endparseCntrl@
	} 
	i = findVariableLength(curBlk,cntxt->nxt,l);
	if( i<0){
		arg= idCopy(cntxt,l);
		i= newVariable(curBlk, arg, @4);
	} else advance(cntxt,l); 
	curInstr->argv[0]= i;
	if(@3symbol== CATCHsymbol) curInstr->barrier= CATCHsymbol;
	if(@3symbol== THREADsymbol) curInstr->barrier= THREADsymbol;
	skipSpace(cntxt);
	if( *cntxt->nxt != ';')
		parseError(cntxt,"';' expected\n");
	@:endparseCntrl@
}
@c
@:parseCntrl("catch", 5,CATCH, TYPE_str)@
@:parseCntrl("redo", 4,REDO, TYPE_any)@
@:parseCntrl("raise", 5,RAISE, TYPE_any)@
@:parseCntrl("return", 6,RETURN, TYPE_any)@
@:parseCntrl("leave", 5,LEAVE, TYPE_any)@
@:parseCntrl("thread", 6,THREAD, TYPE_any)@
@-
Most instructions are simple assignments, possibly
modified with a barrier/catch tag.
@T
stmt	: tag identifier ':=' expr\\
tag	: BARRIER | CATCH\\
expr	: fcncall | [factor  operator] factor \\
factor	: constant | var | type'('constant')'\\

Factors may designate a type variable. In particular
for bat[T1,T2] this is a little tricky to parse.
@= factor
	if( i= cstLength(cntxt,&lt)){
		v= cstCopy(cntxt,i);
		i= typeQualifier(cntxt);
		if(i>=0) lt = i;
		idx= newConstant(curBlk,lt,v,TRUE);
	} else
	if( (v= charCst(cntxt)) ){
		i= typeQualifier(cntxt);
		if(i>=0) lt = i; else lt= TYPE_chr;
		idx= newConstant(curBlk,lt,v,TRUE);
	} else
	if( i = stringLength(cntxt) ){
		str x= strCopy(cntxt,i);
		i= typeQualifier(cntxt);
		if(i>=0) lt = i; else lt= TYPE_str;
		idx= newConstant(curBlk,lt,x,FALSE);
	} else
	if( i= idLength(cntxt)){
		/* parse bat[type,type] */
		if(i==3 && strncmp(cntxt->nxt,"bat[",4)==0){
			str hd = 0, tl =0;
			int ht,tt;

			advance(cntxt,4);
			if( (hd= idCopy(cntxt,idLength(cntxt))) &&
			    nextChar(cntxt)==',' &&
			    (tl= idCopy(cntxt,idLength(cntxt))) ){
				ht = getTypeIndex(hd);
				tt = getTypeIndex(tl);
				i= newBatType(ht,tt);
				v= malTypeName(i);
				idx= newVariable(curBlk,v,i);
			}
			if( nextChar(cntxt) !=']')
				parseError(cntxt,"']' expected\n");
			if( hd ) GDKfree(hd);
			if( tl ) GDKfree(tl);
		}else
		if( (idx=findVariableLength(curBlk,cntxt->nxt,i)) == -1){
			v= idCopy(cntxt,i);
			i= typeQualifier(cntxt);
			i= i>=0?i: TYPE_any;
			idx = newVariable(curBlk, v, i);
		} else advance(cntxt,i);
	} else { 
		idx= 0;
		parseError(cntxt,"<factor> expected\n");
		pushInstruction(curBlk,curInstr);
		return;
	}
@-
The assignment expression is the most complex term recognized.
@T
assign	: [identifier ':='] expr\\
assign	: '(' identifier {',' identifier} ')' ':=' expr\\
expr	: factor \{ operator factor \}\\
factor	: fcn_call | variable | constant\\

@c
void parseAssign(Client cntxt, int kind)
{	InstrPtr curInstr;
	MalBlkPtr curBlk;
	Symbol curPrg;
	int z=0, i=0, k=0, lt,rt,l,type;
	str v, op, arg=0, r;

	curPrg = cntxt->curprg;
	curBlk = curPrg->def;
	curInstr = newInstruction(ASSIGNsymbol);

	if( kind== BARRIERsymbol || kind==THREADsymbol || kind== EXITsymbol)
		curInstr->barrier = kind;
	if( *cntxt->nxt=='('){
		/* parsing multi-assignment */
		nextChar(cntxt); skipSpace(cntxt);
		curInstr->argc=0; /*reset to handle pushArg correctly !! */
		curInstr->retc=0;
		while(*cntxt->nxt  != ')' && *cntxt->nxt){
			i= idLength(cntxt);
			if( i==0) {
				parseError(cntxt,"<identifier> expected\n"); 
				pushInstruction(curBlk,curInstr);
				return;
			}
			arg= idCopy(cntxt,i);
			type = TYPE_any;
			if( *cntxt->nxt==':' ){
				nextChar(cntxt);
				type= melType(cntxt,curInstr);
			}
			pushArgument(curBlk,curInstr, 
				     newVariable(curBlk,arg,type));
			z++;
			curInstr->retc++;
			if( *cntxt->nxt == ')') break;
			if( currChar(cntxt)==',') keyphrase1(cntxt,",");
			skipSpace(cntxt);
		}
		curInstr->argc++; /* advance to make pushArgument work */
		nextChar(cntxt); skipSpace(cntxt);

	}else{ /* assignment to single variable */
		i= idLength(cntxt);
		if( i==0) {
			parseError(cntxt,"<identifier> expected\n"); 
			pushInstruction(curBlk,curInstr);
			return;
		}
		arg= idCopy(cntxt,i);
@-
Every target variable may be typed immediately.
@c
		type = TYPE_any;
		if( *cntxt->nxt==':' && *(cntxt->nxt+1)!='='){
			nextChar(cntxt);
			type= melType(cntxt,curInstr);
		}
	}

	/* test destination variable or function call */
	if( keyphrase2(cntxt,":=") ){
		if( z==0)
		curInstr->argv[z]= newVariable(curBlk,arg,type);
	} else {
		if( curInstr->barrier) {
			curInstr->argv[z]= newVariable(curBlk,arg,TYPE_any);
			curInstr->token= kind;
			goto part3;
		}
		curInstr->argv[z]= newTmpVariable(curBlk,TYPE_any);
		if( currChar(cntxt) != '.' &&
		    currChar(cntxt) != '(' ){
				GDKfree(arg);
				parseError(cntxt,"'.' or '(' expected\n");
				pushInstruction(curBlk,curInstr);
				return;
		}
		goto idseen;
	}
@-
Now parse the expression, start with an operand.
This code is used in both positions of the expression
@= term
	if( i= cstLength(cntxt,&lt)){
		v= cstCopy(cntxt,i);
		i= typeQualifier(cntxt);
		if(i>=0) lt = i;
		i= newConstant(curBlk,lt,v,TRUE);
		pushArgument(curBlk,curInstr,i);
		goto @1;
	} 
	if( (v= charCst(cntxt)) ){
		i= typeQualifier(cntxt);
		if(i>=0) lt = i; else lt= TYPE_chr;
		i= newConstant(curBlk,lt,v,TRUE);
		pushArgument(curBlk,curInstr,i);
		goto @1;
	} 
	if( i = stringLength(cntxt) ){
		v= strCopy(cntxt,i);
		lt= typeQualifier(cntxt);
		if(lt<0)lt= TYPE_str;
		i= newConstant(curBlk,lt,v,FALSE);
		pushArgument(curBlk,curInstr,i);
		goto @1;
	}
@-
Get arguments for a call, assume a single result.
@= parseArguments
	if(z) curInstr->argc--; /* should be done differently */
	else curInstr->argc=1;
	while( currChar(cntxt)!= ')'){
		int idx;
		@:factor@
		pushArgument(curBlk,curInstr,idx);
		if( currChar(cntxt)==',') keyphrase1(cntxt,",");
		else 
		if( currChar(cntxt) != ')'){
			parseError(cntxt,"',' expected\n");
			cntxt->nxt--; /* keep it */
			break;
		}
	}
@c
	@:term(part2)@
	if( idLength(cntxt)==0 && operatorLength(cntxt)==0) {
		if( currChar(cntxt)== '('){
			nextChar(cntxt);
			skipSpace(cntxt);
			@:parseArguments@
		} else
		parseError(cntxt,"<identifier> or <unary operator> expected\n");
		goto part3;
	}
	if( (i=operatorLength(cntxt))) {
		arg = idCopy(cntxt,i);
		if( currChar(cntxt) == '('){
			nextChar(cntxt);
			curInstr->fcnname = arg;
			goto getarguments;
		}
		if( currChar(cntxt) != '.' &&
		    currChar(cntxt) != '(') {
			skipSpace(cntxt);
			curInstr->fcnname = arg;
			goto part2b;
		}
		goto opseen;
	}
	if( (i= operatorLength(cntxt)) || (i=idLength(cntxt))) {
		arg= idCopy(cntxt,i);
idseen:
		if( currChar(cntxt) != '.' &&
		    currChar(cntxt) != '(' &&
		    (isalpha(*arg) || *arg=='_') ) {
			pushArgumentId(curBlk,curInstr,arg);
			goto part2;
		}

opseen:
		/* continue with parseing a function/operator call */
		if( currChar(cntxt) == '.'){
			nextChar(cntxt);
			skipSpace(cntxt);
			curInstr->modname = arg;
			i = idLength(cntxt);
			if( i==0) i= operatorLength(cntxt);
			if( i )
				curInstr->fcnname = idCopy(cntxt,i);
			else {
				parseError(cntxt,"<functionname> expected\n");
				pushInstruction(curBlk,curInstr);
				return;
			}
			if(nextChar(cntxt) != '(')
			{ 	parseError(cntxt,"'(' expected\n");
				pushInstruction(curBlk,curInstr);
				return;
			}
getarguments:
			skipSpace(cntxt);
		} else if(currChar(cntxt) != '(')
		{
			parseError(cntxt,"'(' expected\n");
			pushInstruction(curBlk,curInstr);
			return;
		} else { nextChar(cntxt);
			curInstr->fcnname = arg;
		}

		@:parseArguments@
		goto part3;
	}
	
part2:
	if( i= operatorLength(cntxt) ){
		/* operator expression */
		curInstr->fcnname = idCopy(cntxt,i);
part2b:
		if( i = idLength(cntxt)) {
			/* test variable */
			if( (k=findVariableLength(curBlk,cntxt->nxt,i)) == -1){
				v= idCopy(cntxt,i);
				k= newVariable(curBlk, v, TYPE_any);
			} else advance(cntxt,i);
			pushArgument(curBlk,curInstr,k); 
			goto part3;
		} 
		@:term(part3)@
		parseError(cntxt,"<term> expected\n");
		pushInstruction(curBlk,curInstr);
		return;
	} else  {
		skipSpace(cntxt);
		if( *cntxt->nxt != ';' && *cntxt->nxt!='#')
		parseError(cntxt,"operator expected\n");
	}
part3:
	skipToEnd(cntxt);
	pushInstruction(curBlk,curInstr);
}
int parseMal(Client cntxt){
	int kind=0, i;
	Symbol curPrg= cntxt->curprg;
	InstrPtr curInstr;

	echoInput(cntxt);
	/* here the work takes place */
	while( currChar(cntxt) && curPrg->def->errors<MAXERRORS){
		switch( currChar(cntxt)){
		case '\n': case '\r': case '\f': 
			nextChar(cntxt);
			echoInput(cntxt);
			continue;
		case '\t': case ' ': 
			  nextChar(cntxt);
		case  0 : continue;
		case '#': skipComment(cntxt);
			  continue;
		case 'A': case 'a':
			  if( keyword(cntxt,"atom",4) &&
			      parseModule(cntxt,TRUE)) break;
			  goto allLeft;
		case 'b': case 'B':
			  if( keyword(cntxt,"barrier",7)) 
				kind = BARRIERsymbol; 
			  goto allLeft;
		case 'C': case 'c': 
			  if( keyword(cntxt,"command",7) ) {
				parseCommandPattern(cntxt, COMMANDsymbol);
				continue;
			  }
			  if( parseCATCH(cntxt)) break;
			  goto allLeft;
		case 'E': case 'e': 
			  if( keyword(cntxt,"exit",4))
				kind= EXITsymbol;
			  else
			  if( parseEnd(cntxt)) break;
			  goto allLeft;
		case 'F': case 'f': 
			  if( parseFunction(cntxt)) break;
			  goto allLeft;
		case 'H': case 'h':
			  if( keyword(cntxt,"handler",5)) 
			  { skipToEnd(cntxt); break; }
		case 'L':
		case 'l': if( parseLEAVE(cntxt)) break;
			  goto allLeft;
		case 'M': case 'm': 
			  if( parseModule(cntxt, FALSE)) break;
			  goto allLeft;
		case 'P': case 'p': 
			  if( keyword(cntxt,"pattern",7) ) {
				parseCommandPattern(cntxt, PATTERNsymbol);
				continue;
			  }
			  goto allLeft;
		case 'R': case 'r': 
			  if( parseRAISE(cntxt)) break;
			  if( parseREDO(cntxt)) break;
			  if( parseRETURN(cntxt)) break;
			  if( keyword(cntxt,"rule",4) ) {
				parseCommandPattern(cntxt, RULEsymbol);
				break;
			  }
			  goto allLeft;
		case 't':
			  if( parseTHREAD(cntxt)) break;
			  goto allLeft;
		case 'u': if( parseImport(cntxt)) continue;
		default: allLeft:
			parseAssign(cntxt,kind);
			kind =0;
		}
	}
	return curPrg->def->errors;
}
@- Error display
Display the error information for the current client.
An arrow and state number is printed at the "appropriate" place. 
If no lookahead character is a used and the next character is a newline,
we should also copy the input.
@c
int parseError(Client cntxt, str msg)
{	Symbol curPrg;
	MalBlkPtr curBlk;
	char buf[10*1024];
	char *s=buf, *t, *l = lastline(cntxt);
	int i;

	curPrg = cntxt->curprg;
	curBlk = curPrg->def;
	if(curBlk) curBlk->errors++;

	/* accidental %s directives in the lastline can
	   crash the vfsprintf later => escape them */
        for(t=l; *t && *t!='\n'; t++) {
                if (*t == '%') *s++ = '%'; 
                *s++ = *t;
        }
        *s++ = '\n';
        *s++ = '!';
	/* produce the position marker*/
	i = position(cntxt) + strlen(GDKERROR)-1;
        for(; i > 0; i--) {
                *s++ = (*l++ != '\t')?' ':'\t';
        }
        *s++ = '^'; 
	*s = 0;

        if (msg == 0)
		msg = "can't help you here, sorry.\n";
	if( strlen(msg)+strlen(buf) < 1020)
		snprintf(s,1020,"%s", msg);
	skipToEnd(cntxt);
        GDKerror(buf);
	return 0;
}
