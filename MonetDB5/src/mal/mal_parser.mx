@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@' 
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@' 
@' The Original Code is the Monet Database System.

@a M. L. Kersten
@v 1.1

@-
@node The parser ,Reverse programming, Before-after calls , MonetDB Assembler Language
@+ The parser
MAL is processed by a small thread-safe parser.
The parser (and its target language) are designed for speed of analysis.
For, parsing is a dominant cost-factor in applications interfering with
MonetDB. For the language design it meant that look-ahead and ambiguity
is avoided where possible. At the same time the language 
remains 'readable' to enable ease of debugging.

The syntax layout of a MAL program consists of a module name,
a list of import commands, a list of function/ pattern/ command/ factory
definitions and concludes with the statements to be executed as
the main body of the program.  All components are optional.

The program may be decorated with comments, which starts with a \# and
runs till the end of the current line. Comments are not retained
at runtime.

This parser assumes availability of a complete MAL block upfront
as a string to be parsed and executed on behalf of a client. 
Module management operations are considered global commands.
@menu
* MAL constants::
* MAL variables::
* MAL instructions::
* Flow of control::
* Instruction Records::
* Before-after calls::
* The parser ::
* Reverse programming::
@end menu


@{
@+ The lexical analyzer
The implementation of the lexical analyzer is straightforward:
the input is taken from a client input buffer. It is assumed that
this buffer contains the complete MIL structure to be parsed.
@h
#ifndef _MAL_PARSER_H
#define _MAL_PARSER_H

#include "mal_import.h"

#define MAXERRORS 100

#define CURRENT(c) (c->fdin->buf + c->fdin->pos + c->yycur)
#define currChar(X) (*CURRENT(X))
#define nextChar(X) X->yycur++
#define prevChar(X) if(X->yycur) X->yycur--

mal_export void initParser();   /* needed in src/mal/mal.c */
mal_export int parseMAL(Client cntxt, Symbol curPrg);
mal_export void echoInput(Client cntxt);
mal_export void debugParser(int i);
mal_export str parseError(Client cntxt, str msg);
mal_export void advance(Client cntxt, int length);
mal_export void skipSpace(Client cntxt);
mal_export void skipToEnd(Client cntxt);
mal_export int idLength(Client cntxt);
mal_export str idCopy(Client cntxt, int len);
mal_export int cstLength(Client cntxt, int *type);
mal_export str cstCopy(Client cntxt, int len);
mal_export int stringLength(Client cntxt);
mal_export str charCst(Client cntxt);
mal_export int operatorLength(Client cntxt);
mal_export str operatorCopy(Client cntxt, int length);
mal_export int keyphrase(Client cntxt, str kw, int length);
mal_export int keyphrase1(Client cntxt, str kw);
mal_export int keyphrase2(Client cntxt, str kw);

#endif /* _MAL_PARSER_H */

@- lexical utilities
Before a line is parsed we check for a request to echo it.
This command should be executed at the beginning of a parse
request and each time we encounter EOL.
@c
#include "mal_parser.h"
#include "mal_resolve.h"
#include "mal_linker.h"
#include "mal_atom.h"       /* for malAtomDefinition(), malAtomArray(), malAtomProperty() */
#include "mal_interpreter.h"    /* for showErrors() */
#include "mal_instruction.h"    /* for pushEndInstruction(), findVariableLength() */
#include "mal_namespace.h"


#define FATALINPUT MAXERRORS+1
#define NL(X) ((X)=='\n' || (X)=='\r')


void echoInput(Client cntxt)
{
    if (cntxt->listing & LIST_INPUT) { 
        char *c = CURRENT(cntxt); 
        stream_printf(cntxt->fdout,"#");
		while (*c && !NL(*c)) {
			stream_printf(cntxt->fdout, "%c", *c++);
		}

		stream_printf(cntxt->fdout, "\n");
		stream_flush(cntxt->fdout);
	}
}

INLINE void 
skipComment(Client cntxt)
{
	char c;

	nextChar(cntxt);
	while ((c = currChar(cntxt))) {
		nextChar(cntxt);
		if (c == '\n' || c == '\r') {
			prevChar(cntxt);
			return;
		}
	}
}

INLINE void 
skipSpace(Client cntxt)
{
	char *s= &currChar(cntxt);
	for (;;) {
		switch (*s++) {
		case ' ':
		case '\t':
		case '\n':
		case '\r':
			nextChar(cntxt);
			break;
		default:
			return;
		}
	}
}

INLINE void 
advance(Client cntxt, int length)
{
	cntxt->yycur += length;
	skipSpace(cntxt);
}

@-
The most recurring situation is to recognize identifiers.
This process is split into a few steps to simplify subsequent
construction and comparison.
IdLength searches the end of an identifier without changing
the cursor into the input pool.
IdCopy subsequently prepares a GDK string for inclusion in the
instruction datastructures.

@c
short opCharacter[256];
short idCharacter[256];

void 
initParser()
{
    int i;

	for (i = 0; i < 256; i++)
		idCharacter[i] = isalpha(i);
	for (i = 0; i < 256; i++)
    switch(i){
    case '-': case '!': case '\\': case '$': case '%':
    case '^': case '*': case '~': case '+': case '&':
    case '|': case '<': case '>': case '=': case '/':
    case ':': 
		opCharacter[i]=1; 
    }
    idCharacter['_']=1;
    idCharacter[TMPMARKER]=1;
}

#undef isdigit
#define isdigit(X)  ((X)>='0' && (X)<='9')

int 
idLength(Client cntxt)
{
    int l;
	str s = CURRENT(cntxt);

	if (!idCharacter[(int) (*s)])
		return 0;
	l = 1;
	s++;
	while (idCharacter[(int) (*s)] || isdigit(*s)) {
		s++;
		l++;
	}
	return l;
}
@-
Simple type identifiers can not be marked with a type variable.
@c
int 
typeidLength(Client cntxt)
{
	int l;
	str s = CURRENT(cntxt);

	if (!idCharacter[(int) (*s)])
		return 0;
	l = 1;
	s++;
	idCharacter[TMPMARKER] = 0;
	while (idCharacter[(int) (*s)] || isdigit(*s)) {
		s++;
		l++;
	}
    idCharacter[TMPMARKER]=1;
    return l;
}
str idCopy(Client cntxt, int length){
    str s= GDKmalloc(length+1);
	strncpy(s, CURRENT(cntxt), length);
    s[length]=0;
    advance(cntxt,length);
    return s;
}

int 
keyword(Client cntxt, str kw, int length)
{
    int i;

	if (currChar(cntxt) == *kw &&
	    strncmp(CURRENT(cntxt), kw, length) == 0 &&
	    !idCharacter[(int) (CURRENT(cntxt)[length])]) {
		advance(cntxt, length);
		return 1;
	}
    /* check for captialized versions */
	for (i = 0; i < length; i++)
		if (tolower(CURRENT(cntxt)[i]) != kw[i])
			return 0;
	if (!idCharacter[(int) (CURRENT(cntxt)[length])]) {
        advance(cntxt,length);
        return 1;
    }
    return 0;
}
@-
Keyphrase testing is limited to a few characters only
(check manually). To speed this up we use a pipelined and
inline macros.
@c
int 
keyphrase(Client cntxt, str kw, int length)
{
	if (strncmp(CURRENT(cntxt), kw, length) == 0) {
        advance(cntxt,length);
        return 1;
    }
    return 0;
}

INLINE int 
keyphrase1(Client cntxt, str kw)
{
	if (currChar(cntxt) == *kw) {
        advance(cntxt,1);
        return 1;
    }
    return 0;
}

INLINE int 
keyphrase2(Client cntxt, str kw)
{
	if (CURRENT(cntxt)[0] == kw[0] && CURRENT(cntxt)[1] == kw[1]) {
        advance(cntxt,2);
        return 1;
    }
    return 0;
}
@-
A similar approach is used for string literals.
Beware, string lengths returned include the
brackets and escapes. They are eaten away in strCopy.
@c
int 
stringLength(Client cntxt)
{
    int l=0;
    int quote =0;
	str s = CURRENT(cntxt);

    if( *s != '"') 
		return 0;
    s++;
    while( *s ){
        if( quote ){ 
            l++; 
            s++;
            quote=0;
        } else {
            if( *s == '"' ) break;
            quote= *s == '\\';
            l++;
            s++;
        }
    }
    return l+2;
}
@-
Beware, the idcmp routine uses a short cast to compare multiple bytes
at once. This may cause problems when the net string length is zero.
@c
str strCopy(Client cntxt, int length){
    str s;
    int i= length-1;

    if( i-2 <sizeof(short)) 
		i = sizeof(short);
    s = GDKmalloc(i);
    *(short*)s = 0;
    if (s == 0) 
		GDKfatal("FATAL:strCopy:");
	strncpy(s, CURRENT(cntxt) + 1, length - 2);
    s[length-2] = 0;
    advance(cntxt,length);
    return s;
}
@-
And a similar approach is used for operator names.
A lookup table is considered, because it generally is
faster then a non-dense switch.
@c
int 
operatorLength(Client cntxt)
{
    int l=0;
    str s;

	for (s = CURRENT(cntxt); *s; s++) {
    	if( opCharacter[(int)(*s)] ) 
			l++; 
		else 
			return l;
	}
    return l;
}

str 
operatorCopy(Client cntxt, int length)
{
    return idCopy(cntxt,length);
}
@-
For error reporting we may have to find the start of the previous line,
which, ofcourse, is easy given the client buffer.
The remaining functions are self-explanatory.
@c
str 
lastline(Client cntxt)
{
	str s = CURRENT(cntxt);
	if (NL(*s))
		s++;
	while (s && s > cntxt->fdin->buf && !NL(*s))
		s--;
	if (NL(*s))
		s++;
    return s;
}

long 
position(Client cntxt)
{   
	str s = lastline(cntxt);
	return (long) (CURRENT(cntxt) - s);
}

void 
resetInput(Client cntxt) 
{
	cntxt->fdin->buf[cntxt->fdin->pos + cntxt->yycur] = 0;
}
@-
Upon encountering an error we skip to the nearest semicolon,
or comment terminated by a new line
@c
INLINE void 
skipToEnd(Client cntxt)
{
	char *c = CURRENT(cntxt), *s = c;

	while (*c && *c != ';') {
		c++;
	}
	cntxt->yycur += (c - s);
	if (*c == ';')
		nextChar(cntxt);
}
@-
The lexical analyser for numeric constants is a little more complex.
Aside from getting its length, we need an indication of its type.
We could also rebuild the constant directly, but that is already
handled by newConstant. So be lazy for the time being.
@c
int cstLength(Client cntxt, int *type)
{   
	int i = 0;
	str s = CURRENT(cntxt);

    *type = TYPE_int;
	if (*s == '-') {
		i++;
		s++;
	}
    if( !isdigit(*s)) {
        if (*s != '.') 
			goto parseTFN;
    } 
	while (isdigit(*s)) {
		i++;
		s++;
	}
	if (*s == '.' && isdigit(*(s+1)) ) {
		i++;
		s++;
		while (isdigit(*s)) {
			i++;
			s++;
		}
		*type = TYPE_flt;
	}
	if (*s == 'e' || *s == 'E') {
		i++;
		s++;
		if (*s == '-' || *s == '+')
			s++;
		*type = TYPE_dbl;
		while (isdigit(*s)) {
			i++;
			s++;
		}
	}
	if (*s == '@') {
		i++;
		s++;
		*type = TYPE_oid;
		while (isdigit(*s)) {
			i++;
			s++;
		}
	}
	if (*s == 'L') {
		if (*type == TYPE_int)
			*type = TYPE_lng;
		if (*type == TYPE_flt)
			*type = TYPE_dbl;
		i++;
		s++;
	}
	if (*s == 'L') {
		i++;
		if (*type == TYPE_int)
			*type = TYPE_lng;
		s++;
	}
    return i;
parseTFN:
    if( *s=='f' && strncmp(s,"false",5)==0 && !isalnum((int)*(s+5)) &&
            *(s+5)!= '_'){
        *type = TYPE_bit;
        return 5;
    }
    if( *s== 't' && strncmp(s,"true",4)==0 && !isalnum((int)*(s+4)) &&
            *(s+4)!= '_'){
        *type = TYPE_bit;
        return 4;
    }
    if( *s== 'n' && strncmp(s,"nil",3)==0 && !isalnum((int)*(s+3)) &&
            *(s+3)!= '_'){
        *type = TYPE_void;
        return 3;
    }
    return 0;
}

INLINE str 
cstCopy(Client cntxt, int i)
{ 
	return idCopy(cntxt,i);
}
@- Type qualifier
Types are recognized as identifiers preceded by a colon.
They may be extended with a property list
and 'any' types can be marked with an alias.
The type qualifier parser returns the encoded type 
as a short 32-bit integer. 
The syntax structure is

@multitable @columnfractions 0.15 0.8
@item typeQualifier  
@tab : typeName propQualifier 
@item typeName       
@tab : scalarType | collectionType | anyType
@item scalarType     
@tab :  ':' @code{ identifier} 
@item collectionType 
@tab :  ':' @code{ bat} ['[' col ',' col ']'] 
@item anyType        
@tab :  ':' @code{ any} [typeAlias] 
@item col            
@tab :  scalarType | anyType 
@item propQualifier  
@tab :  ['@{' property '@}']
@end multitable

The type ANY matches any type specifier.
Appending it with an alias turns it into a type variable.
The type alias is \$DIGIT and can be used to relate types
by type equality. They are currently limited to a single
instruction, in particular, the signature.

The parameters are at most two type qualifiers, which
identify the structure of the underlying association.

Additional information, such as a repetition factor,
encoding tables, or type dependency should be modelled as properties.

@-
The type variable should be defined within the context of a function
scope. Currently limited to 10 and known within the signature
instruction only.
@c
int 
typeAlias(Client cntxt)
{
    int t;

	if (currChar(cntxt) != '$')
		return -1;
	nextChar(cntxt);
	if (!isdigit((int) currChar(cntxt))) {
		parseError(cntxt, "[1-9] expected\n");
		return -1;
	}
	t = currChar(cntxt) - '0';
	nextChar(cntxt);
	skipSpace(cntxt);
	return t;
}
@-
The simple type analysis currently assumes a proper type identifier.
We should change getTypeIndex to return a failure instead.
@c
int 
simpleTypeId(Client cntxt)
{
    int l, tpe;

	nextChar(cntxt);
	l = typeidLength(cntxt);
	if (l == 0) {
		parseError(cntxt, "Type identifier expected\n");
		return -1;
	}
	tpe = getTypeIndex(CURRENT(cntxt), l, -1);
	if (tpe < 0) {
		parseError(cntxt, "Type identifier expected\n");
		return -1;
	}
	advance(cntxt, l);
	return tpe;
}

int 
parseTypeId(Client cntxt, int defaultType)
{   
	int i = TYPE_any, ht, tt, kh = 0, kt = 0;
	char *s= CURRENT(cntxt);

	if (s[1]=='b' && strncmp(s, ":bat[", 5) == 0) {
        /* parse :bat[:type,:type] */
        advance(cntxt,5);
		if( currChar(cntxt) ==':')
			ht = simpleTypeId(cntxt);
		else ht = -1;
		if (ht == TYPE_any)
			kh = typeAlias(cntxt);
		if (currChar(cntxt) != ',') {
			parseError(cntxt, "',' expected\n");
			return i;
		} else {
			nextChar(cntxt); /* skip , */
			skipSpace(cntxt);
		}
		if( currChar(cntxt) ==':')
			tt = simpleTypeId(cntxt);
		else tt= -1;
		if (tt == TYPE_any)
			kt = typeAlias(cntxt);
		i = newBatType(ht, tt);
		if (kh > 0)
			setAnyHeadIndex(i, kh);
		if (kt > 0)
			setAnyTailIndex(i, kt);

		if (currChar(cntxt) != ']')
			parseError(cntxt, "']' expected\n");
		nextChar(cntxt); /* skip ']' */
		skipSpace(cntxt);
		return i;
    }  
	if (s[1]=='c' && strncmp(s, ":col[", 5) == 0) {
        /* parse :col[:type] */
        advance(cntxt,5);
		if( currChar(cntxt) ==':')
			ht = simpleTypeId(cntxt);
		else ht = -1;
		if (ht == TYPE_any)
			kh = typeAlias(cntxt);
		i = newColType(ht);
		if (kh > 0)
			setAnyHeadIndex(i, kh);
		if (currChar(cntxt) != ']')
			parseError(cntxt, "']' expected\n");
		nextChar(cntxt); /* skip ']' */
		skipSpace(cntxt);
		return i;
    }  
    if( s[1]=='b' && strncmp(s,":bat",4)==0){
        /* parse default for :bat[:any,:any] */
        advance(cntxt,4);
        return newBatType(TYPE_any,TYPE_any);
    } 
    if( s[1]=='c' && strncmp(s,":col",4)==0){
        /* parse default for :col[:any] */
        advance(cntxt,4);
        return newColType(TYPE_any);
    } 
	if( currChar(cntxt) ==':')
		ht = simpleTypeId(cntxt);
	else ht = -1;
	if (ht >= 0)
		return ht;
    parseError(cntxt,"<type identifier> expected\n");
    return defaultType;
}

int typeElm(Client cntxt, int def)
{
	int type;
    int k;

	if (currChar(cntxt) != ':')
		type= def;	/* no type qualifier */
	else type= parseTypeId(cntxt,def);
	if (type == TYPE_any && (k = typeAlias(cntxt)) >= 0)
		setAnyTailIndex(type, k);
    return type;
}
@-
Character constants may be escaped.
@c
str charCst(Client cntxt) 
{
	int i;
	str v = CURRENT(cntxt);

	if (*v != '\'')
		return 0;
	v++;
	i = 1;
	if (*v == '\\') {
		v++;
		i++;
		if (isdigit(*v)) {
			i++;
			v++;
		}
		if (isdigit(*v)) {
			i++;
			v++;
		}
		if (isdigit(*v)) {
			i++;
			v++;
		}
	} else {
		v++;
	}
	if (*v != '\'')
		return (str) parseError(cntxt, "'\'' expected\n");
	v = strCopy(cntxt, i + 2);
	return v;
}
@+ The Parser
The client is responsible to collect the
input for parsing in a single string before calling the parser.
Once the input is available parsing runs in a critial section for
a single client thread.

The parser uses the rigid structure of the language to speedup
analysis. In particular, each input line is translated into
a MAL instruction record as quickly as possible. Its context is
manipulated during the parsing process, by keeping the  curPrg,
curBlk, and curInstr variables.

The language statements of the parser are gradually introduced, with
the overall integration framework last.
The convention is to return a zero when an error has been
reported or when the structure can not be recognized.
Furthermore, we assume that blancs have been skipped before entering
recognition of a new token.

@- Module statement.
The module and import commands have immediate effect.
The module statement switches the location for symbol table update
to a specific named area. The effect is that all definitions may become
globally known (?) and symbol table should be temporarilly locked
for updates by concurrent users.

@multitable @columnfractions 0.15 0.8
@item moduleStmt      
@tab :  @code{atom} ident [':'ident]
@item
@tab | @code{module} ident
@end multitable

@-
An atom statement does not introduce a new module.
@c
str 
parseAtom(Client cntxt) 
{
	str modnme = 0;
	int l, tpe;
	char *nxt= CURRENT(cntxt);

	if ( (l =idLength(cntxt)) <= 0)
		return parseError(cntxt, "atom name expected\n");

	/* parse: ATOM id:type */
	modnme = putName(nxt, l);
	advance(cntxt,l);
	if (currChar(cntxt) != ':')
		tpe= TYPE_int;	/* no type qualifier */
	else tpe = parseTypeId(cntxt, TYPE_int);
	malAtomDefinition(modnme, tpe);
	cntxt->nspace = fixModule(cntxt->nspace, modnme);
	cntxt->nspace->isAtomModule = TRUE;
	@:helpInfo(cntxt->nspace->help) @
	return "";
}

str parseModule(Client cntxt) 
{
	str modnme = 0;
	int l;
	char *nxt;

	nxt= CURRENT(cntxt);
	if ((l = idLength(cntxt)) <= 0)
		return parseError(cntxt, "<module path> expected\n");
	modnme = putName(nxt, l);
	advance(cntxt,l);
	cntxt->nspace = fixModule(cntxt->nspace, modnme);
@-
Module components may include a function reference overruling
the built-in type resolver. The user-defined type resolver is called
instead.
@c
	if (keyphrase(cntxt, "check", 5)) {
		int l;
		if ((l = idLength(cntxt))) {
			str nme = idCopy(cntxt, l);
			cntxt->nspace->typeChecker = getAddress(nme,0);
			GDKfree(nme);
		} else {
			parseError(cntxt, "<identifier> expected\n");
		}
	}
	@:helpInfo(cntxt->nspace->help)@
	return "";
}
@- Include statement
An include statement is immediately taken into effect. This
calls for temporary switching the input for a particular client.
The administration for this is handled by malInclude.
No listing is produced, because module sources are assumed to
be debugged upfront already.
@multitable @columnfractions 0.15 0.8
@item includeStmt     
@tab : @code{include} identifier 
@item
@tab | @code{include} string_literal
@end multitable

@c
str
parseInclude(Client cntxt)
{
    str modnme = 0;
    int x;
	char *nxt;

    if (!keyword(cntxt,"include",7)) 
		return 0;
	nxt= CURRENT(cntxt);

    if ( (x = idLength(cntxt)) >0 ||  (x = stringLength(cntxt))>0){
		modnme= putName(nxt,x);
		advance(cntxt,x);
	} else
        return parseError(cntxt,"<module path> expected\n");

	if (currChar(cntxt) != ';') {
		parseError(cntxt,"';' expected\n");
		skipToEnd(cntxt);
		return "";
	}
	skipToEnd(cntxt);

    malInclude(cntxt, modnme, modnme, 0);
    return "";
}
@- Definition
The definition statements share a lot in common, which calls for factoring
out the code in a few text macros. Upon encountering a definition, we
initialize a MAL instruction container. We should also check for
non-terminated definitions.

@multitable @columnfractions 0.15 0.8
@item program         
@tab : ( definition [helpinfo] | statement ) *

@item definition      
@tab : moduleStmt | includeStmt 
@item
@tab  |  commandStmt | patternStmt 
@item
@tab  | functionStmt | factoryStmt
@item
@tab  | includeStmt
@end multitable

Beware, a function signature f(a1..an):(b1..bn) is parsed in such a way that
the symbol table and stackframe contains the sequence
f,a1..an,b1..bn. This slightly complicates the implementation
of the return statement.

Note, the function name could be mod.fcn, which calls for storing
the function definition in a particular module instead of the current one.
@= fcnHeader
    l = operatorLength(cntxt);
	if (l == 0)
		l = idLength(cntxt);
	if (l == 0)
		return (MalBlkPtr) parseError(cntxt,
				"<identifier> | <operator> expected\n");

	fnme= putName( ((char *) CURRENT(cntxt)),l);
	advance(cntxt,l);

	if (currChar(cntxt) == '.') {
		nextChar(cntxt); /* skip '.' */
        modnme = fnme;
        l= operatorLength(cntxt);
		if (l == 0)
			l = idLength(cntxt);
		if (l == 0)
			return (MalBlkPtr) parseError(cntxt,
					"<identifier> | <operator> expected\n");
		fnme= putName( ((char *) CURRENT(cntxt)),l);
		advance(cntxt,l);
    } 
    if (currChar(cntxt) != '(') 
        return (MalBlkPtr)parseError(cntxt, "function header '(' expected\n");
 
	nextChar(cntxt); /* skip '(' */
    skipSpace(cntxt);

    /* temporary suspend capturing statements in main block */
    if( cntxt->backup && curBlk && curBlk->errors==0) 
        GDKfatal("mal_parser: unexpected recursion\n");
    cntxt->backup = cntxt->curprg;
	cntxt->curprg = newFunction(fnme, kind);

    curPrg = cntxt->curprg;
    curBlk = curPrg->def;
	curBlk->flowfixed= 0;
	curBlk->typefixed= 0;
    curInstr = getInstrPtr(curBlk,0);
    if( modnme == 0){
        setModuleScope(curInstr, cntxt->nspace);
    } else {
        setModuleId(curInstr, putName(modnme,strlen(modnme)) );
    }

    /* get calling parameters */
    ch= currChar(cntxt);
    while( ch !=')' && ch && !NL(ch)){
        @:binding@
        /* the last argument may be variable length */
        if( keyphrase(cntxt,"...",3) ){
            curInstr->varargs++;
			curInstr->polymorphic=1;
            break;
        }
		if ((ch = currChar(cntxt)) != ',') {
			if (ch == ')')
				break;
            return (MalBlkPtr) parseError(cntxt,"',' expected\n");
		} else {
			nextChar(cntxt); /* skip ',' */
		}
        skipSpace(cntxt);
        ch = currChar(cntxt);
    }
	if (currChar(cntxt) != ')') {
        freeInstruction(curInstr);
        return (MalBlkPtr) parseError(cntxt,"')' expected\n");
    }
	nextChar(cntxt); /* skip ')' */
/*
The return type is either a single type or multiple return type structure.
We simply keep track of the number of arguments added and
during the final phase reshuffle the return values to the beginning (?)
*/
    skipSpace(cntxt);
	type = typeElm(cntxt, -1);
	if( type == TYPE_any)
			curInstr->polymorphic = 1;
	if (type >= 0) {
        setVarType(curBlk,curInstr->argv[0],type);
        if (isPolymorphic(type))
			curInstr->polymorphic = 1;
        @:propList(curInstr->argv[0])@
    } else if( keyphrase1(cntxt,"(")){ /* deal with compound return */
        int retc= curInstr->argc, i1,i2=0;
        int maxarg;
        int *newarg;
        /* parse multi-target result */
        /* skipSpace(cntxt);*/
        ch= currChar(cntxt);
        while( ch !=')' && ch && !NL(ch)){
            int varid=0;
            int type= TYPE_any;
            @:binding@
            if( (ch=currChar(cntxt)) != ',') {
                if( ch==')') break;
                return (MalBlkPtr) parseError(cntxt, "',' expected\n");
            } else {
				nextChar(cntxt); /* skip ',' */ 
			}
            skipSpace(cntxt);
            ch = currChar(cntxt);
        }
        /* re-arrange the parameters, results first*/
        maxarg= curInstr->maxarg;
        newarg= (int*)GDKmalloc(maxarg*sizeof(int));
        for(i1= retc; i1<curInstr->argc; i1++)
            newarg[i2++]= curInstr->argv[i1];
        curInstr->retc= curInstr->argc-retc;
        for(i1= 1; i1<retc; i1++)
            newarg[i2++]= curInstr->argv[i1];
        curInstr->argc= i2;
        for(; i2<maxarg; i2++) newarg[i2]= 0;
        for(i1=0; i1<maxarg; i1++) 
            curInstr->argv[i1] = newarg[i1];
        GDKfree(newarg);
        if (currChar(cntxt) != ')') {
            freeInstruction(curInstr);
            return (MalBlkPtr) parseError(cntxt, "')' expected\n");
        }
		nextChar(cntxt); /* skip ')' */
    } else { /* default */
        setVarType(curBlk,0,TYPE_void);
	}
@-
The common theme in definitions is to parse the argument list.
@multitable @columnfractions .15 .8
@item header          
@tab :  hdrName '(' params ')' result 
@item result          
@tab :  paramType | '(' params ')'
@item params          
@tab :  binding [',' binding]* 
@item binding         
@tab :  identifier typeName [propQualifier]
@end multitable
@
@= binding
    l = idLength(cntxt);
    if( l>0) {
		varid = findVariableLength(curBlk, CURRENT(cntxt), l);
		if( varid < 0){
			varid = newVariable(curBlk,idCopy(cntxt,l),TYPE_any);
			type= typeElm(cntxt,-1);
			if( type == TYPE_any)
					curInstr->polymorphic = 1;
		} else{
			advance(cntxt,l);
			type= typeElm(cntxt,-1);
			if( type == TYPE_any)
					curInstr->polymorphic = 1;
			if( type != getVarType(curBlk,varid))
				parseError(cntxt,"incompatible variable type\n");
		}
    } else {
		type= typeElm(cntxt,-1);
		if( type == TYPE_any)
				curInstr->polymorphic = 1;
    	varid = newTmpVariable(curBlk,type);
	}
    @:propList(varid)@
    curInstr= pushArgument(curBlk,curInstr, varid);
    if( isPolymorphic(type))
        curInstr->polymorphic = 1;
    setVarType(curBlk,varid,type);
@-
@}
MAL variables are statically/dynamically typed.
Function and procedure arguments should always be typed.
We do not permit polymorphism at this interpretation level.

The type information maintained simplifies analysis of 
BAT results. If the underlying type is not known, then it
may be replaced once during execution of a MAL instruction
typically as a side-effect of calling a bat-returning function.

We should also allow for variable argument lists. However, they
may only appear in patterns, because the calling context is necessary
to resolve the actual argument list. Furthermore, we can not 
assume much about its type structure.
@-
Variables are extended with a property list to enable
optimizers to make decisions. (See the section on properties).
@{
@-
@= propList
    if( keyphrase1(cntxt,"{")) {
        do {
            str pname;

            l = idLength(cntxt);
            if(l==0) 
				break;
            pname= idCopy(cntxt,l);
            if( curBlk->var[@1]->props== NULL)
                curBlk->var[@1]->props= newPropertySet();
			/* localize value , simplified version */
			if(keyphrase1(cntxt,"=")) {
				int i,lt;
				if( (i= cstLength(cntxt,&lt))){
					char *nxt= CURRENT(cntxt);
					switch(lt){
					case TYPE_sht:
					case TYPE_int:{
						int l= strtol(nxt, NULL,10);
						int ival= (int)l;
						setVarProperty(curBlk,@1,pname, lt, &ival);
						break;
						}
					case TYPE_lng:{
						lng l= strtol(nxt, NULL,10);
						setVarProperty(curBlk,@1,pname, lt, &l);
						break;
						}
					case TYPE_dbl:
					case TYPE_flt:{
						double l= strtod(nxt,NULL);
						setVarProperty(curBlk,@1,pname, lt, &l);
						break;
						}
					case TYPE_bit:{
						int bval;
						if( strncmp(nxt,"true",4)==0 && i==4)
							bval= TRUE;
						else
						if( strncmp(nxt,"false",5)==0 && i==4)
							bval= FALSE;
						else
						if( strncmp(nxt,"TRUE",4)==0 && i==4)
							bval= TRUE;
						else
						if( strncmp(nxt,"FALSE",4)==0 && i==4)
							bval= FALSE;
						setVarProperty(curBlk,@1,pname, lt, &bval);
						break;
						}
					case TYPE_str:
						setVarProperty(curBlk,@1,pname, lt,
							GDKstrdup(cstCopy(cntxt,i)));
					}
					advance(cntxt,i);
				}
			} else 
				setVarProperty(curBlk,@1,pname, TYPE_str,GDKstrdup(""));
            GDKfree(pname); 
        } while( keyphrase1(cntxt,","));
        if( !keyphrase1(cntxt,"}") )
            /* return (MalBlkPtr) */
            parseError(cntxt,"'}' expected\n");
    }
@-
Each procedure definition opens a structure in which the
information is gathered. The enclosing module is statically
determined.

A proc-header translates into a single MAL instruction.
Since no recursive rules are included, we can stick to
using a single global variable to accummulate the
properties.

The external commands and rules come with a short
help information.

@= helpInfo
    skipSpace(cntxt);
    if( keyphrase(cntxt,"comment",7)){
        if( (l= stringLength(cntxt))){
            @1 = strCopy(cntxt,l);
        } else {
			parseError(cntxt,"<string> expected\n");
		}
    } else 
    if (currChar(cntxt) != ';')
        parseError(cntxt,"';' expected\n");
    skipToEnd(cntxt);
@c
MalBlkPtr parseCommandPattern(Client cntxt, int kind){
    MalBlkPtr curBlk = 0;
    Symbol curPrg = 0;
    InstrPtr curInstr=0;
    int l;
    str fnme=0, modnme=0;
    char ch;

    int varid=0;
    int type= TYPE_any;

    @:fcnHeader@
    getInstrPtr(curBlk,0)->token= kind;
    curPrg->kind = kind;
	modnme= modnme? modnme:"user";
    insertSymbol(findModule(cntxt->nspace, 
			putName(modnme,strlen(modnme))), curPrg);
    trimMalBlk(curBlk);
    chkProgram(cntxt->nspace,curBlk);
    if( cntxt->backup){
        cntxt->curprg = cntxt->backup;
        cntxt->backup = 0;
    }
    skipSpace(cntxt);
@}
@- Short-cut function calls
Most functions are (dynamically) linked with the kernel as
commands or pattern definitions.  This enables for fast execution.

In addition we allow functions to be bound to both
a linked C-function and a MAL specification block.
It the function address is not available, the interpreter
will use the MAL block instead.
This scheme is intended for just-in-time compilation.

[note, command and patterns do not have a MAL block]
@{
@c
    if( keyphrase(cntxt,"address",7)){
        str nme;
        int i;
        i = idLength(cntxt);
        if( i==0){
            parseError(cntxt,"<identifier> expected\n");
            return 0;
        }
        cntxt->blkmode=0;
        nme = idCopy(cntxt,i);
        if( moduleId(curInstr)) freeModuleName(curInstr);
        setModuleScope(curInstr, 
			findModule(cntxt->nspace, putName(modnme,strlen(modnme))) );
        curInstr->fcn = getAddress(nme,0);
        curBlk->binding = nme;
        if( cntxt->nspace->isAtomModule) 
            malAtomProperty(curBlk, curInstr);
    } else {
		return (MalBlkPtr) parseError(cntxt,"'address' expected\n");
	}
    @:helpInfo(curBlk->help)@
    showErrors();
    if(curBlk && cntxt->listing) 
        printFunction(GDKout, curBlk, cntxt->listing);
    return curBlk;
}

MalBlkPtr parseFunction(Client cntxt, int kind){
    MalBlkPtr curBlk = 0;
    Symbol curPrg = 0;
    InstrPtr curInstr=0;
    int l;
    str fnme=0, modnme=0;
    char ch;

    int varid=0;
    int type= TYPE_any;

    @:fcnHeader@
    skipSpace(cntxt);
    if( keyphrase(cntxt,"address",7)){
        str nme;
        int i;
        skipSpace(cntxt);
        i = idLength(cntxt);
        if( i==0){
            parseError(cntxt,"<identifier> expected\n");
            return 0;
        }
        nme = idCopy(cntxt,i);
        curInstr->fcn = getAddress(nme,0);
        skipSpace(cntxt);
    }
    /* block is terminated at the END statement */
    @:helpInfo(curBlk->help)@
    return curBlk;
}

@-
Functions and  factories end with a labeled end-statement. 
The routine below checks for misalignment of the closing statements.
Any instruction parsed after the function block is considered an
error.
@c
int parseEnd(Client cntxt)
{   MalBlkPtr curBlk = 0;
    Symbol curPrg = 0;
    int l,showit=0;

    if( keyword(cntxt,"end",3) ){
        curPrg = cntxt->curprg;
        curBlk = curPrg->def;   
        l = idLength(cntxt);
        if(l==0) l= operatorLength(cntxt);
        if( (l== strlen(curPrg->name) &&
             strncmp(CURRENT(cntxt), curPrg->name, l)==0) || l==0) {
            /* its ok */
        } else {
        	parseError(cntxt,"non matching end label, overruled\n");
		}
        
        advance(cntxt,l);
        pushEndInstruction(curBlk);
        insertSymbol(cntxt->nspace, cntxt->curprg);
        trimMalBlk(cntxt->curprg->def);
        cntxt->blkmode =0;
		curBlk->typefixed=0;
        chkProgram(cntxt->nspace, cntxt->curprg->def);
        if( cntxt->backup){
            cntxt->curprg = cntxt->backup;
            cntxt->backup = 0;
        }
        showit= TRUE;
        skipToEnd(cntxt);
        if(showit && cntxt->listing) 
            printFunction(GDKout, curBlk, cntxt->listing);
        showErrors();
        return 1;
    }
    return 0;
}
@-
Most instructions are simple assignments, possibly
modified with a barrier/catch tag.
@multitable @columnfractions .15 .8
@item statement       
@tab :  tag varlist [':=' expr ] propQualifier
@item tag             
@tab :  @code{ return} | @code{ barrier} | @code{ catch}
@item
@tab |  @code{ leave} | @code{ redo} | 
@item expr            
@tab :  fcncall 
@item
@tab : [factor  operator] factor 
@item varlist         
@tab :  variable 
@item
@tab |  @verb{'{' variable {',' variable}* ')' } 
@item variable        
@tab :  identifier propQualifier 
@item factor          
@tab :  constant | var 
@end multitable

The basic types are also predefined as a variable.
This makes it easier to communicate types to MAL patterns.

@= GETvariable
if ((varid = findVariableLength(curBlk, CURRENT(cntxt), l)) == -1){
    arg = idCopy(cntxt,l); 
    varid = newVariable(curBlk,arg,TYPE_any);
} else {
    advance(cntxt,l); 
}
@-
@c
void 
parseAssign(Client cntxt, int cntrl) 
{   
	InstrPtr curInstr;
    MalBlkPtr curBlk;
    Symbol curPrg;
    int consumed =0,i=0, lt,l,type=TYPE_any, varid= -1, yycur = cntxt->yycur;
    str arg=0; 

    curPrg = cntxt->curprg;
    curBlk = curPrg->def;
    curInstr = newInstruction(cntrl?cntrl:ASSIGNsymbol);

    /* start the parsing by recognition of the lhs of an assignment */
    if( currChar(cntxt) == '('){
        /* parsing multi-assignment */
        nextChar(cntxt);  /* skip '(' */
		skipSpace(cntxt);
        curInstr->argc=0; /*reset to handle pushArg correctly !! */
        curInstr->retc=0;
        while( currChar(cntxt)  != ')' && currChar(cntxt)) {
            l= idLength(cntxt);
            if( l==0) {
                parseError(cntxt,"<identifier> expected\n"); 
                pushInstruction(curBlk,curInstr);
                return;
            }
            @:GETvariable@
            type = typeElm(cntxt,-1);
			if( type == TYPE_any)
					curInstr->polymorphic = 1;
            if (type>0) 
				setVarType(curBlk,varid,type);
            /* check for any properties */
            @:propList(varid)@
            setVarInitialized(curBlk,varid);
            curInstr= pushArgument(curBlk,curInstr, varid);
            curInstr->retc++;
            if( currChar(cntxt) == ')') 
				break;
            if( currChar(cntxt) == ',') 
				keyphrase1(cntxt,",");
            skipSpace(cntxt);
        }
        nextChar(cntxt); /* skip ')' */
		skipSpace(cntxt);

    }else{ 
        /* are we dealing with a simple assignment? */
        l= idLength(cntxt);
        if( l==0){
            l= operatorLength(cntxt);
            if(l) goto startFCNcall;
            /* we haven't seen an identifier nor an operator */
            /* flow of control statements may end here.
               the control variable can be looked up */
            if( cntrl == LEAVEsymbol || cntrl == REDOsymbol 
             || cntrl == EXITsymbol ){
                pushInstruction(curBlk,curInstr);
                curInstr->argv[0]= getBarrierEnvelop(curBlk);
                skipToEnd(cntxt);
                return;
            }
            pushInstruction(curBlk,curInstr);
            parseError(cntxt,"<identifier> or <operator> expected\n"); 
            return;
        }
        /* Check if we are dealing with an assignment */
        {   
			yycur = cntxt->yycur;
            advance(cntxt,l);
            /* first check for type qualifier and propertyset */
            if( (currChar(cntxt) == ':' && CURRENT(cntxt)[1] != '=') ||
                 currChar(cntxt) == '{' ){
                cntxt->yycur = yycur;
                @:GETvariable@
                curInstr->argv[0]= varid;
                type = typeElm(cntxt,-1);
				if( type == TYPE_any)
						curInstr->polymorphic = 1;
                if (type>0) 
					setVarType(curBlk,varid,type);
                /* check for any properties */
                @:propList(varid)@
                setVarInitialized(curBlk,varid);
                consumed = 1;
                yycur = cntxt->yycur;
            } 
            /* look ahead for assignment operator */
            if( !keyphrase2(cntxt,":=") ){
                /* no assignment !! a variable is allowed */
                if (curInstr->barrier){
                    cntxt->yycur = yycur;
                    if (consumed==0){
                        @:GETvariable@
                        curInstr->argv[0]= varid;
                        curInstr->token= NOOPsymbol;
                        consumed++;
                        yycur = cntxt->yycur;
                    }
                    if (currChar(cntxt) != ';')
                    	parseError(cntxt,"';' expected\n");
                    goto part3;
                } 
                if (currChar(cntxt) != '(' && currChar(cntxt) != '.'){
                    parseError(cntxt,"'.' or '(' expected\n");
                    cntxt->yycur = yycur;
                    goto part3;
                } 
                if (consumed == 0) 
					cntxt->yycur = yycur;
                curInstr->argv[0]= newTmpVariable(curBlk,TYPE_any);
                goto startFCNcall;
            } else {
				cntxt->yycur = yycur;
			}
        }
        if (consumed == 0) {
            cntxt->yycur = yycur;
            @:GETvariable@ 
            curInstr->argv[0]= varid;
            /* check for any properties */
            @:propList(varid)@
        }
    }

    /* test destination variable or function call */
    if (!keyphrase2(cntxt, ":=")) {
        if( cntrl == 0) 
            GDKerror("parseAssign:internal error\n");
        pushInstruction(curBlk,curInstr);
        return;
    }
@-
At this stage the LHS part has been parsed and the destination
variables have been set. Next step is to parse the expression,
which starts with an operand.
This code is used in both positions of the expression
@= term
	str v = NULL;

    if( (i= cstLength(cntxt,&lt))){
        int bak = cntxt->yycur;
		int cstidx = -1,csttpe;

        cstidx = fndConstant(curBlk,((char*)CURRENT(cntxt)),i);
		if( cstidx){
			advance(cntxt,i);
			if( currChar(cntxt)==':')
				csttpe= typeElm(cntxt,-1);
			else csttpe= lt;
			if( csttpe == TYPE_any)
					curInstr->polymorphic = 1;
			if( csttpe == getVarType(curBlk,cstidx) ){
				curInstr = pushArgument(curBlk,curInstr,cstidx);
				@1;
			} else {
				cstidx= -1;
				cntxt->yycur = bak;
			}
		} else cstidx= -1;

		if( cstidx < 0){
			v = cstCopy(cntxt,i);
			i = typeElm(cntxt,-1);
			if( i == TYPE_any)
					curInstr->polymorphic = 1;
			if(i>=0) {
				int newlength = cntxt->yycur - bak;
				lt = i;
				/* save original input */
				if(v) GDKfree(v);
				cntxt->yycur = bak;
				v = idCopy(cntxt,newlength);
			}
			i = newConstant(curBlk,lt,v,TRUE);
			curInstr = pushArgument(curBlk,curInstr,i);
			@1;
		}
    } else if ( currChar(cntxt)=='\'' && (v = charCst(cntxt)) ){
        lt = typeElm(cntxt,TYPE_chr);
		if( lt == TYPE_any)
				curInstr->polymorphic = 1;
        i = newConstant(curBlk,lt,v,TRUE);
        curInstr = pushArgument(curBlk,curInstr,i);
        @1;
    } else if( currChar(cntxt)=='"' &&  (i = stringLength(cntxt)) ){
        v = strCopy(cntxt,i);
        lt = typeElm(cntxt,TYPE_str);
		if( lt == TYPE_any)
				curInstr->polymorphic = 1;
        i = newConstant(curBlk,lt,v,FALSE);
        curInstr = pushArgument(curBlk,curInstr,i);
        @1;
    }
@-
The parameter of parseArguments is the return value of the enclosing function.
@= parseArguments
    while( currChar(cntxt)!= ')'){
        int idx;
        @:term()@ 
		else if( (i= idLength(cntxt))){
            if( (idx=findVariableLength(curBlk,CURRENT(cntxt),i)) == -1){
                v= idCopy(cntxt,i);
				if( currChar(cntxt)==':')
					i= typeElm(cntxt,TYPE_any);
				else i= TYPE_any;
				if( i == TYPE_any)
						curInstr->polymorphic = 1;
                idx = newVariable(curBlk, v, i);
                setVarInitialized(curBlk,idx);
                @:propList(idx)@
            } else {
                advance(cntxt,i);
				if( currChar(cntxt)==':')
					i = typeElm(cntxt,-1);
				else i = -1;
				if( i == TYPE_any)
						curInstr->polymorphic = 1;
                if(i>=0 && getVarType(curBlk,idx)!= i){
                    parseError(cntxt,"incompatible type\n");
                    return @1;
                }
                @:propList(idx)@
            }
            curInstr= pushArgument(curBlk,curInstr,idx);
        } else if (currChar(cntxt) == ':'){
            i = typeElm(cntxt,TYPE_any);
			if( i == TYPE_any)
					curInstr->polymorphic = 1;
            idx = newTypeVariable(curBlk, i );
            @:propList(idx)@
            curInstr = pushArgument(curBlk,curInstr,idx);
        } else { 
            idx = 0;
            parseError(cntxt,"<factor> expected\n");
            pushInstruction(curBlk,curInstr);
            return @1;
        }
        if (currChar(cntxt) == ',') 
			advance(cntxt,1);
        else if (currChar(cntxt) != ')') {
            parseError(cntxt,"',' expected\n");
            cntxt->yycur--; /* keep it */
            break;
        }
    }
    if (currChar(cntxt) == ')') 
		advance(cntxt,1);
@-
We have so far the LHS part of an assignment. The remainder is
either a simple term expression, a multi assignent, or the start 
of a function call.
@c
	{@:term(goto part2)@}
    l=operatorLength(cntxt);
    if (l==0 && idLength(cntxt)==0 ) {
        if (currChar(cntxt) == '('){
            /* parse multi assignment */
            nextChar(cntxt); /* skip '(' */
            skipSpace(cntxt);
            @:parseArguments()@ /* parseAssign() -> void */
        } else {
        	parseError(cntxt,"<identifier> or <unary operator> expected\n");
		}
        skipToEnd(cntxt);
        pushInstruction(curBlk,curInstr);
        return;
    }
    if( l || (l=idLength(cntxt))) {
startFCNcall:
        {
        int yycur = cntxt->yycur; 
		advance(cntxt,l);
        if( currChar(cntxt) != '.' &&
            currChar(cntxt) != '(' &&
            (idCharacter[(int)cntxt->fdin->buf[cntxt->fdin->pos + yycur]]) ){
			cntxt->yycur = yycur;
            @:GETvariable@
            curInstr= pushArgument(curBlk,curInstr,varid);
            goto part2;
        }
        cntxt->yycur = yycur;
        }

        /* continue with parseing a function/operator call */
        if( CURRENT(cntxt)[l] == '.'){
			char *n= CURRENT(cntxt);
			arg= putName(n,l);
			advance(cntxt,l+1); /* skip '.' */
			setModuleId(curInstr,arg);
            i = idLength(cntxt);
            if( i==0) i= operatorLength(cntxt);
            if( i ) {
                setFunctionId(curInstr, putName(((char*)CURRENT(cntxt)),i));
				advance(cntxt,i);
            } else {
                parseError(cntxt,"<functionname> expected\n");
                pushInstruction(curBlk,curInstr);
                return;
            }
			if (currChar(cntxt) != '(') {
				skipSpace(cntxt);
				if (currChar(cntxt) != '(') 
				{   parseError(cntxt,"'(' expected\n");
					pushInstruction(curBlk,curInstr);
					return;
				}
			}
			nextChar(cntxt); /* skip '(' */
        } else {
            /* we expect a module if( CURRENT(cntxt)[l] != '(')*/
            {
                parseError(cntxt,"module name expected\n");
                pushInstruction(curBlk,curInstr);
                return;
            } 
        }
/*getarguments:*//* not used */
        skipSpace(cntxt);
        @:parseArguments()@ /* parseAssign() -> void */
        if( currChar(cntxt)!=';'){
			skipSpace(cntxt);
			if( currChar(cntxt)!=';')
				parseError(cntxt,"';' expected\n");
		}
        goto part3;
    }
    
part2:  /* consume <operator><term> part of expression */
    if( (i= operatorLength(cntxt)) ){
        /* simple arithmetic operator expression */
        setFunctionId(curInstr, putName(((char*)CURRENT(cntxt)),i));
		advance(cntxt,i);
		curInstr->modname= putName("calc",4);
        if( (l = idLength(cntxt))) {
            @:GETvariable@
            curInstr= pushArgument(curBlk,curInstr,varid); 
            goto part3;
        } 
        {@:term(goto part3)@}
        parseError(cntxt,"<term> expected\n");
        pushInstruction(curBlk,curInstr);
        return;
    } else  {
        skipSpace(cntxt);
        if( currChar(cntxt) != ';' && currChar(cntxt) != '#')
            parseError(cntxt,"operator expected\n");
    }
part3:
    skipToEnd(cntxt);
    pushInstruction(curBlk,curInstr);
}
#define BRKONERR if( curPrg->def->errors>=MAXERRORS) return curPrg->def->errors;
int parseMAL(Client cntxt, Symbol curPrg){
    int cntrl=0;
    /*Symbol curPrg= cntxt->curprg;*/
    char c;

    echoInput(cntxt);
    /* here the work takes place */
    while( (c=currChar(cntxt)) ){
        switch( c){
        case '\n': case '\r': case '\f': 
            nextChar(cntxt);
            echoInput(cntxt);
            continue;
        case ';': case '\t': case ' ': 
            nextChar(cntxt);
			continue;
        case '#': skipComment(cntxt);
              continue;
        case 'A': case 'a':
              if( keyword(cntxt,"atom",4) &&
                  parseAtom(cntxt)!=0) break;
              goto allLeft;
        case 'b': case 'B':
              if( keyword(cntxt,"barrier",7)) {
                cntxt->blkmode++;
                cntrl = BARRIERsymbol; 
              }
              goto allLeft;
        case 'C': case 'c': 
              if( keyword(cntxt,"command",7) ) {
                parseCommandPattern(cntxt, COMMANDsymbol);
                continue;
              }
              if( keyword(cntxt,"catch",5)){
                cntrl= CATCHsymbol;
                goto allLeft;
              }
              goto allLeft;
        case 'E': case 'e': 
              if( keyword(cntxt,"exit",4)){
                if(cntxt->blkmode>0) cntxt->blkmode--;
                cntrl= EXITsymbol;
              } else if( parseEnd(cntxt)) {
					break;
			  }
              goto allLeft;
        case 'F': case 'f': 
              if( keyword(cntxt,"function",8) ){
                cntxt->blkmode++;
                if( parseFunction(cntxt, FUNCTIONsymbol)) 
					break;
              } else if( keyword(cntxt,"factory",7) ){
                cntxt->blkmode++;
                parseFunction(cntxt, FACTORYsymbol);
                break;
              }
              goto allLeft;
        case 'H': case 'h':
              if( keyword(cntxt,"handler",5)) { 
				skipToEnd(cntxt); 
                cntxt->blkmode++;
                break; 
			  }
        case 'i': if( parseInclude(cntxt)) continue;
            goto allLeft;
        case 'L': case 'l': 
              if( keyword(cntxt,"leave",5))
                cntrl= LEAVEsymbol;
              goto allLeft;
        case 'M': case 'm': 
              if( keyword(cntxt,"map",3)) {
                cntrl = MAPsymbol; 
              } else
              if( keyword(cntxt,"module",6) &&
                parseModule(cntxt)!= 0) break;
              goto allLeft;
        case 'P': case 'p': 
              if( keyword(cntxt,"pattern",7) ) {
                parseCommandPattern(cntxt, PATTERNsymbol);
                continue;
              }
              goto allLeft;
        case 'R': case 'r': 
              if( keyword(cntxt,"redo",4)){
                cntrl= REDOsymbol;
                goto allLeft;
              }
              if( keyword(cntxt,"raise",5)){
                cntrl= RAISEsymbol;
                goto allLeft;
              }
              if( keyword(cntxt,"return",6)){
                cntrl= RETURNsymbol;
              }
              goto allLeft;
        case 'T': case 't':
              if( keyword(cntxt,"thread",6)){
                cntrl= THREADsymbol;
              }
              goto allLeft;
        case 'Y': case 'y':
            if( keyword(cntxt,"yield",5)){
                cntrl= YIELDsymbol;
                goto allLeft;
            }
        default: allLeft:
            parseAssign(cntxt,cntrl);
            cntrl =0;
            BRKONERR;
        }
    }
    return curPrg->def->errors;
}
@- Error display
Display the error information for the current client.
An arrow and state number is printed at the "appropriate" place. 
If no lookahead character is a used and the next character is a newline,
we should also copy the input.
@c
str parseError(Client cntxt, str msg)
{   
	Symbol curPrg;
    MalBlkPtr curBlk;
    char buf[10*1024];
    char *s=buf, *t, *l = lastline(cntxt);
    long i;

    curPrg = cntxt->curprg;
    curBlk = curPrg->def;
    if(curBlk) 
		curBlk->errors++;

    /* accidental %s directives in the lastline can
       crash the vfsprintf later => escape them */
    for(t=l; *t && *t!='\n'; t++) {
		if (*t == '%') 
			*s++ = '%'; 
		*s++ = *t;
    }
    *s++ = '\n';
    *s++ = '!';
    /* produce the position marker*/
    i = position(cntxt) + strlen(GDKERROR)-1;
    for(; i > 0; i--) {
       *s++ = ((l && *(l+1) && *l++ != '\t'))?' ':'\t';
    }
    *s++ = '^'; 
    *s = 0;

	if (msg == 0)
        msg = "can't help you here, sorry.\n";
    if( strlen(msg)+strlen(buf) < 1020)
        snprintf(s,1020,"%s", msg);
    skipToEnd(cntxt);
    GDKerror(buf);
    return 0;
}
@}
