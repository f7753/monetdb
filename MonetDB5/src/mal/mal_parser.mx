@a M. L. Kersten
@v 1.1

@* Monet Assembler Language
As of Version 5.0 the primary interface for interaction with the Monet kernel
is based on a simple, assembler-like language called MAL. 

The language reflects the virtual machine architecture around the
gdk library and has been designed for speed of interpretation,
ease of analysis, and ease of compilation by applications.

This module contains a small footprint MAL parser for Monet Version 5.
The parser (and its target language) are designed for speed of analysis.
For, parsing is a dominant cost-factor in applications interfering with
Monet. For the language design it means that look-ahead and ambiguity
should be avoided where possible. At the same time the language should
remain 'readable' to enable ease of debugging.

This parser assumes availability of a complete MAL block upfront
as a string to be parsed and executed on behalf of a client. 
Unike Monet V4, no module management operations are allowed within the
context of a procedure. They are considered global commands.

The syntax layout of a MAL program consists of a module name,
a list of import commands, a list of function/pattern/command/stream
definitions and concludes with the statements to be executed as
the main body of the program.  All components are optional.
A commentary may appear anywhere a statement is expected.

The parser produced is intended to be thread safe.

The stand-alone version of this parser (Mal) can be used 
to check any MAL procedure for syntactic errors in a front-end.

@+ The lexical analyzer
The implementation of the lexical analyzer is straightforward:
the input is taken from a client input buffer. It is assumed that
this buffer contains the complete MIL structure to be parsed.

@h
/*
 * The contents of this file are subject to the Monet Public
 * License Version 1.1 (the "License"); you may not use this file
 * except in compliance with the License. You may obtain a copy of
 * the License at http://www.monetsolutions.com/Download/Licensing/MonetPL-1.1.
html
 * 
 * Software distributed under the License is distributed on an "AS
 * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
 * implied. See the License for the specific language governing
 * rights and limitations under the License.
 * 
 * The Original Code is the Monet Database System.
 * 
 * The Initial Developer of the Original Code is CWI.
 * Portions created by CWI are Copyright (C) 1997-2002 CWI.  
 * All Rights Reserved.
 * 
 * Contributor(s): Martin Kersten <Martin.Kersten@cwi.nl>
 */
#ifndef _MAL_PARSER_H
#define _MAL_PARSER_H

#include "mal_import.h"

mal_export int parseMAL(Client cntxt, Symbol curPrg);
mal_export void debugParser(int i);

#endif /* _MAL_PARSER_H */

@- lexical utilities
Before a line is parsed we check for a request to echo it.
This command should be executed at the beginning of a parse
request and each time we encounter EOL.
@c
#include "mal_parser.h"
#include "mal_resolve.h"
#include "mal_linker.h"

#define MAXERRORS 100
#define FATALINPUT MAXERRORS+1
#define NL(X) ((X)=='\n' || (X)=='\r')

int echoInput(Client cntxt){
	if (cntxt->listing & LIST_INPUT) { 
		char *c= cntxt->nxt;
		stream_printf(cntxt->fdout,"#");
		while(*c && !NL(*c)){
			stream_printf(cntxt->fdout,"%c",*c++);
		}
		stream_printf(cntxt->fdout,"\n");
		cntxt->fdout->flush(cntxt->fdout);
	}
}
#define nextChar(X)  (*(X)->nxt?*(X)->nxt++:0)
#define currChar(X)	*(X)->nxt

INLINE
void skipComment(Client cntxt) { 
	char c; 
	cntxt->nxt++;
	while (c = currChar(cntxt)) {
		if(c== '\n') return;
		if(c== '\r') return;
		cntxt->nxt++;
	}
}
INLINE
void skipSpace(Client cntxt){
	for(;;){
		switch(*cntxt->nxt){
		case ' ': case '\t': case '\n': case '\r':
			cntxt->nxt++;
			break;
		default: return;
		}
	}
}
INLINE
void advance(Client cntxt, int length){
	cntxt->nxt += length;
	skipSpace(cntxt);
}
@-
The most recurring situation is to recognize identifiers.
This process is split into a few steps to simplify subsequent
construction and comparison.
IdLength searches the end of an identifier without changing
the cursor into the input pool.
IdCopu subsequently prepares a GDK string for inclusion in the
instruction datastructures.

Note that keyword() favors lowercase keywords. This avoids
conversion cost and safes about 20% on lexical analysis.
@c
short opCharacter[256];
short idCharacter[256];
int initParser(){
	int i;
	for(i=0;i<256;i++) idCharacter[i]= isalpha(i);
	for(i=0;i<256;i++)
	switch(i){
	case '-': case '!': case '\\': case '$': case '%':
	case '^': case '*': case '~': case '+': case '&':
	case '|': case '<': case '>': case '=': case '/':
	case ':': opCharacter[i]=1; 
	}
	idCharacter['_']=1;
	idCharacter[TMPMARKER]=1;
}
#undef isdigit
#define isdigit(X)  ((X)>='0' && (X)<='9')
int idLength(Client cntxt){
	int l;
	str s= cntxt->nxt;
	if( !idCharacter[*s] ) return 0;
	l=1; s++;
	while(idCharacter[*s] || isdigit(*s) ) { s++; l++; }
	return l;
}
str idCopy(Client cntxt, int length){
	str s= GDKmalloc(length+1);
	strncpy(s,cntxt->nxt,length);
	s[length]=0;
	advance(cntxt,length);
	return s;
}
int keyword(Client cntxt, str kw, int length){
	int i;
	if( currChar(cntxt) == *kw &&
		strncmp(cntxt->nxt,kw,length)==0 &&
		!idCharacter[cntxt->nxt[length]] ){
		advance(cntxt,length);
		return 1;
	}
	/* check for captialized versions */
	for(i=0;i<length;i++)
	if( tolower(cntxt->nxt[i]) != kw[i]) return 0;
	if( !idCharacter[cntxt->nxt[length]] ){
		advance(cntxt,length);
		return 1;
	}
	return 0;
}
@-
Keyphrase testing is limited to a few characters only
(check manually). To speed this up we use a pipelined and
inline macros.
@c
int keyphrase(Client cntxt, str kw, int length){
	if( strncmp(cntxt->nxt,kw,length)==0 ){
		advance(cntxt,length);
		return 1;
	}
	return 0;
}
INLINE
int keyphrase1(Client cntxt, str kw){
	if( *cntxt->nxt == *kw){
		advance(cntxt,1);
		return 1;
	}
	return 0;
}
INLINE
int keyphrase2(Client cntxt, str kw){
	if( cntxt->nxt[0] == kw[0] &&
	    cntxt->nxt[1] == kw[1]){
		advance(cntxt,2);
		return 1;
	}
	return 0;
}
@-
A similar approach is used for string literals.
Beware, string lengths returned include the
brackets. They are eaten away in strCopy.
@c
int stringLength(Client cntxt){
	int l=0;
	str s= cntxt->nxt;
	if( *s != '"') return 0;
	s++;
	while( *s ){
		if( *s == '"' && *(s-1) != '\\') break;
		l++;
		s++;
	}
	return l+2;
}
str strCopy(Client cntxt, int length){
	str s= GDKmalloc(length-1);
	if( s== 0) GDKfatal("FATAL:strCopy:");
	strncpy(s,cntxt->nxt+1,length-2);
	s[length-2] = 0;
	advance(cntxt,length);
	return s;
}
@-
And a similar approach is used for operator names.
A lookup table is considered, because it generally is
faster then a non-dense switch.
@c
int operatorLength(Client cntxt){
	int l=0;
	str s;
	for( s= cntxt->nxt ; *s; s++)
	if( opCharacter[*s] ) l++; else return l;
	return l;
}
str operatorCopy(Client cntxt, int length){
	return idCopy(cntxt,length);
}
@-
For error reporting we may have to find the start of the previous line,
which, ofcourse, is easy given the client buffer.
The remaining functions are self-explanatory.
@c
str lastline(Client cntxt){ 
	str s = cntxt->nxt;
	if( NL(*s)) s++;
	while(s && s > cntxt->input && !NL(*s)) s--;
	if( NL(*s)) s++;
	return s;
}
int position(Client cntxt)
{	str s = lastline(cntxt);
	return (int)(cntxt->nxt)- (int)s;
}
void resetInput(Client cntxt) {
        *cntxt->nxt = 0;
}
@-
Upon encountering an error we skip to the nearest semicolon,
or comment terminated by a new line
@c
INLINE
void skipToEnd(Client cntxt){
	char c;
	while ((c = *cntxt->nxt) && c != ';') nextChar(cntxt); 
	if( c== ';') cntxt->nxt++;
}
void parseEndStmt(Client cntxt){
	char c;
	skipSpace(cntxt);
	if( *cntxt->nxt != ';')
		parseError(cntxt,"';' expected\n");
	skipToEnd(cntxt);
}
@-
The lexical analyser for numeric constants is a little more complex.
Aside from getting its length, we need an indication of its type.
We could also rebuild the constant directly, but that is already
handled by newConstant. So be lazy for the time being.
@c
int cstLength(Client cntxt, int *type)
{	int i=0;
	str s= cntxt->nxt;

	*type = TYPE_int;
	if( *s == '-') { i++; s++;}
	if( ! isdigit(*s)) {
		if( *s!= '.') goto parseTFN;
	} 
	while( isdigit(*s)) { i++; s++;}
	if( *s == '.'){ i++; s++; 
		while( isdigit(*s)) { i++; s++;}
		*type= TYPE_flt;
	} 
	if( *s == 'e' || *s == 'E'){ i++; s++;
		if( *s== '-' || *s== '+') s++;
		*type = TYPE_dbl;
		while( isdigit(*s)) { i++; s++;}
	} 
	if( *s == '@'){ i++; s++;
		*type= TYPE_oid;
		while( isdigit(*s)) { i++; s++;}
	} 
	if( *s == 'L' ){
		if( *type== TYPE_int) {i++; *type = TYPE_lng;}
		if( *type== TYPE_flt) {i++; *type = TYPE_dbl;}
	}
	if( *s == 'L' ){
		if( *type== TYPE_int) {i++; *type = TYPE_lng;}
	}
	return i;
parseTFN:
	if( *s=='f' && strncmp(s,"false",5)==0 && !isalnum(*(s+5)) ){
		*type = TYPE_bit;
		return 5;
	}
	if( *s== 't' && strncmp(s,"true",4)==0 && !isalnum(*(s+4)) ){
		*type = TYPE_bit;
		return 4;
	}
	if( *s== 'n' && strncmp(s,"nil",3)==0 && !isalnum(*(s+3)) ){
		*type = TYPE_void;
		return 3;
	}
	return 0;
}
INLINE
str cstCopy(Client cntxt, int i){ return idCopy(cntxt,i);}

@-
Identifiers used as arguments or targets of assignments may be
qualified with a type and property list. The type should be known before-hand,
which essential requires the corresponding module to be loaded first.

The type qualifier can handle array definitions as well. Upon first
encounter they are added as a special type to the atomary type
table.
@c
int typeQualifier(Client cntxt)
{	
	str hd = 0, tl =0;
	int i= TYPE_any, ht,tt;

	if( *cntxt->nxt!=':') return -1;

	cntxt->nxt++;
	skipSpace(cntxt);
	switch(*cntxt->nxt){
	case 'b': if( keyphrase(cntxt,"bit",3) ) return TYPE_bit;
		if( strncmp(cntxt->nxt,"bat[",4)==0){
			/* parse bat[type,type] */

			advance(cntxt,4);
			if( (hd= idCopy(cntxt,idLength(cntxt))) &&
			    nextChar(cntxt)==',' &&
			    (tl= idCopy(cntxt,idLength(cntxt))) ){
				ht = getTypeIndex(hd);
				tt = getTypeIndex(tl);
				i= newBatType(ht,tt);
			}
			if( nextChar(cntxt) !=']')
				parseError(cntxt,"']' expected\n");
			if( hd ) GDKfree(hd);
			if( tl ) GDKfree(tl);
			skipSpace(cntxt);
			return i;
		} 
		break;
	case 'v':
		if(strncmp(cntxt->nxt,"vec[",4)==0){
			/* parse vec[type] */

			advance(cntxt,4);
			if( (hd= idCopy(cntxt,idLength(cntxt))) ){
				ht = getTypeIndex(hd);
				i= newVecType(ht);
			}
			if( nextChar(cntxt) !=']')
				parseError(cntxt,"']' expected\n");
			if( hd ) GDKfree(hd);
			skipSpace(cntxt);
			return i;
		}
	default:
		if( (hd=idCopy(cntxt,idLength(cntxt))) ){
			ht= getTypeIndex(hd);
			if( hd) GDKfree(hd);
			/* parse the array bound */
			if( currChar(cntxt)=='['){
				int cl,tpe,size;
				str v;
				advance(cntxt,1);
				cl= cstLength(cntxt,&tpe);
				if( cl==0 || tpe != TYPE_int)
				parseError("integer constant expected\n");
				v=cstCopy(cntxt,cl);
				size= (int) strtol(v,NULL,0);
				ht= malAtomArray(ht,size);
				if(currChar(cntxt)!=']')
					parseError(cntxt,"array ']' expected\n");
				nextChar(cntxt);
			}
			skipSpace(cntxt);
			return ht;
		} 
		parseError(cntxt,"<type identifier> expected\n");
	}
	return -1;
}
@-
Character constants may be escaped.
@c
str charCst(Client cntxt)
{	int i;
	str v;
	if( *cntxt->nxt!='\'') return 0;
	v= cntxt->nxt; v++;
	i= 1;
	if( *v == '\\') { v++; i++;
		if( isdigit(*v)) { i++; v++;}
		if( isdigit(*v)) { i++; v++;}
		if( isdigit(*v)) { i++; v++;}
	} else v++;
	if( *v != '\'') 
		return (str) parseError(cntxt,"'\'' expected\n");
	v= strCopy(cntxt,i+2);
	return v;
}
@+ The Parser
Unlike Monet V4.3 the client is responsible to collect the
input for parsing in a single string before calling the parser.
Once the input is available parsing runs in a critial section for
a single client thread.

The parser uses the rigid structure of the language to speedup
analysis. In particular, each input line is translated into
a MAL instruction record as quickly as possible. Its context is
manipulated during the parsing process, by keeping the  curPrg,
curBlk, and curInstr variables.

The language does not support '#include' style commands, which
means we do not need a stack to keep track of the parsing context.

The language statements of the parser are gradually introduced, with
the overall integration framework last.
The convention is to return a zero when an error has been
reported or when the structure can not be recognized.
Furthermore, we assume that blancs have been skipped before entering.
@- Module statement.
The module and import commands have immediate effect.
The module statement switches the location for symbol table update
to a specific named area. The effect is that all definitions may become
globally known (?) and symbol table should be temporarilly locked
for updates by concurrent users.
@T
moduleStmt : [ATOM] MODULE modname [':' type]| [ATOM] id [':' type]\\
modname    : identifier | string \\
@-
An atom statement does not introduce a new module.
@= parsePath
	if( x = idLength(cntxt)) modname= idCopy(cntxt,x); else
	if( y = stringLength(cntxt)) modname= strCopy(cntxt,y);
	if( modname==0)
		return parseError(cntxt,"<module path> expected\n");
@c
int parseModule(Client cntxt, int atomary)
{	str modname=0;
	int l,x,y,tpe;

	if( ! keyword(cntxt,"module",6) ){
		if(atomary &&  idLength(cntxt) >0){
			/* parse: ATOM id:type */
			modname= idCopy(cntxt,idLength(cntxt));
			if( currChar(cntxt)==':') {
				tpe= typeQualifier(cntxt);
			} else tpe= TYPE_int;
			malAtomDefinition(modname,tpe);
			GDKfree(modname);
			@:helpInfo(cntxt->nspace->help)@
			return 1;
		} else 	
		if(atomary) return parseError(cntxt,"'module' expected\n");
		return 0;
	}
	@:parsePath@
@-
Atom storage may be defined in terms of an existing type.
@c
	if( atomary ) { 
		if( strrchr(modname,'/') ){
			GDKfree(modname);
			return parseError(cntxt,"<atom name> expected\n");
		}
		if( currChar(cntxt)==':') {
			tpe= typeQualifier(cntxt);
		} else tpe= TYPE_int;
		/* test for arrays TODO */
		malAtomDefinition(modname,tpe);
	}
	if( findScope(cntxt->nspace,modname) != NULL)
		cntxt->curprg->def->errors  = FATALINPUT;
	else	cntxt->nspace = fixateScope(cntxt->nspace, modname);
	if( atomary) cntxt->nspace->isAtomModule = TRUE;
	GDKfree(modname);
	@:typeInfo@
	@:helpInfo(cntxt->nspace->help)@
	return 1;
}
@- Import statement
An import statement is immediately taken into effect. This
calls for temporary switching the input for a particular client.
The administration for this is handled by malImport.
@T
importStmt : USE identifier \\
	   : USE string\\
@c
int parseImport(Client cntxt)
{	MalBlkPtr curBlk = 0;
	Symbol curPrg = 0;
	InstrPtr curInstr=0;
	str modname=0;
	int x,y;

	if( ! keyword(cntxt,"use",3)) return 0;

	@:parsePath@

	malImport(cntxt,modname,modname, cntxt->listing);
	GDKfree(modname);
	skipToEnd(cntxt);
	return 1;
}
@- Definition
The definition statements share a lot in common, which calls for factoring
out the code in a few text macros. Upon encountering a definition, we
initialize a MAL instruction container. We should also check for
non-terminated definitions.
@T
defineStmt : {FUNCTION COMMAND PATTERN STREAM} functionHdr [COMMENT string] ';'

Beware, a function signature f(a1..an):(b1..bn) is parsed in such a way that
the symbol table and stackframe contains the sequence
f,a1..an,b1..bn. This slightly complicates the implementation
of the return statement.

Note, the function name could be mod.fcn, which calls for storing
the function definition in a particular module instead of the current one.
@= closingBracket
	if( nextChar(cntxt) != ')') {
		freeInstruction(curInstr);
		return (MalBlkPtr) parseError(cntxt,"')' expected\n");
	}
@= fcnHeader
	l = operatorLength(cntxt);
	if( l == 0) l = idLength(cntxt);
	if( l == 0) return (MalBlkPtr) parseError(cntxt,
				"<identifier> |<operator> expected\n");

	fnme = idCopy(cntxt,l);

	if( currChar(cntxt) == '.'){
		nextChar(cntxt);
		modnme= fnme;
		l= operatorLength(cntxt);
		if( l == 0) l = idLength(cntxt);
		if( l == 0) return (MalBlkPtr) parseError(cntxt,
					"<identifier> |<operator> expected\n");
		fnme = idCopy(cntxt,l);
		/*parseError(cntxt,"module redirection nyi\n");*/
	}
	if( nextChar(cntxt) != '(') {
		GDKfree(fnme);
		return (MalBlkPtr)parseError(cntxt,
			"function header '(' expected\n");
	}
	skipSpace(cntxt);

	/* temporary suspend capturing statements in main block */
	if( cntxt->backup && curBlk && curBlk->errors==0) 
		GDKfatal("mal_parser: unexpected recursion\n");
	cntxt->backup = cntxt->curprg;
	cntxt->curprg = newFunction(fnme,kind);

	curPrg = cntxt->curprg;
	curBlk = curPrg->def;
	curInstr = getInstrPtr(curBlk,0);
	if( moduleId(curInstr)) freeModuleName(curInstr);
	setModuleId(curInstr, modnme== 0? GDKstrdup(cntxt->nspace->name):modnme);

	/* get calling parameters */
	ch= currChar(cntxt);
	while( ch !=')' && ch && !NL(ch)){
		str arg;
		int varid;
		@:binding@
		/* the last argument may be variable length */
		if( keyphrase(cntxt,"...",3) ){
			curInstr->varargs++;
			break;
		}
		skipSpace(cntxt);
		if( (ch=currChar(cntxt)) != ',') {
			if( ch==')') break;
			return (MalBlkPtr) parseError(cntxt,"',' expected\n");
		} else nextChar(cntxt); 
		skipSpace(cntxt);
		ch = currChar(cntxt);
	}
	@:closingBracket@
/*
The return type is either a single type or multiple return type structure.
We simply keep track of the number of arguments added and
during the final phase reshuffle the return values to the beginning (?)
*/
	skipSpace(cntxt);
	if( currChar(cntxt) != ':') {
		/* default */
		setVarType(curBlk,0,TYPE_any);
	} else { nextChar(cntxt); skipSpace(cntxt);
		if( *(cntxt->nxt) =='('){
			int retc= curInstr->argc, i1,i2=0;
			/* parse multi-target result */
			nextChar(cntxt);skipSpace(cntxt);
			ch= currChar(cntxt);
			while( ch !=')' && ch && !NL(ch)){
				str arg;
				int varid;
				@:binding@
				if( (ch=currChar(cntxt)) != ',') {
					if( ch==')') break;
					return (MalBlkPtr) parseError(cntxt,
							"',' expected\n");
				} else nextChar(cntxt); 
				skipSpace(cntxt);
				ch = currChar(cntxt);
			}
			/* re-arrange the parameters, results first*/
			int maxarg= curInstr->maxarg;
			int *newarg= (int*)GDKmalloc(maxarg*sizeof(int));
			for(i1= retc; i1<curInstr->argc; i1++)
				newarg[i2++]= curInstr->argv[i1];
			curInstr->retc= curInstr->argc-retc;
			for(i1= 1; i1<retc; i1++)
				newarg[i2++]= curInstr->argv[i1];
			curInstr->argc= i2;
			for(; i2<maxarg; i2++) newarg[i2]= 0;
			for(i1=0; i1<maxarg; i1++) 
				curInstr->argv[i1] = newarg[i1];
			GDKfree(newarg);
			@:closingBracket@
		} else {
			type= melType(cntxt,curBlk,curInstr,curInstr->argv[0]);
			/* setVarType(curBlk,0,type);*/
			@:propList(curInstr->argv[0])@
		}
	}
	
@-
The common theme in definitions is to parse the argument list.
@T
functionHdr: fcnName '(' [ binding \{',' binding\}] ')' ':' type\\
@
@= binding
	l = idLength(cntxt);
	arg = idCopy(cntxt,l);
	if( nextChar(cntxt) != ':')
		return (MalBlkPtr) parseError(cntxt,"':' expected\n");
	skipSpace(cntxt);
	varid= newVariable(curBlk,arg,TYPE_any);
	curInstr= pushArgument(curBlk,curInstr, varid);
	type= melType(cntxt,curBlk,curInstr,varid);
	skipSpace(cntxt);
@-
MAL variables are statically/dynamically typed.
Function and procedure arguments should always be typed.
We do not permit polymorphism at this interpretation level.

The type information maintained simplifies analysis of 
BAT results. If the underlying type is not known, then it
may be replaced once during execution of a MAL instruction
typically as a side-effect of calling a bat-returning function.

We should also allow for variable argument lists. However, they
may only appear in rules, because the calling context is necessary
to resolve the actual argument list. Furthermore, we can not 
assume much about the resulting type structure.
@T
melType	: melElm [propList] | bat '[' melElm [propList]',' melElm [propList]']'\\
melElm  : identifier | any ['::'digit]\\
propList : '\{' identifier [ ',' identifier] '\}'\\
@-
Variables will later be extended with a property list to enable
optimizers to make decisions. An example is :int{key, notnull} for
a column of a BAT. BATs are composed of two components, which leads
to three possible property list.
The argument to propList is the variable that owns the properties.

@= propList
	if( keyphrase1(cntxt,"{")) {
		char cmd;
		do{
			str pname, pvalue;
			int lt;
			cmd= currChar(cntxt);
			if( cmd == '+' || cmd == '-'){
				advance(cntxt,1);
			} else cmd='+';
			l = idLength(cntxt);
			if(l){
			pname= idCopy(cntxt,l);
			if( keyphrase1(cntxt,"=")){
				/* eat value away*/
				skipSpace(cntxt);
				l = stringLength(cntxt);
				pvalue= strCopy(cntxt,l);
			} else pvalue= GDKstrdup("");
			if( curBlk->var[@1]->props== NULL)
				curBlk->var[@1]->props= newPropertySet();
			setProperty(curBlk->var[@1]->props,0,pname,
					TYPE_str,pvalue);
			GDKfree(pname); 
			}
		} while( keyphrase1(cntxt,","));
		if( !keyphrase1(cntxt,"}") )
			/* return (MalBlkPtr) */
			parseError(cntxt,"'}' expected\n");
		skipSpace(cntxt);
	}
@= melElement
	if( keyword(cntxt,"any",3)){
		type = TYPE_any;
		if( keyphrase2(cntxt,"::")){
			if( !isdigit(currChar(cntxt)) ){
				parseError(cntxt,"[1-9] expected\n");
			} else {
				int k= nextChar(cntxt) - '0';
				setAnyTailIndex(type,k);
			}
		}
		curInstr->polymorphic = TRUE;
	} else {
		char x;
		l = idLength(cntxt);
		x = cntxt->nxt[l];
		cntxt->nxt[l]= 0;
		type= getTypeIndex(cntxt->nxt);
		if( type == TYPE_any){
			parseError(cntxt,"Type identifier expected\n");
			printf("l=%d, tpe= %s\n",l,cntxt->nxt);
		}
		cntxt->nxt[l]= x;
		cntxt->nxt += l;
	}
	skipSpace(cntxt);
	@:propList(varid)@
@-
@c
int melType(Client cntxt,MalBlkPtr curBlk, InstrPtr curInstr, int varid){
	int type= TYPE_any;
	int l;

	if( keyword(cntxt,"bat",3)){
		if( keyphrase1(cntxt,"[")){
			int ht,tt;
			@:melElement@ ht = type;
			if( nextChar(cntxt) !=','){
				parseError(cntxt,"',' expected\n");
				return TYPE_any;
			}
			skipSpace(cntxt);
			@:melElement@ tt = type;
			type = malAnyBatType(ht,tt);
			if( !keyphrase1(cntxt,"]")){
				parseError(cntxt,"']' expected\n");
			}
		} else {
			type = malAnyBatType(TYPE_any,TYPE_any);
			curInstr->polymorphic = TRUE;
			@:propList(varid)@
		}
	} else
	if( keyword(cntxt,"vec",3)){
		/* patch to simulate vectors collections */
		if( keyphrase1(cntxt,"[")){
			@:melElement@ 
			type = newVecType(type);
			if( !keyphrase1(cntxt,"]")){
				parseError(cntxt,"']' expected\n");
			}
		} else {
			type = newVecType(TYPE_any);
			curInstr->polymorphic = TRUE;
			@:propList(varid)@
		}
		skipSpace(cntxt);
	} else{
		@:melElement@
	}
	skipSpace(cntxt);
	setVarType(curBlk,varid,type);
	return type;
}
@-
Most functions are (dynamically) linked with the kernel.
Once we encounter an external function, the block mode
for reading unfinished definitions is also terminated.
@= externalFcn
	if( keyphrase1(cntxt,"=")){
		str nme;
		int i;
		skipSpace(cntxt);
		i = idLength(cntxt);
		if( i==0){
			parseError(cntxt,"<identifier> expected\n");
			return 0;
		}
		cntxt->blkmode=0;
		nme = idCopy(cntxt,i);
		if( moduleId(curInstr)) GDKfree(curInstr->modname);
		setModuleId(curInstr, GDKstrdup(cntxt->nspace->name));
		curInstr->fcn = getAddress(nme);
		curBlk->binding = nme;
		if( cntxt->nspace->isAtomModule) 
			malAtomProperty(curBlk,curInstr);
	} else return (MalBlkPtr) parseError(cntxt,"'=' expected\n");
@-
Each procedure definition opens a structure in which the
information is gathered. The enclosing module is statically
determined.

A proc-header translates into a single MAL instruction.
Since no recursive rules are included, we can stick to
using a single global variable to accummulate the
properties.

The external commands and rules come with a short
help information.

@= helpInfo
	skipSpace(cntxt);
	if( keyphrase(cntxt,"comment",7)){
		skipSpace(cntxt);
		if( l= stringLength(cntxt)){
			@1 = strCopy(cntxt,l);
		} else parseError(cntxt,"<string> expected\n");
	} 
	skipToEnd(cntxt);
@-
Module components may include a function reference overruling
the built-in type resolver. The user-defined type resolver is called
instead.
@= typeInfo
	skipSpace(cntxt);
	if( keyphrase(cntxt,"check",5)){
		int l;
		skipSpace(cntxt);
		if( keyphrase(cntxt,"=",1)==0){
			parseError(cntxt,"'=' expected\n");
		} else{
			skipSpace(cntxt);
			if( l= idLength(cntxt)){
				str nme = idCopy(cntxt,l);
				cntxt->nspace->typeChecker = getAddress(nme);
				GDKfree(nme);
			} else parseError(cntxt,"<identifier> expected\n");
		}
	} 
@c
MalBlkPtr parseCommandPattern(Client cntxt, int kind){
	MalBlkPtr curBlk = 0;
	Symbol curPrg = 0;
	InstrPtr curInstr=0;
	int l;
	str fnme=0, modnme=0, arg=0;
	char ch;
	int type;

	@:fcnHeader@
	getInstrPtr(curBlk,0)->token= kind;
	curPrg->kind = kind;
	insertSymbol(cntxt->nspace,curPrg);
	trimMalBlk(curBlk);
	chkProgram(cntxt->nspace,curBlk);
	if( cntxt->backup){
		cntxt->curprg = cntxt->backup;
		cntxt->backup = 0;
	}
	skipSpace(cntxt);
	@:externalFcn@
	@:helpInfo(curBlk->help)@
	showErrors(cntxt);
	if(curBlk && cntxt->listing) 
		printFunction(GDKout, curBlk, cntxt->listing);
	return curBlk;
}

MalBlkPtr parseFunction(Client cntxt, int kind){
	MalBlkPtr curBlk = 0;
	Symbol curPrg = 0;
	InstrPtr curInstr=0;
	int l;
	str fnme=0, modnme=0;
	char ch;
	int type;

	@:fcnHeader@
	/* block is terminated at the END statement */
	@:helpInfo(curBlk->help)@
	return curBlk;
}

@-
Commands, functions, rulers, barriers and catch blocks all end
with a labeled end-statement. The routine below checks for
misalignment of the closing statements.
Any instruction parsed after the function block is considered an
error.
@c
int parseEnd(Client cntxt)
{	MalBlkPtr curBlk = 0;
	Symbol curPrg = 0;
	InstrPtr curInstr=0;
	int i,l,showit=0;
	str v;

	if( keyword(cntxt,"end",3)){
		curPrg = cntxt->curprg;
		curBlk = curPrg->def;	
		l = idLength(cntxt);
		if(l==0) l= operatorLength(cntxt);
		if( (l== strlen(curPrg->name) &&
		     strncmp(cntxt->nxt, curPrg->name,l)==0) ||
		     l==0){
			/* its ok */
		} else 
		parseError(cntxt,"non matching end label, overruled\n");
		
		advance(cntxt,l);
		pushEndInstruction(curBlk);
		insertSymbol(cntxt->nspace, cntxt->curprg);
		trimMalBlk(cntxt->curprg->def);
		cntxt->blkmode =0;
		chkProgram(cntxt->nspace, cntxt->curprg->def);
		if( cntxt->backup){
			cntxt->curprg = cntxt->backup;
			cntxt->backup = 0;
		}
		showit= TRUE;
		skipToEnd(cntxt);
		if(showit && cntxt->listing) 
			printFunction(GDKout, curBlk, cntxt->listing);
		showErrors(cntxt);
		return 1;
	}
	return 0;
}
@-
The non-assignment control statements are :
@T
cntrl	: (CATCH | RAISE | RETURN) identifier\\
@= endparseCntrl
	pushInstruction(curBlk, curInstr);
	if( *cntxt->nxt != ';')
		parseError(cntxt,"';' expected\n");
	skipToEnd(cntxt);
	return 1;
@= parseCntrl
int parse@3(Client cntxt)
{	InstrPtr curInstr;
	MalBlkPtr curBlk;
	Symbol curPrg;
	str arg,v;
	int lt,i,l,z=0;

	if( ! keyword(cntxt,@1,@2)) return 0;
	curPrg = cntxt->curprg;
	curBlk = curPrg->def;	
	curInstr= newInstruction(@3symbol);
	l= cstLength(cntxt,&lt);
	if( l>0){
		str v= cstCopy(cntxt,l);
		i= typeQualifier(cntxt);
		if(i>=0) lt = i;
		i= newConstant(curBlk,lt,v,TRUE);
	} else {
		l = idLength(cntxt);
		if( l == 0){
			if( @3symbol != RETURNsymbol ){
				parseError(cntxt,"'return' expected\n");
				@:endparseCntrl@
			}
			if( currChar(cntxt) != '('){
				parseError(cntxt,"'(' or 'identifier' expected\n");
				@:endparseCntrl@
			}
			nextChar(cntxt); skipSpace(cntxt);
			z++; /* parse multiple return arguments */
			@:parseArguments@
			curInstr->retc= curInstr->argc;
			@:endparseCntrl@
		} 
		i = findVariableLength(curBlk,cntxt->nxt,l);
		if( i<0){
			arg= idCopy(cntxt,l);
			i= newVariable(curBlk, arg, @4);
		} else advance(cntxt,l); 
	}
	getDestVar(curInstr) = i;
	if(@3symbol== CATCHsymbol) curInstr->barrier= CATCHsymbol;
	if(@3symbol== THREADsymbol) {
		curInstr->barrier= THREADsymbol;
		setVarType(curBlk, getDestVar(curInstr),TYPE_int);
	}
	skipSpace(cntxt);
	@:propList(i)@
	@:endparseCntrl@
}
@c
@:parseCntrl("catch", 5,CATCH, TYPE_str)@
@:parseCntrl("raise", 5,RAISE, TYPE_any)@
@:parseCntrl("thread", 6,THREAD, TYPE_any)@
@-
parseCntrl("return", 6,RETURN, TYPE_any)
The return statements is a special kind of assignment in the sense
that the target variables are the function return variables.
By copying those into the assignment structure we ensure that
a proper type analysis takes place later on.
@c

int parseRETURN(Client cntxt)
{	InstrPtr curInstr, sig;
	MalBlkPtr curBlk;
	Symbol curPrg;
	str arg,v;
	int lt,i,l,z=0;

	curPrg = cntxt->curprg;
	curBlk = curPrg->def;	
	curInstr= newInstruction(RETURNsymbol);
	sig= getInstrPtr(curBlk,0);
	for(l=0;l<sig->retc;l++)
		curInstr->argv[l]= sig->argv[l];
	curInstr->retc= curInstr->argc= l;

	l= cstLength(cntxt,&lt);
	if( l>0){
		str v= cstCopy(cntxt,l);
		i= typeQualifier(cntxt);
		if(i>=0) lt = i;
		i= newConstant(curBlk,lt,v,TRUE);
		curInstr= pushArgument(curBlk,curInstr, i);
	} else {
		l = idLength(cntxt);
		if( l == 0){
			if( currChar(cntxt) != '('){
				parseError(cntxt,"'(' or 'identifier' expected\n");
				@:endparseCntrl@
			}
			nextChar(cntxt); skipSpace(cntxt);
			z= 1; /* funny control to parseArg */
			curInstr->argc++;
			@:parseArguments@
			@:endparseCntrl@
		} 
		i = findVariableLength(curBlk,cntxt->nxt,l);
		if( i<0){
			arg= idCopy(cntxt,l);
			i= newVariable(curBlk, arg, TYPE_any);
		} else advance(cntxt,l); 
		curInstr= pushArgument(curBlk,curInstr, i);
	}
	skipSpace(cntxt);
	@:propList(i)@
	@:endparseCntrl@
}
@-
Most instructions are simple assignments, possibly
modified with a barrier/catch tag.
@T
stmt	: tag identifier ':=' expr [':' typeQualifier]['{' proplist'}']\\
	| RETURN expr [':' typeQualifier]['{' proplist'}']
tag	: BARRIER | CATCH\\
expr	: fcncall | [factor  operator] factor \\
factor	: constant | var | type'('constant')'\\

The basic types are also predefined as a variable.
This makes it easier to communicate types to MAL patterns.
@-
The assignment expression is the most complex term recognized.
@T
assign	: [identifier ':='] expr\\
assign	: '(' identifier {',' identifier} ')' ':=' expr\\
expr	: factor \{ operator factor \}\\
factor	: fcn_call | variable | constant\\

@= GETvariable
if( (varid=findVariableLength(curBlk,cntxt->nxt,l)) == -1){
	arg= idCopy(cntxt,l); 
	varid= newVariable(curBlk,arg,TYPE_any);
} else {
	advance(cntxt,l); 
}
@-
Control flow statements may be abreviated
@= controlFlow
if( kind == LEAVEsymbol || kind == REDOsymbol || kind == EXITsymbol ){
	pushInstruction(curBlk,curInstr);
	if(@1) curInstr->argv[0]= getBarrierEnvelop(curBlk);
	skipToEnd(cntxt);
	return;
}
@c
debugParse(){}
void parseAssign(Client cntxt, int kind)
{	InstrPtr curInstr;
	MalBlkPtr curBlk;
	Symbol curPrg;
	int consumed =0,z=0, i=0, k=0, lt,rt,l,type=TYPE_any, varid;
	str v, op, arg=0, r;

	curPrg = cntxt->curprg;
	curBlk = curPrg->def;
	curInstr = newInstruction(ASSIGNsymbol);
	curInstr->barrier = kind;

	/* start the parsing by recognition of the lhs of an assignment */
	if( currChar(cntxt) == '('){
		/* parsing multi-assignment */
		nextChar(cntxt); skipSpace(cntxt);
		curInstr->argc=0; /*reset to handle pushArg correctly !! */
		curInstr->retc=0;
		while(*cntxt->nxt  != ')' && *cntxt->nxt){
			l= idLength(cntxt);
			if( l==0) {
				parseError(cntxt,"<identifier> expected\n"); 
				pushInstruction(curBlk,curInstr);
				return;
			}
			@:GETvariable@
			type= typeQualifier(cntxt);
			if( type>0) setVarType(curBlk,varid,type);
			curInstr= pushArgument(curBlk,curInstr, varid);
			z++;
			curInstr->retc++;
			if( *cntxt->nxt == ')') break;
			if( currChar(cntxt)==',') keyphrase1(cntxt,",");
			skipSpace(cntxt);
		}
		curInstr->argc++; /* advance to make pushArgument work */
		nextChar(cntxt); skipSpace(cntxt);

	}else{ 
		/* are we dealing with a simple assignment? */
		l= idLength(cntxt);
		if( l==0){
			l= operatorLength(cntxt);
			if(l) goto startFCNcall;
			/* we haven't seen an identifier nor an operator */
			/* control blocks may use implied name */
			@:controlFlow(1)@
			pushInstruction(curBlk,curInstr);
			parseError(cntxt,"<identifier> or <operator> expected\n"); 
			return;
		}
		/* Check if we are dealing with an assignment */
		{	v= cntxt->nxt;
			advance(cntxt,l);
			/* first check for type variable */
			if( *cntxt->nxt==':' && *(cntxt->nxt+1)!='='){
				cntxt->nxt=v;
				@:GETvariable@
				curInstr->argv[0]= varid;
				type= typeQualifier(cntxt);
				if( type>0) setVarType(curBlk,varid,type);
				consumed =1;
				v= cntxt->nxt;
			}
			/* look ahead for assignment operator */
			if( !keyphrase2(cntxt,":=") ){
				/* no assignment !! */
				if( curInstr->barrier){
					cntxt->nxt=v;
					if( consumed==0){
						@:GETvariable@
						curInstr->argv[0]= varid;
						curInstr->token= kind;
						consumed++;
						v= cntxt->nxt;
					}
					if( *cntxt->nxt!=';')
					parseError(cntxt,"';' expected\n");
					goto part3;
				}
				if( *cntxt->nxt!='(' &&
				    *cntxt->nxt!='.'){
					parseError(cntxt,"'.' or '(' expected\n");
					cntxt->nxt=v;
					goto part3;
				}
				if(consumed==0) cntxt->nxt=v;
				curInstr->argv[0]= newTmpVariable(curBlk,TYPE_any);
				goto startFCNcall;
			} else cntxt->nxt= v;
		}
		if( consumed ==0) {
			cntxt->nxt=v;
			@:GETvariable@ 
			curInstr->argv[0]= varid;
		}
	}

	/* test destination variable or function call */
	if( !keyphrase2(cntxt,":=") ){
		GDKerror("parseAssign:internal error\n");
		pushInstruction(curBlk,curInstr);
		return;
	}
@-
At this stage the LHS part has been parsed and the destination
variables have been set. Next step is to parse the expression,
which starts with an operand.
This code is used in both positions of the expression
@= term
	if( i= cstLength(cntxt,&lt)){
		v= cstCopy(cntxt,i);
		i= typeQualifier(cntxt);
		if(i>=0) lt = i;
		i= newConstant(curBlk,lt,v,TRUE);
		curInstr= pushArgument(curBlk,curInstr,i);
		@1;
	} else 
	if( (v= charCst(cntxt)) ){
		i= typeQualifier(cntxt);
		if(i>=0) lt = i; else lt= TYPE_chr;
		i= newConstant(curBlk,lt,v,TRUE);
		curInstr= pushArgument(curBlk,curInstr,i);
		@1;
	} else 
	if( i = stringLength(cntxt) ){
		v= strCopy(cntxt,i);
		lt= typeQualifier(cntxt);
		if(lt<0)lt= TYPE_str;
		i= newConstant(curBlk,lt,v,FALSE);
		curInstr= pushArgument(curBlk,curInstr,i);
		@1;
	}
@-
Get arguments for a call, assume a single result.
@= parseArguments
	if(z) curInstr->argc--; /* should be done differently */
	else curInstr->argc=1;
	while( currChar(cntxt)!= ')'){
		int idx;
		@:term()@ else
		if( i= idLength(cntxt)){
			if( (idx=findVariableLength(curBlk,cntxt->nxt,i)) == -1){
				v= idCopy(cntxt,i);
				i= typeQualifier(cntxt);
				i= i>=0?i: TYPE_any;
				idx = newVariable(curBlk, v, i);
			} else advance(cntxt,i);
			curInstr= pushArgument(curBlk,curInstr,idx);
		} else 
		if( *cntxt->nxt==':' ){
			i = typeQualifier(cntxt);
			i = i >=0? i :TYPE_any;
			idx= newTypeVariable(curBlk, i );
			curInstr= pushArgument(curBlk,curInstr,idx);
		} else { 
			idx= 0;
			parseError(cntxt,"<factor> expected\n");
			pushInstruction(curBlk,curInstr);
			return;
		}
		if( currChar(cntxt)==',') keyphrase1(cntxt,",");
		else 
		if( currChar(cntxt) != ')'){
			parseError(cntxt,"',' expected\n");
			cntxt->nxt--; /* keep it */
			break;
		}
	}
	if( currChar(cntxt) ==')') advance(cntxt,1);
@-
We have so far the LHS part of an assignment. The remainder is
either a simple term expression, a multi assignent, or the start 
of a function call.
@c
	@:term( goto part2)@
	l=operatorLength(cntxt);
	if(l==0 && idLength(cntxt)==0 ) {
		if( currChar(cntxt)== '('){
			/* parse multi assignment */
			nextChar(cntxt);
			skipSpace(cntxt);
			@:parseArguments@
		} else
		parseError(cntxt,"<identifier> or <unary operator> expected\n");
		skipToEnd(cntxt);
		pushInstruction(curBlk,curInstr);
		return;
	}
	if( l || (l=idLength(cntxt))) {
startFCNcall:
		{v= cntxt->nxt; advance(cntxt,l);
		if( currChar(cntxt) != '.' &&
		    currChar(cntxt) != '(' &&
		    (idCharacter[*v]) ){
			cntxt->nxt=v;
			@:GETvariable@
			curInstr= pushArgument(curBlk,curInstr,varid);
			goto part2;
		}
		cntxt->nxt=v;
		}

		arg= idCopy(cntxt,l);
		/* continue with parseing a function/operator call */
		if( currChar(cntxt) == '.'){
			nextChar(cntxt);
			skipSpace(cntxt);
			setModuleId(curInstr, arg);
			i = idLength(cntxt);
			if( i==0) i= operatorLength(cntxt);
			if( i )
				setFunctionId(curInstr, idCopy(cntxt,i));
			else {
				parseError(cntxt,"<functionname> expected\n");
				pushInstruction(curBlk,curInstr);
				return;
			}
			if(nextChar(cntxt) != '(')
			{ 	parseError(cntxt,"'(' expected\n");
				pushInstruction(curBlk,curInstr);
				return;
			}
			skipSpace(cntxt);
		} else if(currChar(cntxt) != '(')
		{
			parseError(cntxt,"'(' expected\n");
			pushInstruction(curBlk,curInstr);
			return;
		} else { 
			nextChar(cntxt); skipSpace(cntxt);
			setFunctionId(curInstr, arg);
		}
getarguments:

		@:parseArguments@
		skipSpace(cntxt);
		if( currChar(cntxt)!=';')
			parseError(cntxt,"';' expected\n");
		goto part3;
	}
	
part2:	/* consume <operator><term> part of expression */
	if( i= operatorLength(cntxt) ){
		/* operator expression */
		setFunctionId(curInstr, idCopy(cntxt,i));
		if( l = idLength(cntxt)) {
			@:GETvariable@
			curInstr= pushArgument(curBlk,curInstr,varid); 
			goto part3;
		} 
		@:term( goto part3)@
		parseError(cntxt,"<term> expected\n");
		pushInstruction(curBlk,curInstr);
		return;
	} else  {
		skipSpace(cntxt);
		if( *cntxt->nxt != ';' && *cntxt->nxt!= '#')
			parseError(cntxt,"operator expected\n");
	}
part3:
	skipToEnd(cntxt);
	pushInstruction(curBlk,curInstr);
}
#define BRKONERR if( curPrg->def->errors>=MAXERRORS) return curPrg->def->errors;
int parseMAL(Client cntxt, Symbol curPrg){
	int kind=0, i;
	/*Symbol curPrg= cntxt->curprg;*/
	InstrPtr curInstr;
	char c;

	echoInput(cntxt);
	/* here the work takes place */
	while( c=currChar(cntxt) ){
		switch( c){
		case ';': case '\n': case '\r': case '\f': 
			nextChar(cntxt);
			echoInput(cntxt);
			continue;
		case '\t': case ' ': 
			  nextChar(cntxt);
		case  0 : continue;
		case '#': skipComment(cntxt);
			  continue;
		case 'A': case 'a':
			  if( keyword(cntxt,"atom",4) &&
			      parseModule(cntxt,TRUE)) break;
			  goto allLeft;
		case 'b': case 'B':
			  if( keyword(cntxt,"barrier",7)) {
				cntxt->blkmode++;
				kind = BARRIERsymbol; 
			  }
			  goto allLeft;
		case 'C': case 'c': 
			  if( keyword(cntxt,"command",7) ) {
				parseCommandPattern(cntxt, COMMANDsymbol);
				continue;
			  }
			  if( parseCATCH(cntxt)) {
				 break;
			  }
			  goto allLeft;
		case 'E': case 'e': 
			  if( keyword(cntxt,"exit",4)){
				if(cntxt->blkmode>0) cntxt->blkmode--;
				kind= EXITsymbol;
			  } else
			  if( parseEnd(cntxt)) break;
			  goto allLeft;
		case 'F': case 'f': 
			  if( keyword(cntxt,"function",8) ){
				cntxt->blkmode++;
				if( parseFunction(cntxt, FUNCTIONsymbol)) break;
			  }
			  goto allLeft;
		case 'H': case 'h':
			  if( keyword(cntxt,"handler",5)) 
			  { skipToEnd(cntxt); 
			    cntxt->blkmode++;
			    break; }
		case 'L':
		case 'l': /* if( parseLEAVE(cntxt)) break;*/
			  if( keyword(cntxt,"leave",5))
				kind= LEAVEsymbol;
			  goto allLeft;
		case 'M': case 'm': 
			  if( parseModule(cntxt, FALSE)) break;
			  goto allLeft;
		case 'P': case 'p': 
			  if( keyword(cntxt,"pattern",7) ) {
				parseCommandPattern(cntxt, PATTERNsymbol);
				continue;
			  }
			  goto allLeft;
		case 'R': case 'r': 
			  if( keyword(cntxt,"redo",4)){
				kind= REDOsymbol;
				goto allLeft;
			  }
			  if( parseRAISE(cntxt)) break;
			  if( keyword(cntxt,"return",6)){
				  parseRETURN(cntxt);
				  break;
			  }
			  goto allLeft;
		case 'S': case 's': 
			  if( keyword(cntxt,"stream",6) ){
				cntxt->blkmode++;
				parseFunction(cntxt, STREAMsymbol);
				break;
			  }
			  goto allLeft;
		case 't':
			  if( parseTHREAD(cntxt)) break;
			  goto allLeft;
		case 'u': if( parseImport(cntxt)) continue;
		default: allLeft:
			parseAssign(cntxt,kind);
			kind =0;
			BRKONERR;
		}
	}
	return curPrg->def->errors;
}
@- Error display
Display the error information for the current client.
An arrow and state number is printed at the "appropriate" place. 
If no lookahead character is a used and the next character is a newline,
we should also copy the input.
@c
int parseError(Client cntxt, str msg)
{	Symbol curPrg;
	MalBlkPtr curBlk;
	char buf[10*1024];
	char *s=buf, *t, *l = lastline(cntxt);
	int i;

	curPrg = cntxt->curprg;
	curBlk = curPrg->def;
	if(curBlk) curBlk->errors++;

	/* accidental %s directives in the lastline can
	   crash the vfsprintf later => escape them */
        for(t=l; *t && *t!='\n'; t++) {
                if (*t == '%') *s++ = '%'; 
                *s++ = *t;
        }
        *s++ = '\n';
        *s++ = '!';
	/* produce the position marker*/
	i = position(cntxt) + strlen(GDKERROR)-1;
        for(; i > 0; i--) {
                *s++ = (*l++ != '\t')?' ':'\t';
        }
        *s++ = '^'; 
	*s = 0;

        if (msg == 0)
		msg = "can't help you here, sorry.\n";
	if( strlen(msg)+strlen(buf) < 1020)
		snprintf(s,1020,"%s", msg);
	skipToEnd(cntxt);
        GDKerror(buf);
	return 0;
}
