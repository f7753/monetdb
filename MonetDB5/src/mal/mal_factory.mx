@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2004 CWI.
@' All Rights Reserved.
@'
@' Contributor(s):
@'              Martin Kersten <Martin.Kersten@cwi.nl>
@'              Peter Boncz <Peter.Boncz@cwi.nl>
@'              Niels Nes <Niels.Nes@cwi.nl>
@'              Stefan Manegold  <Stefan.Manegold@cwi.nl>
@'              Sjoerd Mullender  <Sjoerd.Mullender@cwi.nl>

@a M. Kersten
@v 0.0
@* MAL factories 
A convenient programming construct is the co-routine, which
is specified as an ordinary function, but maintains its
own state between calls, and permits re-entry other than
by the first statement. 

For simple cases, e.g. implementation of a random function,
it suffices to ensure that the state is secured between calls.
But, in a database context there are multiple clients
active. This means we have to be more precise on the relationship
between a co-routine and the client for which it works.

The concept researched in Monet 5 is the notion of a 'factory'.
The random generator example is used to illustrate its definition and use.
{\footnotesize
\begin{variable}
FACTORY random(seed:int,limit:int):int;
	rnd:=seed;
	lim:= limit;
BARRIER lim;
	LEAVE lim:= lim-1;
	rnd:= rnd*125;
	YIELD rnd:= rnd * 32676;
	REDO lim;
EXIT lim;
END random;
\end{variable}
}
The first time this factory is called it initializes the
generator. The random number is generated and YIELDed as
a result of this call. The factory process is put to sleep.
The second call received by the factory wakes it up at the
point where it went to sleep. In this case it will
find a REDO statement and produces the next random number.
Note that also in this case a seed and limit value are
expected, but ignored in the body.
This factory can be called upon to generate at most 'limit'
random numbers using the 'seed' to initialize the generator.
Thereafter it is being removed, i.e. reset to the original state.

A cooperative group of factories can be readily constructed.
For example, assume we would like the
random factories to respond to both random(seed,limit) and
random(). This can be defined as follows:
{\footnotesize
\begin{variable}
	box.open(randomState);
	
FACTORY random(seed:int,limit:int):int;
	rnd:=seed;
	lim:= limit;
	box.deposit(rnd);
BARRIER lim;
	LEAVE lim:= lim-1;
	rnd:= rnd*125;
	YIELD rnd:= rnd * 32676;
	REDO lim;
EXIT lim;
END random;

FACTORY random():int;
barrier forever:=true;
	YIELD random(0,0);
	redo forever;
exit forever;
EXIT lim;
END random;
\end{variable}
}

Conceptually the factories are implemented as independent thread
of control.

@+ Factory clients
The factory can produce elements for multiple clients.
The default policy is to isolate all clients from one-another.
If needed, a shared box can be used to maintain state information
relevant for many clients.

@{
@h
#ifndef _MAL_FACTORY_H
#define _MAL_FACTORY_H

/* #define DEBUG_MAL_FACTORY */

#include "mal_function.h"
#include "mal_exception.h"


#endif /*  _MAL_FACTORY_H*/
@-
@c
#include "mal_factory.h"

Symbol newFactory(str nme,int kind){
	return s;
}
