@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2004 CWI.
@' All Rights Reserved.

@a M. Kersten
@v 0.0
@* Factories 
@T
A convenient programming construct is the co-routine, which
is specified as an ordinary function, but maintains its
own state between calls, and permits re-entry other than
by the first statement. 

For simple cases, e.g. implementation of a random function,
it suffices to ensure that the state is secured between calls.
But, in a database context there are multiple clients
active. This means we have to be more precise on the relationship
between a co-routine and the client for which it works.

The co-routine concept researched in Monet 5 is the notion of a 'factory'.
The random generator example is used to illustrate its definition and use.
{\footnotesize
\begin{verbatim}
FACTORY random(seed:int,limit:int):int;
	rnd:=seed;
	lim:= limit;
BARRIER lim;
	LEAVE lim:= lim-1;
	rnd:= rnd*125;
	YIELD rnd:= rnd % 32676;
	REDO lim;
EXIT lim;
END random;
\end{verbatim}
}
The first time this factory is called it initializes the
generator. The random number is generated and YIELDed as
a result of this call. The factory process is put to sleep.
The second call received by the factory wakes it up at the
point where it went to sleep. In this case it will
find a REDO statement and produces the next random number.
Note that also in this case a seed and limit value are
expected, but they are ignored in the body.
This factory can be called upon to generate at most 'limit'
random numbers using the 'seed' to initialize the generator.
Thereafter it is being removed, i.e. reset to the original state.

A cooperative group of factories can be readily constructed.
For example, assume we would like the
random factories to respond to both random(seed,limit) and
random(). This can be defined as follows:
{\footnotesize
\begin{verbatim}
	box.open(randomState);
	
FACTORY random(seed:int,limit:int):int;
	rnd:=seed;
	lim:= limit;
	box.deposit(rnd);
BARRIER lim;
	LEAVE lim:= lim-1;
	rnd:= rnd*125;
	YIELD rnd:= rnd % 32676;
	REDO lim;
EXIT lim;
END random;

FACTORY random():int;
BARRIER forever:=true;
	YIELD random(0,0);
	REDO forever;
EXIT forever;
END random;
\end{verbatim}
}

@+ Factory clients
@T
A factory can produce elements for multiple clients.
In most cases it is sufficient to use explicit parameters
to distinguish clients. 

A private random number generator calls for a factory
that can distinguish between clients. They should have a 
client list. A possible implementation would be:

{\footnotesize
\begin{verbatim}
FACTORY random(seed:int,clientid:int):int;
	clt:= new(:int,:int);
	insert(clt,clientid,seed);
BARRIER always:=true;
	rnd:= find(clt,clientid);
CATCH	rnd; #failed to find client
	insert(clt,clientid,seed);
	rnd:= find(clt,clientid);
EXIT	rnd;
	rnd:= rnd * 125;
	rnd:= rnd % 32676;
	replace(clt,clientid,rnd);
	yield rnd;
	REDO always;
EXIT always;
END random;

\end{verbatim}
}
Alternatively, the factory has access to a limited 
set of properties to determine the identity of the caller.
These can be used to silently administer the requests
on a per caller basis.

The operators to built client aware factories are,
factory.getCaller(), which returns a client index,
factory.getModule() and factory.getFunction(), 
which returns the identity of the enclosed scope.

To illustrate, the client specific random generator
can be shielded using the factory:
{\footnotesize
\begin{verbatim}
FACTORY random(seed:int):int;
BARRIER always:=true;
	clientid:= factory.getCaller();
	YIELD random(seed, clientid);
	REDO always;
EXIT always;
END random;

\end{verbatim}
}

@+ Factory control
@T
The predominant interaction between customer and factory
is the ordinary call. The parameters can be used to instruct
the factory on the actions to be taken. However, exceptional
cases may occur which the factory should be told about.

An exception raised in any client is also
forwarded to any factory which it would have called otherwise.
I.e. any factory call skipped while catching the exception
gets a copy too.
It effectively leads to a YIELD statement raising an exception.

@+ Volcano processing
@T
One interesting use of the factory scheme is to model
a volcano-style query processor. Each node in the query
tree is an iterator that calls upon the operands to produce
a chunk, which are combined into a new  chunk for concumption
of the parent. The prototypical join(R,S) query illustrates it.
The plan does not test for all boundary conditions, it merely
implements a nested loop. The end of a sequence is identified
by a NIL chunk.

{\footnotesize
\begin{verbatim}
FACTORY query();
	Left:= bind("relationA");
	Right:= bind("relationB");
	rc:= joinStep(Left,Right);
BARRIER rc!= nil;
	print(rc);
	rc:= joinStep(Left,Right);
	REDO rc!= nil;
EXIT rc;
END query;

#nested loop join
FACTORY joinStep(Left:bat[:any,:any],Right:bat[:any,:any]):bat[:any,:any];
	lc:= chunkStep(Left);
BARRIER outer:= lc != nil;
	rc:= chunkStep(Right);
	BARRIER inner:= rc != nil;
		chunk:= join(lc,rc);
		YIELD chunk;
		rc:= chunkStep(Right);
		REDO inner:= rc != nil;
	EXIT inner;
	lc:= chunkStep(Left);
	REDO outer:= lc != nil;
EXIT outer;
	# we have seen everything
	return nil;
END joinStep;

#factory for left branch
FACTORY chunkStepL(L:bat[:any,:any]):bat[:any,:any];
	i:= 0;
	j:= 20;
	cnt:= count(L);
BARRIER outer:= j<cnt;
	chunk:= slice(L,i,j);
	i:= j;
	j:= i+ 20;
	YIELD chunk;
	REDO loop:= j<cnt;
EXIT outer;
	# sent last portion
	chunk:= slice(L,i,cnt);
	YIELD chunk;
	RETURN nil;
END chunkStep;

#factory for right leg
FACTORY chunkStepR(L:bat[:any,:any]):bat[:any,:any];

\end{verbatim}
}
Ao far we haven;t re-used the pattern that both legs are
identical. This could be modeled by a generic chunk factory.
Choosing a new factory for each query steps reduces the 
administrative overhead.
@+ Open issues
What is the lifetime of a factory? Does it persists after
all clients has disappeared?

What additional control do you need? Can you throw an
exception to a Factory? implicitly yes.
{\footnotesize
\begin{verbatim}
	RAISE reset:="reset";
	chunkStep(L);	# receives 'reset' exception
	CATCH reset;
	EXIT reset;
\end{verbatim}
}

@{
@h
#ifndef _MAL_FACTORY_H
#define _MAL_FACTORY_H

/* #define DEBUG_MAL_FACTORY */

#include "mal_function.h"
#include "mal_exception.h"


#endif /*  _MAL_FACTORY_H*/
@-
@c
#include "mal_factory.h"

Symbol newFactory(str nme,int kind){
	(void) nme; (void) kind;
	return 0;
}
@}
