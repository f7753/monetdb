@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@' 
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@' 
@' The Original Code is the Monet Database System.
@' 
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2004 CWI.
@' All Rights Reserved.

@a M. L. Kersten
@* MAL runtime name space

The MAL name spaces are organized in a hierarchy of module scopes.
Each scope itself is organized as a list of subscopes
indexed by the first character of the function name.

A function call mod.fcn(Anme:Type, ..) is resolved as follows. We traverse the
nested scopes towards the root to locate the MODULE symbol named 'mod'.
From there we search the subscope 'fcn' and try to resolve the procedure.
If it fails and 'mod' was not given we inspect all subscopes. 

This method provides overloading, which can be enforced from a particular
level. For example, the user can introduce a module M with the function F,
but still force resolution within the body of F to start at an outer level.
(using MAL.F to indicate resolution in shared outerscope).
The main benefit for overloading is to introduce enhanced versions of
predefined modules, such as for traceing, accellerator maintenance,...

This implementation scheme limits the number of comparisons to find 
the relevant collection of function signatures to a handfull.
For the time being it is not worthwhile to implement a more complex
scope lookup scheme, for 1) the number of languages,
2) the number of modules/language, and 3) the routines per module/type
are limited

The global organization of the namespace consists of a core, language
and a client layer. 
The core layer contains all pre-compiled and linkable functions.
The next layer is bound to a particular front-end language, e.g. MIL or SQL
and contains a scope level for each module imported.
Such language scopes may be nested, e.g. SQL->MIL->MAL->kernel.

The client layer typically contains a collection of private MAL-procedures.
It contains a procedure 'main' to be executed by default. 

Each user has a separate scope, but the secondary clients have shared
access to the definitions available to the administrator.
This is (will) be realized by copying the scope resolution path.
The global scope and private scopes are separated by an a priori known
scope name "MAL_scope".


Unlike Monet V4, a MAL function scope is privately assigned to a single client
thread. Moreover, all dynamically loaded functions remain in existing
for the duration of the server session. Only the administrator can
load functions (upon system restart). Therefore, we do not have
to lock the dictionary table while traversing it for information.
Global (private) variables can be realized keeping the symbol table
and runtime stack around between requests.

Unlike Monet Version 4, administration for MAL procedures is
decoupled from their actual runtime behavior. This means we are
more relaxed on space allocation, because the size is determined
by the number of MAL procedure definitions instead of the runtime
calling behavior. (See mal_interpreter for details on value stack
management)
@{
@h
#ifndef _MAL_SCOPE_H_
#define _MAL_SCOPE_H_
#include "mal_box.h"
#include "mal_xml.h"

#define MAXSCOPE 256

typedef struct SCOPEDEF {
        struct SCOPEDEF   *outer; /* outer level in the scope tree */
        str     name;
    MALfcn  typeChecker;    /* function address for type checker */
        Symbol *subscope; /* type dispatcher table */
    Box box;    /* module related objects */
    int isAtomModule; /* atom module definition ? */
    str help;   /* short description of module functionality*/
} *Scope, ScopeDefinition;


mal_export Scope    mal_scope;  /* the start of the module list */

mal_export Scope    newScope(Scope scope, str nme);
mal_export Scope    fixateScope(Scope scope, str nme, int len);
mal_export void         freeScope(Scope cur);
mal_export void         freeScopeList(Scope cur);
mal_export void     insertSymbol(Scope scope, Symbol prg);
mal_export void     deleteSymbol(Scope scope, Symbol prg);
mal_export Scope    findScope(Scope scope, str name);
mal_export Symbol   findSymbolInScope(Scope v, str fcn);
mal_export Symbol   findMALSymbol(str mod, str fcn);
mal_export int      displayScope(stream *f, Scope v, str fcn,int listing);
mal_export void     showScopes(stream *f, Scope s);
mal_export void     debugScope(stream *f, Scope v, str nme);
mal_export void     dumpManual(stream *f, Scope v, int recursive);
mal_export void     dumpManualHeader(stream *f);
mal_export void     dumpManualFooter(stream *f);
mal_export void     showScopeStatistics(stream *f,Scope s); /* used in src/mal/mal_debugger.c */

#define getSubScope(N)  (*(N))

#endif /* _MAL_SCOPE_H_ */
@+ Scope management
Upon system restart, the global scope is created. It is called "root" and
does not contain any symbol definitions. It merely functions as an anchor
point for the modules to be added later.

@= newscope
    if( nme == NULL){
        GDKfatal("@1:unexpected name (=null)\n");
    }
        cur = (Scope) GDKmalloc(sizeof(ScopeDefinition));
    if( cur == NULL){
        GDKfatal("@1: cannot initialize scope\n");
    }
    bzero((str)cur,sizeof(ScopeDefinition));
    cur->name = nme;
    cur->outer = NULL;
    cur->typeChecker = NULL;
    cur->subscope = NULL; 
    cur->isAtomModule = FALSE;

@c
#include "mal_scope.h"
#include "mal_function.h"   /* for printFunction() */

Scope mal_scope;    /* the root of the tree */
Scope scopeJump[256][256];  /* to speedup access to correct scope */

void newSubScope(Scope scope){
    int len = (MAXSCOPE)*sizeof(Scope);
    scope->subscope = (Symbol *) GDKmalloc(len);
    bzero((char*)scope->subscope, len);
}
@-
Definition of a new module scope may interfere with concurrent
actions of multiple threads. This calls for a secure update 
of the scope tree structure. 
A jump table is mainted to provide a quick start in the module
table to find the correct one. This simple scheme safes about
100ms/100K calls
@c

Scope newScope(Scope scope, str nme){
    Scope cur;
    @:newscope(newScope)@
    newSubScope(cur);
    if( scope != NULL){
        cur->outer = scope->outer;
        scope->outer= cur;
        scopeJump[(int)(*nme)][(int)(*(nme+1))]= cur;
    } 
    return cur;
}
@-
The scope can be fixed using a length delimited string. 
This is used by the parser to avoid creation of
a string structure when possible. Subsequently we can
replace the modname in the instructions to become a pointer
to the scope directly.
Reading a module often calls for opening a scope level
if it didn't exist.
@c
Scope fixateScope(Scope scope, str nme, int len){
    Scope s= scope;
    str n;
    if( nme == NULL) return scope;
    if( s->name != NULL) {
        if( scopeJump[(int)(*nme)][(int)(*(nme+1))]) 
            s= scopeJump[(int)(*nme)][(int)(*(nme+1))];
        while(s != NULL){
            if( strcmp(nme,s->name)== 0 )
                return s;
            s= s->outer;
        }
    }
    n= (str) GDKmalloc(len+1);
    *(short*)n = 0;
    strncpy(n,nme,len);
    n[len]=0;
    return newScope(scope, n);
}
@-
The freeScope operation throws away a symbol without
concerns on it whereabouts in the scope structure.
This routine therefore assumes care in use.
The final action of the system is to remove all
instructions and procedures. This forcefull action
helps in localization of memory leakages.
@c
void freeSubScope(Scope scope){
    int i;
    if(scope->subscope==0) return;
    for(i=0;i<MAXSCOPE;i++)
    if( scope->subscope[i]){
        freeSymbolList(scope->subscope[i]);
        scope->subscope[i]= NULL;
    }
    GDKfree(scope->subscope);
    scope->subscope = 0;
}
void freeScope(Scope s){
    if(s==NULL) return;
    freeSubScope(s);
    if( s->name) { GDKfree(s->name); s->name = NULL;}
    GDKfree(s);
}
void freeScopeList(Scope s){
    Scope t=s;
    while(s){
        t= s->outer;
        s->outer= NULL;
        freeScope(s);
        s=t;
    }
}
@-
After filling in a structure it is added to the multi-level
symbol table. We keep a skip list of similar named function
symbols. This speeds up searching provided the modules adhire
to the structure group the functions as well.
@c
void insertSymbol(Scope scope, Symbol prg){
        InstrPtr sig;
        int t;
    Scope c;

        sig = getSignature(prg);
    if(moduleId(sig) && idcmp(moduleName(sig),scope->name) != 0){
        /* move the definition to the proper place */
        c= findScope(scope,moduleName(sig));
        if(c == NULL){
            GDKwarning("insertSymbol:undefined module\n");
        } else scope = c;
    }
        t = getSubScope(functionName(sig));
        if( scope->subscope == NULL){
        newSubScope(scope);
                scope->subscope[t] = prg;
        } else {
                prg->peer= scope->subscope[t];
        if( prg->peer && 
            idcmp(prg->name,prg->peer->name) == 0)
            prg->skip = prg->peer->skip;
        else    prg->skip = prg->peer;
                scope->subscope[t] = prg;
        }
}
@-
Removal of elements from the symbol table should be
done with care. For, it should be assured that
there are no references to the definition at the
moment of removal. This situation can not easily
checked at runtime, without tremendous overhead.
@c
void deleteSymbol(Scope scope, Symbol prg){
        InstrPtr sig;
        int t;

        sig = getSignature(prg);
    if(moduleId(sig) && idcmp(moduleName(sig),scope->name) != 0){
        /* move the definition to the proper place */
        Scope c= findScope(scope,moduleName(sig));
        if(c == NULL){
            GDKwarning("deleteSymbol:undefined module\n");
        } else scope = c;
    }
        t = getSubScope(functionName(sig));
    if( scope->subscope[t] == prg){
        scope->subscope[t] = scope->subscope[t]->peer;
    } else {
        Symbol nxt = scope->subscope[t];
        while( nxt->peer != NULL){
            if( nxt->peer == prg){
                Symbol old = nxt->peer;
                nxt->peer = old->peer;
                freeSymbol(old);
                return;
            }
            nxt = nxt->peer;
        }
        }
}


@+ Searching the scope structure.
Finding a scope is unrestricted. For modules we explicitly look for
the start of a new module scope.
@c
Scope findScope(Scope scope, str name){
    if( scope->name==NULL) return NULL;
    if( name==NULL) return scope;
    if( scopeJump[(int)(*name)][(int)(*(name+1))]) 
        scope= scopeJump[(int)(*name)][(int)(*(name+1))];
        while(scope != NULL){
                if( idcmp(name,scope->name)== 0 )
                        return scope;
                scope= scope->outer;
        }
        return scope;
}
@-
The routine @%findMALSymbol@ starts at the MAL scope level and searches 
an element amongst the peers. If it fails, it will recursively
inspect the outer scopes.

In principal, external variables are subject to synchronization actions
to avoid concurrency conflicts. This also implies, that any parallel
block introduces a temporary scope.

The variation on this routine is to dump the definition of
all matching definitions.
@c
Symbol findSymbolInScope(Scope v, str fcn){
    Symbol s;
    if( v == NULL || fcn == NULL) return NULL;
    s= v->subscope[(int)(*fcn)];
    while(s!=NULL){
        if( idcmp(s->name,fcn)==0 ) return s;
        s= s->skip;
    }
    return NULL;
}
Symbol findMALSymbol(str mod, str fcn){
    Scope v;
    v= findScope(mal_scope, mod);
    return findSymbolInScope(v,fcn);
}
int displayScope(stream *f, Scope v, str fcn, int listing){
    Symbol s;
    int k=0;

    if( v == NULL || fcn == NULL) return 0;
    s= v->subscope[(int)(*fcn)];
    while(s!=NULL){
        if( idcmp(s->name,fcn)==0 ) {
            printFunction(f,s->def,listing);
            k++;
        }
        s= s->peer;
    }
    return k;
}
@- Utilities
@c
void  printScope(stream *fd, Scope scope, int tab, int outer)
{
    int j;
    Scope s=scope;
    Symbol t;

    stream_printf(fd,"%smodule %s", 
        (scope->isAtomModule?"atom ":""),s->name);
    if( s->typeChecker) stream_printf(fd, " typechecker");
    stream_printf(fd,"\n");
    if( s->subscope)
    for(j=0;j<MAXSCOPE;j++)
    if(s->subscope[j]){
        stream_printf(fd,"[%c]",j);
        for(t= s->subscope[j];t!=NULL;t=t->peer) {
            stream_printf(fd," %s",t->name);
            if( getSignature(t)==NULL ||
                (getSignature(t)->fcn==0 &&
                 getSignature(t)->token == COMMANDsymbol &&
                 getSignature(t)->blk==0) ) 
                stream_printf(fd,"(?)");
        }
        stream_printf(fd,"\n");
    }
    stream_printf(fd,"\n");
    if(outer && scope->outer) printScope(fd,scope->outer,tab+1, outer);
}

void showScopes(stream *f, Scope s)
{
    for(; s; s= s->outer) {
        stream_printf(f,"%s",s->name);
        if( s== mal_scope) stream_printf(f,"(*)");
        if( s->subscope==0) stream_printf(f,"?");
        if(s->outer) stream_printf(f,",");
    }
    stream_printf(f,"\n");
}

void debugScope(stream *f, Scope start, str nme){
    Scope m;
    if( nme==0 || *nme ==0) printScope(f, start,0,TRUE);
    else{
        char *s;
        for(s=nme;*s && (isalnum((int) *s) ||*s=='_');s++);
        *s = 0;
        m= findScope(start,nme);
        if( m== NULL) stream_printf(f,"Scope '%s' not found\n",nme);
        else printScope(f,m,0,FALSE);
    }
}
@-
The commands and operators come with a short description. 
The dumpManual() command produces a single XML file for post 
processing and producing a system manual.
@c
void dumpManualHeader(stream *f){
    stream_printf(f,"<?xml version=\"1.0\"?>\n");
    stream_printf(f,"<manual>\n");
}
void dumpManualFooter(stream *f){
    stream_printf(f,"</manual>\n");
}
int cmpModName(Scope *f, Scope *l){
    return strcmp((*f)->name, (*l)->name);
}
void dumpManual(stream *f, Scope s, int recursive){
    int j;
    Symbol t;
    str ps, lnk, hlp=0, op=0, endtag=0;
    InstrPtr sig;
    Scope list[256]; int k, top=0;


    if(s==NULL || f==NULL){
        return;
    }
    list[top++]=s;
    while(s->outer && recursive){ list[top++]= s->outer;s=s->outer;}

    if(top>1) qsort(list, top, sizeof(Scope), 
        (int(*)(const void *, const void *))cmpModName);

    for(k=0;k<top;k++){
    s= list[k];
    stream_printf(f,"<%smodule name=\"%s\">\n", 
        (s->isAtomModule?"atom":""),xmlChr(s->name));
    if(s->help)
        stream_printf(f,"%s\n",s->help);
    if( s->subscope)
    for(j=0;j<MAXSCOPE;j++)
    if(s->subscope[j]){
        for(t= s->subscope[j];t!=NULL;t=t->peer) {
            sig= getSignature(t);

            if(op==0 || strcmp(op,t->name)){
                if(endtag) stream_printf(f,"  </%s>\n",endtag);
                stream_printf(f,"  <%s",fcnClass(sig));
                op = t->name;
                stream_printf(f,"  name=\"%s\">\n",xmlChr(op));
                if(t->def->help)
                stream_printf(f,"    <comment>%s</comment>\n",
                    xmlChr(t->def->help));
                op= t->name;
                endtag= fcnClass(sig);
            }

            ps= instruction2str(t->def,sig,0);
            lnk= strrchr(ps,'=');
            if(lnk && *(lnk+1)!='(') *lnk=0;

            stream_printf(f,"  <instantiation>\n");
            stream_printf(f,"    <signature>%s</signature>\n",
                xmlChr(strchr(ps,'(')));
            if(lnk)
            stream_printf(f,"    <implementation>%s</implementation>\n",xmlChr(lnk+1));
            GDKfree(ps);
            if(t->def->help){
                if(hlp && strcmp(hlp,t->def->help))
                stream_printf(f,"    <comment>%s</comment>\n",
                    xmlChr(t->def->help));
            }
            stream_printf(f,"  </instantiation>\n");
        }
    }
    if(endtag) stream_printf(f,"  </%s>\n",endtag);
    stream_printf(f,"</%smodule>\n", (s->isAtomModule?"atom":""));
    endtag=0;
    }
}
@-
Summarize the type resolution table.
@c

void showScope(stream *f, Scope v,int cnt[256]){
    int sigs=0,i,max=0,m;
    Symbol s;
    int c[256];
    for(i=0;i<256;i++) c[i]=0;
    for(i=0;i<256;i++){
        m=0;
        s= v->subscope[i];
        while(s!=NULL){
            m++;
            sigs++;
            cnt[i]++;
            c[i]++;
            s= s->peer;
        }
        if(m>max)max=m;
    }
    m=0;
    for(i=0;i<256;i++)
    if(v->subscope[i]){
        stream_printf(f,"%20s",(m++ ==0?v->name:""));
        stream_printf(f,"[%c] %5d %5d\n",i,c[i],(cnt[i]-c[i]/2));
    }
    if(v->outer) showScope(f,v->outer,cnt);
}
void showScopeStatistics(stream *f,Scope s){
    int i,cnt[256];

        stream_printf(f,"%20s%5s%5s\n","module","#sig","avg chk");
    for(i=0;i<256;i++) cnt[i]=0;
    showScope(f,s,cnt);
}
@}
