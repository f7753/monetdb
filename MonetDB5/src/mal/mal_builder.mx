@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2004 CWI.
@' All Rights Reserved.

@f mal_builder
@a M. Kersten
@v 1.0

@* The MAL builder
The MAL builder library containst the primitives to simplify construction 
of programs by compilers. It has grown out of the MonetDB/SQL code generator
and further refined during the MIL-2-MAL compiler.

The strings being passed as arguments are copied in the process.

@h
#ifndef _MAL_BUILDER_
#define _MAL_BUILDER_

#include "mal.h"
#include "mal_function.h"
#include "mal_namespace.h"

mal_export InstrPtr newStmt( MalBlkPtr mb, char *module, char *name ) ;
mal_export InstrPtr newStmtId( MalBlkPtr mb, char *id, char *module, char *name ) ;
mal_export InstrPtr newAssignment( MalBlkPtr mb );
mal_export InstrPtr newFcnCall( MalBlkPtr mb, char *mod, char *fcn );
mal_export InstrPtr pushInt(MalBlkPtr mb, InstrPtr q, int val) ;
mal_export InstrPtr pushOid(MalBlkPtr mb, InstrPtr q, oid val) ;
mal_export InstrPtr pushVoid(MalBlkPtr mb, InstrPtr q) ;
mal_export InstrPtr pushLng(MalBlkPtr mb, InstrPtr q, long val) ;
mal_export InstrPtr pushDbl(MalBlkPtr mb, InstrPtr q, double val) ;
mal_export InstrPtr pushStr(MalBlkPtr mb, InstrPtr q, const char *val) ;
mal_export InstrPtr pushBit(MalBlkPtr mb, InstrPtr q, const char *val) ;
mal_export InstrPtr pushNilType(MalBlkPtr mb, InstrPtr q, char *tpe ) ;

#endif /* _MAL_BUILDER_*/

@c
#include "mal_builder.h"
InstrPtr
newAssignment( MalBlkPtr mb )
{
	InstrPtr q= newInstruction(ASSIGNsymbol);
	pushInstruction(mb,q);
	return q;
}

InstrPtr 
newStmt( MalBlkPtr mb, char *module, char *name ) 
{ 
	InstrPtr q= newAssignment(mb);
	moduleId(q)= (module)? putName(module,strlen(module)): 0;
	functionId(q)= (name)? putName(name,strlen(name)): 0;
	setDestVar(q, newTmpVariable(mb,TYPE_any));
	setVarInitialized(mb,getDestVar(q));
	return q;
}

InstrPtr 
newStmtId( MalBlkPtr mb, char *id, char *module, char *name ) 
{
	InstrPtr q= newAssignment(mb);
	moduleId(q)= (module)? putName(module,strlen(module)): 0;
	functionId(q)= (name)? putName(name,strlen(name)): 0;
	setDestVar(q, newVariable(mb,GDKstrdup(id),TYPE_any));
	setVarInitialized(mb,getDestVar(q));
	return q;
}

InstrPtr
newFcnCall( MalBlkPtr mb, char *mod, char *fcn )
{
	InstrPtr q= newAssignment(mb);
	setModuleId(q,putName(mod,strlen(mod)) );
	setFunctionId(q,putName(fcn,strlen(fcn)));
	return q;
}

InstrPtr 
pushInt(MalBlkPtr mb, InstrPtr q, int val) 
{	
	int _t; 
	char bufi[BUFSIZ];

	snprintf(bufi,BUFSIZ,"%d",val);
	_t= newConstant(mb,TYPE_int,GDKstrdup(bufi),TRUE); 
	return pushArgument(mb,q,_t);
}

InstrPtr 
pushOid(MalBlkPtr mb, InstrPtr q, oid val) 
{	
	int _t; 
	char bufi[BUFSIZ];

	snprintf(bufi,BUFSIZ,"%d@0",val);
	_t= newConstant(mb,TYPE_oid,GDKstrdup(bufi),TRUE); 
	return pushArgument(mb,q,_t);
}
InstrPtr 
pushVoid(MalBlkPtr mb, InstrPtr q) 
{	
	int _t; 
	char bufi[BUFSIZ];

	snprintf(bufi,BUFSIZ,"nil");
	_t= newConstant(mb,TYPE_void,GDKstrdup(bufi),TRUE); 
	return pushArgument(mb,q,_t);
}

InstrPtr 
pushLng(MalBlkPtr mb, InstrPtr q, long val) 
{	
	int _t; 
	char bufi[BUFSIZ];

	snprintf(bufi,BUFSIZ,"%ld",val);
	_t= newConstant(mb,TYPE_lng,GDKstrdup(bufi),TRUE); 
	return pushArgument(mb,q,_t);
}
InstrPtr 
pushDbl(MalBlkPtr mb, InstrPtr q, double val) 
{	
	int _t; 
	char bufi[BUFSIZ];

	snprintf(bufi,BUFSIZ,"%f",val);
	_t= newConstant(mb,TYPE_dbl,GDKstrdup(bufi),TRUE); 
	return pushArgument(mb,q,_t);
}

InstrPtr 
pushStr(MalBlkPtr mb, InstrPtr q, const char *val) 
{
	int _t = newConstant(mb,TYPE_str,GDKstrdup(val),TRUE); 
	return pushArgument(mb,q,_t);
}

InstrPtr 
pushBit(MalBlkPtr mb, InstrPtr q, const char *val) 
{
	int _t = newConstant(mb,TYPE_bit,GDKstrdup(val),TRUE); 
	return pushArgument(mb,q,_t);
}

InstrPtr 
pushNilType(MalBlkPtr mb, InstrPtr q, char *tpe ) 
{	
	int _t = newConstant(mb,
		getTypeIndex(tpe,strlen(tpe),TYPE_any),GDKstrdup("nil"),TRUE); 
	return pushArgument(mb,q,_t);
}

