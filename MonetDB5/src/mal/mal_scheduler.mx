@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2005 CWI.
@' All Rights Reserved.

@f mal_scheduler
@a M. Kersten
@* Scheduler framework
A key design decision for this MonetDB  version is to create a clean
processing pipeline: compile-, optimize-, schedule- and execute.
The MAL scheduler controls the actual execution of a program through a number of
techniques described here. It accepts a program with the intend to execute it
as soon as possible.

Recall that the MAL optimizer already had an opportunity to massage the program
into something that has a better execution behaviour. These optimizations
necessarily rely on static (or stale) information, such as histograms, indices,
and rewrite heuristics. It is the task of the scheduler to achieve this 
performance
objective (or better), while at the same time guaranteeing a great throughput.

Unlike the optimizer, the scheduler has access to the calling parameters,
runtime stack for the about-to-be-executed plan, and system resources,
such as cached results. Moreover, a scheduler can be called at any time
during a MAL interpreter loop to re-consider the actions to be taken.
This gives many more opportunities to improve performance.
This does not hold for e.g. compiled code, nor X100 backends)

Much like the optimizer framework, there are many aspects you can deal with
at scheduling time. The easiest is to simply do nothing and rely on
the MAL interpreter, which is the default action when no scheduler directive 
is found. This still costs time, because the schedule processor
has to go thru the program once to detect any pre-execution action.

To make its life easy, it is assumed that all scheduler decisions to be
taken before the back-end is called recide in the module 'scheduler'.
Any action to be taken during execution is kept in module 'reschduler'.

In most cases, however,  you would like a scheduler to take a specific action.
It typically rewrites, extends, or reshuffles the query plan. In this process
it can use the optimizer infrastructure, provided the changes are isolated
to a private instance. The upfront cost attached is to make a complete
copy of the program, so as to assure that the definitions in the
symbol table remain intact.

What scheduler operators are provided?

The generic scheduler presented here shows a series of techniques that migh be
usefull in construcing your own scheduler.

@emph{Run isolation (RUNisolation*)}
Goal: to isolate changes to the query plan from others
Rationale: A scheduler may change the order, and actual function calls.
These changes should be convined to a single execution. The next time around
there may be a different situation to take care of. This is achieved by
replacing the query plan with a private copy.
Note that this process may involve a deep analysis to identify the pieces
needed for isolation, e.g. for SQL we need to extract a copy from the query
cache. Just massaging the call to the cached plan is not effective.
Impact: cost of program copying may become an issue.

@emph{Run trace (RUNtracing)}
Goal: to collect performance data for either direct monitoring or post-analysis
Rationale:The performance profiling option in the interpreter is overly expensive,
because it is also called for simple statements. One way out of this, is to
inject specific performance metric calls at places where it counts.
For example, you could wrap calls calls to a specific module or operation.

@emph{Run notification (RUNnotification)}
Goal: to inject notification calls to awaiting servers
Rationale: Operations on the database may require side effects to take place, 
such as activating a trigger (implemented as a factory)

@emph{Update notification (RUNupdateNotification)}
Goal: Updates to the Boxes may have to  forwared to stand-by replicas.
Rationale: actually a refinement of the notification scheme, but geared at
maintaining a replicated system.

@emph{Run parallization (RUNparallel)}
Goal: to improve throughput/response time by exploiting parallel hardware

@emph{Run stepping RUNstepping}
goal: to return to the scheduler at specific points in the program
execution. For example to re-consider the scheduling actions.
Note that this requires a scheme to 'backtrack' in the scenario

@emph{Cache management (RUNbatCaching}
Goal: to capture expensive BAT operations and to keep them around for
re-use. 

@emph{JIT compilation}
Use the optimizer scheme to prepare for a different execution engine.

What the scheduler should do more?

One of the areas to be decided upon is whether the scheduler is
also the place to manage the stack spaces. It certainly could
reconcile parallel executions by inspection of the stack.
@{
@h
#include "mal.h"
#include "mal_optimizer.h"

/* #define DEBUG_MAL_SCHEDULER     show partial result */

mal_export str MALscheduler(Client c);
mal_export str debugScheduler(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);

@+ Scheduler implementation
@= schedulerCleanup
	if(@1) {
		removeInstruction(mb,@1);
		chkFlow(mb);
	}
@c
#include "mal_scheduler.h"
#include "mal_interpreter.h"    /* for showErrors() */

str debugScheduler(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	Client cntxt= getClient();
	(void) stk;

    cntxt->debugScheduler= cntxt->debugScheduler? FALSE: TRUE;
	@:schedulerCleanup(pci)@
	return MAL_SUCCEED;
}
@-
The implementation approach of the scheduler aligns with that of the
optimizer. We look for specific scheduler module calls and act accordingly.
The result should be a MAL block that can be executed by the corresponding
engine. 
[how to assure that a proper optimizer-scheduler-engine triple is used]
@c
str schedulerMALBlock(MalBlkPtr mb)
{   InstrPtr p;
    int callMALinterpreter=1, pc,cnt=0;
    str msg= NULL;
    int loops =0;
#ifdef DEBUG_MAL_SCHEDULER
    int oldstop= mb->stop;
#endif

    do{
        cnt=0;
        for(pc=0; pc< mb->stop; pc++){
            p= getInstrPtr(mb,pc);
            if( moduleId(p) && idcmp(moduleName(p),"scheduler")==0){
                cnt++;
				callMALinterpreter++;
                if( p->fcn)
					/* all schedulers should behave like patterns */
					/* However, we don;t have a stack now */
                    msg= (str) (*p->fcn)(mb,0,p);
                if( msg) {
                    GDKerror(msg);
                    showErrors();
                    return msg;
                }
                pc--; /*scheduler statement has been removed*/
            }
        }
    } while(cnt && loops++ < 64);
	if( callMALinterpreter )
		return MAL_SUCCEED;
#ifdef DEBUG_MAL_SCHEDULER
    if( getClient()->debugScheduler && oldstop!=mb->stop){
    stream_printf(GDKout,"Scheduler effect %d -> %d instructions\n",
        oldstop,mb->stop);
    }
#endif
    if( cnt >= 64)
        return throwMessage("scheduler.MALscheduler",
                "too many optimization cycles\n");
    return 0;
}
str MALscheduler(Client c)
{
	return schedulerMALBlock(c->curprg->def);
}
@}
@+ Run isolation
Run isolation involves maken available private copies for further massageing.
The easiest is to simply take a copy of the current MAL program. It is the
first example. The next one is to  make modules or operations private.
The isolated versions are made private to the client.

@example
function main();
	print("start running\n");
	scheduler.isolate();
	print("done\n");
	showFunction();
@end example

@example
function sql_cache.qry01();
	print("query 01\n");
end qry01;

function main();
	print("start running\n");
	scheduler.isolate(sql_cache);
	sql_cache.qry01();
	print("done\n");
	showFunction();
@end example

The isolation is a simple copy. The backup should be detected
by the engine and reset after the execution. It should free up
the space.
The pointer passed can be used to remove the scheduler call
from the dummy.
@{
@c
str RUNisolationTop(MalBlkPtr mb, MalStkPtr stk, InstrPtr p){
	Client cntxt= getClient();

	(void) stk; 
	if( cntxt->backup)
		return throwMessage("scheduler.isolation","no space for backup");
	cntxt->backup = cntxt->curprg;
	cntxt->curprg->def = copyMalBlk(mb);
	removeInstruction(cntxt->curprg->def,p);
	return MAL_SUCCEED;
}
@}
