@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2005 CWI.
@' All Rights Reserved.

@f mal_scheduler
@a M. Kersten
@* Scheduler framework
A key design decision for this MonetDB  version is to create a clean
processing pipeline: compile-, optimize-, schedule- and execute.
The MAL scheduler controls the actual execution of a program through a number of
techniques described here. It accepts a program with the intend to execute it
as soon as possible with the best possible behavior.

Note that optimizer and scheduler should only work no temporary plans.
Keeping an optimized plan in the symbol table calls for a sound administration
to invalidate it. This assumed that such decisions are taken by a cooperative
front-end compiler, e.g. SQL. For the remainder we assume a volatile MAL 
program is available.

Recall that the MAL optimizer already had an opportunity to massage the program
into something that has a better execution behavior. These optimizations
necessarily rely on static (or stale) information, such as histograms, indices,
and rewrite heuristics. It is the task of the scheduler to achieve this 
performance
objective (or better), while at the same time guaranteeing a great throughput.

Unlike the optimizer, the scheduler has access to the calling parameters,
runtime stack for the about-to-be-executed plan, and system resources,
such as cached results. Moreover, a scheduler can be called at any time
during a MAL interpreter loop to re-consider the actions to be taken.
This gives many more opportunities to improve performance.
This does not hold for e.g. compiled code, nor X100 back ends)

Much like the optimizer framework, there are many aspects you can deal with
at scheduling time. The easiest is to simply do nothing and rely on
the MAL interpreter, which is the default action when no scheduler directive 
is found. This still costs time, because the schedule processor
has to go through the program once to detect any pre-execution action.

To make its life easy, it is assumed that all scheduler decisions to be
taken before the back-end is called reside in the module 'scheduler'.
Any action to be taken during execution is kept in module 'rescheduler'.

In most cases, however,  you would like a scheduler to take a specific action.
It typically rewrites, extends, or reshuffles the query plan. In this process
it can use the optimizer infrastructure, provided the changes are isolated
to a private instance. The upfront cost attached is to make a complete
copy of the program, so as to assure that the definitions in the
symbol table remain intact.

What scheduler operators are provided?

The generic scheduler presented here shows a series of techniques that 
might be useful in construction of your own scheduler.

@emph{Run isolation (RUNisolated)}
Goal: to isolate changes to the query plan from others
Rationale: A scheduler may change the order, and actual function calls.
These changes should be confined to a single execution. The next time around
there may be a different situation to take care off. This is achieved by
replacing the query plan with a private copy.
Note that this process may involve a deep analysis to identify the pieces
needed for isolation, e.g. for SQL we need to extract a copy from the query
cache. Just massaging the call to the cached plan is not effective.
Impact: cost of program copying may become an issue.

@emph{Run trace (RUNtracing)}
Goal: to collect performance data for either direct monitoring or post-analysis
Rationale:The performance profiling option in the interpreter is overly expensive,
because it is also called for simple statements. One way out of this, is to
inject specific performance metric calls at places where it counts.
For example, you could wrap calls calls to a specific module or operation.

@emph{Run notification (RUNnotification)}
Goal: to inject notification calls to awaiting servers
Rationale: Operations on the database may require side effects to take place, 
such as activating a trigger (implemented as a factory)

@emph{Update notification (RUNupdateNotification)}
Goal: Updates to the Boxes may have to  forwarded to stand-by replicas.
Rationale: actually a refinement of the notification scheme, but geared at
maintaining a replicated system.

@emph{Run parallelization (RUNparallel)}
Goal: to improve throughput/response time by exploiting parallel hardware

@emph{Run stepping RUNstepping}
goal: to return to the scheduler at specific points in the program
execution. For example to re-consider the scheduling actions.
Note that this requires a scheme to 'backtrack' in the scenario

@emph{Cache management (RUNbatCaching}
Goal: to capture expensive BAT operations and to keep them around for
re-use. 

@emph{JIT compilation}
Use the optimizer scheme to prepare for a different execution engine.

What the scheduler should do more?

One of the areas to be decided upon is whether the scheduler is
also the place to manage the stack spaces. It certainly could
reconcile parallel executions by inspection of the stack.
@{
@h
#include "mal.h"
#include "mal_optimizer.h"

/* #define DEBUG_MAL_SCHEDULER     show partial result */

mal_export str MALscheduler(Client c);
mal_export str debugScheduler(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);

@+ Scheduler implementation
@= schedulerCleanup
	if(@1) {
		removeInstruction(mb,@1);
		chkFlow(mb);
	}
@c
#include "mal_scheduler.h"
#include "mal_interpreter.h"    /* for showErrors() */

str debugScheduler(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	Client cntxt= getClient();
	(void) stk;

    cntxt->debugScheduler= cntxt->debugScheduler? FALSE: TRUE;
	@:schedulerCleanup(pci)@
	return MAL_SUCCEED;
}
@-
The implementation approach of the scheduler aligns with that of the
optimizer. We look for specific scheduler module calls and act accordingly.
The result should be a MAL block that can be executed by the corresponding
engine. 
@c
str schedulerMALBlock(MalBlkPtr mb)
{   InstrPtr p;
    int callMALinterpreter=1, pc,cnt=0;
    str msg= NULL;
    int loops =0;
#ifdef DEBUG_MAL_SCHEDULER
    int oldstop= mb->stop;
#endif

    do{
        cnt=0;
        for(pc=0; pc< mb->stop; pc++){
            p= getInstrPtr(mb,pc);
            if( moduleId(p) && idcmp(moduleName(p),"scheduler")==0){
                cnt++;
				callMALinterpreter++;
                if( p->fcn)
					/* all schedulers should behave like patterns */
					/* However, we don;t have a stack now */
                    msg= (str) (*p->fcn)(mb,0,p);
                if( msg) {
                    GDKerror(msg);
                    showErrors();
                    return msg;
                }
                pc--; /*scheduler statement has been removed*/
            }
        }
    } while(cnt && loops++ < 64);
	if( callMALinterpreter )
		return MAL_SUCCEED;
#ifdef DEBUG_MAL_SCHEDULER
    if( getClient()->debugScheduler && oldstop!=mb->stop){
    stream_printf(GDKout,"Scheduler effect %d -> %d instructions\n",
        oldstop,mb->stop);
    }
#endif
    if( cnt >= 64)
        return throwMessage("scheduler.MALscheduler",
                "too many optimization cycles\n");
    return 0;
}
str MALscheduler(Client c)
{
	return schedulerMALBlock(c->curprg->def);
}
@}
@+ Run isolation
Run isolation involves making available a private copy for further massaging.
The easiest is to simply take a copy of the MAL program into
the client's namespace (e.g. Admin), effectively overloading the definition.
with a temporary one. The major pitfall is that the program could call
itself recursively or is indirectly referenced.
Since we are already at the execution stage, this doesn;t cause
any problems, because any related re-scheduling activity should be
part of the program code any scheduling activity should
be embedded as 'rescheduler' calls. At that time we have precise knowledge
over the runtime stack.

At the end of its execution, the modified program may be removed, because
successive calls may call for different scheduling actions. Since this is
not a priori known, we keep the modified plan around.
It should be garbage collected outside the main loop. [tricky]

@example
function main();
	print("start running\n");
	scheduler.isolate();
	print("done\n");
	showFunction();
@end example

The target of a scheduler is the program block in which it
is called. This is the easiest way to ensure the information
about changes are propagated between scheduler call.
For example, in the example below parallel() would have to be
informed that qry01() has changed into a local copy.
This is hard to realize if schedulers would be given a freedom
to change programs at arbitrary places in the symbol table.
@example
function sql_cache.qry01();
	print("query 01\n");
end qry01;

function main();
	print("start running\n");
	scheduler.isolate(sql_cache,qry01);
	scheduler.parallel(sql_cache,qry01);
	sql_cache.qry01();
	print("done\n");
	showFunction();
@end example

The isolation is a simple copy. The backup should be detected
by the engine and reset after the execution. It should free up
the space.
The pointer passed can be used to remove the scheduler call
from the dummy.
@{
@c
str RUNisolate(MalBlkPtr mb, MalStkPtr stk, InstrPtr p){
	Client cntxt= getClient();

	(void) stk; 
	if( cntxt->backup)
		return throwMessage("scheduler.isolation","no space for backup");
	cntxt->backup = cntxt->curprg;
	cntxt->curprg->def = copyMalBlk(mb);
	removeInstruction(cntxt->curprg->def,p);
	return MAL_SUCCEED;
}
@}
