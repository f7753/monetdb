@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2005 CWI.
@' All Rights Reserved.

@a M. Kersten
@v 0.0
@+ Bootstrap loading 
The server is bootstrapped by processing a MAL script with
module definitions. For each module encountered, the object library 
lib_<modulename>.so is searched for in @dots{}/lib/MonetDB.
The corresponding signature are defined 
in @dots{}/lib/<modulename>.mal.
@-
The default bootstrap script is called @dots{}/lib/MonetDB/mal_init.mal
and it is designated in the configuration file as the mal_init property.
The rationale for this set-up is that database administrators can
extend/overload the bootstrap procedure without affecting the distributed
software package. 
It merely requires a different direction for the mal_init property.
@-
The scheme also isolates the functionality embedded in modules from
inadvertise use on non-compliant databases.
[access control issue, how to limit what a user can do on a database?]
@-
Unlike previous versions of MonetDB, modules can not be unloaded. 
Dynamic libraries are always global and, therefore, it
is best to load them as part of the server initialization phase.
@-
The MAL program should be compiled with -rdynamic and -ldl.
This enables loading the routines and finding out the address
of a particular routine
@-
@{
For the time being we assume that all commands are statically linked.
@h
#ifndef _MAL_LINKER_H
#include "mal_scope.h"
#include <dlfcn.h>

/*#define DEBUG_MAL_LINKER  */
#define MONET64 1
mal_export MALfcn getAddress(str fcnname);
mal_export str loadModuleLibrary(str modnme);
mal_export void unloadModuleLibraries();
mal_export void initLibraries();
mal_export int  isPreloaded(str nme);
#endif
@}
@+ Function binding
The mapping from MAL module.function() identifier to an address is
resolved in the function getAddress. Since all modules libraries are loaded
completely with GLOBAL visibility, it suffices to provide the internal function 
name.
Note, however, that the libraries are reference counted. Although we
do;t close them until end of session it seems prudent to maintain
the consistency of this counter.

In the case an attempt to link to an address fails, 
a final attempt is made to locate the *.o file in
the current directory.
@{
@c
#include "mal_linker.h"
#include "mal_function.h"   /* for throwException() */
#include "mal_import.h"     /* for slash_2_dir_sep() */

static void clear_moddir();

static int noDlopen;

MALfcn getLocalObjectFile(str fcnname){
    int mode = RTLD_NOW|RTLD_GLOBAL;
    void *handle = NULL;
    char *fullname;

    fullname = MSP_locate_module(fcnname);
    if( fullname == NULL) {
        /* stream_printf(GDKout,"Name not resolved %s\n",fullname);*/
        return 0;
    }
    /* printf("attempt to load function %s\n",fullname);*/
    handle = dlopen(fullname, mode);
    /* printf("loaded ? %s\n",(handle!=0?"yes":"no"));*/
    if( handle)
        return (MALfcn) dlsym(handle,fcnname);
    stream_printf(GDKout,"could not access library %s\n",dlerror());
    return 0;
}

MALfcn getAddress(str fcnname){
    void *dl;
    MALfcn adr;

#ifdef DEBUG_MAL_LINKER2
        stream_printf(GDKout,"addres of %s ?\n", fcnname);
#endif
    dl= dlopen(NULL, RTLD_NOW | RTLD_GLOBAL);
    if(dl==NULL){
        GDKfatal("getAddress:can;t get dl-handle\n");
        exit(0);
    }
    adr= (MALfcn) dlsym(dl,fcnname);
    if( adr == NULL) adr = getLocalObjectFile(fcnname);
    if(noDlopen && adr == NULL)
        GDKerror("address of '%s' not found\n", fcnname);
#ifdef DEBUG_MAL_LINKER2
    if( adr != NULL)
        stream_printf(GDKout,"addres of %s %o %s\n", 
            fcnname,(int) adr, dlerror());
#endif
    dlclose(dl);
    return adr;
}
@}
@+ Module loading
The default location to search for the module is in monet_mod_path
unless an absolute path is given.

Loading further relies on the Linux policy to search for the module
location in the following order: 1) the colon-separated list of
directories in the user's LD_LIBRARY, 2) the libraries specified
in /etc/ld.so.cache, and 3) /usr/lib followed by /lib
If the module contains a routine _init, then that code is executed
before the loader returns. Likewise the routine _fini is called just
before the module is unloaded.

A module loading conflict emerges if a function is redefined.
A duplicate load is simply ignored by keeping track of modules
already loaded.
@{
@c
#define MAXMODULES 256

static str *moduleLoaded;
static void **moduleHandle;
static int maxmodules= 0;
static int lastmodule= 0;

static void initM5Loader(){
	str *newModuleLoaded;
	void **newModuleHandle;
	int i,newsize= maxmodules+MAXMODULES;

	/* assume a safe all environment */
	if( moduleLoaded == NULL){
		mal_set_lock(mal_contextLock, "loadModule");
		if( moduleLoaded == NULL){
			maxmodules= MAXMODULES;
			moduleLoaded = (str*) GDKmalloc(maxmodules * sizeof(str));
			moduleHandle = (void **) GDKmalloc(maxmodules * sizeof(void *));
			for(i=0;i<maxmodules;i++){
				moduleLoaded[i]=NULL;
				moduleHandle[i]=NULL;
			}
		}
		mal_unset_lock(mal_contextLock, "loadModule");
	} else if( lastmodule+2 == maxmodules){
		/* guarantee at least one free slot */
		mal_set_lock(mal_contextLock, "loadModule");
		newModuleLoaded = (str*) GDKmalloc(newsize * sizeof(str));
		newModuleHandle = (void **) GDKmalloc(newsize * sizeof(void *));
		bzero((char*) newModuleLoaded, newsize * sizeof(str));
		memcpy((char*) newModuleLoaded, (char*)moduleLoaded, 
				maxmodules * sizeof(str*));
		memcpy((char*) newModuleHandle, (char*)moduleHandle, 
				maxmodules * sizeof(void **));
		GDKfree(moduleLoaded);
		GDKfree(moduleHandle);
		moduleLoaded = newModuleLoaded;
		moduleHandle = newModuleHandle;
		for(i=maxmodules;i<newsize;i++){
			moduleLoaded[i]=NULL;
			moduleHandle[i]=NULL;
		}
		maxmodules= newsize;
		mal_unset_lock(mal_contextLock, "loadModule");
	}
}

str loadModuleLibrary(str modnme){
    int mode = RTLD_NOW|RTLD_GLOBAL;
    char nme[MAXPATHLEN];
    char errbuf[1024];
    void *handle = NULL;
    str fullname,s;
    int i = 0, idx;

	initM5Loader();
    for(idx=0;moduleLoaded[idx] && idx<maxmodules;idx++)
        if( strcmp(moduleLoaded[idx],modnme)==0) {
#ifdef DEBUG_MAL_LINKER
        stream_printf(GDKout,"already load:%s:%s\n",modnme,handle==NULL?
            (handle==NULL?errbuf:"failed"):"succeeded");
#endif
			return 0;
		}
@-
Use the search path provided in the configuration file
@c
    s= strrchr(modnme,DIR_SEP);
    snprintf(nme,MAXPATHLEN,"_%s", s? s+1:modnme);
    fullname = MSP_locate_module(nme);

/* AIX requires RTLD_MEMBER to load a module that is a member of an archive.  */
#ifdef RTLD_MEMBER
        mode |= RTLD_MEMBER;
#endif
    if( fullname){
        handle = dlopen(fullname, mode);
#ifdef DEBUG_MAL_LINKER
        stream_printf(GDKout,"load:%s:%s\n",fullname,handle==NULL?
            (handle==NULL?errbuf:"failed"):"succeeded");
#endif
        if(handle == NULL) {
            strcpy(errbuf, dlerror());
            GDKfree(fullname);
            GDKerror("load error %s\n", errbuf);
            return (str) throwException("loaderException",
                "loadModuleLibrary",modnme);
        }
        GDKfree(fullname);
    } else {
		GDKerror("Failed to bind module '%s' to library\n",modnme);
		return (str) throwException("loaderException",
			"loadModuleLibrary",modnme);
	}

	mal_set_lock(mal_contextLock, "loadModule");
    for(i=0;moduleLoaded[i] && i<=lastmodule;i++);
    if( i==maxmodules)
        GDKerror("loadModule:internal error, too many modules loaded\n");
    else {
        moduleLoaded[i]= GDKstrdup(modnme);
        moduleHandle[i]= handle;
		lastmodule= i;
    }
	mal_unset_lock(mal_contextLock, "loadModule");
    return 0;
}
@-
For analysis of memory leaks we should cleanup the libraries before
we exit the server
@c
void unloadModuleLibraries(){
    int i;
	mal_set_lock(mal_contextLock, "loadModule");
    for(i=0;i<maxmodules;i++)
    if( moduleHandle[i]) {
        dlclose(moduleHandle[i]);
        GDKfree(moduleLoaded[i]);
    }
	lastmodule=0;
    (void) clear_moddir();
	mal_unset_lock(mal_contextLock, "loadModule");
}
@}
@+ Static pre-loading
To speedup restart and to simplify debugging, the Monet server can
be statically linked with some (or all) of the modules. 
A complicating factor is then to avoid users to initiate another load
of the module file, because it would lead to a dlopen error.

The partial way out of this dilema is to administer somewhere
the statically bound modules, or to enforce that each module
comes with a known routine for which we can search.
In the current version we use the former approach.
@{
The routine below turns off dynamic loading while parsing the
command signature files.
@c
static str preloaded[]={
    "kernel/bat",
    0 };

int isPreloaded(str nme){
    int i;
#ifdef DEBUG_MAL_LINKER
    stream_printf(GDKout,"load:%s:preloaded?\n",nme);
#endif
    for(i=0;preloaded[i];i++) 
    if( strcmp(preloaded[i],nme)==0) return 1;
    return 0;
}
void initLibraries() {
    noDlopen = TRUE;
/*
    for(i=0;preloaded[i];i++) {
        stream_printf(GDKout,"loading %s\n",preloaded[i]);
        loadModuleLibrary(preloaded[i]);
    }
*/
}
@+ Handling of Module Search Path
The plausible locations of the modules can be designated by
an environment variable. 
This code was originally developed by Florian Waas.
@h
#ifndef _searchpath_H
#define _searchpath_H

#include <gdk_storage.h>

#ifndef SO_EXT
#define SO_EXT ".so"
#endif

/* 
 * prototypes 
 *
 */

/* rewind list cursor and initialize the list if not done yet */
void MSP_rewind_module_list(void);

/* search for module and return the complete path */
char *MSP_locate_module(char *);
char *MSP_locate_script(char *);

/* return next module found in the list */
char *MSP_next_module(char *);

#endif
@c

#ifdef HAVE_SYS_PARAM_H
#include <sys/param.h>
#endif

static size_t SO_EXT_LEN = 0;   /* length of SO_EXT string, will be
                   filled in before use */

struct moddir {
    char *path;
    struct moddir *next;
};

static struct moddir *moddir_list=0;

#if 0               /* not used */
static void print_moddir_list(void) {
    struct moddir *entry=moddir_list;
    while(entry)
        {
            printf("list: %s\n",entry->path);
            entry=entry->next;
        }
}
#endif

static void clear_moddir()
{
    struct moddir *entry=moddir_list, *e;
    while(entry)
        {
        e= entry->next;
        GDKfree(entry->path);
        GDKfree(entry);
        entry=e;
        }
}

static void
insert_moddir_entry(const char *name)
{
    struct moddir *last;
    struct moddir *newentry;

    if (!name || !*name)
        return;
    /* printf("inserted dir %s\n",name); */

    newentry = (struct moddir*) GDKmalloc(sizeof(struct moddir));
    newentry->next = 0;

    if ((last = moddir_list) != 0) {
        while (last->next)
            last = last->next;
        last->next = newentry;
    } else
        moddir_list = newentry;

    newentry->path = GDKstrdup(name);
}


static 
void insert_moddir_recursively(char *name) {
    DIR *dirp;
    struct dirent *dent=0;
    char fullname[MAXPATHLEN];

/*    printf("rec %s\n",name); */
    
    if (strlen(name)>2 && !strcmp(&name[strlen(name)-2],"//"))
        name[strlen(name)-2]='\0';
    
    dirp=opendir(name);
    if (!dirp) return;
    rewinddir(dirp);
    insert_moddir_entry(name);
    while((dent=readdir(dirp))!=0)
        {
            if (dent->d_name[0]=='.') continue;
            sprintf(fullname,"%s%c%s",name,DIR_SEP,dent->d_name);
            insert_moddir_recursively(fullname);
        }
    closedir(dirp);
}

static 
void parse_mod_path(void) {
    char *mod_path = GDKstrdup(GDKgetenv("monet_mod_path"));

    if (mod_path){
      size_t pos=0, len=strlen(mod_path);
      char *dirbegin=mod_path;
      do
        {
            while(mod_path[pos]!='\0' && mod_path[pos]!=PATH_SEP) pos++;
            mod_path[pos]='\0';

            if (strlen(dirbegin)>2 && !strcmp(&mod_path[pos-2],"//"))
                insert_moddir_recursively(dirbegin);
            else                    
                insert_moddir_entry(dirbegin);

            if (pos==len) break;
            dirbegin = mod_path + (++pos);
        }
      while(1);
    }
    GDKfree(mod_path);
}

static struct moddir *current_entry=0;
static DIR *dirp=0;

void MSP_rewind_module_list(void) {
    if (!moddir_list) parse_mod_path();
    current_entry=moddir_list;
    if(dirp) closedir(dirp);
    dirp=0;
}
    
#define LIBLEN  3
char *MSP_next_module(char *ext) {
    struct dirent *dent=0;
    char *next_module;

    while(current_entry)
        {
            if (!dirp)
                {
                    dirp=opendir(current_entry->path);
                    if (!dirp)
                        {
                            current_entry=current_entry->next;
                            continue;
                        }
                    rewinddir(dirp);
                }
            while((dent=readdir(dirp))!=0)
                {
                    char *suffix=0;
                    if ((suffix=strstr(dent->d_name,ext))==NULL) continue;
            /*
             * On some platforms (e.g., MacOS X/Mach-O/Darwin), 
             * a library's version number (e.g., ".0"/".0.0.0")
             * is not appended to the suffix, but rather placed
             * between the library's name and suffix; however,
             * we only want to match "lib<name><ext>", here,
             * but not "lib<name><version><ext>":
             */
            if (((suffix-2)>=dent->d_name) &&
                (suffix[-2]=='.')          &&
                (suffix[-1]>='0')&&(suffix[-1]<='9')) continue; 
                    suffix[0]='\0';
                    next_module=(char *)GDKmalloc(strlen(current_entry->path)+
                                               strlen(dent->d_name)+2);
                    sprintf(next_module,"%s%c%s", 
                            current_entry->path, DIR_SEP, dent->d_name);
                    return(next_module);
                }
            current_entry=current_entry->next;
            closedir(dirp);
            
            dirp=0;
        }
    return 0;
}

static char *MSP_libname( char *name ){
    char *libname = (char*)GDKmalloc( strlen(name) + LIBLEN + 1 );
    strcpy(libname, "lib");
    strcpy(libname+LIBLEN, name);
    return libname;
}

char *MSP_locate_module(char *mod_name) {
    char *name = MSP_libname( mod_name ); 
    size_t len = strlen(name);
    size_t fulllen = 0;
    char *next_module,*fullname;
    MSP_rewind_module_list();
    for (;;)
        {
            next_module=MSP_next_module(SO_EXT);
            if (!next_module) break;
        fulllen = strlen(next_module);
            if ( fulllen > len &&
         next_module[fulllen-len-1] == DIR_SEP &&
         !strcmp(&next_module[fulllen-len],name))
                {
            if (!SO_EXT_LEN)
            SO_EXT_LEN = strlen(SO_EXT);
#ifdef _AIX
                    fullname=(char *)GDKmalloc(fulllen+SO_EXT_LEN+1+len+7);
            sprintf(fullname,"%s%s(%s.so.0)",next_module, SO_EXT, name);
#else
                    fullname=(char *)GDKmalloc(fulllen+SO_EXT_LEN+1);
                    sprintf(fullname,"%s%s",next_module, SO_EXT);
#endif
                    GDKfree(next_module);
                    GDKfree(name);
                    return fullname;
                }
        GDKfree(next_module);
        }
    GDKfree(name);
    return 0;
}

@-
In Monet 4. searching the script files associated with modules
was driven  by the list of modules already loaded, because
it contained their full path.
In version 5 the scripts are organized in subdirectories.
@c
#define LANG_EXT ".mal"
#define LANG_LEN 4

char *MSP_locate_script(char *mod_name) {
    char *name =  mod_name; 
    size_t len = strlen(name);
    size_t fulllen = 0;
    char *next_module,*fullname;
    MSP_rewind_module_list();
    for (;;)
        {
            next_module=MSP_next_module(LANG_EXT);
            if (!next_module) break;
        fulllen = strlen(next_module);
            if ( fulllen > len &&
         next_module[fulllen-len-1] == DIR_SEP &&
         !strcmp(&next_module[fulllen-len],name))
                {
                    fullname=(char *)GDKmalloc(fulllen+LANG_LEN+1);
                    sprintf(fullname,"%s%s",next_module, LANG_EXT);
                    GDKfree(next_module);
                    return fullname;
                }
        GDKfree(next_module);
        }
    return 0;
}
char *MSP_locate_scriptVersion4(char *mod_name) {
    int LANG_EXT_LEN = (int) strlen(LANG_EXT);
    char *name = GDKstrdup(mod_name); 
    size_t len = strlen(name);
    size_t fulllen = 0;
    char *next_module,*fullname;
    MSP_rewind_module_list();
    for (;;)
        {
            next_module=MSP_next_module(LANG_EXT);
            if (!next_module) break;
        fulllen = strlen(next_module);
            if ( fulllen > len &&
         next_module[fulllen-len-1] == DIR_SEP &&
         !strcmp(&next_module[fulllen-len],name))
                {
                    fullname=(char *)GDKmalloc(fulllen+LANG_EXT_LEN+1);
                    sprintf(fullname,"%s%s",next_module, LANG_EXT);
                    GDKfree(next_module);
                    GDKfree(name);
                    return fullname;
                }
        GDKfree(next_module);
        }
    GDKfree(name);
    return 0;
}
@}
