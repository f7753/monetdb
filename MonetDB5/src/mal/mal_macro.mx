@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@' 
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@' 
@' The Original Code is the Monet Database System.
@' 
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2004 CWI.
@' All Rights Reserved.

@f mal_macro
@a M. L. Kersten
@+ MAL macro processors
Two MAL optimizers are based on MAL macro expansion and contraction.
The former involves replacing individual instructions by a block of
MAL code.
The latter depicts the inverse operation, a group of instructions
is replaced by a single MAL assignment statement.

The macros structures considered are type-correct MAL functions only,
which means that replacement is not essential from a semantic
point of view. They could have been called, or the block need
not be compressed.

The optimizers form the basis for replacing code fragments.
In particular, it provides a handle to implement peep-hole
based optimization. 
The prototypical test case is the following template:
@example
function joinPath( a:bat[:any$1,:any$2],
                b:bat[:any$2,:any$3],
                c:bat[:any$3,:any4]):bat[:any$1,:any$4];
    z:= join(a,b);
    zz:= join(z,c);
    return zz;
end joinPath;
@end example

The MEoptimizer will hunt for occurrences of the instruction
joinPath() and replaces it with the body, i.e. it in-lines the code.
Conversely,  the MCoptimizer attempts to localize a block
of two join operations and,
when found, it is replaced by the call to joinPath.

The current implementation is limited to finding a consecutive
sequence, ending in a return-statement. The latter is needed to
properly embed the result in the enclosed environment.
It may be extended in the future to consider the flow of control as well.

After both operations the flow of control structure has to be
checked and fort contraction we also have to resolve the new
code, e.g. to bind the new instruction with an implementation.
(Or become part of a macro expansion)

The implementation is based on matching MAL instructions.
The operation malMatch takes two MAL instructions and returns true
if they are equivalent. This means they address the same function,
but also that their variables are isomorphic.
The generalization of malMatch is malFcnMatch, which checks
equivalence of a function body as an occurrence in another one.

The optimizers work on a specific symbol, module or act on all
known symbols.

@- Known issues. 
The functions subject to expansion or contraction should be
checked on 'proper' behavior.

The current implementation is extremely limited. 
The MCoptimizer does not recognize use of intermediate results 
outside the block being contracted. This should be checked and
blocks the replacement, unless the intermediates are part of
the return list.
Likewise, we assume here that the block has a single return
statement, which is also the last one to be executed.

The MEoptimizer can not deal with calls controlled by a barrier.
It would often require a rewrite of several other statements
as well.
Similar, the original target list should be properly merged
with the new block. In particular, the return statement
provides the handle to move the results into the variables
expecting the outcome of the function call.

@{
@+ Implementation section
@h
#ifndef _MAL_MACRO_H_
#define _MAL_MACRO_H_

/* #define DEBUG_MAL_MACRO */

#include "mal.h"
#include "mal_client.h"

mal_export int malMatch(InstrPtr p1, InstrPtr p2);
mal_export int malFcnMatch(MalBlkPtr m1, MalBlkPtr mb, int pc);
mal_export str ORCAMprocessor(MalBlkPtr mb, Symbol t);
mal_export str MACROprocessor(MalBlkPtr mb, Symbol t);
mal_export str QOTMEoptimizerSymbol( MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
mal_export str QOTMEoptimizerModule( MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
mal_export str QOTMEoptimizer( MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
mal_export str QOTMCoptimizerSymbol( MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
mal_export str QOTMCoptimizerModule( MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
mal_export str QOTMCoptimizer( MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
#endif /* _MAL_MACRO_H_ */
@-
@c
#include "mal_macro.h"
#include "mal_interpreter.h"
#include "mal_optimizer.h"
@-
The optimizer hooks are introduced first.
They are refered to from the optimizer module.
@= macroOptimizer
str QOT@1optimizerSymbol( MalBlkPtr mb, MalStkPtr stk, InstrPtr p){
    Scope s;
    Symbol t;
    int j;
    str nme, fcn;

    (void)stk;
    removeInstruction(mb,getPC(mb,p));
    nme= getVarConstant(mb, getArg(p,1)).val.sval;
    fcn= getVarConstant(mb, getArg(p,2)).val.sval;
#ifdef DEBUG_MAL_MACRO
    printf("@1optimizer: %s.%s\n",nme,fcn);
#endif


    s= findModule(mal_scope,nme);
    if (s == 0) s= mal_scope;
    for(; s; s=s->outer)
    if(strcmp(s->name,nme)== 0 && s->subscope){
        j = getSubScope(fcn); 
        for(t= s->subscope[j];t!=NULL;t=t->peer) {
            if( getSignature(t)->token == FUNCTIONsymbol &&
                idcmp(fcn, functionName(getSignature(t)) )==0
                )
                /* call macro expansion */
                @2processor(mb,t);
        }
    }
    chkFlow(mb);
    return MAL_SUCCEED;
}
str QOT@1optimizerModule( MalBlkPtr mb, MalStkPtr stk, InstrPtr p){
    Scope s;
    Symbol t;
    int j;
    str fcn;

    (void) stk; 
    removeInstruction(mb,getPC(mb,p));
    fcn= getVarConstant(mb, getArg(p,1)).val.sval;
    s= findModule(mal_scope,fcn);
#ifdef DEBUG_MAL_MACRO
    printf("@1optimizer: %s\n",fcn);
#endif
    if( s== 0)
        return throwException(MALEXCEPTION,"optimizer.@1optimizer",
            "module '%s' not found\n",fcn);
    if( s->subscope){
        j = getSubScope(fcn); 
        for(t= s->subscope[j];t!=NULL;t=t->peer) {
            if( getSignature(t)->token == FUNCTIONsymbol )
                /* call macro expansion */
                @2processor(mb,t); 
        }
    }
    chkFlow(mb);
    return MAL_SUCCEED;
}
str QOT@1optimizer( MalBlkPtr mb, MalStkPtr stk, InstrPtr p){
    Scope s;
    Symbol t;
    int j;

    removeInstruction(mb,getPC(mb,p));
#ifdef DEBUG_MAL_MACRO
    printf("@1optimizer\n");
#endif
    for(s= mal_scope; s; s=s->outer)
    if( s->subscope){
        for(j=0;j<MAXSCOPE;j++)
        if(s->subscope[j]){
            for(t= s->subscope[j];t!=NULL;t=t->peer) {
                if( getSignature(t)->token == FUNCTIONsymbol )
                    /* call macro expansion */
                    @2processor(mb,t);
            }
        }
    }
    (void) stk; 
    chkFlow(mb);
    return MAL_SUCCEED;
}
@c
@:macroOptimizer(ME,MACRO)@
@:macroOptimizer(MC,ORCAM)@
@c
int malMatch(InstrPtr p1, InstrPtr p2){
int i,j;
    if( functionId(p1) == 0 && functionId(p2)!=0) return 0;
    if( moduleId(p1) == 0 && moduleId(p2)!=0) return 0;
    if( idcmp(moduleName(p1), moduleName(p2)) ) return 0;
    if( idcmp(functionName(p1),functionName(p2)) ) return 0;
    if( p1->retc!= p2->retc) return 0;
    if( p1->argc!= p2->argc) return 0;
    if( p1->barrier != p2->barrier) return 0;
    for(i= 0; i<p1->argc; i++)
    for(j= i+1; j<p1->argc; j++)
    if( (getArg(p1,i) == getArg(p1,j) && getArg(p2,i)!= getArg(p2,j)) ||
        (getArg(p1,i) != getArg(p1,j) && getArg(p2,i)== getArg(p2,j)) )
            return 0;
    return 1;
}
@-
Matching a block calls for building two variable lists used.
The isomorphism can be determined after-wards using a single scan.
The candidate block is matched with mb starting at a given pc.
The candidate block is expected to defined as a function, including
a signature and end-statement. They are ignored in the comparison

Beware, the variables in the block being removed, could be
used furtheron in the program. [tricky to detect, todo]
@c
int malFcnMatch(MalBlkPtr mc, MalBlkPtr mb, int pc){
    int i,j,k,lim;
    int *cvar, *mvar;
    int ctop=0, mtop=0;
    InstrPtr p,q;

    if( mb->stop-pc < mc->stop-2) return 0;

    cvar = (int*) alloca(mc->vtop * MAXARG);
    mvar = (int*) alloca(mb->vtop * MAXARG);
    lim = pc+mc->stop-2;
    k = 1;
    for( i=pc; i< lim; i++,k++){
        p= getInstrPtr(mb,i);
        q= getInstrPtr(mc,k);
        if( malMatch(p,q) ==0 )
            return 0;
        for(j=0;j<p->argc; j++)
            cvar[ctop++] = getArg(p,j);
        for(j=0;j<p->argc; j++)
            mvar[mtop++] = getArg(q,j);
    }
    assert( mtop == ctop); /*shouldn;t happen */
#ifdef DEBUG_MAL_MACRO
    for(i=0;i<ctop; i++)
    printf("match %d %d\n",cvar[i],mvar[i]);
#endif
    for( i=0; i<ctop; i++)
    for( j=i+1; j<ctop; j++)
    if( (cvar[i] == cvar[j] && mvar[i]!= mvar[j])  ||
        (mvar[i] == mvar[j] && cvar[i]!= cvar[j]) )
            return 0;
    return 1;
}
@+ Macro expansions
The macro expansion routine walks through the MAL code block in search
the function to be expanded.  
The macro expansion process is restarted at the first new instruction.
A global is used to protect at (direct) recursive expansions
@c
#define MAXEXPANSION 256

int inlineMALblock(MalBlkPtr mb, int pc, MalBlkPtr mc){
    int i,k,l,n,v;
    InstrPtr *ns,p;
    int *nv;

    ns = GDKmalloc((l = (mb->ssize+mc->ssize-3)) * sizeof(InstrPtr));
    nv= alloca( mc->vtop * sizeof(int));
    p = getInstrPtr(mb,pc);
    v= p->argc-p->retc;
    k=0;

    for(n= 0; n < mc->vtop; n++){
        if( mc->var[n]->isaconstant )
            nv[n]= newConstant(mb,getVarType(mc,n), 
                        GDKstrdup(getVarLiteral(mc,n)),1);
        else
            nv[n]= newTmpVariable(mb, getVarType(mc,n));
        isVarUsed(mb,nv[n]) = isVarUsed(mc,n);
        isVarInitialized(mb,nv[n]) = isVarInitialized(mc,n);
        k++;
    }
    for(n= 1; n<p->argc; n++) nv[n]= getArg(p,n);
#ifdef DEBUG_MAL_MACRO
    for(n=1; n< mc->vtop; n++)
        printf("variable %d %d\n",n,nv[n]);
#endif
    k=0;
    for(i=0; i< pc; i++) ns[k++]= mb->stmt[i];
    for(i=1; i< mc->stop-1; i++) {
        /* copy the instruction and fix variable references */
        p= mc->stmt[i];
        ns[k]= copyInstruction(p);
        for(n=0; n< p->argc; n++){
                /* fix the variable */
#ifdef DEBUG_MAL_MACRO
                    printf("map %d  (%d) ",getArg(p,n),v);
#endif
                if( getArg(p,n) >= v) {
                    getArg(ns[k],n)= nv[getArg(p,n)];
                } else {
                    getArg(ns[k],n)= getArg(mb->stmt[pc],n);
                }
                isVarUsed(mb, getArg(ns[k],n))= 1;
                isVarInitialized(mb,getArg(ns[k],n)) = 1;
        }
#ifdef DEBUG_MAL_MACRO
        printf("\n");
#endif
        k++;
    }
    for(i=pc+1; i< mb->stop; i++) ns[k++]= mb->stmt[i];
    GDKfree(mb->stmt);
    mb->stmt= ns;
    mb->ssize= l;
    mb->stop= k;
    return pc;
}

str MACROprocessor(MalBlkPtr mb, Symbol t){
    InstrPtr q;
    int i, cnt=0,last = -1;
#ifdef DEBUG_MAL_MACRO
    printf("calling the MACRO processor\n");
#endif
    for( i=0; i< mb->stop; i++){
        q= getInstrPtr(mb,i);
        if( functionId(q) &&
            idcmp(functionName(q),t->name)==0){
            if( getSignature(t)->token == FUNCTIONsymbol ||
                getSignature(t)->token == FACTORYsymbol){
#ifdef DEBUG_MAL_MACRO
            printf("Hit, replace macro call %s\n",t->name);
#endif
            if( i == last)
                return throwMessage("optimizer.MACROoptimizer",
                    "duplicate macro expansion");
                
            last= i;
            i= inlineMALblock(mb,i,t->def);
            cnt++;
            if( cnt >MAXEXPANSION )
                return throwMessage("optimizer.MACROoptimizer",
                    "too many macro expansions");
            }
        }
    }
    return MAL_SUCCEED;
}
@}
@+ Macro inversions
Macro inversions map a consecutive sequences of MAL instructions
into a single call. Subsequence resolution will bind it with the proper
function. The pattern being replaced should be a self-standing
assignment. [could be improved]

The function being replaced should assign the result to
the signature variables. Otherwise it will be difficult
to assess which result to retain.
@{
@c
int replaceMALblock(MalBlkPtr mb, int pc, MalBlkPtr mc){
    int i,j,k,lim;
    InstrPtr p,q,rq;
    int *cvar, *mvar;
    int ctop=0, mtop=0;

    /* collect variable map */
    cvar = (int*) alloca(mc->vtop * MAXARG);
    mvar = (int*) alloca(mb->vtop * MAXARG);
    lim = pc+mc->stop-2;
    k = 1;
    for( i=pc; i< lim; i++,k++){
        p= getInstrPtr(mb,i);
        q= getInstrPtr(mc,k);
        for(j=0;j<p->argc; j++)
            cvar[ctop++] = getArg(q,j);
        for(j=0;j<p->argc; j++)
            mvar[mtop++] = getArg(p,j);
    }
    assert( mtop == ctop); /*shouldn;t happen */
#ifdef DEBUG_MAL_MACRO
    for(i=0;i<ctop; i++)
    printf("match %d %d\n",cvar[i],mvar[i]);
#endif

    p = getInstrPtr(mb,pc);
    q = copyInstruction(getInstrPtr(mc,0));  /* the signature */
    q->token = ASSIGNsymbol;
    mb->stmt[pc]= q;
    for(i=q->retc;i<q->argc; i++)
        for(j=0; j<ctop; j++)
        if( q->argv[i] == cvar[j]){
            q->argv[i] = mvar[j];
            break;
        }
    rq= getInstrPtr(mb,mb->stop-2);
    if( rq->token != RETURNsymbol)
        GDKerror("wrong token %d\n",rq->token);
    for(i=0;i<rq->retc; i++)
        for(j=0; j<ctop; j++)
        if( rq->argv[i] == cvar[j]){
            rq->argv[i] = mvar[j];
            break;
        }
    freeInstruction(p);

    /* strip signature, return, and end statements */
    k= mc->stop-3;
    for(i=pc+1; i< pc+k; i++) 
        freeInstruction(mb->stmt[i]);
    for(i=pc+k ; i<mb->stop; i++)
        mb->stmt[i-k+1]= mb->stmt[i];
    for(; i<mb->stop; i++)
        mb->stmt[i]=0;
    mb->stop= i-k;
    return pc;
}

str ORCAMprocessor(MalBlkPtr mb, Symbol t){
    MalBlkPtr mc= t->def;
    int i;
#ifdef DEBUG_MAL_MACRO
    printf("calling the ORCAM processor\n");
#endif
    /* strip signature, return, and end statements */
    for(i=1; i<mb->stop- mc->stop+3; i++)
    if( malFcnMatch(mc,mb,i)){
#ifdef DEBUG_MAL_MACRO
    printf("found match for %s at %d \n",t->name,i);
#endif
        replaceMALblock(mb,i,mc);
    }
    chkProgram(getClient()->nspace,mb);
    return MAL_SUCCEED;
}
@}
