@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@' 
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@' 
@' The Original Code is the Monet Database System.
@' 
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2004 CWI.
@' All Rights Reserved.

@f mal_macro
@a M. L. Kersten
@+ Macro processors
Two MAL optimizers are based on macro expansion and contraction.
The former involves replacing individual instructions by a block of
code.  The latter depicts the inverse operation, a group of instructions
is replaced by a single one.
These optimizers work on a symbol, module or globally and can
be applied to MAL functions and factories only.

The prototypical test case is the following function
@example
function joinPath( a:bat[:any$1,:any$2],
                b:bat[:any$2,:any$3],
                c:bat[:any$3,:any4]):bat[:any$1,:any$4];
    z:= join(a,b);
    zz:= join(z,c);
end joinPath;
@end example

The MEoptimizer will hunt for occurrences of the instruction
joinPath() and replaces it with the body, i.e. it in-lines the code.
Conversely,  the MCoptimizer attempts to localize a block
consisting of two join operations and
when found, it is replaced by the call to joinPath.
The current implementation is limited to finding a consecutive
sequence. It may be extended in the future to consider the
flow of control as well.

The implementation is based on matching MAL patterns.
The operation malMatch takes two MAL instructions and returns true
if they are equivalent. This means they address the same function,
but also that the parameters are isomorphic.

The generalization of malMatch is malFcnMatch, which checks
equivalence of a function body as an occurrence in another one.

@{
@+ Implementation section
@h
#ifndef _MAL_MACRO_H_
#define _MAL_MACRO_H_

#define DEBUG_MAL_MACRO

#include "mal.h"
#include "mal_client.h"

mal_export int malMatch(InstrPtr p1, InstrPtr p2);
mal_export int malFcnMatch(MalBlkPtr m1, MalBlkPtr mb, int pc);
mal_export str ORCAMprocessor(MalBlkPtr mb, Symbol t);
mal_export str MACROprocessor(MalBlkPtr mb, Symbol t);
mal_export str QOTMEoptimizerSymbol( MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
mal_export str QOTMEoptimizerModule( MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
mal_export str QOTMEoptimizer( MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
mal_export str QOTMCoptimizerSymbol( MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
mal_export str QOTMCoptimizerModule( MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
mal_export str QOTMCoptimizer( MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
#endif /* _MAL_MACRO_H_ */
@-
@c
#include "mal_macro.h"
#include "mal_interpreter.h"
#include "mal_optimizer.h"
@-
The optimizer hooks are introduced first.
They are refered to from the optimizer module.
@= macroOptimizer
str QOT@1optimizerSymbol( MalBlkPtr mb, MalStkPtr stk, InstrPtr p){
    Scope s;
    Symbol t;
    int j;
    str nme, fcn;

    (void)stk;
    removeInstruction(mb,getPC(mb,p));
    nme= getVarConstant(mb, getArg(p,1)).val.sval;
    fcn= getVarConstant(mb, getArg(p,2)).val.sval;
#ifdef DEBUG_MAL_MACRO
    printf("@1optimizer: %s.%s\n",nme,fcn);
#endif

    for(s= mal_scope; s; s=s->outer)
    if(strcmp(s->name,nme)== 0 && s->subscope){
        for(j=0;j<MAXSCOPE;j++)
        if(s->subscope[j]){
            for(t= s->subscope[j];t!=NULL;t=t->peer) {
                if( (getSignature(t)->token == FUNCTIONsymbol ||
                    getSignature(t)->token == FACTORYsymbol) &&
                    idcmp(fcn, functionName(getSignature(t)) )==0
                    )
                    /* call macro expansion */
                    @2processor(mb,t);
            }
        }
    }
    chkFlow(mb);
    return MAL_SUCCEED;
}
str QOT@1optimizerModule( MalBlkPtr mb, MalStkPtr stk, InstrPtr p){
    Scope s;
    Symbol t;
    int j;
    str nme;

    (void) stk; 
    removeInstruction(mb,getPC(mb,p));
    nme= getVarConstant(mb, getArg(p,1)).val.sval;
    s= findModule(mal_scope,nme);
#ifdef DEBUG_MAL_MACRO
    printf("@1optimizer: %s\n",nme);
#endif
    if( s== 0)
        return throwException(MALEXCEPTION,"optimizer.@1optimizer",
            "module '%s' not found\n",nme);
    if( s->subscope){
        for(j=0;j<MAXSCOPE;j++)
        if(s->subscope[j]){
            for(t= s->subscope[j];t!=NULL;t=t->peer) {
                if( getSignature(t)->token == FUNCTIONsymbol ||
                    getSignature(t)->token == FACTORYsymbol)
                    /* call macro expansion */
                    @2processor(mb,t); 
            }
        }
    }
    chkFlow(mb);
    return MAL_SUCCEED;
}
str QOT@1optimizer( MalBlkPtr mb, MalStkPtr stk, InstrPtr p){
    Scope s;
    Symbol t;
    int j;

    removeInstruction(mb,getPC(mb,p));
#ifdef DEBUG_MAL_MACRO
    printf("@1optimizer\n");
#endif
    for(s= mal_scope; s; s=s->outer)
    if( s->subscope){
        for(j=0;j<MAXSCOPE;j++)
        if(s->subscope[j]){
            for(t= s->subscope[j];t!=NULL;t=t->peer) {
                if( getSignature(t)->token == FUNCTIONsymbol ||
                    getSignature(t)->token == FACTORYsymbol)
                    /* call macro expansion */
                    @2processor(mb,t);
            }
        }
    }
    (void) stk; 
    chkFlow(mb);
    return MAL_SUCCEED;
}
@c
@:macroOptimizer(ME,MACRO)@
@:macroOptimizer(MC,ORCAM)@
@c
int malMatch(InstrPtr p1, InstrPtr p2){
int i,j;
    if( idcmp(moduleName(p1), moduleName(p2)) ) return 0;
    if( idcmp(functionName(p1),functionName(p2)) ) return 0;
    if( p1->retc!= p2->retc) return 0;
    if( p1->argc!= p2->argc) return 0;
    if( p1->barrier != p2->barrier) return 0;
    for(i= 0; i<p1->argc; i++)
    for(j= i+1; j<p1->argc; j++)
    if( (getArg(p1,i) == getArg(p1,j) && getArg(p2,i)!= getArg(p2,j)) ||
        (getArg(p1,i) != getArg(p1,j) && getArg(p2,i)== getArg(p2,j)) )
            return 0;
    return 1;
}
@-
Matching a block calls for building two variable lists used.
The isomorphism can be determined after-wards using a single scan.
The candidate block is matched with mb starting at a given pc.
The candidate block is expected to defined as a function, including
a signature and end-statement. They are ignored in the comparison
@c
int malFcnMatch(MalBlkPtr candidate, MalBlkPtr mb, int pc){
    int i,j,k,lim;
    int *cvar, *mvar;
    int ctop=0, mtop=0;
    InstrPtr p,q;

    if( mb->stop-pc < candidate->stop-2) return 0;

    cvar = (int*) alloca(candidate->vtop * MAXARG);
    mvar = (int*) alloca(mb->vtop * MAXARG);
    lim = pc+candidate->stop-2;
    k = 1;
    for( i=pc; i< lim; i++,k++){
        p= getInstrPtr(mb,i);
        q= getInstrPtr(candidate,k);
        if( malMatch(p,q) ==0 )
            return 0;
        for(j=0;j<p->argc; j++)
            cvar[ctop++] = getArg(p,j);
        for(j=0;j<p->argc; j++)
            mvar[mtop++] = getArg(q,j);
    }
    assert( mtop == ctop); /*shouldn;t happen */
#ifdef DEBUG_MAL_MACRO
    for(i=0;i<ctop; i++)
    printf("match %d %d\n",cvar[i],mvar[i]);
#endif
    for( i=0; i<ctop; i++)
    for( j=i+1; j<ctop; j++)
    if( (cvar[i] == cvar[j] && mvar[i]!= mvar[j])  ||
        (mvar[i] == mvar[j] && cvar[i]!= cvar[j]) )
            return 0;
    return 1;
}
@+ Macro expansions
The macro expansion routine walks through the MAL code block in search
the function to be expanded.  
The macro expansion process is restarted at the first new instruction.
A global is used to protect at (direct) recursive expansions
@c
#define MAXEXPANSION 256

int inlineMALblock(MalBlkPtr mb, int pc, MalBlkPtr mc, int first, int last){
    int i,k,l,n,v;
    InstrPtr *ns,p;
    int *nv;

    ns = GDKmalloc((l = (mb->ssize+mc->ssize-3)) * sizeof(InstrPtr));
    nv= GDKmalloc( mc->vtop * sizeof(int));
    p = getInstrPtr(mb,pc);
    v= p->argc-p->retc;
    k=0;

    for(n= p->argc-p->retc; n < mc->vtop; n++){
        if( mc->var[n]->isaconstant )
            nv[n]= newConstant(mb,getVarType(mc,n), 
                        GDKstrdup(getVarLiteral(mc,n)),1);
        else
            nv[n]= newTmpVariable(mb, getVarType(mc,n));
        isVarUsed(mb,nv[n]) = isVarUsed(mc,n);
        isVarInitialized(mb,nv[n]) = isVarInitialized(mc,n);
        k++;
    }
    for(n= 1; n<p->argc; n++) nv[n]= getArg(p,n);
#ifdef DEBUG_MAL_MACRO
    for(n=1; n< mc->vtop; n++)
        printf("variable %d %d\n",n,nv[n]);
#endif
    k=0;
    for(i=0; i< pc; i++) ns[k++]= mb->stmt[i];
    for(i=first; i< last; i++) {
        /* copy the instruction and fix variable references */
        p= mc->stmt[i];
        ns[k]= copyInstruction(p);
        for(n=0; n< p->argc; n++){
                /* fix the variable */
#ifdef DEBUG_MAL_MACRO
                    printf("map %d  (%d) ",getArg(p,n),v);
#endif
                if( getArg(p,n) >= v) {
                    getArg(ns[k],n)= nv[getArg(p,n)];
                } else {
                    getArg(ns[k],n)= getArg(mb->stmt[pc],n);
                }
                isVarUsed(mb, getArg(ns[k],n))= 1;
                isVarInitialized(mb,getArg(ns[k],n)) = 1;
        }
#ifdef DEBUG_MAL_MACRO
        printf("\n");
#endif
        k++;
    }
    for(i=pc+1; i< mb->stop; i++) ns[k++]= mb->stmt[i];
    GDKfree(nv);
    GDKfree(mb->stmt);
    mb->stmt= ns;
    mb->ssize= l;
    mb->stop= k;
    return pc;
}

str MACROprocessor(MalBlkPtr mb, Symbol t){
    InstrPtr q;
    int i, cnt=0,last = -1;
#ifdef DEBUG_MAL_MACRO
    printf("calling the MACRO processor\n");
#endif
    for( i=0; i< mb->stop; i++){
        q= getInstrPtr(mb,i);
        if( functionId(q) &&
            idcmp(functionName(q),t->name)==0){
            if( getSignature(t)->token == FUNCTIONsymbol ||
                getSignature(t)->token == FACTORYsymbol){
#ifdef DEBUG_MAL_MACRO
            printf("Hit, replace macro call %s\n",t->name);
#endif
            if( i == last)
                return throwMessage("optimizer.MACROoptimizer",
                    "duplicate macro expansion");
                
            last= i;
            i= inlineMALblock(mb,i,t->def,1,t->def->stop-1);
            cnt++;
            if( cnt >MAXEXPANSION )
                return throwMessage("optimizer.MACROoptimizer",
                    "too many macro expansions");
            }
        }
    }
    return MAL_SUCCEED;
}
@}
@+ Macro inversions
Macro inversions map a consecutive sequences of MAL instructions
into a single call. Subsequence resolution will bind it with the proper
function.
@{
@c
str ORCAMprocessor(MalBlkPtr mb, Symbol t){
    MalBlkPtr mc= t->def;
    int i;
    InstrPtr p;
#ifdef DEBUG_MAL_MACRO
    printf("calling the ORCAM processor\n");
#endif
    for(i=1; i<mb->stop- mc->stop+2; i++)
    if( malFcnMatch(mc,mb,i)){
#ifdef DEBUG_MAL_MACRO
    printf("found match for %s at %d \n",t->name,i);
#endif
        removeInstructionBlock(mb,i,mc->stop-2);
        p= newInstruction(ASSIGNsymbol);
        getArg(p,0) = 0;
        insertInstruction(mb, p,i);
        inlineMALblock(mb,i,mc,0,1);
        p= getInstrPtr(mb,i);
        p->token= ASSIGNsymbol;
    }
    chkFlow(mb);
    return MAL_SUCCEED;
}
@}
