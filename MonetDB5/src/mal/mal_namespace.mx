@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2005 CWI.
@' All Rights Reserved.

@a M.L. Kersten
@* MAL name space.
A separate namespace organisation seems in place for module and function
names. The number of such names managed by the MAL engine 
is expected to be rather limited except for those generated on 
the fly to represent temporaries functions.
Variables are always stored local to the MAL block in which they
are used.
@-
We can gain speed at type resolution and during the optimization phases 
when each identifier is replaced by a fixed length internal identifier,
i.e. an integer. 
Translation from/to their string is needed only in limited places, e.g.
input output.
@-
The namespace manager is organized as a shared table. The alternative
considered would be a namespace per client. However, this would force
passing around the client identity or an expensive operation to deduce
this from the process id. The price paid is that updates to the namespace
should be protected against concurrent access.
@{
@h
#ifndef _MAL_NAMESPACE_H
#define _MAL_NAMESPACE_H

mal_export void initNamespace();
mal_export void finishNamespace();
mal_export str getName(int nid);
mal_export int putName(str nme,int len);
mal_export void dumpNamespaceStatistics(stream *f, int details);

#endif /* _MAL_NAMESPACE_H */
@+ Code bodies
The Namespace block is organized using a simple hashstructure over the first
character. Better structures can be introduced when searching becomes
too expensive. An alternative would be to use a BAT to handle the collection.
@c
#include "mal_type.h"
#include "mal_namespace.h"
#define MAXIDENTIFIERS 1024

typedef struct NAMESPACE{
    int  size;  /* amount of space available */
    int  nmetop;
    str  *nme;
    int  *link;
    int  *hit;
} Namespace;

static Namespace namespace;

static void expandNamespace(int incr){
    str *nme;
    int *link, *hit;

    if(incr < 0){
        GDKwarning("expandNamespace:illegal increment\n");
        return;
    }
    if(namespace.size+incr > 32000){
        GDKwarning("Namespace becomes too large\n");
    }

    nme= (str *) GDKmalloc(sizeof(str *) * namespace.nmetop+incr);
    link= (int *) GDKmalloc(sizeof(int) * namespace.nmetop+incr);
    hit = (int *) GDKmalloc(sizeof(int) * namespace.nmetop+incr);
    memcpy(nme, namespace.nme, sizeof(str *) * namespace.nmetop);
    memcpy(link, namespace.link, sizeof(int) * namespace.nmetop);
    memcpy(hit, namespace.hit, sizeof(int) * namespace.nmetop);

    namespace.size += incr;
    namespace.nmetop+= incr;
    GDKfree(namespace.nme); namespace.nme= nme;
    GDKfree(namespace.link); namespace.link= link;

}
void initNamespace() {
    namespace.nme= (str *) GDKmalloc(sizeof(str *) * MAXIDENTIFIERS);
    namespace.link= (int *) GDKmalloc(sizeof(int) * MAXIDENTIFIERS);
    namespace.hit= (int *) GDKmalloc(sizeof(int) * MAXIDENTIFIERS);
    namespace.size = MAXIDENTIFIERS;
    namespace.nmetop= 256; /* hash overflow */
}
void finishNamespace() {
    GDKfree(namespace.nme);
    GDKfree(namespace.link);
    GDKfree(namespace.hit);
}
@-
The function getName returns the pointer to the identifier representation.
This reference may not be freed. Temporary names are materialized upon need
only.
@c
str getName(int nid) { return namespace.nme[nid]; }
@-
Before a name is being stored we should check for its occurrence first.
The administration is initialized incrementally.
@c
int putName(str nme, int len)
{
    int l= nme[0];
	char buf[1024];

	if( len >= 1022) return 0;
	strncpy(buf,nme,len);
	buf[len]=0;
    
    if( namespace.nme[l]== 0){
        namespace.nme[l]= GDKstrdup(buf);
        namespace.link[l]= 0;
        namespace.hit[l]= 0;
        return l;
    }
    for(l= namespace.link[l]; l; l= namespace.link[l]){
        if(idcmp(nme,namespace.nme[l])==0) {
            namespace.hit[l]++;
            return l;
        }
    }
    if( namespace.nmetop+1== namespace.size)
        expandNamespace(MAXIDENTIFIERS);
	l= nme[0];
    namespace.nme[namespace.nmetop]= GDKstrdup(buf);
    namespace.link[namespace.nmetop]= namespace.link[l];
	namespace.link[l]= namespace.nmetop;
    namespace.hit[namespace.nmetop]= 0;
    namespace.nmetop++;
    return namespace.nmetop-1;
}
@-
The routine parseName takes a reference to a string and attempts
to decode it as an identifier or operator. If successful, it is stored in the
namespace table. The number of characters forming the identifier
is returned. This routine is primarilly used by the parser.

The namespace may become a bottleneck when the chain of identifiers grows.
This issue can be tackled from two angles. Either we change the hash function
using multiple characters of the identifier or we sort the identifiers list
using the actual hits reported so far. The field hit keeps track of this
crucial information. The choice on the way to move forward is postponed.
@c
void dumpNamespaceStatistics(stream *f, int details)
{
    int i,l,cnt;

    stream_printf(f,"Namespace statistics\n");
    stream_printf(f,"nmetop = %d size= %d\n",
        namespace.nmetop, namespace.size);
    for(i=0;i<256; i++){
        cnt =0;
        stream_printf(f,"list %d ",i);
        for(l= i; l; l= namespace.link[l]){
            cnt++;
            if(details) {
                stream_printf(f,"(%s %d) ",
                namespace.nme[l], namespace.hit[l]);
                if( i+1 % 5 == 0) stream_printf(f,"\n");
            }
        }
        if(cnt)  stream_printf(f," has %d elements",cnt);
    }
}
@}
