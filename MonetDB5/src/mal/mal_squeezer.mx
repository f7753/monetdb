@t MAL squeezer code
@a M. Kersten
@v 0.0
@* Introduction

This module contains the framework for inclusion of squeezer code, i.e.
C-programs geared at optimizing a piece of MAL.
The squeezer appears at the language level as an ordinary module.
Each squeezer function has access to the runtime scope of the
routine in which it is called. This can be used to maintain status
information between successive calls. For example, constantpropagation
within a block should be done once. This can be realized by either
dropping the call squeezer.constantpropagation() from the optimized
code or to maintain a runtime boolean checked upon calling this
squeezer.

Beware, a squeezer has global effect. All concurrent
users will see/use the transformed MAL program.
A more refined policy, i.e. a per user approach, calls for duplication
of the built-in modules. A solution is to introduce wrapper-like
modules for users where appropriate

A squeezer implementation should not change the content of the symbol
table, nor the original instruction sequence. This is necessary to
enable alternative variations of the code to be derived during a session,
without the need to re-parse the program definition.

A squeezer call appears at the language level as a PATTERN call,
which passes control over the interpretation to the squeezer body.

The first implementation contains the sqzPrepare(), sqzAccess(),
and sqzConstantPropagate() routines. 
The former merely prepares a copy of the instruction list
and helps to assess the infrastructure for calling the squeezer.
The function sqzAccess() implements a simple access control scheme
where an authorization instruction is injected in the stream,
before the variable is used or assigned to. 

All examples are meant to help identifying the API for squeezer construction.

@h
#ifndef _MAL_SQUEEZE_H
/*
 * The contents of this file are subject to the Monet Public
 * License Version 1.1 (the "License"); you may not use this file
 * except in compliance with the License. You may obtain a copy of
 * the License at
 * http://www.monetsolutions.com/Download/Licensing/MonetPL-1.1.html
 * 
 * Software distributed under the License is distributed on an "AS
 * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
 * implied. See the License for the specific language governing
 * rights and limitations under the License.
 * 
 * The Original Code is the Monet Database System.
 * 
 * The Initial Developer of the Original Code is CWI.
 * Portions created by CWI are Copyright (C) 1997-2001 CWI.  
 * All Rights Reserved.
 * 
 * Contributor(s): Martin Kersten <Martin.Kersten@cwi.nl>
 */

#define _MAL_SQUEEZE_H

#include "mal_stack.h"
#include "mal_instruction.h"
#include "mal_resolve.h"

#define DEBUG_MAL_SQUEEZER 1
mal_export ptr getArgValue(MalStkPtr stk, InstrPtr pci, int k);
mal_export ptr getArgReference(MalStkPtr stk, InstrPtr pci, int k);

#endif /*  _MAL_SQUEEZE_H*/

@+ Pattern analysis
Patterns analysis routines need handy functions to obtain the
argument values. Note that the garbage collection  for return
arguments should be handled by the pattern implementation.
(see keepBAT,keepString,releaseBAT,releaseString)
@c
#include "mal_squeezer.h"
#include "mal_resolve.h"
#include "mal_client.h"

ptr getArgValue(MalStkPtr stk, InstrPtr pci, int k){
	int j=0;
	ValRecord *v;
	ptr val = NULL;

	j = pci->argv[k];
	v= &stk->stk[j];
	switch(ATOMstorage(v->vtype)){
	case TYPE_void: val= (ptr) & v->val.ival; break;
	case TYPE_bit: val= (ptr) & v->val.cval[0]; break;
	case TYPE_chr: val= (ptr) & v->val.cval[0]; break;
	case TYPE_sht: val= (ptr) & v->val.shval; break;
	case TYPE_bat: val= (ptr) & v->val.br.id; break;
	case TYPE_int: val= (ptr) & v->val.ival; break;
	case TYPE_oid: val= (ptr) & v->val.oval; break;
	case TYPE_ptr: val= (ptr) v->val.pval; break;	/* !! */
	case TYPE_flt: val= (ptr) & v->val.fval; break;
	case TYPE_dbl: val= (ptr) & v->val.dval; break;
	case TYPE_lng: val= (ptr) & v->val.lval; break;
	case TYPE_str: val= (ptr) v->val.sval; break;	/* !! */
	default:
		val= (ptr) v->val.pval; 
/*		GDKerror("evalParameters:unknown value type\n");*/
	}
	return val;
} 
@-
Alternatively, the routines can obtain a reference to a particular
value. This particularly handy for the squeezers, while the former
is mostly used to prepare a call to the linked libraries.

@c
INLINE
ptr getArgReference(MalStkPtr stk, InstrPtr pci, int k){
#ifdef STRUCT_ALIGNED
	return (ptr) & stk->stk[pci->argv[k]].val.ival;
#else
	int j=0;
	ValRecord *v=0;
	ptr ret = NULL;

	j = pci->argv[k];
	v= &stk->stk[j];

	switch(ATOMstorage(v->vtype)){
	case TYPE_void: ret= (ptr) & v->val.ival; break;
	case TYPE_bit: ret= (ptr) & v->val.cval[0]; break;
	case TYPE_chr: ret= (ptr) & v->val.cval[0]; break;
	case TYPE_sht: ret= (ptr) & v->val.shval; break;
	case TYPE_bat: ret= (ptr) & v->val.br.id; break;
	case TYPE_int: ret= (ptr) & v->val.ival; break;
	case TYPE_oid: ret= (ptr) & v->val.oval; break;
	case TYPE_ptr: ret= (ptr) & v->val.pval; break;
	case TYPE_flt: ret= (ptr) & v->val.fval; break;
	case TYPE_dbl: ret= (ptr) & v->val.dval; break;
	case TYPE_lng: ret= (ptr) & v->val.lval; break;
	case TYPE_str: ret= (ptr) & v->val.sval; break;
	default:
		 ret= (ptr) & v->val.pval; 
		/* GDKerror("eretParameters:unknown value type\n");*/
	}
	return ret;
#endif
} 
@-
The sqzPrepare function simple copies the procedure definition
sequence to the optimized version, leaving out the call to the
squeezer itself. Beware, calling a squeezer to manipulate the code
base should respect the integrity of the runtime information,
such as the program counter.

@= initSqueezes
	int i,lim,top,ssize, stkpc;	
	InstrPtr *new;
@-
@= prepareSqueeze
	lim = getPrgSize(m);
	top = 0;
	stkpc= getPC(m,p);
	ssize= m->ssize+ @1*sizeof(InstrPtr);
	new = (InstrPtr*) GDKmalloc(ssize);
	if( new == NULL)
                GDKfatal("sqzPrepare:could not allocate space\n");
@-
After the new instruction sequence has been constructed, we
can update the administration of the MAL block.

@= finalizeSqueeze
	if( new != NULL){
		GDKfree(m->stmt);
		m->stmt= new;
		m->stop= top;
		m->ssize= ssize;
	}
#ifdef DEBUG_MAL_SQUEEZER
	printf("Modified stmt sequence\n");
	printFunction(stdout,m);
#endif
@-
@= assertSqueeze
	if( top== ssize){
		GDKerror("sqzPrepare:need more space");
		GDKfree(new);
		new = NULL;
		break;
	}
@-
The squeezer does not use argument values from the instruction itself.
@c

str sqzPrepare(MalBlkPtr m, MalStkPtr s, InstrPtr p){
	@:initSqueezes@
	@:prepareSqueeze(0)@

	for(i=0;i<lim;i++){
		if( i!= stkpc)
			new[top++]= m->stmt[i];
		@:assertSqueeze@
	}
	@:finalizeSqueeze@
	return GDKstrdup("redo statement");
}
@+ Access control 
A simple squeezer action is to perform static access control, such
as blocking use of a function, a function on a specific operand,
and access to a specific table. It retract itself after modifying
the remainder of the sequence.

In the example below, use of a particular integer variable (indicated by
its symbol table entry number) is potentially blocked.
Before access is granted, an authorization is performed and
an exception is raised when the variable is < 0.
The statement is appended to the instruction block.
Note that it is up to the implementor to assure that the value pointers
are interpreted correctly.
@c

str sqzAccess(MalBlkPtr m, MalStkPtr s, InstrPtr p){
	@:initSqueezes@
	str nme ;
	int j,symid;
	InstrPtr pp, newstmt;

	nme = (str) getArgValue(s,p,1);
	symid= findVariable(m,nme);
	printf("entering sqzAccess blocking %d %s\n",symid,nme);
	@:prepareSqueeze(10)@
	for(i=0;i<stkpc;i++)
		new[top++]= m->stmt[i];
	for(i=stkpc+1;i<lim;i++){
		pp= getInstrPtr(m,i);
		for(j=0;j<pp->argc;j++)
		if( pp->argv[j]== symid){
			/* insert blocking statement */
printInstruction(stdout,m,p);
			newstmt= newCall("squeezer","AccessTst",ASSIGNsymbol);
			setReturnArgument(newstmt, newTmpVariable(m,TYPE_int));
			pushArgument(m,newstmt, symid);
			pushInstruction(m,newstmt); /* add to block */
			typeChecker(getClient()->nspace,m,newstmt, TYPE_FIXED);
			/*watch out for overflow , to do!*/
printInstruction(stdout,m,newstmt);
			new[top++]= m->stmt[m->stop-1];
		}
		/*watch out for overflow , to do!*/
		new[top++]= m->stmt[i];
		@:assertSqueeze@
	}
	@:finalizeSqueeze@
	return NULL;
}
str sqzAccessTst(void *res, int *v0){
	printf("Entering AccessTst with argument %d\n",*v0);
	if( *v0 <0) 
	return raiseException(0,0,"IllegalAccess","something is wrong");
	return NULL; /* No exception */
}
