@t MAL object management
@a M.L. Kersten
@* MAL object management
The key objects managed by Monet are the persistent BATs, which
call for an efficient scheme to make them accessible for manipulation
in the MAL procedures taking into account a possibly hostile
parallel access.

Most kernel routines produce BATs as a result, which will be referenced 
from the runtime stack. They should be garbage collected as soon as
deemed possible to free-up space. By default, temporary results are
garbage collected before returning from a MAL function.

Furthermore, clients sessions often come with a global scope of
variable settings, which are garbage collected only at the end
of a session. Access to these global variables should be easy,
but they should also provide protection against concurrent update
when the client wishes to perform parallel processing.

Finally, databases, languages, etc. may define constants and variables
accessible to all hierarchical related clients.

The approach taken is to rely on the concept of object spaces
as pioniered in Lynda and -later- JavaSpaces.

The (short) concept name introduced in Monet is the 'box',
which acts as a container for objects. In particular,
every module scope comes with a box of objects to store
constants, global variables, etc., provided it contains
an implementation of the box interface.

Before a client can interact with a box of objects, it
should open it, possibly passing qualifying authorization
information and parameters to instruct the box-manager
of the intended use.

At the end of a session, the box should be closed. Some box-managers
may implement a lease-scheme to automatically close interaction
with a client when the lease runs out.

A box can be extended with a new object using the function
deposit(nme:str,v:any). The basic implementation silently
accepts any new definition of the box.

A local copy of an object can be obtained using the
pattern 'take(nme:str):any', where 'nme' denotes the object
of interest. The type of the receiving variable should
match the one known for the object.

The object is given back to the box manager calling 'release(nme:str)'
or 'release(nme:str,newval:any)'.
It may update the content of the repository accordingly, release locks,
and move the value to persistent store. Whatever the semantics
of the box requires. [The default implementation is a no-op]

Finally, the object manager can be requested to 'discard(nme:str)'
an object completely.  The default implementation is to reclaim
the space in the box, which may affect the visibiltiy of the box's content
when it is concurrently used in an iterator.

Upon need, a user can extend the functionality of a box by provision
of additional functions.
Concurrency control, replication services, as well as access
to remote stores may be delegated to a box manager.
Depending on the intended semantics, the box manager
may keep track of the clients holding links to this members, 
provide a traditional 2-phase
locking scheme, optimistic control, or check-out/check-in scheme.
In all cases, these management issues are transparant to the
main thread (=client) of control, which operates on a temporary
snapshot. For the time being we realize the managers as critical
code sections, i.e. one client is permitted access to the space
at a time.

Example: consider the client function:
@T
function myfcn():void;
	b:bat[oid,int] := bbp.take("mytable");
	c:bat[int,str] := sql.take("person","age");
	d:= intersect(b,c);
	print(d);
	u:str:= client.take("user");
	print(u);
	client.release("user");
end function;
@-
The function obtains a copy from the local persistent bat space,
much like bat-names are resolved under MIL semantics. The second
statement uses the default schema to resolve the location of a
column. The result bat 'd' is temporary and disappears upon garbage
collection. The variable 'u' is looked up as the string object user.

Note that bats b and c need be released at some point. In general
this point in time does not coincide with a computational boundary
like return of a function. During a session, several bats may be taken
out of the box, being processed, and only at the end of a session 
being released. In this example, it means that the reference to
b and c is lost at the end of the function (due to garbarge collection)
and that subsequent use requires another take() call.

The type parameters in the target variable of take() enable early type checking
Failure to find a properly typed object leads to an exception.
The type indicator for a take instruction may be ommitted, but
this defers type resolution to execution time, where the type manager
is called for each unresolved statement.

Possible extensions for the box technique is
to introduce e.g. xml.take() which converts an XML document to a BAT,
jpeg.take() similer for an image.

@+ Inheritance.
Nesting boxes (like Russian dolls) is possible. It provides a simple
inheritance scheme between boxes, but in general will interfere with
the semantics of each box. Therefore, nesting should be handled explicitly.

@+ Session box
The code base introduced here provides a reference case and
the building blocks for more advanced box management schemes.

Aside from box associated with the modules, they can also be created
dynamically on behalf of a client. Such boxes are considered private
and require access by name parameter. 
At the end of a session they are closed, which means that they are
saved in persistent store until the next session starts.
For example:
@T
function m():void;
	box.open("client_name");
	box.deposit("client_name","pi",3.417:flt);
	f:flt := box.take("client_name","pi");
	print(t);
	box.close("client_name");
end function;

Every client has a private session scope, which also provides an object box.
In the namespace it is placed subordinate to any space introduced by the
system administrator. It will contain global client data, e.g.
user, language, database, port, and any other session parameter.

The boxes are all collected in the context of the database directory,
i.e. the directory <dbfarm>/box
@h
/*
 * The contents of this file are subject to the Monet Public
 * License Version 1.1 (the "License"); you may not use this file
 * except in compliance with the License. You may obtain a copy of
 * the License at 
 * http://monetdb.cwi.nl/Legal/MonetDBPL-1.0.html
 * 
 * Software distributed under the License is distributed on an "AS
 * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
 * implied. See the License for the specific language governing
 * rights and limitations under the License.
 * 
 * The Original Code is the Monet Database System.
 * 
 * The Initial Developer of the Original Code is CWI.
 * Portions created by CWI are Copyright (C) 1997-2001 CWI.  
 * All Rights Reserved.
 * 
 * Contributor(s): Martin Kersten <Martin.Kersten@cwi.nl>
 */

#ifndef _MAL_BOX_H
#define _MAL_BOX_H
#include "mal_stack.h"
#include "mal_instruction.h"

/*#define DEBUG_MAL_BOX */

typedef struct BOX{        
        MT_Lock lock;     /* provide exclusive access */
	str	name;
        MalBlkPtr sym;		
        MalStkPtr val;
} *Box, BoxRecord;

mal_export Box newBox(str name);
mal_export Box findBox(str name);
mal_export Box openBox(str name);
mal_export int closeBox(str name,int flag);
mal_export void destroyBox(str name);
mal_export str boxFileName(Box box, str extension);
mal_export int saveBox(Box box,int flag);
mal_export void loadBox(str nme);
mal_export int releaseAllBox(Box box);

mal_export int depositBox(Box box, str name, ValPtr val);
mal_export void insertToBox(Box box, str name, str val);
mal_export int takeBox(Box box, str name, ValPtr val);
mal_export int bindBAT(Box box, str name, str location);
mal_export int releaseBox(Box box, str name);
mal_export int discardBox(Box box, str name);
mal_export str getBoxName(Box box, lng i);
mal_export str toString(Box box, lng i);
mal_export int nextBoxElement(Box box, lng *cursor, ValPtr v);

mal_export void printSomeBox(stream *fd, int k);
mal_export void printBox(stream *fd, Box obj);
mal_export void freeBoxes();
#endif /* _MAL_BOX_H */
@-
The hierarchy of object spaces ends at the root of the tree.
This is a dummy element and should contain system-wide objects
only.
@= newBOX
	obj= (Box) GDKmalloc(sizeof(BoxRecord));
	bzero((char*) obj, sizeof(BoxRecord));
	obj->name= GDKstrdup(name);
	obj->sym=  newMalBlk(MAXVARS,MAXSTMTS);
	obj->val = newGlobalStack(MAXVARS);
	obj->lock= MT_create_lock();
@-
@c
#include "mal_box.h"
#include "mal_interpreter.h"	/* for garbageCollector() & garbageElement() */
#include "mal_client.h"		/* for getClient() */
#include "mal_debugger.h"	/* for printStack() */
#include "mal_import.h"		/* for malImport() */

#define MAXSPACES 64	/* >MAXCLIENTS+ max modules !! */
Box box[MAXSPACES];

Box newBox(str name){
	Box obj= 0;
	int i;
        MT_set_lock(mal_contextLock, "newBox");
#ifdef DEBUG_MAL_BOX
	stream_printf(GDKout,"create new box '%s'\n",name);
#endif
	for(i=0; i<MAXSPACES; i++)
	if( box[i]!= NULL && idcmp(name,box[i]->name)==0) {
		MT_unset_lock(mal_contextLock, "newBox");
		GDKwarning("newBox:duplicate box definition\n");
		return box[i];
	}
	for(i=0; i<MAXSPACES; i++)
	if( box[i]== NULL) {
		@:newBOX@
		box[i]= obj;
		break;
	}
        MT_unset_lock(mal_contextLock, "newBox");
	if( i== MAXSPACES)
		GDKerror("too many boxes\n");
#ifdef DEBUG_MAL_BOX
	stream_printf(GDKout,"succeeded at %d\n",i);
#endif
	return obj;

}
void freeBoxes(){
	int i;
	for(i=0;i<MAXSPACES;i++)
	if( box[i]){
		garbageCollector(box[i]->sym, box[i]->val, TRUE);
		GDKfree(box[i]->name);
		freeMalBlk(box[i]->sym);
		GDKfree(box[i]->val);
		GDKfree(box[i]);
		box[i]=0;
	}
}

Box findBox(str name){
	int i;
        MT_set_lock(mal_contextLock, "findBox");

	for(i=0; i<MAXSPACES; i++)
	if( box[i]!= NULL && idcmp(name,box[i]->name)==0) {
#ifdef DEBUG_MAL_BOX
		stream_printf(GDKout,"found the box '%s' %d\n",name,i);
#endif
		MT_unset_lock(mal_contextLock, "findBox");
		return box[i];
	}
        MT_unset_lock(mal_contextLock, "findBox");
#ifdef DEBUG_MAL_BOX
	stream_printf(GDKout,"could not find the box '%s' \n",name);
#endif
	return 0;

}
Box openBox(str name){
	Box box = findBox(name);
	if( box ) return box;
	box = newBox(name);
	loadBox(name);
	return box;
}
int closeBox(str name ,int flag){
	Box box;
	flag= 0; /* fool the compiler */
	if( (box=findBox(name))){
		saveBox(box,flag);
		return 0;
	}
	return -1;
}
void destroyBox(str name){
	int i,j;
	str boxfile;

        MT_set_lock(mal_contextLock, "destroyBox");
	for(i=j=0;i<MAXSPACES;i++){
		if( idcmp(box[j]->name,name) == 0){
			free(box[i]->name);
			freeMalBlk(box[i]->sym);
			freeStack(box[i]->val);
			boxfile= boxFileName(box[i],0);
			unlink(boxfile);
			GDKfree(boxfile); 
		} else box[i] = box[j++];
	}
        MT_unset_lock(mal_contextLock, "destroyBox");

}
@+ Operations
The deposit operation silently accepts any request to store
an element.
@c
int depositBox(Box box, str name, ValPtr val){
	int i;
	ValPtr v;
	i= findVariable(box->sym, name);
	if( i<0){
		i= newVariable(box->sym,GDKstrdup(name),val->vtype);
		chkStack(box->val,i);
	}
	v= &box->val->stk[i];
	box->val->stktop++;
	VALcopy(v,val);
#ifdef DEBUG_MAL_BOX
	stream_printf(GDKout,"depositBox: entered '%s' at %d type %d\n",
		name,i,v->vtype);
#endif
	return 0;
}
void insertToBox(Box box, str nme, str val){
        ValRecord vr;
        vr.vtype= TYPE_str;
        vr.val.pval= val;
        depositBox(box,nme,&vr);
}

@-
Taking an element from a box is only permitted if the type of
the receiver matches the type of the source.
@c
int takeBox(Box box, str name, ValPtr val){
	int i;
	ValPtr v;
	i= findVariable(box->sym, name);
#ifdef DEBUG_MAL_BOX
		stream_printf(GDKout,"takeBox: found '%s' at %d\n",name,i);
#endif
	if( i<0) return i;
	v= &box->val->stk[i];
	if(val->vtype != v->vtype && v->vtype!= TYPE_any){
#ifdef DEBUG_MAL_BOX
	stream_printf(GDKout,"takeBox:type error %d,%d\n",
			val->vtype,box->val->stk[i].vtype);
#endif
		return -1;
	}
	VALcopy(val, &box->val->stk[i]);
	if( val->vtype == TYPE_bat){
		if(val->val.bval)
			BBPdecref(val->val.bval,FALSE);
		else return -1;
	}
#ifdef DEBUG_MAL_BOX
	stream_printf(GDKout,"takeBox:'%s' from '%s'\n",name,box->name);
#endif
	return 0;
}

@-
The function bindBAT relates a logical BAT name with a physical
representation. The bind commands are typically found in the boxes,
which provide users a partial view over the BAT storage area.
That is, all bats bound can be taken out of the box upon need.
A variable can be rebound to another BAT at any time.
@c
int bindBAT(Box box, str name, str location){
	int i;
	ValPtr v;
	i= findVariable(box->sym, name);
	if( i<0) i= newVariable(box->sym,GDKstrdup(name),TYPE_any);
	v= &box->val->stk[i];
	v->val.br.id = BBPindex(location);
	if( v->val.br.id == 0) return -1;
	v->vtype= TYPE_bat;
#ifdef DEBUG_MAL_BOX
	stream_printf(GDKout,"bindBox:'%s' to '%s' [%d] in '%s'\n",
		name,location,v->val.br.id,box->name);
#endif
	return 0;
}

int releaseBox(Box box, str name){
	int i;

#ifdef DEBUG_MAL_BOX
	stream_printf(GDKout,"releaseBox:%s from %s\n",name,box->name);
#endif
	i= findVariable(box->sym,name);
	if( i<0) return i;
	return 0;
}

int releaseAllBox(Box box){
#ifdef DEBUG_MAL_BOX
	stream_printf(GDKout,"releaseAllBox:%s \n",box->name);
#else
	(void) box;
#endif
	return 0;
}

int discardBox(Box box, str name){
	int i,j;
#ifdef DEBUG_MAL_BOX
	stream_printf(GDKout,"discardBox:%s from %s\n",name,box->name);
#endif
	i= findVariable(box->sym,name);
	if( i<0) return i;
	garbageElement(&box->val->stk[i]);
	for(j=i;j< box->sym->vtop-2;j++){
		box->sym->var[j] = box->sym->var[j+1];
		VALcopy(&box->val->stk[j], &box->val->stk[j+1]);
	}
	box->sym->vtop--;
	box->val->stktop--;
	return 0;
}
@+
The elements can be obtained using iterator, which returns the name
of the next element in the box.
@c
int nextBoxElement(Box box, lng *cursor, ValPtr v){
	if( *cursor >= box->sym->vtop){
		*cursor = 0;
		return 0;
	}
        garbageElement(v);
	v->vtype= TYPE_str;
        v->val.pval= getBoxName(box,*cursor);
	*cursor= *cursor+1;
	return 0;
}
str getBoxName(Box box, lng i){
	str s;
	s= getVarName(box->sym,i);
	return GDKstrdup(s);
}
str toString(Box box, lng i){
	box=0; i=0; /* fool the compiler */
	return GDKstrdup("");
}
@+ Persistency
The content of a box is saved on a file for subsequent re-use.
The storage is explicitly in terms of MAL operations.
For BAT objects, the corresponding object is made persistent.
Note that the user can not control these operations directly.
The box container is created if it did not yet exist.
@= checkDir
	if( access(boxfile,X_OK) ){
#ifdef DEBUG_MAL_BOX
	stream_printf(GDKout,"box directory %s created\n",boxfile);
#endif
		mkdir(boxfile,0755);
		if( access(boxfile,X_OK) ){
			GDKerror("checkDir:can not create box directory\n");
			return NULL;
		}
	}
@c
str boxFileName(Box box, str backup){
	char boxfile[PATHLENGTH];
	int i= 0;

	snprintf(boxfile,PATHLENGTH,"%s/%s/box",
			GDKgetenv("gdk_dbfarm"), GDKgetenv("gdk_dbname"));
	@:checkDir@
	i= strlen(boxfile);
	if(backup) {
		snprintf(boxfile+i,PATHLENGTH-i,"/%s/", backup);
		@:checkDir@
		i= strlen(boxfile);
	}
	snprintf(boxfile+i,PATHLENGTH-i,"/%s.box", box->name);
	return GDKstrdup(boxfile);
}
int saveBox(Box box,int flag){
	int i, ret=0;
	ValPtr v;
	stream *f;
	str boxfile, boxfilebak;

	flag=0; /*fool the compiler */
	boxfile = boxFileName(box,0);
	boxfilebak = boxFileName(box,"backup");

	if(boxfile==0) {
		GDKerror("saveBox:can not determine box file\n");
		return 1;
	}
#ifdef DEBUG_MAL_BOX
	stream_printf(GDKout,"saveBox:%s\n",boxfile);
#endif
	if( access(boxfile,R_OK) == 0){
		if(access(boxfilebak,R_OK)==0  && unlink(boxfilebak) ) {
#ifdef DEBUG_MAL_BOX
			stream_printf(GDKout,"saveBox:can not unlink %s\n",boxfilebak);
#endif
			GDKerror("saveBox:can not unlink backup\n");
			GDKfree(boxfile); GDKfree(boxfilebak);
			return 1;
		} 

		if( link(boxfile,boxfilebak)) {
#ifdef DEBUG_MAL_BOX
			stream_printf(GDKout,"saveBox:%s \n-> %s\n",
					boxfile,boxfilebak);
#endif
			GDKerror("saveBox:can not link backup\n");
			GDKfree(boxfile); GDKfree(boxfilebak);
			return 1;
		}
		unlink(boxfile);
	} 

	f= open_wastream(boxfile);
	if(f != NULL){
#ifdef DEBUG_MAL_BOX
	stream_printf(GDKout,"saveBox:created %s\n",boxfile);
#endif
		chmod(boxfile, (S_IRUSR | S_IWUSR));
		for(i=0;i<box->sym->vtop; i++){
			v= &box->val->stk[i];
			if( v->vtype == TYPE_bat ) {
			BAT *b= (BAT*)BBPgetdesc(v->val.br.id);
			if( b && b->batPersistence & PERSISTENT)
			stream_printf(f,"%s.bind(\"%s\",\"%s\");\n", 
				box->name, getVarName(box->sym,i),
				BBPname(v->val.br.id));
			} else{
				stream_printf(f,"%s.deposit(\"%s\",", 
					box->name, getVarName(box->sym,i));
				ATOMprint(v->vtype,VALptr(v),f);
				stream_printf(f,":%s);\n", getTypeName(v->vtype));
			}
		}
	} else {
		GDKerror("saveBox:can not create box file\n");
		ret= -1;
	}
	if(f){
		stream_close(f);
		if( link(boxfilebak,boxfile) && unlink(boxfilebak) ) ret= -1;
	}
	GDKfree(boxfile); GDKfree(boxfilebak);
	return ret;
}
@-
Loading a box is equivalent to reading a script.
@c
void loadBox(str name){
	char boxfile[PATHLENGTH];
	int i=0;
	snprintf(boxfile,PATHLENGTH,"%s/%s/box/",
			GDKgetenv("gdk_dbfarm"), GDKgetenv("gdk_dbname"));
	i= strlen(boxfile);
	snprintf(boxfile+i,PATHLENGTH-i,"%s.box",name);
#ifdef DEBUG_MAL_BOX
	stream_printf(GDKout,"loadBox:start loading the file %s\n",boxfile);
#endif
	if( access(boxfile,R_OK)== 0){
		malImport(getClient(),boxfile,0,0);
#ifdef DEBUG_MAL_BOX
		stream_printf(GDKout,"loadBox:loaded the file %s\n",boxfile);
#endif
	} 
}
@+ Utilities
Utilities for the debugger permit dumping of all the object
spaces.
@c
void printBox(stream *fd, Box obj)
{ printStack(fd,obj->sym,obj->val); }

void printSomeBox(stream *fd, int k)
{
	if( box[k]== 0){
		GDKerror("printSomeBox:illegal space id\n");
	} else printBox(fd,box[k]);
}

