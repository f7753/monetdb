@t Atom administration
@a M.L. Kersten
@* Introduction
Monet supports definitions of user-defined types. 
This feature is of particular interest to system experts. 
It is not meant for end-users trying to intruduce record- or 
struct-like objects in the database. They better decompose
the complex object structure and represent the components in
different BATs.

For the courageous at heart, you may enter the difficult world
of extending the kernel library. This calls for studying the
documentation associated with the atom structures (gdk_atoms),
because you have to develop routines complying with the
signatures required in the GDK library.

Once you have assembled these primitive, you can introduce them
in a running server using a ATOM MODULE definition, which contains
a MAL specification of their signature and calls to the routines
below to register the atom in the kernel.

Each ruler dealing with registering a function performs the necessary
type check, but relies on the user to comply with this signature in
its C-implementation. The ruler calls are part of a module
initialization routine.

A concrete example is the 'blob' datatype (see blob.mx)

The Monet Assembler Language recognizes the definition of a new
atom type by replacing the MODULE keyword with ATOM MODULE.
Atoms definitions require special care, because their definition and 
properties should be communicated with the GDK kernel library.
The commands defined in an ATOM MODULE block are screened as of interest 
to the gdk_atom library. 

Functions passed to the GDK kernel are not directly accessible
as MAL routines, because their implementation requires a
GDK-specific signature. (See GDK documentation)
This is realized by renaming them to an non-parseable function.
@h
/*
 * The contents of this file are subject to the Monet Public
 * License Version 1.1 (the "License"); you may not use this file
 * except in compliance with the License. You may obtain a copy of
 * the License at http://www.monetsolutions.com/Download/Licensing/MonetPL-1.1.
html
 * 
 * Software distributed under the License is distributed on an "AS
 * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
 * implied. See the License for the specific language governing
 * rights and limitations under the License.
 * 
 * The Original Code is the Monet Database System.
 * 
 * The Initial Developer of the Original Code is CWI.
 * Portions created by CWI are Copyright (C) 1997-2001 CWI.  
 * All Rights Reserved.
 * 
 * Contributor(s): Martin Kersten <Martin.Kersten@cwi.nl>
 */
#ifndef _MAL_ATOM_H
#define _MAL_ATOM_H

/* #define MAL_ATOM_DEBUG  */

#include "mal_instruction.h"
mal_export void malAtomDefinition(str name,int tpe);
mal_export int malAtomProperty(MalBlkPtr mb, InstrPtr pci);
mal_export int malAtomArray(int tpe, int idx);
mal_export int malAtomFixed(int size, int align);
mal_export void showAtoms(stream *fd);	/* used in src/mal/mal_debugger.c */

#endif /*  _MAL_ATOM_H*/
@+
Every MAL command introduced in an atom module should be checked
to detect overloading of a predefined function.
Subsequently, we update the BAT atom structure.
The function signatures should be parameter-less, which
enables additional functions with the same name to appear
as ordinary mal operators.

@= chkItem
if( idcmp(@1,name)==0 && pci->argc==1){
	BATatoms[tpe].@2= (@3 (*)()) pci->fcn;
#ifdef MAL_ATOM_DEBUG
	stream_printf(GDKout,"replaced the function %s.%s\n",
		moduleName(pci),functionName(pci));
#endif
	setAtomName(pci);
	return 1;
} 
@-
A few fields are set only once, at creation time.
They should be implemented with parameter-less functions.
@= setItem
if( idcmp(@1,name) || pci->argc != 1)
	return 0;
else{
#ifdef MAL_ATOM_DEBUG
	stream_printf(GDKout,"set the atom property %s.%s\n",
		moduleName(pci),functionName(pci));
#endif
	BATatoms[tpe].@2= (@4) (*pci->fcn)();
	setAtomName(pci);
	return 1;
}
@c
#include "mal_atom.h"
void setAtomName(InstrPtr pci){
	char buf[MAXPATHLEN];
	snprintf(buf,MAXPATHLEN,"#%s", functionName(pci));
	GDKfree(pci->fcnname);
	setFunctionId(pci, GDKstrdup(buf));
}

int malAtomProperty(MalBlkPtr mb, InstrPtr pci){
	str name= functionName(pci);
	int tpe = getTypeIndex(moduleName(pci));
	if( tpe<0 || tpe>= GDKatomcnt)
		GDKfatal("malAtomProperty:illegal type name");
	if( pci->fcn == 0)
		GDKwarning("malAtomProperty:function not bound\n");
	switch(name[0]){
	case 'a': @:setItem("align",align,TYPE_sht,short)@ break;
	case 'd': @:chkItem("del",atomDel,void)@ break;
	case 'c': @:chkItem("cmp",atomCmp,int)@ 
		  @:chkItem("convert",atomConvert,void)@ break;
	case 'f': @:chkItem("fromstr",atomFromStr,int)@ 
		  @:chkItem("fix",atomFix,int)@ break;
	case 'h': @:chkItem("heap",atomHeap,void)@ 
		  @:chkItem("heapconvert",atomHeapConvert,void)@ 
		  @:chkItem("hash",atomHash,unsigned int)@ 
		  @:chkItem("heapcheck",atomHeapCheck,int)@ break;
	case 'l': @:chkItem("length",atomLen,int)@ 
		  @:setItem("linear",linear,TYPE_sht,short)@ break;
	case 'n': @:setItem("null",atomNull,TYPE_ptr,ptr)@ 
		  @:chkItem("nequal",atomCmp,int)@ break;
	case 'p': @:chkItem("put",atomPut,void)@ break; 
	case 's': @:setItem("size",size,TYPE_sht,short)@
		  @:setItem("storage",storage,TYPE_int,int); break;
	case 't': @:chkItem("tostr",atomToStr,int)@ break;
	case 'u': @:chkItem("unfix",atomUnfix,int)@ 
	case 'v': @:setItem("varsized",varsized,TYPE_int,int)@ 
	}
	return 0;
}
@-
Atoms are constructed incrementally in the kernel using the
ATOMproperty function. It takes an existing type as a base
to derive a new one.
The most tedisous work is to check the signature types of the functions
acceptable for the kernel.
@c

void malAtomDefinition(str name, int tpe){
	int i;

	if(strlen(name) >= IDLENGTH){
		GDKerror("Atom name '%s' too long\n", name);
		return;
	}
	if( ATOMindex(name)>=0){
		GDKerror("Redefinition of atom '%s'\n", name);
		return;
	}
	if( tpe<0 || tpe >=GDKatomcnt){
		GDKerror("Undefined atom inheritance '%s'\n", name);
		return;
	}
#ifdef MAL_ATOM_DEBUG
	stream_printf(GDKout,"introduce a new atom type '%s'  %d\n",name,tpe);
#endif
	
	ATOMproperty(name,"",  (int (*)()) 0);
	i= ATOMindex(name);
	memcpy((char*)(BATatoms+i),
		(char*)(BATatoms+tpe), sizeof(BATatoms[tpe]));
	strncpy(BATatoms[i].name, name, IDLENGTH);
	BATatoms[i].storage= BATatoms[tpe].storage;
}
@-
User defined modules may introduce fixed sized types
to store information in BATs.
@c
int malAtomFixed(int size, int align){
	int i;
	char buf[IDLENGTH], *name;

	snprintf(buf,IDLENGTH,"fixed_%d", size);
	i= strlen(buf);
	snprintf(buf+i,IDLENGTH-i,"_%d", align);
	name= GDKstrdup(buf);
	ATOMproperty(name,"",  (int (*)()) 0);
	i= ATOMindex(name);
	memcpy((char*)(BATatoms+i),
		(char*)(BATatoms+TYPE_chr), sizeof(BATatoms[TYPE_chr]));
	strncpy(BATatoms[i].name, name, IDLENGTH);
	BATatoms[i].storage= i;
	BATatoms[i].size = size;
	BATatoms[i].align = align;
	BATatoms[i].linear = FALSE;
	return i;
}
int malAtomArray(int tpe, int size){
	int i;
	char name[IDLENGTH];
	str nme;

	nme = getTypeName(tpe);
	stream_printf(GDKout,"enter a new array type definition %s %d\n", nme,size);
	snprintf(name,IDLENGTH,"%s_", nme);
	i= strlen(name);
	snprintf(name+i,IDLENGTH-i,"%d", size);
	GDKfree(nme);
	if(strlen(name) >= IDLENGTH){
		GDKerror("Atom name '%s' too long\n", name);
		return -1;	/* ERROR! */
	}
#ifdef MAL_ATOM_DEBUG
	stream_printf(GDKout,"new type name %s\n",name);
#endif
	ATOMproperty(name,"",  (int (*)()) 0);
	i= ATOMindex(name);
	memcpy((char*)(BATatoms+i),
		(char*)(BATatoms+tpe), sizeof(BATatoms[tpe]));
	strncpy(BATatoms[i].name, name, IDLENGTH);
	BATatoms[i].storage= tpe;
	BATatoms[i].size *= size;
	BATatoms[i].linear = FALSE;
#ifdef MAL_ATOM_DEBUG
	stream_printf(GDKout,"new type %d\n",i);
#endif
	return i;
}

void showAtoms(stream *fd){
	int i;
	for(i=0;BATatoms[i].name[0] && i<TYPE_any; i++){
		stream_printf(fd,"%s", BATatoms[i].name);
		if( BATatoms[i+1].name[0]) stream_printf(fd,",");
	}
	stream_printf(fd,"\n");

}
