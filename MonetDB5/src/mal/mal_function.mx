@t MAL functions
@a M. Kersten
@v 0.0
@+ MAL functions
MAL functions are represented by MAL instruction lists.
The first instruction contains the signature.

The representation of the MAL functions is rather traditional,
using C-structure to collect the necessary information.
Moreover, we assume that MAL functions are relatively small, up to
a few hundred of instructions. This assumption makes us to rely on
linear scans as it comes to locating information of interest.

The information maintained for each MAL function should both
be geared towards fast execution and to ease symbolic debugging.
@h
/*
 * The contents of this file are subject to the Monet Public
 * License Version 1.1 (the "License"); you may not use this file
 * except in compliance with the License. You may obtain a copy of
 * the License at http://www.monetsolutions.com/Download/Licensing/MonetPL-1.1.
html
 * 
 * Software distributed under the License is distributed on an "AS
 * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
 * implied. See the License for the specific language governing
 * rights and limitations under the License.
 * 
 * The Original Code is the Monet Database System.
 * 
 * The Initial Developer of the Original Code is CWI.
 * Portions created by CWI are Copyright (C) 1997-2001 CWI.  
 * All Rights Reserved.
 * 
 * Contributor(s): Martin Kersten <Martin.Kersten@cwi.nl>
 */
#ifndef _MAL_FCN_H
#define _MAL_FCN_H

#include "mal_scope.h"

/* #define DEBUG_MAL_FCN */
/* #define DEBUG_CLONE*/

mal_export Symbol	newFunction(str nme,int kind);
mal_export void		clearFcn(MalBlkPtr m);
mal_export int getPC(MalBlkPtr mb, InstrPtr p);

mal_export InstrPtr newCall(str modname, str fcnname, int kind);
mal_export Symbol cloneFunction(Scope scope, Symbol proc, MalBlkPtr mb, InstrPtr p);

mal_export Symbol	getSymbol(Scope scope, InstrPtr p);
mal_export void chkFlow(MalBlkPtr mb);
mal_export int getBarrierEnvelop(MalBlkPtr mb);

/*VARARGS*/
mal_export str throwException(str nme, str fcn, char *format, ...);
mal_export str	raiseException(MalBlkPtr mb, int pc, str name, str msg);
mal_export str appendException(MalBlkPtr mb, int pc, str name, str msg,str old);
mal_export str locateException(MalBlkPtr mb, int pc, str oldmsg);
mal_export void	showException(MalBlkPtr mb, int pc, str name, str msg);
mal_export void printFunction(stream *fd, MalBlkPtr mb, int listing);

#define MALEXCEPTION "MALexception"
#define throwMessage(Fcn,Msg)	throwException(MALEXCEPTION,Fcn,"%s",Msg)
#endif /*  _MAL_FCN_H*/
@-
The MAL functions are constructed incrementally while parsing the source.
The variable is used to hold the return value.
@c
#include "mal_function.h"

Symbol newFunction(str nme,int kind){
	Symbol s;
	InstrPtr p;
	MalBlkPtr mb;
	int i,j;

	s = newSymbol(nme,kind);
	p = newInstruction(kind);
	p->fcnname = GDKstrdup(nme);
	getDestVar(p)= newVariable(s->def,GDKstrdup(nme),TYPE_any);
	pushInstruction(s->def,p);
	return s;
}
InstrPtr newCall(str modname, str fcnname, int kind){
	InstrPtr p;
	p= newInstruction(kind);
	p->modname= GDKstrdup(modname);
	p->fcnname= GDKstrdup(fcnname);
	return p;
}
@-
Optimizers may be interested in the function definition
for obtaining properties. Rather then polution of the
instruction record, we use a lookup function until it
becomes a performance hindrance.
@c
Symbol	getSymbol(Scope scope, InstrPtr p){
	Scope m;
	Symbol s;

	for(m= findScope(scope,p->modname); m; m= m->outer)
        if(idcmp(m->name, p->modname)==0 ) {
                s= m->subscope[getSubScope(p->fcnname)];
                for(; s; s= s->peer)
                if( getSignature(s)->fcn == p->fcn) return s;
        }

	GDKerror("getSymbol:internal error\n");
	return 0;
}
@+ Flow of control
The nesting of (BARRIER, CATCH) and EXIT statements with their associated
flow of control primitives LEAVE, REDO and RAISE should form a valid
hierarchy. Failure to comply is considered a structural error
and leads to flagging the function as erroneous.

The operands of the LEAVE and REDO operators are either a single
identifier or an assignment. In the former case, they are simply
interpreted as  goto statements. If the REDO contains an assignment,
it overrules the barrier expression, by providing an alternative test.
If the LEAVE instruction contains an expression, it overrules any
assignment in the EXIT statement and continues processing directly 
following the EXIT. These jumps required are set accordingly.

Check barrier should ensure that both exit-points of a block for the
variable referenced in 'pp' exists. In addition, we should ensure
proper weaveing of the begin-end pairs. This can simply be checked by
counting the begin/end pairs. It should balance for every block.
Currently, the barrier control variables should be of type bit,
sht, int, or lng. A number zero is interpreted as end of the barrier
block.

To speed-up interpretation of the control statements, we also
include the program-counter in instruction record. This implies
that any subsequent change to a program, i.e. squeezers,
should be followed by a call to this procedure.

@c
int getPC(MalBlkPtr mb, InstrPtr p)
{	int i;
	for( i=0;i<mb->stop; i++)
	if( getInstrPtr(mb,i)==p) return i;
	return -1;
}

@h
#define functionStart(X) ((X)->token == FUNCTIONsymbol || \
			  (X)->token == COMMANDsymbol || \
			  (X)->token == STREAMsymbol )
#define functionExit(X)	 ((X)->token == ENDDEFsymbol)

#define blockStart(X)	((X)->barrier == BARRIERsymbol || \
		     (X)->barrier == CATCHsymbol ||	\
		     (X)->barrier == THREADsymbol)
#define blockExit(X) (X)->barrier == EXITsymbol
#define blockCntrl(X) ((X)->token== LEAVEsymbol || (X)->token== REDOsymbol ||\
			((X)->token== ASSIGNsymbol && ( \
			 (X)->barrier== LEAVEsymbol ||  \
			 (X)->barrier== REDOsymbol  )) )
#define assignCntrl(X)	((X)->token== ASSIGNsymbol ||\
			  (X)->token== CMDcall ||\
			  (X)->token== PATcall ||\
			  (X)->token== FCNcall )

@-
Checking the control flow structure is done by a single pass over the
MAL program after the program has been type-checked.
@c
#define DEPTH 128

void chkFlow(MalBlkPtr mb)
{	int i,j,k, v;
	int  pc[DEPTH];
	int  var[DEPTH];
	InstrPtr stmt[DEPTH];
	int btop=0;
	InstrPtr p;

	for(i= 0; i<mb->stop; i++){
		p= getInstrPtr(mb,i);
		if( blockStart(p) ){
			if(btop== DEPTH){
				GDKerror("Too many nested MAL blocks\n");
				mb->errors++;
				return;
			}
			pc[btop]= i;
			v= var[btop]= getDestVar(p);
			stmt[btop]=p;

			for(j=btop-1;j>=0;j--)
			if( v==var[j]){
				GDKerror("recursive %s[%d] shields %s[%d]\n",
					getVarName(mb,v), pc[j],
					getFcnName(mb),pc[i]);
				mb->errors++;
			}

			if( getVarType(mb,v) != TYPE_bit && 
			    getVarType(mb,v)!= TYPE_any &&
			    getVarType(mb,v) != TYPE_sht && 
			    getVarType(mb,v)!= TYPE_lng && 
			    getVarType(mb,v) != TYPE_int &&
			    getVarType(mb,v) != TYPE_str ){
				GDKerror("barrier '%s' should be of type bit or number in %s[%d]\n",
				getVarName(mb, v), getFcnName(mb), i);
			}
			btop++;

		} else  
		if( blockExit(p) ){
			v= getDestVar(p);
			if( btop>0 && var[btop-1] != v){
				mb->errors++;
				GDKerror("exit-label '%s' doesnot match '%s' in %s[%d]\n",
				getVarName(mb,v),
				getVarName(mb,var[btop-1]),
				getFcnName(mb),i);
			}
			if(btop==0){
				GDKerror("exit-label '%s' without begin-label in %s[%d]\n",
				getVarName(mb,v), getFcnName(mb),i);
				continue;
			}
			/* search the matching block */
			for(j=btop-1;j>=0;j--)
			if( var[j]==v) break;
			if(j>=0) btop= j; else btop--;

			/* retrofit LEAVE/REDO instructions */
			/* and check their illegal use in THREAD block*/
			stmt[btop]->jump= i;
			for(k=pc[btop]; k<i; k++){
			InstrPtr p1= getInstrPtr(mb,k);
			if( getDestVar(p1)==v ) {
				if( p1->token == REDOsymbol ) 
					p1->jump= pc[btop];
				if(p1->token== LEAVEsymbol )
					p1->jump= i;
				/* handle assignments with leave/redo option*/
				if( assignCntrl(p1) ){
					if(p1->barrier== LEAVEsymbol )
						p1->jump= i;
					if( p1->barrier==REDOsymbol )
						p1->jump= pc[btop];
				}
			}
			}
		}  else 
		if( blockCntrl(p)){
			v= getDestVar(p);
			for(j=btop-1;j>=0;j--)
			if( var[j]==v) break;
			if(j<0){
				GDKerror("label '%s' not in guarded block in %s[%d]\n",
				getVarName(mb,v),getFcnName(mb),i);
				mb->errors++;
			}
		} else
		if( isaSignature(p) && i ){
			str msg=instruction2str(mb,p,TRUE);
                        GDKerror("SYNTAX ERROR: signature misplaced\n!%s\n",msg);
                        GDKfree(msg);
                        mb->errors++;
		}
	}
	for(btop--; btop>=0;btop--)
	GDKerror("begin '%s' without exit in %s[%d]\n",
		getVarName(mb,var[btop]),getFcnName(mb),i);
	p= getInstrPtr(mb,0);
	if( !isaSignature(p))
		GDKerror("SYNTAX ERROR: signature missing\n");
}
@-
A code may contain temporary names for marking barrier blocks.
Since they are introduced by the compiler, the parser should locate
them itself when encountering the LEAVE,EXIT,REDO.
The starting position is mostly the last statement entered.
Purposely, the nameless envelops searches the name of the last
unclosed block. All others are ignored.
@c
int getBarrierEnvelop(MalBlkPtr mb){
	int i,pc;
	InstrPtr p;
	for(pc= mb->stop-2 ; pc>=0; pc--){
		p= getInstrPtr(mb,pc);
		if( blockExit(p)){
			int l= p->argv[0];
			for(; pc>=0;pc--){
				p= getInstrPtr(mb,pc);
				if( blockStart(p) && p->argv[0]==l) break;
			}
			continue;
		}
		if( blockStart(p) ) return p->argv[0];
	}
	return newTmpVariable(mb,TYPE_any);
}
@+ Function cloning
MAL supports functions defined with type variables.
Each time such a MAL routine is called, a complete copy of
the polymorphic routine is generated, whereafter the type
variables are replaced with concrete types.

Patterns should not be cloned, because the alternative interpretations
are handled by the underlying code fragments.

The function body should be immediately type checked and if
a correct clone can be obtained, returns success by
returning the symbol with the instantiated function.

Beware that polymorphic type variables should be propagated.
This may imply propagation of a type to a component type of
a BAT.
Replace a particular variable, indexed by v
@c
void replaceTypeVar(MalBlkPtr mb, InstrPtr p, int v, malType t){
	int i,x;
#ifdef DEBUG_MAL_FCN
	stream_printf(GDKout,"replace type variable %d by type %d\n",v,t);
#endif
	for(i=0;i<p->argc; i++)
	if( isPolymorphic(x= getArgType(mb,p,i))) {
#ifdef DEBUG_MAL_FCN
		stream_printf(GDKout," %d x= %d\n",i,x);
#endif 
		if( isaBatType(x)){
			int head,tail;
			int hx,tx;
			head = getHeadType(x);
			tail = getTailType(x);
			hx = getHeadIndex(x);
			tx = getTailIndex(x);
			if( hx == v && head == TYPE_any){
				hx =0;
				head =t;
			}
			if( tx == v && tail == TYPE_any){
				tx= 0;
				tail = t;
			}
			x= newBatType(head,tail);
			setAnyHeadIndex(x,hx);
			setAnyTailIndex(x,tx);
			setArgType(mb,p,i,x);
		} else
		if( getTailIndex(x) == v){
			setArgType(mb,p,i,t);
		} 
	}
}
@-
Upon cloning a function we should remove all the polymorphic flags.
Otherwise we may end up with a recursive clone.
@c
Symbol 	cloneFunction(Scope scope, Symbol proc, MalBlkPtr mb, InstrPtr p){
	Symbol new;
	int i,v;
	InstrPtr pp;

#ifdef DEBUG_CLONE
	stream_printf(GDKout,"clone the function %s to scope %s\n",
			proc->name,scope->name);
#endif
	new= newFunction(GDKstrdup(proc->name), getSignature(proc)->token );
	new->def = copyMalBlk(proc->def);
	/* now change the definition of the original proc */
	pp = getSignature(new);
	for(i=0;i<pp->argc;i++)
	if( isPolymorphic(v= getArgType(new->def,pp,i)) ){
		int t = getArgType(mb,p,i);

		if( isaBatType(t) ){
			int head,tail;
			head = getHeadType(t);
			tail = getTailType(t);
			replaceTypeVar(new->def, pp, getHeadIndex(v), head);
			replaceTypeVar(new->def, pp, getTailIndex(v), tail);
		} else
			replaceTypeVar(new->def, pp, getTailIndex(v), t);
	} /* else stream_printf(GDKout,"%d is %d\n",i,getArgType(mb,pp,i));*/
	/* include the function at the proper place in the scope */
	insertSymbol(scope,new);
	/* clear polymorphic */
	for(i=0;i<new->def->stop;i++) {
                pp= getInstrPtr(new->def,i);
		pp->polymorphic= 0;
	}
	/* clear type fixations */
	for(i=0;i< new->def->vtop; i++)
		new->def->var[i]->fixtype=0;
	new->def->errors= 0;
	/* check for errors after fixation , TODO*/
	chkProgram(scope,new->def);
	if( new->def->errors){
		str err;
		GDKerror("Error in cloned function\n");
		err= function2str(new->def,LIST_MAL_ALL);
		GDKerror("%s",err);
		GDKfree(err);
		showErrors(getClient());
	}
#ifdef DEBUG_CLONE
	stream_printf(GDKout,"newly cloned function added to %s %d \n",scope->name,i);
	printFunction(GDKout,new->def, LIST_MAL_ALL);
#endif
	return new;
}
@- Exception handling
@c
str appendException(MalBlkPtr mb, int pc, str name, str msg,str oldmsg){
        char buf[4196];
	int i;
	str s,fcn;

	s = mb? getModName(mb): "";
	fcn= mb? getFcnName(mb):"";
	buf[0]=0;
	if(oldmsg) snprintf(buf,4196,"%s",oldmsg);
	i= strlen(buf);
	if(name) snprintf(buf+i,4196-i,"%s:", name);
	i= strlen(buf);
	if(s) snprintf(buf+i,4196-i,"%s.",s);
	i= strlen(buf);
	snprintf(buf+i,4196-i,"%s",fcn);
	i= strlen(buf);
	snprintf(buf+i,4196-i,"[%d]",pc);
	i= strlen(buf);
	if(msg) snprintf(buf+i,4196-i,":%s",msg);
	i= strlen(buf);
	if( buf[i-1]!='\n'){ buf[i]='\n'; buf[i+1]=0;}
        return GDKstrdup(buf);
}
str locateException(MalBlkPtr mb, int pc, str oldmsg){
	str s, msg=0,name=0;

	if( s= strchr(oldmsg,':')){
		*s =0;
		name= oldmsg;
		msg= s+1;
	} else msg=oldmsg;
	return appendException(mb,pc,name,msg,0);
}
@-
The linked libraries should use the throwException to signal
an erroneous situation. It takes the name of MAL exception name
to be raised.
@c
/*VARARGS*/
str throwException(str nme, str fcn, char *format, ...){
        char message[GDKMAXERRLEN];
        int len = strlen(MALexception)+1;
        va_list ap;

	sprintf(message,"%s:%s:",nme,fcn);
	len= strlen(message);
        va_start(ap, format);
        vsnprintf(message + len, GDKMAXERRLEN-(len+2), format, ap);
        va_end(ap);

        return GDKstrdup(message);
}
str raiseException(MalBlkPtr mb, int pc, str name, str msg){
	return appendException(mb,pc,name,msg,"");
}
void showException(MalBlkPtr mb, int pc, str name, str msg){
	str n;
	n= raiseException(mb,pc,name,msg);
	GDKerror(n);
	GDKfree(n);
}
@-
For commands we do not have to clone the routine. We merely have to
assure that the type-constraints are obeyed. The resulting type
is returned.
@c
void printFunction(stream *fd, MalBlkPtr mb, int flg){
	int i;
	for(i=0;i<mb->stop;i++)
	printInstruction(fd,mb, getInstrPtr(mb,i),flg);
}
