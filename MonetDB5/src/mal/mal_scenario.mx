@f mal_scenario
@t MAL scenarios
@a M. Kersten
@v 0.0
@+ Introduction
In Monet multiple languages, optimizers, and execution engines can
be combined at run time to satisfy a wide user-community.
A assemblage of components is called a scenario.
The default being to accept MAL instructions immediately
followed by a MAL optimization & interpreter call.

The language engine "currently" supported are SQL, MIL (Monet version 4),
and MAL (Monet Assembler Language).
The input obtained with a language specific reader should
be  parsed to produce MAL intermediate code.
Parsing should include any semantic check imposed by the language frontend.

After parsing the MAL code block is passed through a strategic
optimizer, which normally deploys language specific optimizations,
e.g. foreign-key optimizations in joins and volume reduction over
intermediates. They may leave advice and their findings in attributes
in the symboltable.

Once the MAL block has thus been prepared for execution, the
tactics optimizer(s) is (are) called to prepare scheduling the program.
For example, it may perform symbolic evaluations, parallelize the code,
or prepare for replication management.

The first time a scenario is used, the system looks for a scenario
initialization routine and executes it. It is typically used to 
prepare the server for language specific interactions.
Thereafter the reader,parsers,... are set to those required by
the scenario (e.g. "sql") and the client initialization takes place.
using initClientScenario().

Before the server terminates (cleanly) an exit routine is called.
They typically perform cleanup, backup and monitoring functions.

A scenario is interpreted in a strictly linear fashion,
i.e. performing a symbolic optimization after a parallelization 
is not permitted. The routines associated with each state in
the scenario may patch the code so as to assure that subsequent
execution can use a different scenario, e.g. to handle dynamic
code fragments.

The state of execution is maintained in the scenario record for
each individual client. Sharing of this information between clients
should be dealt with in the implementation of the scenario managers.
Upon need, the client can postpone a session scenario by 
pushing a new one call scenario(language, optimize, tactic, 
processor). Propagation of the state information is
encapsulated a scenario2scenario() call. Not all transformations
may be legal.
@h
/*
 * The contents of this file are subject to the Monet Public
 * License Version 1.1 (the "License"); you may not use this file
 * except in compliance with the License. You may obtain a copy of
 * the License at 
 * http://www.monetdb.com/Legal/MonetDBPL-1.0.html
 * 
 * Software distributed under the License is distributed on an "AS
 * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
 * implied. See the License for the specific language governing
 * rights and limitations under the License.
 * 
 * The Original Code is the Monet Database System.
 * 
 * The Initial Developer of the Original Code is CWI.
 * Portions created by CWI are Copyright (C) 1997-2002 CWI.  
 * All Rights Reserved.
 * 
 * Contributor(s): Martin Kersten <Martin.Kersten@cwi.nl>
 */

#ifndef _MAL_SCENARIO_H
#define _MAL_SCENARIO_H

#include "mal_import.h"

#define READER 0
#define PARSER	1
#define OPTIMIZE 2
#define TACTICS 3
#define ENGINE 4
#define INITCLIENT 5
#define EXITCLIENT 6

/*#define MAL_SCENARIO_DEBUG*/
@-
The scenario descriptions contains all information to
implement the scenario. A client gets a copy.
An exception or error detected while parsing is turned
into an exception and aborts the scenario.
@h
#define MAXSCEN 128

typedef struct SCENARIO{
	str 	name;
	str	initScenario;	GDKfcn initScenarioCmd;
	str	exitScenario;	GDKfcn exitScenarioCmd;
	str	initClient;	GDKfcn initClientCmd;
	str	exitClient;	GDKfcn exitClientCmd;
	str	reader;		GDKfcn readerCmd;	void *readerState;
	str	parser;		GDKfcn parserCmd;	void *parserState;
	str	optimizer;	GDKfcn optimizerCmd;	void *optimizerState;
	str	tactics;	GDKfcn tacticsCmd;	void *tacticsState;
	str	engine;		GDKfcn engineCmd;	void *engineState;
	struct SCENARIO	*next;
} *Scenario;

mal_export Scenario newScenario();
mal_export Scenario dropScenario();
mal_export str setScenario(Client c, str nme);
mal_export void runScenario(Client c);
mal_export void fillScenario(Client c, Scenario scen);
mal_export void clrScenario(Client c);

mal_export void showCurrentScenario();
mal_export void showScenarioByName(stream *f, str s);
mal_export void showScenario(stream *f, Scenario s);
mal_export void showAllScenarios(stream *f);
mal_export void resetScenario(Client c);
mal_export str setScenario(Client c, str nme);
#endif /* _MAL_SCENARIO_H*/
@-
@c
#include "mal_scenario.h"

struct SCENARIO scenarioRec[MAXSCEN]={
{"mal",	0,0,0,0,0,0,0,0,
	"MALreader", 	0,0,
	"MALparser",	0, 0,
	"MALoptimizer",	0, 0,
	0,		0, 0,
	"MALengine",	0, 0,  0},
{"mil",	0,0,0,0,0,0,0,0,
	"MILreader",	0,0,
	"MILparser",	0, 0,
	0,		0, 0,
	0,		0, 0,
	"MILengine",	0, 0,  0},
{"sql",	"SQLinit",0, "SQLexit",0,
	"SQLinitClient",0,
	"SQLexitClient",0,
	"SQLreader",	0, 0,
	"SQLparser",	0, 0,
	0,		0, 0,
	0,		0, 0,
	"SQLengine",	0, 0,  0},
{0,	0,0,0,0,0,0,0,0,
	0,		0, 0,
	0,		0, 0,
	0,		0, 0,
	0,		0, 0,
	0,	0, 0,  0}
};

@-
Currently each user can define a new scenario, provide we have a free slot.
Scenarios not hardwired can always be dropped.
@c
Scenario getFreeScenario(){
	int i;
	Scenario scen= NULL;

	MT_set_lock(mal_contextLock,"Scenario");
	for(i=0;i<MAXSCEN && scenarioRec[i].name;i++);

	if( i==MAXSCEN)
	GDKerror("freeScenario:no scenario space left; adjust & recompile \n");
	else scen= scenarioRec+i;
	MT_unset_lock(mal_contextLock, "Scenario");

	return scen;
}
@-
@= initScen
if( @1->@2){
	if( @1->@2Cmd == 0) @1->@2Cmd = (GDKfcn)getAddress( @1->@2);
	if( @1->@2Cmd == 0) {
	    return throwMessage("initScenario","@2 address not found\n"); }
}
@-
A scenario is initialized only once per session. 
All other requests are silently ignored. 
After initialization, all state functions should have been set.
Initialization includes searching for the scenario startup file in
the etc/MonetDB directory. This creates a dependency, because the
malImport also needs a scenario. To break this cycle, the system should
call once the routine default scenario for each client first.
@c
str initScenario(Client c, Scenario s){
	char buf[PATHLENGTH];

	if(s->initScenario && s->initScenarioCmd==0){
		/* prepare for conclicts */
		MT_set_lock(mal_contextLock,"Scenario");
		s->initScenarioCmd= (GDKfcn)getAddress( s->initScenario);
		if(s->initScenarioCmd) (*s->initScenarioCmd)(c);
		MT_unset_lock(mal_contextLock,"Scenario");
	}
	@:initScen(s,exitScenario)@
	@:initScen(s,initClient)@
	@:initScen(s,exitClient)@
	@:initScen(s,reader)@
	@:initScen(s,parser)@
	@:initScen(s,optimizer)@
	@:initScen(s,tactics)@
	@:initScen(s,engine)@
	fillScenario(c,s);

	return 0;
}
str defaultScenario(Client c){
	initScenario(c,scenarioRec);
	return MAL_SUCCEED;
}
@-
The Monet debugger provides an option to inspect the scenarios currently
defined.
@= scenarioCommand
	if( scen->@1) stream_printf(f," \"%s%s\",",scen->@1,
		(scen->@1Cmd?"":"?"));
	else stream_printf(f," nil,");
@c
void showScenario(stream *f, Scenario scen){
	stream_printf(f,"[ \"%s\",", scen->name);
	@:scenarioCommand(initScenario)@
	@:scenarioCommand(exitScenario)@
	@:scenarioCommand(initClient)@
	@:scenarioCommand(exitClient)@
	@:scenarioCommand(parser)@
	@:scenarioCommand(optimizer)@
	@:scenarioCommand(tactics)@
	@:scenarioCommand(engine)@
	stream_printf(f,"]\n");
}
void showScenarioByName(stream *f, str s){
	int i;
	Scenario scen= scenarioRec;

	for(i=0;i<MAXSCEN && scen->name;i++, scen++)
	if( strcmp(scen->name,s)==0) showScenario(f,scen);
}
void showAllScenarios(stream *f){
	int i;
	Scenario scen= scenarioRec;

	for(i=0;i<MAXSCEN && scen->name;i++, scen++)
		showScenario(f,scen);
}
@-
Changing the scenario for a particular client invalidates the
state maintained for the previous scenario. The old scenario is
retained in the client record to facilitate propagation of 
state information, or to simply switch back to the previous one.
Before we initialize a scenario the client scenario is reset to
the MAL scenario. This implies that all scenarios are initialized
using the same scenario. After the scenario initialization file 
has been processed, the scenario phases are replaced with the
proper ones.

@c
Scenario fndScenario(str nme){
	int i;
	Scenario scen= scenarioRec;
	for(i=0;i<MAXSCEN && scen->name; i++, scen++)
	if( strcmp(scen->name,nme)==0 ) return scen;
	return 0;
}
@-
All client records should be initialized with a default
scenario, i.e. the first described in the scenario table.
@c
void fillScenario(Client c, Scenario scen){
	c->scenario= GDKstrdup(scen->name);

	c->phase[READER] = scen->readerCmd;
	c->phase[PARSER] = scen->parserCmd;
	c->phase[OPTIMIZE] = scen->optimizerCmd;
	c->phase[TACTICS] = scen->tacticsCmd;
	c->phase[ENGINE] = scen->engineCmd;
	c->phase[INITCLIENT] = scen->initClientCmd;
	c->phase[EXITCLIENT] = scen->exitClientCmd;
	c->state[READER] =0;
	c->state[PARSER] =0;
	c->state[OPTIMIZE] =0;
	c->state[TACTICS] =0;
	c->state[ENGINE] =0;
	c->state[INITCLIENT] =0;
	c->state[EXITCLIENT] =0;
	if( scen->initClientCmd)
		(*scen->initClientCmd)(c);
}
void clrScenario(Client c){
	if( c->scenario==0) return;
	GDKfree(c->scenario);
	c->scenario=0;
	c->phase[READER] = 0;
	c->phase[PARSER] = 0;
	c->phase[OPTIMIZE] = 0;
	c->phase[TACTICS] = 0;
	c->phase[ENGINE] = 0;
	c->phase[INITCLIENT] =0;
	c->phase[EXITCLIENT] =0;
	c->state[READER] =0;
	c->state[PARSER] =0;
	c->state[OPTIMIZE] =0;
	c->state[TACTICS] =0;
	c->state[ENGINE] =0;
	c->state[INITCLIENT] =0;
	c->state[EXITCLIENT] =0;
}
@-
Setting a new scenario calls for saving the previous state
and execution of the initClientScenario routine.
@c
str setScenario(Client c, str nme){
	int i;
	str msg;
	Scenario scen= scenarioRec;
	GDKfcn start;

	scen = fndScenario(nme);
	if( scen== NULL)
		return throwMessage("setScenario",
			"Missing scenario specification\n");
	if(c->scenario){
		c->oldscenario = c->scenario;
		for(i=0;i<7;i++){
			c->oldstate[i] = c->state[i];
			c->oldphase[i] = c->phase[i];
		}
	}
	for(i=0;i<7;i++) c->state[i]= 0;

	msg= initScenario(c,scen);
	if(msg) return msg;
	return MAL_SUCCEED;
}
@-
After finishing a session in a scenario, we should reset the
state of the previous one. But also call the exitClient
to garbage collect any scenario specific structures.
@c
str getCurrentScenario(Client c){
	return c->scenario;
}
void resetScenario(Client c){
	int i;
	str msg;
	Scenario scen= scenarioRec;
	if( c->scenario==0) return;

	scen = fndScenario(c->scenario);
	if( scen!= NULL && scen->exitClientCmd)
		(*scen->exitClientCmd)(c);
	
	if(c->scenario) GDKfree(c->scenario);
	c->scenario= c->oldscenario;
	for(i=0;i<7;i++){
		c->state[i] = c->oldstate[i];
		c->phase[i] = c->oldphase[i];
	}
	c->oldscenario =0;
}
void exitScenario(Client c){
	str msg;
	Scenario scen= scenarioRec;
	if( c->scenario==0) return;
	scen = fndScenario(c->scenario);
	if( scen->exitScenarioCmd)
		(*scen->exitScenarioCmd)(c);
}
@- Running a scenario
The building blocks of scenarios are routines obeying a strict
calling sequence.

The XYZparser(Client c) contains the parser for language XYZ
and should fill the mal program block associated with the client record.
The latter may have been initialized with variables. 
Each language parser may require a catalog with information
on the translation of language specific datastructures into their BAT
equivalent.

The XYZoptimizer(Client c) contains language specific optimizations
using the MAL intermediate code as a starting point.

The XYZtactics(Client c) synchronizes the program execution with the
state of the machine, e.g. claiming resources, the history of the client 
or alignment of the request with concurrent actions (e.g. transaction
coordination).

@= runPhase
	if(c->phase[@1] && (msg= (str) (*c->phase[@1])(c)) ){
		/* error occurred */
#ifdef MAL_SCENARIO_DEBUG
		stream_printf(c->fdout,"Error in @1 phase\n");
		if( c->mode > FINISHING && c->nxt!=c->input)
			stream_printf(c->fdout,"%s",msg);
		c->fdout->flush(c->fdout);
#endif
		GDKfree(msg); msg=0;
		continue;
	}
@c
void runScenario(Client c){
	str msg;

	while( c->mode > FINISHING ){
		@:runPhase(READER)@
		@:runPhase(PARSER)@
		@:runPhase(OPTIMIZE)@
		@:runPhase(TACTICS)@
		@:runPhase(ENGINE)@
	}
#ifdef MAL_SCENARIO_DEBUG
	printf("About to terminate scenario %s\n",c->scenario);
#endif
	if(c->phase[EXITCLIENT] ) (*c->phase[EXITCLIENT])(c);
}

@+ MAL scenario initialization
The scenario initialization is currently empty. However, the file should always
be available. Actually, we should move welcome messages to this script, because
it will indicate that the kernel is basically running as expected.
@mal
#print("Welcome in MAL scenario");

