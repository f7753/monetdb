@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@' 
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@' 
@' The Original Code is the Monet Database System.
@' 
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2004 CWI.
@' All Rights Reserved.

@f mal_scenario
@a M. Kersten
@v 0.0
@-
@node Session management , ,MAL synopsis , MonetDB overview
@* Sessions
In MonetDB multiple languages, optimizers, and execution engines can
be combined at run time to satisfy a wide user-community.
Such an assemblage of components is called a @emph{ scenario}
and consists of a @emph{ reader}, @emph{ parser}, @emph{ optimizer},
@emph{ tactic scheduler} and @emph{ engine}. These hooks allow
for both linked-in and external components.

The languages "currently" supported are SQL, MIL ( a large 
part of Monet version 4), and MAL (Monet Assembler Language).
The default being to accept MAL instructions immediately
followed by a MAL optimization \& interpreter call.

The @emph{ reader} component merely handles interaction with
a front-end to obtain a string for subsequent compilation and
execution. The string is associated with the client record
for the duration of its execution.
Possible functional enhancements are a query cache,
history scheme, replication to remote Mservers,....

The prime task of the parser is to prepare a
MAL block for subsequent processing. It could be as simple
as generating a MAL program string followed by separate 
compilation of the back-end,
or parsing the front-end directly into MAL data structures.

The MAL code block are sent through an
optimizer, which normally deploys language specific optimizations,
e.g. foreign-key optimizations in joins and volume reduction over
intermediates. All information is statically derived from the
code blocks. They may leave advice and their findings in properties
in the symbol table.

Once the MAL block has thus been prepared for execution, the
scheduler prepares for tactical optimizations.
For example, it may parallelize the code, generate an ad-hoc
user-defined function, or prepare for efficient replication management.

The final stage is to choose an execution paradigm,
i.e. interpretative (default), compilation of an ad-hoc user
defined function, dataflow driven interpretation,
or vectorized pipe-line execution by a dedicated engine.

@menu
* Session management::
* Client administration::
* Session scenarios::
* MAL execution::
@end menu
@node Session scenarios, MAL execution , Client administration, Session management, 
@+ Scenario scenarios
Scenarios are captured in modules; they can be dynamically loaded
and remain active until the system is brought to a halt.
The first time a scenario is used, the system looks for a scenario
initialization routine and executes it. It is typically used to 
prepare the server for language specific interactions.
Thereafter its components are set to those required by
the scenario (e.g. "SQL") and the client initialization takes place.

When the last user interested in a particular scenario leaves the
scene, we activate its finalization routine.
It typically perform cleanup, backup and monitoring functions.

A scenario is interpreted in a strictly linear fashion,
i.e. performing a symbolic optimization after a parallelization 
is not permitted. The routines associated with each state in
the scenario may patch the code so as to assure that subsequent
execution can use a different scenario, e.g. to handle dynamic
code fragments.

The state of execution is maintained in the scenario record for
each individual client. Sharing this information between clients
should be dealt with in the implementation of the scenario managers.
Upon need, the client can postpone a session scenario by 
pushing a new one(language, optimize, tactic, 
processor). Propagation of the state information is
encapsulated a scenario2scenario() call. Not all transformations
may be legal.

@{
@+ Scenario administration
Administration of scenarios follows the access rules 
defined for code modules in general.

@h

#ifndef _MAL_SCENARIO_H
#define _MAL_SCENARIO_H

#include "mal_import.h"

#define READER 0
#define PARSER  1
#define OPTIMIZE 2
#define SCHEDULER 3
#define ENGINE 4
#define INITCLIENT 5
#define EXITCLIENT 6

/*#define MAL_SCENARIO_DEBUG*/
@-
The scenario descriptions contains all information to
implement the scenario. Each client gets a copy.
An exception or error detected while parsing is turned
into an exception and aborts the scenario.
@h
#define MAXSCEN 128

typedef struct SCENARIO{
    str     name;
    str initScenario;   MALfcn initScenarioCmd;
    str exitScenario;   MALfcn exitScenarioCmd;
    str initClient; MALfcn initClientCmd;
    str exitClient; MALfcn exitClientCmd;
    str reader;     MALfcn readerCmd;   void *readerState;
    str parser;     MALfcn parserCmd;   void *parserState;
    str optimizer;  MALfcn optimizerCmd;    void *optimizerState;
    str tactics;    MALfcn tacticsCmd;  void *tacticsState;
    str engine;     MALfcn engineCmd;   void *engineState;
    struct SCENARIO *next;
} *Scenario;

mal_export Scenario newScenario();
mal_export Scenario dropScenario();
mal_export str setScenario(Client c, str nme);
mal_export void runScenario(Client c);
mal_export void fillScenario(Client c, Scenario scen);
mal_export void clrScenario(Client c);

mal_export str defaultScenario(Client c);   /* used in src/mal/mal_session.c */
mal_export void exitScenario(Client c);     /* used in src/mal/mal_session.c */

mal_export void showCurrentScenario();
mal_export void showScenarioByName(stream *f, str s);
mal_export void showScenario(stream *f, Scenario s);
mal_export void showAllScenarios(stream *f);
mal_export void resetScenario(Client c);
mal_export str setScenario(Client c, str nme);
#endif /* _MAL_SCENARIO_H*/
@-
@c
#include "mal_scenario.h"
#include "mal_linker.h"  /* for getAddress() */

struct SCENARIO scenarioRec[MAXSCEN]={
{"mal", 0,0,
    0,0,
    0,0,
    "MALexitClient",0,
    "MALreader",    0,0,
    "MALparser",    0, 0,
    "MALoptimizer", 0, 0,
    0,      0, 0,
    "MALengine",    0, 0,  0},
{"mil", 0,0,0,0,0,0,0,0,
    "MILreader",    0,0,
    "MILparser",    0, 0,
    0,      0, 0,
    0,      0, 0,
    "MILengine",    0, 0,  0},
{"sql", "SQLinit",0, "SQLexit",0,
    "SQLinitClient",0,
    "SQLexitClient",0,
    "SQLreader",    0, 0,
    "SQLparser",    0, 0,
    "SQLoptimizer", 0, 0,
    0,      0, 0,
    "SQLengine",    0, 0,  0},
{0, 0,0,0,0,0,0,0,0,
    0,      0, 0,
    0,      0, 0,
    0,      0, 0,
    0,      0, 0,
    0,  0, 0,  0}
};

@-
Currently each user can define a new scenario, provide we have a free slot.
Scenarios not hardwired can always be dropped.
@c
Scenario getFreeScenario(){
    int i;
    Scenario scen= NULL;

    mal_set_lock(mal_contextLock,"Scenario");
    for(i=0;i<MAXSCEN && scenarioRec[i].name;i++);

    if( i==MAXSCEN)
    GDKerror("freeScenario:no scenario space left; adjust & recompile \n");
    else scen= scenarioRec+i;
    mal_unset_lock(mal_contextLock, "Scenario");

    return scen;
}
@-
@= initScen
if( @1->@2){
    if( @1->@2Cmd == 0) @1->@2Cmd = (MALfcn)getAddress( @1->@2);
    if( @1->@2Cmd == 0) {
        return throwMessage("initScenario","@2 address not found\n"); }
}
@-
A scenario is initialized only once per session. 
All other requests are silently ignored. 
After initialization, all state functions should have been set.
Initialization includes searching for the scenario startup file in
the etc/MonetDB directory. This creates a dependency, because the
malInclude also needs a scenario. To break this cycle, the system should
call once the routine default scenario for each client first.
@c
str initScenario(Client c, Scenario s){
    if(s->initScenario && s->initScenarioCmd==0){
        /* prepare for conclicts */
        mal_set_lock(mal_contextLock,"Scenario");
        s->initScenarioCmd= (MALfcn)getAddress( s->initScenario);
        if(s->initScenarioCmd) (*s->initScenarioCmd)(c);
        mal_unset_lock(mal_contextLock,"Scenario");
    }
    @:initScen(s,exitScenario)@
    @:initScen(s,initClient)@
    @:initScen(s,exitClient)@
    @:initScen(s,reader)@
    @:initScen(s,parser)@
    @:initScen(s,optimizer)@
    @:initScen(s,tactics)@
    @:initScen(s,engine)@
    fillScenario(c,s);

    return 0;
}
str defaultScenario(Client c){
    initScenario(c,scenarioRec);
    return MAL_SUCCEED;
}
@-
The Monet debugger provides an option to inspect the scenarios currently
defined.
@= scenarioCommand
    if( scen->@1) stream_printf(f," \"%s%s\",",scen->@1,
        (scen->@1Cmd?"":"?"));
    else stream_printf(f," nil,");
@c
void showScenario(stream *f, Scenario scen){
    stream_printf(f,"[ \"%s\",", scen->name);
    @:scenarioCommand(initScenario)@
    @:scenarioCommand(exitScenario)@
    @:scenarioCommand(initClient)@
    @:scenarioCommand(exitClient)@
    @:scenarioCommand(parser)@
    @:scenarioCommand(optimizer)@
    @:scenarioCommand(tactics)@
    @:scenarioCommand(engine)@
    stream_printf(f,"]\n");
}
void showScenarioByName(stream *f, str s){
    int i;
    Scenario scen= scenarioRec;

    for(i=0;i<MAXSCEN && scen->name;i++, scen++)
    if( strcmp(scen->name,s)==0) showScenario(f,scen);
}
void showAllScenarios(stream *f){
    int i;
    Scenario scen= scenarioRec;

    for(i=0;i<MAXSCEN && scen->name;i++, scen++)
        showScenario(f,scen);
}
@-
Changing the scenario for a particular client invalidates the
state maintained for the previous scenario. The old scenario is
retained in the client record to facilitate propagation of 
state information, or to simply switch back to the previous one.
Before we initialize a scenario the client scenario is reset to
the MAL scenario. This implies that all scenarios are initialized
using the same scenario. After the scenario initialization file 
has been processed, the scenario phases are replaced with the
proper ones.

@c
Scenario fndScenario(str nme){
    int i;
    Scenario scen= scenarioRec;
    for(i=0;i<MAXSCEN && scen->name; i++, scen++)
    if( strcmp(scen->name,nme)==0 ) return scen;
    return 0;
}
@-
All client records should be initialized with a default
scenario, i.e. the first described in the scenario table.
@c
void fillScenario(Client c, Scenario scen){
    c->scenario= GDKstrdup(scen->name);

    c->phase[READER] = scen->readerCmd;
    c->phase[PARSER] = scen->parserCmd;
    c->phase[OPTIMIZE] = scen->optimizerCmd;
    c->phase[SCHEDULER] = scen->tacticsCmd;
    c->phase[ENGINE] = scen->engineCmd;
    c->phase[INITCLIENT] = scen->initClientCmd;
    c->phase[EXITCLIENT] = scen->exitClientCmd;
    c->state[READER] =0;
    c->state[PARSER] =0;
    c->state[OPTIMIZE] =0;
    c->state[SCHEDULER] =0;
    c->state[ENGINE] =0;
    c->state[INITCLIENT] =0;
    c->state[EXITCLIENT] =0;
    if( scen->initClientCmd)
        (*scen->initClientCmd)(c);
}
void clrScenario(Client c){
    if( c->scenario==0) return;
    GDKfree(c->scenario);
    c->scenario=0;
    c->phase[READER] = 0;
    c->phase[PARSER] = 0;
    c->phase[OPTIMIZE] = 0;
    c->phase[SCHEDULER] = 0;
    c->phase[ENGINE] = 0;
    c->phase[INITCLIENT] =0;
    c->phase[EXITCLIENT] =0;
    c->state[READER] =0;
    c->state[PARSER] =0;
    c->state[OPTIMIZE] =0;
    c->state[SCHEDULER] =0;
    c->state[ENGINE] =0;
    c->state[INITCLIENT] =0;
    c->state[EXITCLIENT] =0;
}
@-
Setting a new scenario calls for saving the previous state
and execution of the initClientScenario routine.
@c
str setScenario(Client c, str nme){
    int i;
    str msg;
    Scenario scen= scenarioRec;

    scen = fndScenario(nme);
    if( scen== NULL)
        return throwMessage("setScenario",
            "Missing scenario specification\n");
    if(c->scenario){
        c->oldscenario = c->scenario;
        for(i=0;i<7;i++){
            c->oldstate[i] = c->state[i];
            c->oldphase[i] = c->phase[i];
        }
    }
    for(i=0;i<7;i++) c->state[i]= 0;

    msg= initScenario(c,scen);
    if(msg) return msg;
    return MAL_SUCCEED;
}
@-
After finishing a session in a scenario, we should reset the
state of the previous one. But also call the exitClient
to garbage collect any scenario specific structures.
@c
str getCurrentScenario(Client c){
    return c->scenario;
}
void resetScenario(Client c){
    int i;
    Scenario scen= scenarioRec;
    if( c->scenario==0) return;

    scen = fndScenario(c->scenario);
    if( scen!= NULL && scen->exitClientCmd)
        (*scen->exitClientCmd)(c);
    
    if(c->scenario) GDKfree(c->scenario);
    c->scenario= c->oldscenario;
    for(i=0;i<7;i++){
        c->state[i] = c->oldstate[i];
        c->phase[i] = c->oldphase[i];
    }
    c->oldscenario =0;
}
void exitScenario(Client c){
    Scenario scen= scenarioRec;
    if( c->scenario==0) return;
    scen = fndScenario(c->scenario);
    if( scen->exitScenarioCmd)
        (*scen->exitScenarioCmd)(c);
}
@}
@-
@+ Scenario Administration
The building blocks of scenarios are routines obeying a strict
signature. They all require sole access to the client
record. Any specific information should be accessible from
there, e.g. access to a scenario specific state descriptor.

The XYZparser(Client c) contains the parser for language XYZ
and should fill the mal program block associated with the client record.
The latter may have been initialized with variables. 
Each language parser may require a catalog with information
on the translation of language specific datastructures into their BAT
equivalent.

The XYZoptimizer(Client c) contains language specific optimizations
using the MAL intermediate code as a starting point.

The XYZtactics(Client c) synchronizes the program execution with the
state of the machine, e.g. claiming resources, the history of the client 
or alignment of the request with concurrent actions (e.g. transaction
coordination).

@menu
* Session management::
* Client administration::
* Session scenarios::
* MAL execution::
@end menu
@-
@{
@= runPhase
#ifdef MAL_SCENARIO_DEBUG
    stream_printf(GDKout,"start @1\n");
#endif
    if(c->phase[@1] && (msg= (str) (*c->phase[@1])(c)) ){
        /* error occurred */
#ifdef MAL_SCENARIO_DEBUG
        stream_printf(GDKout,"Error in @1 phase\n");
        if( c->mode > FINISHING && c->nxt!=c->input)
            stream_printf(GDKout,"%s",msg);
#endif
        GDKfree(msg); msg=0;
        continue;
    }
@c
void runScenario(Client c){
    str msg;
    int cnt=0;
    Client c1;

    while( c->mode > FINISHING ){
        @:runPhase(READER)@
        @:runPhase(PARSER)@
        @:runPhase(OPTIMIZE)@
        @:runPhase(SCHEDULER)@
        @:runPhase(ENGINE)@
    }
#ifdef MAL_SCENARIO_DEBUG
    printf("About to terminate scenario %s\n",c->scenario);
#endif
@-
Check if we are closing the last client, because then we also
have to call the scenario exit.
@c
    for(c1 = mal_clients; c1 < mal_clients+MAL_MAXCLIENTS; c1++) 
    if( c1->scenario && strcmp(c->scenario,c1->scenario)==0) cnt++;

    if(c->phase[EXITCLIENT] ){
#ifdef MAL_SCENARIO_DEBUG
        printf("Calling client exit function \n");
#endif
        (*c->phase[EXITCLIENT])(c);
    }
    if(cnt==1){
        exitScenario(c);
    }
}

@+ MAL scenario initialization
The scenario initialization is currently empty. However, the file should always
be available. Actually, we should move welcome messages to this script, because
it will indicate that the kernel is basically running as expected.
@mal
#print("Welcome in MAL scenario");

@-
@}
