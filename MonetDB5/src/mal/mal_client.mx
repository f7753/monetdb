@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2003 CWI.
@' All Rights Reserved.
@'
@' Contributor(s):
@'              Martin Kersten <Martin.Kersten@cwi.nl>
@'              Peter Boncz <Peter.Boncz@cwi.nl>
@'              Niels Nes <Niels.Nes@cwi.nl>
@'              Stefan Manegold  <Stefan.Manegold@cwi.nl>

@a M. L. Kersten
@v 5.0
@* Monet Client Interface
Clients gain access to the Monet server through a internet connection
or through its server console.
Access through the internet requires a Monet client program at the
source, but ordinary telnet connections can be applied when the internet
port number of the database server is publicised.

At the server, each client is represented by a session record about the
current status, such as name, file descriptors, namespace, and local stack.
Furthermore, each client session has a dedicated thread of control.
@-
The number of clients permitted concurrent access is a compile time option.
They are referenced internally by number. The console is the first and 
should always be present. It reads from standard input and writes to 
standard output.
The number of clients depends on the permissible open file descriptors. 

Client records are linked into a hierarchy, where the top record
describes system-wide resources, owned by the dba. The next layer
contains the user session descriptors.

The routines defined below provide management of the client
administration. Routines dealing with serviceing requests
are located in mal_startup.
@h
#ifndef _MAL_CLIENT_H_
#define _MAL_CLIENT_H_
#define bitset int

/* #define MAL_CLIENT_DEBUG_2*/

#include "mal_resolve.h"
#include "mal.h"

#define MAL_MAXCLIENTS	32
#define CONSOLE		0
#define isAdministrator(X) (X==mal_clients)

#define FREECLIENT	0
#define FINISHING	1	
#define CLAIMED		2
#define AWAITING	4

#define TIMEOUT		(5*60)	/* seconds */
#define PROCESSTIMEOUT	2	/* seconds */

@-
The prompt structure is designed to simplify recognition
of the language framework for interaction. For direct console
access it is a short printable ascii string. For access through
an API we assume the prompt is an ascii string surrounded by a \001
character. This simplifies recognition.
The information between the prompt brackets can be used to
pass the mode to the front-end. Moreover, the prompt can be
dropped if a single stream of information is expected from the
server(See mal_profiler.mx).

The user can request server-side compilation as part of the 
initialization string. 
The languages foreseen are SQL, MIL (Monet version 4) and MAL (Monet
Assembler Language), MDB (Monet DeBugger)
@h
typedef struct CLIENT{
	int	idx;		/* entry in mal_clients */
	str 	user;		/* user name. */
	str	password;	/* of user */
	int	sessionkey;	/* unique key addressed to session */
	int	permission;	/* access mode */
@-
The actions for a client is separated into several stages: parsing,
strategic optimization, tactial optimization, and execution. 
The routines to handle them are obtained once the scenario is choosen.
Each stage carries a state descriptor, but they share the IO state
description. A backup structure is provided
to temporarily switch to another scenario. Propagation of the state
information should be dealt with separately.[TODO]
@h
	str	scenario, oldscenario;	/* scenario management */
	void	*state[7], *oldstate[7];
	GDKfcn	phase[7], oldphase[7];
	short	itrace;		/* trace execution using interactive mdb */
	short 	debugoptimizer;
	long	timer;		/* trace time in usec */
@-
The time interval between requests are maintained. At some point
we will kill clients when their time-out value is exceeded.
A client can manipulate the timeout with a system call.
@h
	time_t		login;	
	time_t		logout;
	time_t		delay;
@-
Communication channels for the interconnect are stored here.
It is perfectly legal to have a client without input stream.
It will simple terminate after consuming the input buffer.
The monitor file descriptor can be set to trace the input received
from a particular client. This facility is used by Mapi to trace
the interaction on the system console (sysmon). 
@h
	stream	*fdin, *fdout;		/* streams from and to user. */
	int	socket;			/* socket based communication */
	str	input, output, limit;	/* IO buffers + input limit */
	str	nxt;			/* next unparsed input */
	str	prompt;			/* acknowledge prompt */
	int	promptlength;
@-
In interactive mode, reading one line at a time, we should be
aware of parsing compound structures, such as functions and
barrier blocks. The level of nesting is maintained in blkmode,
which is reset to zero upon encountering an end instruction,
or the closing bracket has been detected. Once the complete
structure has been parsed the program can be checked and executed.
Nesting is indicated using a '+' before the prompt.
@h
	int	blkmode;		/* control block parsing */
@-
The listing bit set controls the level of detail to be generated during
program execution tracing. The lowest level (1) simply dumps the input,
(2) also demonstrates the MAL internal structur (4) adds the hidden information
@h
	bitset	listing;		
@-
The debug bit set contains the debugger flags for both the GDK kernel and
the MAL layer.
@h
	bitset debug;
	stream	*sysmon;		/* trace interaction */
	stream	*journal;
	int	mode;			/* FREECLIENT..BLOCKED */
	str	cwd;			/* working directory of client */
@-
Client records are organized into a two-level dependency
tree, where children may be created to deal with parallel processing
activities. Each client runs in its own process thread. Its identity
is retained here for access by others (=father).
@h
	Thread		mythread;
	str		errbuf;		/* location of GDK exceptions */
	struct CLIENT	*father;	
@-
Each client has a private entry point into the namespace and
object space (the global variables).
Moreover, the parser needs some administration variables
to keep track of critical elements.
@h
	Scope		nspace;
	Box		ospace;
	Symbol		curprg;		/* focus of parser */
	Symbol		backup;		/* save parsing context */
	MalStkPtr	glb;		/* global variable stack */
} *Client, ClientRec;

mal_export ClientRec mal_clients[MAL_MAXCLIENTS+1];

mal_export Client	initClient(str nme, str passwd, stream *fin, stream *fout);
mal_export Client	forkClient     (Client c);
mal_export Client	getClient	();
mal_export void 	initClientThread(Client c);
mal_export void		closeClient    (Client c);
mal_export void		killClient     (Client c);
mal_export void 	freeClient	(Client c);
mal_export int 		readClient	(Client c, str prompt);
mal_export void 	setClientTrace(Client c, int flag);
mal_export str 		stopClient(Client c, str nme);
mal_export str 		stopClientIndex(Client c, int id);
mal_export str 		resumeClient(Client c, int sessionkey);
mal_export str 		suspendClient(Client c, int sessionkey, int timeout);

#endif /* _MAL_CLIENT_H_ */
@-
Upon acceptance of a connection a client record is initialized.
After initializion the client record is activated in its own
thread of control until it finds a
soft-termination request mode (FINISHING) or its IO file
descriptors are closed. This will generate an IO error, which
should lead to a safe termination.

The system administrator client runs in the primary thread of
control to simplify debugging with external debuggers.

A new Client structure can only be requested if the 'adm'
user is available, because it guarantees a way to deliver
any error message.
Searching a free client record should be encapsulated in
a critical section to hand them out one-at-a-time.
Marking them as being claimed avoids any interference from parallel
actions to obtain client records.
@c
#include "mal_client.h"

ClientRec	mal_clients[MAL_MAXCLIENTS+1];

Client newClient(){
	Client 	c;
	MT_set_lock(mal_contextLock, "newClient");
	if( mal_clients[CONSOLE].user &&
	    mal_clients[CONSOLE].mode == FINISHING){
		GDKerror("newClient:system shutdown in progress \n");
		MT_unset_lock(mal_contextLock, "newClient");
		return NULL;
	}
	for(c = mal_clients; c < mal_clients+MAL_MAXCLIENTS; c++) {
		if (c->mode == FREECLIENT) {
			c->mode= CLAIMED;
			break;
		}
	}
	MT_unset_lock(mal_contextLock, "newClient");

	if (c == mal_clients+MAL_MAXCLIENTS) {
		GDKfatal("Out of client slots\n");
		return NULL;
	}
	c->idx= c - mal_clients;
#ifdef MAL_CLIENT_DEBUG
	printf("New client created %d\n",c-mal_clients);
#endif
	return c;
}
@-
You can always retrieve a client record using the thread identifier,
because we maintain a 1-1 mapping between client and thread of control.
Therefore, we don;t need locks either.
If the number of clients becomes too large, we have to change the 
allocation and lookup scheme.
@c
Client getClient()
{
	Client c;
	Thread tid= THRget(THRgettid());
	
	for(c = mal_clients; c < mal_clients+MAL_MAXCLIENTS; c++) 
	if( c->mythread == tid) return c;

	for(c = mal_clients; c < mal_clients+MAL_MAXCLIENTS; c++) 
	if( c->mythread) stream_printf(GDKout,"client %d\n",c->mythread);
	GDKerror("unexpected call to getClient %d\n" , tid);
	return NULL;
}

@-
The arguments are private copies, which should be garbage collected
upon return;
@c
Client initClient(str nme, str passwd, stream *fin, stream *fout){
	Client 	c;
	Thread t;

	if( ( c= newClient()) == NULL) {
		if( nme != 0) GDKfree(nme);
		if( passwd != 0) GDKfree(passwd);
		return NULL;
	}

       	c->user = nme; 
	c->scenario= NULL;
	c->oldscenario = NULL;
	c->sessionkey = 0;
	c->blkmode = 0;

	c->socket= 0;
	c->fdin = fin? fin: GDKin;
	if( c->input == 0) {
		c->input = (str) GDKmalloc(BLOCK);
		c->limit = c->input + BLOCK;
	}
	c->listing = 0;
	*c->input = 0;
	c->nxt = c->input;

	c->fdout = fout?fout: GDKout;
	c->sysmon = mal_clients[0].sysmon?mal_clients[0].fdout:0;
	c->journal = NULL;
@-
The output buffer is currently not used. Beware to garbage
collect the buffer when in use.
@c
	c->output = 0;
	if(c->nspace==0)
		c->nspace = newScope(NULL, GDKstrdup("guest"));
	c->curprg = c->backup = 0;

	c->father = NULL;
	c->login = time(0); c->delay= TIMEOUT;
	c->logout= c->login+c->delay;
	c->mode = AWAITING;
	c->itrace = 0;
	c->debugoptimizer = 0;
	c->errbuf = 0;

	{ char buffer[1024];
	 	getcwd(buffer,1024);
		c->cwd= GDKstrdup(buffer);
	}
	c->prompt= GDKstrdup(">");
	c->promptlength= strlen(c->prompt);
	if( isAdministrator(c)) initClientThread(c);
	return c;
}
@-
The administrator should be initialized to enable
interpretation of the command line arguments, before
it starts serviceing statements
@c
void initClientThread(Client c)
{
	Thread t;
	c->mythread = t=  THRnew(MT_getpid(),c->user);
	GDKsetbuf( GDKmalloc(GDKMAXERRLEN));
	c->errbuf = GDKerrbuf;
	c->errbuf[0]=0;
@-
The GDK thread administration should be set to reflect use of
the proper IO descriptors.
@c
	if ( t==0) {
		GDKerror("Failed to initialize client\n");
		c->fdout->flush(c->fdout);
		(void) c->fdin->close(c->fdin);
		(void) c->fdin->close(c->fdout);
		if( c->socket) close(c->socket);
		c->socket=0;
		return ;
	}
	t->data[1] = c->fdin;
	t->data[0] = c->fdout;
} 

@- Client decendants
Forking is a relatively cheap way to create a new client.
The new client record shares the IO descriptors.
To avoid interference, we limit children to only produce 
output by closing the input-side.

If the father itself is a temporary client, let 
the new child depend on the grandfather.
@c
Client forkClient(Client father){
        Client son = NULL;
	if( father == NULL) return NULL;
	if (father->father != NULL) father = father->father;
	if ((son = initClient( GDKstrdup(father->user),
		GDKstrdup(father->password), father->fdin,father->fdout))){
		son->fdin= NULL;
		GDKfree(son->input);
		son->input = son->limit = NULL;
		son->father = father;
		son->scenario = GDKstrdup(father->scenario);
		son->prompt = GDKstrdup(father->prompt);
		son->promptlength= strlen(father->prompt);
		/* reuse the scopes wherever possible */
		son->nspace->name= GDKstrdup("Client-child");
		son->nspace->outer = mal_scope;
	}
        return son;
}

@-
When a client needs to be terminated then the file descriptors for
its input/output are simply closed. 
This leads to a graceful degradation, but may take some time
when the client is busy.
A more forcefull method is to kill the client thread, but this
may leave locks and semaphores in an undesirable state.

The routine freeClient ends a single client session,
but through side effects of sharing IO descriptors,
also its children. Conversely, a child can not close a parent.
@c
void freeClient(Client c)
{
	c->mode = FINISHING;

	/* epilogue actions have been done already */
	if (c->father == NULL) { /* normal client */
		if(c->fdin){
			(void) c->fdin->close(c->fdin);
			(void) c->fdin->destroy(c->fdin);
		}
		if( c->fdout){
			(void) c->fdout->flush(c->fdout); 
			(void) c->fdout->close(c->fdout);
			(void) c->fdout->destroy(c->fdout);
		}
		c->fdout= c->fdin= NULL;
		if( c->socket) close(c->socket); c->socket=0;
	} 
	/* forked client also */

	if( c->curprg ) freeSymbol(c->curprg);
	c->curprg= 0;
	/* scope list can not be removed, because the client may recide in a
	  quit() command. Therefore the scopelist is re-used.
	if( c->nspace) {
		freeScopeList(c->nspace);
		c->nspace=0;
	}
	*/
	/* re-use input/output buffers */
	if(c->scenario) GDKfree(c->scenario); c->scenario = NULL;
	if(c->prompt) GDKfree(c->prompt); c->prompt = NULL;
	c->promptlength=0;
	if(c->errbuf){
		GDKsetbuf(0);
		GDKfree(c->errbuf);
		c->errbuf=0;
	}
	c->father = 0;
	c->login = c->delay = c->logout = 0;
	THRdel(c->mythread);
	c->mythread= 0;
	GDKfree(c->user); c->user = NULL;
	c->mode = FREECLIENT;
}

@-
If a client disappears from the scene (eof on stream), we should
terminate all its children. This is in principle a forcefull action,
because the children may be ignoring the primary IO streams.
(Instead they may be blocked in an infinite loop)

Special care should be taken by closing the 'adm' thread.
It is permitted to leave only when it is the sole user of the system.

Furthermore, once we enter closeClient, the process in which it is
raised has already lost its file descriptors.
@c
void closeClient(Client c) {
	Client k;

#ifdef MAL_DEBUG_CLIENT
	printf("closeClient %d %s\n",c-mal_clients,c->user);
#endif
	/* kill living background clients */
	for (k = mal_clients; k < mal_clients+MAL_MAXCLIENTS; k++) {
		if ((k->mode > FINISHING) && (k->father == c)) 
			killClient(k);
	}

	/* free resources of a single thread */
	if( !isAdministrator(c)) {
		freeClient(c);
		return;
	} 

	/* adm is set to disallow new clients entering */
	mal_clients[CONSOLE].mode= FINISHING;

	for (k = mal_clients+1; k < mal_clients+MAL_MAXCLIENTS; k++) 
	if ((k->mode > FINISHING) ){
		GDKerror("closeClient:client '%s' is still active\n", k->user);
		killClient(k);
	}
	mal_exit(c);
	/* MT_global_exit(0); not needed ?*/
}

@-
Killing a (child) client is a delicate action, because the state of
the client is unknown. The current solution is to issue
a soft-termination request first by setting its mode flag. 
The client main interpreter loop should look at it upon each
cycle and terminate.

After the PROCESSTIMEOUT delay the thread is forcefully killed,
assuming it was either waiting for a lock, or external
event in any way.

The current code is not correct. It should selectively kill
a pthread, rather waiting for them to finish the request being
handled.  Since they may be waiting for IO this can take a
very long time, since we have access to the file descriptor it may
work by closing them.
@c 

void killClient(Client c){
    if (c && c->user) {
#ifdef MAL_DEBUG_CLIENT
	printf("killClient %d\n",c-mal_clients);
#endif
        Thread victim = c->mythread;
	MT_Id tid= victim->tid;
	MT_Id pid= victim->pid;

	if( victim == (Thread) THRgettid()){
		GDKerror("killClient: attempt to perform process suicide.\n");
		return;
	}
	GDKwarning("killClient:forcing client to stop ...\n");
	/* the process may hang upon gaining access to the file descriptors */
	c->mode= FINISHING;
	(void) c->fdout->flush(c->fdout);
	(void) c->fdin->close(c->fdin);
	(void) c->fdin->destroy(c->fdin); c->fdin= NULL;
	(void) c->fdout->close(c->fdout);
	(void) c->fdout->destroy(c->fdout); c->fdout= NULL;
	if( c->socket) close(c->socket); c->socket=0;

	GDKwarning("killClient:about to kill process ...\n");
	sleep(PROCESSTIMEOUT);
	pthread_kill((pthread_t)(pid-1),SIGKILL);
	sleep(PROCESSTIMEOUT);
	GDKwarning("killClient:process killed\n");
    }
}
@-
An internet connection may be terminated from the server console.
And killing the administrator this way is prohibited.
@c
str stopClientIndex(Client c, int id){
        if( ! isAdministrator(c))
                return throwMessage("stop","Only permitted from server console");
        if( id<=0 || id>=MAL_MAXCLIENTS || mal_clients[id].mode==FREECLIENT)
                return throwMessage("stop","Illegal client index");
        killClient(mal_clients+id);
	return MAL_SUCCEED;
}
str stopClient(Client c, str nme){
        if( ! isAdministrator(c))
                return throwMessage("stop","Only permitted from server console");

	MT_set_lock(mal_contextLock, "stopClient");
	for(c = mal_clients; c < mal_clients+MAL_MAXCLIENTS; c++) {
		if (c->mode > FREECLIENT && strcmp(nme,c->user)==0) {
			killClient(c);
			MT_unset_lock(mal_contextLock, "stopClient");
			return MAL_SUCCEED;
		}
	}
	MT_unset_lock(mal_contextLock, "stopClient");
	return throwMessage("stop","Illegal client name");
}
@-
A client may temporarily leave the scene by calling the routine suspend(K,T),
where K is a user defined random number to represent the session, and T is
a timeout value (in seconds). If the client returns within T seconds the changes
are high his thread of control is still avaiable and the session can be
continued where he left off.
@c
str suspendClient(Client c, int sessionkey, int timeout){
	c->sessionkey= sessionkey;
	c->delay += timeout *1000;
	
	return throwMessage("suspend","Not yet implemented");
}
str resumeClient(Client c,int sessionkey){
	return throwMessage("suspend","Not yet implemented");
}
@+ Spying on clients
To enable tracing interactions from the internet connections,
the system console can be used as a duplicate echo device.
@= sysTrace
if( c->sysmon){
	stream_printf(c->sysmon,"#[%s]",c->user);
	stream_printf(c->sysmon, @1);
	stream_printf(c->sysmon,"\n");
	c->sysmon->flush(c->sysmon);
}
@-
@c
void traceClient(str nme, int flag){
	Client c;
        for(c = mal_clients; c < mal_clients+MAL_MAXCLIENTS; c++) 
	if( c->user && strcmp(c->user,nme)==0){
#ifdef MAL_CLIENT_DEBUG
	printf("trace client %d\n",c-mal_clients);
#endif
		if( flag) c->sysmon= mal_clients[0].fdout;
		else c->sysmon= NULL;
	}
}
void traceAllClients(int flag){
	Client c;
        for(c = mal_clients; c < mal_clients+MAL_MAXCLIENTS; c++) 
	if( c->user){
		if( flag) c->sysmon= mal_clients[0].fdout;
		else c->sysmon= NULL;
	}
}
@+ Client input
The input is read from a (blocked) stream and stored in the client record
input buffer. The storage area grows automatically upon need.
Where the stream is comming from depends on the connectivity mode.

Most interactions should be regulated through the Mclient
front-end. This will also take care of buffering a request before
submission. This avoids a significant number of network interactions.
@c
static 
void enlargebuffer(Client c, int newsize){
	int i;
	int l,ln;

	l = strlen(c->input);
	ln = c->nxt-c->input;
	i = c->limit - c->input + newsize;
	c->input = (char *) GDKrealloc(c->input,i);
	c->limit = c->input+i;
	c->nxt= c->input+ln;
}

@-
Each operation received from a front-end consists of at least one line.
If it contains the text #bytes:%6d then it is assumed that a block
of data can be read in bulk mode containing the request to be processed.

Otherwise the line is interpreted as a MAL instruction and appended
to the main-procedure associated with a client record. As soon as a
statementblock is recognized, it is taken into execution.

To simplify misaligned communication with front-ends, we use different
prompts structures. [think, can we avoid acks]
@= makespace
	if( c->limit-s < BLOCK){
		enlargebuffer(c, BLOCK);
		s = c->nxt; *s = 0;
	}

@c
int readClient(Client c,str prompt){
	if( isAdministrator(c)) return streamClient(c,prompt);
	return bstreamClient(c);
}
@-
The default action is to read information from an ascii-stream
one line at a time. This is the preferred mode for reading
from terminal.
@c
int streamClient(Client c, str prompt){
	int i,free;
	str  s;
 
@-
The next statement block is to be read. Sent a prompt to warn
the front-end to issue the request.
@c
	s = c->nxt; *s = 0;
	@:makespace@

#ifdef MAL_CLIENT_DEBUG
	printf("# streamClient %s\n",c->user);
#endif
	free= c->limit - s-1;	/* reserve null byte */
	free= free>BLOCK?BLOCK:free;

	if(c->promptlength) { 
		if( c->blkmode) 
			stream_printf(c->fdout,"+%s",(prompt?prompt:c->prompt));
		else stream_printf(c->fdout,"%s",(prompt?prompt:c->prompt));
		c->fdout->flush(c->fdout);
	}
	while( (i= c->fdin->read(c->fdin,s,1,1)) == 1){
		if(*s== 13) continue; /* WIN32 */
		if(*s== 0 || *s== '\n') { *s=0; break;}
		s++;
		if( s==c->limit-1) { @:makespace@ }
	}
	if( i<=0) {
		/* end of stream reached */
		return 0;
	}
#ifdef MAL_CLIENT_DEBUG
	printf("# received %s\n",c->input);
#endif
	@:sysTrace(c->input)@
	return 1;
}
@-
In block stream mode we repeatedly read complete blocks
from the stream until we have encountered the last one.
@c
int bstreamClient(Client c, str prompt){
	str  s;
        int len = 0, size = 0;

	s = c->nxt; *s = 0;
	if( (c->limit-c->input) < BLOCK+1){
		@:makespace@
	}
	if(c->promptlength) { 
		if( c->blkmode) 
			stream_printf(c->fdout,"\001+%s\002\n",
					(prompt?prompt:c->prompt));
		else stream_printf(c->fdout,"\001%s\002\n",
					(prompt?prompt:c->prompt));
		c->fdout->flush(c->fdout);
	}
#ifdef MAL_CLIENT_DEBUG_2
printf("bstreamClient:read block\n"); fflush(stdout);
#endif

        while ((len = c->fdin->read(c->fdin, s, 1, BLOCK)) == BLOCK){
                size += len;
		s[len]=0;
#ifdef MAL_CLIENT_DEBUG_2
printf("size %d\n",size); fflush(stdout);
#endif
		if( (c->limit-c->input) - size < BLOCK+1){
			@:makespace@
		}
                s= c->input+len;
        }
	s[len]=0;
#ifdef MAL_CLIENT_DEBUG_2
	printf("# received [%d] %s\n",size,c->input);
#endif
	@:sysTrace(c->input)@
	return len != 0;
}
