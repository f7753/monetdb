@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@' 
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@' 
@' The Original Code is the Monet Database System.
@' 
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2004 CWI.
@' All Rights Reserved.
@' 
@' Contributor(s):
@' 		Martin Kersten <Martin.Kersten@cwi.nl>
@' 		Peter Boncz <Peter.Boncz@cwi.nl>
@' 		Niels Nes <Niels.Nes@cwi.nl>
@' 		Stefan Manegold  <Stefan.Manegold@cwi.nl>

@f mal
@T
\newpage
\tableofcontents
\clearpage
 \newpage
{\tt WARNING: This documentation is in flux. It has been derived
from the Monet V5 code base by simple insertion of the hiding levels.
}
@* Introduction
The MonetDB product family consists of a large number of components
developed within out group over the last decade. Some components have
already been shipped to happy customers, some are still in the making,
and others have found a resting place in the attic.

MonetDB Version 5 is a major departure from the previous MonetDB database
kernel versions. The most notable differences are its
improved software stack and a new interface language,
which turns the database server backend into an
abstract database machine with its associated assembler language (MAL).

The architecture is designed to accomodate a wide-spectrum 
of query language front-ends (SQL,RAM,MIL,XQUERY),
a variety of query transformation schemes, and
different execution platforms (interpreted MAL, x100, and
dynamic compilation).

The system expands the MonetDB software infrastructure, distributed
already in the open source community. In particular, it supports backward
compatability of interfaces, tools, and source sharing where
feasible within the limited scope of resources available.

This interface is designed for ease of interpretation, versatility and
flexible to accommodate system debugging and application tool development.
Although a textual interface potentially leads to a performance degradation,
our experience with earlier systems,
showed that the overhead can be kept within acceptable limits.
Moreover, a textual interface reduces the programming
effort otherwise needed to develop test and application programs.

In the remainder of this section we shortly introduce the
MonetDB product familiy, the design considerations and
a quick overview of the MonetDB Version 5 architecture.

@+ Backward compatibility
@T
In the development of Version 5 the requirements of the
following components are taken into account.
\begin{itemize}
\item {\em front-ends} SQL and Xquery should compile 
directly on both old and new versions. MIL programs can
mostly be converted to the MAL language.\footnote{
Only those features are compiled that do not require runtime
knowledge on the typeing structure.}
\item {\em back-ends}. Both  GDK, column buffer managers, and 
possibly the x100 kernel can targets for execution.
\item {\em extension modules}, the key extensions to the GDK kernel
are mostly carried over without change.
\item{\em nested BATs} are not supported anymore, due to unnecessary
complexity at the language layer. However, the concept of a BAT type
is retained, it denotes the bat of interest with a guarantee
that the bat was not removed after it got referenced.
\item{\em auxilliary search paths} are not supported, due to lack
of interest in Version 4 user community.
\end{itemize}
@+ Design considerations
@T
Redesign of the MonetDB software stack was driven by the need to
reduce the Total Execution Cost (TEC) for query execution.
The TEC is what an end-user or application program will
notice. The TEC is composed on several cost factors:
\begin{itemize}
\item  API messages
\item  Parsing and semantic analysis
\item  Optimization and plan generation
\item  Data access to the operands
\item  Execution of the query terms
\item  Result construction
\item  Answer delivery to the application
\end{itemize}

Choosing an architecture for processing database operations pre-supposes an
intuition on where and how the cost will be distributed. In an OLTP
setting you expect most of the cost to be in \{P,O\}, while in OLAP it will
be \{D,E,R,A\}. In a distributed setting the components \{O,D,E\} are dominant.
Web-applications would focus on \{A,E,R,A\}.

However, such a simple first characterization ignores the wide-spread
differences that can be experienced at each level. To illustrate,
in D and R it makes a big difference whether the data is already in the
cache or still on disk. Within E it makes a big difference whether you
are comparing two integers, performing a math function such as Gaussian, or
a regular expression evaluation on a string.
As a result, intense optimization in one area may become completely invisible
due to being overshadowed by other cost factors.

The Version 5 infrastructure is designed to ease addressing each
of these cost factors in a well-defined way, while retaining an
option to combine the components needed for a particular situation.
This results in a PnP architecture to assemble the components
for a particular application domain and hardware platform.

@+ Architecture overview
The software stack for Version 5 is shown in 
@T \figure{architecture.gif}
@-
The top layer consists of the query language processors and their
strategic optimizers. Moreover, each language comes with its language
oriented catalog, which may, but need not be stored in the MonetDB database.

@+ MAL
@T
The target language for Version 5 is an assembler-like language,
derived as a subset of the Monet Interface Language introduced
previously. This language provides the textual interface to
the back-end, the communication between (independent) family components,
and the API.

Its design is geared to provide a controlled setting for the
query processors. They can produce algebraic representations
of query plans, which by the MAL optimizers are turned into
physical execution plans.
In this process an execution paradigm is chosen to best fit
the engines available and application needs.

The novel container model for MAL objects is a balance between hardwired
decisions based on the typing scheme
and hooks to implement those as user-defined extensions.
In particular, objects can be assembled in {\em box}es, which come
with a simple management protocol. Their implementation can be
geared towards any management style required, e.g. delivery of
read-only objects for query processing, transparency to external
resources through wrappers, and high-volume transaction support.

Much in the spirit of Version 4
MAL can be readily extended with user defined types and
service modules. 
Moreover, it supports polymorphic functions.

Furthermore, the language design is meant to support the
full breath of computational paradigms deployed in a database
setting. In particular, it should provide a clean infrastructure
to implement triggers and stream-based database applications.

@+ Functional improvements
@T
The design and implementation takes the functionality a 
significant step further. To name a few:
\begin{itemize}
\item {\em strong typing}. All instructions are strongly
typed before being executed. However, type checking depends on
the structure of the signarture, e.g. polymorphic functions are supported. 
They act as templates that produce strongly typed instanciations when needed.
\item {\em function style expressions}, 
each assignment instruction can receives multiple target results;
it forms a point in the dataflow graph. 
\item {\em factories}, to support co-routines and building
streaming applications.
\item {\em properties} The objects can be assigned properties
for use during compilation and optimization.
\end{itemize}
@-
@{
@+ Critical sections and semaphores
Monet V5 is implemented as a collection of threads. This calls for extreme
care in coding. At several places locks and semaphores are necessary
to achieve predictable results. In particular, after they are created
and when they are inspected or being modified to take decisions.
 
In the current implementation the following list of locks and semaphores
is used in the Monet layer:
@T
\begin{tabular}{|l | l | l |}\hline
Name & Used in & Protects\\
mal_contextLock       & mal_client.mx      & {\em created  }\\
\end{tabular}
 
@+ Monet Basic Definitions 
Definitions that need to included in every file of the Monet system,
as well as in user defined module implementations.
@h
#ifndef _MAL_H
#define _MAL_H

#include <gdk.h>
#include <gdk_utils.h>
#include <stream.h>

#ifdef _MSC_VER
#ifndef LIBMONET
#define mal_export extern __declspec(dllimport)
#else
#define mal_export extern __declspec(dllexport)
#endif
#else
#define mal_export extern
#endif

@+ Monet Calling Options
The number of invocation arguments is kept to a minimum.
See the MonetDB5.conf file for additional system variable settings
@
@h
#define MAXSCRIPT 64

mal_export void monet_hello();

mal_export char            monet_cwd[PATHLENGTH];
mal_export int             monet_welcome; 
mal_export str             *monet_script;

#define mal_set_lock(X,Y) if(GDKprotected) MT_set_lock(X,Y)
#define mal_unset_lock(X,Y) if(GDKprotected) MT_unset_lock(X,Y)
#define mal_up_sema(X,Y) if(GDKprotected) MT_up_sema(X,Y)
#define mal_down_sema(X,Y) if(GDKprotected) MT_down_sema(X,Y)
@c 
#include <mal.h>

char            monet_cwd[PATHLENGTH]={0};
int             monet_welcome=1; 
str             *monet_script;

@-
@}
@+ MAL interpretation

Startup of the Monet engine consists of two steps. First, the
system kernel libraries are loaded.
The global symbol table is initialized with pre-compiled commands
and pattern definitions.
Second, for each service thread we execute a script with predefined
MAL procedures.

The information for the first phase consists of commands 
signatures bound to actual routine implementations.
The corresponding libraries may be statically linked or dynamically loaded.
Failure to find the startup-files terminates to session, because
there is no way to activate a linked procedure.

After the initialization phase, the system prohibits dynamic loading of
C- modules by casual users. For the time being we even forbid it,
it should be part of the system startup.
The rational behind this design decision is that the free load/drop
feature of Monet V4 was hardly used and severely complicates the code.
In particular, upon each access to the global symbol table we have to be
prepaired that concurrent threads my be actively changing its structure.
Especially, dropping modules may cause sever problems by not being
able to detect references kept around.
This danger required all accesses to global information to be packaged
in a critical section, which was known to be a performance hindrence.
@-
@{
@h

mal_export int             mal_debug;
mal_export MT_Lock	mal_contextLock;

mal_export int mal_init();

/* This should be here, but cannot, as "Client" isn't known, yet ... |-(
 * For now, we move the prototype declaration to src/mal/mal_client.c,
 * the only place where it is currently used. Maybe, we should concider
 * also moving the implementation there...
 */
/* mal_export void mal_exit(Client cntxt); */	/* used in src/mal/mal_client.c */

#define MALprofiler 1		/* activate the profiler */
/* #undef MALprofiler*/


/* Listing modes are globally known */
#define LIST_INPUT      1       /* echo original input */
#define LIST_MAL_INSTR  2       /* show mal instruction */
#define LIST_MAL_TYPE   4       /* show type resolutoin */
#define LIST_MAL_BIND   8       /* show binding information*/
#define LIST_MAL_ALL    (LIST_MAL_INSTR | LIST_MAL_TYPE | LIST_MAL_BIND)

#define MAL_SUCCEED	(str) 0	/* apparently no error */
#define MALexception	"MALexception"

#define STRUCT_ALIGNED

#endif /*  _MAL_H*/
@c
#include "mal_client.h"
#include "mal_linker.h"
#include "mal_session.h"
#include "mal_parser.h"
#include "mal_interpreter.h"
#include "mal_namespace.h"	/* for initNamespace() */

int             mal_debug= 0;
MT_Lock		mal_contextLock=0;
@-
Initialization of the MAL context
The compiler directive STRUCT_ALIGNED tells that the
fields in the VALrecord all start at the same offset.
This knowledge avoids low-level type decodings, but should
be assured at least once.
@c

void tstAligned()
{
	int allAligned=0;
	ValRecord v;
	ptr val, base;
	base = (ptr) & v.val.ival; 
	val= (ptr) & v.val.ival; if(val != base){allAligned = -1; return;}
	val= (ptr) & v.val.bval; if(val != base){allAligned = -1; return;}
	val= (ptr) & v.val.cval[0]; if(val != base){allAligned = -1; return;}
	val= (ptr) & v.val.shval; if(val != base){allAligned = -1; return;}
	val= (ptr) & v.val.br.id; if(val != base){allAligned = -1; return;}
	val= (ptr) & v.val.ival; if(val != base){allAligned = -1; return;}
	val= (ptr) & v.val.oval; if(val != base){allAligned = -1; return;}
	val= (ptr) & v.val.pval; if(val != base){allAligned = -1; return;}
	val= (ptr) & v.val.fval; if(val != base){allAligned = -1; return;}
	val= (ptr) & v.val.dval; if(val != base){allAligned = -1; return;}
	val= (ptr) & v.val.lval; if(val != base){allAligned = -1; return;}
	val= (ptr) & v.val.sval; if(val != base){allAligned = -1; return;}
	allAligned = 1;
#ifdef STRUCT_ALIGNED
	if(allAligned<0)
		GDKfatal("Recompile with STRUCT_ALIGNED flag disabled\n");
#else
	if(allAligned>0)
		GDKfatal("Recompile with STRUCT_ALIGNED flag enabled\n");
#endif
}
int mal_init(){
	GDKprotect();
	mal_contextLock= MT_create_lock();
	tstAligned();
	initNamespace();
	initParser();
        if( malStartupAdmin() == 0) return -1;
	return 0;
}
@-
Upon exit we should attempt to remove all allocated memory explicitly.
This seemingly superflous action is necessary to simplify memory leakage
problems later on.
Unfortunately the GDK layer is does not clean-up upon exit.
@c
void mal_exit(Client cntxt){
#ifdef MALprofiler
	profileReport( cntxt->nspace,1, open_wastream("/tmp/Monet.prof"));
#endif
	freeScopeList(cntxt->nspace);
	freeBoxes();
	mal_scope = 0;
	unloadModuleLibraries();
	TMcommit();
	finishNamespace();
	GDKexit(1);
}
@}
