@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@' 
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@' 
@' The Original Code is the Monet Database System.
@' 
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2004 CWI.
@' All Rights Reserved.
@' 
@' Contributor(s):
@' 		Martin Kersten <Martin.Kersten@cwi.nl>
@' 		Peter Boncz <Peter.Boncz@cwi.nl>
@' 		Niels Nes <Niels.Nes@cwi.nl>
@' 		Stefan Manegold  <Stefan.Manegold@cwi.nl>

@f mal
@T
\newpage
\tableofcontents
\newpage
 
@* Introduction

Monet Version 5 is a major departure from the previous Monet database
kernel versions. The most notable differences are its
improved software stack and a new interface language,
which turns the database server backend into an
abstract database machine with its associated assembler language (MAL).

The architecture is designed to accomodate a wide-spectrum 
of query language front-ends (SQL,RAM,MIL,XQUERY),
a variety of query transformation schemes, and
different execution platforms (interpreted MAL, x100, and
dynamic compilation).

The system expands upon the software infrastructure and distributed
in the open source community. In particular, it supports backward
compatability of interfaces, tools, and source sharing where
feasible within the limited scope of resources available.

In the remainder of this section we shortly introduce the
MonetDB product familiy, the design considerations and
a quick overview of the Monet Version 5 architecture.

This interface is designed for ease of interpretation, versatility and
flexible to accommodate system debugging and application tool development.
Although a textual interface potentially leads to a performance degradation,
our experience with earlier systems,
showed that the overhead can be kept within acceptable limits.
Moreover, a textual interface reduces the programming
effort otherwise needed to develop test and application programs.

@+ MonetDB product family
@T
The MonetDB product family consists of a large number of components
developed within out group over the last decade. Some components have
already been shipped to happy customers, some are still in the making,
and others have found a resting place in the attic.

In de the development of Monet V5 the requirements of the
following components are taken into account.
\begin{itemize}
\item {\em SQL front-end}
\item {\em GDK back-end}
\item {\em Plain modules}, the key extensions to the GDK kernel
described in user defined modules.
\end{itemize}
@+ Design considerations
@T
Redesign of the Monet software stack was driven by the need to
reduce the Total Execution Cost (TEC) for query execution.
The TEC is what an end-user of application program will
notice. The TEC is composed on several cost factors:
\begin{itemize}
\item - Messaging with the API
\item - Parsing
\item - Optimization and code generation
\item - Data access to the operands
\item - Execution of the query term,
\item - Result construction
\item - Answer delivery to the application
\end{itemize}

Choosing an architecture for processing database operations pre-supposes an
intuition on where and how the cost will be distributed. In an OLTP
setting you expect most of the cost to be in PO, while in OLAP it will
be DERA. In a distributed setting the components ODE are dominant.
Web-applications would focus on AE.

However, such a simple first characterization ignores the wide-spread
differences that can be experienced at each level. To illustrate,
in D and R it makes a big difference whether the data is already in the
cache of still on disk. Within E it makes a big difference whether you
are comparing 2 integers, performing an math function such as Log, or
a regular expression evaluation on a string.
As a result, intense optimization in one area may become completely invisible
due to other cost factors.

The Monet V5 infrastructure is designed to ease addressing each
of these cost factors in a well-defined way, while retaining an
option to combine the components needed for a particular situation.

@+ Architecture overview
The software stack for Monet V5 is shown in @T\figure{architecture.gif}@
The top layer consists of the query language processors and their
strategic optimizers. Moreover, each language comes with its language
oriented catalog, which may, but need not be stored in the Monet V5
kernel.
@-
@- MAL
The target language for Monet V5 is an assembler-like language,
derived as a subset of the Monet Interface Language introduced
previously. This language provides the textual interface to
the back-end, the communication between (independent) family component,
and the API.
@+ Functional improvements
The design and implementation of Monet V5 takes the functionality a 
significant step further. To name a few:
\begin{itemize}
\item {\em strong typing}, to better deal with compile time errors
\item {\em function style expressions}, 
\item {\em triggers and stream functions}
\end{itemize}

@{
@+ Critical sections and semaphores
Monet V5 is implemented as a collection of threads. This calls for extreme
care in coding. At several places locks and semaphores are necessary
to achieve predictable results. In particular, after they are created
and when they are inspected or being modified to take decisions.
 
In the current implementation the following list of locks and semaphores
is used in the Monet layer:
@T
\begin{tabular}{|l | l | l |}\hline
Name & Used in & Protects\\
mal_contextLock       & mal_client.mx      & {\em created  }\\
\end{tabular}
 
@+ Monet Basic Definitions 
Definitions that need to included in every file of the Monet system,
as well as in user defined module implementations.
@h
#ifndef _MAL_H
#define _MAL_H

#include <gdk.h>
#include <stream.h>

#ifdef _MSC_VER
#ifndef LIBMONET
#define mal_export extern __declspec(dllimport)
#else
#define mal_export extern __declspec(dllexport)
#endif
#else
#define mal_export extern
#endif

#define MONET_ADMIN	"admin"

@+ Monet Calling Options
The number of invocation arguments is kept to a minimum.
See the monet.conf file for additional system variable settings
@
@h
#define MAXSCRIPT 64

mal_export void monet_hello();

mal_export char            monet_cwd[PATHLENGTH];
mal_export int             monet_welcome; 
mal_export str             *monet_script;
mal_export str             monet_mod_path;
mal_export str             monet_mal_path;
@c 
#include <mal.h>

char            monet_cwd[PATHLENGTH]={0};
int             monet_welcome=1; 
str             *monet_script;
str             monet_mod_path;
str             monet_mal_path;


@+ MAL interpretation

Startup of the Monet engine consists of two steps. First, the
system kernel libraries are loaded.
The global symbol table is initialized with pre-compiled commands
and pattern definitions.
Second, for each service thread we execute a script with predefined
MAL procedures.

The information for the first phase consists of commands 
signatures bound to actual routine implementations.
The corresponding libraries may be statically linked or dynamically loaded.
Failure to find the startup-files terminates to session, because
there is no way to activate a linked procedure.

After the initialization phase, the system prohibits dynamic loading of
C- modules by casual users. For the time being we even forbid it,
it should be part of the system startup.
The rational behind this design decision is that the free load/drop
feature of Monet V4 was hardly used and severely complicates the code.
In particular, upon each access to the global symbol table we have to be
prepaired that concurrent threads my be actively changing its structure.
Especially, dropping modules may cause sever problems by not being
able to detect references kept around.
This danger required all accesses to global information to be packaged
in a critical section, which was known to be a performance hindrence.
@h

mal_export int             mal_debug;
mal_export MT_Lock	mal_contextLock;

mal_export int mal_init(str modpath, str prefix);

/* This should be here, but cannot, as "Client" isn't known, yet ... |-(
 * For now, we move the prototype declaration to src/mal/mal_client.c,
 * the only place where it is currently used. Maybe, we should concider
 * also moving the implementation there...
 */
/* mal_export void mal_exit(Client cntxt); */	/* used in src/mal/mal_client.c */

#define MALprofiler 1		/* activate the profiler */
/* #undef MALprofiler*/


/* Listing modes are globally known */
#define LIST_INPUT      1       /* echo original input */
#define LIST_MAL_INSTR  2       /* show mal instruction */
#define LIST_MAL_TYPE   4       /* show type resolutoin */
#define LIST_MAL_BIND   8       /* show binding information*/
#define LIST_MAL_ALL    (LIST_MAL_INSTR | LIST_MAL_TYPE | LIST_MAL_BIND)

#define MAL_SUCCEED	(str) 0	/* apparently no error */
#define MALexception	"MALexception"

#define STRUCT_ALIGNED

#endif /*  _MAL_H*/
@c
#include "mal_client.h"
#include "mal_linker.h"
#include "mal_session.h"
#include "mal_parser.h"
#include "mal_interpreter.h"
#include "mal_namespace.h"	/* for initNamespace() */

int             mal_debug= 0;
MT_Lock		mal_contextLock=0;
@-
Initialization of the MAL context
The compiler directive STRUCT_ALIGNED tells that the
fields in the VALrecord all start at the same offset.
This knowledge avoids low-level type decodings, but should
be assured at least once.
@c

void tstAligned()
{
	int allAligned=0;
	ValRecord v;
	ptr val, base;
	base = (ptr) & v.val.ival; 
	val= (ptr) & v.val.ival; if(val != base){allAligned = -1; return;}
	val= (ptr) & v.val.bval; if(val != base){allAligned = -1; return;}
	val= (ptr) & v.val.cval[0]; if(val != base){allAligned = -1; return;}
	val= (ptr) & v.val.shval; if(val != base){allAligned = -1; return;}
	val= (ptr) & v.val.br.id; if(val != base){allAligned = -1; return;}
	val= (ptr) & v.val.ival; if(val != base){allAligned = -1; return;}
	val= (ptr) & v.val.oval; if(val != base){allAligned = -1; return;}
	val= (ptr) & v.val.pval; if(val != base){allAligned = -1; return;}
	val= (ptr) & v.val.fval; if(val != base){allAligned = -1; return;}
	val= (ptr) & v.val.dval; if(val != base){allAligned = -1; return;}
	val= (ptr) & v.val.lval; if(val != base){allAligned = -1; return;}
	val= (ptr) & v.val.sval; if(val != base){allAligned = -1; return;}
	allAligned = 1;
#ifdef STRUCT_ALIGNED
	if(allAligned<0)
		GDKfatal("Recompile with STRUCT_ALIGNED flag disabled\n");
#else
	if(allAligned>0)
		GDKfatal("Recompile with STRUCT_ALIGNED flag enabled\n");
#endif
}
int mal_init(str modpath, str prefix){
	char buf[PATHLENGTH];

	monet_mod_path= modpath;
	snprintf(buf,PATHLENGTH,"%s/lib/MonetDB",prefix);
	monet_mal_path= GDKstrdup(buf);
	mal_contextLock= MT_create_lock();
	tstAligned();
	initNamespace("T%d");
	initParser();
        if( malStartupAdmin() == 0) return -1;
	return 0;
}
@-
Upon exit we should attempt to remove all allocated memory explicitly.
This seemingly superflous action is necessary to simplify memory leakage
problems later on.
Unfortunately the GDK layer is does not clean-up upon exit.
@c
void mal_exit(Client cntxt){
#ifdef MALprofiler
	profileReport( cntxt->nspace,1, open_wastream("/tmp/Monet.prof"));
#endif
	freeScopeList(cntxt->nspace);
	freeBoxes();
	mal_scope = 0;
	unloadModuleLibraries();
	TMcommit();
	GDKexit(1);
}
@}
