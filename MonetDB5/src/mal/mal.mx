@f mal
@T
% define titlepage
@t The Monet Database System
@v Version 5.0
@a Martin L. Kersten & Peter Boncz

% create table of contents 
\newpage
\tableofcontents
\newpage
 
@* Monet
The Monet kernel library finds its roots in developing the runtime
system for an object-oriented database language Goblin in the early nineties. 
This language never reached maturity, but the code base reflects the
assumptions and chooses made many years ago.
The Monet kernel library is complemented by a textual interface, 
called the Monet Interface Language until version 5.
This language was a poor-mans programming/scripting language to
directly interact with the kernel code.

As of Version 5.0 we use an abstract machine model and an associated
Monet Assembler Language. This interface is easy to interpret, versatile and 
flexible to accommodate system debugging and application tool development.
Although a textual interface potentially leads to a performance degradation, 
our experience with earlier systems, e.g. Troll and PRISMA,
showed that the overhead can be kept within acceptable limits.
Moreover, a textual interface reduces the programming
effort otherwise needed to develop test and application programs.


@+ Critical sections and semaphores
Monet is implemented as a collection of threads. This calls for extreme
care in coding. At several places locks and semaphores are necessary
to achieve predictable results. In particular, after they are created
and when they are inspected or being modified to take decisions.
 
In the current implementation the following list of locks and semaphores
is used in the Monet layer:
@T
\begin{tabular}{|l | l | l |}\hline
Name & Used in & Protects\\
mal_contextLock       & mal_client.mx      & {\em created  }\\
\end{tabular}
 
@+ Monet Basic Definitions 
Definitions that need to included in every file of the Monet system,
as well as in user defined module implementations.
@h
/*
 * The contents of this file are subject to the Monet Public
 * License Version 1.1 (the "License"); you may not use this file
 * except in compliance with the License. You may obtain a copy of
 * the License at http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
 * 
 * Software distributed under the License is distributed on an "AS
 * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
 * implied. See the License for the specific language governing
 * rights and limitations under the License.
 * 
 * The Original Code is the Monet Database System.
 * 
 * The Initial Developer of the Original Code is CWI.
 * Portions created by CWI are Copyright (C) 1997-2002 CWI.  
 * All Rights Reserved.
 * 
 * Contributor(s): Martin Kersten <Martin.Kersten@cwi.nl>
 *		   Peter Boncz <Peter.Boncz@cwi.nl>
 *		   Niels Nes <Niels.Nes@cwi.nl>
 */
#ifndef _MAL_H
#define _MAL_H

#include <gdk.h>
#include <stream.h>

#ifdef _MSC_VER
#ifndef LIBMONET
#define mal_export extern __declspec(dllimport)
#else
#define mal_export extern __declspec(dllexport)
#endif
#else
#define mal_export extern
#endif


#define MONET_ADMIN	"adm"

@+ Monet Calling Options
The number of invocation arguments is kept to a minimum.
See the monet.conf file for additional system variable settings
@
@h
#define MAXSCRIPT 64

mal_export void monet_hello();

mal_export char            monet_cwd[PATHLENGTH];
mal_export int             monet_welcome; 
mal_export str             *monet_script;
mal_export str             monet_mod_path;
mal_export str             monet_mal_path;
@c 
#include <mal.h>

char            monet_cwd[PATHLENGTH]={0};
int             monet_welcome=1; 
str             *monet_script;
str             monet_mod_path;
str             monet_mal_path;


@+ MAL interpretation

Startup of the Monet engine consists of two steps. First, the
system kernel libraries are loaded.
The global symbol table is initialized with pre-compiled commands
and pattern definitions.
Second, for each service thread we execute a script with predefined
MAL procedures.

The information for the first phase consists of commands 
signatures bound to actual routine implementations.
The corresponding libraries may be statically linked or dynamically loaded.
Failure to find the startup-files terminates to session, because
there is no way to activate a linked procedure.

After the initialization phase, the system prohibits dynamic loading of
C- modules by casual users. For the time being we even forbid it,
it should be part of the system startup.
The rational behind this design decision is that the free load/drop
feature of Monet V4 was hardly used and severely complicates the code.
In particular, upon each access to the global symbol table we have to be
prepaired that concurrent threads my be actively changing its structure.
Especially, dropping modules may cause sever problems by not being
able to detect references kept around.
This danger required all accesses to global information to be packaged
in a critical section, which was known to be a performance hindrence.
@h

mal_export int             mal_debug;
mal_export MT_Lock	mal_contextLock;

mal_export int mal_init(str modpath, str prefix);

/* This should be here, but cannot, as "Client" isn't known, yet ... |-(
 * For now, we move the prototype declaration to src/mal/mal_client.c,
 * the only place where it is currently used. Maybe, we should concider
 * also moving the implementation there...
 */
/* mal_export void mal_exit(Client cntxt); */	/* used in src/mal/mal_client.c */

#define MALprofiler 1		/* activate the profiler */
/* #undef MALprofiler*/


/* Listing modes are globally known */
#define LIST_INPUT      1       /* echo original input */
#define LIST_MAL_INSTR  2       /* show mal instruction */
#define LIST_MAL_TYPE   4       /* show type resolutoin */
#define LIST_MAL_BIND   8       /* show binding information*/
#define LIST_MAL_ALL    (LIST_MAL_INSTR | LIST_MAL_TYPE | LIST_MAL_BIND)

#define MAL_SUCCEED	(str) 0	/* apparently no error */
#define MALexception	"MALexception"

#define STRUCT_ALIGNED

#endif /*  _MAL_H*/
@c
#include "mal_client.h"
#include "mal_linker.h"
#include "mal_session.h"
#include "mal_parser.h"
#include "mal_interpreter.h"
#include "mal_namespace.h"	/* for initNamespace() */

int             mal_debug= 0;
MT_Lock		mal_contextLock=0;
@-
Initialization of the MAL context
The compiler directive STRUCT_ALIGNED tells that the
fields in the VALrecord all start at the same offset.
This knowledge avoids low-level type decodings, but should
be assured at least once.
@c

void tstAligned()
{
	int allAligned=0;
	ValRecord v;
	ptr val, base;
	base = (ptr) & v.val.ival; 
	val= (ptr) & v.val.ival; if(val != base){allAligned = -1; return;}
	val= (ptr) & v.val.bval; if(val != base){allAligned = -1; return;}
	val= (ptr) & v.val.cval[0]; if(val != base){allAligned = -1; return;}
	val= (ptr) & v.val.shval; if(val != base){allAligned = -1; return;}
	val= (ptr) & v.val.br.id; if(val != base){allAligned = -1; return;}
	val= (ptr) & v.val.ival; if(val != base){allAligned = -1; return;}
	val= (ptr) & v.val.oval; if(val != base){allAligned = -1; return;}
	val= (ptr) & v.val.pval; if(val != base){allAligned = -1; return;}
	val= (ptr) & v.val.fval; if(val != base){allAligned = -1; return;}
	val= (ptr) & v.val.dval; if(val != base){allAligned = -1; return;}
	val= (ptr) & v.val.lval; if(val != base){allAligned = -1; return;}
	val= (ptr) & v.val.sval; if(val != base){allAligned = -1; return;}
	allAligned = 1;
#ifdef STRUCT_ALIGNED
	if(allAligned<0)
		GDKfatal("Recompile with STRUCT_ALIGNED flag disabled\n");
#else
	if(allAligned>0)
		GDKfatal("Recompile with STRUCT_ALIGNED flag enabled\n");
#endif
}
int mal_init(str modpath, str prefix){
	char buf[PATHLENGTH];

	monet_mod_path= modpath;
	snprintf(buf,PATHLENGTH,"%s/lib/MonetDB",prefix);
	monet_mal_path= GDKstrdup(buf);
	mal_contextLock= MT_create_lock();
	tstAligned();
	initNamespace("T%d");
	initParser();
        if( malStartupAdmin() == 0) return -1;
	return 0;
}
@-
Upon exit we should attempt to remove all allocated memory explicitly.
This seemingly superflous action is necessary to simplify memory leakage
problems later on.
Unfortunately the GDK layer is does not clean-up upon exit.
@c
void mal_exit(Client cntxt){
#ifdef MALprofiler
	profileReport( cntxt->nspace,1, open_wastream("/tmp/Monet.prof"));
#endif
	freeScopeList(cntxt->nspace);
	freeBoxes();
	mal_scope = 0;
	unloadModuleLibraries();
	TMcommit();
	GDKexit(1);
}

