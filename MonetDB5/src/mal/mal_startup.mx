@t MAL startup
@a M. Kersten
@v 0.0
@+ Serving Clients

For the time being we distinguish two classes of clients.
The primary client is the 'Admin', which runs directly
against the server. 
It works as a console and will be the recipient of major error messages.

Secondary lients gain access to the Monet server through a internet connection.
Access through the internet requires a Monet client program at the
source, but ordinary telnet connections can be applied when the internet
port number of the database server is publicised.

Each user has a separate scope, but the secondary clients have shared
access to the definitions available to the administrator.
The global scope and private scopes are separated by an a priori known
scope name "MAL_scope". 

@h
/*
 * The contents of this file are subject to the Monet Public
 * License Version 1.1 (the "License"); you may not use this file
 * except in compliance with the License. You may obtain a copy of
 * the License at http://www.monetsolutions.com/Download/Licensing/MonetPL-1.1.
html
 * 
 * Software distributed under the License is distributed on an "AS
 * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
 * implied. See the License for the specific language governing
 * rights and limitations under the License.
 * 
 * The Original Code is the Monet Database System.
 * 
 * The Initial Developer of the Original Code is CWI.
 * Portions created by CWI are Copyright (C) 1997-2001 CWI.  
 * All Rights Reserved.
 * 
 * Contributor(s): Martin Kersten <Martin.Kersten@cwi.nl>
 */
#ifndef _MAL_STARTUP_H
#define _MAL_STARTUP_H

#include "mal_client.h"

#define SRVINIT "startup.mal"
#define SRVORIGIN "share/Monet/startup.mal"

mal_export int malStartupAdmin(int listing);
mal_export void serveClient(void *dummy);
mal_export void resetClientPrg(Client cntxt);
mal_export void closeClientPrg(Client cntxt, int flag);
mal_export void scheduleClient(str user, int socket);
#endif /*  _MAL_STARTUP_H*/
@-
The startup script for databases recides in the administrator's
directory of each database. Upon need, its location can be overruled 
using the configuration scripts.
If initialization of the server is successful, then the MAL_scope symbol
position is being returned as the namespace entry point for the client.
@c
#include "mal_startup.h"

void startupPrelude(Client c, str fnme1, str fnme2)
{	char buf[PATHLENGTH];
	FILE *fd;
	int i;

	snprintf(buf,PATHLENGTH,"%s/",GDKdirStr);
	i= strlen(buf);
	snprintf(buf+i,PATHLENGTH-i,"%s",fnme1);
	SLASH_2_DIR_SEP(buf);
	if( (fd= fopen(buf,"r")) == NULL){
		snprintf(buf,PATHLENGTH,"%s/",GDKdistrStr);
		i= strlen(buf);
		snprintf(buf+i,PATHLENGTH-i,"%s",fnme2);
		SLASH_2_DIR_SEP(buf);
		if( (fd= fopen(buf,"r")) == NULL){
			GDKerror("FATAL:server file '%s' missing\n",fnme2);
			return;
		}
	} 
	fclose(fd);
	malImport(c,buf,0);
}

int malStartupAdmin(int listing){
	Client c;
	c= initClient(GDKstrdup("Admin"),NULL,0);
	c->nspace= newScope(NULL, GDKstrdup("Admin"));
	initLibraries();
	startupPrelude(c,SRVINIT,SRVORIGIN);
	mal_scope = c->nspace->outer;
	showErrors(c);
	/* showScopeTrail(stdout,c->nspace);*/
	return 1;
}
@+ Client main routine
Every client has a 'main' function to collect the statements.
Once the END instruction has been found, it is added to the
symbol table and a fresh container is being constructed.
Note, this scheme makes testing for recursive function calls a
little more difficult. Therefore, type checking should be performed
afterwards.

In interactive mode,  the closing statement is never reached.
The 'main' procedure is typically cleaned between successive external
messages except for its variables, which are considerd global.
@c

void resetClientPrg(Client cntxt){
        InstrPtr p;
        MalBlkPtr mb;

        cntxt->curprg = newFunction(GDKstrdup("main"));
        mb = cntxt->curprg->def;
        p = getSignature(cntxt->curprg);
        p->modname= GDKstrdup(cntxt->nspace->name);
        setVarType(mb,findVariable(mb,"main"), TYPE_int);
}
void closeClientPrg(Client cntxt, int flag){
        InstrPtr p;
        MalBlkPtr mb;
	int i;

	mb = cntxt->curprg->def;
	i = mb->stop-1;
	/* ignore empty MAL function blocks */
	p = getInstrPtr(mb,0);
	if( !(i==0 && p->token == FUNCTIONsymbol)){
		insertSymbol(cntxt->nspace,cntxt->curprg);
	} else{
		if(!flag ) /* comming from parseCommandPattern */
		{
			freeMalBlk(mb);
		} else {
		printf("freeing unused block %d \n",i);
			freeMalBlk(mb);
		}
		/* garbage collect prg ? no just empty file*/
		return;
	}
	if( flag){
		p = getInstrPtr(mb,i);
		if( p->token != ENDDEFsymbol)
			pushEndInstruction(mb);
	}
	trimMalBlk(mb);
	chkProgram(cntxt->nspace, cntxt->curprg->def);
	showErrors(cntxt);
	if( cntxt->backup){
		cntxt->curprg = cntxt->backup;
		cntxt->backup = 0;
	} else resetClientPrg(cntxt);
}
@+ Client authorization
The default method to interact with the database server is to
connect using a port number. The first line received should contain
authorization information, such as user name and a possible session key.

No encryption scheme is performed yet.

An example initialization string would be "guest:23" which indicates access
of the client named 'guest' to a session previously started under identity 23.
@c
void scheduleClient(str user, int socket)
{
	str mode;
	int key=0;
	Client c;
	int i;
	MT_Id p;
	Thread t;

	mode = strchr(user,':');
	if(mode && *mode){
		*mode= 0;
		mode++;
		mode= strchr(mode,':');
		if( mode){
			key= atol(mode+1);
		}
	}
	mode = strchr(user,'\n');
	if( mode) *mode =0;
	c= initClient(GDKstrdup(user),NULL,socket);
	c->nspace= newScope(NULL,GDKstrdup(user));
	c->nspace->outer = mal_scope;
	c->sessionkey = key;
	resetClientPrg(c);
	/*showScopeTrail(stdout,c->nspace);*/

	if( (i= MT_create_thread(&p, serveClient, (void *)c)) < 0) {
		GDKerror("initClient: can not fork new client\n");
		return;
	}
}
@+ Client services
After the client initialization has been finished, we
can start the interaction protocol. This involves parsing the
input in the context of an already defined procedure and upon
success, its execution.

In essence, this calls for an incremental parsing operation, 
because we should wait until a complete basic block has been detected.
Test, first collect the instructions before we take them all.
@-
In interactive mode, we should remove the instructions before
accepting new ones. The function signature remains the same
and the symbol table should also not be affected.
Aside from removing instruction, we should also condense the
variable stack, i.e. removing at least the temporary variables,
but maybe everything beyond a previous defined pont.

Beware that we have to cleanup the global stack as well. This to avoid
subsequent calls to find garbage information.
@c
void    resetMalBlk(MalBlkPtr mb, MalStkPtr glb){
        InstrPtr p;
        int i,j;

        for(i=1;i<mb->stop;i++){
                p= getInstrPtr(mb,i); 
                freeInstruction(p);
		mb->stmt[i] = NULL;
        }
	for(i=j=0; i< mb->vtop; ){
		if(getVarName(mb,i)[0]==TMPMARKER ) {
			freeVariable(mb,i);
			if(glb) garbageElement(&glb->stk[i]);
			i++;
		} else {
			if(i!=j){
				copyVar(mb,j,i);
				if(glb){
					glb->stk[j]= glb->stk[i];
					glb->stk[i].vtype= TYPE_int;
					glb->stk[i].val.ival= 0;
					glb->stk[i].len= 0;
				}
			}
			i++; j++;
		}
		
	}
	mb->vtop = j;
	mb->stop =1;
	mb->errors = 0;
}
@c
void serveClient(void *dummy)
{	MalBlkPtr mb;
	MalStkPtr glb;
	Client c= (Client) dummy;

	if( !isAdministrator(c) ) initClientThread(c);
@-
A stack frame is initialized to keep track of global variables.
@c
	mb= c->curprg->def;
	newStack(glb,MAXGLOBALS);
	glb->stktop =mb->vtop;
	glb->blk = mb;

	processInput(c,glb);
        garbageCollector(mb,glb);

	if( c->mode > FINISHING){
		if( isAdministrator(c)){
			OIDflushdelta =0;
			TMcommit();
		}
	}
	closeClient(c);
}
