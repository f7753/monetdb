@t MAL import
@a M. Kersten
@v 0.0
@+ MAL import
The import statement simple switches the parser to a new input file, which
takes precedence. The context for which the file should be interpreted
is determined by the module name supplied.
Typically this involves a module, whose definitions are stored at 
a known location.

@h
/*
 * The contents of this file are subject to the Monet Public
 * License Version 1.1 (the "License"); you may not use this file
 * except in compliance with the License. You may obtain a copy of
 * the License at http://www.monetsolutions.com/Download/Licensing/MonetPL-1.1.
html
 * 
 * Software distributed under the License is distributed on an "AS
 * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
 * implied. See the License for the specific language governing
 * rights and limitations under the License.
 * 
 * The Original Code is the Monet Database System.
 * 
 * The Initial Developer of the Original Code is CWI.
 * Portions created by CWI are Copyright (C) 1997-2001 CWI.  
 * All Rights Reserved.
 * 
 * Contributor(s): Martin Kersten <Martin.Kersten@cwi.nl>
 */
#ifndef _MAL_IMPORT_H
#define _MAL_IMPORT_H

#include "mal_client.h"

mal_export void slash_2_dir_sep(str fname);
mal_export void malImport(Client c, str fname,int listing);
mal_export void malImportDirect(str fname);
mal_export FILE *malOpenSource(str fname);
mal_export void processInput(Client c,MalStkPtr glb);
mal_export void evalString(Client c, str s, int listing, MalStkPtr stk);
mal_export void runScript(Client c, str fname, int listing,MalStkPtr stk);
#endif /*  _MAL_IMPORT_H*/
@-
The import context is located. If the module already exists, 
we should silently skip parsing the file. This is handled at the parser level.
The files are extracted from a default location,
namely the DBHOME/modules directory.

If the string starts with '/' or '~' the context is not changed.

Every IMPORT statement denotes a possible dynamic load library.
Make sure it is loaded as well.
@c
#include "mal_import.h"

void slash_2_dir_sep(str fname){
	char *s;
	for(s=fname;*s; s++)
	if( *s== '/') *s= '/';
}
FILE *malOpenSource(str fname){
	FILE *fd= NULL;
	char path[PATHLENGTH];

	strcpy(path,fname);
        slash_2_dir_sep(path);
	if ((fd = fopen(path, "r")) == 0) {
	    /* try to locate the file with 'mal' extension */
	    snprintf(path,PATHLENGTH, "%s.mal",path);
            if (fname[0] == DIR_SEP) {
                strcpy(path, path);
                fd = fopen(path, "r");
            } else {
	    /* try to locate the file in the module store */
		int i=0;
                snprintf(path,PATHLENGTH, "%s/mal/",GDKdirStr);
		i= strlen(path);
                snprintf(path+i,PATHLENGTH-i, "%s.mal",fname);
		slash_2_dir_sep(path);
                fd = fopen(path, "r");
		if( fd==NULL){
		/* try to locate the file in the distribution location */
			snprintf(path,PATHLENGTH, "%s/src/modules/",GDKdistrStr);
			i= strlen(path);
			snprintf(path+i,PATHLENGTH-i, "%s.mal",fname);
			slash_2_dir_sep(path);
                	fd = fopen(path, "r");
		}
            }
        }
	return fd;
}

void malImportDirect(str fname){
	Client c= getClient();
	malImport(c,fname,0);
}
void malImport(Client c, str fname,int listing){
	FILE *fd;
	long i=0,len;
	Symbol	prg;
	str	s;
	int lines=0;

	str oldinput= c->input, oldnxt=c->nxt, oldlimit= c->limit;
	int oldlisting = c->listing;
	Scope oldscope = c->nspace;
	Symbol oldprg = c->curprg;

        if ( (fd=fopen(fname,"r"))==0 && (fd= malOpenSource(fname)) == 0) {
                GDKerror("malImport: could not open file: %s\n", fname);
                return;
        }
        (void) fseek(fd,0L,SEEK_END);
        len = ftell(fd)+1;
        (void) fseek(fd,0L,0);
	c->nxt = c->input = (char *) GDKmalloc(len);
	c->limit = c->input + len ;
	if( c->input == 0)
		GDKfatal("unable to allocate buffer\n");

        i=fread(c->input, 1, len, fd);
        if( i != len - 1) GDKerror("not enough bytes read \n");
        fclose(fd);
        c->input[i] = 0;
@-
It makes sense to estimate the number of instructions in the loaded
file, because it will avoid repeated extend of the MAL block later
on. In passing, we can also get rid of the NT <cr><lf> combination.
@c
	for(s=c->input; *s; s++){
		if(*s=='\n') lines++;
		if(*s== 13) *s= ' '; /* get rid of ^M */
	}
	/* printf("%s:lines encountered %d\n",fname,lines);*/

@-
Load any associated module first, because this sets the context for
resolving addresses. 
@c
	loadModuleLibrary(fname);

	c->listing = listing;
	resetClientPrg(c);
	expandMalBlk(c->curprg->def,lines);
	c->nxt= c->input;
	if( parseMal(c)) {
		/* catched errors*/
		showErrors(c);
		goto endImport;
	}
	/* empty files should be skipped as well */
	if( c->curprg->def->stop == 1) goto endImport;

	/* printf("%s:statements %d",fname, c->curprg->def->stop);
	printf(" variables %d\n",c->curprg->def->vtop); */
	closeClientPrg(c,TRUE);
	/* locate the main procedure for the imported file */
	prg = findSymbolInScope(c->nspace,"main");
	if( prg && listing) printFunction(c->fdout,prg->def);
	
	if( prg){
		str msg;
		msg= (str) runMAL(c,prg->def,0,0,0);
		if( msg ){
			GDKerror(msg);
			GDKfree(msg);
		}
		showErrors(c);
		resetMalBlk(prg->def,0);
	} 
endImport:
	/* restore the context */
	GDKfree(c->input);
	c->listing = oldlisting;
	c->input= oldinput;
	c->limit= oldlimit;
	c->nxt = oldnxt;
	c->nspace= oldscope;
	if(oldprg) stop();
	if( c->curprg && oldprg) {
		if(c->curprg->def->stop >1 )
		printf("assertion violation, no instructions expected %d\n",
			c->curprg->def->stop);
		freeSymbol(c->curprg);
	}
	c->curprg = oldprg;
}
stop(){}
@+ File and input processing
A recurring situation is to execute a stream of simple MAL instructions
stored on a file or comes from standard input. We parse one MAL 
instruction line at a time and attempt to execute it immediately.
Note, this precludes entereing complex MAL structures on the primary
input channel, because 1) this requires complex code to keep track
that we are in 'definition mode' 2) this requires (too) carefull
typing by the user, because he can not make an typeing error

Therefore, all compound code fragments should be loaded and executed
using the run(file) command.

A stack frame is initialized to keep track of global variables.
The nesting of barrier blocks should ensure detection of the end
of the hierarchy.
@c
void processString(Client c,MalStkPtr glb)
{	str msg;
	InstrPtr p;
	MalBlkPtr mb;

	mb= c->curprg->def;
	if( glb){
		glb->stktop =mb->vtop;
		glb->blk = mb;
	}
	if( parseMal(c)) {
		showErrors(c);
		resetMalBlk(c->curprg->def,glb);
		return;
	}
	if( mb->stop == 1) return; /* nothing added */
	p= getInstrPtr(mb, mb->stop-1);
	pushEndInstruction(mb);
	chkProgram(c->nspace, c->curprg->def);
	if( mb->errors == 0){
		msg= (str) runMAL(c,mb,0,glb,0);
		if( msg ){
			GDKerror(msg);
			if( !c->listing) 
				printFunction(c->fdout,mb);
			GDKfree(msg);
		}
	} 
	showErrors(c);
	resetMalBlk(mb,glb);
	if( glb) glb->cmd= c->itrace?'n':0;
}

void processInput(Client c,MalStkPtr glb)
{	
	while(c->mode > FINISHING && readClient(c,c->prompt)){
		c->nxt= c->input;
		processString(c,glb);
	}
}
@-
Running looks much like an Import operation, except for the execution
phase. This is performed in the context of an a priori defined
stack frame. Life becomes a little complicated when the script contains
a definition.

@c
void runScript(Client c, str fname, int listing, MalStkPtr glb)
{	
	FILE *fd, *oldinput;
	int oldlisting= c->listing;
	int oldmode = c->blkmode;
	str oldprompt = c->prompt;

	oldinput= c->fdin;
	c->fdin = fd;
	c->listing = listing;
	c->blkmode = 0;
	c->prompt = "";	/* do not produce visible prompts */
	resetClientPrg(c);

	GDKerror("runScript is not yet defined\n");
	c->fdin = oldinput;
	c->listing = oldlisting;
	c->blkmode = oldmode;
	c->prompt = oldprompt;
	(void) fclose(fd);
}
void evalString(Client c, str s, int listing, MalStkPtr stk)
{	
	int oldlisting= c->listing;
	int oldmode = c->blkmode;
	str oldprompt = c->prompt;
	str oldnxt = c->nxt;
	str oldinput= c->input;
	str oldlimit = c->limit;

	c->listing = listing;
	c->blkmode = 0;
	c->prompt = "";	/* do not produce visible prompts */
	
	resetClientPrg(c);

	c->limit = s + strlen(s)+1;
	c->input = s;
	c->nxt= c->input;
	processString(c,NULL);

	c->limit= oldlimit;
	c->nxt= oldnxt;
	c->input= oldinput;
	c->listing = oldlisting;
	c->blkmode = oldmode;
	c->prompt = oldprompt;
}
