# Monet Database Server V5.0
# Copyright (c) 1993-2004, CWI. All rights reserved.
# compiled for 32biti686-pc-linux-gnu/32bit.
# config:/ufs/mk/monet5/src/mal/Tests/tst.conf
# dbfarm:/ufs/mk/monet5/Linux/var/MonetDB/dbfarm
# dbname:demo
## testing the basic functionality of the enum module
## This example illustrates use of the atomary aspect
#
#atom fruit:enum;	# to announce existence of a new type
#a:= new(:int,:str);
#insert(a,0,"apples");
#insert(a,1,"oranges");
#insert(a,2,"grapes");
#insert(a,3,"grapes");
#insert(a,5,"apples");
#insert(a,6,"apples");
#insert(a,7,"apples");
#print(a);
#enum.create(:fruit,a);
#b:= bbp.bind("fruit");
#print("located fruit");
#print(b);
#print("check encode");
#x:= enum.encode(:fruit,"apples");
#print(x);
#y:= enum.encode(:fruit, "oranges");
#print(y);
#z:= enum.encode(:fruit,"grapes");
#print(z);
#print("finding lower of apples");
#x:= enum.lower(:fruit,"apples");
#print(x);
#y:= enum.lower(:fruit, "oranges");
#print(y);
#z:= enum.lower(:fruit,"grapes");
#print(z);
#
#
function Admin.main():int;	# 0  (main:int)
    a := bbp.new(int:,str:);	# 1 CMDBATnew (a:bat[:int,:str])<-($2:int)($3:str)
    bat.insert(a,0,"apples");	# 2 BKCinsert_bun ($4:void)<-(a:bat[:int,:str])($5:int)($6:str)
    bat.insert(a,1,"oranges");	# 3 BKCinsert_bun ($7:void)<-(a:bat[:int,:str])($8:int)($9:str)
    bat.insert(a,2,"grapes");	# 4 BKCinsert_bun ($10:void)<-(a:bat[:int,:str])($11:int)($12:str)
    bat.insert(a,3,"grapes");	# 5 BKCinsert_bun ($13:void)<-(a:bat[:int,:str])($14:int)($12:str)
    bat.insert(a,5,"apples");	# 6 BKCinsert_bun ($15:void)<-(a:bat[:int,:str])($16:int)($6:str)
    bat.insert(a,6,"apples");	# 7 BKCinsert_bun ($17:void)<-(a:bat[:int,:str])($18:int)($6:str)
    bat.insert(a,7,"apples");	# 8 BKCinsert_bun ($19:void)<-(a:bat[:int,:str])($20:int)($6:str)
    io.print(a);	# 9 IOprint_val ($21:int)<-(a:bat[:int,:str])
    enum.create(fruit:,a);	# 10 ENUMcreate ($22:bat[:str,:fruit])<-($23:fruit)(a:bat[:int,:str])
    b := bbp.bind("fruit");	# 11 CMDbbpbind (b:bat[:any,:any])<-($25:str)
    io.print("located fruit");	# 12 IOprint_val ($26:int)<-($27:str)
    io.print(b);	# 13 IOprint_val ($28:int)<-(b:bat[:any,:any])
    io.print("check encode");	# 14 IOprint_val ($29:int)<-($30:str)
    x := enum.encode(fruit:,"apples");	# 15 ENUMencode (x:fruit)<-($32:fruit)($6:str)
    io.print(x);	# 16 IOprint_val ($33:int)<-(x:fruit)
    y := enum.encode(fruit:,"oranges");	# 17 ENUMencode (y:fruit)<-($35:fruit)($9:str)
    io.print(y);	# 18 IOprint_val ($36:int)<-(y:fruit)
    z := enum.encode(fruit:,"grapes");	# 19 ENUMencode (z:fruit)<-($38:fruit)($12:str)
    io.print(z);	# 20 IOprint_val ($39:int)<-(z:fruit)
    io.print("finding lower of apples");	# 21 IOprint_val ($40:int)<-($41:str)
    x := enum.lower(fruit:,"apples");	# 22 ENUMlower (x:fruit)<-($42:fruit)($43:str)
    io.print(x);	# 23 IOprint_val ($44:int)<-(x:fruit)
    y := enum.lower(fruit:,"oranges");	# 24 ENUMlower (y:fruit)<-($45:fruit)($46:str)
    io.print(y);	# 25 IOprint_val ($47:int)<-(y:fruit)
    z := enum.lower(fruit:,"grapes");	# 26 ENUMlower (z:fruit)<-($48:fruit)($49:str)
    io.print(z);	# 27 IOprint_val ($50:int)<-(z:fruit)
end main;	# 28  
#-------------------------#
# h	tmp_4		  # name
# int	str		  # type
#-------------------------#
[ 0,	  "apples"	  ]
[ 1,	  "oranges"	  ]
[ 2,	  "grapes"	  ]
[ 3,	  "grapes"	  ]
[ 5,	  "apples"	  ]
[ 6,	  "apples"	  ]
[ 7,	  "apples"	  ]
[ "located fruit" ]
#-------------------------#
# h		fruit	  # name
# str		int	  # type
#-------------------------#
[ "apples",	  4	  ]
[ "grapes",	  2	  ]
[ "oranges",	  1	  ]
[ "check encode" ]
[ apples ]
[ oranges ]
[ grapes ]
[ "finding lower of apples" ]
[ apples ]
[ oranges ]
[ grapes ]
>