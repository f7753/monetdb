# Monet Database Server V5.0
# Copyright (c) 1993-2004, CWI. All rights reserved.
# compiled for 32biti686-pc-linux-gnu/32bit.
# config:/ufs/mk/monet5/src/mal/Tests/tst.conf
# dbfarm:/ufs/mk/monet5/Linux/var/MonetDB/dbfarm
# dbname:demo
##The 2000 serie  is focussed on parallelism
## Example of a simple producer/consumer pair
#
#
#	cWait:= true;	#consumer put to sleep
#	pWait:= true;	#consumer put to sleep
#
#thread 	producer;	
#	printf("Created producer thread\n");
#barrier pBody:=true;
#barrier pWait;		# bussy loop to await for consumer 
#	printf("producer: sleep\n");
#	alarm.sleep(1);
#	redo pWait;
#exit 	pWait;
#	printf("produce an element\n");
#	pWait:= true;
#	cWait:= false;
#barrier b:= i==0;
#	leave producer;
#exit	b;
#	redo pBody;
#exit	pBody;
#	printf("Finished producer\n");
#exit	producer;
#
#thread consumer;
#	printf("Created consumer thread\n");
#barrier cBody:=true;
#barrier cWait;	
#	printf("consumer: sleep\n");
#	alarm.sleep(1);
#	redo cWait;
#exit 	cWait;
#	printf("consume element %d\n",i);
#barrier b:= i==0;
#	leave consumer;
#exit	b;
#	i:=i-1;
#	cWait:= true;
#	pWait:= false;
#	redo cBody;
#exit	cBody;
#	printf("Finished consumer\n");
#exit 	consumer;
#
#	i:= 2;
#	pWait:= false;
#	printf("await dead of producer/consumer\n");
#
!ERROR: 'printf' undefined in Admin.main[29]
!ERROR: MALresolve:Admin.main[40]:type mismatch bat[:any,:int] := int
!ERROR: barrier 'b' should be of type bit or number in main[14]
!ERROR: barrier 'b' should be of type bit or number in main[30]
function Admin.main():int;	# 0  (main:int)
    cWait := true;	# 1  (cWait:bit)<-($2:bit)
    pWait := true;	# 2  (pWait:bit)<-($2:bit)
thread producer;	# 3  (producer:int) jump 20
    io.printf("Created producer thread\n");	# 4 IOprint_str ($5:int)<-($6:str)
barrier pBody := true;	# 5  (pBody:bit)<-($2:bit) jump 18
barrier pWait;	# 6  (pWait:bit) jump 10
    io.printf("producer: sleep\n");	# 7 IOprint_str ($8:int)<-($9:str)
    alarm.sleep(1);	# 8 ALARMsleep ($10:void)<-($11:int)
    redo pWait;	# 9  (pWait:bit) jump 6
exit pWait;	# 10  (pWait:bit)
    io.printf("produce an element\n");	# 11 IOprint_str ($12:int)<-($13:str)
    pWait := true;	# 12  (pWait:bit)<-($2:bit)
    cWait := false;	# 13  (cWait:bit)<-($14:bit)
barrier b := batcalc.==(i,0);	# 14 CMDcmpEQcst (b:bat[:any,:bit])<-(i:bat[:any,:int])($17:int) jump 16
    leave producer;	# 15  (producer:int) jump 20
exit b;	# 16  (b:bat[:any,:bit])
    redo pBody;	# 17  (pBody:bit) jump 5
exit pBody;	# 18  (pBody:bit)
    io.printf("Finished producer\n");	# 19 IOprint_str ($18:int)<-($19:str)
exit producer;	# 20  (producer:int)
thread consumer;	# 21  (consumer:int) jump 39
    io.printf("Created consumer thread\n");	# 22 IOprint_str ($21:int)<-($22:str)
barrier cBody := true;	# 23  (cBody:bit)<-($2:bit) jump 37
barrier cWait;	# 24  (cWait:bit) jump 28
    io.printf("consumer: sleep\n");	# 25 IOprint_str ($24:int)<-($25:str)
    alarm.sleep(1);	# 26 ALARMsleep ($26:void)<-($11:int)
    redo cWait;	# 27  (cWait:bit) jump 24
exit cWait;	# 28  (cWait:bit)
    printf("consume element %d\n",i);	# 29  unknown ($27:any)<-($28:str)(i:bat[:any,:int])
barrier b := batcalc.==(i,0);	# 30 CMDcmpEQcst (b:bat[:any,:bit])<-(i:bat[:any,:int])($17:int) jump 32
    leave consumer;	# 31  (consumer:int) jump 39
exit b;	# 32  (b:bat[:any,:bit])
    i := batcalc.-(i,1);	# 33 CMDbatMINcst (i:bat[:any,:int])<-(i:bat[:any,:int])($11:int)
    cWait := true;	# 34  (cWait:bit)<-($2:bit)
    pWait := false;	# 35  (pWait:bit)<-($14:bit)
    redo cBody;	# 36  (cBody:bit) jump 23
exit cBody;	# 37  (cBody:bit)
    io.printf("Finished consumer\n");	# 38 IOprint_str ($29:int)<-($30:str)
exit consumer;	# 39  (consumer:int)
    i := 2;	# 40  unknown (i:bat[:any,:int])<-($31:int)
    pWait := false;	# 41  (pWait:bit)<-($14:bit)
    io.printf("await dead of producer/consumer\n");	# 42 IOprint_str ($32:int)<-($33:str)
end main;	# 43  
>