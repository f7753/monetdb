#inspection of the runtime setting
#it uses the dynamic type analysis scheme

# type error when the type variable numbers are ignored
#function get(br:bat[:any,:any],nme:str, title:str):bat;
function get(br:bat[:any$1,:any$2],nme:str, title:str):bat[:any$3,:any$4];
	b:bat[:int,:str] := bbp.nme();
	z:= algebra.join(br,b);
	bat.setColumn(z,title);
	return z;
end get;
# Note the type of the variables will be fixed during the first call
# Thus, a better schould would be a term rewriter call, which
# replaces an instruction
#rule get(Y:bat,N:str)
function getInt(br:bat[:any$1,:any$2],nme:str, title:str):bat[:any$3,:any$4];
	b:bat[:int,:int] := bbp.nme();
	z:= algebra.join(br,b);
	bat.setColumn(z,title);
	return z;
end getInt;
function getLng(br:bat[:any$1,:any$2],nme:str, title:str):bat[:any$3,:any$4];
	b:bat[:int,:lng] := bbp.nme();
	z:= algebra.join(br,b);
	bat.setColumn(z,title);
	return z;
end getLng;
function dir(b:bat[:int,:str]):void;
	atm:= inspect.getAtomNames();
	brev:= bat.reverse(b);
	bm := bat.mirror(brev);
	bHead:= user.get(brev,"getHeadType","htype");
	bTail:= user.get(brev,"getTailType","ttype");
	bCount:= user.getLng(brev,"getCount","count");
	bHeat:= user.getInt(brev,"getHeat","heat");
	bDirty:= user.get(brev,"getDirty","dirty");
	bStatus:= user.get(brev,"getStatus","status");
	bKind:= user.get(brev,"getKind","kind");
	bRef:= user.getInt(brev,"getRefCount","refCount");
	io.table(brev, bm, bHead,bTail,bCount, bHeat,bDirty,bStatus,bKind,bRef);
end dir;

function dir(s:str):void;
	t:= bbp.getNames();
	tn:= algebra.like(t,s);
	io.print(tn);
	user.dir(tn);
end dir;
b:= bbp.new(:int,:int);
bat.setName(b,"simplemind");

z:= bbp.getNames();
io.print("Get first directory");
user.dir(z);

io.print("Get second directory");
user.dir("simple");

