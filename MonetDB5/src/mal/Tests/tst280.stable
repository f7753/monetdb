# Monet Database Server V5.0
# Copyright (c) 1993-2002, CWI. All rights reserved.
# compiled for i686-pc-linux-gnu/32bit.
# gdk_dbfarm:/ufs/mk/monet_5-0/Linux/../dbfarm
# gdk_dbname:demo
# gdk_dbdir:/ufs/mk/monet_5-0/Linux/../dbfarm/demo
# gdk_distr:/ufs/mk/monet_5-0/Linux
# monetrc:/ufs/mk/.monet.conf
#function pow(i:int,j:int):int;
#	z:= i+j;
#	printf("result %d\n",z);
#	return z;
#end pow;
function Admin.pow(i:int,j:int):int; #0:(pow:int)<-(i:int)(j:int)
    z := calc.+(i,j); #1:(z:int)<-(i:int)(j:int)
    system.printf("result %d\n",z); #2:($4:int)<-($5:str)(z:int)
    return z; #3:(z:int)
end pow; #4:
#function tst(A2:bat[void,int],A3:bat[void,int]):bat[void,int]; 
#	print(A2);
#	resB := mal.new(void,int); 
#	bat.setSequenceBase(resB,0@0);
#	lim:= count(A2);
#	printf("count %d\n",lim);
#	m:= -1:lng;
#barrier mloop:=mal.nextElement(m,0:lng,lim); 
#	printf("loopindex %d\n",m);
#        B2 := algebra.fetch(A2,m);       
#	printf("B2 value %d\n",B2);
#        B3 := algebra.fetch(A3,m);       
#	printf("B3 value %d\n",B3);
#        cr := pow(B2,B3);
#        bat.insert(resB,nil,cr); 
#        redo mloop ;    
#catch   MALexception;  
#exit    MALexception; 
#exit    mloop;  
#        return resB;    
#end tst;   
function Admin.tst(A2:bat[void,int],A3:bat[void,int]):bat[void,int]; #0:(tst:bat[void,int])<-(A2:bat[void,int])(A3:bat[void,int])
    io.print(A2); #1:($3:int)<-(A2:bat[void,int])
    resB := mal.new(void,int); #2:(resB:bat[void,int])<-(void:void)(int:int)
    bat.setSequenceBase(resB,0@0); #3:($7:int)<-(resB:bat[void,int])($8:oid)
    lim := algebra.count(A2); #4:(lim:lng)<-(A2:bat[void,int])
    system.printf("count %d\n",lim); #5:($10:int)<-($11:str)(lim:lng)
    m := -1; #6:(m:lng)<-($13:lng)
barrier mloop := mal.nextElement(m,0,lim); #7:(mloop:bit)<-(m:lng)($15:lng)(lim:lng) jump 19
    system.printf("loopindex %d\n",m); #8:($16:int)<-($17:str)(m:lng)
    B2 := algebra.fetch(A2,m); #9:(B2:int)<-(A2:bat[void,int])(m:lng)
    system.printf("B2 value %d\n",B2); #10:($19:int)<-($20:str)(B2:int)
    B3 := algebra.fetch(A3,m); #11:(B3:int)<-(A3:bat[void,int])(m:lng)
    system.printf("B3 value %d\n",B3); #12:($22:int)<-($23:str)(B3:int)
    cr := Admin.pow(B2,B3); #13:(cr:int)<-(B2:int)(B3:int)
    bat.insert(resB,nil,cr); #14:($25:bat[void,int])<-(resB:bat[void,int])($26:void)(cr:int)
    redo mloop ; #15:(mloop:bit) jump 7
catch MALexception; #16:(MALexception:str) jump 18
exit MALexception; #17:(MALexception:str)
exit mloop; #18:(mloop:bit)
    return resB; #19:(resB:bat[void,int])
end tst; #20:
#
#	b := new(void,int);
#	setSequenceBase(b,0@0);
#	insert(b,nil,1);
#	insert(b,nil,2);
#	e:=fetch(b,1);
#	print(e);
#	print(b);
#	c:= copy(b);
#	z:= tst(b,c);
#	print(z);
#
#
function Admin.main():int; #0:(main:int)
    b := mal.new(void,int); #1:(b:bat[void,int])<-(void:void)(int:int)
    bat.setSequenceBase(b,0@0); #2:($4:int)<-(b:bat[void,int])($5:oid)
    bat.insert(b,nil,1); #3:($6:bat[void,int])<-(b:bat[void,int])($7:void)($8:int)
    bat.insert(b,nil,2); #4:($9:bat[void,int])<-(b:bat[void,int])($7:void)($10:int)
    e := algebra.fetch(b,1); #5:(e:int)<-(b:bat[void,int])($8:int)
    io.print(e); #6:($12:int)<-(e:int)
    io.print(b); #7:($13:int)<-(b:bat[void,int])
    c := algebra.copy(b); #8:(c:bat[void,int])<-(b:bat[void,int])
    z := Admin.tst(b,c); #9:(z:bat[void,int])<-(b:bat[void,int])(c:bat[void,int])
    io.print(z); #10:($16:int)<-(z:bat[void,int])
end main; #11:
[ 2 ]
#-----------------#
# BAT:	  tmp_4	  #
# (void)  (int)	  #
#-----------------#
[ 0@0,	  1	  ]
[ 1@0,	  2	  ]
#-----------------#
# BAT:	  tmp_4	  #
# (void)  (int)	  #
#-----------------#
[ 0@0,	  1	  ]
[ 1@0,	  2	  ]
count 2
loopindex 0
B2 value 1
B3 value 1
result 2
loopindex 1
B2 value 2
B3 value 2
result 4
#-----------------#
# BAT:	  tmp_6	  #
# (void)  (int)	  #
#-----------------#
[ 0@0,	  2	  ]
[ 1@0,	  4	  ]
>