stdout of test 'tst2040` in directory 'src/mal` itself:


# 08:01:00 >  
# 08:01:00 >  Mtimeout -timeout 60 Mserver "--config=/ufs/mk/monet5/Linux/etc/MonetDB5.conf" --debug=10 --set "monet_mod_path=/ufs/mk/monet5/Linux/lib/MonetDB5:/ufs/mk/opensource/MonetDB/Linux/lib/MonetDB" --set "gdk_dbfarm=/ufs/mk/monet5/Linux/var/MonetDB5/dbfarm" --set "sql_logdir=/ufs/mk/monet5/Linux/var/MonetDB5/log" --set mapi_port=42158 --set sql_port=55708 --set monet_prompt= --trace "--config=/ufs/mk/monet5/src/mal/Tests/All.conf" --dbname=mTests_src_mal  tst2040.mal </dev/null
# 08:01:00 >  

# Monet Database Server V4.99.19
# Copyright (c) 1993-2004, CWI. All rights reserved.
# Compiled for i686-redhat-linux-gnu/32bit; dynamically linked.
# config:/ufs/mk/monet5/Linux/etc/MonetDB5.conf
# dbfarm:/ufs/mk/monet5/Linux/var/MonetDB5/dbfarm
# dbname:mTests_src_mal
# Visit http://monetdb.cwi.nl/ for further information.
##The 2000 serie  is focussed on parallelism
## Example of a simple producer/consumer pair
#
#
#	cWait:= true;	#consumer put to sleep
#	pWait:= true;	#consumer put to sleep
#
#thread 	producer;	
#	printf("Created producer thread\n");
#barrier pBody:=true;
#barrier pWait;		# bussy loop to await for consumer 
#	printf("producer: sleep\n");
#	alarm.sleep(1);
#	redo pWait;
#exit 	pWait;
#	printf("produce an element\n");
#	pWait:= true;
#	cWait:= false;
#barrier b:= i==0;
#	leave producer;
#exit	b;
#	redo pBody;
#exit	pBody;
#	printf("Finished producer\n");
#exit	producer;
#
#thread consumer;
#	printf("Created consumer thread\n");
#barrier cBody:=true;
#barrier cWait;	
#	printf("consumer: sleep\n");
#	alarm.sleep(1);
#	redo cWait;
#exit 	cWait;
#	printf("consume element %d\n",i);
#barrier b:= i==0;
#	leave consumer;
#exit	b;
#	i:=i-1;
#	cWait:= true;
#	pWait:= false;
#	redo cBody;
#exit	cBody;
#	printf("Finished consumer\n");
#exit 	consumer;
#
#	i:= 2;
#	pWait:= false;
#	printf("await dead of producer/consumer\n");
#
!ERROR: 'calc.==' undefined in user.main[19]
!ERROR: 'io.printf' undefined in user.main[34]
!ERROR: 'calc.==' undefined in user.main[35]
!ERROR: 'calc.-' undefined in user.main[38]
!ERROR: 'i' may not be used before being set in main[19]
!ERROR: 'i' may not be used before being set in main[34]
!ERROR: 'i' may not be used before being set in main[35]
!ERROR: 'i' may not be used before being set in main[38]
function user.main():int;	# 0  (main:int)
#The 2000 serie  is focussed on parallelism 	# 1  ($2:str)
# Example of a simple producer/consumer pair 	# 2  ($4:str)
    cWait := true;	# 3  (cWait:bit)<-($6:bit)
#consumer put to sleep 	# 4  ($8:str)
    pWait := true;	# 5  (pWait:bit)<-($6:bit)
#consumer put to sleep 	# 6  ($8:str)
thread producer;	# 7  (producer:any) jump 25
    io.printf("Created producer thread\n");	# 8 IOprint_str ($12:int)<-($13:str)
barrier pBody := true;	# 9  (pBody:bit)<-($6:bit) jump 23
barrier pWait;	# 10  (pWait:bit) jump 15
# bussy loop to await for consumer  	# 11  ($16:str)
    io.printf("producer: sleep\n");	# 12 IOprint_str ($17:int)<-($18:str)
    alarm.sleep(1);	# 13 ALARMsleep ($19:void)<-($20:int)
    redo pWait;	# 14  (pWait:bit) jump 11
exit pWait;	# 15  (pWait:bit)
    io.printf("produce an element\n");	# 16 IOprint_str ($21:int)<-($22:str)
    pWait := true;	# 17  (pWait:bit)<-($6:bit)
    cWait := false;	# 18  (cWait:bit)<-($23:bit)
barrier b := calc.==(i,0);	# 19  unknown (b:any)<-(i:int)($26:int) jump 21
    leave producer;	# 20  (producer:any) jump 25
exit b;	# 21  (b:any)
    redo pBody;	# 22  (pBody:bit) jump 10
exit pBody;	# 23  (pBody:bit)
    io.printf("Finished producer\n");	# 24 IOprint_str ($27:int)<-($28:str)
exit producer;	# 25  (producer:any)
thread consumer;	# 26  (consumer:any) jump 44
    io.printf("Created consumer thread\n");	# 27 IOprint_str ($30:int)<-($31:str)
barrier cBody := true;	# 28  (cBody:bit)<-($6:bit) jump 42
barrier cWait;	# 29  (cWait:bit) jump 33
    io.printf("consumer: sleep\n");	# 30 IOprint_str ($33:int)<-($34:str)
    alarm.sleep(1);	# 31 ALARMsleep ($35:void)<-($20:int)
    redo cWait;	# 32  (cWait:bit) jump 30
exit cWait;	# 33  (cWait:bit)
    io.printf("consume element %d\n",i);	# 34  unknown ($36:any)<-($37:str)(i:int)
barrier b := calc.==(i,0);	# 35  unknown (b:any)<-(i:int)($26:int) jump 37
    leave consumer;	# 36  (consumer:any) jump 44
exit b;	# 37  (b:any)
    i := calc.-(i,1);	# 38  unknown (i:int)<-(i:int)($20:int)
    cWait := true;	# 39  (cWait:bit)<-($6:bit)
    pWait := false;	# 40  (pWait:bit)<-($23:bit)
    redo cBody;	# 41  (cBody:bit) jump 29
exit cBody;	# 42  (cBody:bit)
    io.printf("Finished consumer\n");	# 43 IOprint_str ($38:int)<-($39:str)
exit consumer;	# 44  (consumer:any)
    i := 2;	# 45  (i:int)<-($40:int)
    pWait := false;	# 46  (pWait:bit)<-($23:bit)
    io.printf("await dead of producer/consumer\n");	# 47 IOprint_str ($41:int)<-($42:str)
end main;	# 48  

# 08:01:00 >  
# 08:01:00 >  Done.
# 08:01:00 >  

