# Mil compiler Version 1.0)
# Copyright (c) 1993-2001, CWI. All rights reserved.

# Predefined code segment
## the following implementation paths in the standard pump implementation exist:
##
## proc_sorted
## proc_hash
## packed_sorted
## packed_hash
## direct_sorted_chr
## direct_sorted_sht
## direct_sorted_int
## direct_sorted_void
## direct_hash_chr
## direct_hash_sht
## direct_hash_int
## direct_idx_chr
## direct_idx_sht
## direct_idx_int
##
## this script intends to test them all.
use "kernel/aggr";
#module(aggr);
#
	aa_a := bat(int,str);
	ba_a := insert(aa_a,1,"1");
	ca_a := insert(ba_a,2,"2");
	b_int:= take("b_int");
	b_int := insert(ca_a,1,"1");
#b_int := bat(int,str).insert(1,"1").insert(2,"2").insert(1,"1");
	da_a := insert(b_int,3,"3");
	ea_a := insert(da_a,4,"4");
	fa_a := insert(ea_a,5,"5");
	ga_a := insert(fa_a,6,"6");
#b_int.insert(3,"3").insert(4,"4").insert(5,"5").insert(6,"6");
	ha_a := insert(b_int,3,"3");
	ia_a := insert(ha_a,4,"4");
	ja_a := insert(ia_a,5,"5");
	ka_a := insert(ja_a,6,"6");
#b_int.insert(3,"3").insert(4,"4").insert(5,"5").insert(6,"6");
	la_a := reverse(b_int);
	ma_a := multiplex.sht(la_a);
	b_sht:= take("b_sht");
	b_sht := reverse(ma_a);
#b_sht := [sht](b_int.reverse).reverse;
	na_a := reverse(b_int);
	oa_a := multiplex.chr(na_a);
	b_chr:= take("b_chr");
	b_chr := reverse(oa_a);
#b_chr := [chr](b_int.reverse).reverse;
	pa_a := reverse(b_int);
	qa_a := multiplex.str(pa_a);
	b_str:= take("b_str");
	b_str := reverse(qa_a);
#b_str := [str](b_int.reverse).reverse;
	ra_a := bat(void,str);
	sa_a := insert(ra_a,nil,"1");
	ta_a := insert(sa_a,nil,"2");
	v_oid:= take("v_oid");
	v_oid := insert(ta_a,nil,"3");
#v_oid := bat(void,str).insert(nil,"1").insert(nil,"2").insert(nil,"3");
	ua_a := insert(v_oid,nil,"4");
	va_a := insert(ua_a,nil,"5");
	wa_a := insert(va_a,nil,"6");
	xa_a := seqbase(wa_a,1@0);
#v_oid.insert(nil,"4").insert(nil,"5").insert(nil,"6").seqbase(1@0);
#
	ya_a := bat(int,void);
	ab_a := insert(ya_a,1,nil);
	bb_a := insert(ab_a,3,nil);
	cb_a := insert(bb_a,4,nil);
	e_int:= take("e_int");
	e_int := insert(cb_a,5,nil);
#e_int := bat(int,void).insert(1,nil).insert(3,nil).insert(4,nil).insert(5,nil);
	db_a := insert(e_int,6,nil);
	eb_a := insert(db_a,7,nil);
	fb_a := insert(eb_a,8,nil);
	gb_a := setColumn(fb_a,"e_int");
#e_int.insert(6,nil).insert(7,nil).insert(8,nil).setColumn("e_int");
	hb_a := reverse(e_int);
	ib_a := multiplex.sht(hb_a);
	jb_a := reverse(ib_a);
	e_sht:= take("e_sht");
	e_sht := setColumn(jb_a,"e_sht");
#e_sht := [sht](e_int.reverse).reverse.setColumn("e_sht");
	kb_a := reverse(e_int);
	lb_a := multiplex.chr(kb_a);
	mb_a := reverse(lb_a);
	e_chr:= take("e_chr");
	e_chr := setColumn(mb_a,"e_chr");
#e_chr := [chr](e_int.reverse).reverse.setColumn("e_chr");
	nb_a := reverse(e_int);
	ob_a := multiplex.str(nb_a);
	pb_a := reverse(ob_a);
	e_str:= take("e_str");
	e_str := setColumn(pb_a,"e_str");
#e_str := [str](e_int.reverse).reverse.setColumn("e_str");
	qb_a := reverse(e_int);
	rb_a := multiplex.oid(qb_a);
	sb_a := reverse(rb_a);
	e_oid:= take("e_oid");
	e_oid := setColumn(sb_a,"e_oid");
#e_oid := [oid](e_int.reverse).reverse.setColumn("e_oid");
#
#
	tests:= take("tests");
	tests := bat(bat,bat);
#tests := bat(bat,bat);
	tb_a := setColumn(b_int,"b_int");
	ub_a := insert(tests,tb_a,e_int);
#tests.insert(b_int.setColumn("b_int"), e_int);
	vb_a := setColumn(b_sht,"b_sht");
	wb_a := insert(tests,vb_a,e_sht);
#tests.insert(b_sht.setColumn("b_sht"), e_sht);
	xb_a := setColumn(b_chr,"b_chr");
	yb_a := insert(tests,xb_a,e_chr);
#tests.insert(b_chr.setColumn("b_chr"), e_chr);
	ac_a := setColumn(b_str,"b_str");
	bc_a := insert(tests,ac_a,e_str);
#tests.insert(b_str.setColumn("b_str"), e_str);
	cc_a := setColumn(v_oid,"v_oid");
	dc_a := insert(tests,cc_a,e_oid);
#tests.insert(v_oid.setColumn("v_oid"), e_oid);
#
	ec_a := sort(b_int);
	fc_a := setColumn(ec_a,"s_int");
	gc_a := insert(tests,fc_a,e_int);
#tests.insert(b_int.sort.setColumn("s_int"), e_int);
	hc_a := sort(b_sht);
	ic_a := setColumn(hc_a,"s_sht");
	jc_a := insert(tests,ic_a,e_sht);
#tests.insert(b_sht.sort.setColumn("s_sht"), e_sht);
	kc_a := sort(b_chr);
	lc_a := setColumn(kc_a,"s_chr");
	mc_a := insert(tests,lc_a,e_chr);
#tests.insert(b_chr.sort.setColumn("s_chr"), e_chr);
	nc_a := sort(b_str);
	oc_a := setColumn(nc_a,"s_str");
	pc_a := insert(tests,oc_a,e_str);
#tests.insert(b_str.sort.setColumn("s_str"), e_str);
#
function idx(b:bat[any,any]#proc idx(bat[any,any] b) {
):void;
	index:= take("index");
	qc_a := accbuild(b,index);
#	b.accbuild(index);
	return b;
#	return b;
end function;
#}
#
	tests:= take("tests");
	b_int:= take("b_int");
	rc_a := copy(b_int);
	sc_a := idx(rc_a);
	tc_a := setColumn(sc_a,"i_int");
	e_int:= take("e_int");
	uc_a := insert(tests,tc_a,e_int);
#tests.insert(b_int.copy.idx.setColumn("i_int"), e_int);
	b_sht:= take("b_sht");
	vc_a := copy(b_sht);
	wc_a := idx(vc_a);
	xc_a := setColumn(wc_a,"i_sht");
	e_sht:= take("e_sht");
	yc_a := insert(tests,xc_a,e_sht);
#tests.insert(b_sht.copy.idx.setColumn("i_sht"), e_sht);
	b_chr:= take("b_chr");
	ad_a := copy(b_chr);
	bd_a := idx(ad_a);
	cd_a := setColumn(bd_a,"i_chr");
	e_chr:= take("e_chr");
	dd_a := insert(tests,cd_a,e_chr);
#tests.insert(b_chr.copy.idx.setColumn("i_chr"), e_chr);
	b_str:= take("b_str");
	ed_a := copy(b_str);
	fd_a := idx(ed_a);
	gd_a := setColumn(fd_a,"i_str");
	e_str:= take("e_str");
	hd_a := insert(tests,gd_a,e_str);
#tests.insert(b_str.copy.idx.setColumn("i_str"), e_str);
#
function ku(b:bat[any,any]):bat[any,any];
#proc ku(bat[any,any] b) : bat[any,any] {
	id_a := kunique(b);
	return id_a;
#	return kunique(b);
end function;
#}
#
function mstr(i:int):str;
#proc mstr(int i) : str {
barrier	jd_a:= isnil(i);
	return "nil";
#	if (isnil(i)) return "nil";
end	jd_a;
	kd_a := str(i);
	return kd_a;
#	return str(i);
end function;
#}
#
function mset_print(m:bat[any,bat]#proc mset_print(bat[any,bat] m) {
):void;
	ld_a_cursor := 0:lng;
barrier	ld_a:= batloop(ld_a_cursor,m,ld_aH,ld_aT);
#    m@batloop() {
	h:= ld_aH;
#        var h := $h;
	t:= ld_aT;
#        var t := $t;
	md_a_cursor := 0:lng;
barrier	md_a:= batloop(md_a_cursor,t,md_aH,md_aT);
#        t@batloop() {
	nd_a := int(h);
	od_a := mstr(nd_a);
	pd_a := int(md_aT);
	qd_a := mstr(pd_a);
	rd_a := printf("\t%s\t%s\n",od_a,qd_a);
#            printf("\t%s\t%s\n", mstr(int(h)), mstr(int($t)));
redo	md_a;
end	md_a;
#        }
redo	ld_a;
end	ld_a;
#    }
end function;
#}
#
function set_print(b:bat[any,any]#proc set_print(bat[any,any] b) {
):void;
	sd_a_cursor := 0:lng;
barrier	sd_a:= batloop(sd_a_cursor,b,sd_aH,sd_aT);
#    b@batloop() {
	td_a := int(sd_aH);
	ud_a := mstr(td_a);
	vd_a := int(sd_aT);
	wd_a := mstr(vd_a);
	xd_a := printf("\t%s\t%s\n",ud_a,wd_a);
#        printf("\t%s\t%s\n", mstr(int($h)), mstr(int($t)));
redo	sd_a;
end	sd_a;
#    }
end function;
#}
#
## start testing, switch mask that tells us which implementation is actually used
	yd_a := debugmask(131072);
#debugmask(131072);
#
	tests:= take("tests");
	ae_a_cursor := 0:lng;
barrier	ae_a:= batloop(ae_a_cursor,tests,ae_aH,ae_aT);
#tests@batloop() {
	be_a := "\n# test proc {kunique}(%s)\n";
	ce_a := bbpname(ae_aH);
	de_a := printf(be_a,ce_a);
#	printf("\n# test proc {kunique}(%s)\n", $h.bbpname);
	ee_a := pump.ku(ae_aH);
	fe_a := mset_print(ee_a);
#	{ku}($h).mset_print;
redo	ae_a;
end	ae_a;
#}
#
	ge_a_cursor := 0:lng;
barrier	ge_a:= batloop(ge_a_cursor,tests,ge_aH,ge_aT);
#tests@batloop() {
	he_a := "\n# test proc {kunique}(%s,%s)\n";
	ie_a := bbpname(ge_aH);
	je_a := bbpname(ge_aT);
	ke_a := printf(he_a,ie_a,je_a);
#	printf("\n# test proc {kunique}(%s,%s)\n", $h.bbpname, $t.bbpname);
	le_a := pump.ku(ge_aH,ge_aT);
	me_a := mset_print(le_a);
#	{ku}($h,$t).mset_print;
redo	ge_a;
end	ge_a;
#}
#
	ne_a_cursor := 0:lng;
barrier	ne_a:= batloop(ne_a_cursor,tests,ne_aH,ne_aT);
#tests@batloop() {
	oe_a := "\n# test packed {kunique}(%s)\n";
	pe_a := bbpname(ne_aH);
	qe_a := printf(oe_a,pe_a);
#	printf("\n# test packed {kunique}(%s)\n", $h.bbpname);
	re_a := pump.kunique(ne_aH);
	se_a := mset_print(re_a);
#	{kunique}($h).mset_print;
redo	ne_a;
end	ne_a;
#}
#
	te_a_cursor := 0:lng;
barrier	te_a:= batloop(te_a_cursor,tests,te_aH,te_aT);
#tests@batloop() {
	ue_a := "\n# test packed {max}(%s,%s)\n";
	ve_a := bbpname(te_aH);
	we_a := bbpname(te_aT);
	xe_a := printf(ue_a,ve_a,we_a);
#	printf("\n# test packed {max}(%s,%s)\n", $h.bbpname, $t.bbpname);
	ye_a := pump.max(te_aH,te_aT);
	af_a := set_print(ye_a);
#	{max}($h,$t).set_print;
redo	te_a;
end	te_a;
#}
#
	bf_a_cursor := 0:lng;
barrier	bf_a:= batloop(bf_a_cursor,tests,bf_aH,bf_aT);
#tests@batloop() {
	cf_a := "\n# test direct {max}(%s)\n";
	df_a := bbpname(bf_aH);
	ef_a := printf(cf_a,df_a);
#	printf("\n# test direct {max}(%s)\n", $h.bbpname);
	ff_a := multiplex.int(bf_aH);
	gf_a := pump.max(ff_a);
	hf_a := set_print(gf_a);
#	{max}([int]($h)).set_print;
redo	bf_a;
end	bf_a;
#}
#
	if_a_cursor := 0:lng;
barrier	if_a:= batloop(if_a_cursor,tests,if_aH,if_aT);
#tests@batloop() {
	jf_a := "\n# test direct {max}(%s,%s)\n";
	kf_a := bbpname(if_aH);
	lf_a := bbpname(if_aT);
	mf_a := printf(jf_a,kf_a,lf_a);
#	printf("\n# test direct {max}(%s,%s)\n", $h.bbpname, $t.bbpname);
	nf_a := multiplex.int(if_aH);
	of_a := pump.max(nf_a,if_aT);
	pf_a := set_print(of_a);
#	{max}([int]($h),$t).set_print;
redo	if_a;
end	if_a;
#}
#
	quit:= take("quit");
#quit;
