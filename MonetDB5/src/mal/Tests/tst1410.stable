# Monet Database Server V5.0
# Copyright (c) 1993-2002, CWI. All rights reserved.
# compiled for i686-pc-linux-gnu/32bit.
# gdk_dbfarm:/ufs/mk/monet_5-0/Linux/../dbfarm
# gdk_dbname:demo
# gdk_dbdir:/ufs/mk/monet_5-0/Linux/../dbfarm/demo
# gdk_distr:/ufs/mk/monet_5-0/Linux
# monetrc:/ufs/mk/.monet.conf
## testing the basic functionality of the enum module
## This example illustrates use of the atomary aspect
#
#atom fruit:enum;	# to announce existence of a new type
#a:= new(int,str);
#insert(a,0,"apples");
#insert(a,1,"oranges");
#insert(a,2,"grapes");
#insert(a,3,"grapes");
#insert(a,5,"apples");
#insert(a,6,"apples");
#insert(a,7,"apples");
#print(a);
#enum.create(fruit,a);
#print("get encoding table");
#e:= enum.getTable(fruit);
#print(e);
#print("test type for enumeration");
#b:= enum.isEnum(e);
#print(b);
#print("start bulk encoding test");
#z:= copy(a);
#print(z);
#print("encode the bat");
#y:= enum.encode(fruit,z);
#print(y);
#print("decode the bat");
#x:= enum.decode(y);
#print(x);
#print("set histogram on tail");
#tt:= reverse(y);
#setHistogram(fruit,tt);
#b:= enum.isHistogram(fruit,tt);
#print(b);
#
function Admin.main():int; #0:(main:int)
    a := mal.new(int,str); #1:(a:bat[int,str])<-(int:int)(str:str)
    bat.insert(a,0,"apples"); #2:($4:bat[int,str])<-(a:bat[int,str])($5:int)($6:str)
    bat.insert(a,1,"oranges"); #3:($7:bat[int,str])<-(a:bat[int,str])($8:int)($9:str)
    bat.insert(a,2,"grapes"); #4:($10:bat[int,str])<-(a:bat[int,str])($11:int)($12:str)
    bat.insert(a,3,"grapes"); #5:($13:bat[int,str])<-(a:bat[int,str])($14:int)($12:str)
    bat.insert(a,5,"apples"); #6:($15:bat[int,str])<-(a:bat[int,str])($16:int)($6:str)
    bat.insert(a,6,"apples"); #7:($17:bat[int,str])<-(a:bat[int,str])($18:int)($6:str)
    bat.insert(a,7,"apples"); #8:($19:bat[int,str])<-(a:bat[int,str])($20:int)($6:str)
    io.print(a); #9:($21:int)<-(a:bat[int,str])
    enum.create(fruit,a); #10:($22:bat[str,fruit])<-(fruit:fruit)(a:bat[int,str])
    io.print("get encoding table"); #11:($24:int)<-($25:str)
    e := enum.getTable(fruit); #12:(e:bat[any,any])<-(fruit:fruit)
    io.print(e); #13:($27:int)<-(e:bat[any,any])
    io.print("test type for enumeration"); #14:($28:int)<-($29:str)
    b := enum.isEnum(e); #15:(b:bit)<-(e:bat[any,any])
    io.print(b); #16:($31:int)<-(b:bit)
    io.print("start bulk encoding test"); #17:($32:int)<-($33:str)
    z := algebra.copy(a); #18:(z:bat[int,str])<-(a:bat[int,str])
    io.print(z); #19:($35:int)<-(z:bat[int,str])
    io.print("encode the bat"); #20:($36:int)<-($37:str)
    y := enum.encode(fruit,z); #21:(y:bat[int,fruit])<-(fruit:fruit)(z:bat[int,str])
    io.print(y); #22:($39:int)<-(y:bat[int,fruit])
    io.print("decode the bat"); #23:($40:int)<-($41:str)
    x := enum.decode(y); #24:(x:bat[int,any])<-(y:bat[int,fruit])
    io.print(x); #25:($43:int)<-(x:bat[int,any])
    io.print("set histogram on tail"); #26:($44:int)<-($45:str)
    tt := bat.reverse(y); #27:(tt:bat[fruit,int])<-(y:bat[int,fruit])
    enum.setHistogram(fruit,tt); #28:($47:void)<-(fruit:fruit)(tt:bat[fruit,int])
    b := enum.isHistogram(fruit,tt); #29:(b:bit)<-(fruit:fruit)(tt:bat[fruit,int])
    io.print(b); #30:($48:int)<-(b:bit)
end main; #31:
#-------------------------#
# BAT:	  tmp_4		  #
# (int)	  (str)		  #
#-------------------------#
[ 0,	  "apples"	  ]
[ 1,	  "oranges"	  ]
[ 2,	  "grapes"	  ]
[ 3,	  "grapes"	  ]
[ 5,	  "apples"	  ]
[ 6,	  "apples"	  ]
[ 7,	  "apples"	  ]
[ "get encoding table" ]
#-------------------------#
# BAT:		  fruit	  #
# (str)		  (int)	  #
#-------------------------#
[ "apples",	  4	  ]
[ "grapes",	  2	  ]
[ "oranges",	  1	  ]
[ "test type for enumeration" ]
[ true ]
[ "start bulk encoding test" ]
#-------------------------#
# BAT:	  tmp_6		  #
# (int)	  (str)		  #
#-------------------------#
[ 0,	  "apples"	  ]
[ 1,	  "oranges"	  ]
[ 2,	  "grapes"	  ]
[ 3,	  "grapes"	  ]
[ 5,	  "apples"	  ]
[ 6,	  "apples"	  ]
[ 7,	  "apples"	  ]
[ "encode the bat" ]
#-------------------------#
# BAT:	  tmp_7		  #
# (int)	  (fruit)	  #
#-------------------------#
[ 0,	  apples	  ]
[ 1,	  oranges	  ]
[ 2,	  grapes	  ]
[ 3,	  grapes	  ]
[ 5,	  apples	  ]
[ 6,	  apples	  ]
[ 7,	  apples	  ]
[ "decode the bat" ]
#-------------------------#
# BAT:	  tmp_8		  #
# (int)	  (str)		  #
#-------------------------#
[ 0,	  "apples"	  ]
[ 1,	  "oranges"	  ]
[ 2,	  "grapes"	  ]
[ 3,	  "grapes"	  ]
[ 5,	  "apples"	  ]
[ 6,	  "apples"	  ]
[ 7,	  "apples"	  ]
[ "set histogram on tail" ]
[ true ]
>