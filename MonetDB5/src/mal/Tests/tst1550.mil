setoid(oid(20000000));
# The procedures part of the old prelude
     PROC CTorderby(bat[oid,any] b, bat[oid,any] a) : bat[oid,oid] {
         if (not(b.reverse.ordered)) {
                b := b.reverse.sort.reverse;
         }
         return CTrefine(b,a);
     }

     PROC CTsubgroup(BAT[oid,oid] ct, BAT[oid,any] b, BAT[oid,any] sel) : BAT[oid,oid] 
     		return ct.CTgroup(b.semijoin(sel));

     PROC {count}(BAT[oid,bit] sel, BAT[oid,oid] ct, BAT[oid,int] dom) : BAT[oid,int] 
		return {count}([sel?ct:], dom);

     PROC {count}(BAT[void,bit] sel, BAT[void,oid] ct, BAT[oid,int] dom) : BAT[oid,int] 
		return CTsubhisto(sel, ct, dom);

     proc orderby_table(str fcn, str spec, ..bat[any::1,any]..) {
             var meta := new(str,str,$0);
             var first := int(spec) + 2;
             var b := $(first);
             var s := b.reverse.sort.reverse;
     
             while(true) {   
                     var idx := spec.search(',');
                     if (idx < 0) break;
                     spec := spec.string(idx + 1);   
                     s := s.CTrefine($(int(spec) + 2));
             }
             var bb := s.mirror.outerjoin(b);
             var i := 2;
             meta.insert("int", str(first - 2));
             while((i :+= 1) <= $0) {
                     if (i = first) {
                         meta.insert("BAT", str(bb));
                     } else {
                         meta.insert("BAT", str($(i)));
                     }
             }
             call(fcn, meta);
     }
     
     proc table(str spec, bat[any::1,any] b, ..bat[any::1,any]..) {
             orderby_table("table", $(1..));
     }
     
     proc print(str spec, bat[any::1,any] b, ..bat[any::1,any]..) {
             orderby_table("print", $(1..));
     }

# First some procs for convenience: 
# - xtable_print(group[oid,oid], str, attr1[oid,a1], attr2[oid,a2], ...)
# 	print group count table 
# - xtable_realloc(bat, capacity):  bat
#	allocate more memory and return a copy of a bat
# - xtable_test(str title, bat x, bat y, bat z)
#	 major test script on xtable functionality
 
proc xtable_print(bat[oid,int] grp,str nme, bat[oid,any] b1,bat[oid,any] b2, bat b3) :={
    printf("\n# %s",nme);
    printf(" (ct: %d elts", b1.count);
    printf(", %d groups",grp.count);
    printf(", %d bytes)\n", b1.size());
    table(grp.setColumn("count"), b1,b2,b3);
}

proc xtable_histo_direct2(str title,bat b1,bat b2):= {
    var histo := b1.histogram;
    histo.xtable_print(title,b1,b2, histo.mirror.setColumn("gid"));
}
proc xtable_histo_direct3(str title,bat b1,bat b2, bat b3):= {
    var histo := b1.histogram;
    histo.xtable_print(title,b1,b2,b3, histo.mirror.setColumn("gid"));
}

proc xtable_histo_remap3(str title, bat[oid,oid] b1, bat[oid,oid] b2) := {
    var map := new(oid,oid).setKey(true).reverse.insert(b1);
    map.join(b1.histogram).xtable_print(title,b1,b2, map.setColumn("gid"));
}
 
proc xtable_histo_remap4(str title, bat[oid,oid] b1, 
	bat[oid,oid] b2, bat[oid,oid] b3) := {
    var map := new(oid,oid).setKey(true).reverse.insert(b1);
    map.join(b1.histogram).xtable_print(title,b1,b2,b3, map.setColumn("gid"));
}
 
proc xtable_histo_remap5(str title, bat[oid,oid] b1, 
	bat[oid,oid] b2, bat[oid,oid] b3,bat[oid,oid] b4) := {
    var map := new(oid,oid).setKey(true).reverse.insert(b1);
    map.join(b1.histogram).xtable_print(title,b1,b2,b3,b4, map.setColumn("gid"));
}
 
proc xtable_realloc(bat b,int cap) := {
    var inf := b.info;
    var ht := monet_atomtbl.find(inf.find("head"));
    var tt := monet_atomtbl.find(inf.find("tail"));
    var bn := new(ht, tt, cap);
    bn.insert(b);
    if (ht = void) bn.setSequenceBase(b.reverse.fetch(0));
    if (tt = void) bn.setSequenceBase(b.fetch(0));
    return bn;
}
 
proc xtable_test(str title, bat[oid,any] x, bat[oid,any] y, bat[oid,any] z) := {
    printf("# xtable_test: %s ", title);
    printf("grouping (%d ",x.count);
    printf("tuples, %d bytes)\n\n", x.size() + y.size() + z.size());
    x.setColumn("x"); y.setColumn("y"); z.setColumn("z");
    var yy := [+](y,dbl(1.0)).setColumn("yy");
 
    print(x.slice(0,7).setColumn("x"),y,yy,z);
    printf("synced(x,y) := %s\n", isSynced(x,y).str);
    printf("synced(x,z) := %s\n", isSynced(x,z).str);

    # test group 
    b1:= CTgroup(x);
    xtable_histo_direct2("group(x)", b1, x);

    # test derive
    b2:= CTgroup(b1,y).setWriteMode();
    xtable_histo_direct3("group(x,y)", b2, x, y);

    # test orderby
{   var b2 := CTrefine(x.reverse.sort.reverse, y);
    xtable_histo_remap4("orderby(x,y)", b2, x, y); }
 
    # test subgroup
{   var b2 := {count}([<=](y,dbl(2.0)),b1,b1.histogram).setColumn("count");
    b2.xtable_print("subhisto(x,y|1-2)", x, y, b2.mirror.setColumn("gid")); }
    b1 := CTsubgroup(b1,y, y.uselect(dbl(1.0),dbl(2.0)));
    xtable_histo_direct3("group(x,y|1-2)", b1, x, y);

    # test regroup
    CTregroup(b1,z);
    xtable_histo_direct3("regroup(x,y,z)", b1, x, y, z);

#    # test multigroup
#    b1 := CTmultigroup(new(bat,void).insert(y,nil).insert(yy,nil)).reverse;
#    xtable_histo_remap3("multigroup(y)", b1.fetch(0), y); 
#    xtable_histo_remap3("multigroup(yy)", b1.fetch(1), yy); 
#
#    # test multiderive
#    b1 := CTmultiderive(new(bat,bat).insert(y,x).insert(yy,x)).reverse;
#    xtable_histo_remap4("multigroup(y,x)", b1.fetch(0), y, x); 
#    xtable_histo_remap4("multigroup(yy,x)", b1.fetch(1), yy, x); 
#
#    # test multiregroup
#    b1 := CTmultiregroup(project(b1.reverse,z)).reverse;
#    xtable_histo_remap5("multiregroup(y,x)", b1.fetch(0), y, x, z); 
#    xtable_histo_remap5("multiregroup(yy,x)", b1.fetch(1), yy, x, z); 
}

x := new(oid,chr);
x.insert(1@0,'a');
x.insert(2@0,'a');
x.insert(3@0,'b');
x.insert(4@0,'b');
x.insert(5@0,'b');
x.insert(6@0,'b');
x.insert(7@0,'c');
x.insert(8@0,'c');
 
y:= new(oid,dbl);
y.insert(1@0,dbl(1.0));
y.insert(2@0,dbl(2.0));
y.insert(3@0,dbl(2.0));
y.insert(4@0,dbl(2.0));
y.insert(5@0,dbl(2.0));
y.insert(6@0,dbl(3.0));
y.insert(7@0,dbl(1.0));
y.insert(8@0,dbl(1.0));
 
z:= new(oid,str);
z.insert(1@0,"c");
z.insert(2@0,"a");
z.insert(3@0,"b");
z.insert(4@0,"c");
z.insert(5@0,"a");
z.insert(6@0,"a");
z.insert(7@0,"c");
z.insert(8@0,"a");

xtable_test("small hash", x, y, z);
 
# create vectorized versions
#x := x.reverse.project.reverse.copy;
#y := y.reverse.project.reverse.copy;
#z := z.reverse.project.reverse.copy;
 
# activate voids
#x.setSequenceBase(1@0);
#y.setSequenceBase(1@0);
#z.setSequenceBase(1@0);
 
#xtable_test("small vectorized", x, y, z);
 
#print("growing vectorized tables from 8 to 512k elements...");
#x := x.xtable_realloc(512*1024);
#y := y.xtable_realloc(512*1024);
#z := z.xtable_realloc(512*1024);
#var i := 17;
#while((i := i - 1) > 0) {
#        x.insert(x.copy);
#        y.insert(y.copy);
#        z.insert(z.copy);
#        print(x.count);
#}
#print("done!");
# 
#xtable_test("big vectorized", x, y, z);
# 
## materialize the oids again
#x := [oid](x.reverse).reverse;
#y := [oid](y.reverse).reverse;
#z := [oid](z.reverse).reverse;
#y.setWriteMode();
#z.setWriteMode();
#y.insert(0@0,dbl(nil));
#z.insert(0@0,str(nil));
#y.delete(0@0);
#z.delete(0@0);
# 
#xtable_test("big hash", x, y, z);
# 
## let the Mserver find out that the head columns are equal
#y := x.mirror.join(y);
#z := x.mirror.join(z);
# 
#xtable_test("big synced", x, y, z);
