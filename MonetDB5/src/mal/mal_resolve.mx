@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2005 CWI.
@' All Rights Reserved.

@' 
@a M. Kersten
@v 0.0
@* MAL type resolution
The type resolution scheme should be flexible and efficient.
Given the interpretative nature of many of the MAL instructions,
when and where type resolution takes place is a critical design issue.
Performing it too late, i.e. at each instruction, leads to 
performance problems if we derive the same information over and over again.
However, many built-in operators handle polymorphic typed objects, 
so we cannot escape it altogether.

Consider the small illustrative MAL program which we should
definitely support at the language level.
@example
@verbatim
function sample(nme:str, val:any):bit;
   c := 2*3;
   b := bbp.bind(nme);  #find a BAT
   h := select(b,val,val);
   t := count(h);
   x := print(t);
   y := print(val);
end sample;
@end verbatim
@end example
@-
The function definition is polymorphic typed on the 2cnd argument,
it becomes a concrete type upon invocation. 

The first assignment can be type checked during parsing
and could even lead to a frozen value. Looking up a BAT leads to
an element bat[ht,tt] where ht and tt are runtime dependent types.
We can not typecheck the bat selection. It should be done at runtime.
We can check t at compile time, because we only have to assure
that count() is given a bat argument. This assumes that we can infer
that 'h' is indeed a BAT, which requires assurance that all 'select'
operators produce a bat. In general, this is not possible, as a user may
overload the select() operation  to return somethin else as a bat[any,any];
Because print(t) contains an undetermined typed
argument we should postpone typechecking as well.
The last print statement can be checked upon function invocation.

Life becomes really complex if the body contains a loop, which changes
the variable types. For then we also have to keep track of the original
state of the function. Or alternatively, type checking should consider
the runtime stack rather than the function definition itself.

A few conclusions can be drawn. 1) Every statement should carry a
flag to indicate whether it has been type-resolved. 
1a) you can always postpone type checking,
2) polymorphic functions can be cloned to built a cache of instantiated 
functions.
3) we have to call the type-checker potentially at every instruction
and its result is call specific, this means we have to propagate
the type through the runtime stack rather than the symbol table,
4) once the type of a variable is fixed, we should stick to it.
This precludes loops where the typing scheme changes with each step.
Instead, such type changes should be factored out algoritmically.

The type resolution status is marked in each instruction.
TYPE_RESOLVED implies that the type of the instruction is fully
resolved, it is marked TYPE_DYNAMIC otherwise.

Alternatie solutions.
A) split the function such that type analysis only occurs at the
   function call level.
Disadvantage, it does not work for the example above.
Moreover, you need to carry too much contextual information.

Omission of the module name leads to a search process.
The current policy is to start at the client module level and inspect
the outer scopes when the symbol is not found. This may lead
to ambigous behavior though. If a module M imports K for its function K.f()
then it clashes with L.f() when the initialization script calls for
import K,L,M. This can be recognized by inspecting the code produced
@{
@h
#ifndef _MAL_RESOLVE_H
#define _MAL_RESOLVE_H

#include "mal_exception.h"
#include "mal_function.h"

/*
#define DEBUG_MAL_RESOLVE 1 
*/
#define MAXTYPEVAR  10

mal_export void chkProgram(Module s, MalBlkPtr mb);
mal_export void chkTypes(Module s, MalBlkPtr mb);
mal_export void typeChecker(Module scope, MalBlkPtr mb, InstrPtr p, int silent);
mal_export InstrPtr dynamicTypeChecker(Module scope,MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
mal_export int fcnBinder(Module scope, MalBlkPtr mb, InstrPtr p);
mal_export int resolveType(int dsttype, int srctype);
mal_export int isPolymorphic(malType t);
mal_export malType getPolyType(malType t, int *polytype);
mal_export int updateTypeMap(int formal, int actual, int polytype[MAXTYPEVAR]);

extern void typeMismatch(MalBlkPtr mb, InstrPtr p, int lhs, int rhs,int silent);
extern str traceFcnName;

#endif /*  _MAL_RESOLVE_H*/
@+ Function call resolution
Search the first definition of the operator in the visible scopes
and check the parameter types.
For a polymorphic MAL function we make a fully instantiated clone.
This effectively overloads the MAL procedure.
It will be prepended to the symbol list as it is more restrictive.

Debugging of this module can be dynamically controlled in the debugger
by setting the routine of interest.
@c
#include "mal_resolve.h"
#include "mal_namespace.h"

int typeKind(MalBlkPtr mb, InstrPtr p, int i);

#define MAXMALARG 256

str traceFcnName= "_____";
int tracefcn;
int polyVector[MAXTYPEVAR];
void polyInit(){
    int i;
    for(i=0;i<MAXTYPEVAR;i++) polyVector[i]= TYPE_any;
}
@-
A function may be characterised by its module, i.e. the location to
start the search. Ommision of the module name implies searching from
the client layer upward. (cost estimate 4ms/1000calls)
@c
malType findFunctionType(Module scope, MalBlkPtr mb, InstrPtr p,int silent){
    Module m;
    Symbol s;
    InstrPtr sig;
    int i,k, polymorphic, unmatched = 0, s1;
    int foundbutwrong=0;
    int polytype[MAXTYPEVAR];
    int returntype[MAXMALARG];

@-
Check first for a module specific type checker. It takes
precedence and should handle all cases. It returns -1
upon failure, which shortcuts the execution.
@c
    if(scope->typeChecker && moduleName(p)==scope->name ){
        if( (scope->typeChecker)(scope,mb,p,FALSE)!=0)
            return getArgType(mb,p,0);
        return -3;
    }
@-
Within a module find the subscope to locate the element in its list
of symbols.
@c
    if( p->maxarg >= MAXMALARG){
        GDKerror("Function called with too many arguments");
        return -3;
    }
    m= scope;
    s= m->subscope[(int)(getSubScope(functionName(p)))];
    while(s != NULL){   /* single scope element check */
    if(functionName(p) && functionName(p) != s->name  ){
        s= s->skip; continue;
    }
@-
Perform a strong type-check on the actual arguments. If it turns
out to be a polymorphic MAL function, we have to clone it. 
Provided the actual/formal parameters are compliant throughout
the function call.

Also look out for variable argument lists. This means that we
have to keep two iterators, one for the caller (i) and one for
the callee (k). Since a variable argument only occurs as the last one,
we simple avoid an increment when running out of formal arguments.

A call of the form (X1,..., Xi) := f(Y1,....,Yn) can be matched against
the function signature (B1,...,Bk):= f(A1,...,Am) where i==k , n<=m
and type(Ai)=type(Yi). Furthermore, the variables Xi obtain their type
from Bi (or type(Bi)==type(Xi)).
@c
    sig = getSignature(s); 
    if( ! ( sig->retc == p->retc &&
          ( sig->argc== p->argc ||
          ( sig->argc<p->argc && sig->varargs))
      ) ) {
#ifdef DEBUG_MAL_RESOLVE
    if(tracefcn) {
    stream_printf(GDKout,"-->resolving\n");
    printInstruction(GDKout,mb,p,LIST_MAL_ALL);
    stream_printf(GDKout,"-->didn't match candidate\n");
    printInstruction(GDKout,s->def,getSignature(s),LIST_MAL_ALL);
    stream_printf(GDKout,"sig argc %d retc %d p.argc %d p.retc %d\n",
        sig->argc, sig->retc, p->argc, p->retc);
    }
#endif
         s=s->peer; continue;
    }
    polymorphic = 0;
    unmatched = 0;

#ifdef DEBUG_MAL_RESOLVE
    if(tracefcn) {
    stream_printf(GDKout,"-->resolving\n");
    printInstruction(GDKout,mb,p,LIST_MAL_ALL);
    stream_printf(GDKout,"++> test against signature\n");
    printInstruction(GDKout,s->def,getSignature(s),LIST_MAL_ALL);
    stream_printf(GDKout," %s \n", sig->polymorphic?"polymorphic":"");
    }
#endif
@-
The simple case could be taken care of separately to speedup processing
However, it turned out not to make a big difference.
The first time we encounter a polymorphic argument in the
signature, we initialize a type variable table.
Subsequently, the polymorphic arguments update this table
and check for any type mismatches that might occur.
There are at most 2 type variables involved per argument
due to the limited type nesting permitted.
Note, each function returns at least one value.
@c
    if( sig->polymorphic ){
        if(polyVector[0]==0) polyInit();
        memcpy(polytype,polyVector, sizeof(polyVector));
        polymorphic++;
        for(k=i=p->retc;i<p->argc;i++){
            int actual = getArgType(mb,p,i);
            int formal = getArgType(s->def,sig,k);
@-
Take care of variable argument lists. They are allowed as the last in the
signature only.
Furthermore, for patterns if the formal type is 'any' then all remaining arguments 
are acceptable and detailed type analysis becomes part of the pattern 
implementation.
In all other cases the type should apply to all remaining arguments.
@c

            if( updateTypeMap(formal, actual, polytype)){
                unmatched= i; 
                break;
            }
            formal= getPolyType(formal,polytype);
@-
Any reference to the polytype table is removed. Possibly
turning a contrainted type into 'any', which matches all types.
@c
            if(formal!=actual &&  resolveType( formal,actual) == -1 ){
                unmatched= i;
                break;
            }
            k++;
            if(sig->varargs && k == sig->argc) k--;
        }
    } else {
        for(i=p->retc;i<p->argc;i++){
            int actual = getArgType(mb,p,i);
            int formal = getArgType(s->def,sig,i);
            if(formal!=actual &&  resolveType( formal,actual) == -1 ){
                unmatched= i;
                break;
            }
        }
    }
@-
It is possible that you may have to coerce the value to another type.
We assume that coercions are explicit at the MAL
level. (e.g. var2:= var0:int). This avoids repeated type analysis
just before you execute a function.
At a later stage we may automatically insert such coercion requests.
@c
#ifdef DEBUG_MAL_RESOLVE
    if(tracefcn) {
         stream_printf(GDKout,"finished %s.%s unmatched=%d polymorphic=%d %d\n",
            moduleName(sig), functionName(sig),
            unmatched, polymorphic,p==sig);
        if( polymorphic){
            int l;
            for(l=0;l<2*p->argc;l++) 
            if( polytype[l] != TYPE_any)
            stream_printf(GDKout,"poly %d %s\n",l,getTypeName(polytype[l]));
        }
        if( unmatched)
        stream_printf(GDKout,"mismatch test %s poly %s\n",
            getTypeName(getArgType(mb,p,unmatched)),
            getTypeName(getArgType(s->def,sig,unmatched)));
    }
#endif
    if( unmatched) { s= s->peer; continue; }
@-
The argument section has been handled, before we finalize the process,
we should assure that also the target variables have the proper types
or can inherit them from the signature. The type vector should be
build separately first, because we may encounter an error later on.

If any of the arguments refer to a constraint type, any$x, then
the resulting type can not be determined.
@c
    s1 = 0;
    for(k=i=0; i < p->argc; i++){
        int actual = getArgType(mb,p,i);
        int formal = getArgType(s->def,sig,k);

        if( k+1 == sig->argc){
            if(sig->varargs ){
                if( sig->token == PATTERNsymbol &&
                    formal== TYPE_any){
                    returntype[i]= TYPE_any;
                    continue;
                }
            }
        } else k++;
        s1= getPolyType(formal, polytype);

        returntype[i]= resolveType(actual,s1);
        if( returntype[i]== -1 && i< p->retc ){
            returntype[i]= actual; /* TYPE_any;*/
			if( !isPolyType(actual)) {
				typeMismatch(mb, p, actual, s1,silent);
				s1= -1;
				break;
			}
        }
    }
    if(s1<0 ){
        if(getSignature(s)->token !=PATTERNsymbol) foundbutwrong++;
        s= s->peer; continue;
    }
@-
If the return types are correct, copy them in place. 
Beware that signatures should be left untouched, which
means that we may not overwrite any formal argument.
Using the knowledge dat the arguments occupy the header
of the symbol stack, it is easy to filter such errors.
@c
    p->typechk= TYPE_RESOLVED;
    for(i=0;i<p->argc;i++) {
        if( !isFixed(mb,getArg(p,i)) && returntype[i]>=0) {
            setVarType(mb, getArg(p,i),returntype[i]);
            setFixed(mb, getArg(p,i));
        } 
    }
@-
Mark all variables that are subject to garbage control.
Beware, this is not yet effectuated in the interpreter.
@c
    for(i=0;i<p->retc;i++) 
    if( isaBatType(returntype[i]) || isaColType(returntype[i]) ||
        ( !isPolyType(returntype[i])  && 
			returntype[i]>=0 && returntype[i]< TYPE_any &&
           ATOMstorage(returntype[i])== TYPE_str) ){
        garbageControl(mb,getArg(p,i)) = TRUE;
    }
@-
It may happen that an argument was still untyped and as a result of
the polymorphism matching became strongly typed. This should be
reflected in the symbol table. 
@c
    s1= returntype[0];  /* for those interested */
    foundbutwrong = 0;
@-
If the call refers to a polymorphic function, we
clone it to arrive at a bounded instance. Polymorphic patterns and
commands are responsible for type resolution themselves.
Note that cloning pre-supposes that the function being cloned
does not contain errors detected earlier in the process,
nor does it contain polymorphic actual arguments.
@c
    if( polymorphic){ 
        int cnt=0;
        for(k=i=p->retc;i<p->argc;i++){
            int actual = getArgType(mb,p,i);
            if( isPolymorphic(actual)) cnt++;
        }
        if(cnt==0 && s->kind!= COMMANDsymbol && s->kind!=PATTERNsymbol ){
            s = cloneFunction(scope, s, mb,p);
            if( s->def->errors) return -3;
        }
    }
@-
We found the proper function. Copy some properties. In particuler,
determine the calling strategy, i.e. FCNcall, CMDcall, FACcall, PATcall
This piece of code may be shared by the separate binder
@= bindFunction
    if( p->token == ASSIGNsymbol){
        switch(getSignature(s)->token){
        case COMMANDsymbol: 
            p->token = CMDcall; 
            p->fcn = getSignature(s)->fcn;
            if( p->fcn == 0) {
                p->typechk= TYPE_UNKNOWN;
                mb->errors++;
                return -3;
            }
            break;
        case PATTERNsymbol: 
            p->token = PATcall; 
            p->fcn = getSignature(s)->fcn;
            break;
        case FACTORYsymbol:
            p->token = FACcall; 
            p->fcn = getSignature(s)->fcn;
            break;
        case FUNCTIONsymbol: 
            p->token = FCNcall; 
            if( getSignature(s)->fcn)
                p->fcn = getSignature(s)->fcn;
            break;
        default:
            showException(mb,getPC(mb,p),"MALresolve",
                    "unexpected token type\n");
            mb->errors++;
            return -3;
        }
        p->blk = s->def;
    }
@-
@c
    @:bindFunction@
@-
Since we now know the storage type of the receiving variable, we can
set the garbagge collection flag.
@= prepostProcess
    if(isaBatType(s1)){
        garbageControl(mb,getArg(p,0)) = TRUE;
    }
    else if( !isPolyType(s1)  && s1< TYPE_any && s1>=0 && ATOMstorage(s1)== TYPE_str){
        garbageControl(mb,getArg(p,0)) = TRUE;
    } 
@c
    @:prepostProcess@
#ifdef DEBUG_MAL_RESOLVE
    if(tracefcn) {
        printInstruction(GDKout,mb,p,LIST_MAL_ALL);
        stream_printf(GDKout,"Finished matching\n");
    }
#endif
    return s1;
    } /* while */
@-
We haven;t found the correct function.  To ease debugging, we may reveal
that we found an instruction with the proper arguments, but that clashes
with one of the target variables.
@c
    if( foundbutwrong && !silent){
        if(m->name)
			GDKerror("type conflict in assignment of %s.%s\n", m->name,functionName(p));
        else {
			str err;
			GDKerror("type conflict in assignment of %s\n", functionName(p));
			err= instruction2str(mb,p,0);
			GDKerror(err);
			GDKfree(err);
        }
    }
    return -3;
}

@- Type resolution algorithm.
Every actual argument of a function call should be type compatible
with the formal argument, and the function result type should be
compatible with the destination variable.
In both cases the 'receiving' variable may not be fully qualified,
i.e. of type 'any'. The type resolution algorithm creates the concrete
type for subsequent use.
@c
int resolveType(int dsttype, int srctype){  
#ifdef DEBUG_MAL_RESOLVE
    if( tracefcn){
        stream_printf(GDKout,"resolveType dst %s (%d) %s(%d)\n",
            getTypeName(dsttype), dsttype,
            getTypeName(srctype),srctype);
    }
#endif
    if( dsttype == srctype) return dsttype;
    if( dsttype == TYPE_any) return srctype;
    if( srctype == TYPE_any) return dsttype;
    if( isaBatType(dsttype) && isaBatType(srctype) ){
        int h1,t1,h2,t2,h3,t3;
#ifdef DEBUG_MAL_RESOLVE
        int i1,i2;
        i1= getHeadIndex(dsttype);
        i2= getTailIndex(dsttype);
#endif
        h1= getHeadType(dsttype);
        t1= getTailType(dsttype);
        h2= getHeadType(srctype);
        t2= getTailType(srctype);

        /* BAT reference type , ignore for the time being*/
        if( h1== TYPE_bat) h1= newBatType(TYPE_any,TYPE_any);
        if( t1== TYPE_bat) t1= newBatType(TYPE_any,TYPE_any);
        if( h2== TYPE_bat) h2= newBatType(TYPE_any,TYPE_any);
        if( t2== TYPE_bat) t2= newBatType(TYPE_any,TYPE_any);

@-
The BAT void column type is exchangeable with an oid column type
@c
        h3= -1;
        if( h1 == TYPE_any) h3= h2;
        /* if( h2 == TYPE_any) h3= h1;*/
        if( h1== TYPE_void && h2 == TYPE_oid) h3= TYPE_oid; else
        if( h2== TYPE_void && h1 == TYPE_oid) h3= TYPE_oid; else
        if( h1 == h2) h3= h1;
        if( h3 == -1) goto noResolution;
        t3= -1;
        if( t1 == TYPE_any) t3= t2;
        /*if( t2 == TYPE_any) t3= t1;*/
        if( t1== TYPE_void && t1 == TYPE_oid) t3= TYPE_oid; else
        if( t1== TYPE_void && t1 == TYPE_oid) t3= TYPE_oid; else
        if( t1 == t2) t3= t1;
        if(t3 == -1) goto noResolution;
#ifdef DEBUG_MAL_RESOLVE
        if( tracefcn){
        stream_printf(GDKout,"resolved to bat[:%s,:%s] bat[:%s,:%s]->bat[%s:%d,%s:%d]\n",
            getTypeName(h1),getTypeName(t1),
            getTypeName(h2),getTypeName(t2),
            getTypeName(h3),i1,getTypeName(t3),i2
            );
        }
#endif
        return newBatType(h3,t3);
    }
@-
Column type resolution looks much like a BAT
@c
    if( isaColType(dsttype) && isaColType(srctype) ){
        int t1,t2,t3;
#ifdef DEBUG_MAL_RESOLVE
        int i2;
        i2= getTailIndex(dsttype);
#endif
        t1= getTailType(dsttype);
        t2= getTailType(srctype);

        t3= -1;
        if( t1 == TYPE_any) t3= t2;
        if( t2 == TYPE_any) t3= t1;
        if( t1 == t2) t3= t1;
        if( t3== TYPE_void || t3 == -1) goto noResolution;
        return newColType(t3);
    }
noResolution:
#ifdef DEBUG_MAL_RESOLVE
    if(tracefcn) stream_printf(GDKout,"Can not be resolved \n");
#endif
    return -1;
}

@-
We try to clear the type check flag by looking up the
functions. Errors are simply ignored at this point of the game,
because they may be resolved as part of the calling sequence.
@c
void typeMismatch(MalBlkPtr mb, InstrPtr p, int lhs, int rhs, int silent){
    str n1 = getTypeName(lhs);
    str n2 = getTypeName(rhs);
    char buf[1024];
    int i;

	if( !silent) {
		snprintf(buf,1024,"type mismatch %s := ",n1);
		i= strlen(buf);
		snprintf(buf+i,1024-i,"%s\n",n2);
		showException(mb, getPC(mb,p),"MALresolve",buf);
		GDKfree(n1); GDKfree(n2);
	}
    mb->errors++;
    p->typechk= TYPE_UNKNOWN;
}
@-
A function search should inspect all modules unless a specific module
is given. Preference is given to the lower scopes.
The type check is set to TYPE_UNKNOWN first to enforce a proper
analysis. This way it forms a cheap mechanism to resolve
the type after a change by an optimizer.
If we can not find the function, the type check returns unsuccesfully.
In this case we should issue an error message to the user.

A re-check after the optimizer call should reset the token
to assignment.
@c
void typeChecker(Module scope, MalBlkPtr mb, InstrPtr p,int silent){
    int s1= -1, i,k;
    Module m=0;
	p->typechk= TYPE_UNKNOWN;

	if( p->fcn && (p->token== CMDcall || p->token== PATcall ||
		p->token==FCNcall || p->token == FACcall)){
			p->token= ASSIGNsymbol;
			p->fcn = NULL;
	}

    if( isaSignature(p) ) {
        for(k=0;k<p->argc;k++)
            setFixed(mb,getArg(p,k));
        p->typechk= TYPE_RESOLVED;
        for(k=0; k<p->retc;k++)
            p->typechk = MIN(p->typechk,typeKind(mb,p,0));
        return;
    }
    if( functionId(p)){
#ifdef DEBUG_MAL_RESOLVE
        tracefcn= idcmp(functionName(p),traceFcnName)==0;
#endif
assert(moduleId(p) != NULL);
        m= findModule(scope,moduleId(p));
        while(s1<0 && m!= NULL){
			if( m->inheritance==0) {
				m= m->outer;
				continue;
			}
            if( m->subscope[(int)(getSubScope(functionName(p)))])
                s1= findFunctionType(m,mb,p,silent);
            if( moduleId(p)) break;
            m= m->outer;
        }
        if( s1>= 0) return;
@-
Could not find a function that statisfies the constraints.
If the instruction is just a function header we may continue.
Likewise, the function and module may refer to string variables
known only at runtime.

In all other cases we should generate a message, but only if we know
that the error was not caused by checking the definition
of a polymorphic function or the module or function name are variables,
In those cases, the detailed analysis is performed upon an actual call.
@c
        if( moduleId(p) && (i=findVariable(mb,moduleName(p))) != -1 &&
                    getVarType(mb,i) == TYPE_str){
            for(i=0;i<p->retc;i++) setFixed(mb,getArg(p,i));
            p->typechk= TYPE_UNKNOWN;
            return;
        } 
        if( functionId(p) && (i=findVariable(mb,functionName(p))) != -1 &&
                    getVarType(mb,i) == TYPE_str){
            for(i=0;i<p->retc;i++) setFixed(mb,getArg(p,i));
            p->typechk= TYPE_UNKNOWN; 
			return; 
        }
        if( ! isaSignature(p) && !getInstrPtr(mb,0)->polymorphic )  {
            mb->errors++;
			if( !silent)
				GDKerror("'%s%s%s' undefined in %s.%s[%d]\n", 
					(moduleId(p)?moduleName(p):""), (moduleName(p)?".":""),
					functionName(p), scope->name,
					functionName(getInstrPtr(mb,0)),getPC(mb,p));
				p->typechk= TYPE_UNKNOWN;
        } else p->typechk= TYPE_RESOLVED;
        return;
    }
@+ Assignment 
When we arrive here the operator is an assignment.
The language should also recognize (a,b):=(1,2);
This is achieved by propagation of the rhs types to the lhs
variables.
@c
    if( p->retc > 1 && p->argc>p->retc && p->argc!= 2 * p->retc){
        GDKerror("Multiple assignment mismatch\n");
        mb->errors++;
    } else
		p->typechk= TYPE_RESOLVED;
    for(k=0,i= p->retc; k<p->retc && i<p->argc; i++,k++){
        int rhs = getArgType(mb,p,i);
        int lhs = getArgType(mb,p,k);

        if( rhs != TYPE_void){
            s1= resolveType(lhs,rhs);
            if( s1== -1 ){
                typeMismatch(mb,p,lhs,rhs,silent);
                return;
            }
        } else 
@-
The language permits assignment of 'nil' to any variable,
using the target type.
@c
		if( lhs != TYPE_void && lhs != TYPE_any){
			p->argv[i]= newConstant(mb,
				(isaBatType(lhs)?TYPE_bat:lhs), GDKstrdup("nil"),TRUE);
		} else 
        if( lhs != TYPE_void && lhs != TYPE_any) {
            typeMismatch(mb,p,lhs,rhs,silent);
            return;
        }
        if( !isFixed(mb,getArg(p,k))) {
            setVarType(mb,getArg(p,k),rhs);
            setFixed(mb,getArg(p,k));
        }
        @:prepostProcess@
    }
}
@-
Typechecking instructions can be delegated to runtime. In particular, 
MAL allows module and function names to be represented by string variables.
The dynamic type checker uses these names and calls for a strong type
check. 
Since the typechecker has side-effects on the symbol table, 
subsequent replacements can not produce differently typed results.
This makes it possible to pass function names as arguments or to
collect them from a function table. The underlying signature remains
the same.
@c
InstrPtr dynamicTypeChecker(Module scope, MalBlkPtr mb, MalStkPtr stk, InstrPtr p){
    InstrPtr pci;
    int i;

#ifdef DEBUG_MAL_RESOLVE
	stream_printf(GDKout,"Start dynamic type check on:\n");
	/*printInstruction(GDKout, mb, altpci,LIST_MAL_ALL);*/
#endif

    pci = copyInstruction(p);
	if( functionId(pci) && (i=findVariable(mb,functionName(pci))) != -1){
		if( getVarType(mb,i) != TYPE_str)
			setFunctionId(pci, 0);
		else 
			setFunctionId(pci,putName( stk->stk[i].val.sval,
						strlen(stk->stk[i].val.sval)));
	}
	if( moduleId(pci) && (i=findVariable(mb,moduleName(pci))) != -1){
		if( getVarType(mb,i) != TYPE_str)
				setModuleId(pci, NULL);
		else {
				setModuleScope(pci, findModule(scope, stk->stk[i].val.sval));
		}
	}
	typeChecker(scope, mb,pci,FALSE);
#ifdef DEBUG_MAL_RESOLVE
	stream_printf(GDKout,"type checked version:\n");
	printInstruction(GDKout, mb, pci,LIST_MAL_ALL);
#endif

    return pci;
}
@+ Function binder
In some cases the front-end may already assure type correctness
of the MAL instruction generated (e.g. the SQL front-end)
In that case we merely have to locate the function address and
finalize the code for execution. Beware that we should be able to
distinguish the function by module name, function name, and
number of arguments only. Whether this is sufficient remains
to be seen.
@c
int fcnBinder(Module scope, MalBlkPtr mb, InstrPtr p){
    Module m=0;
    Symbol s;

    if( p->token != ASSIGNsymbol) return 0;
    if( moduleId(p)== NULL || functionId(p)== NULL) return 0;
    for(m= findModule(scope,moduleName(p)); m; m= m->outer)
    if( m->name == moduleName(p) ) {
        s= m->subscope[(int)(getSubScope(functionName(p)))];
        for(; s; s= s->peer)
        if( functionName(p)==s->name &&
            p->argc == getSignature(s)->argc ){
            /* found it */
            @:bindFunction@
        }
    }
    return 0;
}
@-
After the parser finishes, we have to look for semantic errors,
such as flow of control problems and possible typeing conflicts.
The nesting of BARRIER, THREAD and CATCH statements with their associated
flow of control primitives LEAVE and RETRY should form a valid
hierarchy. Failure to comply is considered a structural error
and leads to flagging the function as erroneous.
Also check general conformaty of the ML block structure.
It should start with a signature and finish with and ENDsymbol
@c
int chkProgramIdentifier(MalBlkPtr mb, str nme, int tpe){
    if( ATOMindex(nme)>0) return TRUE;
    if( tpe!= TYPE_str ){
        GDKerror("TYPE ERROR:mod/fcn should be a string\n");
        mb->errors++;
    }
    return FALSE;
}
@-
Type checking a program is limited to those instructions that are
not resolved yet. Once the program is completely checked, further calls
should be ignored. This should be separately administered for the flow
as well, because a dynamically typed instruction should later on not
lead to a re-check when it was already fully analysed.
@c
void chkTypes(Module s, MalBlkPtr mb){
	InstrPtr p=0;
    int i, chk=0;

	for(i=0;i<mb->stop;i++) {
		p= getInstrPtr(mb,i);
		if(p== NULL) continue;
		if( p->typechk == TYPE_BIND) 
			fcnBinder(s,mb,p);
		else /*  not ready if( p->typechk != TYPE_RESOLVED)*/
			typeChecker(s,mb,p,FALSE);

		if( functionId(p) ){
			if(p->fcn != NULL && p->typechk== TYPE_RESOLVED) chk++;
		} else
		if( p->typechk== TYPE_RESOLVED) chk++;
	}
}
void chkProgram(Module s, MalBlkPtr mb)
{
/* it is not ready yet, too fragile
		mb->typefixed = mb->stop == chk; ignored END */
/*	if( mb->flowfixed == 0)*/

	chkTypes(s,mb);
	chkFlow(mb);
	chkDeclarations(mb,FALSE);
}
@+ Polymorphic type analysis
MAL provides for type variables of the form any$N. This feature
supports polymorphic types, but also complicates the subsequent
analysis. A variable typed with any$N not occuring in the function
header leads to a dynamic typed statement. In principle we have
to type check the function upon each call.
@c
int typeKind(MalBlkPtr mb, InstrPtr p, int i){
    malType t= getArgType(mb,p,i);
    if( isAnyExpression(t) || t == TYPE_any) {
        return TYPE_DYNAMIC;
    }
    return TYPE_RESOLVED;
}
int isPolymorphic(malType t){
    int ret =0;
    if( t== TYPE_any) ret= 1; else
    if( isAnyExpression(t)) ret= 1; else
    if( isaBatType(t)){
        if( getHeadType(t)==TYPE_any) ret= 1; else
        if( getTailType(t)==TYPE_any) ret= 1;
    }
	if( isaColType(t)){
        if( getTailType(t)==TYPE_any) ret= 1;
	}
    return ret;
}
@-
For a polymorphic commands we do not generate a cloned version.
It suffices to determine the actual return value taking into
account the type variable constraints.
@c
malType getPolyType(malType t,int *polytype){
    int hi,ti;
    int head, tail;

	ti = getTailIndex(t);
	if( ti == 0)
		tail= getTailType(t);
	else tail = polytype[ti];
    if( isaBatType(t)){
		hi = getHeadIndex(t);
		if( hi == 0)
			head= getHeadType(t);
		else head = polytype[hi];
        return newBatType(head,tail);
	}

    if( t== TYPE_bat) 
        return newBatType(TYPE_any,TYPE_any);
    if( isaColType(t))
        return newColType(tail);
    return tail;
}
@-
Each argument is checked for binding of polymorphic arguments.
This routine assumes that the type index is indeed smaller than maxarg. 
(The parser currently enforces a single digit from 1-9 )
The polymorphic type 'any', i.e. any$0, does never constraint an operation
it can match with all polymorphic types.
The routine returns the instanciated formal type for subsequent
type resolution.
@c
int updateTypeMap(int formal, int actual, int polytype[MAXTYPEVAR])
{
    int h,t;

    if( isaBatType(formal)){
        if(!isaBatType(actual)){
            if( getTailType(actual) == TYPE_any) t= TYPE_any;
            else return -1;
        } else  t= getHeadType(actual);

        if( (h=getHeadIndex(formal)) ){
            if( polytype[h] == TYPE_any) polytype[h]= t;
            if( polytype[h] != t && t!= TYPE_any) return -1;
        }
    }
	if( isaColType(formal)){
        if(!isaColType(actual)){
            if( getTailType(actual) == TYPE_any) t= TYPE_any;
            else return -1;
        } else  t= getTailType(actual);
        if( (h=getTailIndex(formal)) ){
            if( polytype[h] == TYPE_any) polytype[h]= t;
            if( polytype[h] != t && t!= TYPE_any) return -1;
        }
		return 0;
	}
    if( (h=getTailIndex(formal)) ){
        t= getTailType(actual);
        if( t== TYPE_bat)
            t= newBatType(TYPE_any,TYPE_any);
        if( polytype[h] == TYPE_any ) polytype[h]=  t;
        if( polytype[h] != t && t!= TYPE_any) return -1;
    }
    return 0;
}
@}
