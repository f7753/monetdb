@f mal_stack
@a M. L. Kersten

@* MAL runtime stack
The runtime context of a MAL procedure is allocated on the runtime stack
of the corresponding interpreter.
Access to the elements in the stack are through index offsets,
determined during MAL procedure parsing.
This method has been proven highy efficient compared to using 
individual GDKmalloci calls.

Unlike Monet Version 4, the scope administration for MAL procedures is
decoupled from their actual runtime behavior. This means we are
more relaxed on space allocation, because the size is determined
by the number of MAL procedure definitions instead of the runtime
calling behavior. (See mal_interpreter for details on value stack
management)

The variable names and types are kept in the stack to ease debugging.
The underlying string value need not be garbage collected.
@h
/*
 * The contents of this file are subject to the Monet Public
 * License Version 1.1 (the "License"); you may not use this file
 * except in compliance with the License. You may obtain a copy of
 * the License at http://www.monetsolutions.com/Download/Licensing/MonetPL-1.1.
html
 * 
 * Software distributed under the License is distributed on an "AS
 * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
 * implied. See the License for the specific language governing
 * rights and limitations under the License.
 * 
 * The Original Code is the Monet Database System.
 * 
 * The Initial Developer of the Original Code is CWI.
 * Portions created by CWI are Copyright (C) 1997-2001 CWI.  
 * All Rights Reserved.
 * 
 * Contributor(s): Martin Kersten <Martin.Kersten@cwi.nl>
 */
#ifndef _MAL_STACK_H_
#define _MAL_STACK_H_
#include "mal.h"

#define STACKINCR	128
#define MAXGLOBALS	4 * STACKINCR
#define MAXSHARES	16

typedef struct MALSTK {
	int 	stksize;
	int	stktop;
	MT_Lock	stklock;	/* used for parallel processing */
	int	shares;		/* number of processes on this stack */
	int	childs[MAXSHARES];
	char	cmd;		/* debugger communication */
	struct MALSTK *up;	/* stack trace list */
	struct MALSTK *down;	/* stack trace list */
	struct MALBLK *blk;	/* associated definition */
	ValRecord stk[1];
}MalStack, *MalStkPtr;

#define stackSize(CNT) (sizeof(ValRecord)*(CNT) + sizeof(MalStack))
#define newStack(S,CNT)	S= (MalStkPtr) alloca(stackSize(CNT));\
			bzero((char *) S, stackSize(CNT));\
			(S)->stksize=CNT;
/*
#define newStack(S,CNT)	S= (MalStkPtr) GDKmalloc(stackSize(CNT));\
			bzero((char *) S, stackSize(CNT));\
			(S)->stksize=CNT;
*/
	
#define newFrame(S,Ssize,Top,Cnt) S= reallocStack(S,&(Ssize),Top,Cnt)

mal_export MalStkPtr newGlobalStack(int size);
mal_export void freeStack(MalStkPtr stk);

#define VARfreeze(X)	if(X){X->frozen=TRUE;}
#define VARfixate(X)	if(X){X->constant=TRUE;}

#define getStkRecord(S,P,I)	&(S)->stk[(P)->argv[I]]
#define getStkValue(S,P,I)	( getStkType(S,P,I)== TYPE_str? \
				  getStkRecord(S,P,I)->val.sval :\
				  getStkRecord(S,P,I)->val.pval )
#define getStkType(S,P,I)	(S)->stk[(P)->argv[I]].vtype
#define setStkType(S,P,I,T)	(S)->stk[(P)->argv[I]].vtype = T
#endif /* _MAL_STACK_H_ */
@-
The clearStack operation throws away any space occupied by variables
Freeing the stack itself is automatic upon return from the interpreter
context. Since the stack is allocated and zeroed on the calling stack,
it may happen that entries are never set to a real value.
This can be recognized by the vtype component
@c
#include "mal_stack.h"

MalStkPtr newGlobalStack(int size){
	MalStkPtr s;
	s= (MalStkPtr) GDKmalloc(stackSize(size)+sizeof(MalStack));
	if( s== NULL)
		GDKfatal("newGlobalStack:can not obtain memory\n");
	bzero((char*)s, stackSize(size)+sizeof(MalStack));
	s->stksize = size;
	return s;
}

MalStkPtr reallocStack(MalStkPtr s, int cnt){
	int k= s->stksize;
	MalStkPtr old= s; 

	if( s->stksize - s->stktop >cnt ) return s;
	k = k+ ((cnt/STACKINCR)+1) * STACKINCR;
	newStack(s, k);
	memcpy(s, old, stackSize(s->stksize)); 
	s->stksize = k;
	GDKfree(old);
	return s;
}
@-
When you add a value to the stack, you should ensure that
there is space left. It should only be used for global
stack frames, because the others are allocated in the
runtime stack.
@c
void chkStack(MalStkPtr stk, int i){
	if(stk->stksize <=i){
		reallocStack(stk,STACKINCR);
	}
}
void freeStack(MalStkPtr stk){
	GDKfree(stk);
}
void clearStack(MalStkPtr s){
	ValPtr v;
	int i = s->stktop;

	for( v= s->stk; i >=0; i--, v++)
	if (ATOMextern(v->vtype) && v->val.pval) {
		printf("freeing %s\n",v->val.sval);
                GDKfree(v->val.pval);
        }
}
