@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@' 
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@' 
@' The Original Code is the Monet Database System.
@' 
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2004 CWI.
@' All Rights Reserved.
@' 
@' Contributor(s):
@' 		Martin Kersten <Martin.Kersten@cwi.nl>
@' 		Peter Boncz <Peter.Boncz@cwi.nl>
@' 		Niels Nes <Niels.Nes@cwi.nl>
@' 		Stefan Manegold  <Stefan.Manegold@cwi.nl>

@f mal_properties
@a M. Kersten
@* Property management
One of the shortcomings of the Monet version 4 system is that most variables,
e.g. BATS have static/dynamic properties hardwired into the system. 
The consequence is that it is often hard to detect the property state, and,
more importantly, to reason about the state before actual execution takes place.

Properties come in several classes, those linked with the symbol table and
those linked with the runtime environment. The former are often determined
once upon parsing or catalogue lookup. The runtime properties have two 
major subclasses, i.e. reflective and prescriptive. The reflective properties 
merely provide a fast cache to information aggregated from the target.
Prescriptive properties communicate desirable states, leaving it to other
system components to reach this state at the cheapest cost possible.
This multifacetted world makes it difficult to come up with a concise model
for dealing with properties. The approach taken here is an experimental step
into this direction.

This module provides a generic scheme to administer property sets and to
provide a concise API for (runtime) optimizers to manage them. The property
model assumes a namespace built around Identifiers. Furthermore, their
semantics does not depend on the context in which this name is used.
I.e. property names have global semantics.

Object of interest may collect a set of properties over their life time.
They may be collected explicitly, i.e. at some point in the operational
sequence a property tag is added (removed),
or implicitly, i.e. the property ceases to
exist if the underlying expression can not be proven/evaluated.
This leads to predicates hasProperty(Object,PropertyName) and
hasnotProperty(Object,PropertyName), which are semantically complementary.

Properties capture part of the state of the system in the form of an 
expression. This expression may be hidden deep in the algorithm, or even
be visible at the external level. (e.g. de count property over a table could
be a simple query)

Another assumption for all properties is their functional behavior.
The property values can only change as a result of using the target object,
e.g. being it an analysis step, an update, query access, 
or migration on the host storage system. 

To effectively work with properties, we should be careful not to let this
set explode beyond control. One way to achieve this is to make
properties part of the function space, which prohibits dynamic creation.
Furthermore, the properties could then be grouped into modules, which
addresses a particular issue.
The rationale is to model and understand the reasoning going
on with properties. Large property sets are best split into orthogonal
groups to deal with the complexity of interference.

Properties can be classified by their type structure. The generic
structure is that of a pair (property name, value). Depending on the 
value type, their use, and volatility leads to a different storage scheme.
For example, simple boolean valued properties could be assembled in a bit
vector, while values obtained from an ADT could require a rather complex
storage structure. For the time being, we take a relaxed approach, modelling
the pair with a simple record structure organized in a linked list.

To speedup management of the property values, they too have properties.
Aside from their value type, it is worth to know if the value is constant,
frozen upon first assignment, need be refreshed upon each read,...
Likewise, for operations we should identify which subset of properties 
propagate to the result structures and which not.

@+ Property use
Properties can be accessed from many places in the code, i.e. the parser,
an optimizer, code scheduler, or a DBMS kernel routine. Furthermore,
the properties and their manipulation may become part of the query plans,
which stresses the computational properties of such a language.

One of the decision points is whether the set of properties for an object
is defined for its complete scope. I.e. properties are independent on
the position in the execution graph. 
[We might restrict property definitions to
the signature, or we should make properties location dependent (=pc)]

Some properties have a life-time for the duration of a session.
These are typical global variables and should be handled as such.

Properties may be organized in an inheritance scheme. Compare with
the file access mode in your Unix shell.

[Does it make sense to dynamically add/delete properties.?]

In the middle layers we find properties such as the size of a (temporary)
BAT with a lifetime of just a few instructions.
At the extreme side, we find properties accessed and maintained by the DBMS
kernel routines, but whose value should be made known at the upper layers.

@+ Who is allowed to carry properties?
The objects comming to mind in the MAL setting are: variables (symbol table
entries), MAL instructions, MAL blocks, function signatures, and
function arguments.
Furthermore, SQL queries, Boxes (containers with persistent data), modules,...

MAL variables. A variable already contains a number of properties, e.g. type,
isaconstant, isused (both read and written), garbage(for garbage collector).
Especially for BATs we have to extend this list significantly.

Properties associated with a variable have a scope identical to the scope 
of the variable. However, its value depends on the position in a simulated
execution. I.e., consider the instruction sort(B) in
a MAL block. It leads to the property 'sorted' for B,
whose value is a posterori true, and not necessarily before execution.

MAL blocks. Every MAL block is semantically a callable function. Such a block
could be tagged with properties to identify the stages of processing it went
through (e.g. optimized or not), ownership, scheduling primitives etc. These are
typically workflow related properties.

MAL function signatures. A function signature contains a description of
the kind of objects it is willing to accept and an indication of the
result. It seems appropriate to be able to tag parameters with properties
that 'should be obeyed, or implied' by the actual arguments. As such,
it extends the typing scheme used during compilation/optimization.
Likewise, the return values could be tagged with properties that 'at least'
exist after the function returns. (See below)

MAL instructions. Properties associated with an instruction are aimed
at the a tactical optimizer and execution engine. It says something about
the context in which the instruction should take place, e.g. a timeout 
property.

The second layer involves tagging structures known to front-ends, such as
SQL and XML. Given that they produce a MAL block, setting properties
becomes an explicit action. This can be handled as a first step in the
optimization phase, which 'executes' all property setting actions first.
However, 'preferred' properties may have to be dealt with later. For example,
an operation should produce a sorted BAT. This calls for a runtime test and
possible coercion. Alternatively, the desired property leads to a different
selection of an operator implementation.

Although we may constrain the number of properties, we probably can not limit
the number of objects for which properties may have to be maintained. Just
imagine the total cost of execution for a very simple instruction.

@+ How to propagate properties?
Property propagation is strongly linked with the actual operator 
implementation.  We examine a few recurring cases.

V:=W; Both V and W should be type compatible, otherwise the compiler will 
already complain.(Actually, it requires V.type()==W.type() and ~V.isaConstant())
But what happens with all others? What is the property propagation rule for
the assignment? Several cases can be distinguished:

I)   W has a property P, unknown to V.
II)  V has a propery P, unknown to W.
III) V has property P, and W has property Q, P and Q are incompatible.
IV)  V and W have a property P, but its value disaggrees.

case I). If the variable V was not initialized, we can simply copy or share
the properties. Copying might be too expensive, while shareing leads 
to managing the dependencies.
case II) It means that V is re-assigned a value, and depending on its type and
properties we may have to 'garbage collect/finalize' it first. Alternatively,
it could be interpreted as a property that will hold after assignment 
which is not part of the right-hand side expression.
case III) if P and Q are type compatible, it means an update of the P value.
Otherwise, it should generates an exception.
case IV) this calls for an update of V.P using the value of W.P. How this
should be done is property specific.

Overall, the policy would be to 'disgard' all knowledge from V first and
then copy the properties from W.

[Try 1]
V:= fcn(A,B,C) and signature fcn(A:int,B:int,C:int):int
The signature provides several handles to attach properties. 
Each formal parameter could come with a list of 'desirable/necessary'
properties. Likewise, the return values have a property set.
This leads to the extended signature
function fcn(A:T{P1},....,B:T{Pn}): (C:T{Pk}...D:T{Pm})
where each Pi denotes a property set.
Properties P1..Pn can be used to select the proper function variant.
At its worst, several signatures of fcn() should be inspected at
runtime to find one with matching properties. To enable analysis and
optimization, however, it should be clear that once the function is finished, 
the properties Pk..Pm exist.

[Try 2]
V:= fcn(A,B,C) and signature fcn(A:int,B:int,C:int):int
The function is applicable when a (simple conjuntive) predicate over 
the properties of the actual arguments holds. A side-effect of execution
of the function leads to an update of the property set associated with
the actual arguments. An example:
@T
<pre>
function fcn (A:int,B:bat[int,int],C:int):int
	?{A.read=true, B.count<1000}
	{fcn.write:=true;}
</pre>
@-

[Try 3] Organize property management by the processor involved, e.g.
a cost-based optimizer or a access control enforcer.
For each optimizer we should then specify the 'symbolic' effect of
execution of instructions of interest. This means 'duplication' of
the instruction set.

Can you drop properties? It seems possible, but since property operations
occur before actual execution there is no guarantee that they actually
take place.

[case: how to handle sort(b:bat{P}):bat{+sorted} as a means to propagate  ]
[actually we need an expression language to indicate the propety set,
e.g. sort(b:bat):bat{sorted,+b} which first obtains the properties of b and
extends it with sorted. A nested structure emerge

Is it necessary to construct the property list intersection?
Or do we need a user defined function to consolidate property lists?
]

Aside, it may be valuable to collect information on e.g. the execution time 
of functions as a basis for future optimizations. Rather then cluttering the
property section, it makes sense to explicitly update this information in
a catalog.

@+ Properties at the MAL level
Aside from routines targeted as changing the MAL blocks, it should
be possible to reason about the properties within the language itself.
This calls for gaining access and update.
For example, the following snippet shows how properties
are used in a code block.

@T
<pre>
B := new(int,int);
I := properties.has(B,{hsorted}); 
J := properties.get(B,{cost});
print(J);

properties.set(B,{cost},2315); 
barrier properties.has(B,{sorted});
exit;
</pre>
@-
These example illustrate that the property manipulations are
executed throug patterns, which also accept a stack frame.

Sample problem with dropping properties:
@T
<pre>
	B := new(int,int);
barrier tst:= randomChoice()
	I := properties.drop(B,{hsorted}); 
exit	tst;
</pre>

@+ The cost model problem
An important issue for property management is to be able to pre-calculate
a cost for a MAL block. This calls for an cost model implementation that
recognizes instructions of interest, understands and can deal with the
dataflow semantics, and

For example, selectivity estimations can be based on a histogram associated
with a BAT. The code for this could look like
@T
<pre>
	B:= new(int,int);
	properties.add(B,{min,max,histogram});
	Z:= select(B,1,100);
</pre>
Addition of a property may trigger its evaluation, provided enough
information is available (e.g. catalog). The instruction triggers the
calls properties.set(B,{min}), properties.set(B,{max}), and 
properties.set(B,{histogram})
once a property evaluation engine is ran against the code block.
After assignment to Z, we have to propagate properties
properties.update(B,{min}).
@+ SQL case
To study the use of properties in the complete pipeline SQL-execution
we contrive a small SQL problem. The person table is sorted by name,
the car table is unsorted.
@T
<pre>
create table person(name varchar not null, address varchar);
create table car(name varchar, model varchar, milage int not null);
select distinct name, model, milage
from person, car
where car.name= person.name and milage>60000;
</pre>
@-
@+ Implementation rules
Properties can be associated with variables, MAL blocks, and MAL instructions.
This property list is only initialized upon explicit request, e.g. by
the frontend parser, a box manager, or as a triggered action.

Every property should come with a function that accepts a reference to 
the variable and updates the property record. This function is activated
either once or automatically upon each selection.

@+ Property ADT implementation

Given a property P, what are the permissible actions.

addProperty(O,P) adds property P to the list associated with O. If O represents
a compound structure, e.g. a BAT, we should indicate the component as well. For
example, addProperty(O,P,Ia,...Ib) introduces a property shared by the 
components Ia..Ib (indicated with an integer index.

hasProperty(O,P) is a boolean function that merely checks existence
hasnotProperty(O,P) is the dual operation.


setProperty(O,P,V) changes the propety value to V. It may raise a 
PropertyUpdateViolation exception when this can not be realized. 
Note, the property value itself is changed, not the object referenced.

getProperty(O,P) retrieves the current value of a property. This may involve
calling a function or running a database query.

setPropertyAttribute(O,P,A) changes the behavior of the property. For example,
the attribute 'freeze' will result in a call to the underlying function only
once and to cache the result for the remainder of the objects life time.

@+ Predefined properties
The MAL language uses a few defaults, recognizable as properties
@T
\begin{tabular}{l l}
unsafe & property is attached to a function when it has side effects
such as updates to a BAT. Default, unsafe=off\\
read & data can be read but not updated\\
append & data can be appended\\
\end{tabular}
@-
A poperty set contains a multi-list of (name,value) pairs.
Each list corresponds to an element in the corresponding group, e.g.
for simple objects we have a single lists, which for a BAT we have three
lists, the group properties, the head, and the tail list.

Since property lists are propagated throughout a program block,
its implementation should be geared at keeping the volatile properties
in the head. This way, in most cases it suffices to pass a pointer to a next
statement.

To make it work efficiently, we also require each name-value pair to be 
accessed only once.

In the implementation below we limit the number of property lists
per variable to 3, the upperbound for BATs. at a later stage we can
extend it to support arbitrary sized groups. A reference count is used
to simplify garbage collection.
@{
@h
#include "mal.h"

#define MAXPROPLIST 3

typedef struct PROPrecord{
	str		nme;
	ValRecord	val;
	struct PROPrecord *nxt;
} *Property;

typedef struct PROPSET{
	int 	refcount;
	int	maxlist;
	Property prop[MAXPROPLIST];
} *PropertySet;

mal_export PropertySet newPropertySet();
mal_export Property fndProperty(PropertySet ps, int first, int last, str nme);
mal_export void setProperty(PropertySet ps, int idx, str nme, int tpe, ptr val);
mal_export str propertySet2str(PropertySet ps, int idx);
@c
#include "mal_properties.h"
#include "mal_type.h"	/* for idcmp() */

PropertySet newPropertySet()
{	int i;
	PropertySet ps;

	ps= (PropertySet) GDKmalloc(sizeof(struct PROPSET));
	ps->refcount=0;
	ps->maxlist= MAXPROPLIST;
	for(i=0;i<MAXPROPLIST;i++) ps->prop[i]=0;
	return ps;
}
Property fndProperty(PropertySet ps, int first, int last, str nme){
	Property pr;
	int i;

	for(i=first; i<last;i++){
		pr= ps->prop[i];
		while(pr){
			if( idcmp(pr->nme,nme)==0) return pr;
			pr= pr->nxt;
		}
	}
	return 0;
}
@-
A property is assigned to a specific property list.
@c
void setProperty(PropertySet ps, int idx, str nme, int tpe, ptr val)
{	Property pr;

	pr= fndProperty(ps,idx,idx,nme);	
	if(pr == 0){
		pr = (Property) GDKmalloc(sizeof(struct PROPrecord));
		pr->nxt= ps->prop[idx];
		ps->prop[idx]= pr;
		pr->nme= GDKstrdup(nme);
	}
	VALset(&pr->val, tpe, val);
}
@-
For debugging purposes we should be able to convert any property set
back into a string. We simple assume the space required is limited.
@c
str propertySet2str(PropertySet ps, int idx){
	char buf[128*1024];
	str s=buf,t=0;
	Property pr;

	if(ps== NULL || ps->prop[idx]==NULL) return GDKstrdup("");
	pr= ps->prop[idx];
	*s++ = '{'; 
	while(pr){
		t=0;
		ATOMformat(pr->val.vtype, VALget(&pr->val), &t);
		if( strlen(t)==2)
			sprintf(s,"%s",pr->nme);
		else 	sprintf(s,"%s=%s",pr->nme,t);
		while(*s) s++;
		pr= pr->nxt;
		if( pr) *s++ = ',';
		if( t) GDKfree(t);
	}
	*s++ = '}'; 
	*s =0;
	return GDKstrdup(buf);
}
@}
