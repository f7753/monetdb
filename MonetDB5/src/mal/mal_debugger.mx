@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2004 CWI.
@' All Rights Reserved.
@'
@' Contributor(s):
@'              Martin Kersten <Martin.Kersten@cwi.nl>
@'              Peter Boncz <Peter.Boncz@cwi.nl>
@'              Niels Nes <Niels.Nes@cwi.nl>
@'              Stefan Manegold  <Stefan.Manegold@cwi.nl>
@'              Sjoerd Mullender  <Sjoerd.Mullender@cwi.nl>

@a M.L. Kersten
@* The MAL debugger
To enable ease of debugging and performance monitoring, the MAL interpreter
comes with a gdb-like text-based debugger.
The debugger can be entered at any time using the call mdb().
Also if there is no apparent console from which the debugger can be controlled.

@+ The debugger instruction set
@T
{\small
\begin{tabular} {l l}
next		& Advance to next statement\\
continue 	& Continue program being debugged\\
bbp 		& BBP memory layout\\
break 		& set breakpoint on current instruction\\
break {\em var} 	& break on assignment to {\em var}\\
delete {\em var} 	& remove break point {\em var}\\
step 		& advance to next MAL instruction\\
module 	& display the module [scopes] \\
finish 	& finish current call\\
quit 		& leave debugger\\
list 		& list current program block\\
List 		& list with type information\\
variables 	& print variable bindings\\
print {\em var} 	& display value of a variable\\
print {\em var} {\em c}[{\em f}] & display BAT chunk c:(c+f)\\
info {\em var} 	& display bat variable properties\\
run 		& restart current procedure\\
where 		& print stack trace\\
down  		& go down the stack\\
up  		& go up the stack\\
timer 		& micro-second response time\\
help 		& the help message\\
\end{tabular}
}
@+ Breakpoint tables
A powerful mechanism for debugging a program is to set breakpoints.
In MAL the breakpoints are designated by the <module>.<variable> name.
As soon as the variable recieves a new valued the breakpoint effectuated.
@-
The breakpoints are maintained in a system-wide
 global table. Although a little space
consumptive, it is the easiest to maintain and much less expensive
as reserving debugger space in each instruction.
@{
@- Compilation control
Being able to debug comes at a price.
The debugger options can be turned of at compile time using the 

@h
#ifndef _MAL_DEBUGGER_H
#define _MAL_DEBUGGER_H

#include "mal_scenario.h"
#include "mal_client.h"

#define MAXBREAKS 32

typedef struct {
	MalBlkPtr 	brkBlock[MAXBREAKS];
	int		brkVar[MAXBREAKS];
	char		brkCmd[MAXBREAKS];
	str		brkVarName[MAXBREAKS];
	int		brkTop;
} mdbStateRecord, *mdbState;

mal_export void mdbSetBreakpoint(Client cntxt, MalBlkPtr mb, InstrPtr p, str name,char cmd);
mal_export void mdbShowBreakpoints(Client cntxt);
mal_export void mdbCommand(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p, int pc);
mal_export void mdbStep(Client cntxt, MalBlkPtr mb, MalStkPtr stk, int pc);
mal_export void mdbHelp(stream *f);
mal_export void printStackElm(stream *f, MalBlkPtr mb, VarPtr n, ValPtr v,int index, int cnt,int first);
mal_export void printStack(stream *f, MalBlkPtr mb, MalStkPtr s);
mal_export void printBatInfo(stream *f, VarPtr n, ValPtr v);
mal_export str call2str(MalBlkPtr mb, MalStkPtr stk, int pc, int extra);

mal_export int mdbToggle(MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
mal_export int mdbSetCmd(MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
mal_export void printBBPinfo(stream *out);
#endif /* _MAL_DEBUGGER_h */
@+ Debugger framework
Before the interpreter is allowed to proceed we give control
to the user to alter the trace/debugger options.
@c
#include "mal_debugger.h"
#include "mal_atom.h"		/* for showAtoms() */
#include "mal_interpreter.h"	/* for getArgReference() */
#include "mal_linker.h"		/* for getAddress() */
#include "mal_scope.h"		/* for showScopeStatistics() */

mdbStateRecord mdbTable[MAL_MAXCLIENTS];

char isBreakpoint(Client cntxt, InstrPtr p){
	int i;

	for(i=0;i<mdbTable[cntxt->idx].brkTop;i++)
	if( getDestVar(p)== mdbTable[cntxt->idx].brkVar[i] ||
	    ( functionId(p) && 
	     strcmp(functionName(p), mdbTable[cntxt->idx].brkVarName[i])==0))
		return mdbTable[cntxt->idx].brkCmd[i];
	return 0;
}
@-
Break points can be set on assignment to a specific variable
or specific function name.
@c
void mdbSetBreakpointName(Client cntxt, MalBlkPtr mb, str name, char cmd){
	int i;
	char *c=name;
	InstrPtr p;

	while(*c && (isalnum((int)*c) || *c=='$' || *c=='_')) c++;
	*c = 0;
	for(i=0;i<mb->stop; i++){
		p= getInstrPtr(mb,i);
		if( (functionId(p) && strcmp(functionName(p),name) == 0) ||
		    strcmp(getVarName(mb,0),name) == 0){
			mdbSetBreakpoint(cntxt,mb,p,name,cmd);
			return;
		}
	}
}

void mdbSetBreakpoint(Client cntxt, MalBlkPtr mb, InstrPtr p, str name, char cmd)
{	mdbState mdb= mdbTable + cntxt->idx;
	mdb->brkBlock[mdb->brkTop] = mb;
	mdb->brkVar[mdb->brkTop] = getDestVar(p);
	mdb->brkVarName[mdb->brkTop] = name;
	mdb->brkCmd[mdb->brkTop] =cmd;
	if( mdb->brkTop+1< MAXBREAKS) 
		mdb->brkTop++;
}
void mdbShowBreakpoints(Client cntxt)
{	int i;
	mdbState mdb= mdbTable + cntxt->idx;

	for(i=0;i<mdb->brkTop;i++)
	stream_printf(cntxt->fdout,"breakpoint %s [%d]\n",
			mdb->brkVarName[i], mdb->brkVar[i]);
}

void mdbClrBreakpoint(Client cntxt, InstrPtr p)
{	int i,j=0;
	mdbState mdb= mdbTable + cntxt->idx;

	for(i=0;i<mdb->brkTop;i++){
		mdb->brkVar[j]= mdb->brkVar[i];
		mdb->brkVarName[j]= mdb->brkVarName[i];
		mdb->brkCmd[j]= mdb->brkCmd[i];
		mdb->brkBlock[j]= mdb->brkBlock[i];
		if( mdb->brkVar[i] != getDestVar(p)) j++;
	}
	mdb->brkTop = j;
}
void mdbClrBreakpointName(Client cntxt, str name)
{	int i,j=0;
	mdbState mdb= mdbTable + cntxt->idx;

	for(i=0;i<mdb->brkTop;i++){
		mdb->brkVar[j]= mdb->brkVar[i];
		mdb->brkVarName[j]= mdb->brkVarName[i];
		mdb->brkCmd[j]= mdb->brkCmd[i];
		mdb->brkBlock[j]= mdb->brkBlock[i];
		if( strcmp(mdb->brkVarName[i],name) ) j++;
	}
	mdb->brkTop = j;
}

#define skipBlanc(X)	while(*(X) && isspace((int)*X)) X++;
#define skipNonBlanc(X)	while(*(X) && !isspace((int) *X)) X++;
#define skipWord(X)	skipNonBlanc(X); skipBlanc(X);

@-
Prepare a string for an instruction call. The flag indicates
a need for position information as well.
@c
str call2str(MalBlkPtr mb, MalStkPtr stk, int pc, int extra){
	InstrPtr p;
	char buf[BLOCK];
	int l,k;

	p= getInstrPtr(mb, pc);
	if( p != NULL){
		if( moduleId(p) && functionId(p)){
			snprintf(buf,BLOCK,"%s.%s(",
				moduleName(p),functionName(p));
			for(k= p->retc; k<p->argc; k++){
				str msg=0; 
				ValPtr v= &stk->stk[p->argv[k]];
				ATOMformat(v->vtype, VALptr(v), &msg);
				l= strlen(buf);
				snprintf(buf+l,BLOCK-l,"%s",msg);
				GDKfree(msg);
				if( k < p->argc-1 ) {
					l= strlen(buf);
					snprintf(buf+l,BLOCK-l,",");
				}
			}
			l= strlen(buf);
			snprintf(buf+l,BLOCK-l,");");
		} else strcpy(buf,instruction2str(mb,p,FALSE));
	}
	if( extra){
		p= getInstrPtr(mb,0);
		l= strlen(buf);
		snprintf(buf+l,BLOCK-l," at #%d in %s", pc, functionName(p));
	}
	return GDKstrdup(buf);
}
void printCall(Client cntxt, MalBlkPtr mb, MalStkPtr stk, int pc){
	str msg;

	msg= call2str(mb,stk,pc,TRUE);
	stream_printf(cntxt->fdout,"%s\n",msg);
	GDKfree(msg);
}
void printTraceCall(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p){
	int k;
	str msg;
	str s;

	msg= instruction2str(mb,p,FALSE);
	s= strchr(msg,'(');
	if(s){
		s++;
		*s = 0;
		stream_printf(cntxt->fdout,"%s",msg);
		for(k= p->retc; k<p->argc; k++){
			ValPtr v= &stk->stk[p->argv[k]];
			ATOMprint(v->vtype,VALptr(v),cntxt->fdout);
			if( k < p->argc-1 ) stream_printf(cntxt->fdout,",");
			}
		stream_printf(cntxt->fdout,")\n");
	} else stream_printf(cntxt->fdout,"%s\n",msg);
	GDKfree(msg);
}

@+ MDB module implementation 
The following routines are available for inclusion also in MAL programs.
Either one set is sufficient to produce the required action.
Note that the mdbToggle command is called mostly from within a
(dummy) function. Therefore, we should also export the debugging mode
to the context.
@c
#define MDBstatus(X) stream_printf(cntxt->fdout,"#Monet Debugger %s\n", (X?"on":"off"));

int mdbToggle(MalBlkPtr mb, MalStkPtr stk, InstrPtr p){
	Client cntxt= getClient();
	int b=0;
	(void) mb; /* still unused */
	if( p->argc==1){
		/* Toggle */
		stk->cmd= stk->cmd? 0: 's';
		cntxt->itrace = cntxt->itrace == 0;
		if( stk->up) stk->up->cmd=  0;
		return 0;
	}
	if( p->argc >1){
		b= *(int *) getArgReference(stk,p,1);
	} else b= stk->cmd; 
	stk->cmd= b?'n':0;
	if( stk->up) stk->up->cmd=  b?'n':0;
	cntxt->itrace= b?'n':0;
	MDBstatus(b);
	return 0;
}

int mdbSetCmd(MalBlkPtr mb, MalStkPtr stk, InstrPtr p){
	Client cntxt= getClient();
	int b;
	(void) mb; /* still unused */
	b= *(chr *) getArgReference(stk,p,1);
	stk->cmd= b;
	cntxt->itrace= 'T';
	MDBstatus(b);
	return 0;
}

@+ MAL parser
The debugger structure is inherited from GDB.
The routine mdbCommand is called with p=0 after finishing a mal- function call
and before continuing at the next level of invocation.
The commands are self-explanatory.

The prompt string sent to the user indicates the debugger mode.
@c
void mdbCommand(Client cntxt,MalBlkPtr mb, MalStkPtr stk, InstrPtr p, int pc){
	char *b;
	stream *out = cntxt->fdout;
	int listing=cntxt->listing;

	if( p != NULL){
		stream_printf(out,"#mdb ");
		printInstruction(out,mb,p,listing);
	}
	do{
	cntxt->nxt= cntxt->input; *cntxt->nxt=0;
	readClient(cntxt,(cntxt==mal_clients?"mdb>":"\001mdb>\001"));
	b= cntxt->input;
	skipBlanc(b);
	switch(*b){
	case 0: return;
	case 'a': if( strncmp("atoms",b,5)==0) showAtoms(out);
		break;
	case 'c': if( strncmp("call",b,4)==0){
			GDKerror("call instruction not yet implemented\n");
			break;
		 }
		 stk->cmd= 'c';
		 return;
	case 'h': mdbHelp(out); break;
	case 'q': 
		stk->cmd= 'q';/* return from this debugger */
		cntxt->itrace= 0;
		MDBstatus(0);
		return;
	case 'f': /* finish */
	case 'n': /* next */
	case 's': /* step */
		if( strncmp("scenarios",b,3)==0){
			showAllScenarios(out);
		} else 
		if( strncmp("scenario",b,3)==0){
			showScenarioByName(out, cntxt->scenario);
		} else 
		if( strncmp("scope",b,3)==0){
			showScopeStatistics(out,cntxt->nspace);
			return;
		} 
		stk->cmd= *b;
		return;
	case 'm': /* display a module */
		{
		str modnme, fcnname;
		Scope fsym;
		Symbol fs;
		int i;

		if( strncmp("modules",b,7)==0){
			showScopes(out, cntxt->nspace);
			continue;
		}

		skipWord(b);
		skipBlanc(b);
		if(*b){
			modnme=b;
			fcnname= strchr(b,'.');
			if( fcnname == NULL){
				fsym= findScope(cntxt->nspace,modnme);
				if( fsym==0) {
					stream_printf(out,"%smodule not found\n",
							"#mdb ");
					continue;
				}
				for(i=0;i<MAXSCOPE;i++){
					fs= fsym->subscope[i];
					while(fs != NULL){
						printSignature(out,fs,listing);
						fs= fs->peer;
					}
				}
				continue;
			}
		}
		debugScope(out,cntxt->nspace,b);
		}
		break;
	case 't': /* trace breakpoint */
		if( strncmp("type",b,4)==0){
			skipWord(b); skipBlanc(b);
			if(strchr(b,'\n')) *strchr(b,'\n')= 0;
			traceFcnName= GDKstrdup(b);
		} else
		if( strncmp("timer",b,5)==0){
			if( cntxt->timer==0)
				cntxt->timer = GDKusec();
			else cntxt->timer = 0;
		}
		break;
	case 'T': /* trace instruction calls */
		printTraceCall(cntxt,mb,stk,p);
		break;
	case 'v':
		printStack(out,mb,stk);
		break;
	case 'b':
		if( strncmp(b,"bbp",3)==0){
			printBBPinfo(out);
			continue;
		}
		skipWord(b);
		if(*b==0) { mdbShowBreakpoints(cntxt); continue;}
		if( !isspace((int)*b) && *b != 0){
			/* set breakpoints by name */
			mdbSetBreakpointName(cntxt,mb,b,*b);
		} else {
			mdbSetBreakpoint(cntxt,mb,p,getArgName(mb,p,0),*b);
		}
		continue;
	case 'd':
		if( strncmp(b,"down",2)==0 && stk->down!= NULL){
			stream_printf(out,"%sgo down the stack\n","#mdb ");
			stk= stk->down;
			mb = stk->blk;
			break;
		}
		skipWord(b);
		/* get rid of break point */
		if(*b && !isspace((int)*b)){
			mdbClrBreakpointName(cntxt,b);
		} else {
			mdbClrBreakpoint(cntxt,p);
		}
		continue;
	case 'i':
	{	int i; 
		char *t;
		
		skipWord(b);
		t=b;
		skipNonBlanc(t);
		*t = 0;
		/* search the symbol */
		i = findVariable(mb,b);
		if( i<0){
			stream_printf(out,"%sSymbol not found\n","#mdb ");
		} else{
			printBatInfo(out,getVar(mb,i),stk->stk+i);
		}
		continue;
	}
	case 'p':
	{	int i, size=0,first=0;
		char *t;
		
		skipWord(b);
		t=b;
		skipNonBlanc(t);
		*t = 0;
		/* you can identify a start and length */
		t++; skipBlanc(t);
		if(isdigit((int)*t)){
			size= atol(t);
			skipWord(t);
			if( isdigit((int)*t)) first= atol(t);
		}
		/* search the symbol */
		i = findVariable(mb,b);
		if( i<0){
			stream_printf(out,"%sSymbol not found\n","#mdb ");
			continue;
		} 
		printStackElm(out, mb, getVar(mb,i),stk->stk+i,i,size,first);
		continue;
	}
	case 'u':
		if( stk->up == NULL) break;
		stream_printf(out,"%sgo up the stack\n","#mdb ");
		stk= stk->up;
		mb = stk->blk;
		printCall(cntxt,mb,stk,pc);
		continue;
	case 'w':
	{	MalStkPtr w;
		MalBlkPtr mw=mb;
		for(w=stk;w!= NULL; w=w->up){
			mw = w->blk;
			stream_printf(out,"#mdb ");
			printCall(cntxt,mw,w,pc);
		}
		continue;
	}
@-
While debugging it should be possible to inspect the symbol 
table using the 'module.function' name. The default is to list all
signatures satisfying the pattern.
@c
	case 'L': 
	case 'l': /* list the current code block */
	{	str modnme, fcnname;
		Scope fsym;
		Symbol fs;
		int i;

		listing |= *b=='L'? LIST_MAL_ALL:LIST_MAL_INSTR;
		skipWord(b);
		if( *b!= 0){
			modnme=b;
			fcnname= strchr(b,'.');
			if( fcnname == NULL){
				fsym= findScope(cntxt->nspace,modnme);
				if( fsym==0) {
					stream_printf(out,"%smodule not found\n",
							"#mdb ");
					continue;
				}
				for(i=0;i<MAXSCOPE;i++){
					fs= fsym->subscope[i];
					while(fs != NULL){
						printFunction(out,fs->def,listing);
						fs= fs->peer;
					}
				}
				continue;
			} 
			*fcnname = 0;
			fcnname ++;
			fsym= findScope(cntxt->nspace,modnme);
			if( fsym==0) {
				stream_printf(out,"%smodule not found\n","#mdb ");
				continue;
			}
			/* display the overloaded symbol definition */
			if( displayScope(out,fsym,fcnname)==0){
				stream_printf(out,"%sSymbol '%s.%s' not found\n",
					"#mdb ",modnme,fcnname);
			} 
		} else printFunction(out,mb,listing);
		continue;
	}
	case 'r': /* reset program counter */
		stream_printf(out,"%srestart with current stack\n","#mdb ");
		stk->cmd= 'r';
		return;
	default:
		stream_printf(out,"%sdebugger command expected\n","#mdb ");
		mdbHelp(out);
	}
	} while(1);
}
void mdbStep(Client cntxt, MalBlkPtr mb, MalStkPtr stk, int pc ){
	InstrPtr p;
	char newcmd;

	p= getInstrPtr(mb,pc);
	switch(stk->cmd){
	case 'c':
		if( (newcmd= isBreakpoint(cntxt,p)) ){
			if( newcmd == 't') 
				stream_printf(cntxt->fdout,"show value nyi \n");
			mdbCommand(cntxt,mb,stk,p,pc);
		} 
		break;
	case 's': case 'n':
		if( cntxt->timer){
			long n= GDKusec();
			long l= n - cntxt->timer;
			stream_printf(cntxt->fdout,"%s[%-3d usec]\n","#mdb ",l);
		}
		mdbCommand(cntxt,mb,stk,p,pc);
		break;
	case 'r': stk->cmd = 'n';
		if( cntxt->timer){
			long l= GDKusec() - cntxt->timer;
			stream_printf(cntxt->fdout,"[%d usec]",l);
		}
		break;
	case 'T':
		stream_printf(cntxt->fdout,"#mdb ");
		if( cntxt->timer){
			long n= GDKusec();
			long l= n - cntxt->timer;
			stream_printf(cntxt->fdout,"%s[%-3d usec]\n","#mdb ",l);
		}
		printTraceCall(cntxt,mb,stk,p);
	}
	if( cntxt->timer) cntxt->timer = GDKusec();
	stream_flush(cntxt->fdout);
}
@+ Utilities
DUmping a stack on a file is primarilly used for debugging.
Printing the stack requires access to both the symbol table and
the stackframes.
Beware that a stack frame need not be initialized with null values.
Instead, it has been zeroed upon creation.
@c
void printStack(stream *f, MalBlkPtr mb, MalStkPtr s){
        int i = 0;

	stream_printf(f,"#mdb ");
        stream_printf(f,"Stack size=%d top=%d\n",s->stksize,s->stktop);
        for( ; i<mb->vtop ; i++){
		printStackElm(f, mb, getVar(mb,i), s->stk+i,i,0,0);
        }
}

void printStackElm(stream *f, MalBlkPtr mb, VarPtr n, ValPtr v, int index, int cnt,int first){
	str nme,nmeOnStk;
	char nmebuf[PATHLENGTH];
	(void) mb; /* fool the compiler */
	if( n->tmpindex){
		snprintf(nmebuf,PATHLENGTH,"%c%d",TMPMARKER, n->tmpindex);
		nme= nmebuf;
	} else nme = n->name;
	stream_printf(f,"[%d] %s\t= ",index,nme);
	if( n->type == TYPE_void)
		stream_printf(f,"nil");
	else
/*
	if( n->isaconstant) {
		ATOMprint(v->vtype,VALptr(&n->value),f);
	} else {
		if( !(v->vtype== TYPE_str && v->len==0) )
			ATOMprint(v->vtype,VALptr(v),f);
	}
*/
	ATOMprint(v->vtype,VALptr(v),f);
	nme= getTypeName(n->type);
	nmeOnStk= getTypeName(v->vtype);
	stream_printf(f,":%s", nme);
	if( strcmp(nmeOnStk,nme) && 
	    !(isaBatType(n->type) && strcmp(nmeOnStk,"BAT")==0)){
		stream_printf(f," != %s", nmeOnStk);
	}
	stream_printf(f," %s", (n->isaconstant?" constant":""));
	stream_printf(f," %s", (n->isatypevar?" type variable":""));
	GDKfree(nme); GDKfree(nmeOnStk);
	if(cnt && isaBatType(n->type) && v->val.ival){
		BAT *b,*bs;
		b= BATdescriptor(v->val.ival);
		if( b== NULL){
			stream_printf(f,"Could not access descriptor\n");
			return;
		}
		stream_printf(f,"\n");
		if(cnt < BATcount(b)) {
			stream_printf(f,"Sample %d out of %d\n",cnt, BATcount(b));
		}
		/* cut out a portion of the BAT for display */
		printf("should cut out %d-%d\n",first, first+cnt);
		bs= BATslice(b,first,first+cnt);
		if(bs== NULL)
			stream_printf(f,"Failed to take chunk\n");
		else BATmultiprintf(f,2,&bs,TRUE,0);
		BBPunfix(b->batCacheid);
	} else 
	if( isaBatType(n->type)){
		BAT *b;
		b= BATdescriptor(v->val.ival);
		if(b){
			/* ignore ref count of this call */
			stream_printf(f," count=%d lrefs=%d refs=%d",
				BATcount(b),BBP_lrefs(ABS(b->batCacheid)),
				BBP_refs(ABS(b->batCacheid))-1);
			BBPunfix(b->batCacheid);
		}
	}
	stream_printf(f,"\n");
}
void printBatInfo(stream *f, VarPtr n, ValPtr v){
	if(isaBatType(n->type) && v->val.ival){
		int bid;
		int ret;
		MALfcn fcn;

		fcn = getAddress("CMDinfo");
		if(fcn){
			BAT *b;
			bid = v->val.ival;
			stream_printf(f,"Show info for %d\n",bid);
			(*fcn)(&ret,&bid);
			stream_printf(f,"got the info bat from %d\n",bid);
			b= BATdescriptor(ret);
			if( b== NULL){
				stream_printf(f,"Could not access descriptor\n");
				return;
			}
			BATmultiprintf(f,2,&b,TRUE,0);
			BBPunfix(b->batCacheid);
		}
	}
}
@-
The memory positions for the BATs is useful information to
asses for memory fragmentation.
@= heapinfo
hp= &b->@1;
if(hp->base){
	stream_printf(GDKout,"\t@1=%d size=%d\n",hp->base, hp->size);}
@= hashinfo
h= &b->@1;
if(h->mask){
        stream_printf(GDKout,"\t@1=%d size=%d\n",h, sizeof(*h));
        stream_printf(GDKout,"\t@1link=%d size=%d\n",h->link, 
				(h->mask+h->lim+1)*sizeof(int));
}
@-
The memProfileVector routine produces a character string to represent
the usage of memory by BAT information. The characters are interpreted
as follows:
.=unused, X=completely used, [0-9]=small elements within the granule
More then 9 elements makes it full. 
@= setVector
	start= (((long)@1)-min)/granule;
	lim= (((long)@1)-min + @2)/granule;
	stream_printf(GDKout,"start %d lim %d\n",start,lim);

@c
str memProfileVector(int cells){
	str v= GDKmalloc(cells+1);
	int i;
	long max= (long) sbrk(0);
	long min= 0;
	long granule= 0;
	if( cells<=0) {
		GDKerror("memProfileVector:positive argument expected\n");
		return GDKstrdup("");
	}
	v= GDKmalloc(cells+1);
	if( v== 0) 
		GDKfatal("memProfileVector:malloca failure\n");
	
	for(i=0; i<cells;i++) v[i]='.';
	v[i]=0;

	for(i=1; i<BBPsize; i++)
	if( BBP_status(i) & BBPLOADED ){
		BAT *b = BATdescriptor(i);
		Heap *hp;
		Hash *h;
		long start,lim;

		stream_printf(GDKout,"\tdesc=%d size=%d\n",b, sizeof(*b));
		hp= b->batBuns;
		stream_printf(GDKout,"\tbuns=%d size=%d\n",hp->base, hp->size);
		if( min==0){
			min= (long)b;
			max= min + GDKmem_heapsize();
			granule= (max-min)/cells;
			stream_printf(GDKout,"granule %dK\n",granule/1024);
		}
		@:setVector(b,sizeof(*b))@
		@:setVector(hp->base,hp->size)@

		@:heapinfo(hheap)@
		@:heapinfo(theap)@
		@:heapinfo(haccelerator)@
		@:heapinfo(taccelerator)@
		@:hashinfo(hhash)@
		@:hashinfo(thash)@
		BBPunfix(b->batCacheid);
	}
	return v;
}
void printBBPinfo(stream *out){
	str v;

	stream_printf(out,"#BBP memory layout\n");
	stream_printf(out,"#heap maximum =%d/M\n",GDKmem_heapsize()/(1024*1024));
	v= memProfileVector(32);
	stream_printf(out,"#%s\n",v);
	GDKfree(v);
#ifdef GDK_VM_KEEPHISTO
	stream_printf(out,"#BBP VM history available\n");
#else
	stream_printf(out,"#BBP VM history not available\n");
#endif
}
@-
Some utilities for the debugger 
@c
void mdbHelp(stream *f){
	stream_printf(f,"next		-- Advance to next statement\n");
	stream_printf(f,"continue 	-- Continue program being debugged\n");
	stream_printf(f,"bbp 		-- BBP memory layout\n");
	stream_printf(f,"break 		-- set breakpoint on current instruction\n");
	stream_printf(f,"break <var> 	-- break on assignment to <var>\n");
	stream_printf(f,"delete <var> 	-- remove break point <var>\n");
	stream_printf(f,"step 		-- advance to next MAL instruction\n");
	stream_printf(f,"module 	-- display the module [scopes] \n");
	stream_printf(f,"finish 	-- finish current call\n");
	stream_printf(f,"quit 		-- leave debugger\n");
	stream_printf(f,"list 		-- list current program block\n");
	stream_printf(f,"List 		-- list with type information\n");
	stream_printf(f,"variables 	-- print variable bindings\n");
	stream_printf(f,"print <var> 	-- display value of a variable\n");
	stream_printf(f,"print <var> <cnt>[<first>] -- display BAT chunk\n");
	stream_printf(f,"info <var> 	-- display bat variable properties\n");
	stream_printf(f,"run 		-- restart current procedure\n");
	stream_printf(f,"where 		-- print stack trace\n");
	stream_printf(f,"down  		-- go down the stack\n");
	stream_printf(f,"up  		-- go up the stack\n");
	stream_printf(f,"timer 		-- produce micro-second response time\n");
	stream_printf(f,"help 		-- this message\n");
}
@}
