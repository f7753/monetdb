@t The MAL debugger
@a M.L. Kersten
@* Introduction
To enable ease of debugging and performance monitoring, the MAL interpreter
comes with a gdb-like text-based debugger.
A global table of breakpoints is maintained. Although a little space
consumptive, it is the easiest to maintain and much less expensive
as reserving debugger space in each instruction.

@h
/*
 * The contents of this file are subject to the Monet Public
 * License Version 1.1 (the "License"); you may not use this file
 * except in compliance with the License. You may obtain a copy of
 * the License at http://www.monetsolutions.com/Download/Licensing/MonetPL-1.1.
html
 * 
 * Software distributed under the License is distributed on an "AS
 * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
 * implied. See the License for the specific language governing
 * rights and limitations under the License.
 * 
 * The Original Code is the Monet Database System.
 * 
 * The Initial Developer of the Original Code is CWI.
 * Portions created by CWI are Copyright (C) 1997-2001 CWI.  
 * All Rights Reserved.
 * 
 * Contributor(s): Martin Kersten <Martin.Kersten@cwi.nl>
 */
#ifndef _MAL_DEBUGGER_H
#define _MAL_DEBUGGER_H

#include "mal_scenario.h"
#include "mal_client.h"

#define MAXBREAKS 32

typedef struct {
	MalBlkPtr 	brkBlock[MAXBREAKS];
	int		brkVar[MAXBREAKS];
	char		brkCmd[MAXBREAKS];
	str		brkVarName[MAXBREAKS];
	int		brkTop;
} mdbStateRecord, *mdbState;

mal_export void mdbSetBreakpoint(Client cntxt, MalBlkPtr mb, InstrPtr p, str name,char cmd);
mal_export void mdbShowBreakpoints(Client cntxt);
mal_export void mdbCommand(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p, int pc);
mal_export void mdbStep(Client cntxt, MalBlkPtr mb, MalStkPtr stk, int pc);
mal_export void mdbHelp(stream *f);
mal_export void printStackElm(stream *f, MalBlkPtr mb,VarPtr n, ValPtr v,int index, int cnt,int first);
mal_export void printStack(stream *f, MalBlkPtr mb, MalStkPtr s);
mal_export void printBatInfo(stream *f, VarPtr n, ValPtr v);
mal_export str call2str(MalBlkPtr mb, MalStkPtr stk, int pc);

mal_export int mdbToggle(MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
mal_export int mdbSetCmd(MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
mal_export void printBBPinfo(stream *out);
#endif /* _MAL_DEBUGGER_h */
@+ Debugger framework
Before the interpreter is allowed to proceed we give control
to the user to alter the trace/debugger options.
@c
#include "mal_debugger.h"

mdbStateRecord mdbTable[MAL_MAXCLIENTS];

char isBreakpoint(Client cntxt, InstrPtr p){
	int i;

	for(i=0;i<mdbTable[cntxt->idx].brkTop;i++)
	if( getDestVar(p)== mdbTable[cntxt->idx].brkVar[i] ||
	    ( functionId(p) && 
	     strcmp(functionName(p), mdbTable[cntxt->idx].brkVarName[i])==0))
		return mdbTable[cntxt->idx].brkCmd[i];
	return 0;
}
@-
Break points can be set on assignment to a specific variable
or specific function name.
@c
void mdbSetBreakpointName(Client cntxt, MalBlkPtr mb, str name, char cmd){
	int i,j;
	char *c=name;
	InstrPtr p;
	mdbState mdb= mdbTable + cntxt->idx;

	while(*c && (isalnum(*c) || *c=='$' || *c=='_')) c++;
	*c = 0;
	for(i=0;i<mb->stop; i++){
		p= getInstrPtr(mb,i);
		if( (functionId(p) && strcmp(functionName(p),name) == 0) ||
		    strcmp(getVarName(mb,0),name) == 0){
			mdbSetBreakpoint(cntxt,mb,p,name,cmd);
			return;
		}
	}
}

void mdbSetBreakpoint(Client cntxt, MalBlkPtr mb, InstrPtr p, str name, char cmd)
{	mdbState mdb= mdbTable + cntxt->idx;
	mdb->brkBlock[mdb->brkTop] = mb;
	mdb->brkVar[mdb->brkTop] = getDestVar(p);
	mdb->brkVarName[mdb->brkTop] = name;
	mdb->brkCmd[mdb->brkTop] =cmd;
	if( mdb->brkTop+1< MAXBREAKS) 
		mdb->brkTop++;
}
void mdbShowBreakpoints(Client cntxt)
{	int i;
	mdbState mdb= mdbTable + cntxt->idx;

	for(i=0;i<mdb->brkTop;i++)
	stream_printf(cntxt->fdout,"breakpoint %s [%d]\n",
			mdb->brkVarName[i], mdb->brkVar[i]);
}

void mdbClrBreakpoint(Client cntxt, InstrPtr p)
{	int i,j=0;
	mdbState mdb= mdbTable + cntxt->idx;

	for(i=0;i<mdb->brkTop;i++){
		mdb->brkVar[j]= mdb->brkVar[i];
		mdb->brkVarName[j]= mdb->brkVarName[i];
		mdb->brkCmd[j]= mdb->brkCmd[i];
		mdb->brkBlock[j]= mdb->brkBlock[i];
		if( mdb->brkVar[i] != getDestVar(p)) j++;
	}
	mdb->brkTop = j;
}
void mdbClrBreakpointName(Client cntxt, str name)
{	int i,j=0;
	mdbState mdb= mdbTable + cntxt->idx;

	for(i=0;i<mdb->brkTop;i++){
		mdb->brkVar[j]= mdb->brkVar[i];
		mdb->brkVarName[j]= mdb->brkVarName[i];
		mdb->brkCmd[j]= mdb->brkCmd[i];
		mdb->brkBlock[j]= mdb->brkBlock[i];
		if( strcmp(mdb->brkVarName[i],name) ) j++;
	}
	mdb->brkTop = j;
}

#define skipBlanc(X)	while(*(X) && isspace(*X)) X++;
#define skipNonBlanc(X)	while(*(X) && !isspace(*X)) X++;
#define skipWord(X)	skipNonBlanc(X); skipBlanc(X);

str call2str(MalBlkPtr mb, MalStkPtr stk, int pc){
	InstrPtr p;
	char buf[BLOCK];
	int l,k;

	p= getInstrPtr(mb, pc);
	if( p != NULL){
		if( p->token== ASSIGNsymbol){
			strcpy(buf,instruction2str(mb,p,FALSE));
		} else {
		snprintf(buf,BLOCK,"%s.%s(",moduleName(p),functionName(p));
		for(k= p->retc; k<p->argc; k++){
			str msg=0; 
			ValPtr v= &stk->stk[p->argv[k]];
			ATOMformat(v->vtype, VALptr(v), &msg);
			l= strlen(buf);
			snprintf(buf+l,BLOCK-l,"%s",msg);
			GDKfree(msg);
			if( k < p->argc-1 ) {
				l= strlen(buf);
				snprintf(buf+l,BLOCK-l,",");
			}
		}
		l= strlen(buf);
		snprintf(buf+l,BLOCK-l,")");
		}
	}
	p= getInstrPtr(mb,0);
	l= strlen(buf);
	snprintf(buf+l,BLOCK-l," at #%d in %s", pc, functionName(p));
	return GDKstrdup(buf);
}
void printCall(Client cntxt, MalBlkPtr mb, MalStkPtr stk, int pc){
	str msg;

	msg= call2str(mb,stk,pc);
	stream_printf(cntxt->fdout,"%s\n",msg);
	GDKfree(msg);
}
void printTraceCall(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p){
	int k;
	str msg;
	str s;

	msg= instruction2str(mb,p,FALSE);
	s= strchr(msg,'(');
	if(s){
		s++;
		*s = 0;
		stream_printf(cntxt->fdout,"%s",msg);
		for(k= p->retc; k<p->argc; k++){
			ValPtr v= &stk->stk[p->argv[k]];
			ATOMprint(v->vtype,VALptr(v),cntxt->fdout);
			if( k < p->argc-1 ) stream_printf(cntxt->fdout,",");
			}
		stream_printf(cntxt->fdout,")\n");
	} else stream_printf(cntxt->fdout,"%s\n",msg);
	GDKfree(msg);
}

@+ MDB module implementation 
The following routines are available for inclusion also in MAL programs.
Either one set is sufficient to produce the required action.
Note that the mdbToggle command is called mostly from within a
(dummy) function. Therefore, we should also export the debugging mode
to the context.
@c
#define MDBstatus(X) stream_printf(cntxt->fdout,"#Monet Debugger %s\n", (X?"on":"off"));

int mdbToggle(MalBlkPtr mb, MalStkPtr stk, InstrPtr p){
	Client cntxt= getClient();
	int b;
	if( p->argc==1){
		/* Toggle */
		stk->cmd= stk->cmd? 0: 's';
		cntxt->itrace = cntxt->itrace == 0;
		if( stk->up) stk->up->cmd=  b?'s':0;
		return 0;
	}
	if( p->argc >1){
		b= *(int *) getArgReference(stk,p,1);
	} else b= stk->cmd; 
	stk->cmd= b?'n':0;
	if( stk->up) stk->up->cmd=  b?'n':0;
	cntxt->itrace= b?'n':0;
	MDBstatus(b);
	return 0;
}

int mdbSetCmd(MalBlkPtr mb, MalStkPtr stk, InstrPtr p){
	Client cntxt= getClient();
	int b;
	b= *(chr *) getArgReference(stk,p,1);
	stk->cmd= b;
	cntxt->itrace= 'T';
	MDBstatus(b);
	return 0;
}

@+ MAL parser
The debugger structure is inherited from GDB.
The routine mdbCommand is called with p=0 after finishing a mal- function call
and before continuing at the next level of invocation.
The commands are self-explanatory.

The prompt string sent to the user indicates the debugger mode.
@c
void mdbCommand(Client cntxt,MalBlkPtr mb, MalStkPtr stk, InstrPtr p, int pc){
	char *b;
	stream *out = cntxt->fdout;
	int listing=cntxt->listing;

	if( p != NULL){
		stream_printf(out,"#mdb ");
		printInstruction(out,mb,p,listing);
	}
	do{
	cntxt->nxt= cntxt->input; *cntxt->nxt=0;
	if( readClient(cntxt,(cntxt==mal_clients?"mdb>":"\001mdb>\001"))==0){
		stream_printf(GDKout,"Client %s disappeared\n",cntxt->user);
		return;
	}
	b= cntxt->input;
	skipBlanc(b);
	switch(*b){
	case 0: return;
	case 'a': if( strncmp("atoms",b,5)==0) showAtoms(out);
		break;
	case 'c': if( strncmp("call",b,4)==0){
			GDKerror("call instruction not yet implemented\n");
			break;
		 }
		 stk->cmd= 'c';
		 return;
	case 'h': mdbHelp(out); break;
	case 'q': 
		stk->cmd= 'q';/* return from this debugger */
		cntxt->itrace= 0;
		MDBstatus(0);
		return;
	case 'f': /* finish */
	case 'n': /* next */
	case 's': /* step */
		if( strncmp("scenarios",b,9)==0){
			showAllScenarios(out);
		} else 
		if( strncmp("scenario",b,8)==0){
			showScenarioByName(out, cntxt->scenario);
		} else 
		if( strncmp("scope",b,5)==0){
			showScopeStatistics(out,cntxt->nspace);
			return;
		} 
		stk->cmd= *b;
		return;
	case 'm': /* display a module */
		{
		str modname, fcnname;
		Scope fsym;
		Symbol fs;
		int i;

		if( strncmp("modules",b,7)==0){
			showScopes(out, cntxt->nspace);
			continue;
		}

		skipWord(b);
		skipBlanc(b);
		if(*b){
			modname=b;
			fcnname= strchr(b,'.');
			if( fcnname == NULL){
				fsym= findScope(cntxt->nspace,modname);
				if( fsym==0) {
					stream_printf(out,"%smodule not found\n",
							"#mdb ");
					continue;
				}
				for(i=0;i<MAXSCOPE;i++){
					fs= fsym->subscope[i];
					while(fs != NULL){
						printSignature(out,fs,listing);
						fs= fs->peer;
					}
				}
				continue;
			}
		}
		debugScope(out,cntxt->nspace,b);
		}
		break;
	case 't': /* trace breakpoint */
		if( strncmp("type",b,4)==0){
			skipWord(b); skipBlanc(b);
			if(strchr(b,'\n')) *strchr(b,'\n')= 0;
			traceFcnName= GDKstrdup(b);
		} else
		if( strncmp("timer",b,5)==0){
			if( cntxt->timer==0)
				cntxt->timer = GDKusec();
			else cntxt->timer = 0;
		}
		break;
	case 'T': /* trace instruction calls */
		printTraceCall(cntxt,mb,stk,p);
		break;
	case 'b':
		if( strncmp(b,"bbp",3)==0){
			printBBPinfo(out);
			continue;
		}
		skipWord(b);
		if(*b==0) { mdbShowBreakpoints(cntxt); continue;}
		if( !isspace(*b) && *b != 0){
			/* set breakpoints by name */
			mdbSetBreakpointName(cntxt,mb,b,*b);
		} else {
			mdbSetBreakpoint(cntxt,mb,p,getArgName(mb,p,0),*b);
		}
		continue;
	case 'd':
		/* get rid of break point */
		if( strncmp(b,"do",2)==0 && stk->down!= NULL){
			stream_printf(out,"%sgo down the stack\n","#mdb ");
			stk= stk->down;
			mb = stk->blk;
			break;
		}
		skipWord(b);
		if(*b && !isspace(*b)){
			mdbClrBreakpointName(cntxt,b);
		} else {
			mdbClrBreakpoint(cntxt,p);
		}
		continue;
	case 'i':
	{	int i; int size;
		char *t;
		
		skipWord(b);
		t=b;
		skipNonBlanc(t);
		*t = 0;
		size= atol(t+1);
		/* search the symbol */
		i = findVariable(mb,b);
		if( i<0){
			stream_printf(out,"%sSymbol not found\n","#mdb ");
		} else{
			printBatInfo(out,getVar(mb,i),stk->stk+i);
		}
		continue;
	}
	case 'p':
	{	int i, size=0,first=0;
		char *t;
		
		skipWord(b);
		t=b;
		skipNonBlanc(t);
		*t = 0;
		/* you can identify a start and length */
		t++; skipBlanc(t);
		if(isdigit(*t)){
			size= atol(t);
			skipWord(t);
			if( isdigit(*t)) first= atol(t);
		}
		/* search the symbol */
		i = findVariable(mb,b);
		if( i<0){
			stream_printf(out,"%sSymbol not found\n","#mdb ");
			continue;
		} 
		printStackElm(out,mb,getVar(mb,i),stk->stk+i,i,size,first);
		continue;
	}
	case 'u':
		if( stk->up == NULL) break;
		stream_printf(out,"%sgo up the stack\n","#mdb ");
		stk= stk->up;
		mb = stk->blk;
		printCall(cntxt,mb,stk,pc);
		continue;
	case 'v': /* variable bindings */
		printStack(out,mb,stk);
		continue;
	case 'w':
	{	MalStkPtr w;
		MalBlkPtr mw=mb;
		for(w=stk;w!= NULL; w=w->up){
			mw = w->blk;
			stream_printf(out,"#mdb ");
			printCall(cntxt,mw,w,pc);
		}
		continue;
	}
@-
While debugging it should be possible to inspect the symbol 
table using the 'module.function' name. The default is to list all
signatures satisfying the pattern.
@c
	case 'L': 
	case 'l': /* list the current code block */
	{	str modname, fcnname;
		Scope fsym;
		Symbol fs;
		int i;

		listing |= *b=='L'? LIST_MAL_ALL:LIST_MAL_INSTR;
		skipWord(b);
		if( *b!= 0){
			modname=b;
			fcnname= strchr(b,'.');
			if( fcnname == NULL){
				fsym= findScope(cntxt->nspace,modname);
				if( fsym==0) {
					stream_printf(out,"%smodule not found\n",
							"#mdb ");
					continue;
				}
				for(i=0;i<MAXSCOPE;i++){
					fs= fsym->subscope[i];
					while(fs != NULL){
						printFunction(out,fs->def,listing);
						fs= fs->peer;
					}
				}
				continue;
			} 
			*fcnname = 0;
			fcnname ++;
			fsym= findScope(cntxt->nspace,modname);
			if( fsym==0) {
				stream_printf(out,"%smodule not found\n","#mdb ");
				continue;
			}
			/* display the overloaded symbol definition */
			if( displayScope(out,fsym,fcnname)==0){
				stream_printf(out,"%sSymbol '%s.%s' not found\n",
					"#mdb ",modname,fcnname);
			} 
		} else printFunction(out,mb,listing);
		continue;
	}
	case 'r': /* reset program counter */
		stream_printf(out,"%srestart with current stack\n","#mdb ");
		stk->cmd= 'r';
		return;
	default:
		stream_printf(out,"%sdebugger command expected\n","#mdb ");
		mdbHelp(out);
	}
	} while(1);
}
void mdbStep(Client cntxt, MalBlkPtr mb, MalStkPtr stk, int pc ){
	InstrPtr p;
	char newcmd;

	p= getInstrPtr(mb,pc);
	switch(stk->cmd){
	case 'c':
		if( newcmd= isBreakpoint(cntxt,p) ){
			if( newcmd == 't') 
				stream_printf(cntxt->fdout,"show value nyi \n");
			mdbCommand(cntxt,mb,stk,p,pc);
		} 
		break;
	case 's': case 'n':
		if( cntxt->timer){
			long n= GDKusec();
			long l= n - cntxt->timer;
			stream_printf(cntxt->fdout,"%s[%-3d usec]\n","#mdb ",l);
		}
		mdbCommand(cntxt,mb,stk,p,pc);
		break;
	case 'r': stk->cmd = 'n';
		if( cntxt->timer){
			long l= GDKusec() - cntxt->timer;
			stream_printf(cntxt->fdout,"[%d usec]",l);
		}
		break;
	case 'T':
		stream_printf(cntxt->fdout,"#mdb ");
		if( cntxt->timer){
			long n= GDKusec();
			long l= n - cntxt->timer;
			stream_printf(cntxt->fdout,"%s[%-3d usec]\n","#mdb ",l);
		}
		printTraceCall(cntxt,mb,stk,p);
	}
	if( cntxt->timer) cntxt->timer = GDKusec();
	cntxt->fdout->flush(cntxt->fdout);
}
@+ Utilities
DUmping a stack on a file is primarilly used for debugging.
Printing the stack requires access to both the symbol table and
the stackframes.
Beware that a stack frame need not be initialized with null values.
Instead, it has been zeroed upon creation.
@c
void printStack(stream *f, MalBlkPtr mb, MalStkPtr s){
        int i = 0;

	stream_printf(f,"#mdb ");
        stream_printf(f,"Stack size=%d top=%d\n",s->stksize,s->stktop);
        for( ; i<mb->vtop ; i++){
		printStackElm(f, mb, getVar(mb,i), s->stk+i,i,0,0);
        }
}

void printStackElm(stream *f, MalBlkPtr mb, VarPtr n, ValPtr v, int index, int cnt,int first){
	str nme,nmeOnStk;
	char nmebuf[PATHLENGTH];
	if( n->tmpindex){
		snprintf(nmebuf,PATHLENGTH,"%c%d",TMPMARKER, n->tmpindex);
		nme= nmebuf;
	} else nme = n->name;
	stream_printf(f,"[%d] %s\t= ",index,nme);
	if( n->type == TYPE_void)
		stream_printf(f,"nil");
	else
	if( n->isaconstant) {
		ATOMprint(v->vtype,VALptr(&n->value),f);
	} else {
		ATOMprint(v->vtype,VALptr(v),f);
	}
	nme= getTypeName(n->type);
	nmeOnStk= getTypeName(v->vtype);
	stream_printf(f,":%s", nme);
	if( strcmp(nmeOnStk,nme) && 
	    !(isaBatType(n->type) && strcmp(nmeOnStk,"BAT")==0)){
		stream_printf(f," != %s (%d)", nmeOnStk,v->vtype);
	}
	stream_printf(f," %s", (n->isaconstant?" constant":""));
	stream_printf(f," %s", (n->isatypevar?" type variable":""));
	GDKfree(nme); GDKfree(nmeOnStk);
	if(cnt && isaBatType(n->type) && v->val.ival){
		BAT *b,*bs;
		b= BATdescriptor(v->val.ival);
		if( b== NULL){
			stream_printf(f,"Could not access descriptor\n");
			return;
		}
		stream_printf(f,"\n");
		if(cnt < BATcount(b)) {
			stream_printf(f,"Sample %d out of %d\n",cnt, BATcount(b));
		}
		/* cut out a portion of the BAT for display */
		printf("should cut out %d-%d\n",first, first+cnt);
		bs= BATslice(b,first,first+cnt);
		if(bs== NULL)
			stream_printf(f,"Failed to take chunk\n");
		else BATmultiprintf(f,2,&bs,TRUE,0);
		BBPunfix(b->batCacheid);
	} else 
	if( isaBatType(n->type)){
		BAT *b;
		b= BATdescriptor(v->val.ival);
		if(b){
			stream_printf(f," count=%d refs=%d",
				BATcount(b),BBP_refs(b->batCacheid));
			BBPunfix(b->batCacheid);
		}
	}
	stream_printf(f,"\n");
}
void printBatInfo(stream *f, VarPtr n, ValPtr v){
	if(isaBatType(n->type) && v->val.ival){
		int bid;
		int ret;
		GDKfcn fcn;

		fcn = (GDKfcn) getAddress("CMDinfo");
		if(fcn){
			BAT *b;
			bid = v->val.ival;
			stream_printf(f,"Show info for %d\n",bid);
			(*fcn)(&ret,&bid);
			stream_printf(f,"got the info bat from %d\n",bid);
			b= BATdescriptor(ret);
			if( b== NULL){
				stream_printf(f,"Could not access descriptor\n");
				return;
			}
			BATmultiprintf(f,2,&b,TRUE,0);
			BBPunfix(b->batCacheid);
		}
	}
}
@-
The memory positions for the BATs is useful information to
asses for memory fragmentation.
@= heapinfo
hp= &b->@1;
if(hp->base){
	stream_printf(GDKout,"\t@1=%d size=%d\n",hp->base, hp->size);}
@= hashinfo
h= &b->@1;
if(h->mask){
        stream_printf(GDKout,"\t@1=%d size=%d\n",h, sizeof(*h));
        stream_printf(GDKout,"\t@1link=%d size=%d\n",h->link, 
				(h->mask+h->lim+1)*sizeof(int));
}
@-
The memProfileVector routine produces a character string to represent
the usage of memory by BAT information. The characters are interpreted
as follows:
.=unused, X=completely used, [0-9]=small elements within the granule
More then 9 elements makes it full. 
@= setVector
	start= (((long)@1)-min)/granule;
	lim= (((long)@1)-min + @2)/granule;
	stream_printf(GDKout,"start %d lim %d\n",start,lim);

@c
str memProfileVector(int cells){
	str v= GDKmalloc(cells+1);
	int i;
	long max= (long) sbrk(0);
	long min= 0;
	long granule;
	if( cells<=0) {
		GDKerror("memProfileVector:positive argument expected\n");
		return GDKstrdup("");
	}
	v= GDKmalloc(cells+1);
	if( v== 0) 
		GDKfatal("memProfileVector:malloca failure\n");
	
	for(i=0; i<cells;i++) v[i]='.';
	v[i]=0;

	for(i=1; i<BBPsize; i++)
	if( BBP_status(i) & BBPLOADED ){
		BAT *b = BATdescriptor(i);
		Heap *hp;
		Hash *h;
		long start,lim;

		stream_printf(GDKout,"\tdesc=%d size=%d\n",b, sizeof(*b));
		hp= b->batBuns;
		stream_printf(GDKout,"\tbuns=%d size=%d\n",hp->base, hp->size);
		if( min==0){
			min= (long)b;
			max= min + GDKmem_heapsize();
			granule= (max-min)/cells;
			stream_printf(GDKout,"granule %dK\n",granule/1024);
		}
		@:setVector(b,sizeof(*b))@
		@:setVector(hp->base,hp->size)@

		@:heapinfo(hheap)@
		@:heapinfo(theap)@
		@:heapinfo(haccelerator)@
		@:heapinfo(taccelerator)@
		@:hashinfo(hhash)@
		@:hashinfo(thash)@
		BBPunfix(b->batCacheid);
	}
	return v;
}
void printBBPinfo(stream *out){
	int i;
	str v;

	stream_printf(out,"#BBP memory layout\n");
	stream_printf(out,"#heap maximum =%d/M\n",GDKmem_heapsize()/(1024*1024));
	v= memProfileVector(32);
	stream_printf(out,"#%s\n",v);
	GDKfree(v);
#ifdef GDK_VM_KEEPHISTO
	stream_printf(out,"#BBP VM history available\n");
#else
	stream_printf(out,"#BBP VM history not available\n");
#endif
}
@-
Some utilities for the debugger 
@c
void mdbHelp(stream *f){
	stream_printf(f,"next		-- Advance to next statement\n");
	stream_printf(f,"continue 	-- Continue program being debugged\n");
	stream_printf(f,"bbp 		-- BBP memory layout\n");
	stream_printf(f,"break 		-- set breakpoint on current instruction\n");
	stream_printf(f,"break <var> 	-- break on assignment to <var>\n");
	stream_printf(f,"step 		-- advance to next MAL instruction\n");
	stream_printf(f,"module 	-- display the module [scopes] \n");
	stream_printf(f,"finish 	-- finish current call\n");
	stream_printf(f,"quit 		-- leave debugger\n");
	stream_printf(f,"list 		-- list current program block\n");
	stream_printf(f,"variables 	-- print variable bindings\n");
	stream_printf(f,"where 		-- print stack trace\n");
	stream_printf(f,"print <var> 	-- display value of a variable\n");
	stream_printf(f,"print <var> <cnt>[<first>] -- display BAT chunk\n");
	stream_printf(f,"info <var> 	-- display bat variable properties\n");
	stream_printf(f,"run 		-- restart current procedure\n");
	stream_printf(f,"timer 		-- produce micro-second response time\n");
	stream_printf(f,"help 		-- this message\n");
}
