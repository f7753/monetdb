@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2005 CWI.
@' All Rights Reserved.

@a M.L. Kersten
@* The MAL debugger
To ease debugging and performance monitoring, the MAL interpreter
comes with a gdb-like text-based debugger.
The debugger can be entered at any time using the call mdb() against
a MonetDB client.

@+ The debugger instruction set
@multitable @columnfractions .2 .8
@item next
@tab  Advance to next statement
@item continue
@tab  Continue program being debugged
@item break
@tab set breakpoint on current instruction
@item break @emph{ var}
@tab break on assignment to @emph{ var}
@item call
@tab execute MAL instruction [todo]
@item continue
@tab to next breakpoint
@item delete @emph{ var}
@tab remove break point @emph{ var}
@item step
@tab advance to next MAL instruction
@item module
@tab display the module signatures
@item finish
@tab finish current call
@item quit
@tab leave debugger
@item list
@tab list current program block
@item List
@tab list with type information
@item var
@tab print symbol table [with bindings]
@item print @emph{ var}
@tab display value of a variable
@item print @emph{ var} @emph{ c}[@emph{ f}]
@tab display BAT chunk c:(c+f)
@item info @emph{ var}
@tab display bat variable properties
@item run
@tab restart current procedure
@item where
@tab print stack trace
@item down
@tab go down the stack
@item up
@tab go up the stack
@item timer
@tab micro-second response time
@item help
@tab the help message
@end multitable

@+ Breakpoints
A powerful mechanism for debugging a program is to set breakpoints.
In MAL they are designated by the <operator> or <variable> name.
As soon as the variable recieves a new value  or the operation
is called the debugger is activated.

@+ Embedded debugger calls
Part of the debugger functionality can also be controlled using
MAL instructions. For, the debugger can be (de-)activated using the
corresponding mdb() instruction with a boolean argument.
The debugger is only activated when the user can direct its execution
from the client interface. Otherwise, there is no proper input channel
and the debugger will run in trace mode.

A particular operation can be traced using the command
setTrace(<modulename>,<operation>,<on/off>).
Likewise, breackpoints can be set and cleared on operations and variables
to escape to the debugger.

The debugger flag setTimer(<on/off>) enables tracing the micro-seconds
spent on each instruction.
@{
@- Compilation control
Being able to debug comes at a price.
It should be possible to turn off the feature at compile time.

@h
#ifndef _MAL_DEBUGGER_H
#define _MAL_DEBUGGER_H

#include "mal_scenario.h"
#include "mal_client.h"

#define MAL_DEBUGGER 	/* debugger is active */

#define MAXBREAKS 32

mal_export int MDBdelay; /* do not immediately react */
typedef struct {
    MalBlkPtr   brkBlock[MAXBREAKS];
    int     brkVar[MAXBREAKS];
    char        brkCmd[MAXBREAKS];
    str     brkVarName[MAXBREAKS];
    int     brkTop;
} mdbStateRecord, *mdbState;

mal_export void mdbSetBreakpoint(Client cntxt, MalBlkPtr mb, InstrPtr p, str name,char cmd);
mal_export void mdbClrBreakpointName(Client cntxt, str name);
mal_export void mdbShowBreakpoints(Client cntxt);
mal_export void mdbCommand(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p, int pc);
mal_export void mdbStep(Client cntxt, MalBlkPtr mb, MalStkPtr stk, int pc);
mal_export void mdbHelp(stream *f);
mal_export void printStackElm(stream *f, MalBlkPtr mb, VarPtr n, ValPtr v,int index, int cnt,int first);
mal_export void printStack(stream *f, MalBlkPtr mb, MalStkPtr s);
mal_export void printBatInfo(stream *f, VarPtr n, ValPtr v);
mal_export void printTraceCall(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
mal_export str call2str(MalBlkPtr mb, MalStkPtr stk, int pc, int extra);

mal_export void printBBPinfo(stream *out);

mal_export void resetOptimizerDebugger();
mal_export void optimizerDebug(MalBlkPtr mb, str name,int actions,long usec);
mal_export str optimizeMALBlock(MalBlkPtr mb);
mal_export void showOptimizerStep(int i,int flg);
mal_export void showOptimizerHistory();
mal_export str debugOptimizers(MalBlkPtr mb,MalStkPtr stk, InstrPtr pci);

#endif /* _MAL_DEBUGGER_h */
@+ Debugger framework
Before the interpreter is allowed to proceed we give control
to the user to alter the trace/debugger options.
@c
#include "mal_debugger.h"
#include "mal_atom.h"       /* for showAtoms() */
#include "mal_interpreter.h"    /* for getArgReference() */
#include "mal_linker.h"     /* for getAddress() */
#include "mal_module.h"      /* for showModuleStatistics() */
#include "mal_parser.h"
#include "mal_namespace.h"


int MDBdelay; /* do not immediately react */

#define skipBlanc(c,X)    while(*(X) && isspace((int)*X)){ X++; }
#define skipNonBlanc(c,X) while(*(X) && !isspace((int) *X)){ X++; }
#define skipWord(c,X) 	  skipNonBlanc(c,X); skipBlanc(c,X);
@-
Each client has its own breakpoint administration, kept in a global table.
Although a little space consumptive, it is the easiest to maintain
and much less expensive as reserving debugger space in each instruction.
@c
mdbStateRecord mdbTable[MAL_MAXCLIENTS];

char isBreakpoint(Client cntxt, InstrPtr p){
    int i,j;

    for(i=0;i<mdbTable[cntxt->idx].brkTop;i++){
        if( functionId(p) &&
            strcmp(functionName(p),
                mdbTable[cntxt->idx].brkVarName[i])==0)
            return mdbTable[cntxt->idx].brkCmd[i];
        for(j=0;j<p->retc;j++)
        if( p->argv[j] == mdbTable[cntxt->idx].brkVar[i])
            return mdbTable[cntxt->idx].brkCmd[i];
    }
    return 0;
}
@-
Break points can be set on assignment to a specific variable
or specific operation.
@c
void mdbSetBreakpointName(Client cntxt, MalBlkPtr mb, str name, char cmd){
    int i,j,cnt=0;
    InstrPtr p;

    for(i=0;i<mb->stop; i++){
        p= getInstrPtr(mb,i);
        if( functionId(p) && strcmp(functionName(p),name) == 0 ){
            mdbSetBreakpoint(cntxt,mb,p,name,cmd);
            cnt++;
            continue;
        }
        for(j=0; j<p->retc; j++)
        if( strcmp(getArgName(mb,p,j),name) == 0){
            mdbSetBreakpoint(cntxt,mb,p,name,cmd);
            cnt++;
            continue;
        }
    }
    if(cnt == 0)
    stream_printf(cntxt->fdout,"breakpoint on '%s' not set\n", name);
}
@-
A breakpoint should be set once for each combination
@c
void mdbSetBreakpoint(Client cntxt, MalBlkPtr mb, InstrPtr p, str name, char cmd)
{   mdbState mdb= mdbTable + cntxt->idx;
	int i;
	for(i=0;i<mdb->brkTop; i++)
	if( mdb->brkBlock[i] == mb &&
    	strcmp(mdb->brkVarName[i], name)==0 ) return;
    mdb->brkBlock[mdb->brkTop] = mb;
    mdb->brkVar[mdb->brkTop] = getDestVar(p);
    mdb->brkVarName[mdb->brkTop] = GDKstrdup(name);
    mdb->brkCmd[mdb->brkTop] =cmd;
    if( mdb->brkTop+1< MAXBREAKS)
        mdb->brkTop++;
}
void mdbShowBreakpoints(Client cntxt)
{   int i;
    mdbState mdb= mdbTable + cntxt->idx;

    for(i=0;i<mdb->brkTop;i++)
    stream_printf(cntxt->fdout,"breakpoint on '%s' with id %d\n",
            mdb->brkVarName[i], mdb->brkVar[i]);
}

void mdbClrBreakpoint(Client cntxt, InstrPtr p)
{   int i,j=0;
    mdbState mdb= mdbTable + cntxt->idx;

    for(i=0;i<mdb->brkTop;i++){
        mdb->brkVar[j]= mdb->brkVar[i];
        mdb->brkVarName[j]= mdb->brkVarName[i];
        mdb->brkCmd[j]= mdb->brkCmd[i];
        mdb->brkBlock[j]= mdb->brkBlock[i];
        if( mdb->brkVar[i] != getDestVar(p)) j++;
        else {
            GDKfree(mdb->brkVarName[i]);
            mdb->brkVarName[i]= 0;
        }

    }
    mdb->brkTop = j;
}
void mdbClrBreakpointName(Client cntxt, str name)
{   int i,j=0;
    mdbState mdb= mdbTable + cntxt->idx;

    for(i=0;i<mdb->brkTop;i++){
        mdb->brkVar[j]= mdb->brkVar[i];
        mdb->brkVarName[j]= mdb->brkVarName[i];
        mdb->brkCmd[j]= mdb->brkCmd[i];
        mdb->brkBlock[j]= mdb->brkBlock[i];
        if( strcmp(mdb->brkVarName[i],name) ) j++;
        else {
            GDKfree(mdb->brkVarName[i]);
            mdb->brkVarName[i]= 0;
        }
    }
    mdb->brkTop = j;
}

@-
The instruction call stack is the most common command.
Prepare a string for an instruction call. The flag indicates
a need for position information as well.
@c
str call2str(MalBlkPtr mb, MalStkPtr stk, int pc, int extra){
	InstrPtr p;
	char target[BLOCK],buf[BLOCK];
	int l,k;

	p= getInstrPtr(mb, pc);
	if( p != NULL){
		target[0]=0;
		fillTarget(mb,p,target);
		if( moduleId(p) && functionId(p)){
			snprintf(buf,BLOCK,"%s%s.%s(", target,
				moduleName(p),functionName(p));
			for(k= p->retc; k<p->argc; k++){
				str msg=0;
				ValPtr v= &stk->stk[getArg(p,k)];

                ATOMformat(v->vtype, VALptr(v), &msg);
                l= strlen(buf);
                snprintf(buf+l,BLOCK-l,"%s",msg);
                GDKfree(msg);
                if( k < p->argc-1 ) {
                    l= strlen(buf);
                    snprintf(buf+l,BLOCK-l,",");
                }
            }
            l= strlen(buf);
            snprintf(buf+l,BLOCK-l,");");
        } else{
			strcpy(buf,instruction2str(mb,p,FALSE));
			strcpy(buf,target);
		}
	}
	if( extra){
		p= getInstrPtr(mb,0);
		l= strlen(buf);
		snprintf(buf+l,BLOCK-l," at #%d in %s", pc, functionName(p));
	}
    return GDKstrdup(buf);
}
void printCall(Client cntxt, MalBlkPtr mb, MalStkPtr stk, int pc){
    str msg;

    msg= call2str(mb,stk,pc,TRUE);
    stream_printf(cntxt->fdout,"%s\n",msg);
    GDKfree(msg);
}
void printTraceCall(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p){
    int k;
    str msg;
    str s;

    msg= instruction2str(mb,p,FALSE);
    s= strchr(msg,'(');
	if( p->retc > 1 && s){
		s= strchr(s+1,'(');
	}
    if(s){
        s++;
        *s = 0;
        stream_printf(cntxt->fdout,"%s",msg);
        for(k= p->retc; k<p->argc; k++){
			VarPtr v= getVar(mb, getArg(p,k));
            ValPtr val= &stk->stk[getArg(p,k)];
			if( v->tmpindex == 0)
				stream_printf(cntxt->fdout,"%s=",v->name);
			else
				stream_printf(cntxt->fdout,"%c%d=",TMPMARKER,v->tmpindex);
            ATOMprint(val->vtype,VALptr(val),cntxt->fdout);
            if( k < p->argc-1 ) stream_printf(cntxt->fdout,", ");
            }
        stream_printf(cntxt->fdout,")\n");
    } else stream_printf(cntxt->fdout,"%s\n",msg);
    GDKfree(msg);
}

@+ MAL parser
The debugger structure is inherited from GDB.
The routine mdbCommand is called with p=0 after finishing a mal- function call
and before continuing at the next level of invocation.
The commands are self-explanatory.

The prompt string sent to the user indicates the debugger mode.
@c
#define MDBstatus(X) if(cntxt->fdout) \
	stream_printf(cntxt->fdout,"#Monet Debugger %s\n", (X?"on":"off"));

void mdbCommand(Client cntxt,MalBlkPtr mb, MalStkPtr stk, InstrPtr p, int pc)
{
    int m = 1;
    char *b,*c;
	bstream *oldin;
    stream *out = cntxt->fdout;
    int listing = cntxt->listing;
	char *oldprompt = cntxt->prompt;
	int oldpromptlength = cntxt->promptlength;

    if( p != NULL){
        stream_printf(out,"#mdb ");
        printInstruction(out,mb,p,listing);
    }
	if (cntxt==mal_clients){
		cntxt -> prompt = "mdb>";
		cntxt -> promptlength = 4;
	}
	oldin= cntxt->fdin;
	cntxt->fdin= getConsole(cntxt);
    cntxt->fdin->pos += cntxt->yycur;
	cntxt->yycur = 0;
	cntxt->fdin->buf[cntxt->fdin->pos] = 0;
    do {
		if (cntxt->phase[READER]) {
 			if(  (*cntxt->phase[READER])(cntxt) ) {
        		    break;
			}
		} else if ( readClient(cntxt) <= 0) {
        	break;
		}
    	b = CURRENT(cntxt);

        /* terminate the line with zero */
        c = strchr(b,'\n');
        if (c) {
			*c = 0;
    		cntxt->fdin->pos += (c-b)+1;
		} else {
    		cntxt->fdin->pos = cntxt->fdin->len;
		}

    	skipBlanc(cntxt,b);
    	switch(*b){
    	case 0:
			m = 0;
			break;
    	case 'a':
			if( strncmp("atoms",b,5)==0)
				showAtoms(out);
        	break;
    	case 'c':
			if( strncmp("call",b,4)==0) {
            	GDKerror("call instruction not yet implemented\n");
            	break;
         	}
         	stk->cmd= 'c';
        	skipWord(cntxt,b);
			m = 0;
			break;
    	case 'h':
			mdbHelp(out);
			break;
    	case 'q':
        	stk->cmd= 'q';/* return from this debugger */
        	cntxt->itrace= 0;
        	cntxt->timer= 0;
        	MDBstatus(0);
			cntxt->fdin= oldin;
			cntxt->prompt = oldprompt;
			cntxt->promptlength = oldpromptlength;
			return;
    	case 'f': /* finish */
    	case 'n': /* next */
    	case 's': /* step */
        	if( strncmp("scenarios",b,3)==0){
            	showAllScenarios(out);
        	} else if( strncmp("scenario",b,3)==0){
            	showScenarioByName(out, cntxt->scenario);
        	} else if( strncmp("scope",b,3)==0){
            	showModuleStatistics(out,cntxt->nspace);
            	break;
        	}
        	stk->cmd= *b;
			m = 0;
			break;
    	case 'm': /* display a module */
        	{
        		str modname, fcnname;
        		Module fsym;
        		Symbol fs;
        		int i;

        		if( strncmp("modules",b,7)==0){
            		showModules(out, cntxt->nspace);
            		continue;
        		}

        		skipWord(cntxt,b);
        		if(*b){
            		modname=b;
					fcnname= strchr(b,'.');
					if( fcnname ){
						*fcnname= 0;
						fcnname++;
					}
					fsym= findModule(cntxt->nspace, putName(modname,strlen(modname)));

					if( fsym == NULL){
						stream_printf(out,"%s module not found\n",modname);
						continue;
					}
					for(i=0;i<MAXSCOPE;i++){
						fs= fsym->subscope[i];
						while(fs != NULL){
							if( fcnname == NULL)
								printSignature(out,fs,listing);
							else if( strcmp(fcnname,getFcnName(fs->def))==0)
								printSignature(out,fs,listing);
							fs= fs->peer;
						}
					}
					continue;
        		}
        		debugModule(out,cntxt->nspace,b);
        	}
        	break;
    	case 't': /* trace breakpoint */
        	if( strncmp("type",b,4)==0){
            	skipWord(cntxt,b); skipBlanc(cntxt,b);
            	if(strchr(b,'\n'))
                        *strchr(b,'\n')= 0;
           		traceFcnName= GDKstrdup(b);
        	} else if( strncmp("timer",b,5)==0){
            	if( cntxt->timer==0)
                	cntxt->timer = GDKusec();
            	else
                        cntxt->timer = 0;
        	}
        	break;
    	case 'v': {	/* show the symbol table and bindings */
				str modname, fcnname;
        		Module fsym;
        		Symbol fs;
        		int i;
				skipWord(cntxt,b);
				if( *b!= 0){
					modname=b;
					fcnname= strchr(b,'.');
					if( fcnname == NULL){
						fsym= findModule(cntxt->nspace, putName(modname,strlen(modname)));
						if( fsym==0) {
							stream_printf(out,"%s module not found\n", modname);
							continue;
						}
						for(i=0;i<MAXSCOPE;i++){
							fs= fsym->subscope[i];
							while(fs != NULL){
								printStack(out,fs->def,0);
								fs= fs->peer;
							}
						}
						continue;
					}
            		*fcnname = 0;
            		fcnname ++;
            		fsym= findModule(cntxt->nspace, putName(modname,strlen(modname)));
            		if( fsym==0) {
               		 	stream_printf(out,"%s module not found\n",modname);
						continue;
            		}
            		/* display the overloaded symbol definition */
					for(i=0;i<MAXSCOPE;i++){
						fs= fsym->subscope[i];
						while(fs != NULL){
							if( strcmp(fs->name,fcnname)==0)
								printStack(out,fs->def,0);
							fs= fs->peer;
						}
					}
        		} else
        			printStack(out,mb,stk);
        		break;
			}
    	case 'b':
			if( strcmp(b,"bbp") == 0 ){
			int i;
				for(i=1; i < BBPsize; i++)
				if (BBP_cache(i) && BBP_logical(i)) {
					stream_printf(out,"[%d] %s lref = %d ref= %d ", i,
						BBP_logical(i), BBP_lrefs(i), BBP_refs(i));
					stream_printf(out," dirty=%d \n", BATdirty(BBP_cache(i)) );
				}
				continue;
			}
			if( strcmp(b,"breakpoints") == 0 ){
				mdbShowBreakpoints(cntxt);
				continue;
			}
			if( strncmp(b,"break",5) == 0 ) b+=4;
			if( isspace((int)b[1]) ){
				skipWord(cntxt,b);
				if( *b && !isspace((int)*b) )
					/* set breakpoints by name */
					mdbSetBreakpointName(cntxt,mb,b,'s');
				 else
					mdbSetBreakpoint(cntxt,mb,p,getArgName(mb,p,0),'s');
				continue;
			}
        	continue;
    	case 'd':
        	if( strncmp(b,"down",2)==0 && stk->down!= NULL){
            	stream_printf(out,"%sgo down the stack\n","#mdb ");
            	stk= stk->down;
            	mb = stk->blk;
            	break;
        	}
        	skipWord(cntxt,b);
        	/* get rid of break point */
        	if(*b && !isspace((int)*b)){
            	mdbClrBreakpointName(cntxt,b);
        	} else {
            	mdbClrBreakpoint(cntxt,p);
        	}
        	continue;
    	case 'i':
    	{
			int i;
        	char *t;

        	skipWord(cntxt,b);
        	t=b;
        	skipNonBlanc(cntxt,t);
        	*t = 0;
        	/* search the symbol */
        	i = findVariable(mb,b);
        	if( i<0){
            	stream_printf(out,"%s Symbol not found\n","#mdb ");
        	} else{
            	printBatInfo(out,getVar(mb,i),stk->stk+i);
        	}
        	continue;
    	}
    	case 'p':
    	{
			int i, size=0,first=0;
        	char *t;

        	skipWord(cntxt,b);
        	t=b;
        	skipNonBlanc(cntxt,t);
        	*t = 0;
        	/* you can identify a start and length */
        	t++;
			skipBlanc(cntxt,t);
        	if(isdigit((int)*t)){
            	size= atol(t);
            	skipWord(cntxt,t);
            	if( isdigit((int)*t))
					first= atol(t);
        	}
        	/* search the symbol */
        	i = findVariable(mb,b);
        	if( i<0){
            	stream_printf(out,"%s Symbol not found\n","#mdb ");
            	continue;
        	}
        	printStackElm(out, mb, getVar(mb,i),stk->stk+i,i,size,first);
        	continue;
    	}
		case 'S':
			dumpNamespaceStatistics(out,1);
			break;
    	case 'u':
        	if( stk->up == NULL)
				break;
        	stream_printf(out,"%s go up the stack\n","#mdb ");
        	stk= stk->up;
        	mb = stk->blk;
        	printCall(cntxt,mb,stk,pc);
        	continue;
    	case 'w':
    	{
			MalStkPtr w;
        	MalBlkPtr mw=mb;
			int pci=pc; /*  how to find enclosing pc */
        	for(w=stk;w!= NULL; w=w->up){
            	mw = w->blk;
            	stream_printf(out,"#mdb ");
            	printCall(cntxt,mw,w,pci);
				if( w->up)
					pci=w->up->pcup;
        	}
        	continue;
    	}
@-
While debugging it should be possible to inspect the symbol
table using the 'module.function' name. The default is to list all
signatures satisfying the pattern.
@c
    	case 'L':
    	case 'l': /* list the current code block */
    	{
			str modname, fcnname;
        	Module fsym;
        	Symbol fs;
        	int i, lstng;

        	lstng = /* listing |*/ (*b == 'L' ? LIST_MAL_ALL : LIST_MAL_INSTR);
        	skipWord(cntxt,b);
        	if( *b!= 0){
            	modname=b;
            	fcnname= strchr(b,'.');
            	if( fcnname == NULL){
                	fsym= findModule(cntxt->nspace,putName(modname,strlen(modname)));
                	if( fsym==0) {
                    	stream_printf(out,"%s module not found\n", modname);
                    	continue;
                	}
                	for(i=0;i<MAXSCOPE;i++){
                    	fs= fsym->subscope[i];
                    	while(fs != NULL){
                        	printFunction(out,fs->def,lstng);
                        	fs= fs->peer;
                    	}
                	}
                	continue;
            	}
            	*fcnname = 0;
            	fcnname ++;
            	fsym= findModule(cntxt->nspace,putName(modname,strlen(modname)));
            	if( fsym==0) {
                	stream_printf(out,"%s module not found\n",modname);
                	continue;
            	}
            	/* display the overloaded symbol definition */
            	if( displayModule(out,fsym,fcnname,lstng)==0){
                	stream_printf(out,"%sSymbol '%s.%s' not found\n",
                    	"#mdb ",modname,fcnname);
            	}
        	} else {
				printFunction(out,mb,lstng);
			}
        	continue;
    	}
		case 'o': case 'O': /* optimizer steps */
		{ 	int flg= *b == 'o'? LIST_MAL_INSTR:LIST_MAL_ALL;
			int idx;
			skipWord(cntxt,b);
			if( *b ){
				idx= atoi(b);
				showOptimizerStep(idx,flg);
			} else showOptimizerHistory();
			break;
		}
    	case 'r': /* reset program counter */
        	stream_printf(out,"%srestart with current stack\n","#mdb ");
        	stk->cmd= 'r';
        	break;
    	default:
        	stream_printf(out,"%s debugger command expected\n","#mdb ");
        	mdbHelp(out);
    	}
    } while(m);
	cntxt->fdin= oldin;
	cntxt->prompt = oldprompt;
	cntxt->promptlength = oldpromptlength;
}
void mdbStep(Client cntxt, MalBlkPtr mb, MalStkPtr stk, int pc ){
    InstrPtr p;

    switch(stk->cmd){
    case 'c':
		p= getInstrPtr(mb,pc);
        if( isBreakpoint(cntxt,p) ){
            mdbCommand(cntxt,mb,stk,p,pc);
        }
        break;
    case 's': case 'n':
		p= getInstrPtr(mb,pc);
        mdbCommand(cntxt,mb,stk,p,pc);
        break;
    case 'r': stk->cmd = 'n';
	case 'T': ;
    }
    if( cntxt->timer) cntxt->timer = GDKusec();
    stream_flush(cntxt->fdout);
}
@+ Utilities
Dumping a stack on a file is primarilly used for debugging.
Printing the stack requires access to both the symbol table and
the stackframes in most cases.
Beware that a stack frame need not be initialized with null values.
It has been zeroed upon creation.

The routine  can also be used to inspect the symbol table of
arbitrary functions.
@c
void printStack(stream *f, MalBlkPtr mb, MalStkPtr s){
        int i = 0;

    stream_printf(f,"#mdb  %s\n", getInstrPtr(mb,0)->fcnname);
	if( s) {
		stream_printf(f,"Stack size=%d top=%d\n",s->stksize,s->stktop);
        for( ; i<mb->vtop ; i++)
			printStackElm(f, mb, getVar(mb,i), s->stk+i,i,0,0);
	} else
        for( ; i<mb->vtop ; i++)
			printStackElm(f, mb, getVar(mb,i), 0,i,0,0);
}

void printStackElm(stream *f, MalBlkPtr mb, VarPtr n, ValPtr v, int index, int cnt,int first){
    str nme,nmeOnStk;
    char nmebuf[PATHLENGTH];
    (void) mb; /* fool the compiler */
    if( n->tmpindex){
        snprintf(nmebuf,PATHLENGTH,"%c%d",TMPMARKER, n->tmpindex);
        nme= nmebuf;
    } else nme = n->name;
    stream_printf(f,"[%d] %s\t= ",index,nme);
    if( n->type == TYPE_void)
        stream_printf(f,"nil");
    else if(v)
    	ATOMprint(v->vtype,VALptr(v),f);
	else if( n->literal)
		stream_printf(f,"%s", n->literal);

    nme= getTypeName(n->type);
    stream_printf(f,":%s", nme);
    nmeOnStk= v? getTypeName(v->vtype):GDKstrdup(nme);
    if( strcmp(nmeOnStk,nme) ){
		if( isaBatType(n->type)){
			BAT *b;
			b= BATdescriptor(v->val.ival);
			if( b){
				nmeOnStk= getTypeName(newBatType(b->htype,b->ttype));
				if( strcmp(nme,nmeOnStk))
					stream_printf(f," != :%s", nmeOnStk);
				BBPunfix(b->batCacheid);
			}
		} else
        if( !(isaBatType(n->type) && strcmp(nmeOnStk,"BAT")==0))
			stream_printf(f," != %s", nmeOnStk);
    }
    stream_printf(f," %s", (n->isaconstant?" constant":""));
    stream_printf(f," %s", (n->isatypevar?" type variable":""));
    GDKfree(nme); GDKfree(nmeOnStk);

    if(cnt && isaBatType(n->type) && v && v->val.ival){
        BAT *b,*bs;
        b= BATdescriptor(v->val.ival);
        if( b== NULL){
            stream_printf(f,"Could not access descriptor\n");
            return;
        }
        stream_printf(f,"\n");
        if(cnt < BATcount(b)) {
            stream_printf(f,"Sample %d out of %d\n",cnt, BATcount(b));
        }
        /* cut out a portion of the BAT for display */
        bs= BATslice(b,first,first+cnt);
        if(bs== NULL)
            stream_printf(f,"Failed to take chunk\n");
        else BATmultiprintf(f,2,&bs,TRUE,0,TRUE);
        BBPunfix(b->batCacheid);
    } else
    if( isaBatType(n->type) && v){
        BAT *b;
        b= BATdescriptor(v->val.ival);
        if(b){
            /* ignore ref count of this call */
            stream_printf(f," count=%d lrefs=%d refs=%d",
                BATcount(b),BBP_lrefs(ABS(b->batCacheid)),
                BBP_refs(ABS(b->batCacheid))-1);
            BBPunfix(b->batCacheid);
        }
    } else
    if(cnt && isaColType(n->type) && v && v->val.ival){
		stream_printf(f,"Operation not yet implemented for :col types\n");
	}
    stream_printf(f,"\n");
}
void printBatInfo(stream *f, VarPtr n, ValPtr v){
    if(isaBatType(n->type) && v->val.ival){
        int bid;
        int ret;
        MALfcn fcn;

        fcn = getAddress("BKCinfo",0);
        if(fcn){
            BAT *b;
            bid = v->val.ival;
            stream_printf(f,"Show info for %d\n",bid);
            (*fcn)(&ret,&bid);
            stream_printf(f,"got the info bat from %d\n",bid);
            b= BATdescriptor(ret);
            if( b== NULL){
                stream_printf(f,"Could not access descriptor\n");
                return;
            }
            BATmultiprintf(f,2,&b,TRUE,0,TRUE);
            BBPunfix(b->batCacheid);
        }
    }
}
@-
The memory positions for the BATs is useful information to
asses for memory fragmentation.
@= heapinfo
hp= b->@1;
if(hp && hp->base){
    stream_printf(GDKout,"\t@1=%d size=%d\n",hp->base, hp->size);}
@= hashinfo
h= b->@1;
if(h && h->mask){
        stream_printf(GDKout,"\t@1=%d size=%d\n",h, sizeof(*h));
        stream_printf(GDKout,"\t@1link=%d size=%d\n",h->link,
                (h->mask+h->lim+1)*sizeof(int));
}
@-
The memProfileVector routine produces a character string to represent
the usage of memory by BAT information. The characters are interpreted
as follows:
.=unused, X=completely used, [0-9]=small elements within the granule
More then 9 elements makes it full.
@= setVector
    start= (((long)@1)-min)/granule;
    lim= (((long)@1)-min + @2)/granule;
    stream_printf(GDKout,"start %d lim %d\n",start,lim);

@c
str memProfileVector(int cells){
    str v= GDKmalloc(cells+1);
    int i;
    long max= (long) sbrk(0);
    long min= 0;
    long granule= 0;
    if( cells<=0) {
        GDKerror("memProfileVector:positive argument expected\n");
        return GDKstrdup("");
    }
    v= GDKmalloc(cells+1);
    if( v== 0)
        GDKfatal("memProfileVector:malloc failure\n");

    for(i=0; i<cells;i++) v[i]='.';
    v[i]=0;

    for(i=1; i<BBPsize; i++)
    if( BBP_status(i) & BBPLOADED ){
        BAT *b = BATdescriptor(i);
        Heap *hp;
        Hash *h;
        long start,lim;

        stream_printf(GDKout,"\tdesc=%d size=%d\n",b, sizeof(*b));
        hp= b->batBuns;
        stream_printf(GDKout,"\tbuns=%d size=%d\n",hp->base, hp->size);
        if( min==0){
            min= (long)b;
            max= min + GDKmem_heapsize();
            granule= (max-min)/cells;
            stream_printf(GDKout,"granule %dK\n",granule/1024);
        }
        @:setVector(b,sizeof(*b))@
        @:setVector(hp->base,hp->size)@

        @:heapinfo(hheap)@
        @:heapinfo(theap)@
        @:hashinfo(hhash)@
        @:hashinfo(thash)@
        BBPunfix(b->batCacheid);
    }
    return v;
}
void printBBPinfo(stream *out){
    str v;

    stream_printf(out,"#BBP memory layout\n");
    stream_printf(out,"#heap maximum =%d/M\n",GDKmem_heapsize()/(1024*1024));
    v= memProfileVector(32);
    stream_printf(out,"#%s\n",v);
    GDKfree(v);
#ifdef GDK_VM_KEEPHISTO
    stream_printf(out,"#BBP VM history available\n");
#else
    stream_printf(out,"#BBP VM history not available\n");
#endif
}
@-
Some utilities for the debugger
@c
void mdbHelp(stream *f){
    stream_printf(f,"next       -- Advance to next statement\n");
    stream_printf(f,"continue   -- Continue program being debugged\n");
    stream_printf(f,"break      -- set breakpoint on current instruction\n");
    stream_printf(f,"break <var>    -- break on assignment to <var>\n");
    stream_printf(f,"delete <var>   -- remove break point <var>\n");
    stream_printf(f,"step       -- advance to next MAL instruction\n");
    stream_printf(f,"module     -- display the module signatures\n");
    stream_printf(f,"finish     -- finish current call\n");
    stream_printf(f,"quit       -- leave debugger\n");
    stream_printf(f,"list <fcn> -- list current program block\n");
    stream_printf(f,"List <fcn> -- list with type information\n");
    stream_printf(f,"var  <fcn>  -- print symbol table for module\n");
    stream_printf(f,"optimizer <idx>  -- display program after optimizer step\n");
    stream_printf(f,"print <var>    -- display value of a variable\n");
    stream_printf(f,"print <var> <cnt>[<first>] -- display BAT chunk\n");
    stream_printf(f,"info <var>     -- display bat variable properties\n");
    stream_printf(f,"run        -- restart current procedure\n");
    stream_printf(f,"where      -- print stack trace\n");
    stream_printf(f,"down       -- go down the stack\n");
    stream_printf(f,"up         -- go up the stack\n");
    stream_printf(f,"timer      -- produce micro-second response time\n");
    stream_printf(f,"help       -- this message\n");
}
@+ Optimizer debugging
The modular approach to optimize a MAL program brings with it the
need to check individual steps. Two options come to mind. If in
debug mode we could stop after each optimizer action for inspection.
Alternatively, we keep a history of all MAL program versions for
aposteriori analysis.

The latter is implemented first.
@{
A global stack is used for simplity, later we may have to
make it thread safe by assigning it to a client record.
@c
int isInvariant(MalBlkPtr mb, int pcf, int pcl, int varid);

str debugOptimizers(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	Client cntxt= getClient();
	(void) stk;

    cntxt->debugOptimizer= cntxt->debugOptimizer? FALSE: TRUE;
	if(pci)
		removeInstruction(mb,pci);
	return MAL_SUCCEED;
}

#define MAXSTEPS 128
struct{
	str title;
	int actions;
	long usec;
	MalBlkPtr mb;
} optimizerHistory[MAXSTEPS];
static int optTop;

void optimizerDebug(MalBlkPtr mb, str name, int actions,long usec){
	Client c= getClient();
	if( !c->itrace ) return;
	if( optTop+1 == MAXSTEPS) return;
	optimizerHistory[optTop].title= GDKstrdup(name);
	optimizerHistory[optTop].actions= actions;
	optimizerHistory[optTop].usec= usec;
	optimizerHistory[optTop].mb = copyMalBlk(mb);
	optTop++;
}
void resetOptimizerDebugger(){
	int i;
	if( optTop){
		/* garbage collect */
		for(i=0;i<optTop; i++){
			freeMalBlk(optimizerHistory[i].mb);
			GDKfree(optimizerHistory[i].title);
		}
	}
	optTop=0;
}
void showOptimizerStep(int i,int flg){
	if( i<optTop) {
		stream_printf(GDKout,"%s\n",optimizerHistory[i].title);
		printFunction(GDKout,optimizerHistory[i].mb,flg);
	}
}
void showOptimizerHistory(){
	int i;
	stream *fd= GDKout;
	for(i=0;i<optTop;i++)
		stream_printf(fd,"[%d] %s \tactions=%2d time %d usec\n",i,
			optimizerHistory[i].title,
			optimizerHistory[i].actions,
			optimizerHistory[i].usec);
}
@}
