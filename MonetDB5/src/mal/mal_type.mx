@t Mal type utilities
@a M. Kersten
@v 0.0
@* Introduction
The MAL type module overloads the atom structure managed in the GDK
library. In particular, it encodes bat type information in a single
long to safe space. Actually, it makes sense to include the built-in
type BAT in GDK.

For the time being we assume GDK to support at most 255 different
atomic types. If this grows, then the encoding scheme presented
below permits 2^15 different bat types at most
Beware the TYPE_any is a speudo type known within MAL only.
@h
/*
 * The contents of this file are subject to the Monet Public
 * License Version 1.1 (the "License"); you may not use this file
 * except in compliance with the License. You may obtain a copy of
 * the License at http://www.monetsolutions.com/Download/Licensing/MonetPL-1.1.
html
 * 
 * Software distributed under the License is distributed on an "AS
 * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
 * implied. See the License for the specific language governing
 * rights and limitations under the License.
 * 
 * The Original Code is the Monet Database System.
 * 
 * The Initial Developer of the Original Code is CWI.
 * Portions created by CWI are Copyright (C) 1997-2001 CWI.  
 * All Rights Reserved.
 * 
 * Contributor(s): Martin Kersten <Martin.Kersten@cwi.nl>
 */
#ifndef MAL_TYPE_H
#define MAL_TYPE_H
#include "mal.h"

/*#define DEBUG_MAL_TYPE */
/* #define GDKerror printf*/

typedef int malType;

#define malVARG " malVARG"
#define TMPMARKER '$'

#define newBatType(H,T)  (1<<16 | (((H & 0377) <<8) | (T & 0377) ))
#define newVecType(T)  (1<<16 | (((TYPE_void & 0377) <<8) | (T & 0377) ))
#define getHeadType(X)	((X>>8) & 0377 )
#define getTailType(X)	((X) & 0377 )
#define isaBatType(X) 	((X)!=TYPE_any && (1<<16) & (X))
#define isaVecType(X) 	((X)!=TYPE_any && (1<<16) & (X))
@-
Procedure type parameters may be qualified by a formal type term any::I ,
where I is a small integer. 
The malType long contains the following fields:
anyHeadIndex (bit 25-22), anyTailIndex (bit 21-18),
batType (bit 17) headType (16-9) and tailType(8-0)

@h
#define setAnyHeadIndex(X,I) X |= ((I & 017)<<22);
#define setAnyTailIndex(X,I) X |= ((I & 017)<<18);
#define isAnyExpression(X) ((X) >> 17)

#define getHeadIndex(X)  (((X)>>22) & 017)
#define getTailIndex(X)  (((X)>>18) & 017)
@-
The symbol/instruction kinds are introduced here instead of reusing the defines 
derived from the parser to avoid a loop in the define-structure.
@h
#define ASSIGNsymbol 	21
#define RAISEsymbol 	23
#define CATCHsymbol 	24
#define RETURNsymbol 	25
#define BARRIERsymbol	26
#define REDOsymbol	27
#define LEAVEsymbol	28
#define SPACEsymbol	29
#define IMPORTsymbol	30	/* dependency on outer scopes */
#define COMMANDsymbol   31
#define FUNCTIONsymbol	32
#define STREAMsymbol	37
#define ENDDEFsymbol	34
#define THRDsymbol	43
#define COMMENTsymbol	35	/* propagation of comments */
#define ENDsymbol 	36
#define SCOPEsymbol	41
#define PUSHsymbol	42	/* move constant to stack */
#define PATTERNsymbol   44
#define THREADsymbol     46
#define EXITsymbol	47

#define FCNcall		50	/* determines interpreter action*/
#define STRMcall	51
#define CMDcall		52
#define THRDcall	53
#define PATcall		54	/* pattern call */

mal_export str	malTypeName(malType tpe);
mal_export malType coercion(malType t1, malType t2);
mal_export int	getTypeIndex(str nme);
mal_export malType reverseBatType(malType v);
mal_export malType malAnyBatType(malType t1, malType t2);
mal_export int	idcmp(str n, str m);
mal_export str	newTmpName(int i);
mal_export int	isTmpName(str n);
mal_export int	isIdentifier(str s);
#endif /* MAL_TYPE_H*/
@-
At any point we should be able to construct an ascii representation of
the type descriptor. Including the variable references.
@c
#include "mal_type.h"

str malTypeName(malType tpe)
{
#ifdef DEBUG_MAL_TYPE
	stream_printf((GDKout,"maltype: %d %d %d",tpe,getHeadType(tpe),getTailType(tpe));
	stream_printf((GDKout,"	: %d\n",isaBatType(tpe));
#endif
	if( tpe == TYPE_any ) return GDKstrdup("any");
	if( isaBatType(tpe)){
		char buf[1024],*s;
		int l=1024;
		if( getHeadIndex(tpe) ){
			snprintf(buf,l,"bat[any::%d,", getHeadIndex(tpe));
		} else
		if( getHeadType(tpe) == TYPE_any) 
			snprintf(buf,l,"bat[any,","");
		else
			snprintf(buf,l,"bat[%s,", ATOMname(getHeadType(tpe)));
		l -= strlen(buf);
		s= buf+strlen(buf);
		if( getTailIndex(tpe) ){
			snprintf(s,l,"any::%d]", getTailIndex(tpe));
		} else
		if( getTailType(tpe) == TYPE_any) 
			snprintf(s,l,"any]","");
		else
			snprintf(s,l,"%s]", ATOMname(getTailType(tpe)));
#ifdef DEBUG_MAL_TYPE
		stream_printf((GDKout,"%s\n",buf);
#endif
		return GDKstrdup(buf);
	} 
	if( isAnyExpression(tpe) ){
		char buf[PATHLENGTH];
		strncpy(buf,"any",PATHLENGTH);
		if( isAnyExpression(tpe)){
			snprintf(buf+3,PATHLENGTH-3,"::%d",getTailIndex(tpe));
		}
		return GDKstrdup(buf);
	}
#ifdef DEBUG_MAL_TYPE
		stream_printf((GDKout,"Rely on GDK atom %s\n",ATOMname(tpe));
#endif
	return GDKstrdup(ATOMname(tpe));
}

malType malAnyBatType(malType t1, malType t2){
	int t; 
	t= newBatType(getTailType(t1),getTailType(t2));

	if( getTailIndex(t1)){ 
		setAnyHeadIndex(t, getTailIndex(t1));
	} 
	if( getTailIndex(t2)){ 
		setAnyTailIndex(t, getTailIndex(t2));
	} 
	return t;
}

malType reverseBatType(malType v){
	str d1= malTypeName(newBatType(getHeadType(v),getTailType(v))),
	d2=	malTypeName(newBatType(getTailType(v),getHeadType(v)));
	stream_printf(GDKout,"reverseBatType %d %s %s",v,d1,d2);
	GDKfree(d1); GDKfree(d2);
	return newBatType(getTailType(v),getHeadType(v));
}
@+ Type coercion
The coercion scheme below should at some point be added to the GDK kernel.
@c
int  gdkCoercionTable[12][12] ={
/* 		void bit chr sht bat int 
		oid ptr flt dbl lng str */
/* void */
		{TYPE_void, TYPE_any,TYPE_any,TYPE_any,TYPE_any,TYPE_any,
		TYPE_any, TYPE_any,TYPE_any,TYPE_any,TYPE_any,TYPE_str},
/* bit */
		{TYPE_any, TYPE_bit,TYPE_any,TYPE_any,TYPE_any,TYPE_any,
		TYPE_any, TYPE_any,TYPE_any,TYPE_any,TYPE_any,TYPE_str},
/* chr */
		{TYPE_any, TYPE_any,TYPE_chr,TYPE_any,TYPE_any,TYPE_any,
		TYPE_any, TYPE_any,TYPE_any,TYPE_any,TYPE_any,TYPE_str},
/* sht */
		{TYPE_any, TYPE_any,TYPE_any,TYPE_sht,TYPE_any,TYPE_int,
		TYPE_any, TYPE_any,TYPE_flt,TYPE_dbl,TYPE_lng,TYPE_str},
/* bat */
		{TYPE_any, TYPE_any,TYPE_any,TYPE_any,TYPE_bat,TYPE_any,
		TYPE_any, TYPE_any,TYPE_any,TYPE_any,TYPE_any,TYPE_str},
/* int */
		{TYPE_any, TYPE_any,TYPE_any,TYPE_int,TYPE_any,TYPE_int,
		TYPE_any, TYPE_any,TYPE_flt,TYPE_dbl,TYPE_lng,TYPE_str},
/* oid */
		{TYPE_any, TYPE_any,TYPE_any,TYPE_int,TYPE_any,TYPE_int,
		TYPE_oid, TYPE_any,TYPE_any,TYPE_int,TYPE_any,TYPE_str},
/* ptr */
		{TYPE_any, TYPE_any,TYPE_any,TYPE_any,TYPE_any,TYPE_any,
		TYPE_any, TYPE_ptr,TYPE_any,TYPE_any,TYPE_any,TYPE_str},
/* flt */
		{TYPE_any, TYPE_any,TYPE_any,TYPE_any,TYPE_any,TYPE_any,
		TYPE_any, TYPE_any,TYPE_flt,TYPE_dbl,TYPE_any,TYPE_str},
/* dbl */
		{TYPE_any, TYPE_any,TYPE_any,TYPE_any,TYPE_any,TYPE_any,
		TYPE_any, TYPE_any,TYPE_dbl,TYPE_dbl,TYPE_any,TYPE_str},
/* lng */
		{TYPE_any, TYPE_any,TYPE_any,TYPE_lng,TYPE_any,TYPE_lng,
		TYPE_any, TYPE_any,TYPE_flt,TYPE_dbl,TYPE_lng,TYPE_str},
/* str */
		{TYPE_str, TYPE_str,TYPE_str,TYPE_str,TYPE_str,TYPE_str,
		TYPE_str, TYPE_str,TYPE_str,TYPE_str,TYPE_str,TYPE_str}
};
@-
Coercion is defined in terms of malType structures, which means
that we have to be prepared to deal with type variables as well.
@c

malType coercion(malType t1, malType t2){
	if( t1==t2) return t1;
	if( t1 <0 || t1>=TYPE_str) return t1;
	if( t2 <0 || t2>=TYPE_str) return t2;
	return gdkCoercionTable[(int)t1][(int)t2];
}
@+ Some utilities 
In many places we need a confirmed type identifier.
GDK returns the next available index when it can not find the type.
This is not sufficient here, an error message may have to be generated.
It is assumed that the type table does not change in the mean time.
Use the information that identifiers are at least one character
and are terminated by a null to speedup comparison
@c
INLINE
int idcmp(str n, str m)
{
	if( *(short *) n == *(short *) m) return strcmp(n,m);
	return -1;
}
int getTypeIndex(str nme){
	int i;
	i= ATOMindex(nme);
	/*stream_printf((GDKout,"getTypeIndex %s %d %d\n",nme,i, GDKatomcnt);*/
	if( idcmp("any",nme)==0 ) return TYPE_any;
	if( idcmp("bat",nme)==0 ){
/* stream_printf((GDKout,"found a bat[any,any]\n");*/
		i = newBatType(TYPE_any,TYPE_any);
/* stream_printf((GDKout,"isAnyexpression? %d\n", isAnyExpression(i));*/
		return i;
	}
	if( i== -GDKatomcnt) i = TYPE_any;
	return i;
}
int getGDKtype(int type){
	if( isaBatType(type)) return TYPE_bat;
	if( type == TYPE_any) return TYPE_int;
	return ATOMtype(type);
}
str newTmpName(int i){
	char buf[PATHLENGTH],*s;
	snprintf(buf,PATHLENGTH,"%c%d",TMPMARKER,i);
	return GDKstrdup(buf);
}
int isTmpName(str n){ return n && *n == TMPMARKER;}

int isIdentifier(str s)
{
	if( ! isalpha(*s) ) return -1;
	for( ;s && *s; s++)
	if( ! isalnum(*s) && *s !='_') return -1;
	return 0;
}
