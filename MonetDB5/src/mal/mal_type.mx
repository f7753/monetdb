@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@' 
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@' 
@' The Original Code is the Monet Database System.
@' 
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2004 CWI.
@' All Rights Reserved.
@' 
@' Contributor(s):
@' 		Martin Kersten <Martin.Kersten@cwi.nl>
@' 		Peter Boncz <Peter.Boncz@cwi.nl>
@' 		Niels Nes <Niels.Nes@cwi.nl>
@' 		Stefan Manegold  <Stefan.Manegold@cwi.nl>
@'              Sjoerd Mullender  <Sjoerd.Mullender@cwi.nl>

@a M. Kersten
@v 0.0
@* Mal type utilities
The MAL type module overloads the atom structure managed in the GDK
library. In particular, it encodes bat type information in a single
long to safe space. Actually, it makes sense to include the built-in
type BAT in GDK.

For the time being we assume GDK to support at most 255 different
atomic types. If this grows, then the encoding scheme presented
below permits 2^15 different bat types at most
Beware the TYPE_any is a speudo type known within MAL only.
@{
@h
#ifndef MAL_TYPE_H
#define MAL_TYPE_H
#include "mal.h"

/*#define DEBUG_MAL_TYPE */
/* #define GDKerror printf*/

typedef int malType;

#define malVARG " malVARG"
#define TMPMARKER '$'

#define newBatType(H,T)  (1<<16 | (((H & 0377) <<8) | (T & 0377) ))
#define newVecType(T)  (1<<16 | (((TYPE_void & 0377) <<8) | (T & 0377) ))
#define getHeadType(X)	((X>>8) & 0377 )
#define getTailType(X)	((X) & 0377 )
#define isaBatType(X) 	((X)!=TYPE_any && (1<<16) & (X))
#define isaVecType(X) 	((X)!=TYPE_any && (1<<16) & (X))
@-
Procedure type parameters may be qualified by a formal type term any::I ,
where I is a small integer. 
The malType long contains the following fields:
anyHeadIndex (bit 25-22), anyTailIndex (bit 21-18),
batType (bit 17) headType (16-9) and tailType(8-0)

@h
#define setAnyHeadIndex(X,I) X |= ((I & 017)<<22);
#define setAnyTailIndex(X,I) X |= ((I & 017)<<18);
#define isAnyExpression(X) ((X) >> 17)

#define getHeadIndex(X)  (((X)>>22) & 017)
#define getTailIndex(X)  (((X)>>18) & 017)
@-
The symbol/instruction kinds are introduced here instead of reusing the defines 
derived from the parser to avoid a loop in the define-structure.
@h
#define ASSIGNsymbol 	21
#define RAISEsymbol 	23
#define CATCHsymbol 	24
#define RETURNsymbol 	25
#define BARRIERsymbol	26
#define REDOsymbol	27
#define LEAVEsymbol	28
#define SPACEsymbol	29
#define IMPORTsymbol	30	/* dependency on outer scopes */

#define ENDDEFsymbol	34
#define THRDsymbol	43
#define COMMENTsymbol	35	/* propagation of comments */
#define ENDsymbol 	36
#define SCOPEsymbol	41
#define PUSHsymbol	42	/* move constant to stack */
#define THREADsymbol     46
#define EXITsymbol	47

#define FCNcall		50	/* determines interpreter action*/
#define STRMcall	51
#define CMDcall		52
#define THRDcall	53
#define PATcall		54	/* pattern call */


#define COMMANDsymbol   61	/* these tokens should be the last group !! */
#define FUNCTIONsymbol	62
#define STREAMsymbol	63
#define PATTERNsymbol   64

mal_export str	getTypeName(malType tpe);
mal_export malType coercion(malType t1, malType t2);
mal_export int	getTypeIndex(str nme);
mal_export malType reverseBatType(malType v);
mal_export malType malAnyBatType(malType t1, malType t2);
mal_export int	idcmp(str n, str m);
mal_export str	newTmpName(int i);
mal_export int	isTmpName(str n);
mal_export int	isTypeName(str n);
mal_export int	isIdentifier(str s);
mal_export int getGDKtype(int type);	/* used in src/mal/mal_interpreter.c */

#endif /* MAL_TYPE_H*/
@-
At any point we should be able to construct an ascii representation of
the type descriptor. Including the variable references.
@c
#include "mal_type.h"

str getTypeName(malType tpe)
{
#ifdef DEBUG_MAL_TYPE
	stream_printf((GDKout,"maltype: %d %d %d",tpe,getHeadType(tpe),getTailType(tpe));
	stream_printf((GDKout,"	: %d\n",isaBatType(tpe));
#endif
	if( tpe == TYPE_any ) return GDKstrdup("any");
	if( isaBatType(tpe)){
		char buf[1024],*s;
		int l=1024;
		if( getHeadIndex(tpe) ){
			snprintf(buf,l,"bat[any::%d,", getHeadIndex(tpe));
		} else
		if( getHeadType(tpe) == TYPE_any) 
			snprintf(buf,l,"bat[any,");
		else
			snprintf(buf,l,"bat[%s,", ATOMname(getHeadType(tpe)));
		l -= strlen(buf);
		s= buf+strlen(buf);
		if( getTailIndex(tpe) ){
			snprintf(s,l,"any::%d]", getTailIndex(tpe));
		} else
		if( getTailType(tpe) == TYPE_any) 
			snprintf(s,l,"any]");
		else
			snprintf(s,l,"%s]", ATOMname(getTailType(tpe)));
#ifdef DEBUG_MAL_TYPE
		stream_printf((GDKout,"%s\n",buf);
#endif
		return GDKstrdup(buf);
	} 
	if( isAnyExpression(tpe) ){
		char buf[PATHLENGTH];
		strncpy(buf,"any",PATHLENGTH);
		if( isAnyExpression(tpe)){
			snprintf(buf+3,PATHLENGTH-3,"::%d",getTailIndex(tpe));
		}
		return GDKstrdup(buf);
	}
#ifdef DEBUG_MAL_TYPE
		stream_printf((GDKout,"Rely on GDK atom %s\n",ATOMname(tpe));
#endif
	return GDKstrdup(ATOMname(tpe));
}

malType malAnyBatType(malType t1, malType t2){
	int t; 
	t= newBatType(getTailType(t1),getTailType(t2));

	if( getTailIndex(t1)){ 
		setAnyHeadIndex(t, getTailIndex(t1));
	} 
	if( getTailIndex(t2)){ 
		setAnyTailIndex(t, getTailIndex(t2));
	} 
	return t;
}

malType reverseBatType(malType v){
	str d1= getTypeName(newBatType(getHeadType(v),getTailType(v))),
	d2=	getTypeName(newBatType(getTailType(v),getHeadType(v)));
	stream_printf(GDKout,"reverseBatType %d %s %s",v,d1,d2);
	GDKfree(d1); GDKfree(d2);
	return newBatType(getTailType(v),getHeadType(v));
}
@+ Type coercion
The coercion scheme below should at some point be added to the GDK kernel.
@c
int  gdkCoercionTable[12][12] ={
/* 		void bit chr sht bat int 
		oid ptr flt dbl lng str */
/* void */
		{TYPE_void, TYPE_any,TYPE_any,TYPE_any,TYPE_any,TYPE_any,
		TYPE_any, TYPE_any,TYPE_any,TYPE_any,TYPE_any,TYPE_str},
/* bit */
		{TYPE_any, TYPE_bit,TYPE_any,TYPE_any,TYPE_any,TYPE_any,
		TYPE_any, TYPE_any,TYPE_any,TYPE_any,TYPE_any,TYPE_str},
/* chr */
		{TYPE_any, TYPE_any,TYPE_chr,TYPE_any,TYPE_any,TYPE_any,
		TYPE_any, TYPE_any,TYPE_any,TYPE_any,TYPE_any,TYPE_str},
/* sht */
		{TYPE_any, TYPE_any,TYPE_any,TYPE_sht,TYPE_any,TYPE_int,
		TYPE_any, TYPE_any,TYPE_flt,TYPE_dbl,TYPE_lng,TYPE_str},
/* bat */
		{TYPE_any, TYPE_any,TYPE_any,TYPE_any,TYPE_bat,TYPE_any,
		TYPE_any, TYPE_any,TYPE_any,TYPE_any,TYPE_any,TYPE_str},
/* int */
		{TYPE_any, TYPE_any,TYPE_any,TYPE_int,TYPE_any,TYPE_int,
		TYPE_any, TYPE_any,TYPE_flt,TYPE_dbl,TYPE_lng,TYPE_str},
/* oid */
		{TYPE_any, TYPE_any,TYPE_any,TYPE_int,TYPE_any,TYPE_int,
		TYPE_oid, TYPE_any,TYPE_any,TYPE_int,TYPE_any,TYPE_str},
/* ptr */
		{TYPE_any, TYPE_any,TYPE_any,TYPE_any,TYPE_any,TYPE_any,
		TYPE_any, TYPE_ptr,TYPE_any,TYPE_any,TYPE_any,TYPE_str},
/* flt */
		{TYPE_any, TYPE_any,TYPE_any,TYPE_any,TYPE_any,TYPE_any,
		TYPE_any, TYPE_any,TYPE_flt,TYPE_dbl,TYPE_any,TYPE_str},
/* dbl */
		{TYPE_any, TYPE_any,TYPE_any,TYPE_any,TYPE_any,TYPE_any,
		TYPE_any, TYPE_any,TYPE_dbl,TYPE_dbl,TYPE_any,TYPE_str},
/* lng */
		{TYPE_any, TYPE_any,TYPE_any,TYPE_lng,TYPE_any,TYPE_lng,
		TYPE_any, TYPE_any,TYPE_flt,TYPE_dbl,TYPE_lng,TYPE_str},
/* str */
		{TYPE_str, TYPE_str,TYPE_str,TYPE_str,TYPE_str,TYPE_str,
		TYPE_str, TYPE_str,TYPE_str,TYPE_str,TYPE_str,TYPE_str}
};
@-
Coercion is defined in terms of malType structures, which means
that we have to be prepared to deal with type variables as well.
@c

malType coercion(malType t1, malType t2){
	if( t1==t2) return t1;
	if( t1 <0 || t1>=TYPE_str) return t1;
	if( t2 <0 || t2>=TYPE_str) return t2;
	return gdkCoercionTable[(int)t1][(int)t2];
}
@+ Some utilities 
In many places we need a confirmed type identifier.
GDK returns the next available index when it can not find the type.
This is not sufficient here, an error message may have to be generated.
It is assumed that the type table does not change in the mean time.
Use the information that identifiers are at least one character
and are terminated by a null to speedup comparison
@c
INLINE
int idcmp(str n, str m)
{
	if( *(short *) n == *(short *) m) return strcmp(n,m);
	return -1;
}
@-
The ATOMindex routine is pretty slow, because it performs a
linear search through the table. This code should actually
be integrated with the kernel.  
@c
#define qt(x) (nme[1]==x[1] && nme[2]==x[2] && x[3]==0)
int getTypeIndex(str nme){
	int i;
	switch(*nme){
	case 'a': if(qt("any")) return TYPE_any; break;
	case 'b': if(qt("bat")) 
		 return newBatType(TYPE_any,TYPE_any);
		if(qt("bit")) return TYPE_bit; break;
	case 'd': if(qt("dbl")) return TYPE_dbl; break;
	case 'i': if(qt("int")) return TYPE_int; break;
	case 'f': if(qt("flt")) return TYPE_flt; break;
	case 'l': if(qt("lng")) return TYPE_lng; break;
	case 'o': if(qt("oid")) return TYPE_oid; break;
	case 's': if(qt("str")) return TYPE_str; break;
		if(qt("sht")) return TYPE_sht; break;
	}
	i= ATOMindex(nme);
	/*stream_printf(GDKout,"getTypeIndex %s %d %d\n",nme,i, GDKatomcnt);*/
	if( i== -GDKatomcnt) i = TYPE_any;
	return i;
}
int getGDKtype(int type){
	if( isaBatType(type)) return TYPE_bat;
	if( type == TYPE_any) return TYPE_int;
	return ATOMtype(type);
}
str newTmpName(int i){
	char buf[PATHLENGTH];
	snprintf(buf,PATHLENGTH,"%c%d",TMPMARKER,i);
	return GDKstrdup(buf);
}
int isTmpName(str n){ return n && *n == TMPMARKER;}
int isTypeName(str n){
	int i= ATOMindex(n);
	return i>=0;
}

int isIdentifier(str s)
{
	if( ! isalpha((int)*s) ) return -1;
	for( ;s && *s; s++)
	if( ! isalnum((int)*s) && *s !='_') return -1;
	return 0;
}
@}
