@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2005 CWI.
@' All Rights Reserved.

@f mal_exception
@a M. Kersten
@v 0.0

@* Exception handling
MAL comes with an exception handling mechanism, similar in style
as in modern programming languages.
Exceptions are considered rare situations that alter
the flow of control to a place where they can be handled.
After the exceptional case has been handled the following options exist
a) continue where it went wrong, b) retry the failed instruction,
c) leave the block where the exception was handled,
or d) pass the exception to an enclosing call.

Currently only c) and d) are supported.

@- Exception control
The exception handling keywords are: @code{ catch} and @code{ raise}
The @code{ catch}  marks a point in the dataflow where
an exception raised can be dealt with. Any statement between the
point where it is raised and the catch block is ignored.
Moreover, the @code{ catch} ... @code{ exit} block is ignored when
no errors have occurred in the preceeding dataflow structure.
Within the catch block, the exception variable can be manipulated
without constraints.

An exception message is linked with a exception name, a variable of
type string. If it is defined in the receiving block,
the exception message can be delivered. Otherwise, it
implicitly raises the exception in the surrounding scope.

After an exception has been dealt with you have
an option to @code{ leave} the catch block at the normal @code{ exit} or
attempt to redo the failed instruction call using a @code{ redo}.
Both @code{ leave} and @code{ redo} are conditional flow of control modifiers,
which trigger on a non-empty string.
An exception raised within a catch-block terminates
the function and returns control to the enclosing environment.

The argument to the catch statement is a target list,
which holds the exception variables you are interested in.
An expression evaluated with the catch statement is executed
after the block has been entered only. It could be used to
initialize the exception variables further.

The snippet below illustrates how an exception raised
in the function @code{ io.read} is catched using the exception variable IOerror.
After dealing with it locally, it raises a new exception @code{ FATALerror}
for the enclosing call.

@example
    io.write("Welcome");
    ...
catch IOerror;
    print("input error on reading password");
raise FATALerror:= "Can;t handle it";
exit IOerror;
@end example

Since @code{ catch} is a flow control modifier it can be attached to any
assignment statement. This statement is executed whenever there is no
exception outstanding, but will be ignored when control is moved
to the block otherwise.

@+ Builtin exceptions

In many instances information on the exceptional case encountered
should be passed onto the exception handling code block. 
The policy implemented in the MAL modules and recognized by
the interpreter, is to return a string value by default.
A NULL return value indicates that execution was succesful, otherwise
the string encodes information to analyse the error occurred.

This string pattern is strictly formatted and easy to analyse.
It starts with the name of the exception variable to
be set, followed by an indication where the exception was
raise, i.e. the module and function name and the program counter,
and finished with any specific information needed to interpret and handle the
exception.

For example, the exception string 
@code{ 'MALexception:Admin.main[2]:address of function missing'}
denotes an exception raised while typechecking a MAL program.

The exceptions captured within the kernel are marked as 'GDKerror'.
At that level there is no knowledge about the MAL context, which
makes interpretation difficult for the average programmer.
Exceptions in the MAL language layer are denoted by 'MALerror',
and query language exceptiosn fall in their own class, e.g. 'SQLerror'.
Exceptions can be cascaded to form a trail of exceptions recognized
during the exection.
@{
@-
@h
#ifndef _MAL_EXCEPTION_H
#include "mal_instruction.h"
/*VARARGS*/
mal_export str throwException(str nme, str fcn, char *format, ...);
mal_export str  raiseException(MalBlkPtr mb, int pc, str name, str msg);
mal_export str appendException(MalBlkPtr mb, int pc, str name, str msg,str old);
mal_export str locateException(MalBlkPtr mb, int pc, str oldmsg);
mal_export void showException(MalBlkPtr mb, int pc, str name, str msg);

#define MALEXCEPTION "MALexception"
#define throwMessage(Fcn,Msg)   throwException(MALEXCEPTION,Fcn,"%s",Msg)
#endif /*  _MAL_EXCEPTION_H*/

@-
@c
#include "mal_exception.h"

str appendException(MalBlkPtr mb, int pc, str name, str msg,str oldmsg){
        char buf[4196];
    int i;
    str s,fcn;

    s = mb? getModName(mb): "";
    fcn= mb? getFcnName(mb):"";
    buf[0]=0;
    if(oldmsg) snprintf(buf,4196,"%s",oldmsg);
    i= strlen(buf);
    if(name) snprintf(buf+i,4196-i,"%s:", name);
    i= strlen(buf);
    if(s) snprintf(buf+i,4196-i,"%s.",s);
    i= strlen(buf);
    snprintf(buf+i,4196-i,"%s",fcn);
    i= strlen(buf);
    snprintf(buf+i,4196-i,"[%d]",pc);
    i= strlen(buf);
    if(msg) snprintf(buf+i,4196-i,":%s",msg);
    i= strlen(buf);
    if( buf[i-1]!='\n'){ buf[i]='\n'; buf[i+1]=0;}
        return GDKstrdup(buf);
}
str locateException(MalBlkPtr mb, int pc, str oldmsg){
    str s, msg=0,name=0;

    if( (s= strchr(oldmsg,':'))){
        *s =0;
        name= oldmsg;
        msg= s+1;
    } else msg=oldmsg;
    return appendException(mb,pc,name,msg,0);
}
@-
The linked libraries should use the throwException to signal
an erroneous situation. It takes the name of MAL exception name
to be raised.
@c
/*VARARGS*/
str throwException(str nme, str fcn, char *format, ...){
        char message[GDKMAXERRLEN];
        int len = strlen(MALexception)+1;
        va_list ap;

    sprintf(message,"%s:%s:",nme,fcn);
    len= strlen(message);
        va_start(ap, format);
        vsnprintf(message + len, GDKMAXERRLEN-(len+2), format, ap);
        va_end(ap);

        return GDKstrdup(message);
}
str raiseException(MalBlkPtr mb, int pc, str name, str msg){
    return appendException(mb,pc,name,msg,"");
}
void showException(MalBlkPtr mb, int pc, str name, str msg){
    str n;
    n= raiseException(mb,pc,name,msg);
    GDKerror(n);
    GDKfree(n);
}
@}
