@f mal_parser
@a M. L. Kersten
@v 1.0

@* Monet Assembler Language
As of Version 5.0 the primary interface for interaction with the Monet kernel
is based on a simple, assembler-like language called MAL. The language reflects the
internal administration of instructions fed to the kernel interpreter.
A key design issue is further to make pattern matching for the MAL-squeezer
as fast as possible.

This module contains a small footprint MAL parser for Monet Version 5.
This parser assumes availability of a complete MAL block upfront
as a string to be parsed. 
The parser produced is intended to be thread safe.

The stand-alone version of this parser (Mal) can be used 
to check any MAL procedure for syntactic errors.

@+ The lexical analyzer
The lexical analyzer is generated using Flex, the preferred tool in Monet.

The implementation of the lexical analyzer is straightforward:
the input is taken from a client message buffer. It is assumed that
this buffer contains the complete MIL structure to be parsed.
This input buffer may be screwed up in the process, which implies
that front-ends may have to make a copy first.

The lexical analyzer and parser are prefixed with "mil", which ensures that
other language analyzers can safely be added
(provided they run not inparallel). The lexical analyzer should
not maintain a linenumber. This aspect is made explicit in the rules
any way.

The lexical analyser returns simple triples to the parser.
They include the token identifier, the Monet type-id, and a string
representation.

@h
#ifndef _MAL_PARSER_H
#define _MAL_PARSER_H

#include "gdk.h"

typedef struct YYSRECORD{
	int	token, tpe, len;
	char * 	val;
 } yystype, *yystypeptr;

#define YYSTYPE yystype
extern YYSTYPE yylval;
/* this should be  dependent on context of parser */
#define GDKerror(M) 	printf("%s",M) /* no threads here */
#ifdef GDKout
#undef GDKout
#endif
#define GDKout stdout

extern char *mallexname(int Y);
extern void mal_parserror(str msg);
extern void mal_flushbuffer();
extern str mal_lastline();
extern int mal_position();
extern int mal_skipcomment();
extern int mal_getch();
extern int yylex();

#endif /* _MAL_PARSER_H */
@l
%option noyylineno
%option never-interactive
%option noyywrap
%option nomain

D       [0-9]
O       [0-7]
L       [_a-zA-Z]
E       [Ee][-+]?{D}+
S       [\t\n ]*
P       [-!\$%\^\*~+|?<>=/\\]
IDENT	{L}({L}|{D})*
OPER	{P}+
%{

#include "mal_parser.h"
@-
The Bison parser generator will produce the table with token names
needed for tracing the parser.
@l
#include "mal_parser_tab.h"

#define RETURN(Y)       { PARSEDEBUG {\
                                THRprintf(GDKerr, "%s %s\n", mallexname(Y), yytext);\
                          } return Y; }


#define YY_INPUT(buf,result,max_size)   { int c = mal_getch();\
                           result = (c==0) ? YY_NULL: (buf[0] = (char)c,1);}
#define Symbol(X)       { Vector(X,TYPE_void,0,0); }
#define Vector(X,Y,V,L)	{ yylval.token= X;	\
			yylval.tpe  = Y;	\
			if( V != 0 ) \
			yylval.val = GDKstrdup(V);  	\
			yylval.len = L;	\
			RETURN (X); }
#define YY_USE_PROTOS
%}

%%
"#"                   { return mal_skipcomment();                              }
("nil"|"NIL")         { Vector(TOK_CONSTANT, TYPE_void, "nil", 3);   }
("end"|"END")       { Symbol(TOK_END);                                  }
("proc"|"PROC")       { Symbol(TOK_PROC);                                  }
("rule"|"RULE")       { Symbol(TOK_RULE);                                  }
("prop"|"PROP")       { Symbol(TOK_PROP);                                  }
("catch"|"CATCH")     { Symbol(TOK_CATCH);                                    }
("return"|"RETURN")   { Symbol(TOK_RETURN);                                   }
("raise"|"RAISE")     { Symbol(TOK_RAISE);                                    }
("goto"|"GOTO")     { Symbol(TOK_GOTO);                                    }
("label"|"LABEL")	{ Symbol(TOK_LABEL);                                }
("false"|"FALSE")     { Vector(TOK_CONSTANT, TYPE_bit, "0", 1);        }
("true"|"TRUE")       { Vector(TOK_CONSTANT, TYPE_bit, "1", 1);        }
("module"|"MODULE")   { Symbol(TOK_MODULE);				     }
("import"|"IMPORT")   { Symbol(TOK_IMPORT);				     }
("any"|"ANY")         { Vector(TOK_ANY, TYPE_int,  "-1", 2);               }
("bat"|"BAT")         { Symbol(TOK_BAT);				      }
"$$"                  { Symbol(TOK_RETVAR);                                  }
"$"({IDENT})	      { Vector(TOK_VARID,TYPE_str,yytext+1,yyleng-1);	}
"$"{D}+               { Vector(TOK_VARID,TYPE_int,yytext+1,yyleng-1);       }
".."                  { Symbol(TOK_RANGETEMP);                                }
"<<"                  { Symbol(TOK_PRECEEDS);                                }
("any"|"ANY")"::"{D}+           { Vector(TOK_ANY,TYPE_str,yytext+2,yyleng-2);		 }
":="                  { Symbol(TOK_ASSIGNMENT);                               }
("["{OPER}"]")	|
("["{IDENT}"]")	|
("{"{OPER}"}")	|
("{"{IDENT}"}")	|
("[:=]")	|
("[:"{OPER}"=]")	|
("{:=}") 	|
({IDENT})	      { Vector(TOK_IDENT, TYPE_str, yytext,yyleng);	      }
(":"{OPER}"=")	|
({OPER}"="?) 	      { Vector(TOK_OPERATOR, TYPE_str, yytext,yyleng);	      } 
("-")?{D}+"LL"        { Vector(TOK_CONSTANT, TYPE_lng, yytext, yyleng);}
("-")?{D}+            { Vector(TOK_CONSTANT, TYPE_int, yytext, yyleng);}
{D}+"@"{D}+           { Vector(TOK_CONSTANT, TYPE_oid, yytext, yyleng);         }
("-")?{D}+"."{D}+({E})?"LL" |
("-")?"."{D}+({E})?"LL"     |
("-")?{D}+{E}"LL"     { Vector(TOK_CONSTANT, TYPE_dbl,  yytext, yyleng);         }
("-")?{D}+"."{D}+({E})? |
("-")?"."{D}+({E})?     |
("-")?{D}+{E}         { Vector(TOK_CONSTANT, TYPE_flt,  yytext, yyleng);         }
"'"\\0{O}({O})?({O})?"'" {Vector(TOK_CONSTANT, TYPE_chr, yytext, yyleng);        }
\"[^\n"]*\"		{
                        if (yytext[yyleng-1] != '\\') {
				yytext[yyleng-1]=0;
                                Vector(TOK_CONSTANT, TYPE_str, yytext+1, yyleng-2);
                        } else {
				yymore(); 
			}					                     }
\'[^\n\']*\'            { 
                        if (yytext[yyleng-1] != '\\') {
                                Vector(TOK_CONSTANT, TYPE_chr, yytext+1, yyleng-2);
                        } else {
                                yymore(); 
                        }                                                     }
{S}                   ;
.                     { Symbol(*yytext);                                      }
%%
int mal_skipcomment() { 
	char c; 
	while ((c=input()) && (c != '\n')); 
	return yylex();
}
int yywrap(){ return 1;}

void mal_flushbuffer() {
        YY_FLUSH_BUFFER;
}

@
@- Input management
The parser reads its input from a string buffer space, organized as a
stack to permit easy escapes to "included" MIL programs (module inits).
After parsing the string buffer space is freed by the parser as well.

[These variables should be local to a parsing thread.]
@c
#include "mal_parser.h"

typedef struct _strstack_t {
	str buf, cptr, prevline, nxtline;
	int listing;		/* trace line consumption*/
	struct _strstack_t *up;
} strstack;

static strstack  *mal_stack = NULL;

int mal_push(str s, int l) {
	strstack *sp = (strstack*) GDKmalloc(sizeof(strstack));
	sp->listing = 1;
	sp->cptr = sp->nxtline= sp->prevline = sp->buf = s;  
	sp->up = mal_stack;
	mal_stack = sp;
	return 1;
}

int mal_pop() {
	strstack *sp = mal_stack;
	if (mal_stack) {
		mal_stack = sp->up;
		GDKfree(sp->buf);
		GDKfree(sp);
		return 1;
	}
	return 0;
}

@-
The next character is retrieved from the string pool
using the routine mal_getch. The position of the last
newline is retained to gain quick access.
@c
int mal_getch() {
        char ch;
	ch = *mal_stack->cptr;
        if (ch == '\n') {
                if (mal_stack->listing) { 
                        *mal_stack->cptr = 0;
                        fputs(mal_stack->nxtline, GDKout);
                        fputc('\n', GDKout);
                        fflush(GDKout);
                        /* *mal_stack->cptr = '\n'; */
                }
		mal_stack->prevline= mal_stack->nxtline;
                mal_stack->nxtline = mal_stack->cptr + 1;
        } 
        if (ch) mal_stack->cptr++;
        return ch;
}

@-
For error reporting we have to find the start of the previous line,
which, ofcourse, is easy.
@c
str mal_lastline(){ 
	if( mal_stack->nxtline == 0)
		return mal_stack->prevline;
	return mal_stack->nxtline; 
}
int mal_position()
{
	return (int)(mal_stack->cptr)- (int)mal_stack->nxtline;
}
@-
Long strings are in this version easier to handle, because the input is
already concatenated by the front-end. This means that a string literal may not
extend beyond end-of-line.
REWORKED

@+ The Parser
Unlike Monet V4.3 the client is responsible to collect the
input for parsing in a single string before calling the parser.
Once the input is available parsing runs in a critial section for
a single client thread.

@c
int mal_parse(str buf, int listing){
	return 0;
}
@- The Bison Grammar
The grammatica should be context free.
@y
%token_table

%{
#include "mal_parser.h"

#define YYDEBUG 1
#define YYERROR_VERBOSE 1

#undef yyerror
#define yyerror(X)      { mal_parserror(X);  }

#define YYPRINT(file,tpe,val)	mal_print(file,tpe,val)
int yydebug = 0;
void debugParser(int i){ yydebug=i; }
%}

%token TOK_PROC TOK_RULE TOK_PROP TOK_END 
%token TOK_LABEL TOK_GOTO TOK_RAISE TOK_CATCH
%token TOK_RANGETEMP
%token TOK_CONSTANT TOK_ASSIGNMENT 
%token TOK_IDENT TOK_VARID TOK_RETVAR 
%token TOK_RETURN
%token TOK_BAT
%token TOK_OPERATOR TOK_PRECEEDS
%token TOK_MODULE TOK_IMPORT
%token TOK_ANY

%left TOK_ASSIGNMENT TOK_OPERATOR
%%
MAL_program:
        MAL_session
    |   error ';' { yyerrok; yyclearin; return 1; }
    |   /* empty */

MAL_session:
        session
    |   MAL_session session

session:
        module_definition
    |   proc_definition
    |   rule_definition
    |   prop_definition
    |   gstmt

module_definition:
	TOK_MODULE TOK_IDENT exceptions';'

exceptions :
	TOK_RAISE TOK_IDENT
    | 	exceptions ',' TOK_IDENT

proc_definition :
	TOK_PROC proc_header
		statement_list
	TOK_END TOK_PROC

rule_definition :
	TOK_RULE rule_header
		statement_list
	TOK_END TOK_RULE

prop_definition :
	TOK_PROP rule_header
		statement_list
	TOK_END TOK_PROP

statement_list:
        gstmt
    |   statement_list gstmt

gstmt:
	stmt ';'
    |	stmt '?' condition ';'

stmt:
	var_path TOK_ASSIGNMENT expression
    |   TOK_RETURN ret_value
    |   TOK_LABEL factor
    |   TOK_GOTO  factor
    |	TOK_RAISE factor
    |   TOK_CATCH factor
    |   TOK_IMPORT factor
    |	fcn_call

ret_value:
        expression
    |       /* empty */

rule_header:
	pattern
    | 	rule_header TOK_PRECEEDS pattern

pattern:
	binding
    |	TOK_IDENT TOK_ASSIGNMENT fcn_call

proc_header: 
	proc_name '(' proc_params ')' ':' mel_type ';'
    |	proc_name '(' ')' ':' mel_type ';'

proc_name:
        TOK_IDENT
    |   TOK_OPERATOR

proc_params:
        params ',' param_range
    |   params 
    |   param_range

param_range:
        TOK_IDENT ':' mel_type TOK_RANGETEMP

params:
        binding
    |   params ',' binding

binding:
	TOK_IDENT ':' mel_type

mel_type:
        TOK_IDENT 
    |   TOK_BAT
    |   TOK_BAT '[' mel_atom ',' mel_atom ']'
    |   TOK_ANY

mel_atom:
        TOK_IDENT
    | 	TOK_BAT
    |   TOK_ANY

expression:
	term
    |	fcn_call
	
term :
	factor
    |	factor TOK_OPERATOR term
    |	TOK_OPERATOR factor
    | 	factor TOK_OPERATOR
    |   '(' term ')'

factor:
        TOK_CONSTANT
    |  	var_path
   
var_path :
      	variable 
    | 	var_path '.' TOK_IDENT
variable:
	TOK_IDENT
    |	TOK_VARID
    |	TOK_RETVAR

fcn_call :
	var_path '(' var_list ')'
    |	var_path '(' ')'
 
var_list:
     	factor
    |	var_list ',' factor

condition:
	term

%%

@-
Display the error information for the current client.
An arrow and state number is printed at the "appropriate" place. 
If no lookahead character is a used and the next character is a newline,
we should also copy the input .
@{
@y
void mal_parserror(str msg){
        static char buf[1024];
        char *s=buf, *t, *l = mal_lastline();
        int i = strlen(GDKERROR);
	strcpy(buf,GDKERROR); s+= i;

        mal_flushbuffer(); /* flush the lexer's buffer */

        *s++ = '"';
        for(t=l; *t && *t!='\n'; t++) {
                /* accidental %s directives in the lastline can
                   crash the vfsprintf later => escape them */
                if (*t == '%') *s++ = '%';
                *s++ = *t;
        }
        *s++ = '"'; *s++ = '\n';

	/* produce the position marker */
        for(*s++ = '!'; i > 0; i--) *s++ = ' ';
	i = mal_position();
        for(; i > 0; i--) {
        /* for (; *l && *l!='\n'; l++) { */
                *s++ = (*l != '\t')?' ':'\t';
        }
        *s++ = '^'; *s++ = '\n'; *s = 0;
	/* include bison message */
        if (msg) {
                sprintf(s, "! %s.\n", msg);
        } else {
                sprintf(s, "! "); s += 2;
                if (*s == 0) sprintf(s,"can't help you here, sorry.\n");
        }
        GDKerror(buf);
}

int mal_print(FILE *f, int tpe, YYSTYPE v)
{
	if( v.len >0) fprintf(f," %s ", v.val);
	return 0;
}

char *mallexname(int Y)           
{ 	if (Y >= TOK_PROC && Y <= TOK_ANY) {
		return (char*)yytname[Y-TOK_PROC];
	} 
	return (char*)"char";
}
@
@}

