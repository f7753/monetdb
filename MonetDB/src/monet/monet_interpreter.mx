@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@' 
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@' 
@' The Original Code is the Monet Database System.
@' 
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2004 CWI.
@' All Rights Reserved.
@' 
@' Contributor(s):
@' 		Martin Kersten <Martin.Kersten@cwi.nl>
@' 		Peter Boncz <Peter.Boncz@cwi.nl>
@' 		Niels Nes <Niels.Nes@cwi.nl>
@' 		Stefan Manegold  <Stefan.Manegold@cwi.nl>

@f monet_interpreter
@a M. L. Kersten, P. Boncz

@* The Monet interpreter 
The command interpreter executes statements taken from the Monet
Execution queue. More than one Monet Interpreter may be simultanuously
active.  Statements may be simple or composite. Composite statements
include IF..THEN, WHILE, sequential blocks, and parallel blocks. The
first two have their ususal intuitive meaning. The latter two create a
new context stack, and put a series of new requests on the queue (one
for each statement in the block). 
@
To provide for easy iteration over BATs, there are iterators.
They execute a block of MIL over each BUN in a BAT, substituting
$1 for the current head value and $2 for the current tail value. 
Iterators can be specified to run in parallel: in this
case the N MIL-blocks with substituted values are taken into
execution simultanously.
@
Finally, there are the multiplex operators. They execute a MIL command
of N params on a set of N BATs with equal head columns and tail
types corresponding to the N parameters. For each corresponding
set of BUNs the command is invoked. The result values are collected
in the tail column of the result BAT; wherin the head column
is again identical to all other N BATs.
@
MIL programs are represented by trees (see yytree.mx). These
trees are interpreted by the recurcsive interpret() call.
As MIL commands produce maxium one return value, garbage collection
uses the MIL trees (a field in the tree nodes).
@
MIL actions are supposed to be coarse grained. The interpret, however,
is optimized in order to be quick. A common optimization technique is 
run-time tree-rewriting. Expensive startup-actions in a block that is
repeatedly executed (like function resolution) is factored out using
this technique.
@{
@h
#ifndef _MONET_INTERPRETER_H_
#define _MONET_INTERPRETER_H_

#include "gdk.h"

@+ signature checking
We compress actual parameter types (argc,argv) of a command in a so-called
'signature bitstring'. This representation is specifically targeted to 
providing signature equality checks at very high speed. This is achieved by 
making sure the bit string can be compared as an array of 32-bit words.
@T
The signatures contain, in a bit sequence, descriptions for all parameters.
Each parameter starts with a length field of 4 bits. This can encode
values between 0-13 (14/15 are the special values MONETSIG\_BAT/MONETSIG\_BATCONST
that indicate a BAT-value). An integer of this number of bits that encodes the 
type number follows. Hence we can encode type numbers up till 4095 (13 bits 
integers); The simple case - non-BAT types - gets encoded as follows:
\begin{verbatim}
 CONTENTS:   log(tpe)          tpe
          $__ __ __ __$__ __  ..... __ __$
          $  |  |  |  $  |  | .....   |  $
    NBITS:      4           log(tpe)
\end{verbatim}
For BATs we use the previously mentioned MONETSIG\_BAT or MONETSIG\_BATCONST
in the length field.  After this, we place two encoded types, namely the 
head- and tail-type of the BAT. The format of these head- and tail-type 
packings is like described above. This yields the below picture:
\begin{verbatim}
BAT/BATCONST log(b->htpe)    b->htype      log(b->ttpe)      b->ttype
$__ __ __ __$__ __ __ __$__ __ __ __ __ __$__ __ __ __$__ __ __ __ __ __$
$  |  |  |  $  |  |  |  $  |  |  |  |  |  $  |  |  |  $  |  |  |  |  |  $
       4           4      log(b->htype)        4         log(b->ttpe)
\end{verbatim}
In the worst case, a BAT-type occupies 4 + 4 + 14 + 4 + 14 = 40 bits = 5 bytes.
In the very very worst case, MAXPARAMS(=32) BAT parameters are given. This would
require 40 (=MONETSIG\_MAXWORDS) 32-bit words to encode in a function signature.
@h
#define MONETSIG_BAT		15
#define MONETSIG_BATCONST	14
#define MONETSIG_MAXWORDS	((MAXPARAMS*40)/32)
#define MONETSIG_NWORDS(s)	((monetsig_nbits(s)+31)	>> 5)
#define MONETSIG_TOTSIZE(s)	(sizeof(monet_sig_t) + sizeof(int)*(s))

/* this structure contains the result of function resolution.
 * one such thing is stored for each expanded MIL operator in a
 * TOK_FUNCTION node */
typedef int (*PackFcn)(int argc, ValPtr argv);

typedef struct {
	PackFcn pack_fcn;	/* function pointer to generated impl stub */  
	GDKfcn	fast_fcn;	/* function pointer that gets pointer params */
	str	fcn_nme;	/* function name */
	sht	ret_tpe;	/* 0=unknown, or monet atom number */
	sht	token;		/* kind of function to execute */
	chr	special;	/* 0=none, 1=ifthenelse, 2=ifthen, 3=ifelse */
	bit	assignop; 	/* [OP=](A,..) overwrite A with result */
	bit	array_opt;	/* multiplex applicable for array opt */
	bit	merge_opt;	/* multiplex applicable for merge opt */

	/* BIT SIGNATURE -- we misuse words[0] for storing nbits and argc */
#define monetsig_nbits(s)	((sht*)	(s)->words)[0]
#define monetsig_argc(s)	((sht*)	(s)->words)[1]
	int words[1];		/* allocate the rest dynamically */
} monet_sig_t; 

#include "monet.h"

m_export int interpret           (Cntxt stk, YYSTREE lt, ValPtr res);
m_export int interpret_while     (Cntxt stk, YYSTREE lt, ValPtr res);
m_export int interpret_ident     (Cntxt stk, YYSTREE lt, ValPtr res);
m_export int interpret_var       (Cntxt stk, YYSTREE lt, ValPtr res);
m_export int interpret_assignment(Cntxt stk, YYSTREE lt, ValPtr res);
m_export int interpret_seqblock  (Cntxt stk, YYSTREE lt, ValPtr res, int scope);
m_export int interpret_parblock  (Cntxt stk, YYSTREE lt, ValPtr res, int scope);
m_export int interpret_iterator  (Cntxt stk, YYSTREE lt, ValPtr res, int paralle);
m_export int interpret_str       (Cntxt stk, str buf, ValPtr res);
m_export int interpret_file      (Cntxt stk, YYSTREE lt, ValPtr res);
m_export int interpret_cast      (str atom, int argc, ValPtr val, ValPtr res);
m_export int interpret_batcast   (str atom, int argc, ValPtr val, ValPtr res);
m_export void closeProfiler(struct stream* o);
m_export int startProfiler(struct stream* o);
m_export int stopProfiler(void);
m_export int setProfilerFilter(str left, str right);
#endif /* _MONET_INTERPRETER_H_ */

@c
#include "monet.h"

@= pack_bits
 	*wordptr |= @2 << bitoffset;
	bitoffset += @1;
	if (bitoffset > 32) {
		bitoffset -= 32;
		*(++wordptr) = @2 >> (@1-bitoffset);
	}
@= pack_type
{	int _tpe = @1, _log, _base;
	if (_tpe < 0) _tpe = TYPE_void;
	for(_log=0, _base=_tpe; _base; _log++) _base >>= 1;
	@:pack_bits(4,_log)@
	@:pack_bits(_log,_tpe)@ }
@c
static INLINE void monet_sig_pack(monet_sig_t *s, int argc, ValPtr argv) {
	int i=1, bitoffset=0, *wordptr = s->words+1;

	monetsig_argc(s) = argc-1;
	for(*wordptr=0; i<argc; i++) {
		BAT *b;
		if (argv[i].vtype==TYPE_bat){
                        bat bid = argv[i].val.bval;
			BBPfix(bid);
			b = BBPquickdesc(ABS(bid),FALSE);
			if (b) {
				int batbits = (argv[i].len==int_nil)?
					MONETSIG_BATCONST:MONETSIG_BAT;
				@:pack_bits(4,batbits)@
				@:pack_type((bid>0)?b->htype:b->ttype)@
				@:pack_type((bid>0)?b->ttype:b->htype)@
			}
			BBPunfix(bid);
		} else {
			@:pack_type(argv[i].vtype);
		}
	}
	monetsig_nbits(s) = bitoffset + ((wordptr - (s->words+1)) << 5); 
}

static INLINE int monet_sig_eq(monet_sig_t *s1, monet_sig_t *s2) {
	int *e2, *b1 = s1->words, *b2 = s2->words;

	/* check both nbits and argc */
	if (*(b1++) != *(b2++)) return FALSE;
	
	e2 = b2 + MONETSIG_NWORDS(s2);
	while(b2 < e2) {
		if (*(b1++) != *(b2++)) return FALSE;
	}
	return TRUE;
}

@+ Run-time MIL string parsing
Call back the interpreter to do a run-time parse of some string 
(that is supposed to be MIL) and execute the resulting tree.

Until recently this was a quite tricky business because the parser modified
the Client state, which interacted with the interpreter garbage
collection which also depends on the Client record (c->maxstk etc).

now we do a lightweight fork to obtain a temporary client session 

@- interpret_str
This forks a new subclient in order to get an independent context.
In this context, it calls the parser and executes the tree read.
Then the sub-client is killed.
@c
int interpret_str(Cntxt stk, str buf, ValPtr res) {
        int     i = -1;
 
        res->vtype = TYPE_void;

        /* Parse and interpret the script code. */
        if (buf && *buf) {
		Client c = forkClient(stk, FALSE);
		char *input_bak;
		if (c == NULL)
			return i;
		input_bak = c->input;
                c->input = buf;

                if (parseClient(c, FALSE)) {
                        i = interpret(c->stk, c->tree, res);
			if (i != -TOK_RETURN) {
				VALclear(res);
			}
                        CLEANUP(c->tree);
			yyfree(c->tree);
			c->tree = NULL;
                }
                c->input = input_bak;
		closeClient(c, FALSE);
        }
	return i;
}

@- interpret_file
First interpret file name, then read file, then call interpret_str(). 
@c
int interpret_file(Cntxt stk, YYSTREE lt, ValPtr res){
        int     i;
        char    *ptr, *buf;
        Client  c;

	if (lt->cnt != 1) {
		GDKerror("source: expects just one file name parameter\n");
		return -1;
	}
	i = interpret(stk, arg(lt,0), res);
	if (i < 0) {
		return i;
	}
	i = res->vtype;
	res->vtype = TYPE_void;
	if (i != TYPE_str) {
                GDKerror("interpret_file: string argument expected.\n");
                return -1;
	}
	ptr = res->val.sval;
        CNTXTclient(stk, &c);

	buf = monet_load_script(ptr, NULL);
	if (buf){
        	i = interpret_str(stk, buf, res);
        	GDKfree(buf);
	} else {
		i = -1;
	}
        return i;
}


@* Tree interpretation


@- bat pinning 
BATs that are passed into commands must be pinned into memory,
so the BBP trim cannot unexpectedly unload them while a
C implementation is using this BAT handle.

Here, we also solve one of the sticky problems in Monet: calling the 
BUNhead and BUNtail macros on BATs with void columns is thread-unsafe (for 
no good reason, just due to late evolution in the MIL data structures).

A workaround for this problem is to create a BATview on BATs with void
columns whenever it is going to be accessed concurrently. As concurrent
access (should be) read-only, this should not pose too much hindrance
(VIEWs are read-only and do not allow operators that modify them).

The params macro above examines BATs that are used and creates VIEWs
were appropiate. The below macro is called after execution and 
cleans up the created views.
@c
BAT *interpret_pin(batrec *r, str s) {
	BAT *b;
	BATDEBUG THRprintf(GDKerr, "interpret_pin(%s) on bat(%d) refcnt = %d\n",
				s, (int) r->id, BBPrefs(r->id)+1);
	b = BATdescriptor(r->id);
	if (b == NULL) { 
		return NULL;
	} else if (b->htype == TYPE_void || b->ttype == TYPE_void) {
		BAT *_b = BBP_cache(ABS(r->id));
		int tid = THRgettid();
		MT_set_lock(monet_voidLock, "pin");
		if (_b->void_cnt && _b->void_tid != tid) {
			BAT *v = VIEWcreate(b);
			BBPunfix(r->id);
			v->batStamp = b->batCacheid;
			BATDEBUG THRprintf(GDKerr, "interpret_pin(%s) create %d[1,%d] on %d[" SSZFMT "," SSZFMT "]\n", 
		        	s, (int) v->batCacheid, tid, (int) b->batCacheid, _b->void_cnt, _b->void_tid);
			_b = b = v; 
		} else {
	    		BATDEBUG THRprintf(GDKerr, "interpret_pin(%s) => %d[" SSZFMT "," SSZFMT "]\n", s,
				b->batCacheid, _b->void_cnt+1, _b->void_tid);
		}
		_b->void_cnt++;
		_b->void_tid = tid;
		MT_unset_lock(monet_voidLock, "pin");
	}
	r->id = b->batCacheid;
    	r->stamp = b->batStamp;
	return b;
}

void interpret_unpin(batrec *r, str s) {
	BAT *b = BBP_cache(r->id);
	BATDEBUG THRprintf(GDKerr, "interpret_unpin(%s) on bat(%d) refcnt = %d\n",
				s, (int) r->id, BBPrefs(r->id)-1);
	if (b){
	    if (b->batStamp != r->stamp) {
		GDKerror("interpret_unpin(%s) bat=%d,stamp=%d OVERWRITTEN\n", s, r->id, r->stamp);
	    } else if (b->htype == TYPE_void || b->ttype == TYPE_void) {
		BAT *_b = BBPdescriptor(ABS(r->id));
		MT_set_lock(monet_voidLock, "unpin");
		if (--(_b->void_cnt) == 0) {
			BATDEBUG THRprintf(GDKerr, "interpret_unpin(%s) => kill %d[" SSZFMT "," SSZFMT "]\n", 
				s, (int) b->batCacheid, _b->void_cnt, _b->void_tid);
			_b->void_tid = 0;
		} else {
			BATDEBUG THRprintf(GDKerr, "interpret_unpin(%s) => %d[" SSZFMT "," SSZFMT "]\n", 
				s, (int) b->batCacheid, _b->void_cnt, _b->void_tid);
		}
		MT_unset_lock(monet_voidLock, "unpin");
	    }
	}
        BBPunfix(r->id);
}

@- param execution(name,lt,argc,argv) 
this macro interprets all parameters of name={operator,function,etc} 'lt'
placing the parameter count in  'argc' and the result values in 'argv[1..argc]'
@c
int interpret_params(int stk, YYSTREE lt, ValPtr params, str fcn_nme) {
    ValPtr val_array = params+1;
    int j, argc = 1;

    params[0].vtype = TYPE_void;
    params[0].val.oval = void_nil;
    for(argc = 1; lt; lt = lt->overflow ) {
	YYSTREE *t = lt->yysons;
	for(j = 0; j < lt->cnt; j++, t++) {
	    ValRecord res, *argv = &res;
	    YYSTREE tt = *t;
	    int inc = 1, param_range = 0;

	    if (argc >= (1+MAXPARAMS)) {
		GDKerror("%s(parameters out of range): [0,%d]).\n", fcn_nme, MAXPARAMS-1);
		return -argc;
	    }
	    if (tt->token == TOK_RANGETEMP) {
		tt = tt->yysons[0];
		param_range = 1;
	    }
	    if (interpret(stk, tt, &res) < 0) {
		GDKerror("%s(param %d): evaluation error.\n", fcn_nme, j+1);
		return -argc;
	    } 
	    if (param_range) {
		inc += (*t)->yyval.len - argv->val.ival;
		argv = ((ValPtr) (*t)->yyval.val.pval) + argv->val.ival;
		if (res.vtype != TYPE_int) {
		    GDKerror("%s(param %d): illegal vararg range.\n", fcn_nme, j+1);
		    return -argc;
		}
	    }
	    if ((inc > 0) && ((argc+inc) < (1+MAXPARAMS))) while(inc--) {
	        if (argv->vtype == TYPE_bat) {  
		    if (BBPcheck(argv->val.bval,"interpret_params") == 0) {
   			GDKerror("%s(param %d): invalid BAT.\n", fcn_nme, j+1);
		        return -argc;
		    }
	        } else if (ATOMextern(argv->vtype)) {
		    if (!argv->val.pval) {
		        GDKerror("%s(param %d): invalid %s.\n", fcn_nme, j+1, ATOMname(argv->vtype));
		        return -argc;
		    }
	        }
		*val_array++ = *argv++; 
		argc++;
	    }
	}
    }
    return argc;
}

void interpret_params_unpin(int argc, ValPtr argv, str op_name) {
   int i = 0;
   while(++i < argc) 
   if (argv[i].vtype == TYPE_bat) {
	interpret_unpin(&argv[i].val.br,op_name);
   }
}

int interpret_params_pin(int argc, ValPtr argv, str op_name) {
   int ret = 1, i = 0;
   while(++i < argc) 
   if (argv[i].vtype == TYPE_bat) {
	ret &= (interpret_pin(&argv[i].val.br,op_name) != NULL);
   }
   if (!ret) interpret_params_unpin(argc, argv, op_name);
   return ret;
}
@-
The new version dumps performance information on a separate profiling
event stream. The amount of data is rather large and a potential
performance bottleneck. Nevertheless, it is considered usefull information
for debugging and optimizing the mil programs.

To avoid problems, each time client disappears we close the profiling option.
It should be explicitly set afterwards. 
@c
#ifdef HAVE_TIMES
#ifdef HAVE_SYS_TIMES_H
# include <sys/times.h>
#endif

#if OSVER < 560 && defined(SOLARIS)
#include "/usr/ucbinclude/sys/rusage.h"
#include "/usr/ucbinclude/sys/resource.h"
#endif

#ifdef HAVE_SYS_RESOURCE_H
#include <sys/resource.h>
#endif
#include "monet_deparse.h"
m_export void onlineProfilerEvent(char *caller, long clk, long ticks, struct tms *timer, YYSTREE lt);
m_export void onlineProfilerHeader();

static stream *eventstream=NULL;
static int delayswitch=0;
static int showheader=0;

static MT_Lock profilerLock;

void closeProfiler(struct stream *o)
{
	if( profilerLock==NULL)
		profilerLock= MT_create_lock();
	MT_set_lock(profilerLock, "startProfiler");
	if( o == eventstream){ 
		eventstream= NULL;
	}
	MT_unset_lock(profilerLock, "startProfiler");
}
int startProfiler(struct stream *o)
{
	if( profilerLock==NULL)
		profilerLock= MT_create_lock();
	MT_set_lock(profilerLock, "startProfiler");
	eventstream= o;
	delayswitch=1;
	showheader=1;
	MT_unset_lock(profilerLock, "startProfiler");
	return 0;
}
int stopProfiler(void)
{
	MT_set_lock(profilerLock, "stopProfiler");
	eventstream= NULL;
	MT_unset_lock(profilerLock, "stopProfiler");
	return 0;
}
#else
void closeProfiler(void *o)
{
	(void) o;
}
int startProfiler(void)
{
	return 0;
}
int stopProfiler(void)
{
	return 0;
}
#endif /* HAVE_TIMES */
@-
The information gathered is currently limited to some basic OS properties;
It is dumped on the eventstream whenever we leave the interpreter();
@= profileEvent
#ifdef HAVE_TIMES
if( eventstream){
    long nc= GDKusec();
    onlineProfilerEvent("@1",nc, nc-clk, &timer, lt);
}
#endif
@= profileCapture
#ifdef HAVE_TIMES
    if( eventstream) {
	 clk=GDKusec();
	 times(&timer);
    }
#endif
@c

/* the guts of MIL interpretation */
int interpret(Cntxt stk, YYSTREE lt, ValPtr res)
{
    int	stamp, i = res->len = 0, r = 0;
#ifdef HAVE_TIMES
    long clk = 0;
    struct tms timer;
    @:profileCapture@
#endif
@-
We do not want recursive programs crashing the server, so once in 
a while we check whether we are running dangerously low on available 
stack space. 
@c
    if ((stk&31) == 31 && THRhighwater()) {
	GDKerror("interpret: running out of physical stack space!\n");
	return -1;
    }

@+ passive interpretations
massaging interpretation of MIL trees. We shuffle some values around.
No new ones are created. Nothing really happens in the GDK world of BATs.
@c
    if (lt->token <= TOK_TRG) {
	/* the switch list is kept dense (see monet_parse.mx) so maybe
	 * the C compiler can construct a nice jump-table.
	 */
	switch(lt->token) {
	case TOK_ITERTEMP:
	case TOK_TEMPLATE:
		if (!lt->yyval.val.pval && !(lt->yyval.vtype == TYPE_int &&
		  (lt->yyval.val.ival > 0) && (lt->yyval.val.ival < MAXPARAMS)))
		{
		      	GDKerror("interpret: unresolved reference.\n");
		      	return -1;
		}
		*res = *((ValPtr) lt->yyval.val.pval);
		@:profileEvent(template)@
		return 0;
	case TOK_VARTEMP:
		i = interpret(stk, lt->yysons[0], res);
		if (i < 0){
			@:profileEvent(vartemp)@
			return i;
		}
		if (res->vtype != TYPE_int) {
		      	GDKerror("interpret: vararg must be an int.\n");
		      	return -1;
		}
		if ((res->val.ival < 1) ||  (res->val.ival > lt->yyval.len)) {
		      	GDKerror("interpret: vararg $%d does not exist.\n",
				res->val.ival); return -1;
		}
		*res = ((ValPtr) lt->yyval.val.pval)[res->val.ival];
		@:profileEvent(vartemp)@
		return 0;
        case TOK_RANGETEMP:
		GDKerror("interpret: parameter range not appropriate here.\n");
		return -1;
	case TOK_CONSTANT:
		*res = lt->yyval;
		@:profileEvent(constant)@
		return 0;
	case TOK_ASSIGNMENT:
		r= interpret_assignment(stk, lt, res);
		@:profileEvent(assignment)@
		return r;
	case TOK_SEQBLOCK:
		i = 1;
		/* fall through */
	case TOK_SEQ:
		return interpret_seqblock(stk, lt, res, i);
	case TOK_PARBLOCK:
		return interpret_parblock(stk, lt, res, 1);
	case TOK_PAREND:
		return 0;
	case TOK_IDENT:
		return interpret_ident(stk, lt, res);
	case TOK_IF:
       		if ((i = interpret(stk, arg(lt, 0), res)) < 0) {
			@:profileEvent(if)@
			return i;
       		}
		if (res->vtype != TYPE_bit) {
			GDKerror("interpret: if-expression needs BIT param.\n");
			return -1;
		} else if (res->val.cval[0] == bit_nil) {
			GDKerror("interpret: if bit(nil): don't know what to do!\n");
			return -1;
		}
		if (res->val.cval[0]) {
			r= interpret(stk, arg(lt, 1), res);
			@:profileEvent(if1)@
			return r;
		} else if (arg(lt, 2)) {
			r= interpret(stk, arg(lt, 2), res);
			@:profileEvent(if2)@
			return r;
		}
		@:profileEvent(if3)@
		break;
	case TOK_WHILE:
		return interpret_while(stk, lt, res);
	case TOK_ITERATOR:
	case TOK_ITCOMPILED:
		if (lt->yysons[2]) {
			i = interpret(stk, lt->yysons[2], res);
			if (i < 0) return i; 
	       		if (res->vtype != TYPE_int) {
			    GDKwarning(
				"interpret: parloop specifier cast to INT.\n");
			}
			i = MAX(1, res->val.ival);
			CLEANUP(lt->yysons[2]);
		} else {
			i = 1;
		}
		i = interpret_iterator(stk, lt, res, i);
		@:profileEvent(itcompiler)@
		return CATCHBREAK(i);
	case TOK_BREAK:
		return -TOK_BREAK;
	case TOK_RETURN:
		if (lt->yysons[0]) {
       		    i = interpret(stk, arg(lt, 0), res);
		    if (i < 0) return i;
			ATOMfix(res->vtype, VALptr(res));
		    VALcopy(res,res);
		}
		@:profileEvent(return)@
		return -TOK_RETURN;
	case TOK_VAR:
		r= interpret_var(stk, lt, res);
		@:profileEvent(var)@
		return r;
	case TOK_CONST:
		i = interpret(stk, lt->yysons[0], res);
		if (res->vtype == TYPE_bat) {
			res->len = int_nil;
		}
		@:profileEvent(const)@
		return i;

@+ active interpretations
An interpreter is not just interpreting things all the time as this would
mean that nothing could ever happen (you cannot implement smalltalk in
smalltalk in smalltalk, etc..) Magic things must be done someday somewhere!
That place is here for MIL. The tokens below this line call GDK/C routines. 
They are able to produce new values in the process. The deallocation 
primitives CATCH* look after garbage collecting these results.
@c
	case TOK_BUILTIN:
	{	int (*imp)(Cntxt, YYSTREE, ValPtr) = (int (*)(Cntxt, YYSTREE, ValPtr)) lt->yyval.val.pval;
		res->vtype = TYPE_void;
    		res->val.oval = void_nil;
		stamp = BBPcurstamp();	
		i = (*imp)(stk, lt, res); 
		if (i >= 0 ){
			CATCHREF(stk,lt,res);
		}
		CATCHERR(stk,lt,res,i,((YYSTREE) imp)); 
		@:profileEvent(builtin)@
		break;
	}
#ifdef MKMODS
        case TOK_TRG:
		i = interpret_trg(stk, lt, res);
		CATCHERR(stk,lt,res,i,lt->yysons[2]); break;
#endif
	}
    } else if (lt->token > TOK_SETAGGR) {
	GDKerror("interpret: unexpected token %d.\n", lt->token);
	return -1;

@- MIL functor interpretation
Basic MIL functors with multiple parameters (builtins were handled separately
above). All of which may be string derefences ((*nme)(), {*nme}(), [*nme]())
@T
When a functor-tree is inside a loop, it gets executed multiple times. 
Evaluation of a MIL functor (be it a command, proc, set aggregate or multiplex)
needs to go through a phase of {\em function resolution}. This involves finding
the correct overloading of a functor, given the types of the actual parameters.
This resolution process is slow. We want to exploit the fact that often on each
iteration, the types of the actual parameters will be equal (as MIL
is a dynamically typed language, we can never guarantee this 100\%).
In such cases, we factor out command resolution overhead, by using the results
of an earlier iteration. 

The result of function resolution is often a tree-expansion, that contains 
specific info, which depends on the mode of execution (e.g. proc, command,
multiplex, or set-aggr execution). To accomodate these optimizations in 
a generalized setting, each functor MIL tree has the following generic
format:
\begin{verbatim}
                            TOK_FUNCTION
                            yyval.val.sval="print"  ==> function string name
                            yysons[0,1,2]
                                  /  |  \
                                 /   |   \
                                /    |    \
                               /     |     \
                              /      |      \
                         PARAMS  EXPANSIONS  DEREF
                      yysons[..] yysons[..]  yysons[..]
                         /|\        /\        /\
call:                   / | \      /  \      /  \  ==> tree that evaluates
interpret     <==  argv[1]|argv[3]/    \    /____\     to a str fcn-name 
 (stk,argv[i],res)      argv[2]  /      \                        (OPTIONAL)
                               sig1    sigN            
to get the param               /\      yyval.val.pval->monet_sig_t 
          values              /  \                     'signature record'
                             /____\ ==> e.g. expanded 
                                             PROC tree for sig1
\end{verbatim}
The sig-nodes contain a signature-bitstring, that contains a compressed 
representation of the actual parameters for which the expansion was done.
The EXPANSION node hence is like a 'cache' in which the interpret() can
do a quick lookup to see whether an expansion was already made in an earlier
iteration for these actual parameter settings. If so, it can reuse the
already expanded functor. If not, it must expand it the functor and
put it into the EXPANSIONS tree.
@c
    } else {
	YYSTREE   op, opcache = lt->yysons[1];
	int       argc, deref_fcn = (lt->cnt >= 3);
	ValRecord *argv;
	int	  *buf;
	monet_sig_t *sig;
	str 	   fcn_nme;
@- 
phase 1: resolve 'nme' in (*nme)(), {*nme}(), and [*nme]() 
@c
	if (deref_fcn) {
		i = interpret(stk, lt->yysons[2], res);
		if (i < 0 || res->vtype != TYPE_str) {
		    GDKerror("interpret: operator string name expected.\n");
		    return -1;
		} else {
		    int l = (int) strlen(res->val.sval);
		    str s = (str) alloca(l+3);

		    /* resume normal dereference case */
		    fcn_nme = s;
		    if (lt->token==TOK_SETOP) {
			*(s++) = '[';
		    } else if (lt->token==TOK_SETAGGR) {
			*(s++) = '{';
		    }
		    strcpy(s, res->val.sval); s += l;
		    if (lt->token==TOK_SETOP) {
			*(s++) = ']';
		    } else if (lt->token==TOK_SETAGGR) {
			*(s++) = '}';
		    }
		    *s = 0;
		}
	} else {
		fcn_nme = lt->yyval.val.sval;
	}
	buf = (int*) alloca(MONETSIG_TOTSIZE(MONETSIG_MAXWORDS));
	sig = (monet_sig_t*) buf;


@- 
phase 2: interpret the actual params 
@c
	if (opcache->yyval.vtype == TYPE_int) {
	    opcache->yyval.vtype = TYPE_str;
	    /* opcache->yyval.len = opcache->yyval.val.ival; */
	    opcache->yyval.len = (1+MAXPARAMS)*sizeof(ValRecord);
	    opcache->yyval.val.pval = GDKmalloc(opcache->yyval.len);
	}
	argv = opcache->yyval.val.pval; 
	argc = interpret_params(stk, lt->yysons[0], argv, fcn_nme);
	if (argc < 0) return -1;
	res->vtype = TYPE_void;
    	res->val.oval = void_nil;
@- 
phase 3: check if we have this already in expanded form
@c
	monet_sig_pack(sig, argc, argv);

	{   YYSTREE tt = opcache;
	    do for(i=0; i<tt->cnt && (op=tt->yysons[i]); i++) { 
		monet_sig_t *p = (monet_sig_t*) op->yyval.val.pval;
		if (monet_sig_eq(sig, p)) {
			if (deref_fcn && strcmp(p->fcn_nme,fcn_nme)) continue;
			sig = p; goto exec; /* HIT => skip phases 4-6 */
		}
	    } while ((tt=tt->overflow) != NULL);
 	}
@-
phase 4: do resolution and expand an execution tree in op
@c
	sig->token = i = TBL_normal_resolve(fcn_nme,argc,argv,sig,stk);
	if (i < 0) {
		char *alt_nme = (char*) alloca(128), p = *fcn_nme;
		int retry = i;	

		if (p == '{' || p == '[') {
		    strcpy(alt_nme, fcn_nme+1);
		    alt_nme[strlen(alt_nme)-1] = 0; 

		    if (p == '{') {
			retry = TBL_setaggr_resolve(alt_nme,argc,argv,sig,stk);
			sig->token = TOK_SETAGGR;
		    } else {
			sig->assignop = (lt->yyval.len == -TOK_ASSIGNOP);
			sig->special = 0;
			if (alt_nme[0] == 'i' && alt_nme[1] == 'f') {
			    if (strcmp(alt_nme+2, "thenelse") == 0) {
				sig->special = 1;
			    } else if (strcmp(alt_nme+2, "then") == 0) {
				sig->special = 2;
			    } else if (strcmp(alt_nme+2, "else") == 0) {
				sig->special = 3;
			    }
			}
			retry = TBL_multiplex_resolve(alt_nme,argc,argv,sig,stk);
		        sig->token = TOK_SETOP;
			if (retry < 0 && argc == 2 && argv[1].vtype == TYPE_bat && (retry=ATOMindex(alt_nme)) >= 0) {
			    fcn_nme = BATatoms[retry].name;
			    sig->token = i = TOK_BATCAST;
			}
		    }
		} else {
		    alt_nme = fcn_nme;
		    if (argc <= 2 && (retry=ATOMindex(alt_nme)) >= 0) {
			fcn_nme = BATatoms[retry].name;
			sig->token = i = TOK_CAST;
		    }
		}
		if (retry > i) 
			i = retry;  /* found something better */

		/* Function resolution error */ 
		if (i < 0) {
		    char *s, *signatures = NULL;

@- phase 5: function resolution error

A function resolution error generally gives and i=TBL_RESOLVE_NOFCN result;

However, sometimes there is/are an existing function(s) by this name
and with a matching number of parameters, but the actual parameter types don't 
(fully) match a signature. If enumeration types are to be supported in the
MIL kernel, we could now trap and any convert enumeration types present to
their original representation (one by one, cheapest conversion first) and retry.

Such a conditition is identified by a return of i = TBL_RESOLVE_NOSIG
more precisely: (i ==TBL_RESOLVE_NOSIG ||  op->token==TBL_RESOLVE_NOSIG)

Finally, when a user uses a type that is not loaded by himself in an invocation,
there is a special error code TBL_RESOLVE_NOTPE; in that case we give an 
appropriate error message (signatures == NULL) and don't show the list of 
alternative signatures.
@c
		    if (i != TBL_RESOLVE_NOTPE) {
			signatures = (char*) alloca(8192);
			TBL_printsigs(signatures, stk, fcn_nme);
			if (p == '{' || p == '[') { 
			    for(s=signatures; *s; s++);
			    TBL_printsigs(s, stk, alt_nme);
			}
		    }
		    monet_sigerror("MIL operator", fcn_nme,  signatures, argc, argv);
		    return -1;
		}
	}

@- phase 6: expansion
Expand a procedure tree (if fcn_nme resolved to a proc), create a new 
signature record (of just the right size - `not a penny too much') and
add it to the expansion cache.
@c
	if (i == TOK_PROC) {
#if 0
 /* PETER: temporary hack to monitor proc instantiation (1/2) */
	static BAT* yysubst = NULL;
	if (yysubst == NULL) {
		yysubst = BATnew(TYPE_str, TYPE_lng, 1000);
		BATrename(yysubst, "yysubst");
	}
	argv[0].val.ival = 0;
#endif
	    op = yysubstitute_proc((YYSTREE)sig->pack_fcn,argc-1,argv);
#if 0
{ /* PETER: temporary hack to monitor proc instantiation (2/2) */
	BUN pp = BUNfnd(yysubst, fcn_nme);
	if (pp == NULL) {
		lng one = (LL_CONSTANT(1) << 32) + argv[0].val.ival;
		BUNins(yysubst, fcn_nme, &one); 
	} else {
		((int*) BUNtloc(yysubst,pp))[0]++;
		((int*) BUNtloc(yysubst,pp))[1] += argv[0].val.ival;
	}
}
#endif
	} else {
	    op = yynode(i,0);
	}
	i = MONETSIG_TOTSIZE(MONETSIG_NWORDS(sig)); /*length*/
	if (deref_fcn) {
		str s = fcn_nme;	
		sig = (monet_sig_t*) GDKmalloc(i+strLen(fcn_nme));
		strcpy(fcn_nme = ((char*) sig) + i, s);
	} else {
		sig = (monet_sig_t*) GDKmalloc(i);
	}
	memcpy(sig, buf, i);
	sig->fcn_nme = fcn_nme;
	op->yyval.val.pval  = (ptr) sig; 
	op->yyval.vtype = TYPE_str; /* this triggers deallocate of sig */
	yyexpand(opcache, op); /* add 'op' to the expansion list */

@- phase 7: execution
Comes down to 3 cases: normal, proc, or {X}/[X] execution
@c
exec:	stamp = BBPcurstamp();	
	if (sig->token == TOK_PROC) {
		YYSTREE proc = (YYSTREE) sig->pack_fcn;
        	i = interpret(stk, op, res);
        	CATCHRET(stk,opcache,res,i);
        	CATCHERR(stk,opcache,res,i,proc);
        	if (i >=0 && !TBL_procreturn(argc, argv, res, proc)) {
                	GDKerror("interpret: %s returned unexpected type.\n",
                                 proc->yyval.val.sval); i = -1;
        	}
		@:profileEvent(proc)@
		return i;
	}
	if (!interpret_params_pin(argc,argv,fcn_nme)) {
		return -1;
	}
	if (sig->token == TOK_COMMAND) {
		i = (*sig->pack_fcn)(argc, argv);
		*res = argv[0];
		CATCHVAL(stk,opcache,res);
		CATCHERR(stk,opcache,res,i,((YYSTREE) sig->pack_fcn)); 
		@:profileEvent(command)@
	} else if (sig->token == TOK_CAST) {
		i = interpret_cast(sig->fcn_nme,argc,argv+1,res);
		@:profileEvent(cast)@
		if (i >= 0){
			CATCHREF(stk,opcache,res);
		}
	} else if (sig->token == TOK_BATCAST) {
		i = interpret_batcast(sig->fcn_nme,argc,argv+1,res);
		@:profileEvent(batcast)@
		if (i >= 0 ){
			CATCHREF(stk,opcache,res);
		}
	} else {
                /* multiplex and set aggregate can execute procs in a loop!  
                 * we must indicate this to the garbage collector. It will 
  		 * keep the context records around for speed.
                 */
		int reuse = monet_cntxt[stk].reuse;
        	if (reuse < 0) {
                	monet_cntxt[stk].reuse = stk;
        	}
	    	if (sig->token == TOK_SETAGGR) {
			i = interpret_setaggr(sig->fcn_nme,argc,argv,res,op,stk);
			@:profileEvent(setaggr)@
		} else if (sig->token == TOK_SETOP) { 
			i = interpret_multiplex(sig->fcn_nme,argc,argv,res,op,stk);
			@:profileEvent(setop)@
		}
		CATCHVAL(stk,opcache,res); 
        	if (reuse < 0) {
               		monet_cntxt[stk].reuse = reuse;
			CNTXTfree1(stk);
        	}
	}
	interpret_params_unpin(argc,argv,fcn_nme);
    }
    return i;
}

@+ Specific Interpretations
@c
@- While-loop Interpretation
@c
#define RETURN(x) { i = x; goto xit; }

int interpret_while(int	stk, YYSTREE lt, ValPtr res)
{
	int i, reuse = monet_cntxt[stk].reuse;

	if (reuse < 0) {
		monet_cntxt[stk].reuse = stk;
	}
	if ((i = interpret(stk, arg(lt, 0), res)) < 0) {
		RETURN(i);
	}
       	if (res->vtype != TYPE_bit) {
		GDKerror("interpret_while: expression needs BIT param.\n");
		RETURN(-1);
	} else if (res->val.cval[0] == bit_nil) {
		GDKerror("interpret_while: bit(nil) => don't know what to do!\n");
		RETURN(-1);
	}

	while (res->val.cval[0]) {
		CLEANUP(arg(lt,0));
		if ((i = interpret(stk, arg(lt, 1), res)) < 0) {
			RETURN(CATCHBREAK(i));
		}
		CLEANUP(arg(lt,1));
		if ((i = interpret(stk, arg(lt, 0), res)) < 0) {
			RETURN(i);
		}
	}
xit:	CLEANUP(arg(lt,0));
        if (reuse < 0) {
                monet_cntxt[stk].reuse = reuse;
                CNTXTfree1(stk);
        }
	return 0;
}

@- Identifier Interpretation
Identifiers are resolved only the first time. If they are
a constant expression, they are substituted by constants. If they
denote a variable value, it is replaced by a pointer (TOK_TEMPLATE)
to the @%ValRecord@ of that variable in the context stack.
@c
int interpret_ident(int	stk, YYSTREE lt, ValPtr res)
{
	Variable v;
	BAT *b = NULL;
	int i=0, j;

	for(i = lt->yyval.len; i > 0; i--) { /* hacky use of len as ../ depth */
		if (stk >= 0) {
			stk = monet_cntxt[stk].outer;
		} else {
               		GDKerror("interpret_ident: illegal context.\n");
			return -1;
		}
	}
	i = stk;
       	v = VARfind(&i, lt->yyval.val.sval);
       	if (v != NULL) {
		GDKfree(lt->yyval.val.pval);
		/* resolve only once: TEMPLATE */
        	lt->token = TOK_TEMPLATE; 
		lt->yyval.vtype = v->binding.vtype;
		lt->yyval.val.pval = &v->binding;
		*res = v->binding;
		return 0;
	}
	/* resolve only once: CONSTANT */
        lt->token = TOK_CONSTANT; 
	i = BBPindex(lt->yyval.val.sval);
	j = BBPfix(i); 
	if (j == 0 || strcmp(BBP_logical(i), lt->yyval.val.sval)) {
		if (j) BBPunfix(i);
		lt->yyval.vtype = TYPE_str;
		lt->yyval.len = 1+strlen(lt->yyval.val.sval);
               	GDKwarning("interpret: convert identifier '%s' to string.\n", 
			lt->yyval.val.sval);
		return interpret(stk, lt, res);
       	}
	/* LOAD FIX: register the bat for unpinning */
	GDKfree(lt->yyval.val.sval);
	if (BBPincref(i, TRUE) && (b=BBPquickdesc(ABS(i), FALSE)) != NULL) {
		lt->yyval.vtype = TYPE_bat;
		lt->yyval.val.bval = i;
		lt->yyval.len = 0;
		lt->dealloc = TYPE_bat;
		lt->free.batref.id = i;
		lt->free.batref.stamp = b->batStamp;
		BBPunfix(i);
	} else {
		/* if the BAT gives a load error, return nil */
		lt->yyval.vtype = TYPE_void;
		lt->yyval.val.oval = oid_nil;
	}
	*res = lt->yyval;
	return 0;
}

@- Variable Declaration Interpretation
Only executed the first time. We keep the variable stacks, so
the second time only the initialization statements are executed as 
a sequential block.
@c
int interpret_var(int	stk, YYSTREE lt, ValPtr res)
{
        int i=0;
 
        lt->token = TOK_SEQ; /* we only create once */ 
        for(; lt; lt = lt->overflow) {
            Variable v;
            int j;
            for(j = 0; j < lt->cnt; j++) { 
                YYSTREE t = lt->yysons[j];
                if (t != NULL) {
		    v = VARlocalfind(&stk, t->yyval.val.sval);
		    if(!v){
                    	v = VARnew(stk, t->yyval.val.sval);
		    } else {
			/*GDKwarning("Overwriting var %s\n", t->yyval.val.sval);*/

                        ATOMunfix(v->binding.vtype, VALptr(&(v->binding)));
			VALclear(&v->binding);
		    }
                    if (t->token == TOK_ASSIGNMENT) {
                        arg(t,0)->token = TOK_TEMPLATE;
                        arg(t,0)->yyval.vtype = TYPE_ptr;
                        arg(t,0)->yyval.val.pval = (ptr) &v->binding;
                        i = interpret_assignment(stk, t, res);
                        CLEANUP(t);
                        if (i<0) break;
                    } else {
                        lt->yysons[j] = 0;
                        yyfree(t);
                    }
                }
            } 
        }
        return i;
}


@- MIL Trigger Interpretation
Instantiation of a trigger is more-or-less equivalent to procedure call.
A copy of the trigger definition is used and scheduled for execution.
@c
#ifdef MKMODS
int interpret_trigger(int stk, YYSTREE lt, ValPtr res)
{
	ValPtr argv = (ValPtr) GDKmalloc((1+MAXPARAMS)*sizeof(ValRecord));
	YYSTREE definition = (YYSTREE) lt->yyval.val.pval;
	YYSTREE	t,expr;
	int argc,i=0;
 
	argc = interpret_params(stk, lt, argv, definition->yyval.val.sval);
	if (argc < 0) { i = argc; goto xit; }
	t = yynode(TOK_COMPILED, TYPE_str);
	t->yyval.len = MAXPARAMS*sizeof(ValRecord);
	t->yyval.val.pval = argv;
	t->yysons[0] = yysubstitute_proc(definition, argc-1, argv);
	lt->yysons[2] = definition;
	t->cnt = 1;
	i = TEMenable(stk, t->yysons[0], res);
xit:	return i;
}
#endif


@- Atomic Cast Interpretation
Any atom can be casted to another one. All numeric values can be interchanged,
and conversion to and from string is always possible.
@c
#define trivial_cast(dst,src)	\
	((dst) == (src) || \
	 (ATOMstorage(dst) == ATOMstorage(src) && \
	  ((dst) != TYPE_str || BATatoms[src].atomToStr == BATatoms[TYPE_str].atomToStr) && \
	  ((src) != TYPE_str || BATatoms[dst].atomFromStr == BATatoms[TYPE_str].atomFromStr)))

int interpret_cast(str atom, int argc, ValPtr val, ValPtr res)
{
	int tpe = ATOMindex(atom);

	if (argc == 1) {
		res->vtype = TYPE_int;
		res->val.ival = tpe;
	} else if ((tpe == val->vtype ||
		    (ATOMstorage(tpe) == ATOMstorage(val->vtype) &&
		     ATOMstorage(tpe) == TYPE_str && /* extra compared to trivial_cast above */
		     (tpe != TYPE_str ||
		      BATatoms[val->vtype].atomToStr == BATatoms[TYPE_str].atomToStr) &&
		     ((val->vtype) != TYPE_str ||
		      BATatoms[tpe].atomFromStr == BATatoms[TYPE_str].atomFromStr)))) {
		VALcopy(res,val);
		res->vtype = tpe;
	} else if (val->vtype == TYPE_str) {
		char *s = val->val.sval;
		if (ATOMextern(tpe)) {
			res->val.pval = NULL;
			res->len = 0;
			ATOMfromstr(tpe, &res->val.pval, &res->len, s);
		} else {
			ptr dst = (ptr) &res->val.ival;
			res->len = ATOMsize(tpe);
			ATOMfromstr(tpe, &dst, &res->len, s);
		}
		res->vtype = tpe;
	} else if (tpe == TYPE_str) {
		if (ATOMcmp(val->vtype, VALptr(val), ATOMnilptr(val->vtype))) {
			char *s = 0;
			res->len = 1+VALformat(&s, val); 	
			res->val.sval = s;
		} else {
			res->val.sval = ATOMnil(TYPE_str);
		}
		res->vtype = TYPE_str;
	} else {
		*res = *val;
		if ((VALconvert(tpe, res) == ILLEGALVALUE) || TYPEerror(tpe, res->vtype)){
			GDKerror("interpret_cast: should have a string parameter.\n");
			return -1;
		}
	}
	ATOMfix(res->vtype, VALptr(res));
	return 0;
}

int interpret_batcast(str atom, int argc, ValPtr val, ValPtr res)
{
	BAT *bn, *b = BBP_cache(val->val.bval);
	int tpe = ATOMindex(atom);
	(void) argc;

	if (trivial_cast(tpe,b->ttype)) {
	    /* trivial conversion, e.g. int => int or oid => int */
	    int dense_bak = b->T->dense;
	    b->T->dense = FALSE; 	
	    bn = BATrcopy(b); /* we do not want smart oid->void conversion */
	    b->T->dense = dense_bak; 	
	    bn->ttype = BATmirror(bn)->htype = tpe;
	    strcpy(bn->tatom, ATOMname(tpe));
	} else {
	    int reduce = 0;
	    bn = BATnew(b->htype, tpe, BATcount(b));

	    /* propagate properties */
	    bn->hsorted = BAThordered(b);
	    bn->tsorted = 0;
	    BATkey(bn, b->hkey);
	    ALIGNsetH(bn,b);

	    if (BATcount(b)) {
		int len = ATOMsize(BATttype(b));
		BUN q = BUNlast(b);
		BUN p = BUNfirst(b);
		int xx = BUNsize(b);
	    
		if (tpe == TYPE_oid && b->ttype == TYPE_void) {
		    /* void => oid materialization is a special case */
		    oid curid = b->tseqbase;
		    BATloopFast(b,p,q,xx) {
		        BUNfastins(bn, BUNhead(b,p), &curid);
                        if (curid != oid_nil) curid++;
		    }
		    ALIGNsetT(bn,b);
		} else if (tpe == TYPE_str || b->ttype == TYPE_str) {
		    /* from-string or to-string conversion */
		    ptr v = GDKmalloc(len);
		    if (tpe == TYPE_chr) {
			/* str => chr: just get first character */
			BATloopFast(b,p,q,xx) {
			    /* accidentally works well on NILs */
			    BUNfastins(bn, BUNhead(b,p), BUNtvar(b,p));
			}
		    } else if (tpe != TYPE_str) {
			/* str => any: use fromstr ADT routine */
			int (*fromstr)(str, int*, ptr*) = BATatoms[tpe].atomFromStr;
			BATloopFast(b,p,q,xx) {
			    /* nil str value will produce a nil atom value */
			    (*fromstr)(BUNtvar(b,p), &len, &v);
			    BUNfastins(bn, BUNhead(b,p), v);
			}
		    } else if (b->ttype == TYPE_chr) {
			/* chr => str: do this efficiently */
			char s[4]; s[0] = s[2] = '\''; s[3] = 0;
			BATloopFast(b,p,q,xx) {
			    /* accidentally works well on NILs */
			    s[1] = *(char*) BUNtloc(b,p); 
			    BUNfastins(bn, BUNhead(b,p), s);
			}
		    } else {
			/* any => str: use tostr ADT routine */
			int (*tostr)(str*,int*,ptr) = BATatoms[b->ttype].atomToStr;
			int (*cmp)(ptr,ptr) = BATatoms[b->ttype].atomCmp;
			ptr nilptr = ATOMnilptr(b->ttype);
			BATloopFast(b,p,q,xx) {
			    ptr t = BUNtail(b,p);
			    if ((*cmp)(t, nilptr)) {
			    	(*tostr)((str*)&v, &len, t);
			    	BUNfastins(bn, BUNhead(b,p), v);
			    } else {
			    	BUNfastins(bn, BUNhead(b,p), str_nil);
			    }
			}
		    }
		    GDKfree(v);
		} else {
		    ptr s;

		    /* misc conversions by VALconvert are expensive */
		    res->vtype = BATttype(b);
		    if (ATOMextern(res->vtype)) {
			res->val.pval = BUNtail(b,p);
			reduce = 1; /* extern atoms are suspicious */
		    } else {
			memcpy(&res->val.ival, BUNtail(b,p), len);
		    	reduce = 0;
		    }
		    /* reduce is set when conversion loses precision */
		    if (ATOMsize(tpe) <= ATOMsize(res->vtype)) {
			reduce = 1;
		    } else if (b->ttype == TYPE_flt && tpe == TYPE_lng) {
			reduce = 1; /* rounding off */
		    }
		    s = VALconvert(tpe, res); /* try once if this works */
		    if (s == ILLEGALVALUE || TYPEerror(tpe, res->vtype)) {
			GDKerror("interpret_batcast: impossible to convert '%s' into '%s'.\n", 
					ATOMname(b->ttype), ATOMname(tpe));
			BBPreclaim(bn);
			return -1;
		    }
		    BUNfastins(bn, BUNhead(b,p), s);
		    if (ATOMextern(BATttype(b))) {
			for(p+=xx; p < q; p+=xx) {
		    	    res->vtype = BATttype(b);
			    res->val.pval = BUNtail(b,p);
			    s = VALconvert(tpe, res);
			    BUNfastins(bn, BUNhead(b,p), s);
			} 
		    } else {
			for(p+=xx; p < q; p+=xx) {
		    	    res->vtype = BATttype(b);
			    memcpy(&res->val.ival, BUNtail(b,p), len);
			    s = VALconvert(tpe, res);
			    BUNfastins(bn, BUNhead(b,p), s);
			}
		    }
		} /* different kind of conversions */
	    }
	    if ((!bn->tkey) && (!reduce)) {
		BATkey(BATmirror(bn), b->tkey);
	    }
	}
	res->vtype = TYPE_bat;
	res->val.bval = bn->batCacheid;
	res->len = 0;
	BBPincref(bn->batCacheid,TRUE);
	BBPunfix(bn->batCacheid);
	return 0;
}

@- Variable Assignment Interpretation
@c
int interpret_assignment(int stk, YYSTREE lt, ValPtr res)
{
	int	i, s = stk;
	ValRecord oldvalue, *value;
	Variable act = 0;
	
	if (arg(lt, 0)->token == TOK_IDENT) {	
		str nme = arg(lt, 0)->yyval.val.sval; 
		for(i = arg(lt, 0)->yyval.len; i > 0; i--) {
			if (s >= 0) {
				s = monet_cntxt[s].outer;
			} else {
				GDKerror("interpret_assignment: illegal context.\n");
				return -1;
			}
		}	
		if ((act = VARfind(&s, nme)) == 0) {
			act = VARnew(stk, nme);
			if (!act) {
				return -1;
			}
		}
		if (act->constant) {
			GDKerror("interpret_assignment: cannot assign to constant '%s'\n", nme);
	       		return -1;
		}
@-
If the variable is in a stable scope, we modify the reference
into a TEMPLATE, to avoid resolving it again.
@c
		arg(lt,0)->token = TOK_TEMPLATE;
		GDKfree(arg(lt,0)->yyval.val.pval);
		arg(lt,0)->yyval.val.pval = &act->binding;
		value = &act->binding;
	} else {
		value = arg(lt,0)->yyval.val.pval;
	}	
@-
We cannot destroy the old value now, since it may be used
in the expression ('a := a + 1'), so: save its reference.
@c
	oldvalue = *value;
@-
Evaluate the expression, and assign the value. Increment refcnt, 
if it is a bat-expression.
@c
	i = interpret(stk, arg(lt, 1), res);
@-
Variables with frozen type may lead to type errors
@c
        if (act && act->frozen && value->vtype != res->vtype) {
                GDKerror("interpret_assignment: cannot change type of frozen variable '%s'\n",
						act->name);
                return -1;
        }

	VALcopy(value, res);
       	if (i >= 0) {
		ATOMfix(res->vtype, VALptr(res));
	} 
@-
Cleanup the old value.
@c
	ATOMunfix(oldvalue.vtype, VALptr(&oldvalue));
	if (ATOMextern(oldvalue.vtype)) {
		GDKfree(oldvalue.val.pval);
	}
	return i;
}


@}

@- Sequential Block Interpretation
Sequential blocks can be handled directly -- no need to go to the queue.
@c
int interpret_seqblock(int stk, YYSTREE lt, ValPtr res, int scope)
{
	int	i, r = 0;

	if (scope) {
		if (!lt->old_cntxt) {
			stk = CNTXTnew(stk);
			if (stk <= 0) return -1;
			lt->old_cntxt = stk;
		} else stk = lt->old_cntxt; 
		CNTXTuse(stk); 
	} 
	for( ; lt; lt = lt->overflow) {  
		for(i = 0; i < lt->cnt; i++) 
		if (lt->yysons[i]) {
			r = interpret(stk, lt->yysons[i], res); 
			CLEANUP(lt->yysons[i]);
			if (r<0) goto xit;
		}
	}
xit:   if (scope) {
		CNTXTclear(stk);
		if (monet_cntxt[stk].reuse < 0) CNTXTfree1(stk);
	}
	if (r >= 0) {
		res->vtype = TYPE_void;
    		res->val.oval = void_nil;
	}
	return r;
} 
@}
@- Parallel Block Interpretation
The statements in a parallel block are synchronized by the PAREND statement, 
i.e. a no-op, which directly follows the parallel block.
The sole action is to delete the context for the parallel block.
The parallel statements are immediately taken into execution.
@{
@c
int interpret_parblock(int stk, YYSTREE lt, ValPtr res, int scope)
{
	int	reuse = monet_cntxt[stk].reuse;
	int	tid = THRgettid();
	Thread	t = THRget(tid);
	YYSTREE	bt;
	Request barrier;
	Request current;
	Request p = 0;
	Request q = 0;
	Client  c;
	int 	i;
	(void) res;

	PARDEBUG THRprintf(GDKerr, "parallel block\n");

	CNTXTclient(stk,&c);

	if (scope) {
		if (!lt->old_cntxt) {
			stk = CNTXTnew(stk);
			if (stk <= 0) return -1;
			lt->old_cntxt = stk; 
			if (reuse < 0) {
				monet_cntxt[stk].reuse = stk;
			}
		} else stk = lt->old_cntxt;
		CNTXTuse(stk);
	} 
	bt = yynode(TOK_PAREND, stk);
	barrier = newRequest(stk, bt, 0);
@-
The parallel block is translated into a sequence of requests,
which have no interdependencies, and can be scheduled 
immediately.
@c
	for(;lt; lt = lt->overflow) {
		for (i = 0; i < lt->cnt; i++) {
			barrier->ev_status++;
			current = newRequest(stk, lt->yysons[i], 0);
			current->ev_wakeup = barrier;
			if (qm_profile) {
				char msg[40];
				sprintf(msg,"[%d]",i);
				QMmessage(current,msg);
			}
			if (p == 0) {
				q = p = current;
			} else {
				q->ev_next = current;
				current->ev_prev = q;
				q = current;
			}
		}
	}
	q->ev_next = barrier;
	barrier->ev_prev = q;
	barrier->ev_process= tid;
@-
If the current request should wakeup another event upon termination
then the barrier event is made a prerequisite as well. This involves
increasing the status and setting the wakeup flag.
@c
	q = thisRequest();
@-
Insert the string of independent requests in the execution queue.
Use the first request for immediate execution.
@c
	putRequest(p);
	doRequest(t,barrier);
	yyfree(bt);
	if (scope){
		CNTXTclear(stk);
	        if (reuse < 0) {
			monet_cntxt[stk].reuse = reuse;
			CNTXTfree2(stk,c);
		}
	}
	return 0;
}
@}

@- Iterator Interpretation.

Iterators are special Monet commands, that repeatedly evaluate a
syntax-tree, once at a time for each selected BUN out of some BAT. The
selection of BUNs is made by the user-implemented iteration-command.
This user-implemented iteration-command must contain a call in its
inner loop to the function @%ITERATE(head, tail, handle)@, which
triggers the evaluation of the syntax tree. This design allows an
efficient implementation of the user-iterator, but of course
evaluating the syntax tree still incurs normal interpretation-overhead.

@%interpret_iterator()@ prepares the syntax tree for repeated evaluation, by
making a copy of it in which the parameters are substituted by
pointers to value records (the syntax-tree can receive two parameters
named "$h" and "$t", corresponding to a value-record for a head, resp.
tail). On every iteration, the head- and tail-values of the current
BUN are copied into those value-records by the @:ITERATE()@ routine,
and subsequently the syntax-tree is interpreted. 

Things are complicated a bit further because iterators can be
specified to evaluate tuples in parallel. So, actually, a sequence of
syntax trees and their corresponding parameter records (for head,tail
substitution) are created.
@= expand
@:tuple_interpret(@1,@2,f,chval)@
@:tuple_interpret(@1,@2,f,shval)@
@:tuple_interpret(@1,@2,f,ival)@
@:tuple_interpret(@1,@2,f,dval)@
@:tuple_interpret(@1,@2,v,pval)@
@:tuple_interpret(@1,@2,f,pval)@
@:par_collect(@1,@2,f,chval)@
@:par_collect(@1,@2,f,shval)@
@:par_collect(@1,@2,f,ival)@
@:par_collect(@1,@2,f,dval)@
@:par_collect(@1,@2,v,pval)@
@:par_collect(@1,@2,f,pval)@
@c
#define atmlen(h,f)	(h).len = (*(f))((h).val.pval)
#define len_vv(p,x)	atmlen(p[0],x->h_len); atmlen(p[1],x->t_len)
#define len_vf(p,x)	atmlen(p[0],x->h_len) 
#define len_fv(p,x)	atmlen(p[1],x->t_len) 
#define len_ff(p,x)
#define assign_chval(p,v)	p.cval[0] = *(chr*) v;
#define assign_shval(p,v)	p.shval = *(sht*) v;
#define assign_ival(p,v)	p.ival = *(int*) v;
#define assign_dval(p,v)	p.dval = *(dbl*) v;
#define assign_pval(p,v)	p.pval = v;

@:expand(f,chval)@
@:expand(f,shval)@
@:expand(f,ival)@
@:expand(f,dval)@
@:expand(v,pval)@
@:expand(f,pval)@


static 
void iterator_maketrees(
	Iteration handle,
	YYSTREE	body,
	int	parallel,
	int	ht,
	int	tt)
{
	ValPtr p;
	int i;
	(void) ht;
	(void) tt;

	if (handle->params) {
		GDKfree(handle->params); 
	}
	handle->params = p = (ValPtr) GDKmalloc(sizeof(ValRecord)*2*parallel);

	if (parallel > 1) {
		if (handle->parmax <= 1) { 
			YYSTREE t = handle->tree;
			handle->tree = yynode(TOK_PARBLOCK, 0);
			if (t) yyexpand(handle->tree,t);
		}
		for(i = handle->parmax; i < parallel; i++, p += 2) {
			yyexpand(handle->tree, yysubstitute_iter(body, 2, p-1));
		}
	} else if (handle->tree == 0) { 
		handle->tree = yysubstitute_iter(body, 2, p-1);
	}
}

ptr interpret_fcn(int ht, int tt, int parallel)
{
	ptr addr;
	switch(ATOMstorage(ht)) {
	case TYPE_chr:	@:switch_ht(fchval)@	break;
	case TYPE_sht:  @:switch_ht(fshval)@	break;
#if SIZEOF_OID == SIZEOF_INT
	case TYPE_void:
#endif
	case TYPE_int:	
	case TYPE_flt:	@:switch_ht(fival)@	break;
#if SIZEOF_OID == SIZEOF_LNG
	case TYPE_void:
#endif
	case TYPE_lng: 
        case TYPE_dbl:	@:switch_ht(fdval)@	break;
	default: if (ATOMvarsized(ht))	@:switch_ht(vpval)@
	         else			@:switch_ht(fpval)@
	}
@= switch_ht
	switch(ATOMstorage(tt)) {
	case TYPE_chr: @:switch_tt(@1,fchval)@	break;
	case TYPE_sht: @:switch_tt(@1,fshval)@	break;
#if SIZEOF_OID == SIZEOF_INT
	case TYPE_void:
#endif
	case TYPE_int:	
	case TYPE_flt: @:switch_tt(@1,fival)@	break;
#if SIZEOF_OID == SIZEOF_LNG
	case TYPE_void:
#endif
	case TYPE_lng: 
	case TYPE_dbl:	@:switch_tt(@1,fdval)@	break;
	default: if (ATOMvarsized(tt))	@:switch_tt(@1,vpval)@
	         else			@:switch_tt(@1,fpval)@
	} 
@= switch_tt
	addr = (ptr) ((parallel)?par_collect_@1_@2:tuple_interpret_@1_@2); 
@c
	return addr;
}

int interpret_iterator(Cntxt stk, YYSTREE lt, ValPtr res, int parallel)
{
	int reuse = monet_cntxt[stk].reuse;
        ValRecord argv[MAXPARAMS+2];
	ITrecord *handle;
	YYSTREE	params = lt->yysons[1];
	YYSTREE	body = lt->yysons[0];
	int	argc, i, ht, tt, (*cmd)(int, ValRecord *);

	/* Deeper contexts get reused across iterations.
	 */
	if (reuse < 0) {
		monet_cntxt[stk].reuse = stk;
	}

	/* Evaluate the command line parameters.
	 */
	argc = interpret_params(stk, params, argv+1, "batloop");
	if (!interpret_params_pin(argc, argv+1, "batloop"))
		return -1;
	argv[1] = argv[2];
	if (argc <= 1 || argv[1].vtype != TYPE_bat) {
		GDKerror("interpret_iterator: iterator should work on a BAT.\n");
		RETURN(-1);
	}
	ht = BAThtype(BBP_cache(argv[1].val.bval));
	tt = BATttype(BBP_cache(argv[1].val.bval));
	argv[2].vtype = TYPE_ptr;

	if (lt->token == TOK_ITERATOR) {
	/* Create the first iteration handle.
	 */
		char *name = lt->yyval.val.sval;
		/* Try all iterators by that name.  */	
		if (!(cmd = (int (*)(int, ValRecord *)) TBL_iterator(stk, name, argc+1, argv))) {
			char *signatures = (char*) alloca(8192);
			if (name) TBL_printsigs(signatures, stk, name);
			monet_sigerror("iterator", name?name:"name unknown",  
					name?signatures:"", argc+1, argv);
			RETURN(-1);
		} 
		lt->token = TOK_ITCOMPILED;
		lt->yyval.val.pval = (ptr) cmd;
		lt->yyval.vtype = TYPE_void;
		lt->yysons[3] = yynode(0, 0);

		/* Fill the iteration handle.
	 	*/
		handle = (Iteration) GDKmalloc(sizeof(ITrecord));
		handle->stk = stk;
		handle->res = res;
		handle->params = 0; handle->tree = 0;
		handle->parcnt = 0;
		handle->parmax = handle->parcap = 0;
	} else {
		handle = (Iteration) lt->yysons[1]->yyval.val.pval;
		cmd = (int(*)(int, ValRecord *)) lt->yyval.val.pval;
	}

	/* Fill in handle according to current circumstances 
   	 */

	if (parallel > handle->parcap) {
		/* Create more trees 
                 */
		iterator_maketrees(handle, body, parallel, ht, tt);

		/* Rearrange the tree: we make one structure of everything,
	 	 * and hang our created spaces into it as TYPE_str values,
	 	 * such that they will be destroyed later.
	 	 */ 
		lt->cnt = 5;
		lt->yysons[4] = handle->tree;
		lt->yysons[3]->yyval.vtype = TYPE_str;
		lt->yysons[1]->yyval.vtype = TYPE_str;
		lt->yysons[1]->yyval.val.pval = (ptr) handle;
		lt->yysons[3]->yyval.val.pval = (ptr) handle->params;
		handle->parcap = parallel;
	}
	handle->tuple_interpret = (int (*)(ptr, ptr, ptr)) interpret_fcn(ht, tt, parallel>1);
	handle->parmax = parallel;
	handle->status = 0;
	handle->h_len = BATatoms[ht].atomLen;
	handle->t_len = BATatoms[tt].atomLen;
	for(i=0; i<parallel; i++) { 
		handle->params[2*i].vtype = ht; 
		handle->params[2*i].len = ATOMsize(ht);
		handle->params[2*i+1].vtype = tt;
		handle->params[2*i+1].len = ATOMsize(tt);
	}

        /* Call the iterator.
         */
	argv[2].val.pval = handle;
        if ((i = (*cmd)(argc+1, argv)) >= 0) {
		i = handle->status;
	}

	/* Flush rest of parallel jobs.
	 */
	if (parallel > 1) {
		YYSTREE t;
		int i;

		/* limit tree size to handle->parcnt */
		for(t = handle->tree, i=handle->parcnt; t; 
			t = t->overflow, i-= YYMAXSONS)
		{
			t->cnt = MAX(0, MIN(YYMAXSONS,i));
		}
		
		@:par_interpret(handle)@

		i = handle->status;
	}

	/* clean up temporary space/bats, generated by parameter evaluation
         */
xit:	argv[2] = argv[1];
	argc = ABS(argc); 
	interpret_params_unpin(ABS(argc), argv+1, "batloop");
	CLEANUP(lt->yysons[1]);
        if (reuse < 0) {
                monet_cntxt[stk].reuse = reuse;
                CNTXTfree1(stk);
        }
	return i;
}


@- Sequential Iteration
Directly execute the body with head and tail substituted in. 

@= tuple_interpret
int tuple_interpret_@1@2_@3@4(
	ptr head, 
	ptr tail, 
	Iteration handle)
{
	assign_@2(handle->params[0].val, head);
	assign_@4(handle->params[1].val, tail);
 	len_@1@3(handle->params,handle);
	handle->status = interpret(handle->stk, handle->tree, handle->res);
	/* CATCHRET(handle->stk,handle->tree,handle->res,handle->status); */
	CLEANUP(handle->tree);
	return handle->status;
}
@

@- Parallel Iteration
Performing interpretation the iterator-body on a number of tuples
in parallel is a way of expressing data-parallelism. We prepare a
s = maximum number of M iteration bodies, and do M iterations to
obtain the first M tuples. They are then put into a parallel block,
and scheduled for execution. This step is repeated until all tuples
have been interpreted. 
The M is user-defined as in: <bat-expr>@[M]<iterator><stmt>
@c
@= par_collect
int par_collect_@1@2_@3@4(
	ptr	head,
	ptr	tail,
	Iteration handle)
{
	ValPtr params = handle->params+handle->parcnt+handle->parcnt;
	assign_@2(params[0].val, head);
	assign_@4(params[1].val, tail);
 	len_@1@3(params,handle);
	if (++handle->parcnt >= handle->parmax) {
		@:par_interpret(handle)@
		handle->parcnt = 0;
	}
	return handle->status;
}
@= par_interpret
	if (@1->parcnt > 0) {
		YYSTREE t;
		int i;

		for(t = @1->tree; t; t = t->overflow)
			for(i = 0; i < t->cnt; i++)
				t->yysons[i]->par_retval = 0; 	
		
		interpret_parblock(@1->stk, @1->tree, @1->res, 0);

		@1->status = 0;
		for(t = @1->tree; t; t = t->overflow)
			for(i = 0; i < t->cnt; i++)
				if (t->yysons[i]->par_retval < 0)
					@1->status = t->yysons[i]->par_retval;
	} 

@+ Profiler
The remainder consists of utilities for the dynamic profiler
The first part contains the administration needed for
filtering events. The number of filters is explicitly limited.
All events can be filtered by calling setProfilerFilter("*","*");
It also removes any previously defined filter patterns.
Pattern matching is limited to finding the string in the prefix
of the call.
@c
#ifdef HAVE_TIMES

#define MAXFILTER 16
static str filter[MAXFILTER][2];
static int filterlength[MAXFILTER][2];
static int filtertop=0;

int setProfilerFilter(str left, str right)
{
	int i;
	/*fprintf(stderr,"prepare filter %s %s\n",left,right);*/
	if( filtertop==MAXFILTER){
		GDKerror("Out of profile filter space");
		return GDK_FAIL;
	}
	if( profilerLock==NULL)
		profilerLock= MT_create_lock();
	MT_set_lock(profilerLock, "startProfiler");
	if( strcmp(left,"*")==0 && strcmp(right,"*")==0){
		for(i=0;i<filtertop;i++){
			if(filter[i][0]) GDKfree(filter[i][0]);
			if(filter[i][1]) GDKfree(filter[i][1]);
			filter[i][0]= NULL;
			filter[i][1]= NULL;
			filterlength[i][0]= 0;
			filterlength[i][1]= 0;
		}
		filtertop=0;
		MT_unset_lock(profilerLock, "startProfiler");
		return GDK_SUCCEED;
	}
	filter[filtertop][0]= GDKstrdup(left);
	if(strcmp(left,"*")==0)
		filterlength[filtertop][0]= 0; /* quick test */
	else 	filterlength[filtertop][0]= strlen(left);
	filter[filtertop][1]= GDKstrdup(right);
	if(strcmp(right,"*")==0)
		filterlength[filtertop][1]= 0; /* quick test */
	else 	filterlength[filtertop][1]= strlen(right);
	filtertop++;
	MT_unset_lock(profilerLock, "startProfiler");
	return GDK_SUCCEED;
}
static int tstpattern(str pattern, int len, str callee)
{
	char *s;
	s= strchr(callee, *pattern);
	if(s==0) return 0;
	return strncmp(pattern,s,len) == 0;
}
static int tstFilter(str caller, str callee)
{
	int i, cnt=0;
	if( strncmp(callee,"unknown",7)==0) return 0;
	if(filtertop==0) return 1;
	/*for(i=0;i<filtertop;i++){
		fprintf(stderr,"filter:%s %s\n", filter[i][0],filter[i][1]);
	} */
	for(i=0;i<filtertop;i++){
		cnt=0;
		if( filterlength[i][0]==0) cnt++;
		else cnt+= tstpattern(filter[i][0], filterlength[i][0], caller);
		if( cnt==0) continue;
		if( filterlength[i][1]==0) cnt++;
		else cnt+= tstpattern(filter[i][1], filterlength[i][1], callee);
		if(cnt>=2) return 1;
	}
	return 0;
}
@-
As a soon as an error occurs on the event stream we should abandon
any performance profiling.
@c

#define log(X,Y) if(eventstream && (stream_errnr(eventstream) \
		||  stream_printf(eventstream,X,Y)<0)){ \
		eventstream=0;\
		MT_unset_lock(profilerLock, "onlineProfilerEvent"); return;} 
#define log0(X) if(eventstream && (stream_errnr(eventstream) \
		|| stream_printf(eventstream,X)<0) ){ \
		eventstream=0;\
		MT_unset_lock(profilerLock, "onlineProfilerEvent"); return;} 
#define log2(X,Y,Z) if(eventstream && (stream_errnr(eventstream) \
		|| stream_printf(eventstream,X,Y,Z)<0) ){ \
		eventstream=0;\
		MT_unset_lock(profilerLock, "onlineProfilerEvent"); return;} 
#define flushLog() if(eventstream && stream_errnr(eventstream)){eventstream=0;\
	MT_unset_lock(profilerLock, "onlineProfilerEvent"); return;} \
	else stream_flush(eventstream); \
	if(eventstream && stream_errnr(eventstream)){eventstream=0;\
	MT_unset_lock(profilerLock, "onlineProfilerEvent"); return;} 

void onlineProfilerHeader(void)
{
	log0("# ");
	log0("caller,\t");
	log0("callee,\t");
	log0("ticks,\t");
	log0("clock,\t");
	log0("stmt,\t");
	log0("utime,\t");
	log0("cutime,\t");
	log0("stime,\t");
	log0("cstime,\t");
	log0("maxrss,\t");
	log0("arena,\t");
	log0("ordblks,\t");
	log0("smblks,\t");
	log0("hblkhd,\t");
	log0("hblks,\t");
	log0("fsmblks,\t");
	log0("uordblks,\t");
	log0("page reclaim,\t");
	log0("page faults,\t");
	log0("swaps,\t");
	log0("block reads,\t");
	log0("block writes,\t");
	log0("context switch,\t");
	log0("involunarty switch,\t");
	log0("event\t# name\n");
	flushLog();
}
static void quote(char *buf, int lim)
{
	char *tmp= GDKstrdup(buf);
	char *s=buf,*t=tmp, *sl=buf+lim-1;
	while(*t && s<sl){
		switch(*t){
		case '"': *s++ = '\\';
		default: *s++ =*t++;
		}
	}
	*s=0;
	GDKfree(tmp);
}

void onlineProfilerEvent(char *caller, long clk, long ticks, struct tms *timer, YYSTREE lt)
{
	static struct mallinfo prevMalloc;
	static struct rusage   prevUsage;
	static int eventcounter;
	struct tms newTms;
        struct mallinfo infoMalloc;
        struct rusage   infoUsage;
	char namebuf[1024];

	if( eventstream==0) return;
	if( delayswitch >0){
		/* first call to profiled */
		delayswitch--;
		return;
	}
	if( delayswitch==0){
		delayswitch= -1;
	} 
	MT_set_lock(profilerLock, "onlineProfilerEvent");
	if( showheader>0){
		onlineProfilerHeader();
		showheader--;
	}
	if(eventstream==NULL || stream_errnr(eventstream)){
		MT_unset_lock(profilerLock, "onlineProfilerEvent");
			eventstream=NULL;
			return;
	}
	/* generate actual call statement */
	namebuf[0]=0;
	yydeparseFunction(monet_clients,lt,namebuf,namebuf+1024);
	if( !tstFilter(caller,namebuf)) {
		MT_unset_lock(profilerLock, "onlineProfilerEvent");
		return;
	}

	times(&newTms);
	infoMalloc = MT_mallinfo();
	getrusage(RUSAGE_SELF,&infoUsage);

	/* steal a lock for re-use */
	/* make basic profile event tuple  */
	log0("[ ");
	
	/* get context of call */
	log("%s,\t", caller)
	quote(namebuf,256);
	log("\"%s\",\t",namebuf);

	log("%d,\t", ticks);
	log("%d,\t", clk);
	
	namebuf[0]=0;
	yydeparseCall(monet_clients,lt,namebuf,namebuf+256);
	quote(namebuf,256);
	log("\"%s\",\t",namebuf);
	
	log("%d,\t", newTms.tms_utime - timer->tms_utime);
	log("%d,\t", newTms.tms_cutime - timer->tms_cutime);
	log("%d,\t", newTms.tms_stime - timer->tms_stime);
	log("%d,\t", newTms.tms_cstime - timer->tms_cstime);

	log("%d,\t",infoUsage.ru_maxrss);
	log("%d,\t", infoMalloc.arena-prevMalloc.arena);
	log("%d,\t", infoMalloc.ordblks-prevMalloc.ordblks);
	log("%d,\t", infoMalloc.smblks-prevMalloc.smblks);
	log("%d,\t", infoMalloc.hblkhd-prevMalloc.hblkhd);
	log("%d,\t", infoMalloc.hblks-prevMalloc.hblks);
	log("%d,\t", infoMalloc.fsmblks-prevMalloc.fsmblks);
	log("%d,\t", infoMalloc.uordblks-prevMalloc.uordblks);
	prevMalloc = infoMalloc;
	
	log("%d,\t", infoUsage.ru_minflt- prevUsage.ru_minflt);
	log("%d,\t", infoUsage.ru_majflt- prevUsage.ru_majflt);
	log("%d,\t", infoUsage.ru_nswap- prevUsage.ru_nswap);
	log("%d,\t", infoUsage.ru_inblock- prevUsage.ru_inblock);
	log("%d,\t", infoUsage.ru_oublock- prevUsage.ru_oublock);
	log("%d,\t", infoUsage.ru_nvcsw- prevUsage.ru_nvcsw);
	log("%d,\t", infoUsage.ru_nivcsw- prevUsage.ru_nivcsw);
	prevUsage = infoUsage;
	
	log("%d ]\n",eventcounter);
	eventcounter++;
	if (eventstream && stream_flush(eventstream))
		eventstream = 0; 
	MT_unset_lock(profilerLock, "onlineProfilerEvent");
}

#else

int setProfilerFilter(str left, str right)
{
	(void) left;
	(void) right;
	GDKerror("No profiler support");
	return GDK_FAIL;
}

#endif /* HAVE_TIMES */
