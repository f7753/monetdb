@f monet_context
@a M. L. Kersten, P. Boncz

@* Monet variables
The Monet name space is a three-level hierarchy of variables with a value binding.
The root is formed by the context created at server start, i.e. client 0. 
The next layer is bound to a client session, the lowest layer deals 
with dynamic context. This layering reflects a static scope structure a 
la C.

The context structures are collected in a table. The first entries
are reserved for a session context per client.

The stack forms a potential shared resource. Several threads may inspect
it to find an entry and to update it. To synchronize access, a global
lock is currently used for gaining exclusive access.
The implementation is optimistic in the sense that once an entry has been
located it is privately used. This assumes the implementation of detecting
duplicate identifier use in parallel blocks!

A variable binding may become CONSTANT for the duration of its
life time, or the type can be FROZEN.
@h
#ifndef _MONET_CNTXT_H_
#define _MONET_CNTXT_H_
#include "monet.h"


typedef struct VARSTRUCT{
        ValRecord   binding;	/* value,type */
        struct VARSTRUCT *next;
        bit	constant;	/* value cannot change */
        bit	frozen;		/* type cannot change */
        char    name[1];	/* variable name (var lengths) */
} *Variable, VarRecord;

typedef struct CNTXT {
	Variable var;
	Cntxt   outer;	/* where to look next */
	Cntxt   next;	/* for making chains */
	bit 	shadow;	/* shadow stk; do everything in outer */
	bit 	used;	/* in use or not */
	short 	reuse;	/* can be reused in a next iteration */
} CntxtRec;

m_export CntxtRec* monet_cntxt;

m_export void	CNTXTinit    ();
m_export Cntxt	CNTXTnew     (Cntxt outer);
m_export Cntxt	CNTXTreserve (Cntxt outer);
m_export void	CNTXTclear   (Cntxt i);
m_export void	CNTXTfree    (Cntxt stk, Client c);
m_export void	CNTXTdelete  (Cntxt i);
m_export int	CNTXTclient  (Cntxt i, Client *c);

#define CNTXTuse(stk)		monet_cntxt[stk].used = 1;
#define CNTXTfree2(stk,c)	if	(c->maxstk != stk) CNTXTfree(stk,c)
#define CNTXTfree1(stk)		{	Client c; CNTXTclient(stk, &c);\
						    CNTXTfree2(stk,c); }

m_export Variable	VARfind      (Cntxt *stk, str scope);
m_export Variable	VARnew       (Cntxt stk, str name);  
m_export int 	VARpurge     (int nbats, int* bats, int natoms, int* atoms);

#define VARclearBAT(B)	if(B) VARpurge(1, &(B)->batCacheid, 0, NULL)
#define VARfreeze(X)	if(X){X->frozen=TRUE;}
#define VARfixate(X)	if(X){X->constant=TRUE;}

m_export int monet_cntxtmax;
m_export int monet_cntxtlim;

#endif /* _MONET_CNTXT_H_ */
@c
#include "monet.h"

int monet_cntxtmax = 200*MAXCLIENTS;
int monet_cntxtlim = 1024*1024;
Cntxt monet_cntxtcur = MAXCLIENTS;
CntxtRec *monet_cntxtbuf = NULL, *monet_cntxt = NULL;

void CNTXTinit() {
    monet_cntxtlim = MAX(monet_cntxtmax+1,monet_cntxtlim); 

    /* alloc cntxt space; try to reserve as much space as possible */
    while(TRUE) {
        size_t size = (monet_cntxtmax+1)*sizeof(CntxtRec);
        size_t maxsize = monet_cntxtlim*sizeof(CntxtRec);

        monet_cntxtbuf = (CntxtRec*) GDKvmalloc(size, &maxsize);
        if (monet_cntxtbuf && maxsize >= (size_t) (monet_cntxtlim*sizeof(CntxtRec))) {
		monet_cntxtlim = maxsize / sizeof(CntxtRec);
                break;
        }
        if (monet_cntxtbuf) GDKvmfree(monet_cntxtbuf, size, maxsize);
        if ((monet_cntxtlim/=2) < monet_cntxtmax+1) {
            GDKfatal("CNTXTinit: could not alloc arena\n");
        }
    } 
    memset(monet_cntxtbuf, 0, (monet_cntxtmax+1)*sizeof(CntxtRec));
    monet_cntxt = monet_cntxtbuf + 1;
}


int CNTXTrealloc(flt factor) {
    /* extend the VM region; make it start at the same base address */
    size_t oldsize = monet_cntxtmax+1;
    size_t newsize = oldsize*factor;
    size_t maxsize = MAX(newsize,(size_t) monet_cntxtlim)*sizeof(CntxtRec);
    CntxtRec* p = (CntxtRec*) GDKvmrealloc(monet_cntxtbuf, oldsize*sizeof(CntxtRec), 
					newsize*sizeof(CntxtRec), maxsize, &maxsize);
    if (p == NULL || p != monet_cntxtbuf) {
	if (p) GDKvmfree(p, oldsize*sizeof(CntxtRec), maxsize);
	GDKerror("CNTXTrealloc(): out of context space\n");
	return FALSE;
    }
    memset(monet_cntxtbuf+oldsize, 0, (newsize-oldsize)*sizeof(CntxtRec));
    monet_cntxtmax = newsize-1;
    monet_cntxtlim = maxsize/sizeof(CntxtRec);
    return TRUE;
}

@- 
Initialize a new context for a particular user. The non-used
context records are linked through the outer field. This way
we can get a new context in 'constant' time.
The context structure is a shared resource and protected with 
the @%monet_contextLock@.
@c
int CNTXTclient(Cntxt stk, Client* c){
	int depth = 0;	
	while(stk >= MAXCLIENTS) {
		depth++;
		stk = monet_cntxt[stk].outer;
	}
	*c = monet_clients+stk;
	return depth;
}


Cntxt CNTXTnew(Cntxt outer){
	int i;

	MT_set_lock(monet_contextLock, "CNTXTnew");
	if (monet_cntxtcur >= monet_cntxtmax && !CNTXTrealloc(BATMARGIN)) {
		MT_unset_lock(monet_contextLock, "CNTXTnew");
		return 0;
	}
	i = monet_cntxtcur;
	monet_cntxtcur = monet_cntxt[i].next;
	if (!monet_cntxtcur) monet_cntxtcur = i+1;
	monet_cntxt[i].shadow = 0;
	monet_cntxt[i].used = 1;
	monet_cntxt[i].reuse = monet_cntxt[outer].reuse;
	monet_cntxt[i].next = 0;
	monet_cntxt[i].outer = outer;
	MT_unset_lock(monet_contextLock, "CNTXTnew");
	return i;
}

Cntxt CNTXTreserve(Cntxt outer) {
	Client	c;
	int i;

	CNTXTclient(outer, &c);

	MT_set_lock(monet_contextLock, "CNTXTreserve");
	if (monet_cntxtcur >= monet_cntxtmax && !CNTXTrealloc(BATMARGIN)) {
		MT_unset_lock(monet_contextLock, "CNTXTnew");
		return 0;
	}
	i = monet_cntxtcur;
	monet_cntxtcur = monet_cntxt[i].next;
	if (monet_cntxtcur < MAXCLIENTS) monet_cntxtcur = i+1;
	monet_cntxt[i].outer = outer;
	monet_cntxt[i].next = c->maxstk;
	monet_cntxt[i].reuse = monet_cntxt[outer].reuse;
	c->maxstk = i; 
	MT_unset_lock(monet_contextLock, "CNTXTreserve");
	return i;
}
@-
The free operation throws away contexts. They go onto the free context 
(monet_cntxtcur). Freeing a context also means doing away with all variable records. 
In parallel execution, I discovered that contexts between maxstk and stk  may ideed still be 
in use in parallel worker threads. We must keep them and adapt 
@c
void CNTXTdelete(Cntxt cur){
	Variable w, v = monet_cntxt[cur].var;
	for(monet_cntxt[cur].var = 0; v ; v= w) {
		w = v->next;
		GDKfree(v);
	}
	monet_cntxt[cur].reuse = -1;
}

void CNTXTfree(Cntxt stk, Client c){
	Cntxt keep_first = -1, del_first = -1;
	Cntxt keep_last = -1, del_last = -1;
	Cntxt cur;

	MT_set_lock(monet_contextLock, "CNTXTfree");
	for(cur = c->maxstk; cur != stk; cur = monet_cntxt[cur].next) {
		if (monet_cntxt[cur].used == 0 && (monet_cntxt[cur].reuse < 0 
			|| monet_cntxt[monet_cntxt[cur].reuse].reuse < 0))
		{
			CNTXTdelete(cur);
			if (del_first < 0) del_first = cur;
			if (del_last >= 0) monet_cntxt[del_last].next = cur;
			del_last = cur;
		} else {
			if (keep_first < 0) keep_first = cur;
			if (keep_last >= 0) monet_cntxt[keep_last].next = cur;
			keep_last = cur;
		}
       	}
	if (del_last >= 0) {
       		monet_cntxt[del_last].next = monet_cntxtcur;
		monet_cntxtcur = del_first;
	}
	if (keep_last >= 0) {
		monet_cntxt[keep_last].next = stk;
		c->maxstk = keep_first;
	} else {
		c->maxstk = stk;
	}
	MT_unset_lock(monet_contextLock, "CNTXTfree");
}
@-
A context is cleared by removing the variable bindings.
@c
void CNTXTclear(Cntxt stk){
        Variable w, v = monet_cntxt[stk].var;
        
       	while (v) {
       		w = v->next;
		ATOMunfix(v->binding.vtype, VALptr(&v->binding));
		VALclear(&v->binding);
		v = w;
       	}
       	monet_cntxt[stk].used = 0;
}

@-
A variable is initialized as an integer 0 and made accessible through
a context.
The value structure can be cleared with VALclear, it releases the BAT.
Variables are stored in the context on a last in first searched policy.
@c
Variable VARnew(Cntxt stk, str name){
	Variable v;
	int	i;
	

	i = strlen(name);
	v = (Variable) GDKmalloc(sizeof(VarRecord)+i);
	v->binding.vtype = TYPE_int;
	v->binding.val.ival = 0;

	strncpy(v->name, name, i);
	v->name[i] = 0;
	v->constant = 0;
	v->frozen = 0;

	MT_set_lock(monet_contextLock, "VARnew");
	while(monet_cntxt[stk].shadow) stk = monet_cntxt[stk].outer;
	v->next = monet_cntxt[stk].var;
	monet_cntxt[stk].var = v;
	MT_unset_lock(monet_contextLock, "VARnew");
	return v;
}
@
@-
The routine @%VARfind@ dereferences a name to find the variable descriptor.
Both the local and global stack is inspected. If it is not found then 
an attempt is made to load a BAT from disk.
@c
Variable VARfind(Cntxt *stk, str nme){
        Variable v;
	int i, s = *stk;

        if (nme == NULL) {
                return 0;
        }
	do {
		i = s;
	        for (v = monet_cntxt[i].var; v; v = v->next) {
        	        if (*nme == *v->name && strcmp(nme, v->name) == 0) {
				*stk = s;
                	        return v;
               		}
		}
		s = monet_cntxt[i].outer;
	} while(i >= 0);

        return 0;
}


@-
The BATs are referenced by index from the variable table. This means
that once the BAT is removed, we should clear all such references to
avoid access to unknown bats. This is done silently to avoid confusion
about errors.
@c
int VARpurge(int nbats, int *bats, int natoms, int *atoms){
	int i, j, *dst = (int*) alloca((1+natoms)*sizeof(int));
	Variable v;

	if (nbats == 0 && natoms == 0) return 0;

	for(i=0; i<natoms; i++) {
		dst[i] = ATOMstorage(atoms[i]);
		if (dst[i] > TYPE_str) dst[i] = 0; 
	}
	for(i=0; i<nbats; i++) {
		if (bats[i] < 0)  bats[i] = -bats[i];
	}

	for (j = 0; j < monet_cntxtmax; j++) if (monet_cntxt[j].used)
	for (v = monet_cntxt[j].var; v; v = v->next) {
		int tpe = v->binding.vtype;
		if (tpe == TYPE_bat) {
			int bid = ABS(v->binding.val.bval);
			for(i=0; i<nbats; i++) 
				if (bats[i] == bid) {
				    v->binding.vtype = TYPE_int; 
				    break;
				}
		} else if (tpe > TYPE_str) {
			for(i=0; i<natoms; i++) 
		        if (atoms[i] == tpe) {
				if (dst[i]) {
				    v->binding.vtype = dst[i];
				} else {
				    if (ATOMextern(tpe)) {
					GDKfree(v->binding.val.pval);
				    }
				    v->binding.vtype = TYPE_int; 
	   			    v->binding.val.ival = int_nil;
				}
				break;
			}
		}
	}
	for(i=0; i<nbats; i++) {
		BAT* b = BBPcache(bats[i]);
		if (b != NULL) BBPreclaim(b);
	}
	return 0;
}
@
