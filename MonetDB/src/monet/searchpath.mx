@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@' 
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@' 
@' The Original Code is the Monet Database System.
@' 
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2003 CWI.
@' All Rights Reserved.
@' 
@' Contributor(s):
@' 		Martin Kersten <Martin.Kersten@cwi.nl>
@' 		Peter Boncz <Peter.Boncz@cwi.nl>
@' 		Niels Nes <Niels.Nes@cwi.nl>
@' 		Stefan Manegold  <Stefan.Manegold@cwi.nl>

@f searchpath
@a Florian Waas
@v 1.0
@t Handling of Module Search Path

@h
#ifndef _searchpath_H
#define _searchpath_H

#include <monet_utils.h>
#include "monet.h"
#include <gdk_storage.h>

#ifndef SO_EXT
#define SO_EXT ".so"
#endif

/* 
 * prototypes 
 *
 */

/* rewind list cursor and initialize the list if not done yet */
void MSP_rewind_module_list(void);

/* search for module and return the complete path */
char *MSP_locate_module(char *);

/* return next module found in the list */
char *MSP_next_module(void);

#endif
@c
#include "searchpath.h"

#ifdef HAVE_SYS_PARAM_H
#include <sys/param.h>
#endif

static size_t SO_EXT_LEN;	/* length of SO_EXT string, will be
				   filled in before use */

struct moddir {
    char *path;
    struct moddir *next;
};

static struct moddir *moddir_list=0;

static void print_moddir_list(void) {
    struct moddir *entry=moddir_list;
    while(entry)
        {
            printf("list: %s\n",entry->path);
            entry=entry->next;
        }
}

static 
void insert_moddir_entry(char *name) {
    struct moddir *last=moddir_list;
    struct moddir *newentry=(struct moddir*)GDKmalloc(sizeof(struct moddir));

    if (!strlen(name)) return;
/*    printf("inserted dir %s\n",name);*/
    
    if (moddir_list)
        {
            while(last->next) last=last->next;
            last->next=newentry;
        }
    else moddir_list=newentry;

    newentry->path=(char *)GDKmalloc(strlen(name)+1);
    strcpy(newentry->path,name);
    newentry->next=0;
}


static 
void insert_moddir_recursively(char *name) {
    DIR *dirp;
    struct dirent *dent=0;
    char fullname[MAXPATHLEN];

/*    printf("rec %s\n",name); */
    
    if (strlen(name)>2 && !strcmp(&name[strlen(name)-2],"//"))
        name[strlen(name)-2]='\0';
    
    dirp=opendir(name);
    if (!dirp) return;
    rewinddir(dirp);
    insert_moddir_entry(name);
    while((dent=readdir(dirp))!=0)
        {
            if (dent->d_name[0]=='.') continue;
            sprintf(fullname,"%s%c%s",name,DIR_SEP,dent->d_name);
            insert_moddir_recursively(fullname);
        }
    closedir(dirp);
}

static 
void parse_mod_path(void) {
    char *mod_path = GDKstrdup(GDKgetenv("monet_mod_path"));

    if (mod_path){
      size_t pos=0, len=strlen(mod_path);
      char *dirbegin=mod_path;
      do
        {
            while(mod_path[pos]!='\0' && mod_path[pos]!=PATH_SEP) pos++;
            mod_path[pos]='\0';

            if (strlen(dirbegin)>2 && !strcmp(&mod_path[pos-2],"//"))
                insert_moddir_recursively(dirbegin);
            else                    
                insert_moddir_entry(dirbegin);

            if (pos==len) break;
            dirbegin = mod_path + (++pos);
        }
      while(1);
    }
    GDKfree(mod_path);
}

static struct moddir *current_entry=0;
static DIR *dirp=0;

void MSP_rewind_module_list(void) {
    if (!moddir_list) parse_mod_path();
    current_entry=moddir_list;
    if(dirp) closedir(dirp);
    dirp=0;
}
    
char *MSP_next_module(void) {
    struct dirent *dent=0;
    char *next_module;

    while(current_entry)
        {
            if (!dirp)
                {
                    dirp=opendir(current_entry->path);
                    if (!dirp)
                        {
                            current_entry=current_entry->next;
                            continue;
                        }
                    rewinddir(dirp);
                }
            while((dent=readdir(dirp))!=0)
                {
                    char *suffix=0;
                    if ((suffix=strstr(dent->d_name,SO_EXT))==0 || 
		       	 strncmp(dent->d_name,"lib_",4)!=0) continue; 
		    /*
		     * On some platforms (e.g., MacOS X/Mach-O/Darwin), 
		     * a library's version number (e.g., ".0"/".0.0.0")
		     * is not appended to the suffix, but rather placed
		     * between the library's name and suffix; however,
		     * we only want to match "lib_<name><SO_EXT>", here,
		     * but not "lib_<name><version><SO_EXT>":
		     */
		    if (((suffix-2)>=dent->d_name) &&
		        (suffix[-2]=='.')          &&
		       	(suffix[-1]>='0')&&(suffix[-1]<='9')) continue; 
                    suffix[0]='\0';
                    next_module=(char *)GDKmalloc(strlen(current_entry->path)+
                                               strlen(dent->d_name)+2);
                    sprintf(next_module,"%s%c%s", 
                            current_entry->path, DIR_SEP, dent->d_name);
                    return(next_module);
                }
            current_entry=current_entry->next;
            closedir(dirp);
            
            dirp=0;
        }
    return 0;
}

#define LIBLEN	4
static char *MSP_libname( char *name ){
    char *libname = (char*)GDKmalloc( strlen(name) + LIBLEN + 1 );
    strcpy(libname, "lib_");
    strcpy(libname+LIBLEN, name);
    return libname;
}

char *MSP_locate_module(char *mod_name) {
    char *name = MSP_libname( mod_name ); 
    size_t len = strlen(name);
    size_t fulllen = 0;
    char *next_module,*fullname;
    MSP_rewind_module_list();
    for (;;)
        {
            next_module=MSP_next_module();
            if (!next_module) break;
	    fulllen = strlen(next_module);
            if ( fulllen > len &&
		 next_module[fulllen-len-1] == DIR_SEP &&
		 !strcmp(&next_module[fulllen-len],name))
                {
		    if (!SO_EXT_LEN)
			SO_EXT_LEN = strlen(SO_EXT);
                    fullname=(char *)GDKmalloc(fulllen+SO_EXT_LEN+1);
                    sprintf(fullname,"%s%s",next_module, SO_EXT);
                    GDKfree(next_module);
                    GDKfree(name);
                    return fullname;
                }
	    GDKfree(next_module);
        }
    GDKfree(name);
    return 0;
}
