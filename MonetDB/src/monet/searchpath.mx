@f searchpath
@a Florian Waas
@v 1.0
@t Handling of Module Search Path

@h
#ifndef _searchpath_H
#define _searchpath_H

/* name of the environment variable */
#define MONET_MSP	"MONET_MOD_PATH"

#ifdef MSP_MAIN
#define GDKfree(x)	free(x)
#define GDKmalloc(x)	malloc(x)
#else 
#include "monet.h"
#endif

#ifndef SO_EXT
#define SO_EXT ".so"
#endif
/* 
 * prototypes 
 *
 */

/* rewind list cursor and initialize the list if not done yet */
void MSP_rewind_module_list();

/* search for module and return the complete path */
char *MSP_locate_module(char *);

/* return next module found in the list */
char *MSP_next_module();

#endif
@c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#ifdef HAVE_SYS_PARAM_H
#include <sys/param.h>
#endif

#include "searchpath.h"

struct moddir {
    char *path;
    struct moddir *next;
};

static struct moddir *moddir_list=0;

static void print_moddir_list() {
    struct moddir *entry=moddir_list;
    while(entry)
        {
            printf("list: %s\n",entry->path);
            entry=entry->next;
        }
}

static 
void insert_moddir_entry(char *name) {
    struct moddir *last=moddir_list;
    struct moddir *newentry=(struct moddir*)GDKmalloc(sizeof(struct moddir));

    if (!strlen(name)) return;
/*    printf("inserted dir %s\n",name);*/
    
    if (moddir_list)
        {
            while(last->next) last=last->next;
            last->next=newentry;
        }
    else moddir_list=newentry;

    newentry->path=(char *)GDKmalloc(strlen(name)+1);
    strcpy(newentry->path,name);
    newentry->next=0;
}


static 
void insert_moddir_recursively(char *name) {
    DIR *dirp;
    struct dirent *dent=0;
    char fullname[MAXPATHLEN];

/*    printf("rec %s\n",name); */
    
    if (strlen(name)>2 && !strcmp(&name[strlen(name)-2],"//"))
        name[strlen(name)-2]='\0';
    
    dirp=opendir(name);
    if (!dirp) return;
    rewinddir(dirp);
    insert_moddir_entry(name);
    while((dent=readdir(dirp))!=0)
        {
            if (dent->d_name[0]=='.') continue;
            sprintf(fullname,"%s%c%s",name,DIR_SEP,dent->d_name);
            insert_moddir_recursively(fullname);
        }
    closedir(dirp);
}


char empty_path = 0;

static 
void parse_mod_path() {
    char *mod_path, *dirbegin;
    int pos=0,len;
    
    mod_path=getenv(MONET_MSP);
    if (!mod_path) mod_path = getenv("LD_LIBRARY_PATH");
    if (!mod_path) mod_path = &empty_path;
    len=strlen(mod_path);
    dirbegin=mod_path;
    do
        {
            while(mod_path[pos]!='\0' && mod_path[pos]!=PATH_SEP) pos++;
            mod_path[pos]='\0';

            if (strlen(dirbegin)>2 && !strcmp(&mod_path[pos-2],"//"))
                insert_moddir_recursively(dirbegin);
            else                    
                insert_moddir_entry(dirbegin);

            if (pos==len) break;
            dirbegin = mod_path + (++pos);
        }
    while(1);
}

static struct moddir *current_entry=0;
static DIR *dirp=0;

void MSP_rewind_module_list() {
    if (!moddir_list) parse_mod_path();
    current_entry=moddir_list;
    if(dirp) closedir(dirp);
    dirp=0;
}
    
char *MSP_next_module() {
    struct dirent *dent=0;
    char *next_module;

    while(current_entry)
        {
            if (!dirp)
                {
                    dirp=opendir(current_entry->path);
                    if (!dirp)
                        {
                            current_entry=current_entry->next;
                            continue;
                        }
                    rewinddir(dirp);
                }
            while((dent=readdir(dirp))!=0)
                {
                    char *suffix=0;
                    if ((suffix=strstr(dent->d_name,SO_EXT))==0 || 
		       	 strncmp(dent->d_name,"lib_",4)!=0) continue; 
                    suffix[0]='\0';
                    next_module=(char *)GDKmalloc(strlen(current_entry->path)+
                                               strlen(dent->d_name)+2);
                    sprintf(next_module,"%s%c%s", 
                            current_entry->path, DIR_SEP, dent->d_name);
                    return(next_module);
                }
            current_entry=current_entry->next;
            closedir(dirp);
            
            dirp=0;
        }
    return 0;
}

#define LIBLEN	4
static char *MSP_libname( char *name ){
    char *libname = (char*)GDKmalloc( strlen(name) + LIBLEN + 1 );
    strcpy(libname, "lib_");
    strcpy(libname+LIBLEN, name);
    return libname;
}

char *MSP_locate_module(char *mod_name) {
    char *name = MSP_libname( mod_name ); 
    int len = strlen(name);
    int fulllen = 0;
    char *next_module,*fullname;
    MSP_rewind_module_list();
    while(1)
        {
            next_module=MSP_next_module();
            if (!next_module) break;
	    fulllen = strlen(next_module);
            if ( next_module[fulllen-len-1] == DIR_SEP &&
		 !strcmp(&next_module[fulllen-len],name))
                {
                    fullname=(char *)GDKmalloc(fulllen+4);
                    sprintf(fullname,"%s%s",next_module, SO_EXT);
                    GDKfree(next_module);
                    GDKfree(name);
                    return fullname;
                }
	    GDKfree(next_module);
        }
    GDKfree(name);
    return 0;
}

#ifdef MSP_MAIN
int main(int argc, char **argv) {
    char *name;

    MSP_rewind_module_list();
    print_moddir_list();
    
    
    while(1)
        {
            name=MSP_next_module();
            if (!name) 
                {
                    break;
                }
            
            printf("%s\n",name);
        }
    printf("%s\n",MSP_locate_module("algebra"));
    return 0;
}
#endif  
