@f monet
@T
% define titlepage
@t The Monet Database System
@v Version 4.1 
@a Martin L. Kersten & Peter Boncz

% create table of contents 
\newpage
\tableofcontents
\newpage
 
@* Monet
The Goblin Database Kernel library is complemented by a textual interface, 
called @%Monet@.  This interface is easy to interpret, versatile and 
flexible to accommodate system debugging and application tool development.
Although a textual interface potentially leads to a performance degradation, 
our experience with earlier systems, e.g. Troll and PRISMA,
showed that the overhead can be kept within acceptable limits.
Moreover, a textual interface reduces the programming
effort otherwise needed to develop test and application programs.
@T
    \begin{figure}[hbt]
        \mbox{\hspace{120pt}\epsffile{monet.eps}}\\
        \caption{The Monet Modules}
    \end{figure}

The above figure shows the different components of the Monet system. The
{\tt processes} module offers support for single- and multi-threading. 
In single-thread mode the server cycles through the request queue and
processes MIL statements.
In multi-thread mode, the interpreter thread runs independent of the
initial thread. Moreover, a thread is started to accepts requests from the
internet. Each client can indicate the interpreter to interact with.
For example, one can envision a thread dedicated to the parsing and execution
of SQL statements.

The {\tt queue} contains the parsed user request. It 
synchronizes (multiple) workers by locking. The {\tt interface} module
implements the interface to database clients. The {\tt lex/parser}
module converts requests into parse trees.
Those parse trees can be executed by the {\tt interpreter} module, which
invokes basic BAT algebra commands from the {\tt commands} module. There is
a {\tt procedures} module to load and execute user-defined procedures.

In the lower level modules there is support for event {\tt triggers},
temporary {\tt variables} management, and {\tt dynamic loading} of
routines. These parts of the system are still under development.

@+ Critical sections and semaphores
Monet is implemented as a collection of threads. This calls for extreme
care in coding. At several places locks and semaphores are necessary
to achieve predictable results. In particular, after they are created
and when they are inspected or being modified to take decisions.
 
In the current implementation the following list of locks and semaphores
is used:
@T
\begin{tabular}{|l | l | l |}\hline
Name & Used in & Protects\\
GDKthreadLock   & GDKinit       & {\em created }\\
                & GDKexit       & GDKnrofthreads\\
                &  dumplocktable & {\em inspected}\\
                &  THRget       & GDKthreads\\
                &  THRnew       & GDKnrofthreads, GDKthreads\\
                &  THRdel       & GDKnrofthreads\\
                &  THRkill      & GDKnrofthreads\\\hline
GDKcacheLock    & BBPdir        & BBPlogical, BBPphysical, BBPstatus,
                                  BBPcache, BBPsize, BBPrefs\\
                & BBPenter      & BBPlogical, BBPphysical, BBPstatus, \\
                &               & BBPcache, BBPsize, BBPrefs, BBPlimit,\\
 
                &               & BBPcachestore\\
                & BBPclear      & BBPlogical, BBPphysical, BBPstatus,
                                  BBPrefs\\
                & BBPuncacheit  & BBPcache \\\hline
monet_critical          & monet.mx      & {\em created  }\\
                & clrRequest    & QMrequests, qm_first, qm_last, qm_top, qm_bot\
\
monet_contextLock       & monet.mx      & {\em created  }\\
                & CNTXTfree     & monet_cntxt monet_cntxtcur\\
                & CNTXTnew      & monet_cntxt monet_cntxtcur\\
                & CNTXTreserve  & monet_cntxt monet_cntxtcur\\
                & VARnew        & monet_cntxt\\\hline
monet_parserLock        & monet_init    & {\em created  }\\
                & parserEntry & ll_client and parser\\
                & parserExit &  ll_client and parser\\
monet_notifyLock        & monet_init    & {\em created  }\\
                & CMDstop & (trigger) notifiers \\
TBL_readLock    & monet_tbl.mx  & {  }\\
TBL_writeLock   & monet_tbl.mx  & {  }\\\hline
monet_started   & monet_init    & {\em created}\\
                & main          & {\em down for Internet Thread}\\
                & monetServer   & {\em up for Internet Thread\\\hline
monet_available & monet_init    & {\em created}\\
                & clrRequest    & QMrequests, qm_first, qm_last, qm_top, qm_bot\\
                & wakeupRequest & {\em up for available MIL request}\\
                & getRequest & {\em down to get request from queu}
                &               & {\em up to signal available requests}\\\hline
\end{tabular}
 
@T
\begin{verbatim}
Some conclusions:
- BBPcache is also used in BBPdummy, BBPexit, BBPcacheit
- BBPsize is used in many places outside the buffer pool
- BBPlogical and BBPphysical is not protected in BBPrename
- BBPcachestore should become a local variable in BBPextend.
- BBPclear e.d. test on BBPsize should be in critical section always.
- BBPclear should include copy of BBPuncacheit in critical section
- qm_last is not always used in critical section
- monet_cntxt is also used in CNTXTclient, CNTXTdelete, VARfind, CARclearBAT
  and closeClient, CMDvars, CMDconstant, CMDfreeze, CMDbackground,
      CMDscope, CMDvars, interpret_assignment (Are these all safe?)
\end{verbatim}

@{
@+ Monet Basic Definitions 
Definitions that need to included in every file of the Monet system,
as well as in user defined module implementations.
@h
#ifndef _MONET_H_
#define _MONET_H_

#include "gdk.h"

#ifdef _MSC_VER
#ifndef LIBMONET
#define m_export extern __declspec(dllimport) 
#else
#define m_export extern __declspec(dllexport) 
#endif
#else
#define m_export extern 
#endif

#define BUNtailfnd(tp,	bt, bn, vl)                              \
		  ((bn=BUNfnd(bt, vl))?(tp *) BUNtail(bt,bn):0) 
#define BUNtailptr(tp,	bt, bn, id)                              \
                  ((tp *) BUNtail(bt, (bn=BUNptr(bt, id))))
#define BUNheadptr(tp,	bt, bn, id)                              \
                  ((tp *) BUNhead(bt, (bn=BUNptr(bt, id))))

#define MONET_ENV1	"MONETFARM"
#define MONET_ENV2	"MONETHOME"
#define DBHOMES	"homes"
#define MONET_MODDIR	"mod"
#define MONET_ADMIN	"adm"
 
@- ValPtr Records
When manipulating values, Monet puts them into value records.
The built-in types have a direct entry in the union. Others should 
be represented as a pointer of memory in pval or as a string, which
is basically the same. In such cases the @%len@ field indicates
the size of this piece of memory.

Monet Extenders will use value records for passing parameters to
their new operators. Monet algebraic commands receive an 
(argc, argv) combination, where
argc is an integer indicating the size of the the argv array of value 
records. On call, the first record, argv[0], is always empty. The
routine must place its return value - if any - there. The other
values are the parameters.
@h
typedef struct {
	bat	id;
	int	stamp;
} batrec;

typedef struct {
	union {                 /* storage is first in the record */
		int	ival;
		oid	oval;
		sht	shval;
		chr	cval[4];
		flt	fval;
		ptr	pval;
		bat	bval;
		batrec	br;	/* bval + stamp */
		str    	sval;
		dbl	dval;
		lng	lval;
	} val;
	int 		vtype;
	int 	       	len;
} *ValPtr, ValRecord;

#define VALptr(v) (ATOMextern((v)->vtype)?(v)->val.pval:(ptr)&(v)->val.ival)

m_export ValPtr 		VALnew	    ();
m_export ValPtr 		VALset      (ValPtr v, int t, ptr p);
m_export void 		VALempty    (ValPtr v);
m_export ValPtr 		VALcopy	    (ValPtr dst, ValPtr src);
m_export int             VALformat   (char** buf, ValPtr v);
m_export ptr 		VALconvert  (int typ, ValPtr v,int silent);
m_export void            VALclear    (ValPtr v);
m_export int             VALprint    (FILE* fd, ValPtr v);

#define ILLEGALVALUE	((ptr)-1)
#define MAXPARAMS	32

@- Parse Trees
MIL blocks get parsed into parse trees. The exact form is not important here,
as programmers will not need to manipulate parse trees directly.
@h
#define YYMAXSONS 	11	

typedef struct YYS {
        ValRecord       yyval;
        struct YYS      *yysons[YYMAXSONS];
        struct YYS      *overflow, *last, *next;
        union {
                ptr     atmref;
                batrec  batref;
		oid	yyid;
        } free;
	unsigned short  cnt:6, token:10;     
	unsigned short  dealloc;
} yystree, *YYSTREE;

#define YYDEALLOC_BAT	1
#define YYDEALLOC_VAL	2 

#ifndef YYSTYPE
#define YYSTYPE	YYSTREE
#endif

#define arg(T,	I)       ((T)->yysons[I])

#include "monet_parse_tab.h"  /* needed for lex */

@- Iteration Records

The iterator is a cursor-like construct, that according to some predicate
selects some BUNs out of a BAT. It takes them one by one, and executes a
piece of MIL for each BUN, substituting head and tail value as $1 and $2
respectively in the MIL block. MIL has a special syntactic form
for this: [bat-expression] @ [iterator] ( [params] ) [MIL-statement]
@
An example would be:
@
b@batloop() printf("[ %d %d ]\n", $1, $2);
@
which prints a BAT of decimal values. The MIL executing is done in the 
Monet Interpreter. Standard iterators are @%CMDbatloop@ and  @%CMDhashloop@. 
Iterators can also be written by Monet Extenders.
@
Iterators often use a search accelerator for making the selection. For 
instance, if you have developed an R-Tree, you might 
develop also iterators that use the R-Tree to iterate over points near 
to each other.
@
They have the form of a loop over some selection of the BUNs of a BAT,
which is always the first parameter. The second parameter is a PTR 
which points to the @%iteration-record@. The other parameters are the
parameters passed between parentheses. For each BUN, a call
ITERATE(head-ptr, tail-ptr, iteration-record) must be done. This will
execute the MIL block, on the BUN, where the head-ptr is a pointer to
the head atom of the current BUN, and tail-ptr a pointer to the tail-atom.
@
The iteration-record provides the necessary context information 
that allows the Monet Interpreter to know what to execute on each call
of ITERATE(). As mentioned, it is passed to the iterator function at 
startup in the second parameter.
@h
#include "yytree.h"
#define ITERATE(x,y,h) (*((Iteration) h)->tuple_interpret)((x), (y), (h))

#define Cntxt	int
/* typedef int Cntxt; */

typedef struct {
        Cntxt   stk;            /* context for iterator body execution. */
        YYSTREE tree;           /* iterator body/ies. */
        ValPtr   res;            /* iterator result value. */
        int     status;         /* execution status so far. */
        int     (*tuple_interpret)(ptr, ptr, ptr);
        int     (*h_len)(ptr);  /* fcn returning var-sized h_atom length */
        int     (*t_len)(ptr);  /* fcn returning var-sized t_atom length */
        ValPtr   params;        /* (sequence of) head&&tail 2b substituted. */
        int     parcnt;         /* current number of jobs in cointainer. */
        int     parmax;         /* maximum number of jobs in cointainer. */
        int     parcap;         /* maximum paralellism capacity. */
} ITrecord, *Iteration;

@}

@+ Interface functions 
@h
m_export ptr	monet_init	(int argc, char** argv);
m_export ptr	monet_eval	(str mil_script, int *ret_type);
m_export int	monet_exec	(str mil_script);
m_export void	monet_exit	();
m_export void	monet_hello	();
m_export int	monet_sprintf	(str *dst, str format, va_list ap);
m_export void 	monet_checkbat  (BAT* b, int protect);
m_export int	monet_syscall	(GDKfcn addr, int argc, ValPtr argv);
m_export int	monet_sigerror  (str kind, str name, str extra, 
				   int argc, ValPtr argv);
@{
@- external declarations
belong to yacc part of monet_parse.mx, but cannot comfortably be
declared there.
@h
/* lexical analyzer */
m_export int     ll_getch        ();
m_export void    ll_init         ();
m_export str     ll_lastline     ();
m_export void    ll_flushbuffer  ();
m_export int     ll_skipcomment  ();
m_export str     ll_getstr       (char *buf, int len, int c);
m_export void    ll_parserror    (str msg);
m_export void    ll_clrids       ();
m_export void    ll_idconflict   (str s);
@}

@+ Monet Calling Options
The number of invocation arguments is kept to a minimum.
The listing flag is set automatically
when statements are read from a file.
The prompt character is printed each time @%Monet@ expects a new command.
@T
\begin{itemize}
\item
The argument {\tt -prelude} is followed by a file argument, whose
instructions should be executed before any user request is accepted.
It is commonly used to load the database schema into memory and to set
the environment for processing.
\item
The argument {\tt -background} prepares the server for running in the background
by closing standard input. The diagnostic messages are still sent to
the terminal (window) from which it is started.
\item
The argument {\tt -single} leads to a single threaded server. It is of
particular use in debugging kernel extensions.
\item
The location of the database server, called its {\em home}, can be altered with
a statement or indicated as a program argument ({\tt -home}).
It overrules the environment variable MONETHOME.
\item
A dataset within the database server can be selected with the {\tt
-db} option.
\item
OIDs can me made unique on 32-bit systems accross 4 different databases,
using the 2 highest bits as identification. On 64-bits architectures, more space 
will be available.
\item
The flag {\tt -d <nr>}  can be used to control the level of debugging.
\end{itemize}
The input file for commands is standard input.
@
@h
#include "monet_process.h"
#include "monet_client.h"
#include "monet_context.h"
#include "monet_interpreter.h"
#include "monet_tbl.h"
#include "monet_multiplex.h"
#include "monet_queue.h"

m_export char		monet_cwd[PATHLENGTH];	/* where the server started */
m_export char*		monet_dir;		/* contains homes and mod/usr */
m_export char*		monet_db;		/* contains homes and mod/usr */
m_export char*		monet_prompt;		/* system prompt. */
m_export int		monet_listing;		/* echo input */
m_export int		monet_welcome;		/* display welcome message? */
m_export int		monet_background;	/* set server console is deaf */
m_export MT_Id	 	monet_pid;		/* Thread ID of main thread. */
m_export str		monet_port;             /* Overruling internet port */
m_export int		monet_internet;		/* internet client access? */
m_export int		monet_singlethreaded;	/* in singlethreaded mode? */
m_export int		monet_yaccsilent;	/* shut up yacc for testing */
m_export int		monet_modulesilent;	/* shut up module lines */
m_export str		monet_prelude;		/* prelude file. */
m_export str		monet_script;		/* batch of requests */
m_export str		monet_noAccess;		/* User authentication */
m_export MT_Lock		monet_critical;		/* critical section queue mgmt*/
m_export MT_Lock		monet_parserLock;	/* protects access to yacc/lex*/
m_export MT_Lock		monet_contextLock;	/* protects CNTXT structures */
m_export MT_Lock		monet_voidLock;		/* protects void hack */
m_export MT_Sema		monet_available;	/* worker threads in queue */
m_export MT_Sema		monet_started;		/* internet thread started? */
m_export MT_Sema		monet_main;		/* main-interpeter sema */
m_export MT_Sema		monet_forksync;		/* sync semaphore for fork */

m_export int		monet_tokseq;		/* value of TOK_SEQ */
m_export int		monet_tokident;		/* value of TOK_IDENT */
m_export int		monet_tokconstant;	/* value of TOK_CONSTANT */
m_export int		monet_tokbuiltin;	/* value of TOK_BUILTIN */
m_export int		monet_tokcommand;	/* value of TOK_COMMAND */
m_export int		monet_tokoperator;	/* value of TOK_OPERATOR */
m_export int		monet_tokproc;		/* value of TOK_PROC */
m_export int		monet_tokiterator;	/* value of TOK_ITERATOR */
m_export int		monet_tokobject;	/* value of TOK_OBJECT */

m_export char 		monet_arch[PATHLENGTH];
m_export char 		monet_version[PATHLENGTH];
@h
#endif /* _MONET_H_ */
@c 
#include "monet.h"

char            monet_cwd[PATHLENGTH]={0}, *monet_id=0, *monet_ver=0;
char            *monet_prompt="\1>\1", *monet_dir=0, *monet_db=0;
int             monet_listing=0, monet_welcome=1, monet_background=2;
int             monet_singlethreaded=0, monet_internet=1, monet_yaccsilent=0;
str		monet_port=NULL;
MT_Id		monet_pid=0;
str             monet_prelude, monet_script, monet_noAccess = "Anonymous";
MT_Lock         monet_critical, monet_notifyLock, monet_voidLock;
MT_Lock		monet_parserLock, monet_contextLock;
MT_Sema         monet_started, monet_available, monet_main, monet_forksync;
int		monet_modulesilent=0;

@-
Fill in default tokens. yacc and bison yield different numbers.
This makes the kernel modules independent of libmonet in this respect.
@c
int		monet_tokseq = TOK_SEQ;
int		monet_tokident = TOK_IDENT;
int		monet_tokconstant = TOK_CONSTANT;
int		monet_tokbuiltin = TOK_BUILTIN;
int		monet_tokcommand = TOK_COMMAND;
int		monet_tokoperator = TOK_OPERATOR;
int		monet_tokproc = TOK_PROC;
int		monet_tokiterator = TOK_ITERATOR;
int		monet_tokobject = TOK_OBJECT;

@-
A welcoming message is displayed to inform the user about recent
changes.
@c
char monet_arch[PATHLENGTH] = HOST;
char monet_version[PATHLENGTH] = VERSION;

void monet_hello() {
    if (monet_welcome) {
        printf("# Monet Database Server V%s\n", monet_version);
        printf("# Copyright (c) 1993-1999, CWI & SION. ");
        printf("All rights reserved.\n");
        printf("# compiled for %s/%dbit.\n", 
			monet_arch, sizeof(ptr)*8 );
    }
}

static void getoptions(int argc, char **argv){
        int i;
 
        for (i = 1; i < argc; i++) {
            if (argv[i][0] == '-') {
                switch(argv[i][1]) {
                case 'b':
                    if (strcmp("-background", argv[i]) == 0) {
                        monet_background=1;
                    }
                    break;
                case 'd':
                    if (strcmp("-db", argv[i]) == 0) {
                        monet_db = argv[++i];
                    } else GDKdebug = atoi(argv[i]+2);
                    break;
		case 'm': 
		    if (strcmp("-mmap", argv[i]) == 0) {
			GDK_mem_bigsize = ((lng) atoi(argv[++i])) << 10; 
		    } else if (strcmp("-modulesilent", argv[i]) == 0) {
			monet_modulesilent = 1;
		    } break; 
		case 'i': 
		    if (strcmp("-id", argv[i]) == 0)
			monet_id = argv[++i]; 
                    break; 
                case 'w':
                    monet_welcome = !monet_welcome;
                    break;
@-
GDK should have a routine that filters all options directed to it, rather
than to Monet.
@c
                case 'h':
                    if (strcmp("-home", argv[i]) == 0) {
                        monet_dir = argv[++i];
                    } break;
                case 'n':
                    if (strcmp("-noclients", argv[i]) == 0) {
			monet_internet = 0;
		    } break; 
                case 's':
                    if (strcmp("-single", argv[i]) == 0) {
                        monet_singlethreaded++;
			monet_internet = 0;
                    } break;
                case 'p':
                    if (strcmp("-prelude", argv[i]) == 0) {
                        monet_prelude = argv[++i];
                    } else if (strcmp("-port", argv[i]) == 0) {
                        monet_port = (str) argv[++i];
                    } else {
			if ( argv[i][2] != 0 ) {
			    monet_prompt[0] = '\1';
			    monet_prompt[1] = argv[i][2];
			    monet_prompt[2] = '\1';
			} else {
			    monet_prompt = "\1\1";
			}
		    }

                    break;
                case 'v':
                    if (strcmp("-version", argv[i]) == 0) {
                        monet_ver = argv[++i];
                    } break;
                case 'y':
                    if (strcmp("-yaccsilent", argv[i]) == 0) {
                        monet_yaccsilent = 1;
                    } break;
                default:
                explain:
		    monet_hello();
                    printf("usage: %s { option }\n", argv[0]);
		    printf("option:\t-db <db-name>\t\tdatabase to open\n");
		    printf("\t-prelude <input>\texecute MIL file first\n");
		    printf("\t<script>\t\texecute MIL file and exit\n");
		    printf("\t-single\t\t\tsinglethreaded (no Mclient+fork)\n");
		    printf("\t-noclients\t\t\tno Mclient listener\n");
		    printf("\t-background\t\tno console (only Mclient)\n");
		    printf("\t-home <dir>\t\tuse alternative MONETHOME\n");
		    printf("\t-port <nr>\t\tTCP/IP listen port for Mclient\n");
		    printf("\t-version <ver>\t\tcreate BATs in old formats\n");
		    printf(
                     "\t-id <num>\t\tgenerate oid@id (default=0 <= id <= 3)\n");
		    printf("\t-p <prompt-str>\t\tchange the MIL prompt\n"); 
		    printf("\t-yaccsilent\t\tno yacc-specific error msgs\n"); 
                    printf("\t-modulesilent\t\tno module lines output\n");
		    printf("\t-mmap <size>\t\talloc blocks > sizeKB from VM\n");
		    printf("\t-d <debugmask>\t    1 = thread-specific debug output\n");
		    printf("\t\t\t    2 = property enforcing on new BATs\n");
		    printf("\t\t\t    4 = memory allocation\n");
		    printf("\t\t\t    8 = property checking on all values\n");
		    printf("\t\t\t   16 = major IO activity\n");
		    printf("\t\t\t   32 = BAT handling\n");
		    printf("\t\t\t   64 = MIL parser debugging\n");
		    printf("\t\t\t  128 = Thread management\n");
		    printf("\t\t\t  256 = Event management \n");
		    printf("\t\t\t  512 = Transaction management\n");
		    printf("\t\t\t 1024 = Triggers\n");
		    printf("\t\t\t 2048 = Dynamic loading\n");
                    exit(-1);
                }
            } else if (monet_script == 0) {
                monet_listing = 1;
                monet_script = argv[i];
            } else {
                goto explain;
            }
        }
}

@- Monet Exit
The client threads are already killed upon closing their input file.
The server process interpreter is directly killed.
@c
void monet_exit() {
        PARDEBUG THRprintf(GDKerr, "exit from main process\n");
	if (monet_internet) (void) THRexit("InternetServer");
	while (THRexit("Interpreter"));
        GDKexit();
}

extern BAT *TBL_mod_load;

@- Monet Init
Startup the monet server. This is the moment that modules that 
are hardwired into the kernel are activated. The below macro is 
provided to make inclusion of new modules a piece of cake.

@= tokenvar
{	Variable v = VARnew(0, "@1");
	v->binding.vtype = TYPE_int;
	v->binding.val.ival = @1;
	VARfreeze(v);
	VARfixate(v);
}

@c
ptr monet_init(int argc, char **argv){
	static char monet_home_str[] = "-home";
	static char monet_db_str[] = "-db";
	static char monet_ver_str[] = "-version";
        static char buf[256], *gdk_argv[40];
	static int gdk_argc = 0;
        Client  c;

        if (getcwd(monet_cwd, PATHLENGTH-1)  == NULL ){
                perror("pwd");
                GDKfatal("monet_init: could not determine current directory\n");
        }
        monet_db = (char *) getenv("MONETDB");
        getoptions(argc, argv);

        /* determine Monet's administration dir. */
        if (monet_dir == NULL) {
		monet_dir = (char*) getenv(MONET_ENV1);
	}
        if (monet_dir == NULL) {
		monet_dir = (char*) getenv(MONET_ENV2);
	}
        if (monet_dir ==NULL) {
                fprintf(stderr, "FATAL: environment variable %s or %s not defined.\n", MONET_ENV1, MONET_ENV2);
                exit(1);
        }

        gdk_argv[gdk_argc++] = monet_home_str;
        sprintf(buf, "%s%chomes", monet_dir, DIR_SEP);
        gdk_argv[gdk_argc++] = buf;
        if (monet_db) {
                gdk_argv[gdk_argc++] = monet_db_str;
                gdk_argv[gdk_argc++] = monet_db;
        }
        if (monet_ver) {
                gdk_argv[gdk_argc++] = monet_ver_str;
                gdk_argv[gdk_argc++] = monet_ver;
        }
        GDKinit(gdk_argc, gdk_argv);
	if (monet_id) {
		OIDseed(atoi(monet_id) << SERVERBITS); 
	}
        if (monet_port) {
                GDKenviron[GDKport] = monet_port;
        }
#ifdef IRIX
        setbuffer(stdout, GDKmalloc(4096), 4096);
#endif
        ll_init();
        monet_critical   = MT_create_lock();
        monet_contextLock= MT_create_lock();
        monet_parserLock = MT_create_lock();
        monet_notifyLock = MT_create_lock();
        monet_voidLock   = MT_create_lock();
        monet_started    = MT_create_sema(0);
        monet_available  = MT_create_sema(0);
        monet_forksync   = MT_create_sema(0);
        monet_main	 = MT_create_sema(0);

	CNTXTinit();
        monet_pid = MT_getpid();
        THRnew(monet_pid, "Server");
 
        TBL_init(); /* init MIL function table management. */
        c = initClient(GDKstrdup(MONET_ADMIN), GDKstrdup(monet_prompt), 
		      (monet_background!=1));
        if (c == 0) monet_exit();
	c->login = time(0);
        TBL_initclient(c); /* register user 'adm' for a function table. */
@-
Make constants for important language tokens
@c
	@:tokenvar(TOK_BUILTIN)@
	@:tokenvar(TOK_PROC)@
	@:tokenvar(TOK_OPERATOR)@
	@:tokenvar(TOK_COMMAND)@
	@:tokenvar(TOK_ITERATOR)@
	@:tokenvar(TOK_OBJECT)@
@-
Install all link-in modules.
@c

        c->listing = monet_listing;
	return (ptr) c;
}

@- Monet MIL Evaluation
Monet MIL execution made easy: you provide a mil string. It gets
executed and you get a pointer to the return value (a GDK atom) back.
@T
Take good notice of the below points on return values:
\begin{itemize}
\item if there is no return value you get a NULL pointer back! 
\item unless they are exited with a RETURN statement!
\item a single MIL statement {\bf is also} a sequential block.
\end{itemize}
Bottom line: if you want a return value, you should use RETURN!
@
You are supposed to know of which type this return value is..
The space is at least @%ATOMlen(t)@ long. It has to be freed.
by *you* with @%GDKfree@. On error, a NULL pointer is given back,
and the ret_tpe field is (mis)used for the error code..
@c
ptr monet_eval(str mil_script, int *ret_type){
        ValPtr res = (ValPtr) GDKmalloc(sizeof(ValRecord));
        int i = interpret_str(0, mil_script, res);
        if (i == -TOK_RETURN) {
	   	*ret_type = res->vtype;
        	if (ATOMextern(res->vtype)) {
               		ptr p = res->val.pval;
               		GDKfree(res);
               		return p;
        	}
		if (res->vtype == TYPE_bat) {
			BAT *b = BATdescriptor(res->val.bval);
               		GDKfree(res);
			return (ptr) b;
		}
		return (ptr) res; /* HACK: value space is first!! */
	} else if (i < 0) {
	   	*ret_type = i;
	} else {
	   	*ret_type = TYPE_void;
	}
	VALclear(res);
        GDKfree(res);
	return NULL;
}

@-
For those who don't both about return values, there is @:monet_exec@.
It returns <0 on error; else >= 0;
@c
int monet_exec(str mil_script){
	int restype = 0;
	ptr resval = monet_eval(mil_script, &restype); 
	ATOMunfix(restype, resval);
	if (restype > 0) {
		GDKfree(resval);
        }
	return restype;
}

@-
The @%monet_sprintf@() gets a FILE*, str, and a sequence of (ptr,int) parameters
containing values and their type numbers. The @%printf@() proved to be a
great risk; people formatting badly their "%s" format strings were crashing
the kernel. This function will prevent you from doing so.

NEW implementation that repeatedly invokes sprintf => hacking the va_alist 
for using vfsprintf proved to be too compiler-dependent (OLD approach). 

@= writemem
	if (dst+@1 > buf+size) {
		int offset = dst - buf;
		do {
			size *= 2;
		} while (dst+@1 > buf+size);
		buf = GDKrealloc(buf, size);
		dst = buf + offset;
	} 
@= sprintf
	if (width > adds) {
		adds = width+10; 
		add = (str) alloca(adds);
	}
	sprintf(add, meta, @1);
@c
static char toofew_error[80] = 
	"monet_sprintf(): at least %d parameters expected.\n";
static char format_error[80] = 
	"monet_sprintf(): error in format before param %d.\n";
static char type_error[80] = 
	"monet_sprintf(): illegal type in param %d.\n";
#define return_error(x)\
	GDKerror(x, argc); GDKfree(buf); return GDK_FAIL;

int monet_sprintf(str *res, str format, va_list ap){
	int adds = 100, prec, width, dotseen, escaped = 0, type, size, argc = 1;
	char addbuf[100], *add = addbuf, *dst, *buf, *cur, *paramseen = NULL;

        if (format == NULL) {
                GDKerror("monet_sprintf(): NULL pointer passed as format.\n");
                return GDK_FAIL;
        } else if (strchr(format, '%') == NULL) {
		*res = GDKstrdup(format);
                return GDK_SUCCEED;
	}
	buf = dst = (str) GDKmalloc(size=80);
	*res = NULL;

	for(cur=format; *cur; cur++) {
		if (paramseen) {
			char *p, meta[100];
			int extra = 0;

			if (GDKisdigit(*cur)) {
				if (dotseen) {
					prec = 10*prec + (*cur - '0');
				} else {
					width = 10*width + (*cur - '0');
				}
				continue;
			} else if (dotseen == 0  && *cur == '.') {
				dotseen = 1;
				continue;
			} else if (cur == paramseen + 1 && 
				   (*cur == '+' || *cur == '-')) {
				continue;
			} else if (*cur == 'l') {
				cur++;
				if (*cur == 'l') {
					cur++; extra = 1;
				}
			} 
			if ((p = va_arg(ap,char*)) == NULL) {
				return_error(toofew_error);
			}
			type = ATOMstorage(va_arg(ap,int));
			memcpy(meta, paramseen, 1+(cur-paramseen));
			meta[1+(cur-paramseen)] = 0;

			if (strchr("cdiouxX", *cur) && !extra) {
				int ival;
				if (dotseen) {
					return_error(format_error);
		        	} else if (type == TYPE_chr) {
					ival = (int) *(chr*) p;
		        	} else if (type == TYPE_sht) {
					ival = (int) *(sht*) p;
		        	} else if (type == TYPE_flt) {
					ival = (int) *(flt*) p;
		        	} else if (type == TYPE_int) {
					ival = *(int*) p;
				} else {
					return_error(type_error);
				}
				@:sprintf(ival)@
			} else if (strchr("diouxX", *cur)) {
				lng lval;
				if (dotseen) { 
					return_error(format_error);
				} if (type == TYPE_chr) {
					lval = (lng) *(chr*) p;
				} else if (type == TYPE_sht) {
					lval = (lng) *(sht*) p;
				} else if (type == TYPE_int) {
					lval = (lng) *(int*) p;
				} else if (type == TYPE_flt) {
					lval = (lng) *(flt*) p;
				} else if (type == TYPE_dbl) {
					lval = (lng) *(dbl*) p;
		        	} else if (type == TYPE_lng) {
					lval = *(lng*) p;
				} else {
					return_error(type_error);
				}
				@:sprintf(lval)@
		    	} else if (strchr("feEgG", *cur)) {
				dbl dval;
		        	if (type == TYPE_flt) {
					dval = (dbl) *(flt*) p;
		        	} else if (type == TYPE_dbl) {
					dval = *(dbl*) p;
				} else {
					return_error(type_error);
				}
				width += (1+prec);
				@:sprintf(dval)@
			} else if (*cur == 's') {
				int len;
				if (extra) {
					return_error(format_error);
				} else if (type != TYPE_str) {
					return_error(type_error);
				}
				len = strLen(p);
				width++; prec++;  /* account for '\0' */
				if (dotseen && prec < len) len = prec;
				if (len > width) width = len;
				@:sprintf(p)@
			} else {
				return_error(format_error);
			}
			width = strlen(add);
			@:writemem(width)@
			memcpy(dst,add,width); dst += width; 
			paramseen = NULL; argc++;
		} else if (!escaped) {
			if (*cur == '\\' || (*cur == '%' && cur[1] == '%')) { 
				escaped = 1;
			} else if (*cur == '%') {
				paramseen = cur;
				dotseen = prec = width = 0;
			} else {
				@:writemem(1)@
				*dst++ = *cur;
			} 
		} else {
			escaped = 0;
			@:writemem(1)@
			*dst++ = *cur;
		}
	}

	if (va_arg(ap,char*) != NULL) 
	   GDKwarning("monet_sprintf(): params %d and beyond ignored.\n", argc);
	@:writemem(1)@
	*dst = 0;
	*res = buf; 
	return GDK_SUCCEED;
}


@- monet_syscall
this generic function can be used to call a C function with C-like
parameters extracted from a (argc,argv) setup.
 
This is quite tricky as we build a stack of integers by going through
the argv[] list. This stack will be used in a totally dependent way
by the C-routine. No checks possible.
Unsafe to call:  BE SURE TO PASS WHAT THE 'addr' ROUTINE EXPECTS
@c
int monet_syscall(GDKfcn addr, int argc, ValPtr argv) {
        int i,j;
	long v[MAXPARAMS*2];
@-
Convert all parameter values to integers.
@c
        for(i=j=0; i < argc; i++) {
	    int tpe;
            if (argv[i].vtype == TYPE_bat) {
                argv[i].val.sval = (str) BBPname(argv[i].val.bval);
	  	argv[i].vtype = TYPE_str;
	    }
	    tpe = ATOMstorage(argv[i].vtype);
	    if (tpe == TYPE_void) continue;

	    /* normal passing conversions */
	    if (tpe == TYPE_chr) {
		argv[i].val.ival = (int) argv[i].val.cval[0]; 
		tpe = TYPE_int;
	    } else if (tpe == TYPE_sht) {
		argv[i].val.ival = (int) argv[i].val.shval; 
		tpe = TYPE_int;
	    } else if (tpe == TYPE_flt) {
		argv[i].val.dval = (dbl) argv[i].val.fval; 
		tpe = TYPE_lng;
	    }
#if (SIZEOF_LONG==8) 
	    /* 64-bits passing conversions */
	    if (tpe == TYPE_int) {
		argv[i].val.lval = (lng) argv[i].val.ival; 
		tpe = TYPE_lng;
	    }
            v[j++] = argv[i].val.lval; 
#else
	    if (ATOMsize(tpe) == sizeof(int)) {
                v[j++] = argv[i].val.ival; 
	    } else {
                v[j++] = ((int*) &argv[i].val.lval)[0];
                v[j++] = ((int*) &argv[i].val.lval)[1]; 
	    }
#endif
        }
@-
Now pass these integers.
@c
        switch(j) {
        case  0: return (*addr)();
        case  1: return (*addr)(v[0]);
        case  2: return (*addr)(v[0],v[1]);
        case  3: return (*addr)(v[0],v[1],v[2]);
 
        case  4: return (*addr)(v[0],v[1],v[2],v[3]);
        case  5: return (*addr)(v[0],v[1],v[2],v[3],v[4]);
        case  6: return (*addr)(v[0],v[1],v[2],v[3],v[4],v[5]);
        case  7: return (*addr)(v[0],v[1],v[2],v[3],v[4],v[5],v[6]);
        case  8: return (*addr)(v[0],v[1],v[2],v[3],v[4],v[5],v[6],v[7]);
        }
@-
For all other #param cases, just pass all of them (this works).
@c
        return (*addr)(v[0],v[1],v[2],v[3],v[4],v[5],v[6],v[7],v[8],
                v[9],v[10],v[11],v[12],v[13],v[14],v[15],v[16],v[17],
                v[18],v[19],v[20],v[21],v[22],v[23],v[24],v[25],v[26],
                v[27],v[28],v[29],v[30],v[31],v[32],v[33],v[34],v[35], 
                v[36],v[37],v[38],v[39],v[40],v[41],v[42],v[43],v[44],
                v[45],v[46],v[47],v[48],v[49],v[50],v[51],v[52],v[53],
    		v[54],v[55],v[56],v[57],v[58],v[59],v[60],v[61],v[62],v[63]);
}

@- monet_sigerror
this function prints a beautified error message for a function that
did not resolve well.
@c
int monet_sigerror(str kind, str name, str extra, int argc, ValPtr argv){
        char buf[4096], *p=buf;
        BAT *b;
        int i;
 
        strcpy(p, name); p += strlen(p);
        *(p++) = '(';
        for(i=1; i<argc; i++) {
                if (i > 1) { *(p++) = ','; *(p++) = ' '; }
                strcpy(p, ATOMname(argv[i].vtype)); p += strlen(p);
                if ((argv[i].vtype == TYPE_bat) &&
                    (b = BATdescriptor(argv[i].val.bval)))
                {
                        *(p++) = '[';
                        strcpy(p, ATOMname(b->htype)); p += strlen(p);
                        *(p++) = ',';
                        strcpy(p, ATOMname(b->ttype)); p += strlen(p);
                        *(p++) = ']';
                }
        }
        *(p++) = ')'; *p = 0;
        GDKerror("interpret: no matching %s to '%s'.\n%s", kind, buf, extra);
        return 0;
}

@-
the below routine tries to derive every possible property from a
given BAT. It should be fired off on new BATs in the MIL interpreter
in order to achieve optimal optimization decisions being made in MIL 
algebra programs.
@c
static int _t3 = 0;
void monet_checkbat(BAT* b, int protect){
        int _t2, _t1;
        BATDEBUG _t1 = GDKms();
@-
If we look at the copied column of a VIEWcombine (MIL mirror) BAT,
we can skip checking, as we can assume the reverse column will get checked.
@c
        if (b->H != b->T) {
        	BATpropcheck(BATmirror(b));
        }
        BATpropcheck(b);
        if (protect) BATsetaccess(b, BAT_READ);
        BATDEBUG {
                _t2 = GDKms() - _t1; _t3 += _t2;
                THRprintf(GDKerr, "check %s = %d (tot %d)\n", b->batId,_t2,_t3);
        }
}

@{
@+ Value operations
The following primitives are required to manipulate value records.
Note that binding a BAT requires upgrading its reference count.
The receiver of the value should have been cleared or represent
free space.
@c
ValPtr VALnew(){
	ValPtr v = (ValPtr) GDKmalloc(sizeof(ValRecord));
	VALempty(v);
	return v;
}

ValPtr VALset(ValPtr v, int t, ptr p){
	switch(ATOMstorage(v->vtype = t)) {
	case TYPE_chr: v->val.cval[0] = *(chr*) p; break;
	case TYPE_sht: v->val.shval = *(sht*) p; break;
	case TYPE_int: v->val.ival = *(int*) p; break;
	case TYPE_flt: v->val.fval = *(flt*) p; break;
	case TYPE_dbl: v->val.dval = *(dbl*) p; break;
	case TYPE_lng: v->val.lval = *(lng*) p; break;
	default:       v->val.pval = p;
		       v->len = ATOMlen(t, p);
	}
	return v;
}

void VALclear(ValPtr v){
	if (ATOMextern(v->vtype) && v->val.pval) {
		GDKfree(v->val.pval);
	}
	VALempty(v);
}

void VALempty(ValPtr v){
	v->len = 0;
	v->val.oval = oid_nil;
	v->vtype = TYPE_void;
}

ValPtr VALcopy(ValPtr d, ValPtr s){
	if (ATOMextern(s->vtype) == 0) {
		*d = *s;
	} else if (s->val.pval == 0) {
		GDKwarning("VALcopy: copying null %s.\n", ATOMname(s->vtype)); 
		d->vtype = TYPE_void;
	} else if (s->vtype == TYPE_str) {
		d->vtype = TYPE_str;
		d->val.sval = GDKstrdup(s->val.sval);
		d->len = strLen(d->val.sval);
	} else {
		ptr p = s->val.pval;
		d->vtype = s->vtype;
		d->val.pval = GDKmalloc(s->len);
		d->len = s->len;
		memcpy(d->val.pval, p, s->len);
	}
	return d;
}

int VALprint(FILE *fd, ValPtr res){
	int t = res->vtype;
	return ATOMprint(t, VALptr(res), fd);
}	


int VALformat(char **buf, ValPtr res){
	int t = res->vtype;
	*buf = 0;
	return ATOMformat(t, VALptr(res), buf);
}

@-
The routine @%VALconvert@ transforms a value for interpretation
in a certain type. It uses some standard cast conventions to do this.
The result, a pointer to a value, is returned. If there are
illegal values, or type combinations involved, it gives
up with an ILLEGALVALUE.

@= valconvert
	if (dst_tpe == TYPE_chr) {
		t->val.cval[0] = (char) @1; 
	} else if (dst_tpe == TYPE_sht) {
		t->val.shval = (short) @1; 
	} else if (dst_tpe == TYPE_bat) {
		int bid = (int) @1;
		if (ABS(bid) > BBPsize || BBP_logical(bid) == NULL) {
			bid = 0;
			p = ILLEGALVALUE;
		} else {
			p = (ptr) BATdescriptor(bid);
		} t->val.bval = bid; 
	} else if (dst_tpe == TYPE_int) {
		t->val.ival = (int) @1; 
	} else if (dst_tpe == TYPE_flt) {
		t->val.fval = (float) @1; 
	} else if (dst_tpe == TYPE_lng) {
		t->val.lval = (lng) @1; 
	} else if (dst_tpe == TYPE_dbl) {
		t->val.dval = (dbl) @1; 
	}
	warning = (sizeof(dst_tpe) < sizeof(@2));
@c
ptr VALconvert(int typ, ValPtr t, int silent){
	int src_tpe = ATOMstorage(t->vtype), dst_tpe = typ, warning = 0;
	ptr p = VALptr(t);

        if (dst_tpe != TYPE_bat) {
		dst_tpe = ATOMstorage(dst_tpe);
	}  
	if (src_tpe != dst_tpe && t->vtype != typ && dst_tpe != TYPE_void) { 
		if (src_tpe >= TYPE_str || dst_tpe >= TYPE_str) { 
			if (ATOMcmp(src_tpe, ATOMnilptr(src_tpe), p) == 0) {
				VALclear(t);
				VALset(t, dst_tpe, p = ATOMnil(dst_tpe));
			} else { 
				return ILLEGALVALUE; 
			}
		} else if ((t->vtype == TYPE_bat && t->val.bval == 0 ) ||
	    	           ATOMcmp(src_tpe, ATOMnilptr(src_tpe), p) == 0) 
		{
			memcpy(p, ATOMnilptr(dst_tpe), ATOMsize(dst_tpe));
		} else if (src_tpe == TYPE_chr) {
			@:valconvert(t->val.cval[0], chr)@;
		} else if (src_tpe == TYPE_sht) {
			@:valconvert(t->val.shval, sht)@;
		} else if (src_tpe == TYPE_int) {
			@:valconvert(t->val.ival, int)@;
		} else if (src_tpe == TYPE_flt) {
			@:valconvert(t->val.fval, flt)@;
		} else if (src_tpe == TYPE_lng) {
			@:valconvert(t->val.lval, lng)@;
		} else if (src_tpe == TYPE_dbl) {
			@:valconvert(t->val.dval, dbl)@;
		}
        	if (!silent && t->vtype && warning) {
                	GDKwarning("VALconvert: converted type '%s' to '%s'.\n",
                        	ATOMname(t->vtype), ATOMname(typ));
        	}
	}
	t->vtype = typ;
	return p;
}
@}
@* Example Monet Library Application 
This is just a simple example that uses the monet library.
Name the binary to your database and just type MIL in the
command line arguments.
@c
#ifdef MAIN
main(int argc, char** argv){
    int restype;
    char *mil_string;

    if (argc < 2) {
	fprintf(stderr, "usage: %s { monet-options } <mil-string>\n", argv[0]);
	return -1;
    }

    mil_string = argv[--argc];
    monet_init(argc, argv);
    monet_eval(mil_string,&restype);
    monet_exit();
}
#endif
@
