@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@' 
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@' 
@' The Original Code is the Monet Database System.
@' 
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2003 CWI.
@' All Rights Reserved.
@' 
@' Contributor(s):
@' 		Martin Kersten <Martin.Kersten@cwi.nl>
@' 		Peter Boncz <Peter.Boncz@cwi.nl>
@' 		Niels Nes <Niels.Nes@cwi.nl>
@' 		Stefan Manegold  <Stefan.Manegold@cwi.nl>

@f monet_process
@a M. L. Kersten, P. Boncz

@* Monet Processes
@T
The multi-threaded parallel implementation of Monet is geared towards 
shared-memory multiprocessors only. 
The single threaded code simply cycles through the queue until it becomes empty.
The multi-threaded Monet code is split into three kinds
of threads that work semi-independently:
\begin{itemize}
\item an Internet Server thread.
\item MIL Interpreter threads.
\item Client Interpreter threads
\end{itemize}

The  MIL interpreter threads take their requests from an internal request
queue. They normally interpreter MIL statements obtained from client sources.

However, the DBA can extend the number of interpreters easily. So as
to support specialized language interpreters direct access to the BAT
primitives and MIL request queue.

since you have to swap fd-s on every request. ]
@-
The number of threads can be controlled by the Monet
routine @%threads@, which assures a number of concurrent interpreter
threads to become active. 
If there are more threads already active then some are selected
at random to cease operation. 
@-
The threads have to update their I/O descriptor before doing I/O.
@h
#ifndef _MONET_PROCESS_H_
#define _MONET_PROCESS_H_
#include "gdk.h"

m_export void	monetInternet ();

/* monet standard threads */
m_export void	monetServer	(void *dummy);
m_export void	monetInterpreter(void *dummy);
m_export void	monetSingle  	(int status);

/* interpreter thread handling */
m_export MT_Id	monetFork ();
m_export int	monetAdjustThreads (int i);
m_export int	monetSetChannel (Thread t, stream* in, stream* out);


#endif /* _MONET_PROCESS_H_ */
@c
#include  <sys/types.h> 
#ifdef HAVE_SYS_SOCKET_H
# include <sys/socket.h>
#endif
#ifdef HAVE_WINSOCK_H
# include <winsock.h>
#endif
#include "monet.h"

@+ Monet Single Threaded
The single threaded code is large copied from @%monetInterpreter@.
@c
int monet_threads = 0;

void monetSingle(int status){
	ValRecord res;
	MT_Id tid = THRgettid();
	Thread t = THRget(tid);

        res.vtype= TYPE_void;
        res.val.ival = 0;
        monet_threads++;
	while (status == 0 && QMopen() ) {
		PARDEBUG THRprintf(GDKerr, "monetSingle(%d)\n", status);
		PARDEBUG QMprint();
		status = handleRequest(t, getRequest(0), &res);
	}
       	PARDEBUG THRprintf(GDKerr, "exit\n");
}


@+ Monet Interpreter Threads
@-
This will be dropped when everything works ok.
@c
void monetInterpreter(void* dummy){
	Thread	t;

	t = THRnew(MT_getpid(), "Interpreter");
	MT_up_sema(monet_forksync, "monetInterpreter");
	PARDEBUG THRprintf(GDKerr, "monetInterpreter(dummy)\n" );
	if (!monet_threads) monet_threads++;

	doRequest(t,0);
	MT_set_lock(monet_critical, "monetInterpreter");
 	monet_threads--;
	MT_unset_lock(monet_critical, "monetInterpreter");
	THRdel(t);
       	PARDEBUG THRprintf(GDKerr, "monetInterpreter(exit)\n");
	MT_exit_thread(0);
}

int monetSetChannel(Thread t, stream* in, stream* out){
        if ( t==0) {
                GDKerror("monetSetChannel: unknown thread\n");
        }
        if (t->data[0] == 0 || t->data[1] == 0) {
                return EOF;
        }
        PARDEBUG THRprintf(GDKerr, "setchannel %s %s\n",in->name, out->name);
        t->data[1] = in;
        t->data[0] = out;
 
        return 0;
}
 


@-
New interpreters threads are added here. The instruction is ignored
when the system is supposed to run within one thread.
@c
MT_Id monetFork() {
	MT_Id p = 0;

	if (!monet_singlethreaded) {
		MT_set_lock(monet_critical, "monetFork");
		/* exclusive access to monet_forksync barrier
	 	 * and monet_threads counter. */
		if (MT_create_thread(&p, monetInterpreter, 0) < 0) {
			GDKsyserror("monetFork:failed\n");
			MT_unset_lock(monet_critical, "monetFork");
			return (MT_Id)-1;
		} 
		MT_down_sema(monet_forksync, "monetFork");
 		monet_threads++;
		MT_unset_lock(monet_critical, "monetFork");
	}
	return p;
}


int monetAdjustThreads(int i){
	PARDEBUG THRprintf(GDKerr, "monetAdjustThreads(%d)\n", i);
	for (; i < 0; i++) {
		putkillRequest();
	}
	for (; i > 0; i--) {
		if ((int)monetFork() < 0) {
			return monet_threads;
		}
       	}
	return monet_threads;
}
@}
