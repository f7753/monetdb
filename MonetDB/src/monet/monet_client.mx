@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at 
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@' 
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@' 
@' The Original Code is the Monet Database System.
@' 
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2002 CWI.  
@' All Rights Reserved.
@' 
@' Contributor(s):
@' 		Martin Kersten <Martin.Kersten@cwi.nl>
@' 		Peter Boncz <Peter.Boncz@cwi.nl>
@' 		Niels Nes <Niels.Nes@cwi.nl>
@' 		Stefan Manegold  <Stefan.Manegold@cwi.nl>

@f monet_client
@a M. L. Kersten, P. Boncz

@* Monet Client Interface
Clients gain access to the Monet server through a internet connection
or through its server console.
Access through the internet requires a Monet client program at the
source, but ordinary telnet connections can be applied when the internet
number of the database server is publicised.

At the server, each client is represented by a record about the
current status, such as name, file descriptors, and local stack.
Acceptance of request is regulated through an authorization
algorithm. 

The monitor task is to assemble the textual command 
and to submit it to the parser upon requests. It takes care of blocking
However, in interactive mode it can not recognize blocks associated with
procedures and triggers. Therefore, the header should be followed by the
opening bracket.

@-
The number of clients permitted concurrent access is a compile time option.
They are referenced internally by number. The console is the first and 
should always be present. It reads from standard input and writes to 
standard output.
The number of clients depends on the permissible open file
descriptors. Each client has a socket (with two file descriptors ?)
and an open file for logging.

@{
The file descriptors for communication are also stored here for
ease of access. The field @%cptr@ can be manipulated by the lexical analyser.
The backup file descriptors are used to enable temporary reads from
another input file. 

{ TODO: recursive calls, should be based on linked Client records. }

The input of a client may be logged on a specific file for offline inspection.
@h
#ifndef _MONET_CLIENT_H_
#define _MONET_CLIENT_H_
#include "monet.h"

#define MAXCLIENTS	32
#define BLOCKMODE	32
#define FINISHED	0
#define FINISHING	1	
#define CONSOLE		0

typedef struct CLIENT{
	str 		user;			/* user name. */
	long		login;			/* session start time */
	int		permission;		/* not yet used. */
	stream		*fdin, *fdout;		/* streams from and to user. */
	stream		*bkin, *bkout;		/* backup stream storage */
	int 		socket;			/* socket with tcp conn. */
	int		listing;		/* echo input */
	int		mode;			/* FINISHED/BLOCKED */
	int		father;			/* client number of father */
	int		children;		/* has children? */
	str		prompt, bkprompt;	/* prompts */
	str		input, output;		/* char buffers */
	str		top, limit;		/* parser pointers */
	char		*cptr;			/* parser pointers */
	char		*cline;			/* current parse line */
	YYSTREE 	tree;			/* current request */
	YYSTREE 	mil_accept;		/* accept request */
	int		maxstk;			/* highest context stack */
	int		stk;			/* lowest context stack */
	BAT		*fcntbl;		/* BAT(str, FID) */
	BAT		*atomtbl;	       	/* BAT(str, type-id) */
	BAT		*acctbl;	       	/* BAT(str, type-id) */
	BAT		*triggers;		/* BAT(str, type-id) */
	BAT		*events;		/* BAT(str, type-id) */
} *Client, ClientRec;

m_export ClientRec monet_clients[MAXCLIENTS+1];
m_export Client	ll_client;

m_export Client	initClient     (str name, str prompt, int thread);
m_export Client	forkClient     (Cntxt stk, int thread);
m_export int	closeClient    (Client c, int thread);
m_export void	killClient     (Client c, int thread);
m_export void	scheduleClient (Client c);
m_export int 	acceptClient   (Client c);
m_export int 	readClient     (Client c);
m_export YYSTREE	parseClient    (Client c, int reschedule);
m_export int 	scriptClient   (Client c, str nme, int backup);
m_export int	serveClient    (Cntxt stk, YYSTREE lt, ValPtr res);
m_export str	moduleClient   (Client c, YYSTREE lt, int idents);
m_export int	dropClient     (Client c, YYSTREE lt);

m_export void lockparser(Client c);
m_export void unlockparser(Client c);

#endif /* _MONET_CLIENT_H_ */
@-
Upon acceptance of a connection a client record is initialized.
A new thread is started to ensure that a read request on a client
does not block the complete system. 
Failure leads to refusal of the client. 

{ TODO: The accept request should involve a timeout }.

No protection is yet given against
a parallel block with multiple readClient statements
@c
#include "monet.h"
#include <sys/socket.h>
#include <sys/types.h>

ClientRec		monet_clients[MAXCLIENTS+1];
int			monet_nclients = 0;

Client initClient(str nme, str prompt, int thread){
	Client 	c;
@-
Find an empty client slot.  The console entry is reserved.
@c
	MT_set_lock(monet_contextLock, "initClient");
	for(c = monet_clients; c < monet_clients+MAXCLIENTS; c++) {
		if (c->mode == FINISHED) {
			monet_nclients++;
			c->mode = BLOCKMODE;
			break;
		}
	}
	MT_unset_lock(monet_contextLock, "initClient");

	if (c == monet_clients+MAXCLIENTS) {
		GDKfatal("Out of client slots\n");
		return 0;
	}
	if (thread) {
		if ((int)monetFork() < 0) return 0;
	}
       	c->user = nme;
	c->prompt = prompt;
	c->fdin = GDKstdin;
	c->fdout = GDKstdout;
	c->maxstk = c->stk = c-monet_clients;
	c->father = -1;
	monet_cntxt[c->stk].used = TRUE;
	monet_cntxt[c->stk].reuse = -1;
	monet_cntxt[c->stk].outer = c->stk?0:-1;
	monet_cntxt[c->stk].next = -1;
	if (c->input == 0) {
		c->input = (str) GDKmalloc(4096);
	}
	if (c->output == 0) {
		c->output = (str) GDKmalloc(4096);
	}
	c->limit = c->input + 4096;
	c->top = c->input;
	*c->top = 0;
@-
Upon entering of each client we should ensure that there are
at least as many threads as there are clients. Otherwise, waiting for
client input may block the system.
The easiest way to look for sufficient clients is to set a flag in
each Client record to indicate that for this slot a thread has been
created (in the past).
@c

	return c;
}

@-
The default action is to schedule processing of the start-up file
followed by reading a request from the socket.
Execution of the prelude file is scheduled as a separate action.
The first time a client needs input (or when the last input contained
errors) its read request is entered into the queue.
@c

static YYSTREE scheduleFile(str filename) {
        YYSTREE r = yynode(TOK_BUILTIN, TYPE_ptr);
        YYSTREE n = yynode(TOK_CONSTANT, 0);
        yyexpand(r, n);
        n->yyval.vtype = TYPE_str;
        n->yyval.val.sval = GDKstrdup(filename);
        n->yyval.len = strLen(filename);
        r->yyval.val.pval = (ptr) interpret_file;
        r->dealloc = 0;
        return r;
}

#define QMADD(req, stk, lt, txt) {			\
	Request _tmp = newRequest(stk, lt, req!=NULL);	\
	QMmessage(_tmp, txt);				\
	if (req) {					\
		req->ev_wakeup = _tmp;			\
		req->ev_prev  = _tmp;			\
	}						\
	_tmp->ev_next = req;  				\
	req = _tmp; 					\
}

void scheduleClient(Client c){	
	static int monet_first = 1;
	Request req = NULL;
	YYSTREE t;
	int k;

	if (c->mil_accept == NULL) {
        	yyexpand(c->mil_accept = yynode(TOK_BUILTIN, TYPE_int),
        		 t = yynode(TOK_CONSTANT, TYPE_int));
		c->mil_accept->yyval.val.pval = (ptr) serveClient;
		t->yyval.val.ival = c-monet_clients;
	}
	if (monet_first){
		monet_first=0;
		for(k=0;monet_script[k]; k++){
			QMADD(req, 0, scheduleFile(monet_script[k]), 
				"source(<user script>);");
		}
	}
	if (c != monet_clients || monet_deamon != 1) {
		QMADD(req, c->stk, c->mil_accept, "readCmd;");
        }
        putRequest(req);
}

void rescheduleClient(Client c) {	
	Request rm = newRequest(c->stk, c->mil_accept, 0);
	QMmessage(rm,"readCmd;");
	putRequest(rm);
}

@-
Forking is a relatively cheap way to create a new client.
The new client record is shared most datastructures with the father.
@c
Client forkClient(Cntxt stk, int thread){
	Cntxt nstk = 0;
        Client father = NULL, son = NULL;
	CNTXTclient(stk, &father);
	if (father && father->father >= 0) { 
		/* if the father itself is a temporary client, let 
		 * the new child depend on the grandfather.
		 * so: father always points to a real client session!
		 */
		father = monet_clients + father->father;
	}

	if (father && (son=initClient(father->user, father->prompt, FALSE))) {
	        /* reuse all crucial table information from father */
		son->fdin = father->fdin;
		son->fdout = father->fdout;
		son->fcntbl = father->fcntbl;
        	son->atomtbl = father->atomtbl;
        	son->acctbl = father->acctbl;
        	son->triggers = father->triggers;
        	son->events = father->events;
        	son->login = father->login;
        	son->father = father->stk;
		/* also reuse father's stack */
		if (thread){
			nstk = CNTXTcopy( stk );
			monet_cntxt[son->stk].outer = nstk;
			TBL_initclient(son);
		} else {
        		monet_cntxt[son->stk].outer = stk;
        		monet_cntxt[son->stk].shadow = 1;
		}
		MT_set_lock(monet_contextLock, "forkClient");
		father->children++;
		MT_unset_lock(monet_contextLock, "forkClient");

		if (thread)
			if ((int)monetFork() < 0) return 0;
	}
        return son;
}

@-
When a client wishes to terminate then the file descriptors for
its input/output are closed. Termination of the server should lead to
a proper degradation using the quit command.
The end of a session for the client is administered in the log.
The backup output file is often the same as the primary. Thus, 
it may not be simply closed.
@c
void freeClient(Client c) {
	if (c->mode <= FINISHING) {
		GDKwarning("freeClient(%d): double entry prevented\n", c->stk);
		MT_unset_lock(monet_contextLock, "freeClient");
		return;
	}
	/* free the client record */
	if (c->father >= 0) {
		monet_clients[c->father].children--;
	}
	c->mode = FINISHING;
	MT_unset_lock(monet_contextLock, "freeClient");

	/* epilogue actions */
	if (c->father < 0) { /* normal client */
		Thread t = THRget(THRgettid()); 
		stream *bkin = t->data[1], *bkout = t->data[0];
		ValRecord res;

		monetSetChannel(t, bkin, bkout);
       		TBL_exitclient(c);
		GDKlog("Mserver: %s session ends", c->user);	
		(void) c->fdout->flush(c->fdout); 
		c->fdin->close(c->fdin);
		c->fdin->destroy(c->fdin);
		c->fdout->close(c->fdout);
		c->fdout->destroy(c->fdout);
	/*
		if (fileno(c->fdin) != 0){
        		(void) fclose(c->fdin);
        		(void) fclose(c->fdout);
			if (c->stk) shutdown(c->socket, 2);
			(void) close(c->socket);
		}
*/
		GDKfree(c->user); 
		GDKfree(c->prompt); 
	} else { 			/* fork() client */
		c->father = monet_cntxt[c->stk].outer = -1;
	}

	/* destroy all bindings */

	if (c->tree) {
		yyfree(c->tree);
		c->tree = NULL;
		CNTXTfree2(c->stk, c);
	}

	CNTXTclear(c->stk);
	CNTXTfree2(c->stk, c); 
	CNTXTdelete(c->stk); 
	c->user = c->prompt = NULL;
	c->children = 0;
	c->mode = FINISHED;
}

int closeClient(Client c, int thread) {
	static int killadm = FALSE;

	/* end of script reading client? */
	if (c->bkin || c->bkout) {
		c->fdin = c->bkin;
		c->fdout = c->bkout;
		c->bkin = c->bkout = 0;
		c->prompt = c->bkprompt;
		c->bkprompt = 0;
		if (c->fdin == GDKstdin) {
			c->listing = monet_listing;
		}
		rescheduleClient(c);
		return 1;
	} 

	/* kill living background clients */
	if (c->children) {
		Client k;
		for (k = monet_clients; k < monet_clients+MAXCLIENTS; k++) {
			if ((k->mode > FINISHING) && (k->father == c->stk)) 
				killClient(k, TRUE);
		}
	}

	/* free resources */
	if (c == monet_clients) {
		/* adm: do not free immediate */
        	int i, m = monetAdjustThreads(0);
                for (i = 0; i < m; i++) {
                        putkillRequest();
                }
 	} else {
		/* client: free your recources imediately */
		MT_set_lock(monet_contextLock, "closeClient");
		freeClient(c);
		if (thread) {
			putkillRequest();
		}
	}

	/* the adm is freed by the last client */
	MT_set_lock(monet_contextLock, "closeClient");
	if (killadm == FALSE && --monet_nclients == 0) {
		killadm = TRUE;
		freeClient(monet_clients);	
	} else {
		MT_unset_lock(monet_contextLock, "closeClient");
	}
	return 0;
}


void killClient(Client c, int thread){
    if (c && c->user) {
        MT_Id   me = THRgettid();
	Request	r,q=QMclient(0,c);

	if (q) do {
	    r = QMclient(q,c); 
	    if (q->ev_status == EVRUNNING && q->ev_process != me) {
		Thread t = THRget(q->ev_process);
	        if (t != NULL) {
			MT_Id victim = t->pid;
			THRdel(t);
	        	MT_kill_thread(victim);
			MT_sleep_ms(1000); /* why is this needed, isn't MTsafe*/
			monetFork();
		}
	    	rmRequest(q); clrRequest(q);
	    }
	} while((q=r) != NULL);
	closeClient(c, thread);
    }
}
@-
The input is read from a terminal and stored in the client record
message buffer. The storage area grows automatically.
The user can not interrupt the processing of an outstanding request yet.
This should become part of the functionality of the client monitor at
some later stage.
To simplify entering blocks the monitor looks for lines starting
with [ or {. They lead to block mode processing which terminates
by finding a line with the closing bracket.
@c


int acceptClient(Client c){
	int r;
	PARSEDEBUG THRprintf(GDKerr, "accept from %s\n", c->user);
	r = readClient(c);
	if ( r) {
		parseClient(c, TRUE);
	} else {
		Request q = thisRequest();
		q->ev_kill = c->stk + 1;
	}
	return 0;
}

static 
void enlargebuffer(Client c){
	str s;
	int i;
	int l;

	l = c->top - c->input;
	i = c->limit- c->input +4096;
	s = (char *) GDKmalloc((unsigned)i);
	memcpy(s, c->input, l);
	GDKfree(c->input);
	c->input = s;
	c->top = s + l;
	c->limit = c->input+i;
}

int readClient(Client c){
	int i, doflush=0;
	char instring = 0;
	int bracket = 0;
	int incomment = 0;
	stream *fd = GDKout;
	str  s;
 
	PARSEDEBUG THRprintf(GDKerr, "accept client %d input %s buffer:\n#%s\n", 
			c-monet_clients, c->fdin->name, c->top);
@-
The next statement block is read. Care is taken to recognize the
bracket structure within string and character constants.
@c
	c->top = c->input;
	do {
		if (instring != '"') {
			int l = strlen(c->prompt);
			if (c == monet_clients) {
				for(s=c->prompt; *s; s++) 
					if (isprint((int) *s)) fd->write(fd, s, 1, 1);
		    	} else if (fd->write(fd, c->prompt, l, 1) != 1) {
				return 0;
			}
			fd->flush(fd);
		}
@-
The system should use the low level read primitives to ensure that
the client reader does not hang too long on terminal I/O.
@c
again: 		s = c->top; *s = 0;
		while ((i = c->fdin->read(c->fdin, c->top, 1, 1)) > 0) {
			PARSEDEBUG THRprintf(GDKerr, "%c (%d)", *c->top, i);
#ifdef WIN32
			if (*c->top == 13) { /* filter out ^M */
                                i--;
                                c->top++;
				continue;
			}
#endif
			if (*c->top == '\n') {
				incomment = 0;
				if (c->top > c->input && c->top[-1] != '\\') {
					instring = 0;
				}
				break;
			}
			if (!isspace((int) *c->top)) {
				doflush = 0;
			}
			switch(*c->top) {
			case '#':
				if (!instring) {
					incomment++;
				} break;
			case '{':
				if (!(incomment || instring)) {
					bracket++;
				} break;
			case '}':
				if (!(incomment || instring)) {
					bracket--; doflush=1; 
				} break;
			case '\'':
			case '"':
				if ((!incomment) && 
				    (c->top <= c->input || c->top[-1] != '\\')) 
				{
				    if (instring == *c->top) {
					instring = 0;
				    } else if (!instring) {
					instring = *c->top;
			  	    }
				} break;
			case ';':
				if (!(incomment || instring)) { 
					doflush=1;
				}
			}
			c->top++;
			if (c->top >= c->limit-1) {
				enlargebuffer(c);
			}
		}
		if (i <= 0) {
/*
			if (feof(c->fdin)
#ifndef WIN32
			    || (i < 0 && MT_geterrno() != EAGAIN) 
#endif
			){
*/
				return 0;
/*
			}
			MT_seterrno(0);
			goto again; 
*/
		}
		c->top++;
		if (doflush && bracket <= 0) {
			break;
		}
	} while(1);

	*c->top = 0;
	return 1;
}


@-
The message is parsed and entered into the queue for execution.
Currently the parser is a single resource, shared among all users,
since both lex and yacc use global datastructures.
The tree should be freed by the client at a convenient point in time.
Note that the request queue is extended with the command @%readClient()@, 
which ensures that after the block has been executed the next request is
read from the tcp connection.

yacc/lex is not thread-safe => locking is necessary!
@c
void lockparser(Client c){
	MT_set_lock(monet_parserLock, "lockparser");
	ll_client = c;
	c->cptr = c->input;
	c->cline = c->input;
	yylogstart(); /* init node allocation logging */
}

void unlockparser(Client c){
	yylogclean(); /* clean supurfluous nodes */
	c->top = c->input;
	ll_client = 0;
	MT_unset_lock(monet_parserLock, "unlockparser");
}

extern int yyparse();
 
YYSTREE parseClient(Client c, int reschedule){	
	Request cur = 0, after;
	int r;

	if (reschedule) {
		cur = thisRequest();
		after = newRequest(c->stk, c->mil_accept,1);
		after->ev_wakeup = cur->ev_wakeup;
		cur->ev_wakeup = after;
		QMmessage(after,"readCmd;");
        	putRequest(after);
	}
	lockparser(c);

	if (c->tree) {
		yyfree(c->tree);
		c->tree = NULL;
		CNTXTfree2(c->stk, c);
	}
	r = yyparse();

	unlockparser(c);

	if (reschedule && (r == 0) && c->tree) {
        	after = newRequest(c->stk, c->tree, 1);
		after->ev_wakeup = cur->ev_wakeup;
		cur->ev_wakeup = after;
		QMmessage(after,c->input);
        	putRequest(after);
	}
	return c->tree;
}

@-
A dummy client is one that receives it input from a file, executes
the content and terminates.
The client file is read relative to the starting directory of the
server unless the name indicates a complete path.
Actually it makes sense to read the complete file immediately to reduce
the number of IO calls.
@c
int scriptClient(Client c, str nme, int backup){
        FILE *fd;
	stream *s;
	char	dir[2*PATHLENGTH];

        if (c->bkin || c->bkout) {
                GDKerror("scriptClient: No nesting on input\n");
                return 0;
        }
	if (MT_path_absolute(nme)) {
		strcpy(dir,nme);
	} else {
		sprintf(dir, "%s%c%s", monet_cwd, DIR_SEP, nme);
	}
        fd = fopen(dir, "r");
        if (fd == 0) {
                GDKerror("Could not find:%s\n", dir);
                return 0;
        } 
	s = file_rastream(fd, dir );
        if (backup) {
                c->bkin = c->fdin;
                c->bkout = c->fdout;
                c->bkprompt = c->prompt;
                c->fdin = s;
        } else {
                c->fdin = GDKstdin;
        }
        c->prompt = (char*) GDKstrdup("");
        return 1;
}

int serveClient(Cntxt stk, YYSTREE lt, ValPtr res){
        int     i = 0;
        Client  c;
        Thread  t;

        if (lt->cnt != 1 || interpret(stk, lt->yysons[0], res) < 0 ||
            res->vtype != TYPE_int || ((i=res->val.ival)<0) || (i>MAXCLIENTS))
	{
                GDKwarning("serveClient: lost\n");
                return -1;
        }
	res->vtype = TYPE_void; 
        c = monet_clients + i;
        if (c->mode == FINISHED) {
                GDKwarning("serveClient: client died.\n");
                return -1;
        }
        t = THRget(THRgettid());
        if (monetSetChannel(t,  c->fdin,c->fdout)) {
                return -1;
        }
        return acceptClient(c);
}

str moduleClient(Client c, YYSTREE lt, int idents){
        str init_script=NULL;
 
        while (lt) {
	    int i; 
            for(i = 0; i < lt->cnt; i++)  {
        	str mod;
                if (!lt->yysons[i]) continue;
                if (idents && lt->yysons[i]->token == monet_tokident) {
                        mod = arg(lt, i)->yyval.val.sval;
                } else {
			ValRecord res;
			int ret = interpret(c->stk, lt->yysons[i], &res);
			if (ret < 0 || res.vtype != TYPE_str) {
				GDKerror("module: illegal argument.\n");
				return init_script;
			} 
			mod = res.val.sval; 
                }
                if (TBL_loadmod(c, mod, 0, &init_script) == 0) {
			GDKerror("module(%s): load error.\n", mod);
			return init_script;
		}
            }
            lt = lt->overflow;
        }
	return init_script;
}

int dropClient(Client c, YYSTREE lt) {
        while (lt) {
	    int i; 
            for(i = 0; i < lt->cnt; i++)  {
        	str mod;
                if (!lt->yysons[i]) continue;
                if (lt->yysons[i]->token == monet_tokident) {
                        mod = arg(lt, i)->yyval.val.sval;
                } else {
			ValRecord res;
			int ret = interpret(c->stk, lt->yysons[i], &res);
			if (ret < 0 || res.vtype != TYPE_str) {
				GDKerror("drop: illegal argument.\n");
				return 0;
			} 
			mod = res.val.sval; 
                }
                if (TBL_unloadmod(c, mod, 0) == 0) {
			return 0;
                }
            }
            lt = lt->overflow;
        }
	return 1;
}
@
@}
