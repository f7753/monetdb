@f monet_parse
@a M. L. Kersten, P. Boncz

@* Parsing BAT algebra
@T
We will discuss how BAT algebra is lexically analyzed with {\tt lex}, 
parsed with {\tt yacc}, and discuss the dunction table.

@+ The lexical analyzer
The implementation of the lexical analyzer is straightforward:
the input is read from the client message buffer, from which all
tokens are extracted.

The variable YYLMAX should be increased to handle large strings.
[It would be better to adapt the lexical analyzer to 
deal with 'infinite strings'. In fact, the input resides in the client
buffer, which is not reused until end-of-block. It can not be used,
because parse trees may be kept around for re-use]

@l

D       [0-9]
O       [0-7]
L       [_a-zA-Z]
E       [Ee][-+]?{D}+
S       [\t\n ]*
P       [-!\$%\^\*~+|?<>=/\\]
%{

#include "monet_tbl.h"
#include "monet_parse.h"

/* only needed for lex (we need  a big yytext array, since comments can
 * be lengthy. For lexis where yytext is a pointer this is not a problem
 * because they grow dynamically. But we must take care of copiing yytext
 * before any unput is called.
 */
#define YYLMAX 100000

#if (defined(WIN32) || !defined(FLEX_SCANNER) || defined(__CYGWIN32__))
extern YYSTREE yylval;
#endif
#define YY_NEVER_INTERACTIVE	1 /* workaround to flex bug */
#define YY_USE_PROTOS	  	/* make sure ANSI-C prototyes are used */

char *lexname[] = {
 "TOK_ITERTEMP", "TOK_TEMPLATE", "TOK_VARTEMP", "TOK_RANGETEMP",
 "TOK_CONSTANT", "TOK_ASSIGNMENT", "TOK_SEQBLOCK", "TOK_SEQ", "TOK_PARBLOCK", 
 "TOK_PAREND", "TOK_IDENT", "TOK_IF", "TOK_WHILE", "TOK_ITERATOR", 
 "TOK_ITCOMPILED", "TOK_BREAK", "TOK_RETURN", "TOK_VAR", "TOK_ATOM", 
 "TOK_CONST", "TOK_BUILTIN", "TOK_CAST", "TOK_BATCAST", "TOK_BATCONV", 
 "TOK_TRG", "TOK_FUNCTION", "TOK_PROC", "TOK_COMPILED", "TOK_COMMAND", 
 "TOK_OPERATOR", "TOK_SETOP", "TOK_ASSIGNOP", "TOK_SETAGGR", "TOK_PROCDEF", 
 "TOK_ACC", "TOK_STRING", "TOK_OBJECT", "TOK_ITERATION", "TOK_ELSE", "TOK_BAT", 
 "TOK_BACK", "TOK_TRGDEF", "TOK_ON", "TOK_MODULE", "TOK_DROP", "TOK_EVENT", 
 "TOK_ANY", "TOK_UNDEF", "TOK_DEREF", "TOK_ANYNUM", 0, };

char *LEXNAME(Y)           { if (Y >= TOK_ITERTEMP && Y <= TOK_ANYNUM) {
                                return lexname[Y-TOK_ITERTEMP];
                             } else {
                                return "char";
                           } }
#define RETURN(Y)	{ PARSEDEBUG {\
				THRprintf(GDKerr, "%s %s\n", LEXNAME(Y), yytext);\
			     } return Y; }
#ifdef FLEX_SCANNER
#define YY_INPUT(buf,result,max_size)	{ int c = ll_getch();\
                           result = (c==0) ? YY_NULL: (buf[0] = (char)c,1);}
#else
#undef input
#define input()		(yytchar = yysptr > yysbuf?U(*--yysptr):ll_getch())
#endif
#define Symbol(X)	{ RETURN (X); }
#define Vector(X,Y,Z,V,L)	{ yylval = yylognode(X, Y);                      \
                             yylval->yyval.val.Z = V;                       \
                             yylval->yyval.len = L;                         \
                             RETURN (X); }
#define Function(X,V)	if ((X)==TOK_BUILTIN) {\
				Vector(X, TYPE_ptr, pval, (ptr) V, 0);\
			   } else {\
				str _s = GDKstrdup(V);\
				Vector(X, TYPE_str, sval, _s, strLen(_s));\
			   }

void ll_flushbuffer() {	
#ifdef FLEX_SCANNER
	YY_FLUSH_BUFFER;
#else
	extern char yytext[];
	bzero(yytext, YYLMAX);
#endif
}

#define TBLSEARCH(r,s,token,hint) \
	{ char offend = ' '; \
	  while(GDKisspace(offend)) offend = input(); \
	  unput(offend); \
	  r = TBL_search(s, token, hint&&(offend == '(')); }
%}
%p 3400
%a 2300
%e 2000
%%
"#"                   { return ll_skipcomment();                              }
("nil"|"NIL")         { Vector(TOK_CONSTANT, TYPE_void, ival, void_nil, 0);   }
("proc"|"PROC")       { Symbol(TOK_PROCDEF);                                  }
("undef"|"UNDEF")     { Symbol(TOK_UNDEF);                                    }
("return"|"RETURN")   { Symbol(TOK_RETURN);                                   }
("break"|"BREAK")     { Symbol(TOK_BREAK);                                    }
("while"|"WHILE")     { Symbol(TOK_WHILE);                                    }
("if"|"IF")           { Symbol(TOK_IF);                                       }
("else"|"ELSE")       { Symbol(TOK_ELSE);                                     }
("false"|"FALSE")     { Vector(TOK_CONSTANT, TYPE_bit, cval[0], 0, 0);        }
("var"|"VAR")         { Symbol(TOK_VAR);                                      }
("const"|"CONST")     { Symbol(TOK_CONST);                                    }
("true"|"TRUE")       { Vector(TOK_CONSTANT, TYPE_bit, cval[0], 1, 0);        }
("trigger"|"TRIGGER") { Symbol(TOK_TRGDEF);                                   }
("event"|"EVENT")     { Symbol(TOK_EVENT);                                    }
("on"|"ON")           { Symbol(TOK_ON);                                       }
("module"|"MODULE")   { if (!ll_modcmds) Symbol(TOK_MODULE);goto command;     }
("any"|"ANY")         { Vector(TOK_ANY, TYPE_int, ival, -1, 0);               }
"$("                  { Symbol(TOK_VARTEMP);                                  }
".."                  { Symbol(TOK_RANGETEMP);                                }
"::"                  { Symbol(TOK_ANYNUM);                                   }
("$h"|"$H"|"$head"|"$HEAD") { Vector(TOK_ITERTEMP, TYPE_int, ival, 1, 0);     }
("$t"|"$T"|"$tail"|"$TAIL") { Vector(TOK_ITERTEMP, TYPE_int, ival, 2, 0);     }
"$"{D}+               { Vector(TOK_TEMPLATE,TYPE_int,ival,atol(yytext+1),0);  }
":="                  { Symbol(TOK_ASSIGNMENT);                               }
"(*"                  { Symbol(TOK_DEREF);                                    }
"[*"                  { Symbol(TOK_SETOP);                                    }
"{*"                  { Symbol(TOK_SETAGGR);                                  }
"@"                   { Symbol(TOK_ITERATION);                                }
"../"                 { Symbol(TOK_BACK);                                     }
(":"{P}({P}|{L}|{D})*"=") |
({P}({P}|{L}|{D})*)   { int i; char *s = yytext;
		 	if ((!s[1]) && (*s=='~' || *s=='?' || *s==':')) { 
                            Symbol(*s); 
	                } else { 
                            if (ll_resolution) {
                                s = TBL_search(yytext, &i, FALSE);
				if (s != NULL){ Function(i,s); }
                            }
			    REJECT
                        }                                                     }
({P}+) | 
(":"{P}+"=") | 
(":"{L}({L}|{D})*"=") |
({L}({L}|{D})*"="?)  {
command:             {  int i, l = strlen(yytext);
			char *s, *t = (str) alloca(l+1); 
			strcpy(t,yytext); /* copy yytext before unput */
                        if (ll_resolution) {
                            TBLSEARCH(s, t, &i, TRUE);
			    if (s != NULL) {
                                Function(i,s);
                            }
                            s = BUNfnd(ll_client->acctbl, t);
			    if (s != NULL) {
                                i = *(int *) BUNtail(ll_client->acctbl,s);
                                Vector(TOK_ACC, TYPE_int, ival, i, 0); 
                            }
#ifdef MKMODS
                            s = (char*) TEMsearch(t);
			    if (s != NULL) {
                                Vector(TOK_TRG, TYPE_ptr, sval, s, 0);
                            }
#endif
                        }
			s = GDKstrdup(t);
                        Vector(TOK_IDENT, TYPE_str, sval, s, 0);              }}

("["{L}({P}|{L}|{D})*"]") | 
("[:"{L}({P}|{L}|{D})*"=]") |
("{"{L}({L}|{D})*"}") | 
("["{P}+"="?"]") |
("[:"{P}+"=]")      {   int i, l = strlen(yytext);
			char *s, *t = (str) alloca(l+1); 
			strcpy(t,yytext); /* copy yytext before unput */
                        if (ll_resolution) {
			    char cb = t[l-1];  /* save bracket */
                            TBLSEARCH(s, t, &i, FALSE);
                            if (s) {
                               Function(i,s);
                            }
			    t[l-1] = 0; /*remove last bracket*/
                            TBLSEARCH(s, t+1, &i, TRUE);
                            if (s != NULL) {
				if (i == TOK_BUILTIN) {
				   GDKerror("yyparse: cannot use a %cBUILTIN%c()\n", *t, (*t=='[')?']':'}');
				} else if (i!=TOK_ASSIGNOP || *t == '[') {
				   t[l-1] = cb;
				   s = GDKstrdup(t);
                                   Function(i,s);
				}
                            }
                        }
                        yyleng--; 
		        unput((*t == '[')?']':'}');
                        while(--yyleng > 0) unput(t[yyleng]);
                        Symbol(*t);                                      }
("-")?{D}+"LL"        { lng val, *p = &val; int l=sizeof(lng);
			lngFromStr(yytext, &l, &p); 
		        Vector(TOK_CONSTANT, TYPE_int, lval, val, 0);}
("-")?{D}+            { int val, *p = &val; int l=sizeof(int);
			intFromStr(yytext, &l, &p); 
		        Vector(TOK_CONSTANT, TYPE_int, ival, val, 0);}
{D}+"@"{D}+           { oid obj, *p=&obj; int l=sizeof(oid);
			OIDfromStr(yytext, &l, &p);
			Vector(TOK_CONSTANT, TYPE_oid, oval, obj, 0);         } 
("-")?{D}+"."{D}+({E})?"LL" |
("-")?"."{D}+({E})?"LL"     |
("-")?{D}+{E}"LL"     { dbl val, *p = &val; int l = sizeof(dbl);
			dblFromStr(yytext, &l, &p); 
			Vector(TOK_CONSTANT, TYPE_dbl, dval, val, 0);         } 
("-")?{D}+"."{D}+({E})? |
("-")?"."{D}+({E})?     |
("-")?{D}+{E}         { flt val, *p = &val; int l = sizeof(flt);
			fltFromStr(yytext, &l, &p); 
			Vector(TOK_CONSTANT, TYPE_flt, fval, val, 0);         } 
"'"\\0{O}({O})?({O})?"'" {int i; sscanf(yytext+2, "%o", &i);
                        Vector(TOK_CONSTANT, TYPE_chr, cval[0], i, 0);        }
\"[^\n"]* 	      { int len, offending_chr = input(); 
			str s = ll_getstr(yytext, yyleng, offending_chr);
			if (s) {
				len = strlen(s);
				len = strFromStr(s, &len, &s); 
                            	Vector(TOK_STRING, TYPE_str, sval, s, len);
			} else {
				unput('"');
			}                                                     }
\'[^\n\']* 	      { int len, offending_chr = input(); 
			char val, *p = &val;
			str s = ll_getstr(yytext, yyleng, offending_chr);
			if (s) {
				len = strlen(s);
				chrFromStr(s, &len, (ptr)&p); 
				GDKfree(s);
                            	Vector(TOK_CONSTANT, TYPE_chr, cval[0], val, 0);
			} else {
				unput('\'');
			}                                                     }
"{|"                  { Symbol(TOK_PARBLOCK);                                 }
"|}"                  { Symbol(TOK_PAREND);                                   }
{S}                   ;
.                     { Symbol(*yytext);                                      }
%%
int ll_skipcomment() { char c; while ((c=input()) && (c != '\n')); return yylex();}
@
@-
The routine @%ll_getch@ manipulates the input buffer for the current
client indicated by @%ll_client@.
@c
#include "monet_parse.h"

Client 	   ll_client = 0;
int	   ll_nlines=0;		  /* current number of string chunks */ 
int	   ll_maxlines=0; 	  /* maximum number of string chunks */
str*	   ll_lines=0;		  /* string chunks */

typedef struct _strstack_t {
	str buf, cptr, cline;
	struct _strstack_t *up;
} strstack;

strstack  *ll_stack = NULL;

int ll_push(str s) {
	strstack *sp = (strstack*) GDKmalloc(sizeof(strstack));
	sp->cptr = sp->cline = ll_client->cptr; 
	ll_client->cline = ll_client->cptr = sp->buf = s;  
	sp->up = ll_stack;
	ll_stack = sp;
	return 1;
}

int ll_pop() {
	strstack *sp = ll_stack;
	if (ll_stack) {
		ll_stack = sp->up;
		ll_client->cptr = sp->cptr;
                ll_client->cline = sp->cline;
		GDKfree(sp->buf);
		GDKfree(sp);
		return 1;
	}
	return 0;
}

int ll_getch() {
        char ch;

        if (ll_client == 0) {
                GDKfatal("no client for lexical.\n"); 
        }
   	do {
        	ch = *ll_client->cptr; 
	} while (ch == 0 && ll_pop());

        if (ch == '\n') {
                if (ll_client->listing) {
                    if (!monet_modulesilent || !ll_stack) {
                        *ll_client->cptr = 0;
                        fputs(ll_client->cline, ll_client->fdout); 
                        fputc('\n', ll_client->fdout); 
                        fflush(ll_client->fdout); 
                        *ll_client->cptr = '\n';
		    }
                }
                ll_client->cline = ll_client->cptr + 1; 
        } 
        if (ch) ll_client->cptr++;
        return ch; 
}


void ll_init() {	
	ll_lines = (str*) GDKmalloc((ll_maxlines=500)*sizeof(str)); 
}

str ll_lastline(){
        static char line[1024];
        char *l=line, *s = ll_client->cline;
	int c = *s--;

        if (ll_emptychar(c)) {
                while((s >= ll_client->input) && ll_emptychar(c = *s)) s--;
                while((s >= ll_client->input) && *s && (*s != '\n')) s--;
        }
	if (ll_client->cline - s > 512) {
		s = ll_client->cline - 40;
	}
        while ((c = *++s) != 0) {
                if (c == '\n' || l > line+1000) break;
                *l++ = c;        
        }
	*l = 0;
        return line;
}

str ll_getstr(char *buf, int len, int offending) {
	static int ll_buf_len, ll_border;
	int escape = 0;
	str p;

	if (ll_nlines == 0)  { /* first call of sequence? */
		ll_buf_len = 0;
		ll_border = buf[0];
	}

	/* find out if the string goes on */
	for(p=buf+len-1; p >= buf; p--) {
		if (*p != '\\') break;
                else escape = escape?0:1; 
	}
	if (escape) {
		/* it goes on; append this line to the ll_lines array */
		ll_lines[ll_nlines++] = p = (str) GDKmalloc(len+2);
		if (ll_nlines >= ll_maxlines) {
		     ll_lines = (str*) GDKrealloc((int*)ll_lines, (ll_maxlines*=2)*sizeof(str));
		}
		if (offending == '\n') {
			len--;
		} else /* enter border char */ { 
			buf[len++] = ll_border; 
		}
		memcpy(p, buf+1, len); 
		p[len-1] = 0; 

		/* increment the total length of the buffer */
		ll_buf_len += len; 
		return NULL;
	}
	/* concat all */
	ll_lines[ll_nlines] = buf+1;
	p = buf = GDKmalloc(ll_buf_len+len+3);
	*p++ = ll_border;
	for(len=0; len < ll_nlines; len++) {
		strcpy(p, ll_lines[len]);
		p += strlen(ll_lines[len]);
		GDKfree(ll_lines[len]);
	}
	strcpy(p, ll_lines[len]);
	p += strlen(ll_lines[len]);
	*p++ = ll_border; 
	*p++ = 0;
	ll_nlines = 0; /* ready */

	return buf; /* return concatenated string and its length*/
}

@+ The Parser
@h 
#ifndef _MONET_PARSE_H
#define _MONET_PARSE_H

#include "monet.h"
#include "monet_client.h"

#define YY_NEVER_INTERACTIVE	1		/* bison brain damage evasion */

extern int        ll_modcmds;           /* are "module" cmd or tokens? */
extern int        ll_resolution;        /* perform ident-->MIL resolution */
extern Client     ll_client;
extern int        ll_nlines;            /* current number of string chunks */
extern int        ll_maxlines;          /* maximum number of string chunks */
extern str*       ll_lines;             /* string chunks */

#define ll_emptychar(x)	((x == 0) || GDKisspace(x))

#endif /* _MONET_PARSE_H */

@- Global variables for YACC 
@c
int        ll_parblockdepth = 0;  /* nesting depth of paralellism. */
int        ll_templates = 0;      /* are templates currently allowed? */
int        ll_modcmds = 0;        /* are "module" cmd or tokens? */
int        ll_resolution = 1;     /* perform ident-->MIL resolution */
YYSTREE    ll_firstnode,ll_sugarnode;/* for parsing OO sugar syntax XX.op(YY) */
int        ll_argc = 0;           /* */
char       ll_ifthenelse[] = "[ifthenelse]";
char       ll_ifelse[] = "[ifelse]";
char       ll_ifthen[] = "[ifthen]";
char       ll_project[] = "project";
char       ll_reverse[] = "reverse";

@-
The Monet interpreter languages provides a sugar version to OO
programming by considering the first argument the receiver of the method.
@c
YYSTREE yysugar(YYSTREE node){
        YYSTREE t = yylognode(0, 0);
        if (node) {
                yylogexpand(t, node); /* put the sugar argument in front. */
        }
        ll_sugarnode = NULL; 
        return t;
}

int yywrap() { return 1; }

@- The YACC Grammar
@T
A parse tree is build during parsing, such that a compact
representation for function calls result. 

The code below is
{\tt yacc} input format. Executing {\tt yacc} produces the file 
{y.tab.c}, which contains the parsing routine {\tt yyparse()}. It
parses the grammar, executing the inlined C statements along its way. 
@
@y


%{
#ifndef YYSTYPE
#define YYSTYPE	YYSTREE
#endif

#include <stdlib.h>
#include "monet.h"
#include "monet_client.h"

#define YYDEBUG	1

#undef yyerror
#define yyerror(X)	{ ll_parserror(NULL);  }
#define yylogkill(t)	(t)->yyval.vtype = TYPE_void;
#define yylogfree(t)	
@y
extern int	  ll_nlines, ll_maxlines;
extern str*	  ll_lines;		
extern int        ll_parblockdepth; 
extern int        ll_resolution; 
extern int        ll_modcmds; 
extern YYSTREE    ll_firstnode, ll_sugarnode; 
extern int        ll_templates; 
extern int        ll_argc; 
extern char       ll_ifthenelse[], ll_ifelse[], ll_ifthen[], ll_project[], ll_reverse[];

extern YYSTREE yysugar(YYSTREE node);
%}

%token TOK_ITERTEMP TOK_TEMPLATE TOK_VARTEMP TOK_RANGETEMP
%token TOK_CONSTANT TOK_ASSIGNMENT TOK_SEQBLOCK TOK_SEQ TOK_PARBLOCK 
%token TOK_PAREND TOK_IDENT TOK_IF TOK_WHILE TOK_ITERATOR 
%token TOK_ITCOMPILED TOK_BREAK TOK_RETURN TOK_VAR TOK_ATOM 
%token TOK_CONST TOK_BUILTIN TOK_CAST TOK_BATCAST TOK_BATCONV TOK_TRG
%token TOK_FUNCTION TOK_PROC TOK_COMPILED TOK_COMMAND TOK_OPERATOR
%token TOK_SETOP TOK_ASSIGNOP TOK_SETAGGR TOK_PROCDEF TOK_ACC
%token TOK_STRING TOK_OBJECT TOK_ITERATION TOK_ELSE TOK_BAT
%token TOK_BACK TOK_TRGDEF TOK_ON TOK_MODULE TOK_DROP TOK_EVENT
%token TOK_ANY TOK_UNDEF TOK_DEREF TOK_ANYNUM 
%%
program:
        monet_session 
	{ ll_client->tree = $1; yypostprocess(ll_client->tree);               }
    |   error ';' { ll_clrids(); yyerrok; yyclearin; return 1; }
    |   /* empty */ 

monet_session:
        session 
        {   if (!$1 || $1->token != TOK_SEQ) {
                $$ = yylognode(TOK_SEQ, 0);
                if ($1) yylogexpand($$, $1);
            } else $$ = $1;                                                   }
    |   monet_session session 
        {   $$ = $1; if ($2) yylogexpand($$, $2);                             }

session:
        ';'
        {   $$ = 0 ;                                                          }
    |   definition 
        {   $$ = 0 ;                                                          }
    |   statement 
        {   $$ = $1;                                                          }
    |   TOK_MODULE { ll_resolution = 0; } '(' modidents ')' ';' 
        {   str initstr;
	    ll_resolution = 1; 
	    /* EXECUTE MODULE LOAD *DURING* PARSE!!*/
	    initstr = moduleClient(ll_client, $4, TRUE);
	    if (initstr != NULL) {
		ll_push(initstr);
	    }
            $$=0; yylogfree($4);                                                    }


definition:
        proc_definition 
@
#ifdef MKMODS 
    |   event_definition 
    |   trigger_definition 

trigger_definition:
        TOK_TRGDEF TOK_IDENT header 
        {   ll_modcmds = ll_templates = 1;}
        event_expression statement
        {   if ($3) {
		YYSTREE t = yylognode(TOK_SEQBLOCK, 0);
		yylogexpand(t, $3); yylogexpand(t, $6);
		$6 = t;
	    }
	    yylogout($6);
            TEMdefTrigger(ll_client, $2, $5, $6); 
            ll_modcmds = ll_templates = 0;                                    }
 
event_expression:
        TOK_ON event_term
        {   $$= yylognode(0,0); yylogexpand($$, $2);                          }
    |   event_expression ',' event_term
        {   $$= yylogexpand($1, $3);                                          }
 
event_term: event_item {   
            $$ = (ptr) TEMnewevent(0, $1, 0);
        } | '~' event_item {   
            $$ = (ptr) TEMnewevent(0, $2, 1);
        } | event_item '.' event_item {   
            $$ = (ptr) TEMnewevent($1, $3, 0);
        } | '~' event_item '.' event_item {    
            $$ = (ptr) TEMnewevent($2, $4, 1);
        }


event_item : TOK_IDENT
        {   $$ = $1;                                                          }
        | TOK_TEMPLATE
        {   $$ = $1;                                                          }

event_definition: 
        TOK_EVENT TOK_IDENT ';' {   $$ = NULL; 
            TEMdefEvent(ll_client, $2->yyval.val.sval);
        }
#endif /* MKMODS */
@y
statement_seq:
        /* empty */
        {   $$ = yylognode(TOK_SEQ,0);                                        }
    |   statement_list 
        {   $$ = $1;                                                          }

statement_list:
        statement 
        {   $$ = $1;                                                          }
    |   statement_list statement
        {   if ($1->token != TOK_SEQ) {
                 $$ = yylognode(TOK_SEQ, 0);
                 yylogexpand($$, $1);
            } else  $$ = $1;
            yylogexpand($$, $2);                                              }

statement:
        nonvar_statement
        {   $$ = $1;                                                          }
    |   TOK_VAR varidents ';'
        {   $$ = $2; $2->token = TOK_VAR;                                     }
    |   TOK_CONST constidents ';'
        {   YYSTREE t=$2,tt, n = yylognode(TOK_BUILTIN, TYPE_ptr);
            int i; int CMDconstant = 0;
            n->yyval.val.pval = (ptr) CMDconstant;
            $$ = yylognode(TOK_SEQ,0); 
            $2->token = TOK_VAR;
            yylogexpand($$, $2); yylogexpand($$,n);
	    while(t) { 
                for(i=0; i<t->cnt; i++) 
                if (t->yysons[i]) {
                    yylogexpand(n, tt=yylognode(TOK_IDENT, TYPE_str));
                    tt->yyval.val.sval=GDKstrdup(t->yysons[i]->yyval.val.sval);
                }
                n->cnt = t->cnt;
                if ((t=t->overflow) != NULL) { 
                    n->overflow=yylognode(0,0); n=n->overflow;
                } 
            }                                                                 }

nonvar_statement:
        simple_expression { ll_firstnode = $1; } expr_rest 
        { ll_sugarnode = $3; } expr_statement 
        {    $$ = $5;                                                         }
    |   blk_expression
        {    $$ = $1;                                                         }
    |   TOK_RETURN ret_value ';'
        {    $$ = yylognode(TOK_RETURN, 0); 
             if ($2) yylogexpand($$, $2);                                     }
    |   TOK_WHILE '(' expression ')' nonvar_statement 
        {    $$ = yylognode(TOK_WHILE, 0); 
             yylogexpand($$, $3); yylogexpand($$, $5);                        }
    |   TOK_IF '(' expression ')' nonvar_statement else_statement
        {    $$ = yylognode(TOK_IF, 0); 
             yylogexpand($$, $3); yylogexpand($$, $5);
             if ($6) yylogexpand($$, $6);                                     }
    |   TOK_BREAK ';'
        {    $$ = yylognode(TOK_BREAK, 0);                                    } 

expr_statement:
        ';'
        {   $$ = ll_sugarnode; ll_sugarnode = NULL;                           }
    |   TOK_ITERATION parallel TOK_ITERATOR expression_list 
        {   $$ = (ptr) ll_templates; ll_templates = 1; } nonvar_statement
        {   ll_templates = ($5 != NULL);
            yylogexpand($3, $6); yylogexpand($3, $4); 
            if ($2) yylogexpand($3, $2); $$ = $3;                             }

else_statement:
        TOK_ELSE nonvar_statement
        {   $$ = $2;                                                          }
    |   /* empty */
        {   $$ = NULL;                                                        }

ret_value:
        expression 
        {   $$ = $1;                                                          }
    |       /* empty */        
        {   $$ = NULL;                                                        }

parallel:
        '[' expression ']' 
        {   $$ = $2;                                                          }
    |   /* empty */
        {   $$ = NULL;                                                        }

sequential_block:
        '{' { $$=(YYSTREE)ll_modcmds; ll_modcmds=1; } statement_seq '}'
        {   ll_modcmds = ($2 != NULL);
	    $$ = $3;
            if ($3->token == TOK_SEQ || $3->token == TOK_SEQBLOCK) {
                    $3->token = TOK_SEQBLOCK;
            } else if ($3->token != TOK_PARBLOCK) {
                    $$ = yylognode(TOK_SEQBLOCK, 0);
                    if ($3) yylogexpand($$, $3);
            }                                                                 } 

parallel_block:
        TOK_PARBLOCK {ll_parblockdepth++; $$=(YYSTREE)ll_modcmds;ll_modcmds=1;}
	statement_seq TOK_PAREND 
        {   ll_modcmds = ($2 != NULL);
	    if (--ll_parblockdepth == 0) ll_clrids();
            if ($3->token == TOK_SEQBLOCK ||
                $3->token == TOK_SEQ ||
                $3->token == TOK_PARBLOCK) 
            {
                $$ = $3;
                $$->token = TOK_PARBLOCK;
            } else {
                $$ = yylognode(TOK_SEQBLOCK, 0);
                yylogexpand($$, $3);
            }                                                                 }

assignment:
        TOK_ASSIGNMENT expression
        {   $$ = $2;                                                          }
    |   /* empty */
        {   $$ = NULL;                                                        }

variable_reference:
        TOK_IDENT assignment
        {   ll_idconflict($1->yyval.val.sval);
            $1->yyval.len = 0; /* var depth.. */
	    if ($2) {
                $$ = yylognode(TOK_ASSIGNMENT, 0);
                yylogexpand($$, $1); yylogexpand($$, $2);
            } else $$ = $1;                                                   }
    |   template assignment
        {   $1->yyval.len = 0;
            if ($2) {
                $$ = yylognode(TOK_ASSIGNMENT, 0);
                yylogexpand($$, $1); yylogexpand($$, $2);
            } else $$ = $1;                                                   }

proc_definition:
        TOK_PROCDEF proc_name proc_header 
	proc_assign { ll_templates = ll_modcmds = 1; } statement

        {   YYSTREE sig = (YYSTREE) ($3?$3->yyval.val.pval:NULL);
            YYSTREE ret = (YYSTREE) (sig?sig->yyval.val.pval:NULL);
	    int params = ($3 && $3->cnt > 0);

	    if (params || (($6->token != TOK_SEQ) &&
	   	           ($6->token != TOK_SEQBLOCK) &&
                           ($6->token != TOK_PARBLOCK)))
            {
                $$ = yylognode((params)?TOK_SEQBLOCK:TOK_SEQ, 0);
		if (params) yylogexpand($$, $3); 
		yylogexpand($$, $6);
            } else {
                $$ = $6;
            }
	    if ($3 && $3->cnt == 0) {
		yylogfree($3);
	    }
            $$->yyval = $2->yyval;
	    $2->yyval.vtype = TYPE_void;

            /* DIRECT: insert the new proc */         
	    yylogout($$);
            TBL_newproc(ll_client, $2->yyval.val.sval, $$, sig, ret); 
	    if (sig) yylogfree(sig);
	    if (ret) yylogfree(ret);
            ll_modcmds = ll_templates = 0;                                    }
    |   TOK_PROCDEF proc_name ';'
        {   yylogout($2);
	    TBL_newproc(ll_client, $2->yyval.val.sval, $2, $2, NULL); 
            $2->token = TOK_CONSTANT;
            $2->yyval.vtype = TYPE_int;                                       }
    |   TOK_UNDEF TOK_PROC ';'
        {   TBL_delproc(ll_client, $2->yyval.val.sval, TRUE); /* DIRECT */  }

proc_assign:
	TOK_ASSIGNMENT
    |	/* empty */

proc_name:
        TOK_IDENT
	{ $$ = $1; $1->token = TOK_PROC;                                      }
    |   TOK_STRING
        { $$ = $1; $1->token = TOK_PROC;                                      }
    |   TOK_ATOM
        { $$ = $1; $1->token = TOK_PROC;                                      }
    |   TOK_COMMAND
	{ $$ = $1; $1->token = TOK_PROC;                                      }
    |   TOK_OPERATOR
	{ $$ = $1; $1->token = TOK_PROC;                                      }
    |   TOK_PROC
        { $$ = $1; }

proc_header: 
        '(' mel_header ')' mel_return
        {   YYSTREE header = (YYSTREE) $2->yyval.val.pval;   
	    if (header) {
		header->yyval.val.pval = $4;
		header->yyval.vtype = TYPE_ptr;
            } $$ = $2;                                                        }
    |   /* empty */
        {   $$ = NULL;                                                        }

mel_header:
	mel_params mel_tail
        {   YYSTREE h = (YYSTREE) $1->yyval.val.pval;   
            $$ = $1; if ($2) yylogexpand(h,$2);                               }
    |   mel_range
        {   YYSTREE n = yylognode(0,0); yylogexpand(n,$1);
	    $$ = yylognode(0,TYPE_ptr); $$->yyval.val.pval = (ptr) n;         }
    |   /* empty */
        { $$ = yylognode(0,TYPE_ptr); 
          $$->yyval.val.pval = (ptr) yylognode(0,0);                          }

mel_tail:
	',' mel_range
        {   $$ = $2;                                                          }
    |	/* empty */
        {   $$ = NULL;                                                        }

mel_range:
	TOK_RANGETEMP mel_type TOK_RANGETEMP 
        {   $$ = yylognode(TOK_RANGETEMP,0); yylogexpand($$,$2);              }
 
mel_params:
        mel_type TOK_IDENT
        {   YYSTREE temp = yylognode(TOK_TEMPLATE, TYPE_int);
            YYSTREE sig = yylognode(0,0);                        
	    yylogexpand(sig, $1);
	    ll_argc = 0; temp->yyval.val.ival = ++ll_argc;
	    $2->token = TOK_ASSIGNMENT;
	    yylogexpand($2, yylognode(TOK_TEMPLATE,0)); yylogexpand($2, temp); 
            $$ = yylognode(TOK_VAR,TYPE_ptr); yylogexpand($$, $2);
	    $$->yyval.val.pval = (ptr) sig;                                   }
    |   mel_params ',' mel_type TOK_IDENT
        {   YYSTREE temp = yylognode(TOK_TEMPLATE, TYPE_int);
            YYSTREE sig = (YYSTREE) $1->yyval.val.pval;
	    yylogexpand(sig, $3);
	    temp->yyval.val.ival = ++ll_argc;
	    $4->token = TOK_ASSIGNMENT;
	    yylogexpand($4, yylognode(TOK_TEMPLATE,0)); yylogexpand($4, temp); 
            yylogexpand($1, $4); $$ = $1;                                     }

mel_type:
	TOK_ATOM mel_bat
	{ $$ = ($2 && $2->token == TOK_ATOM)?$2:NULL;
	  if ($2 && strcmp($2->yyval.val.sval,"BAT")) {
                ll_parserror("only bat types are parametrized");
	  } else if ($2 == NULL && strcmp($1->yyval.val.sval, "BAT")==0) {
		YYSTREE any1 = yylognode(TOK_ANY,TYPE_int); 
		YYSTREE any2 = yylognode(TOK_ANY,TYPE_int); 
		any1->yyval.val.ival = any2->yyval.val.ival = -1;
		$$ = yylognode(TOK_ATOM,TYPE_str);
	        $$->yyval.val.sval = GDKstrdup(BATatoms[TYPE_bat].name);
		yylogexpand($$, any1); 
		yylogexpand($$, any2);
	  }  
	  if ($$ == NULL) {
		yylogexpand($$=$1,$2); 
	  } else {
 		yylogfree($1);
          }                                                                   }
    |   mel_other
	{ $$ = $1;                                                            }

mel_bat:
	'[' mel_atom ',' mel_atom ']'
        { $$ = yylognode(TOK_ATOM,TYPE_str); 
	  $$->yyval.val.sval = GDKstrdup(BATatoms[TYPE_bat].name);
	  yylogexpand($$,$2); yylogexpand($$,$4);         		      }
    |   /* empty */
	{ $$ = NULL;                                                          }

mel_atom:
        TOK_ATOM
	{ $$ = $1;                                                            } 
    |   mel_other
	{ $$ = $1;                                                            }

mel_other:
        TOK_ANY mel_any
	{ $$ = $1; 
	  if ($2) { $$->yyval = $2->yyval; yylogfree($2); }                   }
    |   /* omitted type spec is an 'any' type without restrictions */
	{ $$ = yylognode(TOK_ANY,TYPE_int);
	  $$->yyval.val.ival = -1;                                            }

mel_any:
	TOK_ANYNUM TOK_CONSTANT 
	{ $$ = $2; if ($2->yyval.vtype != TYPE_int) 
               	ll_parserror("any::<int> expected");                       }
    |   /* empty */
	{ $$ = NULL;                                                          }

mel_return:
	':' mel_type
	{ if ($2->token == TOK_ANY && $2->yyval.val.ival == 0) {
	      yylogfree($2); $2 = NULL;
          } $$ = $2;                                                          }
    |   /* empty */
	{ $$ = NULL;                                                          }

expression:
        simple_expression { ll_firstnode = $1; } expr_rest
        {   $$ = $3;                                                          }
    |   blk_expression
        {   $$ = $1;                                                          }

blk_expression:
        sequential_block
        {   $$ = $1;                                                          }
    |   parallel_block
        {   $$ = $1;                                                          }

expr_rest:
        '.' {ll_sugarnode = ll_firstnode; } command_expression 
        { ll_firstnode = $3; } expr_rest
        {   $$ = $5;                                                          }
    |   operator_expression { ll_firstnode = $1; } expr_rest
        {   $$ = $3;                                                          }
    |   /* empty */
        {   $$ = ll_firstnode;                                                }

simple_expression:
        deref_or_simple_expression 
        {   $$ = $1;                                                          }
    |   constant_expression
        {   $$ = $1;                                                          }
    |   variable_reference
        {   $$ = $1;                                                          }
    |   { ll_sugarnode = NULL; } command_expression
        {   $$ = $2;                                                          }

deref_or_simple_expression:
        TOK_DEREF expression ')' expression_list
        {   $$ = yylognode(TOK_FUNCTION,0);
            yylogexpand($$,$2); yylogexpand($$,$4);                           }
    |	TOK_SETOP expression ']' expression_list
        {   $$ = yylognode(TOK_SETOP,0);
            yylogexpand($$,$2); yylogexpand($$,$4);                           }
    |	TOK_SETAGGR expression '}' expression_list
        {   $$ = yylognode(TOK_SETAGGR,0);
            yylogexpand($$,$2); yylogexpand($$,$4);                           }
    |   '(' expression ')'
        {   $$ = $2;                                                          }

temptok:
        TOK_TEMPLATE
        {   if (!ll_templates) {
                ll_parserror("template not in procedure body");
                $$->token = TOK_CONSTANT;
            } else { $$ = (YYSTREE) $1; }                                     }
    |   TOK_ITERTEMP
        {   if (!ll_templates) {
                ll_parserror("template not in iterator body");
                $$->token = TOK_CONSTANT;
            } else { $$ = (YYSTREE) $1; }                                     }

template:
        temptok
        {   $$ = $1; }
    |   TOK_VARTEMP expression rangetemp
	{   $$ = yylognode($3, 0);
	    yylogexpand($$,$2); }

rangetemp:
	')'
	{ $$ = (YYSTREE) TOK_VARTEMP; }
    | 	TOK_RANGETEMP ')'
	{ $$ = (YYSTREE) TOK_RANGETEMP; }

constant_expression:
        TOK_CONSTANT
        {   $$ = $1;                                                          }
    |   TOK_STRING
        {   $$ = $1; $$->token = TOK_CONSTANT;                                }
    |   TOK_ACC
        {   $$ = $1; $$->token = TOK_CONSTANT;                                }
    | '[' multiplex_expression ']'
	{   $$ = $2; 							      }

multiplex_comma: ',' |	'~' 

multiplex_expression:
      expression multiplex_conditional
	{   $$ = $2; $$->yysons[0] = $1;                                      }
    | multiplex_reversed 
      expression multiplex_conditional
        {   $$ = $2; $$->yysons[0] = $1;                                      }
    | multiplex_reversed
        {   $$ = yylognode(TOK_FUNCTION, TYPE_str);
            $$->yyval.val.sval = GDKstrdup(ll_reverse);
            $1->yyval.val.sval = GDKstrdup(ll_project); yyexpand($$,$1);      }

multiplex_reversed:
        multiplex_comma expression
	{   $$ = yylognode(TOK_FUNCTION, TYPE_str);
	    $1 = yylognode(TOK_FUNCTION, TYPE_str);
            $1->yyval.val.sval = GDKstrdup(ll_reverse);
	    yyexpand($1, $2); yyexpand($$, $1); 
	    yyexpand($$, yylognode(TOK_CONSTANT,TYPE_void));}
    |   TOK_CONST expression multiplex_comma expression 
	{   $$ = yylognode(TOK_FUNCTION, TYPE_str);
	    $1 = yylognode(TOK_FUNCTION, TYPE_str);
            $1->yyval.val.sval = GDKstrdup(ll_reverse);
 	    yyexpand($1,$4); yyexpand($$,$1); yyexpand($$,$2);                }

multiplex_conditional:
	multiplex_comma bat_expression 
	{   $$ = yylognode(TOK_FUNCTION, TYPE_str); $$->cnt = 1;
	    $$->yyval.val.sval = GDKstrdup(ll_project);
	    if ($2->token == 0) { $2->token = TOK_CONSTANT; }
	    yyexpand($$, $2);                                                 }
    |   '?' bat_expression ':' bat_expression 
        {    $$ = yylognode(TOK_FUNCTION, TYPE_str); $$->cnt = 1;
	     $$->yyval.val.sval = ll_ifthenelse;
	     if ($2->token) {
                  yylogexpand($$, $2);
	     } else {
		  yylogfree($2);
	          $$->yyval.val.sval = ll_ifelse;
             }
	     if ($4->token) {
                  yylogexpand($$, $4);
	     } else {
		  yylogfree($4);
	          $$->yyval.val.sval = ll_ifthen;
             } $$->yyval.val.sval = GDKstrdup($$->yyval.val.sval);            }

bat_expression:
     	param_expression
        {   $$ = $1;                                                          }
    |	/* empty */
        {   $$ = yylognode(0,0);                                              }

command_expression:
        builtin expression_list
        {   $2->token = $1->token;
            $2->yyval = $1->yyval;
            yylogkill($1); $$ = $2;                                           }
    |   command_or_operator expression_list
        {   $2->yyval = $1->yyval;
            $2->token = ($1->token == TOK_ASSIGNOP)?TOK_ASSIGNOP:TOK_FUNCTION;
            yylogkill($1); $$ = $2;                                           }

operator_expression:
        operator 
        {   if (ll_firstnode) yylogexpand($1, ll_firstnode);                  } 
        expression
        {   yylogexpand($1, $3);
            $1->token = ($1->token == TOK_ASSIGNOP)?TOK_ASSIGNOP:TOK_FUNCTION;
            $$ = $1;                                                          }

command_or_operator:
	TOK_COMMAND
        {   $$ = $1;                                                          }
    |   TOK_ATOM
        {   $$ = $1;                                                          }
    |   operator
        {   $$ = $1;                                                          }

operator:
        TOK_PROC
        {   $$ = $1;                                                          }
    |   TOK_OPERATOR
        {   $$ = $1;                                                          }
    |   TOK_ASSIGNOP
        {   $$ = $1;                                                          }

builtin:
        TOK_BUILTIN
        {   $$ = $1;                                                          }
    |   TOK_TRG
        {   $$ = $1;                                                          }

expression_list:
        '(' expressions ')'
        {   $$ = $2;                                                          }
    |   '(' ')'
        {   $$ = (ptr) yysugar(ll_sugarnode);                                 }
    |   /* empty */
        {   $$ = (ptr) yysugar(ll_sugarnode);                                 }

expressions:
        { $$ = ll_sugarnode; } param_expression
        {    $$ = (ptr) yysugar($1); yylogexpand($$, $2);                     }
    |   expressions ',' param_expression
        {    yylogexpand($1, $3); $$ = $1;                                    } 

param_expression:
	TOK_CONST expression
	{    $$ = yylognode(TOK_CONST,0); yylogexpand($$, $2);                }
     |  expression
	{    $$ = $1;                                                         }

modident:
        TOK_STRING
        {   $$ = $1; $$->token = TOK_CONSTANT;                                }
    |   TOK_IDENT
        {   $$ = $1;                                                          }

modidents:
        modident
        {    $$ = yylognode(0,0); 
             $1->yyval.len = 0; yylogexpand($$, $1);                          }
    |   modidents ',' modident
        {    $3->yyval.len = 0; yylogexpand($1, $3); $$ = $1;                 }

constidents:
	TOK_IDENT TOK_ASSIGNMENT expression
        {    $$ = yylognode(0,0); 
             yylogexpand($1, yylognode(TOK_TEMPLATE, 0));
             yylogexpand($1, $3);
             $1->token = TOK_ASSIGNMENT;
             $1->yyval.len = 0; yylogexpand($$, $1);                          }
    |   constidents ',' TOK_IDENT TOK_ASSIGNMENT expression
        {    yylogexpand($3, yylognode(TOK_TEMPLATE, 0));
             yylogexpand($3, $5);
             $3->token = TOK_ASSIGNMENT;
             $3->yyval.len = 0; yylogexpand($1, $3); $$ = $1;                 } 

varidents:
        ident_decl
        {    $$ = yylognode(0,0); yylogexpand($$, $1);                        }
    |   varidents ',' ident_decl
        {    yylogexpand($1, $3); $$ = $1;                                    }

initialization:
        TOK_ASSIGNMENT expression
        {    $$ = $2;                                                         }
    |   /* empty */
        {    $$ = NULL;                                                       }

ident_decl:
        { ll_resolution = 0; } TOK_IDENT { ll_resolution = 1; } initialization
        {    $$ = $2; $2->yyval.len = 0;
             if ($4) {
                 yylogexpand($$, yylognode(TOK_TEMPLATE, 0));
                 yylogexpand($$, $4);
                 $$->token = TOK_ASSIGNMENT;
             }                                                                }
%%

@-
Display the error information for the current client. 
If the list-flag is on an arrow and state number is printed at the "appropriate"
place. If no lookahead character is a used and the next character is a newline,
we should also copy the input .
@{
@y
void ll_parserror(str msg){
	static char buf[1024]; 
	char *s=buf, *t, *l = ll_lastline();
	int i = strlen(GDKERROR);

	ll_flushbuffer(); /* flush the lexer's buffer */
        ll_modcmds = 0; ll_resolution = 1; 
        ll_templates = 0; ll_parblockdepth = 0;

	*s++ = '"'; 
	for(t=l; *t; t++) {
		/* accidental %s directives in the lastline can 
                   crash the vfsprintf later => escape them */
		if (*t == '%') *s++ = '%';
		*s++ = *t;
	}
	*s++ = '"'; *s++ = '\n';

	for(*s++ = '!'; i > 0; i--) *s++ = ' ';
        for (; *l; l++) {
		*s++ = (*l != '\t')?' ':'\t';
        }
	*s++ = '^'; *s++ = '\n'; *s = 0;
        if (msg) {
                sprintf(s, "! %s.\n", msg); 
        } else {
        	sprintf(s, "! "); s += 2;
@-
Inlining this is a non-solution which was forced upon me by the new 
makefiles. It effectively introduces the new requirement that all yaccs 
should be the same. And they are not.. Sucker!
@y
#ifndef WIN32
#ifndef YYBISON
		{
		extern int yystate;
		extern int yylineno;

		if (!monet_yaccsilent) 
		switch(yystate) {
		case 3:	case 20: case 58: case 60: case 181: case 183:
			sprintf(s,"you forgot a closing ';'.\n"); break;
		case 11: case 12:
			sprintf(s,"identifier expected.\n"); break;
		case 13:
			sprintf(s,"command name expected.\n"); break;
		case 14:
			sprintf(s,"procedure expected.\n"); break;
		case 18: case 19: case 46: case 47:
			sprintf(s,"'(' expected.\n"); break;
		case 24: case 33: case 156:
			sprintf(s,"command invocation missing.\n"); break;
		case 36:	
			sprintf(s,"would a identifier or ../ be missing?\n"); 
			break;
		case 48: case 51:
			sprintf(s,"would a ';' or ',' be missing?\n"); break;
		case 52: case 105: case 108: case 149:
			sprintf(s,"':=' expected.\n"); break;
		case 78: case 130: case 208: case 229: case 240: case 246:
			sprintf(s,"']' expected.\n"); break;
		case 79:
			sprintf(s,"forgot to close a block?\n"); break;
		case 77: case 80: case 117: case 118:
			sprintf(s,"')' expected.\n"); break;
		case 87:
			sprintf(s,"would a '~' or '?' be missing?\n"); break;
		case 95:
			sprintf(s,"would '..' or ')' be missing?\n"); break;
		case 96: case 97: case 182:
			sprintf(s,"identifier or string missing.\n"); break;
		case 99: case 103: case 107: case 187:
			sprintf(s,"identifier missing.\n"); break;
		case 129:
			sprintf(s,"'~' expected.?\n"); break;
		case 142: case 146: case 163: case 152:	case 202:
			sprintf(s,"would a ')' or ',' be missing?\n"); break;
		case 155:
			sprintf(s,"would a '@' or ';' be missing?\n"); break;
		case 170: 
			sprintf(s,"would a atom or ')' be missing?\n"); break;
		case 209:
			sprintf(s,"':' expected.\n"); break;
		case 217:
			sprintf(s,"iterator expected.\n"); break;
		case 224: case 234: case 243:	
			sprintf(s,"atom name expected.\n"); break;
		case 239: 
			sprintf(s,"comma expected.\n"); break;
		}
    		}
#endif
#endif
		if (*s == 0) sprintf(s,"can't help you here, sorry.\n"); 
        }
	GDKerror(buf);
}
@
@}

@+ Data conflicts
The parser performs a simple data dependency check for all
identifiers mentioned in a parallel block. Duplicate use
of an identifier is flagged as a potential conflict under
parallel execution.It is up to the Monet programmer to assure
himself that these conflicts are avoided by other means (e.g.
if-then-else).

@{
@c
str        ids[500];		/* contains all ids of the parblock. */
char       iderrors[500];	/* just to avoid multiple warnings. */

@-
The identifier table is also used to map the formal arguments into their
position number.
In this case we start at the bottom.
@c
void ll_clrids() {
        str *t = ids; 
        char *c = iderrors; 
 
        while (t < ids+500 && *t) {
                *t++ = 0; 
                *c++ = 0; 
        }
        for( t= ids+499; *t  ; t-- ) {
                *t = 0;
        }
}

void ll_idconflict(str s){
        str        *t; 
        char        *c; 

        if (ll_parblockdepth == 0 ) {
                return ; 
        }
        for (c = iderrors, t = ids; t < ids+500 && *t && *(t+1); t++, c++) {
                if (s && strcmp(*t, s) == 0) {
                        if (*c == 0) {
                                GDKwarning("// conflict on %s\n", s); 
                        }
                        *c = *c + 1; 
                        return ; 
                }
        }
        if (t < ids+500) {
                *t = s; 
        } else {
                GDKerror("potential // conflicts\n"); 
        }
}
@
@}
