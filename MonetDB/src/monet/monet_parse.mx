@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@' 
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@' 
@' The Original Code is the Monet Database System.
@' 
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2004 CWI.
@' All Rights Reserved.
@' 
@' Contributor(s):
@' 		Martin Kersten <Martin.Kersten@cwi.nl>
@' 		Peter Boncz <Peter.Boncz@cwi.nl>
@' 		Niels Nes <Niels.Nes@cwi.nl>
@' 		Stefan Manegold  <Stefan.Manegold@cwi.nl>

@f monet_parse
@a M. L. Kersten, P. Boncz

@* Parsing BAT algebra
@T
We will discuss how BAT algebra is lexically analyzed with {\tt lex}, 
parsed with {\tt yacc}, and discuss the dunction table.

@+ The lexical analyzer
The implementation of the lexical analyzer is straightforward:
the input is read from the client message buffer, from which all
tokens are extracted.

The variable YYLMAX should be increased to handle large strings.
[It would be better to adapt the lexical analyzer to 
deal with 'infinite strings'. In fact, the input resides in the client
buffer, which is not reused until end-of-block. It can not be used,
because parse trees may be kept around for re-use]

@l

D       [0-9]
O       [0-7]
L       [_a-zA-Z]
E       [Ee][-+]?{D}+
S       [\t\n ]*
P       [-!\$%\^\*~+|?<>=/\\]
%{

#include "monet_parse.h"
#include "monet_tbl.h"

/* only needed for lex (we need  a big yytext array, since comments can
 * be lengthy. For lexis where yytext is a pointer this is not a problem
 * because they grow dynamically. But we must take care of copying yytext
 * before any unput is called.
 */
#define YYLMAX 100000

#if (!defined(FLEX_SCANNER))
extern YYSTREE yylval;
#endif
#define YY_NEVER_INTERACTIVE	1 /* workaround to flex bug */
#define YY_USE_PROTOS	  	/* make sure ANSI-C prototyes are used */

char *lexname[] = {
 "TOK_ITERTEMP", "TOK_TEMPLATE", "TOK_VARTEMP", "TOK_RANGETEMP",
 "TOK_CONSTANT", "TOK_ASSIGNMENT", "TOK_SEQBLOCK", "TOK_SEQ", "TOK_PARBLOCK",
 "TOK_PAREND", "TOK_IDENT", "TOK_IF", "TOK_WHILE", "TOK_ITERATOR",
 "TOK_ITCOMPILED", "TOK_BREAK", "TOK_RETURN", "TOK_VAR", "TOK_ATOM",
 "TOK_CONST", "TOK_BUILTIN", "TOK_CAST", "TOK_BATCAST", "TOK_BATCONV",
 "TOK_TRG", "TOK_FUNCTION", "TOK_PROC", "TOK_COMPILED", "TOK_COMMAND",
 "TOK_OPERATOR", "TOK_SETOP", "TOK_ASSIGNOP", "TOK_SETAGGR", "TOK_PROCDEF",
 "TOK_STRING", "TOK_OBJECT", "TOK_ITERATION", "TOK_ELSE", "TOK_BAT",
 "TOK_TRGDEF", "TOK_ON", "TOK_MODULE", "TOK_DROP", "TOK_EVENT",
 "TOK_ANY", "TOK_UNDEF", "TOK_DEREF", "TOK_ANYNUM", 0, };

char *LEXNAME(int Y)       { if (Y >= TOK_ITERTEMP && Y <= TOK_ANYNUM) {
                                return lexname[Y-TOK_ITERTEMP];
                             } else {
                                return "char";
                           } }
#define RETURN(Y)	{ ll_lastval = Y;\
                          PARSEDEBUG {\
				THRprintf(GDKerr, "%s %s\n", LEXNAME(Y), yytext);\
			   }\
                           return Y; }
#ifdef FLEX_SCANNER
/*
#define YY_INPUT(buf,result,max_size)	{ int c = ll_getch();\
                           result = (c==0) ? YY_NULL: (buf[0] = (char)c,1);}
*/
#define YY_INPUT(buf,result,max_size)	{ result = ll_getstring(buf,max_size); }
#else
#undef input
#define input()		(yytchar = yysptr > yysbuf?U(*--yysptr):ll_getch())
#endif
#define Symbol(X)	{ RETURN (X); }
#define Vector(X,Y,Z,V,L)	{ yylval = yylognode(X, Y);                      \
                             yylval->yyval.val.Z = V;                       \
                             yylval->yyval.len = L;                         \
                             RETURN (X); }
#define Function(X,V)	if ((X)==TOK_BUILTIN) {\
				Vector(X, TYPE_ptr, pval, (ptr) V, 0);\
			   } else {\
				str _s = GDKstrdup(V);\
				Vector(X, TYPE_str, sval, _s, strLen(_s));\
			   }

void ll_flushbuffer(void) {
#ifdef FLEX_SCANNER
	YY_FLUSH_BUFFER;
#else
	extern char yytext[];
	bzero(yytext, YYLMAX);
#endif
}

#define TBLSEARCH(r,s,token,cur_is_ident,guess_if_notfound,no_command) \
	{ int offend = ' '; \
	  while(GDKisspace(offend)) offend = input(); \
	  if (offend > 0) unput(offend);\
	  r = TBL_search(s, token, guess_if_notfound, cur_is_ident, no_command&&ll_nocommand[offend], \
                         (offend >= 'a' && offend <= 'z') | (offend >= 'A' && offend <= 'Z')); }
			
static int ll_skipcomment(void);
%}
%p 3400
%a 2300
%e 2000
%pointer
%%
"#"                   { return ll_skipcomment();                              }
("nil"|"NIL")         { Vector(TOK_CONSTANT, TYPE_void, oval, void_nil, 0);   }
("proc"|"PROC")       { Symbol(TOK_PROCDEF);                                  }
("undef"|"UNDEF")     { Symbol(TOK_UNDEF);                                    }
("return"|"RETURN")   { Symbol(TOK_RETURN);                                   }
("break"|"BREAK")     { Symbol(TOK_BREAK);                                    }
("while"|"WHILE")     { Symbol(TOK_WHILE);                                    }
("if"|"IF")           { Symbol(TOK_IF);                                       }
("else"|"ELSE")       { Symbol(TOK_ELSE);                                     }
("false"|"FALSE")     { Vector(TOK_CONSTANT, TYPE_bit, cval[0], 0, 0);        }
("var"|"VAR")         { Symbol(TOK_VAR);                                      }
("const"|"CONST")     { Symbol(TOK_CONST);                                    }
("true"|"TRUE")       { Vector(TOK_CONSTANT, TYPE_bit, cval[0], 1, 0);        }
("trigger"|"TRIGGER") { Symbol(TOK_TRGDEF);                                   }
("event"|"EVENT")     { Symbol(TOK_EVENT);                                    }
("on"|"ON")           { Symbol(TOK_ON);                                       }
("module"|"MODULE")   { if (!ll_modcmds) Symbol(TOK_MODULE);goto command;     }
("any"|"ANY")         { Vector(TOK_ANY, TYPE_int, ival, -1, 0);               }
"$("                  { Symbol(TOK_VARTEMP);                                  }
".."                  { Symbol(TOK_RANGETEMP);                                }
"::"                  { Symbol(TOK_ANYNUM);                                   }
("$h"|"$H"|"$head"|"$HEAD") { Vector(TOK_ITERTEMP, TYPE_int, ival, 1, 0);     }
("$t"|"$T"|"$tail"|"$TAIL") { Vector(TOK_ITERTEMP, TYPE_int, ival, 2, 0);     }
"$"{D}+               { Vector(TOK_TEMPLATE,TYPE_int,ival,atoi(yytext+1),0);  }
":="                  { Symbol(TOK_ASSIGNMENT);                               }
"(*"                  { Symbol(TOK_DEREF);                                    }
"[*"                  { Symbol(TOK_SETOP);                                    }
"{*"                  { Symbol(TOK_SETAGGR);                                  }
"@"                   { Symbol(TOK_ITERATION);                                }
(":"{P}+"=") |
({P}+)                { int i, l = (int) strlen(yytext);
			char *s, *t = (str) alloca(l+1);
			strcpy(t,yytext); /* copy yytext before unput */
		 	if ((!t[1]) && (*t=='~' || *t=='?' || *t==':')) {
                            Symbol(*t);
	                } else {
                            if (ll_resolution) {
                            	TBLSEARCH(s, t, &i, FALSE, TRUE, FALSE);
				if (s != NULL) { 
			            Function(i,s); 
			        }
                            }
			    REJECT
                        }                                                     }
(":"{L}({L}|{D})*"=") |
({L}({L}|{D})*"="?)  {
command:             {  int i, l = (int) strlen(yytext);
			char *s, *t = (str) alloca(l+1);
			strcpy(t,yytext); /* copy yytext before unput */
                        if (ll_resolution) {
                            TBLSEARCH(s, t, &i, TRUE, TRUE, TRUE);
			    if (s != NULL) {
                                Function(i,s);
                            }
                        }
			s = GDKstrdup(t);
                        Vector(TOK_IDENT, TYPE_str, sval, s, 0);              }}

("["{P}+"]") |
("[:"{P}+"=]") |
("["{L}({L}|{D})*"]") |
("[:"{L}({L}|{D})*"=]") |
("{"{L}({L}|{D})*"}") |
("[:"{P}+"=]")      {   int i, l = (int) strlen(yytext);
			char *s, *t = (str) alloca(l+1);
			strcpy(t,yytext); /* copy yytext before unput */
                        if (ll_resolution) {
			    char cb = t[l-1];  /* save bracket */
                            TBLSEARCH(s, t, &i, TRUE, FALSE, FALSE);
                            if (s) {
                               Function(i,s);
                            }
			    t[l-1] = 0; /*remove last bracket*/
                            TBLSEARCH(s, t+1, &i, TRUE, TRUE, FALSE);
                            if (s != NULL) {
				if (i == TOK_BUILTIN) {
				   GDKerror("yyparse: cannot use a %cBUILTIN%c()\n", *t, (*t=='[')?']':'}');
				} else if (i!=TOK_ASSIGNOP || *t == '[') {
				   str nme = (str) alloca((int)strlen(s)+3);
				   sprintf(nme, "%c%s%c", *t, s, cb);
                                   Function(i,nme);
				}
                            }
                        }
                        yyleng--;
		        unput((*t == '[')?']':'}');
                        while(--yyleng > 0) unput(t[yyleng]);
                        Symbol(*t);                                      }
("-")?{D}+"LL"        { lng val, *p = &val; int l=sizeof(lng);
                        if (*yytext == '-' && (ll_lastval == TOK_IDENT || 
			                       ll_lastval == TOK_CONSTANT || 
				               ll_lastval == ')')) REJECT;
			lngFromStr(yytext, &l, &p);
		        Vector(TOK_CONSTANT, TYPE_lng, lval, val, 0);}
("-")?{D}+            { lng val, *p = &val; int l=sizeof(lng);
                        if (*yytext == '-' && (ll_lastval == TOK_IDENT || 
			                       ll_lastval == TOK_CONSTANT || 
				               ll_lastval == ')')) REJECT;
			lngFromStr(yytext, &l, &p);
			if (val > ((lng) GDK_int_min) \
			 && val <= ((lng) GDK_int_max))
		          Vector(TOK_CONSTANT, TYPE_int, ival, ((int) val), 0);
		        Vector(TOK_CONSTANT, TYPE_lng, lval, val, 0);}
{D}+"@"{D}+           { oid obj, *p=&obj; int l=sizeof(oid);
			OIDfromStr(yytext, &l, &p);
			Vector(TOK_CONSTANT, TYPE_oid, oval, obj, 0);         }
("-")?{D}+"."{D}+({E})?"LL" |
("-")?"."{D}+({E})?"LL"     |
("-")?{D}+{E}"LL"     { dbl val, *p = &val; int l = sizeof(dbl);
                        if (*yytext == '-' && (ll_lastval == TOK_IDENT || 
			                       ll_lastval == TOK_CONSTANT || 
				               ll_lastval == ')')) REJECT;
			dblFromStr(yytext, &l, &p);
			Vector(TOK_CONSTANT, TYPE_dbl, dval, val, 0);         }
("-")?{D}+"."{D}+({E})? |
("-")?"."{D}+({E})?     |
("-")?{D}+{E}         { flt val, *p = &val; int l = sizeof(flt);
                        if (*yytext == '-' && (ll_lastval == TOK_IDENT || 
			                       ll_lastval == TOK_CONSTANT || 
				               ll_lastval == ')')) REJECT;
			fltFromStr(yytext, &l, &p);
			Vector(TOK_CONSTANT, TYPE_flt, fval, val, 0);         }
"'"\\0{O}({O})?({O})?"'" {unsigned int i; sscanf(yytext+2, "%o", &i);
                        Vector(TOK_CONSTANT, TYPE_chr, cval[0], i, 0);        }
\"[^\n"]* 	      { int len, offending_chr = input();
			str s = ll_getstr(yytext, yyleng, offending_chr);
			if (s) {
				len = (int) strlen(s);
				len = strFromStr(s, &len, &s);
                            	Vector(TOK_STRING, TYPE_str, sval, s, len);
			} else {
				unput('"');
			}                                                     }
\'[^\n\']* 	      { int len, offending_chr = input();
			char val, *p = &val;
			str s = ll_getstr(yytext, yyleng, offending_chr);
			if (s) {
				len = (int) strlen(s);
				chrFromStr(s, &len, (ptr)&p);
				GDKfree(s);
                            	Vector(TOK_CONSTANT, TYPE_chr, cval[0], val, 0);
			} else {
				unput('\'');
			}                                                     }
"{|"                  { Symbol(TOK_PARBLOCK);                                 }
"|}"                  { Symbol(TOK_PAREND);                                   }
{S}                   ;
.                     { Symbol(*yytext);                                      }
%%
int ll_skipcomment(void) { char c; while ((c=input()) && (c != '\n')); return yylex();}
@
@-
The routine @%ll_getch@ manipulates the input buffer for the current
client indicated by @%ll_client@.

BLACK MAGIC: the parse module-stack. In order to execute module initialize scripts in the correct
order we maintain a stack of scripts (= MIL input buffers). 

In case of modules that include other modules, what happens is that the init scripts of the
included modules are put in front of each other. E.g. module(a); causes module(b) also
to be loaded, and b should be initialized before a.

But, parsing also loads (indepent) modules in sequence , e.g. module(a,c); In this case,
we get the initialization sequence a,b,c; and *not* c,b,a, which would happen if we would
alwas include initialization scripts upfront.

This behavior is steered by setting ll_reset() (i.e. ll_insert = NULL) in the parser at 
TOK_MODULE after having included one module fully.

Ah. and don't confuse the parser module-stack with the execution module-stack (in monet_client.mx).
That one is used to obtain the module-id of the currently *executing* (not parsing) module
initialization script.
@c
#include "monet_parse.h"

Client 	   ll_client = 0;
int	   ll_nlines=0;		  /* current number of string chunks */
int	   ll_maxlines=0; 	  /* maximum number of string chunks */
str*	   ll_lines=0;		  /* string chunks */

char ll_nocommand[256] = { 0 };
int ll_lastval=0;

typedef struct _strstack_t {
	str cleanup, cptr, cline, mod;
	struct _strstack_t *up;
} strstack;

strstack  *ll_insert = NULL, *ll_stack = NULL;
str ll_mod = NULL;

	
void ll_reset() {	
	ll_insert = NULL;
}

int ll_push(str s, str mod) {
        strstack *sp = (strstack*) GDKmalloc(sizeof(strstack));
        if (ll_insert) {
		*sp = *ll_insert;
		ll_insert->up = sp;
		ll_insert->cline = ll_insert->cptr = s;
		ll_insert->mod = GDKstrdup(mod);
        	ll_insert = sp;
        } else {
        	sp->cline = ll_client->cline; 
		sp->cptr = ll_client->cptr;
		sp->mod = ll_mod;
 		ll_mod = GDKstrdup(mod);
		ll_client->cline = ll_client->cptr = s;
                sp->up = ll_stack;
                ll_insert = ll_stack = sp;
        }
	sp->cleanup = s;
        return 1;
}

int ll_pop(void) {
        strstack *sp = ll_stack;
        if (ll_stack) {
                ll_insert = NULL;
		ll_stack = sp->up;
		if (ll_mod) GDKfree(ll_mod);
		ll_mod = sp->mod;
                if (ll_client->cleanup)
                	GDKfree(ll_client->cleanup);
                ll_client->cptr = sp->cptr;
                ll_client->cline = sp->cline;
                GDKfree(sp);
                return 1;
        }
        return 0;
}

str ll_parent_module(){
	if (ll_mod) return ll_mod;
	return moduleGetClient(ll_client);
}

int ll_getch(void) {
        char ch;

        if (ll_client == 0) {
                GDKfatal("no client for lexical.\n");
        }
   	do {
        	ch = *ll_client->cptr;
	} while (ch == 0 && ll_pop());

        if (ch == '\n') {
                if (ll_client->listing) {
                    if (GDKdebug&16384 || !ll_stack) {
			stream *s = ll_client->fdout;
			if (stream_write(s, ll_client->cline, ll_client->cptr - ll_client->cline + 1 , 1  ) < 0 ||
			    stream_flush(s))
				GDKdebug &= ~16384; /* stop logging after error */
		    }
                }
                ll_client->cline = ll_client->cptr + 1;
        }
        if (ch) ll_client->cptr++;
        return ch;
}

int ll_getstring(char *buf, int max_size)
{
	char *start = buf, *end = buf + max_size;
	char ch;
	int statement = 0;

        if (ll_client == 0) {
               	GDKfatal("no client for lexical.\n");
        }
	while(buf < end){
   		do {
        		ch = *ll_client->cptr;
		} while (ch == 0 && ll_pop());

		if (ch == 0)
			break;
        	if (statement && !isspace((int)ch)) {
        		/* quit before non-whitespace after end of statement */
        		break;
        	}

		ll_client->cptr++;
		*buf++ = ch;

        	if (ch == '\n') {
			/* quit after end of line */
                	ll_client->cline = ll_client->cptr;
			break;
        	}
		if (ch == ';') {
			/* end of statement (unless quoted);
			 * don't quit, yet, but read trailing whitespaces */
			statement = 1;
		}
	}
	if (ll_client->listing &&
	    (GDKdebug&16384 || !ll_stack)) {
		stream *s = ll_client->fdout;
		if (stream_write(s, start, 1, buf - start) < 0 ||
		    stream_flush(s))
			GDKdebug &= ~16384; /* stop logging after error */
	}
	return (int) (buf-start);
}


void ll_init(void) {
	ll_lines = (str*) GDKmalloc((ll_maxlines=500)*sizeof(str));

	/* when these chars are seen after an identifier, MIL language constructs impede it be an operator */
	ll_nocommand[(int)';'] = 1; /* a  ; */
	ll_nocommand[(int)','] = 1; /* fcn(a  , b) */
	ll_nocommand[(int)')'] = 1; /* fcn(a  ) */
	ll_nocommand[(int)'.'] = 1; /* a . fcn(..) */
	ll_nocommand[(int)'@'] = 1; /* a @ batloop() */
	ll_nocommand[(int)'?'] = 1; /* a ? b : c */
        ll_nocommand[(int)':'] = 1; /* b ? a : c ALSO a := ... */
	ll_nocommand[(int)']'] = 1; /* b@batloop[ a ]() .. */

	/* operator starter symbols (an operator cannot come after an operator) */
	ll_nocommand[(int)'<'] = 1; /* a < .. */
	ll_nocommand[(int)'>'] = 1; /* a > .. */
	ll_nocommand[(int)'='] = 1; /* a = .. */
	ll_nocommand[(int)'%'] = 1; /* a % b */
	ll_nocommand[(int)'/'] = 1; /* a / b */
	ll_nocommand[(int)'-'] = 1; /* a - b */
	ll_nocommand[(int)'+'] = 1; /* a + b */
	ll_nocommand[(int)'*'] = 1; /* a * b */

	/* symbols not yet used that in the future may be first chars of operators */
	ll_nocommand[(int)'|'] = 1; 
	ll_nocommand[(int)'~'] = 1; 
	ll_nocommand[(int)'!'] = 1;
	ll_nocommand[(int)'^'] = 1;
	ll_nocommand[(int)'&'] = 1;
	ll_nocommand[(int)'\\'] = 1;
}

str ll_lastline(void){
        static char line[1024];
        char *l=line, *s = ll_client->cline;
	int c = *s--;

        if (ll_emptychar(c)) {
                while((s >= ll_client->input) && ll_emptychar(c = *s)) s--;
                while((s >= ll_client->input) && *s && (*s != '\n')) s--;
        }
	if (ll_client->cline - s > 512) {
		s = ll_client->cline - 40;
	}
        while ((c = *++s) != 0) {
                if (c == '\n' || l > line+1000) break;
                *l++ = c;
        }
	*l = 0;
        return line;
}

str ll_getstr(char *buf, int len, int offending) {
	static int ll_buf_len, ll_border;
	int escape = 0;
	str p;

	if (ll_nlines == 0)  { /* first call of sequence? */
		ll_buf_len = 0;
		ll_border = buf[0];
	}

	/* find out if the string goes on */
	for(p=buf+len-1; p >= buf; p--) {
		if (*p != '\\') break;
                else escape = !escape;
	}
	if (escape) {
		/* it goes on; append this line to the ll_lines array */
		ll_lines[ll_nlines++] = p = (str) GDKmalloc(len+2);
		if (ll_nlines >= ll_maxlines) {
		     ll_lines = (str*) GDKrealloc((int*)ll_lines, (ll_maxlines*=2)*sizeof(str));
		}
		if (offending == '\n') {
			len--;
		} else /* enter border char */ {
			buf[len++] = ll_border;
		}
		memcpy(p, buf+1, len);
		p[len-1] = 0;

		/* increment the total length of the buffer */
		ll_buf_len += len;
		return NULL;
	}
	/* concat all */
	ll_lines[ll_nlines] = buf+1;
	p = buf = GDKmalloc(ll_buf_len+len+3);
	*p++ = ll_border;
	for(len=0; len < ll_nlines; len++) {
		strcpy(p, ll_lines[len]);
		p += strlen(ll_lines[len]);
		GDKfree(ll_lines[len]);
	}
	strcpy(p, ll_lines[len]);
	p += strlen(ll_lines[len]);
	*p++ = ll_border;
	*p++ = 0;
	ll_nlines = 0; /* ready */

	return buf; /* return concatenated string and its length*/
}

@+ The Parser
@h 
#ifndef _MONET_PARSE_H
#define _MONET_PARSE_H

#include "monet.h"
#include "monet_client.h"

#define YY_NEVER_INTERACTIVE	1		/* bison brain damage evasion */

m_export int        ll_modcmds;           /* are "module" cmd or tokens? */
m_export int        ll_resolution;        /* perform ident-->MIL resolution */
m_export Client     ll_client;
m_export int        ll_nlines;            /* current number of string chunks */
m_export int        ll_maxlines;          /* maximum number of string chunks */
m_export str*       ll_lines;             /* string chunks */
m_export int        ll_parblockdepth;
m_export YYSTREE    ll_firstnode, ll_sugarnode;
m_export int        ll_templates;
m_export int        ll_argc;
m_export char       ll_nocommand[256];
m_export int        ll_lastval;

#define ll_emptychar(x)	((x == 0) || GDKisspace(x))

m_export int CMDconstant(Cntxt stk, YYSTREE lt, ValPtr res);


m_export void ll_flushbuffer(void);
m_export int ll_getstring(char *buf, int max_size);
m_export int ll_push(str s, str mod);
m_export void ll_reset();
m_export str ll_parent_module();

#endif /* _MONET_PARSE_H */

@- Global variables for YACC 
@c
int        ll_parblockdepth = 0;  /* nesting depth of paralellism. */
int        ll_templates = 0;      /* are templates currently allowed? */
int        ll_modcmds = 0;        /* are "module" cmd or tokens? */
int        ll_resolution = 1;     /* perform ident-->MIL resolution */
YYSTREE    ll_firstnode,ll_sugarnode;/* for parsing OO sugar syntax XX.op(YY) */
int        ll_argc = 0;           /* */

@-
The Monet interpreter language provides a sugar version to OO
programming by considering the first argument the receiver of the method.
@c
YYSTREE yysugar(YYSTREE node){
        YYSTREE t = yylognode(0, 0);
        if (node) {
                yylogexpand(t, node); /* put the sugar argument in front. */
        }
        ll_sugarnode = NULL;
        return t;
}

int yywrap(void) { return 1; }

@- The YACC Grammar
@T
A parse tree is built during parsing, such that a compact
representation for function calls result. 

The code below is
{\tt yacc} input format. Executing {\tt yacc} produces the file 
{y.tab.c}, which contains the parsing routine {\tt yyparse()}. It
parses the grammar, executing the inlined C statements along the way. 
@
@y


%{
#ifndef YYSTYPE
#define YYSTYPE	YYSTREE
#endif

#include "monet_parse.h"	/* includes monet.h */
#include "monet_client.h"


#define YYDEBUG	0

static void ll_parserror(str msg);

extern int yylex(void);

#undef yyerror
#define yyerror(X)	{ ll_parserror(NULL);  }
#define yylogkill(t)	(t)->yyval.vtype = TYPE_void;
#define yylogfree(t)

extern YYSTREE yysugar(YYSTREE node);
%}

%token TOK_ITERTEMP TOK_TEMPLATE TOK_VARTEMP TOK_RANGETEMP
%token TOK_CONSTANT TOK_ASSIGNMENT TOK_SEQBLOCK TOK_SEQ TOK_PARBLOCK
%token TOK_PAREND TOK_IDENT TOK_IF TOK_WHILE TOK_ITERATOR
%token TOK_ITCOMPILED TOK_BREAK TOK_RETURN TOK_VAR TOK_ATOM
%token TOK_CONST TOK_BUILTIN TOK_CAST TOK_BATCAST TOK_BATCONV TOK_TRG
%token TOK_FUNCTION TOK_PROC TOK_COMPILED TOK_COMMAND TOK_OPERATOR
%token TOK_SETOP TOK_ASSIGNOP TOK_SETAGGR TOK_PROCDEF 
%token TOK_STRING TOK_OBJECT TOK_ITERATION TOK_ELSE TOK_BAT
%token TOK_TRGDEF TOK_ON TOK_MODULE TOK_DROP TOK_EVENT
%token TOK_ANY TOK_UNDEF TOK_DEREF TOK_ANYNUM
%%
program:
	monet_session
	{ ll_client->tree = $1; yypostprocess(ll_client->tree); ll_lastval=0; }
    |   error ';' { ll_clrids(); yyerrok; yyclearin; ll_lastval=0; return 1; }
    |   /* empty */
    ;

monet_session:
        session
        {   if (!$1 || $1->token != TOK_SEQ) {
                $$ = yylognode(TOK_SEQ, 0);
                if ($1) yylogexpand($$, $1);
            } else $$ = $1;                                                   }
    |   monet_session session
        {   $$ = $1; if ($2) yylogexpand($$, $2);                             }
    ;

session:
        ';'
        {   $$ = 0 ;                                                          }
    |   definition
        {   $$ = 0 ;                                                          }
    |   statement
        {   $$ = $1;                                                          }
    |   TOK_MODULE { ll_resolution = 0; } '(' modidents ')' ';'
        {   YYSTREE lt = $4;
	    str initstr;
	    str parmod = ll_parent_module();
	    ll_resolution = 1;
	    /* EXECUTE MODULE LOAD *DURING* PARSE!!*/
            while (lt) {
	        unsigned i; 
                for(i = 0; i < lt->cnt; i++)  {
        	    str mod;
                    if (!lt->yysons[i]) continue;
                    if ((int) lt->yysons[i]->token == monet_tokident) {
                            mod = arg(lt, i)->yyval.val.sval;
                    } else {
			    ValRecord res;
			    int ret = interpret(ll_client->stk, lt->yysons[i], &res);
			    if (ret < 0 || res.vtype != TYPE_str) {
				    GDKerror("module: illegal argument.\n");
			    } 
			    mod = res.val.sval; 
                    }
		    initstr = moduleClient( ll_client, mod, parmod );
	            if (initstr != NULL) {
			ll_push(initstr,mod);
	            }
                }
		ll_reset();
                lt = lt->overflow;
            }
            $$=0; yylogfree($4);                                                    }
    ;

definition:
        proc_definition
    ;
@
#ifdef MKMODS
    |   event_definition
    |   trigger_definition
    ;

trigger_definition:
        TOK_TRGDEF TOK_IDENT header
        {   ll_modcmds = ll_templates = 1;}
        event_expression statement
        {   if ($3) {
		YYSTREE t = yylognode(TOK_SEQBLOCK, 0);
		yylogexpand(t, $3); yylogexpand(t, $6);
		$6 = t;
	    }
	    yylogout($6);
            TEMdefTrigger(ll_client, $2, $5, $6);
            ll_modcmds = ll_templates = 0;                                    }
    ;

event_expression:
        TOK_ON event_term
        {   $$= yylognode(0,0); yylogexpand($$, $2);                          }
    |   event_expression ',' event_term
        {   $$= yylogexpand($1, $3);                                          }
    ;

event_term: event_item {
            $$ = (ptr) TEMnewevent(0, $1, 0);
        } | '~' event_item {
            $$ = (ptr) TEMnewevent(0, $2, 1);
        } | event_item '.' event_item {
            $$ = (ptr) TEMnewevent($1, $3, 0);
        } | '~' event_item '.' event_item {
            $$ = (ptr) TEMnewevent($2, $4, 1);
        }
    ;

event_item : TOK_IDENT
        {   $$ = $1;                                                          }
        | TOK_TEMPLATE
        {   $$ = $1;                                                          }
    ;

event_definition:
        TOK_EVENT TOK_IDENT ';' {   $$ = NULL;
            TEMdefEvent(ll_client, $2->yyval.val.sval);
        }
    ;
#endif /* MKMODS */
@y
statement_seq:
        /* empty */
        {   $$ = yylognode(TOK_SEQ,0);                                        }
    |   statement_list
        {   $$ = $1;                                                          }
    ;

statement_list:
        statement
        {   $$ = $1;                                                          }
    |   statement_list statement
        {   if ($1->token != TOK_SEQ) {
                 $$ = yylognode(TOK_SEQ, 0);
                 yylogexpand($$, $1);
            } else  $$ = $1;
            yylogexpand($$, $2);                                              }
    ;

statement:
        nonvar_statement
        {   $$ = $1;                                                          }
    |   TOK_VAR varidents ';'
        {   $$ = $2; $2->token = TOK_VAR;                                     }
    |   TOK_CONST constidents ';'
        {   YYSTREE t=$2,tt, n = yylognode(TOK_BUILTIN, TYPE_ptr);
            unsigned i;
            n->yyval.val.pval = (ptr) CMDconstant;
            $$ = yylognode(TOK_SEQ,0);
            $2->token = TOK_VAR;
            yylogexpand($$, $2); yylogexpand($$,n);
	    while(t) {
                for(i=0; i<t->cnt; i++)
                if (t->yysons[i]) {
                    yylogexpand(n, tt=yylognode(TOK_IDENT, TYPE_str));
                    tt->yyval.val.sval=GDKstrdup(t->yysons[i]->yyval.val.sval);
                }
                n->cnt = t->cnt;
                if ((t=t->overflow) != NULL) {
                    n->overflow=yylognode(0,0); n=n->overflow;
                }
            }                                                                 }
    ;

nonvar_statement:
        simple_expression { ll_firstnode = $1; } expr_rest
        { ll_sugarnode = $3; } expr_statement
        {    $$ = $5;                                                         }
    |   blk_expression
        {    $$ = $1;                                                         }
    |   TOK_RETURN ret_value ';'
        {    $$ = yylognode(TOK_RETURN, 0);
             if ($2) yylogexpand($$, $2);                                     }
    |   TOK_WHILE '(' expression ')' nonvar_statement
        {    $$ = yylognode(TOK_WHILE, 0);
             yylogexpand($$, $3); yylogexpand($$, $5);                        }
    |   TOK_IF '(' expression ')' nonvar_statement else_statement
        {    $$ = yylognode(TOK_IF, 0);
             yylogexpand($$, $3); yylogexpand($$, $5);
             if ($6) yylogexpand($$, $6);                                     }
    |   TOK_BREAK ';'
        {    $$ = yylognode(TOK_BREAK, 0);                                    }
    ;

expr_statement:
        ';'
        {   $$ = ll_sugarnode; ll_sugarnode = NULL;                           }
    |   TOK_ITERATION parallel TOK_ITERATOR expression_list
        {   $$ = ll_templates ? (YYSTREE)(size_t)1 /* non-NULL */ : (ptr) 0; ll_templates = 1; } nonvar_statement
        {   ll_templates = ($5 != NULL);
            yylogexpand($3, $6); yylogexpand($3, $4);
            if ($2) yylogexpand($3, $2); $$ = $3;                             }
    ;

else_statement:
        TOK_ELSE nonvar_statement
        {   $$ = $2;                                                          }
    |   /* empty */
        {   $$ = NULL;                                                        }
    ;

ret_value:
        expression
        {   $$ = $1;                                                          }
    |       /* empty */
        {   $$ = NULL;                                                        }
    ;

parallel:
        '[' expression ']'
        {   $$ = $2;                                                          }
    |   /* empty */
        {   $$ = NULL;                                                        }
    ;

sequential_block:
        '{' { $$=ll_modcmds?(YYSTREE)(size_t)1:0; ll_modcmds=1; } statement_seq '}'
        {   ll_modcmds = ($2 != NULL);
	    $$ = $3;
            if ($3->token == TOK_SEQ || $3->token == TOK_SEQBLOCK) {
                    $3->token = TOK_SEQBLOCK;
            } else if ($3->token != TOK_PARBLOCK) {
                    $$ = yylognode(TOK_SEQBLOCK, 0);
                    if ($3) yylogexpand($$, $3);
            }                                                                 }
    ;

parallel_block:
        TOK_PARBLOCK {ll_parblockdepth++; $$=ll_modcmds?(YYSTREE)(size_t)1:0;ll_modcmds=1;}
	statement_seq TOK_PAREND
        {   ll_modcmds = ($2 != NULL);
	    if (--ll_parblockdepth == 0) ll_clrids();
            if ($3->token == TOK_SEQBLOCK ||
                $3->token == TOK_SEQ ||
                $3->token == TOK_PARBLOCK)
            {
                $$ = $3;
                $$->token = TOK_PARBLOCK;
            } else {
                $$ = yylognode(TOK_SEQBLOCK, 0);
                yylogexpand($$, $3);
            }                                                                 }
    ;

assignment:
        TOK_ASSIGNMENT expression
        {   $$ = $2;                                                          }
    |   /* empty */
        {   $$ = NULL;                                                        }
    ;

variable_reference:
        TOK_IDENT assignment
        {   ll_idconflict($1->yyval.val.sval);
            $1->yyval.len = 0; /* var depth.. */
	    if ($2) {
                $$ = yylognode(TOK_ASSIGNMENT, 0);
                yylogexpand($$, $1); yylogexpand($$, $2);
            } else $$ = $1;                                                   }
    |   template assignment
        {   $1->yyval.len = 0;
            if ($2) {
                $$ = yylognode(TOK_ASSIGNMENT, 0);
                yylogexpand($$, $1); yylogexpand($$, $2);
            } else $$ = $1;                                                   }
    ;

proc_definition:
        TOK_PROCDEF proc_name proc_header
	proc_assign { ll_templates = ll_modcmds = 1; } statement

        {   YYSTREE sig = (YYSTREE) ($3?$3->yyval.val.pval:NULL);
            YYSTREE ret = (YYSTREE) (sig?sig->yyval.val.pval:NULL);
	    int params = ($3 && $3->cnt > 0);

	    if (params || (($6->token != TOK_SEQ) &&
	   	           ($6->token != TOK_SEQBLOCK) &&
                           ($6->token != TOK_PARBLOCK)))
            {
                $$ = yylognode((params)?TOK_SEQBLOCK:TOK_SEQ, 0);
		if (params) yylogexpand($$, $3);
		yylogexpand($$, $6);
            } else {
                $$ = $6;
            }
	    if ($3 && $3->cnt == 0) {
		yylogfree($3);
	    }
            $$->yyval = $2->yyval;
	    $2->yyval.vtype = TYPE_void;

            /* DIRECT: insert the new proc */
	    yylogout($$);
            TBL_newproc(ll_client, $2->yyval.val.sval, ll_parent_module(), $$, sig, ret);
	    if (sig) { yylogfree(sig); }
	    if (ret) { yylogfree(ret); }
            ll_modcmds = ll_templates = 0;                                    }
    |   TOK_PROCDEF proc_name ';'
        {   yylogout($2);
	    TBL_newproc(ll_client, $2->yyval.val.sval, ll_parent_module(), $2, $2, NULL);
            $2->token = TOK_CONSTANT;
            $2->yyval.vtype = TYPE_int;                                       }
    |   TOK_UNDEF TOK_PROC ';'
        {   TBL_delproc(ll_client, $2->yyval.val.sval); }
    ;

proc_assign:
	TOK_ASSIGNMENT
    |	/* empty */
    ;

proc_name:
        TOK_IDENT
	{ $$ = $1; $1->token = TOK_PROC;                                      }
    |   TOK_STRING
        { $$ = $1; $1->token = TOK_PROC;                                      }
    |   TOK_ATOM
        { $$ = $1; $1->token = TOK_PROC;                                      }
    |   TOK_COMMAND
	{ $$ = $1; $1->token = TOK_PROC;                                      }
    |   TOK_OPERATOR
	{ $$ = $1; $1->token = TOK_PROC;                                      }
    |   TOK_PROC
        { $$ = $1; }
    ;

proc_header:
        '(' mel_header ')' mel_return
        {   YYSTREE header = (YYSTREE) $2->yyval.val.pval;
	    if (header) {
		header->yyval.val.pval = $4;
		header->yyval.vtype = TYPE_ptr;
            } $$ = $2;                                                        }
    ;

mel_header:
	mel_params mel_tail
        {   YYSTREE h = (YYSTREE) $1->yyval.val.pval;
            $$ = $1; if ($2) yylogexpand(h,$2);                               }
    |   mel_range
        {   YYSTREE n = yylognode(0,0); yylogexpand(n,$1);
	    $$ = yylognode(0,TYPE_ptr); $$->yyval.val.pval = (ptr) n;         }
    |   /* empty */
        { $$ = yylognode(0,TYPE_ptr);
          $$->yyval.val.pval = (ptr) yylognode(0,0);                          }
    ;

mel_tail:
	',' mel_range
        {   $$ = $2;                                                          }
    |	/* empty */
        {   $$ = NULL;                                                        }
    ;

mel_range:
	TOK_RANGETEMP mel_type TOK_RANGETEMP
        {   $$ = yylognode(TOK_RANGETEMP,0); yylogexpand($$,$2);              }
    ;

mel_params:
        mel_type TOK_IDENT
        {   YYSTREE temp = yylognode(TOK_TEMPLATE, TYPE_int);
            YYSTREE sig = yylognode(0,0);
	    yylogexpand(sig, $1);
	    ll_argc = 0; temp->yyval.val.ival = ++ll_argc;
	    $2->token = TOK_ASSIGNMENT;
	    yylogexpand($2, yylognode(TOK_TEMPLATE,0)); yylogexpand($2, temp);
            $$ = yylognode(TOK_VAR,TYPE_ptr); yylogexpand($$, $2);
	    $$->yyval.val.pval = (ptr) sig;                                   }
    |   mel_params ',' mel_type TOK_IDENT
        {   YYSTREE temp = yylognode(TOK_TEMPLATE, TYPE_int);
            YYSTREE sig = (YYSTREE) $1->yyval.val.pval;
	    yylogexpand(sig, $3);
	    temp->yyval.val.ival = ++ll_argc;
	    $4->token = TOK_ASSIGNMENT;
	    yylogexpand($4, yylognode(TOK_TEMPLATE,0)); yylogexpand($4, temp);
            yylogexpand($1, $4); $$ = $1;                                     }
    ;

mel_type:
	TOK_ATOM mel_bat
	{ $$ = ($2 && $2->token == TOK_ATOM)?$2:NULL;
	  if ($2 && strcmp($2->yyval.val.sval,"BAT")) {
                ll_parserror("only bat types are parametrized");
	  } else if ($2 == NULL && strcmp($1->yyval.val.sval, "BAT")==0) {
		YYSTREE any1 = yylognode(TOK_ANY,TYPE_int);
		YYSTREE any2 = yylognode(TOK_ANY,TYPE_int);
		any1->yyval.val.ival = any2->yyval.val.ival = -1;
		$$ = yylognode(TOK_ATOM,TYPE_str);
	        $$->yyval.val.sval = GDKstrdup(BATatoms[TYPE_bat].name);
		yylogexpand($$, any1);
		yylogexpand($$, any2);
	  }
	  if ($$ == NULL) {
		yylogexpand($$=$1,$2);
	  } else {
 		yylogfree($1);
          }                                                                   }
    |   mel_other
	{ $$ = $1;                                                            }
    ;

mel_bat:
	'[' mel_atom ',' mel_atom ']'
        { $$ = yylognode(TOK_ATOM,TYPE_str);
	  $$->yyval.val.sval = GDKstrdup(BATatoms[TYPE_bat].name);
	  yylogexpand($$,$2); yylogexpand($$,$4);         		      }
    |   /* empty */
	{ $$ = NULL;                                                          }
    ;

mel_atom:
        TOK_ATOM
	{ $$ = $1;                                                            }
    |   mel_other
	{ $$ = $1;                                                            }
    ;

mel_other:
        TOK_ANY mel_any
	{ $$ = $1;
	  if ($2) { $$->yyval = $2->yyval; yylogfree($2); }                   }
    ;

mel_any:
	TOK_ANYNUM TOK_CONSTANT
	{ $$ = $2; if ($2->yyval.vtype != TYPE_int)
               	ll_parserror("any::<int> expected");                       }
    |   /* empty */
	{ $$ = NULL;                                                          }
    ;

mel_return:
	':' mel_type
	{ if ($2->token == TOK_ANY && $2->yyval.val.ival == 0) {
	      yylogfree($2); $2 = NULL;
          } $$ = $2;                                                          }
    ;

expression:
        simple_expression { ll_firstnode = $1; } expr_rest
        {   $$ = $3;                                                          }
    |   blk_expression
        {   $$ = $1;                                                          }
    ;

blk_expression:
        sequential_block
        {   $$ = $1;                                                          }
    |   parallel_block
        {   $$ = $1;                                                          }
    ;

expr_rest:
        '.' {ll_sugarnode = ll_firstnode; } command_or_ident_expression
        { ll_firstnode = $3; } expr_rest
        {   $$ = $5;                                                          }
    |   operator_expression { ll_firstnode = $1; } expr_rest
        {   $$ = $3;                                                          }
    |   /* empty */
        {   $$ = ll_firstnode;                                                }
    ;

simple_expression:
        deref_or_simple_expression
        {   $$ = $1;                                                          }
    |   constant_expression
        {   $$ = $1;                                                          }
    |   variable_reference
        {   $$ = $1;                                                          }
    |   { ll_sugarnode = NULL; } command_expression
        {   $$ = $2;                                                          }
    ;

deref_or_simple_expression:
        TOK_DEREF expression ')' expression_list
        {   $$ = yylognode(TOK_FUNCTION,0);
            yylogexpand($$,$2); yylogexpand($$,$4);                           }
    |	TOK_SETOP expression ']' expression_list
        {   $$ = yylognode(TOK_SETOP,0);
            yylogexpand($$,$2); yylogexpand($$,$4);                           }
    |	TOK_SETAGGR expression '}' expression_list
        {   $$ = yylognode(TOK_SETAGGR,0);
            yylogexpand($$,$2); yylogexpand($$,$4);                           }
    |   '(' expression ')'
        {   $$ = $2;                                                          }
    ;

temptok:
        TOK_TEMPLATE
        {   if (!ll_templates) {
                ll_parserror("template not in procedure body");
                $$->token = TOK_CONSTANT;
            } else { $$ = (YYSTREE) $1; }                                     }
    |   TOK_ITERTEMP
        {   if (!ll_templates) {
                ll_parserror("template not in iterator body");
                $$->token = TOK_CONSTANT;
            } else { $$ = (YYSTREE) $1; }                                     }
    ;

template:
        temptok
        {   $$ = $1; }
    |   TOK_VARTEMP expression rangetemp
	{   $$ = yylognode((int)(size_t)$3, 0);
	    yylogexpand($$,$2); }
    ;

rangetemp:
	')'
	{ $$ = (YYSTREE) (size_t) TOK_VARTEMP; }
    | 	TOK_RANGETEMP ')'
	{ $$ = (YYSTREE) (size_t) TOK_RANGETEMP; }
    ;

constant_expression:
        TOK_CONSTANT
        {   $$ = $1;                                                          }
    |   TOK_STRING
        {   $$ = $1; $$->token = TOK_CONSTANT;                                }
    ;

command_or_ident_expression:
        builtin expression_list
        {   $2->token = $1->token;
            $2->yyval = $1->yyval;
            yylogkill($1); $$ = $2;                                           }
    |   command_or_operator_or_ident expression_list
        {   $2->yyval = $1->yyval;
            $2->token = ($1->token == TOK_ASSIGNOP)?TOK_ASSIGNOP:TOK_FUNCTION;
            yylogkill($1); $$ = $2;                                           }
    ;

command_expression:
        builtin expression_list
        {   $2->token = $1->token;
            $2->yyval = $1->yyval;
            yylogkill($1); $$ = $2;                                           }
    |   command_or_operator expression_list
        {   $2->yyval = $1->yyval;
            $2->token = ($1->token == TOK_ASSIGNOP)?TOK_ASSIGNOP:TOK_FUNCTION;
            yylogkill($1); $$ = $2;                                           }
    ;

operator_expression:
        operator
        {   if (ll_firstnode) yylogexpand($1, ll_firstnode);                  }
        expression
        {   yylogexpand($1, $3);
            $1->token = ($1->token == TOK_ASSIGNOP)?TOK_ASSIGNOP:TOK_FUNCTION;
            $$ = $1;                                                          }
    ;

command_or_operator_or_ident:
	TOK_IDENT
        {   $$ = $1;                                                          }
    |   command_or_operator
        {   $$ = $1;                                                          }
    ;

command_or_operator:
	TOK_COMMAND
        {   $$ = $1;                                                          }
    |   TOK_ATOM
        {   $$ = $1;                                                          }
    |   operator
        {   $$ = $1;                                                          }
    ;

operator:
        TOK_PROC
        {   $$ = $1;                                                          }
    |   TOK_OPERATOR
        {   $$ = $1;                                                          }
    |   TOK_ASSIGNOP
        {   $$ = $1;                                                          }
    ;

builtin:
        TOK_BUILTIN
        {   $$ = $1;                                                          }
    |   TOK_TRG
        {   $$ = $1;                                                          }
    ;

expression_list:
        '(' expressions ')'
        {   $$ = $2;                                                          }
    |   '(' ')'
        {   $$ = (ptr) yysugar(ll_sugarnode);                                 }
    |   /* empty */
        {   $$ = (ptr) yysugar(ll_sugarnode);                                 }
    ;

expressions:
        { $$ = ll_sugarnode; } param_expression
        {    $$ = (ptr) yysugar($1); yylogexpand($$, $2);                     }
    |   expressions ',' param_expression
        {    yylogexpand($1, $3); $$ = $1;                                    }
    ;

param_expression:
	TOK_CONST expression
	{    $$ = yylognode(TOK_CONST,0); yylogexpand($$, $2);                }
     |  expression
	{    $$ = $1;                                                         }
    ;

modident:
        TOK_STRING
        {   $$ = $1; $$->token = TOK_CONSTANT;                                }
    |   TOK_IDENT
        {   $$ = $1;                                                          }
    ;

modidents:
        modident
        {    $$ = yylognode(0,0);
             $1->yyval.len = 0; yylogexpand($$, $1);                          }
    |   modidents ',' modident
        {    $3->yyval.len = 0; yylogexpand($1, $3); $$ = $1;                 }
    ;

constidents:
	TOK_IDENT TOK_ASSIGNMENT expression
        {    $$ = yylognode(0,0);
             yylogexpand($1, yylognode(TOK_TEMPLATE, 0));
             yylogexpand($1, $3);
             $1->token = TOK_ASSIGNMENT;
             $1->yyval.len = 0; yylogexpand($$, $1);                          }
    |   constidents ',' TOK_IDENT TOK_ASSIGNMENT expression
        {    yylogexpand($3, yylognode(TOK_TEMPLATE, 0));
             yylogexpand($3, $5);
             $3->token = TOK_ASSIGNMENT;
             $3->yyval.len = 0; yylogexpand($1, $3); $$ = $1;                 }
    ;

varidents:
        ident_decl
        {    $$ = yylognode(0,0); yylogexpand($$, $1);                        }
    |   varidents ',' ident_decl
        {    yylogexpand($1, $3); $$ = $1;                                    }
    ;

initialization:
        TOK_ASSIGNMENT expression
        {    $$ = $2;                                                         }
    |   /* empty */
        {    $$ = NULL;                                                       }
    ;

ident_decl:
        { ll_resolution = 0; } TOK_IDENT { ll_resolution = 1; } initialization
        {    $$ = $2; $2->yyval.len = 0;
             if ($4) {
                 yylogexpand($$, yylognode(TOK_TEMPLATE, 0));
                 yylogexpand($$, $4);
                 $$->token = TOK_ASSIGNMENT;
             }                                                                }
    ;
%%

@-
Display the error information for the current client.
If the list-flag is on an arrow and state number is printed at the "appropriate"
place. If no lookahead character is a used and the next character is a newline,
we should also copy the input.
@{
@y
void ll_parserror(str msg){
	static char buf[1024];
	char *s=buf, *t, *l = ll_lastline();
	size_t i = strlen(GDKERROR);

        ll_modcmds = 0; ll_resolution = 1;
        ll_templates = 0; ll_parblockdepth = 0;

	*s++ = '"';
	for(t=l; *t; t++) {
		/* accidental %s directives in the lastline can
                   crash the vfsprintf later => escape them */
		if (*t == '%') *s++ = '%';
		*s++ = *t;
	}
	*s++ = '"'; *s++ = '\n';

	for(*s++ = '!'; i > 0; i--) *s++ = ' ';
        for (; *l; l++) {
		*s++ = (*l != '\t')?' ':'\t';
        }
	*s++ = '^'; *s++ = '\n'; *s = 0;
        if (msg) {
                sprintf(s, "! %s.\n", msg);
        } else {
        	sprintf(s, "! "); s += 2;
@-
Inlining this is a non-solution which was forced upon me by the new 
makefiles. It effectively introduces the new requirement that all yaccs 
should be the same. And they are not.. Sucker!
@y
#ifndef WIN32
#ifndef YYBISON
		{
		extern int yystate;
		extern int yylineno;

		if (GDKdebug&32768)
		switch(yystate) {
		case 3:	case 20: case 58: case 60: case 181: case 183:
			strcpy(s,"you forgot a closing ';'.\n"); break;
		case 11: case 12:
			strcpy(s,"identifier expected.\n"); break;
		case 13:
			strcpy(s,"command name expected.\n"); break;
		case 14:
			strcpy(s,"procedure expected.\n"); break;
		case 18: case 19: case 46: case 47:
			strcpy(s,"'(' expected.\n"); break;
		case 24: case 33: case 156:
			strcpy(s,"command invocation missing.\n"); break;
		case 36:
			strcpy(s,"would a identifier or ../ be missing?\n");
			break;
		case 48: case 51:
			strcpy(s,"would a ';' or ',' be missing?\n"); break;
		case 52: case 105: case 108: case 149:
			strcpy(s,"':=' expected.\n"); break;
		case 78: case 130: case 208: case 229: case 240: case 246:
			strcpy(s,"']' expected.\n"); break;
		case 79:
			strcpy(s,"forgot to close a block?\n"); break;
		case 77: case 80: case 117: case 118:
			strcpy(s,"')' expected.\n"); break;
		case 87:
			strcpy(s,"would a '~' or '?' be missing?\n"); break;
		case 95:
			strcpy(s,"would '..' or ')' be missing?\n"); break;
		case 96: case 97: case 182:
			strcpy(s,"identifier or string missing.\n"); break;
		case 99: case 103: case 107: case 187:
			strcpy(s,"identifier missing.\n"); break;
		case 129:
			strcpy(s,"'~' expected.?\n"); break;
		case 142: case 146: case 163: case 152:	case 202:
			strcpy(s,"would a ')' or ',' be missing?\n"); break;
		case 155:
			strcpy(s,"would a '@' or ';' be missing?\n"); break;
		case 170:
			strcpy(s,"would a atom or ')' be missing?\n"); break;
		case 209:
			strcpy(s,"':' expected.\n"); break;
		case 217:
			strcpy(s,"iterator expected.\n"); break;
		case 224: case 234: case 243:
			strcpy(s,"atom name expected.\n"); break;
		case 239:
			strcpy(s,"comma expected.\n"); break;
		}
    		}
#endif
#endif
		if (*s == 0) strcpy(s,"can't help you here, sorry.\n");
        }
	GDKerror(buf);
	ll_sugarnode = NULL;
}
@
@}

@+ Data conflicts
The parser performs a simple data dependency check for all
identifiers mentioned in a parallel block. Duplicate use
of an identifier is flagged as a potential conflict under
parallel execution.  It is up to the Monet programmer to assure
himself that these conflicts are avoided by other means (e.g.
if-then-else).

@{
@c
str        ids[500];		/* contains all ids of the parblock. */
char       iderrors[500];	/* just to avoid multiple warnings. */

@-
The identifier table is also used to map the formal arguments into their
position number.
In this case we start at the bottom.
@c
void ll_clrids(void) {
        str *t = ids;
        char *c = iderrors;

        while (t < ids+500 && *t) {
                *t++ = 0;
                *c++ = 0;
        }
        for( t= ids+499; *t  ; t-- ) {
                *t = 0;
        }
}

void ll_idconflict(str s){
        str        *t;
        char        *c;

        if (ll_parblockdepth == 0 ) {
                return ;
        }
        for (c = iderrors, t = ids; t < ids+500 && *t && *(t+1); t++, c++) {
                if (s && strcmp(*t, s) == 0) {
                        if (*c == 0) {
                                GDKwarning("// conflict on %s\n", s);
                        }
                        *c = *c + 1;
                        return ;
                }
        }
        if (t < ids+500) {
                *t = s;
        } else {
                GDKerror("potential // conflicts\n");
        }
}

@-
All variables mentioned in the constant list become constant.
@c
int CMDconstant(Cntxt stk, YYSTREE lt, ValPtr res){
	unsigned i;
        int j;
        Variable act;
        YYSTREE t;
	(void) res;

        for(t=lt; t; t=t->overflow) {
            for(i=0 ; i<lt->cnt; i++)
		    if ((int) arg(t, i)->token == monet_tokident) {
		    str nme = arg(t, i)->yyval.val.sval;
		    int s = stk;

		    for(j = arg(t, i)->yyval.len; j > 0; j--) {
			    if (s >= 0) {
				    s = monet_cntxt[s].outer;
			    } else {
				    GDKerror("illegal context.\n");
				    return -1;
			    }
		    }
		    if ((act = VARfind(&s, nme)) == 0) {
			    GDKerror("variable '%s' does not exist.\n",nme);
			    return -1;
		    }
		    if (act->constant) {
			    GDKerror("cannot assign to constant '%s'.\n",nme);
			    return -1;
		    }
		    VARfixate(act);
		} else {
		    GDKerror("CONST works on variable names only.\n");
		    return -1;
		}
        }
	return 0;
}
@
@}
