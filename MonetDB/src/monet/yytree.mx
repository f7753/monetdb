@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@' 
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@' 
@' The Original Code is the Monet Database System.
@' 
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2004 CWI.
@' All Rights Reserved.
@' 
@' Contributor(s):
@' 		Martin Kersten <Martin.Kersten@cwi.nl>
@' 		Peter Boncz <Peter.Boncz@cwi.nl>
@' 		Niels Nes <Niels.Nes@cwi.nl>
@' 		Stefan Manegold  <Stefan.Manegold@cwi.nl>

@f yytree
@a M. L. Kersten, P. Boncz
@+ The Parse Tree Structures
This file contains the utility routines to construct a parse tree
within a YACC environment.
@{
@h
#ifndef _YYTREE_H_
#define _YYTREE_H_

#include "monet.h"

#define par_retval	free.batref.id
#define old_cntxt	yyval.len

m_export YYSTREE 		yylognode(int, int);
m_export YYSTREE	 	yylogexpand(YYSTREE, YYSTREE);
m_export void 		yylogstart(void);
m_export void 		yylogclean(void);

m_export YYSTREE	 	yyexpand(YYSTREE, YYSTREE);
m_export YYSTREE 		yynode(int, int);
m_export YYSTREE 		yyload(FILE *);
m_export void 		yysave(FILE *, YYSTREE);
m_export void 		yyfree(YYSTREE);
m_export YYSTREE 		yycopy(YYSTREE);
m_export void 		yyclean(YYSTREE);
m_export YYSTREE 		yysubstitute_proc(YYSTREE, int, ValPtr);
m_export YYSTREE 		yysubstitute_iter(YYSTREE, int, ValPtr);
m_export int 		yypostprocess(YYSTREE);
m_export void 		yylogout(YYSTREE);
@c
#include "yytree.h"
#include <stdio.h> 
#include <ctype.h> 
#include "monet_parse.h"

static oid yyid = 1, yyoid = 1;
YYSTREE	 yyroot = NULL;
static YYSTREE nfree = NULL;

void yylogstart(void) { 
	yyroot = NULL;
}

void yylogclean(void) {
	YYSTREE t2, t1 = yyroot;
	while ((t2=t1) != NULL) {
	    t1 = t1->next; 
	    if (t2->free.yyid == 0) {
		@:yykill(t2)@
	    }
	}
}

void yylogout(YYSTREE t) {
	YYSTREE t1,t2=0;

	if (++yyoid == 0) yyoid=2; 
	yyid = yyoid;
	yypostprocess(t); 
	yyid = 1;

	for (t1=yyroot; t1; t1=t1->next) {
	    if (t1->free.yyid == yyoid) {
		if (t2) t2->next = t1->next;
		else yyroot = t1->next;
	    } else t2 = t1; 
	}
}

static 
void checklist(YYSTREE t) {
	YYSTREE t2, t1 = yyroot;
	while ((t2=t1) != NULL) {
	    t1 = t1->next; 
	    if (t2 == t) {
		t1 = yyroot;
		while(t1 != t2) {
			fprintf(stderr, PTRFMT " ", PTRFMTCAST (void *) t1);
			t1 = t1->next;
		}
		GDKerror("double present %d!!\n", t);
		break;
	    }
	}
}
	

YYSTREE yylognode( int tok, int val) {
	YYSTREE t = yynode(tok,val);
	PARDEBUG checklist(t);
	t->next = yyroot;
	return yyroot = t;
}

YYSTREE yynode( int tok, int val) {
	YYSTREE t;

  	MT_set_lock(monet_critical, "yynode");
	t = nfree;
	if (t)
		nfree = t->nfree;
	else
		t =(YYSTREE) GDKmalloc(sizeof(*t));
        MT_unset_lock(monet_critical, "yynode");
	memset(t, 0, sizeof(*t));
	t->token = tok;
	t->yyval.vtype = val;
	return t;
}

@= yykill
	if ((@1)->token != TOK_TEMPLATE &&
	    (@1)->yyval.val.pval &&
	    ATOMextern((@1)->yyval.vtype))
	{
		GDKfree((@1)->yyval.val.pval);
		(@1)->yyval.val.pval = 0;
	}
  	MT_set_lock(monet_critical, "yykill");
	(@1)->nfree = nfree;
	nfree = (@1);
        MT_unset_lock(monet_critical, "yykill");
@

@-
To avoid concurrency conflicts, all nodes are explicitly freed. 
@c
void yyfree(YYSTREE yytree) {
	YYSTREE delnode;
	unsigned i; 

	while (yytree) {
		for (i = 0; i < yytree->cnt; i++) {
			if (yytree->yysons[i]) {
				yyfree(yytree->yysons[i]);
			}
		}
		delnode = yytree; 
		yytree = yytree->overflow;
		@:yykill(delnode)@
	}
}

@= yyexpand
YYSTREE yy@1expand( YYSTREE yytree, YYSTREE y) {
	YYSTREE n;

	if (y == NULL) return yytree; 
	n = (yytree->last)?yytree->last:yytree;
	while (n->overflow) {
		n = n->overflow;
	}
	if (n->cnt == YYMAXSONS){
		yytree->last = n->overflow = yy@1node(0, 0);
		n = n->overflow;
		n->cnt = 1;
		n->yysons[0] = y;
	} else {
		n->yysons[n->cnt] = y;
		n->cnt++;
	}
	return yytree;
}
@c
@:yyexpand()@
@:yyexpand(log)@

extern str LEXNAME(int);

void yyprint(YYSTREE yytree) {
	static unsigned level;
	char	num[20], tpe[20],*p;
	unsigned i;

	for(i = 0; i < level; i++) printf("\t");
	if (yytree == 0) {
		printf("NULL\n");
		return;
	}
	switch(yytree->yyval.vtype) {
	case TYPE_int:	strcpy(tpe, "int"); break;
	case TYPE_chr:	strcpy(tpe, "chr"); break;
	case TYPE_bit:	strcpy(tpe, "bit"); break;
	case TYPE_oid:	strcpy(tpe, "oid"); break;
	case TYPE_str:	strcpy(tpe, "str"); break;
	case TYPE_ptr:	strcpy(tpe, "ptr"); break;
	case TYPE_flt:	strcpy(tpe, "flt"); break;
	case TYPE_bat:	strcpy(tpe, "bat"); break;
	default: 	sprintf(tpe, "extended%d", yytree->yyval.vtype);
	}
	if (yytree->yyval.vtype != TYPE_str) {
		p = num; sprintf(num, "%d", yytree->yyval.val.ival); 
	} else { 
		if (yytree->yyval.val.sval) {
			p = yytree->yyval.val.sval;
		} else {
			p = num; 
			strcpy(num, "<null>"); 
		}
	}
	printf("%s [%s][%s]\n",LEXNAME(yytree->token),tpe,p);
	level++;
	do {
		for (i = 0; i < yytree->cnt; i++) {
			if (yytree->yysons[i]) yyprint(yytree->yysons[i]);
		}
	} while((yytree = yytree->overflow) != NULL);
	level--;
}


void yysave(FILE *fp, YYSTREE t) {
	int i;

	do {
		fwrite(t, 1, sizeof(struct YYS), fp); 
		if (ATOMextern(t->yyval.vtype)) {
			i = strlen(t->yyval.val.sval) + 1;
			fwrite(&i, 1, 4, fp); 
			fwrite(t->yyval.val.sval, 1, i, fp); 
		}
		for(i = 0; i < YYMAXSONS && t->yysons[i]; i++) {
			yysave(fp, t->yysons[i]);
		}
	} while ((t = t->overflow) != NULL); 
}


YYSTREE yyload(FILE *fp) {
       	YYSTREE t = yynode(0,0);
	int i;

       	if (fread(t, 1, sizeof(struct YYS), fp) == sizeof(struct YYS)) {
		if (ATOMextern(t->yyval.vtype)) {
			if (fread(&i, 1, 4, fp) != 4) {
				return 0;
			}
			t->yyval.val.sval = GDKmalloc(i);	
			if (fread(t->yyval.val.sval, 1, i, fp) != (size_t) i) {
				return 0;
			}
		}
	       	for(i = 0; i < YYMAXSONS && t->yysons[i]; i++) {
	       		t->yysons[i] = yyload(fp);
       		}
		if (t->overflow) {
			t->overflow = yyload(fp);
		}
	} else {
		return 0; 
	}
	
	return t;
}


YYSTREE yycopy(YYSTREE t) {
        unsigned i;
        YYSTREE tn;
 
        if (t == 0) {
                return 0;
        }
        tn = yynode(t->token,0);
        tn->cnt = t->cnt;
        tn->yyval = t->yyval;
	if (t->yyval.val.pval && (t->token != TOK_TEMPLATE)) {
		if (t->yyval.vtype == TYPE_str) {
			tn->yyval.val.sval = GDKstrdup(t->yyval.val.sval); 
		} else if (ATOMextern(t->yyval.vtype)) {
			tn->yyval.val.pval = GDKmalloc(t->yyval.len); 
			memcpy(tn->yyval.val.pval, 
				t->yyval.val.pval, t->yyval.len);
		}
	}
 
        for (i = 0; i < t->cnt; i++) {
                if (t->yysons[i]) tn->yysons[i] = yycopy(t->yysons[i]);
        }
	if (t->overflow) {
		tn->overflow = yycopy(t->overflow);
	}
        return tn;
}

@- Set Operator Trees
@c

int yypostprocess(YYSTREE lt) {
@-
Rewrite TOK_ASSIGNOP in the non-multiplexed case into a simple assignment.
In this way, we do not have to interpret it. It can follow the normal route.
@c
	if (lt->token==TOK_ASSIGNOP) {
		if (lt->yyval.val.sval[0]!='[') {
			if (lt->yysons[0]->token != TOK_IDENT) {
			    lt->token = 0;
			    GDKerror("yypostprocess: must %s= to a variable\n"
				, lt->yyval.val.sval);
			} else {
			    YYSTREE var = yylognode(0,0);
			    YYSTREE op = yylognode(0,0);
			    *var = *lt->yysons[0];
			    *op = *lt;
			    var->yyval.val.sval=GDKstrdup(var->yyval.val.sval);
			    op->token = TOK_FUNCTION;
			    lt->token = TOK_ASSIGNMENT;
			    lt->yyval.val.ival = 0;
			    lt->yyval.vtype = TYPE_void;
			    lt->cnt = 2;
			    lt->last = lt->overflow = NULL;
			    lt->yysons[0] = var;
			    lt->yysons[1] = op;
			}
		    
		} else {
			/* multiplex_resolve will catch the ASSIGNOP */
			lt->token = TOK_FUNCTION;
			lt->yyval.len = -TOK_ASSIGNOP; 
		}
	} 
@-
rewrite the FUNCTION tree to its modern syntax with 
yysons[0]=params, yysons[1]=expansion-cache, yysons[2]=deref/NULL
We store the parameter evaluation space size in the ival of the exec node.
@c
	if (lt->token == TOK_ATOM) {
		lt->token = TOK_FUNCTION;
	}
	if (lt->token==TOK_FUNCTION || 
	    lt->token==TOK_SETOP || 
            lt->token==TOK_SETAGGR) 
	{
		YYSTREE params, exec = yynode(0,0), deref;
		if (lt->yyval.vtype == TYPE_void) {
			deref = lt->yysons[0];
		    	params = lt->yysons[1];
                	yypostprocess(deref);
		} else {
			deref = NULL;
		    	params = yynode(0,0);
			*params = *lt;
			params->token = 0;
			params->yyval.vtype = TYPE_void;
		}
		exec->yyval.vtype = TYPE_int;
		exec->yyval.val.ival = yypostprocess(params)*(int)sizeof(ValRecord);
		lt->cnt = 0;
		lt->last = lt->overflow = NULL;
		lt->free.yyid = yyid;
		yyexpand(lt,params); 
		yyexpand(lt,exec); 
		if (deref) yyexpand(lt,deref); 
	} else {
@-
otherwise just count the number of sons (i.e. parameters below 'params' nodes)
@c
		unsigned i;
		int sons = 1, range_sons = 0;
		YYSTREE t = lt;
		do {
			t->free.yyid = yyid;
			for(i=0; i<t->cnt; i++)
				if (t->yysons[i]) {
					range_sons |= (t->yysons[i]->token == TOK_RANGETEMP);
					yypostprocess(t->yysons[i]);
					sons++;
				}
		}  while ((t = t->overflow) != NULL);
		return range_sons?MAXPARAMS:sons;
	} 
        return 0;
}
 
@- Run-Time Proc Trees
Procedures are parsed into template trees, forming their definition.
At run-time, copies are drawn from it with @%yysubstitute()@. During
this copying phase, the @%$X@ parameters are substituted by TOK_TEMPLATE
values. @%TOK_TEMPLATE@ act as pointers in the Monet Interpreters: their
@%yyval.val.pval@ pointers point to a variable binding. The idea is
that on PROC invocation, an @%argv@ array of @%ValRecord@s exist, in which 
the actual parameter values have been assembled.  The run-time copy of the 
tree has pointers into this array, such that on repetitive PROC invocations, 
the new values just have to be assembled in the array, without having to 
traverse the MIL tree.
@c
YYSTREE yysubstitute_proc(YYSTREE t, int argc, ValPtr argv) {
	YYSTREE tt = yynode(t->token, 0);
	int i;
	unsigned j;

#if 0
argv->val.ival++; /* PETER: proc instantiation stats hack */
#endif
	tt->yyval = t->yyval;
       	if (t->token == TOK_TEMPLATE) {
	    if ((i = t->yyval.val.ival) == 0) {
		tt->token = TOK_CONSTANT;
		tt->yyval.vtype = TYPE_int;
		tt->yyval.val.ival = argc;
	    } else if ((i>0) && (i <= argc)) {
	        tt->yyval.vtype = TYPE_ptr;
		tt->yyval.val.pval = argv+i;
	    } else { 
		GDKerror("yysubstitute: illegal argument '$%d'.\n", i);
		tt->yyval.vtype = TYPE_int;
		tt->yyval.val.ival = 0;
	    }
	} else if (t->yyval.val.pval && ATOMextern(t->yyval.vtype)) {
	    if (t->yyval.vtype == TYPE_str) {
		tt->yyval.val.sval = GDKstrdup(t->yyval.val.pval);
	    } else {
	        tt->yyval.val.pval = GDKmalloc(t->yyval.len); 
	        memcpy(tt->yyval.val.pval, t->yyval.val.pval, t->yyval.len);
	    } 
	}
	tt->cnt = t->cnt;
	for(j = 0; j < t->cnt; j++) 
       	    if (t->yysons[j]) 
		tt->yysons[j] = yysubstitute_proc(t->yysons[j], argc, argv);

	if (t->overflow) 
	    tt->overflow = yysubstitute_proc(t->overflow, argc, argv);

	if ((t->token == TOK_VARTEMP)  || (t->token == TOK_RANGETEMP)) {
		tt->yyval.val.pval = (ptr) argv;
		tt->yyval.len = argc; 
	}
	return tt;
}

YYSTREE yysubstitute_iter(YYSTREE t, int argc, ValPtr argv) {
	YYSTREE tt = yynode(t->token, 0);
	unsigned i;

	tt->yyval = t->yyval;
       	if (t->token == TOK_ITERTEMP) {
	    tt->yyval.vtype = TYPE_ptr;
	    tt->yyval.val.pval = argv + t->yyval.val.ival;
	} else if (t->yyval.val.pval && ATOMextern(t->yyval.vtype)) {
	    if (t->yyval.vtype == TYPE_str) {
		tt->yyval.val.sval = GDKstrdup(t->yyval.val.pval);
	    } else {
	        tt->yyval.val.pval = GDKmalloc(t->yyval.len); 
	        memcpy(tt->yyval.val.pval, t->yyval.val.pval, t->yyval.len);
	    } 
	}
	tt->cnt = t->cnt;
	if (t->yysons[0]) 
	     tt->yysons[0] = (t->token == TOK_ITERATOR)?
		yycopy(t->yysons[0]):
		yysubstitute_iter(t->yysons[0], argc, argv);
	for(i = 1; i < t->cnt; i++) 
	    if (t->yysons[i]) 
		tt->yysons[i] = yysubstitute_iter(t->yysons[i], argc, argv);

	if (t->overflow)
	    tt->overflow = yysubstitute_iter(t->overflow, argc, argv);

	return tt;
}

@- Tree-guided Garbage Collection
The Monet Interpreter (mis)uses the syntax tree structures to guide the 
garbage collection process. This is because:
@T
\begin{itemize}
\item {\em it is possible}. MIL has call-by value parameters. Only return 
values are a problem, from the garbage collection point of view. Functions 
can at most have one return value, making its possible to do the job 
without specific datastructures.
\item {\em it is efficient}. We can avoid a garbage collection module, and
still collect garbage at the earliest possibe time. This is of course
gained by the restrictions put in by the language.
\end{itemize}
@
After invocation of a MIL statement, its MIL tree representation will
contain references to the allocated variables and even BATs, in 
the @%free@ field. MIL has the rule that each simple statement can
generate only one return value (all other garbage (if any) must be collected 
by hand!). This return value is propagated internally in during the
execution of the simple statement, and can only be deleted after the
simple statement has finished executing. 
@
Garbage collection calls are therfore done carefully at dedicated
places in the Monet Interpreter.
@
To obtain high performance, the @%CLEANUP@ macros is inserted for code
expansion, rather than a direct function call to @%yycleanup()@. Due 
to the recursive nature of the trees, it will of course come to recursion 
if trees are more than 2-deep.
@h
#define GARBAGE(x)								   \
	if (x->dealloc) {							   \
	    if (x->dealloc == TYPE_bat) {					   \
	      if (x->free.batref.id != bat_nil){				   \
		BAT* _b;							   \
		BBPfix(x->free.batref.id);					   \
		_b = BBPquickdesc(ABS(x->free.batref.id),FALSE);		   \
		if (_b == NULL) {						   \
			GDKerror("yyclean: BAT %d GONE\n", x->free.batref.id);	   \
		} else if (ABS(x->free.batref.stamp) != ABS(_b->batStamp)) {	   \
			GDKerror("yyclean: BAT %d OVERWRITTEN (stamp %d != %d)\n", \
 				x->free.batref.id,				   \
				_b->batStamp, x->free.batref.stamp);		   \
		} else {							   \
			ATOMunfix(x->dealloc, &x->free.batref.id);		   \
		}								   \
		BBPunfix(x->free.batref.id);					   \
	      }									   \
	    } else {								   \
		ATOMunfix(x->dealloc, x->free.atmref);				   \
		if (ATOMextern(x->dealloc)) GDKfree(x->free.atmref);		   \
	    }									   \
	    x->dealloc = 0;							   \
	}

#define CLEANUP(x)	switch(((YYSTREE) x)->token) {\
	case TOK_SEQ:        break;\
	case TOK_SEQBLOCK:   break;\
	case TOK_PARBLOCK:   break;\
	case TOK_ITCOMPILED: break;\
	case TOK_WHILE:      break;\
	default:\
	{       YYSTREE *cleanup_tt, cleanup_t;\
		unsigned cleanup_j;\
                for(cleanup_t = (YYSTREE) x; cleanup_t;\
		    cleanup_t = cleanup_t->overflow ) {\
                        for(cleanup_j = 0, cleanup_tt = cleanup_t->yysons;\
			    cleanup_j < cleanup_t->cnt;\
			    cleanup_j++, cleanup_tt++)\
			{\
                                if (*cleanup_tt) yyclean(*cleanup_tt);\
                        }\
                }\
         }\
         GARBAGE(((YYSTREE) x));\
}
#define CATCHVAL(stk,lt,res)							\
	if (res->vtype == TYPE_bat) {						\
		bat bid = res->val.bval;					\
		BAT* _b = BBPdescriptor(bid);				\
		assert(_b != NULL);						\
		if (_b->batStamp <= stamp) {					\
			PROPDEBUG monet_checkbat(_b, FALSE);			\
		} else if (_b->batStamp > 0) {					\
			CHECKDEBUG monet_checkbat(_b, BATcount(_b) > 0);	\
			if (BATcount(_b) > 0) {					\
				BATsetaccess(_b, BAT_READ);			\
			}							\
			_b->batStamp = -_b->batStamp;				\
		}								\
		BATDEBUG printf("# batstamp(%d) = %d\n",			\
			 (int) _b->batCacheid, _b->batStamp);			\
		BBPincref(bid, TRUE);					\
		BBPunfix(bid);					\
	}									\
	CATCHREF(stk,lt,res)
#define CATCHREF(stk,lt,res)						\
	lt->dealloc = res->vtype;					\
	if (res->vtype != TYPE_bat) {					\
		lt->free.atmref = res->val.pval;			\
	} else {							\
		lt->free.batref.id = res->val.bval;			\
		if (res->val.bval != bat_nil) {				\
			BAT* _b;					\
			BBPfix(res->val.bval);				\
			_b = BBPquickdesc(ABS(res->val.bval),FALSE);	\
			if (_b) lt->free.batref.stamp = _b->batStamp;	\
			BBPunfix(res->val.bval);			\
		}							\
	}
#define CATCHRET(stk,lt,res,x)			\
	if (x == -TOK_RETURN) {			\
		CATCHREF(stk,lt,res);		\
		x=0;				\
	}
#define CATCHERR(stk,lt,res,x,fcn)\
	if (x == -TOK_BREAK) {\
		x = 0;\
	} else if ((x<0) && (res->vtype == TYPE_str) && res->val.sval) {\
                char *s = (char*) TBL_getname(fcn);\
                GDKerror("%s: %s.\n", s?s:"null", res->val.sval);\
	        CLEANUP(lt); res->vtype = TYPE_void; lt->dealloc = 0;\
        }
#define CATCHBREAK(x) ((x==-TOK_BREAK)?0:x)

#endif /* _YYTREE_H_ */
@c

void yyclean(YYSTREE t) { switch(t->token) {
        case TOK_SEQ:
        case TOK_SEQBLOCK:
        case TOK_PARBLOCK:
        case TOK_WHILE:
        case TOK_ITCOMPILED: return;
        }
        GARBAGE(t);
	for (; t; t = t->overflow) {
                YYSTREE *sons;
		unsigned j;
                for(j = 0, sons= t->yysons; j < t->cnt; j++, sons++) {
                        if (*sons) CLEANUP(*sons);
                }
	}
}
@}
