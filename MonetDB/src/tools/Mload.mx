@f Mload
@a Peter Boncz
@v 2.0
@* Bulk Load Utility
@+ Manual Page
@T
The {\tt Mload} utility is used to bulk load ascii data into Monet.\\
A complete redo of version 1.0:
\begin{itemize}
\item the produced BATs are synced on head-column.
\item it administers which tail columns are sorted in the generated BATs.
\item it can handle complex parsing modes. You can mix positional and pattern
separated parsing.
\item it can process user extended data types.
\item you can link special purpose string-to-atom MIL extension commands
for parsing your weird files.
\item it can use the first value as a key value, instead of generating new OIDs.
\item it can generated unary BATs: synced with the other columns, but without
occupying space for the OID head-column.
\item very efficient now, by using smart memory mapping technique.
\item you cannot run out of swapspace any more. 
\end{itemize}
{\bf Beware}: the format for column specifications has changed!!\\
 
@- Usage
@T
\begin{verbatim}
Mload <file> { -db <db> | -home <home> | -id <stamp>}
      [-oid <seqbase>] [-s <size>] [-f <specfile>] { -mod <module> } 
      { [[~|*|+]<batname>],("<sep>"|<len>),<type>[::<fcn>][,<nil>] }
\end{verbatim}

Floats of the form \{digit\}.\{digit\} are parsed by an efficient
inline funtion. {\bf Floats with powers are broken!} Parse them as 
doubles..


@- Function
@T
The Mload utility bulk loads one table from an ASCII dump into BATs.
@
@- General Monet info
@T
The parameters in the command line start with standard Mserver switches.
They have their normal following semantics:
\begin{description}
\item[$file$:]
The name of the ascii file, contining one multiattribute table.
Each line is supposed to contain all data of exactly one tuple.
\item[$db$:]
The name of the Monet database where the data is to be stored.
The {\bf default} is the first matching entry in the 'homes' file.
\item[$stamp$:]
Generate OIDs with a certain stamps. Currently ony values between 0 an 
are supported.
\item[$size$:]
Probably you know how many tuples the table has. Tell it to Mload,
so it can allocate more efficiently its memory.
\end{description}
@
@- Extensibility Info 
@T
In order to accomodate user extended types, and user extended parsing 
functions, you can instruct Mload to load Monet extension modules first.
\begin{description}
\item[$module$:]
When loading datatypes that are user-implemented database extensions,
you should specify all extension modules that need be loaded.
\end{description}
Note, that Monet will be entered as 'adm', so you need to have any 
extensibility modules you want to know, installed under this name.
@
@- Column Info 
@T

For each column in the table, a specification has to be given.
\\
This can be done in the command-line, but also using a specification
file with one column-description per line (using the $-f$ option). 
Whether you do it the one way or the other (or in both ways), the 
format is the same. 
\\
Each column is described by one column-descriptor, 
which is a string without whitespace, consisting of an ordered
string of options separated by ciommas:
\begin{description}
\item[$batname$:]
A BAT name for this column ({\bf optional}). If this is omitted, the 
column is parsed but ignored; no BAT is generated. If the first character
of the given name is '*', then a BAT-array is generated; that is,
the head column is void, instead of an OID column. If the first character
of the given name is '$\sim$', then the BAT is created with reverse signature,
If the first character is a '+', then the BAT is assumed to exist already,
and the new tuples are added to it (all other options create new empty
BATs that overwrite previous existing versions!).
Finally, in the first
column specifier, if the BAT name is "{\bf key}", then no BAT is generated,
and the values of the first column are used as key (head values) in
the other BATs; instead of generating a unique OID.
\item[$sep$:]
A separator string to expect between the atoms.
\item[$len$:]
Expect a fixed-width field of a certain length.
\item[$type$:]
This is a string (without quotes) denoting the MIL type of the 
column. 
\item[$fcn$:]
A MIL function name that is to be used in order to convert the
data string to a Monet Atomic value ({\bf optional}).
\item[$nil$:]
Values consisting of this string are converted to a Monet NIL value
of the current column type.
\end{description}
\end{verbatim}
@
@+ Examples
@T 
To parse the gold database  as a column-separated list:
\begin{verbatim}
Mload load_100k age,",",int gender,",",chr carprice,",",int 
                category,",",str town,",",str class,",",str
\end{verbatim}
The {\tt load\_100k} is the ASCII file from which the data is read.
  
@- Format Files
@T
For multi-attribute tables it is often more clear to use
format files for the column specifications; instead of
putting everything in the command line.
Comments are permitted in format files.
{\small\begin{verbatim}
# demo of mixed pattern matching in Mload
key,"|",oid
*b1,1,bit,
*b2,1,bit,
*b3,1,bit,
*b4,1,bit,                              001|010101010man  20
*b5,1,bit,                              002|011010100vrouw34
*b6,1,bit,                              003|010100000vrouw119
*b7,1,bit,                              004|010110100nil  2
*b8,1,bit,                              005|011111000man  67
*b9,1,bit,                              006|010010100vrouw 4
mv,5,str,nil
age,3,int
\end{verbatim}}
Left: the format-file, right: the data-file, below: the command to execute: 
\begin{verbatim}
Mload <data_file> -db <database>  -f <format_file> 
\end{verbatim}}
@
@T
Points to note in this example:
\begin{itemize}
\item
no spaces may occur in each column specifier; neither when it is
passed in the command line, as when it is a line in the format file.
\item
Mload will use the values of the first column as key values
for all other BATS; instead of generating new unique OIDs
(this happens, because the BAT name of the first column has 
the special value "key");
\item
the first column is separated by a pattern, in this case "|".
\item
the other columns are by position. Note that no separator character
is necessary. 
\item
the generated BATs {\em b1..b9 } with boolean (bit) values; will be in sync
with each other and {\em mv} and {\em age}, but will have signature
BAT[void,bit]; without OID values (this happens, because there is
a '*' character in front of the names {\em b1..b9})!
\item
the lines of the datafile may differ by having different
widths in the last field. This is no problem, even if fixed-size
fields are used.
\end{itemize}
If a parsing error occurrs during loading of a tuple, you will
be notified, and {\bf no} BAT will have an entry for the tuple.
@
@{
@+ Implemenation
@c
#include <monet.h>
@c
#define CHUNK	100

typedef struct {
    int width, type, seplen, length;
    int (*parse)(), (*extfcn)();
    str sep, batname, nil; 
    ptr store, nilptr;
    BAT *b;
    int prv; /* location of previous */
} column_t;
	
int error, fatal;
str getenv();
str prog, mapped, end, base = (str) -1, input;
oid curoid = 0;
int line=1, ncols = 0, key=0, resolved = 0, chunk, size =10000;
column_t columns[4096] = { { 0 } };
ptr head = &curoid;

short_str mods[128] = { "kernel", "arith", "str", "bat", "algebra", "sys", "trans", { 0 } };
int num_mods = 7;

int usage(FILE* fp){
	fputs(prog, fp);
        fputs(": <ascii_file> { -db <db> | -id <stamp> | -home <home> | -version <ver>}\n",fp); 
	fputs("\t[-oid <seqbase>] [-s <size>] [-f <specfile>] {-mod <module>}\n\t{ [[~|*|+]",fp);
        fputs("<batname>],(\"<sep>\"|<len>),<type>[::<fcn>][,<nil>] } }\n",fp);
	exit(0);
}

@- Special Atom Parsing Functions.
@T
The format of the values in the ASCII file must either:
\begin{itemize}
\item {\em strictly adhere} to the standard MIL syntax for atoms (see the
@[<a href="http://www.cwi.nl/~monet/www/doc/mil.html">MIL Reference Manual</a>@).
\item or: {\em be parseable by a specified MIL extension function} that
gets a string parameter, and returns a value of the desired type.
\item or be one of the exceptions, namely: strings do not necessarily have
to start and end with "", nor do characters have to be bracketed by
''s. Also, boolean values can be specified with either 0/1 or \{t,T\}/\{f,F\}
or \{y,N\}/\{y,N\}.
\end{itemize}
@
@c
int getbit1(str buf, int *len, char **val) {
	**val = (*buf == '1');
	return 1; 
}

int getbit2(str buf, int *len, char **val) {
	**val = (*buf == 'y' || *buf == 'Y');
	return 1; 
}

int getbit3(str buf, int *len, char **val) {
	**val = (*buf == 't' || *buf == 'T');
	return 1; 
}

int getstr(str buf, int *len, char **val) {
	str p = buf;
	*val = buf;
	while(*p) p++;
	while(--p >= buf) 
	    if(*p != ' ') break;
	p[1] = 0;
	return p-buf;
}

int getchr(str buf, int *len, char **val) {
	**val = *buf;
	return 1;
}

/* this is much more efficient then the scanf implementation used
   in the gdk kernel. It only works for floats that have the simple
   form <digits>.<digits> */

#define mult10(x)	(x + x + (x<<3))

int getflt(char *src, int *len, float **dst) {
        str p = src;
        int base;
        float f;
 
        if (*p == '-' || *p == '+') p++;
        if (*p >= '0' && *p <= '9') {
            base = *p++ - '0';
            while (*p >= '0' && *p <= '9')
                base = mult10(base) + (*p++ - '0');
        } else if (*p == '.') {
	    base = 0;
	} else {
            **dst = flt_nil;
            return 0;
        }
	f = (float) base;
        if (*p == '.' && *++p >= '0' && *p <= '9') {
	    int div = 10;
            base = *p++ - '0';
            while (*p >= '0' && *p <= '9') {
                base = mult10(base) + (*p++ - '0');
		div = mult10(div);
	    }
	    f += ((float) base) / div;
	}
        **dst = (*src == '-')?-f:f;
        return p-src;
}

@- BATs Creation 
@c
extern BATstore **BBP_desc;
 
int bats_create() {
	int i,j;
	BAT *b;

	for(i=key; i <ncols; i++) 
	if (columns[i].batname) {
	    int rev = FALSE, add = FALSE, ht = TYPE_oid;
	    str nme = columns[i].batname;
	    while(*nme && !GDKisalnum(*nme)) {
	      if (*nme == '*') ht  = TYPE_void;
	      if (*nme == '~') rev = TRUE;
	      if (*nme == '+') add = TRUE;
	      nme++;
	    } if(!*nme) continue;
	    if (add && (j = BBPindex(nme))) {
		/*BBPfix(j);*/
		if ((b=BATdescriptor(j)) != NULL) {
		    b->batRestricted = BAT_WRITE;
		    ACCremoveall(b);
		    if(rev) columns[i].b = BATmirror(b); else columns[i].b = b;
		    if (BATcount(columns[i].b)){ /* not empty */
			int db;
			oid c;
		    	columns[i].prv = BATcount(b);
			c = *(oid*)BUNhead(columns[i].b,
				BUNptr(columns[i].b, columns[i].prv));
			db = c >> SERVERBITS;
			if (db != GDKdb) {
			    GDKfatal("%s: can only add to %s with -id %d.\n",
				prog, columns[i].batname, db);
			}
			curoid = MAX(curoid, c);
		    }
		} continue;
	    }

	    if (rev) {
	        b = BATnew(columns[i].type, ht, 100);
	        columns[i].b = b = BATmirror(b);
	    } else {
	        columns[i].b = b = BATnew(ht, columns[i].type, 100);
	    }
	    if (ht == TYPE_void) {
		b->hseqbase = curoid;
	    }
	    b->hsorted = b->tsorted = 0;

	    j = BBPindex(nme);
	    if (j > 0) {
		printf("%s: overwriting existing BAT '%s'.\n", prog, nme);
		BBPclear(j, TRUE);
	    } 
	    BATrename(columns[i].b, nme);
	    BATmode(columns[i].b, PERSISTENT);
	    columns[i].prv = -1;
	}
	return 0;
}

int bats_mmap() {
	int i;
	for(i=key; i <ncols; i++) 
	if (columns[i].b) {
	    int bid = columns[i].b->batCacheid;
	
	    columns[i].b->batDirty++;
	    columns[i].b->batRestricted = BAT_APPEND;
	    BATmmap(columns[i].b, STORE_MMAP, STORE_MMAP, STORE_MMAP, STORE_MMAP, STORE_MMAP);
	    BBPunload(bid);
	    BBPfix(bid);
	    columns[i].b = BATdescriptor(bid);
	    if (size > 0) BATextend(columns[i].b, BATcapacity(columns[i].b)+size);
	}
	return 0;
}

int bats_save() {
	int i,j=-1,order=-1;
	oid align; 

	if (!line) {
	     GDKwarning("%s: no tuples read.\n", prog);
	     return 0;
	}
	if (!key) {
	    int diff = curoid - OIDnew(0);
	    if (diff > 0) OIDnew(diff);
	}
	align = OIDnew(1);
	for(i=key; i <ncols; i++) 
	if (columns[i].b) {
	    int bid = columns[i].b->batCacheid;
	    if (columns[i].prv <= 0) { /* new bats */
		columns[i].b->halign = align;
	        BATpropcheck(BATmirror(columns[i].b));
            }
	    if (!key) {
		if (columns[i].prv >= 0){
		    ptr p = BUNptr(columns[i].b, columns[i].prv);
		    columns[i].b->hsorted &= *(oid*) BUNhead(columns[i].b,p) <= 
			*(oid*) BUNhead(columns[i].b,(str)p + BUNsize(columns[i].b));
		} else	{
		    columns[i].b->hsorted = TRUE;
		}
	    } else if (order == -1) {
		BATpropcheck(columns[i].b);
		order = BAThordered(columns[i].b);
	    } else {
		columns[i].b->hsorted = order;
	    }
	    if (!columns[i].b->hsorted) {
		GDKwarning("%s: %d-th head column is not sorted.\n", prog, i);
	    }
	    columns[i].b->batDirty++;
	    if (j >=0 && columns[j].b->halign != columns[i].b->halign) {
		GDKwarning("%s: %d-th head column not aligned with %d-th.\n", 
			prog, i, j);
	    }
	    columns[i].b->batRestricted = BAT_READ;
	    BBPunload(bid);
	    j = i;
	}
	return 0;
}

@- BATs Parsing and Filling
@c
int bats_retract(){
	int i;
	if (head) 
	  for(i=0; i <ncols; i++) 
	    if (columns[i].b) {
	      BUNdelHead(columns[i].b, head);
	    }
	GDKwarning("%s: parse error on line %d\n", prog, line);
	return 0;
}

#define bunins(b,p)\
		if (head == NULL) {\
		    head = p;\
		} else {\
	    	    if (b) BUNfastins(b, head, p);\
		}

@- Slow Variant
Inspects format, and decides on methodology.
@c
int bats_insert(str start, str end) {
	char c, *n, *q, *p=start;
	int i,l;

	for(i=0; i <ncols; i++, p = n) {
	    if ((q = columns[i].sep) != NULL) {
		if ((q = strstr(p, q)) != NULL) {
		    n = q + columns[i].seplen;
		} else if (i+1 == ncols ) {
		    q = end;
		} else {
		    return 0;
		}
	    } else if (i+1 == ncols ) {
		q = end;
	    } else { 
		n = q = p + columns[i].width;
		if (q > end) return 0;
	    }
	    while(q > p && GDKisspace(q[-1])) q--;
	    c = *q; *q = 0;
	    if (columns[i].nil && strcmp(columns[i].nil,p)==0) {
		bunins(columns[i].b, columns[i].nilptr);
		*q = c;
		continue;
	    }
	    while(GDKisspace(*p)) p++;
	    if (columns[i].parse == 0 && columns[i].extfcn == 0) {
	        columns[i].parse = BATatoms[columns[i].type].atomFromStr;
	        switch(columns[i].type) {
	        case TYPE_bit: 
		    if (q == p+1) {
			if (*p=='t' || *p=='T' || *p=='f' || *p=='F') {
			    columns[i].parse = getbit3;
			} else if (*p=='y' || *p=='Y' || *p=='n' || *p=='N') {
			    columns[i].parse = getbit2;
			} else if (*p=='0' || *p=='1' ) {
			    columns[i].parse = getbit1;
			}
		    } break;
		case TYPE_chr: 
		    if (*p != '\'') columns[i].parse = getchr;
		    break;
		case TYPE_flt: 
		    columns[i].parse = getflt;
		    break;
		case TYPE_str: 
		    if (*p != '"') columns[i].parse = getstr;
		}
		resolved++;
	    }
	    if (columns[i].parse) {
	        l = (*columns[i].parse)(p,&columns[i].length,&columns[i].store);
	        if (p + l > q) return 0;
	        bunins(columns[i].b, columns[i].store);
	    } else if (columns[i].extfcn) {
		if ((*columns[i].extfcn)(columns[i].store,p) == 0) 
			return 0;
		bunins(columns[i].b, columns[i].store);
	    }
	    *q = c;
	}
	return 1;
}

@- Fast Variant
@c
static INLINE 
int bats_insertfast(str start, str end) {
	column_t *last, *cur=columns;
	char c, *n, *q,*p=start;

	for(last=cur+ncols-1; cur <= last; cur++,p=n) {
	    if ((q = cur->sep) != NULL) {
		if ((q = strstr(p, q)) != NULL) {
		    n = q + cur->seplen;
		} else if (cur == last ) {
		    q = end;
		} else {
		    return 0;
		}
	    } else if (cur == last ) {
		q = end;
	    } else { 
		n = q = p + cur->width;
		if (q > end) return 0;
	    }
	    c = *q; *q = 0;
	    if (cur->nil && strcmp(cur->nil, p)==0) {
		bunins(cur->b, cur->nilptr);
		continue;
	    } 
	    while(GDKisspace(*p)) p++;
	    if (cur->parse) {
		if (p + (cur->parse)(p, &cur->length, &cur->store) > q) 
		    return 0;
		bunins(cur->b, cur->store);
	    } else if (cur->extfcn) {
		if ((*cur->extfcn)(cur->store,p) == 0) 
		    return 0;
		bunins(cur->b, cur->store);
	    }
	    *q = c;
	}
	return 1;
}

@- The Main Program
Go to the next line and make sure it is mapped changeable/private,
so changes are not copied back to disk.

#define bats_line(p,q)
@= bats_line
	q = strchr(p, '\n');
	if (q-p < ncols) {
	    GDKwarning("%s: bad line %d\n", prog, line);
	    continue;
	} 
	if (q-p > line_size) {
		GDKfree(line_start);
		line_start = GDKmalloc(line_size = (q-p)*2);
	}
	memcpy(line_start, p, q-p);
	line_end = line_start + (q-p);
	*line_end = 0; q++;
@c
int main(int argc, char**argv) { 	
	Client c;
	char **params = argv, *p, *q;
	char buf[1024];
	int line_size = 1024;
	char *line_start = (char*) GDKmalloc(line_size);
	char *line_end;
	struct stat st;
	int i, j, k, oidset = FALSE;
	FILE *fp;

	prog = argv[0];
	for(q=prog+strlen(prog)-1; q >= prog; q--)
		if (*q == '\\' || *q == '/') break;  
	prog = q+1;
	if(argc<4) usage(stdout);
@- 
Memory Map the ASCII file for sequential access  
@c
	if ((fp = fopen(argv[1], "r")) != NULL) {
	    fstat(fileno(fp), &st);
		/*
	    base = mmap(NULL, st.st_size, PROT_READ, MAP_SHARED, fileno(fp), 0);
	  */
	    fclose(fp);
	    base = MT_mmap(argv[1], MMAP_SEQUENTIAL, 0, st.st_size, NULL);
 	}
	if (base == (char*) -1) {
	    fprintf(stderr, 
		"%s: could not open %s for reading.\n", prog, argv[1]);
	    exit(0);
	}
	mapped = input = base;
	end = base + st.st_size;
	/*
	madvise(base, st.st_size, MADV_SEQUENTIAL);
	*/
@- 
Pass Through Standard DB Options 
@c
	for(i=2;i<argc;i+=2) 
	    if (strcmp(argv[i],"-home") &&
	        strcmp(argv[i],"-db") &&
	        strcmp(argv[i],"-version") &&
	        strcmp(argv[i],"-id")) break;
	k = i;
@- 
Read the Format File
@c
	if (i+1 < argc && strcmp(argv[i], "-oid") == 0) {
		oid* dst = (oid*) &curoid;
		int len = sizeof(oid);
		if (OIDfromStr(argv[i+1], &len, &dst));
			oidset = TRUE;
		i += 2;
	}
	if (i+1 < argc && strcmp(argv[i], "-s") == 0) {
		size = atoi(argv[i+1]); i += 2;
	}
	if (i+1 < argc && strcmp(argv[i], "-f") == 0) {
		static char* args[1024];
		FILE *fp = fopen(argv[i+1], "r");
		if (fp == NULL) {
		    GDKfatal("%s: could not read format file %s.\n", 
			prog, argv[i+1]); 
		}
		for(j=0; j < argc; j++)
			args[j] = argv[j];
		while((fgets(buf, 1024, fp)) != NULL) {
			if (*buf == '#') continue;
			if ((p = strchr(buf, '\n')) != NULL) *p = 0;
			args[argc++] = strdup(buf); 
	  	}
		params = args;
		i += 2;
		fclose(fp);
	}
@- 
Init Monet and Load Required Extension Modules
@c
	argv[0] = "-single";
	if ((c = (Client)monet_init(k+1, argv-1)) == 0) exit(0);
	static_module_init(c,buf);

	for(j=num_mods; i<argc; i+=2,j++) {
	    if(strcmp(params[i],"-mod")) break;
	    strcpy(mods[j], params[i+1]);
	}
	for(k=0; k<j; k++) {
	    int restype = 0;
	    sprintf(buf, "module(%s);\n", mods[k]);
	    if (k>num_mods) printf("%s: load extension %s", prog, buf);
	    (void) monet_eval(buf,&restype);
 	    if (restype < 0) {
		GDKfatal("%s: loading modules %s failed, aborting load.\n", prog, mods[k]);
	    }
	}
@- 
Column Specifier Parsing
@c
	for(j=i; i<argc; i++,ncols++) {
	    str r,q,p = params[i];
	    int *tpe,restype = 0;
	    q = strchr(p, ',');
	    if (p < q) {
		*q = 0;
		columns[ncols].batname = p;
		if (i==j && strcmp(p, "key")==0) {
		    key = 1; head = NULL;
		}
   	    } else if (q == NULL) {
		goto error;
	    } q++;
	    if (GDKisdigit(*q)) {
		columns[ncols].width = atoi(q);
		p = q;
	    } else {
		if (*q == '"' || *q == '\'') {
		    while((p = strchr(q+1, *q)) != NULL)
			if (p[-1] != '\\') break; 
		    if (!p) goto error;
	            q++; 
		} else p = q;
		*p++ = 0;
		columns[ncols].sep = q;
	    }
	    q = strchr(p, ','); 
	    if (!q) goto error;
	    *q++ = 0;
	    if (columns[ncols].sep) {
	        columns[ncols].seplen = strlen(columns[ncols].sep);
	    }
	    if ((p = strchr(q, ',')) != NULL) *p++ = 0;
	    if ((r = strstr(q, "::")) != NULL) { *r = 0; r += 2; }

	    sprintf(buf, "return monet_atomtbl.find(\"%s\");", q);
	    if ((tpe = (int*) monet_eval(buf,&restype)) != NULL) {
	        columns[ncols].type = *tpe; 
	    }
	    if (columns[ncols].type <= 0) goto error;
	    columns[ncols].length = ATOMsize(columns[ncols].type);
	    if (columns[ncols].length<32768) columns[ncols].length=32768;
	    columns[ncols].store = (ptr) malloc( columns[ncols].length);
	    if (r) {
		monet_sig_t sig;
		ValRecord params[2];

		params[1].vtype = TYPE_str;
		params[1].val.sval = r;

		if (TBL_normal_resolve(GDKstrdup(r), 2, params, &sig, 0) >= 0) {
			printf("%s: using function %s(str)\n", prog, r);
			columns[ncols].extfcn = sig.fast_fcn;
		}
		if (columns[ncols].extfcn == NULL) {
		    GDKerror("%s: extension function unknown.\n", prog);
		    goto error;
		} 
		r = ATOMname(sig.ret_tpe);
		if (strcmp(q, r)) {
		    GDKerror("%s: fcn returns %s.\n", prog, r);
		    goto error;
		} 
		resolved++;
	    } 
	    if (p) {
	        columns[ncols].nil = p;
	        columns[ncols].nilptr = ATOMnil(columns[ncols].type);
	    }
	    continue;
error:	    GDKfatal("%s: error in %d-th column spec.\n", prog, 1+i-j);
	}
@- Create the BATs
@c
	if (!oidset) {
		curoid = OIDnew(0);
	}
	bats_create();
	if (size*sizeof(int) > GDK_vm_minsize) {
		GDK_vm_minsize = 0L; /* this will make the bats memory mapped */  
	}
@-
Parse slowly, till parsing methods for all columns have resolved.
@c
	for(p=input, i=0; resolved<ncols; line++,i++,p=q) {
	    if (p >= end) break;
	    @:bats_line(p,q)@
	    if (!bats_insert(line_start, line_end)) 
		bats_retract();
	    if (key) head = NULL;
	    else curoid++;
	}
	if ((p-input) > 0) {
	    chunk = (CHUNK*MT_pagesize()) / ((p-input) / line);
	    bats_mmap();
	    while(p < end) {
	        unsigned int addr = (int) p;
	        q = p - (addr & (MT_pagesize()-1));
	        input = q;
@-
Quick parse & insert.
@c
	        for(i=0; i<chunk; line++,i++,p=q) {
		    if (p >= end) break;
	            @:bats_line(p,q)@
	    	    if (!bats_insertfast(line_start, line_end)) 
		        bats_retract();
		    if (key) head = NULL;
		    else curoid++;
	        }
            }
	}
@-
Postprocess the data.
@c
	bats_save();
	BBPdir();
	monet_exit();
	return 0; 
}
@}

