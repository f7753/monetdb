@a M. Kersten and Peter Boncz
@v 3
@f Mclient
@* The Monet Client interface
A textual interface to the Monet server providing command-line MIL access 
for its users. It is the preferred interface for non-DBAs.

Actually the implementation presented should have been rewritten
using the Mapi library.

@- Document control
June 1996 we added a little more functionality. In particular,
it should be possible to connect to a server by providing its
name only. The corresponding port is searched in the homes file
and the .gdk_lock file.

Furthermore, it becomes possible to re-connect to a session left
earlier. (See the Mserver code).

Control directives are '>' to sent output to a file.
Several textual changes made.

@+ Manual Page
@T
The {\tt Mclient} program, provides just as the Mserver console, a
MIL interface to the Monet server. Unlike the concolse, the {\tt Mclient} 
program is intended not only or the database administrator, but to all other 
users. It is more comfortable than the console, since it provides
a command history and automatic file name completion.

\begin{verbatim}
Mclient [-port HOST:PORT] [-session KEY] [-debug] [-prelude FILE] [-c single-command]  
\end{verbatim}

The following options are supported:
\begin{itemize}
\item {\em -port.} Connect to Mserver on machine HOST with tcp port PORT. 
If your MONETPORT environment variable points to "HOST:PORT" already, you
can omit this option.
\item {\em -debug}. Illustrate internalworking.
\item {\em -db.} Connect to a Monet server using the
information maintained in the homes file.
\item {\em -prelude.} At the start of the client session, execute --
before going into command-line mode-- a local file containing MIL statements.
\item {\em -c.} just execute a one-line MIL command (non-interactive mode).
\item {\em -session.} re-establish connection  with session identified.
\end{itemize}
@

@- Files
Mclient users should be aware of the Monet initialization script
stored in the database farm. They are shown below.
@T
\begin{tabular}{l l}
$MONETHOME/$DB/users/$USER/general.mil & general MIL commands executed at start \\
  & of user session. Only the database administrator can change this file.\\
$MONETHOME/$DB/users/$USER/prelude.mil & private MIL commands, executed \\
  & at start of user session. Users can edit this file.\\
$MONETHOME/$DB/users/$USER/epilogue.mil & private MIL commands, executed\\
  & at end of user session. Users can edit this file.\\
\end{tabular}
@
@{
@+ Implementation
@c
/*  (Copyright) 1995-1996 M.L. Kersten, CWI, Amsterdam
	Monet textual interface monitor.
*/
#define GDK_NOLINK
#include <gdk.h>
#include  <stdio.h> 
#include  <ctype.h> 
#include  <sys/types.h> 
#include  <sys/socket.h> 
#include  <errno.h> 
#include  <string.h> 
#include  <signal.h> 
#ifdef HAVE_UNISTD_H
#include  <unistd.h> 
#endif

#ifdef HAVE_PWD_H
#include  <pwd.h> 
#endif

#if TIME_WITH_SYS_TIME
# include <sys/time.h>
# include <time.h>
#else
# if HAVE_SYS_TIME_H
#  include <sys/time.h>
# else
#  include <time.h>
# endif
#endif

FILE	*fdopen();

extern int errno;                       /* pass errors  */
char *program;                          /* my name */
#if sun && !solaris
extern char *strchr();
#endif

#define EXIT(x)	{ exit(x); }
#define MAX_UN_ADDRESS_LEN	108
#undef max
#define max(a,	b)       ((a)>(b)?(a):(b))
#define LINEMODE	23
#define BLOCKMODE	32
#define MONETPROMPT	1

extern void echo(char  ch);
extern void promptMonet(char *s);

FILE	*toMonet;
FILE	*fromMonet;
FILE	*toConsole;
int	MonetId;
int	MonetTrace	= 0;
char 	*message	= 0;
char 	prompt[80], name[80];
int 	mode		= LINEMODE;
char 	address[80];/*	= "chart.fwi.uva.nl:50080"; */
char*	sentinel = "Mclient~sentinel"; 
int	sessionkey	= 0;
int	is_chrsp		= 0;
@-
Make a connection over the Internet to a running Monet server.
The  port-id is obtained from a system variable or should be
passed as a program argument. 
@c
int connectMonet() { 
	struct sockaddr *addr;
 	int	len, ret;
	char 	host[100], *s = strchr(address, ':');

#if ! defined(WIN32) && ! defined(__CYGWIN32__)
        /* unix socket optimization */
#include  <sys/un.h>  

 	if (s == NULL) { 
		struct sockaddr_un a;

		addr = (struct sockaddr *) &a;
		a.sun_family = AF_UNIX;
		if ((len = strlen(address)) > MAX_UN_ADDRESS_LEN) {
			errno = ENAMETOOLONG;
			return -1;
		}
		strcpy(a.sun_path, address);
		if ((MonetId = socket(PF_UNIX, SOCK_STREAM, 0)) < 0) {
			fprintf(toConsole,"! Failed to create a socket\n"); 
			return MonetId;
		}
		len += sizeof(a.sun_family);
	} else 
#endif
	{	/* default: tcp/ip socket */
		char thismachine[32];
		struct sockaddr_in a;
		struct hostent *hp;
		int 	port = atoi(&s[1]);

		strncpy(host, address, s-address);
		host[s-address] = 0;

		/* win95 makes a mess of its hostname function */
		gethostname(thismachine, 32);
		if ((host[0] == 0) || (strcmp(thismachine, host) == 0)) {
			strcpy(host, "localhost");
		}
		addr = (struct sockaddr *) &a;
		len = sizeof(a);
		memset(&a, 0, sizeof(a));

		a.sin_family = AF_INET;
		a.sin_port   = htons((unsigned short)(port&0xFFFF));

		if (!(hp = gethostbyname(host))) {
			return -1;
		}
		memcpy(&a.sin_addr, hp->h_addr, hp->h_length);

		if ((MonetId = socket(PF_INET, SOCK_STREAM, 0)) < 0) {
			return MonetId;
		}
	}
       	ret = connect(MonetId, addr, len) ? -1 : 0;
	if ( ret == -1 ) {
		perror("! Mclient.connectMonet.connect: ");
		fprintf(toConsole,"! Failed to establish connection\n");
		EXIT(0);
	}
	return ret;
}
@-
Interaction between Mclient and Mserver is synchronized on recognition
of an internal prompt character MONETPROMPT.
@c
void promptMonet(char *s) {
	int i;

	for(i=0; (s[i] = fgetc(fromMonet)) != MONETPROMPT; i++);
	s[i++] = ' '; 
	s[i] = '\0';
}

char getMonet() {
	char c = fgetc(fromMonet);

	if (ferror(fromMonet) || feof(fromMonet)) {
		return 0;
	}
	return c; 
}
@-
Output is normally sent to the file indicated by toConsole.
However, if this fails and the output was directed towards a
peer process, we have to reset the direction.
@c
void echo(char  ch) {
	if( fputc(ch, toConsole) == EOF ) {
			fprintf(toConsole,"Command terminated\n");
	}
}
@-
Dorequest sends the input to the server and collects the output.
It terminates upon encountering the prompt or the #!quit message
from the server.
@c

int doRequest(char *cmd, int bytes) { 
	char	ch;
	int sent;

        if (ferror(fromMonet) || ferror(toMonet)) {
                fprintf(toConsole,"! Communication line broken\n");
                return 'q';
        }
        if (MonetTrace) {
		fprintf(toConsole,"MonetMsg.send:%s\n", cmd);
	}
        if ((sent = fputs(cmd, toMonet)) == -1 || fflush(toMonet) == -1) {
                fprintf(toConsole,"! Write error on stream\n");
                return 'q';
        }
@-
Obtain the result from the command from the Monet pipe.
@c
	/* get the chars from monet */
	do {
		/* skip spaces */
		while ((ch = getMonet()) != 0 && isspace(ch)) 
			echo(ch);

		if (ch > 1) {
			do {
				echo(ch);
				if (ch == '\n') break;
			} while ((ch = getMonet()) != 0 && (ch != 1));
		} 
	} while (ch > 1);

        if (!ch) {
		fprintf(toConsole,"! Terminating connection\n");
                fprintf(toConsole,"! Connection broken\n");
                return 'q';
        }
	/* read the Monet prompt */
	promptMonet(prompt);
	return 0;
}
@-
The input for the Monet server is stored in a buffer until
the forward command is issued.
In LINEMODE each line is sent and the monitor awaits the prompt
of the server before continuing
@c
#define CHUNK_SIZE	1024

#ifdef HAVE_LIBREADLINE
#define SEND_MESSAGE()	{					\
	message[m_index++] = '\n';				\
	message[m_index] = 0;					\
	cmd = doRequest(message, m_index);			\
	add_history(start_cmd);					\
        *message = 0; m_index = 0;				\
}
#else
#define SEND_MESSAGE()	{					\
	message[m_index++] = '\n';				\
	message[m_index] = 0;					\
	cmd = doRequest(message, m_index);			\
        *message = 0; m_index = 0;				\
}
#endif

#define GROW_MESSAGE(x)	{					\
	m_index += x;						\
       	if (m_size-m_index  < CHUNK_SIZE) {			\
		message = (char *) realloc(message, m_size*=2);	\
		memset(message+m_index, 0, m_size-m_index);	\
	}							\
}

void clientAccept() {
	FILE	*fp;
	char 	*line=0, *start_cmd, *end_cmd;
	int	n, m_size=CHUNK_SIZE, m_index=0;
	char	cmd = 0, ch;

	message = (char *) malloc(CHUNK_SIZE);

	/* get the Monet prompt */
	while( (ch =fgetc(fromMonet)) != MONETPROMPT && ch != (char) EOF) 
		echo(ch);
	if( feof(fromMonet) ){
		fprintf(toConsole, "! Monet refuses access \n");
		cmd = 'q';
	} else promptMonet(prompt);
	
	while(cmd != 'q') {
		if (line) {
			free(line);
		}
#ifdef HAVE_LIBREADLINE
		if (is_chrsp){
	        	if ((line = (char *) readline(prompt)) == NULL) {
	               		return;
			}
		} else 
#endif
		{
		   	char *buf =(char *)malloc(CHUNK_SIZE);
	        	if ((line =(char *)fgets(buf,CHUNK_SIZE,stdin))==NULL) {
			   	free(buf);
	                	return;
			}
		}
		/* find start and end of the command */
		for(	start_cmd = line;
			*start_cmd && isspace(*start_cmd);
			start_cmd++);
		if (!*start_cmd) {
			continue;
		}
		for(	end_cmd = line + strlen(line) - 1; 
			isspace(*end_cmd);
			end_cmd--);
		n = 1 + end_cmd - start_cmd;
@-
The Mclient terminal monitor provides common functionality,
such as directory changes, reading commands from a file, 
redirection of output to a separate file.
@c
		/* is the string a command ? */
		switch(*start_cmd) {
		case '\\':
		        switch(*(start_cmd+1)) {
		        case 'r': 
				SEND_MESSAGE();
		                continue;
			case 'q':
				cmd = 'q';
				continue;
			case 'b':
				mode = BLOCKMODE;
				continue;
			case 'l':
				mode = LINEMODE;
				/*FALLTHRU*/
		        case 'c':
				m_index = 0; *message = 0;
				continue;
			}
			break;
		case '!':
			system(start_cmd+1);
			continue;
		case 'c':
			if ((start_cmd[1] == 'd') && isspace(start_cmd[2])) {
			    if (chdir(start_cmd+3)) {
                                char err[200];
                                sprintf(err, "chdir: %s", start_cmd+3);
                                perror(err);
			    } else {
				fprintf(toConsole,"chdir to %s\n", start_cmd+3);
			    }
			    message[0] = m_index = 0;
			    continue;
			}
			break;
		case '<':
			if (fp = fopen(start_cmd+1, "r")) {
				while (n = fread(message+m_index, 1,
							 CHUNK_SIZE, fp))
				{
					GROW_MESSAGE(n);
					/* echo to stdout */
					message[m_index] = 0;
					fwrite(message+m_index-n, 1, n, stdout); 
				}
			}
			break;
@-
The output should be saved in a different file.
Ommision of a file name or failure to create it, resets
the output to the stdout. (Also >>)
@c
		case '>':
			if( n==1) {
				toConsole = stdout;
				fprintf(toConsole,"Redirect to standard output\n");
				continue;
			}
			if( strcmp(start_cmd+1,"stdout") == 0) {
				toConsole = stdout;
				continue;
			}
			if( strcmp(start_cmd+1,"stderr") == 0) {
				toConsole = stderr;
				continue;
			}
			toConsole = fopen(start_cmd+1,"w");
			if( toConsole == NULL ){
				toConsole = stdout;
				fprintf(toConsole,
				"! Unable to redirect to %s\n", start_cmd+1);
			} else
				printf("output switched to %s\n",start_cmd+1);
			continue;
@-
The commands available in the terminal monitor can be obtained
using its help operator '?'.
@c
		case '?':
			fprintf(toConsole,"?\t - this message\n");
			fprintf(toConsole,"!\t - shell escape\n");
			fprintf(toConsole,"<file\t - read input from file\n");
			fprintf(toConsole,">file\t - save response in file\n");
			fprintf(toConsole,">\t - response to terminal\n");
			fprintf(toConsole,"cd\t - change directory \n");
			fprintf(toConsole,"\\r\t- run the buffered command \n");
			fprintf(toConsole,"\\c\t- clear the command buffer\n");
			fprintf(toConsole,"\\b\t- block mode, collect up to \\r\n");
			fprintf(toConsole,"\\l\t- line is immediately sent \n");
			fprintf(toConsole,"\\q\t- terminate session \n");
			continue;
		} 
		/* copy the line to the end of the message */
		memcpy(message+m_index, start_cmd, n);
		GROW_MESSAGE(n);
		
		if (mode == LINEMODE) {
			SEND_MESSAGE();
	        }
        } 
}
@-
Upon end of pipe, we have to stop Mclient
@c
void stopClient(int dummy) {
        int pid, status;

        while ((pid = waitpid(-1, &status, WNOHANG)) > 0);

        fprintf(toConsole,"BROKEN PIPE %d (arg %d)\n",pid,dummy);
	EXIT(0);
}

@-
Set up a bidirectional communication stream with another process
@
int rwpopen(char* cmd, FILE** fp_in, FILE** fp_out) {
        int up[2], down[2];
 
        if (pipe(up) || pipe(down)) {
                return (int) (*fp_in = *fp_out = 0);
        }
        if (fork()) {
                close(down[0]);
                close(up[1]);
        } else {
                char *argv[80], *p = cmd;
                int i = 1;
 
                /* put arguments in argv[][] format. */
                argv[0] = cmd;
                while(p = strchr(p, ' ')) {
                        *p = 0; argv[i++] = ++p;
                }
                argv[i] = 0;
 
                /* remap stdin and stdout of child process */
                dup2(up[1], 1);
                close(up[0]);
                dup2(down[0], 0);
                close(down[1]);
 
                if (execvp(cmd, argv) == -1) {
                        fprintf(stderr, "Mclient: could not execute %s.", cmd);
			EXIT(1);
                }
        }
        return ((*fp_out = fdopen(down[1], "w")) &&
                (*fp_in = fdopen(up[0], "r")));
}
@c
void usage() {
	fprintf(stderr, "Usage: %s [-port host:port] ", program);
 	fprintf(stderr, "[-db name ] ");
	fprintf(stderr, "[-session key] ");
 	fprintf(stderr, "[-prelude  pfile ]\n");
 	fprintf(stderr, "[-c command] ");
 	fprintf(stderr, "[-help ] \n");
 	EXIT(1);
}

int main(int argc, char **argv) {
	struct passwd *pwd = getpwuid(getuid());
	char	*command = 0;
 	char	*prelude  = 0;  
	char	*port = (char *) getenv("MONETPORT");
  	int	block = 0;
	int	debug = 0;
	int	i;
	struct stat st;

	toMonet	= stdout;
	fromMonet = stdin;
	toConsole = stdout;
	fstat(fileno(stdin),&st);

	if (S_ISCHR(st.st_mode))
	   is_chrsp = 1;
	else
	   is_chrsp = 0;

	program = argv[0];
        strcpy(name, pwd?pwd->pw_name:"guest");
	if (port) strcpy(address, port);
 
	if (argc == 0) {
		usage();
	}
	for(i = 1; i < argc; i++) {
		if (argv[i][0] == '-') {
			switch(argv[i][1]) {
			case 'd':
				if( strcmp(argv[i],"-db") == 0) {
					if( findport(argv[++i])==0)
						EXIT(0);
				} else debug++;
				break;
			case 'p':
				if (strcmp(argv[i], "-port") == 0) {
					strcpy(address, argv[++i]);
				} else if (strcmp(argv[i], "-prelude") == 0) {
					prelude = argv[++i];
				}
				break;
			case 'h':
				if (strcmp(argv[i], "-help") == 0) {
					usage();
					EXIT(0);
				}
				break;
                       case 's':
                                if (strcmp(argv[i],"-session") == 0) {
                                        i++;
                                        sessionkey= atoi(argv[i]);
                                }
                                break;
       			case 'c':
		        	command = argv[i];
				break;
			default:
				fprintf(stderr, "unknown argument:%s\n", 
						argv[i]);
				usage();
			}
		}
	}
	MT_init_posix();
	if (debug==0) {
		if (connectMonet(address) < 0) {
			perror("connection");
			EXIT(2);
		} else {
			if( sessionkey) {
				sprintf(name,"%s:%d\n",name,sessionkey);
				printf("#establish connection for %s\n", name);
				fflush(stdout);
			} else {
				sprintf(name,"%s\n",name);
			}
			toMonet = fdopen(MonetId, "w");
			fromMonet = fdopen(MonetId, "r");

			if ( toMonet == 0 || fromMonet == 0 ) {
				printf("! Communication lost\n");
				EXIT(0);
			}
			fwrite(name, 1, strlen(name), toMonet);
			fflush(toMonet);
 		}
	}
/*	sigset(SIGPIPE, stopClient);*/
 
	if (prelude) {
		int	i,j=0;
		FILE	*f = fopen(prelude, "r");

		if (!f) {
			fprintf(toConsole,"unable to open prelude %s.\n", 
				prelude);
		} else {
			char c;
			char *prev;
			int len, bufsize = 80;
			char *buf;

			buf = (char*) malloc(bufsize);

			fseek(f, 0, 2);
			i = ftell(f);
			message = (char*) malloc(i+2);
			fseek(f, 0, 0);
			fread(message, 1, i, f);
			if (message[i-1] != '\n')
				message[i++] = '\n';
			message[i] = 0;
			prev = message;
			for (;*message!=0;message++) {
				if (*message == '\n') {
					len = message-prev+1;
					if (len >= bufsize) {
						free(buf);
						bufsize = len+1;
						buf = (char*) malloc(bufsize);
					}
					strncpy(buf, prev, len);
					buf[len] = 0;
					doRequest(buf, len);
					prev = message+1;
				}
			}
			sprintf(buf, "printf(\"%s\");\n", sentinel);
@-
Check basic working of Monet interaction.
@c
			doRequest(buf, strlen(buf));
			free(buf);
			while(c = fgetc(fromMonet)) {
				if (feof(fromMonet)) return 0;
				if (c == sentinel[j]) j++;	
				if (j == 16) break; 
			}
		}
	}

	/* sent a single command to the server */
	if (command) { 
		doRequest(command, strlen(command)); 
	} else {
		clientAccept();
	}
	EXIT(0);
	return 0;
}
@+ Home file
Uses the common code from gdk_utils.mx
@c
#define GDK_NOLINK
#include <gdk.h>
#include "../gdk/gdk_utils.c"

int findport(char *dbnme) {
        char *home,homefile[PATHLENGTH];
        FILE *fp;
 
        home = (char*) getenv("MONETFARM");
        if( home == 0) {
            home = (char*) getenv("MONETHOME");
            if( home == 0) {
                fprintf(toConsole,"MONETHOME variable not set.\n");
                return 0;
            }
        }
        sprintf(homefile, "%s%chomes", home, DIR_SEP);

        GDKhomeScan(name, dbnme, homefile);
 
        strcat(strcat(GDKenviron[GDKdir], DIR_SEP_STR), ".gdk_lock");
        fp = fopen(GDKenviron[GDKdir],"r");
        if (fp == NULL){
                fprintf(stderr,"! Server '%s' not running\n", dbnme);
                return 0;
        }
	fseek(fp, 1L, SEEK_SET);
        fgets(address,80,fp);
        fclose(fp);
        return 1;
}
@}
