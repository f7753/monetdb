@f Mrecover
@a M. L. Kersten and Peter Boncz
@v 0.9
@* The Crash Recovery Utility
@+ Manual Page
@T
After a system crash the internal administration may be inconsistent.
The {\tt Mrecover} utility performs an analysis to assess damage and 
repairs the situation.
 
@- Usage
@T
\begin{verbatim}
Mrecover [-home <file>] -db <name> 
\end{verbatim}
@{
@+ Implementation 
@c
#include <gdk.h>

#define AMODE	0755 

extern void dbargs();
extern void chkDir();
extern void chkTmp();
extern void chkBAT();
extern void chkBBP();
extern int chkFile(char *nme, char *extension, int i);

char * home = 0, *db = 0;
int dbload =0;

void usage() {
	printf("usage: Mrecover [-home <home>] -db <dbname> \n");
}

int main(int argc, char **argv){
        char *args[5];
	char buffer[2000];
@-
Malloc options are set to avoid memory fragmentation. These options
should be copied from monet/main.c
@c
#if !(defined(WIN32) || defined(LINUX))
	mallopt(M_MXFAST, 1024);
	mallopt(M_NLBLKS, 100);
	mallopt(M_GRAIN, 128);
#ifdef IRIX
	mallopt(M_BLKSZ, 8*1024);
#endif
#endif
        dbargs(argc,argv,args);
	args[4]= GDKstrdup("-recover");
        GDKinit(5,args);
	GDKrecovery= 1;
	printf("Recovery of database %s in progress\n",args[3]);
	sprintf(buffer,"%s/core",dbhome);
	unlink(buffer);

	chkDir();
	chkBBP();
	printf("\nDATABASE RECOVERED. GOOD LUCK\n");
	BBPdir();
	GDKexit();
	return 0;
}
@-
First action is to read and check the BBP table.
@c
void chkBBP() {
	int i;
	printf("Repairing Bat Buffer Pool\n");
	BBPclear(0, TRUE);
	for(i=1;i<BBPsize;i++) {
		char *logical = BBP_logical(i);
		char *physical = BBP_physical(i);

		if(logical && physical==NULL){
			printf("Physical part missing: %s, ", logical);
			printf(" Clearing the entry\n");
			BBPclear(i, TRUE);
		} else if (physical && logical==NULL){
			printf("Logical part missing:%s, ", physical); 
			printf(" Clearing the entry\n");
			BBPclear(i, TRUE);
		} else if (physical && chkFile(physical,"desc",i)) {
			chkFile(physical,"buns",i);
		}
	} 
}

int chkFile(char *nme, char *extension, int i) {
	FILE *f,*fc;
	int r=1;
	char buf[200];
	sprintf(buf,"%s.Z",extension);
	
	f= (FILE*) GDKfilelocate(nme,"r",extension);
	fc= (FILE*) GDKfilelocate(nme,"r",buf);
	if(f && fc){
		printf("Replicate storage %s%s and %s%s\n",
			nme,extension,nme,buf);
		printf(" Remove one by hand \n");
	} else
	if(f==NULL && fc==NULL){
		printf("File missing: %s%s, ",nme,extension);
		printf(" Clear BBPentry\n");
		BBPclear(i, TRUE); 
		r=0;
	}
	if(f) fclose(f); if(fc) fclose(fc);
	return r;
}
@-
The next phase inspects the directory for files that look like a BAT, but
which are not stored in the BBP table. Repair simply means addition.
In particular, it should try to cope with old-fashioned directory structures
and role the database structure to a new version.
@c

void chkDir_recursive(str dirname) {
	char msg[200], *s, *t;
	DIR *dp;

	sprintf(msg,"%s/bat/%s", dbhome, dirname);
	printf("scanning the directory %s\n",msg);

	dp= opendir(msg);
	if( dp== (DIR*) NULL){
		printf("Could not open database directory %s\n",msg);
		return;
	}
	for(;;){
		struct dirent *dirp= (struct dirent*) readdir(dp);

		if( dirp== (struct dirent *) NULL){
			closedir(dp);
			break;
		}
		s = dirp->d_name;
		if ((s[0] >= '0' && s[0] <= '7' && s[1] >= '0' && s[1] <= '7' && s[2] == 0) ||
		    (strcmp(s, "LEFTOVERS") == 0))
		{
			long_str path;
			strcpy(path, s); strcat(path,"/");
			chkDir_recursive(path);
			continue;
		} 
		t = (char*) strchr(dirp->d_name,'.');
		if(t && (strcmp(t,".desc")==0 || strcmp(t,".desc.Z")==0)){	
			*t=0;
			if(BBPindex(s)) {
				continue;
			}
			if (s[0] != 't' || s[1] != 'm' || s[2] != 'p' || s[3] != '_') {
				int i = BBPentry(dirname, s, PERSISTENT);
				BAT *b = BATload(s);
				if (b == NULL) {
					BBPclear(i, TRUE); /* failed to recuperate it */
				} else {
					BBPreclaim(b);
				} 
			}
		}
	}
}

void chkDir() {
	char buffer[2048];
	long_str msg;

	chkDir_recursive("/");
@-
Version 3.04 uses the notion of <db>/users/<usr> for collectin
specific user items
@c
	sprintf(msg, "%s/users", dbhome);
	if( opendir(msg) == (DIR*) NULL){
                fprintf(stderr,"Create users directory\n");
                sprintf(buffer,"%s/users",dbhome);
                if( mkdir(buffer,AMODE))
                fprintf(stderr,"failed to create %s\n",buffer);

                /* copy standard prelude en procs files to local place */
                sprintf(buffer,"cp -r %s/scripts/* %s/users",home,dbhome);
                system(buffer);
                printf("%s\n", buffer);

	}
}
	
@- Common utilities
The routine getarguments is shared by most tools. They analyse the calling
parameters to determine the home and database. 
Furthermore, it prepares the argument list for the database server.
This code is textually included in all relevant tools. (Should be
done in a better way).
@c
void dbargs(int argc, char **argv, char *args[4]){
 	int i; 
	char buf[PATHLENGTH];

	args[0]= GDKstrdup("-home");
	args[2] = GDKstrdup("-db");
	home= (char*) getenv("MONETHOME");
	if(argc<3) usage();
	for(i=1;i<argc;i++)
	if( strcmp(argv[i],"-home")==0)
		home = argv[++i];
	else
	if( strcmp(argv[i],"-db")==0)
		db = argv[++i];
	else
	if ( strcmp(argv[i],"-load") == 0)
		dbload =1;

        if( home == 0) {
                printf("MONETHOME missing\n");
		exit(0);
        } 

        if( db == 0) {
                printf("database name missing\n");
		exit(0);
        }
	sprintf(buf,"%s/homes",home);
	args[1] = GDKstrdup(buf);
	args[3] = GDKstrdup(db);
}
@}
