@t Monet cgi-bin framework
@f Mcgi
@a M.L.Kersten and F. Waas
@v 1.0
@* Introduction
This module provides a cgi-bin interface to run a MIL program against
any running Monet server. It can be used as part of an html-form
to trigger a simple transaction against the database.

The interface reads the cgi paramater bindings from standard input.
The following list of reserved variables are is used by the interface.
In principle they should be set by the user to assure contact with
the proper Monet server.

@T
\begin{tabular}{|l|l|}\hline
{\em parameter} & {\em default} \\\hline
database &	demo \\
server	&	vlieland.cwi.nl\\
port	&	50080 \\
user	&	guest\\
password &	\\
\end{tabular}
@

In addition, the interface can be controlled by changing the
value of the following parameters:

@T
\begin{tabular}{|l|l|}\hline
{\em parameter} & {\em default} \\\hline
tabulate	& on (off)\\
echo	& on (off)\\
rowlimit	& 64 \\
timeout	& 10 \\
%urlbase		&\\
%urlerror	& McgiError.html\\
\end{tabular}
@

The remaining list of  variable bindings is interpreted as a
MIL program of simple assignment.
This way, the form arguments appear as global variable
initializations in the context of the server. The last action
then typically consists of calling a MIL procedure to compute and
format the required response.

@T
A simple bibtex library example is included in 
Section  \ref{bibtex} to illustrate the effectiveness of this interface.
@

The functionality of this interface is likely to be extended in
the near future to compile (simple) SQL queries.
@* The Gory Details
In principle all we have to do is taking the input string passed on
via stdin, decrypt special symbols and use all pre-requisite parameters to
open a connection to an Mserver.
The remaining parameter settings are interpreted as MIL assignment statements.

Setting the variable "sql" calls for compiling the corresponding
SQL statement into a MIL program first.
Then, run the MIL and display the output as HTML.

Output is mostly formatted by the MIL procedures being called. 
This involves generation of a complete HTML compliant text.
For development we provide a standard output format, which
echos the request and a tabular display of the results.
The default tabulart formatting can be turned of by 
setting the variable "tabulate" to "off".
Echoing the form request parameters can by turned off with "echo=off".
@h
#ifdef HAVE_CONFIG_H
# include <config.h>
#endif
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#ifdef HAVE_UNISTD_H
# include <unistd.h>
#endif
#include <stdarg.h>


struct dictEntry {
    char *name, *value;
    int markup;
};

// some prototypes

void convertString(char *string);

char *dictLookup(char *name);
void getInput();

void htmlError(char *format,...);
void htmlComment(char *format,...);
void htmlFooter();
void htmlHeader(char *type);

void processQuery();
void prettyPrint();
@-
The Mcgi command uses a dictionary of name/value pairs.
@C
#include "Mcgi.h"
#include "Mapi.h"

#include <sys/types.h>
#include <signal.h>

#ifdef HAVE_SYS_RESOURCE_H
# include <sys/resource.h>
#endif

#if TIME_WITH_SYS_TIME
# include <sys/time.h>
# include <time.h>
#else
# if HAVE_SYS_TIME_H
#  include <sys/time.h>
# else
#  include <time.h>
# endif
#endif


#ifdef HAVE_PTHREAD_H
#include <pthread.h>
#endif

#define MSEC 1000000.0

// compute difference of two time val structures

#define TIME_DIFF(t_one,t_two)   (((t_one.tv_sec-t_two.tv_sec)*MSEC)+(t_one.tv_usec-t_two.tv_usec))/MSEC

#define UTIME_DIFF(ra,rb)       TIME_DIFF(rb.ru_utime,ra.ru_utime)
#define STIME_DIFF(ra,rb)       TIME_DIFF(rb.ru_stime,ra.ru_stime)


char *inputLine=0;
dictEntry *dict=0;
int dictSize=0;

// html as the page output stream; easy to divert if necessary.
FILE *html=0;
Msession mid=0;

@+ Helpers
The input received from the form is encoded in the standard
URL format of changing spaces to +, and encoding special
characters with %xx hexadeicmal encoding. The helper routines
take care of proper decoding.
@C
char x2c(char *string) {
    char digit=(string[0]>='A'? (string[0] & 0xdf)-'A'+10 : string[0]-'0');
    digit*=16;
    digit+=(string[1]>='A'? (string[1] & 0xdf)-'A'+10 : string[1]-'0');

    return digit;
}


void convertString(char *string) {
    int x = 0, y=0;
    for (x=0,y=0; string[y]; ++x,++y)
        {
            if (string[y]=='+') string[y]=' ';
            if ((string[x]=string[y])=='%')
                {
                    string[x]=x2c(&string[y+1]);
                    y+=2;
                }
        }
    string[x]=0;
//    printf("converted to %s\n",string);
}

@+ HTML helpers
The functions provided here can be adjusted to provide a customized
look. The current version has been designed to ease development
of form-based applications.
@C

void htmlTimeStamp() {
    time_t tloc;
    time(&tloc);
    htmlComment(ctime(&tloc));
}

void htmlHeader(char *type) {
    html=stdout;
    fprintf(html,"Content-type: %s\n\n",type);
    fprintf(html,"<HTML><BODY BGCOLOR=\"#FFFFFF\">\n");
    htmlTimeStamp();
}

void htmlSeparator(){
    fprintf(html,"<HR>\n");
    htmlTimeStamp();
}


void htmlDictionary() {
    int i;
    fprintf(html,"<p><table border=1>");
    fprintf(html,"<tr><th>Name</th><th>Value</th></tr>\n");
    for( i=0; i< dictSize; i++)
        fprintf(html,"<tr><td>%s</td><td>%s</td></tr>\n",
            dict[i].name, dictLookup(dict[i].name));

    fprintf(html,"</table>");
}

void htmlFooter() {
    htmlTimeStamp();
    fprintf(html,"</BODY></HTML>\n");
}

@- Error diagnostics
Errors encountered by Mcgi lead to standard messages.
The two most important errors are rowlimit overflow
and a time out. 
@C

void setRowlimitError(){
    strcat(mid->errortext,"<p>Your call to the Monet common gateway \n");
    strcat(mid->errortext,"interface has been terminated due to \n");
    strcat(mid->errortext,"excessing the rowlimit for tabular displays. \n");
    strcat(mid->errortext,"<p>\n");
    strcat(mid->errortext,"The row limit parameter can be adjusted in your\n");
    strcat(mid->errortext,"forms using 'rowlimit=#', where # is the total\n");
    strcat(mid->errortext,"number of rows you are willing to accept\n");
    strcat(mid->errortext," from the database server\n");
    strcat(mid->errortext,"<p>\n");
    strcat(mid->errortext,"The current value is ");
    strcat(mid->errortext,dictLookup("rowlimit"));
    strcat(mid->errortext,".<P>\n");
    mid->error=MEOBAT;
}


void setTimeoutError(){
    sprintf(mid->errortext,"<p>Your call to the Monet common gateway ");
    strcat(mid->errortext,"interface has been terminated due to a \n");
    strcat(mid->errortext,"time out. \n<P>\n ");
    strcat(mid->errortext,"The time out parameter can be adjusted \n");
    strcat(mid->errortext,"in your forms using 'timeout=#', \n");
    strcat(mid->errortext,"where # is the number of \n");
    strcat(mid->errortext,"seconds you want to wait for the database \n");
    strcat(mid->errortext,"server to respond. \n<P>\n");
    strcat(mid->errortext,"The current value is ");
    strcat(mid->errortext,dictLookup("timeout"));
    strcat(mid->errortext,".<P>\n ");
    mid->error=MTIMEOUT;
}

void hardTimeout(int nr) {
    setTimeoutError();
    htmlError(mid->errortext);
}

void softTimeout(int nr) {
    setTimeoutError();
    // let others detect the timeout
}

#define SET_HARD_TIMEOUT	signal(SIGHUP,hardTimeout)
#define SET_SOFT_TIMEOUT	signal(SIGHUP,softTimeout)

void *timeoutThread(void *input) {
    pid_t *ppid=(pid_t *)input;
    sleep(atoi(dictLookup("timeout")));
    kill(*ppid,SIGHUP);
    return 0;
}

@+ HTML Errors
This function is pretty related to the GDKError and allows for an arbitrary
number of arguments in printf format. The message and the parameter dictionary
are showed and the process terminates.
It is of primary use of the application developer. For application systems
it is more effective to designate an automatically loaded html file.
This is recognized from a setting of @%urlerror@ .
@C

void htmlError(char *format,...) {
    va_list ap;
    char *msg;

    if ( (msg = dictLookup("urlerror")) != NULL ) {
		fprintf(html,"Location: %s\n", msg);
		htmlSeparator();
		fprintf(html,"<h3>Error discovered and forwarded\n</h3>");
		htmlFooter();
		return;
    }

    htmlSeparator();
    fprintf(html,"<H3>Error</H3><P>\n");
    va_start (ap,format);
    vfprintf(stdout, format, ap);
    va_end(ap);

//    htmlDictionary();              // for debugging only
    htmlFooter();
    exit(1);
}


void htmlComment(char *format,...) {
    va_list ap;
    fprintf(html,"\n<!--\n");
    va_start (ap,format);
    vfprintf(stdout, format, ap);
    va_end(ap);
    fprintf(html,"\n-->\n");
}


void htmlBeginTable() {
    fprintf(html,"<TABLE BORDER=1>\n");
}


void htmlEndTable() {
    fprintf(html,"</TABLE>\n");
}


@- Predefined names 
The names understood by Mcgi are enumerate here together with their
default values. The get marked up when recognized. Defaults are used
when a value of that variable is requested and the variable is a) not
set at all or b) an empty string.
@C

struct DefaultValue {
    char name[128],value[128];
};

DefaultValue defaultValues[] =
{{"database","demo"},
 {"server","vlieland.cwi.nl"},   
 {"port","50080"},
 {"user","mk"},
 {"password",""},
 {"tabulate","on"},
 {"echo","off"},
 {"rowlimit","64"},
 {"timeout","10"},
 {"urlbase",""},
/* {"urlerror","McgiError.html"}, */
 {'\0','\0'}};


int keywordTest(char *name) {
    for (int i=0;defaultValues[i].name[0];i++)
        if (!strcmp(defaultValues[i].name,name)) return i+1;
    return 0;
}


char *dictLookup(char *name) {
    char *value=0;
    
    for (int i=0;i<dictSize;i++)
        if (!strcmp(dict[i].name,name)) value=dict[i].value;

    if (value && value[0]) return value;

    int def=keywordTest(name);
/*    fprintf(html,"returning default %s\n",defaultValues[def-1].value); */
    
    return def ? defaultValues[def-1].value : 0;
}


@+ Processing the Input
The input is taken from stdin as {\em one} single string. The length of 
this string is given in the environment variable {\tt CONTENT_LENGTH}.
After copying the string we count the number of parameters in the
string by the {\tt =} signs. Given this information, constructing the
parameter dictionary is just to set up pointers to the begin of every
parameter substring and replace '=' and '&' by binary zero to terminate
the string.

@C


void getInput() {
    int length=atoi(getenv("CONTENT_LENGTH"));

    inputLine=new char[length+2];
/*
    FILE *fp=fopen("/ufs/flw/Clipboard/input","r");
    fscanf(fp,"%s",inputLine);    
    */
    fscanf(stdin,"%s",inputLine);
    strcat(inputLine,"&");

/*
    FILE *dump=fopen("/tmp/input","w");
    fprintf(dump,inputLine);
    fclose(dump);
    */
    
    dictSize=0;
    char *ptr=inputLine;

    while(*ptr) if (*ptr++=='=') dictSize++;
    dict=new dictEntry[dictSize];

    ptr=inputLine;
    for (int i=0;i<dictSize;i++)
        {
            dict[i].name=ptr;
            while(*ptr++!='='); *(ptr-1)=0;
            convertString(dict[i].name);

            dict[i].value=ptr;
            while(*ptr++!='&'); *(ptr-1)=0;
            convertString(dict[i].value);

            dict[i].markup=keywordTest(dict[i].name);
//            printf("%s = %s %d \n",dict[i].name,dict[i].value,dict[i].markup);
        }
}

@+ Processing the Query
The main loop in volves traversing the dictionary table and to consider
all non-predefined variable settings as a simple assignment request
to Monet.
The default format is to tabulate tuples as much as possible.
Furthermore, to guard against bogus scripts, the maximum number
of tuples per table is limited by @%rowlimit@ .
This limit is hard, overflow leads to termination of the Mcgi
call and disconnecting from the database server.

Maybe nobody ever noticed that "database" is not used at all when connecting
to the respective server?
@C

void processQuery() {
    SET_HARD_TIMEOUT;
    mid=Mnewstruct(0);
    mid=Mconnect(dictLookup("server"),
                  atoi(dictLookup("port")),
                  dictLookup("user"),
                  dictLookup("password"));
    SET_SOFT_TIMEOUT;
    
    if( mid==0) htmlError("Connection failed\n");

    for (int i=0;i<dictSize;i++)
        {
            if( Merror(mid)) htmlError(mid->errortext);
            
            if (dict[i].markup || !strlen(dict[i].value)) 
                continue; // that's just a keyword or an empty line
            
            char *query=new char[strlen(dict[i].name)+
                                strlen(dict[i].value)+14];
            sprintf(query,"%s:=%s;\n",dict[i].name,dict[i].value);

            SET_HARD_TIMEOUT;
            int err=Mdorequest(mid, query);
            SET_SOFT_TIMEOUT;
            
            if (!err) prettyPrint();
            
            delete[] query; 
        }
    
    if( Merror(mid)) htmlError("%s\n", mid->errortext);
    
    SET_HARD_TIMEOUT;
    Mdisconnect(mid); 
    SET_SOFT_TIMEOUT;
}


int tabulate(char *row) {
    char *ptr=row;
    if (*ptr!='[') return 0; // switch off tabulate!

    ptr++;
    
    fprintf(html,"<TR>\n");

    enum { inString, inNumeric, inSpace };
    int state=inSpace;

    while(*ptr)
        {
            switch(state)
                {
                case inString:
                    if (*ptr=='"') 
                        {
                            state=inSpace;
                            fprintf(html,"&nbsp;</TD>");
                        }
                    break;
                case inNumeric:
                    if (*ptr==' ' || *ptr==',') 
                        {
                            state=inSpace;
                            fprintf(html,"&nbsp;</TD>\n");
                        }
                    break;
                case inSpace:
                    if (*ptr==']') break;
                    if (*ptr>'0') state=inNumeric;
                    if (*ptr=='"'){
			 state=inString; 
			 ptr++;
			 fprintf(html,"<TD>&nbsp;");
			 continue;
		    }

                    if (state!=inSpace) fprintf(html,"<TD>&nbsp"); 
                }
            if (state==inString || state==inNumeric) 
                fprintf(html,"%c",*ptr);
            ptr++;
        }

    fprintf(html,"\n</TR>\n");
    
    return 1;
}


void prettyPrint() {
    int resultRows=0;

    int rowLimit=atoi(dictLookup("rowlimit"));
    int tbl=(strcmp(dictLookup("tabulate"),"on")==0);
    if (tbl) htmlBeginTable();

    while(!Merror(mid) && Mgetreply(mid))
        if (resultRows++<rowLimit) 
            {
                if (tbl) tbl=tabulate(mid->reply);
                if (!tbl) fprintf(html,"%s<BR>\n",mid->reply);  // no(!) else
            }
    
    if (tbl) htmlEndTable();
    if (resultRows >= rowLimit)
        {
            setRowlimitError();
            htmlError(mid->errortext);
        }
}


@+ The Control
The Mcgi script should be time bounded to assure that we do not
clutter the http server.
@C

int main(int argc, char **argv) {
    htmlHeader("text/html");


    getInput();

    int echo=(strcmp(dictLookup("echo"),"on")==0);
    if (echo) htmlDictionary();

    SET_HARD_TIMEOUT;

    pid_t ppid=getpid();
    pthread_t kpid;
    pthread_create(&kpid,0,timeoutThread,&ppid);

    rusage ruBefore,ruAfter;

    getrusage(RUSAGE_SELF,&ruBefore);
    processQuery();
    getrusage(RUSAGE_SELF,&ruAfter);

    htmlComment("%.3fu  %.3fs",
                UTIME_DIFF(ruBefore,ruAfter), 
                STIME_DIFF(ruBefore,ruAfter));

    kill(SIGKILL,(int)kpid);

    htmlFooter();

    return 0;
}

@+ The Interface

@w
<HTML>
<HEAD>
<TITLE>Sample Monet Transaction Form </TITLE>
</HEAD>
<BODY BGCOLOR="#ffffff">
<p>
A simple interaction with a running Monet server can be
requested by filling this form.

<form METHOD=POST ACTION="/htbin/mk/Mcgi">
<table border=0>
<tr>
<td> Database </td> <td> <input type=text name="database" value="db2"> </td>
</tr><tr>
<td> Server </td> <td> <input type=text name="server" value="veerboot"> </td>
</tr><tr>
<td> Port </td> <td> <input type=text name="port" value="50090"> </td>
</tr><tr>
<td> User </td> <td> <input type=text name="user" value="flw"> </td>
</tr><tr>
<td> Password </td> <td> <input type=password name="password"> </td>
</tr>
<tr><td> Rows </td> <td> <input type=text name="rowlimit" value="3"> </td>
</tr>
<!-- <tr><td> Tabulate </td> <td> <input type=text name="tabulate" value="on"> </td>
</tr> -->
<TR>
<TD> Mil1 stmt </TD> <TD> 
<INPUT type=text name="mil1"  size=40 value='environment.print'></TD>
</TR>
<TR>
<TD> Mil2 stmt </TD> <TD> 
<INPUT type=text name="mil2"  size=40 value='clients'></TD>
</TR>
<TR>
<TD> Mil3 stmt </TD> <TD> 
<INPUT type=text name="mil3"  size=40 value='printf("and here is some non-table output\nline1\nline2\nline3\nline4\n")'></TD>
</TR>
<td></td> <td> <input type=submit value="Execute"> </td>
</table>
</form>

</BODY>
</HTML>

@+ The library example
In this section we provide the skeleton of a simple library database
using the form system to enter items and look them up using pattern (?)
match.
@- The database schema
The database schema is a straight forward list of BAT declarations.
This script should be run once in the life of the database.
@' @f bibschema
@' @w
@' 
@' @- Input entry form
@' @f bibupdate
@' @w
@' 
@' @- Search entry form
@' 
@' @f bibsearch
@' @w
