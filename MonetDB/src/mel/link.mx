@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at 
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@' 
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@' 
@' The Original Code is the Monet Database System.
@' 
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2002 CWI.  
@' All Rights Reserved.
@' 
@' Contributor(s):
@' 		Martin Kersten <Martin.Kersten@cwi.nl>
@' 		Peter Boncz <Peter.Boncz@cwi.nl>
@' 		Niels Nes <Niels.Nes@cwi.nl>
@' 		Stefan Manegold  <Stefan.Manegold@cwi.nl>

@f link
@a Niels Nes

@h
#ifndef _LINK_H_
#define _LINK_H_

#include "language.h"
#include "list.h"
#include <string.h>

#include <config.h>
#ifndef DIR_SEP
#ifdef NATIVE_WIN32
#define DIR_SEP '\\'
#else
#define DIR_SEP '/'
#endif
#endif

class Link: public language {
    private:
	List *monet_mod_path;
    public:
	Link(){ libsfx = strdup(""); }
	const char *get_name() const{ return "Link"; }
	virtual int handle_args( int , char **);
	int generate_code( ostream &o, Symbol *root );

	ostream &gen_module( ostream &o, const Module &m );
	ostream &gen_dependency( ostream &o, const Dependency &m );
    public:
	char *libsfx;
};

#endif //_LINK_H_

@C
#include "link.h"
#include "ListIterator.h"
#include <string.h>
#include <stdlib.h>

int Link::handle_args( int argc, char **argv ){
	int i = 0;
	while ( i < argc ){
	   	if (argv[i][0] != '-'){
			cerr << "Unknown option " << argv[i] << "\n";
			return 0;
		}
		switch(argv[i][1]){
		case 's':
			  if (argv[i][2] == '\0'){
			     i++;
			     libsfx = strdup(argv[i]); 
			  } else {
			     libsfx = strdup(argv[i]+2); 
			  }
			  break;
		default:
			cerr << "Unknown option " << argv[i] << "\n";
			return 0;
		}
		i++;
	}
	return 1;
}

int Link::generate_code( ostream &o, Symbol *root ){
	root->print( this, o );
	return 0;
}


ostream &Link::gen_module( ostream &o, const Module &d ){ 
	char *p, *q ,*mod_path = getenv("MONET_MOD_PATH");
	monet_mod_path = new List(10);
	if (mod_path){
		mod_path = strdup(mod_path);
		q = mod_path; 
		while( (p=strchr( q, ':' )) != NULL ){
			*p = '\0';
			monet_mod_path->insert(strdup(q));
			q = p + 1; 
		}
		monet_mod_path->insert(strdup(q));
		delete(mod_path);
	}
	gen_list( o, d.Deps() );
	return o; 
}

static char *basename( char *filename ){
	char *p = strdup(strrchr( filename, DIR_SEP )+1);
	char *q = strrchr( p, '.' );
	if (q)
		*q  = '\0';
	return p;
}

static int matchlen( char *dir, char *file ){
	char *ds, *fs, *d, *f;
	int maxlen = 0;
	int len;

	for( ds = dir; *ds; ds++) {
		if (*ds != DIR_SEP) continue;
		for( fs = file; *fs; fs++) {
			if (*fs != DIR_SEP) continue;

			len = 0;
			for(d = ds, f = fs; *d && *f && *d == *f; d++, f++) {
				len++;
			}
	    
			if (len > maxlen) maxlen = len;
		}
	}

	return maxlen;
}

ostream &Link::gen_dependency( ostream &o, const Dependency &d ){
 	d.Module()->print( this, o );
	char *bn = basename(d.filename());
	if (monet_mod_path){
		char *ldir = NULL;
		int  ldirlen = 0;
		ListIterator *li = monet_mod_path->iterator();
		char *dir;
		while(li->next((void**)&dir)){
			int mlen = matchlen(dir, d.filename());
			if (mlen >= ldirlen){
				ldirlen = mlen;
				if (ldir)
					delete(ldir);
				ldir = strdup(dir);
			}
		}
		o << ldir << "/lib_" << bn << "." << libsfx << " ";
	} else {
	  o << "lib_" << bn << "." << libsfx << " ";
	}
	delete(bn);
	return o; 
}
