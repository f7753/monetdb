@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@' 
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@' 
@' The Original Code is the Monet Database System.
@' 
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2003 CWI.
@' All Rights Reserved.
@' 
@' Contributor(s):
@' 		Martin Kersten <Martin.Kersten@cwi.nl>
@' 		Peter Boncz <Peter.Boncz@cwi.nl>
@' 		Niels Nes <Niels.Nes@cwi.nl>
@' 		Stefan Manegold  <Stefan.Manegold@cwi.nl>

@f mapi
@a N.J. Nes P. Boncz
@t Monets Simple Internet Interface
@v 1.1

This module contains a simple interface for internet connections.

@m
.MODULE mapi;
	.USE streams;

	.BUILTIN mapi_listen(int port, int maxusers, str cmd) = MAPIlisten; 
		"Start the Mapi listener on <port> for <maxusers>.\n For a new client connection MIL procedure <cmd>(Stream s_in, Stream s_out) is called.\nIf no <cmd> is specified a new client thread is forked."

	.BUILTIN mapi_listen_ssl(int port, int maxusers, str keyfile, str certfile, str cmd) = MAPIlistenSSL;
		"Start the Mapi listener on <port> for <maxusers> using SSL.\n<keyfile> and <certfile> give the path names for files with the server key and certificates in PEM format.\nFor a new client connection MIL procedure <cmd>(Stream s_in, Stream s_out) is called.\nIf no <cmd> is specified a new client thread is forked."

	.COMMAND stream_until(Stream S,str stop) : str = stream_read_until;
		"read a string from <S> until the <stop> word"

	.COMMAND socket_close( int s ) = socket_close_wrap;
		"close a socket"

	.COMMAND socket_dup( int s ) : int = socket_dup_wrap;
		"duplicate a socket"

	.PRELUDE = mapi_prelude;
	.EPILOGUE = mapi_epilogue;

.END mapi;

@mil
	VAR mapi_params := bat(int,str);
	mapi_params.rename("mapi_params");

	PROC listen(int port, int maxusers, str cmd) := {
		mapi_params.insert(port,cmd);
		mapi_listen(port,maxusers,cmd);
	}
	ADDHELP("listen", "windhouw", "June  22 2001",
		"Start the Mapi listener on <port> for <maxusers>.\nFor a new client connection MIL procedure <cmd>(int sock) is called.\nIf no <cmd> is specified a new client thread is forked.",
		mod);

	PROC listen(int port, int maxusers) := listen(port,maxusers,"");
	ADDHELP("listen", "windhouw", "June  22 2001",
		"Start the Mapi listener on <port> for <maxusers>.",
		mod);

	PROC listen(int port, str cmd) := listen(port,5,cmd);
	ADDHELP("listen", "windhouw", "June  22 2001",
		"Start the Mapi listener on <port>.\nFor a new client connection MIL procedure <cmd>(int sock) is called.",
		mod);

	PROC listen(int port) := listen(port,5,"");
	ADDHELP("listen", "windhouw", "June  22 2001",
		"Start the Mapi listener on <port>.",
		mod);

	PROC listen(str cmd) := listen(50000,5,cmd);
	ADDHELP("listen", "windhouw", "June  22 2001",
		"Start the Mapi listener on 50000.\nFor a new client connection MIL procedure <cmd>(int sock) is called.",
		mod);

	PROC listen() := listen(50000,5,"");
	ADDHELP("listen", "windhouw", "June  22 2001",
		"Start the Mapi listener on 50000.",
		mod);

	PROC stream_strip(Stream s,str stop) : str := {
		VAR res := stream_until(s,stop);
		VAR pos := r_search(res,stop);
		IF (pos != -1) {
			res := string(res,0,pos);
		}
		RETURN res;
	}
	ADDHELP("stream_strip", "windhouw", "June  22 2001",
		"Read a string from <S> until the <stop> word.\nThe <stop> word is stripped from the result string.",
		mod);

	PROC mapi_stream_read(Stream s) : str := RETURN stream_strip(s,(""+chr(1)));
	ADDHELP("mapi_stream_read", "windhouw", "June  22 2001",
		"Read a string from <S> until a '\1' character.",
		mod);

	PROC stream_line(Stream s) : str := RETURN stream_strip(s,sprintf("%c",chr(10)));
	ADDHELP("stream_line", "windhouw", "June  22 2001",
		"Read a string from <S> until a newline.",
		mod);
@h
#ifndef MAPI_H
#define MAPI_H

#include <streams.h>
#include <monet_context.h>
#include <mapi.proto.h>

#define NEW_ARRAY( type, size )	(type*)GDKmalloc((size)*sizeof(type))
#define STREQ(a, b) 		(strcmp(a, b)==0)

#define MAPIPORT		50000
#define MAPISSLPORT		40000
#define MAPIMAXUSERS 		5

#endif /* MAPI_H */
@c
#include <monet.h>
#include "mapi.h"
#include  <sys/types.h> 
#ifdef HAVE_SYS_SOCKET_H
# include <sys/socket.h>
#endif
#ifdef HAVE_WINSOCK_H
# include <winsock.h>
#endif
#include "kernel.h"

#ifdef AIX
#define SOCKPTR struct sockaddr *
#define SOCKLEN size_t
#else
#ifdef __sgi
#define SOCKPTR void *
#define SOCKLEN int
#else
#define SOCKPTR struct sockaddr *
#if HAVE_SOCKLEN_T
#define SOCKLEN socklen_t
#else
#define SOCKLEN int
#endif
#endif
#endif

#ifdef NATIVE_WIN32
#define s_close closesocket
#else
#define s_close close
#endif

#ifdef HAVE_OPENSSL
#include <openssl/ssl.h>
#include <openssl/err.h>
#endif

@= builtin_operand
{       int _k = interpret(stk, arg(lt, @1), res);
        if (_k < 0) {
                return _k;
        }
        @3 = VALconvert(@2, res);
        if (((ptr) @3 == ILLEGALVALUE)  || (@2 == TYPE_bat && !@3)) {
                return handle_paramerror(res,@1,res->vtype,@2);
        }
}
@c

int MAPIlisten(Cntxt stk, YYSTREE lt, ValPtr res)
{
	struct sockaddr_in server;
	int 	sock;
	SOCKLEN 	length = 0;
	int    	on = 1;
	int 	msgsock;
	int	i = 0;

	int port, *Port;
	int maxusers, *Maxusers;
	char *cmd, *Cmd;
	Client father;

        CNTXTclient(stk, &father);
	if (lt->cnt != 3) {
		return handle_argerror(res,lt->cnt,3);
	}
	@:builtin_operand(0,TYPE_int,Port)@
	port = *Port;
	@:builtin_operand(1,TYPE_int,Maxusers)@
	maxusers = *Maxusers;
	@:builtin_operand(2,TYPE_str,Cmd)@
	cmd = GDKstrdup(Cmd);
	res->vtype = TYPE_void;

	port = (port?port:MAPIPORT);
	maxusers = (maxusers?maxusers:MAPIMAXUSERS);

	sock = socket(AF_INET, SOCK_STREAM, 0);
	if (sock < 0) {
		GDKsyserror("MAPIlisten:creation of stream socket failed\n");
		return GDK_FAIL;
	}
@-
Set server port and allow internet connections from any workstation.
Bind the socket to the server port.
The port id should be obtained from the Homes file.
@c
	server.sin_family = AF_INET;
	server.sin_addr.s_addr = INADDR_ANY;
	server.sin_port = htons((unsigned short)((port)&0xFFFF));
   	for (i=0;i<8;i++)
	    server.sin_zero[i]=0;
 
	setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, (char*) &on, sizeof on);

	length = (SOCKLEN) sizeof(server);
	if (bind(sock, (SOCKPTR)&server, length) < 0) {
		GDKsyserror("MAPIlisten:binding to stream socket (%d) failed\n", port);
		return GDK_FAIL;
	}
@-
Get the new information for the server socket and start listening.
@c
	if (getsockname(sock, (SOCKPTR)&server, &length) < 0) {
		GDKsyserror("MAPIlisten:getting socket name\n");
		return GDK_FAIL;
	}
	listen(sock, maxusers); 

	PARDEBUG {
		THRprintf(GDKerr, "MAPIlisten:Internet started at %d\n", port);
	}
	do {
		int retval;
    		struct timeval tv;
    		fd_set fds;

    		FD_ZERO(&fds);
    		FD_SET(sock, &fds);
    		/* Wait up to 0.5 seconds. */
    		tv.tv_sec = 0;
    		tv.tv_usec = 500;

    		retval = select(sock+1, &fds, &fds, &fds, &tv);
		if (retval == 0) {
			/* nothing interesting has happened */
			continue;
		}
		if (retval < 0) {
			GDKsyserror("MAPIlisten:select failed\n");
			return GDK_FAIL;
		}
    		if ((msgsock = accept(sock, (SOCKPTR) 0, (SOCKLEN *) 0)) < 0) {
			if (MT_geterrno() != EINTR) {
				GDKsyserror("MAPIlisten:accept failed\n");
				return GDK_FAIL;
	    		}
			continue;
		}
		if (STREQ(cmd,"")) {
			int i=0, mpl;
			char *name = (char*) GDKmalloc(BLOCK), *user = name,*s;
			char *mp, *nmp;
			int blocked=0;
			stream *fdin = socket_rastream(msgsock, "mapi-r");
			stream *fdout= NULL;
			Client c;

			assert(name);
			memset(name,0,BLOCK);
			if (fdin == 0 || stream_errnr(fdin) ){
				GDKsyserror("CLIENTlisten:fdin problems\n");
				continue;
			}
			/* get user name */
			stream_read(fdin, user, 1, 1);
			for(i=0; i<BLOCK && *user != '\n'; i++){
				user++;
				stream_read(fdin, user, 1, 1);
			}
			*user=0;
                        /* printf("mapi:Client accepted %s\n", name);*/
                        fflush(stdout);
                        s= strrchr(name,':');
                        blocked= s && strncmp(s,":blocked",8)==0;
                        if( blocked){
                                /* printf("mapi:use blocked mode\n");*/
                                fflush(stdout);
                                *s=0;
				stream_destroy(fdin); /* don't close */
                                fdin= block_stream(socket_rstream(msgsock,"Mserver mapi read"));
                                fdout= block_stream(socket_wstream(msgsock,"Mserver mapi write"));
                        }else
                                fdout= socket_wastream(msgsock,"Mserver mapi write");

			if (fdout == 0){
				GDKsyserror("CLIENTlisten:fdout problems\n");
				continue;
			}
			*user = 0;
			mp = GDKgetenv("monet_prompt");
			mpl = strlen(mp);
			nmp = GDKmalloc(mpl +4);
			nmp[0] = '\1';
			strncpy(nmp+1,mp,mpl);
			nmp[mpl+1] = '\1';
			nmp[mpl+2] = '\n';
			nmp[mpl+3] = '\0';
			c = initClient(name, nmp, FALSE);
			GDKfree(nmp);
			if (c == 0) {
				stream_printf(fdout, "CLIENTlisten:Failed to init client for user %s\n", name );
				GDKfree(name);

				stream_close(fdout);
				stream_destroy(fdout);
				stream_close(fdin);
				stream_destroy(fdin);
				s_close(msgsock);
				continue;
			}
			GDKfree(name);
			c->login = time(0);
			c->listing = 0;
			c->socket = msgsock;
			c->fdin = fdin;
			c->fdout = fdout;
			c->mode = BLOCKMODE;
			CNTXTcopy(stk,c);
			TBL_initclient(c, father);
			(void)monetFork();
			scheduleClient(c);
			PARDEBUG THRprintf(GDKerr, 
				"CLIENTlisten:client accepted %d\n", 
					msgsock);
		} else {
			ValRecord res;
			char buf[BUFSIZ];
			stream *sin, *sout;

			sin = socket_rastream(msgsock, "mapi-r");
			sout = socket_wastream(msgsock, "mapi-w");
			snprintf(buf, BUFSIZ, "%s(Stream(\"" PTRFMT "\"), Stream(\"" PTRFMT "\"));\n", cmd, sin, sout );
			res.vtype = TYPE_void; 
			interpret_str( stk, buf, &res);
		}
	} while (monet_running);
	return GDK_SUCCEED;
}

#ifdef HAVE_OPENSSL
static char *
ssl_error(const char *name, int err, int ret)
{
	char *errstr, *s;
	char buf[120];
	unsigned long e;

	switch (err) {
	case SSL_ERROR_ZERO_RETURN:
		errstr = "TLS/SSL connection has been closed";
		break;
	case SSL_ERROR_WANT_READ:
		errstr = "The operation did not complete (read)";
		break;
	case SSL_ERROR_WANT_WRITE:
		errstr = "The operation did not complete (write)";
		break;
	case SSL_ERROR_WANT_X509_LOOKUP:
		errstr = "The operation did not complete (X509 lookup)";
		break;
	case SSL_ERROR_WANT_CONNECT:
		errstr = "The operation did not complete (connect)";
		break;
	case SSL_ERROR_SYSCALL:
		e = ERR_get_error();
		if (e == 0) {
			if (ret == 0) {
				errstr = "EOF occurred in violation of protocol";
			} else if (ret == -1) {
				/* the underlying BIO reported an I/O error */
				errstr = "I/O error";
			} else {  /* possible? */
				errstr = "Some I/O error occurred";
			}
		} else {
			errstr = ERR_error_string(e, buf);
		}
		break;
	case SSL_ERROR_SSL:
		e = ERR_get_error();
		if (e != 0) 
			errstr = ERR_error_string(e, buf);
		else { /* possible? */
			errstr = "A failure in the SSL library occurred";
		}
		break;
	default:
		errstr = "Invalid error code";
	}
	s = GDKmalloc(strlen(errstr) + strlen(name) + 4);
	sprintf(s, "%s: %s\n", name, errstr); /* we allocated enough, so it fits */
	return s;
}

static MT_Lock *mutex_buf;

static void
locking_function(int mode, int n, const char *file, int line)
{
	(void) file;
	(void) line;
	if (mode & CRYPTO_LOCK)
		MT_set_lock(mutex_buf[n], "locking_function");
	else
		MT_unset_lock(mutex_buf[n], "locking_function");
}

static unsigned long
id_function(void)
{
	return (unsigned long) MT_getpid();
}
#endif	/* HAVE_OPENSSL */

bat *mapi_prelude(void)
{
#ifdef HAVE_OPENSSL
	int i, nlocks;

	nlocks = CRYPTO_num_locks();
	mutex_buf = GDKmalloc(nlocks * sizeof(*mutex_buf));
	if (mutex_buf == NULL) {
		GDKsyserror("mapi_prelude: failed to allocate %d mutexes\n", nlocks);
		return NULL;
	}
	for (i = 0; i < nlocks; i++)
		mutex_buf[i] = MT_create_lock();
	CRYPTO_set_locking_callback(locking_function);
	CRYPTO_set_id_callback(id_function);
#endif
	return NULL;
}

void mapi_epilogue(void)
{
#ifdef HAVE_OPENSSL
	if (mutex_buf) {
		int i, nlocks;

		nlocks = CRYPTO_num_locks();
		CRYPTO_set_id_callback(NULL);
		CRYPTO_set_locking_callback(NULL);
		for (i = 0; i < nlocks; i++)
			MT_destroy_lock(mutex_buf[i]);
		GDKfree(mutex_buf);
		mutex_buf = NULL;
	}
#endif	/* HAVE_OPENSSL */
}

int MAPIlistenSSL(Cntxt stk, YYSTREE lt, ValPtr res)
{
#ifdef HAVE_OPENSSL
	struct sockaddr_in server;
	int 	sock = -1;
	SOCKLEN 	length = 0;
	int    	on = 1;
	int 	msgsock;
	int	i = 0;

	int port, *Port;
	int maxusers, *Maxusers;
	char *keyfile, *Keyfile;
	char *certfile, *Certfile;
	char *cmd, *Cmd;
	Client father;
	SSL_CTX *ctx = NULL;
	SSL *ssl = NULL;

        CNTXTclient(stk, &father);
	if (lt->cnt != 5) {
		return handle_argerror(res,lt->cnt,5);
	}
	@:builtin_operand(0,TYPE_int,Port)@;
	port = *Port;
	@:builtin_operand(1,TYPE_int,Maxusers)@;
	maxusers = *Maxusers;
	@:builtin_operand(2,TYPE_str,Keyfile)@;
	keyfile = GDKstrdup(Keyfile);
	@:builtin_operand(3,TYPE_str,Certfile)@;
	certfile = GDKstrdup(Certfile);
	@:builtin_operand(4,TYPE_str,Cmd)@;
	cmd = GDKstrdup(Cmd);
	res->vtype = TYPE_void;

	if (!port)
		port = MAPISSLPORT;
	if (!maxusers)
 		maxusers = MAPIMAXUSERS;

	ctx = SSL_CTX_new(SSLv23_method());
	if (ctx == NULL) {
		GDKsyserror("MAPIlistenSSL: creation of SSL context failed\n");
		goto fail;
	}
	if (SSL_CTX_set_cipher_list(ctx, "ALL:!LOW") == 0) {
		GDKsyserror("MAPIlistenSSL: SSL_CTX_set_cipher_list failed\n");
		goto fail;
	}
	if (keyfile && *keyfile && certfile && *certfile) {
		if (SSL_CTX_use_PrivateKey_file(ctx, keyfile, SSL_FILETYPE_PEM) < 1) {
			GDKsyserror("MAPIlistenSSL: SSL_CTX_use_PrivateKey_file %s failed\n", keyfile);
			goto fail;
		}
		if (SSL_CTX_use_certificate_chain_file(ctx, certfile) < 1) {
			GDKsyserror("MAPIlistenSSL: SSL_CTX_use_certificate_chain_file %s failed\n", certfile);
			goto fail;
		}
	}
	if (keyfile)
		GDKfree(keyfile);
	if (certfile)
		GDKfree(certfile);

	SSL_CTX_set_verify(ctx, SSL_VERIFY_NONE, NULL);

	sock = socket(AF_INET, SOCK_STREAM, 0);
	if (sock < 0) {
		GDKsyserror("MAPIlisten:creation of stream socket failed\n");
		goto fail;
	}
@-
Set server port and allow internet connections from any workstation.
Bind the socket to the server port.
The port id should be obtained from the Homes file.
@c
	server.sin_family = AF_INET;
	server.sin_addr.s_addr = INADDR_ANY;
	server.sin_port = htons((unsigned short)((port)&0xFFFF));
   	for (i=0;i<8;i++)
	    server.sin_zero[i]=0;
 
	setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, (char*) &on, sizeof on);

	length = (SOCKLEN) sizeof(server);
	if (bind(sock, (SOCKPTR)&server, length) < 0) {
		GDKsyserror("MAPIlisten:binding to stream socket (%d) failed\n", port);
		goto fail;
	}
@-
Get the new information for the server socket and start listening.
@c
	if (getsockname(sock, (SOCKPTR)&server, &length) < 0) {
		GDKsyserror("MAPIlisten:getting socket name\n");
		goto fail;
	}
	listen(sock, maxusers); 

	PARDEBUG {
		THRprintf(GDKerr, "MAPIlisten:Internet started at %d\n", port);
	}
	do {
		int retval;
    		struct timeval tv;
    		fd_set fds;

    		FD_ZERO(&fds);
    		FD_SET(sock, &fds);
    		/* Wait up to 0.5 seconds. */
    		tv.tv_sec = 0;
    		tv.tv_usec = 500;

    		retval = select(sock+1, &fds, &fds, &fds, &tv);
		if (retval == 0) {
			/* nothing interesting has happened */
			continue;
		}
		if (retval < 0) {
			GDKsyserror("MAPIlisten:select failed\n");
			goto fail;
		}
    		if ((msgsock = accept(sock, (SOCKPTR) 0, (SOCKLEN *) 0)) < 0) {
			if (MT_geterrno() != EINTR) {
				GDKsyserror("MAPIlisten:accept failed\n");
				goto fail;
	    		}
			continue;
		}
		if ((ssl = SSL_new(ctx)) == 0) {
			GDKsyserror("MAPIlistenSSL: SSL_new failed\n");
			goto fail;
		}

		if (!SSL_set_fd(ssl, msgsock)) {
			GDKsyserror("MAPIlistenSSL: SSL_set_fd failed\n");
			goto fail;
		}

		for (;;) {
			int ret, err;
			char *errstr;

			ret = SSL_accept(ssl);
			err = SSL_get_error(ssl, ret);
			switch (err) {
			case SSL_ERROR_WANT_READ:
			case SSL_ERROR_WANT_WRITE:
				/* try again */
				continue;
			case SSL_ERROR_NONE:
				/* successful connect */
				break;
			case SSL_ERROR_WANT_CONNECT:
			case SSL_ERROR_WANT_ACCEPT:
			case SSL_ERROR_WANT_X509_LOOKUP:
			default:
				/* some error occurred */
				errstr = ssl_error("MAPIlistenSSL", err, ret);
				GDKsyserror(errstr);
				GDKfree(errstr);
				SSL_free(ssl);
				close(msgsock);
				goto end_loop;
			}
			break;
		}

		if (STREQ(cmd,"")) {
			int i=0, mpl;
			char *name = (char*) GDKmalloc(BLOCK), *user = name,*s;
			char *mp, *nmp;
			int blocked=0;
			stream *fdin = ssl_rastream(ssl, "mapi-r");
			stream *fdout= NULL;
			Client c;

			assert(name);
			memset(name,0,BLOCK);
			if (fdin == 0 || stream_errnr(fdin) ){
				GDKsyserror("MAPIlistenSSL:fdin problems\n");
				continue;
			}
			/* get user name */
			stream_read(fdin, user, 1, 1);
			for(i=0; i<BLOCK && *user != '\n'; i++){
				user++;
				stream_read(fdin, user, 1, 1);
			}
			*user = 0;
                        /* printf("mapi:Client accepted %s\n", name);*/
                        fflush(stdout);
                        s = strrchr(name,':');
                        blocked = s && strncmp(s,":blocked",8)==0;
                        if (blocked) {
                                /* printf("mapi:use blocked mode\n");*/
                                fflush(stdout);
                                *s=0;
				stream_destroy(fdin); /* don't close */
                                fdin = block_stream(ssl_rstream(ssl, "Mserver mapi read"));
                                fdout = block_stream(ssl_wstream(ssl, "Mserver mapi write"));
                        } else {
                                fdout = ssl_wastream(ssl, "Mserver mapi write");
			}

			if (fdout == 0){
				GDKsyserror("MAPIlistenSSL:fdout problems\n");
				continue;
			}
			*user = 0;
			mp = GDKgetenv("monet_prompt");
			mpl = strlen(mp);
			nmp = GDKmalloc(mpl +4);
			nmp[0] = '\1';
			strncpy(nmp+1,mp,mpl);
			nmp[mpl+1] = '\1';
			nmp[mpl+2] = '\n';
			nmp[mpl+3] = '\0';
			c = initClient(name, nmp, FALSE);
			GDKfree(nmp);
			if (c == 0) {
				stream_printf(fdout, "MAPIlistenSSL:Failed to init client for user %s\n", name );
				GDKfree(name);

				stream_close(fdout);
				stream_destroy(fdout);
				stream_close(fdin);
				stream_destroy(fdin);
				s_close(msgsock);
				continue;
			}
			GDKfree(name);
			c->login = time(0);
			c->listing = 0;
			c->socket = msgsock;
			c->fdin = fdin;
			c->fdout = fdout;
			c->mode = BLOCKMODE;
			CNTXTcopy(stk,c);
			TBL_initclient(c, father);
			(void)monetFork();
			scheduleClient(c);
			PARDEBUG THRprintf(GDKerr, 
				"MAPIlistenSSL:client accepted %d\n", 
					msgsock);
		} else {
			ValRecord res;
			char buf[BUFSIZ];
			stream *sin, *sout;

			sin = ssl_rastream(ssl, "mapi-r");
			sout = ssl_wastream(ssl, "mapi-w");
			snprintf(buf, BUFSIZ, "%s(Stream(\"" PTRFMT "\"), Stream(\"" PTRFMT "\"));\n", cmd, sin, sout );
			THRprintf(GDKerr, "MAPIlistenSSL: %s", buf);
			res.vtype = TYPE_void; 
			interpret_str( stk, buf, &res);
		}
	  end_loop:;
	} while (monet_running);
	SSL_CTX_free(ctx);
	close(sock);
	if (cmd)
		GDKfree(cmd);
	return GDK_SUCCEED;
  fail:;
	if (sock >= 0)
		close(sock);
	if (ctx)
		SSL_CTX_free(ctx);
	if (cmd)
		GDKfree(cmd);
	return GDK_FAIL;
#else
	(void) stk;
	(void) lt;
	(void) res;
	GDKerror("No SSL support\n");
	return GDK_FAIL;
#endif	/* HAVE_OPENSSL */
}

int stream_read_until(str *res, Stream *S , str stop)
{
	stream *s = *(stream**)S;
	int slen = strlen(stop);
	int len = 0;
	char buf[BUFSIZ + 1], *start = buf;

	while (stream_read(s, start, 1, 1) > 0){
		if (((start-buf) >= (slen-1)) 
			&& (strncmp((start-slen+1),stop,slen)==0)) {
/*
				start = start-slen+1;
*/
				start++;
				break;
		}
		start++;
	}

	len = start-buf;
	if (len > 0){
		*res = NEW_ARRAY(char, len+1);

		buf[len] = '\0';
		memcpy(*res, buf, len+1);
	} else {
		*res = GDKstrdup("");
	}
	return GDK_SUCCEED;
}

int socket_close_wrap(int *s)
{
	s_close(*s);
	return GDK_SUCCEED;
}

int socket_dup_wrap(int *res, int *s)
{
#ifdef NATIVE_WIN32
  	HANDLE process = GetCurrentProcess();
  	DuplicateHandle(process, 
	       (HANDLE) *s, process,
	       (HANDLE*) res,
	       0, 
	       TRUE, 
	       DUPLICATE_SAME_ACCESS);
#else
	*res = dup(*s);
#endif
	return GDK_SUCCEED;
}

@mil
proc get_mapi_port() := {
	if (monet_environment.exist("mapi_port")){
		return int(monet_environment.find("mapi_port"));
	}
	ERROR("mapi_port is set\n");
}

proc mapi_server(int port, int nr) := {
        var l := listen(port, nr);
	quit;
}

if (mod = "main"){
	fork(mapi_server(get_mapi_port(),5));
}
