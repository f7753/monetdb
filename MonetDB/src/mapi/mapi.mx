@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@' 
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@' 
@' The Original Code is the Monet Database System.
@' 
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2003 CWI.
@' All Rights Reserved.
@' 
@' Contributor(s):
@' 		Martin Kersten <Martin.Kersten@cwi.nl>
@' 		Peter Boncz <Peter.Boncz@cwi.nl>
@' 		Niels Nes <Niels.Nes@cwi.nl>
@' 		Stefan Manegold  <Stefan.Manegold@cwi.nl>

@f mapi
@a N.J. Nes P. Boncz
@t Monets Simple Internet Interface
@v 1.1

This module contains a simple interface for internet connections.

@m
.MODULE mapi;
	.USE streams;

	.BUILTIN mapi_listen(int port, int maxusers, str cmd) = MAPIlisten; 
		"Start the Mapi listener on <port> for <maxusers>.\n For a new client connection MIL procedure <cmd>(int sock) is called.\nIf no <cmd> is specified a new client thread is forked."

	.COMMAND stream_until(Stream S,str stop) : str = stream_read_until;
		"read a string from <S> until the <stop> word"
.LOAD
	VAR _params := nil;
	IF (view_bbp_name.reverse.exist("mapi_params")){
		_params := bat("mapi_params");
	} ELSE {
		_params := new(int,str);
		_params.rename("mapi_params");
	}
	VAR mapi_params := _params;

	PROC listen(int port, int maxusers, str cmd) := {
		mapi_params.insert(port,cmd);
		mapi_listen(port,maxusers,cmd);
	}
	ADDHELP("listen", "windhouw", "June  22 2001",
		"Start the Mapi listener on <port> for <maxusers>.\nFor a new client connection MIL procedure <cmd>(int sock) is called.\nIf no <cmd> is specified a new client thread is forked.",
		"mapi");

	PROC listen(int port, int maxusers) := listen(port,maxusers,"");
	ADDHELP("listen", "windhouw", "June  22 2001",
		"Start the Mapi listener on <port> for <maxusers>.",
		"mapi");

	PROC listen(int port, str cmd) := listen(port,5,cmd);
	ADDHELP("listen", "windhouw", "June  22 2001",
		"Start the Mapi listener on <port>.\nFor a new client connection MIL procedure <cmd>(int sock) is called.",
		"mapi");

	PROC listen(int port) := listen(port,5,"");
	ADDHELP("listen", "windhouw", "June  22 2001",
		"Start the Mapi listener on <port>.",
		"mapi");

	PROC listen(str cmd) := listen(50000,5,cmd);
	ADDHELP("listen", "windhouw", "June  22 2001",
		"Start the Mapi listener on 50000.\nFor a new client connection MIL procedure <cmd>(int sock) is called.",
		"mapi");

	PROC listen() := listen(50000,5,"");
	ADDHELP("listen", "windhouw", "June  22 2001",
		"Start the Mapi listener on 50000.",
		"mapi");

	PROC stream_strip(Stream s,str stop) : str := {
		VAR res := stream_until(s,stop);
		VAR pos := r_search(res,stop);
		IF (pos != -1) {
			res := string(res,0,pos);
		}
		RETURN res;
	}
	ADDHELP("stream_strip", "windhouw", "June  22 2001",
		"Read a string from <S> until the <stop> word.\nThe <stop> word is stripped from the result string.",
		"mapi");

	PROC stream_read(Stream s) : str := RETURN stream_strip(s,(""+chr(1)));
	ADDHELP("stream_read", "windhouw", "June  22 2001",
		"Read a string from <S> until a '\1' character.",
		"mapi");

	PROC stream_line(Stream s) : str := RETURN stream_strip(s,sprintf("%c",chr(10)));
	ADDHELP("stream_line", "windhouw", "June  22 2001",
		"Read a string from <S> until a newline.",
		"mapi");
.END;

.END mapi;

@h
#ifndef MAPI_H
#define MAPI_H

#include <streams.h>
#include <monet_context.h>
#include <mapi.proto.h>

#define NEW_ARRAY( type, size )	(type*)GDKmalloc((size)*sizeof(type))
#define STREQ(a, b) 		(strcmp(a, b)==0)

#define MAPIPORT		50000
#define MAPIMAXUSERS 		5

#endif /* MAPI_H */
@c
#include <config.h>
#include "mapi.h"
#include <monet.h>
#include  <sys/types.h> 
#ifdef HAVE_SYS_SOCKET_H
# include <sys/socket.h>
#endif
#ifdef HAVE_WINSOCK_H
# include <winsock.h>
#endif

#define SOCKPTR struct sockaddr *

@= builtin_operand
{       int _k = interpret(stk, arg(lt, @1), res);
        if (_k < 0) {
                return _k;
        }
        @3 = VALconvert(@2, res, 0);
        if ((@3 == ILLEGALVALUE)  || (@2 == TYPE_bat && !@3)) {
                return handle_paramerror(res,@1,res->vtype,@2);
        }
}
@c

int MAPIlisten(Cntxt stk, YYSTREE lt, ValPtr res){
	struct sockaddr_in server;
	int 	sock;
#ifdef AIX
	size_t 	length;
#else
	int 	length;
#endif
	int    	on = 1;
	int 	msgsock;
	int	i = 0;

	int port, *Port;
	int maxusers, *Maxusers;
	char *cmd, *Cmd;

	if (lt->cnt != 3) {
		return handle_argerror(res,lt->cnt,3);
	}

	@:builtin_operand(0,TYPE_int,Port)@
	port = *Port;
	@:builtin_operand(1,TYPE_int,Maxusers)@
	maxusers = *Maxusers;
	@:builtin_operand(2,TYPE_str,Cmd)@
	cmd = GDKstrdup(Cmd);

	port = (port?port:MAPIPORT);
	maxusers = (maxusers?maxusers:MAPIMAXUSERS);

	sock = socket(AF_INET, SOCK_STREAM, 0);
	if (sock < 0) {
		GDKsyserror("MAPIlisten:creation of stream socket failed\n");
		return GDK_FAIL;
	}
@-
Set server port and allow internet connections from any workstation.
Bind the socket to the server port.
The port id should be obtained from the Homes file.
@c
	server.sin_family = AF_INET;
	server.sin_addr.s_addr = INADDR_ANY;
	server.sin_port = htons((unsigned short)((port)&0xFFFF));
   	for (i=0;i<8;i++)
	    server.sin_zero[i]=0;
 
	setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, (char*) &on, sizeof on);

	length = sizeof(server);
	if (bind(sock, (SOCKPTR)&server, length) < 0) {
		GDKsyserror("MAPIlisten:binding to stream socket (%d) failed\n", port);
		return GDK_FAIL;
	}
@-
Get the new information for the server socket and start listening.
@c
	if (getsockname(sock, (SOCKPTR)&server, &length) < 0) {
		GDKsyserror("MAPIlisten:getting socket name\n");
		return GDK_FAIL;
	}
	listen(sock, maxusers); 

	PARDEBUG {
		THRprintf(GDKerr, "MAPIlisten:Internet started at %d\n", server.sin_port);
	}
	do {
		int retval;
    		struct timeval tv;
    		fd_set fds;

    		FD_ZERO(&fds);
    		FD_SET(sock, &fds);
    		/* Wait up to five seconds. */
    		tv.tv_sec = 5;
    		tv.tv_usec = 0;

    		retval = select(sock+1, &fds, &fds, &fds, &tv);
    		if (retval &&
#ifdef AIX
       			(msgsock = accept(sock, 0, (size_t)0))
#else
       			(msgsock = accept(sock, 0, (int *)0))
#endif
			< 0) {

			if (MT_geterrno() != EINTR) {
				GDKsyserror("MAPIlisten:accept failed\n");
				return GDK_FAIL;
	    		}
		} else if (retval) {
			if (STREQ(cmd,"")) {
				int i, mpl;
				char *name = (char*) GDKmalloc(BUFSIZ), *user = name;
				char *mp, *nmp;
				stream *fdin = socket_rastream(msgsock, "mapi-r");
				stream *fdout = socket_wastream(msgsock, "mapi-w");
				Client c;
	
				if (fdin == 0){
					GDKsyserror("CLIENTlisten:fdin problems\n");
					continue;
				}
				if (fdout == 0){
					GDKsyserror("CLIENTlisten:fdout problems\n");
					continue;
				}
				/* get user name */
				fdin->read(fdin, user, 1, 1);
				for(i=0; i<BUFSIZ && *user != '\n'; i++){
					user++;
					fdin->read(fdin, user, 1, 1);
				}
				*user = 0;
				mp = GDKgetenv("monet_prompt");
				mpl = strlen(mp);
				nmp = GDKmalloc(mpl +3);
				nmp[0] = '\1';
				strncpy(nmp+1,mp,mpl);
				nmp[mpl+1] = '\1';
				nmp[mpl+2] = '\0';
				c = initClient(GDKstrdup(name), nmp, FALSE);
				if (c == 0) {
					stream_printf(fdout, "CLIENTlisten:Failed to init client for user %s\n", name );
					GDKfree(name);
					fdout->flush(fdout);

					fdout->close(fdout);
					fdout->destroy(fdout);
					fdout->close(fdin);
					fdout->destroy(fdin);
					close(msgsock);
					continue;
				}
				GDKfree(name);
				c->login = time(0);
				c->listing = 0;
				c->socket = msgsock;
				c->fdin = fdin;
				c->fdout = fdout;
@
changed setbuf to setbuffer to avoid unintentional buffer overflow.
	                       	setbuffer(c->fdout, c->output, 4096);
@c
				c->mode = BLOCKMODE;
				monet_cntxt[c->stk].outer = CNTXTcopy(stk);
				TBL_initclient(c);
				(void)monetFork();
				scheduleClient(c);
				PARDEBUG THRprintf(GDKerr, 
					"CLIENTlisten:client accepted %d\n", 
						msgsock);
			} else {
				char buf[BUFSIZ];
	
				snprintf( buf, BUFSIZ, "%s(%d);\n", cmd, msgsock );
				interpret_str( stk, buf, res);
			}
		}
	} while (monet_running);
	return GDK_SUCCEED;
}

int stream_read_until(str *res, Stream *S , str stop){
	stream *s = *(stream**)S;
	int slen = strlen(stop);
	int len = 0;
	char buf[BUFSIZ + 1], *start = buf;

	while (s->read(s, start, 1, 1) > 0){
		if (((start-buf) >= (slen-1)) 
			&& (strncmp((start-slen+1),stop,slen)==0)) {
/*
				start = start-slen+1;
*/
				start++;
				break;
		}
		start++;
	}

	len = start-buf;
	if (len > 0){
		*res = NEW_ARRAY(char, len+1);

		buf[len] = '\0';
		memcpy(*res, buf, len+1);
	} else {
		*res = GDKstrdup("");
	}
	return GDK_SUCCEED;
}

@mil
module(str,mapi);

proc get_mapi_port() := {
	if (monet_environment.exist("mapi_port")){
		return int(monet_environment.find("mapi_port"));
	}
	ERROR("mapi_port is set\n");
}

proc mapi_server(int port, int nr) := {
        var l := listen(port, nr);
        printf("!ERROR: listen(%d,%d) failed ... exiting\n", port, nr);
	quit;
}
fork(mapi_server(get_mapi_port(),5));
