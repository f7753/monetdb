@f mapi
@a N.J. Nes P. Boncz
@t Monets Simple Internet Interface
@v 1.1

This module contains a simple interface for internet connections.

@m
.MODULE mapi;

.COMMAND listen()  = MAPIlisten_default;
	"start a Mapi server with the default port number."
.COMMAND listen(int port, int maxusers) = MAPIlisten; 
	"start a Mapi server."

.END mapi;

@h
#ifndef MAPI_H
#define MAPI_H

#define MAPIPORT	50000
#define MAPIMAXUSERS 	5
#include <mapi.proto.h>

#endif /* MAPI_H */
@c
#include "mapi.h"
#include <monet.h>
#include  <sys/types.h> 
#include  <sys/socket.h> 

#define SOCKPTR struct sockaddr *

int MAPIlisten(int *port, int *maxusers){
	struct sockaddr_in server;
	int 	sock;
#ifdef AIX
	size_t 	length;
#else
	int 	length;
#endif
	int    	on = 1;
	int 	msgsock;
	int	i = 0;

	sock = socket(AF_INET, SOCK_STREAM, 0);
	if (sock < 0) {
		GDKsyserror("creation of stream socket failed\n");
		return GDK_FAIL;
	}
@-
Set server port and allow internet connections from any workstation.
Bind the socket to the server port.
The port id should be obtained from the Homes file.
@c
	if (*port == 0)
		*port = MAPIPORT;
	server.sin_family = AF_INET;
	server.sin_addr.s_addr = INADDR_ANY;
	server.sin_port = htons((unsigned short)((*port)&0xFFFF));
   	for (i=0;i<8;i++)
	    server.sin_zero[i]=0;
 
	setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, (char*) &on, sizeof on);

	length = sizeof(server);
	if (bind(sock, (SOCKPTR)&server, length) < 0) {
		GDKsyserror("binding to stream socket (%s) failed\n", *port);
		return GDK_FAIL;
	}
@-
Get the new information for the server socket and start listening.
@c
	if (getsockname(sock, (SOCKPTR)&server, &length) < 0) {
		GDKsyserror("getting socket name\n");
		return GDK_FAIL;
	}
	listen(sock, *maxusers); 

	PARDEBUG {
		THRprintf(GDKerr, "Internet started at %d\n", server.sin_port);
	}
	do {
#ifdef AIX
       		msgsock = accept(sock, 0, (size_t)0);
#else
       		msgsock = accept(sock, 0, (int *)0);
#endif

		if (msgsock == -1) {
			if (MT_geterrno() != EINTR) {
				GDKsyserror("monetServer: accept failed\n");
	    		}
		} else if (msgsock > 0) {
			char *name = (char*) alloca(1024), *user = name;
			FILE *fdin = fdopen(msgsock, "r");
			FILE *fdout = fdopen(msgsock, "w");
			Client c;

			if (fdin == 0){
				GDKsyserror("monetServer: fdin problems\n");
				continue;
			}
			if (fdout == 0){
				GDKsyserror("monetServer: fdout problems\n");
				continue;
			}
			/* get user name */
			while((*user = fgetc(fdin)) != '\n' && *user) user++;
			*user = 0;
			c = initClient(GDKstrdup(name), GDKstrdup(monet_prompt), TRUE);
			if (c == 0) {
				fprintf(fdout, "Failed to init client\n");
				(void) fclose(fdin);
				(void) fclose(fdout);
				close(msgsock);
				continue;
			}
        		c->login = time(0);
			c->listing = 0;
			c->socket = msgsock;
			c->fdin = fdin;
			c->fdout = fdout;
@-
changed setbuf to setbuffer to avoid unintentional buffer overflow.
@c
                        setbuffer(c->fdout, c->output, 4096);
			c->mode = BLOCKMODE;
			TBL_initclient(c);
			scheduleClient(c);
			PARDEBUG THRprintf(GDKerr, "client accepted %d %d\n", 
					fileno(c->fdin), fileno(c->fdout));
		}
	} while (1);
	return GDK_SUCCEED;
}

int MAPIlisten_default(){
	int port = MAPIPORT;
	int maxusers = MAPIMAXUSERS;
	return MAPIlisten(&port, &maxusers);
}


@mil
module(unix,str,mapi);

proc get_monet_port() := {
	var monet_port := getenv("MONETPORT");
	var port := 0;
	var p := search( monet_port, ":" );
	if (p >= 0){
		port := int(string(monet_port, p+1));
	}
	return port;
}
listen(get_monet_port(),5);
