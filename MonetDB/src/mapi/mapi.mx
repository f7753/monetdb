@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@' 
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@' 
@' The Original Code is the Monet Database System.
@' 
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2003 CWI.
@' All Rights Reserved.
@' 
@' Contributor(s):
@' 		Martin Kersten <Martin.Kersten@cwi.nl>
@' 		Peter Boncz <Peter.Boncz@cwi.nl>
@' 		Niels Nes <Niels.Nes@cwi.nl>
@' 		Stefan Manegold  <Stefan.Manegold@cwi.nl>

@f mapi
@a N.J. Nes P. Boncz
@t Monets Simple Internet Interface
@v 1.1

This module contains a simple interface for internet connections.

@m
.MODULE mapi;
	.USE streams;

	.BUILTIN mapi_listen(int port, int maxusers, str cmd) = MAPIlisten; 
		"Start the Mapi listener on <port> for <maxusers>.\n For a new client connection MIL procedure <cmd>(int sock) is called.\nIf no <cmd> is specified a new client thread is forked."

	.COMMAND stream_until(Stream S,str stop) : str = stream_read_until;
		"read a string from <S> until the <stop> word"

	.COMMAND socket_close( int s ) = socket_close_wrap;
		"close a socket"

	.COMMAND socket_dup( int s ) : int = socket_dup_wrap;
		"duplicate a socket"

.END mapi;

@mil
	VAR mapi_params := bat(int,str);
	mapi_params.rename("mapi_params");

	PROC listen(int port, int maxusers, str cmd) := {
		mapi_params.insert(port,cmd);
		mapi_listen(port,maxusers,cmd);
	}
	ADDHELP("listen", "windhouw", "June  22 2001",
		"Start the Mapi listener on <port> for <maxusers>.\nFor a new client connection MIL procedure <cmd>(int sock) is called.\nIf no <cmd> is specified a new client thread is forked.",
		mod);

	PROC listen(int port, int maxusers) := listen(port,maxusers,"");
	ADDHELP("listen", "windhouw", "June  22 2001",
		"Start the Mapi listener on <port> for <maxusers>.",
		mod);

	PROC listen(int port, str cmd) := listen(port,5,cmd);
	ADDHELP("listen", "windhouw", "June  22 2001",
		"Start the Mapi listener on <port>.\nFor a new client connection MIL procedure <cmd>(int sock) is called.",
		mod);

	PROC listen(int port) := listen(port,5,"");
	ADDHELP("listen", "windhouw", "June  22 2001",
		"Start the Mapi listener on <port>.",
		mod);

	PROC listen(str cmd) := listen(50000,5,cmd);
	ADDHELP("listen", "windhouw", "June  22 2001",
		"Start the Mapi listener on 50000.\nFor a new client connection MIL procedure <cmd>(int sock) is called.",
		mod);

	PROC listen() := listen(50000,5,"");
	ADDHELP("listen", "windhouw", "June  22 2001",
		"Start the Mapi listener on 50000.",
		mod);

	PROC stream_strip(Stream s,str stop) : str := {
		VAR res := stream_until(s,stop);
		VAR pos := r_search(res,stop);
		IF (pos != -1) {
			res := string(res,0,pos);
		}
		RETURN res;
	}
	ADDHELP("stream_strip", "windhouw", "June  22 2001",
		"Read a string from <S> until the <stop> word.\nThe <stop> word is stripped from the result string.",
		mod);

	PROC mapi_stream_read(Stream s) : str := RETURN stream_strip(s,(""+chr(1)));
	ADDHELP("mapi_stream_read", "windhouw", "June  22 2001",
		"Read a string from <S> until a '\1' character.",
		mod);

	PROC stream_line(Stream s) : str := RETURN stream_strip(s,sprintf("%c",chr(10)));
	ADDHELP("stream_line", "windhouw", "June  22 2001",
		"Read a string from <S> until a newline.",
		mod);
@h
#ifndef MAPI_H
#define MAPI_H

#include <streams.h>
#include <monet_context.h>
#include <mapi.proto.h>

#define NEW_ARRAY( type, size )	(type*)GDKmalloc((size)*sizeof(type))
#define STREQ(a, b) 		(strcmp(a, b)==0)

#define MAPIPORT		50000
#define MAPIMAXUSERS 		5

#endif /* MAPI_H */
@c
#include <config.h>
#include "mapi.h"
#include <monet.h>
#include  <sys/types.h> 
#ifdef HAVE_SYS_SOCKET_H
# include <sys/socket.h>
#endif
#ifdef HAVE_WINSOCK_H
# include <winsock.h>
#endif
#include "kernel.h"

#ifdef AIX
#define SOCKPTR struct sockaddr *
#define SOCKLEN size_t
#else
#ifdef __sgi
#define SOCKPTR void *
#define SOCKLEN int
#else
#define SOCKPTR struct sockaddr *
#if HAVE_SOCKLEN_T
#define SOCKLEN socklen_t
#else
#define SOCKLEN int
#endif
#endif
#endif

@= builtin_operand
{       int _k = interpret(stk, arg(lt, @1), res);
        if (_k < 0) {
                return _k;
        }
        @3 = VALconvert(@2, res, 0);
        if (((ptr) @3 == ILLEGALVALUE)  || (@2 == TYPE_bat && !@3)) {
                return handle_paramerror(res,@1,res->vtype,@2);
        }
}
@c

int MAPIlisten(Cntxt stk, YYSTREE lt, ValPtr res){
	struct sockaddr_in server;
	int 	sock;
	SOCKLEN 	length = 0;
	int    	on = 1;
	int 	msgsock;
	int	i = 0;

	int port, *Port;
	int maxusers, *Maxusers;
	char *cmd, *Cmd;
	Client father;

        CNTXTclient(stk, &father);
	if (lt->cnt != 3) {
		return handle_argerror(res,lt->cnt,3);
	}

	@:builtin_operand(0,TYPE_int,Port)@
	port = *Port;
	@:builtin_operand(1,TYPE_int,Maxusers)@
	maxusers = *Maxusers;
	@:builtin_operand(2,TYPE_str,Cmd)@
	cmd = GDKstrdup(Cmd);

	port = (port?port:MAPIPORT);
	maxusers = (maxusers?maxusers:MAPIMAXUSERS);

	sock = socket(AF_INET, SOCK_STREAM, 0);
	if (sock < 0) {
		GDKsyserror("MAPIlisten:creation of stream socket failed\n");
		return GDK_FAIL;
	}
@-
Set server port and allow internet connections from any workstation.
Bind the socket to the server port.
The port id should be obtained from the Homes file.
@c
	server.sin_family = AF_INET;
	server.sin_addr.s_addr = INADDR_ANY;
	server.sin_port = htons((unsigned short)((port)&0xFFFF));
   	for (i=0;i<8;i++)
	    server.sin_zero[i]=0;
 
	setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, (char*) &on, sizeof on);

	length = (SOCKLEN) sizeof(server);
	if (bind(sock, (SOCKPTR)&server, length) < 0) {
		GDKsyserror("MAPIlisten:binding to stream socket (%d) failed\n", port);
		return GDK_FAIL;
	}
@-
Get the new information for the server socket and start listening.
@c
	if (getsockname(sock, (SOCKPTR)&server, &length) < 0) {
		GDKsyserror("MAPIlisten:getting socket name\n");
		return GDK_FAIL;
	}
	listen(sock, maxusers); 

	PARDEBUG {
		THRprintf(GDKerr, "MAPIlisten:Internet started at %d\n", port);
	}
	do {
		int retval;
    		struct timeval tv;
    		fd_set fds;

    		FD_ZERO(&fds);
    		FD_SET(sock, &fds);
    		/* Wait up to 0.5 seconds. */
    		tv.tv_sec = 0;
    		tv.tv_usec = 500;

    		retval = select(sock+1, &fds, &fds, &fds, &tv);
		length = 0;
    		if (retval && (msgsock = accept(sock, 0, &length)) < 0) {
			if (MT_geterrno() != EINTR) {
				GDKsyserror("MAPIlisten:accept failed\n");
				return GDK_FAIL;
	    		}
		} else if (retval) {
			if (STREQ(cmd,"")) {
				int i, mpl;
				char *name = (char*) GDKmalloc(BUFSIZ), *user = name;
				char *mp, *nmp;
				stream *fdin = socket_rastream(msgsock, "mapi-r");
				stream *fdout = socket_wastream(msgsock, "mapi-w");
				Client c;
	
				if (fdin == 0){
					GDKsyserror("CLIENTlisten:fdin problems\n");
					continue;
				}
				if (fdout == 0){
					GDKsyserror("CLIENTlisten:fdout problems\n");
					continue;
				}
				/* get user name */
				fdin->read(fdin, user, 1, 1);
				for(i=0; i<BUFSIZ && *user != '\n'; i++){
					user++;
					fdin->read(fdin, user, 1, 1);
				}
				*user = 0;
				mp = GDKgetenv("monet_prompt");
				mpl = strlen(mp);
				nmp = GDKmalloc(mpl +3);
				nmp[0] = '\1';
				strncpy(nmp+1,mp,mpl);
				nmp[mpl+1] = '\1';
				nmp[mpl+2] = '\0';
				c = initClient(name, nmp, FALSE);
				GDKfree(nmp);
				if (c == 0) {
					stream_printf(fdout, "CLIENTlisten:Failed to init client for user %s\n", name );
					GDKfree(name);
					fdout->flush(fdout);

					fdout->close(fdout);
					fdout->destroy(fdout);
					fdout->close(fdin);
					fdout->destroy(fdin);
					close(msgsock);
					continue;
				}
				GDKfree(name);
				c->login = time(0);
				c->listing = 0;
				c->socket = msgsock;
				c->fdin = fdin;
				c->fdout = fdout;
				c->mode = BLOCKMODE;
				monet_cntxt[c->stk].outer = CNTXTcopy(stk);
				TBL_initclient(c, father);
				(void)monetFork();
				scheduleClient(c);
				PARDEBUG THRprintf(GDKerr, 
					"CLIENTlisten:client accepted %d\n", 
						msgsock);
			} else {
				ValRecord res;
				int cres = 0;
				char buf[BUFSIZ];
	
				snprintf( buf, BUFSIZ, "%s(%d);\n", cmd, msgsock );
        			res.vtype = TYPE_void; 
				interpret_str( stk, buf, &res);
				if ((cres = close(msgsock)) < 0){
					GDKerror("Error closing socket %d\n", cres );
					return GDK_FAIL;
				}
			}
		}
	} while (monet_running);
	return GDK_SUCCEED;
}

int stream_read_until(str *res, Stream *S , str stop){
	stream *s = *(stream**)S;
	int slen = strlen(stop);
	int len = 0;
	char buf[BUFSIZ + 1], *start = buf;

	while (s->read(s, start, 1, 1) > 0){
		if (((start-buf) >= (slen-1)) 
			&& (strncmp((start-slen+1),stop,slen)==0)) {
/*
				start = start-slen+1;
*/
				start++;
				break;
		}
		start++;
	}

	len = start-buf;
	if (len > 0){
		*res = NEW_ARRAY(char, len+1);

		buf[len] = '\0';
		memcpy(*res, buf, len+1);
	} else {
		*res = GDKstrdup("");
	}
	return GDK_SUCCEED;
}

int socket_close_wrap( int *s ){
	close(*s);
	return GDK_SUCCEED;
}

int socket_dup_wrap( int *res, int *s ){
	*res = dup(*s);
	return GDK_SUCCEED;
}

@mil
proc get_mapi_port() := {
	if (monet_environment.exist("mapi_port")){
		return int(monet_environment.find("mapi_port"));
	}
	ERROR("mapi_port is set\n");
}

proc mapi_server(int port, int nr) := {
        var l := listen(port, nr);
	quit;
}

if (mod = "main"){
	fork(mapi_server(get_mapi_port(),5));
}
