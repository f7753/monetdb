@a M. Kersten and Peter Boncz and Niels Nes
@v 4
@f MapiClient
@* The Mapi Client interface
A textual interface to the Monet server using the Mapi library,
providing command-line MIL access for its users. It is the preferred 
interface for non-DBAs.

@- ChangeLog
Feb 2001 we rewrote the Mclient. It now uses the Mapi library

June 1996 we added a little more functionality. In particular,
it should be possible to connect to a server by providing its
name only. The corresponding port is searched in the homes file
and the .gdk_lock file.

Control directives are '>' to sent output to a file.
Several textual changes made.

@+ Manual Page
@T
The {\tt Mclient} program, provides just as the Mserver console, a
MIL interface to the Monet server. Unlike the concolse, the {\tt Mclient} 
program is intended not only or the database administrator, but to all other 
users. It is more comfortable than the console, since it provides
a command history and automatic file name completion.

\begin{verbatim}
Mclient 
        [--config|-c config] 
        [--debug|-d [level]] 
        [--host|-h hostname] 
        [--port|-p portnr]
        [--noheaders] 
\end{verbatim}

The following options are supported:
\begin{itemize}
\item {\em -c|--config}. Config file to read options from.
\item {\em -d|--debug}. Illustrate internalworking.
\item {\em -h|--host.} The machine to connect to. 
\item {\em -p|--port.} The port to use . 
\item {\em    --noheaders}. Print also comment lines received in the result; default is to ignore them.
\end{itemize}
@

@
@{
@+ Implementation
@c
/*  (Copyright) 1995-1996 M.L. Kersten, CWI, Amsterdam
	Monet textual interface monitor.
*/
#include "Mapi.h"

#include <monet_options.h> 
#include <ctype.h> 
#include <sys/types.h> 
#include <sys/socket.h> 
#include <sys/stat.h>
#include <errno.h> 
#include <string.h> 
#include <signal.h> 

#ifdef HAVE_PWD_H
#include  <pwd.h> 
#endif

extern int errno;                       /* pass errors  */

#define EXIT(x)	{ exit(x); }
#define LINEMODE	23
#define BLOCKMODE	32

FILE	*toConsole;
char 	*message	= 0;
int 	mode		= LINEMODE;
char*	sentinel 	= "Mclient~sentinel"; 
int	is_chrsp	= 0;


int doRequest(Msession mid, char *buf ){
	char *rtrn;
 
	if (Mdorequest(mid, buf) != MOK){
		return (int)'q';
	}
	while(rtrn=Mgetreply(mid)){
		fprintf(toConsole, "%s\n",rtrn);
	}
	if (Merror(mid)) {
		return (int)'q';
	}
	return 0;
}
@-
The input for the Monet server is stored in a buffer until
the forward command is issued.
In LINEMODE each line is sent and the monitor awaits the prompt
of the server before continuing
@c
#define CHUNK_SIZE	1024

#ifdef HAVE_LIBREADLINE
#define SEND_MESSAGE(mid)	{					\
	message[m_index++] = '\n';				\
	message[m_index] = 0;					\
	cmd = doRequest(mid, message );				\
	add_history(start_cmd);					\
        *message = 0; m_index = 0;				\
}
#else
#define SEND_MESSAGE(mid)	{				\
	message[m_index++] = '\n';				\
	message[m_index] = 0;					\
	cmd = doRequest(mid, message );				\
        *message = 0; m_index = 0;				\
}
#endif

#define GROW_MESSAGE(x)	{					\
	m_index += x;						\
       	if (m_size-m_index  < CHUNK_SIZE) {			\
		message = (char *) realloc(message, m_size*=2);	\
		memset(message+m_index, 0, m_size-m_index);	\
	}							\
}

void clientAccept( Msession mid) {
	FILE	*fp;
	char 	*line=0, *start_cmd, *end_cmd;
	int	n, m_size=CHUNK_SIZE, m_index=0;
	char	cmd = 0, ch;

	message = (char *) malloc(CHUNK_SIZE);

	while(cmd != 'q') {
		if (line) {
			free(line);
		}
#ifdef HAVE_LIBREADLINE
		if (is_chrsp){
	        	if ((line = (char *) readline(mid->prompt)) == NULL) {
	               		return;
			}
		} else 
#endif
		{
		   	char *buf =(char *)malloc(CHUNK_SIZE);
	        	if ((line =(char *)fgets(buf,CHUNK_SIZE,stdin))==NULL) {
			   	free(buf);
	                	return;
			}
		}
		/* find start and end of the command */
		for(	start_cmd = line;
			*start_cmd && isspace(*start_cmd);
			start_cmd++);
		if (!*start_cmd) {
			continue;
		}
		for(	end_cmd = line + strlen(line) - 1; 
			isspace(*end_cmd);
			end_cmd--);
		n = 1 + end_cmd - start_cmd;
@-
The Mclient terminal monitor provides common functionality,
such as directory changes, reading commands from a file, 
redirection of output to a separate file.
@c
		/* is the string a command ? */
		switch(*start_cmd) {
		case '\\':
		        switch(*(start_cmd+1)) {
		        case 'r': 
				SEND_MESSAGE(mid);
		                continue;
			case 'q':
				cmd = 'q';
				continue;
			case 'b':
				mode = BLOCKMODE;
				continue;
			case 'l':
				mode = LINEMODE;
				/*FALLTHRU*/
		        case 'c':
				m_index = 0; *message = 0;
				continue;
			}
			break;
		case '!':
			system(start_cmd+1);
			continue;
		case 'c':
			if ((start_cmd[1] == 'd') && isspace(start_cmd[2])) {
			    if (chdir(start_cmd+3)) {
                                char err[200];
                                sprintf(err, "chdir: %s", start_cmd+3);
                                perror(err);
			    } else {
				fprintf(toConsole,"chdir to %s\n", start_cmd+3);
			    }
			    message[0] = m_index = 0;
			    continue;
			}
			break;
		case '<':
			if (fp = fopen(start_cmd+1, "r")) {
				while (n = fread(message+m_index, 1,
							 CHUNK_SIZE, fp))
				{
					GROW_MESSAGE(n);
					/* echo to stdout */
					message[m_index] = 0;
					fwrite(message+m_index-n, 1, n, stdout); 
				}
			}
			break;
@-
The output should be saved in a different file.
Ommision of a file name or failure to create it, resets
the output to the stdout. (Also >>)
@c
		case '>':
			if( n==1) {
				toConsole = stdout;
				fprintf(toConsole,"Redirect to standard output\n");
				continue;
			}
			if( strcmp(start_cmd+1,"stdout") == 0) {
				toConsole = stdout;
				continue;
			}
			if( strcmp(start_cmd+1,"stderr") == 0) {
				toConsole = stderr;
				continue;
			}
			toConsole = fopen(start_cmd+1,"w");
			if( toConsole == NULL ){
				toConsole = stdout;
				fprintf(toConsole,
				"! Unable to redirect to %s\n", start_cmd+1);
			} else
				printf("output switched to %s\n",start_cmd+1);
			continue;
@-
The commands available in the terminal monitor can be obtained
using its help operator '?'.
@c
		case '?':
			fprintf(toConsole,"?\t - this message\n");
			fprintf(toConsole,"!\t - shell escape\n");
			fprintf(toConsole,"<file\t - read input from file\n");
			fprintf(toConsole,">file\t - save response in file\n");
			fprintf(toConsole,">\t - response to terminal\n");
			fprintf(toConsole,"cd\t - change directory \n");
			fprintf(toConsole,"\\r\t- run the buffered command \n");
			fprintf(toConsole,"\\c\t- clear the command buffer\n");
			fprintf(toConsole,"\\l\t- line is immediately sent \n");
			fprintf(toConsole,"\\q\t- terminate session \n");
			continue;
		} 
		/* copy the line to the end of the message */
		memcpy(message+m_index, start_cmd, n);
		GROW_MESSAGE(n);
		
		if (mode == LINEMODE) {
			SEND_MESSAGE(mid);
	        }
        } 
}

void usage(char *prog) {
	fprintf(stderr, "usage: %s\n", prog);
	fprintf(stderr, "[-c or --config config_file ]\n" );
	fprintf(stderr, "[-h or --host hostname ]\n" );
	fprintf(stderr, "[-p or --port portnr ]\n" );
 	fprintf(stderr, "[-d or --debug [debug_level] ]\n" );
 	fprintf(stderr, "[      --noheaders ]\n" );
 	fprintf(stderr, "[-? or --help ]\n");
 	EXIT(1);
}

int main(int ac, char **av) {
	char 	buf[BUFSIZ], *prog = *av, *config = NULL;
	opt 	*set = NULL;
	int     port = 0, debug = 0, setlen = 0;

	struct passwd *pwd = getpwuid(getuid());
	struct stat st;
	char 	user[80];
        Msession mid;

        static struct option long_options[] =
             {
               {"config", 1, 0, 'c'},
               {"debug", 2, 0, 'd'},
               {"host", 1, 0, 'h'},
               {"port", 1, 0, 'p'},
               {"help", 0, 0, '?'},
               {"noheaders", 0, 0, 0},
               {0, 0, 0, 0}
             };

	toConsole = stdout;
	fstat(fileno(stdin),&st);

	if (S_ISCHR(st.st_mode))
	   is_chrsp = 1;
	else
	   is_chrsp = 0;

        strcpy(user, pwd?pwd->pw_name:"guest");
 
	if (!(setlen = mo_builtin_settings(&set)) )
                usage(prog);

	while(1){
		int option_index = 0;

                int c = getopt_long( ac, av, "c:dh:p:?",
                                long_options, &option_index);

		if (c == -1)
			break;

		switch (c){
		case 0:
			if (strcmp(long_options[option_index].name, 
						"noheaders") == 0){
				setlen = mo_add_option( &set, setlen, 
					opt_cmdline, "mapi_noheaders", "yes" );
				break;
			}
			usage(prog);
			break;
		case 'c':
			config = strdup(optarg);
			break;
		case 'd':
			debug=1;
			if (optarg){ 
				setlen = mo_add_option( &set, setlen, 
					opt_cmdline, "mapi_debug", optarg );
			} else {
				setlen = mo_add_option( &set, setlen, 
					opt_cmdline, "mapi_debug", "1" );
			}
			break;
		case 'h':
			setlen = mo_add_option( &set, setlen, 
					opt_cmdline, "host", optarg );
			break;
		case 'p':
			setlen = mo_add_option( &set, setlen, 
					opt_cmdline, "mapi_port", optarg );
			break;
		case '?':
			usage(prog);
		default:
			fprintf( stderr, 
			    "ERROR: getopt returned character code 0%o ??\n",c);
			usage(prog);
		}
	}

	if (config){
		setlen = mo_config_file(&set, setlen, config);
		free(config);
	} else {
		if (!(setlen = mo_system_config(&set, setlen)) )
			usage(prog);
	}

	port = strtol(mo_find_option(set, setlen, "mapi_port"), NULL, 10);
	mid = Mconnect(mo_find_option(set, setlen, "host"), port, user, NULL);
	mid->everything = 1;
	if ( strcasecmp(
		mo_find_option(set, setlen, "mapi_noheaders"), "yes")==0)
		mid->everything = 0;

	if (Merror(mid)) {
		Mexplain(mid,toConsole);
		EXIT(2);
	}
 
	clientAccept(mid);

	FAKE_ALLOCA_CALL; /* buggy Intel C/C++ compiler for Linux; see gdk.h (gdk.mx) for details */
	return 0;
}
