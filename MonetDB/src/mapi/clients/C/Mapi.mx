@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2003 CWI.
@' All Rights Reserved.
@'
@' Contributor(s):
@'              Martin Kersten <Martin.Kersten@cwi.nl>
@'              Niels Nes <Niels.Nes@cwi.nl>
@'              Stefan Manegold <Stefan.Manegold@cwi.nl>
@'              Peter Boncz <Peter.Boncz@cwi.nl>
@f Mapi
@a M.L. Kersten
@v 2.0
@d August 2003
@* The Monet Application Programming Interface

The easiest way to extend the functionality of Monet is to construct
an independent Monet application, which communicates with a
running server using a database driver with a simple API and a textual protocol.
The effectiveness of such an approach has been demonstrated by the wide
use of database API implementations, such as Perl DBI, PHP ADO, ODBC,...

The database driver implementation given in this document is
focused on developing applications in C/C++. The command collection
have been chosen to align with common practice, i.e. queries follow
a prepare,execute,and fetch_row paradigm. The output is considered
a regular table. An example of a mini
application below illustrates the main operations.
@T
\begin{verbatim}
#include <monet_utils.h>
#include <stream.h>
#include <Mapi.h>
#include <stdio.h>

#define die(X) {mapi_explain(X,stdout); exit(-1); }

main(int argc, char *argv)
{
	Mapi	*dbh;

	dbh = mapi_connect("localhost:50001", "guest", 0, "sql");
	if (mapi_error(dbh))
		die(dbh);

	if (mapi_query(dbh, "create table emp(name varchar, age int)"))
		die(dbh);

	if (mapi_query(dbh, "insert into emp values(\"John\", 23)"))
		die(dbh);

	if (mapi_query(dbh, "insert into emp values(\"Mary\", 22)"))
		die(dbh);

	if (mapi_query("select * from emp"))
		die(stmt);

	while (mapi_fetch_row(dbh)) {
		char *nme = mapi_fetch_field(dbh, 0);
		char *age = mapi_fetch_field(dbh, 1);
		printf("%s is %s\n", nme, age);
	}

	mapi_disconnect(dbh);
}
\end{verbatim}

The mapi_connect() operation establishes a communication channel
with a running server on the local machine. The user identification
is the ubiquitous anonymous guest, for whom we do not require a password.
The query language interface is "sql". Alternatives are the lower
level languages "mil" and "mal". Future versions are expected to
recognize also "xcore" and "xquery".

Errors on the interaction can be captured using mapi_error(), possibly
followed by a request to dump a short error message explanation on a
standard file location. It has been abstracted away in a macro.

Provided we can establish a connection, the interaction proceeds as
in many similar application development packages. Queries are shipped
for execution using mapi_query() and an answer table can be consumed
one row at a time. In many cases these functions suffice.

The tabular data exchange model is primarily meant to support sql
(mil,mal) For xml and xcore the engine is expected to generate
a XPath-like token stream from which the application can built
the internal representation of the document (e.g. a DOM-tree).

The Mapi interface provides caching of rows at the client side.
mapi_query() will load all tuples into the cache, after which
they can be read repeatedly using mapi_fetch_row()
or directly accessed (mapi_seek_row()). This facility is particularly
handy when small, but stable query results are repeatedly used
in the client program.

To ease communication between application code and the cache
entries, the user can bind the C-variables both for input and
output to the query parameters, and output columns, respectively.
The query parameters are indicated by '?' and may appear anywhere
in the query template.

@+ Caveats
The Mapi library expects complete lines from the server as answers
to query actions. Incomplete lines leads to Mapi waiting
forever on the server. Thus formatted printing is discouraged in favor
of tabular printing as offered by the table.print() commands in
Monet 5.

@+ Compilation
The Mapi application uses include files found in the Monet distribution
directory or at a central location in your machine.
Assuming the location of the distribution is marked in the
environment variable $MONET_PREFIX, the following actions are needed to
get a working program (on Linux and V5).
@T
\begin{verbatim}
cc sample.c  -DHAVE_CONF_H -I$MONET_PREFIX \
        -I$MONET_PREFIX/include/common -I$MONET_PREFIX/include/mapi  \
	-Wl,$MONET_PREFIX/lib/MonetDB/libMapi.so \
	-Wl,$MONET_PREFIX/lib/libstream.so \
	-Wl,--rpath -Wl,$MONET_PREFIX/lib/MonetDB:$MONET_PREFIX/lib \
	-o sample
\end{verbatim}

The location of the libraries in 4.3 are slightly different.
@+ Command summary
The quick reference guide to the Mapi library is given below.
More details on their constraints and defaults is geven in the
next section.
@T
\begin{tabular}{l l}
mapi_bind()	&	Bind string C-variable to field\\
mapi_bind_var()	&	Bind typed C-variable to field\\
mapi_bind_numeric()	& Bind numeric C-variable to field\\
mapi_cache_limit()	& Set the tuple cache limit\\
mapi_connect()	&	Connect to a Mserver \\
mapi_connect_ssl()	& Connect to a Mserver using SSL [TODO]\\
mapi_disconnect()	& Disconnect from server\\
mapi_dup()	&	Duplicate the connection structure\\
mapi_error()	&	Test for error occurrence\\
mapi_explain()	&	Display error message and context on stream\\
mapi_execute()	&	Execute a query\\
mapi_execute_array()	&Execute a query using string arguments\\
mapi_fetch_field()	&Fetch a field from the current row\\
mapi_fetch_field_array()	& Fetch all fields from the current row\\
mapi_fetch_line()	&	Retrieve the next line\\
mapi_fetch_reset()	&	Set the cache reader to the begining\\
mapi_fetch_row()	&	Fetch row of values\\
mapi_fetch_all_rows()	&	Fetch all answers from server into cache\\
mapi_finish()	&	Terminate the current query\\
mapi_get_host()	&	Host name of server\\
mapi_get_language()	& Query language name\\
mapi_get_version()	& Monet version name\\
mapi_get_versionId()	& Monet version identifier\\
mapi_get_user()	&	Current user name\\
mapi_get_field_count()	& Number of fields in current row\\
mapi_get_row_count()	&	Number of rows in cache or -1\\
mapi_ping()	&	Test server for accessibility\\
mapi_prepare()	&	Prepare a query for execution\\
mapi_prepare_array()	&	Prepare a query for execution using arguments\\
mapi_query()	&	Send a query for execution\\
mapi_query_array()	& Send a query for execution with arguments\\
mapi_quick_query()	&	Send a query for execution\\
mapi_quick_query_array()	& Send a query for execution with arguments\\
mapi_quote()	& Escape characters\\
mapi_reconnect()	& Reconnect with a clean session context\\
mapi_rows_affected()	& Obtain number of rows changed\\
mapi_quick_response()	&	Quick pass response to stream\\
mapi_seek_row()	&	Move row reader to specific location in cache\\
mapi_table()	&	Get current table name\\
mapi_timeout()	&	Set timeout for long-running queries[TODO]\\
mapi_trace()	&	Set trace flag\\
mapi_trace_log()	& Keep log of interaction\\
mapi_unquote()	&	remove escaped characters\\
\end{tabluar}
@+ Mapi library
The routines to build a Monet application are grouped in the library
Monet Application Programming Interface, or Mapi.

The protocol information is stored in a Mapi interface descriptor (mid),
which should be passed to the library routines in most cases.
The application can set up several channels with the same or a different
Monet server. It is the programmers responsibility not to mix the
descriptors in retrieving the results.

The application may be multi-threaded as long as the user respects
the individual connections represented by the database handlers.

The interface assumes a cautious user, who understands and has experience
with the Monet programming language model. In particular, syntax errors may easily
lead to synchronization errors. It should also be clear that references
returned by the API point directly into the administrative structures of Mapi.
This means that they are valid only for a short period, mostly between
successive mapi_fetch_row commands.
A defensive programming style is advised.
Upon an error, the routine mapi_explain gives information about the context of
the failed call, including the expression shipped and any response received.
The side-effect is clearing the error status.

@T
\begin{description}

\item[Mapi mapi_connect(char *host, char *username, char *password, char *lang)]:
Setup a connection with a Monet server at a {\em host}:{\em port} and
login with {\em username} and {\em password}. If host == NULL, the
local host with a default port is accessed.
If username == NULL, the username of the
owner of the client application containing the Mapi code is used.
If password == NULL, the password is omitted.
The preferred query language is any of \{sql,mil,mal,xcore,xquery\}\\
The command returns a structure with administration about the interconnect.
It also contains an explanation when connection to the server fails.

\item[Mapi mapi_dup(Mapi mid)]:
Setup a second communication channel using the parameter setting of
the previous on.
\item[int mapi_disconnect(Mapi mid)]:
Terminates the session described by {\em mid}. Subsequent use
of the channel represented by this descriptor leads to a failure.
\item[Mapi mapi_reconnect(Mapi mid)]:
Close the current channel and re-establish a fresh connection. This
will remove all global session variables.

\item[MapiMsg mapi_query(Mapi mid, char *Command)]:
This routine sends the Command to the database server represented by mid.
It is one of the most common operations.
If Command is zero it takes the last query string kept around.
It returns zero upon success, otherwise it indicates a failure of the request.
The command response is buffered for consumption, e.g. mapi_fetch_row();

\item[MapiMsg mapi_query_array(Mapi mid, char *Command, char **argv)]:
This routine sends the Command to the database server replacing
the placeholders by the string arguments presented. The default placeholder
is the question mark (?).

\item[MapiMsg mapi_quick_query(Mapi mid, char *Command, FILE *fd)]:
Similar to mapi_query, except that the response of the server is
not analyzed, but shipped immediately to the file indicated.

\item[MapiMsg mapi_quick_query_array(Mapi mid, char *Command, char **argv, FILE *fd)]:
Similar to mapi_query, except that the response of the server is
not analyzed, but shipped immediately to the file indicated.

\item[int mapi_num_fields(Mapi mid)]:
Return the number of fields in the current row.

\item[int mapi_num_rows(Mapi mid)]:
Return the number of rows in the last select call. [ no guarantee given]
A -1 is returned if this information is not available.

\item[int mapi_rows_affected(Mapi mid)]:
Called after a database update (INSERT/DELETE/REPLACE)
to determine the number of rows affected
by the command.

\item[int mapi_fetch_row(Mapi mid)]:
This routine retrieves a row from the server.
The text retrieved is kept around in a buffer linked with the session
descriptor from which selective fields can be extracted.
It returns the number of fields recognized.
A zero is returned upon encountering end of sequence
or error. This can be analyzed in using mapi_error().

\item[int mapi_fetch_all_rows(Mapi mid)]:
All rows are cached at the client side first. Subsequent calls
to either mapi_fetch_row() will take
the row from the cache. The number or rows cached
is returned.

\item[int mapi_quick_response(Mapi mid, stream s)]:
Read the answer to a query and pass the results verbatim
to a stream. The result is not analyzed, nor cached.

\item[MapiMsg mapi_seek_row(Mapi mid, int rownr)];
Reset the row pointer to the requested row number;
Comments lines are ignored.

\item[MapiMsg mapi_fetch_reset(Mapi mid)];
Reset the row pointer to the first line in the cache.
This need not be a tuple.
This is mostly used in combination with fetching all tuples at once.

\item[char **mapi_fetch_array(Mapi mid)]:
Returns an array of string pointers to the individual fields.
A zero is returned upon encountering end of sequence
or error. This can be analyzed in using mapi_error().

\item[char *mapi_fetch_field(Mapi mid, int fnr)]:
Returns a pointer a C-string representation of the value returned.
A zero is returned upon encountering an error;
This can be analyzed in using mapi_error().

\item[MapiMsg mapi_prepare(Mapi mid, char **Command)];
Move the query to the connection structure. Possibly interact with the
back-end to prepare the query for execution.

\item[int mapi_execute(Mapi mid, char *Command)];
The command is shipped to the backend for execution. A single answer
is pre-fetched to detect any runtime error. A NULL command is
interpreted as taking the previous query. MOK is returned upon success.

\item[int mapi_execute_array(Mapi mid, char **Command, char **argv)];
Similar to mapi_execute but replacing the placeholders for the
string values provided.

\item[MapiMsg mapi_bind(Mapi mid, int fldnr, char **val)];
Bind a string variable with a field in the return table.
Returns an error if the field identified does not exist.

\item[MapiMsg mapi_bind_var(Mapi mid, int fldnr, int type, void *val)];
Describe the type and location of the next parameter in a query template.
The types recognized are {SQL_INT, SQL_LONG, SQL_CHAR, SQL_VARCHAR, SQL_FLOAT,
SQL_DOUBLE, SQL_TIME, SQL_DATE}.
The binding operations should be performed after the mapi_execute command.
Subsequently all rows being fetched also involve delivery of the field
values in the C-variables using proper conversion. For variable length
strings a pointer is set into the cache.

\item[MapiMsg mapi_bind_numeric(Mapi mid, int fldnr, int scale, int precision, void *val)];
Bind to a numeric variable, internally represented by SQL_INT
Describe the location of a numeric parameter in a query template.

\item[MapiMsg mapi_param(Mapi mid, int fldnr, char **val)];
Bind a string variable with the n-th placeholder in the query
template.
No conversion takes place.

\item[MapiMsg mapi_param_type(Mapi mid, int fldnr, int type, void *val)];
Similar to mapi_bind_var(), but now binds a parameter.

\item[MapiMsg mapi_paramnumeric(Mapi mid, int fldnr, int scale, int precision, void *val)];
Bind to a numeric variable, internally represented by SQL_INT

\item[MapiMsg mapi_cache_limit(Mapi mid, int maxrows)]:
A limited number of tuples are pre-fetched after each execute().
If maxrows is negative, all rows will be fetched before the
application is permitted to continue.

\item[MapiMsg mapi_finish(Mapi mid)]:
This routine is used in the rare cases that consumption of the
tuple stream produced should be prematurely terminated. It is automatically
called when a new query is shipped to the database.

\item[char * mapi_quote(char *name)]:
Strings in the database should be surrounded by double quotes and
escape of the characters \n,\t,...

\item[char * mapi_unquote(char *name)]:
The reverse action of mapi_quote(), turning the database representation
into a C-representation. The storage space is dynamically created and
should be freed after use.

\item[MapiMsg  mapi_trace(Mapi mid, int flag)]:
Set the trace flag to monitor interaction with the server.

\item[MapiMsg  mapi_trace_log(Mapi mid, char *fname)]:
The interaction between the client and server is logged for
offline inspection. Beware that the log file overwrites any
previous log. It is not intended for recovery.

\item[MapiMsg mapi_ping(Mapi mid)]:
Test availability of the server. Returns zero upon success.

\end{description}

The remaining operations are wrappers around the data structures
maintained. Note that column properties are derived from the
table output returned from the server.
\begin{description}
\item[ char *mapi_get_name(Mapi mid, int fnr)]:
\item[ char *mapi_get_table(Mapi mid, int fnr)]:
\item[ int mapi_get_type(Mapi mid, int fnr)]:
\item[ int mapi_get_len(Mapi mid, int fnr)]:

\item[ char *mapi_get_host(Mapi mid)]:
\item[ char *mapi_get_user(Mapi mid)]:
\item[ char *mapi_get_lang(Mapi mid)]:
\item[ char *mapi_get_version(Mapi mid)]:
\item[ int mapi_get_versionId(Mapi mid)]:

\item[MapiMsg mapi_error(Mapi mid)]:
Returns the last error code or 0 if there is no error.

\item[char *mapi_error_str(Mapi mid)]:
Returns a pointer to the last error message.

\item[MapiMsg mapi_explain(Mapi mid, FILE *fd)]:
Writes the error message obtained from Monet to a file.

%\item[int mapi_timeout(Mapi mid, int timeout)]:
%Sets the time out time in milli seconds for all subsequent
%Mapi commands. Default value is 0, wait indefinitely.

\item[char **mapi_tables(Mapi mid)]:
Returns a list of accessible database tables.

\item[char **mapi_fields(Mapi mid)]:
Returns a list of accessible tables fields. This can also be obtained
by inspecting the field descriptor returned by mapi_fetch_field.

\end{description}
@

@- Error message
@T
The Mapi interface calls return one of the following codes.\\

\begin{tabular}{l l}
MOK  & No error \\
MERROR  & Mapi internal error.\\
\end{tabular}
@
@{
@+ Implementation
@h
/*#define MONET5*/
#define BLOCKED


#ifdef HAVE_UNISTD_H
# include <unistd.h>
#endif
#include  <stdio.h>
#ifdef HAVE_PWD_H
#include  <pwd.h>
#endif
#include  <sys/types.h>
#include  <stream.h>

#ifdef HAVE_SYS_SOCKET_H
# include <sys/socket.h>
#endif
#ifdef HAVE_WINSOCK_H
# include <winsock.h>
#endif


#include  <signal.h>
#include  <string.h>
#include  <memory.h>

#if TIME_WITH_SYS_TIME
# include <sys/time.h>
# include <time.h>
#else
# if HAVE_SYS_TIME_H
#  include <sys/time.h>
# else
#  include <time.h>
# endif
#endif

#define NAMELEN	256
#define MAPIBLKSIZE 256	/* minimum buffer shipped */

#define SQL_AUTO	0	/* automatic type detection */
#define SQL_INT		1
#define SQL_LONG	2
#define SQL_CHAR	3
#define SQL_VARCHAR	4
#define SQL_FLOAT	5
#define SQL_DOUBLE	6
#define SQL_TIME	7
#define SQL_DATE	8
#define SQL_NUMERIC	9

#define PLACEHOLDER	'?'

typedef int MapiMsg;

#define MOK	0
#define MERROR	-1
#define MTIMEOUT	-2

#define LANG_MAL	0
#define LANG_MIL	1
#define LANG_SQL	2
#define LANG_XCORE	3
#define LANG_XQUERY	4

#define PROMPTBEG		'\001'	/* start prompt bracket */
#ifdef MONET5
#define PROMPTEND		'\002'	/* end prompt bracket */
#else
#define PROMPTEND		'\001'	/* end prompt bracket */
#endif
@-
The table field information is extracted from the table headers
obtained from the server. This list may be extended in the future.
The type of both the 'param' and 'binding'
variables refer to their underlying C-type. They are used for
automatic type coercing between back-end and application.
@h

typedef struct{
	char tablename[NAMELEN];
	char columnname[NAMELEN];
	char columntype[NAMELEN];
	int  colwidth;
	int  coltype;
	int  precision;
	int  scale;
	int  isnull;

	void *inparam;		/* to application variable */
	int  intype;
	void *outparam;
	int  outtype;
} MapiField;

@-
The row cache contains a string representation of each (non-error) line
received from the backend. After a mapi_fetch_row() or mapi_fetch_field()
this string has been indexed from the anchor table, which holds a pointer
to the start of the field. A sliced version is recognized by looking
at the fldcnt table, which tells you the number of fields recognized.
Lines received from the server without 'standard' line headers are
considered a single field.
@h
typedef struct {
	int rowlimit;	/* maximal number of rows to cache */
	int limit;	/* current storage space limit */
	int writer;
	int reader;
	int tuples;	/* actual tuples in cache */
	int  *fldcnt;	/* actual number of fields in each row */
	char **rows;	/* string representation of rows received */
	char ***anchors;/* corresponding field pointers */
} MapiRowBuf;

typedef struct{
	char	*buf;
	int	lim;
	int	nxt;
	int	eos;	/* end of sequence*/
} BlockCache;

typedef struct {
	char server[NAMELEN];	/* server version message */
	char hostname[NAMELEN];
	int  port;
	char username[NAMELEN];
	char password[NAMELEN];
	char language[NAMELEN];
	char database[NAMELEN];
	int languageId;
	int versionId;		/* Monet 4 or 5 */
	char prompt[NAMELEN];

	int everything;		/* keep all lines received */
	int trace;		/* Trace Mapi interaction */
	int error;		/* Error occurred */
	char *errorstr;	/* pointer to constant string */
	char *action;	/* pointer to constant string */

	BlockCache blk;
	int connected;
	int active;		/* set when not all rows have been received */
	char *template;		/* keep parameterized query text around */
	char *query;

	int	fieldcnt;	/* the table report section */
	int	rows_affected;	/* mostly unknown */
	int 	maxfields;
	MapiField *fields;
	MapiRowBuf cache;

	stream *tracelog;		/* keep a log for inspection*/
	stream *from, *to;
} MapiStruct, *Mapi;

@-
All external calls to the library should pass the mapi-check
routine. It assures a working connection and proper reset of
the error status of the Mapi structure.
@h
#define mapi_check(X,C) assert(X);if((X)->connected==0) { \
	mapi_setError((X),"Connection lost",C); \
	return (X)->error; } mapi_clrError(X);
#define mapi_check0(X,C) assert(X);if((X)->connected==0) { \
	mapi_setError((X),"Connection lost",C); \
	return 0; } mapi_clrError(X);

#ifdef __cplusplus
extern "C" {
#endif

#ifdef _MSC_VER
#ifndef LIBMAPI
#define mapi_export extern __declspec(dllimport)
#else
#define mapi_export extern __declspec(dllexport)
#endif
#else
#define mapi_export extern
#endif

mapi_export MapiMsg mapi_bind(Mapi mid, int fnr, char **ptr) ;
mapi_export MapiMsg mapi_bind_var(Mapi mid, int fnr, int type, void *ptr) ;
mapi_export MapiMsg mapi_bind_numeric(Mapi mid, int fnr, int scale,int precision, void *ptr) ;
mapi_export Mapi mapi_connect(char *host, char *username,
	 char *password, char *lang);
mapi_export Mapi mapi_connect_ssl(char *host, char *username,
	char *password, char *lang);
mapi_export MapiMsg mapi_disconnect(Mapi mid);
mapi_export MapiMsg mapi_error(Mapi mid);
mapi_export MapiMsg mapi_finish(Mapi mid);
mapi_export MapiMsg mapi_fetch_reset(Mapi mid);
mapi_export MapiMsg mapi_explain(Mapi mid, FILE *fd);
mapi_export MapiMsg mapi_execute(Mapi mid) ;
mapi_export MapiMsg mapi_execute_array(Mapi mid, char **val) ;
mapi_export MapiMsg mapi_ping(Mapi mid);
mapi_export MapiMsg mapi_prepare(Mapi mid,char *cmd);
mapi_export MapiMsg mapi_prepare_array(Mapi mid,char *cmd,char **val);
mapi_export MapiMsg mapi_query(Mapi mid,char *cmd);
mapi_export MapiMsg mapi_quick_query(Mapi mid, char* cmd, FILE *fd);
mapi_export MapiMsg mapi_query_array(Mapi mid,char *cmd, char **val);
mapi_export MapiMsg mapi_quick_query_array(Mapi mid, char* cmd, char **val, FILE *fd);
mapi_export MapiMsg mapi_cache_limit(Mapi mid,int limit);
mapi_export MapiMsg mapi_quick_response(Mapi mid, FILE *fd);
mapi_export MapiMsg mapi_stat(Mapi mid);
mapi_export MapiMsg mapi_seek_row(Mapi mid, int rowne);
mapi_export MapiMsg mapi_trace(Mapi mid, int flag);
mapi_export MapiMsg mapi_trace_log(Mapi mid, char *nme);

mapi_export int mapi_timeout(Mapi mid, int time);
mapi_export int mapi_fetch_row(Mapi mid);
mapi_export int mapi_fetch_all_rows(Mapi mid);
mapi_export int mapi_get_field_count(Mapi mid);
mapi_export int mapi_get_row_count(Mapi mid);
mapi_export int mapi_rows_affected(Mapi mid);

mapi_export char *mapi_fetch_field(Mapi mid, int fnr);
mapi_export char **mapi_fetch_field_array(Mapi mid);
mapi_export char * mapi_fetch_line(Mapi mid);
mapi_export char *mapi_get_lang(Mapi mid);
mapi_export char *mapi_get_host(Mapi mid);
mapi_export char *mapi_get_user(Mapi mid);
mapi_export char *mapi_get_version(Mapi mid);
mapi_export char *mapi_get_table(Mapi mid,int fnr);
mapi_export char *mapi_get_name(Mapi mid,int fnr);
mapi_export char *mapi_quote(char *msg);
mapi_export char *mapi_unquote(char *msg);

#ifdef __cplusplus
}
#endif

@
@+ Mapi functions.
The Monet application interface commands are described below.
They have been developed to ease interaction.

@c
#include "config.h"
#include   "Mapi.h"

static void promptMonet(Mapi mid);
static void mapi_cache_reset(Mapi mid);
static Mapi mapi_new(void);
static void mapi_check_query(Mapi mid);
static void mapi_extend_cache(Mapi mid);
static int mapi_get_row(Mapi mid) ;
static int mapi_extend_fields(Mapi mid,int minfields);
static int mapi_slice_row(Mapi mid);
static int mapi_setError(Mapi mid, char *msg, char *action);
static char * mapi_fetch_line_internal(Mapi mid);
static MapiMsg mapi_finish_internal(Mapi mid);
static void mapi_lost_connection();

#ifndef HAVE_GETLOGIN
#define getlogin() "win32"
#endif

@+ Channel constructor
The first call of an application is to establish a connection with
an already server. The username and password are sent as part of
the initialization sequence.
Future versions may be allowed to set the username and will also
provide a secure socket layer support.

All routines called from outside the package should reset the
error flag of the Mapi structure. Internal calls are designated as such
if there may occur confusion on the status of the error flag.
@c
void mapi_clrError(Mapi mid)
{
	if(mid->errorstr) free(mid->errorstr);
	mid->action=0;	/* contains references to constants */
	mid->error=0;
	mid->errorstr=0;
}

MapiMsg mapi_trace(Mapi mid, int flag)
{
	mapi_check(mid,"mapi_trace");
	mid->trace = flag;
	return MOK;
}

MapiMsg mapi_trace_log(Mapi mid, char *nme)
{
	mapi_check(mid,"mapi_trace_log");
	mid->tracelog= open_wastream(nme);
	if( mid->tracelog->errnr) {
		mid->tracelog= 0;
		return mapi_setError(mid,"Could not create log file",
				"mapi_trace+log");
	}
	return MOK;
}

MapiMsg mapi_ping(Mapi mid)
{
	mapi_check(mid,"mapi_ping");
	if( mid->languageId == LANG_SQL)
		mapi_query(mid,"select true;");
	if( mid->languageId == LANG_MAL)
		mapi_query(mid,"print(1);");
	if( mid->languageId == LANG_MIL)
		mapi_query(mid,"print(1);");
	return mapi_error(mid);
}

static int mapi_setError(Mapi mid, char *msg, char *action)
{
	char *c;
	assert(msg);
	c= (char*) malloc(strlen(msg)+1);
	strcpy(c,msg);
	if( mid->errorstr)
		free(mid->errorstr);
	mid->error = MERROR;
	mid->errorstr = c;
	mid->action = action;
	return mid->error;
}


static Mapi mapi_new(void)
{
	Mapi m;
	m = (Mapi) malloc(sizeof(MapiStruct));
	assert(m);
	m->template=0;
	m->query= 0;

	m->trace = 0;
	m->everything = 0;
	m->error= MOK;
	m->errorstr= 0;
	strcpy(m->hostname,"localhost");
#ifdef MONET5
	strcpy(m->language,"mal");
	m->languageId= LANG_MAL;
	m->versionId = 5;
#else
	strcpy(m->language,"mil");
	m->languageId= LANG_MIL;
	m->versionId= 4;
#endif
	strcpy(m->username,"anonymous");
	strcpy(m->password,"unknown");
	/* default prompt */
	strcpy(m->prompt,">");

	m->maxfields = 64;
	m->fieldcnt = 0;
	m->fields = (MapiField *) malloc( 64 * sizeof(MapiField));
	memset(m->fields,0, 64 * sizeof(MapiField));
	assert(m->fields);
	m->cache.rowlimit= 100;
	m->cache.limit= 0;
	m->cache.writer= 0;
	m->cache.reader= -1;
	m->cache.tuples= 0;
	m->cache.rows= 0;
	m->cache.anchors= 0;
	m->cache.fldcnt= 0;
	m->tracelog= 0;
	m->active= 0;
	m->blk.eos=0;
	m->blk.buf= (char*) malloc(BLOCK+1);
	m->blk.buf[BLOCK]=0;
	m->blk.buf[0]=0;
	m->blk.nxt=0;
	m->blk.lim=BLOCK;
	return m;
}

Mapi mapi_dup(Mapi mid)
{
	Mapi m;
	mapi_check0(mid,"mapi_dup");
	mid->connected++;	/* connection is shared */
	m= mapi_new();
	m->to= mid->to;
	m->from= mid->from;
	m->tracelog= mid->tracelog;
	strcpy(m->hostname, mid->hostname);
	strcpy(m->username, mid->username);
	strcpy(m->password, mid->password);
	strcpy(m->prompt, mid->prompt);
	m->port= mid->port;
	return m;
}

Mapi mapi_connect_ssl(char *host, char *username, char *password, char *lang)
{
	Mapi mid = mapi_connect(host,username,password,lang);
	mapi_setError(mid,"SSL connections not yet supported","mapi_connect_ssl");
	return mid;
}

Mapi mapi_connect(char *host, char *username, char *password, char *lang)
{
	struct hostent *hp;
	struct sockaddr_in server;
	int s;
	char *c;
	Mapi mid;
	int port=0;
	size_t len, ret;
	char buf[BLOCK];

	mid= mapi_new();


	/* avoid writing into constant strings ! */
	if( host)
		snprintf(mid->hostname,NAMELEN,"%s",host);
	else
		strcpy(mid->hostname,"localhost");
	c= strchr(mid->hostname,':');
	if (c) {
		*c = 0;
		port = atol(c+1);
	}
	if(port==0){
		char *def;
		if((def = getenv("MAPIPORT"))!=NULL)
			port=atoi(def);
	}
	if(port==0) {
#ifdef MONET5
		port = 50001;	/* hardwired default */
#else
		port = 50000;	/* hardwired default */
#endif
	}
	if(username)
		strcpy(mid->username,username);
	if(password==0)
		password= getlogin();
	if(password)
		strcpy(mid->password,password);

	mid->port= port;
	hp = gethostbyname(mid->hostname);
	if(!hp) {
		mapi_setError(mid,"gethostbyname failed","mapi_connect");
		return(mid);
	}
	memset(&server, 0, sizeof(server));
	memcpy(&server.sin_addr, hp->h_addr, hp->h_length);

	server.sin_family = hp->h_addrtype;
	server.sin_port   = htons((unsigned short)(mid->port&0xFFFF));

	s=socket(AF_INET, SOCK_STREAM, 0);
	if(s<0) {
		mapi_setError(mid,"Open socket failed","mapi_connect");
		return(mid);
	}

	if(connect(s,(struct sockaddr *)&server, sizeof(server))<0) {
		perror("!ERROR mapi_connect: ");
		mapi_setError(mid,"Setup connection failed","mapi_connect");
		return(mid);
	}

	mid->to = socket_wastream(s,"Mapi client write");
	if (mid->to->errnr){
		mapi_setError(mid,"Cannot open socket for writing ","mapi_connect");
		return(mid);
	}
	mid->connected=1;

	/* default prompt */
	strcpy(mid -> prompt,">");

	{
	memset(buf,0,BLOCK);
#ifdef BLOCKED
	snprintf(buf, BLOCK,"%s:%s:blocked\n", mid->username, mid->password);
#else
	snprintf(buf, BLOCK,"%s:%s\n", mid->username, mid->password);
#endif
	if(mid->trace){
		printf("sending first request [%d]:%s",BLOCK,buf);
		fflush(stdout);
	}
	len= strlen(buf);
	ret= mid->to->write(mid->to,buf,1,len);
	mid->to->flush(mid->to);
	mid->active++;
	if( ret != len){
		mapi_setError(mid,"Could not send initial byte sequence",
			"mapi_connect");
		return(mid);
	}
#ifdef BLOCKED
	mid->to = block_stream(socket_wstream(s,"Mapi client write"));
#endif
	if( mid->to->errnr){
		mapi_setError(mid,"Cannot open socket for writing ","mapi_connect");
		return(mid);
	}

#ifdef BLOCKED
	mid->from = block_stream(socket_rstream(s,"Mapi client read"));
#else
	mid->from = socket_rastream(s,"Mapi client read");
#endif
	if( mid->from->errnr){
		mapi_setError(mid,"Cannot open socket for reading","mapi_connect");
		return(mid);
	}
	/* consume the welcome message from the server */
	while(mid->error==MOK && mid->active ){
		mapi_get_row(mid);
		if( mapi_error(mid)) {  mapi_explain(mid,stdout); break;}
		if( mid->cache.rows)
		mid->versionId= strcmp("Mserver 5.0",mid->cache.rows[0])==0? 5:4;
	}

	if(mid->trace)
		printf("connection established\n");
	if( lang==0 || strcmp(lang,"mal")==0)
		return mid;

	strcpy(mid->language,lang);
	if(strcmp(lang,"mil")==0 )
		mid->languageId= LANG_MIL;
	if(strcmp(lang,"mal")==0 )
		mid->languageId= LANG_MAL;
	if(strcmp(lang,"sql")==0 )
		mid->languageId= LANG_SQL;
	if(strcmp(lang,"xcore")==0 )
		mid->languageId= LANG_XCORE;
	if(strcmp(lang,"xquery")==0 )
		mid->languageId= LANG_XQUERY;
#ifdef MONET5
	/* start the scenario handler*/
	snprintf(buf,BLOCK,"%s();",lang);
	if( mapi_error(mid))
		return mid;
	if( mid->trace)
		printf("send scenario initializer %s\n", buf);
	mapi_query(mid,buf);
#endif
	return mid;
	}
}
@-
Once the start of the prompt string (\0001) has been recognized, the rest should
be eaten away. It is stored in the prompt buffer for possible subsequent display.
@c
MapiMsg mapi_error(Mapi mid)
{
	assert(mid);
	return mid->error;
}

static void promptMonet(Mapi mid)
{
	ptrdiff_t i=0;
	char *s;

	assert(mid);
	if( mid->trace)
		printf("promptMonet:");
	s= strchr(mid->blk.buf+mid->blk.nxt,'\n');
	assert(s);
	*s = 0;
	i= s-(mid->blk.buf+mid->blk.nxt);
	if( i < NAMELEN-1)
		strncpy(mid->prompt,mid->blk.buf+mid->blk.nxt,i+1);
	mid->blk.nxt += i+1;
	mid->active = 0;
	if( mid->trace)
		printf("%s\n",mid->prompt);
}

@
Disconnection from the server leads to removal of the
Mapi structure. Subsequent access may lead to a crash.
@c
static void mapi_lost_connection(Mapi mid){
	mapi_setError(mid,"Lost connection with server",
		"mapi_fetch_line");
	mid->connected= 0;
	/* finish channels */
	if( mid->to){ (void) mid->to->close(mid->to); mid->to =0;}
	if( mid->from){ (void) mid->from->close(mid->from); mid->from =0;}
}

MapiMsg mapi_disconnect(Mapi mid)
{
	int i;
	mapi_check(mid,"mapi_disconnect");
	for(i=0;i<mid->cache.writer;i++){
		if( mid->cache.rows[i])
			free( mid->cache.rows[i]);
		if( mid->cache.anchors[i])
			free( mid->cache.anchors[i]);
	}
	if(mid->cache.fldcnt)
		(void) free(mid->cache.fldcnt);
	if(mid->cache.anchors)
		(void) free(mid->cache.anchors);
	if(mid->cache.rows)
		(void) free(mid->cache.rows);
	if( mid->connected >1){
		mid->connected=0;
		return mapi_setError(mid,"Warning: multiple connections open",
					"mapi_disconnect");
	}
	(void) mid->from->close(mid->from); mid->from =0;
	(void) mid->to->close(mid->to); mid->to =0;
	return mapi_setError(mid,"Connection closed", "mapi_disconnect");
}
MapiMsg mapi_reconnect(Mapi mid){
	Mapi dup;
	char buf[BLOCK];

	mapi_check(mid,"mapi_reconnect");
	snprintf(buf,BLOCK,"%s:%d",mid->hostname,mid->port);
	dup = mapi_connect(buf, mid->username, mid->password, 
			mid->language);
	if( mid->connected>0) mapi_disconnect(mid);
	memcpy(mid, dup, sizeof(*dup));
	return mid->error;
}
@-
Binding placeholders and column names provide some convenience
for bulk interacting with a server.
@= testField
	mapi_check(mid,@2);
	if( fnr <0 ){
		mapi_setError(mid,"Illegal field number",@2);
		return @1;
	}
	if( fnr >= mid->fieldcnt) mapi_extend_fields(mid,fnr);
@c
MapiMsg mapi_bind(Mapi mid, int fnr, char **ptr) {
	@:testField(mid->error,"mapi_bind")@
	mid->fields[fnr].outparam= ptr;
	mid->fields[fnr].outtype= SQL_AUTO;
	return MOK;
}

MapiMsg mapi_bind_var(Mapi mid, int fnr, int type, void *ptr) {
	@:testField(mid->error,"mapi_bind_var")@
	mid->fields[fnr].outparam= ptr;
	if( type>=0 && type < SQL_NUMERIC)
		mid->fields[fnr].outtype= type;
	else
		return mapi_setError(mid,"Illegal SQL type identifier",
					"mapi_bind_var");
	return MOK;
}
MapiMsg mapi_bind_numeric(Mapi mid, int fnr, int scale,int prec, void *ptr) {
	if( mapi_bind_var(mid,fnr, SQL_NUMERIC,ptr) )
		return mid->error;
	mid->fields[fnr].scale= scale;
	mid->fields[fnr].precision= prec;
	return MOK;
}
@-
The routine mapi_check_query appends the semicolon and new line if needed.
Furthermore, it ensures that no 'false' newlines are sent to the server,
because this may lead to a synchronization error easily.
@= expandQry
	char *new= (char*)malloc(i+3);
	strcpy(new,mid->query);
	new[i+1]=@1;
	new[i+2]=0;
	free(mid->query);
	mid->query= new;
	if( mid->template){
		free(mid->template);
		mid->template= (char*) malloc( i+3);
		assert(mid->template);
		strcpy(mid->template,new);
	}
	i++;
@-
The query string could contain commentary lines, marked as starting
with a '#'. They should be silently removed.
Likewise for all end of line commentaries, provided '#' is not
part of a string literal.
@c
static void mapi_check_query(Mapi mid)
{
	size_t i;
	char *c, bracket=0;

	assert(mid->query);
	i= strlen(mid->query)-1;
	for(c=mid->query;*c; c++){
		if( *c=='\'' || *c=='"') {
			if( bracket== *c ) bracket=0; else bracket= *c;
		}
		if( *c == '#' && bracket==0){
			while(*c && *c!='\n') c++;
		}
		if( *c == '\n'){
			mapi_setError(mid,"Newline in query string not allowed","mapi_check_query");
			*c= ' ';
		}
	}
	/* all SQL statements should end with a semicolon */
	/* for the other languages it is assumed that the statements are correct */
	if(mid->languageId== LANG_SQL && mid->query[i] != ';') {
		@:expandQry(';')@
	}
	if( mid->query[i] != '\n') {
		@:expandQry('\n')@
	}
}

MapiMsg mapi_timeout(Mapi mid, int time)
{
	mapi_check(mid,"mapi_timeout");
	if( mid->trace)
		printf("Set timeout to %d\n", time);
	return mapi_setError(mid,"Operation not yet implemented","mapi_timeout");
}
@-
Watch out. The explanation routine should not clear the error status.
@c
MapiMsg mapi_explain(Mapi mid, FILE *fd)
{
	assert(mid);
	fprintf(fd,"MAPI  = %s\@%s:%d\n",
		mid->username, mid->hostname, mid->port);
	if( mid->action) fprintf(fd,"ACTION= %s\n", mid->action);
	if( mid->query) {
		if( strchr(mid->query,'\n'))
			fprintf(fd,"QUERY = %s", mid->query);
		else	fprintf(fd,"QUERY = %s\n", mid->query);
	}
	if( mid->error)
		fprintf(fd,"ERROR = %s\n",mid->errorstr);
	fflush(fd);
	mapi_clrError(mid);
	return MOK;
}
@-
The routine mapi_query is one of the most heavily used ones.
It sends a complete Monet statement for execution
(i.e., ending in a newline; possibly including additional newlines).
Interaction with the server is sped up using block based interaction.
The query is retained in the Mapi structure to repeat shipping.
@= prepareQuery
	if( cmd==0){
		/* re-use the previous query */
	} else {
		size_t len= strlen(cmd);
		if( mid->template){
			free(mid->template);
			mid->template=0;
		}
		if( mid->query)
			free(mid->query);
		mid->query= (char*) malloc( len+1);
		assert(mid->query);
		strcpy(mid->query,cmd);
		if( strchr(cmd,PLACEHOLDER)){
			mid->template= (char*) malloc( len+1);
			assert(mid->template);
			strcpy(mid->template,cmd);
		}
	}
	mapi_check_query(mid);
	ret= mid->error;
@c
MapiMsg mapi_prepare(Mapi mid, char *cmd)
{
	int ret;
	mapi_check(mid,"mapi_prepare");
	@:prepareQuery@
	return ret;
}

MapiMsg mapi_prepare_array_internal(Mapi mid, char *cmd, char **val)
{
	int i,ret;
	@:prepareQuery@
	/* first get rid of previous bindings */
	for(i=0;i<mid->fieldcnt;i++){
		mid->fields[i].inparam= 0;
		mid->fields[i].intype= SQL_AUTO;
	}
	for(i=0; val[i];i++){
		mid->fields[i].inparam= val[i];
		mid->fields[i].intype= SQL_AUTO;
		if( i+1 >= mid->maxfields) mapi_extend_fields(mid,i);
	}
	return ret;
}
MapiMsg mapi_prepare_array(Mapi mid, char *cmd, char **val)
{
	mapi_check(mid,"mapi_prepare_array");
	return mapi_prepare_array_internal(mid,cmd,val);
}
@-
Building the query string using replacement of values require
some care not overfloating the space allocated.
@= checkSpace
	if( (size=strlen(mid->query))+@1 >= lim){
		char *n= (char*) malloc(lim=size+@1+MAPIBLKSIZE);
		assert(n);
		strcpy(n,mid->query);
		free(mid->query);
		mid->query= n;
	}
@c
char *mapi_param_store(Mapi mid)
{
	char *val, buf[MAPIBLKSIZE];
	char *p=mid->template, *q;
	int i;
	size_t k;
	size_t size = 0, lim;

	if( mid->template==0)
		return NULL;
	if( mid->query)
		free(mid->query);

	lim= strlen(mid->template)+MAPIBLKSIZE;
	mid->query= (char*) malloc(lim);
	assert(mid->query);
	mid->query[0]=0;

	q= strchr(mid->template,PLACEHOLDER);
	i=0;
	while(q){
		if( q>p && *(q-1)=='\\'){
			q= strchr(q+1,PLACEHOLDER);
			continue;
		}

		k= strlen(mid->query);
		strncpy(mid->query+k,
			mid->template + (p - mid->template),
			q-p);
		mid->query[k + (q - p)]=0;

		for(;i<mid->maxfields;i++)
			if( mid->fields[i].inparam)
				break;

		if( i==mid->maxfields || mid->fields[i].inparam==0) {
			mid->query[strlen(mid->query)]=PLACEHOLDER;
		} else
			switch(mid->fields[i].intype) {
			case SQL_INT:
				@:checkSpace(30)@
				sprintf(mid->query+strlen(mid->query),
					"%d",*(int *)mid->fields[i].inparam);
				break;
			case SQL_LONG: 
				@:checkSpace(30)@
				sprintf(mid->query+strlen(mid->query),
					"%ld",*(long *)mid->fields[i].inparam);
				break;
			case SQL_FLOAT:
				@:checkSpace(30)@
				sprintf(mid->query+strlen(mid->query),
					"%.9g",*(float *)mid->fields[i].inparam);
				break;
			case SQL_DOUBLE:
				@:checkSpace(30)@
				sprintf(mid->query+strlen(mid->query),
					"%.17g",*(double *)mid->fields[i].inparam);
				break;
			case SQL_CHAR:
				buf[0] =*(char*)mid->fields[i].inparam;
				buf[1]=0;
				val= mapi_quote(buf);
				@:checkSpace(strlen(val))@
				sprintf(mid->query+strlen(mid->query), "'%s'",val);
				break;
			case SQL_VARCHAR:
				val= mapi_quote((char*)mid->fields[i].inparam);
				@:checkSpace(strlen(val))@
				sprintf(mid->query+strlen(mid->query), "'%s'",val);
				break;
			default:
				strcpy(mid->query+strlen(mid->query),mid->fields[i].inparam);
			}

		i++;
		p= q+1;
		q= strchr(p,PLACEHOLDER);
	}
	@:checkSpace(strlen(p))@
	strcpy(mid->query+strlen(mid->query),p);
	if( mid->trace)
		printf("param_store: result=%s\n",mid->query);
	return mid->query;
}

/* copied from gdk.mx since it is not included here */
#if defined(__STDC_VERSION__) && __STDC_VERSION__ >= 199901
#define SZFMT "%zu"
#define SSZFMT "%zd"
#else
#if SIZEOF_SIZE_T == SIZEOF_INT
#define SZFMT "%u"
#define SSZFMT "%d"
#else
#if SIZEOF_SIZE_T == SIZEOF_LONG
#define SZFMT "%lu"
#define SSZFMT "%ld"
#else
#if SIZEOF_SIZE_T == 8
#define SZFMT ULLFMT
#define SSZFMT LLFMT
#else
#error no definition for SZFMT/SSZFMT
#endif
#endif
#endif
#endif

MapiMsg mapi_execute_internal(Mapi mid)
{
	size_t size;
	char *cmd;

	mapi_check(mid,"mapi_execute");
	mapi_param_store(mid);
	cmd= mid->query;
	size =strlen(cmd) /* null byte */;

	mapi_cache_reset(mid);
	if (mid->trace) {
		printf("mapi_query:" SZFMT ":%s\n", size, cmd);
	}
	if (mid->from->errnr || mid->to->errnr) {
		return mapi_setError(mid, "communication line broken",
						"mapi_execute");
	}
	if( mid->to->write(mid->to,cmd,1,size) != size){
		return mapi_setError(mid, "write error on stream",
				"mapi_execute");
	}
	mid->to->flush(mid->to);
	return MOK;
}

MapiMsg mapi_execute(Mapi mid)
{
	mapi_check(mid,"mapi_execute");
	return mapi_execute_internal(mid);
}
MapiMsg mapi_execute_array(Mapi mid, char **val)
{
	int ret;
	char *cmd;
	mapi_check(mid,"mapi_execute_array");
	cmd= mid->query;
	ret= mapi_prepare_array_internal(mid,cmd,val);
	return ret? ret: mapi_execute_internal(mid);
}

static MapiMsg answer_lookahead(Mapi mid)
{
	/* look ahead to detect errors */
	int oldrd= mid->cache.reader;
	do {
		mapi_get_row(mid);
	} while(mid->error==MOK && mid->active && 
		mid->cache.writer+1 <mid->cache.limit);
	mid->cache.reader= oldrd;
	if(mid->trace)
		printf("mapi_query return:%d\n",mid->error);
	return mid->error;
}

MapiMsg mapi_query(Mapi mid, char* cmd)
{
	int ret;
	@:prepareQuery@
	if(ret == MOK) ret= mapi_execute_internal(mid);
	if(ret==MOK) ret= answer_lookahead(mid);
	return ret;
}

MapiMsg mapi_query_array(Mapi mid, char* cmd, char **val)
{
	int ret;
	ret= mapi_prepare_array_internal(mid,cmd,val);
	if(ret == MOK) ret= mapi_execute_internal(mid);
	if(ret==MOK) ret= answer_lookahead(mid);
	return ret;
}
@-
To speed up interaction with a terminal front-end,
the user can issue the quick_*() variants.
They will not analyse the result for errors or
header information, but simply through the output
received from the server to the stream indicated.
@c
MapiMsg mapi_quick_query(Mapi mid, char* cmd, FILE *fd)
{
	int ret;
	mapi_check(mid,"mapi_quick_query");
	@:prepareQuery@
	if(ret == MOK) ret= mapi_execute_internal(mid);
	if(ret==MOK) {
		mapi_quick_response(mid,fd);
		ret= mid->error;
	}
	if(mid->trace)
		printf("mapi_quick_query return:%d\n",ret);
	return ret;
}

MapiMsg mapi_quick_query_array(Mapi mid, char* cmd, char **val, FILE *fd)
{
	int ret;
	mapi_check(mid,"mapi_quick_query_array");
	ret= mapi_prepare_array_internal(mid,cmd,val);
	if(ret == MOK)
		ret= mapi_execute_internal(mid);
	if(ret==MOK) {
		/* look ahead to detect errors */
		mapi_quick_response(mid,fd);
		ret= mid->error;
	}
	if(mid->trace)
		printf("mapi_quick_query return:%d\n",ret);
	return ret;
}

static void mapi_cache_reset(Mapi mid)
{
	int i;
	mapi_finish_internal(mid);
	mid->rows_affected = 0;
	mid->active= 1;
	for (i=0;i< mid->cache.writer; i++)
		if( mid->cache.rows[i])
			mid->cache.rows[i][0]=0;
	mid->cache.reader= -1;
	mid->cache.tuples= 0;
	mid->cache.writer= 0;
	mid->fieldcnt=0;
	memset(mid->cache.fldcnt,0, sizeof(int)* mid->cache.limit);
}

MapiMsg mapi_cache_limit(Mapi mid, int limit)
{
	/* clean out superflous space TODO */
	mapi_check(mid,"mapi_cache_limit");
	mid->cache.rowlimit= limit;
	return MOK;
}

MapiMsg mapi_fetch_reset(Mapi mid)
{
	mapi_check(mid,"mapi_fetch_reset");
	mid->cache.reader= -1;
	return MOK;
}

MapiMsg mapi_seek_row(Mapi mid,int rownr)
{
	int i;
	mapi_check(mid,"mapi_seek_row");
	mid->cache.reader= -1;
	if( rownr<0) 
		return mapi_setError(mid,"Illegal row number","mapi_seek_row");
	for(i=0; rownr>=0 && i< mid->cache.writer;i++){
		if( mid->cache.rows[i][0]=='#' )
			continue;
		if( mid->cache.rows[i][0]=='!' )
			continue;
		if(--rownr<0)
			break;
	}
	if( rownr>=0)
		return mapi_setError(mid,"Row not found","mapi_seek_row");
	mid->cache.reader= i;
	return MOK;
}

static
void  mapi_extend_cache(Mapi mid)
{
	int incr, newsize, oldsize= mid->cache.writer;
	char **newrows, ***anchors;
	int *fldcnt;
	/* extend row cache */
	if( oldsize == mid->cache.rowlimit ){
		mapi_setError(mid,"Row cache limit reached","mapi_extend_cache");
	}
	incr = oldsize /10;
	newsize = oldsize + (incr <100? 100: incr);
	if( newsize >mid->cache.rowlimit && mid->cache.rowlimit>0)
		newsize = mid->cache.rowlimit;

	newrows = (char **) malloc(newsize * sizeof(char**));
	assert(newrows);
	memset(newrows,0, newsize * sizeof(char **));
	if( oldsize){
		memcpy(newrows, mid->cache.rows, oldsize*sizeof(char**));
		free(mid->cache.rows);
	}
	mid->cache.rows= newrows;

	anchors = (char ***) malloc(newsize * sizeof (char **));
	assert(anchors);
	memset(anchors, 0, newsize * sizeof( char **));
	if( oldsize) {
		memcpy(anchors, mid->cache.anchors, oldsize*sizeof(char*));
		if(mid->cache.anchors) free(mid->cache.anchors);
	}
	mid->cache.anchors= anchors;
	fldcnt= (int *) malloc( newsize * sizeof(int));
	assert(fldcnt);
	memset(fldcnt,0, newsize * sizeof(int));
	if( oldsize){
		memcpy(fldcnt, mid->cache.fldcnt, oldsize *sizeof(int));
		free(mid->cache.fldcnt);
	}
	mid->cache.fldcnt = fldcnt;

	mid->cache.limit= newsize;
}

static
int  mapi_clear_cache(Mapi mid)
{
	int i;
	if( mid->cache.rowlimit<0 ) return MOK;
	if( mid->cache.reader+2< mid->cache.writer)
		return mapi_setError(mid,"Cache reset with non-read lines","mapi_clear");
	for(i=0; i<mid->cache.writer;i++){
		if( mid->cache.anchors[i])
			free(mid->cache.anchors[i]);
		mid->cache.anchors[i]=0;
		if( mid->cache.rows[i])
			free(mid->cache.rows[i]);
		mid->cache.rows[i]=0;
	}
	mid->cache.reader= -1;
	mid->cache.writer= 0;
	memset(mid->cache.fldcnt,0, mid->cache.limit * sizeof(int));
	return MOK;
}
@-
The routine mapi_fetch_line forms the basic interaction with the server.
It simply retrieves the next line and stores it in the row cache.
The field anchor structure is prepared for subsequent use by
mapi_fetch_row.
The content received is analysed further by mapi_getRow()

@= endofsession
		if( len==0){
			mid->blk.eos=1;
			mapi_lost_connection(mid);
			return 0;
		}
@c

char * mapi_fetch_line_internal(Mapi mid)
{
	char *reply, *s;
	size_t k;


	if(mid->cache.writer>0 && mid->cache.reader+1< mid->cache.writer)
		return mid->cache.rows[++mid->cache.reader];

	if( mid->active == 0)
		return 0;
	/* get rid of old buffer space */
	if (mid->cache.writer== mid->cache.limit && mapi_clear_cache(mid))
		return 0;

	/* check if you need to read more blocks to catch a new line */
	mid->blk.eos=0;
	while( !strchr(mid->blk.buf+mid->blk.nxt,'\n') && mid->blk.eos==0){
		char *newbuf;
		size_t len;
		int rest,n;

		s= strchr(mid->blk.buf+mid->blk.nxt,'\0');
		assert(s);
		n= s - mid->blk.buf;

		if( mid->blk.lim-n < BLOCK){
			rest= n-mid->blk.nxt;
			if( mid->blk.nxt> BLOCK){
				/* simply shuffle */
				newbuf= (char *)malloc(mid->blk.lim +1);
				memcpy(newbuf, mid->blk.buf + mid->blk.nxt, rest+1);
				if( mid->blk.buf)
					free(mid->blk.buf);
				mid->blk.buf= newbuf;
				mid->blk.nxt= 0;
				n = rest;
			} else{
				/* extend space */
				int len= mid->blk.lim+BLOCK;
				newbuf= (char *)malloc(len +1);
				memcpy(newbuf, mid->blk.buf + mid->blk.nxt, rest+1);
				if( mid->blk.buf)
					free(mid->blk.buf);
				mid->blk.buf= newbuf;
				mid->blk.nxt= 0;
				mid->blk.lim= len;
				n = rest;
			}
		}

		if (mid->from->errnr) {
			mapi_setError(mid, "Connection terminated","mapi_fetch_line");
			return 0;
		}
#ifdef BLOCKED
		/* fetch one more block */
		len = mid->from->read(mid->from, mid->blk.buf+n,
					1, BLOCK);
		mid->blk.buf[n+len]=0;
		@:endofsession@
#else
		/* fetch one more line */
		len=0;
		s=mid->blk.buf+n;
		while( (k= mid->from->read(mid->from,s,1,1))==1 ){
			len++;
			if( *s== '\n')
				break;
			s++;
			if(s== mid->blk.buf+mid->blk.lim)
				break;
		}
		mid->blk.buf[n+len]=0;
		@:endofsession@

#endif
	}
	if(mid->blk.buf[mid->blk.nxt]== PROMPTBEG){
		promptMonet(mid);
		return 0;
	}
	/* we have a complete line in the buffer */
	s= strchr(mid->blk.buf + mid->blk.nxt,'\n');
	assert(s);
	*s=0;
	k= strlen(mid->blk.buf+mid->blk.nxt)+1;
	reply = (char *) malloc(k);
	assert(reply);
	strcpy(reply, mid->blk.buf+mid->blk.nxt);
	mid->blk.nxt += k;

	/* manage the row cache space first */
	if( mid->cache.writer >= mid->cache.limit)
		mapi_extend_cache(mid);


	mid->cache.rows[mid->cache.writer]= reply;
	mid->cache.writer++;
	if( mid->trace)
		printf("mapi_fetch_line:%s\n", reply);
	return mid->cache.rows[++mid->cache.reader];
}
char * mapi_fetch_line(Mapi mid)
{
	mapi_check0(mid,"mapi_fetch_line");
	return mapi_fetch_line_internal(mid);
}
@-
To synchronize on a prompt, the low level routine mapi_finish can be used.
It disgards all output received.
@c
MapiMsg mapi_finish_internal(Mapi mid)
{
	mapi_check(mid,"mapi_finish");
	if( mid->active)
		while(mapi_fetch_line_internal(mid) != (char*) 0)
			;
	return mid->error;
}
MapiMsg mapi_finish(Mapi mid){
	mapi_check(mid,"mapi_finish");
	return mapi_finish_internal(mid);
}
@-
If the answer to a query should be simply passed on towards a client,
i.e. a stream, it pays to use the mapi_quick_response() routine.
The stream is only checked for occurrence of an error indicator
and the prompt.
The best way to use this shortcut execution is calling
mapi_quick_query(), otherwise we are forced to first
empy the row cache.

@= handlePart
	s= strchr(mid->blk.buf+mid->blk.nxt,PROMPTBEG);
	if( s){
		ptrdiff_t len = s-mid->blk.buf;
		fwrite(mid->blk.buf+mid->blk.nxt,1,len,fd);
		mid->blk.nxt += len;
		promptMonet(mid);
		return MOK;
	} else if( @1 > 0) {
		fwrite(mid->blk.buf+mid->blk.nxt,1,@1,fd);
		mid->blk.nxt=0;
	}
	if(ferror(fd))
		return mapi_setError(mid,"Error writing file","mapi.response");
@c
MapiMsg mapi_quick_response(Mapi mid, FILE *fd)
{
	char *s;
	int i;
	size_t k;


	mapi_check(mid,"mapi_quick_response");
	if(fd==0)
	return mapi_setError(mid,"Destination file missing","mapi.response");

	/* any left over rows in the cache? */
	for(i= mid->cache.reader+1; i<mid->cache.writer; i++)
		fprintf(fd,"%s\n", mid->cache.rows[i]);
	if( mid->active == 0)
		return 0;

	/* check if you need to sent pending information */
	k= strlen(mid->blk.buf+mid->blk.nxt);
	@:handlePart(k)@

	mid->blk.eos=0;
	mid->blk.nxt=0;
#ifdef BLOCKED
	while( (k= mid->from->read(mid->from,mid->blk.buf,1,BLOCK))== BLOCK){
		@:handlePart(BLOCK)@
	}
#else
	/* read until we find the prompt */
	s=mid->blk.buf;
	while( (k= mid->from->read(mid->from,s,1,1))==1 ){
		fwrite(s,1,1,fd);
		if( *s == PROMPTBEG) {
			s++;
			break;
		}
	}
	if(k==1)
		while( mid->from->read(mid->from,s,1,1)==1 ){
			k++;
			if( *s== '\n'){
				*(s+1)=0;
				break;
			}
			s++;
			if(s== mid->blk.buf+mid->blk.lim)
				break;
		}
#endif

	if (k>0) {
		@:handlePart(k)@
	}
	mapi_fetch_line_internal(mid);  /* get rid of prompt possibly */
	return mid->error;
}
@-
The routine mapi_get_row retrieves lines from the channel until
it finds either a valid row, or encounters an error.
In passing, it interprets comment lines to detect table headers.
It returns with 0 upon encountering the prompt
(MOK) or an error. The row cache buffer is extended until the limit
is reached.
@c
static
void mapi_header(Mapi mid, char *line)
{
	char *tag= "", *c, *etag;
	char *buf;
	int i,cr= mid->cache.reader;

	if( mid->trace)
		printf("mapi_header:%s\n",line);
	etag= c= strrchr(line,'#');
	if( c == 0 || c==line )
		return;

@-
After a header analysis, we should have restored the original line,
because the client may wish to perform a mapi_fetch_line();
@= keepProp
if(strncmp(@1,tag,4)==0){
	for(i=0; i< mid->cache.fldcnt[mid->cache.reader]; i++){
		size_t len= strlen(mapi_fetch_field(mid,i));
		len= len< NAMELEN? len: NAMELEN-1;
		strncpy(mid->fields[i].@2, mapi_fetch_field(mid,i),len);
		printf("got name %s\n", mapi_fetch_field(mid,i));
	}
}
@c
	buf= malloc(strlen(mid->cache.rows[cr])+1);
	strcpy(buf,mid->cache.rows[cr]);
	mapi_slice_row(mid);


	*line = '['; 	/* fake a value row */
	*c = ']';
	c++;
	while(*c && (*c == ' '|| *c=='\t')) c++;
	if(*c) tag= c;

	@:keepProp("name",columnname)@
	@:keepProp("type",columntype)@
	/* restore the markers */
	*line= '#'; *etag= '#';
	strcpy(mid->cache.rows[cr],buf);
	for(i=0; i< mid->cache.fldcnt[mid->cache.reader]; i++)
		mid->cache.anchors[cr][i]=0;
	mid->cache.fldcnt[cr]=0;
	free(buf);
}

static
int mapi_get_row(Mapi mid)
{
	char *reply=0;

	while(mid->active || mid->cache.reader+1 < mid->cache.writer ){
		if( mid->active){
			reply= mapi_fetch_line_internal(mid);
			if( reply == 0 )
				return MERROR;
		} else
			reply = mid->cache.rows[++mid->cache.reader];

		switch(reply[0]){
		case '#':
			if( !(mid->languageId>= LANG_SQL && reply[1]=='(')){
				mapi_header(mid,reply);
				return mapi_get_row(mid);
			}
		case '!':
			{
			/* concatenate the error messages */
			char *olderr= mid->errorstr;
			char *newerr;
			size_t size= olderr?strlen(olderr):0;
			newerr= (char*) malloc(size+strlen(reply)+2);
			assert(newerr);
			newerr[0]=0;
			if(olderr) strcpy(newerr,olderr);
			strcat(newerr,reply);
			strcat(newerr,"\n");
			mid->error= MERROR;
			mid->action = "mapi_get_row";
			if(mid->errorstr) free(mid->errorstr);
			mid->errorstr= newerr;
			return mapi_get_row(mid);
			}
			break;
		case '[':
			mid->cache.tuples++;
		default:
			return MOK;
		}
	}
	return MERROR;
}
@-
Unquoting of a string is done in place. It returns the start
of the unquoted part section.
@c
static
void unquote(char *msg, char **start, char **next)
{
	char *p= msg, *s;
	char quote;

	while(*p && isspace((int)(*p)))
		p++;
	*start =p;
	quote= *p;
	if( quote=='\'' || quote=='"'){
		/* get quoted string */
		p++; *start=p;
		s= p;
		while(*p && *p != quote){
			if(*p=='\\') {
				p++;
				switch(*p){
				/* later
				case '0': case '1': case '2': case '3': case '4':
				case '5': case '6': case '7': case '8': case '9':
				*/
				case 'n': *s= '\n'; break;
				case 't': *s= '\t'; break;
				case 'r': *s= '\r'; break;
				case 'f': *s= '\f'; break;
				case '\\': *s= '\\'; break;
				default: *s =*p; break;
				}
				p++;
			} else
				*s++ = *p++;
		}
		*p = 0;
	} else {
		while( *p && (*p != ',' && *p != ']'))
			p++;
		for( s= p-1; s > *start && *s == ' '; s--)
			;
		if( s>= *start && s< p-1)
			*s=0;
		if( *p==0) {
			*next = p;
			return;
		}
		*p = 0;
	}
	p++;
	while(*p && *p != '[' && *p != '\t' && *p != ' ')
		p++;
	*next = p;
}
@-
The (un)quote routines should use dynamic storage.
@c
char *mapi_unquote(char *msg)
{
	char *start, *next;
	size_t size;
	unquote(msg, &start,&next);
	size= strlen(start);
	next= (char*) malloc(size+1);
	strcpy(next,start);
	return next;
}

char *mapi_quote(char *msg)
{
	int len= sizeof(msg)*3;
	char *s= (char*) malloc(len);
	char *t=s,*v= s+ len;
	for(; *msg && t<v; t++){
		switch(*msg){
		case '\n': *t++= '\\'; *t= 'n'; break;
		case '\t': *t++= '\\'; *t= 't'; break;
		case '\?': *t++= '\\'; *t= PLACEHOLDER; break;
		case '\\': *t++= '\\'; *t= '\\'; break;
		default:
			*t= *msg++;
		}
		/* also deal with binaries */
	}
	*t=0;
	return s;
}
@-
The low level routine mapi_slice_row breaks the last row received into pieces
and binds the field descriptors with their location. All escaped characters
are immediately replaced, such that we end with a list of C-strings.
It overwrites the contents of the row buffer, because de-escaping
only reduces the size.
It also silently extends the field descriptor table.
@c
static
int mapi_extend_fields(Mapi mid, int minfields)
{
	/* extend the field table */
	MapiField *nf;
	int nm= mid->maxfields +32;
	if( nm <=minfields)
		 nm= minfields+32;
	nf= (MapiField *) malloc(nm * sizeof(MapiField));
	assert(nf);
	memset(nf,0,  nm* sizeof(MapiField));
	memcpy(nf, mid->fields, mid->maxfields * sizeof(MapiField));
	if( mid->fields)
		free(mid->fields);
	mid->fields= nf;
	mid->maxfields= nm;
	return MOK;
}

static
void mapi_extend_anchor(Mapi mid)
{
	int cr= mid->cache.reader;
	char **ac= mid->cache.anchors[cr], **acnew=0;
	if( ac == 0 || mid->maxfields> mid->cache.fldcnt[cr]){
		acnew= (char **)malloc(sizeof(char*)* mid->maxfields);
		assert(acnew);
		memset(acnew, 0, sizeof(char*) * mid->maxfields);
		mid->cache.anchors[cr]= acnew;
		if(ac)
			memcpy(acnew,ac, sizeof(char*)*mid->cache.fldcnt[cr]);
	}
	if(ac)
		free(ac);
}
@-
The values of a row are delivered to any bounded variable before
fetch_row returns. Automatic conversion based on common types
simplifies the work for the programmers.
@c
static
void mapi_store_bind(Mapi mid)
{
	int i;
	int cr= mid->cache.reader;

	for(i=0; i< mid->fieldcnt;i++)
		if( mid->fields[i].outparam){
			char *val= mid->cache.anchors[cr][i];
			void *dst= mid->fields[i].outparam;
			if( val == 0){
				mapi_setError(mid,"Field value undefined",
					      "mapi_store_bind");
				continue;
			}
			/* auto convert to C-type */
			switch(mid->fields[i].outtype){
			case SQL_NUMERIC:
			case SQL_INT:
				*(int *)dst = (int) strtol(val,NULL,0);
				break;
			case SQL_LONG:
				*(long *)dst = (long) strtol(val,NULL,0);
				break;
			case SQL_CHAR:
				*(char *)dst = *val;
				break;
			case SQL_FLOAT:
			case SQL_DOUBLE:
				*(double *)dst = (double) strtod(val,NULL);
				break;
			case SQL_TIME:
			case SQL_DATE:
			case SQL_AUTO:
			case SQL_VARCHAR:
			default:
				*(char **)dst = val;
			}
		}
}

static
int mapi_slice_row(Mapi mid)
{
	char *start;
	char *p;
	int single, i, cr= mid->cache.reader;

	p= mid->cache.rows[cr];
	if( p== NULL )
		return mapi_setError(mid,"Current row missing","mapi_slice_row");
	if( mid->cache.fldcnt[cr]) {
		mapi_store_bind(mid);
		return mid->cache.fldcnt[cr]; /* already sliced */
	}
	single = *p != '[';
	if(!single)
		p++;

	mapi_extend_anchor(mid);
	i=0;
	do {
		if( i== mid->maxfields ) {
			if(mapi_extend_fields(mid,i))
				return mid->error;
			mapi_extend_anchor(mid);
		}
		unquote(p, &start, &p);
		mid->cache.anchors[cr][i++] = start;
		while(*p && *p=='\t' && *p != ']')
			p++;
	} while(!single && *p && *p != ']');
	if (mid->fieldcnt <i)
		mid->fieldcnt=i;
	mid->cache.fldcnt[cr]= i;
	mapi_store_bind(mid);
	return i;
}

@-
The rows presented are broken down into pieces to
simplify access later on.
@c
int mapi_fetch_row(Mapi mid)
{
	mapi_check(mid,"mapi_fetch_row");
	if( mapi_get_row(mid)== MOK)
		return mapi_slice_row(mid);
	return 0;
}
@-
All rows can be cached first as well.
@c
int mapi_fetch_all_rows(Mapi mid)
{
	mapi_check(mid,"mapi_fetch_all_rows");
	mid->cache.rowlimit= -1;
	mid->cache.tuples=0;
	while( mapi_get_row(mid)== MOK)
		mapi_slice_row(mid);
	mid->cache.reader= -1;
	return mid->cache.tuples;
}

char *mapi_fetch_field(Mapi mid, int fnr)
{
	int cr;
	mapi_check0(mid,"mapi_fetch_field");
	cr= mid->cache.reader;

	if( fnr >=0 ){
		/* slice if needed */
		if( mid->cache.fldcnt[cr]==0)
			mapi_slice_row(mid);
		if( fnr < mid->cache.fldcnt[cr])
			return mid->cache.anchors[cr][fnr];
	}
	mapi_setError(mid,"Illegal field number","mapi_fetch_field");
	return 0;
}

char **mapi_fetch_field_array(Mapi mid)
{
	int cr;
	mapi_check0(mid,"mapi_fetch_field_array");
	cr= mid->cache.reader;
	if( mid->cache.fldcnt[cr]==0)
		mapi_slice_row(mid);
	return mid->cache.anchors[cr];
}

int mapi_get_field_count(Mapi mid)
{
	mapi_check(mid,"mapi_get_field_count");
	return mid->fieldcnt;
}

int mapi_get_row_count(Mapi mid)
{
	mapi_check(mid,"mapi_get_row_count");
	return mid->rows_affected;
}

char *mapi_get_name(Mapi mid, int fnr)
{
	mapi_check0(mid,"mapi_get_name");
	if( fnr >=0 && fnr <mid->fieldcnt) {
		if( mid->fields[fnr].columnname[0] == 0)
			snprintf(mid->fields[fnr].columnname, NAMELEN, "column_%d",fnr);
		return mid->fields[fnr].columnname;
	}
	mapi_setError(mid,"Illegal field number","mapi_get_name");
	return 0;
}

char *mapi_get_table(Mapi mid, int fnr)
{
	mapi_check0(mid,"mapi_get_table");
	if( fnr >=0 && fnr <mid->fieldcnt) {
		if( mid->fields[fnr].tablename[0] == 0)
			snprintf(mid->fields[fnr].tablename, NAMELEN, "table_%d",fnr);
		return mid->fields[fnr].tablename;
	}
	mapi_setError(mid,"Illegal field number","mapi_get_table");
	return 0;
}

int mapi_rows_affected(Mapi mid)
{
	mapi_check(mid,"mapi_rows_affected");
	return mid->rows_affected;
}

char *mapi_get_host(Mapi mid)
{
	mapi_check0(mid,"mapi_get_host");
	return mid->hostname;
}

char *mapi_get_user(Mapi mid)
{
	mapi_check0(mid,"mapi_get_user");
	return mid->username;
}

char *mapi_get_lang(Mapi mid)
{
	mapi_check0(mid,"mapi_get_lang");
	return mid->language;
}

char *mapi_get_version(Mapi mid)
{
	mapi_check0(mid,"mapi_get_version");
	return mid->server;
}
int mapi_get_versionId(Mapi mid)
{
	return mid->versionId;
}
@c
@= testField1
	mapi_check(mid,@1);
	if( fnr <0 || fnr >=mid->fieldcnt) {
		mapi_setError(mid,"Illegal field number",@2);
		return @1;
	}
int mapi_get_type(Mapi mid, int fnr)
{
	@:testField1(0,"mapi_get_type")@
	return mid->fields[fnr].type;
}

int mapi_get_scale(Mapi mid, int fnr)
{
	@:testField1(0,"mapi_get_scale")@
	return mid->fields[fnr].scale;
}

int mapi_get_precision(Mapi mid, int fnr)
{
	@:testField1(0,"mapi_get_precision")@
	return mid->fields[fnr].precision;
}

int mapi_get_len(Mapi mid, int fnr)
{
	@:testField(0,"mapi_get_len")@
	return mid->fields[fnr].colwidth;
}

@-
char **mapi_get_fields(Mapi mid, int fnr)
{
	return mid->fields[fnr].type;
}
@}
