@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@' 
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@' 
@' The Original Code is the Monet Database System.
@' 
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2004 CWI.
@' All Rights Reserved.
@' 
@' Contributor(s):
@' 		Martin Kersten <Martin.Kersten@cwi.nl>
@' 		Peter Boncz <Peter.Boncz@cwi.nl>
@' 		Niels Nes <Niels.Nes@cwi.nl>
@' 		Stefan Manegold  <Stefan.Manegold@cwi.nl>

@f Mapi
@a M.L. Kersten
@v 2.0
@d August 2003
@* The Monet Application Programming Interface

The easiest way to extend the functionality of Monet is to construct
an independent Monet application, which communicates with a
running server using a database driver with a simple API and a textual protocol.
The effectiveness of such an approach has been demonstrated by the wide
use of database API implementations, such as Perl DBI, PHP ADO, ODBC,...

The database driver implementation given in this document is
focused on developing applications in C/C++. The command collection
have been chosen to align with common practice, i.e. queries follow
a prepare,execute,and fetch_row paradigm. The output is considered
a regular table. An example of a mini
application below illustrates the main operations.
@T
\begin{verbatim}
#include <Mapi.h>
#include <stdio.h>

#define die(X) (mapi_explain(X, stdout), exit(-1))

int main(int argc, char **argv)
{
	Mapi dbh;
	MapiHdl hdl;

	dbh = mapi_connect("localhost", 50001, "guest", 0, "sql");
	if (mapi_error(dbh))
		die(dbh);

	if ((hdl = mapi_query(dbh, "create table emp(name varchar, age int)")) == NULL) 
		die(dbh);
	mapi_close_handle(hdl);
	if ((hdl = mapi_query(dbh, "insert into emp values(\"John\", 23)")) == NULL) 
		die(dbh);
	mapi_close_handle(hdl);
	if ((hdl = mapi_query(dbh, "insert into emp values(\"Mary\", 22)")) == NULL)
		die(dbh);
	mapi_close_handle(hdl);
	if ((hdl = mapi_query(dbh, "select * from emp")) == NULL)
		die(dbh);

	while (mapi_fetch_row(hdl)) {
		char *nme = mapi_fetch_field(hdl, 0);
		char *age = mapi_fetch_field(hdl, 1);
		printf("%s is %s\n", nme, age);
	}
	mapi_close_handle(hdl);
	mapi_disconnect(dbh);

	return 0;
}
\end{verbatim}

The mapi_connect() operation establishes a communication channel
with a running server on the local machine. The user identification
is the ubiquitous anonymous guest, for whom we do not require a password.
The query language interface is "sql". Alternatives are the lower
level languages "mil" and "mal". Future versions are expected to
recognize also "xcore" and "xquery".

Errors on the interaction can be captured using mapi_error(), possibly
followed by a request to dump a short error message explanation on a
standard file location. It has been abstracted away in a macro.

Provided we can establish a connection, the interaction proceeds as
in many similar application development packages. Queries are shipped
for execution using mapi_query() and an answer table can be consumed
one row at a time. In many cases these functions suffice.

The tabular data exchange model is primarily meant to support sql
(mil,mal) For xml and xcore the engine is expected to generate
a XPath-like token stream from which the application can built
the internal representation of the document (e.g. a DOM-tree).

The Mapi interface provides caching of rows at the client side.
mapi_query() will load all tuples into the cache, after which
they can be read repeatedly using mapi_fetch_row()
or directly accessed (mapi_seek_row()). This facility is particularly
handy when small, but stable query results are repeatedly used
in the client program.

To ease communication between application code and the cache
entries, the user can bind the C-variables both for input and
output to the query parameters, and output columns, respectively.
The query parameters are indicated by '?' and may appear anywhere
in the query template.

@+ Caveats
The Mapi library expects complete lines from the server as answers
to query actions. Incomplete lines leads to Mapi waiting
forever on the server. Thus formatted printing is discouraged in favor
of tabular printing as offered by the table.print() commands in
Monet 5.

@+ Compilation
The Mapi application uses include files found in the Monet distribution
directory or at a central location in your machine.
Assuming the location of the distribution is marked in the
environment variable $MONET_PREFIX, the following actions are needed to
get a working program (on Linux and V5).
@T
\begin{verbatim}
cc sample.c  -DHAVE_CONF_H -I$MONET_PREFIX \
        -I$MONET_PREFIX/include/common -I$MONET_PREFIX/include/mapi  \
	-Wl,$MONET_PREFIX/lib/libMapi.so \
	-Wl,$MONET_PREFIX/lib/libutils.so \
	-Wl,$MONET_PREFIX/lib/libstream.so \
	-Wl,--rpath -Wl,$MONET_PREFIX/lib/MonetDB:$MONET_PREFIX/lib \
	-o sample
\end{verbatim}

The location of the libraries in 4.3 are slightly different.
@+ Command summary
The quick reference guide to the Mapi library is given below.
More details on their constraints and defaults is geven in the
next section.
@T
\begin{tabular}{l l}
mapi_bind()	&	Bind string C-variable to field\\
mapi_bind_var()	&	Bind typed C-variable to field\\
mapi_bind_numeric()	& Bind numeric C-variable to field\\
mapi_cache_limit()	& Set the tuple cache limit\\
mapi_cache_shuffle()	& Set shuffle fraction for cache refreshment\\
mapi_cache_freeup()	& Forcefully shuffle fraction for cache refreshment\\
mapi_clear_bindings()	& Clear all field bindings\\
mapi_clear_params()	& Clear all parameter bindings\\
mapi_close_handle()	&	Close query handle and free resources\\
mapi_connect()	&	Connect to a Mserver \\
mapi_connect_ssl()	& Connect to a Mserver using SSL [TODO]\\
mapi_destroy()	&	Free resources\\
mapi_disconnect()	& Disconnect from server\\
mapi_dup()	&	Duplicate the connection structure\\
mapi_error()	&	Test for error occurrence\\
mapi_explain()	&	Display error message and context on stream\\
mapi_explain_query()	&	Display error message and context on stream\\
mapi_execute()	&	Execute a query\\
mapi_execute_array()	&Execute a query using string arguments\\
mapi_fetch_field()	&Fetch a field from the current row\\
mapi_fetch_field_array()	& Fetch all fields from the current row\\
mapi_fetch_line()	&	Retrieve the next line\\
mapi_fetch_reset()	&	Set the cache reader to the begining\\
mapi_fetch_row()	&	Fetch row of values\\
mapi_fetch_all_rows()	&	Fetch all answers from server into cache\\
mapi_finish()	&	Terminate the current query\\
mapi_get_dbname()	&	Database being served\\
mapi_get_host()	&	Host name of server\\
mapi_get_language()	& Query language name\\
mapi_get_user()	&	Current user name\\
mapi_get_mapi_version()	& Mapi version name\\
mapi_get_monet_version()	& Monet version name\\
mapi_get_monet_versionId()	& Monet version identifier\\
mapi_get_field_count()	& Number of fields in current row\\
mapi_get_row_count()	&	Number of rows in cache or -1\\
mapi_ping()	&	Test server for accessibility\\
mapi_prepare()	&	Prepare a query for execution\\
mapi_prepare_array()	&	Prepare a query for execution using arguments\\
mapi_query()	&	Send a query for execution\\
mapi_query_handle()	&	Send a query for execution\\
mapi_query_array()	& Send a query for execution with arguments\\
mapi_quick_query()	&	Send a query for execution\\
mapi_quick_query_array()	& Send a query for execution with arguments\\
mapi_quote()	& Escape characters\\
mapi_reconnect()	& Reconnect with a clean session context\\
mapi_rows_affected()	& Obtain number of rows changed\\
mapi_quick_response()	&	Quick pass response to stream\\
mapi_setAutocommit()	&	Set auto-commit flag\\
mapi_stream_query()	& Send query and prepare for reading tuple stream\\
mapi_seek_row()	&	Move row reader to specific location in cache\\
mapi_table()	&	Get current table name\\
mapi_timeout()	&	Set timeout for long-running queries[TODO]\\
mapi_trace()	&	Set trace flag\\
mapi_trace_log()	& Keep log of interaction\\
mapi_unquote()	&	remove escaped characters\\
\end{tabluar}
@+ Mapi library
The routines to build a Monet application are grouped in the library
Monet Application Programming Interface, or Mapi.

The protocol information is stored in a Mapi interface descriptor (mid),
which should be passed to the library routines in most cases.
The application can set up several channels with the same or a different
Monet server. It is the programmers responsibility not to mix the
descriptors in retrieving the results.

The application may be multi-threaded as long as the user respects
the individual connections represented by the database handlers.

The interface assumes a cautious user, who understands and has experience
with the Monet programming language model. In particular, syntax errors may easily
lead to synchronization errors. It should also be clear that references
returned by the API point directly into the administrative structures of Mapi.
This means that they are valid only for a short period, mostly between
successive mapi_fetch_row commands.
A defensive programming style is advised.
Upon an error, the routines mapi_explain and mapi_explain_query give information about the context of
the failed call, including the expression shipped and any response received.
The side-effect is clearing the error status.

@T
\begin{description}

\item[Mapi mapi_connect(char *host, int port, char *username, char *password, char *lang)]:
Setup a connection with a Monet server at a {\em host}:{\em port} and
login with {\em username} and {\em password}. If host == NULL, the
local host is accessed.  If port == 0, a default port is used.
If username == NULL, the username of the
owner of the client application containing the Mapi code is used.
If password == NULL, the password is omitted.
The preferred query language is any of \{sql,mil,mal,xcore,xquery\}\\
The command returns a structure with administration about the interconnect.
It also contains an explanation when connection to the server fails.

\item[Mapi mapi_dup(Mapi mid)]:
Setup a second communication channel using the parameter setting of
the previous one.
\item[int mapi_disconnect(Mapi mid)]:
Terminates the session described by {\em mid}. Subsequent use
of the channel represented by this descriptor leads to a failure.
\item[Mapi mapi_reconnect(Mapi mid)]:
Close the current channel and re-establish a fresh connection. This
will remove all global session variables.

\item[MapiHdl mapi_query(Mapi mid, char *Command)]:
This routine sends the Command to the database server represented by mid.
It is one of the most common operations.
If Command is zero it takes the last query string kept around.
It returns zero upon success, otherwise it indicates a failure of the request.
The command response is buffered for consumption, e.g. mapi_fetch_row().

\item[MapiMsg mapi_query_handle(MapiHdl hdl, char *Command)]:
This routine sends the Command to the database server represented by mid.
It is one of the most common operations.
If Command is zero it takes the last query string kept around.
It returns zero upon success, otherwise it indicates a failure of the request.
The command response is buffered for consumption, e.g. mapi_fetch_row().

\item[MapiHdl mapi_query_array(Mapi mid, char *Command, char **argv)]:
This routine sends the Command to the database server replacing
the placeholders by the string arguments presented. The default placeholder
is the question mark (?).

\item[MapiHdl mapi_quick_query(Mapi mid, char *Command, FILE *fd)]:
Similar to mapi_query, except that the response of the server is
not analyzed, but shipped immediately to the file indicated.

\item[MapiHdl mapi_quick_query_array(Mapi mid, char *Command, char **argv, FILE *fd)]:
Similar to mapi_query, except that the response of the server is
not analyzed, but shipped immediately to the file indicated.

\item[MapiHdl mapi_stream_query(Mapi mid, char *Command, int windowsize)]:
Sent the request for processing and fetch a limited number of
tuples (determined by the window size) to assess any erroneous situation.
Thereafter, prepare for continual reading of tuples from the stream, until
an error occurs. Each time a tuple arrives, the cache is shifted one.

\item[int mapi_num_fields(Mapi mid)]:
Return the number of fields in the current row.

\item[int mapi_num_rows(Mapi mid)]:
Return the number of rows in the last select call. [ no guarantee given]
A -1 is returned if this information is not available.

\item[int mapi_rows_affected(MapiHdl hdl)]:
Called after a database update (INSERT/DELETE/REPLACE)
to determine the number of rows affected
by the command.

\item[int mapi_fetch_row(MapiHdl hdl)]:
This routine retrieves a row from the server.
The text retrieved is kept around in a buffer linked with the session
descriptor from which selective fields can be extracted.
It returns the number of fields recognized.
A zero is returned upon encountering end of sequence
or error. This can be analyzed in using mapi_error().

\item[int mapi_fetch_all_rows(MapiHdl hdl)]:
All rows are cached at the client side first. Subsequent calls
to either mapi_fetch_row() will take
the row from the cache. The number or rows cached
is returned.

\item[int mapi_quick_response(MapiHdl hdl, FILE *fd)]:
Read the answer to a query and pass the results verbatim
to a stream. The result is not analyzed, nor cached.

\item[MapiMsg mapi_seek_row(MapiHdl hdl, int rownr, int whence)]:
Reset the row pointer to the requested row number.
If whence is MAPI_SEEK_SET (0), rownr is the absolute row number (0 being the first row);
if whence is MAPI_SEEK_CUR (1), rownr is relative to the current row;
if whence is MAPI_SEEK_END (2), rownr is relative to the last row.
Comments lines are ignored.

\item[MapiMsg mapi_fetch_reset(MapiHdl hdl)]:
Reset the row pointer to the first line in the cache.
This need not be a tuple.
This is mostly used in combination with fetching all tuples at once.

\item[char **mapi_fetch_array(MapiHdl hdl)]:
Returns an array of string pointers to the individual fields.
A zero is returned upon encountering end of sequence
or error. This can be analyzed in using mapi_error().

\item[char *mapi_fetch_field(MapiHdl hdl, int fnr)]:
Returns a pointer a C-string representation of the value returned.
A zero is returned upon encountering an error.
This can be analyzed in using mapi_error().

\item[MapiHdl mapi_prepare(Mapi mid, char *Command)]:
Move the query to the connection structure. Possibly interact with the
back-end to prepare the query for execution.

\item[int mapi_execute(MapiHdl hdl)]:
The command is shipped to the backend for execution. A single answer
is pre-fetched to detect any runtime error. MOK is returned upon success.

\item[int mapi_execute_array(MapiHdl hdl, char **argv)]:
Similar to mapi_execute but replacing the placeholders for the
string values provided.

\item[MapiMsg mapi_bind(MapiHdl hdl, int fldnr, char **val)]:
Bind a string variable with a field in the return table.
Returns an error if the field identified does not exist.

\item[MapiMsg mapi_bind_var(MapiHdl hdl, int fldnr, int type, void *val)]:
Describe the type and location of the next parameter in a query template.
The types recognized are {MAPI_TINY, MAPI_UTINY, MAPI_SHORT, MAPI_USHORT,
MAPI_INT, MAPI_UINT, MAPI_LONG, MAPI_ULONG, MAPI_LONGLONG, MAPI_ULONGLONG,
MAPI_CHAR, MAPI_VARCHAR, MAPI_FLOAT, MAPI_DOUBLE, MAPI_DATE, MAPI_TIME,
MAPI_DATETIME}.
The binding operations should be performed after the mapi_execute command.
Subsequently all rows being fetched also involve delivery of the field
values in the C-variables using proper conversion. For variable length
strings a pointer is set into the cache.

\item[MapiMsg mapi_bind_numeric(MapiHdl hdl, int fldnr, int scale, int precision, void *val)]:
Bind to a numeric variable, internally represented by MAPI_INT
Describe the location of a numeric parameter in a query template.

\item[MapiMsg mapi_clear_bindings(MapiHdl hdl)]:
Clear all field bindings.

\item[MapiMsg mapi_param(MapiHdl hdl, int fldnr, char **val)]:
Bind a string variable with the n-th placeholder in the query
template.
No conversion takes place.

\item[MapiMsg mapi_param_type(MapiHdl hdl, int fldnr, int ctype, int sqltype, void *val)]:
Similar to mapi_bind_var(), but now binds a parameter.

\item[MapiMsg mapi_param_numeric(MapiHdl hdl, int fldnr, int scale, int precision, void *val)]:
Bind to a numeric variable, internally represented by MAPI_INT.

\item[MapiMsg mapi_param_string(MapiHdl hdl, int fldnr, int sqltype, char *val, int *sizeptr)]:
Bind to a string variable, internally represented by MAPI_VARCHAR.  The 
sizeptr parameter points to the length of the string pointed to by val.
If sizeptr == NULL or *sizeptr == -1, the string is NULL-terminated.

\item[MapiMsg mapi_clear_params(MapiHdl hdl)]:
Clear all parameter bindings.

\item[MapiMsg mapi_setAutocommit(Mapi mid, int autocommit)]:
Set the autocommit flag (default is off).  This only has an effect when
the language is SQL.  In that case, a commit statement is added to the
end of each query sent to the server.

\item[MapiMsg mapi_cache_limit(Mapi mid, int maxrows)]:
A limited number of tuples are pre-fetched after each execute().
If maxrows is negative, all rows will be fetched before the
application is permitted to continue. Once the cache is filled, 
a number of tuples are shuffled to make room for new ones,
but taking into account non-read elements.
Filling the cache quicker than reading leads to an error.

\item[MapiMsg mapi_cache_shuffle(MapiHdl hdl, int percentage)]:
It is sometimes handy to make room in the cache. For example,
when your application is stream-based and you process each tuple
as it arrives and still need a limited look-back.
This percentage can be set between 0 to 100.
Making shuffle= 100% (default) leads to paging behaviour,
while shuffle==1 leads to a sliding window over a tuple stream
with 1% refreshing.

\item[MapiMsg mapi_cache_freeup(MapiHdl hdl, int percentage)]:
Forcefully shuffle the cache making room for new rows.
It ignores the read counter, so rows may be lost.

\item[MapiMsg mapi_finish(MapiHdl hdl)]:
This routine is used in the rare cases that consumption of the
tuple stream produced should be prematurely terminated. It is automatically
called when a new query is shipped to the database.

\item[char * mapi_quote(char *name, int size)]:
Strings in the database should be surrounded by double quotes and
escape of the characters \n,\t,...

\item[char * mapi_unquote(char *name)]:
The reverse action of mapi_quote(), turning the database representation
into a C-representation. The storage space is dynamically created and
should be freed after use.

\item[MapiMsg  mapi_trace(Mapi mid, int flag)]:
Set the trace flag to monitor interaction with the server.

\item[MapiMsg  mapi_trace_log(Mapi mid, char *fname)]:
The interaction between the client and server is logged for
offline inspection. Beware that the log file overwrites any
previous log. It is not intended for recovery.

\item[MapiMsg mapi_ping(Mapi mid)]:
Test availability of the server. Returns zero upon success.

\end{description}

The remaining operations are wrappers around the data structures
maintained. Note that column properties are derived from the
table output returned from the server.
\begin{description}
\item[ char *mapi_get_name(MapiHdl hdl, int fnr)]:
\item[ char *mapi_get_type(MapiHdl hdl, int fnr)]:
\item[ char *mapi_get_table(MapiHdl hdl, int fnr)]:
\item[ int mapi_get_len(Mapi mid, int fnr)]:

\item[ char *mapi_get_dbname(Mapi mid)]:
\item[ char *mapi_get_host(Mapi mid)]:
\item[ char *mapi_get_user(Mapi mid)]:
\item[ char *mapi_get_lang(Mapi mid)]:
\item[ char *mapi_get_version(Mapi mid)]:
\item[ int mapi_get_versionId(Mapi mid)]:

\item[MapiMsg mapi_error(Mapi mid)]:
Returns the last error code or 0 if there is no error.

\item[char *mapi_error_str(Mapi mid)]:
Returns a pointer to the last error message.

\item[MapiMsg mapi_explain(Mapi mid, FILE *fd)]:
Writes the error message obtained from Monet to a file.

\item[MapiMsg mapi_explain_query(MapiHdl hdl, FILE *fd)]:
Writes the error message obtained from Monet to a file.

%\item[int mapi_timeout(Mapi mid, int timeout)]:
%Sets the time out time in milli seconds for all subsequent
%Mapi commands. Default value is 0, wait indefinitely.

\item[char **mapi_tables(Mapi mid)]:
Returns a list of accessible database tables.

\item[char **mapi_fields(Mapi mid)]:
Returns a list of accessible tables fields. This can also be obtained
by inspecting the field descriptor returned by mapi_fetch_field.

\end{description}
@

@- Error message
@T
The Mapi interface calls return one of the following codes.\\

\begin{tabular}{l l}
MOK  & No error \\
MERROR  & Mapi internal error.\\
\end{tabular}
@
@{
@+ Implementation
@c
#include "monetdb_config.h"
#include   "Mapi.h"

#ifdef HAVE_UNISTD_H
# include <unistd.h>
#endif
#include  <stdio.h>
#ifdef HAVE_PWD_H
#include  <pwd.h>
#endif
#include  <sys/types.h>
#include  <stream.h>

#ifdef HAVE_SYS_SOCKET_H
# include <sys/socket.h>
#endif
#ifdef HAVE_WINSOCK_H
# include <winsock.h>
#endif

#include  <signal.h>
#include  <string.h>
#include  <memory.h>

#if TIME_WITH_SYS_TIME
# include <sys/time.h>
# include <time.h>
#else
# if HAVE_SYS_TIME_H
#  include <sys/time.h>
# else
#  include <time.h>
# endif
#endif

@h
#ifndef _MAPI_H_INCLUDED
#define _MAPI_H_INCLUDED

#include <stdio.h>		/* for FILE * */

/*#define MONET5*/

#define MAPINAMELEN	256
#define MAPIBLKSIZE	256	/* minimum buffer shipped */

#define MAPI_AUTO	0	/* automatic type detection */
#define MAPI_TINY	1
#define MAPI_UTINY	2
#define MAPI_SHORT	3
#define MAPI_USHORT	4
#define MAPI_INT	5
#define MAPI_UINT	6
#define MAPI_LONG	7
#define MAPI_ULONG	8
#define MAPI_LONGLONG	9
#define MAPI_ULONGLONG	10
#define MAPI_CHAR	11
#define MAPI_VARCHAR	12
#define MAPI_FLOAT	13
#define MAPI_DOUBLE	14
#define MAPI_DATE	15
#define MAPI_TIME	16
#define MAPI_DATETIME	17
#define MAPI_NUMERIC	18

#define PLACEHOLDER	'?'

#define MAPI_SEEK_SET	0
#define MAPI_SEEK_CUR	1
#define MAPI_SEEK_END	2

typedef int MapiMsg;

#define MOK		0
#define MERROR		(-1)
#define MTIMEOUT	(-2)

#define LANG_MAL	0
#define LANG_MIL	1
#define LANG_SQL	2
#define LANG_XCORE	3
#define LANG_XQUERY	4

#define PROMPTBEG		'\001'	/* start prompt bracket */
#ifdef MONET5
#define PROMPTEND		'\002'	/* end prompt bracket */
#else
#define PROMPTEND		'\001'	/* end prompt bracket */
#endif
@-
The table field information is extracted from the table headers
obtained from the server. This list may be extended in the future.
The type of both the 'param' and 'binding'
variables refer to their underlying C-type. They are used for
automatic type coercing between back-end and application.
@c

typedef struct {
	char tablename[MAPINAMELEN];
	char columnname[MAPINAMELEN];
	char columntype[MAPINAMELEN];
	int colwidth;
	int coltype;
	int precision;
	int scale;
	int isnull;

	void *outparam;		/* pointer to application variable */
	int outtype;		/* type of application variable */
} MapiField;

typedef struct {
	void *inparam;		/* pointer to application variable */
	int *sizeptr;		/* if string, points to length of string or -1 */
	int intype;		/* type of application variable */
	int outtype;		/* type of value */
	int precision;
	int scale;
} MapiParam;

@-
The row cache contains a string representation of each (non-error) line
received from the backend. After a mapi_fetch_row() or mapi_fetch_field()
this string has been indexed from the anchor table, which holds a pointer
to the start of the field. A sliced version is recognized by looking
at the fldcnt table, which tells you the number of fields recognized.
Lines received from the server without 'standard' line headers are
considered a single field.
@c
typedef struct {
	int rowlimit;		/* maximum number of rows to cache */
	int shuffle;		/* percentage of rows to shuffle upon overflow */
	int limit;		/* current storage space limit */
	int writer;
	int reader;
	int first;		/* row # of first tuple */
	int *fldcnt;		/* actual number of fields in each row */
	char **rows;		/* string representation of rows received */
	int tuplecount;		/* number of tuples in the cache */
	int *tupleindex;	/* index of tuple rows */
	int *tuplerev;		/* reverse map of tupleindex */
	char ***anchors;	/* corresponding field pointers */
} MapiRowBuf;

typedef struct {
	char *buf;
	int lim;
	int nxt;
	int eos;		/* end of sequence */
} BlockCache;

typedef struct MapiStruct {
	char server[MAPINAMELEN];	/* server version */
	char mapiversion[MAPINAMELEN];	/* mapi version */
	char hostname[MAPINAMELEN];
	int port;
#ifdef HAVE_OPENSSL
	int secure;
#endif
	char username[MAPINAMELEN];
	char password[MAPINAMELEN];
	char language[MAPINAMELEN];
	char database[MAPINAMELEN];	/* to obtain from server */
	int languageId;
	int versionId;		/* Monet 4 or 5 */

	int autocommit;		/* auto-commit every query (SQL) */
	int trace;		/* Trace Mapi interaction */
	int blocked;		/* blocked mode */
	int error;		/* Error occurred */
	char *errorstr;		/* pointer to constant string */
	const char *action;	/* pointer to constant string */

	BlockCache blk;
	int connected;
	int active;		/* set when not all rows have been received */

	Mapi next;		/* circular list of Mapi's sharing streams */

	int cachelimit;		/* default maximum number of rows to cache */

	stream *tracelog;	/* keep a log for inspection */
	stream *from, *to;
} MapiStruct;

typedef struct MapiStatement {
	MapiStruct *mid;
	char *template;		/* keep parameterized query text around */
	char *query;
	int tableid;		/* SQL id of current result set */
	int fieldcnt;		/* the table report section */
	int rows_affected;	/* mostly unknown */
	int maxfields;
	MapiField *fields;
	int maxparams;
	MapiParam *params;
	MapiRowBuf cache;
} MapiStatement;

@h
typedef struct MapiStruct *Mapi;
typedef struct MapiStatement *MapiHdl;

@-
All external calls to the library should pass the mapi-check
routine. It assures a working connection and proper reset of
the error status of the Mapi structure.
@c
#define mapi_check(X,C)							\
	do {								\
		assert(X);						\
		if ((X)->connected == 0) {				\
			mapi_setError((X), "Connection lost", (C));	\
			return (X)->error;				\
		}							\
		mapi_clrError(X);					\
	} while (0)
#define mapi_check0(X,C)						\
	do {								\
		assert(X);						\
		if ((X)->connected == 0) {				\
			mapi_setError((X), "Connection lost", (C));	\
			return 0;					\
		}							\
		mapi_clrError(X);					\
	} while (0)
#define mapi_hdl_check(X,C)						\
	do {								\
		assert(X);						\
		assert((X)->mid);					\
		if ((X)->mid->connected == 0) {				\
			mapi_setError((X)->mid, "Connection lost", (C));\
			return (X)->mid->error;				\
		}							\
		mapi_clrError((X)->mid);				\
	} while (0)
#define mapi_hdl_check0(X,C)						\
	do {								\
		assert(X);						\
		assert((X)->mid);					\
		if ((X)->mid->connected == 0) {				\
			mapi_setError((X)->mid, "Connection lost", (C));\
			return 0;					\
		}							\
		mapi_clrError((X)->mid);				\
	} while (0)
@h
#ifdef __cplusplus
extern "C" {
#endif

#ifdef _MSC_VER
#ifndef LIBMAPI
#define mapi_export extern __declspec(dllimport)
#else
#define mapi_export extern __declspec(dllexport)
#endif
#else
#define mapi_export extern
#endif

/* three structures used for communicating date/time information */
/* these structs are deliberately compatible with the ODBC versions
  SQL_DATE_STRUCT, SQL_TIME_STRUCT, and SQL_TIMESTAMP_STRUCT */
typedef struct {		/* used by MAPI_DATE */
	short year;
	unsigned short month;
	unsigned short day;
} MapiDate;

typedef struct {		/* used by MAPI_TIME */
	unsigned short hour;
	unsigned short minute;
	unsigned short second;
} MapiTime;

typedef struct {		/* used by MAPI_DATETIME */
	short year;
	unsigned short month;
	unsigned short day;
	unsigned short hour;
	unsigned short minute;
	unsigned short second;
	unsigned int fraction;	/* in 1000 millionths of a second (10e-9) */
} MapiDateTime;

mapi_export MapiMsg mapi_bind(MapiHdl hdl, int fnr, char **ptr) ;
mapi_export MapiMsg mapi_bind_var(MapiHdl hdl, int fnr, int type, void *ptr) ;
mapi_export MapiMsg mapi_bind_numeric(MapiHdl hdl, int fnr, int scale,
	int precision, void *ptr) ;
mapi_export MapiMsg mapi_clear_bindings(MapiHdl hdl);
mapi_export MapiMsg mapi_param(MapiHdl hdl, int fnr, char **ptr);
mapi_export MapiMsg mapi_param_type(MapiHdl hdl, int fnr, int ctype, int sqltype, void *ptr);
mapi_export MapiMsg mapi_param_numeric(MapiHdl hdl, int fnr, int scale,
	int precision, void *ptr);
mapi_export MapiMsg mapi_param_string(MapiHdl hdl, int fnr, int sqltype, char *ptr, int *sizeptr);
mapi_export MapiMsg mapi_clear_params(MapiHdl hdl);
mapi_export Mapi mapi_mapi(const char *host, int port, const char *username,
	const char *password, const char *lang);
mapi_export Mapi mapi_connect(const char *host, int port, const char *username,
	const char *password, const char *lang);
mapi_export Mapi mapi_connect_ssl(const char *host, int port, const char *username,
	const char *password, const char *lang);
mapi_export Mapi mapi_dup(Mapi mid);
mapi_export MapiMsg mapi_reconnect(Mapi mid);
mapi_export MapiMsg mapi_close_handle(MapiHdl hdl);
mapi_export MapiMsg mapi_destroy(Mapi mid);
mapi_export MapiMsg mapi_disconnect(Mapi mid);
mapi_export MapiMsg mapi_error(Mapi mid);
mapi_export char *mapi_error_str(Mapi mid);
mapi_export MapiMsg mapi_finish(MapiHdl hdl);
mapi_export MapiMsg mapi_fetch_reset(MapiHdl hdl);
mapi_export MapiMsg mapi_explain(Mapi mid, FILE *fd);
mapi_export MapiMsg mapi_explain_query(MapiHdl hdl, FILE *fd);
mapi_export MapiHdl mapi_new_handle(Mapi mid);
mapi_export MapiMsg mapi_execute(MapiHdl hdl) ;
mapi_export MapiMsg mapi_execute_array(MapiHdl hdl, char **val) ;
mapi_export MapiMsg mapi_ping(Mapi mid);
mapi_export MapiHdl mapi_prepare(Mapi mid, const char *cmd);
mapi_export MapiMsg mapi_prepare_handle(MapiHdl hdl, const char *cmd);
mapi_export MapiHdl mapi_prepare_array(Mapi mid, const char *cmd, char **val);
mapi_export MapiHdl mapi_query(Mapi mid, const char *cmd);
mapi_export MapiMsg mapi_query_handle(MapiHdl hdl, const char *cmd);
mapi_export MapiHdl mapi_query_prep(Mapi mid);
mapi_export MapiMsg mapi_query_part(MapiHdl hdl, const char *cmd, size_t size);
mapi_export MapiMsg mapi_query_done(MapiHdl hdl);
mapi_export MapiHdl mapi_quick_query(Mapi mid, const char* cmd, FILE *fd);
mapi_export MapiHdl mapi_query_array(Mapi mid, const char *cmd, char **val);
mapi_export MapiHdl mapi_quick_query_array(Mapi mid, const char* cmd, char **val, FILE *fd);
mapi_export MapiHdl mapi_stream_query(Mapi mid, const char* cmd, int windowsize);
mapi_export MapiMsg mapi_setAutocommit(Mapi mid, int autocommit);
mapi_export MapiMsg mapi_cache_limit(Mapi mid,int limit);
mapi_export MapiMsg mapi_cache_shuffle(MapiHdl hdl,int percentage);
mapi_export MapiMsg mapi_cache_freeup(MapiHdl hdl,int percentage);
mapi_export MapiMsg mapi_quick_response(MapiHdl hdl, FILE *fd);
mapi_export MapiMsg mapi_seek_row(MapiHdl hdl, int rowne, int whence);
mapi_export MapiMsg mapi_trace(Mapi mid, int flag);
mapi_export MapiMsg mapi_trace_log(Mapi mid, const char *nme);

mapi_export int mapi_timeout(Mapi mid, int time);
mapi_export int mapi_fetch_row(MapiHdl hdl);
mapi_export int mapi_fetch_all_rows(MapiHdl hdl);
mapi_export int mapi_get_field_count(MapiHdl hdl);
mapi_export int mapi_get_row_count(MapiHdl hdl);
mapi_export int mapi_rows_affected(MapiHdl hdl);

mapi_export char *mapi_fetch_field(MapiHdl hdl, int fnr);
mapi_export MapiMsg mapi_store_field(MapiHdl hdl, int fnr, int outtype, void *outparam);
mapi_export char **mapi_fetch_field_array(MapiHdl hdl);
mapi_export char *mapi_fetch_line(MapiHdl hdl);
mapi_export char *mapi_get_lang(Mapi mid);
mapi_export char *mapi_get_dbname(Mapi mid);
mapi_export char *mapi_get_host(Mapi mid);
mapi_export char *mapi_get_user(Mapi mid);
mapi_export char *mapi_get_mapi_version(Mapi mid);
mapi_export char *mapi_get_monet_version(Mapi mid);
mapi_export int mapi_get_monet_versionId(Mapi mid);
mapi_export int mapi_is_blocked(Mapi mid);
mapi_export char *mapi_get_table(MapiHdl hdl,int fnr);
mapi_export char *mapi_get_name(MapiHdl hdl,int fnr);
mapi_export char *mapi_get_type(MapiHdl hdl,int fnr);
mapi_export char *mapi_quote(const char *msg, int size);
mapi_export char *mapi_unquote(char *msg);

mapi_export void mapi_setBlocking(int b);
#ifdef __cplusplus
}
#endif

#endif /* _MAPI_H_INCLUDED */
@
@+ Mapi functions.
The Monet application interface commands are described below.
They have been developed to ease interaction.

@c
static void promptMonet(Mapi mid);
static void mapi_cache_reset(MapiHdl hdl);
static Mapi mapi_new(void);
static void mapi_check_query(MapiHdl hdl);
static void mapi_extend_cache(MapiHdl hdl);
static MapiMsg mapi_get_row(MapiHdl hdl);
static int mapi_extend_fields(MapiHdl hdl, int minfields);
static int mapi_extend_params(MapiHdl hdl, int minparams);
static int mapi_slice_row(MapiHdl hdl);
static MapiMsg mapi_setError(Mapi mid, const char *msg, const char *action);
static char *mapi_fetch_line_internal(MapiHdl hdl);
static MapiMsg mapi_finish_internal(MapiHdl hdl);
static void mapi_lost_connection(Mapi mid);

#ifndef HAVE_GETLOGIN
#define getlogin() "win32"
#endif

#ifdef HAVE_OPENSSL
static SSL_CTX *mapi_ssl_ctx = 0;
#endif

static int mapi_initialized = 0;

/* code adapted from gdk.mx */
#ifdef HAVE_LONG_LONG
typedef unsigned long long mapi_uint64;
typedef long long mapi_int64;

#define LLFMT "%lld"		/* format to print a long long */
#define ULLFMT "%llu"		/* format to print a unsigned long long */
#else
#ifdef HAVE___INT64
typedef unsigned __int64 mapi_uint64;
typedef __int64 mapi_int64;

#define LLFMT "%I64d"		/* format to print a __int64 */
#define ULLFMT "%I64u"		/* format to print a unsigned __int64 */
#endif
#endif
/* define printf formats for printing size_t and ssize_t variables */
#if defined(__STDC_VERSION__) && __STDC_VERSION__ >= 199901
#define SZFMT "%zu"
#define SSZFMT "%zd"
#elif SIZEOF_SIZE_T == SIZEOF_INT
#define SZFMT "%u"
#define SSZFMT "%d"
#elif SIZEOF_SIZE_T == SIZEOF_LONG
#define SZFMT "%lu"
#define SSZFMT "%ld"
#elif SIZEOF_SIZE_T == SIZEOF_LONG_LONG
#define SZFMT ULLFMT
#define SSZFMT LLFMT
#elif SIZEOF_SIZE_T == SIZEOF___INT64
#define SZFMT ULLFMT
#define SSZFMT LLFMT
#else
#error no definition for SZFMT
#endif

#define check_stream(mid,s,msg,f,e)				\
	do {							\
		if ((s) == NULL || stream_errnr(s)) {		\
			mapi_lost_connection(mid);		\
			mapi_setError((mid), (msg), (f));	\
			return (e);				\
		}						\
	} while (0)
#define REALLOC(p,c)	((p) = ((p) ? realloc((p),(c)*sizeof(*(p))) : malloc((c)*sizeof(*(p)))))

@+ Blocking
The server side code works with a common/stream package, a fast buffered IO scheme.
However, this package is not always available for every language runtime system.
For those cases a simepl line-based protocol is also supported by the server.

To enable debugging in either blocked and line mode the user can set a global
variable before initiating a connection.
@c
static int blocked = 1;		/* the default */
void
mapi_setBlocking(int b)
{
	blocked = b != 0;
}

@+ Channel constructor
The first call of an application is to establish a connection with
an already server. The username and password are sent as part of
the initialization sequence.
Future versions may be allowed to set the username and will also
provide a secure socket layer support.

All routines called from outside the package should reset the
error flag of the Mapi structure. Internal calls are designated as such
if there may occur confusion on the status of the error flag.
@c
void
mapi_clrError(Mapi mid)
{
	if (mid->errorstr)
		free(mid->errorstr);
	mid->action = 0;	/* contains references to constants */
	mid->error = 0;
	mid->errorstr = 0;
}

MapiMsg
mapi_trace(Mapi mid, int flag)
{
	mapi_check(mid, "mapi_trace");
	mid->trace = flag;
	return MOK;
}

MapiMsg
mapi_trace_log(Mapi mid, const char *nme)
{
	mapi_check(mid, "mapi_trace_log");
	mid->tracelog = open_wastream(nme);
	if (mid->tracelog == NULL || stream_errnr(mid->tracelog)) {
		if (mid->tracelog)
			stream_destroy(mid->tracelog);
		mid->tracelog = NULL;
		return mapi_setError(mid, "Could not create log file",
				     "mapi_trace_log");
	}
	return MOK;
}

MapiMsg
mapi_ping(Mapi mid)
{
	mapi_check(mid, "mapi_ping");
	switch (mid->languageId) {
	case LANG_SQL:
		mapi_query(mid, "select true;");
		break;
	case LANG_MAL:
	case LANG_MIL:
		mapi_query(mid, "print(1);");
		break;
	}
	return mapi_error(mid);
}

MapiMsg
mapi_setAutocommit(Mapi mid, int autocommit)
{
	mapi_check(mid, "mapi_setAutocommit");
	mid->autocommit = autocommit;
	return MOK;
}

static MapiMsg
mapi_setError(Mapi mid, const char *msg, const char *action)
{
	assert(msg);
	REALLOC(mid->errorstr, strlen(msg) + 1);
	strcpy(mid->errorstr, msg);
	mid->error = MERROR;
	mid->action = action;
	return mid->error;
}

MapiHdl
mapi_new_handle(Mapi mid)
{
	MapiHdl hdl;

	if (mid == NULL)
		return NULL;

	hdl = malloc(sizeof(*hdl));
	assert(hdl);
	if (hdl == NULL) {
		mapi_setError(mid, "Memory allocation failure",
			      "mapi_new_handle");
		return NULL;
	}
	hdl->mid = mid;

	hdl->template = NULL;
	hdl->query = NULL;
	hdl->tableid = -1;

	hdl->rows_affected = 0;

	hdl->fieldcnt = 0;
	hdl->maxfields = 0;
	hdl->fields = NULL;

	hdl->maxparams = 0;
	hdl->params = NULL;

	hdl->cache.rowlimit = mid->cachelimit;
	hdl->cache.shuffle = 100;
	hdl->cache.limit = 0;
	hdl->cache.writer = 0;
	hdl->cache.reader = -1;
	hdl->cache.first = 0;
	hdl->cache.rows = NULL;
	hdl->cache.tuplecount = 0;
	hdl->cache.tupleindex = NULL;
	hdl->cache.tuplerev = NULL;
	hdl->cache.anchors = NULL;
	hdl->cache.fldcnt = NULL;

	return hdl;
}

MapiMsg
mapi_close_handle(MapiHdl hdl)
{
	if (hdl == NULL)
		return MERROR;
	if (hdl->tableid >= 0) {
		hdl->mid->active = 1;
		if (stream_printf(hdl->mid->to, "X" "close %d\n", hdl->tableid) < 0 ||
		    stream_flush(hdl->mid->to)) {
			mapi_lost_connection(hdl->mid);
			mapi_setError(hdl->mid, stream_error(hdl->mid->to), "mapi_close_handle");
		} else
			mapi_finish_internal(hdl);
		hdl->tableid = -1;
	}
	if (hdl->fields)
		free(hdl->fields);
	hdl->fields = NULL;
	hdl->maxfields = hdl->fieldcnt = 0;
	if (hdl->params)
		free(hdl->params);
	hdl->params = NULL;
	hdl->maxparams = 0;
	if (hdl->query)
		free(hdl->query);
	hdl->query = NULL;
	if (hdl->template)
		free(hdl->template);
	hdl->template = NULL;
	if (hdl->cache.rows) {
		int i;

		for (i = 0; i < hdl->cache.writer; i++)
			if (hdl->cache.rows[i])
				free(hdl->cache.rows[i]);
		free(hdl->cache.rows);
		hdl->cache.rows = NULL;
		if (hdl->cache.tupleindex)
			free(hdl->cache.tupleindex);
		hdl->cache.tupleindex = NULL;
		if (hdl->cache.tuplerev)
			free(hdl->cache.tuplerev);
		hdl->cache.tuplerev = NULL;
	}
	if (hdl->cache.anchors) {
		int i;

		for (i = 0; i < hdl->cache.writer; i++)
			if (hdl->cache.anchors[i])
				free(hdl->cache.anchors[i]);
		free(hdl->cache.anchors);
		hdl->cache.anchors = NULL;
	}
	if (hdl->cache.fldcnt)
		free(hdl->cache.fldcnt);
	hdl->cache.fldcnt = NULL;
	free(hdl);
	return MOK;
}

static Mapi
mapi_new(void)
{
	Mapi m;
	m = malloc(sizeof(*m));
	if (m == NULL)
		return NULL;
	assert(m);

	/* initialize everything to 0 */
	memset(m, 0, sizeof(*m));

	/* then fill in some details */
	m->next = m;		/* the shortest circular list possible */
	m->blocked = blocked;
	m->error = MOK;
	m->autocommit = 0;
	strcpy(m->hostname, "localhost");
#ifdef MONET5
	strcpy(m->language, "mal");
	m->languageId = LANG_MAL;
	m->versionId = 5;
#else
	strcpy(m->language, "mil");
	m->languageId = LANG_MIL;
	m->versionId = 4;
#endif
	strcpy(m->mapiversion, "mapi 1.0");
	strcpy(m->username, "anonymous");
	strcpy(m->password, "unknown");

	m->cachelimit = 1000;
	m->tracelog = NULL;
	m->blk.eos = 0;
	m->blk.buf = malloc(BLOCK + 1);
	m->blk.buf[BLOCK] = 0;
	m->blk.buf[0] = 0;
	m->blk.nxt = 0;
	m->blk.lim = BLOCK;
	return m;
}

MapiMsg
mapi_destroy(Mapi mid)
{
	if (mid->connected)
		(void) mapi_disconnect(mid);
	if (mid->blk.buf)
		free(mid->blk.buf);
	if (mid->errorstr)
		free(mid->errorstr);
	free(mid);
	return MOK;
}

Mapi
mapi_dup(Mapi mid)
{
	Mapi m;

	mapi_check0(mid, "mapi_dup");
	m = mapi_new();
	if (m == NULL)
		return NULL;
	/* link into circular list */
	m->next = mid->next;
	mid->next = m;

	/* copy relevant information */
	m->to = mid->to;
	m->from = mid->from;
	m->tracelog = mid->tracelog;
	strcpy(m->hostname, mid->hostname);
	strcpy(m->username, mid->username);
	strcpy(m->password, mid->password);
	m->port = mid->port;
	m->autocommit = mid->autocommit;
#ifdef HAVE_OPENSSL
	m->secure = mid->secure;
#endif
	return m;
}

Mapi
mapi_mapi(const char *host, int port, const char *username,
	  const char *password, const char *lang)
{
	Mapi mid;

	if (!mapi_initialized) {
		mapi_initialized = 1;
		if (stream_init() < 0)
			return NULL;
	}

	mid = mapi_new();
	if (mid == NULL)
		return NULL;

	if (host) {
		strncpy(mid->hostname, host, sizeof(mid->hostname) - 1);
		mid->hostname[sizeof(mid->hostname) - 1] = 0;
	} else
		strcpy(mid->hostname, "localhost");
	if (port == 0) {
		char *def;

		if ((def = getenv("MAPIPORT")) != NULL)
			port = atoi(def);
	}
	if (port == 0) {
#ifdef MONET5
		port = 50001;	/* hardwired default */
#else
		port = 50000;	/* hardwired default */
#endif
	}
	if (username) {
		strncpy(mid->username, username, sizeof(mid->username) - 1);
		mid->username[sizeof(mid->username) - 1] = 0;
	}
	if (password == 0)
		password = getlogin();
	if (password) {
		strncpy(mid->password, password, sizeof(mid->password) - 1);
		mid->password[sizeof(mid->password) - 1] = 0;
	}

	mid->port = port;
#ifdef HAVE_OPENSSL
	mid->secure = 0;
#endif

	if (lang == NULL) {
#ifdef MONET5
		lang = "mal";
#else
		lang = "mil";
#endif
	}
	strncpy(mid->language, lang, sizeof(mid->language) - 1);
	mid->language[sizeof(mid->language) - 1] = 0;

	if (strcmp(lang, "mil") == 0)
		mid->languageId = LANG_MIL;
	if (strcmp(lang, "mal") == 0)
		mid->languageId = LANG_MAL;
	if (strcmp(lang, "sql") == 0)
		mid->languageId = LANG_SQL;
	if (strcmp(lang, "xcore") == 0)
		mid->languageId = LANG_XCORE;
	if (strcmp(lang, "xquery") == 0)
		mid->languageId = LANG_XQUERY;

	return mid;
}

Mapi
mapi_connect(const char *host, int port, const char *username,
	     const char *password, const char *lang)
{
	Mapi mid;

	mid = mapi_mapi(host, port, username, password, lang);
	if (mid && mid->error == MOK)
		mapi_reconnect(mid);	/* actually, initial connect */
	return mid;
}

Mapi
mapi_connect_ssl(const char *host, int port, const char *username,
		 const char *password, const char *lang)
{
	Mapi mid = mapi_mapi(host, port, username, password, lang);

#ifdef HAVE_OPENSSL
	mid->secure = 1;
	if (mid && mid->error == MOK)
		mapi_reconnect(mid);	/* actually, initial connect */
#else
	mapi_setError(mid, "SSL connections not supported",
		      "mapi_connect_ssl");
#endif
	return mid;
}

@-
Once the start of the prompt string (\0001) has been recognized, the rest should
be eaten away. It is stored in the prompt buffer for possible subsequent display.
@c
MapiMsg
mapi_error(Mapi mid)
{
	assert(mid);
	return mid->error;
}

char *
mapi_error_str(Mapi mid)
{
	assert(mid);
	return mid->errorstr;
}

static void
promptMonet(Mapi mid)
{
	ptrdiff_t i = 0;
	char *s;

	assert(mid);
	if (mid->trace)
		printf("promptMonet:");
	s = strchr(mid->blk.buf + mid->blk.nxt, '\n');
	assert(s);
	*s = 0;
	i = s - (mid->blk.buf + mid->blk.nxt);
	mid->blk.nxt += i + 1;
	mid->active = 0;
	if (mid->trace)
		printf("prompt\n");
}

@
Disconnection from the server leads to removal of the
Mapi structure. Subsequent access may lead to a crash.
@c
static void
mapi_lost_connection(Mapi mid)
{
	/* TODO: decide what to do with dup'ed entries */
	mid->connected = 0;
	/* finish channels */
	/* Make sure that the read- (from-) stream is closed first,
	 * as the related write- (to-) stream closes the shared
	 * socket; see also src/common/stream.mx:socket_close .
	 */
	if (mid->from) {
		stream_close(mid->from);
		stream_destroy(mid->from);
		mid->from = 0;
	}
	if (mid->to) {
		stream_close(mid->to);
		stream_destroy(mid->to);
		mid->to = 0;
	}
}

MapiMsg
mapi_disconnect(Mapi mid)
{
	mapi_check(mid, "mapi_disconnect");
	/* only close streams if we're not in a linked list of Mapi's
	   sharing the streams */
	if (mid->next == mid) {
		/* only (last) element in circular list, so close streams */
		stream_close(mid->from);
		stream_destroy(mid->from);
		stream_close(mid->to);
		stream_destroy(mid->to);
	} else {
		/* remove from circular list */
		Mapi m;

		for (m = mid->next; m->next != mid; m = m->next)
			;
		m->next = mid->next;	/* take out of circular list */
		mid->next = mid;	/* circular list by itself */
	}
	mid->from = mid->to = NULL;
	mid->connected = 0;
	return MOK;
}

#ifdef HAVE_OPENSSL
static char *
ssl_error(int err, int ret)
{
	char *errstr;
	char buf[120];
	unsigned long e;

	switch (err) {
	case SSL_ERROR_ZERO_RETURN:
		errstr = "TLS/SSL connection has been closed";
		break;
	case SSL_ERROR_WANT_READ:
		errstr = "The operation did not complete (read)";
		break;
	case SSL_ERROR_WANT_WRITE:
		errstr = "The operation did not complete (write)";
		break;
	case SSL_ERROR_WANT_X509_LOOKUP:
		errstr = "The operation did not complete (X509 lookup)";
		break;
	case SSL_ERROR_WANT_CONNECT:
		errstr = "The operation did not complete (connect)";
		break;
	case SSL_ERROR_SYSCALL:
		e = ERR_get_error();
		if (e == 0) {
			if (ret == 0) {
				errstr = "EOF occurred in violation of protocol";
			} else if (ret == -1) {
				/* the underlying BIO reported an I/O error */
				errstr = "I/O error";
			} else {	/* possible? */
				errstr = "Some I/O error occurred";
			}
		} else {
			errstr = ERR_error_string(e, buf);
		}
		break;
	case SSL_ERROR_SSL:
		e = ERR_get_error();
		if (e != 0)
			errstr = ERR_error_string(e, buf);
		else {		/* possible? */
			errstr = "A failure in the SSL library occurred";
		}
		break;
	default:
		errstr = "Invalid error code";
	}
	return strdup(errstr);
}
#endif /* HAVE_OPENSSL */

MapiMsg
mapi_reconnect(Mapi mid)
{
	struct hostent *hp;
	struct sockaddr_in server;
	int s;
	char buf[BLOCK];
	size_t len;
	MapiHdl hdl;

#ifdef HAVE_OPENSSL
	SSL *ssl = NULL;
#endif

	hp = gethostbyname(mid->hostname);
	if (!hp) {
		return mapi_setError(mid, "gethostbyname failed",
				     "mapi_reconnect");
	}
	memset(&server, 0, sizeof(server));
	memcpy(&server.sin_addr, hp->h_addr, hp->h_length);

	server.sin_family = hp->h_addrtype;
	server.sin_port = htons((unsigned short) (mid->port & 0xFFFF));

#ifdef HAVE_OPENSSL
	if (mid->secure && mapi_ssl_ctx == NULL) {
		mapi_ssl_ctx = SSL_CTX_new(SSLv23_method());
		if (mapi_ssl_ctx == 0) {
			char *errstr = ssl_error(SSL_ERROR_SSL, 0);

			mapi_setError(mid, errstr, "mapi_reconnect");
			free(errstr);
			return mid->error;
		}
		SSL_CTX_set_verify(mapi_ssl_ctx, SSL_VERIFY_NONE, NULL);
	}
#endif
	s = socket(AF_INET, SOCK_STREAM, 0);
	if (s < 0) {
		return mapi_setError(mid, "Open socket failed",
				     "mapi_reconnect");
	}

	if (connect(s, (struct sockaddr *) &server, sizeof(server)) < 0) {
		perror("!ERROR mapi_reconnect: ");
		return mapi_setError(mid, "Setup connection failed",
				     "mapi_reconnect");
	}
#ifdef HAVE_OPENSSL
	if (mid->secure) {
		if ((ssl = SSL_new(mapi_ssl_ctx)) == 0) {
			char *errstr = ssl_error(SSL_ERROR_SSL, 0);

			mapi_setError(mid, errstr, "mapi_reconnect");
			free(errstr);
			close(s);
			return mid->error;
		}
		if (!SSL_set_fd(ssl, s)) {
			char *errstr = ssl_error(SSL_ERROR_SSL, 0);

			mapi_setError(mid, errstr, "mapi_reconnect");
			free(errstr);
			SSL_free(ssl);
			close(s);
			return mid->error;
		}
		SSL_set_connect_state(ssl);

		for (;;) {
			int ret, err;
			char *errstr;

			ret = SSL_connect(ssl);
			err = SSL_get_error(ssl, ret);
			switch (err) {
			case SSL_ERROR_WANT_READ:
			case SSL_ERROR_WANT_WRITE:
				/* try again */
				continue;
			case SSL_ERROR_NONE:
				/* successful connect */
				break;
			case SSL_ERROR_WANT_CONNECT:
			case SSL_ERROR_WANT_ACCEPT:
			case SSL_ERROR_WANT_X509_LOOKUP:
			default:
				/* some error occurred */
				SSL_free(ssl);
				close(s);
				errstr = ssl_error(err, ret);
				mapi_setError(mid, errstr, "mapi_reconnect");
				free(errstr);
				return mid->error;
			}
			break;
		}

		mid->to = ssl_wastream(ssl, "Mapi client write");
	} else
#endif
		mid->to = socket_wastream(s, "Mapi client write");
	check_stream(mid, mid->to, "Cannot open socket for writing",
		     "mapi_reconnect", mid->error);
	mid->connected = 1;

	if (mid->blocked) {
		snprintf(buf, BLOCK, "%s:%s:blocked\n", mid->username,
			 mid->password);
	} else {
		snprintf(buf, BLOCK, "%s:%s\n", mid->username, mid->password);
	}
	if (mid->trace) {
		printf("sending first request [%d]:%s", BLOCK, buf);
		fflush(stdout);
	}
	len = strlen(buf);
	stream_write(mid->to, buf, 1, len);
	check_stream(mid, mid->to, "Could not send initial byte sequence",
		     "mapi_reconnect", mid->error);
	stream_flush(mid->to);
	check_stream(mid, mid->to, "Could not send initial byte sequence",
		     "mapi_reconnect", mid->error);
	mid->active++;
	if (mid->blocked) {
		mid->to = stream_wstream(mid->to);
		check_stream(mid, mid->to, stream_error(mid->to),
			     "mapi_reconnect", mid->error);
		mid->to = block_stream(mid->to);
		check_stream(mid, mid->to, stream_error(mid->to),
			     "mapi_reconnect", mid->error);
	}
#ifdef HAVE_OPENSSL
	if (mid->secure) {
		if (mid->blocked) {
			mid->from = ssl_rstream(ssl, "Mapi client read");
			check_stream(mid, mid->from,
				     "Cannot open socket for reading",
				     "mapi_reconnect", mid->error);
			mid->from = block_stream(mid->from);
		} else {
			mid->from = ssl_rastream(ssl, "Mapi client read");
		}
	} else
#endif
	{
		if (mid->blocked) {
			mid->from = socket_rstream(s, "Mapi client read");
			check_stream(mid, mid->from,
				     "Cannot open socket for reading",
				     "mapi_reconnect", mid->error);
			mid->from = block_stream(mid->from);
		} else {
			mid->from = socket_rastream(s, "Mapi client read");
		}
	}
	check_stream(mid, mid->from, "Cannot open socket for reading",
		     "mapi_reconnect", mid->error);

	/* consume the welcome message from the server */
	hdl = mapi_new_handle(mid);
	while (mid->error == MOK && mid->active) {
		mapi_get_row(hdl);
		if (mapi_error(mid)) {
			mapi_explain(mid, stdout);
			break;
		}
		if (hdl->cache.rows)
			mid->versionId = strcmp("Mserver 5.0", hdl->cache.rows[0]) == 0 ? 5 : 4;
	}
	mapi_close_handle(hdl);

	if (mid->trace)
		printf("connection established\n");
	if (mid->languageId == LANG_MAL)
		return mid->error;

#ifdef MONET5
	/* start the scenario handler */
	snprintf(buf, BLOCK, "%s();", mid->language);
	if (mapi_error(mid))
		return mid->error;
	if (mid->trace)
		printf("send scenario initializer %s\n", buf);
	mapi_query(mid, buf);
#endif
	return mid->error;
}

@-
Binding placeholders and column names provide some convenience
for bulk interacting with a server.
@c
#define testField(hdl,fnr,funcname)					\
	do {								\
		mapi_hdl_check(hdl, funcname);				\
		if (fnr < 0) {						\
			return mapi_setError(hdl->mid,			\
					     "Illegal field number",	\
					     funcname);			\
		}							\
		/* make sure there is enough space */			\
		if (fnr >= hdl->maxfields)				\
			mapi_extend_fields(hdl, fnr);			\
		/* record how much we've actually used */		\
		if (fnr >= hdl->fieldcnt)				\
			hdl->fieldcnt = fnr + 1;			\
	} while (0)

#define testParam(hdl, fnr, funcname)					\
	do {								\
		mapi_hdl_check(hdl, funcname);				\
		if (fnr < 0) {						\
			return mapi_setError(hdl->mid,			\
					     "Illegal param number",	\
					     funcname);			\
		}							\
		if (fnr >= hdl->maxparams)				\
			mapi_extend_params(hdl, fnr);			\
	} while (0)

MapiMsg
mapi_bind(MapiHdl hdl, int fnr, char **ptr)
{
	testField(hdl, fnr, "mapi_bind");
	hdl->fields[fnr].outparam = ptr;
	hdl->fields[fnr].outtype = MAPI_AUTO;
	return MOK;
}

MapiMsg
mapi_bind_var(MapiHdl hdl, int fnr, int type, void *ptr)
{
	testField(hdl, fnr, "mapi_bind_var");
	hdl->fields[fnr].outparam = ptr;
	if (type >= 0 && type < MAPI_NUMERIC)
		hdl->fields[fnr].outtype = type;
	else
		return mapi_setError(hdl->mid, "Illegal SQL type identifier",
				     "mapi_bind_var");
	return MOK;
}

MapiMsg
mapi_bind_numeric(MapiHdl hdl, int fnr, int scale, int prec, void *ptr)
{
	if (mapi_bind_var(hdl, fnr, MAPI_NUMERIC, ptr))
		 return hdl->mid->error;
	hdl->fields[fnr].scale = scale;
	hdl->fields[fnr].precision = prec;
	return MOK;
}

MapiMsg
mapi_clear_bindings(MapiHdl hdl)
{
	if (hdl->fields)
		memset(hdl->fields, 0, hdl->maxfields * sizeof(*hdl->fields));
	return MOK;
}

MapiMsg
mapi_param_type(MapiHdl hdl, int fnr, int ctype, int sqltype, void *ptr)
{
	testParam(hdl, fnr, "mapi_param_type");
	hdl->params[fnr].inparam = ptr;
	if (ctype >= 0 && ctype < MAPI_NUMERIC)
		hdl->params[fnr].intype = ctype;
	else
		return mapi_setError(hdl->mid, "Illegal SQL type identifier",
				     "mapi_param_type");
	hdl->params[fnr].sizeptr = NULL;
	hdl->params[fnr].outtype = sqltype;
	hdl->params[fnr].scale = 0;
	hdl->params[fnr].precision = 0;
	return MOK;
}

MapiMsg
mapi_param_string(MapiHdl hdl, int fnr, int sqltype, char *ptr, int *sizeptr)
{
	testParam(hdl, fnr, "mapi_param_type");
	hdl->params[fnr].inparam = (void *) ptr;
	hdl->params[fnr].intype = MAPI_VARCHAR;
	hdl->params[fnr].sizeptr = sizeptr;
	hdl->params[fnr].outtype = sqltype;
	hdl->params[fnr].scale = 0;
	hdl->params[fnr].precision = 0;
	return MOK;
}

MapiMsg
mapi_param(MapiHdl hdl, int fnr, char **ptr)
{
	return mapi_param_type(hdl, fnr, MAPI_AUTO, MAPI_AUTO, ptr);
}

MapiMsg
mapi_param_numeric(MapiHdl hdl, int fnr, int scale, int prec, void *ptr)
{
	if (mapi_param_type(hdl, fnr, MAPI_NUMERIC, MAPI_NUMERIC, ptr))
		 return hdl->mid->error;
	hdl->params[fnr].scale = scale;
	hdl->params[fnr].precision = prec;
	return MOK;
}

MapiMsg
mapi_clear_params(MapiHdl hdl)
{
	if (hdl->params)
		memset(hdl->params, 0, hdl->maxparams * sizeof(*hdl->params));
	return MOK;
}

@-
The routine mapi_check ensures that no 'false' newlines are sent to the server,
because this may lead to a synchronization error easily.
@-
The query string could contain commentary lines, marked as starting
with a '#'. They should be silently removed.
Likewise for all end of line commentaries, provided '#' is not
part of a string literal.
@c
static void
mapi_check_query(MapiHdl hdl)
{
	char *c, bracket = 0, *comm = 0;

	assert(hdl->query);
	for (c = hdl->query; *c; c++) {
		if (*c == '\'' || *c == '"') {
			if (bracket == *c)
				bracket = 0;
			else if (bracket == 0)
				bracket = *c;
		}
		if (*c == '#' && bracket == 0) {
			comm = c;
			while (*c && *c != '\n')
				c++;
		}
		if (*c == '\n' && !hdl->mid->blocked) {
			mapi_setError(hdl->mid,
				      "Newline in query string not allowed",
				      "mapi_check_query");
			*c = ' ';
		}
	}
	if (comm) {
		/* remove comment and white space before comment start */
		while (--comm >= hdl->query && isspace((int) *comm))
			;
		*++comm = 0;
	}
}

MapiMsg
mapi_timeout(Mapi mid, int time)
{
	mapi_check(mid, "mapi_timeout");
	if (mid->trace)
		printf("Set timeout to %d\n", time);
	return mapi_setError(mid, "Operation not yet implemented",
			     "mapi_timeout");
}

@-
Watch out. The explanation routine should not clear the error status.
@c
MapiMsg
mapi_explain(Mapi mid, FILE *fd)
{
	assert(mid);
	fprintf(fd, "MAPI  = %s\@%s:%d\n", mid->username, mid->hostname,
		mid->port);
	if (mid->action)
		fprintf(fd, "ACTION= %s\n", mid->action);
	if (mid->error) {
		/* for multiline error messages, indent all subsequent
		   lines with the space it takes to print "ERROR = " */
		char *s, *p, *q;

		s = "ERROR = ";
		p = mid->errorstr;
		while (p && *p) {
			fprintf(fd, "%s", s);
			s = "        ";
			q = strchr(p, '\n');
			if (q) {
				q++;	/* also print the newline */
				fprintf(fd, "%.*s", (int) (q - p), p);
			} else {
				/* print bit after last newline,
				   adding one ourselves */
				fprintf(fd, "%s\n", p);
				break;	/* nothing more to do */
			}
			p = q;
		}
	}
	fflush(fd);
	mapi_clrError(mid);
	return MOK;
}

MapiMsg
mapi_explain_query(MapiHdl hdl, FILE *fd)
{
	Mapi mid;

	assert(hdl);
	mid = hdl->mid;
	assert(mid);
	fprintf(fd, "MAPI  = %s\@%s:%d\n", mid->username, mid->hostname,
		mid->port);
	if (mid->action)
		fprintf(fd, "ACTION= %s\n", mid->action);
	if (hdl->query) {
		if (strchr(hdl->query, '\n'))
			fprintf(fd, "QUERY = %s", hdl->query);
		else
			fprintf(fd, "QUERY = %s\n", hdl->query);
	}
	if (mid->error) {
		/* for multiline error messages, indent all subsequent
		   lines with the space it takes to print "ERROR = " */
		char *s, *p, *q;

		s = "ERROR = ";
		p = mid->errorstr;
		while (p && *p) {
			fprintf(fd, "%s", s);
			s = "        ";
			q = strchr(p, '\n');
			if (q) {
				q++;	/* also print the newline */
				fprintf(fd, "%.*s", (int) (q - p), p);
			} else {
				/* print bit after last newline,
				   adding one ourselves */
				fprintf(fd, "%s\n", p);
				break;	/* nothing more to do */
			}
			p = q;
		}
	}
	fflush(fd);
	mapi_clrError(mid);
	return MOK;
}

@-
The routine mapi_query is one of the most heavily used ones.
It sends a complete Monet statement for execution
(i.e., ending in a newline; possibly including additional newlines).
Interaction with the server is sped up using block based interaction.
The query is retained in the Mapi structure to repeat shipping.
@c
static MapiHdl
prepareQuery(MapiHdl hdl, const char *cmd)
{
	if (hdl && cmd) {
		size_t len = strlen(cmd);

		hdl->query = malloc(len + 1);
		assert(hdl->query);
		strcpy(hdl->query, cmd);
		if (strchr(cmd, PLACEHOLDER)) {
			hdl->template = malloc(len + 1);
			assert(hdl->template);
			strcpy(hdl->template, cmd);
		}
		mapi_check_query(hdl);
	}
	return hdl;
}

MapiHdl
mapi_prepare(Mapi mid, const char *cmd)
{
	mapi_check0(mid, "mapi_prepare");
	return prepareQuery(mapi_new_handle(mid), cmd);
}

MapiMsg
mapi_prepare_handle(MapiHdl hdl, const char *cmd)
{
	mapi_hdl_check(hdl, "mapi_prepare");
	if (hdl->tableid >= 0) {
		hdl->mid->active = 1;
		if (stream_printf(hdl->mid->to, "X" "close %d\n", hdl->tableid) < 0 ||
		    stream_flush(hdl->mid->to))
			check_stream(hdl->mid, hdl->mid->to, stream_error(hdl->mid->to), "mapi_prepare_handle", MERROR);
		hdl->tableid = -1;
		mapi_finish_internal(hdl);
	}
	prepareQuery(hdl, cmd);
	return hdl->mid->error;
}

static MapiMsg
mapi_prepare_array_internal(MapiHdl hdl, char **val)
{
	int i;

	for (i = 0; val[i]; i++) {
		if (i >= hdl->maxparams)
			mapi_extend_params(hdl, i + 1);
		hdl->params[i].inparam = val[i];
		hdl->params[i].intype = MAPI_AUTO;
		hdl->params[i].outtype = MAPI_AUTO;
		hdl->params[i].sizeptr = NULL;
		hdl->params[i].scale = 0;
		hdl->params[i].precision = 0;
	}
	return MOK;
}

MapiHdl
mapi_prepare_array(Mapi mid, const char *cmd, char **val)
{
	MapiHdl hdl;
	mapi_check0(mid, "mapi_prepare_array");
	hdl = prepareQuery(mapi_new_handle(mid), cmd);
	mapi_prepare_array_internal(hdl, val);
	return hdl;
}

@-
Building the query string using replacement of values require
some care not overfloating the space allocated.
@c
#define checkSpace(len)						\
	do {							\
		/* note: k==strlen(hdl->query) */		\
		if( k+len >= lim){				\
			lim = k + len + MAPIBLKSIZE;		\
			hdl->query= realloc(hdl->query, lim);	\
			assert(hdl->query);			\
		}						\
	} while (0)

static void
mapi_param_store(MapiHdl hdl)
{
	char *val, buf[MAPIBLKSIZE];
	char *p = hdl->template, *q;
	int i;
	size_t k;
	size_t lim;

	if (hdl->template == 0)
		return;

	lim = strlen(hdl->template) + MAPIBLKSIZE;
	REALLOC(hdl->query, lim);
	assert(hdl->query);
	hdl->query[0] = 0;
	k = 0;

	q = strchr(hdl->template, PLACEHOLDER);
	i = 0;
	/* loop invariant: k == strlen(hdl->query) */
	while (q && i < hdl->maxparams) {
		if (q > p && *(q - 1) == '\\') {
			q = strchr(q + 1, PLACEHOLDER);
			continue;
		}

		strncpy(hdl->query + k, p, q - p);
		k += q - p;
		hdl->query[k] = 0;

		if (hdl->params[i].inparam == 0) {
			hdl->query[k++] = PLACEHOLDER;
			hdl->query[k] = 0;
		} else {
			void *src = hdl->params[i].inparam;	/* abbrev */

			switch (hdl->params[i].intype) {
			case MAPI_TINY:
				checkSpace(5);
				sprintf(hdl->query + k, "%d",
					*(signed char *) src);
				break;
			case MAPI_UTINY:
				checkSpace(5);
				sprintf(hdl->query + k, "%u",
					*(unsigned char *) src);
				break;
			case MAPI_SHORT:
				checkSpace(10);
				sprintf(hdl->query + k, "%d", *(short *) src);
				break;
			case MAPI_USHORT:
				checkSpace(10);
				sprintf(hdl->query + k, "%u",
					*(unsigned short *) src);
				break;
			case MAPI_INT:
				checkSpace(20);
				sprintf(hdl->query + k, "%d", *(int *) src);
				break;
			case MAPI_UINT:
				checkSpace(20);
				sprintf(hdl->query + k, "%u",
					*(unsigned int *) src);
				break;
			case MAPI_LONG:
				checkSpace(20);
				sprintf(hdl->query + k, "%ld", *(long *) src);
				break;
			case MAPI_ULONG:
				checkSpace(20);
				sprintf(hdl->query + k, "%lu",
					*(unsigned long *) src);
				break;
			case MAPI_LONGLONG:
				checkSpace(30);
				sprintf(hdl->query + k, LLFMT,
					*(mapi_int64 *) src);
				break;
			case MAPI_ULONGLONG:
				checkSpace(30);
				sprintf(hdl->query + k, ULLFMT,
					*(mapi_uint64 *) src);
				break;
			case MAPI_FLOAT:
				checkSpace(30);
				sprintf(hdl->query + k, "%.9g",
					*(float *) src);
				break;
			case MAPI_DOUBLE:
				checkSpace(20);
				sprintf(hdl->query + k, "%.17g",
					*(double *) src);
				break;
			case MAPI_DATE:
				checkSpace(50);
				sprintf(hdl->query + k, "DATE '%04d-%02u-%02u'",
					((MapiDate *) src)->year,
					((MapiDate *) src)->month,
					((MapiDate *) src)->day);
				break;
			case MAPI_TIME:
				checkSpace(60);
				sprintf(hdl->query + k, "TIME '%02u:%02u:%02u'",
					((MapiTime *) src)->hour,
					((MapiTime *) src)->minute,
					((MapiTime *) src)->second);
				break;
			case MAPI_DATETIME:
				checkSpace(110);
				sprintf(hdl->query + k,
					"TIMESTAMP '%04d-%02u-%02u %02u:%02u:%02u.%09u'",
					((MapiDateTime *) src)->year,
					((MapiDateTime *) src)->month,
					((MapiDateTime *) src)->day,
					((MapiDateTime *) src)->hour,
					((MapiDateTime *) src)->minute,
					((MapiDateTime *) src)->second,
					((MapiDateTime *) src)->fraction);
				break;
			case MAPI_CHAR:
				buf[0] = *(char *) src;
				buf[1] = 0;
				val = mapi_quote(buf, 1);
				checkSpace(strlen(val));
				sprintf(hdl->query + k, "'%s'", val);
				free(val);
				break;
			case MAPI_VARCHAR:
				val = mapi_quote((char *) src, hdl->params[i].sizeptr ? *hdl->params[i].sizeptr : -1);
				checkSpace(strlen(val));
				sprintf(hdl->query + k, "'%s'", val);
				free(val);
				break;
			default:
				strcpy(hdl->query + k, src);
				break;
			}
			k += strlen(hdl->query + k);
		}

		i++;
		p = q + 1;
		q = strchr(p, PLACEHOLDER);
	}
	checkSpace(strlen(p));
	strcpy(hdl->query + k, p);
	if (hdl->mid->trace)
		printf("param_store: result=%s\n", hdl->query);
	return;
}

static MapiMsg
answer_lookahead(MapiHdl hdl)
{
	/* look ahead to detect errors */
	int oldrd;

	do {
		oldrd = hdl->cache.reader;
		do {
			mapi_get_row(hdl);
		} while (hdl->mid->error == MOK && hdl->mid->active &&
			 hdl->cache.writer + 1 < hdl->cache.limit);
		hdl->cache.reader = oldrd;
		if (hdl->mid->active)
			mapi_extend_cache(hdl);
	} while (hdl->mid->error == MOK && hdl->mid->active);
	if (hdl->mid->trace)
		printf("mapi_query return:%d\n", hdl->mid->error);
	return hdl->mid->error;
}

static MapiMsg
mapi_execute_internal(MapiHdl hdl)
{
	size_t size;
	char *cmd;
	Mapi mid;

	mapi_hdl_check(hdl, "mapi_execute");
	mid = hdl->mid;
	mapi_param_store(hdl);
	cmd = hdl->query;
	size = strlen(cmd) /* null byte */ ;

	mapi_cache_reset(hdl);
	if (mid->trace) {
		printf("mapi_query:" SZFMT ":%s\n", size, cmd);
	}
	if (mid->languageId == LANG_SQL) {
		/* indicate to server this is a SQL command */
		stream_write(mid->to, "S", 1, 1);
	}
	stream_write(mid->to, cmd, 1, size);
	check_stream(mid, mid->to, "write error on stream", "mapi_execute",
		     mid->error);
	/* all SQL statements should end with a semicolon */
	/* for the other languages it is assumed that the statements are correct */
	if (mid->languageId == LANG_SQL) {
		stream_write(mid->to, ";", 1, 1);
		check_stream(mid, mid->to, "write error on stream",
			     "mapi_execute", mid->error);
	}
	if (mid->languageId == LANG_SQL && mid->autocommit) {
		stream_write(mid->to, "commit;", 7, 1);
		check_stream(mid, mid->to, "write error on stream",
			     "mapi_execute", mid->error);
	}
	stream_write(mid->to, "\n", 1, 1);
	check_stream(mid, mid->to, "write error on stream",
		     "mapi_execute", mid->error);
	stream_flush(mid->to);
	check_stream(mid, mid->to, "write error on stream",
		     "mapi_execute", mid->error);
	return MOK;
}

MapiMsg
mapi_execute(MapiHdl hdl)
{
	int ret;

	mapi_hdl_check(hdl, "mapi_execute");
	ret = mapi_execute_internal(hdl);
	if (ret == MOK)
		ret = answer_lookahead(hdl);
	return ret;
}

MapiMsg
mapi_execute_array(MapiHdl hdl, char **val)
{
	int ret;

	mapi_hdl_check(hdl, "mapi_execute_array");
	ret = mapi_prepare_array_internal(hdl, val);
	return ret ? ret : mapi_execute_internal(hdl);
}

MapiHdl
mapi_query(Mapi mid, const char *cmd)
{
	int ret = MERROR;
	MapiHdl hdl;

	hdl = prepareQuery(mapi_new_handle(mid), cmd);
	ret = mid->error;
	if (ret == MOK)
		ret = mapi_execute_internal(hdl);
	if (ret == MOK)
		ret = answer_lookahead(hdl);
	return hdl;
}

MapiMsg
mapi_query_handle(MapiHdl hdl, const char *cmd)
{
	int ret = MERROR;

	if (hdl->tableid >= 0) {
		hdl->mid->active = 1;
		if (stream_printf(hdl->mid->to, "X" "close %d\n", hdl->tableid) < 0 ||
		    stream_flush(hdl->mid->to))
			check_stream(hdl->mid, hdl->mid->to, stream_error(hdl->mid->to), "mapi_query_handle", MERROR);
		hdl->tableid = -1;
		mapi_finish_internal(hdl);
	}
	prepareQuery(hdl, cmd);
	ret = hdl->mid->error;
	if (ret == MOK)
		ret = mapi_execute_internal(hdl);
	if (ret == MOK)
		ret = answer_lookahead(hdl);
	return ret;
}

MapiHdl
mapi_query_array(Mapi mid, const char *cmd, char **val)
{
	int ret = MERROR;
	MapiHdl hdl;

	hdl = prepareQuery(mapi_new_handle(mid), cmd);
	ret = hdl->mid->error;
	if (ret == MOK)
		ret = mapi_prepare_array_internal(hdl, val);
	if (ret == MOK)
		ret = mapi_execute_internal(hdl);
	if (ret == MOK)
		ret = answer_lookahead(hdl);
	return hdl;
}

MapiHdl
mapi_query_prep(Mapi mid) 
{
	int ret = MERROR;
	MapiHdl hdl;

	if (mid->languageId == LANG_SQL) {
		/* indicate to server this is a SQL command */
		stream_write(mid->to, "S", 1, 1);
	}
	hdl = prepareQuery(mapi_new_handle(mid), "large query");
	ret = mid->error;
	return hdl;
}

MapiMsg
mapi_query_part(MapiHdl hdl, const char *query, size_t size )
{
	Mapi mid;

	mapi_hdl_check(hdl, "mapi_execute");
	mid = hdl->mid;
	if (mid->trace) {
		printf("mapi_query:" SZFMT ":%s\n", size, query);
	}
	stream_write(mid->to, (char*)query, 1, size);
	check_stream(mid, mid->to, "write error on stream", "mapi_execute",
		     mid->error);

	check_stream(mid, mid->to, "write error on stream",
		     "mapi_execute", mid->error);
	return MOK;
}

MapiMsg
mapi_query_done( MapiHdl hdl )
{
	int ret;
	Mapi mid;

	mapi_hdl_check(hdl, "mapi_execute");
	mid = hdl->mid;
	stream_flush(mid->to);
	check_stream(mid, mid->to, "write error on stream",
		     "mapi_execute", mid->error);
	ret = mid->error;
	if (ret == MOK)
		ret = mapi_execute_internal(hdl);
	if (ret == MOK)
		ret = answer_lookahead(hdl);
	return ret;
}

@-
To speed up interaction with a terminal front-end,
the user can issue the quick_*() variants.
They will not analyse the result for errors or
header information, but simply through the output
received from the server to the stream indicated.
@c
MapiHdl
mapi_quick_query(Mapi mid, const char *cmd, FILE *fd)
{
	int ret = MERROR;
	MapiHdl hdl;

	mapi_check0(mid, "mapi_quick_query");
	hdl = prepareQuery(mapi_new_handle(mid), cmd);
	ret = hdl->mid->error;
	if (ret == MOK)
		ret = mapi_execute_internal(hdl);
	if (ret == MOK)
		ret = mapi_quick_response(hdl, fd);
	if (mid->trace)
		printf("mapi_quick_query return:%d\n", ret);
	return hdl;
}

MapiHdl
mapi_quick_query_array(Mapi mid, const char *cmd, char **val, FILE *fd)
{
	int ret = MERROR;
	MapiHdl hdl;

	mapi_check0(mid, "mapi_quick_query_array");
	hdl = prepareQuery(mapi_new_handle(mid), cmd);
	ret = hdl->mid->error;
	if (ret == MOK)
		ret = mapi_prepare_array_internal(hdl, val);
	if (ret == MOK)
		ret = mapi_execute_internal(hdl);
	if (ret == MOK) {
		/* look ahead to detect errors */
		ret = mapi_quick_response(hdl, fd);
	}
	if (mid->trace)
		printf("mapi_quick_query return:%d\n", ret);
	return hdl;
}

@-
Stream queries are requests to the database engine that produce a stream
of answers of indefinite length. Elements are eaten away using the normal way.
The stream ends upon encountering of the prompt.
A stream query can not rely on upfront caching.
The stream query also ensures that the cache contains a window
over the stream by shuffling tuples once it is filled.
@c
MapiHdl
mapi_stream_query(Mapi mid, const char *cmd, int windowsize)
{
	MapiHdl hdl;

	mapi_check0(mid, "mapi_stream_query");

	hdl = mapi_query(mid, cmd);
	if (hdl != NULL) {
		mapi_cache_reset(hdl);
		mapi_cache_limit(hdl->mid, windowsize);
		mapi_cache_shuffle(hdl, 100);
	}
	return hdl;
}
static void
mapi_cache_reset(MapiHdl hdl)
{
	int i;

	mapi_finish_internal(hdl);
	hdl->rows_affected = 0;
	hdl->fieldcnt = 0;
	hdl->mid->active = 1;
	for (i = 0; i < hdl->cache.writer; i++)
		if (hdl->cache.rows[i])
			hdl->cache.rows[i][0] = 0;
	if (hdl->cache.tupleindex)
		for (i = 0; i < hdl->cache.writer; i++)
			hdl->cache.tupleindex[i] = -1;
	if (hdl->cache.tuplerev)
		for (i = 0; i <= hdl->cache.writer; i++)
			hdl->cache.tuplerev[i] = -1;
	hdl->cache.tuplecount = 0;
	hdl->cache.reader = -1;
	hdl->cache.writer = 0;
	hdl->cache.first = 0;
	assert(hdl->cache.limit == 0 || hdl->cache.fldcnt != NULL);
	if (hdl->cache.fldcnt)
		memset(hdl->cache.fldcnt, 0, sizeof(*hdl->cache.fldcnt) * hdl->cache.limit);
}

MapiMsg
mapi_cache_limit(Mapi mid, int limit)
{
	/* clean out superflous space TODO */
	mapi_check(mid, "mapi_cache_limit");
	mid->cachelimit = limit;
/* 	if (hdl->cache.rowlimit < hdl->cache.limit) { */
		/* TODO: decide what to do here */
/* 		hdl->cache.limit = hdl->cache.rowlimit; *//* arbitrarily throw away cache lines */
/* 		if (hdl->cache.writer > hdl->cache.limit) { */
/* 			hdl->cache.writer = hdl->cache.limit; */
/* 			if (hdl->cache.reader > hdl->cache.writer) */
/* 				hdl->cache.reader = hdl->cache.writer; */
/* 		} */
/* 	} */
	if (mid->languageId == LANG_SQL) {
		MapiHdl hdl = mapi_new_handle(mid);
		if (stream_printf(mid->to, "X" "reply_size %d\n", limit) < 0 ||
		    stream_flush(mid->to))
			check_stream(mid, mid->to, stream_error(mid->to), "mapi_cache_limit", MERROR);
		mid->active = 1;
		mapi_finish_internal(hdl);
		mapi_close_handle(hdl);
	}
	return MOK;
}

MapiMsg
mapi_cache_shuffle(MapiHdl hdl, int percentage)
{
	/* clean out superflous space TODO */
	mapi_hdl_check(hdl, "mapi_cache_shuffle");
	if (percentage < 0 || percentage > 100) {
		return mapi_setError(hdl->mid, "Illegal percentage",
				     "mapi_cache_shuffle");
	}
	hdl->cache.shuffle = percentage;
	return MOK;
}

MapiMsg
mapi_fetch_reset(MapiHdl hdl)
{
	mapi_hdl_check(hdl, "mapi_fetch_reset");
	hdl->cache.reader = -1;
	return MOK;
}

MapiMsg
mapi_seek_row(MapiHdl hdl, int rownr, int whence)
{
	mapi_hdl_check(hdl, "mapi_seek_row");
	switch (whence) {
	case MAPI_SEEK_SET:
		break;
	case MAPI_SEEK_CUR:
		rownr += hdl->cache.tuplerev[hdl->cache.reader + 1];
		break;
	case MAPI_SEEK_END:
		rownr += hdl->rows_affected;
		break;
	default:
		return mapi_setError(hdl->mid, "Illegal whence value",
				     "mapi_seek_row");
	}
	if (rownr < 0 || rownr > hdl->rows_affected)
		return mapi_setError(hdl->mid, "Illegal row number",
				     "mapi_seek_row");
	if (hdl->cache.first <= rownr &&
	    rownr < hdl->cache.first + hdl->cache.tuplecount) {
		/* we've got the requested tuple in the cache */
		hdl->cache.reader = hdl->cache.tupleindex[rownr - hdl->cache.first] - 1;
	} else {
		/* we don't have the requested tuple in the cache
		   reset the cache and at the next fetch we'll get the data */
		if (mapi_cache_freeup(hdl, 100) == MOK) {
			hdl->cache.first = rownr;
		}
	}
	/* mapi_seek_row als fetches the seeked-to row */
	if (!hdl->mid->error)
		(void) mapi_fetch_row(hdl);

	return hdl->mid->error;
}

static MapiMsg
mapi_cache_freeup_internal(MapiHdl hdl, int k)
{
	int i;			/* just a counter */
	int n = 0;		/* # of tuples being deleted from front */

	hdl->cache.tuplecount = 0;
	for (i = 0; i < hdl->cache.writer - k; i++) {
		if (hdl->cache.rows[i]) {
			if (hdl->cache.rows[i][0] == '[')
				n++;
			free(hdl->cache.rows[i]);
		}
		hdl->cache.rows[i] = hdl->cache.rows[i + k];
		hdl->cache.rows[i + k] = 0;
		if (hdl->cache.anchors[i])
			free(hdl->cache.anchors[i]);
		hdl->cache.anchors[i] = hdl->cache.anchors[i + k];
		hdl->cache.anchors[i + k] = 0;
		hdl->cache.fldcnt[i] = hdl->cache.fldcnt[i + k];
		if (hdl->cache.rows[i] && hdl->cache.rows[i][0] == '[') {
			hdl->cache.tuplerev[i] = hdl->cache.tuplecount;
			hdl->cache.tupleindex[hdl->cache.tuplecount++] = i;
		}
	}
	/* after the previous loop, i == hdl->cache.writer - k, and
	   the last (hdl->cache.writer - k) cache entries have been
	   cleared already , so we don't need to go the Full Monty
	   here */
	for (/*i = hdl->cache.writer - k*/; i < k /*hdl->cache.writer*/; i++) {
		if (hdl->cache.rows[i]) {
			if (hdl->cache.rows[i][0] == '[')
				n++;
			free(hdl->cache.rows[i]);
		}
		hdl->cache.rows[i] = 0;
		if (hdl->cache.anchors[i])
			free(hdl->cache.anchors[i]);
		hdl->cache.anchors[i] = 0;
		hdl->cache.fldcnt[i] = 0;
	}
	hdl->cache.reader -= k;
	if (hdl->cache.reader < 0)
		hdl->cache.reader = -1;
	hdl->cache.writer -= k;
	if (hdl->cache.writer < 0) /* "cannot happen" */
		hdl->cache.writer = 0;
	hdl->cache.first += n;

	return MOK;
}

static void
mapi_extend_cache(MapiHdl hdl)
{
	int incr, newsize, oldsize = hdl->cache.limit, i;

	/* extend row cache */
	if (oldsize == 0)
		incr = 1000;
	else
		incr = oldsize * 2;
	if (incr > 200000)
		incr = 20000;
	newsize = oldsize + incr;
	if (hdl->cache.rowlimit > 0 && newsize > hdl->cache.rowlimit) {
		newsize = hdl->cache.rowlimit;
		incr = newsize - oldsize;
		if (incr <= 0) {
			if (hdl->cache.reader >= 0) {
				/* flush all read entries */
				mapi_cache_freeup_internal(hdl, hdl->cache.reader + 1);
				/* since we've made space, we can return */
				return;
			}
			/* not enough space, so increase limit */
			hdl->cache.rowlimit += 100;
			mapi_extend_cache(hdl);	/* try again */
			return;
		}
	}

	REALLOC(hdl->cache.rows, newsize);
	assert(hdl->cache.rows);
	memset(hdl->cache.rows + oldsize, 0, incr * sizeof(*hdl->cache.rows));

	REALLOC(hdl->cache.tupleindex, newsize);
	assert(hdl->cache.tupleindex);
	for (i = oldsize; i < newsize; i++)
		hdl->cache.tupleindex[i] = -1;

	REALLOC(hdl->cache.tuplerev, newsize + 1);
	assert(hdl->cache.tuplerev);
	for (i = oldsize; i <= newsize; i++)
		hdl->cache.tuplerev[i] = -1;

	REALLOC(hdl->cache.anchors, newsize);
	assert(hdl->cache.anchors);
	memset(hdl->cache.anchors + oldsize, 0, incr * sizeof(*hdl->cache.anchors));

	REALLOC(hdl->cache.fldcnt, newsize);
	assert(hdl->cache.fldcnt);
	memset(hdl->cache.fldcnt + oldsize, 0, incr * sizeof(*hdl->cache.fldcnt));

	hdl->cache.limit = newsize;
}

/* Make space in the cache for new tuples, ignore the read pointer */
MapiMsg
mapi_cache_freeup(MapiHdl hdl, int percentage)
{
	int k;			/* # of cache lines to be deleted from front */

	if (hdl->cache.writer == 0 && hdl->cache.reader == -1)
		return MOK;
	if (percentage < 0 || percentage > 100)
		percentage = 100;
	k = (hdl->cache.writer * percentage) / 100;
	if (k < 1)
		k = 1;
	return mapi_cache_freeup_internal(hdl, k);
}

@-
The routine mapi_fetch_line forms the basic interaction with the server.
It simply retrieves the next line and stores it in the row cache.
The field anchor structure is prepared for subsequent use by
mapi_fetch_row.
The content received is analysed further by mapi_getRow()

@c
char *
mapi_fetch_line_internal(MapiHdl hdl)
{
	char *reply, *s;
	ssize_t k;
	Mapi mid;

	if (hdl->cache.writer > 0 && hdl->cache.reader + 1 < hdl->cache.writer)
		return hdl->cache.rows[++hdl->cache.reader];

	mid = hdl->mid;
	if (!mid->active)
		return 0;
	/* get rid of old buffer space */
	if (hdl->cache.rowlimit > 0 &&
	    hdl->cache.writer >= hdl->cache.rowlimit)
		mapi_extend_cache(hdl);

	/* check if you need to read more blocks to get a new line */
	mid->blk.eos = 0;
	while (!strchr(mid->blk.buf + mid->blk.nxt, '\n') && mid->blk.eos == 0) {
		char *newbuf;
		ssize_t len;
		int rest, n;

		s = strchr(mid->blk.buf + mid->blk.nxt, '\0');
		assert(s);
		n = s - mid->blk.buf;

		if (mid->blk.lim - n < BLOCK) {
			int len;

			rest = n - mid->blk.nxt;
			len = mid->blk.lim;
			if (mid->blk.nxt <= BLOCK) {
				/* extend space */
				len += BLOCK;
			}
			newbuf = malloc(len + 1);
			memcpy(newbuf, mid->blk.buf + mid->blk.nxt, rest + 1);
			if (mid->blk.buf)
				free(mid->blk.buf);
			mid->blk.buf = newbuf;
			mid->blk.nxt = 0;
			mid->blk.lim = len;
			n = rest;
		}

		if (mid->blocked) {
			/* fetch one more block */
			if (mid->trace)
				printf("fetch next block: start at:%d\n", n);
			len = stream_read(mid->from, mid->blk.buf + n, 1, BLOCK);
			check_stream(mid, mid->from, "Connection terminated",
				     "mapi_fetch_line", (mid->blk.eos = 1, (char *) 0));
			mid->blk.buf[n + len] = 0;
			if (mid->trace) {
				printf("got next block: length:" SSZFMT "\n",
				       len);
				printf("text:%s\n", mid->blk.buf + n);
			}
		} else {
			/* fetch one more line */
			len = 0;
			s = mid->blk.buf + n;
			while ((k = stream_read(mid->from, s, 1, 1)) == 1) {
				len++;
				if (*s == '\n')
					break;
				s++;
				if (s == mid->blk.buf + mid->blk.lim)
					break;
			}
			check_stream(mid, mid->from, "Connection terminated",
				     "mapi_fetch_line", (mid->blk.eos = 1, (char *) 0));
			mid->blk.buf[n + len] = 0;
		}
	}
	if (mid->trace) {
		printf("got complete block: \n");
		printf("text:%s\n", mid->blk.buf + mid->blk.nxt);
	}
	if (mid->blk.buf[mid->blk.nxt] == PROMPTBEG) {
		promptMonet(mid);
		return 0;
	}
	/* we have a complete line in the buffer */
	s = strchr(mid->blk.buf + mid->blk.nxt, '\n');
	assert(s);
	*s++ = 0;
	k = s - (mid->blk.buf + mid->blk.nxt);	/* strlen(mid->blk.buf + mid->blk.nxt) + 1 */
	reply = malloc(k);
	assert(reply);
	strcpy(reply, mid->blk.buf + mid->blk.nxt);
	mid->blk.nxt += k;

	/* manage the row cache space first */
	if (hdl->cache.writer >= hdl->cache.limit)
		mapi_extend_cache(hdl);

	hdl->cache.rows[hdl->cache.writer] = reply;
	hdl->cache.tuplerev[hdl->cache.writer] = hdl->cache.tuplecount;
	hdl->cache.tuplerev[hdl->cache.writer + 1] = hdl->cache.tuplecount + 1;
	if (*reply == '[') {
		hdl->cache.tupleindex[hdl->cache.tuplecount++] = hdl->cache.writer;
		if (hdl->rows_affected < hdl->cache.first + hdl->cache.tuplecount)
			hdl->rows_affected = hdl->cache.first + hdl->cache.tuplecount;
	}
	hdl->cache.writer++;
	if (mid->trace)
		printf("mapi_fetch_line:%s\n", reply);
	return hdl->cache.rows[++hdl->cache.reader];
}

char *
mapi_fetch_line(MapiHdl hdl)
{
	char *reply;

	mapi_hdl_check0(hdl, "mapi_fetch_line");
	reply = mapi_fetch_line_internal(hdl);
	if (reply == NULL && hdl->mid->languageId == LANG_SQL &&
	    !hdl->mid->active && hdl->rows_affected > 0 &&
	    hdl->cache.first + hdl->cache.tuplecount < hdl->rows_affected) {
		hdl->mid->active = 1;
		if (stream_printf(hdl->mid->to, "X" "export %d %d\n", hdl->tableid, hdl->cache.first + hdl->cache.tuplecount) < 0 ||
		    stream_flush(hdl->mid->to))
			check_stream(hdl->mid, hdl->mid->to, stream_error(hdl->mid->to), "mapi_fetch_line", NULL);
		answer_lookahead(hdl);
		reply = mapi_fetch_line_internal(hdl);
	}
	return reply;
}

@-
To synchronize on a prompt, the low level routine mapi_finish can be used.
It disgards all output received.
@c
MapiMsg
mapi_finish_internal(MapiHdl hdl)
{
	mapi_hdl_check(hdl, "mapi_finish");
	if (hdl->mid->active)
		while (mapi_fetch_line_internal(hdl) != (char *) 0)
			;
	return hdl->mid->error;
}

MapiMsg
mapi_finish(MapiHdl hdl)
{
	mapi_hdl_check(hdl, "mapi_finish");
	return mapi_finish_internal(hdl);
}

@-
If the answer to a query should be simply passed on towards a client,
i.e. a stream, it pays to use the mapi_quick_response() routine.
The stream is only checked for occurrence of an error indicator
and the prompt.
The best way to use this shortcut execution is calling
mapi_quick_query(), otherwise we are forced to first
empy the row cache.

@c
#define handlePart(sz)							\
	do {								\
		s= strchr(mid->blk.buf+mid->blk.nxt,PROMPTBEG);		\
		if( s){							\
			ptrdiff_t len = s-mid->blk.buf;			\
			fwrite(mid->blk.buf+mid->blk.nxt,1,len,fd);	\
			mid->blk.nxt += len;				\
			promptMonet(mid);				\
			return MOK;					\
		} else if( sz > 0) {					\
			fwrite(mid->blk.buf+mid->blk.nxt,1,sz,fd);	\
			mid->blk.nxt=0;					\
		}							\
		if(ferror(fd))						\
			return mapi_setError(mid, "Error writing file",	\
					     "mapi.response");		\
	} while (0)

MapiMsg
mapi_quick_response(MapiHdl hdl, FILE *fd)
{
	char *s;
	int i;
	ssize_t k;
	Mapi mid;

	mid = hdl->mid;
	mapi_check(mid, "mapi_quick_response");
	if (fd == 0)
		return mapi_setError(mid, "Destination file missing",
				     "mapi.response");

	/* any left over rows in the cache? */
	for (i = hdl->cache.reader + 1; i < hdl->cache.writer; i++)
		fprintf(fd, "%s\n", hdl->cache.rows[i]);
	if (mid->active == 0)
		return 0;

	/* check if you need to send pending information */
	k = strlen(mid->blk.buf + mid->blk.nxt);
	handlePart(k);

	mid->blk.eos = 0;
	mid->blk.nxt = 0;
	if (mid->blocked) {
		while ((k = stream_read(mid->from, mid->blk.buf, 1, BLOCK)) > 0)
			handlePart(k);
		check_stream(mid, mid->from, "Connection terminated",
			     "mapi_quick_response", mid->error);
	} else {
		/* read until we find the prompt */
		s = mid->blk.buf;
		while ((k = stream_read(mid->from, s, 1, 1)) == 1) {
			fwrite(s, 1, 1, fd);
			if (*s == PROMPTBEG) {
				s++;
				break;
			}
		}
		check_stream(mid, mid->from, "Connection terminated",
			     "mapi_quick_response", mid->error);
		if (k == 1) {
			while (stream_read(mid->from, s, 1, 1) == 1) {
				k++;
				if (*s == '\n') {
					*(s + 1) = 0;
					break;
				}
				s++;
				if (s == mid->blk.buf + mid->blk.lim)
					break;
			}
			check_stream(mid, mid->from, "Connection terminated",
				     "mapi_quick_response", mid->error);
		}
	}

	if (k > 0) {
		handlePart(k);
	}
	mapi_fetch_line_internal(hdl);	/* get rid of prompt possibly */
	return mid->error;
}

@-
The routine mapi_get_row retrieves lines from the channel until
it finds either a valid row, or encounters an error.
In passing, it interprets comment lines to detect table headers.
It returns with 0 upon encountering the prompt
(MOK) or an error. The row cache buffer is extended until the limit
is reached.

TODO, header line does not appear in cache, reuse of old line is erroneous
@c
static void
mapi_header(MapiHdl hdl, char *line)
{
	char *tag = "", *c, *etag;
	char *buf;
	int i, cr = hdl->cache.reader;

	if (hdl->mid->trace)
		printf("mapi_header:%s\n", line);
	etag = c = strrchr(line, '#');
	if (c == 0 || c == line)
		return;

@-
After a header analysis, we should have restored the original line,
because the client may wish to perform a mapi_fetch_line();
@c
#define keepProp(name, attr)						\
	do {								\
		if (strcmp(name, tag) == 0) {				\
			char *fld;					\
									\
			i = 0;						\
			while ((fld = mapi_fetch_field(hdl, i)) != NULL) { \
				strncpy(hdl->fields[i].attr, fld,	\
					sizeof(hdl->fields[i].attr) - 1); \
				hdl->fields[i].attr[sizeof(hdl->fields[i].attr) - 1] = 0; \
				if (hdl->mid->trace)			\
					printf("got %s %s\n", name, fld); \
				i++;					\
			}						\
			mapi_clrError(hdl->mid);			\
			if (hdl->cache.fldcnt[hdl->cache.reader] < i)	\
				hdl->cache.fldcnt[hdl->cache.reader] = i; \
			if (hdl->fieldcnt < i)				\
				hdl->fieldcnt = i;			\
		}							\
	} while (0)

	buf = strdup(hdl->cache.rows[cr]);
	mapi_slice_row(hdl);

	*line = '[';		/* fake a value row */
	*c = ']';
	c++;
	while (*c && isspace((int) *c))
		c++;
	if (*c)
		tag = c;

	keepProp("name", columnname);
	keepProp("type", columntype);
	if (strcmp("tuplecount", tag) == 0) {
		char *fld;

		if ((fld = mapi_fetch_field(hdl, 0)) != NULL) {
			hdl->rows_affected = atoi(fld);
			if (hdl->mid->trace)
				printf("got tuplecount %d\n",
				       hdl->rows_affected);
		}
		mapi_clrError(hdl->mid);
	}
	if (strcmp("id", tag) == 0) {
		char *fld;

		if ((fld = mapi_fetch_field(hdl, 0)) != NULL) {
			hdl->tableid = atoi(fld);
			if (hdl->mid->trace)
				printf("got id %d\n", hdl->tableid);
		}
		mapi_clrError(hdl->mid);
	}
	/* restore the markers */
	*line = '#';
	*etag = '#';
	strcpy(hdl->cache.rows[cr], buf);
	for (i = 0; i < hdl->cache.fldcnt[hdl->cache.reader]; i++)
		hdl->cache.anchors[cr][i] = 0;
	hdl->cache.fldcnt[cr] = 0;
	free(buf);
}

static MapiMsg
mapi_get_row(MapiHdl hdl)
{
	char *reply = 0;
	Mapi mid = hdl->mid;

	while (mid->active || hdl->cache.reader + 1 < hdl->cache.writer) {
		reply = mapi_fetch_line_internal(hdl);
		if (reply == 0)
			return MERROR;

		switch (reply[0]) {
		case '#':
			if (!(mid->languageId >= LANG_SQL && reply[1] == '(')) {
				mapi_header(hdl, reply);
				break;
			}
		case '!':
		{
			/* concatenate the error messages */
			size_t size = mid->errorstr ? strlen(mid->errorstr) : 0;

			mid->error = MERROR;
			mid->action = "mapi_get_row";
			REALLOC(mid->errorstr, size + strlen(reply) + 2);
			strcpy(mid->errorstr + size, reply);
			strcat(mid->errorstr + size, "\n");
		}
			break;
		default:
			return MOK;
		}
	}
	return MERROR;
}

@-
Unquoting of a string is done in place. It returns the start
of the unquoted part section.
@c
/* msg is a string consisting comma-separated values.  The list of
   values is terminated by ] or by the end-of-string NULL byte.
   Values can be quoted strings or unquoted values.  Upon return,
   *start points to the start of the first value which is stripped of
   leading and trailing white space, and if it was a quoted string,
   also of the quotes.  Also, backslash-escaped characters in the
   quoted string are replaced by the values the escapes represent.
   *next points to either the start of the next value (i.e. after the
   separating comma, possibly to the leading white space of the next
   value), or to the trailing ] or NULL byte if this was the last
   value.
   msg is *not* a const string: it is altered by this function.
*/
static void
unquote(char *msg, char **start, char **next)
{
	char *p = msg, *s;
	char quote;

	/* first skip over leading white space */
	while (*p && isspace((int) *p))
		p++;
	quote = *p;
	if (quote == '\'' || quote == '"') {
		/* get quoted string and remove trailing bracket first */
		p++;
		*start = p;
		s = p;
		while (*p && *p != quote) {
			if (*p == '\\') {
				p++;
				switch (*p) {
				/* later
				   case '0': case '1': case '2': case '3': case '4':
				   case '5': case '6': case '7': case '8': case '9':
				 */
				case 'n':
					*s = '\n';
					break;
				case 't':
					*s = '\t';
					break;
				case 'r':
					*s = '\r';
					break;
				case 'f':
					*s = '\f';
					break;
				default:
					*s = *p;
					break;
				}
				p++;
			} else {
				*s = *p++;
			}
			s++;
		}
		*p++ = 0;	/* end-of-string quote */
		/* skip over trailing junk (presumably white space) */
		while (*p && *p != ',' && *p != ']')
			p++;
		if (*p == ',')
			p++;
	} else {
		/* p points at first non-white space character */
		*start = p;	/* record start of value */
		/* find separator or terminator */
		while (*p && *p != ',' && *p != ']')
			p++;
		/* search back over trailing white space */
		for (s = p - 1; s > *start && isspace((int) *s); s--)
			;
		if (s < *start || !isspace((int) *s))	/* gone one too far */
			s++;
		if (*p == ',') {
			/* there is more to come; skip over separator */
			p++;
		}
		/* make sure value is NULL terminated */
		/* If the value is the last one before ] and there is
		   no trailing white space, s points to the ']' which
		   now gets squashed.  However in this case p==s, so
		   *p will be 0 as well, and thus **next will be 0,
		   terminating the loop in our caller. */
		*s = 0;
	}
	*next = p;
}

@-
The (un)quote routines should use dynamic storage.
@c
char *
mapi_unquote(char *msg)
{
	char *start, *next;
	size_t size;

	unquote(msg, &start, &next);
	size = strlen(start);
	next = malloc(size + 1);
	strcpy(next, start);
	return next;
}

char *
mapi_quote(const char *msg, int size)
{
	char *s = malloc(strlen(msg) * 2 + 1);	/* we absolutely don't need more than this (until we start producing octal escapes */
	char *t = s;

	/* the condition is tricky: if initially size < 0, we must
	   continue until a NULL byte, else, size gives the number of
	   bytes to be copied */
	while (size < 0 ? *msg : size > 0) {
		if (size > 0)
			size--;
		switch (*msg) {
		case '\n':
			*t++ = '\\';
			*t++ = 'n';
			break;
		case '\t':
			*t++ = '\\';
			*t++ = 't';
			break;
		case PLACEHOLDER:
			*t++ = '\\';
			*t++ = PLACEHOLDER;
			break;
		case '\\':
			*t++ = '\\';
			*t++ = '\\';
			break;
		case '\0':
			*t++ = '\\';
			*t++ = '0';
			break;
		default:
			*t++ = *msg;
			break;
		}
		msg++;
		/* also deal with binaries */
	}
	*t = 0;
	return s;
}

@-
The low level routine mapi_slice_row breaks the last row received into pieces
and binds the field descriptors with their location. All escaped characters
are immediately replaced, such that we end with a list of C-strings.
It overwrites the contents of the row buffer, because de-escaping
only reduces the size.
It also silently extends the field descriptor table.
@c
@= extend
static int
mapi_extend_@1(MapiHdl hdl, int min@1)
{
	/* extend the @1 table */
	int nm = hdl->max@1 + 32;

	if (nm <= min@1)
		 nm = min@1 + 32;
	REALLOC(hdl->@1, nm);
	assert(hdl->@1);
	/* clear new entries */
	memset(hdl->@1 + hdl->max@1, 0, (nm - hdl->max@1) * sizeof(*hdl->@1));
	hdl->max@1 = nm;
	return MOK;
}
@c
@:extend(fields)@
@:extend(params)@

static void
mapi_extend_anchor(MapiHdl hdl)
{
	int cr = hdl->cache.reader;
	char **ac = hdl->cache.anchors[cr];

	if (ac == 0 || hdl->maxfields > hdl->cache.fldcnt[cr]) {
		REALLOC(hdl->cache.anchors[cr], hdl->maxfields);
		if (ac) {
			/* implies hdl->maxfields > hdl->cache.fldcnt[cr] */
			memset(hdl->cache.anchors[cr] + hdl->cache.fldcnt[cr],
			       0,
			       sizeof(*hdl->cache.anchors[cr]) * (hdl->maxfields - hdl->cache.fldcnt[cr]));
		}
	}
}
@-
The values of a row are delivered to any bounded variable before
fetch_row returns. Automatic conversion based on common types
simplifies the work for the programmers.
@c
#if HAVE_STRTOF && !HAVE_DECL_STRTOF
extern float strtof(const char *, char **);
#endif

MapiMsg
mapi_store_field(MapiHdl hdl, int fnr, int outtype, void *dst)
{
	int cr;
	char *val;

	mapi_hdl_check(hdl, "mapi_store_field");

	if (fnr < 0 || fnr >= hdl->fieldcnt) {
		return mapi_setError(hdl->mid, "Illegal field number",
				     "mapi_store_field");
	}

	cr = hdl->cache.reader;
	val = hdl->cache.anchors[cr][fnr];

	if (val == 0) {
		return mapi_setError(hdl->mid, "Field value undefined",
				     "mapi_store_field");
	}

	if (strcmp(val, "nil") == 0)
		return mapi_setError(hdl->mid, "Field value is nil",
				     "mapi_store_field");

	/* auto convert to C-type */
	switch (outtype) {
	case MAPI_TINY:
		*(signed char *) dst = (signed char) strtol(val, NULL, 0);
		break;
	case MAPI_UTINY:
		*(unsigned char *) dst = (unsigned char) strtoul(val, NULL, 0);
		break;
	case MAPI_SHORT:
		*(short *) dst = (short) strtol(val, NULL, 0);
		break;
	case MAPI_USHORT:
		*(unsigned short *) dst = (unsigned short) strtoul(val, NULL, 0);
		break;
	case MAPI_NUMERIC:
	case MAPI_INT:
		*(int *) dst = (int) strtol(val, NULL, 0);
		break;
	case MAPI_UINT:
		*(unsigned int *) dst = (unsigned int) strtoul(val, NULL, 0);
		break;
	case MAPI_LONG:
		*(long *) dst = strtol(val, NULL, 0);
		break;
	case MAPI_ULONG:
		*(unsigned long *) dst = strtoul(val, NULL, 0);
		break;
#ifdef HAVE_STRTOLL
	case MAPI_LONGLONG:
		*(mapi_int64 *) dst = strtoll(val, NULL, 0);
		break;
#endif
#ifdef HAVE_STRTOULL
	case MAPI_ULONGLONG:
		*(mapi_uint64 *) dst = strtoull(val, NULL, 0);
		break;
#endif
	case MAPI_CHAR:
		*(char *) dst = *val;
		break;
#ifdef HAVE_STRTOF
	case MAPI_FLOAT:
		*(float *) dst = strtof(val, NULL);
		break;
#endif
#ifdef HAVE_STRTOD
	case MAPI_DOUBLE:
		*(double *) dst = strtod(val, NULL);
		break;
#endif
	case MAPI_DATE:
		sscanf(val, "%hd-%hu-%hu",
		       &((MapiDate *) dst)->year,
		       &((MapiDate *) dst)->month,
		       &((MapiDate *) dst)->day);
		break;
	case MAPI_TIME:
		sscanf(val, "%hu:%hu:%hu",
		       &((MapiTime *) dst)->hour,
		       &((MapiTime *) dst)->minute,
		       &((MapiTime *) dst)->second);
		break;
	case MAPI_DATETIME: {
		int n;

		((MapiDateTime *) dst)->fraction = 0;
		sscanf(val, "%hd-%hu-%hu %hu:%hu:%hu%n",
		       &((MapiDateTime *) dst)->year,
		       &((MapiDateTime *) dst)->month,
		       &((MapiDateTime *) dst)->day,
		       &((MapiDateTime *) dst)->hour,
		       &((MapiDateTime *) dst)->minute,
		       &((MapiDateTime *) dst)->second,
		       &n);
		if (val[n] == '.') {
			unsigned int fac = 1000000000;
			unsigned int nsec = 0;

			for (n++; isdigit((int) val[n]); n++) {
				fac /= 10;
				nsec += (val[n] - '0') * fac;
			}
			((MapiDateTime *) dst)->fraction = nsec;
		}
		break;
	}
	case MAPI_AUTO:
	case MAPI_VARCHAR:
	default:
		*(char **) dst = val;
	}
	return MOK;
}

static void
mapi_store_bind(MapiHdl hdl)
{
	int i;

	for (i = 0; i < hdl->fieldcnt; i++)
		if (hdl->fields[i].outparam)
			mapi_store_field(hdl, i, hdl->fields[i].outtype,
					 hdl->fields[i].outparam);
}

static int
mapi_slice_row(MapiHdl hdl)
{
	char *start;
	char *p;
	int i = 0, cr = hdl->cache.reader;

	p = hdl->cache.rows[cr];
	if (p == NULL)
		return mapi_setError(hdl->mid, "Current row missing",
				     "mapi_slice_row");
	if (hdl->cache.fldcnt[cr]) {
		mapi_store_bind(hdl);
		return hdl->cache.fldcnt[cr];	/* already sliced */
	}
	mapi_extend_anchor(hdl);
	if (*p != '[') {
		if (i == hdl->maxfields) {
			if (mapi_extend_fields(hdl, i))
				return hdl->mid->error;
			mapi_extend_anchor(hdl);
		}
		hdl->cache.anchors[cr][0] = p;
		/* count fields by counting type columns in the header
		   each type looks like "(str)\t", so only count \t if
		   preceded by ). */
		i = 0;
		while ((p = strchr(p + 1, '\t')) != NULL) {
			if (p[-1] == ')')
				i++;
		}
		if (hdl->fieldcnt < i)
			hdl->fieldcnt = i;
		return 1;
	}
	p++;
	i = 0;
	do {
		if (i == hdl->maxfields) {
			if (mapi_extend_fields(hdl, i))
				return hdl->mid->error;
			mapi_extend_anchor(hdl);
		}
		unquote(p, &start, &p);
		hdl->cache.anchors[cr][i++] = start;
		while (*p && isspace((int) *p))
			p++;
	} while (*p && *p != ']');
	if (hdl->fieldcnt < i)
		hdl->fieldcnt = i;
	hdl->cache.fldcnt[cr] = i;
	mapi_store_bind(hdl);
	return i;
}

@-
The rows presented are broken down into pieces to
simplify access later on.
@c
int
mapi_fetch_row(MapiHdl hdl)
{
	mapi_hdl_check(hdl, "mapi_fetch_row");
	if (mapi_get_row(hdl) == MOK)
		return mapi_slice_row(hdl);
	if (hdl->mid->languageId == LANG_SQL && !hdl->mid->active &&
	    hdl->rows_affected > 0 &&
	    hdl->cache.first + hdl->cache.tuplecount < hdl->rows_affected) {
		hdl->mid->active = 1;
		if (stream_printf(hdl->mid->to, "X" "export %d %d\n", hdl->tableid, hdl->cache.first + hdl->cache.tuplecount) < 0 ||
		    stream_flush(hdl->mid->to))
			check_stream(hdl->mid, hdl->mid->to, stream_error(hdl->mid->to), "mapi_fetch_row", MERROR);
		answer_lookahead(hdl);
		if (mapi_get_row(hdl) == MOK)
			return mapi_slice_row(hdl);
	}
	return 0;
}

@-
All rows can be cached first as well.
@c
int
mapi_fetch_all_rows(MapiHdl hdl)
{
	mapi_hdl_check(hdl, "mapi_fetch_all_rows");
	hdl->cache.rowlimit = -1;
	while (mapi_fetch_row(hdl) > 0)
		;
	hdl->cache.reader = -1;
	return hdl->cache.tuplecount;
}

char *
mapi_fetch_field(MapiHdl hdl, int fnr)
{
	int cr;

	mapi_hdl_check0(hdl, "mapi_fetch_field");
	cr = hdl->cache.reader;

	if (cr < 0) {
		mapi_setError(hdl->mid,
			      "Must do a successful mapi_fetch_row first",
			      "mapi_fetch_field");
		return 0;
	}
	assert(hdl->cache.fldcnt != NULL);
	if (fnr >= 0) {
		/* slice if needed */
		if (hdl->cache.fldcnt[cr] == 0)
			mapi_slice_row(hdl);
		if (fnr < hdl->cache.fldcnt[cr])
			return hdl->cache.anchors[cr][fnr];
	}
	mapi_setError(hdl->mid, "Illegal field number", "mapi_fetch_field");
	return 0;
}

char **
mapi_fetch_field_array(MapiHdl hdl)
{
	int cr;

	mapi_hdl_check0(hdl, "mapi_fetch_field_array");
	if(hdl->cache.fldcnt == 0){
		mapi_setError(hdl->mid, "Assertion error", "mapi_fetch_field_array");
		return 0;
	}
	cr = hdl->cache.reader;
	if (hdl->cache.fldcnt[cr] == 0)
		mapi_slice_row(hdl);
	return hdl->cache.anchors[cr];
}

int
mapi_get_field_count(MapiHdl hdl)
{
	mapi_hdl_check(hdl, "mapi_get_field_count");
	return hdl->fieldcnt;
}

int
mapi_get_row_count(MapiHdl hdl)
{
	mapi_hdl_check(hdl, "mapi_get_row_count");
	return hdl->rows_affected;
}

char *
mapi_get_name(MapiHdl hdl, int fnr)
{
	mapi_hdl_check0(hdl, "mapi_get_name");
	if (fnr >= 0 && fnr < hdl->fieldcnt) {
		if (hdl->fields[fnr].columnname[0] == 0)
			snprintf(hdl->fields[fnr].columnname,
				 sizeof(hdl->fields[fnr].columnname),
				 "column_%d", fnr);
		return hdl->fields[fnr].columnname;
	}
	mapi_setError(hdl->mid, "Illegal field number", "mapi_get_name");
	return 0;
}

char *
mapi_get_type(MapiHdl hdl, int fnr)
{
	mapi_hdl_check0(hdl, "mapi_get_type");
	if (fnr >= 0 && fnr < hdl->fieldcnt) {
		if (hdl->fields[fnr].columntype[0] == 0)
			return "unknown";
		return hdl->fields[fnr].columntype;
	}
	mapi_setError(hdl->mid, "Illegal field number", "mapi_get_type");
	return 0;
}

char *
mapi_get_table(MapiHdl hdl, int fnr)
{
	mapi_hdl_check0(hdl, "mapi_get_table");
	if (fnr >= 0 && fnr < hdl->fieldcnt) {
		if (hdl->fields[fnr].tablename[0] == 0)
			snprintf(hdl->fields[fnr].tablename,
				 sizeof(hdl->fields[fnr].tablename),
				 "table_%d", fnr);
		return hdl->fields[fnr].tablename;
	}
	mapi_setError(hdl->mid, "Illegal field number", "mapi_get_table");
	return 0;
}

int
mapi_rows_affected(MapiHdl hdl)
{
	mapi_hdl_check(hdl, "mapi_rows_affected");
	return hdl->rows_affected;
}

char *
mapi_get_dbname(Mapi mid)
{
	mapi_check0(mid, "mapi_get_dbname");
	return mid->database;
}

char *
mapi_get_host(Mapi mid)
{
	mapi_check0(mid, "mapi_get_host");
	return mid->hostname;
}

char *
mapi_get_user(Mapi mid)
{
	mapi_check0(mid, "mapi_get_user");
	return mid->username;
}

char *
mapi_get_lang(Mapi mid)
{
	mapi_check0(mid, "mapi_get_lang");
	return mid->language;
}

char *
mapi_get_mapi_version(Mapi mid)
{
	mapi_check0(mid, "mapi_get_mapi_version");
	return mid->mapiversion;
}

char *
mapi_get_monet_version(Mapi mid)
{
	mapi_check0(mid, "mapi_get_monet_version");
	return mid->server;
}

int
mapi_get_monet_versionId(Mapi mid)
{
	mapi_check0(mid, "mapi_get_monet_versionId");
	return mid->versionId;
}

int
mapi_is_blocked(Mapi mid)
{
	mapi_check0(mid, "mapi_isBlocked");
	return mid->blocked;
}

@}
