@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2004 CWI.
@' All Rights Reserved.
@'
@' Contributor(s):
@'              Martin Kersten <Martin.Kersten@cwi.nl>
@'              Niels Nes <Niels.Nes@cwi.nl>
@'              Stefan Manegold <Stefan.Manegold@cwi.nl>
@'              Peter Boncz <Peter.Boncz@cwi.nl>

@a Sjoerd Mullender, based on code by M. Kersten and Peter Boncz and Niels Nes
@v 5
@f MapiClient
@* The Mapi Client interface (V4+V5)
A textual interface to the Monet server using the Mapi library,
providing command-line MIL access for its users. It is the preferred
interface for non-DBAs.

@+ Manual Page
@T
The {\tt MapiClient} program provides a textual
interface to the Monet server. Unlike the Mserver console, the {\tt MapiClient}
program is intended not only for the database administrator, but to all other
users. It is more comfortable than the console, since it provides
a command history and automatic file name completion.

\begin{verbatim}
MapiClient [-h HOST] [-p PORT] [-d] [-e] [-u username] [-P password] [inputfile+]
\end{verbatim}

The following options are supported:
\begin{itemize}
\item {\em -h -p} Connect to Mserver on machine HOST with tcp port PORT.
\item {\em -d} Debug internal working.
\item {\em -c} Use a different configuration script
\item {\em -s} Execute a single statement
\item {\em -u -P} Replace interactive authorization by command line.
\item{\em -b true/false} run in (non-)blocked mode
\item{\em -h} A synopsis of the command line options
Can be used in scripts, but is insecure.
\item{\em -trace} produces a trace of the interaction with the server
\item{\em -T} produce response timings
\end{itemize}
@

@{
@+ Implementation
@c
#include <monet_options.h>
#include "Mapi.h"
#include <unistd.h>
#include <stdlib.h>
#include <ctype.h>
#include <sys/stat.h>
#include <errno.h>
#include <string.h>
#ifdef HAVE_TERMIOS_H
#include <termios.h>
#endif
#ifdef HAVE_LIBREADLINE
#include <readline/readline.h>
#include <readline/history.h>
#endif

#ifndef S_ISCHR
#define S_ISCHR(m)	(((m) & S_IFMT) == S_IFCHR)
#endif

static FILE *toConsole;

static long t0, t1;		/* used for timing */
static char *mark, *mark2;

/* stolen piece */
#ifdef HAVE_FTIME
#include <sys/timeb.h>
#endif

#if TIME_WITH_SYS_TIME
# include <sys/time.h>
# include <time.h>
#else
# if HAVE_SYS_TIME_H
#  include <sys/time.h>
# else
#  include <time.h>
# endif
#endif

static long
gettime(void)
{
#ifdef HAVE_GETTIMEOFDAY
        struct timeval tp;
        gettimeofday(&tp, NULL);
        return (long) tp.tv_sec * 1000000 + (long) tp.tv_usec;
#else
#ifdef HAVE_FTIME
        struct timeb tb;
        ftime(&tb);
        return (long) tb.time * 1000000 + (long) tb.millitm * 1000;
#endif
#endif
}

static void
timerStart(void)
{
	t0 = gettime();
}

static void
timerEnd(void)
{
	t1 = gettime();
	if (mark)
		fprintf(toConsole, "%s %d usec %s\n", mark, t1 - t0, mark2);
}

static int
doRequest(Mapi mid, const char *buf)
{
	char *rtrn;
	MapiHdl hdl;

	if ((hdl = mapi_query(mid, buf)) == NULL) {
		mapi_explain(mid, stderr);
		return 1;
	}
	if (mapi_error(mid)) {
		mapi_explain_query(hdl, stderr);
		mapi_close_handle(hdl);
		return 1;
	}
	while ((rtrn = mapi_fetch_line(hdl)) != 0) {
		fprintf(toConsole, "%s\n", rtrn);
	}
	if (mapi_error(mid)) {
		mapi_explain_query(hdl, stderr);
		mapi_close_handle(hdl);
		return 1;
	}
	mapi_close_handle(hdl);
	return 0;
}

static void
showCommands(void)
{
	fprintf(toConsole, "?\t - show this message\n");
	fprintf(toConsole, "!\t - shell escape\n");
	fprintf(toConsole, "<file\t - read input from file\n");
	fprintf(toConsole, ">file\t - save response in file\n");
	fprintf(toConsole, ">\t - response to terminal\n");
	fprintf(toConsole, "cd\t - change directory\n");
	/*fprintf(toConsole, "\\r\t- run the buffered command\n");*/
	/*fprintf(toConsole, "\\c\t- clear the command buffer\n");*/
	fprintf(toConsole, "\\l\t- line is immediately sent\n");
	fprintf(toConsole, "\\q\t- terminate session\n");
}

static int
doFile(Mapi mid, const char *file)
{
	FILE *fp;
	char buf[BUFSIZ];
	size_t length;
	MapiHdl hdl;
	int rc;
	char *rtrn;

	if ((fp = fopen(file, "r")) == NULL) {
		fprintf(stderr, "%s: cannot open\n", file);
		return 1;
	}

	rc = 0;
	if ((hdl = mapi_query_prep(mid)) == NULL) {
		mapi_explain(mid, stderr);
		return 1;
	}
	if (mapi_error(mid)) {
		mapi_explain_query(hdl, stderr);
		mapi_close_handle(hdl);
		return 1;
	}
	while ((length = fread(buf, 1, sizeof(buf), fp)) > 0) {
		mapi_query_part(hdl, buf, length);
		if (mapi_error(mid)) {
			mapi_explain_query(hdl, stderr);
			mapi_close_handle(hdl);
			return 1;
		}
	}
	mapi_query_done(hdl);
	if (mapi_error(mid)) {
		mapi_explain_query(hdl, stderr);
		mapi_close_handle(hdl);
		return 1;
	}

	while ((rtrn = mapi_fetch_line(hdl)) != 0)
		fprintf(toConsole, "%s\n", rtrn);

	if (mapi_error(mid)) {
		mapi_explain_query(hdl, stderr);
		rc = 1;
	}
	mapi_close_handle(hdl);
	fclose(fp);
	return rc;
}

static int
doFileByLines(Mapi mid, FILE *fp, const char *prompt, int linemode)
{
	int prepared = 0;
	char *line = NULL;
	char *buf = NULL;
	size_t length;
	MapiHdl hdl = NULL;

#ifdef HAVE_LIBREADLINE
	if (prompt == NULL)
#endif
		buf = malloc(BUFSIZ);

	for (;;) {
#ifdef HAVE_LIBREADLINE
		if (prompt) {
			if (buf)
				free(buf);
			buf = readline(prompt);
			/* add a newline to the end since that makes
			   further processing easier */
			if (buf) {
				length = strlen(buf);
				buf = realloc(buf, length + 2);
				buf[length++] = '\n';
				buf[length] = 0;
			}
			line = buf;
		} else
#endif
		{
#ifndef HAVE_LIBREADLINE
			if (prompt) {
				fputs(prompt, stdout);
				fflush(stdout);
			}
#endif
			line = fgets(buf, BUFSIZ, fp);
		}
		if (line == NULL) {
			if (buf)
				free(buf);
			return 0;
		}
		length = strlen(line);
		if (length == 0)
			continue;

		if (!linemode ||
		    (!prepared && length > 0 && line[length - 1] == '\n')) {
			/* test for special commands */
			while (length > 0 && isspace((int) *line)) {
				line++;
				length--;
			}
			switch (*line) {
			case '\0':
				/* empty line */
				break;
			case '\\':
				switch (line[1]) {
				case 'q':
					free(buf);
					return 0;
				case 't':
					mark = "Timer";
					if (mark2)
						free(mark2);
					mark2 = strdup(line + 2);
					continue;
				case 'T':
					mark = NULL;
					continue;
				case 'l':
					linemode = 1;
					line = "";
					length = 0;
					break;
				case 'b':
					linemode = 0;
					continue;
				default:
					break;
				}
				break;
			case '<':
				/* read commands from file */
				if (line[length - 1] == '\n')
					line[--length] = 0;
				if (line[length - 1] == '\r')
					line[--length] = 0;
				doFile(mid, line + 1);
				continue;
			case '>':
				/* redirect output to file */
				line++;
				length--;
				if (line[length - 1] == '\n')
					line[--length] = 0;
				if (line[length - 1] == '\r')
					line[--length] = 0;
				if (toConsole != stdout && toConsole != stderr)
					fclose(toConsole);
				if (length == 0 || strcmp(line, "stdout") == 0)
					toConsole = stdout;
				else if (strcmp(line, "stderr") == 0)
					  toConsole = stderr;
				else if ((toConsole = fopen(line, "w")) == NULL) {
					toConsole = stdout;
					fprintf(stderr, "Cannot open %s\n", line);
				}
				continue;
			case 'c': /* cd command? */
				if (line[1] == 'd' && isspace((int) line[2])) {
					if (line[length - 1] == '\n')
						line[--length] = 0;
					if (line[length - 1] == '\r')
						line[--length] = 0;
					if (chdir(line + 3) < 0)
						perror(line);
					continue;
				}
				break;
			case '?':
				showCommands();
				continue;
			}
		}

		if ((length == 0 || line[length - 1] == '\n') && linemode) {
			char *rtrn;

			/* send rest of or whole query */
			if (prepared) {
				assert(hdl != NULL);
				if (length > 0) {
					mapi_query_part(hdl, line, length);
					if (mapi_error(mid))
						break;
				}
				mapi_query_done(hdl);
				if (mapi_error(mid))
					break;
				prepared = 0;
			} else {
				assert(hdl == NULL);
				/* send one complete line */
				timerStart();
				hdl = mapi_query(mid, line);
				if (mapi_error(mid))
					break;
#ifdef HAVE_LIBREADLINE
				if (prompt && length > 1) {
					line[--length] = 0;
					add_history(buf);
				}
#endif
			}

			while ((rtrn = mapi_fetch_line(hdl)) != 0)
				fprintf(toConsole, "%s\n", rtrn);
			timerEnd();

			if (mapi_error(mid))
				break;
			mapi_close_handle(hdl);
			hdl = NULL;
		} else {
			/* send part of query */
			if (!prepared) {
				assert(hdl == NULL);
				timerStart();
				hdl = mapi_query_prep(mid);
				if (mapi_error(mid))
					break;
				prepared = 1;
			}
			if (length > 0) {
				mapi_query_part(hdl, line, length);
				if (mapi_error(mid))
					break;
			}
		}
	}
	/* only reached on error */
	if (hdl) {
		mapi_explain_query(hdl, stderr);
		mapi_close_handle(hdl);
	} else
		mapi_explain(mid, stderr);
	return 1;
}

static const char *column_format = "select name,type,type_digits,type_scale,"
	"null,default from columns c,tables t "
	"where c.table_id = t.id and '%s' = t.name order by c.number;\n"; 
#define COLUMN 6
#define C_NAME 0
#define C_TYPE 1
#define C_TYPE_DIGITS 2
#define C_TYPE_SCALE 3

static int 
dump_table(Mapi mid, char *tname)
{
	int cnt = 0, i;
	MapiHdl hdl;
	char query[BUFSIZ];

	char *select_count = "select count(*) from %s";
	char *select_format = "select * from %s";
	int *string;

	fprintf(toConsole, "CREATE TABLE %s (\n", tname);

	snprintf(query, BUFSIZ, column_format, tname);
	if ((hdl = mapi_query(mid, query)) == NULL || mapi_error(mid)) {
		if (hdl) {
			mapi_explain_query(hdl, stderr);
			mapi_close_handle(hdl);
		} else
			mapi_explain(mid, stderr);
		return 1;
	}

	while ((mapi_fetch_row(hdl)) != 0) {
		char *c_name = mapi_fetch_field(hdl, C_NAME);
		char *c_type = mapi_fetch_field(hdl, C_TYPE);
		char *c_type_digits = mapi_fetch_field(hdl, C_TYPE_DIGITS);
		char *c_type_scale = mapi_fetch_field(hdl, C_TYPE_SCALE);

		if (mapi_error(mid)) {
			mapi_explain_query(hdl, stderr);
			mapi_close_handle(hdl);
			return 1;
		}
		if (cnt)
			fprintf(toConsole, ",\n");

		if (strcmp(c_type_digits, "0") == 0) {
			fprintf(toConsole, "\t%s %s", c_name, c_type);
		} else if (strcmp(c_type_scale, "0") == 0) {
			fprintf(toConsole, "\t%s %s(%s)", c_name, c_type,
				c_type_digits);
		} else {
			fprintf(toConsole, "\t%s %s(%s,%s)", c_name, c_type,
				c_type_digits, c_type_scale);
		}
		cnt++;
	}
	if (mapi_error(mid)) {
		mapi_explain_query(hdl, stderr);
		mapi_close_handle(hdl);
		return 1;
	}
	fprintf(toConsole, "\n");

	fprintf(toConsole, ");\n");
	mapi_close_handle(hdl);

	snprintf(query, BUFSIZ, select_count, tname);
	if ((hdl = mapi_query(mid, query)) == NULL || mapi_error(mid)) {
		if (hdl) {
			mapi_explain_query(hdl, stderr);
			mapi_close_handle(hdl);
		} else
			mapi_explain(mid, stderr);
		return 1;
	}
	if (mapi_fetch_row(hdl)) {
		char *cnt = mapi_fetch_field(hdl, 0);
		fprintf(toConsole, "COPY %s RECORDS INTO %s FROM "
			"stdin USING DELIMITERS '\\t';\n", cnt, tname);
	}
	mapi_close_handle(hdl);

	snprintf(query, BUFSIZ, select_format, tname);
	if ((hdl = mapi_query(mid, query)) == NULL || mapi_error(mid)) {
		if (hdl) {
			mapi_explain_query(hdl, stderr);
			mapi_close_handle(hdl);
		} else
			mapi_explain(mid, stderr);
		return 1;
	}

	cnt = mapi_get_field_count(hdl);
	string = malloc(sizeof(int)*cnt);
	for (i = 0; i < cnt; i++) {
		string[i] = 0;
		if (strcmp(mapi_get_type(hdl, i), "char") == 0) 
			string[i] = 1;
	}
	while (mapi_fetch_row(hdl)) {
		char *format;

		for(i = 0; i < cnt - 1; i++) {
			format = "%s\t";
			if (string[i])
				format = "'%s'\t";
			fprintf(toConsole, format, mapi_fetch_field(hdl, i));
		}
		format = "%s\n";
		if (string[i])
			format = "'%s'\n";
		fprintf(toConsole, format, mapi_fetch_field(hdl, i));
	}
	free(string);
	if (mapi_error(mid)) {
		mapi_explain_query(hdl, stderr);
		mapi_close_handle(hdl);
		return 1;
	}
	mapi_close_handle(hdl);
	return 0;
}

static int
dump_tables(Mapi mid)
{
	const char *tables = "select name from tables where type=0"; 
	const char *views = "select name,query from tables where type=2";
	MapiHdl hdl;
	int rc = 0;

	if ((hdl = mapi_query(mid, tables)) == NULL || mapi_error(mid)) {
		if (hdl) {
			mapi_explain_query(hdl, stderr);
			mapi_close_handle(hdl);
		} else
			mapi_explain(mid, stderr);
		return 1;
	}

	while (mapi_fetch_row(hdl) != 0) {
		char *tname = mapi_fetch_field(hdl, 0);

		rc += dump_table(mid, tname);
	}
	if (mapi_error(mid)) {
		mapi_explain_query(hdl, stderr);
		mapi_close_handle(hdl);
		return 1;
	}
	mapi_close_handle(hdl);

	if ((hdl = mapi_query(mid, views)) == NULL || mapi_error(mid)) {
		if (hdl) {
			mapi_explain_query(hdl, stderr);
			mapi_close_handle(hdl);
		} else
			mapi_explain(mid, stderr);
		return 1;
	}
	while (mapi_fetch_row(hdl) != 0) {
		char *vname = mapi_fetch_field(hdl, 0);
		char *query = mapi_fetch_field(hdl, 1);

		fprintf(toConsole, "CREATE VIEW %s %s\n", vname, query);
	}
	if (mapi_error(mid)) {
		mapi_explain_query(hdl, stderr);
		mapi_close_handle(hdl);
		return 1;
	}
	mapi_close_handle(hdl);

	return rc;
}

static char *
simple_prompt(const char *prompt, int maxlen, int echo)
{
	int length = 0;
	char *destination = NULL;
	FILE *termin = NULL, *termout = NULL;

#ifdef HAVE_TERMIOS_H
	struct termios t_orig, t;
#else
	(void) echo;
#endif

	destination = (char *) malloc(maxlen + 2);
	if (!destination)
		return NULL;

	termin = fopen("/dev/tty", "r");
	termout = fopen("/dev/tty", "w");

	if (termin == NULL || termout == NULL) {
		if (termin)
			fclose(termin);
		if (termout)
			fclose(termout);
		termin = stdin;
		termout = stderr;
	}

	if (prompt) {
		fputs(prompt, termout);
		fflush(termout);
	}
#ifdef HAVE_TERMIOS_H
	if (!echo) {
		tcgetattr(fileno(termin), &t);
		t_orig = t;
		t.c_lflag &= ~ECHO;
		tcsetattr(fileno(termin), TCSAFLUSH, &t);
	}
#endif
	if (fgets(destination, maxlen, termin) == NULL)
		destination[0] = '\0';

	length = strlen(destination);
	if (length > 0 && destination[length - 1] != '\n') {
		char	buf[128];
		int	buflen;

		do {
			if (fgets(buf, sizeof(buf), termin) == NULL)
				break;
			buflen = strlen(buf);
		} while (buflen > 0 && buf[buflen - 1] != '\n');
	}

	if (length > 0 && destination[length - 1] == '\n')
		destination[length - 1] = '\0';
#ifdef HAVE_TERMIOS_H
	if (!echo) {
		tcsetattr(fileno(termin), TCSAFLUSH, &t_orig);
		fputs("\n", termout);
		fflush(termout);
	}
	if (termin != stdin)
		fclose(termin);
	if (termout != stdout)
		fclose(termout);
#endif
        return destination;
}

static void
usage(const char *prog)
{
	fprintf(stderr, "Usage: %s [ options ]\n", prog);
	fprintf(stderr, "Options are:\n");
	fprintf(stderr, " -b t/f      | --blocked=true/false /* blocked mode */\n");
	fprintf(stderr, " -d          | --debug=[level]  /* set debug level */\n");
	fprintf(stderr, " -D          | --dump           /* dump sql database */\n");
	fprintf(stderr, " -e          | --error          /* exit on error */\n");
	fprintf(stderr, " -h hostname | --host=hostname  /* host to connect to */\n");
	fprintf(stderr, " -l language | --language=lang  /* {mal,sql,mil} */\n");
	fprintf(stderr, " -P passwd   | --passwd=passwd  /* password */\n");
	fprintf(stderr, " -p portnr   | --port=portnr    /* port to connect to */\n");
	fprintf(stderr, " -s stmt     | --statement=stmt /* run single statement */\n");
	fprintf(stderr, " -t          | --trace          /* trace Monet interaction */\n");
	fprintf(stderr, " -T          | --time           /* time commands */\n");
	fprintf(stderr, " -u user     | --user=user      /* user id */\n" );
	fprintf(stderr, " -?          | --help           /* show this usage message */\n");
	exit(-1);
}

int
main(int argc, char **argv)
{
	opt *set = NULL;
	int setlen;
	char *config = NULL;
#ifdef MONET5
	char *language = "mal";
#else
	char *language = "mil";
#endif
	int port = 0;
	char *user = NULL;
	char *passwd = NULL;
	char *host = NULL;
	char *command = NULL;
	int dodump = 0;
	int trace = 0;
	int linemode = 1;
	int c;
	Mapi mid;
	static struct option long_options[] = {
		{"blocked", 1, 0, 'b'},
		{"config", 1, 0, 'c'},
		{"debug", 2, 0, 'd'},
		{"dump", 0, 0, 'D'},
		{"host", 1, 0, 'h'},
		{"language", 1, 0, 'l'},
		{"passwd", 1, 0, 'P'},
		{"port", 1, 0, 'p'},
		{"set", 1, 0, 'S'},
		{"statement", 1, 0, 's'},
		{"time", 0, 0, 'T'},
		{"trace", 0, 0, 't'},
		{"user", 1, 0, 'u'},
		{0, 0, 0, 0}
	};

	toConsole = stdout;
	mark = NULL;
	mark2 = NULL;

	if ((setlen = mo_builtin_settings(&set)) == 0)
		usage(argv[0]);

	while ((c = getopt_long(argc, argv, "c:l:u:P:h:s:DtTd::", long_options, NULL)) != -1) {
		switch (c) {
		case 'c':
			config = optarg;
			break;
		case 'l':
			language = optarg;
			break;
		case 'u':
			user = optarg;
			break;
		case 'P':
			passwd = optarg;
			break;
		case 'h':
			host = optarg;
			break;
		case 'p':
			port = atoi(optarg);
			setlen = mo_add_option(&set, setlen, opt_cmdline,
					       "port", optarg);
			break;
		case 's':
			command = optarg;
			break;
		case 'D':
			dodump = 1;
			break;
		case 'T':
			mark = "Timer";
			break;
		case 't':
			trace = 1;
			break;
		case 'd':
			setlen = mo_add_option(&set, setlen, opt_cmdline,
					       "debug", optarg ? optarg : "2");
			break;
		case 'S': {
			char *eq = strchr(optarg, '=');

			if (eq)
				*eq = 0;
			setlen = mo_add_option(&set, setlen, opt_cmdline,
					       optarg, eq ? eq + 1 : "");
			if (eq)
				*eq = '=';
			break;
		}
		case 'b':
			if (*optarg == 't' || *optarg == 'T' || *optarg == '1')
				linemode = 0;
			else if (*optarg == 'f' || *optarg == 'F' || *optarg == '0')
				linemode = 1;
			else
				usage(argv[0]);
			break;
		default:
			usage(argv[0]);
		}
	}

	if (config)
		setlen = mo_config_file(&set, setlen, config);
	else
		setlen = mo_system_config(&set, setlen);

	if (port == 0) {
		char *s;

		if (strcmp(language, "sql") == 0)
			s = "sql_port";
		else
			s = "mapi_port";
		if ((s = mo_find_option(set, setlen, s)) != NULL)
			port = strtol(s, NULL, 10);
	}

	if (host == NULL) {
		host = mo_find_option(set, setlen, "host");
		if (host == NULL)
			host = "localhost";
	}

	if (strcmp(language, "sql") == 0) {
		if (user == NULL)
			user = simple_prompt("User: ", BUFSIZ, 1);
		if (passwd == NULL)
			passwd = simple_prompt("Password: ", BUFSIZ, 0);
	}

	mid = mapi_connect(host, port, user, passwd, language);
	if (mid == NULL) {
		fprintf(stderr, "failed to allocate Mapi structure\n");
		exit(2);
	}
	if (mapi_error(mid)) {
		mapi_explain(mid, stderr);
		exit(2);
	}
	mapi_trace(mid, trace);

#ifdef MONET5
	if (strcmp(language, "mal") != 0) {
		char buf[1024];
		snprintf(buf, sizeof(buf), "%s();", language);
		doRequest(mid, buf);
	}
#endif

	if (dodump && strcmp(language, "sql") == 0) {
		c = dump_tables(mid);
		mapi_disconnect(mid);
		return c;
	}

	while (optind < argc) {
		doFile(mid, argv[optind]);
		optind++;
	}

	if (command) {
		c = doRequest(mid, command);
	} else {
		struct stat statb;
		char *prompt = NULL;

		if (fstat(fileno(stdin), &statb) == 0 &&
		    S_ISCHR(statb.st_mode)) {
			prompt = mo_find_option(set, setlen, "prompt");
			if (prompt == NULL) {
#ifdef MONET5
				if (strcmp(language, "mal") == 0)
					prompt = "mal>";
				else
#endif
					prompt = ">";
			}
		}
		c = doFileByLines(mid, stdin, prompt, linemode);
	}
	mapi_disconnect(mid);
	return c;
}
