@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2004 CWI.
@' All Rights Reserved.

@a Sjoerd Mullender, based on code by M. Kersten and Peter Boncz and Niels Nes
@v 5
@f MapiClient
@* The Mapi Client interface (V4+V5)
A textual interface to the Monet server using the Mapi library,
providing command-line MIL access for its users. It is the preferred
interface for non-DBAs.

@+ Manual Page
@T
The {\tt MapiClient} program provides a textual
interface to the MonetDB server. Unlike the Mserver console, the
{\tt MapiClient} program is intended not only for the database
administrator, but for all users. It is more comfortable than the
console, since it provides a command history and automatic file name
completion. The default authorization for SQL interaction is the user
'monetdb'.

\begin{verbatim}
MapiClient [options] [inputfile+]
\end{verbatim}

The following options are supported:

\begin{tabular} {l l l}
 -b t/f      & --blocked=true/false& blocked mode \\
 -d          & --debug=[level]  & set debug level \\
 -D          & --dump           & dump sql database \\
 -e          & --error          & exit on error \\
 -h hostname & --host=hostname  & host to connect to \\
 -l language & --language=lang  & {mal,sql,mil} \\
 -P passwd   & --passwd=passwd  & password \\
 -p portnr   & --port=portnr    & port to connect to \\
 -s stmt     & --statement=stmt & run single statement \\
 -t          & --trace          & trace Monet interaction \\
 -T          & --time           & time commands \\
 -u user     & --user=user      & user id \\
 -H          & --history        & load/save cmdline history (default off) \\
 -?          & --help           & show this usage message \\
\end{tabular}

Calling "MapiClient -l sql" establishes a SQL connection with an
Mserver server running on the local machine. The default user
'monetdb' is used, which provides administrative rights.
To protect your database you may want to introduce another DBA name and
limit the access permisions of 'monetdb' to the level of a guest account.
@

@{
@+ Implementation
@c
#include <monet_options.h>
#include "Mapi.h"
#include <unistd.h>
#include <stdlib.h>
#include <ctype.h>
#include <sys/stat.h>
#include <errno.h>
#include <string.h>
#ifdef HAVE_TERMIOS_H
#include <termios.h>
#endif
#ifdef HAVE_LIBREADLINE
#include <readline/readline.h>
#include <readline/history.h>
#include "ReadlineTools.h"
#endif

#ifndef S_ISCHR
#define S_ISCHR(m)	(((m) & S_IFMT) == S_IFCHR)
#endif

#ifdef NATIVE_WIN32
/* Windows doesn't declare chdir, even though it does provide the function */
extern int chdir(const char *);
#endif

static FILE *toConsole;

static long t0, t1;		/* used for timing */
static char *mark, *mark2;

/* stolen piece */
#ifdef HAVE_FTIME
#include <sys/timeb.h>
#endif

#if TIME_WITH_SYS_TIME
# include <sys/time.h>
# include <time.h>
#else
# if HAVE_SYS_TIME_H
#  include <sys/time.h>
# else
#  include <time.h>
# endif
#endif

static long
gettime(void)
{
#ifdef HAVE_GETTIMEOFDAY
        struct timeval tp;
        gettimeofday(&tp, NULL);
        return (long) tp.tv_sec * 1000000 + (long) tp.tv_usec;
#else
#ifdef HAVE_FTIME
        struct timeb tb;
        ftime(&tb);
        return (long) tb.time * 1000000 + (long) tb.millitm * 1000;
#endif
#endif
}

static void
timerStart(void)
{
	t0 = gettime();
}

static void
timerEnd(void)
{
	t1 = gettime();
	if (mark )
		fprintf(toConsole, "%s %d usec %s\n",
			mark, t1 - t0, mark2?mark2:"");
}

static int
doRequest(Mapi mid, const char *buf)
{
	MapiHdl hdl;

	if ((hdl = mapi_quick_query(mid, buf, toConsole)) == NULL) {
		mapi_explain(mid, stderr);
		return 1;
	}
	if (mapi_error(mid)) {
		mapi_explain_query(hdl, stderr);
		mapi_close_handle(hdl);
		return 1;
	}
	mapi_close_handle(hdl);
	return 0;
}

static void
showCommands(void)
{
	fprintf(toConsole, "?\t - show this message\n");
	fprintf(toConsole, "!\t - shell escape\n");
	fprintf(toConsole, "<file\t - read input from file\n");
	fprintf(toConsole, ">file\t - save response in file\n");
	fprintf(toConsole, ">\t - response to terminal\n");
	fprintf(toConsole, "cd\t - change directory\n");
	/*fprintf(toConsole, "\\r\t- run the buffered command\n");*/
	/*fprintf(toConsole, "\\c\t- clear the command buffer\n");*/
	fprintf(toConsole, "\\l\t- line is sent immediately\n");
	fprintf(toConsole, "\\q\t- terminate session\n");
}

static int
doFile(Mapi mid, const char *file)
{
	FILE *fp;
	char buf[BUFSIZ];
	size_t length;
	MapiHdl hdl = NULL;
	MapiMsg rc;

	if ((fp = fopen(file, "r")) == NULL) {
		fprintf(stderr, "%s: cannot open\n", file);
		return 1;
	}
	timerStart();

	do {
		if ((length = fread(buf, 1, sizeof(buf), fp)) == 0) {
			/* end of file */
			if (hdl == NULL) {
				/* nothing more to do */
				return 0;
			}
			/* hdl != NULL, we should finish the current query */
		}

		if (hdl == NULL) {
			hdl = mapi_query_prep(mid);
			switch (mapi_error(mid)) {
			case MOK:
				/* everything A OK */
				break;
			case MERROR:
				/* some error, but try to continue */
				if (hdl) {
					mapi_explain_query(hdl, stderr);
					mapi_close_handle(hdl);
					hdl = NULL;
				} else
					mapi_explain(mid, stderr);
				continue;
			case MTIMEOUT:
				/* lost contact with the server */
				if (hdl) {
					mapi_explain_query(hdl, stderr);
					mapi_close_handle(hdl);
					hdl = NULL;
				} else
					mapi_explain(mid, stderr);
				return 1;
			}
		}
		if (length > 0) {
			assert(hdl != NULL);
			mapi_query_part(hdl, buf, length);
			switch (mapi_error(mid)) {
			case MOK:
				/* everything A OK */
				break;
			case MERROR:
				/* some error, but try to continue */
				if (hdl) {
					mapi_explain_query(hdl, stderr);
					mapi_close_handle(hdl);
					hdl = NULL;
				} else
					mapi_explain(mid, stderr);
				continue;
			case MTIMEOUT:
				/* lost contact with the server */
				if (hdl) {
					mapi_explain_query(hdl, stderr);
					mapi_close_handle(hdl);
					hdl = NULL;
				} else
					mapi_explain(mid, stderr);
				return 1;
			}
		}

		assert(hdl != NULL);
		/* If the server wants more but we're at the end of
		   file (length == 0), notify the server that we
		   don't have anything more.  If the server still
		   wants more (shouldn't happen accordint to the
		   protocol) we break out of the loop (via the
		   continue).  The assertion at the end will then go
		   off. */
		if (mapi_query_done(hdl) == MMORE &&
		    (length > 0 || mapi_query_done(hdl) == MMORE))
			continue;	       /* get more data */

		switch (mapi_error(mid)) {
		case MOK:
			/* everything A OK */
			break;
		case MERROR:
			/* some error, but try to continue */
			mapi_explain_query(hdl, stderr);
			mapi_close_handle(hdl);
			hdl = NULL;
			continue;
		case MTIMEOUT:
			/* lost contact with the server */
			mapi_explain_query(hdl, stderr);
			mapi_close_handle(hdl);
			hdl = NULL;
			return 1;
		}

		do {
			char *reply;

			if ((reply = mapi_result_error(hdl)) != NULL)
				mapi_explain_result(hdl, stderr);
			while ((reply = mapi_fetch_line(hdl)) != NULL)
				fprintf(toConsole, "%s\n", reply);
		} while ((rc = mapi_next_result(hdl)) == 1);
		if (rc == MMORE &&
		    (length > 0 || mapi_query_done(hdl) != MOK))
			continue; /* get more data */

		switch (mapi_error(mid)) {
		case MOK:
			/* everything A OK */
			break;
		case MERROR:
			/* some error, but try to continue */
			mapi_explain_query(hdl, stderr);
			mapi_close_handle(hdl);
			hdl = NULL;
			continue;
		case MTIMEOUT:
			/* lost contact with the server */
			mapi_explain_query(hdl, stderr);
			mapi_close_handle(hdl);
			hdl = NULL;
			return 1;
		}

		mapi_close_handle(hdl);
		hdl = NULL;
	} while (length > 0);
	/* reached on end of file */
	assert(hdl == NULL);

	return 0;
}

static int
doFileByLines(Mapi mid, FILE *fp, const char *prompt, int linemode)
{
	char *line = NULL;
	char *buf = NULL;
	size_t length;
	MapiHdl hdl = NULL;
	MapiMsg rc;

#ifdef HAVE_LIBREADLINE
	if (prompt == NULL)
#endif
		buf = malloc(BUFSIZ);

	do {
#ifdef HAVE_LIBREADLINE
		if (prompt) {
			if (buf)
				free(buf);
			buf = readline(hdl ? "more>" : prompt);
			/* add a newline to the end since that makes
			   further processing easier */
			if (buf) {
				add_history(buf);
				length = strlen(buf);
				buf = realloc(buf, length + 2);
				buf[length++] = '\n';
				buf[length] = 0;
			}
			line = buf;
		} else
#endif
		{
#ifndef HAVE_LIBREADLINE
			if (prompt) {
				fputs(hdl ? "more>" : prompt, stdout);
				fflush(stdout);
			}
#endif
			line = fgets(buf, BUFSIZ, fp);
		}
		if (line == NULL) {
			/* end of file */
			if (hdl == NULL) {
				/* nothing more to do */
				return 0;
			}
			/* hdl != NULL, we should finish the current query */
			length = 0;
		} else
			length = strlen(line);

		if (length > 0 &&
		    (!linemode ||
		     (hdl == NULL && length > 0 && line[length - 1] == '\n'))) {
			/* test for special commands */
			while (length > 0 && isspace((int) *line)) {
				line++;
				length--;
			}
			switch (*line) {
			case '\0':
				/* empty line */
				break;
			case '\\':
				switch (line[1]) {
				case 'q':
					free(buf);
					return 0;
				case 't':
					mark = "Timer";
					if (mark2)
						free(mark2);
					mark2 = strdup(line + 2);
					continue;
				case 'T':
					mark = NULL;
					continue;
				case 'l':
					linemode = 1;
					line = "";
					length = 0;
					break;
				case 'b':
					linemode = 0;
					continue;
				default:
					break;
				}
				break;
			case '<':
				/* read commands from file */
				if (line[length - 1] == '\n')
					line[--length] = 0;
				if (line[length - 1] == '\r')
					line[--length] = 0;
				doFile(mid, line + 1);
				continue;
			case '>':
				/* redirect output to file */
				line++;
				length--;
				if (line[length - 1] == '\n')
					line[--length] = 0;
				if (line[length - 1] == '\r')
					line[--length] = 0;
				if (toConsole != stdout && toConsole != stderr)
					fclose(toConsole);
				if (length == 0 || strcmp(line, "stdout") == 0)
					toConsole = stdout;
				else if (strcmp(line, "stderr") == 0)
					  toConsole = stderr;
				else if ((toConsole = fopen(line, "w")) == NULL) {
					toConsole = stdout;
					fprintf(stderr, "Cannot open %s\n", line);
				}
				continue;
			case 'c': /* cd command? */
				if (line[1] == 'd' && isspace((int) line[2])) {
					if (line[length - 1] == '\n')
						line[--length] = 0;
					if (line[length - 1] == '\r')
						line[--length] = 0;
					if (chdir(line + 3) < 0)
						perror(line);
					continue;
				}
				break;
			case '?':
				showCommands();
				continue;
			}
		}

		if (hdl == NULL) {
			timerStart();
			hdl = mapi_query_prep(mid);
			switch (mapi_error(mid)) {
			case MOK:
				/* everything A OK */
				break;
			case MERROR:
				/* some error, but try to continue */
				if (hdl) {
					mapi_explain_query(hdl, stderr);
					mapi_close_handle(hdl);
					hdl = NULL;
				} else
					mapi_explain(mid, stderr);
				continue;
			case MTIMEOUT:
				/* lost contact with the server */
				if (hdl) {
					mapi_explain_query(hdl, stderr);
					mapi_close_handle(hdl);
					hdl = NULL;
				} else
					mapi_explain(mid, stderr);
				return 1;
			}
		}
		if (length > 0) {
			assert(hdl != NULL);
			mapi_query_part(hdl, line, length);
			switch (mapi_error(mid)) {
			case MOK:
				/* everything A OK */
				break;
			case MERROR:
				/* some error, but try to continue */
				if (hdl) {
					mapi_explain_query(hdl, stderr);
					mapi_close_handle(hdl);
					hdl = NULL;
				} else
					mapi_explain(mid, stderr);
				continue;
			case MTIMEOUT:
				/* lost contact with the server */
				if (hdl) {
					mapi_explain_query(hdl, stderr);
					mapi_close_handle(hdl);
					hdl = NULL;
				} else
					mapi_explain(mid, stderr);
				return 1;
			}
		}
		if ((line == NULL ||
		     (length > 0 && line[length - 1] == '\n')) &&
		    linemode) {
			assert(hdl != NULL);
			/* If the server wants more but we're at the
			   end of file (line == NULL), notify the
			   server that we don't have anything more.
			   If the server still wants more (shouldn't
			   happen accordint to the protocol) we break
			   out of the loop (via the continue).  The
			   assertion at the end will then go off. */
			if (mapi_query_done(hdl) == MMORE &&
			    (line != NULL || mapi_query_done(hdl) == MMORE))
				continue; /* get more data */

			switch (mapi_error(mid)) {
			case MOK:
				/* everything A OK */
				break;
			case MERROR:
				/* some error, but try to continue */
				mapi_explain_query(hdl, stderr);
				mapi_close_handle(hdl);
				hdl = NULL;
				continue;
			case MTIMEOUT:
				/* lost contact with the server */
				mapi_explain_query(hdl, stderr);
				mapi_close_handle(hdl);
				hdl = NULL;
				return 1;
			}

			do {
				char *reply;

				if ((reply = mapi_result_error(hdl)) != NULL)
					mapi_explain_result(hdl, stderr);
				while ((reply = mapi_fetch_line(hdl)) != NULL)
					fprintf(toConsole, "%s\n", reply);
			} while ((rc = mapi_next_result(hdl)) == 1);
			if (rc == MMORE &&
			    (line != NULL || mapi_query_done(hdl) != MOK))
				continue; /* get more data */

			switch (mapi_error(mid)) {
			case MOK:
				/* everything A OK */
				break;
			case MERROR:
				/* some error, but try to continue */
				mapi_explain_query(hdl, stderr);
				mapi_close_handle(hdl);
				hdl = NULL;
				continue;
			case MTIMEOUT:
				/* lost contact with the server */
				mapi_explain_query(hdl, stderr);
				mapi_close_handle(hdl);
				hdl = NULL;
				return 1;
			}

			timerEnd();
			mapi_close_handle(hdl);
			hdl = NULL;
		}
	} while (line != NULL);
	/* reached on end of file */
	assert(hdl == NULL);
	return 0;
}

static const char *column_format = "select name,type,type_digits,type_scale,"
	"null,default,number from columns c,tables t "
	"where c.table_id = t.id and '%s' = t.name order by number;\n";
#define COLUMN 6
#define C_NAME 0
#define C_TYPE 1
#define C_TYPE_DIGITS 2
#define C_TYPE_SCALE 3

static int
dump_table(Mapi mid, char *tname)
{
	int cnt = 0, i;
	MapiHdl hdl;
	char query[BUFSIZ];

	char *select_count = "select count(*) from %s";
	char *select_format = "select * from %s";
	int *string;

	fprintf(toConsole, "CREATE TABLE %s (\n", tname);

	snprintf(query, BUFSIZ, column_format, tname);
	if ((hdl = mapi_query(mid, query)) == NULL || mapi_error(mid)) {
		if (hdl) {
			mapi_explain_query(hdl, stderr);
			mapi_close_handle(hdl);
		} else
			mapi_explain(mid, stderr);
		return 1;
	}

	while ((mapi_fetch_row(hdl)) != 0) {
		char *c_name = mapi_fetch_field(hdl, C_NAME);
		char *c_type = mapi_fetch_field(hdl, C_TYPE);
		char *c_type_digits = mapi_fetch_field(hdl, C_TYPE_DIGITS);
		char *c_type_scale = mapi_fetch_field(hdl, C_TYPE_SCALE);

		if (mapi_error(mid)) {
			mapi_explain_query(hdl, stderr);
			mapi_close_handle(hdl);
			return 1;
		}
		if (cnt)
			fprintf(toConsole, ",\n");

		if (strcmp(c_type_digits, "0") == 0) {
			fprintf(toConsole, "\t%s %s", c_name, c_type);
		} else if (strcmp(c_type_scale, "0") == 0) {
			fprintf(toConsole, "\t%s %s(%s)", c_name, c_type,
				c_type_digits);
		} else {
			fprintf(toConsole, "\t%s %s(%s,%s)", c_name, c_type,
				c_type_digits, c_type_scale);
		}
		cnt++;
	}
	if (mapi_error(mid)) {
		mapi_explain_query(hdl, stderr);
		mapi_close_handle(hdl);
		return 1;
	}
	fprintf(toConsole, "\n");

	fprintf(toConsole, ");\n");
	mapi_close_handle(hdl);

	snprintf(query, BUFSIZ, select_count, tname);
	if ((hdl = mapi_query(mid, query)) == NULL || mapi_error(mid)) {
		if (hdl) {
			mapi_explain_query(hdl, stderr);
			mapi_close_handle(hdl);
		} else
			mapi_explain(mid, stderr);
		return 1;
	}
	if (mapi_fetch_row(hdl)) {
		char *cnt = mapi_fetch_field(hdl, 0);
		fprintf(toConsole, "COPY %s RECORDS INTO %s FROM "
			"stdin USING DELIMITERS '\\t';\n", cnt, tname);
	}
	mapi_close_handle(hdl);

	snprintf(query, BUFSIZ, select_format, tname);
	if ((hdl = mapi_query(mid, query)) == NULL || mapi_error(mid)) {
		if (hdl) {
			mapi_explain_query(hdl, stderr);
			mapi_close_handle(hdl);
		} else
			mapi_explain(mid, stderr);
		return 1;
	}

	cnt = mapi_get_field_count(hdl);
	string = malloc(sizeof(int)*cnt);
	for (i = 0; i < cnt; i++) {
		string[i] = 0;
		if (strcmp(mapi_get_type(hdl, i), "char") == 0 ||
			strcmp(mapi_get_type(hdl, i), "varchar") == 0)
		{
			string[i] = 1;
		}
	}
	while (mapi_fetch_row(hdl)) {
		char *s;

		for(i = 0; i < cnt; i++) {
			s = mapi_fetch_field(hdl, i);
			if (s == NULL)
				fputs("NULL", toConsole);
			else if (string[i]) {
				/* write double-quoted string with
				   certain characters escaped */
				putc('"', toConsole);
				while (*s) {
					/* strToStr and strFromStr in gdk_atoms.mx only
					   support \t \n \\ \" and \377 */
					switch (*s) {
					case '\\':
					case '"':
						putc('\\', toConsole);
						putc(*s, toConsole);
						break;
					case '\n':
						putc('\\', toConsole);
						putc('n', toConsole);
						break;
					case '\t':
						putc('\\', toConsole);
						putc('t', toConsole);
						break;
					default:
						if ((0 < *s && *s < 32) || *s == '\377') {
							char *tmp = malloc(sizeof(char) * 4 + 1);
							snprintf(tmp, 5, "\\%03o", (unsigned char)*s);
							fwrite(tmp, 4, 1, toConsole);
							free(tmp);
						} else {
							putc(*s, toConsole);
						}
						break;
					}
					s++;
				}
				putc('"', toConsole);
			} else
				fputs(s, toConsole);
			if (i < cnt - 1)
				putc('\t', toConsole);
			else
				putc('\n', toConsole);
		}
	}
	free(string);
	if (mapi_error(mid)) {
		mapi_explain_query(hdl, stderr);
		mapi_close_handle(hdl);
		return 1;
	}
	mapi_close_handle(hdl);
	return 0;
}

static int
dump_tables(Mapi mid)
{
	const char *tables = "SELECT name FROM tables WHERE type = 0 AND name NOT LIKE 'history'";
	const char *views = "select name,query from tables where type=2";
	MapiHdl hdl;
	int rc = 0;

	if ((hdl = mapi_query(mid, tables)) == NULL || mapi_error(mid)) {
		if (hdl) {
			mapi_explain_query(hdl, stderr);
			mapi_close_handle(hdl);
		} else
			mapi_explain(mid, stderr);
		return 1;
	}

	while (mapi_fetch_row(hdl) != 0) {
		char *tname = mapi_fetch_field(hdl, 0);

		rc += dump_table(mid, tname);
	}
	if (mapi_error(mid)) {
		mapi_explain_query(hdl, stderr);
		mapi_close_handle(hdl);
		return 1;
	}
	mapi_close_handle(hdl);

	if ((hdl = mapi_query(mid, views)) == NULL || mapi_error(mid)) {
		if (hdl) {
			mapi_explain_query(hdl, stderr);
			mapi_close_handle(hdl);
		} else
			mapi_explain(mid, stderr);
		return 1;
	}
	while (mapi_fetch_row(hdl) != 0) {
		char *vname = mapi_fetch_field(hdl, 0);
		char *query = mapi_fetch_field(hdl, 1);

		fprintf(toConsole, "CREATE VIEW %s AS %s\n", vname, query);
	}
	if (mapi_error(mid)) {
		mapi_explain_query(hdl, stderr);
		mapi_close_handle(hdl);
		return 1;
	}
	mapi_close_handle(hdl);

	/* finally commit the whole transaction */
	fprintf(toConsole, "COMMIT;\n");

	return rc;
}

static char *
simple_prompt(const char *prompt, int maxlen, int echo, const char *def)
{
	int length = 0;
	char *destination = NULL;
	FILE *termin = NULL, *termout = NULL;

#ifdef HAVE_TERMIOS_H
	struct termios t_orig, t;
#else
	(void) echo;
#endif

	destination = (char *) malloc(maxlen + 2);
	if (!destination)
		return NULL;

	termin = fopen("/dev/tty", "r");
	termout = fopen("/dev/tty", "w");

	if (termin == NULL || termout == NULL) {
		if (termin)
			fclose(termin);
		if (termout)
			fclose(termout);
		termin = stdin;
		termout = stderr;
	}

	if (prompt) {
		if( def)
			fprintf(termout,"%s(%s):",prompt,def);
		else	fprintf(termout,"%s:",prompt);
		fflush(termout);
	}
#ifdef HAVE_TERMIOS_H
	if (!echo) {
		tcgetattr(fileno(termin), &t);
		t_orig = t;
		t.c_lflag &= ~ECHO;
		tcsetattr(fileno(termin), TCSAFLUSH, &t);
	}
#endif
	if (fgets(destination, maxlen, termin) == NULL)
		destination[0] = '\0';

	length = strlen(destination);
	if (length > 0 && destination[length - 1] != '\n') {
		char	buf[128];
		int	buflen;

		do {
			if (fgets(buf, sizeof(buf), termin) == NULL)
				break;
			buflen = strlen(buf);
		} while (buflen > 0 && buf[buflen - 1] != '\n');
	}

	if (length > 0 && destination[length - 1] == '\n')
		destination[length - 1] = '\0';
#ifdef HAVE_TERMIOS_H
	if (!echo) {
		tcsetattr(fileno(termin), TCSAFLUSH, &t_orig);
		fputs("\n", termout);
		fflush(termout);
	}
	if (termin != stdin)
		fclose(termin);
	if (termout != stdout)
		fclose(termout);
#endif
	if( destination[0]==0 && def) strcpy(destination,def);
        return destination;
}

static void
usage(const char *prog)
{
	fprintf(stderr, "Usage: %s [ options ]\n", prog);
	fprintf(stderr, "Options are:\n");
	fprintf(stderr, " -b t/f      | --blocked=true/false /* blocked mode */\n");
	fprintf(stderr, " -d          | --debug=[level]  /* set debug level */\n");
	fprintf(stderr, " -D          | --dump           /* dump sql database */\n");
	fprintf(stderr, " -e          | --error          /* exit on error */\n");
	fprintf(stderr, " -h hostname | --host=hostname  /* host to connect to */\n");
	fprintf(stderr, " -l language | --language=lang  /* {mal,sql,mil} */\n");
	fprintf(stderr, " -P passwd   | --passwd=passwd  /* password */\n");
	fprintf(stderr, " -p portnr   | --port=portnr    /* port to connect to */\n");
	fprintf(stderr, " -q          | --quiet          /* don't print welcome message */\n");
	fprintf(stderr, " -s stmt     | --statement=stmt /* run single statement */\n");
	fprintf(stderr, " -t          | --trace          /* trace Monet interaction */\n");
	fprintf(stderr, " -T          | --time           /* time commands */\n");
	fprintf(stderr, " -u user     | --user=user      /* user id */\n" );
	fprintf(stderr, " -H          | --history        /* load/save cmdline history (default off) */\n" );
	fprintf(stderr, " -?          | --help           /* show this usage message */\n");
	exit(-1);
}

#define SQLdefaultPort 45123 	/* hardwired SQL default */

int
main(int argc, char **argv)
{
	opt *set = NULL;
	int setlen;
#ifdef MONET5
	char *language = "mal";
#else
	char *language = "mil";
#endif
	int port = 0;
	char *user = NULL;
	char *passwd = NULL;
	char *host = NULL;
	char *command = NULL;
	int dodump = 0;
	int trace = 0;
	int guest = 0;
	int linemode = 1;
	int c;
	Mapi mid;
	int quiet = 0;
	int save_history = 0;
	static struct option long_options[] = {
		{"blocked", 1, 0, 'b'},
		{"config", 1, 0, 'c'},
		{"debug", 2, 0, 'd'},
		{"dump", 0, 0, 'D'},
		{"host", 1, 0, 'h'},
		{"language", 1, 0, 'l'},
		{"passwd", 1, 0, 'P'},
		{"port", 1, 0, 'p'},
		{"set", 1, 0, 'S'},
		{"statement", 1, 0, 's'},
		{"time", 0, 0, 'T'},
		{"trace", 0, 0, 't'},
		{"user", 1, 0, 'u'},
		{"history", 0, 0, 'H'},
		{"quiet", 0, 0, 'q'},
		{"help", 0, 0, '?'},
		{0, 0, 0, 0}
	};

	toConsole = stdout;
	mark = NULL;
	mark2 = NULL;

	if ((setlen = mo_builtin_settings(&set)) == 0)
		usage(argv[0]);

	while ((c = getopt_long(argc, argv, "b:c:l:u:p:P:qHh:s:DtTd::?", long_options, NULL)) != -1) {
		switch (c) {
		case 'b':
			if (*optarg == 't' || *optarg == 'T' || *optarg == '1')
				linemode = 0;
			else if (*optarg == 'f' || *optarg == 'F' || *optarg == '0')
				linemode = 1;
			else
				usage(argv[0]);
			break;
		case 'c':
			setlen = mo_add_option(&set, setlen, opt_cmdline,
					       "config", optarg);
			break;
		case 'l':
			guest= !( user!= NULL || passwd!=NULL);
			if(guest && port==0) port= SQLdefaultPort;
			language = optarg;
			break;
		case 'u':
			guest= 0;
			user = optarg;
			break;
		case 'P':
			guest= 0;
			passwd = optarg;
			break;
		case 'h':
			host = optarg;
			break;
		case 'p':
			port = atoi(optarg);
			setlen = mo_add_option(&set, setlen, opt_cmdline,
					       "port", optarg);
			break;
		case 's':
			command = optarg;
			break;
		case 'q':
			quiet = 1;
			break;
		case 'D':
			dodump = 1;
			break;
		case 'T':
			mark = "Timer";
			break;
		case 't':
			trace = 1;
			break;
		case 'd':
			setlen = mo_add_option(&set, setlen, opt_cmdline,
					       "debug", optarg ? optarg : "2");
			break;
		case 'S': {
			char *eq = strchr(optarg, '=');

			if (eq)
				*eq = 0;
			setlen = mo_add_option(&set, setlen, opt_cmdline,
					       optarg, eq ? eq + 1 : "");
			if (eq)
				*eq = '=';
			break;
		}
		case 'H':
			save_history = 1;
			break;
		case '?':
			usage(argv[0]);
		default:
			usage(argv[0]);
		}
	}

	setlen = mo_system_config(&set, setlen);

	if (port == 0) {
		char *s;

		if (strcmp(language, "sql") == 0)
			s = "sql_port";
		else
			s = "mapi_port";
		if ((s = mo_find_option(set, setlen, s)) != NULL)
			port = strtol(s, NULL, 10);
	}

	if (host == NULL) {
		host = mo_find_option(set, setlen, "host");
		if (host == NULL)
			host = "localhost";
	}

	if (strcmp(language, "sql") == 0) {
		if (guest)
			user= "monetdb";
		else if (user == NULL)
			user = simple_prompt("User ", BUFSIZ, 1, "monetdb");
		if (guest)
			passwd= "monetdb";
		else if (passwd == NULL)
			passwd = simple_prompt("Password ", BUFSIZ, 0, "monetdb");
	}

	mid = mapi_connect(host, port, user, passwd, language);
	if (mid == NULL) {
		fprintf(stderr, "failed to allocate Mapi structure\n");
		exit(2);
	}
	if (mapi_error(mid)) {
		mapi_explain(mid, stderr);
		exit(2);
	}
	if (!quiet) {
		char *motd = mapi_get_motd(mid);

		if (motd)
			printf("%s", motd);
	}
	mapi_trace(mid, trace);

#ifdef MONET5
	if (strcmp(language, "mal") != 0) {
		char buf[1024];
		snprintf(buf, sizeof(buf), "%s();", language);
		doRequest(mid, buf);
	}
#endif

	if (dodump && strcmp(language, "sql") == 0) {
		c = dump_tables(mid);
		mapi_disconnect(mid);
		return c;
	}

	while (optind < argc) {
		doFile(mid, argv[optind]);
		optind++;
	}

#ifdef HAVE_LIBREADLINE
	init_readline(mid, language, save_history);
#endif

	if (command) {
		c = doRequest(mid, command);
	} else {
		struct stat statb;
		char *prompt = NULL;
		char promptbuf[16];

		if (fstat(fileno(stdin), &statb) == 0 &&
		    S_ISCHR(statb.st_mode)) {
			/* reading from terminal, prepare prompt */
			sprintf(promptbuf, "%.*s>",
				(int) sizeof(promptbuf) - 2, language);
			prompt = promptbuf;
		}
		c = doFileByLines(mid, stdin, prompt, linemode);
	}

#ifdef HAVE_LIBREADLINE
	deinit_readline();
#endif

	mapi_disconnect(mid);
	return c;
}
