@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2003 CWI.
@' All Rights Reserved.
@'
@' Contributor(s):
@'              Martin Kersten <Martin.Kersten@cwi.nl>
@'              Niels Nes <Niels.Nes@cwi.nl>
@'              Stefan Manegold <Stefan.Manegold@cwi.nl>
@'              Peter Boncz <Peter.Boncz@cwi.nl>

@a M. Kersten and Peter Boncz and Niels Nes
@v 5
@f MapiClient
@* The Mapi Client interface (V4+V5)
A textual interface to the Monet server using the Mapi library,
providing command-line MIL access for its users. It is the preferred
interface for non-DBAs.

@+ Manual Page
@T
The {\tt MapiClient} program provides textual
interface to the Monet server. Unlike the Mserver console, the {\tt MapiClient}
program is intended not only or the database administrator, but to all other
users. It is more comfortable than the console, since it provides
a command history and automatic file name completion.

\begin{verbatim}
MapiClient [-h HOST] [-p PORT] [-d] [-e] [-u username] [-P password] [-c single-command]
\end{verbatim}

The following options are supported:
\begin{itemize}
\item {\em -h -p} Connect to Mserver on machine HOST with tcp port PORT.
\item {\em -d} Debug internalworking.
\item {\em -c} just execute a one-line command (non-interactive mode).
\item {\em -u -P} Replace interactive authorization by command line.
\item{\em -h} A synopsis of the command line options
Can be used in scripts, but is insecure.
\end{itemize}
@

@{
@+ Implementation
@c
#include <monet_options.h>	/* includes config.h */
#include "Mapi.h"
#include <stdlib.h>
#include <ctype.h>
#ifdef HAVE_LIBREADLINE
#include <sys/stat.h>
#endif
#include <errno.h>
#include <string.h>
/* #include <signal.h> */

#define _strdup( ptr )		strdup((char*)ptr)

#ifdef HAVE_LANGINFO_H
#include <langinfo.h>
#endif
#ifdef HAVE_ICONV_H
#include <iconv.h>
#endif
#ifdef HAVE_LOCALE_H
#include <locale.h>
#endif

#if !defined(HAVE_SETLOCALE) || \
    !defined(HAVE_ICONV) || \
    !defined(HAVE_NL_LANGINFO)
#	define	NO_LOCALE
#endif

stream *ws = NULL, *rs = NULL;
int is_chrsp = 0;
int exit_on_error =0;

#ifdef HAVE_ICONV
iconv_t to_utf = NULL;
iconv_t from_utf = NULL;

char *conv( char *org, iconv_t cd)
{
	if (cd){
		size_t len = strlen(org);
		size_t size = len * 4;
		char *buf = malloc(size);
		char *to = buf;
		char *from = org;

		if (iconv(cd, &from, &len, &to, &size ) == (size_t)(-1)){
			perror("conv ");
			fprintf(stderr, "could not convert string %s\n", from );
			free(buf);
			exit(1);
		}
		*to = 0;
		return buf;
	} else {
		return _strdup(org);
	}
}
#else
#define conv( org, dummy) _strdup(org)
#endif

@-
The login procedure has been improved. The default is to ask for
user name and password (non-displayed). The log procedure is
started after it has become clear that a server is available at
the port indicated. This enables more elaborate authentication
schemes to be deployed in the future.
@c

#ifdef HAVE_TERMIOS_H
#include <termios.h>
#endif

char *
simple_prompt(const char *prompt, int maxlen, int echo)
{
	int length = 0;
	char *destination = NULL;
	FILE *termin = NULL, *termout = NULL;

#ifdef HAVE_TERMIOS_H
	struct termios t_orig, t;
#else
	(void) echo;
#endif

	destination = (char *) malloc(maxlen + 2);
	if (!destination)
		return NULL;

	termin = fopen("/dev/tty", "r");
	termout = fopen("/dev/tty", "w");

	if (termin == NULL || termout == NULL){
		termin = stdin;
		termout = stderr;
	}

	if (prompt) {
		fputs( prompt, termout);
		fflush(termout);
	}
#ifdef HAVE_TERMIOS_H
	if (!echo) {
		tcgetattr(fileno(termin), &t);
		t_orig = t;
		t.c_lflag &= ~ECHO;
		tcsetattr(fileno(termin), TCSAFLUSH, &t);
	}
#endif
	if (fgets(destination, maxlen, termin) == NULL)
		destination[0] = '\0';

	length = strlen(destination);
	if (length > 0 && destination[length - 1] != '\n') {
		char	buf[128];
		int	buflen;

		do {
			if (fgets(buf, sizeof(buf), termin) == NULL)
				break;
			buflen = strlen(buf);
		} while (buflen > 0 && buf[buflen - 1] != '\n');
	}

	if (length > 0 && destination[length - 1] == '\n')
		destination[length - 1] = '\0';
#ifdef HAVE_TERMIOS_H
	if (!echo) {
		tcsetattr(fileno(termin), TCSAFLUSH, &t_orig);
		fputs("\n", termout);
		fflush(termout);
	}
	if (termin != stdin)
		fclose(termin);
	if (termout != stdout)
		fclose(termout);
#endif
        return destination;
}

extern int errno;		/* pass errors  */
char *program;			/* my name */

#define EXIT(x)	{ exit(x); }
#define LINEMODE	23
#define BLOCKMODE	32

FILE	*toConsole;
char	*message	= 0;
int	mode		= LINEMODE;
char*	sentinel 	= "MapiClient~sentinel";


int doRequest(Mapi mid, char *buf )
{
	char *rtrn;

/*
	if (mapi_quick_query(mid, buf,toConsole) != MOK){
		mapi_explain(mid,stdout);
		return 0;
	}
	fflush(toConsole);
*/
	if (mapi_query(mid, buf) != MOK){
		mapi_explain(mid,stdout);
		return 0;
	}
	while ((rtrn = mapi_fetch_line(mid)) != 0) {
		fprintf(toConsole, "%s\n",rtrn);
	}
	if (mapi_error(mid)) {
		mapi_explain(mid,stdout);
		return 0;
	}
	return 0;
}
@-
The input for the Monet server is stored in a buffer until
the forward command is issued.
In LINEMODE each line is sent and the monitor awaits the prompt
of the server before continuing
@c
#define CHUNK_SIZE	1024

#ifdef HAVE_LIBREADLINE

#include <readline/readline.h>
#include <readline/history.h>

#define SEND_MESSAGE(mid)	{					\
	message[m_index] = 0;					\
	cmd = doRequest(mid, message );				\
	add_history(start_cmd);					\
	*message = 0; m_index = 0;				\
}
#else
#define SEND_MESSAGE(mid)	{				\
	message[m_index] = 0;					\
	cmd = doRequest(mid, message );				\
	*message = 0; m_index = 0;				\
}
#endif

#define GROW_MESSAGE(x)		{				\
	m_index += x;						\
	if (m_size-m_index  < CHUNK_SIZE) {			\
		message = (char *) realloc(message, m_size*=2);	\
		memset(message+m_index, 0, m_size-m_index);	\
	}							\
}

void showCommands(void)
{
	fprintf(toConsole,"?\t - this message\n");
	fprintf(toConsole,"!\t - shell escape\n");
	fprintf(toConsole,"<file\t - read input from file\n");
	fprintf(toConsole,">file\t - save response in file\n");
	fprintf(toConsole,">\t - response to terminal\n");
	fprintf(toConsole,"cd\t - change directory\n");
	fprintf(toConsole,"\\r\t- run the buffered command\n");
	fprintf(toConsole,"\\c\t- clear the command buffer\n");
	fprintf(toConsole,"\\l\t- line is immediately sent\n");
	fprintf(toConsole,"\\q\t- terminate session\n");
}

void terminalInput( Mapi mid)
{
	FILE	*fp;
	char 	*line=0, *start_cmd, *end_cmd;
	int	n, m_size=CHUNK_SIZE, m_index=0;
	char	cmd = 0;

	message = (char *) malloc(CHUNK_SIZE);

	while(cmd != 'q') {
		if (line) {
			free(line);
		}
#ifdef HAVE_LIBREADLINE
		if (is_chrsp){
			if ((line = (char *) readline(mid->prompt)) == NULL) {
				return;
			}
		} else
#endif
		{
			int len;
			char *buf =(char *)malloc(CHUNK_SIZE);
			if ((line =(char *)fgets(buf,CHUNK_SIZE,stdin))==NULL) {
				free(buf);
				return;
			}
			/* seems some fgets implementations fon't replace
			the newline with a EOS marker */
			len = strlen(line);
			if( len && line[len-1] == '\n')
				line[len-1] = '\0';
		}
		/* find start and end of the command */
		for (start_cmd = line;
		     *start_cmd && isspace(*start_cmd);
		     start_cmd++)
			;
		/* empty lines are meaningfull in some interpreters, like mdb*/
		for(end_cmd = line + strlen(line) - 1;
		    isspace(*end_cmd);
		    end_cmd--)
			;
		n = 1 + end_cmd - start_cmd;
@-
The MapiClient terminal monitor provides common functionality,
such as directory changes, reading commands from a file,
redirection of output to a separate file.
@c
		/* is the string a command ? */
		switch(*start_cmd) {
		case '\\':
			switch(*(start_cmd+1)) {
			case 'r':
				SEND_MESSAGE(mid);
				continue;
			case 'q':
				cmd = 'q';
				continue;
			case 'b':
				mode = BLOCKMODE;
				continue;
			case 'l':
				mode = LINEMODE;
				/*FALLTHRU*/
			case 'c':
				m_index = 0; *message = 0;
				continue;
			}
			break;
		case '!':
			system(start_cmd+1);
			continue;
		case 'c':
			if ((start_cmd[1] == 'd') && isspace(start_cmd[2])) {
				if (chdir(start_cmd+3)) {
					char err[200];
					sprintf(err, "chdir: %s", start_cmd+3);
					perror(err);
				} else {
					fprintf(toConsole,"chdir to %s\n", start_cmd+3);
				}
				message[0] = m_index = 0;
				continue;
			}
			break;
		case '<':
			if ((fp = fopen(start_cmd+1, "r")) != NULL) {
				while ((n = fread(message+m_index, 1,
						  CHUNK_SIZE, fp)) != 0) {
					GROW_MESSAGE(n);
					/* echo to stdout */
					message[m_index] = 0;
					fwrite(message+m_index-n, 1, n, stdout);
				}
			}
			break;
@-
The output should be saved in a different file.
Ommision of a file name or failure to create it, resets
the output to the stdout. (Also >>)
@c
		case '>':
			if( n==1) {
				toConsole = stdout;
				fprintf(toConsole,"Redirect to standard output\n");
				continue;
			}
			if( strcmp(start_cmd+1,"stdout") == 0) {
				toConsole = stdout;
				continue;
			}
			if( strcmp(start_cmd+1,"stderr") == 0) {
				toConsole = stderr;
				continue;
			}
			toConsole = fopen(start_cmd+1,"w");
			if( toConsole == NULL ){
				toConsole = stdout;
				fprintf(toConsole,
				"! Unable to redirect to %s\n", start_cmd+1);
			} else
				printf("output switched to %s\n",start_cmd+1);
			continue;
@-
The commands available in the terminal monitor can be obtained
using its help operator '?'.
@c
		case '?':
			showCommands();
			continue;
		}
		/* copy the line to the end of the message */
		memcpy(message+m_index, start_cmd, n);
		GROW_MESSAGE(n);

		if (mode == LINEMODE) {
			SEND_MESSAGE(mid);
		}
	}
}

void usage( char *prog )
{
	(void) prog;
	fprintf(stderr, "Usage: MapiClient [ options ]\n");
	fprintf(stderr, "Options are:\n");
	fprintf(stderr, " -d          | --debug=[level]  /* set debug level */\n");
	fprintf(stderr, " -h hostname | --host=hostname  /* host to connect to */\n");
	fprintf(stderr, " -p portnr   | --port=portnr    /* port to connect to */\n");
	fprintf(stderr, " -l language | --language=lang  /* {mal,sql,mil} */\n");
	fprintf(stderr, " -u user     | --user=user      /* user id */\n" );
	fprintf(stderr, " -P passwd   | --passwd=passwd  /* password */\n");
	fprintf(stderr, " -e          | --error          /* exit on error */\n");
	fprintf(stderr, " -s stmt     | --statement=stmt /* run single statement */\n");
	fprintf(stderr, " -t          | --trace          /* trace Monet interaction */\n");
	fprintf(stderr, " -?          | --help           /* show this usage message */\n");
	exit(-1);
}

int main(int ac, char **av)
{
	char *prompt= NULL;
	char buf[BUFSIZ];
	char *prog = *av, *config = NULL, *passwd = NULL, *user = NULL;
	char *host=NULL;
#ifdef MONET5
	char *language = _strdup("mal");
#else
	char *language = _strdup("mil");
#endif
	int debug = 0, port = 0, setlen = 0, trace = 0;
	opt *set= NULL;

	char *command = NULL;

#ifdef HAVE_LIBREADLINE
	struct stat st;
#endif
	Mapi mid;

	static struct option long_options[] = {
		{"debug", 2, 0, 'd'},
		{"config", 1, 0, 'c'},
		{"host", 1, 0, 'h'},
		{"port", 1, 0, 'p'},
		{"passwd", 1, 0, 'P'},
		{"user", 1, 0, 'u'},
		{"language", 1, 0, 'l'},
		{"error", 1, 0, 'e'},
		{"statement", 1, 0, 's'},
		{"trace", 0, 0, 0},
		{"help", 0, 0, '?'},
		{0, 0, 0, 0}
	};

	if (!(setlen = mo_builtin_settings(&set)) )
		usage(av[0]);

	while(1){
		int option_index = 0;

		int c = getopt_long( ac, av, "c:d::Dh:p:P:u:s:S:l:e:?",
				long_options, &option_index);

		if (c == -1)
			break;

		switch (c){
		case 0:
			if (strcmp(long_options[option_index].name,
						"trace") == 0) {
				trace = 1;
				break;
			}
			/* all other long options are mapped on their short version */
			printf("option %s", long_options[option_index].name);
			if (optarg)
				printf( " with arg %s", optarg );
			printf("\n");
			usage(prog);
			break;
		case 'c':
			config = _strdup(optarg);
			break;
		case 'd':
			if (optarg){
				setlen = mo_add_option( &set, setlen,
					opt_cmdline, "debug", optarg );
			} else {
				setlen = mo_add_option( &set, setlen,
					opt_cmdline, "debug", "2" );
			}
			break;
		case 'e':
			exit_on_error=1;
			break;
		case 'h':
			setlen = mo_add_option( &set, setlen,
					opt_cmdline, "host", optarg );
			break;
		case 'l':
			if (optarg)
			language= _strdup(optarg);
			else printf("language argument missing\n");
			break;
		case 'p':
			{char *m= _strdup(optarg);
			port= strtol(m,NULL,10);
			setlen = mo_add_option( &set, setlen,
					opt_cmdline, "port", m );
			}
			break;
		case 'P':
			passwd = _strdup(optarg);
			break;
		case 's':
			command= _strdup(optarg);
			break;
		case 'u':
			user = _strdup(optarg);
			break;
		case '?':
			usage(prog);
		default:
			printf( "?? getopt returned character code 0%o ??\n",c);
			usage(prog);
		}
	}

	if (optind < ac){
		printf("some arguments are not parsed by getopt\n");
		while(optind < ac)
			printf("%s ", av[optind++]);
		printf("\n");
		usage(prog);
	}
#ifndef NO_LOCALE
	if (setlocale(LC_CTYPE, "") == NULL){/* why is this needed ? */
		fprintf(stderr, "WARN: cannot set locale\n");
	} else {
		char *codeset = NULL;
		if ((codeset = nl_langinfo(CODESET)) == NULL){
			fprintf(stderr, "WARN: cannot get codeset\n");
		} else {
			to_utf = iconv_open("UTF-8", codeset);
			from_utf = iconv_open(codeset, "UTF-8" );
		}
	}
#endif

	if (config){
		setlen = mo_config_file(&set, setlen, config );
		free(config);
	} else {
		if (!(setlen = mo_system_config(&set, setlen)) )
			usage(prog);
	}

	stream_init();
	if(debug==0){
		char *nme;
		nme=mo_find_option(set, setlen, "mapi_debug");
		if(nme) debug= strtol(nme, NULL, 10);
	}
	if(port==0){
		char *nme;
		nme=mo_find_option(set, setlen, "mapi_port");
		if(nme) port= strtol(nme, NULL, 10);
	}

	host= mo_find_option(set, setlen, "host");
	if (host == NULL) strcpy(host,"localhost");


	prompt = mo_find_option(set, setlen, "prompt");
	if (!prompt) {
		if(strcmp(language,"mal")) {
			char pbuf[256];
			snprintf(pbuf,sizeof(pbuf),"%s> ",language);
			prompt = _strdup(pbuf);
		} else
			prompt = _strdup(">");
	}

#ifdef HAVE_LIBREADLINE
	fstat(fileno(stdin),&st);
	if (S_ISCHR(st.st_mode))
		is_chrsp = 1;
#endif
/*
	if (!user)
		user = simple_prompt("User: ", BUFSIZ, 1 );
	if (!passwd)
		passwd = simple_prompt("Password: ", BUFSIZ, 0 );
*/

	toConsole = stdout;
	snprintf(buf,sizeof(buf),"%s:%d",host,port);
	mid = mapi_connect(buf, user, passwd,0);
	mid->trace = trace;
	if (mapi_error(mid)) {
		mapi_explain(mid,toConsole);
		fflush(toConsole);
		EXIT(2);
	}
#ifdef MONET5
	if( language && strcmp(language,"mal")){
		char lang[BUFSIZ];
		snprintf(lang,sizeof(lang),"%s();",language);
		doRequest(mid, lang);				\
	}
#endif


	if (command) {
		doRequest(mid, command );
	} else {
		terminalInput(mid);
	}
	return 0;
}
