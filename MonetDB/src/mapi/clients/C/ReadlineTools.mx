@h
#ifndef READLINETOOLS_H_INCLUDED
#define READLINETOOLS_H_INCLUDED
#include <monet_options.h>
#include "Mapi.h"
#ifdef HAVE_LIBREADLINE
#include <readline/readline.h>
#include <readline/history.h>


void init_readline(Mapi mid, const char *language, int save_history);
void deinit_readline();

char **sql_completion (const char *text, int start, int end);
char *sql_tablename_generator (const char *text, int state);
char *sql_command_generator (const char *text, int state);

char **mil_completion (const char *text, int start, int end);
char *mil_batname_generator (const char *text, int state);

#endif /* HAVE_LIBREADLINE */
#endif /* READLINETOOLS_H_INCLUDED */
@c
/*
 * Readline specific stuff
 */
#include "ReadlineTools.h"

#ifdef HAVE_LIBREADLINE

#ifdef HAVE_STRINGS_H
#include <strings.h>		/* for strncasecmp */
#endif

#define PATHLENGTH	256		/* maximum file pathname length. */ 

const char *SQL_COMMANDS[] = {	"SELECT", "INSERT", "UPDATE", "SET", "DELETE", "COMMIT", "ROLLBACK", 
		  		"DROP TABLE", "CREATE", "ALTER", "RELEASE SAVEPOINT", "START TRANSACTION", 0};

Mapi _mid;
char _history_file[PATHLENGTH];
int _save_history = 0;

void 
init_readline(Mapi mid, const char *language, int save_history)
{
	_mid = mid;
	/* Allow conditional parsing of the ~/.inputrc file. */
	rl_readline_name = "MapiClient";
	/* Tell the completer that we want to try our own completion before std completion (filename) kicks in. */
	if (strcmp(language, "sql")==0) {
		rl_attempted_completion_function = sql_completion;
	} else {
		rl_attempted_completion_function = mil_completion;
	}

	if (save_history) {
#ifndef NATIVE_WIN32
		if (getenv("HOME")!=NULL) {
			snprintf(_history_file, PATHLENGTH, "%s/.mapiclient_history_%s", getenv("HOME"), language);
			_save_history = 1;
		}
#else
		snprintf(_history_file, PATHLENGTH, "%s%c_mapiclient_history_%s", mo_find_option(&set, setlen, "prefix"), DIR_SEP, language);
		_save_history = 1;
#endif
		read_history(_history_file);
	}
}

void
deinit_readline()
{
	if (_save_history) {
		write_history(_history_file);
	}
}


char **
sql_completion (const char *text, int start, int end)
{
	char **matches;

	matches = (char **)NULL;

	if (start==0 || end == 0) {
	}	
	/* FIXME: Nice, context-sensitive completion strategy should go here */
	if (start == 0) {
		matches = rl_completion_matches (text, sql_command_generator);
	} else {
		matches = rl_completion_matches (text, sql_tablename_generator);
	}

	return (matches);
}

char *sql_tablename_generator (const char *text, int state) {

	static int seekpos, len, rowcount;
	static MapiHdl table_hdl;
	char *name;

	if (!state) {
		seekpos = 0;
      		len = strlen (text);
		if ((table_hdl = mapi_query(_mid, "SELECT name FROM tables"))==NULL || mapi_error(_mid)) {
			if (table_hdl) {
				mapi_explain_query(table_hdl, stderr);
				mapi_close_handle(table_hdl);
			} else
				mapi_explain(_mid, stderr);
			return NULL;
		}
		mapi_fetch_all_rows(table_hdl);
		rowcount = mapi_get_row_count(table_hdl);
    	}

	while (seekpos < rowcount) {
		mapi_seek_row(table_hdl, seekpos++, MAPI_SEEK_SET);
		mapi_fetch_row(table_hdl);
		name = mapi_fetch_field(table_hdl, 0);
		if (strncmp(name, text, len) == 0) 
			return strdup(name);
	}

	return NULL;
}

/* SQL commands (at start of line) */
char *sql_command_generator (const char *text, int state) {

	static int index, len;
	const char *name;
	if (!state) {
		index = 0;
		len = strlen(text);
	}

	
	while ((name = SQL_COMMANDS[index++])) {
#ifdef HAVE_STRNCASECMP
		if (strncasecmp(name, text, len)==0)
#else
		if (strncmp(name, text, len)==0)
#endif
			return strdup(name);
	}

	return NULL;
}

char **
mil_completion (const char *text, int start, int end)
{
	char **matches;

	matches = (char **)NULL;

	if (start==0 || end == 0) {
	}

	/* FIXME: Nice, context-sensitive completion strategy should go here */
	matches = rl_completion_matches (text, mil_batname_generator);

	return (matches);
}

char *mil_batname_generator (const char *text, int state) {

	static int seekpos, len, rowcount;
	static MapiHdl table_hdl;
	char *name;

	if (!state) {
		seekpos = 0;
      		len = strlen (text);
		if ((table_hdl = mapi_query(_mid, "ls;"))==NULL || mapi_error(_mid)) {
			if (table_hdl) {
				mapi_explain_query(table_hdl, stderr);
				mapi_close_handle(table_hdl);
			} else
				mapi_explain(_mid, stderr);
			return NULL;
		}
		mapi_fetch_all_rows(table_hdl);
		rowcount = mapi_get_row_count(table_hdl);
    	} else {
	}

	while (seekpos < rowcount) {
		mapi_seek_row(table_hdl, seekpos++, MAPI_SEEK_SET);
		mapi_fetch_row(table_hdl);
		name = mapi_fetch_field(table_hdl, 0);
		if (strncmp(name, text, len) == 0) 
			return strdup(name);
	}

	return NULL;
}


#endif /* HAVE_LIBREADLINE */
