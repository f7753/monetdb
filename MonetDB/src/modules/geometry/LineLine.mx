@f LineLine
@A C.W. Quak
@h
#ifndef __LINELINE_H__
#define __LINELINE_H__

extern bool Relate(const Line& l1,const Line& l2,const char matrix[9]);
extern int intRelate(const Line& l1,const Line& l2,Line& isection);
extern relationship Relate(const Line& l1,const Line& l2);
extern BAT* relate_histogram();

extern void split(
   const segment& s1,
   const segment& s2,
   oid o1,
   oid o2,
   BAT* oid_segid,
   BAT* oid_segpos,
   BAT* oid_ipoint);

#endif /* __LINELINE_H__ */
@C
#include "geometry.h"
#include "opengis.h"

//
//===============================================
// Dimensionally Extended Nine-Intersection Model
//===============================================
//

bool Relate(const Line& l1,const Line& l2,const char matrix[9])
{
   return(Relate(l1,l2).match(matrix));
}

int intRelate(const Line& s1,const Line& s2,Line& isection)
{
   int dimension = baserelate(s1,s2,isection);

   if (dimension == -1)
   {
      return(relationship::DISJOINT);
   }
   else
   {
      if (dimension == 0)
      {
         if (s1.hasendpoint(isection.source))
	 {
	    if (s2.hasendpoint(isection.source))
	       return(relationship::TOUCH);
	    else
	       return(relationship::LEINR);
	 }
	 else
	 {
	    if (s2.hasendpoint(isection.source))
	       return(relationship::REINL);
	    else
	       return(relationship::CROSS);
	 }
      }
      else
      {
	 if (equivalent(isection.source,s1.startPoint()) && equivalent(isection.dest,s1.endPoint()))
	 {
	    if ((equivalent(s1.startPoint(),s2.startPoint()) && equivalent(s1.endPoint(),s2.endPoint())) ||
		(equivalent(s1.startPoint(),s2.endPoint()) && equivalent(s1.endPoint(),s2.startPoint())))
	       return(relationship::EQUAL);
	    else
	    {
	       if (s2.hasendpoint(isection.source) ||
	       s2.hasendpoint(isection.dest))
		  return(relationship::LIN2R);
	       else
		  return(relationship::LINR);
	    }
	 }
	 else
	 {
	    if (s2.hasendpoint(isection.source) && s2.hasendpoint(isection.dest))
	    {
	       if (s1.hasendpoint(isection.source) ||
	       s1.hasendpoint(isection.dest))
		  return(relationship::RIN2L);
	       else
		  return(relationship::RINL);
	    }
	    else
	       return(relationship::OVERLAP);
	 }
      }
   }
}

int relatehistogram[] = { 0,0,0,0,0,0,0,0,0,0,0,0,0,0 };

relationship Relate(const Line& s1,const Line& s2)
{
   Line dummy;
   int rel = intRelate(s1,s2,dummy);
   ++relatehistogram[rel];
   switch(rel)
   {
      case relationship::DISJOINT: return(relationship(
	 -1,-1, 1,
	 -1,-1, 0,
	  1, 0, 2));
      case relationship::TOUCH: return(relationship(
	 -1,-1, 1,
	 -1, 0, 0,
	  1, 0, 2));
      case relationship::REINL: return(relationship(
	 -1, 0, 1,
	 -1,-1, 0,
	  1, 0, 2));
      case relationship::LEINR: return(relationship(
	 -1,-1, 1,
	  0,-1, 0,
	  1, 0, 2));
      case relationship::CROSS: return(relationship(
	  0,-1, 1,
	 -1,-1, 0,
	  1, 0, 2));
      case relationship::EQUAL: return(relationship(
	  1,-1,-1,
	 -1, 0,-1,
	 -1,-1, 2));
      case relationship::LINR: return(relationship(
	  1,-1,-1,
	  0,-1,-1,
	  1, 0, 2));
      case relationship::RINL: return(relationship(
	  1, 0, 1,
	 -1,-1, 0,
	 -1,-1, 2));
      case relationship::LIN2R: return(relationship(
	  1,-1,-1,
	  0, 0,-1,
	  1, 0, 2));
      case relationship::RIN2L: return(relationship(
	  1, 0, 1,
	 -1, 0, 0,
	 -1,-1, 2));
      case relationship::OVERLAP: return(relationship(
	  1, 0, 1,
	  0,-1, 0,
	  1, 0, 2));
      default:
         GDKerror("If your public hair's on fire: SOMETHING'S WRONG\n");
          return(relationship(
	  1, 0, 1,
	  0,-1, 0,
	  1, 0, 2));
   }
}


BAT* relate_histogram()
{
   BAT* rval = BATnew(TYPE_str,TYPE_int,15);

   BUNins(rval,(void *)"DISJOINT",&relatehistogram[relationship::DISJOINT]);
   BUNins(rval,(void *)"TOUCH",&relatehistogram[relationship::TOUCH]);
   BUNins(rval,(void *)"REINL",&relatehistogram[relationship::REINL]);
   BUNins(rval,(void *)"LEINR",&relatehistogram[relationship::LEINR]);
   BUNins(rval,(void *)"CROSS",&relatehistogram[relationship::CROSS]);
   BUNins(rval,(void *)"EQUAL",&relatehistogram[relationship::EQUAL]);
   BUNins(rval,(void *)"LINR",&relatehistogram[relationship::LINR]);
   BUNins(rval,(void *)"RINL",&relatehistogram[relationship::RINL]);
   BUNins(rval,(void *)"LIN2R",&relatehistogram[relationship::LIN2R]);
   BUNins(rval,(void *)"RIN2L",&relatehistogram[relationship::RIN2L]);
   BUNins(rval,(void *)"OVERLAP",&relatehistogram[relationship::OVERLAP]);

   return(rval);
}

void split(
   const segment& s1,
   const segment& s2,
   oid segid1,
   oid segid2,
   BAT* oid_segid,
   BAT* oid_segpos,
   BAT* oid_location)
{
   segment isection;
   int dimension = baserelate(s1,s2,isection);

   if (dimension == -1)
   {
      //
      // No need to split.
      //
   }
   else
   {
      double i1pos = s1.positionof(isection.source);
      if ((i1pos != 0) && (i1pos != 1))
      {
	 oid newid = OIDnew(1);
	 BUNins(oid_segid,&newid,&segid1);
	 BUNins(oid_segpos,&newid,&i1pos);
	 BUNins(oid_location,&newid,&isection.source);
      }

      double i2pos = s2.positionof(isection.source);
      if ((i2pos != 0) && (i2pos != 1))
      {
	 oid newid = OIDnew(1);
	 BUNins(oid_segid,&newid,&segid2);
	 BUNins(oid_segpos,&newid,&i2pos);
	 BUNins(oid_location,&newid,&isection.source);
      }

      if (isection.source != isection.dest)
      {
	 double i1pos = s1.positionof(isection.dest);
	 if ((i1pos != 0) && (i1pos != 1))
	 {
	    oid newid = OIDnew(1);
	    BUNins(oid_segid,&newid,&segid1);
	    BUNins(oid_segpos,&newid,&i1pos);
	    BUNins(oid_location,&newid,&isection.dest);
	 }

	 double i2pos = s2.positionof(isection.dest);
	 if ((i2pos != 0) && (i2pos != 1))
	 {
	    oid newid = OIDnew(1);
	    BUNins(oid_segid,&newid,&segid2);
	    BUNins(oid_segpos,&newid,&i2pos);
	    BUNins(oid_location,&newid,&isection.dest);
	 }
      }
   }
}
