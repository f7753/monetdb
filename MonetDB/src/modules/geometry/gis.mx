@f gis
@A C.W. Quak
@* The module 'gis'
@T
This module contains the Monet interface to all the operations which exist on
spatial atomic types. The types that are currently supported are; {\tt point, box,
segment, circle, polyline, polygon and cpolygon}.
Monet support for geo.

The new spatial types have the following syntax:

{\small
\begin{verbatim}
   POINT ::= '(' DBL ',' DBL ')' ;
   BOX ::= '(' DBL ',' DBL ',' DBL ',' DBL ')' ;
   SEGMENT ::= '(' POINT ',' POINT ')' ;
   TRIANGLE ::= '(' POINT ',' POINT ',' POINT ')' ;
   CIRCLE ::= '(' POINT ',' DBL ')' ;
   POLYGON ::= '(' INT ':' DOUBLE ',' DOUBLE { ',' DOUBLE ',' DOUBLE } ')' ;
   POLYLINE :: '(' INT ':' DOUBLE ',' DOUBLE [ ',' DOUBLE ',' DOUBLE ] ')' ;
   CPOLYGON ::= '(' INT ',' INT ':' POLYGON { ',' POLYGON  } ')' ;
\end{verbatim}}

@m
.MODULE gis;

   .USE mmath,gdkmem;

   .ATOM point[16,8];
      .TOSTR   = point_tostr;
      .FROMSTR = point_fromstr;
      .COMP    = point_comp;
      .HASH    = point_hash;
      .NULL    = point_null;
      .CONVERT = point_convert;
   .END;

   .ATOM point3d[24,8];
      .TOSTR   = point3d_tostr;
      .FROMSTR = point3d_fromstr;
      .NEQUAL  = point3d_comp;
      .HASH    = point3d_hash;
      .NULL    = point3d_null;
      .CONVERT = point3d_convert;
   .END;

   .ATOM box3d[48,8];
      .TOSTR   = box3d_tostr;
      .FROMSTR = box3d_fromstr;
      .NEQUAL  = box3d_comp;
      .HASH    = box3d_hash;
      .NULL    = box3d_null;
      #.CONVERT = box3d_convert;
   .END;

   .ATOM triangle3d[72,8];
      .TOSTR   = triangle3d_tostr;
      .FROMSTR = triangle3d_fromstr;
      .NEQUAL  = triangle3d_comp;
      .HASH    = triangle3d_hash;
      .NULL    = triangle3d_null;
      .CONVERT = triangle3d_convert;
   .END;

   .ATOM triangle[48,8];
      .TOSTR   = triangle_tostr;
      .FROMSTR = triangle_fromstr;
      .NEQUAL  = triangle_comp;
      .HASH    = triangle_hash;
      .NULL    = triangle_null;
      .CONVERT = triangle_convert;
   .END;

   .ATOM box[32,8];
      .TOSTR   = box_tostr;
      .FROMSTR = box_fromstr;
      .NEQUAL  = box_comp;
      .HASH    = box_hash;
      .NULL    = box_null;
      .CONVERT = box_convert;
   .END;

   .ATOM circle[24,8];
      .TOSTR   = circle_tostr;
      .FROMSTR = circle_fromstr;
      .NEQUAL  = circle_comp;
      .HASH    = circle_hash;
      .NULL    = circle_null;
      .CONVERT = circle_convert;
   .END;

   .ATOM segment[32,8];
      .TOSTR   = segment_tostr;
      .FROMSTR = segment_fromstr;
      .NEQUAL  = segment_comp;
      .HASH    = segment_hash;
      .NULL    = segment_null;
      .CONVERT = segment_convert;
   .END;

   .ATOM polyline;
      .TOSTR   = polyline_tostr;
      .FROMSTR = polyline_fromstr;
      .NEQUAL  = polyline_comp;
      .DEL     = polyline_del;
      .HASH    = polyline_hash;
      .NULL    = polyline_null;
      .CONVERT = polyline_convert;
      .PUT     = polyline_put;
      .LENGTH  = polyline_length;
      .HEAP    = polyline_heap;
      .CHECK   = polyline_heapcheck;
   .END;

   .ATOM multipoint;
      .TOSTR   = multipoint_tostr;
      .FROMSTR = multipoint_fromstr;
      .NEQUAL  = multipoint_comp;
      .DEL     = multipoint_del;
      .HASH    = multipoint_hash;
      .NULL    = multipoint_null;
      .PUT     = multipoint_put;
      .LENGTH  = multipoint_length;
      .HEAP    = multipoint_heap;
      .CHECK   = multipoint_heapcheck;
   .END;

   .ATOM polygon;
      .TOSTR   = polygon_tostr;
      .FROMSTR = polygon_fromstr;
      .NEQUAL  = polygon_comp;
      .DEL     = polygon_del;
      .HASH    = polygon_hash;
      .NULL    = polygon_null;
      .CONVERT = polygon_convert;
      .PUT     = polygon_put;
      .LENGTH  = polygon_length;
      .HEAP    = polygon_heap;
      .CHECK   = polygon_heapcheck;
   .END;

   .ATOM cpolygon;
      .TOSTR   = cpolygon_tostr;
      .FROMSTR = cpolygon_fromstr;
      .NEQUAL  = cpolygon_comp;
      .DEL     = cpolygon_del;
      .HASH    = cpolygon_hash;
      .NULL    = cpolygon_null;
      .CONVERT = cpolygon_convert;
      .PUT     = cpolygon_put;
      .LENGTH  = cpolygon_length;
      .HEAP    = cpolygon_heap;
      .CHECK   = cpolygon_heapcheck;
   .END;

   .ATOM minitree;
      .TOSTR   = minitree_tostr;
      .FROMSTR = minitree_fromstr;
      .NEQUAL  = minitree_comp;
      .DEL     = minitree_del;
      .HASH    = minitree_hash;
      .NULL    = minitree_null;
      .CONVERT = minitree_convert;
      .PUT     = minitree_put;
      .LENGTH  = minitree_length;
      .HEAP    = minitree_heap;
      .CHECK   = minitree_heapcheck;
   .END;

   .ATOM interval[16,8];
      .TOSTR   = interval_tostr;
      .FROMSTR = interval_fromstr;
      .NEQUAL  = interval_comp;
      .HASH    = interval_hash;
      .NULL    = interval_null;
      .CONVERT = interval_convert;
   .END;

   .OPERATOR (point)     "="     (point)    : bit = point_equals_point; ""
   .OPERATOR (point)     "!="    (point)    : bit = point_notequals_point; ""

   .OPERATOR (triangle3d)     "="     (triangle3d)    : bit = triangle3d_equals_triangle3d; ""
   .OPERATOR (triangle3d)     "!="    (triangle3d)    : bit = triangle3d_notequals_triangle3d; ""

   .OPERATOR (point3d)     "="     (point3d)    : bit = point3d_equals_point3d; ""
   .OPERATOR (point3d)     "!="    (point3d)    : bit = point3d_notequals_point3d; ""

   .OPERATOR (box)       "="     (box)      : bit = box_equals_box; ""
   .OPERATOR (box)       "!="    (box)      : bit = box_notequals_box; ""

   .OPERATOR (circle)    "="     (circle)   : bit = circle_equals_circle; ""
   .OPERATOR (circle)    "!="    (circle)   : bit = circle_notequals_circle; ""

   .OPERATOR (segment)   "="     (segment)  : bit = segment_equals_segment; ""
   .OPERATOR (segment)   "!="    (segment)  : bit = segment_notequals_segment; ""

   .OPERATOR (polyline)  "="     (polyline) : bit = polyline_equals_polyline; ""
   .OPERATOR (polyline)  "!="    (polyline) : bit = polyline_notequals_polyline; ""

   .OPERATOR (polygon)   "="     (polygon)  : bit = polygon_equals_polygon; ""
   .OPERATOR (polygon)   "!="    (polygon)  : bit = polygon_notequals_polygon; ""

   .OPERATOR (cpolygon)   "="    (cpolygon) : bit = cpolygon_equals_cpolygon; ""
   .OPERATOR (cpolygon)   "!="   (cpolygon) : bit = cpolygon_notequals_cpolygon; ""

   .COMMAND bbox(polygon)	: box		= polygon_bbox; "Returns minimum boundin rectangle of given polygon"
   .COMMAND bbox(cpolygon)	: box		= cpolygon_bbox; "Returns minimum bounding rectangle of given Complex Polygon"
   .COMMAND bbox(polyline)	: box 		= polyline_bbox; "Returns minimum bounding rectangle of given Polyline"
   .COMMAND bbox(segment)	: box		= segment_bbox; "Returns minimum bounding rectangle of given segment"
   .COMMAND bbox(circle)	: box		= circle_bbox; "Returns minimum bounding rectangle of given circle"
   .COMMAND bbox(box)		: box		= box_bbox; "Returns minimum bounding rectangle of given box"
   .COMMAND bbox(point)		: box		= point_bbox; "Returns minimum bounding rectangle of given point"

   .COMMAND bbox(box3d)		: box3d		= box3d_bbox; "Returns minimum bounding rectangle of given box"
   .COMMAND xinterval(box3d)	: interval	= box3d_xinterval; "Returns xinterval of box3d"
   .COMMAND yinterval(box3d)	: interval	= box3d_yinterval; "Returns yinterval of box3d"
   .COMMAND zinterval(box3d)	: interval	= box3d_zinterval; "Returns zinterval of box3d"
   .COMMAND setmaxz(box3d,dbl)	: box3d		= box3d_setmaxz; ""
   .COMMAND setminz(box3d,dbl)	: box3d		= box3d_setminz; ""

   .COMMAND rotate(triangle,dbl)	: triangle	= triangle_rotate; "Rotate triangle by given angle around origin"
   .COMMAND rotate(point,dbl)		: point		= point_rotate; "Rotate point by given angle around origin"
   .COMMAND rotate(polygon,dbl)		: polygon	= polygon_rotate; "Rotate polygon by given angle around origin"
   .COMMAND rotate(polyline,dbl)	: polyline	= polyline_rotate; "Rotate polyline by given angle around origin"
   .COMMAND scale(point,dbl)		: point		= point_scale; "Scale point by given factor"
   .COMMAND scale(polygon,dbl)		: polygon	= polygon_scale; "Scale polygon by given factor"
   .COMMAND scale(polyline,dbl)		: polyline	= polyline_scale; "Scale polyline by given factor"
   .COMMAND scale(triangle,dbl)		: triangle	= triangle_scale; "Scale triangle by given factor"
   .COMMAND translate(triangle,point)	: triangle	= triangle_translate; "Translate triangle along given vector (point)"
   .COMMAND translate(point,point)	: point		= point_translate; "Translate point along given vector (point)"
   .COMMAND translate(polygon,point)	: polygon	= polygon_translate; "Translate polygon along given vector (point)"
   .COMMAND translate(polyline,point)	: polyline	= polyline_translate; "Translate polyline along given vector (point)"

   .COMMAND area(box)		: dbl	= box_area; "Return area of given box"
   .COMMAND area(polygon)	: dbl	= polygon_area; "Return area of given polygon"
   .COMMAND area(cpolygon)	: dbl	= cpolygon_area; "Return area of given cpolygon"
   .COMMAND area(circle)		: dbl	= circle_area; "Return area of given circle"
   .COMMAND area(triangle)	: dbl	= triangle_area; "Return area of given triangle"

   .COMMAND hash_val(cpolygon)	: int	= cpolygon_hash_val; "Return hash value of given cpolygon"
   .COMMAND hash_val(triangle)	: int	= triangle_hash_val; "Return hash value of given triangle"
   .COMMAND hash_val(box)	: int	= box_hash_val; "Return hash value of given box"
   .COMMAND hash_val(circle)	: int	= circle_hash_val; "Return hash value of given circle"
   .COMMAND hash_val(polygon)	: int	= polygon_hash_val; "Return hash value of given polygon"
   .COMMAND hash_val(polyline)	: int	= polyline_hash_val; "Return hash value of given polyline"
   .COMMAND hash_val(segment)	: int	= segment_hash_val; "Return hash value of given segment"
   .COMMAND hash_val(point)	: int	= point_hash_val; "Return hash value of given point"

   .COMMAND nbytes(cpolygon)	: int	= cpolygon_nbytes; "Return number of bytes occupied by cpolygon"
   .COMMAND nbytes(polygon)	: int	= polygon_nbytes; "Return number of bytes occupied by polygon"
   .COMMAND nbytes(polyline)	: int	= polyline_nbytes; "Return number of bytes occupied by polyline"

   .COMMAND ok(interval)	: bit	= interval_ok; "Perform internal integrity check on interval"
   .COMMAND ok(cpolygon)	: bit	= cpolygon_ok; "Perform internal integrity check on cpolygon"
   .COMMAND ok(triangle)	: bit	= triangle_ok; "Perform internal integrity check on triangle"
   .COMMAND ok(box)		: bit	= box_ok; "Perform internal integrity check on box"
   .COMMAND ok(circle)		: bit	= circle_ok; "Perform internal integrity check on circle"
   .COMMAND ok(polygon)		: bit	= polygon_ok; "Perform internal integrity check on polygon"
   .COMMAND ok(polyline)	: bit	= polyline_ok; "Perform internal integrity check on polyline"
   .COMMAND ok(segment)		: bit	= segment_ok; "Perform internal integrity check on segment"
   .COMMAND ok(point)		: bit	= point_ok; "Perform internal integrity check on point"

   .COMMAND monotone(polygon,int,int) : bit	= polygon_monotone; ""
   .COMMAND monotone(polyline,int,int) : bit	= polyline_monotone; ""

   .COMMAND convex_hull(polygon)	: polygon = polygon_chull; ""
   .COMMAND convex_hull(cpolygon)	: polygon = cpolygon_chull; ""
   .COMMAND convex_hull(polyline)	: polygon = polyline_chull; ""
   .COMMAND convex_hull(bat[any,point])	: polygon = points_chull; ""

   .COMMAND point_rand()	: point = point_rand; ""
   .COMMAND points_rand(int n)	: bat[oid,point] = points_rand; ""

   .COMMAND multiply(polygon,dbl)	: polygon	= polygon_multiply; ""
   .COMMAND divide(polygon,dbl)		: polygon	= polygon_divide; ""
   .COMMAND add(polygon,point)		: polygon	= polygon_add; ""
   .COMMAND subtract(polygon,point)	: polygon	= polygon_subtract; ""

   .COMMAND multiply(polyline,dbl)	: polyline	= polyline_multiply; ""
   .COMMAND divide(polyline,dbl)	: polyline	= polyline_divide; ""
   .COMMAND add(polyline,point)		: polyline	= polyline_add; ""
   .COMMAND subtract(polyline,point)	: polyline	= polyline_subtract; ""

   .COMMAND multiply(box,dbl)		: box	= box_multiply; ""
   .COMMAND divide(box,dbl)		: box	= box_divide; ""
   .COMMAND add(box,point)		: box	= box_add; ""
   .COMMAND subtract(box,point)		: box	= box_subtract; ""

   .COMMAND multiply(point,dbl)		: point	= point_multiply; ""
   .COMMAND divide(point,dbl)		: point	= point_divide; ""
   .COMMAND add(point,point)		: point	= point_add; ""
   .COMMAND subtract(point,point)	: point	= point_subtract; ""

   .COMMAND xcoord(point) : dbl				= point_xcoord; "Return x-coordinate of given point"
   .COMMAND ycoord(point) : dbl				= point_ycoord; "Return y-coordinate of given point"
   .COMMAND create(dbl x,dbl y) : point			= point_create; "Create point with given x and y coordinates"

   .COMMAND left(box)            : dbl			= box_left; "Return left margin of box"
   .COMMAND right(box)           : dbl			= box_right; "Return right margin of box"
   .COMMAND top(box)             : dbl			= box_top; "Return top margin of box"
   .COMMAND bottom(box)          : dbl			= box_bottom; "Return bottom margin of box"
   .COMMAND width(box)		: dbl			= box_width; "Return width of box"
   .COMMAND height(box)		: dbl			= box_height; "Return height of box"
   .COMMAND center(box)		: point			= box_center; "Return centerpoint of box"
   .COMMAND topolygon(box)	: polygon		= box_topolygon; "Convert box to polygon"
   .COMMAND topolyline(box)	: polyline		= box_topolyline; "Return boundary of box as polyline"

   .COMMAND center(circle)       : point        	= circle_center; "Return centerpoint of circle"
   .COMMAND radius(circle)       : dbl			= circle_radius; "Return radius of circle"

   .COMMAND create_circle(point p1,point p2) : circle = circle_create_point_point; "Return smallest circle through 2 given boundary points"
   .COMMAND create_circle(point p1,point p2,point p3) : circle = circle_create_point_point_point; "Return smallest circle through 3 given boundary points"

   .COMMAND north(box)            : segment		= box_north; "Return top segment of box"
   .COMMAND south(box)            : segment		= box_south; "Return bottom segment of box"
   .COMMAND east(box)             : segment		= box_east; "Return left segment of box"
   .COMMAND west(box)             : segment		= box_west; "Return right segment of box"

   .COMMAND index(triangle,int)	: point				= triangle_index; ""
   .COMMAND create(point p1,point p2,point p3)	: triangle	= triangle_create; "Create triangle with p1,p2,p3 as cornerpoints"
   .COMMAND clockwise(triangle)	: bit				= triangle_clockwise; "Return whether triangle has clockwise orientation"
   .COMMAND topolygon(triangle)	: polygon			= triangle_topolygon; "Convert triangle to polygon"
   .COMMAND topolyline(triangle): polyline			= triangle_topolyline; "Convert triangle to polyline"
   .COMMAND centroid(triangle)	: point				= triangle_centroid; "Calculate centroid of triangle"
   .COMMAND pnt1(triangle):point = triangle_p1; "Return corner point 1 of triangle"
   .COMMAND pnt2(triangle):point = triangle_p2; "Return corner point 2 of triangle"
   .COMMAND pnt3(triangle):point = triangle_p3; "Return corner point 3 of triangle"

   .COMMAND length(segment)      : dbl	        		 = segment_length; "Return length of segment"
   .COMMAND src(segment)         : point        		 = segment_source; "Return source of segment"
   .COMMAND dest(segment)        : point        		 = segment_dest; "Return destination of segment"
   .COMMAND reverse(segment)     : segment      		 = segment_reverse; "Return segment with source and destination swapped"
   .COMMAND topolyline(segment)  : polyline      		 = segment_topolyline; "Return segment as polyline"
   .COMMAND create(point source,point destination) : segment	 = segment_create; "Create segment with given source and destination"

   .COMMAND src(polyline)                : point	= polyline_source; ""
   .COMMAND src_direction(polyline)      : dbl		= polyline_source_direction; ""
   .COMMAND npoints(polyline)            : int		= polyline_npoints; ""
   .COMMAND dest(polyline)               : point	= polyline_dest; ""
   .COMMAND dest_direction(polyline)      : dbl		= polyline_dest_direction; ""
   .COMMAND index(polyline,int)          : point	= polyline_index; ""
   .COMMAND closed(polyline)             : bit		= polyline_closed; ""
   .COMMAND selfintersect(polyline)      : bit		= polyline_selfintersect; ""
   .COMMAND reverse(polyline)            : polyline	= polyline_reverse; ""
   .COMMAND interior(polyline)		 : polygon	= polyline_interior; ""
   .COMMAND sgmt(polyline,int)		 : segment	= polyline_sgmt; ""
   .COMMAND intersect(polyline,polyline) : bit		= intersect_pln_pln; ""
   .COMMAND length(polyline)             : dbl	        = polyline_line_length; "Return length of segment"

   .COMMAND index(polygon,int)		: point		= polygon_index; ""
   .COMMAND npoints(polygon)		: int		= polygon_npoints; ""
   .COMMAND clockwise(polygon)		: bit		= polygon_clockwise; ""
   .COMMAND boundary(polygon)		: polyline	= polygon_boundary; ""
   .COMMAND reverse(polygon)		: polygon	= polygon_reverse; ""
   .COMMAND gcenter(polygon)		: point		= polygon_gcenter; ""
   .COMMAND remove_dups(polygon)	: polygon	= polygon_remove_dups; ""
   .COMMAND lower_res(polygon,dbl)	: polygon	= polygon_lower_res; ""

   .COMMAND baserelate(segment s1,segment s2) : segment = segment_baserelate; ""

   .COMMAND boundary(cpolygon)          : polygon            = cpolygon_boundary; "Return boundary of cpolygon"
   .COMMAND topolygon(cpolygon)         : polygon            = cpolygon_topolygon; ""
   .COMMAND nholes(cpolygon)            : int                = cpolygon_nholes; "Return number of holes in cpolygon"
   .COMMAND hole(cpolygon,int number)   : polygon            = cpolygon_hole; "Return geometry of a hole in cpolygon. number should be between 0 and nholes"
   .COMMAND create(polygon)           	: cpolygon           = cpolygon_create; "Create a cpolygon without holes with the given polygon as boundary"
   .COMMAND addhole(cpolygon c,polygon p): cpolygon          	= cpolygon_addhole; "Append polygon p as a hole to cpolygon c and return it"
   .COMMAND info(cpolygon)           	 		     	= cpolygon_info; "Print some info on the cpolygon as GDKwarnings"
   .COMMAND npoints(cpolygon)           : int		     	= cpolygon_npoints; "Return the total number of points in this polygon. this is the sum of the npoints of holes and boundary"
   .COMMAND append(polyline p1,polyline p2)	: polyline	= polyline_append; "Append the polylines p1 and p2. PRE: p1.dest == p2.src or one of the polylines is empty"

   @:reldec(distance,point,point,dbl)@
   @:reldec(distance,point,segment,dbl)@
   @:reldec(distance,point,box,dbl)@
   @:reldec(distance,point,circle,dbl)@
   @:reldec(distance,point,polyline,dbl)@
   @:reldec(distance,point,polygon,dbl)@
   @:reldec(distance,point,cpolygon,dbl)@

   @:reldec(distance,box,point,dbl)@
   @:reldec(distance,box,box,dbl)@

   @:reldec(distance,segment,point,dbl)@
   @:reldec(distance,segment,segment,dbl)@
   @:reldec(distance,segment,circle,dbl)@
   @:reldec(distance,segment,polyline,dbl)@
   @:reldec(distance,segment,polygon,dbl)@
   @:reldec(distance,segment,cpolygon,dbl)@

   @:reldec(distance,circle,point,dbl)@
   @:reldec(distance,circle,segment,dbl)@
   @:reldec(distance,circle,circle,dbl)@

   @:reldec(distance,polyline,point,dbl)@
   @:reldec(distance,polyline,segment,dbl)@
   @:reldec(distance,polyline,polyline,dbl)@
   @:reldec(distance,polyline,polygon,dbl)@
   @:reldec(distance,polyline,cpolygon,dbl)@

   @:reldec(distance,polygon,point,dbl)@
   @:reldec(distance,polygon,segment,dbl)@
   @:reldec(distance,polygon,polyline,dbl)@
   @:reldec(distance,polygon,polygon,dbl)@
   @:reldec(distance,polygon,cpolygon,dbl)@

   @:reldec(distance,cpolygon,point,dbl)@
   @:reldec(distance,cpolygon,segment,dbl)@
   @:reldec(distance,cpolygon,polyline,dbl)@
   @:reldec(distance,cpolygon,polygon,dbl)@
   @:reldec(distance,cpolygon,cpolygon,dbl)@

   @:reldec(inside,point,circle,bit)@
   @:reldec(inside,point,polygon,bit)@
   @:reldec(inside,point,cpolygon,bit)@

   @:reldec(inside,segment,circle,bit)@
   @:reldec(inside,segment,polygon,bit)@
   @:reldec(inside,segment,cpolygon,bit)@

   @:reldec(inside,polyline,circle,bit)@
   @:reldec(inside,polyline,polygon,bit)@
   @:reldec(inside,polyline,cpolygon,bit)@

   @:reldec(inside,polygon,circle,bit)@
   @:reldec(inside,polygon,polygon,bit)@
   @:reldec(inside,polygon,cpolygon,bit)@

   @:reldec(inside,cpolygon,circle,bit)@
   @:reldec(inside,cpolygon,polygon,bit)@
   @:reldec(inside,cpolygon,cpolygon,bit)@

   @:reldec(overlap,point,box,bit)@
   @:reldec(overlap,point,polyline,bit)@
   @:reldec(overlap,point,polygon,bit)@
   @:reldec(overlap,point,cpolygon,bit)@

   @:reldec(overlap,box,point,bit)@

   @:reldec(overlap,segment,point,bit)@
   @:reldec(overlap,segment,polyline,bit)@
   @:reldec(overlap,segment,polygon,bit)@
   @:reldec(overlap,segment,cpolygon,bit)@

   @:reldec(overlap,polyline,point,bit)@
   @:reldec(overlap,polyline,polyline,bit)@
   @:reldec(overlap,polyline,polygon,bit)@
   @:reldec(overlap,polyline,cpolygon,bit)@

   @:reldec(overlap,polygon,point,bit)@
   @:reldec(overlap,polygon,segment,bit)@
   @:reldec(overlap,polygon,polyline,bit)@
   @:reldec(overlap,polygon,polygon,bit)@
   @:reldec(pq_overlap,polygon,polygon,bit)@
   @:reldec(overlap,polygon,cpolygon,bit)@

   @:reldec(overlap,cpolygon,point,bit)@
   @:reldec(overlap,cpolygon,polyline,bit)@
   @:reldec(overlap,cpolygon,polygon,bit)@
   @:reldec(overlap,cpolygon,cpolygon,bit)@

@= reldec
   .COMMAND @1(@2,@3) : @4 = @1_@2_@3; "Return whether given @2 and @3 @1"
@
@m

   .COMMAND bbox(box3d,box3d)		: box3d		= bbox_box3d_box3d; ""
   .COMMAND bbox(box,box)		: box		= box_Bbox_box; ""
   .COMMAND bbox(bat[any,box]) : box = boxset_bbox; ""
   .COMMAND bbox(bat[any,box3d]) : box3d = box3dset_bbox; ""

   .COMMAND overlap(box,box)		: bit		= overlap_box_box; ""

   .COMMAND inside(point,box)		: bit = inside_point_box; ""
   .COMMAND inside(box,box)		: bit = inside_box_box; ""
   .COMMAND inside(circle,box)		: bit = inside_circle_box; ""
   .COMMAND inside(segment,box)		: bit = inside_segment_box; ""
   .COMMAND inside(triangle,box)		: bit = inside_triangle_box; ""
   .COMMAND inside(polyline,box)		: bit = inside_polyline_box; ""
   .COMMAND inside(polygon,box)		: bit = inside_polygon_box; ""
   .COMMAND inside(cpolygon,box)		: bit = inside_cpolygon_box; ""



   .COMMAND project(point,point,dbl) : point   = point_project; ""
   .COMMAND blowup(box,dbl)	: box		= box_blowup; ""

   .COMMAND point_add(point,point) : point = point_Add_point; ""
   .COMMAND point_div(point,dbl) : point = point_Div_double; ""
   .COMMAND point_rel(point,point) : point = point_Rel_point; ""
   .COMMAND point_dir(point) : dbl = point_Dir_double; ""

   .COMMAND center(segment)	: point		= segment_center; ""
   .COMMAND angle(segment)       : dbl        	= segment_angle; ""
   .COMMAND segment_length(segment)  : dbl        = seg_length; ""
   .COMMAND max_line(segment, segment) : segment = segment_max_line; ""

   .COMMAND dimension(box):int = dimension_box; ""
   .COMMAND dimension(circle):int = dimension_circle; ""
   .COMMAND dimension(cpolygon):int = dimension_cpolygon; ""
   .COMMAND dimension(point):int = dimension_point; ""
   .COMMAND dimension(polygon):int = dimension_polygon; ""
   .COMMAND dimension(polyline):int = dimension_polyline; ""
   .COMMAND dimension(segment):int = dimension_segment; ""
   .COMMAND dimension(triangle):int = dimension_triangle; ""

   .COMMAND angle(point,point,point) : dbl = angle_ppp; ""
   .COMMAND angle(dbl,dbl) : dbl = angle_dd; ""
   .COMMAND direction(point,point) : dbl = direction_pp; ""

   .COMMAND segments(bat[any,polyline])   : bat[any,segment] = polylines_segmentify; ""
   .COMMAND segments(bat[any,cpolygon])   : bat[any,segment] = cpolygons_segmentify; ""
   .COMMAND segments(bat[any,polygon])   : bat[any,segment] = polygons_segmentify; ""

   .COMMAND triangulate(polygon) : bat[oid,segment] = polygon_triangulate; ""
   .COMMAND triangulate(cpolygon) : bat[oid,segment] = cpolygon_triangulate; ""

   .COMMAND heapstatus(bat[any,polygon]) = heapstatus_polygon; ""
   .COMMAND heapstatus(bat[any,polyline]) = heapstatus_polyline; ""
   .COMMAND heapstatus(bat[any,cpolygon]) = heapstatus_cpolygon; ""

   .COMMAND hasminitree(polygon p) : bit	= polygon_hasminitree; "Return whether this polygon contains minitree"
   .COMMAND hasminitree(polyline p) : bit	= polyline_hasminitree; "Return whether this polyline contains minitree"
   .COMMAND hasminitree(cpolygon c) : bit	= cpolygon_hasminitree; "Return whether this cpolygon contains minitree"

   .COMMAND addminitree(cpolygon c,int maxleafsize) : cpolygon	= minitree_add_cpolygon; "Add minitrees to this cpolygon"
   .COMMAND addminitree(polyline p,int maxleafsize) : polyline	= minitree_add_polyline; "Add minitrees to this polylin"
   .COMMAND addminitree(polygon p,int maxleafsize) : polygon	= minitree_add_polygon; "Add minitrees to this polygon"

   .COMMAND removeminitree(polyline p) : polyline	= minitree_remove_polyline; "remove minitrees to this polylin"
   .COMMAND removeminitree(polygon p) : polygon		= minitree_remove_polygon; "remove minitrees to this polygon"

   .COMMAND mini_depth(polygon p) : int		= polygon_minitree_depth; "Return depth of associated minitree"
   .COMMAND mini_nnodes(polygon p) : int	= polygon_minitree_nnodes; "Return number of nodes of associated minitree"
   .COMMAND mini_nbytes(polygon p) : int	= polygon_minitree_nbytes; "Return number of bytes occupied by associated minitree"

   .COMMAND create_minitree(polygon p,int maxleafsize) : minitree	= minitree_create; "Create a minitree for polygon p with maximun nodesize mn"
   .COMMAND unite(polygon p,minitree m) : polygon		= minitree_unite; "Create a polygon with an integrated minitree"
   .COMMAND extract(polygon p) : minitree			= minitree_extract_polygon; "Extract a minitree from a polygon"
   .COMMAND extract(polyline p) : minitree			= minitree_extract_polyline; "Extract a minitree from a polyline"
   .COMMAND nbytes(minitree) : int 				= minitree_nbytes; ""
   .COMMAND nnodes(minitree) : int 				= minitree_nnodes; ""
   .COMMAND depth(minitree) : int 				= minitree_depth; ""
   .COMMAND distance(polygon p,minitree m,segment s) :dbl 	= minitree_distance_segment; "Return distance between p and s using minitree m."
   .COMMAND distance(polygon pgn,minitree m,point pnt) :dbl 	= minitree_distance_point; "Return distance between pgn and pnt using minitree m."
   .COMMAND inside(point pnt,polygon pgn,minitree m) :bit 	= minitree_point_in_polygon; "Return whether pnt is inside pgn using m."
   .COMMAND distance(polygon p1,minitree m1,polygon p2,minitree m2) :dbl = minitree_distance_polygon_polygon; "Return distance between two polyogns using minitrees."

   # .COMMAND split(polyline p1,polyline p2,oid i1,oid o2,bat[oid,oid],bat[oid,dbl],bat[oid,point]) = polyline_split; ""

   .COMMAND create_interval(dbl min,dbl max) : interval = interval_create; "Create interval"
   .COMMAND inside(dbl v,interval i): bit	= inside_dbl_interval; ""
   .COMMAND min(interval):dbl = interval_min; "Return min value of interval"
   .COMMAND max(interval):dbl = interval_max; "Return max value of interval"

   .COMMAND pnt1(triangle3d):point3d = triangle3d_p1; "Return corner point 1 of triangle3d"
   .COMMAND pnt2(triangle3d):point3d = triangle3d_p2; "Return corner point 2 of triangle3d"
   .COMMAND pnt3(triangle3d):point3d = triangle3d_p3; "Return corner point 3 of triangle3d"

   .COMMAND xcoord(point3d) : dbl	= point3d_xcoord; "Return x-coordinate of given point3d"
   .COMMAND ycoord(point3d) : dbl	= point3d_ycoord; "Return y-coordinate of given point3d"
   .COMMAND zcoord(point3d) : dbl	= point3d_zcoord; "Return z-coordinate of given point3d"


   .COMMAND tobox(box3d) : box				= box3d_tobox; "Convert box3d to a box"
   .COMMAND create(box,interval) : box3d		= box3d_create_2; ""
   .COMMAND create(interval,interval,interval) : box3d = box3d_create; "Create a box3d with given intervals"
   .COMMAND create(point3d,point3d,point3d) : triangle3d = triangle3d_create; "Create a triangle3d with given coordinates"
   .COMMAND create(dbl x,dbl y,dbl z) : point3d		= point3d_create; "Create point3d with given x, y and z coordinates"
   .COMMAND add(point3d,point3d) :point3d		= add_point3d_point3d; "Add the given vectors"
   .COMMAND angle(point3d) :dbl				= angle_point3d; "Calculate the angle between this vector and the z=0 plane"
   .COMMAND distance(point3d,point3d) :dbl		= distance_point3d_point3d; "return the distance between the given vectors"
   .COMMAND perpendicular(triangle3d) :point3d		= perpendicular_triangle3d; "Return a vector which is perpendicular to the given triangle"

   .COMMAND toscreen(polygon p,box viewarea, int w,int h):polygon = polygon_toscreen; "Convert a polygon from map coordinates to screen coordinates"
   .COMMAND toscreen(polyline p,box viewarea, int w,int h):polyline = polyline_toscreen; "Convert a polyline from map coordinates to screen coordinates"
   .COMMAND toscreen(point p,box viewarea, int w,int h):point = point_toscreen; "Convert a point from map coordinates to screen coordinates"
   .COMMAND toscreen(box b,box viewarea, int w,int h):box = box_toscreen; "Convert a box from map coordinates to screen coordinates"
   .COMMAND toscreen(box3d b,box viewarea, int w,int h):box = box3d_toscreen; "Convert a box3d from map coordinates to screen coordinates"


.END gis;
@h
#ifndef __GIS_H__
#define __GIS_H__

#include "geometry.h"

extern "C"
{
#include "gdk_heap.h"
#define HEAPindex(HEAP,INDEX,TYPE) ((TYPE *)(HEAP->base + INDEX))
}

#include "gis.proto.h"

#endif /* __GIS_H__ */
@C
#include "gis.h"

#include "triangulate.h"
#include <string.h>
#include <math.h>
#include "chull.h"
#include "Array.h"

//
//======================
// Dimension Operations.
//======================
//
@:dimop(box)@
@:dimop(circle)@
@:dimop(cpolygon)@
@:dimop(point)@
@:dimop(polygon)@
@:dimop(polyline)@
@:dimop(segment)@
@:dimop(triangle)@

@= dimop
int dimension_@1(int* rval,@1* arg1)
{
   *rval = arg1->dimension();
   return(GDK_SUCCEED);
}
@
@C
//
//===================
// Distance Functions
//===================
//
@:relop(distance,point,point,dbl)@
@:relop(distance,point,segment,dbl)@
@:relop(distance,point,box,dbl)@
@:relop(distance,point,circle,dbl)@
@:relop(distance,point,polyline,dbl)@
@:relop(distance,point,polygon,dbl)@
@:relop(distance,point,cpolygon,dbl)@

@:rrelop(distance,box,point,dbl)@
@:relop(distance,box,box,dbl)@

@:rrelop(distance,segment,point,dbl)@
@:relop(distance,segment,segment,dbl)@
@:relop(distance,segment,circle,dbl)@
@:relop(distance,segment,polyline,dbl)@
@:relop(distance,segment,polygon,dbl)@
@:relop(distance,segment,cpolygon,dbl)@

@:rrelop(distance,circle,point,dbl)@
@:rrelop(distance,circle,segment,dbl)@
@:relop(distance,circle,circle,dbl)@

@:rrelop(distance,polyline,point,dbl)@
@:rrelop(distance,polyline,segment,dbl)@
@:relop(distance,polyline,polyline,dbl)@
@:relop(distance,polyline,polygon,dbl)@
@:relop(distance,polyline,cpolygon,dbl)@

@:rrelop(distance,polygon,point,dbl)@
@:rrelop(distance,polygon,segment,dbl)@
@:rrelop(distance,polygon,polyline,dbl)@
@:relop(distance,polygon,polygon,dbl)@
@:relop(distance,polygon,cpolygon,dbl)@

@:rrelop(distance,cpolygon,point,dbl)@
@:rrelop(distance,cpolygon,segment,dbl)@
@:rrelop(distance,cpolygon,polyline,dbl)@
@:rrelop(distance,cpolygon,polygon,dbl)@
@:relop(distance,cpolygon,cpolygon,dbl)@

@:relop(inside,point,box,bit)@
@:relop(inside,point,circle,bit)@
@:relop(inside,point,polygon,bit)@
@:relop(inside,point,cpolygon,bit)@

@:relop(inside,box,box,bit)@

@:relop(inside,circle,box,bit)@

@:relop(inside,triangle,box,bit)@

@:relop(inside,segment,box,bit)@
@:relop(inside,segment,circle,bit)@
@:relop(inside,segment,polygon,bit)@
@:relop(inside,segment,cpolygon,bit)@

@:relop(inside,polyline,box,bit)@
@:relop(inside,polyline,circle,bit)@
@:relop(inside,polyline,polygon,bit)@
@:relop(inside,polyline,cpolygon,bit)@

@:relop(inside,polygon,box,bit)@
@:relop(inside,polygon,circle,bit)@
@:relop(inside,polygon,polygon,bit)@
@:relop(inside,polygon,cpolygon,bit)@

@:relop(inside,cpolygon,box,bit)@
@:relop(inside,cpolygon,circle,bit)@
@:relop(inside,cpolygon,polygon,bit)@
@:relop(inside,cpolygon,cpolygon,bit)@

@:relop(overlap,point,box,bit)@
@:relop(overlap,point,polyline,bit)@
@:relop(overlap,point,polygon,bit)@
@:relop(overlap,point,cpolygon,bit)@

@:relop(overlap,box,point,bit)@

@:relop(overlap,segment,point,bit)@
@:relop(overlap,segment,segment,bit)@
@:relop(overlap,segment,polyline,bit)@
@:relop(overlap,segment,polygon,bit)@
@:relop(overlap,segment,cpolygon,bit)@

@:relop(overlap,polyline,point,bit)@
@:relop(overlap,polyline,polyline,bit)@
@:relop(overlap,polyline,polygon,bit)@
@:relop(overlap,polyline,cpolygon,bit)@

@:relop(overlap,polygon,point,bit)@
@:relop(overlap,polygon,segment,bit)@
@:relop(overlap,polygon,polyline,bit)@
@:relop(overlap,polygon,polygon,bit)@
@:relop(pq_overlap,polygon,polygon,bit)@
@:relop(overlap,polygon,cpolygon,bit)@

@:relop(overlap,cpolygon,point,bit)@
@:relop(overlap,cpolygon,polyline,bit)@
@:relop(overlap,cpolygon,polygon,bit)@
@:relop(overlap,cpolygon,cpolygon,bit)@

@= rrelop
int @1_@2_@3(@4* rval,@2* arg1,@3* arg2)
{
      *rval = @1(*arg2,*arg1);
      return(GDK_SUCCEED);
}
@

@= relop
int @1_@2_@3(@4* rval,@2* arg1,@3* arg2)
{
      *rval = @1(*arg1,*arg2);
      return(GDK_SUCCEED);
}
@
//
//========================================================================
//
@- Equivalence Functions
@C
@:equop(point)@
@:equop(box3d)@
@:equop(point3d)@
@:equop(triangle3d)@
@:equop(circle)@
@:equop(box)@
@:equop(segment)@
@:equop(triangle)@
@:equop(polyline)@
@:equop(polygon)@
@:equop(cpolygon)@

@= equop
int @1_equals_@1(bit *res,@1 *p1, @1 *p2)
{
   *res = (@1_comp(p1,p2) == 0);
   return(GDK_SUCCEED);
}

int @1_notequals_@1(bit *res,@1 *p1, @1 *p2)
{
   *res = (@1_comp(p1,p2) != 0);
   return(GDK_SUCCEED);
}
@
@C
//========================================================================
//
// Copy a varsized object from somewhere to a heap.
//

void cpolygon_put(Heap* h,int*  bun,cpolygon* val)
{
   //
   // We only copy the part of the cpolygon that is
   // really used.
   //
   int nbytes = val->usedbytes();

   //
   // Allocate the memory in the heap.
   //
   *bun  = HEAP_malloc(h,nbytes);

   //
   //
   //
   cpolygon* goalpos = (cpolygon *)(&((char *)(h->base))[*bun]);
   memcpy((char *)goalpos,(char *)val,nbytes);
   goalpos->nbytes_v = nbytes;
}

@:putop(polyline)@
@:putop(polygon)@
@:putop(multipoint)@

@= putop
void @1_put(Heap* h,int*  bun,@1* val)
{
   char* base;
   int nbytes = val->nbytes();

   *bun  = HEAP_malloc(h,nbytes);
   base = h->base;
   memcpy(&base[*bun],(char *)val,nbytes);
}
@
@C
//========================================================================

@:heapop(polyline)@
@:heapop(polygon)@
@:heapop(cpolygon)@
@:heapop(multipoint)@

@= heapop
int @1_heapcheck(
   Heap*        h,
   HeapRepair*  hr)

{
   return(HEAP_check(h,hr));
}

int heapstatus_@1(BAT *bat)
{
   HEAP_printstatus(&(bat->theap));
   return(GDK_SUCCEED);
}

int @1_heap(Heap* h,int capacity)
{
   HEAP_initialize(h,capacity,0,8);
   return(0);
}

void @1_del(Heap* h,int* index)
{
   HEAP_free(h,*index);
}

int @1_length(@1* obj)
{
   return(obj->nbytes());
}

@
//
//========================================================================
//
@- Translation Operations
@C
@:transopfixed(point)@
@:transopfixed(triangle)@

@= transopfixed
int @1_rotate(@1 *rval, @1 *obj,double* angle)
{
   *rval = *obj;
   rval->rotate(*angle);
   return(GDK_SUCCEED);
}

int @1_scale(@1 *rval, @1 *obj,double* factor)
{
   *rval = *obj;
   rval->scale(*factor);
   return(GDK_SUCCEED);
}

int @1_translate(@1 *rval, @1 *obj,point* p)
{
   *rval = *obj;
   rval->translate(*p);
   return(GDK_SUCCEED);
}
@

@C
@:transop(polygon)@
@:transop(polyline)@

@= transop
int @1_rotate(@1 **rval, @1 *obj,double* angle)
{
   *rval = obj->copy();
   (*rval)->rotate(*angle);
   return(GDK_SUCCEED);
}

int @1_scale(@1 **rval, @1 *obj,double* factor)
{
   *rval = obj->copy();
   (*rval)->scale(*factor);
   return(GDK_SUCCEED);
}

int @1_translate(@1 **rval, @1 *obj,point* p)
{
   *rval = obj->copy();
   (*rval)->translate(*p);
   return(GDK_SUCCEED);
}
@
//========================================================================
@- Monitonicity Functions
@C
@:monoop(polygon)@
@:monoop(polyline)@

@= monoop
int @1_monotone(bit *rval, @1 *obj,int* min,int* max)
{
   *rval = obj->ismonotone(*min,*max);
   return(GDK_SUCCEED);
}
@
//========================================================================
@- Area Functions
@C
@:areaop(circle)@
@:areaop(box)@
@:areaop(triangle)@
@:areaop(polygon)@
@:areaop(cpolygon)@

@= areaop
int @1_area(dbl *rval, @1 *obj)
{
   *rval = obj->area();
   return(GDK_SUCCEED);
}
@
//
//========================================================================
//
@- Nbytes
@C
@:nbytesopc(polygon)@
@:nbytesopc(polyline)@
@:nbytesopc(cpolygon)@

@= nbytesopc
int @1_nbytes(int *rval, @1 *obj)
{
   *rval = obj->nbytes();
   return(GDK_SUCCEED);
}
@
//
//========================================================================
//
@- Consistency check functions.
@C
@:hashopc(point)@
@:hashopc(box)@
@:hashopc(segment)@
@:hashopc(circle)@
@:hashopc(triangle)@
@:hashopc(polygon)@
@:hashopc(polyline)@
@:hashopc(cpolygon)@

@= hashopc
int @1_hash_val(int *rval, @1 *obj)
{
   *rval = obj->hash();
   return(GDK_SUCCEED);
}
@
//
//========================================================================
//
@- Consistency check functions.
@C
@:okop(point)@
@:okop(interval)@
@:okop(box)@
@:okop(segment)@
@:okop(circle)@
@:okop(triangle)@
@:okop(polygon)@
@:okop(polyline)@
@:okop(cpolygon)@

@= okop
int @1_ok(bit *rval, @1 *obj)
{
   *rval = obj->OK();
   return(GDK_SUCCEED);
}
@
//
//========================================================================
//
@- Bbox Functions
@C
@:bboxop(point)@
@:bboxop(box)@
@:bboxop(circle)@
@:bboxop(segment)@
@:bboxop(triangle)@
@:bboxop(polyline)@
@:bboxop(polygon)@
@:bboxop(cpolygon)@

@= bboxop
int @1_bbox(
   box*	rval,
   @1* obj)
{
   *rval = obj->bbox();
   return(GDK_SUCCEED);
}
@
@C
int box3d_bbox(
   box3d* rval,
   box3d* obj)
{
   *rval = *obj;
   return(GDK_SUCCEED);
}
//
//========================================================================
//
@- CONVERT Functions
@C
@:convert(point)@
@:convert(point3d)@
@:convert(triangle3d)@
@:convert(interval)@
@:convert(box)@
@:convert(circle)@
@:convert(segment)@
@:convert(triangle)@
@:convert(multipoint)@
@:convert(polyline)@
@:convert(polygon)@
@:convert(cpolygon)@
@:convert(minitree)@


@= convert
void @1_convert(@1* obj,int direction)
{
   if (direction == CONV_NTOH)
      obj->convert_net_to_host();
   else if(direction == CONV_HTON)
      obj->convert_host_to_net();
   else
      GDKerror("Wrong parameter %d in atomconvert\n",direction);
}
@
//
//========================================================================
//
@- NULL Functions
@C
@:nullval(point3d)@
@:nullval(triangle3d)@
@:nullval(box3d)@
@:nullval(box)@
@:nullval(circle)@
@:nullval(triangle)@
@:nullval(cpolygon)@
@:nullval(interval)@

@= nullval
@1* @1_null()
{
   return(@1::null());
}
@
@C

@:nullval2(point)@
@:nullval2(polygon)@
@:nullval2(polyline)@
@:nullval2(segment)@
@:nullval2(multipoint)@

@= nullval2
@1* @1_null()
{
   return(@1::null.copy());
}
@
//
//========================================================================
//
@- String Functions
@C
@:strop(point)@
@:strop(point3d)@
@:strop(interval)@
@:strop(triangle3d)@
@:strop(box3d)@
@:strop(box)@
@:strop(circle)@
@:strop(segment)@
@:strop(triangle)@
@:strop(multipoint)@
@:strop(polyline)@
@:strop(polygon)@
@:strop(cpolygon)@

@= strop
int @1_tostr(str* s,int* l,@1* val)
{
   int expectedlen = val->expectedstrlen();
   if (*l < expectedlen)
   {
      GDKfree(*s);
      *s = (str)GDKmalloc(expectedlen);
      *l = expectedlen;
   }

   return(val->tostr(*s,*l));
}

int @1_fromstr(str s,int* l,@1** val)
{
   int nparsed = 1000;
   *val = @1::fromstr(s,&nparsed,l,*val);
   return(nparsed);
}

@
@C

//
//========================================================================
//
@- Compare Functions
@C
@:neqop(point3d)@
@:neqop(triangle3d)@
@:neqop(box3d)@
@:neqop(interval)@
@:neqop(multipoint)@
@:neqop(box)@
@:neqop(polyline)@
@:neqop(circle)@
@:neqop(triangle)@
@:neqop(cpolygon)@
@:neqop(segment)@
@:neqop(polygon)@

@= neqop
int @1_comp(@1* l,@1* r)
{
   int rval = (!(*l == *r));
   return(rval);
}
@
@C

int point_comp(point* l,point* r)
{
   return(point_compare(*l,*r));
}

//
//========================================================================
//
@- Hash Functions
@C
@:hashop(point)@
@:hashop(point3d)@
@:hashop(interval)@
@:hashop(box3d)@
@:hashop(triangle3d)@
@:hashop(box)@
@:hashop(circle)@
@:hashop(polyline)@
@:hashop(multipoint)@
@:hashop(polygon)@
@:hashop(cpolygon)@
@:hashop(segment)@
@:hashop(triangle)@

@= hashop
int @1_hash(@1* obj)
{
   return(obj->hash());
}
@

//
//==================================================================
//
@- Point functions.
@C
int point_rand(point* rval)
{
   *rval = point(drand48(),drand48());
   return(GDK_SUCCEED);
}


int points_rand(BAT **res, int *size_ptr)
{
   int size = *size_ptr;
   BAT *b = *res = BATnew( TYPE_oid, TYPE_point, size );

   for( int j = 0; j < size; j++)
   {
       point p(drand48(),drand48());
       BUNins(b, &j, &p );
   }
   return (GDK_SUCCEED);
}

int point_xcoord(coord *rval, point *p)
{
   *rval = p->x;
   return(GDK_SUCCEED);
}

int point_ycoord(coord *rval, point *p)
{
   *rval = p->y;
   return(GDK_SUCCEED);
}

int point_create(point *rval, coord *x, coord *y )
{
   rval->x = *x;
   rval->y = *y;
   return(GDK_SUCCEED);
}

static void project(point *out, point *in, point *p, double b)
{
   double b1;

   if (b == COORD_MAX){
        out->x = p->x;
        out->y = in->y;
   } else if (b != 0.0){
        b1 = 1/b;
        out->x = (coord)(((in->y-p->y) + b1 * (in->x-p->x))/(b+b1));
        out->y = (coord)(b*out->x);
        out->x += p->x;
        out->y += p->y;
   } else {
        out->x = in->x;
        out->y = p->y;
   }
}

int point_project(point *rval, point *in, point *p, dbl *b)
{
   project( rval, in, p, *b);
   return(GDK_SUCCEED);
}

int point_Add_point(point *rval, point *p1, point *p2)
{
   rval->x = p1->x + p2->x;
   rval->y = p1->y + p2->y;
   return(GDK_SUCCEED);
}

int point_times_dbl(point *rval, point *p,dbl* val)
{
   *rval = *p * *val;
   return(GDK_SUCCEED);
}

int point_Div_double(point *rval, point *p1, dbl *d )
{
   rval->x = (coord)(p1->x/(*d));
   rval->y = (coord)(p1->y/(*d));
   return(GDK_SUCCEED);
}

int point_Rel_point(point *rval, point *p1, point *p2)
{
   coord dx = p1->x - p2->x;
   rval->x = dx * dx;
   rval->y = p1->y * dx;
   return(GDK_SUCCEED);
}

int point_Dir_double(dbl *rval,point *p1)
{
   *rval = (p1->x != 0.0)? p1->y / p1->x: COORD_MAX;
   return(GDK_SUCCEED);
}

//
//==================================================================
//
@- Box functions.
@C

int box_north(
   segment*   retval,
   box*       b)
{
   *retval = b->north();
   return(GDK_SUCCEED);
}

int box_south(
   segment*   retval,
   box*       b)
{
   *retval = b->south();
   return(GDK_SUCCEED);
}

int box_east(
   segment*   retval,
   box*       b)
{
   *retval = b->east();
   return(GDK_SUCCEED);
}

int box_west(
   segment*   retval,
   box*       b)
{
   *retval = b->west();
   return(GDK_SUCCEED);
}

int box_left(
   coord*       retval,
   box*       b)
{
   *retval = b->left;
   return(GDK_SUCCEED);
}

int box_right(
   coord*       retval,
   box*       b)
{
   *retval = b->right;
   return(GDK_SUCCEED);
}

int box_top(
   coord*       retval,
   box*       b)
{
   *retval = b->top;
   return(GDK_SUCCEED);
}

int box_width(
   coord*     retval,
   box*       b)
{
   *retval = b->width();
   return(GDK_SUCCEED);
}

int box_height(
   coord*     retval,
   box*       b)
{
   *retval = b->height();
   return(GDK_SUCCEED);
}

int box_center(
   point*     retval,
   box*       b)
{
   *retval = b->center();
   return(GDK_SUCCEED);
}

int box_bottom(
   coord*       retval,
   box*       b)
{
   *retval = b->bottom;
   return(GDK_SUCCEED);
}

int box_topolyline(
   polyline**  rval,
   box*       b)
{
   *rval = b->topolyline();
   return(GDK_SUCCEED);
}

int box_topolygon(
   polygon**  rval,
   box*       b)
{
   *rval = b->topolygon();
   return(GDK_SUCCEED);
}

int overlap_box_box(
   bit* result,
   box *b1,
   box *b2)
{
   *result = overlap(*b1,*b2);
   return(GDK_SUCCEED);
}

int box_Bbox_box(
   box *rval,
   box *b1,
   box *b2)
{
   *rval = bbox(*b1,*b2);
   return(GDK_SUCCEED);
}

int box_blowup(
   box*       rval,   /* put pointer to user-defined atom here. */
   box*       b,      /* pointer to user-defined atom.*/
   dbl*       factor) /* pointer to double value.*/
{
   if (factor < 0)
   {
      GDKwarning("Blowup only works with factors > 0\n");
      return(GDK_FAIL);
   }
   coord newwidth = (coord)((b->right - b->left) * *factor * 0.5);
   coord  newheight = (coord)((b->top - b->bottom) * *factor * 0.5);
   coord cx = (b->right + b->left ) / 2;
   coord cy = (b->top + b->bottom ) / 2;
   rval->left = cx - newwidth;
   rval->right = cx + newwidth;
   rval->top = cy + newheight;
   rval->bottom = cy - newheight;
   return(GDK_SUCCEED);
}

//
//============================
// Function concerning circles
//============================
//
int circle_radius(
   coord*      retval,
   circle* c)
{
   *retval = c->radius;
   return GDK_SUCCEED;
}

int circle_center(
   point*    rval,
   circle* c)
{
   *rval = c->location;
   return GDK_SUCCEED;
}

int circle_create_point_point(
   circle* rval,
   point* p1,
   point* p2)
{
   *rval = circle(*p1,*p2);
   return GDK_SUCCEED;
}

int circle_create_point_point_point(
   circle* rval,
   point* p1,
   point* p2,
   point* p3)
{
   *rval = circle(*p1,*p2,*p3);
   return GDK_SUCCEED;
}

//
//==============================
// Function concerning triangles
//==============================
//
int triangle_centroid(
   point *res,
   triangle *t)
{
   *res = t->centroid();
   return(GDK_SUCCEED);
}

int triangle_clockwise(
   bit *res,
   triangle *t)
{
   *res = t->clockwise();
   return(GDK_SUCCEED);
}

int triangle_topolyline(
   polyline**  rval,
   triangle*       b)
{
   *rval = b->topolyline();
   return(GDK_SUCCEED);
}

int triangle_topolygon(
   polygon**  rval,
   triangle*       b)
{
   *rval = b->topolygon();
   return(GDK_SUCCEED);
}

int triangle_index(
   point* rval,
   triangle* t,
   int* index)
{
   if  (*index == 0)
   {
      *rval = t->p1;
      return(GDK_SUCCEED);
   }
   else if (*index == 1)
   {
      *rval = t->p2;
      return(GDK_SUCCEED);
   }
   else if (*index == 2)
   {
      *rval = t->p3;
      return(GDK_SUCCEED);
   }
   else
   {
      GDKwarning("index out of bounds in index(triange,int)\n");
      return(GDK_FAIL);
   }
}

//
// .COMMAND create(point,point,point) : triangle
//
int triangle_create(triangle *rval,point *p1,point * p2,point* p3)
{
   rval->p1 = *p1;
   rval->p2 = *p2;
   rval->p3 = *p3;
   return(GDK_SUCCEED);
}

int triangle_p1(
   point* rval,
   triangle* param
)
{
   *rval = param->p1;
   return(GDK_SUCCEED);
}

int triangle_p2(
   point* rval,
   triangle* param
)
{
   *rval = param->p2;
   return(GDK_SUCCEED);
}

int triangle_p3(
   point* rval,
   triangle* param
)
{
   *rval = param->p3;
   return(GDK_SUCCEED);
}


//
//==================================================================
//
@- Segment functions.
@C
inline void max_line( segment *ml, segment *s1, segment *s2 )
{
   coord x11,y11,x12,y12,x21,y21,x22,y22;
   if ( s2->source.x == s2->dest.x && s2->source.y == s2->dest.y ){
      *ml = *s1;
      return;
   }
   if (s1->source.x < s1->dest.x ){
        x11 = s1->source.x; x12 = s1->dest.x;
        y11 = s1->source.y; y12 = s1->dest.y;
   } else {
        x11 = s1->dest.x; x12 = s1->source.x;
        y11 = s1->dest.y; y12 = s1->source.y;
   }
   if (s2->source.x < s2->dest.x ){
        x21 = s2->source.x; x22 = s2->dest.x;
        y21 = s2->source.y; y22 = s2->dest.y;
   } else {
        x21 = s2->dest.x; x22 = s2->source.x;
        y21 = s2->dest.y; y22 = s2->source.y;
   }
   ml->source.x = (x11<x21)?x11:x21;
   ml->dest.x = (x12>x22)?x12:x22;
   if (y11 < y12 && y21 < y22 ){
        ml->source.y = (y11<y21)?y11:y21;
        ml->dest.y = (y12>y22)?y12:y22;
   } else if (y11 < y12 && y21 > y22 ){
        ml->source.y = (y12>y21)?y12:y21;
        ml->dest.y = (y11<y22)?y11:y22;
   } else if (y11 > y12 && y21 < y22 ){
        ml->source.y = (y11>y22)?y11:y22;
        ml->dest.y = (y12<y21)?y12:y21;
   } else {
        ml->source.y = (y11>y21)?y11:y21;
        ml->dest.y = (y12<y22)?y12:y22;
   }
}


//
//   .COMMAND max_line(segment, segment) : segment
//
int segment_max_line(segment *res, segment *s1, segment *s2)
{
   max_line( res, s1, s2 );
   return GDK_SUCCEED;
}

//
//   .COMMAND length(segment) : double
//
int seg_length(dbl *length, segment *s)
{
   *length = s->length();
   return GDK_SUCCEED;
}

inline double get_angle( segment* s )
{
        double dx, dy, angle;

        if ( s->source.x > s->dest.x ){
                dx = s->source.x - s->dest.x;
                dy = s->source.y - s->dest.y;
        } else {
                dx = s->dest.x - s->source.x;
                dy = s->dest.y - s->source.y;
        }
        if (dx == 0)
                angle = M_PI/2;
        else {
                angle = atan(dy/dx);
                if (dy < 0)
                        angle += M_PI;
        }
        return(angle);
}

//
//   .COMMAND angle(segment) : double
//
int segment_angle(dbl *angle, segment *s)
{
   *angle = get_angle(s);
   return GDK_SUCCEED;
}


//
//   .COMMAND source(segment) : point
//
int segment_source( point *rval, segment *s )
{
   *rval = s->source;
   return GDK_SUCCEED;
}


//
//   .COMMAND dest(segment) : point
//
int segment_dest( point *rval, segment *s )
{
   *rval = s->dest;
   return GDK_SUCCEED;
}

//
//   .COMMAND center(segment) : point
//
int segment_center(point *rval, segment *s)
{
   rval->x = (s->source.x + s->dest.x) /2;
   rval->y = (s->source.y + s->dest.y) /2;
   return GDK_SUCCEED;
}

//
//================================
// Wrapper function for polylines.
//================================
//
@C
int polyline_append(
   polyline** rval,
   polyline* p1,
   polyline* p2)
{
   *rval = append(*p1,*p2);
   return(GDK_SUCCEED);
}

int polyline_dest_direction(
   dbl* rval,
   polyline* p)
{
   *rval = p->dest_direction();
   return (GDK_SUCCEED);
}

int polyline_source_direction(
   dbl* rval,
   polyline* p)
{
   *rval = p->source_direction();
   return (GDK_SUCCEED);
}

int polyline_source(
   point* rval,
   polyline* p)
{
   *rval = p->source();
   return (GDK_SUCCEED);
}

int polyline_dest(
   point* rval,
   polyline* p)
{
   *rval = p->dest();
   return (GDK_SUCCEED);
}

//
//  .COMMAND npoints(polyline) : int
//
int polyline_npoints(
   int* rval,
   polyline* p)
{
   *rval = p->npoints();
   return (GDK_SUCCEED);
}

int polyline_sgmt(
   segment* rval,
   polyline* p,
   int* index)
{
   if ((*index < 0) || (*index >= p->nsegments()))
   {
      GDKwarning("index %d out of bounds in sgmt(polyline[%d],int)\n",*index,p->nsegments());
      return(GDK_FAIL);
   }

   *rval = p->sgmt(*index);
   return (GDK_SUCCEED);
}

//
// .COMMAND index(polyline,int) :point
//
int polyline_index(
   point* rval,
   polyline* p,
   int* index)
{
   if ((*index < 0) || (*index >= p->npoints()))
   {
      GDKwarning("index out of bounds in index(polyline,int)\n");
      return(GDK_FAIL);
   }

   *rval = p->pnt(*index);
   return (GDK_SUCCEED);
}

int points_chull(
   polygon** rval,
   BAT*  b)
{
   Array<point> points;

   BUN hd,tl;
   BATloop(b,hd,tl)
   {
      points.append(*(point *)BUNtail(b,hd));
   }

   *rval = convex_hull(points);
   return GDK_SUCCEED;
}

int polygon_chull(
   polygon** rval,
   polygon*  p)
{
   *rval = convex_hull(*p);
   return GDK_SUCCEED;
}

int cpolygon_chull(
   polygon** rval,
   cpolygon*  p)
{
   *rval = convex_hull(p->boundary());
   return GDK_SUCCEED;
}

int polyline_chull(
   polygon** rval,
   polyline*  p)
{
   *rval = convex_hull(*p);
   return GDK_SUCCEED;
}

//
// .COMMAND reverse(polyline) :polyline
//
int polyline_reverse(
   polyline** rval,
   polyline*  p)
{
   *rval = p->copy();
   (*rval)->reverse();
   return GDK_SUCCEED;
}

//
// .COMMAND selfintersect(polyline): bit
//
int intersect_pln_pln(
   bit* rval,
   polyline* p,
   polyline* q)
{
   *rval = intersect(*p,*q);
   return GDK_SUCCEED;
}

//
// .COMMAND selfintersect(polyline): bit
//
int polyline_selfintersect(
   bit* rval,
   polyline* p)
{
   *rval = p->selfintersect();
   return GDK_SUCCEED;
}

//
// .COMMAND closed(polyline): bit
//
int polyline_closed(
   bit* rval,
   polyline* p)
{
   *rval = p->closed();
   return GDK_SUCCEED;
}

//
//  .COMMAND interior(polyline) : polygon
//
int polyline_interior(polygon **rval, polyline *p)
{
   if (!p->closed())
   {
      GDKwarning("polyline_interior must have closed polyline as parameter\n");
      return(GDK_FAIL);
   }
   *rval = p->interior();
   return(GDK_SUCCEED);
}

//
//=============================
// Function concerning polygons
//=============================
//

//
//  .COMMAND clockwise(polygon) : bit
//
int polygon_clockwise(
   bit *res,
   polygon *p)
{
   *res = p->clockwise();
   return(GDK_SUCCEED);
}

//
//  .COMMAND gcenter(polygon) : point
//
int polygon_gcenter(
   point *res,
   polygon *p)
{
   *res = p->gcenter();
   return(GDK_SUCCEED);
}

//
//  .COMMAND boundary(polygon) : polyline  = polygon_boundary;
//
int polygon_boundary(polyline **rval, polygon *p )
{
   *rval = p->boundary();
   return(GDK_SUCCEED);
}


//
//  .COMMAND index(polygon,int) : point
//
int polygon_index(
   point *rval,
   polygon *p,
   int *i)
{
   int index = *i;

   if ((index < 0) || (index >= p->npoints()))
   {
      GDKwarning("index out of bounds in polygon_index\n");
      return(GDK_FAIL);
   }

   *rval = p->pnt(index);
   return(GDK_SUCCEED);
}

//
//  .COMMAND npoints(polygon) : int
//
int polygon_npoints(int *res , polygon *p )
{
   *res = p->npoints();
   return(GDK_SUCCEED);
}

//
// .COMMAND remove_dups(polygon) :polygon
//
int polygon_lower_res(
   polygon** rval,
   polygon*  p,
   double*   d)
{
   *rval = p->lower_res(*d);
   return GDK_SUCCEED;
}


//
// .COMMAND remove_dups(polygon) :polygon
//
int polygon_remove_dups(
   polygon** rval,
   polygon*  p)
{
   *rval = p->remove_dups();
   return GDK_SUCCEED;
}


//
// .COMMAND reverse(polygon) :polygon
//
int polygon_reverse(
   polygon** rval,
   polygon*  p)
{
   *rval = p->copy();
   (*rval)->reverse();
   return GDK_SUCCEED;
}

int polygon_minitree_depth(int *res , polygon *p)
{
   if (p->hasminitree())
   {
      const minitree* m = p->minitreeptr();
      *res = m->depth();
      return(GDK_SUCCEED);
   }
   else
   {
      GDKwarning("Minitree operation performed on polygon without minitree\n");
      return(GDK_FAIL);
   }
}

int polygon_minitree_nnodes(int *res , polygon *p)
{
   if (p->hasminitree())
   {
      const minitree* m = p->minitreeptr();
      *res = m->dimension();
      return(GDK_SUCCEED);
   }
   else
   {
      GDKwarning("Minitree operation performed on polygon without minitree\n");
      return(GDK_FAIL);
   }
}

int polygon_minitree_nbytes(int *res , polygon *p)
{
   if (p->hasminitree())
   {
      const minitree* m = p->minitreeptr();
      *res = m->nbytes();
      return(GDK_SUCCEED);
   }
   else
   {
      GDKwarning("Minitree operation performed on polygon without minitree\n");
      return(GDK_FAIL);
   }
}


//
//==============================
// Function concerning cpolygons
//==============================
//
int cpolygon_hole( polygon **rval, cpolygon *p, int *number)
{
   *rval = p->hole(*number).copy();
   return(GDK_SUCCEED);
}

//
//  .COMMAND addhole(cpolygon,polygon) : cpolygon
//
int cpolygon_addhole(
   cpolygon** retval,
   cpolygon* c,
   polygon* p)
{
   cpolygon *rval = c->copy();
   rval = rval->addhole(*p);
   *retval = rval;

   return(GDK_SUCCEED);
}

//
//  .COMMAND create(polygon) : cpolygon
//
int cpolygon_create(
   cpolygon** rval,
   polygon* p)
{
   *rval = cpolygon::create(5,p->nbytes() * 3);
   (*rval)->addhole(*p);
   return(GDK_SUCCEED);
}

//
//  .COMMAND boundary(cpolygon) : polygon
//
int cpolygon_boundary(
   polygon** rval,
   cpolygon* p)
{
   *rval = p->boundary().copy();
   return(GDK_SUCCEED);
}

int cpolygon_topolygon(
   polygon** rval,
   cpolygon* p)
{
   *rval = p->topolygon();
   return(GDK_SUCCEED);
}

//
// .COMMAND nholes(cpolygon) : int
//
int cpolygon_nholes(int *res, cpolygon *p)
{
   *res = p->nholes();
   return(GDK_SUCCEED);
}

int cpolygon_info(cpolygon *p)
{
   p->info();
   return(GDK_SUCCEED);
}

//
//  .COMMAND npoints(polyline) : int
//
int cpolygon_npoints(
   int* rval,
   cpolygon* p)
{
   *rval = p->npoints();
   return (GDK_SUCCEED);
}


//
//==================================================================
//

int segment_topolyline(polyline** rval, segment* s)
{
   *rval = s->topolyline();
   return(GDK_SUCCEED);
}

int segment_length(dbl *rval,segment *s)
{
   *rval = s->length();
   return(GDK_SUCCEED);
}

//
// .COMMAND reverse(,point,point) : triangle
//
int segment_reverse(segment *rval,segment *s)
{
   *rval = s->reverse();
   return(GDK_SUCCEED);
}

//
// .COMMAND create(point,point) : segment
//
int segment_create(segment *rval,point *src,point * dest)
{
   rval->source = *src;
   rval->dest = *dest;
   return(GDK_SUCCEED);
}

int angle_dd(
   double* rval,
   double* d1,
   double* d2)
{
   *rval = angle(*d1,*d2);
   return(GDK_SUCCEED);
}

int direction_pp(
   double* rval,
   point* p1,
   point* p2)
{
   *rval = direction(*p1,*p2);
   return(GDK_SUCCEED);
}

int angle_ppp(
   double* rval,
   point* p1,
   point* p2,
   point* p3)
{
   *rval = angle(*p1,*p2,*p3);
   return(GDK_SUCCEED);
}

//
// .COMMAND setbbox(bat[any,any]) : box = boxset_bbox;
//
int boxset_bbox(box *result, BAT *boxes)
{
   BUN hd,tl;

   //
   // If there is an index you can use the bbox of the index. (TODO)
   //
   *result =  *(box *)BUNtail(boxes,BUNfirst(boxes));
   BATloop(boxes,hd,tl)
   {
      result->bbox_include(*(box *)BUNtail(boxes, hd));
   }
   return(GDK_SUCCEED);
}


int box3dset_bbox(box3d *result, BAT *boxes)
{
   BUN hd,tl;

   //
   // If there is an index you can use the bbox of the index. (TODO)
   //
   *result =  *(box3d *)BUNtail(boxes,BUNfirst(boxes));
   BATloop(boxes,hd,tl)
   {
      result->bbox_include(*(box3d *)BUNtail(boxes, hd));
   }
   return(GDK_SUCCEED);
}


int cpolygons_segmentify(
   BAT** rval,
   BAT*  cpolygons)
{
   BUN bn,dummy;

   *rval = BATnew(BAThtype(cpolygons),TYPE_segment, BATcount(cpolygons) * 2);
   BAT* mir = BATmirror(*rval);


   BATloop(cpolygons,bn,dummy)
   {
      cpolygon* c = (cpolygon *)BUNtail(cpolygons, bn);

      for (int pol = -1; pol < c->nholes();++pol)
      {
	 polygon* p;
	 if (pol == -1)
	    p = &(c->boundary());
	 else
	    p = &(c->hole(pol));

	 for(int i=0;i<p->nsegments();++i)
	 {
	    segment s(p->sgmt(i));

	    // if ((BUNfnd(mir,&s) == NULL) && (s.source != s.dest))
	    BUN r;
	    HASHfnd(r,mir,&s);
	    if ((r == NULL) && (s.source != s.dest))
	    {
	       BUNins(*rval,BUNhead(cpolygons,bn),&s);
	    }
	 }
      }
   }
   return(GDK_SUCCEED);
}

int polygons_segmentify(
   BAT**	rval,
   BAT*		polygons)
{
   BUN bn,dummy;

   *rval = BATnew(BAThtype(polygons),TYPE_segment, BATcount(polygons) * 2);
   BAT* mir = BATmirror(*rval);


   BATloop(polygons,bn,dummy)
   {
      polygon* p = (polygon *)BUNtail(polygons, bn);

      for(int i=0;i<p->nsegments();++i)
      {
	 segment s(p->sgmt(i));

	 if ((BUNfnd(mir,&s) == NULL) && (s.source != s.dest))
	 {
	    BUNins(*rval,BUNhead(polygons,bn),&s);
	 }
      }
   }
   return(GDK_SUCCEED);
}

int polylines_segmentify(
   BAT**	rval,
   BAT*		polylines)
{
   BUN bn,dummy;

   *rval = BATnew(BAThtype(polylines),TYPE_segment, BATcount(polylines) * 2);
   BAT* mir = BATmirror(*rval);


   BATloop(polylines,bn,dummy)
   {
      polyline* p = (polyline *)BUNtail(polylines, bn);

      for(int i=0;i<p->nsegments();++i)
      {
	 segment s(p->sgmt(i));

	 if ((BUNfnd(mir,&s) == NULL) && (s.source != s.dest))
	 {
	    BUNins(*rval,BUNhead(polylines,bn),&s);
	 }
      }
   }
   return(GDK_SUCCEED);
}

//int polyline_split(
//   polyline* p1,
//   polyline* p2,
//   oid* o1,
//   oid* o2,
//   BAT* oid_plnid,
//   BAT* oid_segnumpos,
//   BAT* oid_position)
//{
//   split(*p1,*p2,*o1,*o2,oid_plnid,oid_segnumpos,oid_position);
//   return(GDK_SUCCEED);
//}

int cpolygon_triangulate(BAT **retval,cpolygon* p)
{
   segment* segs;
   int nsegs = triangulate(*p,&segs);

   oid id = OIDnew(nsegs);
   BAT* rval = BATnew(TYPE_oid,TYPE_segment,nsegs);

   for(int i=0;i<nsegs;++i)
   {
      BUNins(rval,&id,&segs[i]);
   }
   GDKfree(segs);
   *retval = rval;
   return(GDK_SUCCEED);
}

int polygon_triangulate(BAT **retval,polygon* p)
{
   Array<segment> segs;

   triangulate(*p,segs);

   oid id = OIDnew(segs.nitems());
   BAT* rval = BATnew(TYPE_oid,TYPE_segment,segs.nitems());

   for(int i=0;i<segs.nitems();++i)
   {
      segment s = segs[i];
      BUNins(rval,&id,&s);
   }
   *retval = rval;
   return(GDK_SUCCEED);
}

//
//==================================================================
//
int polygon_multiply(
   polygon** rval,
   polygon* p,
   dbl* factor)
{
   *rval = p->copy();
   **rval *= *factor;
   return(GDK_SUCCEED);
}

int polygon_divide(
   polygon** rval,
   polygon* p,
   dbl* factor)
{
   *rval = p->copy();
   **rval /= *factor;
   return(GDK_SUCCEED);
}

int polygon_add(
   polygon** rval,
   polygon* pgn,
   point* pnt)
{
   *rval = pgn->copy();
   **rval += *pnt;
   return(GDK_SUCCEED);
}

int polygon_subtract(
   polygon** rval,
   polygon* pgn,
   point* pnt)
{
   *rval = pgn->copy();
   **rval -= *pnt;
   return(GDK_SUCCEED);
}

int point_multiply(
   point* rval,
   point* p,
   dbl* factor)
{
   *rval = *p * *factor;
   return(GDK_SUCCEED);
}

int point_divide(
   point* rval,
   point* p,
   dbl* factor)
{
   *rval = *p / *factor;
   return(GDK_SUCCEED);
}

int point_add(
   point* rval,
   point* p1,
   point* p2)
{
   *rval = *p1 + *p2;
   return(GDK_SUCCEED);
}

int point_subtract(
   point* rval,
   point* p1,
   point* p2)
{
   *rval = *p1;
   *rval -= *p2;
   return(GDK_SUCCEED);
}


int box_multiply(
   box* rval,
   box* b,
   dbl* factor)
{
   *rval = *b;
   *rval *= *factor;
   return(GDK_SUCCEED);
}

int box_divide(
   box* rval,
   box* b,
   dbl* factor)
{
   *rval = *b;
   *rval /= *factor;
   return(GDK_SUCCEED);
}

int box_add(
   box* rval,
   box* b,
   point* p)
{
   *rval = *b;
   *rval += *p;
   return(GDK_SUCCEED);
}

int box_subtract(
   box* rval,
   box* b,
   point* p)
{
   *rval = *b;
   *rval -= *p;
   return(GDK_SUCCEED);
}


int polyline_multiply(
   polyline** rval,
   polyline* p,
   dbl* factor)
{
   *rval = p->copy();
   **rval *= *factor;
   return(GDK_SUCCEED);
}

int polyline_divide(
   polyline** rval,
   polyline* p,
   dbl* factor)
{
   *rval = p->copy();
   **rval /= *factor;
   return(GDK_SUCCEED);
}

int polyline_line_length(dbl *rval,polyline *p)
{
   *rval = p->length();
   return(GDK_SUCCEED);
}

int polyline_add(
   polyline** rval,
   polyline* pgn,
   point* pnt)
{
   *rval = pgn->copy();
   **rval += *pnt;
   return(GDK_SUCCEED);
}

int polyline_subtract(
   polyline** rval,
   polyline* pgn,
   point* pnt)
{
   *rval = pgn->copy();
   **rval -= *pnt;
   return(GDK_SUCCEED);
}

//
//===============================
// Function concerning triangle3d
//===============================
//
int triangle3d_create(
   triangle3d *rval,
   point3d *p1,
   point3d *p2,
   point3d *p3)
{
   rval->p1 = *p1;
   rval->p2 = *p2;
   rval->p3 = *p3;
   return(GDK_SUCCEED);
}

int triangle3d_p1(
   point3d* rval,
   triangle3d* param
)
{
   *rval = param->p1;
   return(GDK_SUCCEED);
}

int triangle3d_p2(
   point3d* rval,
   triangle3d* param
)
{
   *rval = param->p2;
   return(GDK_SUCCEED);
}

int triangle3d_p3(
   point3d* rval,
   triangle3d* param
)
{
   *rval = param->p3;
   return(GDK_SUCCEED);
}

int perpendicular_triangle3d(
   point3d* rval,
   triangle3d* param
)
{
   *rval = param->perpendicular();
   return(GDK_SUCCEED);
}

//
//==========================
// Function concerning box3d
//==========================
//
int box3d_create_2(
   box3d *rval,
   box *b,
   interval *i)
{
   rval->xinterval = interval(b->left,b->right);
   rval->yinterval = interval(b->bottom,b->top);
   rval->zinterval = *i;
   return(GDK_SUCCEED);
}

int box3d_create(
   box3d *rval,
   interval *i1,
   interval *i2,
   interval *i3)
{
   rval->xinterval = *i1;
   rval->yinterval = *i2;
   rval->zinterval = *i3;
   return(GDK_SUCCEED);
}

int box3d_setminz(
   box3d* rval,
   box3d* b,
   double* v)
{
   *rval = *b;
   rval->zinterval.setmin(*v);
   return(GDK_SUCCEED);
}

int box3d_setmaxz(
   box3d* rval,
   box3d* b,
   double* v)
{
   *rval = *b;
   rval->zinterval.setmax(*v);
   return(GDK_SUCCEED);
}

int box3d_xinterval(
   interval* rval,
   box3d* b)
{
   *rval = b->xinterval;
   return(GDK_SUCCEED);
}

int box3d_yinterval(
   interval* rval,
   box3d* b)
{
   *rval = b->yinterval;
   return(GDK_SUCCEED);
}

int box3d_zinterval(
   interval* rval,
   box3d* b)
{
   *rval = b->zinterval;
   return(GDK_SUCCEED);
}

int box3d_tobox(
   box*  rval,
   box3d* b)
{
   *rval = b->tobox();
   return(GDK_SUCCEED);
}

int bbox_box3d_box3d(
   box3d *rval,
   box3d *b1,
   box3d *b2)
{
   *rval = bbox3d(*b1,*b2);
   return(GDK_SUCCEED);
}

//
//==============================
// Functions concerning interval
//==============================
//
int interval_min(
   dbl *rval,
   interval *i)
{
   *rval = i->min;
   return(GDK_SUCCEED);
}

int interval_max(
   dbl *rval,
   interval *i)
{
   *rval = i->max;
   return(GDK_SUCCEED);
}

int inside_dbl_interval(
   bit *rval,
   dbl *v,
   interval *i)
{
   *rval = i->inside(*v);
   return(GDK_SUCCEED);
}

int interval_create(
   interval *rval,
   dbl *min,
   dbl *max)
{
   rval->min = *min;
   rval->max = *max;
   return(GDK_SUCCEED);
}

//
//====================================================
// Functions converting objects to screen coordinates.
//====================================================
//
int polygon_toscreen(
   polygon** r,
   polygon* p,
   box* viewarea,
   int* w,
   int* h)
{
   polygon* rval =  polygon::create(p->npoints());
   *r = rval;

   double xscaling = *w / viewarea->width();
   double yscaling = *h / viewarea->height();
   for(int i=0;i<p->npoints();++i)
   {
      rval->data(i).x =  int((p->pnt(i).x - viewarea->left) * xscaling);
      rval->data(i).y =  *h - int((p->pnt(i).y - viewarea->bottom) * yscaling);
   }
   return(GDK_SUCCEED);
}

int polyline_toscreen(
   polyline** r,
   polyline* p,
   box* viewarea,
   int* w,
   int* h)
{
   polyline* rval =  polyline::create(p->npoints());
   *r = rval;

   double xscaling = *w / viewarea->width();
   double yscaling = *h / viewarea->height();

   int j=0;
   for(int i=0;i<p->npoints();++i)
   {
      point newp (
         int((p->pnt(i).x - viewarea->left) * xscaling),
	 *h - int((p->pnt(i).y - viewarea->bottom) * yscaling));
      
      if ((j == 0) || (rval->pnt(j-1) != newp))
         rval->data(j++) = newp;
   }
   rval->npoints_v = j;
   return(GDK_SUCCEED);
}

int point_toscreen(
   point* r,
   point* p,
   box* viewarea,
   int* w,
   int* h)
{
   double xscaling = *w / viewarea->width();
   double yscaling = *h / viewarea->height();

   r->x =  int((p->x - viewarea->left) * xscaling);
   r->y =  *h - int((p->y - viewarea->bottom) * yscaling);

   return(GDK_SUCCEED);
}

int box_toscreen(
   box* r,
   box* b,
   box* viewarea,
   int* w,
   int* h)
{
   double xscaling = *w / viewarea->width();
   double yscaling = *h / viewarea->height();

   r->left =  int((b->left - viewarea->left) * xscaling);
   r->top =  *h - int((b->top - viewarea->bottom) * yscaling);
   r->right =  int((b->right - viewarea->left) * xscaling);
   r->bottom =  *h - int((b->bottom - viewarea->bottom) * yscaling);

   return(GDK_SUCCEED);
}

int box3d_toscreen(
   box* r,
   box3d* b,
   box* viewarea,
   int* w,
   int* h)
{
   double xscaling = *w / viewarea->width();
   double yscaling = *h / viewarea->height();

   r->left =  int((b->xinterval.min - viewarea->left) * xscaling);
   r->top =  *h - int((b->yinterval.max - viewarea->bottom) * yscaling);
   r->right =  int((b->xinterval.max - viewarea->left) * xscaling);
   r->bottom =  *h - int((b->yinterval.min - viewarea->bottom) * yscaling);

   return(GDK_SUCCEED);
}

//
//=============================
// Functions concerning point3d
//=============================
//
int point3d_create(
   point3d *rval,
   coord *x,
   coord *y,
   coord *z)
{
   rval->x = *x;
   rval->y = *y;
   rval->z = *z;
   return(GDK_SUCCEED);
}

int distance_point3d_point3d(
   dbl* rval,
   point3d* left,
   point3d* right)
{
   *rval = sqrt(squared_distance(*left,*right));
   return(GDK_SUCCEED);
}

int add_point3d_point3d(
   point3d* rval,
   point3d* left,
   point3d* right)
{
   *rval = *left + *right;
   return(GDK_SUCCEED);
}

int angle_point3d(
   dbl* rval,
   point3d* arg)
{
   *rval = arg->angle();
   return(GDK_SUCCEED);
}

int point3d_xcoord(coord *rval, point3d *p)
{
   *rval = p->x;
   return(GDK_SUCCEED);
}

int point3d_ycoord(coord *rval, point3d *p)
{
   *rval = p->y;
   return(GDK_SUCCEED);
}

int point3d_zcoord(coord *rval, point3d *p)
{
   *rval = p->z;
   return(GDK_SUCCEED);
}

//
//==============================
// Function concerning minitrees
//==============================
//
int minitree_distance_polygon_polygon(
   double* rval,
   polygon* p1,
   minitree* m1,
   polygon* p2,
   minitree* m2)
{
   *rval = sqrt(squared_distance(*p1,*m1,*p2,*m2));
   return(GDK_SUCCEED);
}

int minitree_create(
   minitree** retval,
   polygon* p,
   int* maxleafsize)
{
   minitree* rval = create_minitree(*p,*maxleafsize);
   *retval = rval;
   return(GDK_SUCCEED);
}

int minitree_extract_polyline(
   minitree** rval,
   polyline* p)
{
   *rval = extract(*p);
   return(GDK_SUCCEED);
}

int minitree_extract_polygon(
   minitree** rval,
   polygon* p)
{
   *rval = extract(*p);
   return(GDK_SUCCEED);
}

int minitree_unite(
   polygon** rval,
   polygon* p,
   minitree* m)
{
   *rval = p->addminitree(*m);
   return(GDK_SUCCEED);
}

int minitree_point_in_polygon(
   bit* rval,
   point* pnt,
   polygon* pgn,
   minitree* m)
{
   *rval = inside(*pnt,*pgn,*m);
   return(GDK_SUCCEED);
}

int minitree_depth(int* rval,minitree* m)
{
   *rval = (int)(m->depth());
   return(GDK_SUCCEED);
}

int minitree_nbytes(int* rval,minitree* m)
{
   *rval = (int)(m->nbytes());
   return(GDK_SUCCEED);
}

int minitree_nnodes(int* rval,minitree* m)
{
   *rval = m->dimension();
   return(GDK_SUCCEED);
}

int minitree_add_polyline(polyline** rval,polyline* p,int* nodesize)
{
   *rval = addminitree(*p,*nodesize);
   return(GDK_SUCCEED);
}

int minitree_add_polygon(polygon** rval,polygon* p,int* nodesize)
{
   *rval = addminitree(*p,*nodesize);
   return(GDK_SUCCEED);
}

int minitree_add_cpolygon(cpolygon** rval,cpolygon* c,int* nodesize)
{
   *rval = addminitree(*c,*nodesize);
   return(GDK_SUCCEED);
}

int minitree_remove_polyline(polyline** rval,polyline* p)
{
   *rval = removeminitree(*p);
   return(GDK_SUCCEED);
}

int minitree_remove_polygon(polygon** rval,polygon* p)
{
   *rval = removeminitree(*p);
   return(GDK_SUCCEED);
}

int polygon_hasminitree(bit* rval,polygon* p)
{
   *rval = p->hasminitree();
   return(GDK_SUCCEED);
}

int polyline_hasminitree(bit* rval,polyline* p)
{
   *rval = p->hasminitree();
   return(GDK_SUCCEED);
}

int cpolygon_hasminitree(bit* rval,cpolygon* c)
{
   *rval = c->hasminitree();
   return(GDK_SUCCEED);
}

int minitree_distance_point(
   double* rval,
   polygon* pgn,
   minitree *m,
   point* pnt)
{
   *rval = sqrt(squared_distance(*pnt,*pgn,*m));
   return(GDK_SUCCEED);
}

int minitree_distance_segment(
   double* rval,
   polygon* p,
   minitree *m,
   segment* s)
{
   *rval = sqrt(squared_distance(*s,*p,*m));
   return(GDK_SUCCEED);
}

//
//===================
// Various Functions.
//===================
//
int segment_baserelate(segment* rval,segment* s1,segment* s2)
{
   baserelate(*s1,*s2,*rval);
   return(GDK_SUCCEED);
}

@mil
setoid(oid(20000000));
module(gis);

p1 := point("(3,3)");
p2 := point("(.5,.5)");
b := box("(0,1,1,0)");
c := circle("((0,0),1)");
s := segment("((0,1),(3,3))");
pln := polyline("(3:0,0,3,3,0,1)");
pgn := polygon("(3:0,0,3,3,0,1)");
cpg := cpolygon("(1:(4:0,0,10,0,10,10,0,10) (3:1,1,9,7,7,9))");
pgns := new(int,polygon);
pgns.insert(1,pgn);

p := polygon("(4:0,0,0,1,1,1,1,0)");
p.reverse.triangulate.print;
p.triangulate.print;

cpg := cpg.addhole(polygon("(3:2,3,4,5,5,4)"));

p1.print;
b.print;
c.print;
s.print;
pln.print;
pgn.print;
cpg.print;


# all shoult return true.

p1.ok.print;
b.ok.print;
c.ok.print;
s.ok.print;
pln.ok.print;
pgn.ok.print;
cpg.ok.print;
p1.inside(b).not.print;
p2.inside(b).print;
(b.area = dbl(1)).print;
(pgn.index(1) = p1).print;
(pln.src = point("(0,0)")).print;
(pgn.bbox = box("(0.000000,3.000000,3.000000,0.000000)")).print;
(pln.bbox = box("(0.000000,3.000000,3.000000,0.000000)")).print;
(s.bbox = box("(0.000000,3.000000,3.000000,1.000000)")).print;
(c.bbox = box("(-1.000000,1.000000,1.000000,-1.000000)")).print;
(b.left = b.bottom).print;
(b.right = b.top).print;
(c.center = pln.src).print;
(pln.reverse.src = pln.dest).print;
(pgn.boundary.src = pgn.boundary.dest).print;
(polyline("(3:0,0,1,1,0,0)").interior.area = dbl(0)).print;
(pgns.reverse.select(1).count = 1).print;

quit;
