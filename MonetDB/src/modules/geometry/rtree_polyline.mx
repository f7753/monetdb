@f rtree_polyline
@A C.W. Quak
@* The 'rtree_polyline' accelerator for boxes.
@h
#ifndef __RTREE_POLYLINE_H__
#define __RTREE_POLYLINE_H__

extern BAT* select_overlap_polyline_box(BAT* seglist,const box& b);
extern BAT* join_overlap_polyline_polyline(BAT* left,BAT* right);
extern BAT* select_overlap_polyline_polyline(BAT* left,const polyline& p);

#endif /* __RTREE_POLYLINE_H__ */
@C
#include "gis.h"
#include "opengis.h"
#include "gisbulk.proto.h"
#include "rtree.h"
#include "rtree_polyline.h"
#include "opengis.h"

//
// Build an RTREE index on the head of the given bat.
//
// PRE: The bat must be of type (polyline,any).
//
void RTREEbuild_polyline(
   Heap* heap,
   int*,
   BAT* bat)
{
   if (BAThtype(bat) != TYPE_polyline)
   {
      GDKerror("Cannot build RTREE because head not of type polyline\n");
      return;
   }

   bat->hacctype = ACC_rtree_polyline;
   RTREEcreate(heap);


   //
   // Insert all buns into the heap.
   //
   {
      BUN index,dummy;

      BATloop(bat,index,dummy)
      {
	 RTREEinsert_polyline(heap,BUNindex(bat,index),bat,(polyline *)BUNhead(bat, index));
      }
   }
}


static void RTREE_local_select(
   BAT* rectlist,
   Heap* heap,
   int nodeindex,
   const box& b,
   BAT* result)
{
   RTREEnode* self = RTREEindex(heap,nodeindex);

   // GDKwarning("Entering node %d (%f,%f,%f,%f)\n",nodeindex,self->bbox.left,self->bbox.top,self->bbox.right,self->bbox.bottom);

   if (!overlap(self->bbox,b))
      return;

   if (self->isleaf())
   {
      for(int i = 0;i<self->number;++i)
      {
	 BUN bun = (BUN)BUNptr(rectlist,self->entries[i]);
	 polyline *t = (polyline *)BUNtail(rectlist,bun);
	 if (overlap(b,t->bbox()))
	    BUNins(result,BUNhead(rectlist,bun),t);
      }
   }
   else
   {
      for(int i = 0;i < self->number;++i)
	 RTREE_local_select(rectlist,heap,self->entries[i],b,result);
   }
}

BAT* select_overlap_polyline_box(BAT* seglist,const box& b)
{
   BAT* result = BATnew(BAThtype(seglist),BATttype(seglist),BATcount(seglist)/10);
   Heap* heap = &seglist->taccelerator;

   if (heap->base == NULL)
   {
      GDKerror("This BAT has no index");
      return(NULL);
   }

   int rootindex = RTREErootindex(heap);

   if (rootindex != 0)
      RTREE_local_select(seglist,heap,rootindex,b,result);

   return(result);
}

//
//==========================================
// Function for joining two polyline rtrees.
//==========================================
//
static void RTREE_RTREE_local_join_overlap(
   BAT* batleft,
   BAT* batright,
   Heap* heapleft,
   Heap* heapright,
   int nodeleft,
   int noderight,
   BAT* result)
{
   RTREEnode* leftptr = RTREEindex(heapleft,nodeleft);
   RTREEnode* rightptr = RTREEindex(heapright,noderight);

   //
   // If bounding boxes do not overlap the join is empty
   //
   if (!overlap(leftptr->bbox,rightptr->bbox))
      return;

   //
   // If both are leaves we are at the deepest level and must compare al pairs.
   //
   if ((leftptr->isleaf()) && (rightptr->isleaf()))
   {
      for(int i=leftptr->number - 1;i>=0;--i)
      {
	 LineString* leftseg = (polyline *)BUNtail(batleft,BUNptr(batleft,leftptr->entries[i]));

	 for(int j=rightptr->number - 1;j>=0;--j)
	 {
	    LineString* rightseg = (polyline *)BUNhead(batright,BUNptr(batright,rightptr->entries[j]));

	    if (Relate(*leftseg,*rightseg,"T********") ||
	        Relate(*leftseg,*rightseg,"*T*******") ||
	        Relate(*leftseg,*rightseg,"***T*****"))
	    {
	       BUNins(result,
		  BUNhead(batleft,BUNptr(batleft,leftptr->entries[i])),
		  BUNtail(batright,BUNptr(batright,rightptr->entries[j])));
	    }
	 }
      }
   }
   else
   {
      //
      // We must decide which node we enter. If we can choose (when both node
      // are intermediate nodes) we choose the largest node.
      //
      int deepen;
      if (leftptr->isleaf())
	 deepen = RIGHTBOX;
      else if (rightptr->isleaf())
	 deepen = LEFTBOX;
      else
      {
	 if (leftptr->bbox.area() > rightptr->bbox.area())
	    deepen = LEFTBOX;
	 else
	    deepen = RIGHTBOX;
      }

      if (deepen == LEFTBOX)
      {

	 for(int i=leftptr->number -1;i>=0;--i)
	 {
	    RTREE_RTREE_local_join_overlap(
	       batleft,batright, heapleft,heapright,
	       leftptr->entries[i],noderight,
	       result);
	 }
      }
      else // we go into the right node
      {
	 for(int j=rightptr->number-1;j>=0;--j)
	 {
	    RTREE_RTREE_local_join_overlap(
	       batleft,batright, heapleft,heapright,
	       nodeleft,rightptr->entries[j],
	       result);
	 }
      }
   }
}

BAT* join_overlap_polyline_polyline(BAT* left,BAT* right)
{
   BAT* result;
   Heap* heapleft = &(left->taccelerator);
   Heap* heapright = &(right->haccelerator);
   int leftrootindex = RTREErootindex(heapleft);
   int rightrootindex = RTREErootindex(heapright);


   /*
   // We create a BAT for the joined pairs.
   // res_tuples should be set to the expected number of BUNs in the result.
   */
   {
      int res_tuples = 1000;
      result = BATnew(BAThtype(left),BATttype(right),res_tuples);
   }

   if ((leftrootindex != 0) && (rightrootindex != 0))
   {
      RTREE_RTREE_local_join_overlap(
	 left, right,
	 heapleft, heapright,
	 leftrootindex,
	 rightrootindex,
	 result);
   }
   return(result);
}

//
//==========================================
// Function for joining two polyline rtrees.
//==========================================
//
static void RTREE_local_select_overlap(
   BAT* rectlist,
   Heap* heap,
   int nodeindex,
   const polyline& p,
   BAT* result)
{
   RTREEnode* self = RTREEindex(heap,nodeindex);

   if (!overlap(self->bbox,p.bbox()))
      return;

   if (self->isleaf())
   {
      for(int i = 0;i<self->number;++i)
      {
	 BUN bun = (BUN)BUNptr(rectlist,self->entries[i]);
	 polyline *t = (polyline *)BUNtail(rectlist,bun);

	 // int rel = relate(*t,p);
	 // if ((rel != DISJOINT) && (rel != TOUCH))
	 {
	    BUNins(result,BUNhead(rectlist,bun),t);
	 }
      }
   }
   else
   {
      for(int i = 0;i < self->number;++i)
	 RTREE_local_select_overlap(rectlist,heap,self->entries[i],p,result);
   }
}


BAT* select_overlap_polyline_polyline(BAT* left,const polyline& p)
{
   BAT* result;
   Heap* heapleft = &(left->taccelerator);
   int leftrootindex = RTREErootindex(heapleft);

   {
      int res_tuples = 10;
      result = BATnew(BAThtype(left),BATttype(left),res_tuples);
   }

   if (leftrootindex != 0)
   {
      RTREE_local_select_overlap(
	 left,
	 heapleft,
	 leftrootindex,
	 p,
	 result);
   }
   return(result);
}
