@f rtree_point
@A C.W. Quak
@* The 'rtree_point' accelerator for boxes.
@h
#ifndef __RTREE_POINT_H__
#define __RTREE_POINT_H__

extern BAT* select_overlap_point_box(BAT* seglist,const box& b);

extern BAT* select_dist_point_point(
   BAT* points,
   const point& p,
   double* min,
   double* max);

#endif /* __RTREE_POINT_H__ */
@+ Code for ptree accelerator.
@C
#include "gis.h"
#include "opengis.h"
#include "gisbulk.proto.h"
#include "rtree.h"
#include "rtree_point.h"
@C
//
// Build an rtree index on a bat[point,any].
//
void RTREEbuild_point(
   Heap* heap,
   int*,
   BAT* bat)
{
   bat->hacctype = ACC_rtree_point;

   RTREEcreate(heap);

   //
   // Insert all buns into the heap.
   //
   {
      BUN index,dummy;

      BATloop(bat,index,dummy)
      {
	 RTREEinsert_point(heap,BUNindex(bat,index),bat,(point *)BUNhead(bat, index));
      }
   }
}

//
//------------------------------------------------------------------------
//
@- Ptree distance select.
@C
static void RTREE_local_select_squared_dist_point_point(
   BAT* points,
   Heap* ptree,
   int nodeindex,
   const point& p,
   double* min,
   double* max,
   BAT* result)
{
   RTREEnode* self = RTREEindex(ptree,nodeindex);

   if ((min != NULL) && (squared_maxdist(p,self->bbox) < *min))
      return;
   if ((max != NULL) && (squared_mindist(p,self->bbox) > *max))
      return;

   if (self->isleaf())
   {
      for(int i = 0;i<self->number;++i)
      {
	 BUN bun = (BUN)BUNptr(points,self->entries[i]);
	 point *t = (point *)BUNtail(points,bun);

	 if ((min != NULL) && (squared_distance(p,*t) < *min))
	    continue;
	 if ((max != NULL) && (squared_distance(p,*t) > *max))
	    continue;

	 BUNins(result,BUNhead(points,bun),t);
      }
   }
   else
   {
      for(int i = 0;i < self->number;++i)
	 RTREE_local_select_squared_dist_point_point
	    (points,ptree,self->entries[i],p,min,max,result);
   }
}

BAT* select_dist_point_point(BAT* points,const point& p,double* min,double* max)
{
   BAT* result = BATnew(BAThtype(points),BATttype(points),BATcount(points)/10);
   Heap* ptree = &points->taccelerator;

   if (min != NULL)
      *min *= *min;
   if (max != NULL)
      *max *= *max;

   if (ptree->base == NULL)
   {
      GDKerror("This BAT has no index");
      return(NULL);
   }

   int rootindex = RTREErootindex(ptree);

   if (rootindex != 0)
      RTREE_local_select_squared_dist_point_point
         (points,ptree,rootindex,p,min,max,result);

   return(result);
}

//
//------------------------------------------------------------------------
//
@- Ptree select.
@C
static void PTREE_local_select(
   BAT* rectlist,
   Heap* heap,
   int nodeindex,
   const box& b,
   BAT* result)
{
   RTREEnode* self = RTREEindex(heap,nodeindex);

   if (!overlap(self->bbox,b))
      return;

   if (self->isleaf())
   {
      for(int i = 0;i<self->number;++i)
      {
	 BUN bun = (BUN)BUNptr(rectlist,self->entries[i]);
	 point *t = (point *)BUNtail(rectlist,bun);
	 if (b.surrounds(*t))
	    BUNins(result,BUNhead(rectlist,bun),t);
      }
   }
   else
   {
      for(int i = 0;i < self->number;++i)
	 PTREE_local_select(rectlist,heap,self->entries[i],b,result);
   }
}

BAT* select_overlap_point_box(BAT* seglist,const box& b)
{
   BAT* result = BATnew(BAThtype(seglist),BATttype(seglist),BATcount(seglist)/10);
   Heap* heap = &seglist->taccelerator;

   if (heap->base == NULL)
   {
      GDKerror("This BAT has no index");
      return(NULL);
   }

   int rootindex = RTREErootindex(heap);

   if (rootindex != 0)
      PTREE_local_select(seglist,heap,rootindex,b,result);

   return(result);
}
