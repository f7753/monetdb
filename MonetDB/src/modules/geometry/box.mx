@f box
@t The Box class
@A C.W. Quak
@* The box class

This module defines a C++ class box. A box is represented by for margins: The left
and right margins are the minimum-, resp maximum x-coordinate. The top and bottom 
margins are the maximum and minimum y-coordinate.
@h
#ifndef __BOX_H__
#define __BOX_H__

//
// Object Definition.
//
class box
{
public:
   //
   // Data storage.
   //
   coord left;
   coord top;
   coord right;
   coord bottom;

   //
   // Constructors.
   //
   box(coord left,coord top,coord right,coord bottom);
   box();
   box(const point& p);

   //
   // Operations Required by Monet.
   //
   int hash() const;
   bool OK() const;
   bool operator== (const box& b) const;
   bool operator!= (const box& b) const;
   int expectedstrlen() const;
   int tostr(char* s,int len) const;
   static box* null();
   static box* create();
   static box* fromstr(char *s,int* parselen,int *buflen,box* p);

   //
   // Const Operations.
   //
   box bbox() const;
   int dimension() const;
   double area() const;
   box* copy() const;
   bool surrounds(const point& p) const;
   bool surrounds(const box& b) const;
   bool surrounds(const class segment& s) const;
   bool surrounds(const class polygon& p) const;
   bool surrounds(const class polyline& p) const;
   point center() const;
   class polygon* topolygon() const;
   class polyline* topolyline() const;
   coord width() const;
   coord height() const;

   segment north() const;
   segment south() const;
   segment east() const;
   segment west() const;

   point rupper() const;
   point runder() const;
   point lupper() const;
   point lunder() const;

   box translate(const point& p) const;
   box scale(const double factor) const;

   void operator+=(const point& p);
   void operator-=(const point& p);
   void operator*=(const double factor);
   void operator/=(const double factor);

   //
   // Update operations.
   //
   box& bbox_include(const point& p);		// enlarge box so that p is included.
   box& bbox_include(const box& b);		// enlarge box so that b is included.
   box& bbox_include(const class segment& s);	// enlarge box so that s is included.
   box& bbox_include(const class triangle& t);	// enlarge box so that t is included.
   box& bbox_include(const class polystruct& p);// enlarge box so that p is included.
   void set(coord left,coord top,coord right,coord bottom);
   void set(const point& p);

   void convert_host_to_net();
   void convert_net_to_host();
};

//
// Function Prototypes.
//
extern bool marginoverlap(const box& b1,const box& b2);
// extern void bbox(box& rval,const box& b1,const box&b2);
extern box intersection(const box& b1,const box& b2);

inline int box::dimension() const
{
   return(2);
}


//
// Inline Implementation
//
inline box::box()
{
#ifdef DEBUG
   left = 0;
   top = 0;
   right = 0;
   bottom = 0;
#endif
}


inline box* box::create()
{
#ifdef OVERLOAD_NEW
   return new box;
#else
   return((box* )GDKmalloc(sizeof(box)));
#endif
}

inline box* box::copy() const
{
#ifdef OVERLOAD_NEW
   return(new box(*this));
#else
   box* rval = box::create();
   *rval = *this;
   return(rval);
#endif
}

inline box box::bbox() const
{
   return(*this);
}

inline box::box(const point& p)
{
   left = p.x;
   right = p.x;
   top = p.y;
   bottom = p.y;
}

inline box::box(coord l,coord t,coord r,coord b)
{
   left = l;
   right = r;
   top = t;
   bottom = b;

#ifdef DEBUG
   OK();
#endif
}

inline void box::set(coord l,coord t,coord r,coord b)
{
   left = l;
   right = r;
   top = t;
   bottom = b;

#ifdef DEBUG
   OK();
#endif
}

inline bool box::operator==(const box& r) const
{
   return((left == r.left) &&
          (right == r.right) &&
	  (top == r.top) &&
	  (bottom == r.bottom));
}

inline bool box::operator!=(const box& r) const
{
   return(!(*this == r));
}

inline void box::set(const point& p)
{
   left = p.x;
   right = p.x;
   top = p.y;
   bottom = p.y;
}

inline coord box::height() const
{
#ifdef DEBUG
   OK();
#endif

   return(top - bottom);
}

inline coord box::width() const
{
#ifdef DEBUG
   OK();
#endif

   return(right - left);
}

inline point box::center() const
{
#ifdef DEBUG
   OK();
#endif

   return(point((right + left) / 2,(top + bottom) / 2));
}

inline double box::area() const
{
#ifdef DEBUG
   OK();
#endif

   return((right - left) * (top - bottom));
}


inline box& box::bbox_include(const box& b)
{
#ifdef DEBUG
   OK();
   b.OK();
#endif

   if (b.left < left)
      left = b.left;
   if (b.top > top)
      top = b.top;
   if (b.right > right)
      right = b.right;
   if (b.bottom < bottom)
      bottom = b.bottom;

   return(*this);
}

inline box& box::bbox_include(const point& p)
{
   if (p.x > right)
      right = p.x;
   if (p.x < left)
      left = p.x;
   if (p.y > top)
      top = p.y;
   if (p.y < bottom)
      bottom = p.y;

   return(*this);
}

inline box bbox(const box& b1,const box& b2)
{
   return(box(
    (b1.left < b2.left)?(b1.left):(b2.left),
    (b1.top > b2.top)?(b1.top):(b2.top),
    (b1.right > b2.right)?(b1.right):(b2.right),
    (b1.bottom < b2.bottom)?(b1.bottom):(b2.bottom)));
}

inline int box::hash() const
{
   union flcu
   {
      float fval;
      int  lval;
      char  cval[4];
   } h;

   h.fval = (left + top + right + bottom);
   //GDKwarning("(%f,%f,%f,%f) = %f\n",left,top,right,bottom,h.fval);
   h.lval *= 104729;
   h.cval[0] = 0;
   int rval = h.lval;


   return(rval);

}


#endif /* __BOX_H__ */
@C
@+ Implementation Code for box values.
@C
#include <string.h>
#include <stdlib.h>
#include <stdio.h>
#include <math.h>

#include "geometry.h"

int box::expectedstrlen() const
{
   return(200);
}

int box::tostr(char* s,int len) const
{
   int rval = 0;
   rval += sprintf(s + rval,"(");
   rval += put_coord(s + rval,left);
   rval += sprintf(s + rval,",");
   rval += put_coord(s + rval,top);
   rval += sprintf(s + rval,",");
   rval += put_coord(s + rval,right);
   rval += sprintf(s + rval,",");
   rval += put_coord(s + rval,bottom);
   rval += sprintf(s + rval,")");

   if (rval > len)
      GDKwarning("Prepare for the worst\n");
   return(rval);
}

box* box::fromstr(char *s,int* parselen,int *buflen,box* b)
{
   if (b == NULL)
   {
      b = box::create();
      *buflen = sizeof(box);
   }
   if (*buflen < (int)sizeof(box))
   {
      delete (void *)b;
      b = box::create();
      *buflen = sizeof(box);
   }
   char *snew = s;

   snew = strchr(snew,'(');
   ++snew;
   b->left = get_coord(snew,&snew);

   snew = strchr(snew,',');
   ++snew;
   b->top = get_coord(snew, &snew);

   snew = strchr(snew,',');
   ++snew;
   b->right = get_coord(snew, &snew);

   snew = strchr(snew,',');
   ++snew;
   b->bottom = get_coord(snew, &snew);

   snew = strchr(snew,')');
   ++snew;

   //
   // Check some constraints
   //
   if (b->left > b->right)
   {
      coord temp;
      GDKwarning("Box found where left > right(swapped)\n");

      temp = b->right;
      b->right = b->left;
      b->left = temp;
   }
   if (b->bottom > b->top)
   {
      coord temp;
      GDKwarning("Box found where bottom > top (swapped)\n");

      temp = b->top;
      b->top = b->bottom;
      b->bottom = temp;
   }

   int bytesread = snew-s;
   if (bytesread > *parselen)
      GDKwarning("Problems\n");
   
   *parselen = bytesread;
   return(b);
}

box* box::null()
{
   box* rval = new box(COORD_MAX,COORD_MAX,COORD_MAX,COORD_MAX);
   return(rval);
}

box& box::bbox_include(const segment& s)
{
   bbox_include(s.source);
   bbox_include(s.dest);
   return(*this);
}


box& box::bbox_include(const triangle& t)
{
   bbox_include(t.p1);
   bbox_include(t.p2);
   bbox_include(t.p3);
   return(*this);
}

point box::runder() const
{
   return(point(right,bottom));
}

point box::rupper() const
{
   return(point(right,top));
}

point box::lunder() const
{
   return(point(left,bottom));
}

point box::lupper() const
{
   return(point(left,top));
}

segment box::north() const
{
   return(segment(point(left,top),point(right,top)));
}

segment box::south() const
{
   return(segment(point(left,bottom),point(right,bottom)));
}

segment box::west() const
{
   return(segment(point(left,top),point(left,bottom)));
}

segment box::east() const
{
   return(segment(point(right,top),point(right,bottom)));
}

box& box::bbox_include(const polystruct& p)
{
   bbox_include(p.bbox());

   return(*this);
}

bool box::OK() const
{
   if ((left > right) || (top < bottom))
   {
      GDKerror("box (%f,%f,%f,%f) is inconsistent\n",left,top,right,bottom);
      return(false);
   }
   return(true);
}

bool box::surrounds(const box& b) const
{
   return((b.left >= left) && (b.right <= right) &&
          (b.top <= top) && (b.bottom >= bottom));
}

bool box::surrounds(const point& p) const
{
   return((p.x >= left) && (p.x <= right) && (p.y <= top) && (p.y >= bottom));
}

polyline* box::topolyline() const
{
   polyline* rval = polyline::create(5);

   rval->data(0).x = left;
   rval->data(0).y = bottom;
   rval->data(1).x = right;
   rval->data(1).y = bottom;
   rval->data(2).x = right;
   rval->data(2).y = top;
   rval->data(3).x = left;
   rval->data(3).y = top;
   rval->data(4).x = left;
   rval->data(4).y = bottom;

   return(rval);
}

polygon* box::topolygon() const
{
   polygon* rval = polygon::create(4);

   rval->data(0).x = left;
   rval->data(0).y = bottom;
   rval->data(1).x = right;
   rval->data(1).y = bottom;
   rval->data(2).x = right;
   rval->data(2).y = top;
   rval->data(3).x = left;
   rval->data(3).y = top;

   return(rval);
}

bool box::surrounds(const polygon& p) const
{
   return(surrounds(p.bbox()));
}

bool box::surrounds(const polyline& p) const
{
   return(surrounds(p.bbox()));
}

bool box::surrounds(const segment& s) const
{
   return(surrounds(s.source) && surrounds(s.dest));
}

//
// Return true if the two boxes have at least one edge in common.
// This function is useful for a silly (but useful) optimization in
// rtreedelete.
//
bool marginoverlap(const box& b1,const box& b2)
{
   int rval = (
      (b1.left == b2.left) || (b1.right == b2.right) ||
      (b1.top == b2.top) || (b1.bottom == b2.bottom));
   return(rval);
}

void box::operator -=(const point& p)
{
   left -= p.x;
   top -= p.x;
   right -= p.y;
   bottom -= p.y;
}

void box::operator +=(const point& p)
{
   left += p.x;
   top += p.x;
   right += p.y;
   bottom += p.y;
}

void box::operator*=(const double factor)
{
   left = (coord)(left * factor);
   top = (coord)(top * factor);
   right = (coord)(right * factor);
   bottom = (coord)(factor * factor);
}

void box::operator/=(const double factor)
{
   left = (coord)(left / factor);
   top = (coord)(top / factor);
   right = (coord)(right / factor);
   bottom = (coord)(factor / factor);
}

void box::convert_host_to_net()
{
   convert_endianism(left);
   convert_endianism(top);
   convert_endianism(right);
   convert_endianism(bottom);
}

void box::convert_net_to_host()
{
   convert_endianism(left);
   convert_endianism(top);
   convert_endianism(right);
   convert_endianism(bottom);
}

box intersection(const box& b1,const box& b2)
{
#ifdef DEBUG
   if (!overlap(b1,b2))
      GDKerror("intersection of two boxes is empty\n");
#endif
   interval hor(intersection(
      interval(b1.left,b1.right),
      interval(b2.left,b2.right)));
   interval ver(intersection(
      interval(b1.bottom,b1.top),
      interval(b2.bottom,b2.top)));
   return(box(hor.min,ver.max,hor.max,ver.min));
}
