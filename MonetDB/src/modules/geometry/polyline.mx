@f polyline
@A C.W. Quak
@* The polyline class
@h
#ifndef __POLYLINE_H__
#define __POLYLINE_H__

//
// Object Definition.
//
class polyline : public polystruct
{
public:

   bool OK() const;
   bool operator==(const polyline& r) const;
   bool operator!=(const polyline& r) const;

   //
   // Const Operations.
   //
   int nsegments() const;
   bool selfintersect() const;
   int dimension() const;
   const point& source() const;
   double source_direction() const;
   double dest_direction() const;
   double length() const;
   const segment& sgmt(int index) const;
   const point& dest() const;
   int contains(const point& p) const;
   int closed() const;
   polyline* copy() const;
   static polyline* fromstr(char *s,int* parselen,int *buflen,polyline* p);
   static polyline* create(int npoints);
   class multipoint* boundary() const;
   static polyline* create(const Array<point>& pointlist);
   class polygon* interior() const;
   box bbox() const;
   const minitree* minitreeptr() const;
   bool hasminitree() const;
   const minitree& getminitree() const;
   polyline* addminitree(const minitree& m) const;

   static polyline null;
   bool isnull() const;
   polyline();
};

extern polyline* append(const polyline& p1,const polyline& p2);

//extern void split(
//   const polyline& p1,
//   const polyline& p2,
//   oid o1,
//   oid o2,
//   BAT* oid_plnid,
//   BAT* oid_segpos,
//   BAT* oid_position);

inline bool polyline::isnull() const
{
   return(*this == null);
}

inline polyline::polyline()
{
}

//
// Function Prototypes.
//
extern bool intersect(const polyline& p1,const polyline& p2);

inline int polyline::dimension() const
{
   return(1);
}

inline bool polyline::hasminitree() const
{
   return(hasaccelerator());
}

inline const minitree& polyline::getminitree() const
{
   return(*(minitree *)acceleratorptr());
}


inline const segment& polyline::sgmt(int index) const
{
   return((const segment&)(pnt(index)));
}

inline int polyline::nsegments() const
{
   return(npoints() -1);
}

inline int polyline::closed() const
{
   return(pnt(0) == pnt(npoints() -1));
}

inline const point& polyline::dest() const
{
   return(pnt(npoints()-1));
}

inline const point& polyline::source() const
{
   return(pnt(0));
}

inline bool polyline::operator!=(const polyline& r) const
{
   return(!(*this == r));
}

inline const minitree* polyline::minitreeptr() const
{
   return((minitree *)acceleratorptr());
}

#endif /* __POLYLINE_H__ */
@C
#include <stdlib.h>
#include <string.h>
#include <math.h>

#include "geometry.h"
#include "Pqueue.h"

polyline polyline::null;

//
//=============================================================
// Append polylines p1 and p2, for wich p1.tail() == p2.head().
//=============================================================
//
polyline* append(const polyline& p1,const polyline& p2)
{
   //
   // This function assumes that the two polystructs connect.
   //
   if ((p1.npoints() != 0) && (p2.npoints() != 0) && (p1.dest() != p2.source()))
      GDKwarning("polyline::append polylines do not connect\n");

   //
   // If one of the objects is empty we have special cases.
   //
   if (p1.npoints() == 0)
      return(p2.copy());

   if (p2.npoints() == 0)
      return(p1.copy());

   polyline* rval = polyline::create(p1.npoints() + p2.npoints() - 1);
   int current = 0;

   //
   // We copy the full polyline.
   //
   for(int i=0;i<p1.npoints();++i)
      rval->data(current++) = p1.pnt(i);

   //
   // We skip the first point of the second polyline.
   //
   for(int j=1;j<p2.npoints();++j)
      rval->data(current++) = p2.pnt(j);

   //
   // Sanity checking.
   //
   if (current != rval->npoints())
      GDKerror("Did I smell fish around here?\n");
   
   //
   // If one of the current polylines has a minitree we add a minitree.
   //
   if (p1.hasminitree() || p2.hasminitree())
   {
      polyline* tmpval = rval;
      rval = ::addminitree(*tmpval,10);
      delete tmpval;
   }
   
   return(rval);
}

//
//==================================================================
// Returns the index of point p in the polyline. If p is not a point 
// of the polyline -1 is returned.
//==================================================================
//
int polyline::contains(const point& p) const
{
   for(int i=0;i<npoints();++i)
   {
      if (pnt(i) == p)
	 return(i);
   }
   return(-1);
}
//========================================================================
class Event
{
public:
   int segno;
   double priority;

   inline Event(){};
   inline Event(const int s,const double& p)
   {
      segno = s;
      priority = p;
   }
};

inline bool operator>(const Event& left,const Event& right)
{
   return(left.priority > right.priority);
}

//
// Returns true if some of the segments of the
// polyline cross.
//
bool polyline::selfintersect() const
{
   Pqueue<Event> pq;

   Array<int> status;

   for(int i=0;i<nsegments();++i)
   {
      const segment& s = sgmt(i);

      if (s.source > s.dest)
      {
	 pq.insert(Event(i+1,s.source.x));
	 pq.insert(Event(-i-1,s.dest.x));
      }
      else
      {
	 pq.insert(Event(i+1,s.dest.x));
	 pq.insert(Event(-i-1,s.source.x));
      }
   }

   while(!pq.empty())
   {
      Event event = pq.pop();
      if (event.segno > 0)
      {
	 --event.segno;
	 for(int j=0;j<status.nitems();++j)
	 {
	    segment isection;

	    int dim = baserelate(sgmt(event.segno),sgmt(status[j]),isection);
	    if (dim >= 0)
	    {
	       if (!sgmt(event.segno).hasendpoint(isection.source))
	          return(true);
	    }
	    else if (dim == 1)
	    {
	       if (!sgmt(event.segno).hasendpoint(isection.dest))
	          return(true);
	    }
	 }
	 status.append(event.segno);
      }
      else
      {
	 event.segno = -event.segno -1;
	 status.find(event.segno);
	 status.del(event.segno);
      }
   }
   return(false);
}
//
//=====================================================
// Functions return start and end direction of polyline
//=====================================================
//
double polyline::dest_direction() const
{
   return (direction(dest(),pnt(npoints() -2)));
}

double polyline::source_direction() const
{
   return (direction(source(),pnt(1)));
}
//========================================================================

//
// Returns whether two polylines are equivalent.
// In case of closed lines this is complicated because the lines
// do not have to start at the same point.
//
bool polyline::operator==(const polyline& r) const
{
   if (npoints() != r.npoints())
      return(false);
   if (isnull() && r.isnull())
      return(true);

   //
   // If the polylines are closed some more work needs to be done.
   //
   if (closed() && r.closed())
   {
      //
      // If the polyline is closed the last point needs not to be
      // considered.
      //
      int npts = npoints()-1;

      for(int i=0;i<npts;++i)
      {
	 int j;
	 for(j = 0;j<npts;++j)
	 {
	    if (pnt(i) != r.pnt((i+j)%npts))
	       break;
	 }
	 if (j == npts)
	    return(true);

	 for(j = 0;j<npts;++j)
	 {
	    if (pnt(i) != r.pnt((npts+i-j)%npts))
	       break;
	 }
	 if (j == npts)
	    return(true);
      }
      return(false);
   }

   int i;
   for(i=0;i<npoints();++i)
   {
      if (pnt(i) != r.pnt(i))
	 break;
   }
   if (i == npoints())
      return(true);

   for(i=0;i<npoints();++i)
   {
      if (pnt(i) != r.pnt(npoints()-i-1))
         return(false);
   }

   return(true);
}

bool polyline::OK() const
{
   bool rval = true;

   for(int i=0;i<npoints() - 1;++i)
   {
      for(int j=i+1;j<npoints() - 1;++j)
      {
	 if (pnt(i) == pnt(j))
	 {
	    GDKwarning("polyline with duplicate points %d == %d\n",i,j);
	    rval = false;
	 }
      }
   }
   return(rval);
}

multipoint* polyline::boundary() const
{
   if (closed())
   {
      multipoint* rval = multipoint::create(0);
      return(rval);
   }
   else
   {
      multipoint* rval = multipoint::create(2);
      rval->pnt(0) = source();
      rval->pnt(1) = dest();
      return(rval);
   }
}

//
// Return a polygon of the area enclosed by the polyline. 
// PRE: Polyline must be closed.
//
polygon* polyline::interior() const
{
   if (!closed())
   {
      GDKerror("No interior of nonclosed polyline\n");
      return(0);
   }
   polygon* rval = polygon::create(npoints() -1);

   for(int i=0;i<rval->npoints();++i)
         rval->data(i) = pnt(i);
   
   if (hasminitree())
   {
      polygon* tmpval = rval;
      rval = ::addminitree(*tmpval,10);
      delete tmpval;
   }

   return(rval);
}

polyline* polyline::fromstr(char *instr,int* parselen,int *buflen,polyline* p)
{
   return((polyline *)polystruct::fromstr(instr,parselen,buflen,p));
}

polyline* polyline::create(const Array<point>& pointlist)
{
   return((polyline *)polystruct::create(pointlist));
}

polyline* polyline::create(int npoints)
{
   return((polyline *)polystruct::create(npoints));
}

polyline* polyline::copy() const
{
   return((polyline *)polystruct::copy());
}

extern bool intersect(const polyline& P,const polyline& Q)
{
   segment isection;

   for(int p=0;p<P.nsegments();++p)
      for(int q=0;q<Q.nsegments();++q)
      {
	 if (baserelate(P.sgmt(p),Q.sgmt(q),isection) != -1)
	    return(true);
      }
   return(false);
}

double polyline::length() const
{
   double rval = 0.0;
   for(int i=0;i<nsegments();++i)
      rval += sgmt(i).length();
   return(rval);
}

polyline* polyline::addminitree(const minitree& m) const
{
   polyline* rval = (polyline *)addaccelerator((const char *)&m,m.nbytes());
   return(rval);
}

//
// Return the bounding box of a polyline.
//
box polyline::bbox() const
{
   if (hasminitree())
   {
      const minitree* m = minitreeptr();
      const minitnode& root = (*m)[0];

      return(box(
       modpnt(root.left).x,
       modpnt(root.top).y,
       modpnt(root.right).x,
       modpnt(root.bottom).y));
   }

   //
   // There is no minitree so we do it the oldfashioned way.
   //
   return(((polystruct*)this)->bbox());
}

#ifdef KANTOCHNIETWEG
static void split(
   const polyline& p1,
   const polyline& p2,
   oid polyid1,
   oid polyid2,
   BAT* oid_plnid,
   BAT* oid_segnumpos,
   BAT* oid_location)
{
   bool startpoint_intersect = false;
   bool prevseg_intersect = false;
   bool endseg_intersect = false;
   bool startseg_intersect = false;

   for(int i1=0;i1<p1.nsegments();++i1)
   {
      const segment& s1 = p1.sgmt(i1);

      for(int i2=0;i2<p2.nsegments();++i2)
      {
	 const segment& s2 = p2.sgmt(i2);

	 interval intrvl1 = baserelate(s1,s2);
	 
	 if (!intrvl1.isempty())
	 {
	    interval intrvl2 = baserelate(s2,s1);

	    if (intrvl1.length() == 0)
	    {
	       if (intrvl1.min == 0)
	       {
		  startpoint_intersect = true;
	       }
	       else if (intrvl1.min != 1)
	       {
		  oid newid = OIDnew(1);
		  point p = s1.pointon(intrvl1.min);
		  double pos1 = i1 + intrvl1.min;

		  BUNins(oid_plnid,&newid,&polyid1);
		  BUNins(oid_segnumpos,&newid,&pos1);
		  BUNins(oid_location,&newid,&p);

		  newid = OIDnew(1);
		  double pos2 = i2 + intrvl2.min;

		  BUNins(oid_plnid,&newid,&polyid2);
		  BUNins(oid_segnumpos,&newid,&pos2);
		  BUNins(oid_location,&newid,&p);
	       }
	    }
	    else
	    {

	       if (intrvl1.min == 0)
		  startseg_intersect = true;
	       else
	       {
		  point p = s1.pointon(intrvl1.min);
		  double pos1 = i1 + intrvl1.min;
		  oid newid = OIDnew(1);

		  BUNins(oid_plnid,&newid,&polyid1);
		  BUNins(oid_segnumpos,&newid,&pos1);
		  BUNins(oid_location,&newid,&p);

		  // XX
	       }

	       if (intrvl1.max == 1)
		  endseg_intersect = true;
	       else
	       {
		  point p = s1.pointon(intrvl1.max);
		  double pos1 = i1 + intrvl1.max;
		  oid newid = OIDnew(1);

		  BUNins(oid_plnid,&newid,&polyid1);
		  BUNins(oid_segnumpos,&newid,&pos1);
		  BUNins(oid_location,&newid,&p);

		  // XX
	       }
	    }
	 }
      }

      if (i1 != 0)
      {
         if ((startpoint_intersect == true && startseg_intersect == false && prevseg_intersect == false) ||
	     (startseg_intersect != prevseg_intersect))
	 {
	    point p = s1.source;
	    double pos1 = i1 + 0.0;
	    oid newid = OIDnew(1);

	    BUNins(oid_plnid,&newid,&polyid1);
	    BUNins(oid_segnumpos,&newid,&pos1);
	    BUNins(oid_location,&newid,&p);

	    // XX
	 }
      }

      startpoint_intersect = false;
      prevseg_intersect = endseg_intersect;
      endseg_intersect = false;
      startseg_intersect = false;

   }
}
#endif
