@f segment
@A C.W. Quak
@* The segment class
@h
#ifndef __SEGMENT_H__
#define __SEGMENT_H__

//
// Object Definition.
//
class segment
{
public:
   //
   // Data storage.
   //
   point source;
   point dest;

   //
   // Operations needed by Monet.
   //
   int hash() const;
   bool OK() const;
   int operator==(const segment& right) const;
   int operator!=(const segment& right) const;
   int expectedstrlen() const;
   int tostr(char* s,int len) const;
   static segment null;
   bool isnull() const;
   bool vertical() const;
   bool horizontal() const;
   static segment* create();
   static segment* fromstr(char *s,int* parselen,int *buflen,segment* p);

   coord give_x_if_y_is(coord y);
   coord give_y_if_x_is(coord x);

   //
   // Constructors.
   //
   segment(const point& p1,const point& p2);
   segment(const point& p);
   segment();

   segment* copy() const;
   //
   // Const Operations.
   //
   polyline* topolyline() const;
   box bbox() const;
   point midpoint() const;
   point pointon(double d) const;
   double positionof(point p) const;
   bool hasendpoint(const point& p) const;
   int dimension() const;
   double squared_length() const;
   double length() const;
   double direction() const;
   segment reverse() const;
   class multipoint* boundary() const;

   const point& startPoint() const;
   const point& endPoint() const;

   //
   // Non Const Operations.
   //
   void translate(const point& p);
   void scale(const double factor);
   void rotate(const double angle);
   void set(const point& src,const point& dst);
   void convert_host_to_net();
   void convert_net_to_host();
};

//
// Function Prototypes.
//
extern double angle(const segment& s1,const segment& s2);
// extern point intersection(const segment& s1,const segment& s2);

extern bool adjacent(const segment& s1,const segment& s2);

extern bool common_endpoint(const segment& s1,const segment& s2);
// extern bool intersect(const segment& s1,const segment& s2);
// extern bool intersection(const segment& s1,const segment& s2,point& p);

extern const point& touchpoint(
   const segment& s1,
   const segment& s2);

extern double dummy_numerator;
extern double dummy_denominator;

extern double segment_intersec(
   const point& A,
   const point& B,
   const point& C,
   const point& D,
   double& numerator = dummy_numerator,
   double& denominator = dummy_denominator);


inline const point& segment::startPoint() const
{
   return(source);
}

inline const point& segment::endPoint() const
{
   return(dest);
}

inline int segment::dimension() const
{
   return(1);
}

inline segment::segment(const point& p):
   source(p),
   dest(p)
{
}

inline segment::segment(const point& src,const point& dst):
   source(src),
   dest(dst)
{
}

inline segment::segment()
{
}

//
// Calculate the bounding box of a segment.
//
inline box segment::bbox() const
{
   return(box(
      (source.x < dest.x)?(source.x):(dest.x),
      (source.y > dest.y)?(source.y):(dest.y),
      (source.x > dest.x)?(source.x):(dest.x),
      (source.y < dest.y)?(source.y):(dest.y)
   ));
}

//
// Returns true if p is one if the endpoints of this segment.
//
inline bool segment::hasendpoint(const point& p) const
{
   return((p == source) || (p == dest));
}

#endif /* __SEGMENT_H__ */
@C
@+ Implementation Code for segment values.
@C
#include <string.h>
#include <stdlib.h>
#include <stdio.h>
#include <math.h>

#include "geometry.h"
#include "interval.h"

segment* segment::create()
{
#ifdef OVERLOAD_NEW
   return new segment;
#else
   return((segment* )GDKmalloc(sizeof(segment)));
#endif
}
int segment::tostr(char* s,int len) const
{
   int rval = 0;
   rval += sprintf(s + rval,"(");
   rval += source.tostr(s + rval,len-rval);
   rval += sprintf(s + rval,",");
   rval += dest.tostr(s + rval,len-rval);
   rval += sprintf(s + rval,")");

   if (rval > len)
      GDKwarning("Prepare for the worst\n");
   return(rval);
}

int segment::expectedstrlen() const
{
   return(300);
}

segment* segment::fromstr(char *s,int* parselen,int *buflen,segment* t)
{
   if (t == 0)
   {
      t = segment::create();
      *buflen = sizeof(segment);
   }
   if (*buflen < (int)sizeof(segment))
   {
      delete (void *)t;
      t = segment::create();
      *buflen = sizeof(segment);
   }

   char* snew = s;

   int pbuflen = sizeof(point);
   int pparselen;


   snew = strchr(snew,'(');
   ++snew;

   pparselen = *parselen - (s - snew);
   point::fromstr(snew,&pparselen,&pbuflen,&(t->source));
   s += pparselen;

   snew = strchr(snew,',');
   pparselen = *parselen - (s - snew);
   point::fromstr(snew,&pparselen,&pbuflen,&(t->dest));
   s += pparselen;
   snew = strchr(snew,')');

   int bytesread = snew-s;
   if (bytesread > *parselen)
      GDKwarning("Problems\n");
   
   *parselen = bytesread;
   return(t);
}

segment segment::null(point(COORD_MAX,COORD_MAX),point(COORD_MAX,COORD_MAX));

bool segment::vertical() const
{
   return(source.x == dest.x);
}

bool segment::horizontal() const
{
   return(source.y == dest.y);
}

bool segment::isnull() const
{
   return(*this == null);
}

double segment::positionof(point p) const
{
   if (p == source)
      return(0);
   if (p == dest)
      return(1);
   else
   {
      if (source.y == dest.y)
         return((p.x - source.x) / (dest.x - source.x));
      else
         return((p.y - source.y) / (dest.y - source.y));
   }
}

point segment::pointon(double d) const
{
   if (d == 0)
      return(source);
   if (d == 1)
      return(dest);
   
   return(point(
      source.x + d * (dest.x - source.x),
      source.y + d * (dest.y - source.y)));
}

point segment::midpoint() const
{
   return(point((source.x + dest.x)/2.0,(source.y + dest.y)/2.0));
}

int segment::hash() const
{
   return(bbox().hash());
}

bool segment::OK() const
{
   if (source == dest)
   {
      GDKwarning("segment where (source == dest)\n");
      return(false);
   }
   else
      return(true);
}

polyline* segment::topolyline() const
{
   polyline* rval = polyline::create(2);
   rval->data(0) = source;
   rval->data(1) = dest;
   return(rval);
}

double segment::length() const
{
   return(distance(source,dest));
}

double segment::squared_length() const
{
   return(squared_distance(source,dest));
}

int segment::operator!=(const segment& s) const
{
   return(!(*this == s));
}

int segment::operator==(const segment& s) const
{
   int rval = ((source == s.source && dest == s.dest) ||
               (dest == s.source && source == s.dest));
   return(rval);
}

void segment::set(const point& src,const point& dst)
{
   source = src;
   dest = dst;
}

multipoint* segment::boundary() const
{
   multipoint* rval = multipoint::create(2);
   rval->pnt(0) = source;
   rval->pnt(1) = dest;
   return(rval);
}

segment segment::reverse() const
{
   return(segment(dest,source));
}

double segment::direction() const
{
   return(::direction(source,dest));
}

double angle(const segment& s1,const segment& s2)
{
   return(angle(s1.direction(),s2.direction()));
}

coord segment::give_y_if_x_is(coord x)
{
   //
   // Check whether the segment intersects line.
   //
   if (!interval(source.x,dest.x).inside(x))
   {
      GDKerror("segment::give_y_if_x_is is false\n");
      GDKwarning("  segment = ((%f,%f)---(%f,%f))\n",
         source.x,source.y,dest.x,dest.y);
      GDKwarning("   x = %f\n",x);
      return(0);
   }

   //
   // Special case is horizontal line.
   //
   if (source.y == dest.y)
      return(source.y);

   //
   // Of course this can be done more efficient, but we will change that
   // if the code profiler shows that here is a bottleneck.
   //
   segment t(*this);
   t.source.x = x;
   t.dest.x = x;
   segment testsegment;
   baserelate(*this,t,testsegment);
   return(testsegment.source.y);
}

coord segment::give_x_if_y_is(coord y)
{
   //
   // Check whether the segment intersects line.
   //
   if (!interval(source.y,dest.y).inside(y))
   {
      GDKerror("segment::give_x_if_y_is is false\n");
      return(0);
   }

   //
   // Special case is horizontal line.
   //
   if (source.x == dest.x)
      return(source.x);

   //
   // Of course this can be done more efficient, but we will change that
   // if the code profiler shows that here is a bottleneck.
   //
   segment t(*this);
   t.source.y = y;
   t.dest.y = y;
   segment testsegment;
   baserelate(*this,t,testsegment);
   return(testsegment.source.x);
}



bool common_endpoint(const segment& s1,const segment& s2)
{
   return ((s1.source == s2.source) ||
           (s1.dest == s2.dest) ||
	   (s1.dest == s2.source) ||
	   (s1.source == s2.dest));
}


//
// Segments have at least 1 point in common.
//
bool intersect(const segment& s1,const segment& s2)
{
   segment isection;
   return (baserelate(s1,s2,isection) != -1);
}

//
// Pre: The segments have at least one endpoint in common.
//
const point& touchpoint(
   const segment& s1,
   const segment& s2)
{
   if ((s1.source == s2.source) || (s1.source == s2.dest))
      return(s1.source);
   if ((s1.dest == s2.source) || (s1.dest == s2.dest))
      return(s1.dest);
   GDKwarning("touchpoint called with wrong pre\n");
   return(s1.source);
}

segment* segment::copy() const
{
   segment* rval = create();
   *rval = *this;
   return(rval);
}

//
// Convert endianism.
//
void segment::convert_host_to_net()
{
   source.convert_host_to_net();
   dest.convert_host_to_net();
}
void segment::convert_net_to_host()
{
   source.convert_net_to_host();
   dest.convert_net_to_host();
}

