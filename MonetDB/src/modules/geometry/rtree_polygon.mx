@f rtree_polygon
@A C.W. Quak
@* The 'rtree_polygon' accelerator for boxes.
@h
#ifndef __RTREE_POLYGON_H__
#define __RTREE_POLYGON_H__

extern BAT* select_overlap_polygon_box(BAT* seglist,const box& b);
extern BAT* join_inside_polygon_polygon(BAT* left,BAT* right);

#endif /* __RTREE_POLYGON_H__ */
@C
#include "gis.h"
#include "opengis.h"
#include "gisbulk.proto.h"
#include "rtree.h"
#include "rtree_polygon.h"

//
// Build an RTREE index on the head of the given bat.
//
void RTREEbuild_polygon(
   Heap* heap,
   int*,
   BAT* bat)
{
   if (BAThtype(bat) != TYPE_polygon)
   {
      GDKerror("Cannot build RTREE because head not of type polygon\n");
      return;
   }

   bat->hacctype = ACC_rtree_polygon;
   RTREEcreate(heap);

   //
   // Insert all buns into the heap.
   //
   BUN index,dummy;

   BATloop(bat,index,dummy)
   {
      RTREEinsert_polygon(heap,BUNindex(bat,index),bat,(polygon *)BUNhead(bat, index));
   }
}

static void RTREE_local_select(
   BAT* rectlist,
   Heap* heap,
   int nodeindex,
   const box& b,
   BAT* result)
{
   RTREEnode* self = RTREEindex(heap,nodeindex);

   if (!overlap(self->bbox,b))
      return;

   if (self->isleaf())
   {
      for(int i = 0;i<self->number;++i)
      {
	 BUN bun = (BUN)BUNptr(rectlist,self->entries[i]);
	 polygon *t = (polygon *)BUNtail(rectlist,bun);
	 if (overlap(b,t->bbox()))
	    BUNins(result,BUNhead(rectlist,bun),t);
      }
   }
   else
   {
      for(int i = 0;i < self->number;++i)
	 RTREE_local_select(rectlist,heap,self->entries[i],b,result);
   }
}

BAT* select_overlap_polygon_box(BAT* seglist,const box& b)
{
   BAT* result = BATnew(BAThtype(seglist),BATttype(seglist),BATcount(seglist)/10);
   Heap* heap = &seglist->taccelerator;

   if (heap->base == NULL)
   {
      GDKerror("This BAT has no index");
      return(NULL);
   }

   int rootindex = RTREErootindex(heap);

   if (rootindex != 0)
      RTREE_local_select(seglist,heap,rootindex,b,result);

   return(result);
}

//
//==========================================
// Function for joining two polygon rtrees.
//==========================================
//
static void RTREE_RTREE_local_join_inside(
   BAT* batleft,
   BAT* batright,
   Heap* heapleft,
   Heap* heapright,
   int nodeleft,
   int noderight,
   BAT* result)
{
   RTREEnode* leftptr = RTREEindex(heapleft,nodeleft);
   RTREEnode* rightptr = RTREEindex(heapright,noderight);

   //
   // If bounding boxes do not overlap the join is empty
   //
   if (!overlap(leftptr->bbox,rightptr->bbox))
      return;

   //
   // If both are leaves we are at the deepest level and must compare al pairs.
   //
   if ((leftptr->isleaf()) && (rightptr->isleaf()))
   {
      for(int i=leftptr->number - 1;i>=0;--i)
      {
	 polygon* leftpol = (polygon *)BUNtail(batleft,BUNptr(batleft,leftptr->entries[i]));

	 for(int j=rightptr->number - 1;j>=0;--j)
	 {
	    polygon* rightpol = (polygon *)BUNhead(batright,BUNptr(batright,rightptr->entries[j]));

	    if (inside(*leftpol,*rightpol))
	    {
	       BUNins(result,
		  BUNhead(batleft,BUNptr(batleft,leftptr->entries[i])),
		  BUNtail(batright,BUNptr(batright,rightptr->entries[j])));
	    }
	 }
      }
   }
   else
   {
      /*
      // We must decide which node we enter. If we can choose (when both node
      // are intermediate nodes) we choose the largest node.
      */
      int deepen;
      if (leftptr->isleaf())
	 deepen = RIGHTBOX;
      else if (rightptr->isleaf())
	 deepen = LEFTBOX;
      else
      {
	 if (leftptr->bbox.area() > rightptr->bbox.area())
	    deepen = LEFTBOX;
	 else
	    deepen = RIGHTBOX;
      }

      if (deepen == LEFTBOX)
      {

	 for(int i=leftptr->number -1;i>=0;--i)
	 {
	    RTREE_RTREE_local_join_inside(
	       batleft,batright, heapleft,heapright,
	       leftptr->entries[i],noderight,
	       result);
	 }
      }
      else // we go into the right node
      {
	 for(int j=rightptr->number-1;j>=0;--j)
	 {
	    RTREE_RTREE_local_join_inside(
	       batleft,batright, heapleft,heapright,
	       nodeleft,rightptr->entries[j],
	       result);
	 }
      }
   }
}

BAT* join_inside_polygon_polygon(BAT* left,BAT* right)
{
   BAT* result;
   Heap* heapleft = &(left->taccelerator);
   Heap* heapright = &(right->haccelerator);
   int leftrootindex = RTREErootindex(heapleft);
   int rightrootindex = RTREErootindex(heapright);


   /*
   // We create a BAT for the joined pairs.
   // res_tuples should be set to the expected number of BUNs in the result.
   */
   {
      int res_tuples = 1000;
      result = BATnew(BAThtype(left),BATttype(right),res_tuples);
   }

   if ((leftrootindex != 0) && (rightrootindex != 0))
   {
      RTREE_RTREE_local_join_inside(
	 left, right,
	 heapleft, heapright,
	 leftrootindex,
	 rightrootindex,
	 result);
   }
   return(result);
}
