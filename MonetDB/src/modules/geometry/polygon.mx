@f polygon
@A C.W. Quak
@* The polygon class
@h
#ifndef __POLYGON_H__
#define __POLYGON_H__

//
// Object Definition.
//
class polygon : public polystruct
{
public: 

   bool OK() const;
   bool operator==(const polygon& r) const;
   bool operator!=(const polygon& r) const;

   //
   // Const Operations.
   //
   point gcenter() const;
   point centroid() const;
   point internalpoint() const;
   bool clockwise() const;
   int nsegments() const;
   segment sgmt(int index) const;
   polyline* boundary() const;
   double area() const;
   polygon* copy() const;
   polygon* remove_dups() const;
   polygon* lower_res(double n) const;
   class cpolygon* tocpolygon() const;
   pie getpie(int i,bool* cw=0) const;
   box bbox() const;
   int dimension() const;
   const char* typestring() const;

   bool hasminitree() const;
   const minitree* minitreeptr() const;
   const minitree& getminitree() const;
   polygon* addminitree(const minitree& m) const;

   //
   // Rotate the points of the polygon.
   //
   void cycle();

   static polygon* fromstr(char *s,int* parselen,int *buflen,polygon* p);
   static polygon* create(int npoints);
   static polygon* create(const Array<point>& pointlist);
   static polygon* create(int npoints,int indexsize);
   static polygon null;
   bool isnull() const;
   polygon();
};

inline bool polygon::isnull() const
{
   return(*this == null);
}

inline polygon::polygon()
{
}

inline int polygon::dimension() const
{
   return(2);
}

inline const char* polygon::typestring() const
{
   return "POLYGON";
}


inline const minitree* polygon::minitreeptr() const
{
   return((minitree *)acceleratorptr());
}

inline const minitree& polygon::getminitree() const
{
   return(*(minitree *)acceleratorptr());
}

inline bool polygon::hasminitree() const
{
   return(hasaccelerator());
}

inline int polygon::nsegments() const
{
   return(npoints());
}

inline segment polygon::sgmt(int i) const
{
   return(segment(pnt(i),modpnt(i+1)));
}
#endif /* __POLYGON_H__ */
@C
#include <math.h>
#include <stdlib.h>

#include "geometry.h"

cpolygon* polygon::tocpolygon() const
{
   cpolygon* rval = cpolygon::create(0,nbytes() + 16);
   rval->addhole(*this);
   return(rval);
}

//
// Return center of gravity.
//
// THIS CODE IS NOT TESTED QQQ XXX 
//
point polygon::gcenter() const
{
   double pgarea = area();
   pgarea *= 6;
   double resx = 0;
   double resy = 0;
   double ar;

   for (int i=0; i< npoints(); ++i)
   {
      ar = ((pnt(i).x * modpnt(i+1).y) -
            (pnt(i).y * modpnt(i+1).x));
      resx += (pnt(i).x + modpnt(i+1).x) * ar;
      resy += (pnt(i).y + modpnt(i+1).y) * ar;
   }

   if (clockwise())
   {
      resx = - resx;
      resy = - resy;
   }
   return(point(resx / pgarea,resy / pgarea));
}

point polygon::centroid() const
{
   return(gcenter());
}

//   FAQ:comp.graphics.algoritms.
//
//Subject 2.06: How do I find a single point inside a simple polygon?
//
//   Given a simple polygon, find some point inside it.  Here is a method
//   based on the proof that there exists an internal diagonal, in
//   [O'Rourke (C), 13-14].  The idea is that the midpoint of a diagonal
//   is interior to the polygon.
// 
//   1. Identify a convex vertex v; let its adjacent vertices be a and b.
//   2. For each other vertex q do:
//        2a. If q is inside avb, compute distance to v (orthogonal to ab).
//        2b. Save point q if distance is a new min.
//   3. If no point is inside, return midpoint of ab, or centroid of avb.
//   4. Else if some point inside, qv is internal: return its midpoint.
// 
//   Code for finding a diagonal is in [O'Rourke (C), 35-39], and is part
//   of many other software packages.  See Subject 0.07: Where is all the 
//   source?


point polygon::internalpoint() const
{
   // 
   // 1. Identify a convex vertex v; 
   //    let its adjacent vertices be a and b.
   //
   int cw = clockwise();

   int i;
   for (i = 0; i < npoints(); ++i)
   {
      if (((cw) && (angle(pnt(i),modpnt(i+1),modpnt(i+2)) < M_PI)) ||
          ((!cw) && (angle(pnt(i),modpnt(i+1),modpnt(i+2)) > M_PI)))
         break;
   }
   int a = i;
   int v = i + 1;
   int b = i + 2;


   //
   // 2. For each other vertex q do:
   //      2a. If q is inside avb, compute distance to v (orthogonal to ab).
   //      2b. Save point q if distance is a new min.
   //
   point* closest = 0;
   triangle t(modpnt(a),modpnt(v),modpnt(b));
   for (i = 0; i < npoints(); ++i)
   {
      if ((i == a) || (i == b) || (i == v))
         continue;
      
      if (t.inside(pnt(i)))
      {
         if (closest == 0)
	    closest = pnt(i).copy();
	 else
	 {
	    if (distance(pnt(v),pnt(i)) < distance(pnt(v),*closest))
	       *closest = pnt(i);
	 }
      }
   }

   if (closest == 0)
      return(t.centroid());
   else
      return(segment(*closest,pnt(v)).midpoint());
}

//
// Remove duplicate points in a polygon.
//
polygon* polygon::remove_dups() const
{
   int finalp=npoints() - 1;
   while(pnt(0) == pnt(finalp))
      --finalp;

   int lastpoint = 0;
   int np = 1;
   for(int i=1;i<finalp;++i)
   {
      if (pnt(i) != pnt(lastpoint))
      {
	 ++np;
	 lastpoint = i;
      }
   }

   polygon* rval = create(np);

   rval->data(0) = pnt(0);
   int current = 0;

   for(int j=1;j<finalp;++j)
   {
      if (pnt(j) != rval->pnt(current))
      {
	 ++current;

	 if (current == np)
	    GDKerror("bug 1 in polygon::remove_dups()\n");
	 else
	    rval->data(current) = pnt(j);
      }
   }

   if (current +1 != np)
      GDKerror("bug 2 in polygon::remove_dups()\n");

   return(rval);
}

//
// Lower the resolution of a polygon.
//
polygon* polygon::lower_res(double n) const
{
   polygon* rval = create(npoints());

   for(int i=0;i<npoints();++i)
   {
      rval->data(i).x = (coord)(n * ((int)(pnt(i).x / n)));
      rval->data(i).y = (coord)(n * ((int)(pnt(i).y / n)));
   }

   return(rval);
}

//
// Generate duplicate of polygon.
//
polygon* polygon::copy() const
{
   return((polygon *)polystruct::copy());
}

bool polygon::operator!=(const polygon& r) const
{
   return(!(*this == r));
}

//
// Returns true if two polygons are equivalent. This means
// they have the same list of points. It checks on starting
// point.
//
bool polygon::operator==(const polygon& r) const
{
   int i,j;

   if (npoints() != r.npoints())
      return(false);

   if (isnull() && r.isnull())
      return(true);

   int np = npoints();
   for(i=0;i<np;++i)
   {
      if (pnt(0) == r.pnt(i))
      {
	 for(j = 0;j<np;++j)
	 {
	    if (pnt(j) != r.modpnt(i+j))
	       break;
	 }
	 if (j == np)
	    return(true);
	 for(j = 0;j<np;++j)
	 {
	    if (pnt(j) != r.modpnt(np+i-j))
	       break;
	 }
	 if (j == np)
	    return(true);
      }
   }
   return(false);
}

//
// Perform some integrity checks on the polygons. Returns true if OK.
// 1. Intersecting segments is wrong.
// 2. A polygon with 0 area is wrong.
// 3. Its accompanying minitree is OK.
//
bool polygon::OK() const
{
   bool rval = true;

   for(int i=0;i<npoints();++i)
   {
      for(int j=i+1;j<npoints();++j)
      {
	 if (sgmt(i) == sgmt(j))
	 {
	    rval = false;
	 }
      }
   }

   if (area() == 0)
   {
      rval = false;
   }

   //
   // Check whether the accompanying minitree is OK.
   //
   if (hasminitree())
   {
      const minitree* m = minitreeptr();

      if (!::OK(*this,*m))
	 rval = false;
   }
   return(rval);
}

polygon* polygon::create(const Array<point>& pointlist)
{
   return((polygon *)polystruct::create(pointlist));
}

polygon* polygon::create(int npoints,int indexsize)
{
   return((polygon *)polystruct::create(npoints,indexsize));
}

polygon* polygon::create(int npoints)
{
   return((polygon *)polystruct::create(npoints));
}

polyline* polygon::boundary() const
{
   int i;

   polyline* rval = polyline::create(npoints() +1);
   for(i=0;i<npoints();++i)
      rval->data(i) = pnt(i);
   rval->data(npoints()) = pnt(0);
   return(rval);
}

//
// Return true if the points on the polygon are clockwise ordered.
//
bool polygon::clockwise() const
{
   double rval=0;
   for (int i=0;i<npoints();++i)
   {
      rval += (pnt(i).x - modpnt(i+1).x) * (pnt(i).y + modpnt(i+1).y);
   }

   if (rval == 0.0)
      GDKwarning("Flat polygon is neither clockwise nor counterclockwise\n");
   
   return(rval < 0.0);
}

double polygon::area() const
{
   double       rval=0;
   int          i;

   for (i=0;i<npoints();++i)
   {
      rval += ((pnt(i).x) - modpnt(i+1).x) * ((pnt(i).y) + modpnt(i+1).y);
   }
   rval /= 2.0;
   if (rval < 0)
      rval = - rval;

   return(rval);
}

polygon* polygon::fromstr(char *instr,int* parselen,int *buflen,polygon* p)
{
   return((polygon *)polystruct::fromstr(instr,parselen,buflen,p));
}

polygon polygon::null;

//
// Return the pie of a 
//
pie polygon::getpie(int i,bool* cwcache) const
{
   bool cw;
   if(cwcache != 0)
      cw = *cwcache;
   else
      cw = clockwise();

   if (cw)
      return(pie(
         direction(pnt(i),modpnt(i+1)),
         direction(pnt(i),modpnt(i-1))));
   else
      return(pie(
         direction(pnt(i),modpnt(i-1)),
         direction(pnt(i),modpnt(i+1))));
}

//
// Return the bounding box of a polygon.
//
box polygon::bbox() const
{
#ifdef DEBUG
   OK();
#endif

   if (hasminitree())
   {
      const minitree* m = minitreeptr();
      const minitnode& root = (*m)[0];

      return(box(
       modpnt(root.left).x,
       modpnt(root.top).y,
       modpnt(root.right).x,
       modpnt(root.bottom).y));
   }

   //
   // There is no minitree so we do it the oldfashioned way.
   //
   return(((polystruct*)this)->bbox());
}

void polygon::cycle()
{
   point tmp(pnt(0));

   for(int i=1;i<npoints();++i)
      data(i-1) = data(i);
   data(npoints()-1) = tmp;
}

polygon* polygon::addminitree(const minitree& m) const
{
   polygon* rval = (polygon *)addaccelerator((const char *)&m,m.nbytes());
   return(rval);
}
