@f minitree
@* An accelator for operations on polygon atoms.
@h
#ifndef __MINITREE_H__
#define __MINITREE_H__

class minitnode
{
public:
   short left;		// Index to point with smallest x-coordinate.
   short top;		// Index to point with biggest y-coordinate.
   short right;		// Index to point with biggest x-coordinate.
   short bottom;	// Index to point with smallest y-coordinate.

   void convert_host_to_net();	// Convert given node from big to little- endian.
   void convert_net_to_host();

   box getbbox(const polystruct& p) const;
};

//
// The minitree, a small atomic type belonging to a polygon, which can be used
// to speed up operations on the polygon.
//
class minitree
{
public:
   int nbytes_v;		// Number of bytes used by minitree.
private:
   short depth_v;		// Number of levels in minitree.

public:
   minitnode data[1];		// Array of Nodes.

public:

   //
   // Simple member functions.
   //
   int dimension() const;
   int nbytes() const;
   int depth() const;

   //
   // Return a reference to a given node in the minitree.
   //
   minitnode& operator[](int index);
   const minitnode& operator[](int index) const;

   //
   // Constructors.
   //
   minitree(int dim);
   void *operator new(size_t size,int depth);
   void operator delete(void *ptr);
   void convert_host_to_net();
   void convert_net_to_host();
   static minitree* create(int dim);
   minitree* copy() const;
};

//
// Consistency Check
//
extern bool OK(const polygon& p,const minitree& m);

//
// Is point pnt inside polygon pgn?
//
extern bool inside(const point& pnt,const polygon& pgn,const minitree& m);
extern double squared_distance(const point& pnt,const polygon& pgn,const minitree& m);
extern double squared_distance(const segment& s,const polygon& p,const minitree& m);
extern double squared_distance(const polygon& p1,const minitree& m1,const polygon& p2,const minitree& m2);
extern double squared_distance(const polyline& p1,const minitree& m1,const polyline& p2,const minitree& m2);

extern bool overlap(const polygon& p1,const minitree& m1,const polygon& p2,const minitree& m2);
extern bool inside(const polygon& p1,const minitree& m1,const polygon& p2,const minitree& m2);
extern bool overlap(const segment& s,const polygon& p,const minitree& m);

extern minitree* extract(polystruct& p);

extern minitree* create_minitree(const polygon& p,int maxleafsize);
extern minitree* create_minitree(const polyline& p,int maxleafsize);

extern polygon* addminitree(const polygon& p,int n);
extern cpolygon* addminitree(const cpolygon& p,int n);
extern polyline* addminitree(const polyline& p,int n);

extern polygon* removeminitree(const polygon& p);
extern cpolygon* removeminitree(const cpolygon& p);
extern polyline* removeminitree(const polyline& p);

extern bool calc_0(
   const polyline& l1,
   const minitree& m1,
   const multipoint& bnd1,
   const polyline& l2,
   const minitree& m2,
   const class multipoint& bnd2,
   class relmatrix& rel);

extern bool contains(
   const polyline& l,
   const minitree& m,
   const point& p);

inline int getmid(int min,int max)
{
   return((min + max) / 2);
}

inline int child0(int index)
{
   return(index + index + 1);
}

inline int child1(int index)
{
   return(index + index + 2);
}

//
// Return the nbytes attribute of the minitree.
//
inline int minitree::nbytes() const
{
   return(nbytes_v);
}

static inline int calcdimension(int depth)
{
   return( (1 << depth) - 1);
}

//
// Calculate number of bytes used by minitree given its depth.
//
inline size_t minitreesize(int depth)
{
   int dim = calcdimension(depth);
   return(sizeof(minitree) + (((dim>0)?(dim -1):(0))* sizeof(minitnode)));
}

inline int minitree::depth() const
{
   return(depth_v);
}

inline int minitree::dimension() const
{
   return(calcdimension(depth()));
}

inline minitree::minitree(int depth)
{
   depth_v = (short)depth;
   nbytes_v = minitreesize(depth);
}

inline void minitree::operator delete( void *ptr)
{
   delete ptr;
}

inline void* minitree::operator new(size_t size,int depth)
{
   int dim = calcdimension(depth);
   return ((void *)new char[size + ((dim -1)* sizeof(minitnode))]);
}

inline minitree* minitree::copy() const
{
   minitree* rval = new(depth()) minitree(depth());
   memcpy(rval,this,minitreesize(depth()));
   return(rval);
}

inline box minitnode::getbbox(const polystruct& p) const
{
   return(box(
      p.modpnt(left).x,
      p.modpnt(top).y,
      p.modpnt(right).x,
      p.modpnt(bottom).y));
}

inline box bbox(const polygon& p,const minitree& m)
{
   const minitnode& root = m[0];
   return(box(
      p.modpnt(root.left).x,
      p.modpnt(root.top).y,
      p.modpnt(root.right).x,
      p.modpnt(root.bottom).y));
}

#endif /* __MINITREE_H__ */
@C
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include "geometry.h"
#include "gis.proto.h"
#include "opengis.h"
#include "minitree.h"

extern "C"
{
#include "gdk_heap.h"
}

#define HEAPindex(HEAP,INDEX,TYPE) ((TYPE *)(HEAP->base + INDEX))

int minitree_tostr(char** tostr,int* l,minitree* m)
{
   {
      int expectedlen = 20 + (m->dimension() * 15);
      if (*l < expectedlen)
      {
         if (*tostr != NULL)
	    delete *tostr;
	 *tostr = new char[expectedlen];
         *l = expectedlen;
      }
   }

   sprintf(*tostr,"(%d:", m->dimension());
   char* s = *tostr + strlen(*tostr);

   for (int i=0;i<m->dimension();++i)
   {
      sprintf(s,"%s[%d %d %d %d]", ((i==0)?"":","),
         (int)(*m)[i].left,
         (int)(*m)[i].top,
         (int)(*m)[i].right,
         (int)(*m)[i].bottom);
      s += strlen(s);
   }
   *s++ = ')';
   *s = '\0';
   return(s - *tostr);
}

int minitree_fromstr(char*,int*,minitree** val)
{
   *val = NULL;
   return(1);
}

void minitree_put(Heap* h,int* bun,minitree* val)
{
   char* base;

   *bun  = HEAP_malloc(h,minitreesize(val->dimension()));
   base = h->base;
   memcpy(&base[*bun],(char *)val,minitreesize(val->dimension()));

}

int minitree_get(Heap* h,int* bun,int* l,minitree** val)
{
   minitree* from = HEAPindex(h,*bun,minitree);
   int size = minitreesize(from->dimension());

   if (*val == NULL)
   {
      *val = (minitree *)(new char[size]);
      *l = size;
   }
   else if (*l < size)
   {
      delete *val;
      *val = (minitree *)(new char[size]);
      *l = size;
   }
   memcpy(*val,from,size);

   return (size);
}

int minitree_comp(minitree* l,minitree*  r)
{
   int minlen = l->dimension();
   if (r->dimension() < minlen)
      minlen = r->dimension();
   
   if (minlen == -1)
      return(0);

   for(int i=0;i<minlen;++i)
   {
      if(l->data[i].left != r->data[i].left)
      {
	 if ((*l)[i].left > (*r)[i].left)
	    return(1);
	 else
	    return(-1);
      }
   }

   if (l->dimension() == r->dimension())
      return(0);
   else if (l->dimension() < r->dimension())
      return(-1);
   else
      return(1);
}

int minitree_heapcheck(
   Heap*        h,
   HeapRepair*  hr)

{
   return(HEAP_check(h,hr));
}

void minitree_del(Heap* h,int* index)
{
   HEAP_free(h,*index);
}

int minitree_hash(minitree* I)
{
   const minitnode& root = (*I)[0];

   return(I->dimension() * root.left * root.right);

   //
   // Ok not a perfect implementation.
   //
}

 minitree* minitree_null()
{
   minitree* rval = new(0) minitree(0);
   return(rval);
}

int minitree_length(minitree* p)
{
   return(minitreesize(p->dimension()));
}


int minitree_heap(Heap* heap,int capacity)
{
   HEAP_initialize(heap,capacity,0,4);
   return 0;
}

minitree* minitree::create(int depth)
{
   minitree* rval = new(depth) minitree(depth);
   return(rval);
}

const minitnode& minitree::operator[](int index) const
{
#ifdef DEBUG
   if ((index < 0) || (index >= dimension()))
      GDKerror("index %d out of bounds [0,%d] allowed in minitree::operator[]\n",
         index,dimension()-1);
#endif
   return(data[index]);
}

minitnode& minitree::operator[](int index)
{
#ifdef DEBUG
   if ((index < 0) || (index >= dimension()))
      GDKerror("index %d out of bounds [0,%d] allowed in minitree::operator[]\n",
         index,dimension()-1);
#endif
   return(data[index]);
}

//------------------------------------------------------------------------

//
// Return an upper bound for the distance between two polygons.
//

//
// Method one: Two random points is the cheapest way.
//
static inline double probe_squared_distance_random(
   const polystruct& p1,
   const minitree&,
   const polystruct& p2,
   const minitree&)
{
   return(squared_distance(p1.pnt(0),p2.pnt(0)));
}

//
// Using the bounding box is a somewhat better and more expensive way.
//
static inline double probe_squared_distance_bbox(
   const polystruct& p1,
   const minitree& t1,
   const polystruct& p2,
   const minitree& t2)
{
   const minitnode& root1 = t1[0];
   const minitnode& root2 = t2[0];
   
   double rval = squared_distance(p1[0],p2[0]);

   reduce_squared_distance(rval,p1.modpnt(root1.left),p2.modpnt(root2.right));
   reduce_squared_distance(rval,p1.modpnt(root1.right),p2.modpnt(root2.left));
   reduce_squared_distance(rval,p1.modpnt(root1.top),p2.modpnt(root2.bottom));
   reduce_squared_distance(rval,p1.modpnt(root1.bottom),p2.modpnt(root2.top));

   return(rval);
}

//
// Finally one can probe the minitree.
//
static void probe_squared_distance_rec(
   const polystruct& p1,
   const minitnode* tree1,
   int currentindex1,
   int min1,
   int max1,
   const int depth1,
   const int maxdepth1,
   const polystruct& p2,
   const minitnode* tree2,
   int currentindex2,
   int min2,
   int max2,
   const int depth2,
   const int maxdepth2,
   double rval)
{
   const minitnode& current1 = tree1[currentindex1];
   const minitnode& current2 = tree2[currentindex2];

   //
   // Both children are leaves.
   //
   if ((depth1 == maxdepth1) && (depth2 == maxdepth2))
   {
      //
      // We found two leaves which are probablt close to each other.
      //
      reduce_squared_distance(rval,p1.modpnt(current1.left),p2.modpnt(current2.right));
      reduce_squared_distance(rval,p1.modpnt(current1.right),p2.modpnt(current2.left));
      reduce_squared_distance(rval,p1.modpnt(current1.top),p2.modpnt(current2.bottom));
      reduce_squared_distance(rval,p1.modpnt(current1.bottom),p2.modpnt(current2.top));

      return;
   } 
   else if (depth1 < maxdepth1)
   {
      box bb1a(tree1[child0(currentindex1)].getbbox(p1));
      box bb1b(tree1[child0(currentindex2)].getbbox(p2));
      box bb2(current2.getbbox(p2));
      int mid1 = getmid(min1,max1);

      if (distance(bb1a,bb2) < distance(bb1b,bb2))
      {
	 if (depth2 < maxdepth2)
	 {
	    probe_squared_distance_rec(
	       p2, tree2, currentindex2, min2, max2,depth2,maxdepth2,
	       p1, tree1, child0(currentindex1), min1, mid1,depth1 + 1,maxdepth1,rval);
	    return;
	 }
	 else
	 {
	    probe_squared_distance_rec(
	       p1, tree1, child0(currentindex1), min1, mid1, depth1 + 1,maxdepth1,
	       p2, tree2, currentindex2, min2, max2, depth2 + 1,maxdepth2,rval);
	   return;
	 }
      }
      else
      {
	 if (depth2 < maxdepth2)
	 {
	    probe_squared_distance_rec(
	       p2, tree2, currentindex2, min2, max2, depth2 + 1,maxdepth2,
	       p1, tree1, child1(currentindex1), mid1, max1, depth1 + 1,maxdepth1,rval);
	    return;
	 }
	 else
	 {
	    probe_squared_distance_rec(
	       p1, tree1, child1(currentindex1), mid1, max1,depth1 + 1,maxdepth1,
	       p2, tree2, currentindex2, min2, max2,depth2 + 1,maxdepth2,rval);
	    return;
	 }
      }
   }
   else if(depth2 < maxdepth2)
   {
      probe_squared_distance_rec(
	 p2, tree2, currentindex2, min2, max2, depth2 + 1,maxdepth2,
	 p1, tree1, currentindex1, min1, max1, depth1 + 1,maxdepth1,rval);
         
      return;
   }
   else
   {
      GDKerror("If this happens Bill Clinton might be talking the truth\n");
      return;
   }
}

static inline double probe_squared_distance_minitree(
   const polystruct& p1,
   const minitree& m1,
   const polystruct& p2,
   const minitree& m2)
{
   double rval = squared_distance(p1.pnt(0),p2.pnt(0));
   probe_squared_distance_rec(
      p1,
      &(m1.data[0]),
      0,
      0,
      p1.npoints(),
      1,
      m1.depth(),
      p2,
      &(m2.data[0]),
      0,
      0,
      p2.npoints(),
      1,
      m2.depth(),
      rval);

   return(rval);
}

//------------------------------------------------------------------------
//
// This function uses the minitree to find an upperbound
// to the distance between the polygon and the point.
//
double probe_squared_distance(
   const polygon& pgn,
   const minitree& tree,
   const point& pnt)
{
   //
   // For now we only try the four extremes of the root node.
   //
   const minitnode& root = tree[0];

   double current = squared_distance(pnt,pgn.modpnt(root.left));

   reduce_squared_distance(current,pnt,pgn.modpnt(root.right));
   reduce_squared_distance(current,pnt,pgn.modpnt(root.top));
   reduce_squared_distance(current,pnt,pgn.modpnt(root.bottom));
   return(current);
}
//------------------------------------------------------------------------
static bool minitree_overlap_segment_rec(
   const polystruct& pgn,
   const minitnode* tree,
   const int currentindex,
   const int min,
   const int max,
   const int depth,
   const int maxdepth,
   const segment& s)
{
   const minitnode& current = tree[currentindex];
   box bb(
      pgn.modpnt(current.left).x,
      pgn.modpnt(current.top).y,
      pgn.modpnt(current.right).x,
      pgn.modpnt(current.bottom).y);
   box bbs(s.bbox());

   //
   // If there is a chance that we find a closer point in this node
   // we enter it.
   //
   if (!overlap(bb,bbs))
      return(false);

   if (depth == maxdepth)
   {
      //
      // Calculate distance to all segments in this node.
      //
      for(int i=min;i<max;++i)
      {
	if (overlap(s,segment(pgn.pnt(i),pgn.modpnt(i+1))))
	   return(true);
      }
      return(false);
   }
   else
   {
      int mid = getmid(min,max);

       //
       // Enter recursion.
       //
      bool rval = minitree_overlap_segment_rec(
	 pgn,
	 tree,
	 child0(currentindex),
	 min,
	 mid,
	 depth + 1,
	 maxdepth,
	 s);

      if (rval == true)
         return(true);

      return(minitree_overlap_segment_rec(
	 pgn,
	 tree,
	 child1(currentindex),
	 mid,
	 max,
	 depth + 1,
	 maxdepth,
	 s));
   }
}

bool overlap(
   const segment& s,
   const polygon& p,
   const minitree& m)
{
   bool rval = minitree_overlap_segment_rec(
      p,
      &(m.data[0]),
      0,
      0, p.npoints(),
      1,
      m.depth(),
      s);
   
   if (rval == true)
      return(true);

   if (inside(s,p))
      return(true);
   else
      return(false);
}

//------------------------------------------------------------------------
static void minitree_squared_distance_segment_rec(
   const polystruct& pgn,
   const minitnode* tree,
   const int currentindex,
   const int min,
   const int max,
   const int depth,
   const int maxdepth,
   const segment& s,
   double &curdist)
{
   const minitnode& current = tree[currentindex];
   box bb(
      pgn.modpnt(current.left).x,
      pgn.modpnt(current.top).y,
      pgn.modpnt(current.right).x,
      pgn.modpnt(current.bottom).y);
   box bbs(s.bbox());

   //
   // If there is a chance that we find a closer point in this node
   // we enter it.
   //
   if (squared_mindist(bbs,bb) < curdist)
   {
       if (depth == maxdepth)
       {
          //
	  // Calculate distance to all segments in this node.
	  //
	  for(int i = min;i<max;++i)
	  {
	    reduce_squared_distance(curdist,s,segment(pgn.pnt(i),pgn.modpnt(i+1)));
	    if (curdist == 0)
	       return;
	  }
       }
       else
       {
	 int mid = getmid(min,max);

          //
	  // Enter recursion.
	  //
	 minitree_squared_distance_segment_rec(
	    pgn,
	    tree,
	    child0(currentindex),
	    min,
	    mid,
	    depth + 1,
	    maxdepth,
	    s,
	    curdist);

	 if (curdist != 0) // Distance can never be smaller than 0.
	 {
	    minitree_squared_distance_segment_rec(
	       pgn,
	       tree,
	       child1(currentindex),
	       mid,
	       max,
	       depth + 1,
	       maxdepth,
	       s,
	       curdist);
         }
      }
   }
}

double squared_distance(
   const segment& s,
   const polygon& p,
   const minitree& m)
{
   double rval = probe_squared_distance(p,m,s.source);

   minitree_squared_distance_segment_rec(
      p,
      &(m.data[0]),
      0,
      0, p.npoints(),
      1,
      m.depth(),
      s,
      rval);
   
   if (rval != 0)
   {
      //
      // If s is totally inside p the distance is 0.
      //
      if (inside(s,p))
	 rval = 0;
   }
   return(rval);
}

//------------------------------------------------------------------------
static bool minitree_overlap_polystruct_rec(
   const polystruct& p1,
   const minitnode* tree1,
   const int currentindex1,
   const int min1,
   const int max1,
   const int depth1,
   const int maxdepth1,
   const polystruct& p2,
   const minitnode* tree2,
   const int currentindex2,
   const int min2,
   const int max2,
   const int depth2,
   const int maxdepth2)
{
   const minitnode& current1 = tree1[currentindex1];
   const minitnode& current2 = tree2[currentindex2];
   box bb1(
      p1.modpnt(current1.left).x,
      p1.modpnt(current1.top).y,
      p1.modpnt(current1.right).x,
      p1.modpnt(current1.bottom).y);
   box bb2(
      p2.modpnt(current2.left).x,
      p2.modpnt(current2.top).y,
      p2.modpnt(current2.right).x,
      p2.modpnt(current2.bottom).y);

   //
   // If the bounding boxes do not overlap we can return.
   //
   if (!overlap(bb1,bb2))
      return(false);

   if ((depth1 == maxdepth1) && (depth2 == maxdepth2)) // Two leaves.
   {
      for(int i1=min1;i1<max1;++i1)
      {
	 segment s1(p1.pnt(i1),p1.modpnt(i1+1));

         for(int i2=min2;i2<max2;++i2)
	 {
	    segment dummy;
	    if (baserelate(s1,segment(p2.pnt(i2),p2.modpnt(i2+1)),dummy) != -1)
	      return(true);
	 }
      }
      return(false);
   }
   else
   {
      if (bb1.area() > bb2.area())  // Enter the first node.
      {
	 if (depth1 == maxdepth1)
	 {
	    //
	    // Left leaf, right node:
	    //    For all segments in the leaf calculate distance
	    //    to right node.
	    //
	    for(int i1=min1;i1<max1;++i1)
	    {
	       segment s1(p1.pnt(i1),p1.modpnt(i1+1));

	       if (minitree_overlap_segment_rec(
	          p2,tree2,currentindex2,min2,max2,depth2,maxdepth2,s1))
		  return(true);
	    }
	    return(false);
	 }
	 else
	 {
	    //
	    // Left node, right anything:
	    //    For both children do recursion.
	    //
	    int mid1 = getmid(min1,max1);

	    bool rval = minitree_overlap_polystruct_rec(
	       p1, tree1, child0(currentindex1),
	       min1, mid1,
	       depth1 +1,maxdepth1,
	       p2, tree2, currentindex2,
	       min2, max2,
	       depth2,maxdepth2);
	    if (rval == true)
	       return(true);
	    return(minitree_overlap_polystruct_rec(
	       p1, tree1, child1(currentindex1),
	       mid1, max1,
	       depth1 +1,maxdepth1,
	       p2, tree2, currentindex2,
	       min2, max2,depth2,maxdepth2));
	 }
      }
      else // Enter the second node.
      {
	 if (depth2 == maxdepth2)
	 {
	    //
	    // Right leaf,left node:
	    //   For all segments on the right calculate distance
	    //   to the left node.
	    //
	    for(int i2=min2;i2<max2;++i2)
	    {
	       segment s2(p2.pnt(i2),p2.modpnt(i2+1));

	       if (minitree_overlap_segment_rec(
	          p1,tree1,currentindex1,min1,max1,depth1,maxdepth1,s2))
		     return(true);
	    }
	    return(false);
	 }
	 else
	 {
	    int mid2 = getmid(min2,max2);

	    //
	    // Right node, left anything:
	    //   For both children on the right, enter recursion.
	    //
	    bool rval = minitree_overlap_polystruct_rec(
	       p1, tree1, currentindex1,
	       min1, max1, depth1, maxdepth1,
	       p2, tree2, child0(currentindex2),
	       min2, mid2,
	       depth2 + 1,maxdepth2);
	    if (rval == true)
	       return(true);
	    return(minitree_overlap_polystruct_rec(
	       p1, tree1, currentindex1,
	       min1, max1, depth1, maxdepth1,
	       p2, tree2, child1(currentindex2),
	       mid2, max2,
	       depth2 + 1,maxdepth2));
	 }
      }
   }
}

bool overlap(
   const polygon& p1,
   const minitree& m1,
   const polygon& p2,
   const minitree& m2)
{
   bool rval = minitree_overlap_polystruct_rec(
      p1,
      &(m1.data[0]),
      0,
      0,
      p1.npoints(),
      1,
      m1.depth(),
      p2,
      &(m2.data[0]),
      0,
      0,
      p2.npoints(),
      1,
      m2.depth());

   //
   // If the boundaries overlap the polygons surely overlap
   //
   if (rval == true)
      return(true);

   //
   // If one of the two is completely inside
   // the other, the distance is 0 of course.
   // Somehow we must prevent the inside check.
   //
   if (inside(p1.modpnt(m1[0].right),p2,m2) || inside(p2.modpnt(m1[0].right),p1,m1))
      return(true);
   else
      return(false);
}

bool inside(
   const polygon& p1,
   const minitree& m1,
   const polygon& p2,
   const minitree& m2)
{
   bool rval = minitree_overlap_polystruct_rec(
      p1,
      &(m1.data[0]),
      0,
      0,
      p1.npoints(),
      1,
      m1.depth(),
      p2,
      &(m2.data[0]),
      0,
      0,
      p2.npoints(),
      1,
      m2.depth());

   //
   // If the boundaries overlap the polygons cannot be totally inside.
   //
   if (rval == true)
      return(false);

   //
   // If the boundaries do not intersect. p1 is inside p2 if one
   // of its points is inside.
   //
   return(inside(p1.modpnt(m1[0].right),p2,m2));
}

//------------------------------------------------------------------------
static void minitree_squared_distance_polystruct_rec(
   const polystruct& p1,
   const minitnode* tree1,
   const int currentindex1,
   const int min1,
   const int max1,
   const int depth1,
   const int maxdepth1,
   const polystruct& p2,
   const minitnode* tree2,
   const int currentindex2,
   const int min2,
   const int max2,
   const int depth2,
   const int maxdepth2,
   double &curdist)
{
   const minitnode& current1 = tree1[currentindex1];
   const minitnode& current2 = tree2[currentindex2];
   box bb1(
      p1.modpnt(current1.left).x,
      p1.modpnt(current1.top).y,
      p1.modpnt(current1.right).x,
      p1.modpnt(current1.bottom).y);
   box bb2(
      p2.modpnt(current2.left).x,
      p2.modpnt(current2.top).y,
      p2.modpnt(current2.right).x,
      p2.modpnt(current2.bottom).y);

   //
   // If there is no chance that we find a closer point in these nodes we stop.
   //
   if (squared_mindist(bb1,bb2) >= curdist)
      return;


   //
   // Now we have two candidate nodes. There are some cases based
   // on the types of the nodes.
   //

   
   if ((depth1 == maxdepth1) && (depth2 == maxdepth2)) // Two leaves.
   {
      //
      // Compare all segments of all leaves.
      //

      reduce_squared_distance(curdist,p1.modpnt(current1.right),p2.modpnt(current2.left));
      reduce_squared_distance(curdist,p1.modpnt(current1.left),p2.modpnt(current2.right));
      reduce_squared_distance(curdist,p1.modpnt(current1.top),p2.modpnt(current2.bottom));
      reduce_squared_distance(curdist,p1.modpnt(current1.bottom),p2.modpnt(current2.top));

      for(int i1=min1;i1<max1;++i1)
      {
	 segment s1(p1.pnt(i1),p1.modpnt(i1+1));

         for(int i2=min2;i2<max2;++i2)
	 {
	    reduce_squared_distance(curdist,s1,segment(p2.pnt(i2),p2.modpnt(i2+1)));
	    if (curdist == 0)
	       return;
	 }
      }
   }
   else
   {
      if (bb1.area() > bb2.area())  // Enter the first node.
      {
	 if (depth1 == maxdepth1)
	 {
	    //
	    // Left leaf, right node:
	    //    For all segments in the leaf calculate distance
	    //    to right node.
	    //
	    for(int i1=min1;i1<max1;++i1)
	    {
	       segment s1(p1.pnt(i1),p1.modpnt(i1+1));

	       minitree_squared_distance_segment_rec(
	          p2,tree2,currentindex2,min2,max2,depth2,maxdepth2,s1,curdist);
	       if (curdist == 0)
		  return;
	    }
	 }
	 else
	 {
	    //
	    // Left node, right anything:
	    //    For both children do recursion.
	    //
	    int mid1 = getmid(min1,max1);

	    minitree_squared_distance_polystruct_rec(
	       p1, tree1, child0(currentindex1),
	       min1, mid1,
	       depth1 +1,maxdepth1,
	       p2, tree2, currentindex2,
	       min2, max2,
	       depth2,maxdepth2,
	       curdist);
	    if (curdist == 0)
	       return;
	    minitree_squared_distance_polystruct_rec(
	       p1, tree1, child1(currentindex1),
	       mid1, max1,
	       depth1 +1,maxdepth1,
	       p2, tree2, currentindex2,
	       min2, max2,depth2,maxdepth2,
	       curdist);
	 }
      }
      else // Enter the second node.
      {
	 if (depth2 == maxdepth2)
	 {
	    //
	    // Right leaf,left node:
	    //   For all segments on the right calculate distance
	    //   to the left node.
	    //
	    for(int i2=min2;i2<max2;++i2)
	    {
	       segment s2(p2.pnt(i2),p2.modpnt(i2+1));

	       minitree_squared_distance_segment_rec(
	          p1,tree1,currentindex1,min1,max1,depth1,maxdepth1,s2,curdist);
	       if (curdist == 0)
		  return;
	    }
	 }
	 else
	 {
	    int mid2 = getmid(min2,max2);

	    //
	    // Right node, left anything:
	    //   For both children on the right, enter recursion.
	    //
	    minitree_squared_distance_polystruct_rec(
	       p1, tree1, currentindex1,
	       min1, max1, depth1, maxdepth1,
	       p2, tree2, child0(currentindex2),
	       min2, mid2,
	       depth2 + 1,maxdepth2,
	       curdist);
	    if (curdist == 0)
	       return;
	    minitree_squared_distance_polystruct_rec(
	       p1, tree1, currentindex1,
	       min1, max1, depth1, maxdepth1,
	       p2, tree2, child1(currentindex2),
	       mid2, max2,
	       depth2 + 1,maxdepth2,
	       curdist);
	 }
      }
   }
}

double squared_distance(
   const polygon& p1,
   const minitree& m1,
   const polygon& p2,
   const minitree& m2)
{
   double rval = probe_squared_distance_bbox(p1,m1,p2,m2);

   minitree_squared_distance_polystruct_rec(
      p1,
      &(m1.data[0]),
      0,
      0,
      p1.npoints(),
      1,
      m1.depth(),
      p2,
      &(m2.data[0]),
      0,
      0,
      p2.npoints(),
      1,
      m2.depth(),
      rval);

   //
   // If distance is 0 it can't get smaller.
   //
   if (rval == 0)
      return(rval);

   //
   // If one of the two is completely inside
   // the other, the distance is 0 of course.
   // Somehow we must prevent the inside check.
   //
   if (inside(p1.pnt(0),p2,m2) || inside(p2.pnt(0),p1,m1))
      rval = 0;
   return(rval);
}

double squared_distance(
   const polyline& p1,
   const minitree& m1,
   const polyline& p2,
   const minitree& m2)
{
   double rval = probe_squared_distance_bbox(p1,m1,p2,m2);

   minitree_squared_distance_polystruct_rec(
      p1,
      &(m1.data[0]),
      0,
      0,
      p1.npoints() -1,
      1,
      m1.depth(),
      p2,
      &(m2.data[0]),
      0,
      0,
      p2.npoints() -1,
      1,
      m2.depth(),
      rval);

   return(rval);
}

//------------------------------------------------------------------------
static void minitree_squared_distance_point_rec(
   const polygon& pgn,
   const minitnode* tree,
   const int currentindex,
   const int min,
   const int max,
   const int depth,
   const int maxdepth,
   const point& pnt,
   double &curdist)
{
   const minitnode& current = tree[currentindex];
   box bb(
      pgn.modpnt(current.left).x,
      pgn.modpnt(current.top).y,
      pgn.modpnt(current.right).x,
      pgn.modpnt(current.bottom).y);

   //
   // If there is a chance that we find a closer point in this node
   // we enter it.
   //
   if (squared_mindist(pnt,bb) < curdist)
   {
       if (depth == maxdepth)
       {
          //
	  // Check all segments in this node.
	  //
	  for(int i = min;i<max;++i)
	  {
	     double newdist = squared_distance(pnt,pgn.sgmt(i));

	    if (newdist < curdist)
	       curdist = newdist;
	    if (curdist == 0)
	       return;
	  }
       }
       else
       {
	  int mid = getmid(min,max);

          //
	  // Enter recursion.
	  //
	 minitree_squared_distance_point_rec(
	    pgn,
	    tree,
	    child0(currentindex),
	    min,
	    mid,
	    depth + 1,
	    maxdepth,
	    pnt,
	    curdist);

	 if (curdist != 0) // Distance can never be smaller than 0.
	 {
	    minitree_squared_distance_point_rec(
	       pgn,
	       tree,
	       child1(currentindex),
	       mid,
	       max,
	       depth + 1,
	       maxdepth,
	       pnt,
	       curdist);
         }
      }
   }
}

double squared_distance(
   const point& pnt,
   const polygon& pgn,
   const minitree& m)
{
   if(inside(pnt,pgn,m))
      return(0);
   
   //
   // Probe a startvalue for the distance function.
   //
   double current = probe_squared_distance(pgn,m,pnt);

   minitree_squared_distance_point_rec(
      pgn,
      &(m.data[0]),
      0,
      0,
      pgn.npoints(),
      1,
      m.depth(),
      pnt,
      current);

   return(current);
}

//
//------------------------------------------------------------------------
//

static bool OK_tree_rec(
   const minitree& m,
   const polygon& p,
   const minitnode* tree,
   const int currentindex,
   const int min,
   const int max,
   const int depth,
   const int maxdepth)
{
   const minitnode& current = tree[currentindex];

   if (depth == maxdepth)
   {
      //
      // Check whether extremes are OK.
      //
      if (
	 (current.left < min) || (current.left > max) ||
	 (current.top < min) || (current.top > max) ||
	 (current.right < min) || (current.right > max) ||
	 (current.bottom < min) || (current.bottom > max))
      {
	    GDKwarning("minitree leaf corrupt I\n");
      }

      //
      // Check the bounding box.
      //
      box bb(
         p.modpnt(current.left).x,p.modpnt(current.top).y,
         p.modpnt(current.right).x,p.modpnt(current.bottom).y);
      
      for(int i = min;i<max;++i)
      {
	 if (!inside(p.modpnt(i),bb))
	 {
	    GDKwarning("minitree leaf corrupt II\n");
	    return(false);
	 }
      }
      return(true);
   }
   else
   {
      int mid = getmid(min,max);

      //
      // Check bounding BOX
      //
      if (!OK_tree_rec(m,p,tree,child0(currentindex),min,mid,depth +1,maxdepth))
	 return(false);
      if (!OK_tree_rec(m,p,tree,child1(currentindex),mid,max,depth +1,maxdepth))
	 return(false);

      return(true);
   }
}

//
// Perform Consistence Check on Minitree and Associated Polygon.
//
bool OK(const polygon& p,const minitree& m)
{
   return(OK_tree_rec(m,p,&m.data[0],0,0,p.npoints(),1,m.depth()));
}

//------------------------------------------------------------------------
static void build_tree_rec(
   const polystruct& p,
   minitnode* tree,
   const int currentindex,
   const int min,
   const int max,
   const int depth,
   const int maxdepth)
{
   minitnode& current = tree[currentindex];

   // GDKwarning("cindex = %d : min = %d,max = %d,depth = %d, md = %d\n",currentindex,min,max,depth,maxdepth);

   if (depth == maxdepth)
   {
      //
      // Generate bounding box for leaf. This is the bounding box
      // of all points between min and max.
      //
      int left,top,right,bottom;
      p.rangebbox(min,max,left,top,right,bottom);

      current.left = left;
      current.top = top;
      current.right = right;
      current.bottom = bottom;
   }
   else // We create a node.
   {
      //
      // Calculate split point.
      //
      int split = getmid(min,max);

      build_tree_rec(p,tree,child0(currentindex),min,split,depth+1,maxdepth);
      build_tree_rec(p,tree,child1(currentindex),split,max,depth+1,maxdepth);

      //
      // Calculate bounding box for node. This is the bounding
      // box of both children.
      //
      minitnode& kid0 = tree[child0(currentindex)];
      minitnode& kid1 = tree[child1(currentindex)];

      current.left = (p.modpnt(kid0.left).x < p.modpnt(kid1.left).x)?kid0.left:kid1.left;
      current.top = (p.modpnt(kid0.top).y > p.modpnt(kid1.top).y)?kid0.top:kid1.top;
      current.right = (p.modpnt(kid0.right).x > p.modpnt(kid1.right).x)?kid0.right:kid1.right;
      current.bottom = (p.modpnt(kid0.bottom).y < p.modpnt(kid1.bottom).y)?kid0.bottom:kid1.bottom;
   }
}

//
// Create a minitree for the given polygon. 
//
minitree* create_minitree(const polygon& p,int maxleafsize)
{
   //
   // Calculate optimal depth for the minitree.
   //
   int depth = 1;
   int nleaves = 1;
   double leafsize = p.npoints();

   while(leafsize > maxleafsize)
   {
      depth++;
      nleaves += nleaves;

      leafsize = p.npoints() / nleaves;
   }

   //GDKwarning("ml = %d, depth = %d, np = %d\n",
   //  maxleafsize,depth,p.npoints());

   //
   // Allocate memomy for the minitree.
   //
   minitree* rval = minitree::create(depth);

   //
   // Build minitree.
   //
   build_tree_rec(
      p,
      &(rval->data[0]),
      0,
      0,
      p.npoints(),
      1,
      depth);

   return(rval);
}

//
// Create a minitree for the given polyline. 
//
minitree* create_minitree(const polyline& p,int maxleafsize)
{
   int depth = 1;
   int nleaves = 1;
   double leafsize = p.npoints() - 1;

   while(leafsize > maxleafsize)
   {
      depth++;
      nleaves += nleaves;

      leafsize = (p.npoints() -1) / nleaves;
   }

   minitree* rval = minitree::create(depth);

   //
   // Build minitree.
   //
   build_tree_rec(
      p,
      &(rval->data[0]),
      0,
      0,
      p.npoints() -1,
      1,
      depth);

   return(rval);
}

polygon* addminitree(const polygon& p,int maxleafsize)
{
   minitree* m = create_minitree(p,maxleafsize);

   polygon* rval = p.addminitree(*m);

   delete m;
   return(rval);
}

polygon* removeminitree(const polygon& p)
{
   polygon* rval = (polygon *)p.removeaccelerator();
   return(rval);
}

polyline* removeminitree(const polyline& p)
{
   polyline* rval = (polyline *)p.removeaccelerator();
   return(rval);
}


polyline* addminitree(const polyline& p,int maxleafsize)
{
   minitree* m = create_minitree(p,maxleafsize);

   polyline* rval = p.addminitree(*m);

   delete m;
   return(rval);
}

cpolygon* addminitree(const cpolygon& p,int n)
{
   size_t expectedbytes = p.nbytes() + (p.nbytes() / 10);
   cpolygon* rval = cpolygon::create(p.nholes(),expectedbytes);

   for (int pol = -1; pol < p.nholes();++pol)
   {
      const polygon& current = (pol==-1)?(p.boundary()):(p.hole(pol));
      polygon* mt = addminitree(current,n);

      rval = rval->addhole(*mt);
      delete mt;
   }
   return(rval);
}

//
//------------------------------------------------------------------------
//
static void point_in_polygon_rec(
   const point& pnt,			// IN: The point we want to check
   const polygon& pgn,			// IN: The polygon.
   const minitnode* const tree,		// IN: Minitree belonging to pgn.
   const int currentindex,		// IN: Current node we are visiting.
   const int min,			// IN: Point is this node range 
   const int max,			//       between min and max.
   const int depth,
   const int maxdepth,
   int &count)				// OUT: Intersection count.
{
   //
   // Calculate bounding box of current node.
   //
   const minitnode& current = tree[currentindex];
   box bb(
      pgn.modpnt(current.left).x,
      pgn.modpnt(current.top).y,
      pgn.modpnt(current.right).x,
      pgn.modpnt(current.bottom).y);
   
   //
   // If this node overlaps with the line going to the
   // right from p then we have to enter the node.
   //
   if ((bb.right >= pnt.x) && (bb.top >= pnt.y) && (bb.bottom < pnt.y))
   {
      if (depth == maxdepth) // this is a leaf,
      {
         //
	 // Check all segments in this node.
	 //
	 const point* prevpoint = &pgn.modpnt(max);
	 for(int i = max-1;i>=min;--i)
	 {
	    segment s(pgn.pnt(i),*prevpoint);
	    box b(s.bbox());

	    if ((b.right >= pnt.x) && (b.top >= pnt.y) && (b.bottom < pnt.y))
	    {
	       if (b.left >= pnt.x)
	          ++count;
	       else
	       {
	          if (s.give_x_if_y_is(pnt.y) >= pnt.x)
		    ++count;
	       }
	    }
	    prevpoint = &pgn.pnt(i);
	 }
      }
      else
      {
	 int mid = getmid(min,max);

	 //
	 // Enter recursion.
	 //
	 point_in_polygon_rec(
	    pnt,
	    pgn,
	    tree,
	    child0(currentindex),
	    min,
	    mid,
	    depth + 1,
	    maxdepth,
	    count);
	 point_in_polygon_rec(
	    pnt,
	    pgn,
	    tree,
	    child1(currentindex),
	    mid,
	    max,
	    depth + 1,
	    maxdepth,
	    count);
      }
   }
}

//
// Returns whether the given point 'pnt' is inside the polygon 'pgn'.
// The minitree m is used to speed up this process.
//
// How does it work:
// The function checks how many times the polygon intersects with a
// line drawn from 'ptn' to the right. If this is an odd number, the
// point is inside the polygon, otherwise the point is outside the
// polygon.
//
// The minitree is used to weed out parts of the polygon which will 
// definitely not overlap with the line from 'pgn'.
//
bool inside(const point& pnt,const polygon& pgn,const minitree& m)
{
   int count = 0;

   point_in_polygon_rec(
      pnt,
      pgn,
      &m.data[0],
      0,
      0,
      pgn.npoints(),
      1,
      m.depth(),
      count);
   
   return(count%2 == 1);
}

//------------------------------------------------------------------------

//
// Convert a minitree from big to little endian, or vice versa.
//
void minitnode::convert_host_to_net()
{
   convert_endianism(left);
   convert_endianism(top);
   convert_endianism(right);
   convert_endianism(bottom);
}

void minitnode::convert_net_to_host()
{
   convert_endianism(left);
   convert_endianism(top);
   convert_endianism(right);
   convert_endianism(bottom);
}

void minitree::convert_host_to_net()
{
   for(int i=0;i<dimension();++i)
      data[i].convert_host_to_net();

   convert_endianism(nbytes_v);
   convert_endianism(depth_v);
}

void minitree::convert_net_to_host()
{
   convert_endianism(nbytes_v);
   convert_endianism(depth_v);

   for(int i=0;i<dimension();++i)
      data[i].convert_net_to_host();
}

//------------------------------------------------------------------------

//
// Return a copy of the integrated minitree in this polygon. If there
// is no minitree. return NULL.
//
minitree* extract(polystruct& p)
{
   if (p.accelerator() == 0)
      return(NULL);
   minitree* orig = (minitree *)(p.acceleratorptr());
   return(orig->copy());
}
//
//=================================================
// Check whether a polyline contains a given point.
//=================================================
//
static bool minitree_contains_rec(
   const polyline& pln,		// The polyline
   const minitnode* tree,	// The arry of nodes which is the minitree.
   const int currentindex,	// The index of the current node in the tree.
   const int min,		// The minimum index of points under this node.
   const int max, 		// The maximum index of points under this node.
   const int depth,		// The current depth in the minitree.
   const int maxdepth,		// The maximum depth in the minitree.
   const point& pnt)
{
   const minitnode& current = tree[currentindex];
   box bb(
      pln.pnt(current.left).x,
      pln.pnt(current.top).y,
      pln.pnt(current.right).x,
      pln.pnt(current.bottom).y);

   if (!overlap(bb,pnt))
      return(false);

   if (depth == maxdepth)
   {
      //
      // This is a leaf. Test all entries.
      //
      for(int i=min;i<max;++i)
      {
	 if(baserelate(pln.sgmt(i),pnt) != -1)
	    return(true);
      }
      return(false);
   }
   else
   {
      //
      // This is a node. Enter recursion.
      //
      int mid = getmid(min,max);
      bool rval = minitree_contains_rec(
	 pln,
	 tree,
	 child0(currentindex),
	 min,
	 mid,
	 depth + 1,
	 maxdepth,
	 pnt);
      if (rval == true)
         return(true);
      else
      {
	 return(minitree_contains_rec(
	    pln,
	    tree,
	    child1(currentindex),
	    mid,
	    max,
	    depth + 1,
	    maxdepth,
	    pnt));
      }
   }
}

bool contains(
   const LineString& l,
   const minitree& m,
   const Point& p)
{
   return(minitree_contains_rec(
      l,
      &(m.data[0]),
      0,
      0,
      l.npoints() - 1,
      1,
      m.depth(),
      p));
}

//
//===============================================================
// Calculate the intersection between two interiors of polylines.
//===============================================================
//

static void minitree_calc_0_rec(
   const polyline& p1,		// The polyline
   const minitnode* tree1,	// The arry of nodes which is the minitree.
   const int currentindex1,	// The index of the current node in the tree.
   const int min1,		// The minimum index of points under this node.
   const int max1, 		// The maximum index of points under this node.
   const int depth1,		// The current depth in the minitree.
   const int maxdepth1,		// The maximum depth in the minitree.
   const multipoint& bnd1,
   const polyline& p2,
   const minitnode* tree2,
   const int currentindex2,
   const int min2,
   const int max2,
   const int depth2,
   const int maxdepth2,
   const multipoint& bnd2,
   relmatrix& rel)
{
   const minitnode& current1 = tree1[currentindex1];
   const minitnode& current2 = tree2[currentindex2];
   box bb1(
      p1.pnt(current1.left).x,
      p1.pnt(current1.top).y,
      p1.pnt(current1.right).x,
      p1.pnt(current1.bottom).y);
   box bb2(
      p2.pnt(current2.left).x,
      p2.pnt(current2.top).y,
      p2.pnt(current2.right).x,
      p2.pnt(current2.bottom).y);

   //
   // If the bounding boxes do not overlap we can return.
   //
   if (!overlap(bb1,bb2))
      return;

   if ((depth1 == maxdepth1) && (depth2 == maxdepth2))
   {
      // GDKwarning("Two leaves: [%d,%d] and [%d,%d]\n",min1,max1,min2,max2);
      //
      // We have two leaves an try all combinations.
      //
      for(int i1=min1;i1<max1;++i1)
      {
	 segment s1(p1.pnt(i1),p1.pnt(i1+1));

         for(int i2=min2;i2<max2;++i2)
	 {
	    segment s2(p2.pnt(i2),p2.pnt(i2+1));

	    segment isection;
	    int dim = baserelate(s1,s2,isection);
	    // GDKwarning("s(%d,%d) s(%d,%d) have dim = %d\n",i1,i1+1,i2,i2+1,dim);
	    // GDKwarning("isection = (%f,%f) s(%f,%f)\n",isection.source.x,isection.source.y,isection.dest.x,isection.dest.y);

	    if (dim == 1)
	    {
	       //
	       // The intersection of the interiors has at least dimension 1.
	       // if this results in a matched pattern we return at once.
	       //
	       if (rel.increase_mindimension(relmatrix::INTERIOR_INTERIOR,1))
	          return;
	    }
	    else if (dim == 0)
	    {
	       //
	       // We have an intersection point. Now if this is not part of
	       // a boundary the dimension of the interior intersection is at
	       // least 0.
	       //
	       if (!bnd1.contains(isection.source) && !bnd2.contains(isection.source))
	       {
		  //
		  // If this knowledge is enough to match the pattern we return.
		  //
		  if (rel.increase_mindimension(relmatrix::INTERIOR_INTERIOR,0))
		     return;
	       }
	    }
	 }
      }
   }
   else
   {
      //
      // Left or right (or both) there is a noded. We decide whether we
      // go left or right.
      //
      bool goleft;
      if (depth1 == maxdepth1)
      {
         goleft = false;
      }
      else
      {
         if (depth2 == maxdepth2)
	 {
	    goleft = true;
	 }
	 else
	 {
	    if (bb1.area() > bb2.area())
	       goleft = true;
	    else
	       goleft = false;
	 }
      }


      if (goleft)  // Enter the left node.
      {
	 //
	 // Left node, right anything:
	 //    For both left children do recursion.
	 //
	 int mid1 = getmid(min1,max1);

	 minitree_calc_0_rec(
	    p1, tree1, child0(currentindex1),
	    min1, mid1,
	    depth1 +1,maxdepth1,bnd1,
	    p2, tree2, currentindex2,
	    min2, max2,
	    depth2,maxdepth2,bnd2,rel);
	 
	 if (rel.resolved(relmatrix::INTERIOR_INTERIOR))
	    return;

	 minitree_calc_0_rec(
	    p1, tree1, child1(currentindex1),
	    mid1, max1,
	    depth1 +1,maxdepth1,bnd1,
	    p2, tree2, currentindex2,
	    min2, max2,depth2,maxdepth2,bnd2,rel);
      }
      else 
      {
         //
	 // Enter the right node.
	 //
	 int mid2 = getmid(min2,max2);

	 //
	 // Right node, left anything:
	 //   For both children on the right, enter recursion.
	 //
	 minitree_calc_0_rec(
	    p1, tree1, currentindex1,
	    min1, max1, depth1, maxdepth1,bnd1,
	    p2, tree2, child0(currentindex2),
	    min2, mid2,
	    depth2 + 1,maxdepth2,bnd2,rel);

	 if (rel.resolved(relmatrix::INTERIOR_INTERIOR))
	    return;

	 minitree_calc_0_rec(
	    p1, tree1, currentindex1,
	    min1, max1, depth1, maxdepth1,bnd1,
	    p2, tree2, child1(currentindex2),
	    mid2, max2,
	    depth2 + 1,maxdepth2,bnd2,rel);
      }
   }
}

bool calc_0(
   const LineString& l1,
   const minitree& m1,
   const MultiPoint& bnd1,
   const LineString& l2,
   const minitree& m2,
   const MultiPoint& bnd2,
   relmatrix& rel)

{
   minitree_calc_0_rec(
      l1,
      &(m1.data[0]),
      0,
      0,
      l1.npoints() - 1,
      1,
      m1.depth(),
      bnd1,

      l2,
      &(m2.data[0]),
      0,
      0,
      l2.npoints() - 1,
      1,
      m2.depth(),
      bnd2,
      
      rel);

   //
   // We have checked all intersections. Now we can set the maxdimension to
   // mindimension.
   //
   return (rel.setdimension(relmatrix::INTERIOR_INTERIOR,rel.dim_min[0]));
}
