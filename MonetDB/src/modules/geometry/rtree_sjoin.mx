@f rtree_sjoin
@A C.W. Quak
@h
#ifndef __RTREE_SJOIN_H__
#define __RTREE_SJOIN_H__

#endif /* __RTREE_SJOIN_H__ */
@C
#include "gis.h"
#include "opengis.h"
#include "gisbulk.proto.h"
#include "rtree.h"
#include "rtree_box.h"

//
// This macro generates a join operator on an rtree.
// @1
//   name of function.
// @2:
//    bool @1(const box& left,const box& right) returns true when this pair
//    of boxes should be part of the result.
// @3:
//   bool @2(const box& left,const box& right) returns true when there is
//   no chance that any subboxes of left and right will ever be part of the
//   result.
//

static inline bool right_inside_left(const box& left,const box& right)
{
   return(left.surrounds(right));
}


@:joinop(disjoint,!overlap,overlap,box,box)@
@:joinop(inside,right_inside_left,!overlap,box,box)@
@:joinop(overlap,overlap,!overlap,box,box)@
@:joinop(overlap,overlap,!overlap,box,point)@

@= joinop
void local_join_@1_@4_@5(
   BAT* batleft,
   BAT* batright,
   Heap* heapleft,
   Heap* heapright,
   int nodeleft,
   int noderight,
   BAT* result)
{
   RTREEnode* leftptr = RTREEindex(heapleft,nodeleft);
   RTREEnode* rightptr = RTREEindex(heapright,noderight);

   //
   // If bounding boxes do not overlap the join is empty
   //
   if (@3(leftptr->bbox,rightptr->bbox))
      return;

   //
   // If both are leaves we are at the deepest level and must compare al pairs.
   //
   if ((leftptr->isleaf()) && (rightptr->isleaf()))
   {
      for(int i=0;i<leftptr->number;++i)
      {
	 @4* leftbox = (@4 *)BUNtail(batleft,BUNptr(batleft,leftptr->entries[i]));

	 for(int j=0;j<rightptr->number;++j)
	 {
	    @5* rightbox = (@5 *)BUNhead(batright,BUNptr(batright,rightptr->entries[j]));

	    if (@2(*leftbox,*rightbox))
	    {
	       BUNins(result,
		  BUNhead(batleft,BUNptr(batleft,leftptr->entries[i])),
		  BUNtail(batright,BUNptr(batright,rightptr->entries[j])));
	    }
	 }
      }
   }
   else
   {
      /*
      // We must decide which node we enter. If we can choose (when both node
      // are intermediate nodes) we choose the largest node.
      */
      int deepen;
      if (leftptr->isleaf())
	 deepen = RIGHTBOX;
      else if (rightptr->isleaf())
	 deepen = LEFTBOX;
      else
      {
	 if (leftptr->bbox.area() > rightptr->bbox.area())
	    deepen = LEFTBOX;
	 else
	    deepen = RIGHTBOX;
      }

      if (deepen == LEFTBOX)
      {

	 for(int i=0;i<leftptr->number;++i)
	 {
	    local_join_@1_@4_@5(
	       batleft,batright, heapleft,heapright,
	       leftptr->entries[i],noderight,
	       result);
	 }
      }
      else // we go into the right node
      {
	 for(int j=0;j<rightptr->number;++j)
	 {
	    local_join_@1_@4_@5(
	       batleft,batright, heapleft,heapright,
	       nodeleft,rightptr->entries[j],
	       result);
	 }
      }
   }
}

BAT* join_@1_@4_@5(BAT* left,BAT* right)
{
   BAT* result;
   Heap* heapleft = &(left->taccelerator);
   Heap* heapright = &(right->haccelerator);
   int leftrootindex = RTREErootindex(heapleft);
   int rightrootindex = RTREErootindex(heapright);


   /*
   // We create a BAT for the joined pairs.
   // res_tuples should be set to the expected number of BUNs in the result.
   */
   {
      int res_tuples = 1000;
      result = BATnew(BAThtype(left),BATttype(right),res_tuples);
   }

   if ((leftrootindex != 0) && (rightrootindex != 0))
   {
      local_join_@1_@4_@5(
	 left, right,
	 heapleft, heapright,
	 leftrootindex, rightrootindex,
	 result);
   }
   return(result);
}
@
