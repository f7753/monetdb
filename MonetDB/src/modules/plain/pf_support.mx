@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@' 
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@' 
@' The Original Code is the Monet Database System.
@' 
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2004 CWI.
@' All Rights Reserved.
@' 
@' Contributor(s):
@' 		Martin Kersten <Martin.Kersten@cwi.nl>
@' 		Peter Boncz <Peter.Boncz@cwi.nl>
@' 		Niels Nes <Niels.Nes@cwi.nl>
@' 		Stefan Manegold  <Stefan.Manegold@cwi.nl>

@f pf_support
@a Stefan Manegold
@v 1.0
@t MIL primitives to support the XQuery front-end "Pathfinder"

@* Introduction
This modules provides new MIL primitives to support the XQuery
implementation on to of MonetDB within the "Pathfinder" project.
@
@* Module Definition 
@m
.MODULE pf_support;

.COMMAND mark_grp( BAT[any::1,oid] b , BAT[oid,oid] g) : 
				BAT[any::1,OID] = CMDmark_grp; 
"\"grouped mark\": Produces a new BAT with per group a locally unique dense
 ascending sequense of OIDs in the tail. The tail of the first BAT (b)
 identifies the group that each BUN of b belongs to. The second BAT (g)
 represents the group extend, i.e., the head is the unique list of group IDs
 from b's tail. The tail of g gives for each group the base value for the new
 OID sequence."

.COMMAND merged_union( BAT[void,any::1] left, BAT[void,any::1] right, ..BAT[void,any].. ) :
			BAT[void,BAT] = CMDmerged_union;
"PARAMETERS:
Even number of BAT[void,any] with pairs of equal tail type;
all odd BATs must be head-aligned and all even BATs must be head-aligned;
first two BATs must be sorted on tail values.
DESCRIPITON:
Merges pairs of bats according to the order as defined by the first pair's tails."
@(
"Returns the union of two *tail-sorted* BATs. All BUNs of both BATs appear
 in the result, i.e., duplicates are not eliminated. As opposed to standard
 "union", the sortedness on the tail column is maintained in the result and
 all BUNs in the result appear in the same order as in their respective
 input."
@)

.END pf_support;

@* Module Implementation
@h
#ifndef PF_SUPPORT_H
#define PF_SUPPORT_H

#include "pf_support.proto.h"

#endif
@c
#include "pf_support.h"
#include <gdk_scanselect.h> /* for type-specific HT_bunfastins_nocheck_noinc(), until they're moved to gdk.mx */

@= mark_grp_loop3
{	BUN p, q;
	int xx;
	BATloopFast(b, p, q, xx) {
		oid n = oid_nil;
		BUN w;
		ptr v = BUNt@2(b, p);

		BUNfnd@3(w, gc, v);
		if (w) {
			oid *m = (oid*) BUNtloc(gc, w);
			if (*m != oid_nil) {
				n = (*m)++;
			}
		}
		if (n == oid_nil) {
			tsdk = 0;
		}
		bunfastins_nocheck(bn, r, BUNh@1(b, p), &n, yy); 
		r += yy; 
	}
}
@= mark_grp_loop2
	if (gc->htype==TYPE_void) {
		@:mark_grp_loop3(@1,@2,VOID)@
	} else {
		@:mark_grp_loop3(@1,@2,OID)@
	}
@= mark_grp_loop1
	if (b->ttype==TYPE_void) {
		@:mark_grp_loop2(@1,var)@
	} else {
		@:mark_grp_loop2(@1,loc)@
	}
@= mark_grp_loop
{	BUN r = BUNfirst(bn);
	int yy = BUNsize(bn);
	if (b->hvarsized) {
		@:mark_grp_loop1(var)@
	} else {
		@:mark_grp_loop1(loc)@
	}
}

@c
static BAT *BATmark_grp(BAT *b, BAT *g) {
        BAT *bn, *gc;
	int tsdk;
 
        BATcheck(b, "BATmark_grp");
        BATcheck(g, "BATmark_grp");
	ERRORcheck((b->ttype!=TYPE_void) && (b->ttype!=TYPE_oid),
	           "BATmark_grp: tail of BAT b must be oid.\n");
	ERRORcheck((g->htype!=TYPE_void) && (g->htype!=TYPE_oid),
	           "ERRORcheck: head of BAT g must be oid.\n");
	ERRORcheck((g->ttype!=TYPE_oid),
	           "BATmark_grp: tail of BAT g must be oid.\n");

	tsdk = ((BATcount(g) == 1) || (BATcount(b) == 0));
	gc = batcopy(g, g->htype, g->ttype, TRUE);
	if (gc == NULL) return NULL;
	bn = BATnew(b->htype, TYPE_oid, BATcount(b));
	if (bn == NULL) {
		BBPreclaim(gc);
		return NULL;
	}

	@:mark_grp_loop@

	ALIGNsetH(bn,b);
	bn->hsorted = BAThordered(b);
	bn->hdense = BAThdense(b);
	BATkey(bn, (b->hkey!=0));
	bn->tsorted = (tsdk?GDK_SORTED:0);
	bn->tdense = tsdk;
	BATkey(BATmirror(bn), tsdk);

	BBPreclaim(gc);
        return bn;
bunins_failed:
	BBPreclaim(gc);
	BBPreclaim(bn);
	return NULL;
}

int CMDmark_grp(BAT** res, BAT *b, BAT *g){
	return (*res=BATmark_grp(b, g))?GDK_SUCCEED:GDK_FAIL;
}

int CMDmerged_union(BAT** res, BAT *L, BAT *R, ...){
	BAT *b[MAXPARAMS], *bn[MAXPARAMS>>1], *BN;
	BUN cur[MAXPARAMS], lst[MAXPARAMS], dst[MAXPARAMS>>1], DST;
	int bs[MAXPARAMS], bns[MAXPARAMS>>1], BS;
	int nbats = 2, npairs = 1, i, j, k, any;
	chr *w = NULL;
	size_t sze = 0, h = 0;
	va_list ap;
	
	*res = NULL;

	/* check arguments */

	BATcheck(L, "CMDmerged_union");
	BATcheck(R, "CMDmerged_union");
	ERRORcheck(!(BATtordered(L)&1), "merged_union: tail of first BAT must be sorted.\n");
	ERRORcheck(!(BATtordered(R)&1), "merged_union: tail of second BAT must be sorted.\n");

	b[0] = L;
	b[1] = R;
	va_start(ap,R);
	while((b[nbats] = va_arg(ap, BAT*)) != NULL) {
		nbats++;
	}
	va_end(ap);
	
	if (nbats&1) {
		GDKerror("merged_union: uneven number of BATs: %d.\n", nbats);
		return GDK_FAIL;
	}
	npairs = nbats>>1;

	for (i=0; i<nbats; i+=2) {
		j = i+1;
		if (b[i]->ttype != b[j]->ttype) {
			GDKerror("merged_union: BATs %d & %d must have the same tail types.\n", i, j);
			return GDK_FAIL;
		}
		if (b[i]->hseqbase != b[0]->hseqbase) {
			GDKerror("merged_union: BAT %d must have the same hseqbase as BAT 0.\n", i);
			return GDK_FAIL;
		}
		if (b[j]->hseqbase != b[1]->hseqbase) {
			GDKerror("merged_union: BAT %d must have the same hseqbase as BAT 1.\n", j);
			return GDK_FAIL;
		}
		if (BATcount(b[i]) != BATcount(b[0])) {
			GDKerror("merged_union: BAT %d must have the same size as BAT 0.\n", i);
			return GDK_FAIL;
		}
		if (BATcount(b[j]) != BATcount(b[1])) {
			GDKerror("merged_union: BAT %d must have the same size as BAT 1.\n", j);
			return GDK_FAIL;
		}
	}

	/* create result BATs */

	sze = BATcount(b[0]) + BATcount(b[1]);
	BN = BATnew(TYPE_void, TYPE_bat, npairs);
	if (BN == NULL) {
		GDKerror("merged_union: BATnew(TYPE_void, TYPE_bat, %d) failed.\n", npairs);
		return GDK_FAIL;
	}
	for (k=0; k<npairs; k++) {
		i = k<<1;
		bn[k] = BATnew(TYPE_void, (b[i]->ttype!=TYPE_void)?b[i]->ttype:TYPE_oid, sze);
		if (bn[k] == NULL) {
			GDKerror("merged_union: BATnew(TYPE_void, %s, " SZFMT ") failed.\n", (b[i]->ttype!=TYPE_void)?"TYPE_void":"TYPE_oid", sze);
			while (k>0) {
				BBPreclaim(bn[--k]);
			}
			BBPreclaim(BN);
			return GDK_FAIL;
		}
	}
	if (sze > 0) {
		w = (chr*)GDKmalloc(sze);
		if (w == NULL) {
			GDKerror("merged_union: GDKmalloc(" SZFMT ") failed.\n", sze);
			goto bunins_failed;
		}
	}

	/* do the merged_union */

	for (k=0; k<npairs; k++) {
		bns[k] = BUNsize(bn[k]);
		dst[k] = BUNlast(bn[k]);
	}
	for (i=0; i<nbats; i++) {
		bs[i] = BUNsize(b[i]);
		cur[i] = BUNfirst(b[i]);
		lst[i] = BUNlast(b[i]);
	}
@= merged_union_0
	/* copy tails from BAT @3 to the results; 
	   for each BUN, remember in w, whether it came from BAT 0 or BAT 1 */
	while ((cur[@3] < lst[@3]) && (@4)) {
		void@1_bunfastins_nocheck_noinc(bn[0],dst[0],0,BUN@2(b[@3],cur[@3]));
		cur[@3] += bs[@3];
		dst[0] += bns[0];
		w[h++] = (chr)@3;
	}
@= merged_union_1
	/* merge-union the first two BATs; regard and preserve tail-order */
	h = 0;
	while ((cur[0] < lst[0]) && (cur[1] < lst[1])) {
		@:merged_union_0(@1,@2,0,@3_LE(BUN@2(b[0],cur[0]), BUN@2(b[1],cur[1]), @1))@
		if (cur[0] < lst[0]) {
			@:merged_union_0(@1,@2,1,@3_GT(BUN@2(b[0],cur[0]), BUN@2(b[1],cur[1]), @1))@
		}
	}
	/* get remaining BUNs */
	@:merged_union_0(@1,@2,0,TRUE)@
	@:merged_union_0(@1,@2,1,TRUE)@
	break;
@= merged_union_2
	/* merge-union each of the remaining BAT-pairs; 
	   w tell us, from which BAT we need to get the next BUN */
	for (h=0; h<sze; h++) {
		j = i + (int)w[h];
		void@1_bunfastins_nocheck_noinc(bn[k],dst[k],0,BUN@2(b[j],cur[j]));
		cur[j] += bs[j];
		dst[k] += bns[k];
	}
	break;
@c
	/* merge-union the first two BATs */
	any = b[0]->ttype;
	switch(ATOMstorage(b[0]->ttype)) {
	case TYPE_chr:	@:merged_union_1(chr,tloc,simple)@
	case TYPE_sht:	@:merged_union_1(sht,tloc,simple)@
	case TYPE_int:	@:merged_union_1(int,tloc,simple)@
	case TYPE_flt:	@:merged_union_1(flt,tloc,simple)@
	case TYPE_lng:	@:merged_union_1(lng,tloc,simple)@
	case TYPE_dbl:	@:merged_union_1(dbl,tloc,simple)@
	default:	@:merged_union_1(any,tail,atom)@
	}
	/* merge-union each of the remaining BAT-pairs */
	for (k=1; k<npairs; k++) {
		i = (k<<1);
		any = b[i]->ttype;
		switch(ATOMstorage(b[i]->ttype)) {
		case TYPE_chr:	@:merged_union_2(chr,tloc)@
		case TYPE_sht:	@:merged_union_2(sht,tloc)@
		case TYPE_int:	@:merged_union_2(int,tloc)@
		case TYPE_flt:	@:merged_union_2(flt,tloc)@
		case TYPE_lng:	@:merged_union_2(lng,tloc)@
		case TYPE_dbl:	@:merged_union_2(dbl,tloc)@
		default:	@:merged_union_2(any,tail)@
		}
	}

	/* set BAT properties */

	for (k=0; k<npairs; k++) {
		BATseqbase(bn[k], (oid)0);
		bn[k]->batBuns->free = dst[k] - bn[k]->batBuns->base;
		if (!bn[k]->batDirty) bn[k]->batDirty = TRUE;
		BATkey(bn[k],TRUE);
		BATkey(BATmirror(bn[k]),FALSE);
		bn[k]->hsorted = GDK_SORTED;
		bn[k]->tsorted = FALSE;
		bn[k]->hdense = TRUE;
		bn[k]->tdense = FALSE;
	}

	/* insert bn[] BATs in BN BAT */

	DST = BUNlast(BN);
	BS = BUNsize(BN);
	BATseqbase(BN, (oid)0);
	for (k=0; k<npairs; k++) {
		voidany_bunfastins_nocheck_noinc(BN,DST,0,&bn[k]->batCacheid);
		DST += BS;
	}
	BN->batBuns->free = DST - BN->batBuns->base;
	if (!BN->batDirty) BN->batDirty = TRUE;
	BATkey(BN,TRUE);
	BATkey(BATmirror(BN),TRUE);
	BN->hsorted = GDK_SORTED;
	BN->tsorted = FALSE;
	BN->hdense = TRUE;
	BN->tdense = FALSE;

	*res = BN;

	GDKfree(w);

	return GDK_SUCCEED;
bunins_failed:
	BBPreclaim(BN);
	for (k=0; k<npairs; k++) {
		BBPreclaim(bn[k]);
	}
	return GDK_FAIL;
}
