@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@' 
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@' 
@' The Original Code is the Monet Database System.
@' 
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2003 CWI.
@' All Rights Reserved.
@' 
@' Contributor(s):
@' 		Martin Kersten <Martin.Kersten@cwi.nl>
@' 		Peter Boncz <Peter.Boncz@cwi.nl>
@' 		Niels Nes <Niels.Nes@cwi.nl>
@' 		Stefan Manegold  <Stefan.Manegold@cwi.nl>

@f aggr
@a P. Boncz, S. Manegold 
@t Aggregates Module
@v 1.0

This module contains some efficient aggregate functions that compute their 
result in one scan, rather than in the iterative manner of the generic 
MIL aggr_ implementations.

The implementation code is derived from the already existing tpcd module and some
test scripts were added.
@m
.MODULE aggr;

.USE uchr;

.COMMAND {sum_uchr}(BAT[oid,uchr] b, BAT[oid,any] e) : BAT[oid,uchr] = CMDaggr_sum_uchr_uchr; 
	"grouped tail sum"
.COMMAND {sum_sht}(BAT[oid,uchr] b, BAT[oid,any] e) : BAT[oid,sht] = CMDaggr_sum_uchr_sht; 
	"grouped tail sum"
.COMMAND {sum_sht}(BAT[oid,sht] b, BAT[oid,any] e) : BAT[oid,sht] = CMDaggr_sum_sht_sht; 
	"grouped tail sum"
.COMMAND {sum_int}(BAT[oid,uchr] b, BAT[oid,any] e) : BAT[oid,int] = CMDaggr_sum_uchr_sht; 
	"grouped tail sum"
.COMMAND {sum_int}(BAT[oid,sht] b, BAT[oid,any] e) : BAT[oid,int] = CMDaggr_sum_sht_int; 
	"grouped tail sum"
.COMMAND {sum_int}(BAT[oid,int] b, BAT[oid,any] e) : BAT[oid,int] = CMDaggr_sum_int_int; 
	"grouped tail sum"
.COMMAND {sum_lng}(BAT[oid,int] b, BAT[oid,any] e) : BAT[oid,lng] = CMDaggr_sum_int_lng; 
	"grouped tail sum"
.COMMAND {sum_lng}(BAT[oid,lng] b, BAT[oid,any] e) : BAT[oid,lng] = CMDaggr_sum_lng_lng; 
	"grouped tail sum"
.COMMAND {sum_flt}(BAT[oid,flt] b, BAT[oid,any] e) : BAT[oid,flt] = CMDaggr_sum_flt_flt; 
	"grouped tail sum"
.COMMAND {sum_dbl}(BAT[oid,flt] b, BAT[oid,any] e) : BAT[oid,dbl] = CMDaggr_sum_flt_dbl; 
	"grouped tail sum"
.COMMAND {sum_dbl}(BAT[oid,dbl] b, BAT[oid,any] e) : BAT[oid,dbl] = CMDaggr_sum_dbl_dbl; 
	"grouped tail sum"

.COMMAND {prod_uchr}(BAT[oid,uchr] b, BAT[oid,any] e) : BAT[oid,uchr] = CMDaggr_prod_uchr_uchr; 
	"grouped tail product"
.COMMAND {prod_int}(BAT[oid,uchr] b, BAT[oid,any] e) : BAT[oid,int] = CMDaggr_prod_uchr_int; 
	"grouped tail product"
.COMMAND {prod_sht}(BAT[oid,sht] b, BAT[oid,any] e) : BAT[oid,sht] = CMDaggr_prod_sht_sht; 
	"grouped tail product"
.COMMAND {prod_int}(BAT[oid,sht] b, BAT[oid,any] e) : BAT[oid,int] = CMDaggr_prod_sht_int; 
	"grouped tail product"
.COMMAND {prod_int}(BAT[oid,int] b, BAT[oid,any] e) : BAT[oid,int] = CMDaggr_prod_int_int; 
	"grouped tail product"
.COMMAND {prod_lng}(BAT[oid,int] b, BAT[oid,any] e) : BAT[oid,lng] = CMDaggr_prod_int_lng; 
	"grouped tail product"
.COMMAND {prod_lng}(BAT[oid,lng] b, BAT[oid,any] e) : BAT[oid,lng] = CMDaggr_prod_lng_lng; 
	"grouped tail product"
.COMMAND {prod_flt}(BAT[oid,flt] b, BAT[oid,any] e) : BAT[oid,flt] = CMDaggr_prod_flt_flt; 
	"grouped tail product"
.COMMAND {prod_dbl}(BAT[oid,flt] b, BAT[oid,any] e) : BAT[oid,dbl] = CMDaggr_prod_flt_dbl; 
	"grouped tail product"
.COMMAND {prod_dbl}(BAT[oid,dbl] b, BAT[oid,any] e) : BAT[oid,dbl] = CMDaggr_prod_dbl_dbl; 
	"grouped tail product"

.COMMAND {avg}(BAT[oid,uchr] b, BAT[oid,any] e) : BAT[oid,dbl] = CMDaggr_avg_uchr; 
	"grouped tail average"
.COMMAND {avg}(BAT[oid,sht] b, BAT[oid,any] e) : BAT[oid,dbl] = CMDaggr_avg_sht; 
	"grouped tail average"
.COMMAND {avg}(BAT[oid,int] b, BAT[oid,any] e) : BAT[oid,dbl] = CMDaggr_avg_int; 
	"grouped tail average"
.COMMAND {avg}(BAT[oid,lng] b, BAT[oid,any] e) : BAT[oid,dbl] = CMDaggr_avg_lng; 
	"grouped tail average"
.COMMAND {avg}(BAT[oid,flt] b, BAT[oid,any] e) : BAT[oid,dbl] = CMDaggr_avg_flt; 
	"grouped tail average"
.COMMAND {avg}(BAT[oid,dbl] b, BAT[oid,any] e) : BAT[oid,dbl] = CMDaggr_avg_dbl; 
	"grouped tail average"

.COMMAND {min}(BAT[oid,any::1] b, BAT[oid,any] e) : BAT[oid,any::1] = CMDaggr_min; 
	"grouped tail minimum"
.COMMAND {max}(BAT[oid,any::1] b, BAT[oid,any] e) : BAT[oid,any::1] = CMDaggr_max; 
	"grouped tail maximum"

.COMMAND {count}(BAT[oid,any] b, BAT[oid,any] e, bit ignore_nils) : BAT[oid,int] = CMDaggr_count; 
	"grouped count; ignores nil values iff ignore_nils==TRUE"
.COMMAND {size}(BAT[oid,bit] b, BAT[oid,any] e) : BAT[oid,int] = CMDaggr_size;
	"grouped count of true values"

.END aggr;

@mil
    proc {count}(BAT[oid,any] b, BAT[oid,any] e) : BAT[oid,int] {
		return {count}(b,e,FALSE);
    }
    ADDHELP("{count}", "manegold", "Jun 03 2003",
    "short-cut for {count}(b,e,FALSE)", "aggr");

    proc {count_no_nil}(BAT[oid,any] b, BAT[oid,any] e) : BAT[oid,int] {
		return {count}(b,e,TRUE);
    }
    ADDHELP("{count_no_nil}", "manegold", "Jun 03 2003",
    "short-cut for {count}(b,e,TRUE)", "aggr");

    proc size(BAT[any,bit] b) : int {
	var h := b.histogram;
	if (h.exist(true)) 
	    return h.find(true);
	return 0;
    }

    proc {sum}(BAT[oid, uchr] b, bat[oid,any] e ) : BAT[oid,uchr] {
		return	 {sum_uchr}(b,e);
    }
    proc {sum}(BAT[oid, sht] b, bat[oid,any] e ) : BAT[oid,sht] {
		return	 {sum_sht}(b,e);
    }
    proc {sum}(BAT[oid, int] b, bat[oid,any] e ) : BAT[oid,int] {
		return	 {sum_int}(b,e);
    }
    proc {sum}(BAT[oid, lng] b, bat[oid,any] e ) : BAT[oid,lng] {
		return	 {sum_lng}(b,e);
    }
    proc {sum}(BAT[oid, flt] b, bat[oid,any] e ) : BAT[oid,flt] {
		return	 {sum_flt}(b,e);
    }
    proc {sum}(BAT[oid, dbl] b, bat[oid,any] e ) : BAT[oid,dbl] {
		return	 {sum_dbl}(b,e);
    }

    proc {prod}(BAT[oid, uchr] b, bat[oid,any] e ) : BAT[oid,uchr] {
		return	 {prod_uchr}(b,e);
    }
    proc {prod}(BAT[oid, sht] b, bat[oid,any] e ) : BAT[oid,sht] {
		return	 {prod_sht}(b,e);
    }
    proc {prod}(BAT[oid, int] b, bat[oid,any] e ) : BAT[oid,int] {
		return	 {prod_int}(b,e);
    }
    proc {prod}(BAT[oid, lng] b, bat[oid,any] e ) : BAT[oid,lng] {
		return	 {prod_lng}(b,e);
    }
    proc {prod}(BAT[oid, flt] b, bat[oid,any] e ) : BAT[oid,flt] {
		return	 {prod_flt}(b,e);
    }
    proc {prod}(BAT[oid, dbl] b, bat[oid,any] e ) : BAT[oid,dbl] {
		return	 {prod_dbl}(b,e);
    }

    proc card(BAT[any,any] b) : int {
	return b.tunique.count;
    }

    proc {card}(BAT[oid,any] b, BAT[oid,any] e) : BAT[oid,int] {
	return {count}(b.sunique,e);
    }

@{
@+ Test Script

@mil
proc toset(bat[any,any] b) : str {
        var res := "{ ";
        b@batloop() {
		if (isnil($t)) {
			res :+= "nil ";
		} else {
	                res :+= str($t) + " ";
		}
        }
        return res + "}";
}

proc aggrtst(int num, int fanout, str agg, ..str..) {
	var gagg := sprintf("{%s}",agg);
	var p := 3;
	while((p :+= 1) <= $0) {
	        var b, e, v := bat(void, int, num);
	        var tpe := $(p);
	        var i := 0;
	        while(i <= num) {
	                v.insert(nil, 42);
	                i :+= 1;
	        }
	        e := [oid](v.seqbase(0@0).reverse).reverse;
	        if (fanout = 1) {
	                b := bat(void,(*tpe)()).seqbase(0@0);
	        } else {
	                b := bat(oid,(*tpe)());
	        }
	        var n := 0; 
	        e@batloop() {
		   if (int($h) < num) {
	                i := 0; 
	                while(i < fanout) {
	                        if  (n = 0) {
	                                b.insert($h, (*tpe)(-1));
	                        } else if  (($h = oid(num/2)) and (i = (fanout/2))) {
	                                b.insert($h, (*tpe)(nil));
	                        } else if (($h = oid(num - 1)) and (i = (fanout - 1))) {
	                                b.insert($h, (*tpe)(0));
	                        } else {
	                                b.insert($h, (*tpe)(n));
                        	} 
                        	n :+= 1; i :+= 1;
                	}
                    }
                }
		var bs := {toset}(b).col_name("test-set "+tail(b));
		var ab  := (*gagg)(b).col_name(sprintf("%s(b)",gagg));
		var abv := (*gagg)(b,v).col_name(sprintf("%s(b,v)",gagg));
		var abe := (*gagg)(b,e).col_name(sprintf("%s(b,e)",gagg));
		if (not(printed)) {
			v.print;
			e.print;
			var bh := b.mark(0@0).reverse;
			var bt := b.reverse.mark(0@0).reverse;
			print(bh,bt,bt.[sht],bt.[int],bt.[lng],bt.[flt],bt.[dbl],bt.[str]);
			printed := TRUE;
		}
		var tpe2 := tail(ab);
		ab.access(BAT_WRITE).insert(oid(num),(*agg)(b.reverse.select(oid(num)).reverse));
		bs.access(BAT_WRITE).insert(oid(num),"{  }");
        	print(bs,
        	      ab , ab.[str] ,
        	      abv, abv.[str],
        	      abe, abe.[str]);
        }
}

PROC test_aggr() : void := {
	module("decimal");
	var printed := FALSE;
	aggrtst(5,9,"sum","sht","int","lng","flt","dbl");
	aggrtst(5,9,"sum_lng","sht","int","lng");
	aggrtst(5,9,"sum_dbl","flt","dbl");
	aggrtst(5,9,"prod","sht","int","lng","flt","dbl");
	aggrtst(5,9,"prod_lng","sht","int","lng");
	aggrtst(5,9,"prod_dbl","flt","dbl");
	aggrtst(5,9,"avg","sht","int","lng","flt","dbl");
	aggrtst(5,9,"min","sht","int","lng","flt","dbl","decimal");
	aggrtst(5,9,"max","sht","int","lng","flt","dbl","decimal");
	aggrtst(5,9,"count","sht","int","lng","flt","dbl","decimal");
	aggrtst(5,9,"count_no_nil","sht","int","lng","flt","dbl","decimal");
	aggrtst(5,9,"card","sht","int","lng","flt","dbl","decimal");
}

PROC test_aggr_uchr() : void := {
	module("decimal");
	var printed := FALSE;
	aggrtst(5,9,"sum","uchr");
	aggrtst(5,9,"sum_lng","uchr");
	aggrtst(5,9,"prod","uchr");
	aggrtst(5,9,"prod_lng","uchr");
	aggrtst(5,9,"avg","uchr");
	aggrtst(5,9,"min","uchr");
	aggrtst(5,9,"max","uchr");
	aggrtst(5,9,"count","uchr");
	aggrtst(5,9,"count_no_nil","uchr");
	aggrtst(5,9,"card","uchr");
}

@{
@+ Implementation
These implementations need just one scan and a simple hash-maintained data
structure to compute a group of common aggregates. 
@c
#include <gdk.h>
#include "uchr.h"
#include "aggr.proto.h"

/* 
with group OIDs spanning a range of less SMALL_AGGR_MAX (the actual number
of groups might be even less, in case there are "holes" in the group OID
range), we use a simple array as temporary sum/cnt table on order to benefit
from positional lookups; with size of sum <= 8 bytes and size of cnt == 4
bytes, we stay below 16 KBytes, i.e., within (almost) any L1 cache
*/
#define SMALL_AGGR_MAX 1024

@= large_aggr_sum
	(void) BATprepareHash(bn);
	BATloopFast(b, p, q, xx) {
		oid *h = (oid*) BUNhead(b,p);
		@1 *t = (@1*) BUN@2(b,p);

		BUNfndOID(r, bn, h);
		if (r) {
			@3 *dst = (@3*) BUN@2(bn, r);
			if (*dst != @3_nil) {
				if (*t == @1_nil) {	
					*dst = @3_nil;
				} else {
					*dst += *t;
				}
			} 
		}
	} 
@c
@= small_aggr_sum
	sums = (@3*) GDKmalloc(range*sizeof(@3));
	for (i = 0; i < range; i++) sums[i] = zero;
	BATloopFast(b, p, q, xx) {
		oid h = (*(oid*) BUNhead(b,p)) - min;
		@1 *t = (@1*) BUN@2(b,p);

		if (h < range) {
			@3 *dst = sums + h;
			if (*dst != @3_nil) {
				if (*t == @1_nil) {	
					*dst = @3_nil;
				} else {
					*dst += *t;
				}
			} 
		}
	} 
	BATloopFast(bn, p, q, xx) {
		oid h = (*(oid*) BUNhead(bn,p)) - min;
		*(@3*)BUN@2(bn, p) = sums[h];
	}
        GDKfree(sums);
@c
@= large_aggr_prod
	(void) BATprepareHash(bn);
	BATloopFast(b, p, q, xx) {
		oid *h = (oid*) BUNhead(b,p);
		@1 *t = (@1*) BUN@2(b,p);

		BUNfndOID(r, bn, h);
		if (r) {
			@3 *dst = (@3*) BUN@2(bn, r);
			if (*dst != @3_nil) {
				if (*t == @1_nil) {	
					*dst = @3_nil;
				} else {
					*dst *= *t;
				}
			} 
		}
	} 
@c
@= small_aggr_prod
	prods = (@3*) GDKmalloc(range*sizeof(@3));
	for (i = 0; i < range; i++) prods[i] = one;
	BATloopFast(b, p, q, xx) {
		oid h = (*(oid*) BUNhead(b,p)) - min;
		@1 *t = (@1*) BUN@2(b,p);

		if (h < range) {
			@3 *dst = prods + h;
			if (*dst != @3_nil) {
				if (*t == @1_nil) {	
					*dst = @3_nil;
				} else {
					*dst *= *t;
				}
			} 
		}
	} 
	BATloopFast(bn, p, q, xx) {
		oid h = (*(oid*) BUNhead(bn,p)) - min;
		*(@3*)BUN@2(bn, p) = prods[h];
	}
        GDKfree(prods);
@c
@= large_aggr_avg
	cnt  = (size_t*) GDKmalloc(BATcount(e)*sizeof(size_t));
	memset(cnt, 0, BATcount(e)*sizeof(size_t));
	(void) BATprepareHash(bn);
	BATloopFast(b, p, q, xx) {
		oid *h = (oid*) BUNhead(b,p);
		@1 *t = (@1*) BUN@2(b,p);

		BUNfndOID(r,bn,h);
		if (r) {
			dbl *dst = (dbl*) BUN@2(bn, r);
			if (*dst != dbl_nil) {
				if (*t == @1_nil) {	
					*dst = dbl_nil;
				} else {
					*dst += *t;
				}
				cnt[BUNindex(bn,r)-off]++;
			} 
		}
	} 
	/* postprocess by dividing sums by counts */
	BATloopFast(bn, p, q, xx) {
		dbl *dst = (dbl*) BUN@2(bn, p);
		if (cnt[yy] == 0) {
			*dst = dbl_nil;
		} else if (*dst != dbl_nil) {
			*dst = (dbl) (*dst / cnt[yy]);
		} yy++;
	} 
	GDKfree(cnt);
@c
@= small_aggr_avg
	sums = (dbl*) GDKmalloc(range*sizeof(dbl));
	cnt  = (size_t*) GDKmalloc(range*sizeof(size_t));
	for (i = 0; i < range; i++) sums[i] = zero;
	memset(cnt, 0, range*sizeof(size_t));
	BATloopFast(b, p, q, xx) {
		oid h = (*(oid*) BUNhead(b,p)) - min;
		@1 *t = (@1*) BUN@2(b,p);

		if (h < range) {
			dbl *dst = sums + h;
			if (*dst != dbl_nil) {
				if (*t == @1_nil) {	
					*dst = dbl_nil;
				} else {
					*dst += *t;
				}
				cnt[h]++;
			} 
		}
	} 
	/* postprocess by dividing sums by counts */
	BATloopFast(bn, p, q, xx) {
		oid h = (*(oid*) BUNhead(bn,p)) - min;
		dbl *dst = (dbl*) BUN@2(bn, p);
		if (cnt[h] == 0 || sums[h] == dbl_nil) {
			*dst = dbl_nil;
		} else {
			*dst = (dbl) (sums[h]/cnt[h]);
		}
	}
        GDKfree(sums);
	GDKfree(cnt);
@c

@= arithsumprod
int CMDaggr_sum_@1_@3(BAT **ret, BAT *b, BAT *e){
	BAT *bn = BATnew(e->htype, TYPE_@3, BATcount(e));	
	@3 zero = (@3) 0, *sums;
	BUN p, q, r;
	int xx;
	oid i, range, min, max;

	/* init: set all sums to zero */
	bn->tsorted = bn->hsorted = 0;
	ALIGNsetH(bn, e);
	if (BAThordered(e)&1) {
		min = *(oid*)BUNhead(e, BUNfirst(e));
		BATloopFast(e, p, q, xx) {
			BUNfastins(bn, BUNhead(e,p), &zero);
		}
		max = *(oid*)BUNhead(e, BUNlast(e)-BUNsize(e));
	} else {
		min = max = *(oid*)BUNhead(e, BUNfirst(e));
		BATloopFast(e, p, q, xx) {
			BUNfastins(bn, BUNhead(e,p), &zero);
			i = *(oid*)BUNhead(e, p);
			if (i < min) min = i;
			else
			if (i > max) max = i;
		}
	}
	range = max - min + 1;

	/* scan b, and add values to sums in-place */
	if (range > SMALL_AGGR_MAX) {
		ALGODEBUG THRprintf(GDKout, "CMDaggr_sum_@1_@3: range(=%lu) > SMALL_AGGR_MAX(=%d)  => large_aggr_sum\n",(unsigned long) range,SMALL_AGGR_MAX);
		@:large_aggr_sum(@1,@2,@3)@
	} else {
		ALGODEBUG THRprintf(GDKout, "CMDaggr_sum_@1_@3: range(=%lu) <= SMALL_AGGR_MAX(=%d)  => small_aggr_sum\n",(unsigned long) range,SMALL_AGGR_MAX);
		@:small_aggr_sum(@1,@2,@3)@
	}
	*ret = bn;
	return GDK_SUCCEED;
}

int CMDaggr_prod_@1_@3(BAT **ret, BAT *b, BAT *e){
	BAT *bn = BATnew(e->htype, TYPE_@3, BATcount(e));	
	@3 one = (@3) 1, *prods;
	BUN p, q, r;
	int xx;
	oid i, range, min, max;

	/* init: set all prods to one */
	bn->tsorted = bn->hsorted = 0;
	ALIGNsetH(bn, e);
	if (BAThordered(e)&1) {
		min = *(oid*)BUNhead(e, BUNfirst(e));
		BATloopFast(e, p, q, xx) {
			BUNfastins(bn, BUNhead(e,p), &one);
		}
		max = *(oid*)BUNhead(e, BUNlast(e)-BUNsize(e));
	} else {
		min = max = *(oid*)BUNhead(e, BUNfirst(e));
		BATloopFast(e, p, q, xx) {
			BUNfastins(bn, BUNhead(e,p), &one);
			i = *(oid*)BUNhead(e, p);
			if (i < min) min = i;
			else
			if (i > max) max = i;
		}
	}
	range = max - min + 1;

	/* scan b, and mul values to prods in-place */
	if (range > SMALL_AGGR_MAX) {
		ALGODEBUG THRprintf(GDKout, "CMDaggr_prod_@1_@3: range(=%lu) > SMALL_AGGR_MAX(=%d)  => large_aggr_prod\n",(unsigned long) range,SMALL_AGGR_MAX);
		@:large_aggr_prod(@1,@2,@3)@
	} else {
		ALGODEBUG THRprintf(GDKout, "CMDaggr_prod_@1_@3: range(=%lu) <= SMALL_AGGR_MAX(=%d)  => small_aggr_prod\n",(unsigned long) range,SMALL_AGGR_MAX);
		@:small_aggr_prod(@1,@2,@3)@
	}
	*ret = bn;
	return GDK_SUCCEED;
}
@c
@:arithsumprod(uchr,tloc,uchr)@
@:arithsumprod(uchr,tloc,sht)@
@:arithsumprod(uchr,tloc,int)@
@:arithsumprod(uchr,tloc,lng)@
@:arithsumprod(sht,tloc,sht)@
@:arithsumprod(sht,tloc,int)@
@:arithsumprod(sht,tloc,lng)@
@:arithsumprod(int,tloc,int)@
@:arithsumprod(int,tloc,lng)@
@:arithsumprod(lng,tloc,lng)@
@:arithsumprod(flt,tloc,flt)@
@:arithsumprod(flt,tloc,dbl)@
@:arithsumprod(dbl,tloc,dbl)@

@= arithavg
int CMDaggr_avg_@1(BAT **ret, BAT *b, BAT *e){
	BAT *bn = BATnew(e->htype, TYPE_dbl, BATcount(e));	
	int xx;
	size_t yy = 0, off = BUNindex(bn,BUNfirst(bn));
	size_t *cnt;
	oid i, range, min, max; 
	dbl zero = (dbl) 0, *sums;
	BUN p, q, r;

	/* init sums and counts to zero */
	bn->tsorted = bn->hsorted = 0;
	ALIGNsetH(bn, e);
	if (BAThordered(e)&1) {
		min = *(oid*)BUNhead(e, BUNfirst(e));
		BATloopFast(e, p, q, xx) {
			BUNfastins(bn, BUNhead(e,p), &zero);
		}
		max = *(oid*)BUNhead(e, BUNlast(e)-BUNsize(e));
	} else {
		min = max = *(oid*)BUNhead(e, BUNfirst(e));
		BATloopFast(e, p, q, xx) {
			BUNfastins(bn, BUNhead(e,p), &zero);
			i = *(oid*)BUNhead(e, p);
			if (i < min) min = i;
			else
			if (i > max) max = i;
		}
	}
	range = max - min + 1;

	/* scan b, adding sums, and incrementing counts */
	if (range > SMALL_AGGR_MAX) {
		ALGODEBUG THRprintf(GDKout, "CMDaggr_avg_@1: range(=%lu) > SMALL_AGGR_MAX(=%d)  =>  large_aggr_avg\n",(unsigned long)range,SMALL_AGGR_MAX);
		@:large_aggr_avg(@1,@2)@
	} else {
		ALGODEBUG THRprintf(GDKout, "CMDaggr_avg_@1: range(=%lu) <= SMALL_AGGR_MAX(=%d)  =>  small_aggr_avg\n",(unsigned long)range,SMALL_AGGR_MAX);
		@:small_aggr_avg(@1,@2)@
	}
	*ret = bn;
	return GDK_SUCCEED;
}
@c
@:arithavg(uchr,tloc)@
@:arithavg(sht,tloc)@
@:arithavg(int,tloc)@
@:arithavg(lng,tloc)@
@:arithavg(flt,tloc)@
@:arithavg(dbl,tloc)@

@= extreme
int CMDaggr_@1(BAT **ret, BAT *b, BAT *e){
	BAT *bn = BATnew(e->htype, BATttype(b), BATcount(e));	
	int (*cmp)(ptr,ptr) = BATatoms[bn->ttype].atomCmp;
	ptr nil = ATOMnilptr(bn->ttype);
	int xx;
	size_t yy = 0, off = BUNindex(e,BUNfirst(e));
	ptr *extremes = (ptr*) GDKmalloc(BATcount(e)*sizeof(ptr)); 
	BUN p, q, r;

	/* init: set all extremes to the zero pointer */
	memset(extremes, 0, BATcount(e)*sizeof(ptr)); 

	/* scan b and replace totals by the extreme value (just pointers to vals in b) */
	(void) BATprepareHash(e);
	BATloopFast(b, p, q, xx) {
		oid *h = (oid*) BUNhead(b,p);
		ptr t =  BUNtail(b,p);

		BUNfndOID(r,e,h);
		if (r) {
			ptr *val = extremes + (BUNindex(e,r) - off);
			if (*val != nil) {
				if ((*cmp)(t,nil) == 0) {
					*val = nil;
				} else if (*val == NULL || (*cmp)(t,*val) @2 0) {
					*val = t;
				}
			}
		}
	} 
	/* insert the extreme values into the result */
	BATloopFast(e, p, q, xx) {
		ptr val = extremes[yy++];
		BUNfastins(bn, BUNhead(e,p), val?val:nil); 
	} 
	bn->tsorted = bn->hsorted = 0;
	ALIGNsetH(bn, e);
	GDKfree(extremes);
	*ret = bn;
	return GDK_SUCCEED;
}
@c
@:extreme(min,<)@
@:extreme(max,>)@

@= large_aggr_count
	(void) BATprepareHash(bn);
	BATloopFast(b, p, q, xx) {
		oid *h = (oid*) BUNhead(b,p);

		BUNfndOID(r, bn, h);
		if (r) {
			ptr t = BUNtail(b,p);
			@1 {
				int *dst = (int*) BUNtloc(bn, r);
				(*dst)++;
			}
		}
	} 
@c
@= small_aggr_count
	cnt  = (int*) GDKmalloc(range*sizeof(int));
	memset(cnt, 0, range*sizeof(int));
	BATloopFast(b, p, q, xx) {
		oid h = (*(oid*) BUNhead(b,p)) - min;

		if (h < range) {
			ptr t = BUNtail(b,p);
			@1 {
				cnt[h]++;
			}
		}
	} 
	BATloopFast(bn, p, q, xx) {
		oid h = (*(oid*) BUNhead(bn,p)) - min;
		*(int*)BUNtloc(bn, p) = cnt[h];
	}
        GDKfree(cnt);
@c

int CMDaggr_count(BAT **ret, BAT *b, BAT *e, bit *ignore_nils){
/* XXX in a large BAT, it is conceivable that there are head elements
   that occur more often than fits in an "int", so the return BAT
   should really have a tail type of size_t.
 */
	BAT *bn = BATnew(e->htype, TYPE_int, BATcount(e));	
	int zero = 0, *cnt;
	BUN p, q, r;
	int xx;
	oid i, range, min, max;
  	int btt = b->ttype;
	ptr bt_nil = ATOMnilptr(b->ttype);

	/* init: set all sums to zero */
	bn->tsorted = bn->hsorted = 0;
	ALIGNsetH(bn, e);
	if (BAThordered(e)&1) {
		min = *(oid*)BUNhead(e, BUNfirst(e));
		BATloopFast(e, p, q, xx) {
			BUNfastins(bn, BUNhead(e,p), &zero);
		}
		max = *(oid*)BUNhead(e, BUNlast(e)-BUNsize(e));
	} else {
		min = max = *(oid*)BUNhead(e, BUNfirst(e));
		BATloopFast(e, p, q, xx) {
			BUNfastins(bn, BUNhead(e,p), &zero);
			i = *(oid*)BUNhead(e, p);
			if (i < min) min = i;
			else
			if (i > max) max = i;
		}
	}
	range = max - min + 1;

	/* scan b, and add increment totals for true values */
	if (range > SMALL_AGGR_MAX) {
		if (*ignore_nils) {
			ALGODEBUG THRprintf(GDKout, "CMDaggr_count: range(=%lu) > SMALL_AGGR_MAX(=%d)  =>  large_aggr_count(if (ATOMcmp(btt,t,bt_nil)))\n",(unsigned long)range,SMALL_AGGR_MAX);
			@:large_aggr_count(if (ATOMcmp(btt,t,bt_nil)))@
		} else {
			ALGODEBUG THRprintf(GDKout, "CMDaggr_count: range(=%lu) > SMALL_AGGR_MAX(=%d)  =>  large_aggr_count()\n",(unsigned long)range,SMALL_AGGR_MAX);
			@:large_aggr_count()@
		}
	} else {
		if (*ignore_nils) {
			ALGODEBUG THRprintf(GDKout, "CMDaggr_count: range(=%lu) <= SMALL_AGGR_MAX(=%d)  =>  small_aggr_count(if (ATOMcmp(btt,t,bt_nil)))\n",(unsigned long)range,SMALL_AGGR_MAX);
			@:small_aggr_count(if (ATOMcmp(btt,t,bt_nil)))@
		} else {
			ALGODEBUG THRprintf(GDKout, "CMDaggr_count: range(=%lu) <= SMALL_AGGR_MAX(=%d)  =>  small_aggr_count()\n",(unsigned long)range,SMALL_AGGR_MAX);
			@:small_aggr_count()@
		}
	}
	*ret = bn;
	return GDK_SUCCEED;
}

int CMDaggr_size(BAT **ret, BAT *b, BAT *e){
	BAT *bn = BATnew(e->htype, TYPE_int, BATcount(e));	
	int zero = 0;
	BUN p, q, r;
	int xx;

	/* init: set all sums to zero */
	bn->tsorted = bn->hsorted = 0;
	ALIGNsetH(bn, e);
	BATloopFast(e, p, q, xx) {
		BUNfastins(bn, BUNhead(e,p), &zero);
	}
	/* scan b, and add increment totals for true values */
	(void) BATprepareHash(bn);
	BATloopFast(b, p, q, xx) {
		if (*(bit*) BUNtloc(b,p) == TRUE) {
			oid *h = (oid*) BUNhead(b,p);

			BUNfndOID(r, bn, h);
			if (r) {
				int *dst = (int*) BUNtloc(bn, r);
				(*dst)++;
			}
		}
	} 
	*ret = bn;
	return GDK_SUCCEED;
}

@}
@}
