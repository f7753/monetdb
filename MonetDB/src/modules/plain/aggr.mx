@f aggr
@a P. Boncz 
@t Aggregates Module
@v 1.0

This module contains some efficient aggregate functions that compute their 
result in one scan, rather than in the iterative manner of the generic 
MIL aggr_ implementations.

The implementation code is derived from the already existing tpcd module and some
test scripts were added.
@m
.MODULE aggr;

.COMMAND {sum}(BAT[oid,sht] b, BAT[oid,any] e) : BAT[oid,sht] = CMDaggr_sum_sht; 
	"grouped tail sum"
.COMMAND {sum}(BAT[oid,int] b, BAT[oid,any] e) : BAT[oid,int] = CMDaggr_sum_int; 
	"grouped tail sum"
.COMMAND {sum}(BAT[oid,lng] b, BAT[oid,any] e) : BAT[oid,lng] = CMDaggr_sum_lng; 
	"grouped tail sum"
.COMMAND {sum}(BAT[oid,flt] b, BAT[oid,any] e) : BAT[oid,flt] = CMDaggr_sum_flt; 
	"grouped tail sum"
.COMMAND {sum}(BAT[oid,dbl] b, BAT[oid,any] e) : BAT[oid,dbl] = CMDaggr_sum_dbl; 
	"grouped tail sum"

.COMMAND {avg}(BAT[oid,sht] b, BAT[oid,any] e) : BAT[oid,sht] = CMDaggr_avg_sht; 
	"grouped tail average"
.COMMAND {avg}(BAT[oid,int] b, BAT[oid,any] e) : BAT[oid,int] = CMDaggr_avg_int; 
	"grouped tail average"
.COMMAND {avg}(BAT[oid,lng] b, BAT[oid,any] e) : BAT[oid,lng] = CMDaggr_avg_lng; 
	"grouped tail average"
.COMMAND {avg}(BAT[oid,flt] b, BAT[oid,any] e) : BAT[oid,flt] = CMDaggr_avg_flt; 
	"grouped tail average"
.COMMAND {avg}(BAT[int,dbl] b, BAT[int,any] e) : BAT[int,dbl] = CMDaggr_avg_dbl; 
	"grouped tail average"

.COMMAND {min}(BAT[oid,any::1] b, BAT[oid,any] e) : BAT[oid,any::1] = CMDaggr_min; 
	"grouped tail minimum"
.COMMAND {max}(BAT[oid,any::1] b, BAT[oid,any] e) : BAT[oid,any::1] = CMDaggr_max; 
	"grouped tail maximum"

.COMMAND {count}(BAT[oid,any] b, BAT[oid,any] e) : BAT[oid,int] = CMDaggr_count; 
	"grouped count"
.COMMAND {size}(BAT[oid,bit] b, BAT[oid,any] e) : BAT[oid,int] = CMDaggr_size;
	"grouped count of true values"

.LOAD
    proc size(BAT[any,bit] b) : int {
	var h := b.histogram;
	if (h.exist(true)) 
	    return h.find(true);
	return 0;
    }

    proc avg(BAT[any, any::1] b) : any::1 {
	var cnt := count(b);
        if (cnt = 0) 
	    return cast(0,ttype(b));
	return /(sum(b),cast(cnt,ttype(b)));
    }

    proc card(BAT[any,any] b) : int {
	return b.tunique.count;
    }

    proc {card}(BAT[oid,any] b, BAT[oid,any] e) : BAT[oid,int] {
	return {count}(b.sunique,e);
    }
.END;

.END aggr;

@{
@+ Test Script
@mil
module(aggr,decimal);

proc toset(bat[any,any] b) : str {
        var res := "{ ";
        b@batloop() {
                res :+= str($t) + " ";
        }
        return res + "}";
}

proc aggrtst(int num, int fanout, str aggr) {
	var p := 3;
	while((p :+= 1) <= $0) {
	        var b, e, v := bat(void, int, num);
	        var tpe := $(p);
	        var i := 0;
	        while(i < num) {
	                v.insert(nil, 42);
	                i :+= 1;
	        }
	        e := [oid](v.seqbase(0@0).reverse).reverse;
	        if (fanout = 1) {
	                b := bat(void,(*tpe)()).seqbase(0@0);
	        } else {
	                b := bat(oid,(*tpe)());
	        }
	        var n := 0; 
	        e@batloop() {
	                i := 0; 
	                while(i < fanout) {
	                        if  (($h = 0@0) and (i = 0)) {
	                                b.insert($h, (*tpe)(nil));
	                        } else {
	                                b.insert($h, (*tpe)(n));
                        	} 
                        	n :+= 1; i :+= 1;
                	}
                }
        	print({toset}(b).col_name("test-set"),
        	      (*aggr)(b).col_name(sprintf("%s(b)",aggr)),
        	      (*aggr)(b,v).col_name(sprintf("%s(b,v)",aggr)),
        	      (*aggr)(b,e).col_name(sprintf("%s(b,e)",aggr)));
        }
}

aggrtst(16,160,"{sum}","sht","int","lng","flt","dbl");
aggrtst(16,160,"{avg}","sht","int","lng","flt","dbl");
aggrtst(16,160,"{min}","sht","int","lng","flt","dbl","decimal");
aggrtst(16,160,"{max}","sht","int","lng","flt","dbl","decimal");
aggrtst(16,160,"{card}","sht","int","lng","flt","dbl","decimal");
aggrtst(16,160,"{count}","sht","int","lng","flt","dbl","decimal");

@{
@+ Implementation
These implementations need just one scan and a simple hash-maintained data
structure to compute a group of common aggregates. 
@c
#include <gdk.h>
#include "aggr.proto.h"

@= arithpump
int CMDaggr_sum_@1(BAT **ret, BAT *b, BAT *e){
	BAT *bn = BATnew(e->htype, BATttype(b), BATcount(e));	
	@1 zero = (@1) 0;
	BUN p, q, r;
	int xx;

	/* init: set all sums to zero */
	bn->tsorted = bn->hsorted = 0;
	ALIGNsetH(bn, e);
	BATloopFast(e, p, q, xx) {
		BUNfastins(bn, BUNhead(e,p), &zero);
	}
	/* scan b, and add values to sums in-place */
	(void) BATprepareHash(bn);
	BATloopFast(b, p, q, xx) {
		oid *h = (oid*) BUNhead(b,p);
		@1 *t = (@1*) BUNtail(b,p);

		BUNfndOID(r, bn, h);
		if (r) {
			@1 *dst = (@1*) BUNtloc(bn, r);
			if (*dst != @1_nil) {
				if (*t == @1_nil) {	
					*dst = @1_nil;
				} else {
					*dst += *t;
				}
			} 
		}
	} 
	*ret = bn;
	return GDK_SUCCEED;
}

int CMDaggr_avg_@1(BAT **ret, BAT *b, BAT *e){
	BAT *bn = BATnew(e->htype, BATttype(b), BATcount(e));	
	int xx, yy = 0, off = BUNindex(bn,BUNfirst(bn));
	int *cnt = (int*) GDKmalloc(BATcount(e)*sizeof(int)); 
	@1 zero = (@1) 0;
	BUN p, q, r;

	/* init sums and counts to zero */
	bn->tsorted = bn->hsorted = 0;
	ALIGNsetH(bn, e);
	memset(cnt, 0, BATcount(e)*sizeof(int));
	BATloopFast(e, p, q, xx) {
		BUNfastins(bn, BUNhead(e,p), &zero);
	}
	/* scan b, adding sums, and incrementing counts */
	(void) BATprepareHash(bn);
	BATloopFast(b, p, q, xx) {
		oid *h = (oid*) BUNhead(b,p);
		@1 *t = (@1*) BUNtail(b,p);

		BUNfndOID(r,bn,h);
		if (r) {
			@1 *dst = (@1*) BUNtloc(bn, r);
			if (*dst != @1_nil) {
				if (*t == @1_nil) {	
					*dst = @1_nil;
				} else {
					*dst += *t;
				}
				cnt[BUNindex(bn,r)-off]++;
			} 
		}
	} 
	/* postprocess by dividing sums by counts */
	BATloopFast(bn, p, q, xx) {
		@1 *dst = (@1*) BUNtail(bn, p);
		if (cnt[yy] == 0) {
			*dst = @1_nil;
		} else if (*dst != @1_nil) {
			*dst /= cnt[yy];
		} yy++;
	} 
	GDKfree(cnt);
	*ret = bn;
	return GDK_SUCCEED;
}
@c
@:arithpump(sht)@
@:arithpump(int)@
@:arithpump(lng)@
@:arithpump(flt)@
@:arithpump(dbl)@

@= extreme
int CMDaggr_@1(BAT **ret, BAT *b, BAT *e){
	BAT *bn = BATnew(e->htype, BATttype(b), BATcount(e));	
	int (*cmp)(ptr,ptr) = BATatoms[bn->ttype].atomCmp;
	ptr nil = ATOMnilptr(bn->ttype);
	int xx, yy = 0, off = BUNindex(e,BUNfirst(e));
	ptr *extremes = (ptr*) GDKmalloc(BATcount(e)*sizeof(ptr)); 
	BUN p, q, r;

	/* init: set all extremes to the zero pointer */
	memset(extremes, 0, BATcount(e)*sizeof(ptr)); 

	/* scan b and replace totals by the extreme value (just pointers to vals in b) */
	(void) BATprepareHash(e);
	BATloopFast(b, p, q, xx) {
		oid *h = (oid*) BUNhead(b,p);
		ptr t =  BUNtail(b,p);

		BUNfndOID(r,e,h);
		if (r) {
			ptr *val = extremes + (BUNindex(e,r) - off);
			if (*val != nil) {
				if ((*cmp)(t,nil) == 0) {
					*val = nil;
				} else if (*val == NULL || (*cmp)(t,*val) @2 0) {
					*val = t;
				}
			}
		}
	} 
	/* insert the extreme values into the result */
	BATloopFast(e, p, q, xx) {
		ptr val = extremes[yy++];
		BUNfastins(bn, BUNhead(e,p), val?val:nil); 
	} 
	bn->tsorted = bn->hsorted = 0;
	ALIGNsetH(bn, e);
	GDKfree(extremes);
	*ret = bn;
	return GDK_SUCCEED;
}
@c
@:extreme(min,<)@
@:extreme(max,>)@

int CMDaggr_count(BAT **ret, BAT *b, BAT *e){
	BAT *bn = BATnew(e->htype, TYPE_int, BATcount(e));	
	int zero = 0;
	BUN p, q, r;
	int xx;

	/* init: set all sums to zero */
	bn->tsorted = bn->hsorted = 0;
	ALIGNsetH(bn, e);
	BATloopFast(e, p, q, xx) {
		BUNfastins(bn, BUNhead(e,p), &zero);
	}
	/* scan b, and add increment totals for true values */
	(void) BATprepareHash(bn);
	BATloopFast(b, p, q, xx) {
		oid *h = (oid*) BUNhead(b,p);

		BUNfndOID(r, bn, h);
		if (r) {
			int *dst = (int*) BUNtloc(bn, r);
			(*dst)++;
		}
	} 
	*ret = bn;
	return GDK_SUCCEED;
}

int CMDaggr_size(BAT **ret, BAT *b, BAT *e){
	BAT *bn = BATnew(e->htype, TYPE_int, BATcount(e));	
	int zero = 0;
	BUN p, q, r;
	int xx;

	/* init: set all sums to zero */
	bn->tsorted = bn->hsorted = 0;
	ALIGNsetH(bn, e);
	BATloopFast(e, p, q, xx) {
		BUNfastins(bn, BUNhead(e,p), &zero);
	}
	/* scan b, and add increment totals for true values */
	(void) BATprepareHash(bn);
	BATloopFast(b, p, q, xx) {
		if (*(bit*) BUNtloc(b,p) == TRUE) {
			oid *h = (oid*) BUNhead(b,p);

			BUNfndOID(r, bn, h);
			if (r) {
				int *dst = (int*) BUNtloc(bn, r);
				(*dst)++;
			}
		}
	} 
	*ret = bn;
	return GDK_SUCCEED;
}
@}
@}
