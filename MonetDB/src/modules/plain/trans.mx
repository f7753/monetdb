@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2005 CWI.
@' All Rights Reserved.

@f trans
@t Transactions
@a M.L. Kersten, P. Boncz
@v 1.0
@T
@* Introduction
In the philosophy of Monet, transaction management overhead should only
be paid when necessary. Transaction management is for this purpose 
implemented as a module.
TODO: move simple 2-phase locking transaction code from ODMG to this module. 

@* Module Definition
@m
.MODULE trans;

@- global transaction management
@m
.COMMAND sync() = global_sync;
 "save all persistent BATs"
.COMMAND commit() = global_commit;
 "global commit on all BATs"
.COMMAND abort() = global_abort;
 "global abort on all BATs"

@- BAT specific transaction management
@m
.COMMAND commit(BAT[ANY,ANY], ...BAT[ANY,ANY]...) = trans_commit;
	"commit changes in certain BATs."
.COMMAND abort(BAT[ANY,ANY], ...BAT[ANY,ANY]...) = trans_abort;
	"abort changes in certain BATs."
.COMMAND clean(BAT[ANY,ANY], ...BAT[ANY,ANY]...) = trans_clean;
	"declare a BAT clean without flushing to disk."
@- delta status
@m
.COMMAND alpha(BAT[ANY::1,ANY::2]) : BAT[ANY::1,ANY::2] = trans_alpha;
	"give list of insertions since last commit."
.COMMAND delta(BAT[ANY::1,ANY::2]) : BAT[ANY::1,ANY::2] = trans_delta;
	"give list of deletions since last commit."

.END trans;

@{
@* Implementation Code 
@c
#include "trans.proto.h"

int global_sync(void) { BBPsync(TRUE); return GDK_SUCCEED; }
int global_commit(void) { TMcommit(); return GDK_SUCCEED; }
int global_abort(void) { TMabort(); return GDK_SUCCEED; }

int trans_alpha(BAT **retval, BAT *b) {
	*retval = BATalpha(b);
	return retval?GDK_SUCCEED:GDK_FAIL;
}

int trans_delta(BAT **retval, BAT *b) {
	*retval = BATdelta(b);
	return retval?GDK_SUCCEED:GDK_FAIL;
}

int trans_commit(BAT *b, ...) {
        va_list ap;

        va_start (ap,b);
	do {
		BATcommit(b);
	} while ((b = va_arg(ap, BAT*)) != 0);
        va_end (ap);
	return GDK_SUCCEED;
}

int trans_abort(BAT *b, ...) {
        va_list ap;

        va_start (ap,b);
	do {
		BATundo(b);
		if (b->batPersistence == PERSISTENT)
			BBPsave(b);
	} while ((b = va_arg(ap, BAT*)) != 0); 
        va_end (ap);
	return GDK_SUCCEED;
}

int trans_clean(BAT *b, ...) {
        va_list ap;

        va_start (ap,b);
	do {
		BATfakeCommit(b);
	} while ((b = va_arg(ap, BAT*)) != 0);
        va_end (ap);
	return GDK_SUCCEED;
}
@
@}
