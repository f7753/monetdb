@f algebra
@a Peter Boncz
@v 1.0
@t BAT Algebra

@* Introduction
[THIS MODULE HAS BEEN PATCHED FOR V5, all Prolog code is removed as well]
This modules contains the most common algebraic BAT manipulation 
commands. We call them @#algebra@, because all operations take
values as parameters, and produce new result values, but  
@%do not modify their parameters@.
@
@* Module Definition 
@m
.MODULE algebra;
@
We split between selections that return one value, and selections 
that return a BAT.
@+ Value Selections
@m
.COMMAND exist(BAT[any::1,any] b, any::1 h) : bit = CMDexist;
"Returns whether 'h' occurs as a head value in b."

.COMMAND exist(BAT[any::1,any::2] b, any::1 h, any::2 t) : bit = CMDexistBUN;
"Returns true when 'h,t' occurs as a bun in b."

.COMMAND find(BAT[any::1,any::2] b, any::1 h) : any::2 = CMDfind; 
"Returns the tail value 't' for which some [h,t] BUN exists in b.
 If no such BUN exists, an error occurs." 

.COMMAND position(BAT[any::1,any] b, any::1 val) : int = CMDposition; 
"Returns the BAT position e [0.. b.count> of a 'val' in the head column of b.
 It gives an error if 'val' does not occur in b. "
 
.COMMAND position(BAT[any::1,any::2] b, any::1 val, any::2 tval) : int = CMDpositionBUN; 
"Returns the BAT position e [0.. b.count> of a 'val' in the head column of b.
 It gives an error if 'val' does not occur in b. "
 
.COMMAND fetch(BAT[any,any::1] b, int x) : any::1 = CMDfetch; 
"Returns the tail value of the BUN at the x-th position with 0 <= x < b.count"

.COMMAND fetch(BAT[any,any::1] b, oid x) : any::1 = CMDfetchoid; 
"Returns the tail value of the BUN at the x-th position with 0 <= x < b.count"
@+ BAT Selections
@- positional select
@m
.COMMAND fetch(BAT[any::1,any::2] b, BAT[int, any] s) : 
				BAT[any::1,any::2] = CMDfetchbat; 
"Returns a positional selection of b by the integer head values of s"

.COMMAND fetch(BAT[any::1,any::2] b, BAT[oid, any] s) : 
				BAT[any::1,any::2] = CMDfetchbat; 
"Returns a positional selection of b by the oid head values of s"
@- range select
@m
.COMMAND select ( BAT[any::1,any::2] b, any::2 low, any::2 high) : 
				BAT[any::1, any::2] = CMDselect; 
"Select all BUNs of a BAT that have tail values: {v| low <= v <= high}.\n

NIL boundary values have a special meaning.\n
+ low  == nil means: no lower bound\n
+ high == nil means: no upper bound.

NOTE 1: you should cast the nil to the appropriate type, e.g. int(nil)
        in order to cirumvent type clashes.
NOTE 2: as the 'nil' element has no clear place in the ordered domain 
        of values, tuples with 'nil values are NEVER returned by the 
        range select."
@- unary range select
@m
.COMMAND uselect ( BAT[any::1,any::2] b, any::2 low, any::2 high) : 
				BAT[any::1, void] = CMDuselect;
"Select on tail, returning only the head values. 
 SEE ALSO: select(bat,low,high)."
@- value select
@m
.COMMAND select ( BAT[any::1,any::2] b, any::2 value) :
                                BAT[any::1, any::2] = CMDselect1; 
"Select all BUNs of a BAT with a certain tail value. Selection
 on NIL is also possible (it should be properly casted, e.g.: int(nil))."
@- unary value select
@m
.COMMAND uselect ( BAT[any::1,any::2] b, any::2 value) : 
				BAT[any::1, void] = CMDuselect1; 
"Value select, but returning only the head values.
 SEE ALSO: select(bat,val)"
@m
.COMMAND fragment ( BAT[any::1,any::2] b, 
	any::1 hlow, any::1 hhigh,
	any::2 tlow, any::2 thigh) : 
				BAT[any::1,any::2] = CMDfragment; 
"Select both on head and tail range."
@- random selection 
@m
.COMMAND sample ( BAT[any::1,any::2] b, int num) : 
				BAT[any::1,any::2] = CMDsample; 
"Produce a random selection of size 'num' from the input BAT."
@- substring select 
@m
.COMMAND like ( BAT[any::1, str] b, str substr ) :  
				BAT[any::1, str] = CMDlike; 
"Selects all elements from the input BAT that have 'substr'
as substring in the tail."
@- positional select 
@m
.COMMAND slice(BAT[any::1,any::2], int x, int y) : 
				BAT[any::1,any::2] =CMDslice;
"Return the slice with the BUNs at position x till y."
@+ BAT copying
@m
.COMMAND copy ( BAT[any::1,any::2] b) : 
				BAT[any::1, any::2] = CMDcopy; 
"Returns physical copy of a BAT."
@- sorted copy
@m
.COMMAND sort ( BAT[any::1,any::2] b) : 
				BAT[any::1, any::2] = CMDsort; 
"Returns a sorted copy of a BAT."
@- vertical projection
@m
.COMMAND project ( BAT[any::1,any] b, any::2 val) : 
				BAT[any::1, any::2] = CMDproject; 
"Fill the tail column with a constant value."
@+ Sets
@T
Sets in Monet can be viewed in two ways:
\begin{itemize} 
\item by looking at both colums of a BAT together (Set-, or s-operators).
\item by looking at the head column only (Key- or k-operators).
\end{itemize} 
For this reason, all standard set operations come in two flavors:
\begin{itemize}
\item k-{\tt operand}, which look only at the head column.
\item s-{\tt operand} series, that look at the whole BUN.
\end{itemize}
@

@T
Operands provided are:
\begin{itemize}
\item {\tt [s,k]unique} (bat[any::1,any::2]) : bat[any::1,any::2]\\
produces a copy of the bat, with double elimination
\item {\tt [s,k]union}(bat[any::1,any::2],bat[any::1,any::2]) : bat[any::1,any::
2]\\
bat union.
\item {\tt [s,k]diff}(bat[any::1,any::2],bat[any::1,any::2]) : bat[any::1,any:
:2]\\
bat difference.
\item {\tt [s,k]intersection}(bat[any::1,any::2],bat[any::1,any::2]) : bat[any:
:1,any::2]\\
bat intersection.
\end{itemize}
Implementations typically take two forms: if the input relation(s) is/are
ordered, a merge-algorithm is used. Otherwise, hash-indices are produced
on demand for the hash-based algorithms.
\\
The {\tt [k,s]intersect(l,r)} operations result in all BUNs of {\tt l} that 
are also in {\tt r}. They do not do double-elimination over the {\tt l} BUNs.
\\
The {\tt [k,s]diff(l,r)} operations result in all BUNs of {\tt l} that are
not in {\tt r}. They do not do double-elimination over the {\tt l} BUNs.
\\
The {\tt [k,s]union(l,r)} operations result in all BUNs of l that are  
not in {\tt r}, plus all BUNs of {\tt r}. They do not do double-elimination 
over the {\tt l} nor {\tt r} BUNs.
\\
Operations with double-elimination can be formed by performing 
{\tt [k,s]unique(l)} on their operands.
\\
The {\tt kintersect(l,r)} is used also as implementation for the 
{\tt semijoin()}.

@- bun-unique elements
@m
.COMMAND sunique ( BAT[any::1,any::2] b ) : 
				BAT[any::1,any::2] = CMDsunique; 
"Select unique tuples from the input BAT. Double elimination is done over 
 BUNs as a whole (head and tail). Result is a BAT with real set() semantics."
@- head-unique elements
@m
.COMMAND kunique ( BAT[any::1,any::2] b ) : 
				BAT[any::1,any::2] = CMDkunique; 
"Select unique tuples from the input BAT. Double elimination is done
 only looking at the head column. Result is a BAT with hkeyed() == true."
@- bun-intersecting elements
@m
.COMMAND sintersect ( BAT[any::1,any::2] left, BAT[any::1,any::2] right) : 
				BAT[any::1,any::2] = CMDsintersect; 
"Returns the intersection taken over *both* columns of two BATs.
 Results in all BUNs of 'left' that are also in 'right'. Does *not* do 
 double-elimination over the 'left' BUNs, If you want this, use:
 'sintersect(left.sunique,right.sunique)' or: 'sintersect(left,right).sunique'."
@- head-intersecting elements (a.k.a. semijoin)
@m
.COMMAND kintersect ( BAT[any::1,any::2] left, BAT[any::1,any] right) :
				BAT[any::1,any::2] = CMDsemijoin; 
"Returns the intersection taken over only the *head* columns of two BATs.
 Results in all BUNs of 'left' that are also in 'right'. Does *not* do 
 double-elimination over the 'left' BUNs, If you want this, use:
 'kintersect(left.kunique,right.kunique)' or: 'kintersect(left,right).kunique'."
@- bun-differing elements
@m
.COMMAND sdiff ( BAT[any::1,any::2] left, BAT[any::1,any::2] right) : 
				BAT[any::1,any::2] = CMDsdiff; 
"Returns the difference taken over *both* columns of two BATs.  
 Results in all BUNs of 'left' that are *not* in 'right'. Does *not* do
 double-elimination over the 'left' BUNs, If you want this, use:
 'sdiff(left.sunique,right.sunique)' or: 'sdiff(left,right).sunique'."
@- head-differing elements
@m
.COMMAND kdiff ( BAT[any::1,any::2] left, BAT[any::1,any] right) :
				BAT[any::1,any::2] = CMDkdiff; 
"Returns the difference taken over only the *head* columns of two BATs. 
 Results in all BUNs of 'left' that are *not* in 'right'. Does *not* do
 double-elimination over the 'left' BUNs, If you want this, use:
 'kdiff(left.kunique,right.kunique)' or: 'kdiff(left,right).kunique'."
@- union on bun
@m
.COMMAND sunion ( BAT[any::1,any::2] left, BAT[any::1,any::2] right) : 
				BAT[any::1,any::2] = CMDsunion; 
"Returns the union of two BATs; looking at both columns of both BATs. 
 Results in all BUNs of 'left' that are  not in 'right', plus all BUNs 
 of 'right'. *no* double-elimination is done. If you want this, do: 
 'sunion(left.sunique,right.sunique)' or: 'sunion(left,right).sunique'."
@- union on head
@m
.COMMAND kunion ( BAT[any::1,any::2] left, BAT[any::1,any::2] right) : 
				BAT[any::1,any::2] = CMDkunion; 
"Returns the union of two BATs; looking at head-columns only. 
 Results in all BUNs of 'left' that are  not in 'right', plus all BUNs 
 of 'right'. *no* double-elimination is done. If you want this, do: 
 'kunion(left.kunique,right.kunique)' or: 'sunion(left,right).kunique'."
@+ Joins
The core of every relational engine.
Signature Changed: Output tail type incorrect because of soid to coid switch. 
@- semijoin
.COMMAND semijoin ( BAT[any::1,any::2] left, 
                   BAT[any::1,any] right) :
				BAT[any::1,any::2] = CMDsemijoin; 
@- join (projected out join columns)
@m
.COMMAND join ( BAT[any::1,any::2] left, BAT[any::2,any::3] right) :
                               BAT[any::1,any::3] = CMDjoin; 
"Returns all BUNs, consisting of a head-value from 'left' and
a tail-value from 'right' for which there are BUNs in 'left'
and 'right' with equal tail- resp. head-value (i.e. the join
columns are projected out)."
@- Outer Join
@m
.COMMAND outerjoin ( BAT[any::1,any::2] outer, BAT[any::2,any::3] inner) :
                                BAT[any::1,any::3] = CMDouterjoin; 
"Returns all the result of a join, plus the BUNS formed NIL in
the tail and the head-values of 'outer' whose tail-value does
not match an head-value in 'inner'."
@- { <,<=,=,>=,> } Join
@m
.COMMAND thetajoin ( BAT[any::1,any::2] left, BAT[any::2,any::3] right, 
		int mode) : BAT[any::1,any::3] = CMDthetajoin; 
"Theta join on for 'mode' in { LE, LT, EQ, GT, GE }.\n
JOIN_EQ is just the same as join(). All other options do merge
algorithms; either using the fact that they are ordered()
already (left on tail, right on head), or by using/creating
binary search trees on the join columns. "
@- Theta Join with inner columns
@m
.COMMAND theta ( BAT[any::2,any::2] inner_result, 
		BAT[any::1,any::3] outer_result,
		BAT[any::1,any::2] left, 
		BAT[any::2,any::3] right, int mode) 
				= CMDtheta; 
"Theta join, just as simple thetajoin(l,r); the difference
is that it returns two values, which are added to the first params
'inner_result' and 'outer_result'; 'inner_result' gets all matching
inner tuples, 'outer_result' the other two (what would have the
result of thetajoin(l,r))."
@- Band Join (approximate match)
@m
.COMMAND bandjoin ( BAT[any::1,any::2] outer, 
		   BAT[any::2,any::3] inner,
		   any::2 minus, any::2 plus) : 
				BAT[any::1,any::3] = CMDbandjoin; 
"This is a join() for which the predicate is that two BUNs match if
the left-tail value is within the range [right-head - minus,
right-head + plus]\n
Works only for the builtin numerical types, and their derivates."
@+ OID Introducing Commands
For relational processing, some operators are necessary to produce newly 
initiated OID columns, for representing n-ary (intermediary) relations. 

@- OID head column
@m
.COMMAND mark( BAT[any::1,any] b ) : 
				BAT[any::1,OID] = CMDmark_default; 
"Produces a new BAT with fresh unique OIDs in the tail."

.COMMAND mark( BAT[any::1,any] b , oid base) : 
				BAT[any::1,OID] = CMDmark; 
"Produces a new BAT with fresh unique dense sequense of OIDs in the tail
 that starts at base (i.e. [base,base+1,..base+b.count()-1] )."
@- number tail column
@m
.COMMAND number( BAT[any::1,any] b ) : 
				BAT[any::1,int]  = CMDnumber;
"Produces a new BAT with identical head column, and consecutively
increasing integers (starting with 0) in the tail column."

.COMMAND group(BAT[any::1, any] b, int start, int incr, int grpsize) : BAT[any::1, int] = CMDgroup;
"Produces a new BAT with identical head column, and in the tail column groups of equally valued 
integers within each group. Parameters: a start group value, group number increment, group size."

@+ BAT fragmentation commands
Various operations for splitting BATs into useful fragments.

@- Hash Split
@m
.COMMAND hashsplit ( BAT[any::1,any::2] b, int buckets ) :
			 	BAT[int,BAT[any::1,any::2]] = CMDhashsplit; 
"Split a BAT on tail column according (hash-value MOD buckets).
Returns a recursive BAT, containing the fragments in the tail,
their bucket number in the head."

.COMMAND uhashsplit ( BAT[any::1,any::2] b, int buckets ) :
			 	BAT[int,BAT[any::1,any::2]] = CMDuhashsplit; 
"Same as hashsplit, but only collect the head values in the fragments" 
@- Range Split
@m
.COMMAND rangesplit ( BAT[any::1,any::2] b, int ranges ) : 
				BAT[any::2,BAT[any::1,any::2]] = CMDrangesplit;
"Split a BAT on tail column in 'ranges' equally sized
consecutive ranges. Returns a recursive BAT, containing the
fragments in the tail, the higher-bound of the range in the head.
The higher bound of the last range is 'nil'."

.COMMAND urangesplit ( BAT[any::1,any::2] b, int ranges ) : 
				BAT[any::2,BAT[any::1,void]] = CMDurangesplit;
"Same as rangesplit, but only collect the head values in the fragments" 

@+ Common BAT Aggregates
These operations examine a BAT, and compute some simple aggregate result 
over it.
@- BAT size
@m
.COMMAND count ( BAT[any,any] b ) : 
				int = CMDcount; 
"Return the number of elements currently in a BAT."
@- Histogram on Tail 
@m
.COMMAND histogram ( BAT[any,any::2] b) : 
				BAT[any::2,int] = CMDhistogram; 
"Produce a BAT containing the histogram of the tail values.
 bat.histogram() ::= {count}(bat.reverse)"

.COMMAND {count} ( BAT[any::2,any] b) : 
				BAT[any::2,int] = CMDhistogram_rev; 
"has fast implementation: histogram(bat.reverse)"

@- Default Min and Max
@T
Implementations a generic Min and Max routines get declared first. The 
{\tt min()} and {\tt max()} routines below catch any tail-type. 
The type-specific routines defined later are faster, and will 
override these any implementations.
@c
@- minimum tail value
@m
.COMMAND min ( BAT[any::1,any::2] b ) 	
			: any::2 = CMDminany; "
Give the lowest tail value. Error on empty BATs."

@- maximum tail value
@m
.COMMAND max ( BAT[any::1,any::2] b ) 
			: any::2 = CMDmaxany; "
Give the highest tail value. Error on empty BATs."
@+ Type-Specific Sum, Max and Min
@T
For X $\in$ \{ sht,int,flt,dbl,lng \},  we define (using the {\em aggregate}
macro):
\begin{itemize}
\item .COMMAND sum(BAT[any,X] : X, 
\item .COMMAND max(BAT[any,X] : X, and 
\item .COMMAND min(BAT[any,X] : X. 
\end{itemize}
@m
@:aggregate(sum,"Gives the sum of all tail values.")@
@:aggregate(max,"Give the highest tail value. Error on empty BATs.")@
@:aggregate(min,"Give the lowest tail value. Error on empty BATs.")@

@= aggregate_definition
.COMMAND @1 ( BAT[any,@2] ) : @2 = CMD@1_@2; @3
@= aggregate
@:aggregate_definition(@1,sht,@2)@
@:aggregate_definition(@1,int,@2)@
@:aggregate_definition(@1,flt,@2)@
@:aggregate_definition(@1,dbl,@2)@
@:aggregate_definition(@1,lng,@2)@

@* MIL definitions
@m
.LOAD
@- constants for theta() and thetajoin()
@m
CONST EQ := 0;
CONST LT := -1;
CONST LE := -2;
CONST GT := 1;
CONST GE := 2;

    PROC ADDHELP(str cmd, str aut, str dat, str hlp, str mod) : void {
        #VAR fid := monet_fcn_nme.reverse.find(cmd);
        #VAR fid := monet_fcn_nme.select(cmd).kdiff(monet_fcn_aut).reverse.find(cmd);
        VAR fid := monet_fcn_nme.select(cmd).kdiff(monet_fcn_aut).reverse.min;
        monet_fcn_dsc.insert(fid, hlp);
        monet_fcn_aut.insert(fid, aut);
        monet_fcn_dat.insert(fid, dat);
	monet_fcn_mid.insert(fid, monet_mod_nme.reverse.find(mod));
    }

    ADDHELP("ADDHELP", "boncz", "Feb  6 1996",
    "provide helpful info on a command (author, date, help-text).", "algebra");

    PROC clear(bat[any::1,any::2] b) : bat[any::1,any::2] 
		return b.delete;
    ADDHELP("clear", "boncz", "Mar  6 1996",
        "Backward compatibility. Does a b.delete()", "algebra");

@- new MIL procedures
The MIL described in the journal paper needs the below constructs
that for the moment are defined as procs.
@m
    PROC semijoin(bat[any::1,any::2] l, bat[any::1,any] r) : bat[any::1,any::2] 
 		return kintersect(l,r);
    ADDHELP("semijoin", "boncz", "Nov  1 1998",
	    "semijoin is a synonym of kintersect.", "algebra");

    PROC unique(bat[any::1,any::2] b) : bat[any::1,any::2] 
		return sunique(b);
    ADDHELP("unique", "boncz", "Apr  6 1997",
            "backward compatibility: use sunique() explicitly.", "algebra");

    PROC diff(bat[any::1,any::2] b1, bat[any::1,any::2] b2)  : bat[any::1,any::2] 
		return sdiff(b1,b2);
    ADDHELP("diff", "boncz", "Apr  6 1997",
            "backward compatibility: use sdiff() explicitly.", "algebra");

    PROC intersect(bat[any::1,any::2] b1, bat[any::1,any::2] b2) : bat[any::1,any::2] 
		return sintersect(b1,b2); 
    ADDHELP("intersect", "boncz", "Apr  6 1997",
             "backward compatibility: use sintersect() explicitly.", "algebra");

    PROC union(bat[any::1,any::2] b1, bat[any::1,any::2] b2) : bat[any::1,any::2] := 
		return sunion(b1,b2);
    ADDHELP("union", "boncz", "Feb  6 1996",
            "backward compatibility: use sunion() explicitly.", "algebra");

    PROC project(bat[any::1,any] b) : bat[any::1,void] 
		return b.project(nil);

    PROC join(bat[any::1,any::2] l, bat[any::2,any::3] r, str fcn, ..any..) : bat[any::1,any::3] 
    {
        if ($0 = 3) {
            if (fcn = "=") {
                return join(l,r);
            } else if (fcn = "<=") {
                return thetajoin(l,r,LE);
            } else if (fcn = "<") {
                return thetajoin(l,r,LT);
            } else if (fcn = ">=") {
                return thetajoin(l,r,GE);
            } else if (fcn = ">") {
                return thetajoin(l,r,GT);
            } else if (fcn = "true") {
                var bn := new(l.htype,r.ttype, l.count*r.count);
                l@batloop() {
                    var h := $h;
                    r@batloop() bn.insert(h,$t);
                }
                return bn;
            }
        }
        var swapped := false;
        if (l.count < r.count) {
            var swap := l;
            l := r.reverse; r := swap.reverse;
            swapped := true;
        }
        var bn := new(l.htype, r.ttype, l.count);
        l@batloop() {
            var h := $h;
            var t := $t;
            if (swapped) {
                r@batloop() if ((*fcn)($h,t,$(4..))) bn.insert(h,$t);
            } else {
                r@batloop() if ((*fcn)(t,$h,$(4..))) bn.insert(h,$t);
            }
        }
        if (swapped) {
            return bn.reverse;
        } else {
            return bn;
        }
    }
    ADDHELP("join", "boncz", "Aug  6 1998",
            "Returns [left.head,right.tail] where (*fcn)(left.tail,right.head,..params..)", "algebra");

    # SQL like functionality, vectorized MIL implementation
    # TODO: escaped percents
    PROC likeselect(bat[any::1,str] b, str pat) : bat[any::1,oid] := {
        var s, idx := pat.search('%');

        if (idx = -1) {
            return b.uselect(pat);
        } else if (idx > 0) {
            s := [[startsWith](b, pat.string(0, idx))?b:];
            b := s.[string](0, idx);
        }
        while((idx :+=1) < pat.length) {
            pat := pat.string(idx, pat.length-idx);
            idx := pat.search('%');
            if (idx < 0) {
                if (pat.length > 0) {
                    b := [b.[endsWith](pat)?b:];
                } break;
            }
            s := b.[search](pat.string(0, idx)).select(0,int(nil));
            b := b.[string](s, [-](b.semijoin(s).[length], s));
        }
        return b.mark(nil);
    }

    PROC mil_select(bat[any::1,any::2] b, str fcn, ..any..) : bat[any::1,any::2] 
    {
        if ($0 = 3) {
            var val := $3;
            if (val.type = b.ttype) {    
                var nilval := nil.cast(val.type); 
                if (fcn = "=") {
                    return b.select(val);
                } else if (fcn = "<=") {
                    return b.select(nilval, val);
                } else if (fcn = "<") {
                    var bn := b.select(nilval, val);
		    if ( (bn.htype() = oid) and(not(isnil(bn.seqbase()))) ){
			bn := [oid](bn.reverse).reverse();
		    }
                    var bn_access := bn.access();
                    bn.access(BAT_WRITE);
                    bn.reverse.delete(val);
                    bn.access(bn_access);
                    return bn;
                } else if (fcn = ">=") {
                    return b.select(val, nilval);
                } else if (fcn = ">") {
                    var bn := b.select(val, nilval);
		    if ( (bn.htype() = oid) and(not(isnil(bn.seqbase()))) ){
			bn := [oid](bn.reverse).reverse();
		    }
                    var bn_access := bn.access();
                    bn.access(BAT_WRITE);
                    bn.reverse.delete(val);
                    bn.access(bn_access);
                    return bn;
                } else if (fcn = "like") {
                    var bn := likeselect(b, val);
                    return b.semijoin(bn);
                }
            }
        }
        var bitvector := [*fcn](b,$(3..));
        return [bitvector?b:];
    }

    PROC mil_select(bat[any::1,any::2] b, str fcn, any::2 lo, any::2 hi) : bat[any::1,any::2] 
    {
        if (or((fcn = "between"),(fcn = "[in]"))) {
            return b.select(lo,hi);
        } else if (fcn = "<in]") {
            var bn := b.select(lo,hi);
	    if ( (bn.htype() = oid) and(not(isnil(bn.seqbase()))) ){
		bn := [oid](bn.reverse).reverse();
	    }
            var bn_access := bn.access();
            bn.access(BAT_WRITE);
            bn.reverse.delete(lo);
            bn.access(bn_access);
            return bn;
        } else if (fcn = "[in>") {
            var bn := b.select(lo,hi);
	    if ( (bn.htype() = oid) and(not(isnil(bn.seqbase()))) ){
		bn := [oid](bn.reverse).reverse();
	    }
            var bn_access := bn.access();
            bn.access(BAT_WRITE);
            bn.reverse.delete(hi);
            bn.access(bn_access);
            return bn;
        } else if (fcn = "<in>") {
            var bn := b.select(lo,hi);
	    if ( (bn.htype() = oid) and(not(isnil(bn.seqbase()))) ){
		bn := [oid](bn.reverse).reverse();
	    }
            var bn_access := bn.access();
            bn.access(BAT_WRITE);
            bn.reverse.delete(lo);
            bn.reverse.delete(hi);
            bn.access(bn_access);
            return bn;
        }
        var bitvector := [*fcn](b,lo,hi);
        return [bitvector?b:];
    }
    ADDHELP("mil_select", "boncz", "Aug  6 1998",
            "Returns all BUNs where (*fcn)(tail,,..params..).", "algebra");

    PROC neg_select(bat[any::1,any::2] b, str fcn, ..any..) : bat[any::1,any::2] 
    {
        if ($0 = 3) {
            var val := $3;
            if (val.type = b.ttype) {    
                if (fcn = "!=") {
                    return b.mil_select("=", val);
                } else if (fcn = ">=") {
                    return b.mil_select("<", val);
                } else if (fcn = "<=") {
                    return b.mil_select(">", val);
                } else if (fcn = ">") {
                    return b.mil_select("<=", val);
                } else if (fcn = "<") {
                    return b.mil_select(">=", val);
                } else if (fcn = "like") {
                    var bn := likeselect(b, val);
                    return b.kdiff(bn);
                }
            }
        }
        var bitvector := [*fcn](b,$(3..));
        return [bitvector?:b];
    }
    ADDHELP("neg_select", "boncz", "Aug  6 1998",
            "Returns all BUNs where not (*fcn)(tail,,..params..)", "algebra");

    PROC rev_select(bat[any::1,any::2] b, str fcn, any::2 val) : bat[any::1,any::2] 
    {
        if (fcn = "=") {
            return b.mil_select("=",val);
        } else if (fcn = "!=") {
            return b.mil_select("!=",val);
        } else if (fcn = ">") {
            return b.mil_select("<",val);
        } else if (fcn = "<") {
            return b.mil_select(">",val);
        } else if (fcn = "<=") {
            return b.mil_select(">=",val);
        } else if (fcn = ">=") {
            return b.mil_select("<=",val);
        }
        ERROR("rev_select: unknown predicate %s(%s)\n", fcn, str(val));
    }
    ADDHELP("rev_select", "boncz", "Aug  6 1998",
            "(value OP column) select rather than (column OP value)","algebra");

    PROC tunique (bat[any,any::1] b) : bat[any::1,void]
	return b.reverse.mark(nil).kunique;

    PROC sort_ht (bat[any::1,any::2] B) : bat[any::1,any::2] 
    {
        var R := new(htype(B),ttype(B),count(B));
        B.kunique.sort@batloop {
            B.reverse.select($h).sort@batloop {
                R.insert($t,$h);
            }
        }
        return R;
    }
    ADDHELP("sort_ht", "manegold", "Dec 17 1998",
            "sorts a BAT according to its head (primary) and tail values (secondary).\
             (straight forward hack, not tuned for performance at all, just used for testing.)", "algebra");

.END;
.END algebra;

@* Cost Model
This module contains a full cost model on the algebraic 
operators, in the form of executable Prolog clauses.
We in turn discuss the basic concepts of this model:
properties, propagation rules, and cost functions.

@+ Modeling With Properties
@T
The Monet kernel performs {\em run-time optimizations}. To choose between
alternaticve algorithms in a sensible way, it maintains knowledge about 
each BAT, sometimes as a {\em BAT property}, sometimes as two
{\em column properties} for each column (head and tail)
of a BAT. An example of the former is {\em size(bat) : int}
(which gives the number of BUNs in a BAT), an example
of the latter is {\tt ordered(column) : bit}, indicating 
whether the column contains its valued stored in ascending order.
The convention is to use a BAT as operand also for the column
properties; which then is supposed to be valid for the head
column ({\tt ordered(BAT)}). Tail columns can be described by 
using the mirror BAT with the minus operator ({\tt ordered(-BAT)}).

@- Column Properties
@T
\begin{description}
\item[{\tt ordered(BAT) : bit}] 
	TRUE if the head column is stored in ascending order, else FALSE.
\item[{\tt keyed(BAT) : bit}] 
	TRUE if no duplicates are present in the head column, else FALSE.
\item[{\tt idx(BAT) : bit}] 
	TRUE if a binary index tree search accelerator is present on 
	the head column of the BAT, else FALSE.
\item[{\tt hashtab(BAT) : bit}] presence of hash table on the head column of 
	a BAT. TRUE if a bucket-chained hash table search accelerator is 
	present on the head column of the BAT, else FALSE.
\item[{\tt subcol(BAT, BAT) : bit}] 
	TRUE if the bag of all values in the head column of the left BAT is
	a bag-subset of the bag of all values in the head column of the 
	right BAT, else FALSE. 
\item[{\tt sync(BAT) : oid}] 
	Sync-OID on the head column of a BAT. A sync-OID denotes some unique
	sequence of values. If two columns have the same sync-OID, then they
	are guaranteed to contain the same values, in the same sequence.
\end{description}

@- BAT properties
@T
\begin{description}
\item[{\tt size(BAT) : int}] 
	The (estimated) length of a column.
\item[{\tt unique(BAT) : int}] 
	The (estimated) number of distinct values in one column.
\item[{\tt subset(BAT, BAT) : bit}] 
	TRUE if the left BAT is a subset of the BUNs of the right BAT, 
	else FALSE.
\item[{\tt setunique(BAT) : bit}] 
	TRUE if the BAT contains no duplicate BUNs, else FALSE.
\end{description}

@- Property Propagation Rules
@T
At database creation time, the properties of the BATs in the database
can be derived directly from the database schema.

When queries are executed, they will produce {\em intermediate results},
which in terms are operands for further execution. Hence it is necessary
to {\em propagate properties} from the operands of an algebraic operator,
to its result. 

This process can be captured by having a series of {\em propagation rules} 
for each algebraic operand. Since each algebraic operands may apply
different strategies, according to different status in its operand properties, 
each algebraic operator may have different propagation rules with these 
different situations as conditions.

This module speficies full property propagation rules for the entire set
of standard algebraic MIL operators.

@- Kernel vs Model Properties
@T
The properties managed by the model are a superset of the ones maintained 
run-rime by the query. The reason for this follows:

Suppose we do {\tt B:=select(A,l,h)}
from a large table A into B. If we now do {\tt C:=semijoin(A,B)} 
we will get a C with the same size of B. Moreover they will be exactly 
equal, so the {\tt sync()} properies of B and C will be equal. 
This transformation of {\tt sync()} properties can be done run-time
without any properties, but not by a cost model at compile time.

The cost model needs to explicitly recall that B is a subset of A.
It can easily deduce this from the fact that B was the result of a 
{\tt select()} on A. Only then will it be able to propagate the {\tt sync()}s 
of B to C. For these and similar reasons, the {\tt subset()}, {\tt subcol()} 
and {\tt distinct()} properties were introduced into the model, 
although they do not occur in the Monet kernel at run-time.

@- Cost Functions
@T
With the property propagation rules in hand, for each algebraic operator,
split out for each different algorithmic strategy in each operator, it is 
a small step to a full cost model. In the last section, cost functions 
can be found for each different akgorithm. The design of this prolog program
is such that the propagation rules are separated from the cost functions.
In this way, we can experiment with different cost functions without modifying
all code.

@- Disclaimer
As a first attempt we give a very simple cost model without any memory status
and IO (yet), nor does it discriminate between cost factors for different
atomic types. BATs are estimated by uniform distribution data, instead
of more sophisticated methods like sampling or histograms. The cost
functions just give a crude estimation of CPU cost for each operator.

@+ Model Implementation
The model is implemented as a series of prolog clauses. SWI/prolog
gives you a free inference system, a programmer can directly concentrate
on the rules that make up his model. This was the rationale for going 
with prolog.

The model consists of a bunch of prolog clauses that correspond 1-1 to 
MIL algebra primitives. Special prolog clauses also exist for introducing
a data model (that is, persistent BATs) in the model. 

@- Data Definition
@T
We quickly sketch the prolog clauses that can be used to declare 
an object-oriented data model, mapped on Monet BATs, in the 
prolog cost model:
\begin{itemize}
\item 
{\small extent(table-name, cardinality)}\\
declares the existence of a table. Monet will generate an extent for
it that consists of a bat[oid,nil]. The oid column contains OIDs
of all objects instances of this table. This bat is simply named 
$<table-name>$. 
\item 
{\small attrib(table-name, attr-name, value-type, ordinality, min-value, max-value)}\\
declares an attribute, and hence a BAT with [void,value] tuples. The void column
is a dense column that contains OIDs of all objects. This bat is named 
$table\_attr$. Monet actually generates automatically an {\bf inversion-list}
bat[oid,value] that is sorted on the values. This bat is named {$tableRattr$}. 
\item 
{\small attrib(table-name, attr-name, value-type, ordinality)}\\
This is a shorter way to declare an attribute. You do not need to specify
the minimum and maximum values that are used in the uniform estimations; 
monet assumes them, to be zero and $ordinality$.
This is only applicable for numerical attributes.
\item 
{\small relation(table-name, attr-name, table-name, ordinality)}\\
A relation is an attribute that refers to an object instead of a value.
This will translate into a value of type oid. But referential integrity gives
you now more knowledge: the values of this column will be a subset of the
extent of the objects referred to. So you specify in the third parameter
this table-name, and need not give a domain size (the cost model infers
this from the extent).

\item 
{\small select\_est(Result, tries, domain)}\\
This clause yields a result in the first parameter. It computes
the expected number of different colors if you select $tries$ time
from the same set of $domain$ different values.

This formula stems from the inner workings of the cost model but
might come handy for estimating ordinalities that were generated with
random assumptions. 
\end{itemize}

@- MIL to Prolog
@T
For each execution order, we give a mil-like prolog script. The
first line tpcd() clause instantiates the tpcd data model.
The other lines correspond 1-1 with MIL assignments statements,
in which the variable to which is assigned is placed as the first
parameter of the prolog clause. The prolog clause corresponds directly
with the name of the MIL command mto be invoked, with the command
signature appended to it after an underscore. That is 
{\bf\begin{verbatim}
X := uselect(bat_x,any_y);
\end{verbatim}}
in MIL becomes:
{\bf\begin{verbatim}
uselect_batany(X, bat_x, any_y),
\end{verbatim}}
in prolog.

Remember to change the ; into commas, but to end the script with
a dot, and to place an empty white line at the end. That's what
the SWI/prolog compiler wants you to do anyway.  

{\bf As the reverse(bat) operation is common, we allow to identify
     the reverse view on a persistent bat {\tt table\_attr} with  
     the standard synonym {\tt table\_attr\_} (underscore appended).}

@- Bugs
@T
We should package this program into a utility that eats MIL
directly.  It would be an attractive idea to have it calleable
as an extension module from MIL directly. 

@- Utility
@sh
#/bin/sh
# COST MODEL UTILITY
# ==================
#
# usage: milmodel milscript # pl-ified milscript
#
# COMPILE THE MODEL WITH: pl -o milmodel -c algebra.pl
#
milmodel < $1 2>/dev/null|egrep -v "^#"|fgrep "#"|fgrep -v "new"> /tmp/$$
more /tmp/$$
echo "============== +"
awk '{ a += $1 } END { print "TOTAL="a; }' < /tmp/$$
rm /tmp/$$

@* Command Implementations in C
This module contains just a wrapper implementations; since all described 
operations are part of the GDK kernel.

@= aggregate_implementation
int CMDsum_@1(@1* result, BAT *b) {
	return BATsum(b, result)?GDK_SUCCEED:GDK_FAIL;
}
int CMDmin_@1(@1* result, BAT *b) {
	return BATmin(b, result)?GDK_SUCCEED:GDK_FAIL;
}
int CMDmax_@1(@1* result, BAT *b) {
	return BATmax(b, result)?GDK_SUCCEED:GDK_FAIL;
}
@c
#include "gdk.h"

@:aggregate_implementation(sht)@
@:aggregate_implementation(int)@
@:aggregate_implementation(flt)@
@:aggregate_implementation(dbl)@
@:aggregate_implementation(lng)@

int CMDminany(ptr result, BAT *b) {
	if (!ATOMlinear(b->ttype)) 
	    return GDKerror("CMDminANY: atom '%s' cannot be ordered linearly\n",
			ATOMname(b->ttype));
	if (ATOMvarsized(b->ttype)) 
	    return (*(ptr*) result = BATmin(b, NULL))?GDK_SUCCEED:GDK_FAIL;
	if (BATmin(b, result)) {
	    if (b->ttype == TYPE_bat) 
		*(BAT**) result = BATdescriptor(*(int*) result);
	    return GDK_SUCCEED;
	}
	return GDK_FAIL;
}
int CMDmaxany(ptr result, BAT *b) {
	if (!ATOMlinear(b->ttype)) 
	    return GDKerror("CMDmaxANY: atom '%s' cannot be ordered linearly\n",
			ATOMname(b->ttype));
	if (ATOMvarsized(b->ttype)) 
	    return (*(ptr*) result = BATmax(b, NULL))?GDK_SUCCEED:GDK_FAIL;
	if (BATmax(b, result)) {
	    if (b->ttype == TYPE_bat) 
		*(BAT**) result = BATdescriptor(*(int*) result);
	    return GDK_SUCCEED;
	}
	return GDK_FAIL;
}
int CMDselect1(BAT **result, BAT* b, ptr value) {
	return (*result = (BAT*) BATselect(b, value, 0))?GDK_SUCCEED:GDK_FAIL;
}
int CMDuselect1(BAT **result, BAT* b, ptr value) {
	return (*result = (BAT*) BATuselect(b, value, 0))?GDK_SUCCEED:GDK_FAIL;
}
int CMDselect(BAT **result, BAT *b, ptr low, ptr high) {
	return (*result = (BAT*) BATselect(b, low, high))?GDK_SUCCEED:GDK_FAIL;
}
int CMDuselect(BAT **result, BAT *b, ptr low, ptr high) {
	return (*result = (BAT*) BATuselect(b, low, high))?GDK_SUCCEED:GDK_FAIL;
}
int CMDfragment(BAT **result, BAT *b, ptr hlow, ptr hhigh, ptr tlow, ptr thigh) 
{
	return (*result = (BAT*) BATrestrict(b, hlow, hhigh, tlow, thigh))?
		GDK_SUCCEED:GDK_FAIL;
}
int CMDthetajoin(BAT **result, BAT *left, BAT *right, int *mode) {
	return (*result = (BAT*) BATthetajoin(left, right, *mode))?
		GDK_SUCCEED:GDK_FAIL;
}
int CMDtheta(BAT *inner, BAT *outer, BAT *left, BAT *right, int *mode) {
	BATtheta(inner, outer, left, right, *mode);
	return GDK_SUCCEED;
}
int CMDbandjoin(BAT **result, BAT *left, BAT *right, ptr minus, ptr plus) {
	return (*result = (BAT*) BATbandjoin(left, right, minus, plus))?
		GDK_SUCCEED:GDK_FAIL;
}

@-
Let cut this text down with some Mx macro's
@= unary
int CMD@1(BAT **result, BAT *b) {
	return (*result = (BAT*) @2(b))?GDK_SUCCEED:GDK_FAIL;
}
@= unaryint
int CMD@1(int *result, BAT *b) {
	*result = (int) @2(b);
	return GDK_SUCCEED;
}
@= binary
int CMD@1(BAT **result, BAT *left, BAT* right) {
	return (*result = (BAT*) @2(left, right))?GDK_SUCCEED:GDK_FAIL;
}
@= binaryint
int CMD@1(BAT **result, BAT* b, int *param) {
	return (*result = @2(b, *param))?GDK_SUCCEED:GDK_FAIL;
}
@c
@:unaryint(count, BATcount)@
@:unary(histogram, BAThistogram)@
@:unary(sort, BATsort)@
@:unary(number, BATnumber)@
@:unary(copy, BATcopy)@
@:unary(kunique, BATkunique)@
@:unary(sunique, BATsunique)@
@:binary(join, BATjoin)@
@:binary(semijoin, BATsemijoin)@
@:binary(outerjoin, BATouterjoin)@
@:binary(sunion, BATsunion)@
@:binary(kunion, BATkunion)@
@:binary(sintersect, BATsintersect)@
@:binary(kintersect, BATkintersect)@
@:binary(sdiff, BATsdiff)@
@:binary(kdiff, BATkdiff)@
@:binaryint(sample, BATsample)@

int CMDgroup(BAT **result, BAT *b, int *start, int *incr, int *grpsize) {
        return (*result = (BAT *) BATgroup(b, *start, *incr, *grpsize))?GDK_SUCCEED:GDK_FAIL;
}

int CMDproject(BAT** res, BAT *b, ptr p, int t) {
	return (*res=BATconst(b, t, p))?GDK_SUCCEED:GDK_FAIL;
}

int CMDmark(BAT** res, BAT *b, oid *base){
	return (*res=BATmark(b, *base))?GDK_SUCCEED:GDK_FAIL;
}
int CMDmark_default(BAT** res, BAT *b){
	oid base = OIDnew(BATcount(b));
	return CMDmark(res, b, &base);
}
int CMDhashsplit(BAT **res, BAT *b, int *nfrag){
	return (*res=BAThashsplit(b, *nfrag, FALSE))?GDK_SUCCEED:GDK_FAIL;
}
int CMDuhashsplit(BAT **res, BAT *b, int *nfrag){
	return (*res=BAThashsplit(b, *nfrag, TRUE))?GDK_SUCCEED:GDK_FAIL;
}
int CMDrangesplit(BAT **res, BAT *b, int *nfrag){
	return (*res=BATrangesplit(b, *nfrag, FALSE))?GDK_SUCCEED:GDK_FAIL;
}
int CMDurangesplit(BAT **res, BAT *b, int *nfrag){
	return (*res=BATrangesplit(b, *nfrag, TRUE))?GDK_SUCCEED:GDK_FAIL;
}

int CMDhistogram_rev(BAT **bn, BAT *b) {
	return CMDhistogram(bn, BATmirror(b));
} 


@- Substring Select
The string pattern matching routine has been added. It should be
dynamically linked.
A simple string matcher is included. It should be refined later on
@c
INLINE int like(x, y, ylen)
char *x, *y;
int ylen;
{
        char *r;
        if (x == (char *)NULL) {
                return 0;
        }
        for (r = x+strlen(x)-ylen; x <= r; x++) {
                int ok = 1;
                char *s = x;
                char *q;
                for (q = y; *q; q++, s++)
                    if (*q != tolower(*s)) {
                        ok = 0; break;
                    }
                if (ok) return 1;
        }
        return 0;
}

int CMDlike(BAT **ret, BAT* b, str s) {
        BAT	*c = BATnew(BAThtype(b), TYPE_str, BATcount(b)/10);
	str	t = GDKstrdup(s);
	BUN	u, v;
	int 	xx, yy=0;

	for(s=t; *s; s++,yy++)
		*s = tolower(*s);
	
	if (b->hvarsized) {
	    BATloopFast(b, u, v, xx) 
		if (like(BUNtvar(b, u), t, yy)) 
		    BUNfastins(c, BUNhvar(b, u), BUNtvar(b, u));
	} else {
	    BATloopFast(b, u, v, xx) 
		if (like(BUNtvar(b, u), t, yy)) 
		    BUNfastins(c, BUNhloc(b, u), BUNtvar(b, u));
	}
	c->hsorted = BAThordered(b);
	c->tsorted = BATtordered(b);
	*ret = c;
	return GDK_SUCCEED;
}

@- BAT slice
@c
int CMDslice(BAT **retval, BAT *b, int *start, int *end){
	return (*retval = BATslice(b, *start, *end))?GDK_SUCCEED:GDK_FAIL;
}

@- BUN Get/Fetch
@c
int CMDposition(int *retval, BAT *b, ptr val){
	ptr p = (b->htype == TYPE_bat)?(ptr) &((BAT*) val)->batCacheid:val;
	ptr v = BUNfnd(b, p);
        if (v == 0) {
                GDKerror("CMDposition: item not found\n");
                return GDK_FAIL;
        }
        *retval = BUNindex(b, v)- BUNindex(b, BUNfirst(b));
        return GDK_SUCCEED;
}
int CMDpositionBUN(int *retval, BAT *b, ptr val, ptr tval){
	ptr p = (b->htype == TYPE_bat)?(ptr) &((BAT*) val)->batCacheid:val;
	ptr o = (b->ttype == TYPE_bat)?(ptr) &((BAT*) tval)->batCacheid:tval;
	ptr v = BUNlocate(b, p,o);
        if (v == 0) {
                GDKerror("CMDposition: item not found\n");
                return GDK_FAIL;
        }
        *retval = BUNindex(b, v)- BUNindex(b, BUNfirst(b));
        return GDK_SUCCEED;
}

int CMDfetchbat(BAT** ret, BAT *b, BAT *s){
	return (*ret = BATfetch(b, s))?GDK_SUCCEED:GDK_FAIL;
}

int CMDfetch(ptr ret, BAT *b, int *pos){
	int i = *pos;
        if ((i < 0) || (i >= BATcount(b))) {
                GDKerror("CMDfetch: idx out of range\n");
                return GDK_FAIL;
        }
        i += BUNindex(b, BUNfirst(b));
	@:putTail(BUNptr(b,i))@
@= putTail
	if (b->theap.base) {
	    ptr _src = b->theap.base + *(int*) BUNtloc(b,@1);
	    int _len = ATOMlen(b->ttype, _src);
	    ptr _dst = GDKmalloc(_len);
	    memcpy(_dst, _src, _len);
	    *(ptr*) ret = _dst;
	} else {
	    int _s = ATOMsize(ATOMtype(b->ttype));
	    if (ATOMvarsized(b->ttype)) {
		memcpy(*(ptr*) ret=GDKmalloc(_s), BUNtloc(b, @1), _s);
	    } else if (b->ttype == TYPE_bat) {
		bat bid = *(int*) BUNtloc(b, @1);
		*(BAT**) ret = BATdescriptor(bid);
		BBPfix(bid);
	    } else if (_s == 4) {
		*(int*) ret = *(int*) BUNtail(b, @1);
	    } else if (_s == 1) {
		*(chr*) ret = *(chr*) BUNtail(b, @1);
	    } else if (_s == 2) {
		*(sht*) ret = *(sht*) BUNtail(b, @1);
	    } else if (_s == 8) {
		*(lng*) ret = *(lng*) BUNtail(b, @1);
	    } else {
		memcpy(ret, BUNtloc(b, @1), _s);
	    }
	}
@c
        return GDK_SUCCEED;
}

int CMDfetchoid(ptr ret, BAT *b, oid *pos){
	int newpos = (int) (*pos - b->hseqbase);
	if (b->hseqbase == oid_nil) {
                GDKerror("CMDfetchoid: void lookup on uninitialized column.\n");
                return GDK_FAIL;
        }
	return CMDfetch(ret, b, &newpos);
}

int CMDexist(bit *ret, BAT* b, ptr val){ 
	ptr p = (b->htype == TYPE_bat)?(ptr) &((BAT*) val)->batCacheid:val;
	BUN q = BUNfnd(b, p);
	*ret = q?1:0;
        return GDK_SUCCEED;
}
int CMDexistBUN(bit *ret, BAT* b, ptr val, ptr tval){ 
	ptr p = (b->htype == TYPE_bat)?(ptr) &((BAT*) val)->batCacheid:val;
	ptr o = (b->ttype == TYPE_bat)?(ptr) &((BAT*) tval)->batCacheid:tval;
	BUN q = BUNlocate(b, p, o);
	*ret = q?1:0;
        return GDK_SUCCEED;
}

int CMDfind(ptr ret, BAT* b, ptr val){ 
	ptr p = (b->htype == TYPE_bat)?(ptr) &((BAT*) val)->batCacheid:val;
	BUN q = BUNfnd(b, p);
	if (q == NULL) {
		GDKerror("CMDfind: value not found.\n");
		return GDK_FAIL;
	}
	@:putTail(q)@
        return GDK_SUCCEED;
}
