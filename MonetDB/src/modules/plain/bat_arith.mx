@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@' 
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@' 
@' The Original Code is the Monet Database System.
@' 
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2004 CWI.
@' All Rights Reserved.
@' 
@' Contributor(s):
@' 		Martin Kersten <Martin.Kersten@cwi.nl>
@' 		Peter Boncz <Peter.Boncz@cwi.nl>
@' 		Niels Nes <Niels.Nes@cwi.nl>
@' 		Stefan Manegold  <Stefan.Manegold@cwi.nl>

@f bat_arith
@t Optimized Multiplexed Basic Arithmetics on BATs
@a S. Manegold, N. Nes 
@v 1.0
@* Introduction

This module provides optimized code-expanded implementations of multiplxed
basic arithmetics ([+],[-],[*],[/],[%]) on void-headed, head-aligned BATs.
Only the standard types sht, int, lng, flt, dbl are supported.

@* Module Definition 
@m
.MODULE bat_arith;

@T
\begin{verbatim}
	signatures
	@1:	sht, int, lng, flt, dbl	arithmetic type
	@2:	+,   -,   *,   /,   %	basic arithmetic operator
	@3:	add, sub, mul, div, mod	basic arithmetic operator name
\end{verbatim}
@= signatures
.OPERATOR (BAT[void,@1]) "[@2]" (BAT[void,@1]) : BAT[void,@1] = batbat_@1_@3;
	"optimized multiplexed @3 ('@2') on head-aligned [void,@1] BATs"
.OPERATOR (@1) "[@2]" (BAT[void,@1]) : BAT[void,@1] = valbat_@1_@3;
	"optimized multiplexed left-scalar @3 ('@2') on [void,@1] BAT"
.OPERATOR (BAT[void,@1]) "[@2]" (@1) : BAT[void,@1] = batval_@1_@3;
	"optimized multiplexed right-scalar @3 ('@2') on [void,@1] BAT"
.OPERATOR (BAT[void,@1]) "[:@2=]" (BAT[void,@1]) : BAT[void,@1] = batbat_@1_@3_inplace;
	"optimized multiplexed in-place @3 (':@2=') on head-aligned [void,@1] BATs (overwrites first operand)"
.OPERATOR (@1) "[:@2=]" (BAT[void,@1]) : BAT[void,@1] = valbat_@1_@3_inplace;
	"optimized multiplexed left-scalar in-place @3 (':@2=') on [void,@1] BAT (overwrites second operand)"
.OPERATOR (BAT[void,@1]) "[:@2=]" (@1) : BAT[void,@1] = batval_@1_@3_inplace;
	"optimized multiplexed right-scalar in-place @3 (':@2=') on [void,@1] BAT (overwrites first operand)"
@m
@:signatures(sht,+,add)@
@:signatures(sht,-,sub)@
@:signatures(sht,*,mul)@
@:signatures(sht,/,div)@
@:signatures(sht,%,mod)@
@:signatures(int,+,add)@
@:signatures(int,-,sub)@
@:signatures(int,*,mul)@
@:signatures(int,/,div)@
@:signatures(int,%,mod)@
@:signatures(lng,+,add)@
@:signatures(lng,-,sub)@
@:signatures(lng,*,mul)@
@:signatures(lng,/,div)@
@:signatures(lng,%,mod)@
@:signatures(flt,+,add)@
@:signatures(flt,-,sub)@
@:signatures(flt,*,mul)@
@:signatures(flt,/,div)@
@:signatures(dbl,+,add)@
@:signatures(dbl,-,sub)@
@:signatures(dbl,*,mul)@
@:signatures(dbl,/,div)@

.END bat_arith;

@* Implementation
@c
#include <gdk.h>
#include <gdk_scanselect.h> /* for type-specific HT_bunfastins_nocheck_noinc(), until they're moved to gdk.mx */
#include "bat_arith.proto.h"

@c
/*	implementation
	@1:	sht, int, lng, flt, dbl	arithmetic type
	@2:	+,   -,   *,   /,   %	basic arithmetic operator
	@3:	add, sub, mul, div, mod	basic arithmetic operator name
*/
@= implementations
int batbat_@1_@3(BAT **ret, BAT *l, BAT *r) {
	REGISTER @1 *bnp;
	BAT *bn;

        ALGODEBUG THRprintf(GDKout, "batbat_@1_@3[@2](l=%s,r=%s);\n",l->batId,r->batId);
 	ERRORcheck((l->htype!=TYPE_void)||(r->htype!=TYPE_void)||(l->hseqbase!=r->hseqbase)||(BATcount(l)!=BATcount(r)),
 	           "batbat_@1_@3: BATs l & r must be void-headed and head-aligned.\n");

	bn = BATnew(TYPE_void, l->ttype, BATcount(l));
	if( bn == NULL) return GDK_FAIL;
	BATseqbase(bn,l->hseqbase);
	bn->tsorted = 0;

	if ((BUNsize(l)==sizeof(@1))&&(BUNsize(r)==sizeof(@1))) {
		REGISTER @1 *lp, *lq, *rp;
		REGISTER int cnt = 4096/(int)sizeof(@1);
		@1* lbuf = GDKmalloc(2*cnt*sizeof(@1));
		@1* rbuf = lbuf+cnt;

		lq = (@1*)BUNtloc(l,BUNlast(l));
		lp = (@1*)BUNtloc(l,BUNfirst(l));
		rp = (@1*)BUNtloc(r,BUNfirst(r));
		bnp = (@1*)BUNtloc(bn,BUNlast(bn));
		for (; lp < lq; lp+=cnt, rp+=cnt) {
			/* 0 <= cnt <= 4096, so cast to int is safe */
			REGISTER int x = (int) (lq - lp < cnt ? lq - lp : cnt);
			REGISTER int y = x*(int)sizeof(@1);
			REGISTER int i;
			memcpy(lbuf,lp,y);
			memcpy(rbuf,rp,y);
			for (i=0; i<x; i++) {
				if ((lbuf[i] != @1_nil) && (rbuf[i] != @1_nil)) {
					*bnp = lbuf[i] @2 rbuf[i];
				} else {
					*bnp = @1_nil;
				}
				bnp++;
			}
		}
	        GDKfree(lbuf);
	} else if ((BUNsize(l)==BUNsize(r))) {
		REGISTER chr *lp, *lq, *rp;
		REGISTER int bs = BUNsize(l);
		REGISTER int sze = (4096/bs)*bs;
		chr* lbuf = GDKmalloc(2*sze);
		chr* rbuf = lbuf+sze;

		lq = (chr*)BUNtloc(l,BUNlast(l));
		lp = (chr*)BUNtloc(l,BUNfirst(l));
		rp = (chr*)BUNtloc(r,BUNfirst(r));
		bnp = (@1*)BUNtloc(bn,BUNlast(bn));
		for (; lp < lq; lp+=sze, rp+=sze) {
			/* 0 <= sze <= 4096, so cast to int is safe */
			REGISTER int z = (int) (lq - lp < sze ? lq - lp : sze);
			REGISTER chr *lbp=lbuf, *lbq=lbuf+z, *rbp=rbuf;
			memcpy(lbuf,lp,z);
			memcpy(rbuf,rp,z);
			for (; lbp < lbq; lbp+=bs, rbp+=bs) {
				if ((*(@1*)lbp != @1_nil) && (*(@1*)rbp != @1_nil)) {
					*bnp = *(@1*)lbp @2 *(@1*)rbp;
				} else {
					*bnp = @1_nil;
				}
				bnp++;
			}
		}
	        GDKfree(lbuf);
	} else {
		REGISTER chr *lp, *lq, *rp;
		REGISTER int ls = BUNsize(l);
		REGISTER int rs = BUNsize(r);

		lq = (chr*)BUNtloc(l,BUNlast(l));
		lp = (chr*)BUNtloc(l,BUNfirst(l));
		rp = (chr*)BUNtloc(r,BUNfirst(r));
		bnp = (@1*)BUNtloc(bn,BUNlast(bn));
		for (; lp < lq; lp+=ls, rp+=rs) {
			if ((*(@1*)lp != @1_nil) && (*(@1*)rp != @1_nil)) {
				*bnp = *(@1*)lp @2 *(@1*)rp;
			} else {
				*bnp = @1_nil;
			}
			bnp++;
		}
	}

        bn->batBuns->free = (BUN)bnp - bn->batBuns->base;
        if (!bn->batDirty) bn->batDirty = TRUE;

        *ret = bn;
        return GDK_SUCCEED;
}
int batbat_@1_@3_inplace(BAT **ret, BAT *l, BAT *r) {
	REGISTER chr *lp, *lq, *rp;
	REGISTER int ls = BUNsize(l);
	REGISTER int rs = BUNsize(r);

        ALGODEBUG THRprintf(GDKout, "batbat_@1_@3_inplace[@2](l=%s,r=%s);\n",l->batId,r->batId);
 	ERRORcheck((l->htype!=TYPE_void)||(r->htype!=TYPE_void)||(l->hseqbase!=r->hseqbase)||(BATcount(l)!=BATcount(r)),
 	           "batbat_@1_@3_inplace: BATs l & r must be void-headed and head-aligned.\n");

	l->tsorted = 0;
	lq = (chr*)BUNtloc(l,BUNlast(l));
	lp = (chr*)BUNtloc(l,BUNfirst(l));
	rp = (chr*)BUNtloc(r,BUNfirst(r));
	for (; lp < lq; lp+=ls, rp+=rs) {
		if ((*(@1*)lp != @1_nil) && (*(@1*)rp != @1_nil)) {
			*(@1*)lp @2= *(@1*)rp;
		} else {
			*(@1*)lp = @1_nil;
		}
	}
        if (!l->batDirty) l->batDirty = TRUE;

	BBPfix(l->batCacheid);
        *ret = l;
        return GDK_SUCCEED;
}
int valbat_@1_@3(BAT **ret, @1 *v, BAT *b) {
	REGISTER chr *bp, *bq;
	REGISTER @1 *bnp;
	REGISTER @1 vv = (((*v)!=@1_nil)?(*v):@1_nil);
	REGISTER int bs = BUNsize(b);
	BAT *bn;

        ALGODEBUG THRprintf(GDKout, "valbat_@1_@3[@2](v,b=%s);\n",b->batId);
 	ERRORcheck((b->htype!=TYPE_void),
 	           "valbat_@1_@3: BAT b must be void-headed.\n");
	/* todo for commutative operators call batval (ie. for * and /) */

	bn = BATnew(TYPE_void, b->ttype, BATcount(b));
	if( bn == NULL) return GDK_FAIL;
	BATseqbase(bn,b->hseqbase);
	bn->tsorted = 0;
	bq = (chr*)BUNtloc(b,BUNlast(b));
	bp = (chr*)BUNtloc(b,BUNfirst(b));
	bnp = (@1*)BUNtloc(bn,BUNlast(bn));
	if (vv != @1_nil) {
		for (; bp < bq; bp+=bs) {
			REGISTER @1 bv = *(@1*)bp;
			if (bv != @1_nil) {
				bv = vv @2 bv;
			}
			*bnp = bv;
			bnp++;
		}
	} else {
		for (; bp < bq; bp+=bs) {
			*bnp = vv;
			bnp++;
		}
	}
        bn->batBuns->free = (BUN)bnp - bn->batBuns->base;
        if (!bn->batDirty) bn->batDirty = TRUE;

        *ret = bn;
        return GDK_SUCCEED;
}
int valbat_@1_@3_inplace(BAT **ret, @1 *v, BAT *b) {
	REGISTER chr *bp, *bq;
	REGISTER @1 vv = (((*v)!=@1_nil)?(*v):@1_nil);
	REGISTER int bs = BUNsize(b);

        ALGODEBUG THRprintf(GDKout, "valbat_@1_@3_inplace[@2](v,b=%s);\n",b->batId);
 	ERRORcheck((b->htype!=TYPE_void),
 	           "valbat_@1_@3_inplace: BAT b must be void-headed.\n");
	/* todo for commutative operators call batval (ie. for * and /) */

	b->tsorted = 0;
	bq = (chr*)BUNtloc(b,BUNlast(b));
	bp = (chr*)BUNtloc(b,BUNfirst(b));
	if (vv != @1_nil) {
		for (; bp < bq; bp+=bs) {
			if (*(@1*)bp != @1_nil) {
				*(@1*)bp = vv @2 *(@1*)bp;
			}
		}
	} else {
		for (; bp < bq; bp+=bs) {
			*(@1*)bp = vv;
		}
	}
        if (!b->batDirty) b->batDirty = TRUE;

	BBPfix(b->batCacheid);
        *ret = b;
        return GDK_SUCCEED;
}
int batval_@1_@3(BAT **ret, BAT *b, @1 *v) {
	REGISTER chr *bp, *bq;
	REGISTER @1 *bnp;
	REGISTER @1 vv = (((*v)!=@1_nil)?(*v):@1_nil);
	REGISTER int bs = BUNsize(b);
	BAT *bn;

        ALGODEBUG THRprintf(GDKout, "batval_@1_@3[@2](v,b=%s);\n",b->batId);
 	ERRORcheck((b->htype!=TYPE_void),
 	           "batval_@1_@3: BAT b must be void-headed.\n");

	bn = BATnew(TYPE_void, b->ttype, BATcount(b));
	if( bn == NULL) return GDK_FAIL;
	BATseqbase(bn,b->hseqbase);
	bn->tsorted = 0;
	bq = (chr*)BUNtloc(b,BUNlast(b));
	bp = (chr*)BUNtloc(b,BUNfirst(b));
	bnp = (@1*)BUNtloc(bn,BUNlast(bn));
	if (vv != @1_nil) {
		for (; bp < bq; bp+=bs) {
			REGISTER @1 bv = *(@1*)bp;
			if (bv != @1_nil) {
				bv @2= vv;
			}
			*bnp = bv;
			bnp++;
		}
	} else {
		for (; bp < bq; bp+=bs) {
			*bnp = vv;
			bnp++;
		}
	}
        bn->batBuns->free = (BUN)bnp - bn->batBuns->base;
        if (!bn->batDirty) bn->batDirty = TRUE;

        *ret = bn;
        return GDK_SUCCEED;
}
int batval_@1_@3_inplace(BAT **ret, BAT *b, @1 *v) {
	REGISTER chr *bp, *bq;
	REGISTER @1 vv = (((*v)!=@1_nil)?(*v):@1_nil);
	REGISTER int bs = BUNsize(b);

        ALGODEBUG THRprintf(GDKout, "batval_@1_@3_inplace[@2](v,b=%s);\n",b->batId);
 	ERRORcheck((b->htype!=TYPE_void),
 	           "batval_@1_@3_inplace: BAT b must be void-headed.\n");

	b->tsorted = 0;
	bq = (chr*)BUNtloc(b,BUNlast(b));
	bp = (chr*)BUNtloc(b,BUNfirst(b));
	if (vv != @1_nil) {
		for (; bp < bq; bp+=bs) {
			if (*(@1*)bp != @1_nil) {
				*(@1*)bp @2= vv;
			}
		}
	} else {
		for (; bp < bq; bp+=bs) {
			*(@1*)bp = vv;
		}
	}
        if (!b->batDirty) b->batDirty = TRUE;

	BBPfix(b->batCacheid);
        *ret = b;
        return GDK_SUCCEED;
}
@c
@:implementations(sht,+,add)@
@:implementations(sht,-,sub)@
@:implementations(sht,*,mul)@
@:implementations(sht,/,div)@
@:implementations(sht,%,mod)@
@:implementations(int,+,add)@
@:implementations(int,-,sub)@
@:implementations(int,*,mul)@
@:implementations(int,/,div)@
@:implementations(int,%,mod)@
@:implementations(lng,+,add)@
@:implementations(lng,-,sub)@
@:implementations(lng,*,mul)@
@:implementations(lng,/,div)@
@:implementations(lng,%,mod)@
@:implementations(flt,+,add)@
@:implementations(flt,-,sub)@
@:implementations(flt,*,mul)@
@:implementations(flt,/,div)@
@:implementations(dbl,+,add)@
@:implementations(dbl,-,sub)@
@:implementations(dbl,*,mul)@
@:implementations(dbl,/,div)@

