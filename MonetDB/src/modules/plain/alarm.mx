@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@' 
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@' 
@' The Original Code is the Monet Database System.
@' 
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2003 CWI.
@' All Rights Reserved.
@' 
@' Contributor(s):
@' 		Martin Kersten <Martin.Kersten@cwi.nl>
@' 		Peter Boncz <Peter.Boncz@cwi.nl>
@' 		Niels Nes <Niels.Nes@cwi.nl>
@' 		Stefan Manegold  <Stefan.Manegold@cwi.nl>

@f alarm
@a M.L. Kersten, P. Boncz
@t Timers and Timed Interrupts

@* Introduction
@T
This module handles various signalling/timer functionalities.
The Monet interface supports two timer commands: {\tt alarm} and {\tt sleep}.
Their argument is the number of seconds to wait before the timer goes off. 
The {\tt sleep} command blocks till the alram goes off.
The {\tt alarm} command continues dfirectly, executes off a MIL
string when it goes off.
The parameterless routines {\tt time} and {\tt ctime} provide access to
the cpu clock.They return an integer and string, respectively.

@* Module Definition
@m
.MODULE alarm;

.COMMAND sleep(int secs) = CMDsleep; "sleep X secs"
.COMMAND alarm(int secs, str action) = CMDalarm; "execute action in X secs"
.COMMAND timers() : BAT[str,str] = CMDtimers; "give a list of all active timers"
.COMMAND time() : int = CMDtime; "time in millisecs"
.COMMAND epoch() : int = CMDepoch; "current time as unix epoch"
.COMMAND ctime() : str = CMDctime; "current time as a string"

.PRELUDE = CLKprelude;
.EPILOGUE = CLKepilogue;

.END alarm;

@{
@* Implementation
@+ The Clock Interupt Generator
A clock event generator, called @%timer@, has been added to the database kernel.
It accepts a message @%CLKalarm(sec, usec)@, which generates an alarm
after the time indicated.
The timer maintains a small stack of timing events sorted in priority of firing.
The top contains the next timer event to go off.
The timer is disabled when no timer events are outstanding.
@h
#include <monet.h> 
# include <signal.h> 
#define MAXtimer                200

typedef struct {
	str action;	/* MIL action (as a string) */
	MT_Sema sema;	/* barrier */
	int alarm_time;	/* time when the alarm goes off */
} monet_timer_t;

@c
#include "alarm.h"
#include "alarm.proto.h"

static monet_timer_t            timer[MAXtimer]; 
static int                      timerTop = 0; 
@
@- 
The timer is awakened by a clock interrupt. The interrupt granularity 
is OS-dependent. The timer should be initialized as long as there
are outstanding timer events.
@c
#ifdef SIGALRM
void CLKinitTimer(int sec, int usec){
	int i = sec - time(0);
	(void) usec;
	TRGDEBUG THRprintf(GDKerr, "CLKinitTimer: set timer to %d secs \n", i); 
        alarm(i);
}
#endif
@- 
A new alarm is pushed onto the stack using @%CLKalarm@.
The parameter is the real-time value to be approximated.
@c
#ifdef SIGALRM
MT_Sema CLKalarm(int t, str action){
        int     j;
        int     k; 
 
	TRGDEBUG THRprintf(GDKerr, "CLKalarm: push %d \n", t); 
        if (timerTop == MAXtimer) {
                GDKerror("CLKalarm: timer stack overflow\n"); 
                return 0; 
        }
        for (j = 0; j < timerTop; j++) {
                if (timer[j].alarm_time > t) break; 
        }
        for (k = timerTop; k > j; k--) {
                timer[k] = timer[k-1]; 
        }
        timer[k].alarm_time = t; 
	if (action) {
		timer[k].action = GDKstrdup(action);
	} else {
        	timer[k].action = 0;
        	timer[k].sema = MT_create_sema(0);
	}
        if (k == timerTop++) {
                CLKinitTimer(t, 0); /* set it sooner */ 
        }
        return timer[k].sema; 
}
#endif
@- 
Once a timer interrupt occurs, we should inspect the timer queue and
emit a notify signal.
@c
#ifdef SIGALRM
static RETSIGTYPE CLKsignal(int nr){
	int restype;
	int k=timerTop;
        int t; 
	(void) nr;
 
	if (signal(SIGALRM, CLKsignal) == SIG_ERR) {
		GDKsyserror("CLKsignal: call failed\n");
	}
	TRGDEBUG THRprintf(GDKerr, "alarm signal (timeTop=%d)\n", timerTop); 
        if (timerTop == 0) {
                return; 
        }
        t = time(0); 
        while (k-- && t >= timer[k].alarm_time){
	    if (timer[k].action) {
		TRGDEBUG THRprintf(GDKerr, "eval(%s)\n", timer[k].action); 
		monet_eval(timer[k].action,&restype);
		GDKfree(timer[k].action);
	    } else {
		MT_up_sema(timer[k].sema, "CLKsignal");
	    }
	    timerTop--;
        }
        if (timerTop > 0) {
                CLKinitTimer(timer[timerTop-1].alarm_time, 0); 
        }
}
#endif

bat* CLKprelude(void){
#ifdef SIGALRM
        (void) signal(SIGALRM, CLKsignal);
#endif
	return NULL;
}

void CLKepilogue(void){
	int k;
#ifdef SIGALRM
#if !(defined(LINUX) || defined(WIN32) || defined(CYGWIN32) || defined(__MACH__))
	(void) signal(SIGALRM, SIG_IGN);
#endif
#endif
	for (k = 0; k < timerTop; k++) {
		if (timer[k].action) GDKfree(timer[k].action);
	}
}


int CMDsleep(int *secs){

        if (*secs < 0) {
                GDKerror("sleep: negative delay\n");
        	return GDK_FAIL;
        } else {
		MT_sleep_ms(*secs*1000);
/*
		MT_Sema s = CLKalarm(*secs+time(0), 0);
		(void)CLKprelude();
                MT_down_sema(s, "CLKsleep"); */ /* block on this */
/*
		MT_destroy_sema(s);
*/
        }
        return GDK_SUCCEED;
}
 
int CMDalarm(int *secs, str action){
        if (*secs < 0) {
                GDKerror("alarm: negative delay\n");
        	return GDK_FAIL;
        } else {
#ifndef SIGALRM
		GDKerror("alarm: not implemented\n");
		return GDK_FAIL;
#else
                (void) CLKalarm(*secs+time(0), action);
#endif
        }
        return GDK_SUCCEED;
}
@-
Problem with CMDtimers is that they use static buffers that
may be overwritten under parallel processing.
Therefore, the code below is dangerous (!) and the re-entrant code
should be used. 
@c
int CMDtimers(BAT **retval) {
	char buf[27];
	int k;
	*retval = BATnew(TYPE_str, TYPE_str, timerTop);
	BATroles(*retval, "alarm", "action");
	for (k = 0; k < timerTop; k++) {
#ifdef HAVE_CTIME_R3
		ctime_r((time_t *) &timer[k].alarm_time,buf,26); 
#else
#ifdef HAVE_CTIME_R
		ctime_r((time_t *) &timer[k].alarm_time,buf); 
#else
		ctime((time_t *) &timer[k].alarm_time); 
#endif
#endif
		if( buf)
		BUNins(*retval, buf, 
			timer[k].action? timer[k].action:"barrier");
        }
	return GDK_SUCCEED;
}

int CMDctime(str *retval){
	time_t t = time(0);
#ifdef HAVE_CTIME_R3
	char buf[128];
	*retval = GDKstrdup((char*)ctime_r(&t, buf, 26));
#else
#ifdef HAVE_CTIME_R
	char buf[128];
	*retval = GDKstrdup((char*)ctime_r(&t, buf));
#else
	*retval = GDKstrdup((char*)ctime(&t));
#endif
#endif
	return GDK_SUCCEED;
}

int CMDepoch(int *retval) {
	*retval = time(0);
	return GDK_SUCCEED;
}

int CMDtime(int *retval){
	*retval = GDKms();
	return GDK_SUCCEED;
}
@}
