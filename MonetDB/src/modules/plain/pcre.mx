@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2004 CWI.
@' All Rights Reserved.
@f pcre
@a N. Nes
@t PCRE - Perl-compatible regular expressions
@v 0.1
@T
       The  PCRE library is a set of functions that implement regular expres-
       sion pattern matching using the same syntax  and  semantics  as  Perl,
       with  just  a  few  differences.  The  current  implementation of PCRE
       (release 4.x) corresponds approximately with Perl 5.8, including  sup-
       port  for  UTF-8  encoded  strings.   However,  this support has to be
       explicitly enabled; it is not the default.

\begin{center}
       ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre
\end{center}

@+ Module Definition
@m
.MODULE pcre;

.ATOM pcre;
      .TOSTR   = pcre_tostr;
      .FROMSTR = pcre_fromstr;
      .NEQUAL  = pcre_nequal;
      .HASH    = pcre_hash;
      .NULL    = pcre_null;
      .PUT     = pcre_put;
      .DEL     = pcre_del;
      .LENGTH  = pcre_length;
      .HEAP    = pcre_heap;
.END;

.COMMAND pcre_compile(str pattern) : pcre = pcre_compile_wrap;
   "compile a pattern"

.COMMAND pcre_match(pcre pattern, str s) : bit = pcre_exec_wrap;
   "match a pattern"

.COMMAND pcre_select(str pattern, BAT[any::1,str] strs) : BAT[any::1,str] = pcre_select;
   "Select tuples based on the pattern"

.COMMAND pcre_uselect(str pattern, BAT[any::1,str] strs) : BAT[any::1,void] = pcre_uselect;
   "Select tuples based on the pattern, only returning the head"

.PRELUDE  = pcre_init;
.EPILOGUE = pcre_exit;

.END pcre;

@+ Implementation
@c

#include <monetdb_config.h>

#ifndef HAVE_LIBPCRE

#define pcre str

int pcre_compile_wrap( pcre** res, str pattern) { (void)res; (void)pattern; }
int pcre_exec_wrap( bit* res, pcre *pattern, str s) { (void)res; (void)pattern; (void)s; }
int pcre_select( BAT **res, str *pattern, BAT *strs ) { (void)res, (void)pattern; (void)strs; }
int pcre_uselect( BAT **res, str *pattern, BAT *strs ) { (void)res, (void)pattern; (void)strs; }

bat* pcre_init(void){ return NULL; }
void pcre_exit(void){ }

#else

#include <pcre/pcre.h>
#include "pcre.proto.h"

#define m2p(p) (pcre*)(((sht*)p)+1)
#define p2m(p) (pcre*)(((sht*)p)-1)

void *my_pcre_malloc( size_t s ) {
	char *r = GDKmalloc(s+sizeof(sht));
	sht *sz = (sht*)r;

	*sz = s+sizeof(sht);
	return (void*)(sz+1);
}

void my_pcre_free( void *blk ) {
	sht *sz = (sht*)blk;
	sz -= 1;
	GDKfree((void*)sz);
}

int pcre_compile_wrap( pcre** res, str pattern)
{
	pcre *r;
	const char err[BUFSIZ], *err_p = err;
	int errpos = 0;

	if ( (r = pcre_compile( pattern, PCRE_UTF8, &err_p, &errpos, NULL)) == NULL) {
		return GDK_FAIL;
	}
	*(pcre**) res = p2m(r);
	return GDK_SUCCEED;
}

int pcre_exec_wrap( bit* res, pcre *pattern, str s) { 
       	if (pcre_exec( m2p(pattern), NULL, s, strlen(s), 0, 0, NULL, 0) >= 0){
		*res = TRUE; 
	} else {
		*res = FALSE; 
	}
	return GDK_SUCCEED;
}

int pcre_select( BAT **res, str pattern, BAT *strs ) {
	const char err[BUFSIZ], *err_p = err;
	int errpos = 0;
	BAT *r = BATnew( strs->htype, TYPE_str, BATcount(strs));
	BUN p,q;
	pcre *re = NULL;

	if ( (re = pcre_compile( pattern, PCRE_UTF8, &err_p, &errpos, NULL)) == NULL) {
		GDKerror("pcre_select: pcre compile failed\n");
		return GDK_FAIL;
	}
	BATloop(strs, p, q) {
		str s = BUNtail(strs, p);
       		if (pcre_exec( re, NULL, s, strlen(s), 0, 0, NULL, 0) >= 0){
			BUNins(r, BUNhead(strs, p), s);
		}
	}
	*res = r;
	return GDK_SUCCEED;
}

int pcre_uselect( BAT **res, str pattern, BAT *strs ) {
	const char err[BUFSIZ], *err_p = err;
	int errpos = 0;
	BAT *r = BATnew( strs->htype, TYPE_void, BATcount(strs));
	BUN p,q;
	pcre *re = NULL;

	if ( (re = pcre_compile( pattern, PCRE_UTF8, &err_p, &errpos, NULL)) == NULL) {
		GDKerror("pcre_select: pcre compile failed\n");
		return GDK_FAIL;
	}
	BATloop(strs, p, q) {
		str s = BUNtail(strs, p);
       		if (pcre_exec( re, NULL, s, strlen(s), 0, 0, NULL, 0) >= 0){
			BUNins(r, BUNhead(strs, p), NULL);
		}
	}
	*res = r;
	return GDK_SUCCEED;
}

bat* pcre_init(void){
	pcre_malloc = &my_pcre_malloc;
	pcre_free = &my_pcre_free;
	return NULL;
}
void pcre_exit(void){ }
#endif

int pcre_tostr(str* tostr,int* l,pcre* p) {
	(void)tostr;
	(void)l;
	(void)p;
	return GDK_FAIL;
}
int pcre_fromstr(str instr,int* l,pcre** val) {
	(void)l;
	return pcre_compile_wrap(val, instr);
}
int pcre_nequal(pcre* l,pcre*  r) {
	if (l != r)
		return 0;
	else
		return 1;
}

hash_t pcre_hash(pcre* b)
{
   return *(sht*)b;
}

pcre* pcre_null(void)
{
   static sht nullval, *r;
   nullval = ~(sht)0;
   r = &nullval;
   return((pcre*)(r));
}

void pcre_del(Heap* h,var_t* index)
{
   HEAP_free(h, *index);
}

#define pcresize(val) ((sht*)val)[0]

var_t pcre_put(Heap* h,var_t* bun,pcre* val)
{
   char* base;

   *bun = HEAP_malloc(h,pcresize(val));
   base = h->base;
   if (*bun) memcpy(&base[*bun],(char *)val,pcresize(val));
   return *bun;
}

int pcre_length(pcre* p)
{
   return(pcresize(p));
}

void pcre_heap(Heap* heap, size_t capacity)
{
   HEAP_initialize(heap,capacity,0,(int)sizeof(var_t));
}
