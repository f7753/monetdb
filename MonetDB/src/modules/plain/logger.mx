@f logger
@t Transactions
@a N. J. Nes
@v 1.0
@T
@* Introduction
In the philosophy of Monet, transaction management overhead should only
be paid when necessary. Transaction management is for this purpose 
implemented as a module. This module, once loaded, takes care of writing
the commited changes, to a transaction log. The log may reside on the
same system and therefor the writes are done to disk but could also
reside on an other system and then the changes are flushed through
the network.  
The main interface to this logging system is the commit call which
writes all the delta to the log file. Each bat in Monet keeps track 
of the changes using the delta management. On commit these changes are
writen to the log file. The delta management set for new changes.
Since each commit is writen to the same log file, the beginning and
end are marked by a log identifier. A server restart should only (re)process
blocks which are completely writen to disk. The start marker consists of
a LOG_BEGINBLOCK,logid,length-of-block-between-markers. The end marker
is just LOG_ENDBLOCK,logid.

TODO
	handel bbp updates ??
	convertion between big/little endian
	
@* Module Definition
@m
.MODULE logger;

@- global transaction management
@m
.COMMAND backuphost(str host, int port) = logger_backuphost;
	"Use the host,port to backup changes to"
.COMMAND backupfile(str log ) = logger_backupfile;
	"Backup to the file log and write the log identifier to the file logid"

.COMMAND commit() = logger_commit;
	"commit on all BATs to the log"

.COMMAND update() = logger_update;
	"update the all BATs using the log"

.COMMAND logger_debug( int level ) = logger_set_debug;
	"Set the level of debuging"

.EPILOGUE = logger_end;

.END logger;
@{
@* Implementation Code 
@c
#include <gdk.h>
#include <sys/stat.h>

#define LOG_BLOCKBEGIN 	0
#define LOG_BLOCKEND    1
#define LOG_INSERT 	2
#define LOG_DELETE	3

int   logger_debug = 0;

char *logger_host = NULL;
int   logger_port = 0;

static char *logger_log 	= NULL;
static FILE *logger_fp 		= NULL;
static int   logger_logid 	= 0;

int logger_backuphost(str host, int *port){
	if (logger_debug&1)
		fprintf(stderr, "logger_backuphost %s %d\n", host, *port );

	logger_host = GDKstrdup(host);
	logger_port = *port;
	return GDK_SUCCEED; 
}

int logger_backupfile(str log){
	if (logger_debug&1)
		fprintf(stderr, "logger_backupfile %s\n", log );

	logger_log = GDKstrdup(log);

	if (logger_fp) 
		fclose(logger_fp);

	logger_fp = fopen(logger_log,"a"); /* append */

	if (logger_fp) 
		return GDK_SUCCEED; 
	else 
		return GDK_FAIL;
}

static int sz = 0;

int logger_end(){
	if (logger_debug&64)
		fprintf(stderr, "logger_end %d\n", sz);

	if (logger_fp)
		fclose(logger_fp);
	return GDK_SUCCEED;
}

typedef struct logf {
	char flag;
	int id;
	int nr; /* not used by block (begin/end) */
} logf;

void logger_bat(BAT *b){
	if (logger_debug&2 && 
	    (b->batInserted < BUNlast(b) || b->batDeleted < b->batHole))
		fprintf(stderr, "logger_bat %s\n", b->batId);

	if (logger_fp){
		logf 	l;
		BUN	p; 

		l.flag = LOG_INSERT;
		l.nr = BUNindex(b, BUNlast(b)) - BUNindex(b, b->batInserted);
		if (l.nr){
		    l.id = b->batCacheid;
		    fwrite(&l, sizeof(logf), 1, logger_fp);
		    for (p = b->batInserted; p < BUNlast(b); p = BUNnext(b, p)){
			int s1,s2;
			ptr h = BUNhead(b,p);
			ptr t = BUNtail(b,p);
			fwrite(h, s1=ATOMlen(b->htype,h),1,logger_fp);
			fwrite(t, s2=ATOMlen(b->ttype,t),1,logger_fp);
			sz += (s1+s2);
		    }
		}
		l.flag = LOG_DELETE;
		l.nr = BUNindex(b, b->batHole) - BUNindex(b, b->batDeleted);
		if (l.nr){
		    l.id = b->batCacheid;
		    printf("%d del %d\n", l.id, l.nr );
		    fwrite(&l, sizeof(logf), 1, logger_fp);
		    for (p = b->batDeleted; p < b->batHole; p = BUNnext(b, p)){
			int s1,s2;
			ptr h = BUNhead(b,p);
			ptr t = BUNtail(b,p);
			fwrite(h, s1=ATOMlen(b->htype,h),1,logger_fp);
			fwrite(t, s2=ATOMlen(b->ttype,t),1,logger_fp);
			sz += (s1+s2);
		    }
		}
	}
}

static BAT *dirty_bat(int i) {
	if (logger_debug&4)
		fprintf(stderr, "dirty_bat %d\n", i);

	if (BBP_logical(i)) {
		BAT *b;
		BBPspin(i, "dirty_bat");
		b = BBP_cache(i);
		if (b != NULL) {
			if ((b->batPersistence&PERSISTENT) && BATdirty(b)) {
				return b; /* the bat is loaded, persistent and dirty */
			}
		} else if (BBP_status(i)&BBPSWAPPED) { 
		  	b = (BAT*) BBPquickdesc(i, TRUE);
			if (b && b->batDirtydesc) {
				return b; /* only the desc is loaded & dirty */
			}
		}
	}
	return NULL;
}

int logger_commit(){
	int  i; 
	logf l;
	/* first build the buffer with data to write
         * then write to file, host
         */
	if (logger_debug&1)
		fprintf(stderr, "logger_commit\n");

	l.flag = LOG_BLOCKBEGIN;
	l.id = logger_logid;
	l.nr = 0;

	BBPlock("logger_commit");
	fwrite(&l, sizeof(logf), 1, logger_fp);
	for (i = 1; i < BBPsize; i++) {
		BAT *b = dirty_bat(i);
		if (b) logger_bat(b); 
	}
	l.flag = LOG_BLOCKEND;
	fwrite(&l, sizeof(logf), 1, logger_fp);
	fflush(logger_fp);

	for (i = 1; i < BBPsize; i++) {
		BAT *b = dirty_bat(i);
		if (b) BATfakeCommit(b); 
	}
	BBPunlock("logger_commit");

	return GDK_SUCCEED; 
}

int logger_update() { 
	/* first try the file */
	/* else get it from the backup server. */
	int i;
	int curlogid = 0; 
	struct stat st;
	char *buf, *p, *end;

	if (logger_debug&1)
		fprintf(stderr, "logger_update\n");

	if (logger_fp) 
		fclose(logger_fp);
	logger_fp = fopen(logger_log,"r+"); 
	fstat(fileno(logger_fp),&st);
	buf = p = GDKmalloc(st.st_size);
	fread(p, st.st_size, 1, logger_fp);
	end = p + st.st_size;

/*	BBPlock("logger_commit"); */
	while(p<end){
		logf l;
		BAT *b;

		memcpy(&l, p, sizeof(logf)); p += sizeof(logf);
		if (l.flag == LOG_BLOCKBEGIN){
			curlogid = l.id;
		} else if (l.flag == LOG_BLOCKEND ){
			if (l.id != curlogid){
		    		fprintf(stderr, 
				  "BLOCKEND does not match begin, %d != %d\n",
				  l.id, curlogid);
				break;
			}
		} else { 
			b = BATdescriptor(l.id); 
			if (b){
				for(; l.nr>0 && p<end; l.nr--){
					int s1 = ATOMlen(b->htype, p);
					int s2 = ATOMlen(b->ttype, p+s1);
					if (l.flag == LOG_INSERT)
						BUNins( b, p, p+s1 );
					else
					if (l.flag == LOG_DELETE)
						BUNdel( b, p, p+s1 );
					p += s1;
					p += s2;
		    		}
			} else {
				fprintf(stderr,"bat missing %d\n", l.id);
			}
		}
	}
	logger_logid = curlogid;
	for (i = 1; i < BBPsize; i++) {
		BAT *b = dirty_bat(i);
		if (b) BATfakeCommit(b); 
	}
/*	BBPunlock("logger_commit"); */

	if (buf) GDKfree(buf);
	return GDK_SUCCEED; 
}


int logger_set_debug( int *l){
	logger_debug = *l;
	return GDK_SUCCEED; 
}
@}

@mil
module(alarm);

proc pbat(name, acc) := {
        b := new(void,int);
        b.seqbase(oid(0));
        b.rename(name);
        b.persists(true);
        if (int(acc) >= 0){
                b.reverse.accbuild(acc);
        }
        return b;
}

proc logger_create() := {
	b0 := pbat("b0",-1);
	b1 := pbat("b1",hash);
	b2 := pbat("b2",index);

	b0.count.print;
	b1.count.print;
	b2.count.print;
	commit;
}

proc logger_insert(bit useLogger) := {
	if (useLogger){
		module("logger");

		logger_debug(64);
		backupfile("/tmp/logger.log");
	}

	t0 := time();
	var i := 0;
	while (i < 50000){
		i += 1;
	}
	t := time(); print(t-t0); t0 := t;
	
	i := 0;
	while (i < 50000){
		b0.insert(nil,i);
		i += 1;
	}
	commit;

	t := time(); print(t-t0); t0 := t;
	i := 0;
	while (i < 50000){
		b0.insert(nil,i);
		commit;
		i += 1;
	}

	t := time(); print(t-t0); t0 := t;
	i := 0;
	while (i < 50000){
		b1.insert(nil,i);
		i += 1;
	}
	commit;
	
	t := time(); print(t-t0); t0 := t;
	i := 0;
	while (i < 50000){
		b1.insert(nil,i);
		commit;
		i += 1;
	}
	
	t := time(); print(t-t0); t0 := t;
	i := 0;
	while (i < 50000){
		b2.insert(nil,i);
		i += 1;
	}
	commit;
	
	t := time(); print(t-t0); t0 := t;
	i := 0;
	while (i < 50000){
		b2.insert(nil,i);
		commit;
		i += 1;
	}
	t := time(); print(t-t0); t0 := t;

	b0.count.print;
	b1.count.print;
	b2.count.print;
}

proc logger_update() := {
	module("logger");

	logger_debug(1);
	backupfile("/tmp/logger.log");
	
	t0 := time();
	update();
	t := time(); print(t-t0); t0 := t;

	b0.count.print;
	b1.count.print;
	b2.count.print;
}

@sh
#!/bin/sh

rm /tmp/logger.log
Mdestroydb -db logger
Mcreatedb -db logger -user $USER

Mserver -db logger -prelude logger.mil << EOF
logger_create;
quit;
EOF

Mserver -db logger -prelude logger.mil << EOF
logger_insert(true);
quit;
EOF

Mserver -db logger -prelude logger.mil << EOF
logger_update;
quit;
EOF

# now with out logger
Mserver -db logger -prelude logger.mil << EOF
logger_insert(false);
quit;
EOF
