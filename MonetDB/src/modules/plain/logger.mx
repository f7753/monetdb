@f logger
@t Transactions
@a N. J. Nes
@v 1.0
@T
@* Introduction
In the philosophy of Monet, transaction management overhead should only
be paid when necessary. Transaction management is for this purpose 
implemented as a module. This module, once loaded, takes care of writing
the commited changes, to a transaction log. The log may reside on the
same system and therefor the writes are done to disk but could also
reside on an other system and then the changes are flushed through
the network.  

The main interface to this logging system is the commit call which
writes all the delta to the log file. Each bat in Monet keeps track 
of the changes using the delta management. On commit these changes are
writen to the log file and the delta management is reset. Since each 
commit is writen to the same log file, the beginning and end are 
marked by a log identifier. A server restart should only (re)process
blocks which are completely writen to disk. The start marker consists of
a LOG_BEGINBLOCK,logid,length-of-block-between-markers. The end marker
is just LOG_ENDBLOCK,logid.

TODO
	handel bbp updates ??
	convertion between big/little endian
	
@* Module Definition
@m
.MODULE logger;

@- global transaction management
@m
.COMMAND backuphost(str host, int port) = logger_backuphost;
	"Use the host,port to backup changes to"

.COMMAND logger_listen(int port ) = logger_listen;
	"listens for a client willing to backup to this port"

.COMMAND backupfile(str log ) = logger_backupfile;
	"Backup to the file log and write the log identifier to the file logid"

.COMMAND commit() = logger_commit;
	"commit on all BATs to the log"

.COMMAND update() = logger_update;
	"update the all BATs using the log, TODO only needed at initialisation"

.COMMAND logger_debug( int level ) = logger_set_debug;
	"Set the level of debuging"

.EPILOGUE = logger_end;

.END logger;
@{
@* Implementation Code 
@c
#include <gdk.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <sys/socket.h>

#define LOG_BLOCKBEGIN 	0
#define LOG_BLOCKEND    1
#define LOG_INSERT 	2
#define LOG_DELETE	3
#define LOG_CREATE 	4
#define LOG_DESTROY	5
#define LOG_RENAME	6

static int   logger_debug = 0;

static char *logger_host = NULL;
static int   logger_port = 0;
static int   logger_server = 0;

static char *logger_log 	= NULL;
static FILE *logger_fp 		= NULL;
static int   logger_logid 	= 0;

int logger_backuphost(str host, int *port){
	struct sockaddr_in a;
	struct hostent *hp;
	struct sockaddr *addr = (struct sockaddr *) &a;
 	int fd, len = sizeof(a);

	if (logger_debug&1)
		fprintf(stderr, "logger_backuphost %s %d\n", host, *port );

	logger_host = GDKstrdup(host);
	logger_port = *port;

	memset(&a, 0, sizeof(a));
	a.sin_family = AF_INET;
	a.sin_port = htons((unsigned short)(*port&0xFFFF));
	if (!(hp = gethostbyname(host))){
	    GDKsyserror("backuphost(%s:d): lookup error.\n", host, *port);
	    return GDK_FAIL;
	}
	memcpy(&a.sin_addr, hp->h_addr, hp->h_length);
	if ((fd = socket(PF_INET, SOCK_STREAM, 0)) < 0) {
	    GDKsyserror("backuphost(%s:%d): could not create socket.\n",host,*port);
	} else if (connect(fd, addr, len)) {
	    GDKsyserror("backuphost(%s:%d): could not connect with.\n", host,*port);
	} else {
	    logger_fp = fdopen(fd, "w");
	}
	return GDK_SUCCEED; 
}

/* server just reading in the request and does a true commit once 
 * every ... time 
 */
#define SOCKPTR struct sockaddr *

int logger_listen(int *port){
	
	struct sockaddr_in server;
	int 	sock;
#ifdef AIX
	size_t 	length;
#else
	int 	length;
#endif
	int    	on = 1;
	int 	msgsock;
	int	i = 0;

	logger_server = 1; /* resets commit back to TMcommit */

	sock = socket(AF_INET, SOCK_STREAM, 0);
	if (sock < 0) {
		GDKsyserror("creation of stream socket failed\n");
		return GDK_FAIL;
	}
	server.sin_family = AF_INET;
	server.sin_addr.s_addr = INADDR_ANY;
	server.sin_port = htons((unsigned short)((*port)&0xFFFF));
   	for (i=0;i<8;i++)
	    server.sin_zero[i]=0;
 
	setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, (char*) &on, sizeof on);

	length = sizeof(server);
	if (bind(sock, (SOCKPTR)&server, length) < 0) {
		GDKsyserror("binding to stream socket (%s) failed\n", *port);
		return GDK_FAIL;
	}
	if (getsockname(sock, (SOCKPTR)&server, &length) < 0) {
		GDKsyserror("getting socket name\n");
		return GDK_FAIL;
	}
	listen(sock, 1); 

	PARDEBUG {
		THRprintf(GDKerr, "Internet started at %d\n", server.sin_port);
	}
	do {
#ifdef AIX
       		msgsock = accept(sock, 0, (size_t)0);
#else
       		msgsock = accept(sock, 0, (int *)0);
#endif

		if (msgsock == -1) {
			if (MT_geterrno() != EINTR) {
				GDKsyserror("monetServer: accept failed\n");
	    		}
		} else if (msgsock > 0) {
			FILE *fdin = fdopen(msgsock, "r");
			FILE *fdout = fdopen(msgsock, "w");

			if (fdin == 0){
				GDKsyserror("monetServer: fdin problems\n");
				continue;
			}
			if (fdout == 0){
				GDKsyserror("monetServer: fdout problems\n");
				continue;
			}
			while(!feof(fdin)){
				char buf[BUFSIZ];
				int size = fread( buf, 1, BUFSIZ, fdin);
				if (logger_debug)
					printf("read %d\n", size );
			}
		}
	} while (1);
	return GDK_SUCCEED;
}

int logger_backupfile(str log){
	if (logger_debug&1)
		fprintf(stderr, "logger_backupfile %s\n", log );

	logger_log = GDKstrdup(log);

	if (logger_fp) 
		fclose(logger_fp);

	logger_fp = fopen(logger_log,"a"); /* append */

	if (logger_fp) 
		return GDK_SUCCEED; 
	else 
		return GDK_FAIL;
}

static int sz = 0;

int logger_end(){
	if (logger_debug&64)
		fprintf(stderr, "logger_end %d\n", sz);

	if (logger_fp)
		fclose(logger_fp);
	return GDK_SUCCEED;
}

typedef struct logf {
	char flag;
	int id;
	int nr; /* not used by block (begin/end) */
} logf;

void logger_bat(BAT *b){
	int 	status;
	logf 	l;
	BUN	p; 

	if (logger_debug&2 && 
	    (b->batInserted < BUNlast(b) || b->batDeleted < b->batHole))
		fprintf(stderr, "logger_bat %s\n", b->batId);

	l.id = b->batCacheid;
	status = BBPstatus(l.id);
	if (status&BBPNEW && !status&BBPDELETED){
	    l.flag = LOG_CREATE;
	    l.nr = ((b->htype)<<16) + b->ttype;
	    fwrite(&l, sizeof(logf), 1, logger_fp);
	} 
	if (status&BBPDELETED){
	    l.flag = LOG_DESTROY;
	    fwrite(&l, sizeof(logf), 1, logger_fp);
	} 
	if (status&BBPRENAMED){
	    l.flag = LOG_RENAME;
	    fwrite(&l, sizeof(logf), 1, logger_fp);
	    fwrite(BBP_logical(l.id), strlen(BBP_logical(l.id)), 1, logger_fp);
	    fwrite(BBP_logical(-l.id), strlen(BBP_logical(-l.id)),1, logger_fp);
	} 
	l.nr = BUNindex(b, BUNlast(b)) - BUNindex(b, b->batInserted);
	if (l.nr){
	    l.flag = LOG_INSERT;
	    fwrite(&l, sizeof(logf), 1, logger_fp);
	    for (p = b->batInserted; p < BUNlast(b); p = BUNnext(b, p)){
		int s1,s2;
		ptr h = BUNhead(b,p);
		ptr t = BUNtail(b,p);
		fwrite(h, s1=ATOMlen(b->htype,h),1,logger_fp);
		fwrite(t, s2=ATOMlen(b->ttype,t),1,logger_fp);
		sz += (s1+s2);
	    }
	}
	l.nr = BUNindex(b, b->batHole) - BUNindex(b, b->batDeleted);
	if (l.nr){
	    l.flag = LOG_DELETE;
	    printf("%d del %d\n", l.id, l.nr );
	    fwrite(&l, sizeof(logf), 1, logger_fp);
	    for (p = b->batDeleted; p < b->batHole; p = BUNnext(b, p)){
		int s1,s2;
		ptr h = BUNhead(b,p);
		ptr t = BUNtail(b,p);
		fwrite(h, s1=ATOMlen(b->htype,h),1,logger_fp);
		fwrite(t, s2=ATOMlen(b->ttype,t),1,logger_fp);
		sz += (s1+s2);
	    }
	}
}

static BAT *dirty_bat(int i) {
	if (logger_debug&4)
		fprintf(stderr, "dirty_bat %d\n", i);

	if (BBP_logical(i)) {
		BAT *b;
		BBPspin(i, "dirty_bat");
		b = BBP_cache(i);
		if (b != NULL) {
			if ((b->batPersistence&PERSISTENT) && BATdirty(b)) {
				return b; /* the bat is loaded, persistent and dirty */
			}
		} else if (BBP_status(i)&BBPSWAPPED) { 
		  	b = (BAT*) BBPquickdesc(i, TRUE);
			if (b && b->batDirtydesc) {
				return b; /* only the desc is loaded & dirty */
			}
		}
	}
	return NULL;
}

int logger_commit(){
	int  i; 
	logf l;
	/* first build the buffer with data to write
         * then write to file, host
         */
	if (logger_debug&1)
		fprintf(stderr, "logger_commit\n");

	l.flag = LOG_BLOCKBEGIN;
	l.id = logger_logid;
	l.nr = 0;

	BBPlock("logger_commit");
	fwrite(&l, sizeof(logf), 1, logger_fp);
	for (i = 1; i < BBPsize; i++) {
		BAT *b = dirty_bat(i);
		if (b) logger_bat(b); 
	}
	l.flag = LOG_BLOCKEND;
	fwrite(&l, sizeof(logf), 1, logger_fp);
	fflush(logger_fp);

	for (i = 1; i < BBPsize; i++) {
		BAT *b = dirty_bat(i);
		if (b) BATfakeCommit(b); 
	}
	BBPunlock("logger_commit");

	return GDK_SUCCEED; 
}

int logger_update() { 
	/* first try the file */
	/* else get it from the backup server. */
	int i,s1,s2;
	int curlogid = 0; 
	struct stat st;
	char *buf, *p, *end;

	if (logger_debug&1)
		fprintf(stderr, "logger_update\n");

	if (logger_server){
		return TMcommit();
	}
	if (logger_fp) 
		fclose(logger_fp);
	logger_fp = fopen(logger_log,"r+"); 
	fstat(fileno(logger_fp),&st);
	buf = p = GDKmalloc(st.st_size);
	fread(p, st.st_size, 1, logger_fp);
	end = p + st.st_size;

/*	BBPlock("logger_commit"); */
	while(p<end){
		logf l;
		BAT *b;

		memcpy(&l, p, sizeof(logf)); p += sizeof(logf);
		switch(l.flag){
		case LOG_BLOCKBEGIN:
			curlogid = l.id; 
			break;
		case LOG_BLOCKEND:
			if (l.id != curlogid){
		    		fprintf(stderr, 
				  "BLOCKEND does not match begin, %d != %d\n",
				  l.id, curlogid);
				break;
			}
			break;
		case LOG_CREATE:
			printf("create bat %d %d %ld\n",
				(l.nr>>16)&((1<<16)-1), l.nr&((1<<16)-1), l.id);
			b = BATnew((l.nr>>16)&((1<<16)-1),l.nr&((1<<16)-1),l.id);
			BATmode(b,PERSISTENT);
			break;
		case LOG_DESTROY:
			printf("destroy bat %ld\n", l.id);
			b = BATdescriptor(l.id); 
			BATmode(b,TRANSIENT);
			BBPreclaim(b);
			break;
		case LOG_RENAME:
			s1 = strlen(p);
			s2 = strlen(p);
			BBPrename(l.id,p);
			BBPrename(-l.id,p+s1);
			printf("rename bat %ld %s %s\n", l.id, p, p+s1);
			break;
		default:	
			b = BATdescriptor(l.id); 
			if (b){
				for(; l.nr>0 && p<end; l.nr--){
					s1 = ATOMlen(b->htype, p);
					s2 = ATOMlen(b->ttype, p+s1);
					if (l.flag == LOG_INSERT)
						BUNins( b, p, p+s1 );
					else if (l.flag == LOG_DELETE)
						BUNdel( b, p, p+s1 );
					p += s1;
					p += s2;
		    		}
			} else {
				fprintf(stderr,"bat missing %d\n", l.id);
			}
		}
	}
	logger_logid = curlogid;
	for (i = 1; i < BBPsize; i++) {
		BAT *b = dirty_bat(i);
		if (b) BATfakeCommit(b); 
	}
/*	BBPunlock("logger_commit"); */

	if (buf) GDKfree(buf);
	return GDK_SUCCEED; 
}


int logger_set_debug( int *l){
	logger_debug = *l;
	return GDK_SUCCEED; 
}
@}

@mil
module(alarm);

proc pbat(name, acc) := {
        b := new(void,int);
        b.seqbase(oid(0));
        b.rename(name);
        b.persists(true);
        if (int(acc) >= 0){
                b.reverse.accbuild(acc);
        }
        return b;
}

proc logging(bit file) := {
	module("logger");

	logger_debug(64);
	if (file){
		backupfile("/tmp/logger.log");
	} else {
		backuphost("odin.cwi.nl", 50123);
	}
}

proc logger_create() := {
	b0 := pbat("b0",-1);
	b1 := pbat("b1",hash);
	b2 := pbat("b2",index);

	b0.count.print;
	b1.count.print;
	b2.count.print;
	commit;
}

proc logger_insert() := {

	t0 := time();
	var i := 0;
	while (i < 50000){
		i += 1;
	}
	t := time(); print(t-t0); t0 := t;
	
	i := 0;
	while (i < 50000){
		b0.insert(nil,i);
		i += 1;
	}
	commit;

	t := time(); print(t-t0); t0 := t;
	i := 0;
	while (i < 50000){
		b0.insert(nil,i);
		commit;
		i += 1;
	}

	t := time(); print(t-t0); t0 := t;
	i := 0;
	while (i < 50000){
		b1.insert(nil,i);
		i += 1;
	}
	commit;
	
	t := time(); print(t-t0); t0 := t;
	i := 0;
	while (i < 50000){
		b1.insert(nil,i);
		commit;
		i += 1;
	}
	
	t := time(); print(t-t0); t0 := t;
	i := 0;
	while (i < 50000){
		b2.insert(nil,i);
		i += 1;
	}
	commit;
	
	t := time(); print(t-t0); t0 := t;
	i := 0;
	while (i < 50000){
		b2.insert(nil,i);
		commit;
		i += 1;
	}
	t := time(); print(t-t0); t0 := t;

	b0.count.print;
	b1.count.print;
	b2.count.print;
}

proc logger_update() := {

	logger_debug(1);
	
	t0 := time();
	update();
	t := time(); print(t-t0); t0 := t;

	b0.count.print;
	b1.count.print;
	b2.count.print;
}

@sh
#!/bin/sh

rm /tmp/logger.log
Mdestroydb -db logger
Mcreatedb -db logger -user $USER

#Mserver -db logger -prelude logger.mil << EOF
#logger_create;
#quit;
#EOF

Mserver -db logger -prelude logger.mil << EOF
logging(false);
logger_create();
logger_insert();
quit;
EOF

Mserver -db logger -prelude logger.mil << EOF
logging(true);
logger_update;
quit;
EOF

# now with out logger
Mserver -db logger -prelude logger.mil << EOF
logger_insert();
quit;
EOF
