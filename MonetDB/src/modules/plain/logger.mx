@f logger
@t Transactions
@a N. J. Nes
@v 1.0
@T
@* Introduction
In the philosophy of Monet, transaction management overhead should only
be paid when necessary. Transaction management is for this purpose 
implemented as a module. This module, once loaded, takes care of writing
the commited changes, to a transaction log. The log may reside on the
same system and therefor the writes are done to disk but could also
reside on an other system and then the changes are flushed through
the network.  

The main interface to this logging system is the commit call which
writes all the delta to the log file. Each bat in Monet keeps track 
of the changes using the delta management. On commit these changes are
writen to the log file and the delta management is reset. Since each 
commit is writen to the same log file, the beginning and end are 
marked by a log identifier. A server restart should only (re)process
blocks which are completely writen to disk. 

TODO
	handel bbp updates ??
	convertion between big/little endian
	
@* Module Definition
@m
.MODULE logger;

@- global transaction management
@m
.COMMAND backuphost(str host, int port) = logger_backuphost;
	"Use the host,port to backup changes to"

.COMMAND logger_listen(int port ) = logger_listen;
	"listens for a client willing to backup to this port"

.COMMAND backupfile(str log ) = logger_backupfile;
	"Backup to the file log and write the log identifier to the file logid"

.COMMAND commit() = logger_commit;
	"commit on all BATs to the log"

.COMMAND update() = logger_update;
	"update the all BATs using the log, TODO only needed at initialisation"

.COMMAND logger_debug( int level ) = logger_set_debug;
	"Set the level of debuging"

.EPILOGUE = logger_end;

.END logger;
@{
@* Implementation Code 
@c
#include <gdk.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <sys/socket.h>

#define LOG_INSERT 	1
#define LOG_DELETE	2
#define LOG_CREATE 	3
#define LOG_DESTROY	4
#define LOG_RENAME	5

/* simple buffer management */
typedef struct buf_node_t {
	int size;
	char *buf;
	struct buf_node_t *next;
	int used;
} buf_node_t, *buf_node_p;

INLINE static 
buf_node_p new_buffer_node(buf_node_p p){
	buf_node_p c = (buf_node_p)GDKmalloc(sizeof(buf_node_t));
	c->next = NULL;
	c->used = 0;
	if (p){
		c->size = p->size * 2;
		p->next = c;
	} else {
		c->size = BUFSIZ;
	}
	c->buf = GDKmalloc(c->size);
	return c;
}

INLINE static 
void destroy_buffer_node( buf_node_p b ){
	if (b){
		GDKfree(b->buf);
		destroy_buffer_node(b->next);
		GDKfree(b);
	}
}

typedef struct buf_t {
	buf_node_p root;
	buf_node_p cur;
} buf_t, *buf_p;

INLINE static 
buf_p new_buffer(){
	buf_p b = (buf_p)GDKmalloc(sizeof(buf_t));
	b->root = b->cur = new_buffer_node(NULL);
	return b;
}

INLINE static 
void destroy_buffer( buf_p b ){
	destroy_buffer_node(b->root);
	GDKfree(b);
}

#define bwrite(buf,data,len) buffer_write(buf,(char*)data,len)
INLINE static 
void buffer_write(buf_p buf, char *data, size_t len){
	buf_node_p b = buf->cur;

	if (b->used+len > b->size){
		int rest = b->size-b->used;
		memcpy(b->buf+b->used, data, rest);
		b->used += rest;
		len -= rest;
		buf->cur = new_buffer_node(b);
		b = buf->cur;
	}
	memcpy(b->buf+b->used, data, len);
	b->used += len;
}

INLINE static 
void buffer_flush(buf_p buf, FILE *logger_fp){
	buf_node_p b = buf->root; 
	for(;b;b=b->next){
		fwrite(b->buf, 1, b->used, logger_fp);
	}
	fflush(logger_fp);
}

INLINE static 
void buffer_flush_s(buf_p buf, int logger_s){
	buf_node_p b = buf->root; 
	for(;b;b=b->next){
		send(logger_s, b->buf, b->used, 0);
	}
}

INLINE static 
size_t buffer_used(buf_p buf){
	size_t l = 0;
	buf_node_p b = buf->root; 

	for(;b;b=b->next){
		l += b->used;
	}
	return l;
}

static int   logger_debug = 0;

static char *logger_host = NULL;
static int   logger_port = 0;
static int   logger_server = 0;

static char *logger_log 	= NULL;
static FILE *logger_fp 		= NULL;
static int   logger_socket 	= 0;
static int   logger_logid 	= 0;

int logger_backuphost(str host, int *port){
	struct sockaddr_in a;
	struct hostent *hp;
	struct sockaddr *addr = (struct sockaddr *) &a;
 	int fd, len = sizeof(a);

	if (logger_debug&1)
		fprintf(stderr, "logger_backuphost %s %d\n", host, *port );

	logger_host = GDKstrdup(host);
	logger_port = *port;

	memset(&a, 0, sizeof(a));
	a.sin_family = AF_INET;
	a.sin_port = htons((unsigned short)(*port&0xFFFF));
	if (!(hp = gethostbyname(host))){
	    GDKsyserror("backuphost(%s:d): lookup error.\n", host, *port);
	    return GDK_FAIL;
	}
	memcpy(&a.sin_addr, hp->h_addr, hp->h_length);
	if ((fd = socket(PF_INET, SOCK_STREAM, 0)) < 0) {
	    GDKsyserror("backuphost(%s:%d): could not create socket.\n",host,*port);
	} else if (connect(fd, addr, len)) {
	    GDKsyserror("backuphost(%s:%d): could not connect with.\n", host,*port);
	} else {
	    logger_socket = fd;
	    logger_fp = fdopen(fd, "w");
	}
	return GDK_SUCCEED; 
}

int logger_backupfile(str log){
	if (logger_debug&1)
		fprintf(stderr, "logger_backupfile %s\n", log );

	logger_log = GDKstrdup(log);

	if (logger_fp) 
		fclose(logger_fp);

	logger_fp = fopen(logger_log,"a"); /* append */

	if (logger_fp) 
		return GDK_SUCCEED; 
	else 
		return GDK_FAIL;
}

static int sz = 0;

int logger_end(){
	if (logger_debug&64)
		fprintf(stderr, "logger_end %d\n", sz);

	if (logger_fp)
		fclose(logger_fp);
	return GDK_SUCCEED;
}

typedef struct logf {
	char flag;
	int id;
	int nr; /* not used by block (begin/end) */
} logf;

void logger_bat(buf_p buf, BAT *b ){
	int 	status;
	logf 	l;
	BUN	p; 


	l.id = b->batCacheid;
	status = BBPstatus(l.id);
	if (status&BBPNEW && !(status&BBPDELETED)){
	    l.flag = LOG_CREATE;
	    l.nr = ((b->htype)<<16) + b->ttype;
	    bwrite(buf, &l, sizeof(logf));
            if (logger_debug&2)
		printf("new bat htype %d ttype %d id %d\n", 
			b->htype, b->ttype, l.id );
	} 
	if (status&BBPDELETED){
	    if (logger_debug&2)
		fprintf(stderr, "logger_bat destroyed %ld \n", l.id );
	    l.flag = LOG_DESTROY;
	    bwrite(buf, &l, sizeof(logf));
	} 
	if (status&BBPRENAMED){
	    if (logger_debug&2)
		fprintf(stderr, "logger_bat renamed %s \n", BBP_logical(l.id) );
	    l.flag = LOG_RENAME;
	    bwrite(buf, &l, sizeof(logf));
	    bwrite(buf, BBP_logical(l.id), strlen(BBP_logical(l.id)));
	    bwrite(buf, BBP_logical(-l.id), strlen(BBP_logical(-l.id)));
	} 
	l.nr = BUNindex(b, BUNlast(b)) - BUNindex(b, b->batInserted);
	if (l.nr){
	    if (logger_debug&2)
		fprintf(stderr, "logger_bat inserted %d from %s \n", 
			l.nr, b->batId);
	    l.flag = LOG_INSERT;
	    bwrite(buf, &l, sizeof(logf));
	    for (p = b->batInserted; p < BUNlast(b); p = BUNnext(b, p)){
		int s1,s2;
		ptr h = BUNhead(b,p);
		ptr t = BUNtail(b,p);
		bwrite(buf, h, s1=ATOMlen(b->htype,h));
		bwrite(buf, t, s2=ATOMlen(b->ttype,t));
		sz += (s1+s2);
	    }
	}
	l.nr = BUNindex(b, b->batHole) - BUNindex(b, b->batDeleted);
	if (l.nr){
	    if (logger_debug&2)
		fprintf(stderr, "logger_bat deleted %d from %s \n", 
			l.nr, b->batId);
	    l.flag = LOG_DELETE;
	    printf("%d del %d\n", l.id, l.nr );
	    bwrite(buf, &l, sizeof(logf));
	    for (p = b->batDeleted; p < b->batHole; p = BUNnext(b, p)){
		int s1,s2;
		ptr h = BUNhead(b,p);
		ptr t = BUNtail(b,p);
		bwrite(buf, h, s1=ATOMlen(b->htype,h));
		bwrite(buf, t, s2=ATOMlen(b->ttype,t));
		sz += (s1+s2);
	    }
	}
}

INLINE
static BAT *dirty_bat(int i) {
	if (logger_debug&4)
		fprintf(stderr, "dirty_bat %d\n", i);

	if (BBP_logical(i)) {
		BAT *b;
		/*BBPspin(i, "dirty_bat");*/
		b = BBP_cache(i);
		if (b != NULL) {
			if ((b->batPersistence&PERSISTENT) && BATdirty(b)) {
				return b; /* the bat is loaded, persistent and dirty */
			}
		} else if (BBP_status(i)&BBPSWAPPED) { 
		  	b = (BAT*) BBPquickdesc(i, TRUE);
			if (b && b->batDirtydesc) {
				return b; /* only the desc is loaded & dirty */
			}
		}
	}
	return NULL;
}

int logger_commit(){
	int  i,id,nr, *kills = NULL; 
	buf_p buf = new_buffer();
	/* first build the buffer with data to write
         * then write to file, host
         */
	if (logger_debug&2)
		fprintf(stderr, "logger_commit\n");

	id = logger_logid;
	nr = 0;

	BBPlock("logger_commit");
	bwrite(buf, &nr, sizeof(int));
	bwrite(buf, &id, sizeof(int));
	for (i = 1; i < BBPsize; i++) {
		BAT *b = dirty_bat(i);
		if (b){
		       logger_bat(buf,b); 
		       BATfakeCommit(b); 
			/* update BBP status */
		}
	}
	*((int*)buf->root->buf) = buffer_used(buf);
	if (logger_host)
		buffer_flush_s(buf, logger_socket);
	else
		buffer_flush(buf, logger_fp);
	destroy_buffer(buf);
	BBPunlock("logger_commit");

	kills = TMfakeCommit();
	TMkill(kills);
	
	return GDK_SUCCEED; 
}

INLINE static 
void merge_block(char *p, char *block_end){
    while(p<block_end){
    	int s1,s2;
	logf l;
	BAT *b;

	memcpy(&l, p, sizeof(logf)); p += sizeof(logf);
	switch(l.flag){
	case LOG_CREATE:
		printf("create bat htype %d ttype %d id %ld\n",
			(l.nr>>16)&((1<<16)-1), l.nr&((1<<16)-1), l.id);
		b = BATnew((l.nr>>16)&((1<<16)-1),l.nr&((1<<16)-1),l.id);
		BATmode(b,PERSISTENT);
		break;
	case LOG_DESTROY:
		printf("destroy bat %ld\n", l.id);
		b = BATdescriptor(l.id); 
		BATmode(b,TRANSIENT);
		BBPreclaim(b);
		break;
	case LOG_RENAME:
		s1 = strlen(p);
		s2 = strlen(p);
		BBPrename(l.id,p);
		BBPrename(-l.id,p+s1);
		printf("rename bat %ld %s %s\n", l.id, p, p+s1);
		break;
	default:	
		b = BATdescriptor(l.id); 
		if (b){
			for(; l.nr>0 && p<block_end; l.nr--){
				s1 = ATOMlen(b->htype, p);
				s2 = ATOMlen(b->ttype, p+s1);
				if (l.flag == LOG_INSERT)
					BUNins( b, p, p+s1 );
				else if (l.flag == LOG_DELETE)
					BUNdel( b, p, p+s1 );
				p += s1;
				p += s2;
	    		}
		} else {
			fprintf(stderr,"bat missing %d\n", l.id);
		}
	}
    }
}

int logger_update() { 
	/* first try the file */
	/* else get it from the backup server. */
	int i;
	struct stat st;
	char *buf, *p, *end;

	if (logger_debug&1)
		fprintf(stderr, "logger_update\n");

	if (logger_server){
		return TMcommit();
	}
	if (logger_fp) 
		fclose(logger_fp);
	logger_fp = fopen(logger_log,"r+"); 
	fstat(fileno(logger_fp),&st);
	buf = p = GDKmalloc(st.st_size);
	fread(p, st.st_size, 1, logger_fp);
	end = p + st.st_size;

/*	BBPlock("logger_commit"); */
	while(p<end){
	    char *block_end = end;
	    int id;
	    int nr;

	    memcpy(&nr, p, sizeof(int)); 
	    block_end = p+nr;
	    p += sizeof(int);
	    memcpy(&id, p, sizeof(int)); 
	    p += sizeof(int);
	    
	    merge_block(p,block_end);
	    p = block_end;
	    logger_logid = id;
	}

	for (i = 1; i < BBPsize; i++) {
		BAT *b = dirty_bat(i);
		if (b) BATfakeCommit(b); 
	}
/*	BBPunlock("logger_commit"); */

	if (buf) GDKfree(buf);
	return GDK_SUCCEED; 
}


int logger_set_debug( int *l){
	logger_debug = *l;
	return GDK_SUCCEED; 
}

/* server just reading in the request and does a true commit once 
 * every ... time 
 */
#define SOCKPTR struct sockaddr *

int logger_listen(int *port){
	
	struct sockaddr_in server;
	int 	sock;
#ifdef AIX
	size_t 	length;
#else
	int 	length;
#endif
	int    	on = 1;
	int 	msgsock;
	int	i = 0;

	logger_server = 1; /* resets commit back to TMcommit */

	sock = socket(AF_INET, SOCK_STREAM, 0);
	if (sock < 0) {
		GDKsyserror("creation of stream socket failed\n");
		return GDK_FAIL;
	}
	server.sin_family = AF_INET;
	server.sin_addr.s_addr = INADDR_ANY;
	server.sin_port = htons((unsigned short)((*port)&0xFFFF));
   	for (i=0;i<8;i++)
	    server.sin_zero[i]=0;
 
	setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, (char*) &on, sizeof on);

	length = sizeof(server);
	if (bind(sock, (SOCKPTR)&server, length) < 0) {
		GDKsyserror("binding to stream socket (%d) failed\n", *port);
		return GDK_FAIL;
	}
	if (getsockname(sock, (SOCKPTR)&server, &length) < 0) {
		GDKsyserror("getting socket name\n");
		return GDK_FAIL;
	}
	listen(sock, 1); 

	printf("Backup started at %d\n", *port);

	do {
#ifdef AIX
       		msgsock = accept(sock, 0, (size_t)0);
#else
       		msgsock = accept(sock, 0, (int *)0);
#endif

		if (msgsock == -1) {
			if (MT_geterrno() != EINTR) {
				GDKsyserror("monetServer: accept failed\n");
	    		}
		} else if (msgsock > 0) {
			FILE *fdin = fdopen(msgsock, "r");
			FILE *fdout = fdopen(msgsock, "w");

			if (fdin == 0){
				GDKsyserror("monetServer: fdin problems\n");
				continue;
			}
			if (fdout == 0){
				GDKsyserror("monetServer: fdout problems\n");
				continue;
			}
			while(!feof(fdin)){
				int nr, id, size;
				char *data;

				if (fread( &nr, sizeof(int), 1, fdin) != 1){
				    if (!feof(fdin)){
				    	printf( "Nothing to read (nr) %d\n", 
					 	ferror(fdin));
				    }
				    break;
				}
				if (fread( &id, sizeof(int), 1, fdin) != 1){
				    printf( "Id missing %d\n",ferror(fdin));
				    break;
				}
				
				nr -= (2 * sizeof(int));

				data = GDKmalloc(nr);
				size = fread( data, 1, nr, fdin);

	    			merge_block( data, data+nr ); 
				logger_logid = id;
				if (logger_debug&1)
					printf("read %d %d\n", nr, size );
				GDKfree(data);
			}
		}
	} while (1);
	return GDK_SUCCEED;
}

@}

@mil
module(alarm);

proc pbat(name, acc) := {
        b := new(void,int);
        b.seqbase(oid(0));
        b.rename(name);
        b.persists(true);
        if (int(acc) >= 0){
                b.reverse.accbuild(acc);
        }
        return b;
}

proc logging(bit file) := {
	module("logger");

	logger_debug(64);
	if (file){
		backupfile("/tmp/logger.log");
	} else {
		backuphost("thor.cwi.nl", 50123);
	}
}

proc logger_create() := {
	b0 := pbat("b0",-1);
	b1 := pbat("b1",hash);
	b2 := pbat("b2",index);

	b0.count.print;
	b1.count.print;
	b2.count.print;
	commit;
}

proc logger_insert() := {

	t0 := time();
	var i := 0;
	while (i < 50000){
		i += 1;
	}
	t := time(); print(t-t0); t0 := t;
	
	i := 0;
	while (i < 50000){
		b0.insert(nil,i);
		i += 1;
	}
	commit;

	t := time(); print(t-t0); t0 := t;
	i := 0;
	while (i < 50000){
		b0.insert(nil,i);
		commit;
		i += 1;
	}

	t := time(); print(t-t0); t0 := t;
	i := 0;
	while (i < 50000){
		b1.insert(nil,i);
		i += 1;
	}
	commit;
	
	t := time(); print(t-t0); t0 := t;
	i := 0;
	while (i < 50000){
		b1.insert(nil,i);
		commit;
		i += 1;
	}
	
	t := time(); print(t-t0); t0 := t;
	i := 0;
	while (i < 50000){
		b2.insert(nil,i);
		i += 1;
	}
	commit;
	
	t := time(); print(t-t0); t0 := t;
	i := 0;
	while (i < 50000){
		b2.insert(nil,i);
		commit;
		i += 1;
	}
	t := time(); print(t-t0); t0 := t;

	b0.count.print;
	b1.count.print;
	b2.count.print;
}

proc logger_update() := {

	logger_debug(1);
	
	t0 := time();
	update();
	t := time(); print(t-t0); t0 := t;

	b0.count.print;
	b1.count.print;
	b2.count.print;
}

@sh
#!/bin/sh

#rm /tmp/logger.log
#Mdestroydb -db logger
#Mcreatedb -db logger -user $USER

#Mserver -db logger -prelude logger.mil << EOF
#logger_create;
#quit;
#EOF

Mserver -db logger -prelude logger.mil << EOF
logging(false);
#logger_create();
logger_insert();
quit;
EOF

#Mserver -db logger -prelude logger.mil << EOF
#logging(true);
#logger_update;
#quit;
#EOF

# now with out logger
#Mserver -db logger -prelude logger.mil << EOF
#logger_insert();
#quit;
#EOF
