@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at 
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@' 
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@' 
@' The Original Code is the Monet Database System.
@' 
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2002 CWI.  
@' All Rights Reserved.
@' 
@' Contributor(s):
@' 		Martin Kersten <Martin.Kersten@cwi.nl>
@' 		Peter Boncz <Peter.Boncz@cwi.nl>
@' 		Niels Nes <Niels.Nes@cwi.nl>
@' 		Stefan Manegold  <Stefan.Manegold@cwi.nl>

@f monettime
@t New Temporal Module
@a Peter Boncz, Martin van Dinther
@v 1.0

@* Introduction
@T
The goal of this module is to provide adequate functionality for storing
and manipulated time-related data. The minimum requirement is that data
can easily be imported from all common commercial RDBMS products.

This module supersedes the 'temporal' module that has a number of 
conceptual problems and hard-to-solve bugs that stem from these problems.

The starting point of this module are SQL 92 and the ODBC time-related data types.
Also, some functionalities have been imported from the time classes of the Java
standard library.
@T
This module introduces four basic types and operations on them:
\begin{description}
\item[date] a date in the gregorian calendar, e.g. 1999-JAN-31

\item[daytime] a time of day to the detail of milliseconds, e.g. 23:59:59:000

\item[timestamp] a combination of date and time, indicating an exact point in 
time (GMT). GMT is the time at the greenwich meridian without a daylight savings 
time (DST) regime. Absence of DST means that hours are consecutive (no jumps) which 
makes it easy to perform time difference calculations.
\item[timezone] the local time is often different from GMT (even at greenwich in
summer, as the UK also has DST). Therefore, whenever a timestamp is composed
from a local daytime and date, a timezone should be specified in order to
translate the local daytime to GMT (and vice versa if a timestamp is to
be decomposed in a local date and daytime).

There is an additional atom {\bf rule} that is used to define when daylight
savings time in a timezone starts and ends. We provide predefined timezone
objects for a number of timezones below (see the LOAD section of the module).
Also, there is one timezone called the {\bf local timezone}, which can be set
to one global value in a running Monet server, that is used if the timezone 
parameter is omitted from a command that needs it (if not set, the default value 
of the local timezone is plain GMT).
\end{description}

@- Limitations
@T
The valid ranges of the various data types are as follows:
\begin{description}
\item[min and max year]
The maximum and minimum dates and timestamps that can be stored are in the years 5,867,411 and 
-5,867,411, respectively. Interestingly, the year 0 is not a valid year. The year before 1 is 
called -1. 
\item[valid dates]
Fall in a valid year, and have a month and day that is valid in that year. The first day in the year
is january 1, the last december 31. Months with 31 days are january, march, may, juli, august,
october, and december, while april, june, september and november have 30 days. February has 28
days, expect in a leapyear, when it has 29. A leapyear is a year that is an exact multiple of
4. Years that are a multiple of 100 but not of 1000 are an execption; they are no leapyears.
\item[valid daytime]
The smallest daytime is 00:00:00:000 and the largest 23:59:59:999 (the hours in a daytime
range between [0,23], minutes and seconds between [0,59] and milliseconds between [0:999]).
Daytime identifies a valid time-of-day, not an amount of time (for denoting amounts of time, or
time differences, we use here concepts like "number of days" or "number of milliseconds" denoted 
by some value of a standard integer type).
\item[valid timestamp]
is formed by a combination of a valid date and valid daytime.
\item[difference in days]
For difference calculations between dates (in numbers of days) we use signed integers (the {\tt int} 
Monet type), hence the valid range for difference calculations is between -2147483648 and 
2147483647 days (which corresponds to roughly -5,867,411 and 5,867,411 years). 
\item[difference in msecs]
For difference between timestamps (in numbers of milliseconds) we use 64-bit longs (the {\tt lng} Monet type).
These are large integers of maximally 19 digits, which therefore impose a limit of about 106,000,000,000 years 
on the maximum time difference used in computations. 
\end{description}

There are also conceptual limitations that are inherent to the time system itself:
\begin{description}
\item[gregorian calendar]
The basics of the Gregorian calendar stem from the time of Julius Ceasar,
when the concept of a solar year as consisting of 365.25 days (365 days plus once 
in 4 years one extra day) was introduced. However, this Julian Calendar, made a year 11  
minutes long, which subsequently accumulated over the ages, causing a shift in 
seasons. In medieval times this was noticed, and in 1582 Pope Gregory XIII issued a 
decree, skipped 11 days. This measure was not adopted in the whole of Europe inmediately, 
however.  For this reason, there were many regions in Europe that upheld different dates. 

It was only on {\bf september 14, 1752} that some concensus was reached and more countries 
joined the Gregorian Calendar, which also was last modified at that time. The modifications 
were twofold: first, 12 more days were skipped. Second, it was determined that the
year starts on january 1 (in England, for instance, it had been starting on march 25).

Other parts of the world have adopted the Gregorian Calendar even later.

This module implements the Gregorian Calendar in all its regularity. This means
that values before the year 1752 probably do not correspond with the dates that
people really used in times before that (what they did use, however, was very vague
anyway, as explained above). In solar terms, however, this calendar is reasonably 
accurate (see the "correction seconds" note below).

\item[timezones]
The basic timezone regime was established on {\bf november 1, 1884} in the {\em International 
Meridian Conference} held in Greenwich (UK). Before that, a different time held in almost 
any city. The conference established 24 different time zones defined by regular longitude intervals
that all differed by one hour.  Not for long it was that national and political interest started 
to erode this nicely regular system.  Timezones now often follow country borders, and some regions 
(like the Guinea areas in Latin America) have times that differ with a 15 minute grain from GMT 
rather than an hour or even half-an-hour grain.

An extra complication became the introduction of daylight saving time (DST), which 
causes a time jump in spring, when the clock is skips one hour and in autumn, when the 
clock is set back one hour (so in a one hour span, the same times occur twice). 
The DST regime is a purely political decision made on a country-by-country basis. Countries
in the same timezone can have differnt DST regimes. Even worse, some countries have DST in 
some years, and not in other years. 

To avoid confusion, this module stores absolute points of time in GMT only (GMT does not
have a DST regime). When storing local times in the database, or retrieving local times
from absolute timestamps, a correct timezone object should be used for the conversion.

Applications that do not make correct use of timezones, will produce irregular results 
on e.g. time difference calculations.

\item[correction seconds]
Once every such hundred years, a correction second is added on new year's night.
As I do not know the rule, and this rule would seriously complicate this module
(as then the duration of a day, which is now the fixed number of 24*60*60*1000 
milliseconds, becomes parametrized by the date), it is not implemented. Hence 
these seconds are lost, so time difference calculations in milliseconds (rather than 
in days) have a small error if the time difference spans many hundreds of years.
\end{description}

TODO: we cannot handle well changes in the tzone rules (e.g., DST only exists since 
40 years, and some countries make frequent changes to the DST policy). To accommodate
this we should make tzone\_local a function with a year parameter. The tool should 
maintain and access the tzone database stored in two bats [str,tzone],[str,year]. 
Lookup of the correct tzone would be dynamic in this structure. The tzone\_setlocal 
would just set the string name of the tzone.

@+ Concepts

@+ Monet Module Definition
@m
.MODULE monettime;

@- date atom
@T
Monet atoms can have multiple {\em parse formats}. One of these formats is
chosen as the {\em print format}.

To facilitate date descriptions, many formats are supported when parsing
date atoms from a string, as described by the below grammar. 
\begin{verbatim}
print format: INT_YEAR '-' INT_MONTH '-' INT_DAY
parse format: INT_YEAR SEP1 INT_MONTH SEP1 INT_DAY
          or: INT_YEAR SEP2 STR_MONTH SEP2 INT_DAY
          or: STR_MONTH ' '+ INT_DAY ',' ' '* INT_YEAR

with:   INT_YEAR = integer between -5867411 and 5867411
         INT_DAY = integer between 1 and 31
       INT_MONTH = integer between 1 and 12
       STR_MONTH = 'JANUARI' or 'FEBRUARI' or 'MARCH' or 'APRIL' or 'MAY'  
                   or 'JUNE' or 'JULI' or 'AUGUST' or 'SEPTEMBER' or 'OCTOBER' 
                   or 'NOVEMBER' or 'DECEMBER' (lowercase characters, and/or 
                   only the first three characters are also allowed)
            SEP1 = '-' or '/' or '\' or (' ')+
            SEP2 = SEP1 or ''
\end{verbatim}
Printing a date uses the 1999-01-31 format, as this is both language neutral 
and the lexicografical string ordering of this representation respects the 
actual date ordering.

Other print formats can be achieved by writing a customized MIL procedure 
that extract year, month and day from a date as integers and formats those 
in a string.
@m
.ATOM date = int;
	.FROMSTR = date_fromstr;
	.TOSTR = date_tostr;
.END;

@- daytime atom
@T
A valid time of day to the detail of milliseconds, like 23:59:59:000
\begin{verbatim}
print format: HOUR ':' MIN ':' SEC '.' MSEC
parse format: HOUR ':' MIN ':' SEC SEP MSEC
          or: HOUR ':' MIN ':' SEC 
          or: HOUR ':' MIN 

with: HOUR = integer between 0 and 23 
       MIN = integer between 0 and 59 
       SEC = integer between 0 and 59 (default = 0)
      MSEC = integer between 0 and 999 (default = 0)
       SEP = '.' or ':'
\end{verbatim}
@m
.ATOM daytime = int;
	.FROMSTR = daytime_fromstr;
	.TOSTR = daytime_tostr;
.END;

@- timestamp
@T
An absolute point of time, as formed by the combination of a date a daytime in GMT
e.g. 1999-01-31@23:59:59:000. GMT is the universal time at the greenwhich meridian, 
without any daylight savings time (DST). As such GMT times are 'absolute' (continuous,
without hour jumps as in DST), so accurate time difference computations can be performed.
\begin{verbatim}
print format: DATE ' ' DAYTIME 
parse format: DATE ' ' DAYTIME  ['GMT' ZONE ]

with:    DATE = a valid parse format of the date atom (as decribed earlier)
      DAYTIME = a valid parse format of the daytime atom (as decribed earlier)
         ZONE = ('+'|'-') HOUR ':' MIN [ 'DST' ]
\end{verbatim}
Though internally timestamps are stored in GMT, the printing and parsing of 
timestamps is relative to the local timezone. That is, timestamps are 
printed without GMT part, meaning that the time is relative to the local 
timezone.   Also, if a timestamp is parsed from a string that does not have
an explicit GMT specifier, it is taken to be a timestamp in the local 
timezone. The default local timzone is just GMT+00, but iit can be set 
arbitrarily.
@m
.ATOM timestamp = lng;
	.FROMSTR = timestamp_fromstr;
	.TOSTR = timestamp_tostr;
	.NULL	 = timestamp_null;
.END;

@T
When creating a timestamp from a date and daytime, a timezone should be specified
(if timezone is omitted, the local timezone is assumed). If a timezone is specified, 
it is used to convert the date and time in that timezone to GMT, which is the internal 
timestamp representation. One problem here is that the first hour after DST
has ended (some sunday night in autumn, generally), the time is set back one hour, so
the same times occur twice. Hence two translations to a timestamp are possible for
such date and time combinations. In those case, we act as if it was the first 
occurence (still within DST). 

@- tzone
@T
A timezone determines a {\em time offset} from GMT with format 
[-] HOUR ':' MINUTES, with HOUR between [0:23] and MINUTES between [0:59].

Possibly, {\em Daylight Savings Time} (DST) is in force in a timezone, which means that
between a start and an end date, the clock is set back {\bf one hour}. The start and 
end date of DST are determined by a {\em rule}. These rules (similar to the
Java Timezone class) are made up of 4 parameters: a month {\bf M}, a day number in the 
month {\bf D}, a day-of-week (monday,..,sunday) denoted {\bf W}, and a daytime {\bf T}
(only to the minute detail).

Depending of the values of these parameters, five kinds of rules can be made
(similar to the Java TimeZone class):
\begin{itemize}
\item first {\bf D}th weekday {\bf W} from start of month {\bf M}.\\
iff {\bf D} in [1,..,5], {\bf W} in [1,..,7] 

\item last {\bf D}th weekday {\bf W} from end of month {\bf M}.\\
iff {\bf D} in [-5,..,-1], {\bf W} in [1,..,7] 

\item first weekday {\bf W} in month {\bf M} after exact {\bf D}th day of month.\\
iff {\bf D} in [1,..,31], {\bf W} in [-7,..,-1] 

\item last weekday {\bf W} in month {\bf M} before exact {\bf D}th day of month.\\
iff {\bf D} in [-31,..,-1], {\bf W} in [-7,..,-1] 

\item exact {\bf D}th day of month {\bf M}.\\
iff {\bf D} in [1,..,31], {\bf W}=0;

\end{itemize}
The parameters {\bf M} is a month number between 1 and 12, and {\bf T} is a time 
to the minute detail just like the time offset of the timezone.

Other values of the rule parameters on creating a timezone will produce a 
nil-timezone.
@m
.ATOM tzone = lng;
	.FROMSTR = tzone_fromstr;
	.TOSTR   = tzone_tostr;
	.NULL	 = tzone_null;
.END;

.ATOM rule = int;
	.FROMSTR = rule_fromstr;
	.TOSTR = rule_tostr;
.END;

.COMMAND tzone_local(tzone) = tzone_set_local;
	"set the local tzone; which is used for printing timestamps (!DS2.2)"
.COMMAND tzone_local() : tzone = tzone_get_local;
	"get the local tzone; which is used for printing timestamps (!DS2.2)"

@- construction
Construct temporal values from simple(r) parameters.
Out-of range result values are represented by the nil.
@m
.COMMAND "date" (int year, int month, int day) : date = date_create;
	"creates a date from (year,month,day) parameters."
.COMMAND "daytime" (int hours, int minutes, int seconds, int milliseconds) : daytime = daytime_create;
	"creates a time from (hours,minutes,seconds,milliseconds) parameters."
.COMMAND "timestamp" (date,daytime,tzone) : timestamp = timestamp_create;
	"creates a timestamp from (date,daytime,tzone) parameters (!DS2.2)."
.COMMAND "timestamp" (date,daytime) : timestamp = timestamp_create_default;
	"creates a timestamp from (date,daytime) parameters (in the local timezone)."
.COMMAND "rule" (int month, int day, int weekday, int minutes) : rule = rule_create;
	"create a DST start/end date rule. (!DS2.2)"
.COMMAND "tzone" (int minutes) : tzone = tzone_create;
	"create a tzone as a simple hour difference from GMT. (!DS2.2)"
.COMMAND "tzone" (int minutes, rule start, rule end) : tzone = tzone_create_dst;
	"create a tzone as an hour difference from GMT and a DST. (!DS2.2)"

@- decomposition
@T
There are routines that decompose a date and routines that decompose a daytime.
For decomposing a timestamp, there are routines that decompose it in a date 
and daytime.
@m
# date
.COMMAND year(date) : int = date_extract_year;
	"extracts year from date (nonzero value between -5867411 and +5867411)."
.COMMAND month(date) : int = date_extract_month;
	"extracts month from date (value between 1 and 12)"
.COMMAND day(date) : int = date_extract_day;
	"extracts day from date (value between 1 and 31)"

# daytime
.COMMAND hours(daytime) : int = daytime_extract_hours;
	"extracts hour from daytime (value between 0 and 23)"
.COMMAND minutes(daytime) : int = daytime_extract_minutes;
	"extracts minutes from daytime (value between 0 and 59)"
.COMMAND seconds(daytime) : int = daytime_extract_seconds;
	"extracts seconds from daytime (value between 0 and 59)"
.COMMAND milliseconds(daytime) : int = daytime_extract_milliseconds;
	"extracts milliseconds from daytime (value between 0 and 999)"

# timestamp
.COMMAND "daytime" (timestamp) : daytime = timestamp_extract_daytime_default;
	"extracts daytime from timestamp (in the local timezone)."
.COMMAND "daytime" (timestamp, tzone) : daytime = timestamp_extract_daytime;
	"extracts daytime from timestamp in a certain tzone (!DS2.2)."

.COMMAND "date" (timestamp) : date = timestamp_extract_date_default;
	"extracts date from timestamp (in the local timezone)."
.COMMAND "date" (timestamp, tzone) : date = timestamp_extract_date;
	"extracts date from timestamp in a certain tzone (!DS2.2)."

# tzone
.COMMAND start_dst(tzone) : rule = tzone_extract_start;
	"extract rule that determines start of DST from tzone (!DS2.2)."
.COMMAND end_dst(tzone) : rule = tzone_extract_end;
	"extract rule that determines end of DST from tzone (!DS2.2)."
.COMMAND minutes(tzone) : int = tzone_extract_minutes;
	"extract number of minutes that tzone is offset wrt GMT (!DS2.2)."

# rule
.COMMAND month(rule) : int = rule_extract_month;
	"extract month from rule (!DS2.2)."
.COMMAND day(rule) : int = rule_extract_day;
	"extract day from rule (!DS2.2)."
.COMMAND weekday(rule) : int = rule_extract_weekday;
	"extract weekday from rule (!DS2.2)."
.COMMAND minutes(rule) : int = rule_extract_minutes;
	"extract minutes from rule (!DS2.2)."

@- arithmetic
@T
We choose to represent intervals of time as numbers of days (as int, a 32-bits integer)
and numbers of milliseconds (as lng, a 64-bits integer). Using standard integer types
facilitates computation with these amounts of time (you can use all normal integer 
arithmetic operators).

Arithmetic overflow returns the nil atom (no error messages). For all commands in 
this modules it holds that if one of the parameters is nil, the result is also nil 
(nil has the don't know semantics in MIL). 
@m
.COMMAND addyears(date value, int years) : date = date_addyears;
	"returns the date after a number of years (possibly negative)."
.COMMAND addmonths(date value, int months) : date = date_addmonths;
	"returns the date after a number of months (possibly negative)."
.COMMAND adddays(date value, int days) : date = date_adddays;
	"returns the date after a number of days (possibly negative)."
.COMMAND diff(date val1, date val2) : int = date_diff;
	"returns the number of days between 'val1' and 'val2'."

.COMMAND dayofyear(date) : int = date_extract_dayofyear;
	"Returns N where d is the Nth day of the year (january 1 returns 1)"
.COMMAND weekofyear(date) : int = date_extract_weekofyear;
	"Returns the week number in the year."
.COMMAND dayofweek(date) : int = date_extract_dayofweek;
	"Returns the current day of the week where 1=sunday, .., 7=saturday"

.COMMAND add(timestamp value, lng msecs) : timestamp = timestamp_add;
	"returns the timestamp that comes 'msecs' (possibly negative) after 'value' (!DS2.2)."
.COMMAND diff(timestamp val1, timestamp val2) : lng = timestamp_diff;
	"returns the number of milliseconds between 'val1' and 'val2' (!DS2.2)."

.COMMAND dst(timestamp, tzone) : bit = timestamp_inside_dst;
	"return whether DST holds in the tzone at a certain point of time (!DS2.2)."

.COMMAND compute(rule, int year) : date = compute_rule_foryear;
	"compute the date from a rule in a certain year (!DS2.2)."

@- day and month names
One day we should introduce the concept of locale, and hook here.
@m
.COMMAND monthnum(str month) : int = month_from_str;
	"Returns month number [1-12] from a string; or nil if does not match any (!DS2.2)."
.COMMAND monthname(int month) : str = month_to_str;
	"Returns month name from a number between [1-12], str(nil) otherwise (!DS2.2)."
.COMMAND daynum(str day) : int = day_from_str;
	"Returns number of day [1-7] from a string; or nil if does not match any (!DS2.2)."
.COMMAND dayname(int day) : str = day_to_str;
	"Returns day name from a number between [1-7], str(nil) otherwise (!DS2.2)."

.COMMAND monettime_synonyms(bit allow) = monettime_synonyms;
	"Allow synonyms for the parse format of date/timestamp in addition ot their print format (!DS2.2)."

.COMMAND olddate (str format) : date = olddate;
	"create a date from the old instant format."
.COMMAND oldduration(str format) : int = oldduration;
        "parse the old duration format and return an (estimated) number of days."

.PRELUDE = monettime_prelude;
.EPILOGUE = monettime_epilogue;

.LOAD
	# default time creation with zeroed secs and msecs
	proc "daytime" (int h) : daytime
		return daytime(h, 0, 0, 0);
	proc "daytime" (int h, int m) : daytime
		return daytime(h, m, 0, 0);
	proc "daytime" (int h, int m, int s) : daytime
		return daytime(h, m, s, 0);

	proc "[daytime]" (bat[any::1,int] h) : bat[any::1,daytime]
		return [daytime](h, 0, 0, 0);
	proc "[daytime]" (bat[any::1,int] h, bat[any::1,int] m) : bat[any::1,daytime]
		return [daytime](h, m, 0, 0);
	proc "[daytime]" (bat[any::1,int] h, bat[any::1,int] s) : bat[any::1,daytime]
		return [daytime](h, m, s, 0);

	# rule creation synonyms
	proc "rule" (int m, int d, int w, int h, int m) : rule
		return rule(m, d, w, (h * 60) + m);
	proc "rule" (int m, str d, int w, int h, int m) : rule
		return rule(m, daynum(d), w, (h* 60) + m);
	proc "rule" (int m, str d, int w, int m) : rule
		return rule(m, daynum(d), w, m);

	proc "[rule]" (bat[any::1,int] m, bat[any::1,int] d, bat[any::1,int] w, 
                    bat[any::1,int] h, bat[any::1,int] m) : bat[any::1,rule]
		return [rule](m, d, w, [+]([*](h,60),m));
	proc "[rule]" (bat[any::1,int] m, bat[any::1,str] d, bat[any::1,int] w, 
                    bat[any::1,int] h, bat[any::1,int] m) : bat[any::1,rule]
		return [rule](m, [daynum](d), w, [+]([*](h,60),m));
	proc "[rule]" (bat[any::1,int] m, bat[any::1,str] d, bat[any::1,int] w, 
                    bat[any::1,int] m) : bat[any::1,rule]
		return [rule](m, [daynum](d), w, m);

        # As a starting point, we provide some standard tzones
	#
	const RULE_MAR := rule("first sunday from end of march@02:00");
	const RULE_OCT := rule("first sunday from end of october@02:00");
	const TIMEZONES := new(str, tzone).col_name("monettime_tzones"); 
	
	TIMEZONES.insert("Wake Island",          tzone( 12*60));
	TIMEZONES.insert("Melbourne/Australia",  tzone( 11*60));
	TIMEZONES.insert("Brisbane/Australia",   tzone( 10*60));
	TIMEZONES.insert("Japan",                tzone( 09*60));
	TIMEZONES.insert("Singapore",            tzone( 08*60));
	TIMEZONES.insert("Thailand",             tzone( 07*60));
	TIMEZONES.insert("Kazakhstan",           tzone( 06*60, RULE_MAR, RULE_OCT)); 
	TIMEZONES.insert("Pakistan",             tzone( 05*60));
	TIMEZONES.insert("United Arab Emirates", tzone( 04*60)); 
	TIMEZONES.insert("Moscow/Russia",        tzone( 03*60, RULE_MAR, RULE_OCT)); 
	TIMEZONES.insert("East/Europe",          tzone( 02*60, RULE_MAR, RULE_OCT)); 
	TIMEZONES.insert("West/Europe",          tzone( 01*60, RULE_MAR, RULE_OCT)); 
	TIMEZONES.insert("GMT",                  tzone( 00*00)); 
	TIMEZONES.insert("UK",                   tzone( 00*00, RULE_MAR, RULE_OCT)); 
	TIMEZONES.insert("Azore Islands",        tzone(-01*60)); 
	TIMEZONES.insert("Eastern/Brazil",       tzone(-02*60, RULE_OCT, RULE_MAR)); 
	TIMEZONES.insert("Western/Brazil",       tzone(-03*60, RULE_OCT, RULE_MAR)); 
	TIMEZONES.insert("Andes/Brazil",         tzone(-04*60, RULE_OCT, RULE_MAR)); 
	TIMEZONES.insert("East/USA",             tzone(-05*60, RULE_MAR, RULE_OCT)); 
	TIMEZONES.insert("Central/USA",          tzone(-06*60, RULE_MAR, RULE_OCT)); 
	TIMEZONES.insert("Mountain/USA",         tzone(-07*60, RULE_MAR, RULE_OCT)); 
	TIMEZONES.insert("Alaska/USA",           tzone(-09*60, RULE_MAR, RULE_OCT)); 
	TIMEZONES.insert("Hawaii/USA",           tzone(-10*60)); 
	TIMEZONES.insert("American Samoa",       tzone(-11*60)); 

	proc TIMEZONE( str name ) : tzone {
		if (not(TIMEZONES.exist(name))) name := "GMT";
		return TIMEZONES.find(name);
	}

	tzone_local(TIMEZONE("West/Europe"));

	proc "[date]" (bat[any::1,timestamp] t) : bat[any::1,date]
		return [date](t, tzone_local());
	proc "[daytime]" (bat[any::1,timestamp] t) : bat[any::1,daytime]
		return [daytime](t, tzone_local());
	proc "[timestamp]" (bat[any::1,date] d, bat[any::1,daytime] t) : bat[any::1,timestamp]
		return [timestamp](d, t, tzone_local());

	# unix-time (epoch) support: seconds since 1-jan-1970 GMT
	const EPOCH := timestamp(date(1970,1,1),daytime(0,0,0,0),tzone("GMT"));

	proc timestamp(int secs) : timestamp
		return EPOCH.add(lng(secs) * lng(1000));
	proc epoch(timestamp t) : int 
		return int(diff(t, EPOCH)/lng(1000));

	proc [timestamp](bat[any::1,int] secs) : bat[any::1,timestamp]
		return [add](EPOCH, [*]([lng](secs),lng(1000)));
	proc [epoch](bat[any::1,timestamp] t) : bat[any::1,int]
		return [int]([/]([diff](t, EPOCH), lng(1000)));

	proc msecs(int d, int h, int m, int s, int ms) : lng
		return lng(ms) + (lng(1000) * (lng(s) + (lng(60) * (lng(m) + 
                                    (lng(60) * (lng(h) + (lng(24) * lng(d))))))));
.END;

.PRELUDE = date_prelude;

.END monettime;

@+ Test Script

The below tests try to be exhaustive in trying all time functionality.
@mil
module(monettime,alarm);

@- rule
@mil
# test the various ways to create rules
var rule_jan := rule("1st MON from start of JAN@01:15");
var rule_mar := rule("first WEDNE on or after march 10@01:15");
var rule_apr := rule("last THU on or before aPr 1@01:15");
var rule_may := rule("MAY 26@01:15");
var rule_jun := rule("2nd TUE from end of june@01:15");
var rule_jul := rule(7,1,1,75);
var rule_aug := rule(8,-1,1,75);
var rule_sep := rule(9,-10,3,75);
var rule_oct := rule(10,31,0,75);
var rule_nov := rule(11,-10,-4,75);
# nil rules
var rule_dec := rule(12,-31,0,75);
var rule_feb := rule("first fRiDaY on or after february 30@01:15");
 
var rule_bat := new(str,rule,10);
rule_bat.insert("jan",rule_jan).insert("feb",rule_feb).insert("mar",rule_mar).insert("apr",rule_apr);
rule_bat.insert("may",rule_may).insert("jun",rule_jun).insert("jul",rule_jul).insert("aug",rule_aug);
rule_bat.insert("sep",rule_sep).insert("oct",rule_oct).insert("nov",rule_nov).insert("dec",rule_dec);

# test the operations on rules
print(rule_bat.col_name("rule"),
      [month](rule_bat).col_name("month"),
      [weekday](rule_bat).col_name("weekday"),
      [day](rule_bat).col_name("day"),
      [minutes](rule_bat).col_name("minutes"));

print(rule_bat.col_name("rule"),
      [compute](rule_bat, 2001).col_name("2001"),
      [dayname]([dayofweek]([compute](rule_bat, 2001))).col_name("2001"),
      [compute](rule_bat, 1999).col_name("1999"),
      [dayname]([dayofweek]([compute](rule_bat, 1999))).col_name("1999"),
      [compute](rule_bat, 1992).col_name("1992"),
      [dayname]([dayofweek]([compute](rule_bat, 1992))).col_name("1992"));

print(rule_bat.col_name("rule"),
      [compute](rule_bat, 1572).col_name("1572"),
      [dayname]([dayofweek]([compute](rule_bat, 1572))).col_name("1572"),
      [compute](rule_bat, 1).col_name("1"),
      [dayname]([dayofweek]([compute](rule_bat, 1))).col_name("1"),
      [compute](rule_bat, -2000).col_name("-2000"),
      [dayname]([dayofweek]([compute](rule_bat, -2000))).col_name("-2000"));

@- tzone
@mil
# test the various ways to create tzones, using some of the above created rules
var tzone_00 := tzone("GMT");
var tzone_01 := tzone("GMT+01:00");
var tzone_02 := tzone("GMT+0100");
var tzone_03 := tzone(60, rule_oct, rule_mar);
var tzone_04 := tzone(0, rule_jan, rule_aug);
var tzone_05 := tzone(-97, rule_oct, rule_apr);
var tzone_06 := tzone(-97, rule_may, rule_sep);
var tzone_07 := tzone(23*60, rule_apr, rule_nov);
var tzone_08 := tzone((-23*59) - 59);
var tzone_09 := tzone(0);
var tzone_10 := tzone(-60);
var tzone_11 := tzone((23*60)+59);
var tzone_12 := tzone(60);
# nil tzones
var tzone_13 := tzone(60, rule_feb, rule_dec);
var tzone_15 := tzone(24*60, rule_apr, rule_nov);


var tzone_bat := new(oid,tzone);
tzone_bat.insert(00@0, tzone_00).insert(01@0, tzone_01).insert(02@0, tzone_02);
tzone_bat.insert(03@0, tzone_03).insert(04@0, tzone_04).insert(05@0, tzone_05);
tzone_bat.insert(06@0, tzone_06).insert(07@0, tzone_07).insert(08@0, tzone_08);
tzone_bat.insert(09@0, tzone_09).insert(10@0, tzone_10).insert(11@0, tzone_11);
tzone_bat.insert(12@0, tzone_12).insert(13@0, tzone_13).insert(15@0, tzone_15);

# test the operations on tzones
print(tzone_bat.col_name("tzone"));
print([minutes](tzone_bat).col_name("minutes"),
      [start_dst](tzone_bat).col_name("start_dst"),
      [end_dst](tzone_bat).col_name("end_dst"));

@- date
@mil
# test the various ways to create dates
var date_00 := date(2000,01,01);
var date_01 := date("5000-JAN-01");
var date_02 := date("1968-FEBR-29");
var date_03 := date("1-MARCH-01");
var date_04 := date("-5867411-JAN-1");
var date_05 := date("-768/octobe/01");
var date_06 := date("5000\\novembe\\01");
var date_07 := date("-1999/jun/01");
var date_08 := date("2000-jul-14");
var date_09 := date("1999-sept-01");
var date_10 := date("1998-decemBeR-01");
var date_11 := date("1953 may                01");
var date_12 := date("5867411-DEC-31");
# nil dates
var date_13 := date(1996,13,1);
var date_14 := date("999999999999999999999-01-01");
var date_15 := date("1999-JANUARI-01");
var date_16 := date("1999-FEBR-29");
var date_17 := date("-1-DECEMBER-0");
var date_18 := date("5000\novembe\31");
var date_19 := date("nil");
var date_20 := date("1999-sept-31");

var date_bat := new(oid,date);
date_bat.insert(00@0, date_00).insert(01@0, date_01).insert(02@0, date_02);
date_bat.insert(03@0, date_03).insert(04@0, date_04).insert(05@0, date_05);
date_bat.insert(06@0, date_06).insert(07@0, date_07).insert(08@0, date_08);
date_bat.insert(09@0, date_09).insert(10@0, date_10).insert(11@0, date_11);
date_bat.insert(12@0, date_12).insert(13@0, date_13).insert(14@0, date_14);
date_bat.insert(15@0, date_15).insert(16@0, date_16).insert(17@0, date_17);
date_bat.insert(18@0, date_18).insert(19@0, date_19).insert(20@0, date_20);

# test the operations on dates
print(date_bat.col_name("date"),
      [year](date_bat).col_name("year"),
      [day](date_bat).col_name("day"),
      [monthname]([month](date_bat)).col_name("monthname"),
      [monthnum]([monthname]([month](date_bat))).col_name("monthnum"));

var date_addyears := [addyears](date_bat, -100);
var date_addmonths := [addmonths](date_bat, 1);

print(date_bat.col_name("date"),
      date_addyears.col_name("min100y"),
      [diff](date_addyears, date_bat).col_name("diff"));

print(date_bat.col_name("date"),
      date_addmonths.col_name("plus1m"),
      [diff](date_addmonths, date_bat).col_name("diff"));

# test dayofweek and weeknumber using more than two years as consecutive days
var date_seq := new(int, date);
var i := -375;
while ((i :+= 1) < 375) {
	date_seq.insert(i,adddays(date_00,i));
}
print(date_seq.col_name("date"),
      [weekofyear](date_seq).col_name("weekofyear"),
      [dayname]([dayofweek](date_seq)).col_name("dayofweek"),
      [daynum]([dayname]([dayofweek](date_seq))).col_name("num"),
      [dayofyear](date_seq).col_name("dayofyear"));

@- daytime
@mil
# test the various ways top create daytimes
var daytime_00 := daytime(23,59,59,999);
var daytime_01 := daytime("23:59");
var daytime_02 := daytime("00:00");
var daytime_03 := daytime("23:59:59");
var daytime_04 := daytime("00:00:00.000");
var daytime_05 := daytime("00:00:00");
var daytime_06 := daytime("00:00:00:001");
var daytime_07 := daytime("03:49:02.999");
var daytime_08 := daytime("20:48:42:999");
var daytime_09 := daytime("17:53:38:999");
var daytime_10 := daytime("13:15:34:999");
var daytime_11 := daytime("07:34:27.999");
var daytime_12 := daytime("23:59:59:999");
var daytime_13 := daytime("01:00:03.999");
var daytime_14 := daytime("23:59:59.999");
# nil daytimes
var daytime_15 := daytime(24,59,59,999);
var daytime_16 := daytime(23,60,59,999);
var daytime_17 := daytime(23,59,60,999);
var daytime_18 := daytime(23,59,60,1000);
var daytime_19 := daytime("nil");

var daytime_bat := new(oid,daytime);
daytime_bat.insert(00@0, daytime_00).insert(01@0, daytime_01).insert(02@0, daytime_02);
daytime_bat.insert(03@0, daytime_03).insert(04@0, daytime_04).insert(05@0, daytime_05);
daytime_bat.insert(06@0, daytime_06).insert(07@0, daytime_07).insert(08@0, daytime_08);
daytime_bat.insert(09@0, daytime_09).insert(10@0, daytime_10).insert(11@0, daytime_11);
daytime_bat.insert(12@0, daytime_12).insert(13@0, daytime_13).insert(14@0, daytime_14);
daytime_bat.insert(15@0, daytime_15).insert(16@0, daytime_16).insert(17@0, daytime_17);
daytime_bat.insert(18@0, daytime_18).insert(19@0, daytime_19);

print(daytime_bat.col_name("daytime"),
      [hours](daytime_bat).col_name("hours"),
      [minutes](daytime_bat).col_name("minutes"),
      [seconds](daytime_bat).col_name("seconds"),
      [milliseconds](daytime_bat).col_name("milliseconds"));

@- timestamp
@mil
# create timestamps in bulk from the above bats with dates, daytimes and tzones
var timestamp_bat := [timestamp](date_bat,daytime_bat,tzone_bat).access(BAT_WRITE);
# KILL
# var timestamp_now := timestamp(epoch());
# timestamp_bat.insert(14@0, timestamp_now);

# test the timestamp operations
print(timestamp_bat.col_name("timestamp"),
      [date](timestamp_bat,tzone_bat).col_name("date"),
      [daytime](timestamp_bat,tzone_bat).col_name("daytime"));

print(timestamp_bat.col_name("timestamp"),
      [date](timestamp_bat,TIMEZONE("Wake Island")).col_name("Wake Island"),
      [daytime](timestamp_bat,TIMEZONE("Wake Island")),
      [date](timestamp_bat,TIMEZONE("American Samoa")).col_name("American Samoa"),
      [daytime](timestamp_bat,TIMEZONE("American Samoa")));

var timestamp_plus := [add](timestamp_bat, lng(23*60*60*1000));
var timestamp_minus := [add](timestamp_bat, lng(-60*1000));

print(timestamp_bat.col_name("timestamp"),
	timestamp_plus.col_name("plus23"),
	timestamp_minus.col_name("min1"),
	[/]([diff](timestamp_plus, timestamp_minus),lng(60*60*1000)).col_name("diff"));

var timestamp_eur := [timestamp](date_seq, daytime_00, TIMEZONE("West/Europe"));
var timestamp_bra := [timestamp](date_seq, daytime_00, TIMEZONE("Andes/Brazil"));

print(date_seq.col_name("date"), 
	[dayname]([dayofweek](date_seq)).col_name("day"),
	timestamp_eur.col_name("West/Europe"),
	[dst](timestamp_eur,TIMEZONE("West/Europe")).col_name("dst"),
	timestamp_bra.col_name("Andes/Brazil"),
	[dst](timestamp_bra,TIMEZONE("Andes/Brazil")).col_name("dst"));

quit;
@{
@* Implementation

@+ Atoms

@- date
Internally, we store date as the (possibly negative) number of 
days since the start of the calendar. Oddly, since I (later) learned
that the year 0 did no exist, this defines the start of the calendar to
be jan 1 of the year -1 (in other words, a -- positive -- year component 
of a date is equal to the number of years that have passed since the start 
of the calendar).
@h
#ifndef _MONETTIME_H_
#define _MONETTIME_H_

#ifdef __cplusplus
extern "C" {
#endif

#include <gdk.h>

typedef int date;
@c
#include "monettime.h" 

@- daytime
Daytime values are also stored as the number of milliseconds that passed since 
the start of the day (i.e. midnight).
@h
typedef int daytime;

@- timestamp
Timestamp is implemented as a record that contains a date and a time (GMT).  
@h
typedef struct {
#ifndef WORDS_BIGENDIAN
	daytime msecs; 
	date days;
#else
	date days;
	daytime msecs; 
#endif
	} timestamp;

@- rule
rules are used to define the start nad end of DST. It uses the 25 lower bits of an int.
@h
typedef struct {
	unsigned int   month:4,    /* values: [1..12] */
                       minutes:11, /* values: [0:1439] */
		       day:6,      /* values: [-31..-1,1..31] */
		       weekday:4,  /* values: [-7..-1,1..7] */
		       empty:7;	   /* rule uses just 32-7=25 bits */
	} rule;
@c
#define get_rule(r)	((r).weekday | ((r).day<<6) | ((r).minutes<<10) | ((r).month<<21))
#define set_rule(r,i) { (r).weekday = (i)&15;\
			(r).day = ((i)&(63<<6))>>6;\
			(r).minutes = ((i)&(2047<<10))>>10;\
			(r).month = ((i)&(15<<21))>>21; }

/* phony zero values, used to get negative numbers from unsigned sub-integers in rule */
#define WEEKDAY_ZERO	8
#define DAY_ZERO	32
#define OFFSET_ZERO	4096

@- tzone
A tzone consists of an offset and two DST rules, all crammed into one lng.
@h
typedef struct {
		/* we had this as bitfields in one unsigned long long, but native sun CC does not eat that.  */
		unsigned int dst:1, off1:6, dst_start:25;
		unsigned int off2:7, dst_end:25; 
	} tzone;
@c
/* as the offset field got split in two, we need macros to get and set them */
#define get_offset(z)	(((int) (((z)->off1 << 7) + (z)->off2)) - OFFSET_ZERO)
#define set_offset(z,i)	{ (z)->off1 = (((i)+4096)&8064) >> 7; (z)->off2 = ((i)+OFFSET_ZERO)&127; } 

tzone tzone_local;
@h
#include "monettime.proto.h" /* generated definitions by mel */
extern void fromdate(int n, int* d, int* m, int* y);
extern void fromtime(int n, int *hour, int *min, int *sec, int *msec);

#ifdef __cplusplus
}
#endif

#endif /* _MONETTIME_H_ */

@+ Defines
@c
str MONTHS[13] = { NULL, "january", "february", "march", "april", "may", "june", 
		   "july", "august", "september", "october", "november", "december" };
str DAYS[8] =    { NULL, "sunday", "monday", "tuesday", "wednesday", "thursday", 
		   "friday", "saturday" };
str COUNT1[7] =  { NULL, "first", "second", "third", "fourth", "fifth", "last" };
str COUNT2[7] =  { NULL, "1st", "2nd", "3rd", "4th", "5th", "last" };
int NODAYS[13] = { 0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };

date DATE_MAX, DATE_MIN; /* often used dates; computed once */

#define YEAR_MAX 	5867411
#define YEAR_MIN 	-YEAR_MAX
#define MONTHDAYS(m,y)	(((m)!=2)?NODAYS[m]:leapyear(y)?29:28)
#define YEARDAYS(y)	(leapyear(y)?366:365)
#define LEAPYEARS(y)	(leapyears(y)+((y)>=0))
#define DATE(d,m,y) 	((m)>0&&(m)<=12&&(d)>0&&(y)!=0&&(y)>=YEAR_MIN&&(y)<=YEAR_MAX&&(d)<=MONTHDAYS(m,y))
#define TIME(h,m,s,x)	((h)>=0&&(h)<24&&(m)>=0&&(m)<60&&(s)>=0&&(s)<60&&(x)>=0 &&(x)<1000)
#define LOWER(c)   	(((c) >= 'A' && (c) <= 'Z') ? (c)+'a'-'A' : (c))

@+ auxiliary functions
@c

static timestamp ts_nil = {-1,-1};
static tzone tz_nil = {0,12,0,0,0};
static timestamp *ts_nilptr = NULL;
static tzone *tz_nilptr = NULL;

void monettime_prelude(void){
	ts_nilptr = (timestamp*)GDKmalloc(sizeof(timestamp));
	*ts_nilptr = ts_nil;
	tz_nilptr = (tzone*)GDKmalloc(sizeof(tzone));
	*tz_nilptr = tz_nil;
}
void monettime_epilogue(void){
	GDKfree(ts_nilptr);
	GDKfree(tz_nilptr);
}

timestamp*
timestamp_null() {
	return (ts_nilptr);
}
tzone*
tzone_null() {
	return (tz_nilptr);
}

static int synonyms = TRUE;

int monettime_synonyms(bit* allow) {
	if (*allow != bit_nil) synonyms = *allow;
	return GDK_SUCCEED;
}

static INLINE
int leapyear(int year) {
	int ret = !(year%4);
	if (!(year%100) && year%400) ret = 0;
	return year?ret:1;
}

static INLINE
int leapyears(int year) {
	/* count the 4-fold years that passed since jan-1-0 */
	int y4 = year/4;

	/* count the 100-fold years */
	int y100 = year/100;

	/* count the 400-fold years */
	int y400 = year/400;

	return y4 + y400 - y100; /* may be negative */
}

static INLINE
int todate(int day, int month, int year){
	int n = int_nil;
	if (DATE(day, month, year)) { 
		if (year < 0) year++; /* HACK: hide year 0 */
		for(n = day-1; --month > 0; n += MONTHDAYS(month,year));
		/* current year does not count as leapyear */ 
		n += 365*year + LEAPYEARS(year>=0?year-1:year);
	}
	return n;
}

void fromdate(int n, int* d, int* m, int* y){
	int month, year = n/365;
	int day = (n-year*365) - LEAPYEARS(year>=0?year-1:year);
	if (n < 0) {
		year--; 
		while(day >= 0) {
			year++;
			day -= YEARDAYS(year);
		}
		day = YEARDAYS(year) + day;
	} else {
		while(day < 0) {
			year--;
			day += YEARDAYS(year);
		}
	} day++;
	for(month=1; month<=12; month++) {
		int days = MONTHDAYS(month,year);
		if (day <= days) break;
		day -= days;
	}
	if (n != int_nil) {
		*d = day; *m = month; 
		*y = (year<=0)?year-1:year;  /* HACK: hide year 0 */
	} else {
		*d = *m = *y = int_nil;
	}
}

static INLINE
int totime(int hour, int min, int sec, int msec) {
	if (TIME(hour,min,sec,msec)) {
		return ((((hour*60)+min)*60)+sec)*1000 + msec;
	}
	return int_nil;
}

void fromtime(int n, int *hour, int *min, int *sec, int *msec) {
	if (n != int_nil) {
		*hour = n/3600000; n -= (*hour)*3600000;
		*min = n/60000; n -= (*min)*60000;
		*sec = n/1000; n -= (*sec)*1000;
		*msec = n;
	} else {
		*hour = *min = *sec = *msec = int_nil;
	}
}

/* matches regardless of case and extra spaces */
static INLINE
int fleximatch(str s, str pat, int min) {
	int hit, spacy = 0;

	if (min == 0) {
		min = strlen(pat); /* default mininum required hits */
	}
	for(hit = 0; *pat; s++, hit++) {
		if (LOWER(*s) != *pat) {
			if (GDKisspace(*s) && spacy) {
				min++; continue; /* extra spaces */
			} break;
		}
		spacy = GDKisspace(*pat);
		pat++;
	}
	return (hit >= min)?hit:0;
}

static INLINE
int parse_substr(int* ret, str s, int min, str list[], int size) {
	int j = 0, i = 0;
	*ret = int_nil;
	while(++i <= size) {
		if ((j = fleximatch(s, list[i], min)) > 0) {
			*ret = i; break;
		}	
	}
	return j;
}

static INLINE
int date_dayofweek(int v) {
	v %= 7;
	return (v <= 0)?v+7:v;
}

#define SKIP_DAYS(d,w,i) d += i; w = (w + i)%7; if (w <= 0) w += 7;

static INLINE
date compute_rule(rule* val, int y) {
	int m = val->month, cnt = ABS(val->day - DAY_ZERO);
	date d = todate(1,m,y);
	int dayofweek = date_dayofweek((int) d);
	int w = ABS(val->weekday - WEEKDAY_ZERO);

	if (val->weekday == WEEKDAY_ZERO) {
		/* cnt-th of month */
		d += cnt - 1;
	} else if (val->day > DAY_ZERO) {
		if (val->weekday < WEEKDAY_ZERO) {
			/* first weekday on or after cnt-th of month */
			SKIP_DAYS(d,dayofweek,cnt-1);
			cnt = 1;
		} /* ELSE cnt-th weekday of month */
		while(dayofweek != w || --cnt > 0) {
			if (++dayofweek == 8) dayofweek = 1;
			d++;
		}
	} else {
		if (val->weekday > WEEKDAY_ZERO) {
			/* cnt-last weekday from end of month */
			SKIP_DAYS(d,dayofweek,MONTHDAYS(m,y)-1);
		} else {
			/* first weekday on or before cnt-th of month */
			SKIP_DAYS(d,dayofweek,cnt-1);
			cnt = 1;
		}
		while(dayofweek != w || --cnt > 0) {
			if (--dayofweek == 0) dayofweek = 7;
			d--;
		}
	}
	return d;
}

static int dummy;

#define BEFORE(d1,m1,d2,m2) (d1 < d2 || (d1 == d2 && m1 <= m2)) 

#define ts_isnil(t) ((t).days == -1 && (t).msecs == -1)
#define tz_isnil(z) ((z).dst == (z).off2 == (z).dst_start == (z).dst_end == 1 \
			&& (z).off1 == 12 )

static INLINE
int timestamp_inside(timestamp *ret, timestamp *t, tzone* z, lng offset) {
	/* starts with GMT time t, and returns whether it is in the DST for z */
	lng add = (offset != (lng)0) ? offset : (get_offset(z)) * (lng)60000;
	int start_days, start_msecs, end_days, end_msecs, year;
	rule start, end;

	timestamp_add(ret, t, &add);

	if (ts_isnil(*ret) || z->dst == 0) {
		return 0;
	}
	set_rule(start, z->dst_start);
	set_rule(end, z->dst_end);

	start_msecs = start.minutes*60000;
	end_msecs = end.minutes*60000;

	fromdate(ret->days, &dummy, &dummy, &year);
	start_days = compute_rule(&start, year);
	end_days = compute_rule(&end, year);	

	return BEFORE(start_days,start_msecs, end_days,end_msecs)?
		(BEFORE(start_days,start_msecs, ret->days,ret->msecs) 
		  && BEFORE(ret->days,ret->msecs, end_days,end_msecs)):
		(BEFORE(start_days,start_msecs, ret->days,ret->msecs) 
		  || BEFORE(ret->days,ret->msecs, end_days,end_msecs));
}


@+ ADT implementations
@- date
@c
int date_fromstr(str buf, int *len, date **d) {
	int day=0, month=int_nil, year=0, yearneg=(buf[0]=='-'), yearlast=0, pos=0, sep;
	if (*len < (int) sizeof(date)) {
		if (*d) GDKfree(*d);
		*d = (date*) GDKmalloc(*len=sizeof(date));
	}
	**(int**) d = int_nil;
	if (yearneg == 0 && !GDKisdigit(buf[0])) {
		if (synonyms == 0) return 0;
		yearlast = 1;
		sep = ' ';
	} else {
		for(pos=yearneg; GDKisdigit(buf[pos]); pos++) {
			year = (buf[pos] - '0') + year * 10;
			if (year > YEAR_MAX) break;
		}
		sep = buf[pos++]; 
		if (synonyms == 0 && sep != '-') {
			return 0;
		}
		sep = LOWER(sep);
		if (sep >= 'a' && sep <= 'z') {
			sep = 0;
		} else if (sep == ' ') {
			while(buf[pos] == ' ') pos++;
		} else if (sep != '-' && sep != '/' && sep != '\\') {
			return 0; /* syntax error */
		} 
	}
	if (GDKisdigit(buf[pos])) {
		month = buf[pos++] - '0'; 
		if (GDKisdigit(buf[pos])) {
			month = (buf[pos++] - '0') + month*10;  
		}
	} else if (synonyms == 0) {
		return 0;
	} else {
		pos += parse_substr(&month, buf+pos, 3, MONTHS, 12);
	}
	if (month == int_nil || (sep && buf[pos++] != sep)) {
		return 0; /* syntax error */
	}
	if (sep == ' ') {
		while(buf[pos] == ' ') pos++;
	}
	if (!GDKisdigit(buf[pos])) {
		return 0; /* syntax error */
	}
	while(GDKisdigit(buf[pos])) {
		day = (buf[pos++] - '0') + day * 10;
		if (day > 31) break;
	}
	if (yearlast && buf[pos] == ',') {
		while(buf[++pos] == ' ');
		if (buf[pos] == '-') {
			yearneg = 1; pos++;
		}
		while(GDKisdigit(buf[pos])) {
			year = (buf[pos++] - '0') + year * 10;
			if (year > YEAR_MAX) break;
		}
	}
	/* handle semantic error here (returns nil in that case) */
	**d = todate(day, month, yearneg?-year:year);
	return pos;
}

int date_tostr(str* buf, int* len, date* val) {
	int day, month, year;
	fromdate(*(int*) val, &day, &month, &year);
	/* longest possible string: "-5867411-01-01" i.e. 14 chars
	   without NUL (see definition of YEAR_MIN/YEAR_MAX above) */
	if (*len < 15) {
		if (*buf) GDKfree(*buf);
		*buf = (str) GDKmalloc(*len = 15);
	}
	if (*(int*) val == int_nil || !DATE(day,month,year)) {
		strcpy(*buf, "nil");
		return 3;
	}
	sprintf(*buf, "%d-%02d-%02d", year, month, day);
	return strlen(*buf);
}

@- daytime
@c
int daytime_fromstr(str buf, int *len, daytime **ret) {
	int hour, min, sec=0, msec=0, pos=0;

	if (*len < (int) sizeof(daytime)) {
		if (*ret) GDKfree(*ret);
		*ret = (daytime*) GDKmalloc(*len=sizeof(daytime));
	}
	**(int**) ret = int_nil;
	if (!GDKisdigit(buf[pos])) {
		return 0; /* syntax error */
	}
	for(hour=0; GDKisdigit(buf[pos]); pos++)  {
		if (hour <= 24) 
		hour = (buf[pos] - '0') + hour * 10;
	}
	if ((buf[pos++] != ':') || !GDKisdigit(buf[pos])) {
		return 0; /* syntax error */
	}
	for(min=0; GDKisdigit(buf[pos]); pos++)  {
		if (min <= 60) 
		min = (buf[pos] - '0') + min * 10;
	}
	if ((buf[pos] == ':') && GDKisdigit(buf[pos+1])) {
		for(pos++,sec=0; GDKisdigit(buf[pos]); pos++)  {
			if (sec <= 60) 
			sec = (buf[pos] - '0') + sec * 10;
		}
		if ((buf[pos] == '.' || (synonyms && buf[pos] == ':')) && GDKisdigit(buf[pos+1])) {
			for(pos++,msec=0; GDKisdigit(buf[pos]); pos++)  {
				if (msec <= 1000) 
				msec = (buf[pos] - '0') + msec * 10;
			}
		}
	}
	/* handle semantic error here (returns nil in that case) */
	**(int**)ret = totime(hour,min,sec,msec);
	return pos;
}

int daytime_tostr(str* buf, int* len, daytime *val) {
	int hour, min, sec, msec;
	fromtime(*(int*) val, &hour, &min, &sec, &msec);
	if (*len < 12) {
		if (*buf) GDKfree(*buf);
		*buf = (str) GDKmalloc(*len = 13);
	}
	if (*(int*) val == int_nil || !TIME(hour,min,sec,msec)) {
		strcpy(*buf, "nil");
		return 3;
	}
	sprintf(*buf, "%02d:%02d:%02d.%03d", hour, min, sec, msec);
	return 12;
}

@- timestamp
@c
int timestamp_fromstr(str buf, int *len, timestamp **ret) {
	str s = buf;
	int pos;
	date* d;
	daytime* t;

	if (*len < (int) sizeof(timestamp)) {
		if (*ret) GDKfree(*ret);
		*ret = (timestamp*) GDKmalloc(*len=sizeof(timestamp));
	}
	d = &(*ret)->days;
	t = &(*ret)->msecs;
	s += date_fromstr(buf, len, &d);
	if (s > buf && (*(s) == '@' || *s == ' ' || *s == '-')) {
		while(*(++s) == ' ');
		pos = daytime_fromstr(s, len, &t);
		s = pos?s+pos:buf;
	} else {
		(*ret)->msecs = int_nil;
	}
	if (s <= buf || (int) (*ret)->days == int_nil || (int) (*ret)->msecs == int_nil) {
		**ret = ts_nil;
	} else {
	    lng offset;

	    while(GDKisspace(*s)) s++;
	    if (fleximatch(s, "gmt", 0) == 3 && (s[3] == '-' || s[3] == '+') &&
		   GDKisdigit(s[4]) && GDKisdigit(s[5]) && GDKisdigit(s[pos=7]) &&
		   ((s[6] == ':' && GDKisdigit(s[8])) || GDKisdigit(s[pos=6])))
	    {
		offset = (((s[4] - '0')*(lng)10 + (s[5] - '0'))*(lng)60 + 
		              (s[pos] - '0')*(lng)10 + (s[pos+1] - '0'))*(lng)60000;
		pos++;
		if (s[3] != '-') offset = -offset;
		s += pos;
	    } else {
		/* if no tzone is specified; work with the local */
		timestamp tmp = **ret;
		offset = get_offset(&tzone_local) * (lng)-60000; 
		if (timestamp_inside(&tmp, &tmp, &tzone_local, (lng)-3600000)) { 
			**ret = tmp; 
		}
	    }
	    timestamp_add(*ret, *ret, &offset); 
	}
	return s-buf;
}

int timestamp_tostr(str* buf, int* len, timestamp *val) {
	int len1, len2, big=128, off=get_offset(&tzone_local);
	char buf1[128], buf2[128], *s, *s1=buf1, *s2=buf2;
	timestamp tmp = *val;

	if (timestamp_inside(&tmp, val, &tzone_local, (lng)0)) { 
		lng add = (lng)3600000; 
		timestamp_add(&tmp, &tmp, &add); 
		off += 60;
	}
	len1 = date_tostr(&s1, &big, &tmp.days);
	len2 = daytime_tostr(&s2, &big, &tmp.msecs);

	if (*len < 2+len1+len2) {
		if (*buf) GDKfree(*buf);
		*buf = (str) GDKmalloc(*len = len1+len2+2);
	} s = *buf;
	if (ts_isnil(tmp)) {
		strcpy(s, "nil");
		return 3;
	}
	strcpy(s, buf1); s += len1;
	*s++ = ' '; 
	strcpy(s, buf2); s += len2;
/* omit GMT distance in order not to cinfuse the confused user
	strcpy(s, "GMT"); s += 3;
	if (off) {
		*s++ = (off>=0)?'+':'-';
		sprintf(s, "%02d%02d", ABS(off)/60, ABS(off)%60); 
		s += 4;
	}
 */
	return s - *buf;
}

str count1(int i) {
	static char buf[16];
	if (i <= 0) {
		return "(illegal number)";
	} else if (i < 6) {
		return COUNT1[i];
	}
	sprintf(buf, "%dth", i);
	return buf;
}

@- rule
@c
int rule_tostr(str* buf, int* len, rule *r) {
	int hours = r->minutes/60;
	int minutes = r->minutes%60;
	if (*len < 64) {
		if (*buf) GDKfree(*buf);
		*buf = (str) GDKmalloc(*len = 64);
	}
	if (*(int*) r == int_nil) {
		strcpy(*buf, "nil");
	} else if (r->weekday == WEEKDAY_ZERO) {
		sprintf(*buf, "%s %d\@%02d:%02d", MONTHS[r->month], r->day - DAY_ZERO, hours, minutes);
	} else if (r->weekday > WEEKDAY_ZERO && r->day > DAY_ZERO) {
		sprintf(*buf, "%s %s from start of %s\@%02d:%02d", count1(r->day - DAY_ZERO), 
			DAYS[r->weekday - WEEKDAY_ZERO], MONTHS[r->month], hours, minutes);
	} else if (r->weekday > WEEKDAY_ZERO && r->day < DAY_ZERO) {
		sprintf(*buf, "%s %s from end of %s\@%02d:%02d", count1(DAY_ZERO - r->day), 
			DAYS[r->weekday - WEEKDAY_ZERO], MONTHS[r->month], hours, minutes);
	} else if (r->day > DAY_ZERO) {
		sprintf(*buf, "first %s on or after %s %d\@%02d:%02d", DAYS[WEEKDAY_ZERO - r->weekday], 
			MONTHS[r->month], r->day - DAY_ZERO, hours, minutes);
	} else {
		sprintf(*buf, "last %s on or before %s %d\@%02d:%02d", DAYS[WEEKDAY_ZERO - r->weekday], 
			MONTHS[r->month],  DAY_ZERO - r->day, hours, minutes);
	}
	return strlen(*buf);
}

int rule_fromstr(str buf, int *len, rule **d) {
	int day=0, month=0, weekday=0, hours=0, minutes=0;
	int neg_day = 0, neg_weekday = 0, pos;
	str cur = buf;

	if (*len < (int) sizeof(rule)) {
		if (*d) GDKfree(*d);
		*d = (rule*) GDKmalloc(*len = sizeof(rule));
	}
	**(int**)d = int_nil;

	/* start parsing something like "first", "second", .. etc */
	pos = parse_substr(&day, cur, 0, COUNT1, 6);
	if (pos == 0) {
		pos = parse_substr(&day, cur, 0, COUNT2, 6);
	}
	if (pos && cur[pos++] == ' ') {
		/* now we must see a weekday */
		cur += pos;
		cur += parse_substr(&weekday, cur, 3, DAYS, 7);
		if (weekday == int_nil) {
			return 0; /* syntax error */
		} 
		pos = fleximatch(cur, " from start of ", 0);
		if (pos == 0) {
			pos = fleximatch(cur, " from end of ", 0);
			if (pos) neg_day = 1;
		}	
		if (pos && day < 6) {
			/* RULE 1+2: X-th weekday from start/end of month */
			pos = parse_substr(&month, cur += pos, 3, MONTHS, 12);
		} else if (day == 1) {
			/* RULE 3: first weekday on or after-th of month */
			pos = fleximatch(cur, " on or after ", 0);
			neg_weekday = 1;
			day = int_nil; /* re-read below */
		} else if (day == 6) {
			/* RULE 4: last weekday on or before X-th of month */
			pos = fleximatch(cur, " on or before ", 0);
			neg_weekday = neg_day = 1;
			day = int_nil; /* re-read below */
		} 
		if (pos == 0) {
			return 0; /* syntax error */
		} cur += pos;
	} 
	if (day == int_nil) {
		/* RULE 5:  X-th of month */
		cur += parse_substr(&month, cur, 3, MONTHS, 12);
		if (month == int_nil || *cur++ != ' ' || !GDKisdigit(*cur)) {
			return 0; /* syntax error */
		} day = 0;
		while(GDKisdigit(*cur) && day < 31) {
			day = (*(cur++) - '0') + day*10;
		}
	} 

	/* parse hours:minutes */
	if (*cur++ != '\@' || !GDKisdigit(*cur)) {
		return 0; /* syntax error */
	}
	while(GDKisdigit(*cur) && hours < 24) {
		hours = (*(cur++) - '0') + hours*10;
	}
	if (*cur++ != ':' || !GDKisdigit(*cur)) {
		return 0; /* syntax error */
	}
	while(GDKisdigit(*cur) && minutes < 60) {
		minutes = (*(cur++) - '0') + minutes*10;
	}

	/* assign if semantically ok */	
	if (day >= 1 && day <= NODAYS[month] && hours >= 0 && 
            hours < 60 && minutes >= 0 && minutes < 60)
	{
		(*d)->month = month;
		(*d)->weekday = WEEKDAY_ZERO + (neg_weekday?-weekday:weekday);
		(*d)->day = DAY_ZERO + (neg_day?-day:day);
		(*d)->minutes = hours*60 + minutes;
	}
	return cur - buf;
}

@- tzone
@c
int tzone_fromstr(str buf, int *len, tzone **d) {
	int hours = 0, minutes = 0, neg_offset = 0, pos = 0;
	rule r1, *rp1 = &r1, r2, *rp2 = &r2;
	str cur = buf;

	*(int*) rp1 = *(int*) rp2 = 0;
	if (*len < (int) sizeof(tzone)) {
		if (*d) GDKfree(*d);
		*d = (tzone*) GDKmalloc(*len = sizeof(tzone));
	}
	**d = tz_nil;

	/* syntax checks */
	if (fleximatch(cur, "gmt", 0) == 0) {
		return 0; /* syntax error */
	}
	cur += 3;
	if (*cur == '-' || *cur == '+') {
		str bak = cur+1;
		neg_offset = (*cur++ == '-');
		if (!GDKisdigit(*cur)) {
			return 0; /* syntax error */
		}
		while(GDKisdigit(*cur) && hours < 9999) {
			hours = (*(cur++) - '0') + hours*10;
		}
		if (*cur == ':' && GDKisdigit(cur[1])) {
			cur++; do {
				minutes = (*(cur++) - '0') + minutes*10;
			} while(GDKisdigit(*cur) && minutes < 60);
		} else if (*cur != ':' && (cur-bak) == 4) {
			minutes = hours % 100;
			hours = hours / 100;
		} else {
			return 0; /* syntax error */
		}
	}
	if (fleximatch(cur, "-dst[", 0)) {
		pos = rule_fromstr(cur+=5, len, &rp1); 
		if (pos == 0 || cur[pos++] != ',') {
			return 0; /* syntax error */
		}
		pos = rule_fromstr(cur+=pos, len, &rp2); 
		if (pos == 0 || cur[pos++] != ']') {
			return 0; /* syntax error */
		} cur += pos;
	}
	/* semantic check */
	if (hours < 24 && minutes < 60 && *(int*) rp1 != int_nil && *(int*) rp2 != int_nil) {
		minutes += hours*60;
		set_offset(*d, neg_offset?-minutes:minutes);
		if (pos) {
			(*d)->dst = TRUE;
			(*d)->dst_start = get_rule(r1);
			(*d)->dst_end = get_rule(r2);
		} else {
			(*d)->dst = FALSE;
		}
	}
	return cur - buf;
}

int tzone_tostr(str* buf, int* len, tzone *z) {
	str s;
	if (*len < 160) {
		if (*buf) GDKfree(*buf);
		*buf = (str) GDKmalloc(*len = 160);
	} 
        s = *buf;
	if (tz_isnil(*z)) {
		strcpy(s, "nil"); s += 3;
	} else {
		rule dst_start, dst_end;
		int mins = get_offset(z);

		set_rule(dst_start, z->dst_start);
		set_rule(dst_end, z->dst_end);

		strcpy(*buf, "GMT"); s += 3;
		if (mins > 0) {
			sprintf(s, "+%02d:%02d", mins/60,mins%60); s += 6;
		} else if (mins < 0) {
			sprintf(s, "-%02d:%02d", (-mins)/60, (-mins)%60); s += 6;
		}
		if (z->dst) {
			strcpy(s, "-DST["); s += 5;
			s += rule_tostr(&s, len, &dst_start);
			*s++ = ',';
			s += rule_tostr(&s, len, &dst_end);
			*s++ = ']'; *s = 0;
		}
	}
	return s - *buf;
}

@+ operator implementations
@c
void date_prelude(void) {
	MONTHS[0] = str_nil;
	DAYS[0] = str_nil;
	NODAYS[0] = int_nil; 
	DATE_MAX = (date) todate(31,12,YEAR_MAX);
	DATE_MIN = (date) todate(1,1,YEAR_MIN);
	tzone_local.dst = 0;
	set_offset(&tzone_local, 0);
}

int oldduration(int *ndays, str s) {
   unsigned long  year= 0, month=0, day=0;
   int  hour=0 /*, min=0*/;
   char *snew = s;
   int v=0;
   while(  *snew!='\0' ){
        if( GDKisdigit(*snew) ){
                v = 0;
                while( GDKisdigit(*snew) ){
                        v = v*10+(*snew)-'0';
                        snew++;
                }
        } else if( isupper(*snew) || islower(*snew) ){
                switch( *snew++ ){
                case 'y': case 'Y': year = v;   v = 0;          break;
                case 'm': case 'M':
                        if( month || day || hour  )     /*min = v*/;
                        else    month = v;
                        v = 0;          break;
                case 'd': case 'D': day = v;    v = 0;          break;
                case 'h': case 'H': hour = v;   v = 0;          break;
                case 's': case 'S': v = 0;              break;
                default: /* GDKerror("duration_fromstr: wrong duration '%s'!\n",s); */
			*ndays = int_nil;
			return GDK_SUCCEED;
                }
        }else{
                snew++;
        }
   }
   *ndays =  year*365 + month*30 + day;
   return GDK_SUCCEED;
}
int olddate(date *d, str buf) {
        int day=0, month, year, yearneg=(buf[0]=='-'), pos=yearneg;
	*(int*) d = int_nil;
        if (!GDKisdigit(buf[pos])) {
                return GDK_FAIL; /* syntax error */
        }
	for(year=0; GDKisdigit(buf[pos]); pos++) {
		year = (buf[pos] - '0') + year * 10;
		if (year > YEAR_MAX) break;
	}
	pos += parse_substr(&month, buf+pos, 3, MONTHS, 12);
        if (month == int_nil) {
                return GDK_FAIL; /* syntax error */
        }
        if (!GDKisdigit(buf[pos])) {
                return GDK_FAIL; /* syntax error */
        }
        while(GDKisdigit(buf[pos])) {
                day = (buf[pos] - '0') + day * 10;
		pos++;
                if (day > 31) break;
        }
        /* handle semantic error here (returns nil in that case) */
        *d = todate(day, month, yearneg?-year:year);
        return GDK_SUCCEED;
}

int tzone_set_local(tzone *z) {
	tzone_local = *z;
	return GDK_SUCCEED;
}

int tzone_get_local(tzone *z) {
	*z = tzone_local;
	return GDK_SUCCEED;
}
/* Returns month number [1-12] from a string (or nil if does not match any). */
int month_from_str(int *ret, str month) {
	parse_substr(ret, month, 3, MONTHS, 12);
	return GDK_SUCCEED;
}

/* Returns month name from a number between [1-7], str(nil) otherwise. */
int month_to_str(str *ret, int *month) {
	*ret = GDKstrdup(MONTHS[(*month < 1 || *month > 12) ? 0 : *month]);
	return GDK_SUCCEED;
}

/* Returns number of day [1-7] from a string (or nil if does not match any). */
int day_from_str(int *ret, str day) {
	parse_substr(ret, day, 3, DAYS, 7);
	return GDK_SUCCEED;
}

/* Returns day name from a number between [1-7], str(nil) otherwise. */
int day_to_str(str *ret, int *day) {
	*ret = GDKstrdup(DAYS[(*day < 1 || *day > 7) ? 0 : *day]);
	return GDK_SUCCEED;
}

/* creates a date from (day,month,year) parameters */
int date_create(date *ret, int *year, int *month, int *day) {
	*(int*) ret = todate(*day, *month, *year);
	return GDK_SUCCEED;
}

/* creates a daytime from (hours,minutes,seconds,milliseconds) parameters */
int daytime_create(daytime* ret, int *hour, int *min, int* sec, int* msec) {
	*(int*)ret = totime(*hour,*min,*sec,*msec);
	return GDK_SUCCEED;
}

/* creates a timestamp from (date,daytime) parameters */
int timestamp_create(timestamp* ret, date *d, daytime* t, tzone *z) {
	if (*(int*) d == int_nil || *(int*) t == int_nil || tz_isnil(*z)) {
		*ret = ts_nil;
	} else {
		lng add = get_offset(z) * (lng)-60000;
		ret->days = *d;
		ret->msecs = *t;
		if (z->dst) {
			timestamp tmp;
			if (timestamp_inside(&tmp, ret, z, (lng)-3600000)) {
				*ret = tmp;
			}
		}
		timestamp_add(ret, ret, &add);
	}
	return GDK_SUCCEED;
}

int timestamp_create_default(timestamp* ret, date *d, daytime* t) {
	return timestamp_create(ret, d, t, &tzone_local);
}

/* extracts year from date (value between -5867411 and +5867411). */
int date_extract_year(int *ret, date* v) {
	if (*(int*) v == int_nil) {
		*ret = int_nil;
	} else {
		fromdate(*(int*) v, &dummy, &dummy, ret); 
	}
	return GDK_SUCCEED;
}

/* extracts month from date (value between 1 and 12) */
int date_extract_month(int *ret, date* v) {
	if (*(int*) v == int_nil) {
		*ret = int_nil;
	} else {
		fromdate(*(int*) v, &dummy, ret, &dummy); 
	}
	return GDK_SUCCEED;
}

/* extracts day from date (value between 1 and 31)*/
int date_extract_day(int *ret, date* v) {
	if (*(int*) v == int_nil) {
		*ret = int_nil;
	} else {
		fromdate(*(int*) v, ret, &dummy, &dummy); 
	}
	return GDK_SUCCEED;
}

/* Returns N where d is the Nth day of the year (january 1 returns 1). */
int date_extract_dayofyear(int *ret, date* v) {
	if (*(int*) v == int_nil) {
		*ret = int_nil;
	} else {
		int year;
		fromdate(*(int*) v, &dummy, &dummy, &year); 
		*ret = 1 + *(int*) v - todate(1, 1, year);
	}
	return GDK_SUCCEED;
}

/* Returns the week number */
int date_extract_weekofyear(int *ret, date * v) {
	if (*(int*) v == int_nil) {
		*ret = int_nil;
	} else {
		int year, dayofweek, year_jan_1;
		fromdate(*(int*) v, &dummy, &dummy, &year);
		dayofweek = date_dayofweek(year_jan_1 = todate(1, 1, year));

		if (dayofweek <= 4) {
			/* week of jan 1 belongs to this year */
			*ret = 1 + ((*(int*) v - year_jan_1) + dayofweek - 1)/7; 
		} else if ((*(int*) v - year_jan_1) > (7-dayofweek)) {
			/* week of jan 1 belongs to last year; but this is a later week */ 
			*ret = ((*(int*) v - year_jan_1) + dayofweek - 1)/7; 
		} else {
			/* recurse to get last weekno of previous year (it is 52 or 53) */
			int lastyear_dec_31 = todate(31, 12, (year==1)?-1:year-1);
			return date_extract_weekofyear(ret, &lastyear_dec_31); 
		}
	}
	return GDK_SUCCEED;
}

/* Returns the current day  of the week where 1=monday, .., 7=sunday */
int date_extract_dayofweek(int *ret, date *v) {
	if (*(int*) v == int_nil) {
		*ret = int_nil;
	} else {
		*ret = date_dayofweek(*v);
	}
	return GDK_SUCCEED;
}

/* extracts hour from daytime (value between 0 and 23) */
int daytime_extract_hours(int *ret, daytime *v) {
	if (*(int*) v == int_nil) {
		*ret = int_nil;
	} else {
		fromtime(*(int*) v, ret, &dummy, &dummy, &dummy); 
	}
	return GDK_SUCCEED;
}

/* extracts minutes from daytime (value between 0 and 59) */
int daytime_extract_minutes(int *ret, daytime* v){
	if (*(int*) v == int_nil) {
		*ret = int_nil;
	} else {
		fromtime(*(int*) v, &dummy, ret, &dummy, &dummy); 
	}
	return GDK_SUCCEED;
}

/* extracts seconds from daytime (value between 0 and 59) */
int daytime_extract_seconds(int *ret, daytime* v) {
	if (*(int*) v == int_nil) {
		*ret = int_nil;
	} else {
		fromtime(*(int*) v, &dummy, &dummy, ret, &dummy); 
	}
	return GDK_SUCCEED;
}

/* extracts milliseconds from daytime (value between 0 and 999) */
int daytime_extract_milliseconds(int *ret, daytime* v) {
	if (*(int*) v == int_nil) {
		*ret = int_nil;
	} else {
		fromtime(*(int*) v, &dummy, &dummy, &dummy, ret); 
	}
	return GDK_SUCCEED;
}

/* extracts daytime from timestamp */
int timestamp_extract_daytime(daytime* ret, timestamp* t, tzone *z) {
	if (ts_isnil(*t) || tz_isnil(*z)) {
		*ret = int_nil;
	} else {
		timestamp tmp;
		if (timestamp_inside(&tmp, t, z, (lng)0)) {
			lng add = (lng)3600000;
			timestamp_add(&tmp, &tmp, &add);
		} 
		if (ts_isnil(tmp)) {
			*ret = int_nil;
		} else {
			*ret = tmp.msecs;
		}
	}
	return GDK_SUCCEED;
}

int timestamp_extract_daytime_default(daytime* ret, timestamp* t) {
	return timestamp_extract_daytime(ret, t, &tzone_local);
}

/* extracts date from timestamp */
int timestamp_extract_date(date* ret, timestamp *t, tzone *z) {
	if (ts_isnil(*t) || tz_isnil(*z)) {
		*ret = int_nil;
	} else { 
		timestamp tmp;
		if (timestamp_inside(&tmp, t, z, (lng)0)) {
			lng add = (lng)3600000;
			timestamp_add(&tmp, &tmp, &add);
		} 
		if (ts_isnil(tmp)) {
			*ret = int_nil;
		} else {
			*ret = tmp.days;
		}
	}
	return GDK_SUCCEED;
}

int timestamp_extract_date_default(date* ret, timestamp *t) {
	return timestamp_extract_date(ret, t, &tzone_local);
}

/* returns the date that comes a number of years after 'v' (or before iff *delta < 0). */
int date_addyears(date * ret, date *v, int *delta) {
	if (*(int*) v == int_nil || *delta == int_nil) {
		*(int*)ret = int_nil;
	} else {
		int d, m, y, x, z = *delta;
		fromdate(*(int*) v, &d, &m, &y); 
		if (m >= 3) {
			y ++;
		}
		*ret = *v;
		while (z > 0) {
			x = YEARDAYS(y);
			date_adddays(ret, ret, &x);
			z--; y++;
		} 
		while (z < 0) {
			z++; y--; 
			x = -YEARDAYS(y);
			date_adddays(ret, ret, &x);
		} 
	}
	return GDK_SUCCEED;
}

/* returns the date that comes a number of months after 'v' (or before iff *delta < 0). */
int date_addmonths(date * ret, date *v, int *delta) {
	if (*(int*) v == int_nil || *delta == int_nil) {
		*(int*)ret = int_nil;
	} else {
		int d, m, y, x, z = *delta;
		fromdate(*(int*) v, &d, &m, &y); 
		*ret = *v;
		while (z > 0) {
			z--; 
			x = MONTHDAYS(m,y);
			if (++m == 13) m = 1; 
			date_adddays(ret, ret, &x);
		} 
		while (z < 0) {
			z++; 
			if (--m == 0) m = 12; 
			x = -MONTHDAYS(m,y);
			date_adddays(ret, ret, &x);
		} 
	}
	return GDK_SUCCEED;
}

/* returns the date that comes a number of day after 'v' (or before iff *delta < 0). */
int date_adddays(date * ret, date *v, int *delta) {
	lng min = DATE_MIN, max = DATE_MAX;
	lng cur = *(int*) v, inc = *delta;

	if (cur == int_nil || inc == int_nil ||
	    (inc > 0 && (max - cur) < inc) || (inc < 0 && (min - cur) > inc)) 
	{
		*(int*)ret = int_nil;
	} else {
		*(int*)ret = *(int*)v + *delta;
	}
	return GDK_SUCCEED;
}




/* returns the number of days between 'val1' and 'val2'. */
int date_diff(int *ret, date* v1, date *v2) {
	if (*(int*) v1 == int_nil || *(int*) v2 == int_nil) {
		*ret = int_nil;
	} else {
		*ret = *(int*) v1 - *(int*) v2;
	}
	return GDK_SUCCEED;
}

/* returns the timestamp that comes 'milliseconds' after 'value'. */
int timestamp_add(timestamp* ret, timestamp *v, lng *msecs) {
	if (!ts_isnil(*v) && *msecs != lng_nil) {
		int days = (int) (*msecs / (24*60*60*1000));
		ret->msecs = (int) (v->msecs + (*msecs - ((lng) days) * (24*60*60*1000)));
		ret->days = v->days;
		if (ret->msecs >= (24*60*60*1000)) {
			days++; ret->msecs -= (24*60*60*1000);
		} else if (ret->msecs < 0) {
			days--; ret->msecs += (24*60*60*1000);
		}
		if (days) {
			date_adddays(&ret->days, &ret->days, &days);
			if (ret->days == int_nil) {
				*ret = ts_nil;
			} 
		}
	} else {
		*ret = ts_nil;
	}
	return GDK_SUCCEED;
}


/* returns the number of milliseconds between 'val1' and 'val2'. */
int timestamp_diff(lng * ret, timestamp *v1, timestamp *v2) {
	if (ts_isnil(*v1) || ts_isnil(*v2)) {
		*ret = lng_nil;
	} else {
		*ret = ((lng) (v1->days - v2->days))*((lng) 24*60*60*1000) +
		       ((lng) (v1->msecs - v2->msecs));
	}
	return GDK_SUCCEED;
}


/* return whether DST holds in the tzone at a certain point of time. */
int timestamp_inside_dst(bit *ret, timestamp *p, tzone* z) {
	*ret = FALSE;

	if (tz_isnil(*z)) {
		*ret = int_nil;
	} else if (z->dst) {
		timestamp tmp;
		if (timestamp_inside(&tmp, p, z, (lng)0)) {
			*ret = TRUE;
		}
	}
	return GDK_SUCCEED;
}

/* create a DST start/end date rule. */
int rule_create(rule *ret, int *month, int* day, int* weekday, int *minutes) {
	*(int*) ret = int_nil;
	if (*month >= 1 && *month <= 12 && ABS(*weekday) <= 7 && *minutes >= 0 && *minutes < 24*60 
	    && ABS(*day) >= 1 && ABS(*day) <= NODAYS[*month] && (*weekday || *day > 0)) 
	{
		ret->month = *month;
		ret->day = DAY_ZERO + *day;
		ret->weekday = WEEKDAY_ZERO + *weekday;
		ret->minutes = *minutes;
	}
	return GDK_SUCCEED;
}

/* create a tzone as a simple hour difference from GMT. */
int tzone_create_dst(tzone *ret, int* minutes, rule* start, rule* end) {
	*ret = tz_nil;
	if (*minutes != int_nil && ABS(*minutes) < 24*60 &&
            *(int*) start != int_nil && *(int*) end != int_nil) 
	{
		set_offset(ret, *minutes);
		ret->dst = TRUE;
		ret->dst_start = get_rule(*start);
		ret->dst_end = get_rule(*end);
	}
	return GDK_SUCCEED;
}

/* create a tzone as an hour difference from GMT and a DST. */
int tzone_create(tzone *ret, int* minutes) {
	*ret = tz_nil;
	if (*minutes != int_nil && ABS(*minutes) < 24*60) {
		set_offset(ret, *minutes);
		ret->dst = FALSE;
	}
	return GDK_SUCCEED;
}

/* extract month from rule. */
int rule_extract_month(int *ret, rule* r) {
	*ret = (*(int*) r == int_nil)?int_nil:r->month;
	return GDK_SUCCEED;
}

/* extract day from rule. */
int rule_extract_day(int *ret, rule* r) {
	*ret = (*(int*) r == int_nil)?int_nil:r->day - DAY_ZERO;
	return GDK_SUCCEED;
}

/* extract weekday from rule. */
int rule_extract_weekday(int *ret, rule* r) {
	*ret = (*(int*) r == int_nil)?int_nil:r->weekday - WEEKDAY_ZERO;
	return GDK_SUCCEED;
}

/* extract minutes from rule. */
int rule_extract_minutes(int *ret, rule* r) {
	*ret = (*(int*) r == int_nil)?int_nil:r->minutes;
	return GDK_SUCCEED;
}

/* extract rule that determines start of DST from tzone. */
int tzone_extract_start(rule *ret, tzone* t) {
	if (tz_isnil(*t) || !t->dst){
		*(int*) ret = int_nil;
	} else {
		set_rule(*ret, t->dst_start);
	}
	return GDK_SUCCEED;
}

/* extract rule that determines end of DST from tzone. */
int tzone_extract_end(rule *ret, tzone* t) {
	if (tz_isnil(*t) || !t->dst){
		*(int*) ret = int_nil;
	} else {
		set_rule(*ret, t->dst_end);
	}
	return GDK_SUCCEED;
}

/* extract number of minutes that tzone is offset wrt GMT. */
int tzone_extract_minutes(int *ret, tzone* t) {
	*ret = (tz_isnil(*t))?int_nil:get_offset(t);
	return GDK_SUCCEED;
}

/* compute the date from a rule in a certain year. */
int compute_rule_foryear(date *ret, rule* val, int *year) {
	if (*(int*) val == int_nil || *year < YEAR_MIN || *year > YEAR_MAX) {
		*ret = int_nil;
	} else {
 		*ret = compute_rule(val, *year);
	}
	return GDK_SUCCEED;
}


