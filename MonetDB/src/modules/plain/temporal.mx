@f temporal
@t Temporal Extensions To Monet
@v 1.1
@a Serioja Sidorov and Peter Boncz 

@* Introduction
@T
This module implements basic functionality concerning
temporal information, namely:
\begin{itemize}
\item {\em points in time}. It uses Greenwich Mean Time (GMT) 
absolute values having the format $<year><month><day>-<hour>:<minute>$ 
with $<year>$ a 4-digit number, $<hour>$ and $<minute>$ cardinals 
between 0 and 60, and $<month> a three-letter sequence from 
\{ jan,feb,mar,apr,may,jun,jul,aug,sep,oct,nov,dec \} with both
upper- and lower-case allowed.
\item {\em time durations}
Durations are specified as numbers of years,months,days,hours,minutes.
Limited arithmetic with durations is possible.
\item {\em time intervals}
Time intervals are defined as [$<begin\_instant>, <end\_instant>$).
\end{itemize}
TODO: 
\begin{itemize}
\item the module now contains value operations, but no bulk versions.
\item introduction of search accellerators to accelerate the 
expensive bulk operations (interval inclusion join, etc). 
\end{itemize}

@* Module Definition
@m 
.MODULE temporal;

@+ Atom Declarations 

@- Time Instants 
Time instants are absolute points of time (GMT), specified by
year,month,day-hour:minute 
@m
   .ATOM instant = int;	  
      .TOSTR   = instant_tostr;
      .FROMSTR = instant_fromstr;
   .END; 

@- Time Durations 
Time instants are periods of time. They are specified by
a vector  (years, months, days, hours, minutes).
@m
   .ATOM duration = int;
	.TOSTR	= duration_tostr;
	.FROMSTR = duration_fromstr;
   .END;

@- Time Intervals 
Time intervals include a certain starting time instant, and go up to
(but not including) an ending time instant.
@m
   .ATOM  interval = lng;
	.TOSTR	= interval_tostr;
	.FROMSTR = interval_fromstr;
   .END;

@+ Operator Declarations 
@- Time Comparison
@ Peter: these are superfluous and follow from the ADT definition

   .OPERATOR (instant)	 "="  (instant)	 : bit	    = instant_equals_instant; 
	"test equality on time instants"
   .OPERATOR (instant)	 "!=" (instant)	 : bit	    = instant_notequals_instant; 
	"test nequality on time instants"
   .OPERATOR (instant)	 "<"  (instant)	 : bit	    = instant_lt_instant; 
	"test if one time instant lies before another "
   .OPERATOR (instant)	 "<=" (instant)	 : bit	    = instant_le_instant; 
	"test whether one time instant lies before or on another"
   .OPERATOR (instant)	 ">"  (instant)	 : bit	    = instant_gt_instant; 
	"test whether one time instant lies after another "
   .OPERATOR (instant)	 ">=" (instant)	 : bit	    = instant_ge_instant; 
	"test whether one time instant lies on or after another"
   .OPERATOR (duration) "="  (duration) : bit	   = dur_equals_dur; 
	"test whether two durations are equal"
   .OPERATOR (duration) "!=" (duration) : bit	   = dur_notequals_dur; 
	"test whether two durations are different"
   .OPERATOR (duration) "<"  (duration) : bit	   = dur_lt_dur; 
	"test whether one duration is smaller than another"
   .OPERATOR (duration) ">"  (duration) : bit	   = dur_gt_dur; 
	"test whether one duration is larger than another"
   .OPERATOR (interval)	 "="  (interval) : bit	    = interval_equals_interval; 
	"test whether two time intervals are equal"
   .OPERATOR (interval)	 "!=" (interval) : bit	    = interval_notequals_interval;
	"test whether two time intervals are not equal"
@m
   .OPERATOR (instant)	 "<"  (interval) : bit	    = instant_precede_interval; 
	"test whether a time insant lies before a time interval"
   .OPERATOR (instant)	 ">"  (interval) : bit	    = instant_succede_interval; 
	"test whether a time insant lies after a time interval"
   .OPERATOR (interval)	 "<"  (interval) : bit	    = interval_precede_interval;
	"test whether one time interval precedes another entirely"
   .OPERATOR (interval)	 ">"  (interval) : bit	    = interval_succede_interval; 
	"test whether one time intervals entirely succeeds another"

   .COMMAND year(duration)		: int = duration_toyear;
	"returns the integer year value from a duration"
   .COMMAND month(duration)		: int = duration_tomonth;
	"returns the integer month value {jan=1,..dec=12} from a duration"
   .COMMAND day(duration)		: int = duration_today;
	"returns the integer day value from a duration"
   .COMMAND hours(duration)		: int = duration_tohour;
	"returns the integer hour value from a duration"
   .COMMAND minutes(duration)		: int = duration_tominute;
	"returns the integer minute value from a duration"

@- Time Arithmetic
durations are flawed. In multiplication, it is suddenly assumed that 
months are 30 days long, and years have 365 days.
TODO: lazy  evaluation of arithmetic, in order to prevent flaws. 
@m
   .OPERATOR (interval)	 "*"  (flt)	 : interval = interval_mul_flt; 
	"produce a new interval with length a multiple from the original"
   .OPERATOR (duration)	 "*"  (flt)	: duration = dur_mul_dbl; 
	"produce a new duration with length a multiple from the original"
   .OPERATOR (instant)	 "+"  (duration) : instant  = instant_add_dur; 
	"add a duration to an instant to produce a new instant"
   .OPERATOR (instant)	 "-"  (duration) : instant  = instant_substract_dur; 
	"substract a duration to an instant to produce a new instant"
   .OPERATOR (instant)	 "-"  (instant)	 : duration = instant_substract_instant;
	"substract two instants to get a duration"
   .OPERATOR (interval)	 "+"  (duration) : interval = interval_add_dur; 
	"add a duration to the length of an interval"
   .OPERATOR (interval)	 "-"  (duration) : interval = interval_substract_dur; 
	"substract a duration from the length of an interval"

@+ Command Declarations 
@m
   .COMMAND in(instant,interval)		: bit	   = instant_in_interval; 
	"tests whether an instant lies in an interval"
   .COMMAND start_interval(interval)	: instant  = interval_start; 
	"gets the starting instant of an interval"
   .COMMAND end_interval(interval)	: instant  = interval_end; 
	"gets the ending instant of an interval"

   .COMMAND intersect(interval,interval)	: interval =interval_intersect_interval;
	"get the intersection of two intervals"
   .COMMAND overlap(interval,interval)	: bit	   = interval_overlap_interval;
	"test whether to intervals overlap"
   .COMMAND include(interval,interval)	: bit	   = interval_incl_interval; 
	"test whether the first interval totally includes the second"
   .COMMAND included(interval,interval) : bit	   = interval_included_interval;
	"test whether the first interval is totally included by the second"
   .COMMAND new_interval(instant,instant): interval = build_interval; 
	"build an interval from two instants (starting and ending)"
@- Conversion from and to dates
@m
   .COMMAND date(str)			: instant  = instant_fromdate;
	"creates an instant from a string field (e.g., YYYY-MM-DD)" 
   .COMMAND fromday(int, int, int)      : instant  = instant_fromday;
         "creates an instant from a (year, month, day) specification"
   .COMMAND fromtime(int, int, int, int, int) : instant  
                                                    = instant_fromtime;
         "creates an instant from (year, month, day, hours, week)"
   .COMMAND epoch(lng)			: instant  = instant_fromepoch;
	"creates an instant from a number of seconds since 1970"
   .COMMAND epoch(instant)		: lng	   = instant_toepoch;
	"creates a number of seconds since 1970 from an instant"
   .COMMAND year(instant)		: int = instant_toyear;
	"returns the integer year value from an instant"
   .COMMAND month(instant)		: int = instant_tomonth;
	"returns the integer month value {jan=1,..dec=12} from an instant"
   .COMMAND day(instant)		: int = instant_today;
	"returns the integer day value from an instant"
   .COMMAND hours(instant)		: int = instant_tohour;
	"returns the integer hour value from an instant"
   .COMMAND minutes(instant)		: int = instant_tominute;
	"returns the integer minute value from an instant"
.END temporal; 

@{
@* Implementation
@+ The temporal class
@h
#ifndef __INSTANTMEDB_H__
#define __INSTANTMEDB_H__

#include "gdk.h"

struct MonetTime {
#ifndef WORDS_BIGENDIAN
	unsigned short dhm; // 5b-day, 5b-hour, 6b-min
	unsigned short ym; // 12b-year, 4b-month
#else
	unsigned short ym; // 12b-year, 4b-month 
	unsigned short dhm; // 5b-day, 5b-hour, 6b-min
#endif
};

#define LEAPYEAR(y) ((((y)&3)==0 && ((y)%100)!=0) || (y)==2000)
#define NODAYS(m,y) (((m)!=2)?nodays[(m)-1]:LEAPYEAR(y)?29:28)

#define MAXYEAR		0xfff
#define MAXMONTH	0xf
#define MAXDAY		0x2f
#define MAXHOUR		0x1f
#define MAXMIN		0x3f

#define GETYEAR(mt)	((mt).ym>>4)
#define GETMONTH(mt)	((mt).ym&0xF)
#define GETDAY(mt)	(((mt).dhm>>11)&0x1F)
#define GETHOUR(mt)	(((mt).dhm>>6)&0x1F)
#define GETMIN(mt)	((mt).dhm&0x3F)
#define MAKEYEAR(year, month) ((year<<4)+month)
#define MAKEDAY(day, hour, min) ((((day<<5)+hour)<<6)+min)

class duration {
public:
	MonetTime period;

	duration( void);
	INLINE duration(MonetTime );
	INLINE duration(int year, int month, int day, int hour, int min);
	INLINE duration	 operator=( MonetTime );
	INLINE int operator==( const duration ) const;
	INLINE int operator!=( const duration ) const;
	duration   operator*( const double );
	INLINE int operator<(const duration ) const;
	INLINE int operator>(const duration ) const;
};

class instant {	 
public:
	MonetTime timeinstant;

	instant( void);
	instant( const instant &);
	INLINE instant( MonetTime );
	INLINE instant	operator=( MonetTime );
	INLINE instant	operator=( const instant & );
	INLINE int operator==( const instant) const;
	INLINE int operator!=( const instant) const;
	INLINE int operator<(const instant) const;
	INLINE int operator>(const instant) const;
	INLINE int operator<=(const instant) const;
	INLINE int operator>=(const instant) const;
	instant	 operator+( const duration ); 
	instant	 operator-( const duration );
	duration  operator-(const instant ); 
};

class interval {
public:
	instant start_instant, end_instant;

	interval( );
	interval( const instant, const instant );
	interval set( const instant, const instant );
	int operator==( const interval) const;
	int operator!=( const interval) const;
	int precede(const interval) const;
	int succede(const interval) const;
	int include(const interval) const;
	int included(const interval) const;
	int overlap(const interval) const;
	int precede(const instant) const;
	int succede(const instant) const;
	int include(const instant) const;
	interval intersect(const interval );
	interval  operator+(const duration ); 
	interval  operator-(const duration ); 
	interval  operator*(const double );
};

#include "temporal.proto.h"

#endif /* __INSTANTMEDB_H__ */

@+ Implementation Code for Time Classes
@C

/* Does not compile properly on Vlieland due to
inconsistent libraries. 
#include <math.h>
*/

#ifndef __cplusplus
#define __cplusplus
#endif

#define _DEBUG_
#ifdef NOPROTO
#undef NOPROTO
#endif

#include <unistd.h>
#include <stdlib.h>
#include "temporal.h"

static int nodays[]={ 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };
static char  *months[] ={	"jan", "feb", "mar", "apr", "may", "jun", 
				"jul", "aug", "sep", "oct", "nov", "dec" };
	
INLINE struct tm monettime_to_tm( const MonetTime *t){
	struct tm rez;
	rez.tm_min = GETMIN(*t);
	rez.tm_hour = GETHOUR(*t);
	rez.tm_mday = GETDAY(*t);
	rez.tm_mon = GETMONTH(*t);
	rez.tm_year = GETYEAR(*t);
	return rez;
}; 

INLINE time_t monettime_to_epoch( const MonetTime *t){
	int i, m = GETMONTH(*t), y = GETYEAR(*t);
	time_t years = y - 1970;
	time_t days = 365*years + (years+1)/4;

	for(i=1; i<m; i++) {
		days += NODAYS(i,y);
	}
	days += GETDAY(*t) - 1;
	return 60*(days*24*60 + (time_t) GETMIN(*t));
}

INLINE MonetTime monettime_from_epoch(time_t secs){
	struct tm *ptm = gmtime(&secs);
	MonetTime t;
	t.ym  = MAKEYEAR(ptm->tm_year+1900, ptm->tm_mon+1);
	t.dhm = MAKEDAY(ptm->tm_mday, ptm->tm_hour, ptm->tm_min );
	return t;
}

int monettime_month(str s) {
	char buf[10];
	int idx=0;
		
	while(*s && idx < 3 && (isupper(*s) || islower(*s))) {
		buf[idx] = *s;
		if (isupper(*s)) buf[idx] += ('a'-'A');
		idx++; s++;
	}
	buf[idx] = 0;
	for( idx=0; idx<12; idx++ )
		if(strcmp(buf, months[idx]) == 0)  return idx+1;
	return -1;
}

static INLINE int monettime_digit(int x) {
	if ((x-= '0') >= 10) return -1;
	return x;
}
@

Date can handle the following formats:
@mil
module(temporal);

proc check_date(str d) : str {
  if(isnil(date(d)))
	ERROR("Not a date: %s",d);
  else if(isnil(date(str(date(d)))))
	ERROR("Not recastable to str: %s",d);
  return date(d);
}
check_date("721012").print;
check_date("72-10-01").print;
check_date("72/01/12").print;
check_date("19721012").print;
check_date("1972-10-12").print;
check_date("1972-10-12").print;
check_date("72OCT12").print;
check_date("1972OCT12").print;
check_date("72-oct-12").print;
check_date("1972-oct-12").print;
check_date("1972-OCT-12").print;
check_date("1972-Oct-12").print;
check_date("1972/Oct/12").print;
check_date("1972.Oct.12").print;
check_date("1972 Oct 12").print;

var t1 := date("721012");
var t2 := date("1988 Nov 30");
var d := t2 - t1;
printf("%s: %d %d %d %d %d\n", str(d), d.year, d.month, d.day, d.hours, d.minutes);

in(date("1999/05/05"), new_interval(date("1999/02/02"), date("1999/06/06"))).print;
in(date("1998/05/05"), new_interval(date("1999/02/02"), date("1999/06/06"))).print;
in(date("1999/02/02"), new_interval(date("1999/02/02"), date("1999/06/06"))).print;
in(date("1999/06/06"), new_interval(date("1999/02/02"), date("1999/06/06"))).print;
in(date("1999/02/03"), new_interval(date("1999/02/02"), date("1999/06/06"))).print;
in(date("1999/06/05"), new_interval(date("1999/02/02"), date("1999/06/06"))).print;
in(date("1999/02/01"), new_interval(date("1999/02/02"), date("1999/06/06"))).print;
in(date("1999/06/07"), new_interval(date("1999/02/02"), date("1999/06/06"))).print;

# Compare equal intervals
=(new_interval(date("1999/02/02"), date("1999/06/06")), new_interval(date("1999/02/02"), date("1999/06/06"))).print;
<(new_interval(date("1999/02/02"), date("1999/06/06")), new_interval(date("1999/02/02"), date("1999/06/06"))).print;
>(new_interval(date("1999/02/02"), date("1999/06/06")), new_interval(date("1999/02/02"), date("1999/06/06"))).print;
<=(new_interval(date("1999/02/02"), date("1999/06/06")), new_interval(date("1999/02/02"), date("1999/06/06"))).print;
>=(new_interval(date("1999/02/02"), date("1999/06/06")), new_interval(date("1999/02/02"), date("1999/06/06"))).print;

# XXX: no definition of less than and equal than is available.  At least,
# the server should not crash.

# Compare interval 1 < interval 2
=(new_interval(date("1999/02/02"), date("1999/03/03")), new_interval(date("1999/03/04"), date("1999/06/06"))).print;
<(new_interval(date("1999/02/02"), date("1999/03/03")), new_interval(date("1999/03/04"), date("1999/06/06"))).print;
>(new_interval(date("1999/02/02"), date("1999/03/03")), new_interval(date("1999/03/04"), date("1999/06/06"))).print;
<=(new_interval(date("1999/02/02"), date("1999/03/03")), new_interval(date("1999/03/04"), date("1999/06/06"))).print;
>=(new_interval(date("1999/02/02"), date("1999/03/03")), new_interval(date("1999/03/04"), date("1999/06/06"))).print;

# Compare interval 1 <= interval 2 with exact boundary match
=(new_interval(date("1999/02/02"), date("1999/03/03")), new_interval(date("1999/03/03"), date("1999/06/06"))).print;
<(new_interval(date("1999/02/02"), date("1999/03/03")), new_interval(date("1999/03/03"), date("1999/06/06"))).print;
>(new_interval(date("1999/02/02"), date("1999/03/03")), new_interval(date("1999/03/03"), date("1999/06/06"))).print;
<=(new_interval(date("1999/02/02"), date("1999/03/03")), new_interval(date("1999/03/03"), date("1999/06/06"))).print;
>=(new_interval(date("1999/02/02"), date("1999/03/03")), new_interval(date("1999/03/03"), date("1999/06/06"))).print;

quit;
@
It expects that the year is 2 or 4 digits,  the day is 2 digits,
and the month is 2 digits or 3 characters.

@C
INLINE MonetTime monettime_from_date(str date) {
  if(date) {
    int year, month, day, i = strlen(date);
    if(i%2 == 1) { /* The month is represented as a 3 character string */
      str s;
      year = strtol(date,&s,10);
      if(!s) return *(MonetTime*) &int_nil;

      while(*s && !isalpha(*s)) s++;

      if(strlen(s) < 5) /* at least 3 for month name and 2 for day */
	return *(MonetTime*) &int_nil;

      for (month = 1; month < 13; month++) {
	for(i = 0; i < 3; i++) {
	  if(months[month-1][i] != tolower(s[i]))
	    break;
	}
	if(i == 3) {
	  while(!GDKisdigit(s[i])) {
	    if(s[i]) i++;
	    else return *(MonetTime*) &int_nil;
	  }
	  s += i;
	  day = atoi(s);
	  break;
	}
      }
    } else {
      switch(i) {
      case 6: /* YYMMDD */
	if(sscanf(date, "%2d%2d%2d%n", &year, &month, &day, &i) == 3 && i == 6)
	  break;
      case 8: /* YYYYMMDD */
	if(sscanf(date, "%4d%2d%2d%n", &year, &month, &day, &i) == 3 && i == 8)
	  break;
      default: /* YxMxD */
	if(sscanf(date,"%d%*[^0-9]%d%*[^0-9]%d",
		  &year,&month,&day) != 3)
	  return *(MonetTime*) &int_nil;
	break;
      }
    }

    if (year < 0 || month <= 0 || day <= 0 || 
	month > 12 || day > NODAYS(month, year)) {
      return *(MonetTime*) &int_nil;
    }
    MonetTime t;
    t.ym = (year << 4) + month; 
    t.dhm = day << 11;
    return t;
  }
  return *(MonetTime*) &int_nil;
}

INLINE int monettime_eq(const MonetTime *t1, const MonetTime *t2) {
        int *p1 = (int*) t1;
        int *p2 = (int*) t2;
        return (*p1 == *p2);
}
INLINE int monettime_lt(const MonetTime *t1, const MonetTime *t2) {
	if (t1->ym == t2->ym){
		return t1->dhm < t2->dhm;
	}
        return (t1->ym < t2->ym);
}
INLINE int monettime_le(const MonetTime *t1, const MonetTime *t2) {
	if (t1->ym == t2->ym){
		return t1->dhm <= t2->dhm;
	}
        return (t1->ym < t2->ym);
}
INLINE int monettime_gt(const MonetTime *t1, const MonetTime *t2) {
	if (t1->ym == t2->ym){
		return t1->dhm > t2->dhm;
	}
        return (t1->ym > t2->ym);
}
INLINE int monettime_ge(const MonetTime *t1, const MonetTime *t2) {
	if (t1->ym == t2->ym){
		return t1->dhm >= t2->dhm;
	}
        return (t1->ym > t2->ym);
}

static MonetTime instant_now={ (unsigned short) 32767, (unsigned short) -1 };

void adjust_date( int& year, int &month, int &day ){
	while(day > NODAYS(month,year)) {
		day -= NODAYS(month,year);
		if (++month > 12) {
			month = 1;
			year++ ;
		}
	}
	while(day <= 0){
		day += ((month-1)!=2? 
			nodays[(month+10)%12]:(LEAPYEAR(year)? 29:28 ));
		if(--month<1){
			month = 12;
			year--;
		}
	}
}

@- Duration Class
@C
INLINE duration::duration( void ){
	period = *(MonetTime*) &int_nil;
}

INLINE duration::duration( MonetTime mt){
	*this = mt;
}

INLINE duration::duration(int year, int month, int day, 
			  int hour, int min
){
	period.ym = MAKEYEAR(year, month);
	period.dhm = MAKEDAY(day, hour, min);
}

INLINE duration duration::operator=( MonetTime mt){
	period.ym = mt.ym;
	period.dhm = mt.dhm;
	return *this;
}

INLINE int duration::operator==(const duration d) const {
	return monettime_eq(&period, &d.period);	
}


INLINE int duration::operator!=( const duration d) const{
	return !((*this)==d);
}

INLINE int duration::operator<(const duration d) const{
	return monettime_lt(&period, &d.period);
}

INLINE int duration::operator>(const duration d) const{
	return monettime_gt(&period, &d.period);
}

duration duration::operator*( const double v ){
	duration rez;
	unsigned long year4, year, month, day, hour, min;
	double sec;
	sec = 60*(GETMIN(period) + 60*GETHOUR(period));
	sec +=	3600.0*24.0*( GETDAY(period)+30.0*GETMONTH(period));
	sec += (GETYEAR(period)/4*1461.0+ 
		GETYEAR(period)%4*365.0)*3600.0*24.0;
	sec *= v; 
	
	year4 = (unsigned long)(sec/1461.0/24.0/3600.0); // #of 4 years units
	sec -= year4*1461.0*24.0*3600.0;
	year =(unsigned long)(sec/365.0/24.0/3600.0);	 // #of 365 days year;
	sec -= year*365.0*24.0*3600.0;	
	year += 4*year4;
	month = (unsigned long)(sec/30.0/24.0/3600.0);	 // #of 30days month
	sec -= month*30.0*24.0*3600.0;
	day = (unsigned long)(sec/24.0/3600.0);		 // #of days
	sec -= day*24.0*3600.0;
	hour = (unsigned long)(sec/3600.0);		 // #of hours
	sec -= hour*3600;
	min = (unsigned long)(sec/60.0);
	sec -= min*60;
	rez.period.ym  = MAKEYEAR(year,month);
	rez.period.dhm	= MAKEDAY(day,hour,min);
	return rez;
}


@- Time Instant Class
@C
INLINE	instant::instant( MonetTime v){ timeinstant=v; }

INLINE	instant::instant()
{ 
	*this = *(MonetTime*) &int_nil;
}

INLINE	instant::instant(const instant &v)
{ 
	timeinstant = v.timeinstant;
}


instant instant_gettime( void )
{
	instant ti;
	struct timeval	time;
	gettimeofday( &time, NULL );
	ti.timeinstant = monettime_from_epoch(time.tv_sec);
	return ti;
}

INLINE	instant instant::operator=( MonetTime val )
{
	timeinstant = val;
	return *this;
}

INLINE	instant instant::operator=( const instant &v )
{
	timeinstant = v.timeinstant;
	return *this;
}


INLINE	int instant::operator==( const instant ti) const
{
	instant *p1= (instant*) this, *p2= (instant*) &ti;
	int t1now = monettime_eq(&p1->timeinstant,&instant_now);
	int t2now = monettime_eq(&p2->timeinstant,&instant_now);

	if (t1now || t2now) {
	    instant now = instant_gettime( );
	    if (t1now) p1 = &now;
	    if (t2now) p2 = &now;
	    return monettime_eq(&p1->timeinstant, &p2->timeinstant);
	}
	return monettime_eq(&p1->timeinstant, &p2->timeinstant);
}


INLINE int instant::operator!=( const instant ti) const
{
	return !((*this)==ti);
}

INLINE	int instant::operator<( const instant ti) const
{
	instant *p1= (instant*) this, *p2= (instant*) &ti;
	int t1now = monettime_eq(&p1->timeinstant,&instant_now);
	int t2now = monettime_eq(&p2->timeinstant,&instant_now);

	if (t1now || t2now) {
	    instant now = instant_gettime( );
	    if (t1now) p1 = &now;
	    if (t2now) p2 = &now;
	    return monettime_lt(&p1->timeinstant, &p2->timeinstant);
	}
	return	monettime_lt(&p1->timeinstant, &p2->timeinstant);
}

INLINE int instant::operator>( const instant ti) const
{
	instant *p1= (instant*) this, *p2= (instant*) &ti;
	int t1now = monettime_eq(&p1->timeinstant,&instant_now);
	int t2now = monettime_eq(&p2->timeinstant,&instant_now);

	if (t1now || t2now) {
	    instant now = instant_gettime( );
	    if (t1now) p1 = &now;
	    if (t2now) p2 = &now;
	    return monettime_gt(&p1->timeinstant, &p2->timeinstant);
	}
	return	monettime_gt(&p1->timeinstant, &p2->timeinstant);
}

INLINE	int instant::operator<=( const instant ti) const
{
	return !((*this)>ti);
}

INLINE	int instant::operator>=( const instant ti) const
{
	return !((*this)<ti);
}

instant	 instant::operator+(const duration dur)
{
	instant res;
	int year, month, day, hour, min;
	min = GETMIN(timeinstant)+GETMIN(dur.period);
	hour = min/60;
	min = min%60;
	hour += GETHOUR(timeinstant)+GETHOUR(dur.period);
	day = hour/24;
	hour = hour%24;
	day += GETDAY(timeinstant)+GETDAY(dur.period);
	month = GETMONTH(timeinstant)+GETMONTH(dur.period);
	year = (month-1)/12;
	month = month%12;
	if( month==0 ) {
		month = 12;
	}
	year += GETYEAR(timeinstant)+GETYEAR(dur.period);
	adjust_date( year, month, day );
	res.timeinstant.ym = MAKEYEAR(year, month);
	res.timeinstant.dhm = MAKEDAY(day, hour, min);
	return res;
}

instant	 instant::operator-(const duration dur)
{
	instant res;
	int year=0, month=0, day=0, hour=0, min=0;
	month = GETMONTH(this->timeinstant)-GETMONTH(dur.period);
	if( month<=0 ){ 
		month += 12;
		year = -1;
	}
	year += GETYEAR(this->timeinstant)-GETYEAR(dur.period);
	min += GETMIN(this->timeinstant)-GETMIN(dur.period);
	if( min<0 ){	
		min += 60;
		hour = -1;
	}
	hour += GETHOUR(this->timeinstant)-GETHOUR(dur.period); 
	if( hour<0 ){	
		hour += 24;
		day = -1; 
	}
	day += GETDAY(this->timeinstant)-GETDAY(dur.period);	
	adjust_date( year, month, day );
	res.timeinstant.ym = MAKEYEAR(year, month);
	res.timeinstant.dhm = MAKEDAY(day, hour, min );
	return res;
}

duration  instant::operator-(const instant ti )
{
	duration res;
	int year=0, month=0, day=0, hour=0, min=0;
	month = GETMONTH(this->timeinstant)-GETMONTH(ti.timeinstant);
	if( month<0 ){
		month += 12;
		year = -1; 
	}
	year += GETYEAR(this->timeinstant)-GETYEAR(ti.timeinstant);
	min += GETMIN(this->timeinstant)-GETMIN(ti.timeinstant);
	if( min<0 ){
		min += 60;
		hour = -1; 
	}
	hour += GETHOUR(this->timeinstant)-GETHOUR(ti.timeinstant);	
	if( hour<0 ){
		hour += 24;
		day = -1; 
	}
	day += GETDAY(this->timeinstant)-GETDAY(ti.timeinstant);	
	res.period.ym = MAKEYEAR(year, month);
	res.period.dhm = MAKEDAY(day, hour, min );
	return res;
} 

@- Time Interval Class
@C
INLINE	 interval interval::set( const instant ts, const instant te ){
	start_instant = ts;
	end_instant = te;
	return	*this;
}

INLINE interval::interval( const instant ts, const instant te ){
	start_instant = ts;
	end_instant = te;
}

INLINE interval::interval( void ){
	start_instant = ((MonetTime*) &lng_nil)[0];
	end_instant = ((MonetTime*) &lng_nil)[1];
}

INLINE	 int interval::include(const instant ti) const
{
	return	( start_instant < ti || start_instant==ti ) && end_instant > ti;
}

INLINE	 int interval::operator==( const interval tv) const
{
	return	start_instant == tv.start_instant && end_instant == tv.end_instant;
}

INLINE	 int interval::operator!=( const interval tv) const
{
	return	start_instant != tv.start_instant || end_instant != tv.end_instant;
}

INLINE	 int interval::precede(const interval tv) const
{
	return end_instant < tv.start_instant; 
}

INLINE	 int interval::succede(const interval tv) const
{
	return start_instant > tv.end_instant; 
}

INLINE	 int interval::include(const interval tv) const{
	return	this->include(tv.start_instant) && this->include(tv.end_instant); 
}

INLINE	 int interval::included(const interval tv) const
{
	return tv.include(start_instant) && tv.include(end_instant);
}

INLINE	 int interval::overlap(const interval tv) const
{	instant thisend, tvend;
	duration onemin( 0, 0, 0, 0, 1 );
	instant_substract_dur( &thisend, (instant *)&end_instant, &onemin );
	instant_substract_dur( &tvend, (instant *)&tv.end_instant, &onemin );
	return	include(tv.start_instant) || include( tvend ) ||
		tv.include(start_instant) || tv.include( thisend );
}

INLINE	 int interval::precede(const instant ti) const
{
	return ( end_instant < ti || end_instant==ti ) ;
}

INLINE	 int interval::succede(const instant ti) const
{
	return start_instant > ti ;
}

interval  interval::intersect(const interval tv){
	interval res;
	if( this->overlap(tv) ){
		instant s, e;
		if( start_instant>=tv.start_instant && start_instant<=tv.end_instant ) {
			s = start_instant;
		} else	{
			s = tv.start_instant;
		}
		if( end_instant>=tv.start_instant && end_instant<=tv.end_instant )	{
			e = end_instant;
		} else {
			s = tv.end_instant;
		}
		res.set( s, e );
	}
	return res;
}

interval  interval::operator+(const duration dur){
	interval res;
	res.set( this->start_instant+dur,  this->end_instant+dur );
	return res;
}

interval  interval::operator-(const duration dur){
	interval res;
	res.set( this->start_instant-dur,  this->end_instant-dur );
	return res;
}

interval interval::operator*( const double factor ){
	duration dur;
	instant newend;
	interval rez;
	dur = end_instant - start_instant;
	dur = dur * factor;
	newend = start_instant + dur;
	rez.set( start_instant, newend );
	return rez; 
}

@+ Atom Wrappers 
@- duration 
@C
#ifdef __cplusplus
extern "C" {
#endif

int duration_tostr(str *s, int* l, duration* val)
{
   struct tm date = monettime_to_tm(&val->period); 
   char *buf;
   if (*s == NULL) {
	*s = (str) GDKmalloc(*l = 24); 
   } else if (*l < 24) {
	GDKfree(*s);
	*s = (str) GDKmalloc(*l = 24); 
   } 
   buf = *s;
   sprintf(buf, "%1dy%1dm%1dd-%1dh:%1dm", date.tm_year, date.tm_mon,
		date.tm_mday, date.tm_hour, date.tm_min);
   return strlen(buf);
}

int duration_fromstr( str s, int* l, duration** val )
{
   unsigned long  year= 0, month=0, day=0; 
   int	hour=0, min=0;
   char *snew = s;   
   int v=0;
   while(  *snew!='\0' ){
	if( GDKisdigit(*snew) ){
		v = 0;
		while( GDKisdigit(*snew) ){
			v = v*10+(*snew)-'0';
			snew++;
		}
	}else if( isupper(*snew) || islower(*snew) ){
		switch( *snew++ ){
		case 'y': case 'Y': year = v;	v = 0;		break;
		case 'm': case 'M':
			if( month || day || hour  )	min = v;
			else	month = v;	
			v = 0;		break;
		case 'd': case 'D': day = v;	v = 0;		break;
		case 'h': case 'H': hour = v;	v = 0;		break;
		case 's': case 'S': v = 0;		break;
		default: /* GDKerror("duration_fromstr: wrong duration '%s'!\n",s); */
			break;
		}		
	}else{
		snew++;
	}
   }
   if( *val == NULL || (*l) < (int)sizeof(duration))
   {
      *val = (duration *)GDKmalloc(sizeof(duration));
      *l = sizeof(duration);
   }
   (*val)->period.ym = MAKEYEAR(year, month);
   (*val)->period.dhm = MAKEDAY(day, hour, min );
   return (snew-s);
}

int duration_toyear(int *res, duration *d){
	*res = GETYEAR(d->period);
	return GDK_SUCCEED;
}

int duration_tomonth(int *res, duration *d){
	*res = GETMONTH(d->period);
	return GDK_SUCCEED;
}

int duration_today(int *res, duration *d){
	*res = GETDAY(d->period);
	return GDK_SUCCEED;
}

int duration_tohour(int *res, duration *d){
	*res = GETHOUR(d->period);
	return GDK_SUCCEED;
}

int duration_tominute(int *res, duration *d){
	*res = GETMIN(d->period);
	return GDK_SUCCEED;
}


@- Time Interval
@C
int instant_tostr(str* s, int* l, instant* val)
{
    struct tm date;
    char *buf;

    if (*s == NULL) { 
	*s = (str) GDKmalloc(*l = 20); 
    } else if (*l < 20) {
	GDKfree(*s);
	*s = (str) GDKmalloc(*l = 20); 
    } 
    buf = *s;
    if (*(int *)&val->timeinstant == int_nil) {
	strcpy(buf, "nil");
	return 3;
    }
    if (monettime_eq(&val->timeinstant, &instant_now)) { 
	strcpy(buf, "now");
	return 3;
    }
    date = monettime_to_tm(&val->timeinstant );
    if (date.tm_year < 0 || date.tm_mon <= 0 || date.tm_mday <= 0 || 
	date.tm_mon > 12 || date.tm_mday > NODAYS(date.tm_mon, date.tm_year)) {
	strcpy(buf, "<illegal instant>");
	return 17;
    }

    if(date.tm_year<100)
	sprintf(buf, "%02d", date.tm_year );
    else
	sprintf(buf, "%04d", date.tm_year );

    while(*buf) buf++;
	
    strcpy(buf, months[date.tm_mon-1] );
    while(*buf) buf++;

    sprintf(buf, "%02d", date.tm_mday );
    while(*buf) buf++;
	
    if (date.tm_hour != 0 || date.tm_min != 0) {
	*buf++ = '-';

	sprintf(buf, "%1d", date.tm_hour );
	while(*buf) buf++;

	sprintf(buf, ":%1d", date.tm_min );
	while(*buf) buf++;
    }

    return buf - *s;
}


#ifndef __GNUC__
#ifndef HAVE_BOOL
	typedef enum bool_t { false, true } bool;
#endif
#endif
str string_to_date( str s, instant *val)
{
   int year= MAXYEAR, month=MAXMONTH, day=MAXDAY; 
   int	hour=MAXHOUR, min=MAXMIN;
   char *snew = s;   

   if( strlen(snew) < 3) {
       val->timeinstant = *(MonetTime *)&int_nil;
       return snew;
   }

   if( strncmp(snew, "now", 3) == 0 ){
	year=GETYEAR(instant_now);
	month=GETMONTH(instant_now);
	day=GETDAY(instant_now); 
	hour=GETHOUR(instant_now);
	min=GETMIN(instant_now);
	snew += 3;
   } else {
	int v=-1, enddate=0;
	while( *snew==' ') snew++;	// white spaces
	while( *snew!=',' && *snew!=')' && *snew!='\0' ){
	    if( GDKisdigit(*snew) ){
		v = 0;
		while( GDKisdigit(*snew) ){
			v = v*10+(*snew)-'0';
			snew++;
		}
	    } else if( islower(*snew) || isupper(*snew) ){
		int idx = monettime_month(snew);
		if( v>=0 ){	
			year = v;	
			v=-1;	
		}
		month = idx;
		snew += 3;
	    } else if( *snew=='-' ){
		enddate = 1;
		if( v>=0 ){
			day = v; v=-1;	
		}
		snew++;
	    } else if( *snew==':' ){
		snew++;
		if( v>=0 ){
			if( hour==MAXHOUR )	hour = v;
			else			min = v;
			v = -1;
		}
	    } else snew++; //ignore		
	    while( *snew==' ') snew++;	// white spaces
	}
	if( v>=0 ){
		if( hour!=MAXHOUR ) {
			if( min==MAXMIN) min = v;
		} else {
			if( day!=MAXDAY || enddate )	hour = v;
			else				day = v;
		}
	}
		
	if (month == MAXMONTH) month=1; 
	if (day == MAXDAY) day=1;
	if (hour == MAXHOUR) hour=0;
	if (min == MAXMIN) min = 0;

	if( year>=MAXYEAR || month<=0 || month > 12 || day<=0 ||
	    hour<0 || hour>23  || min<0 || min>59 || day>NODAYS(month,year) )
	{
	  /* GDKerror("string_to_date: wrong TimeInstant '%s'!\n",s); */
		val->timeinstant = *(MonetTime *)&int_nil;
		return snew;
	}
   } 
   val->timeinstant.ym = MAKEYEAR(year, month);
   val->timeinstant.dhm = MAKEDAY(day, hour, min );
   return snew;
}

int instant_fromstr( str s, int* l, instant** val )
{
   char *snew;
   instant	ti;
   snew = string_to_date( s, &ti);
   if( *val == NULL || (*l) < (int)sizeof(instant))
   {
      *val = (instant *)GDKmalloc(sizeof(instant));
      *l = sizeof(instant);
   }
   (**val) = ti;
   return (snew-s);
}

@- Time Values
@C
int interval_tostr( str* s, int* l, interval* val )
{
   char *buf;

   if (*s == NULL ) {
	*s = (str) GDKmalloc(*l = 44); 
   } else if (*l < 44) {
	GDKfree(*s);
	*s = (str) GDKmalloc(*l = 44); 
   } 
   buf = *s;
   (void) monettime_to_tm(&val->start_instant.timeinstant );
   (void) monettime_to_tm(&val->end_instant.timeinstant );
   *buf++ = '[';
   buf += instant_tostr(&buf, l, &val->start_instant);
   *buf++ = ',';
   buf += instant_tostr(&buf, l, &val->end_instant);
   *buf++ = ')'; 
   *buf = 0;
   return buf-*s;
}


int interval_fromstr(str s, int* l, interval** val)
{
   char *snew;
   instant	ts, te;

   ts.timeinstant = *(MonetTime *)&int_nil;
   te.timeinstant = *(MonetTime *)&int_nil;

   snew = strchr( s,'[' );
   if (snew == 0) goto end;
   ++snew;

   snew = string_to_date( snew, &ts);
   snew = strchr( snew, ',' );
   if (snew == 0) goto end;
   ++snew;
   snew = string_to_date( snew, &te);
   snew = strchr( snew,')' );
   if (snew == 0) goto end;
   ++snew;

 end:
   if( *val == NULL || (*l) < (int)sizeof(interval))
   {
      *val = (interval *)GDKmalloc(sizeof(interval));
      *l = sizeof(interval);
   }
   (*val)->set( ts, te );
   return (snew-s);
}

@+ Command Wrappers
@
int dur_equals_dur( bit *res, duration *pd1, duration *pd2 ){
	*res = (*pd1)==(*pd2);
	return GDK_SUCCEED;
}

int dur_notequals_dur( bit *res, duration *pd1, duration *pd2 ){
	*res = (*pd1)!=(*pd2);
	return GDK_SUCCEED;
}

int dur_lt_dur( bit *res, duration *pd1, duration *pd2 ){
	*res = (*pd1)<(*pd2);
	return GDK_SUCCEED;
}

int dur_gt_dur( bit *res, duration *pd1, duration *pd2 ){
	*res = (*pd1)>(*pd2);
	return GDK_SUCCEED;
}
@C
int dur_mul_dbl( duration *res, duration *pd, flt *factor ){
	*res = (*pd)*(*factor);
	return GDK_SUCCEED;
}

int instant_add_dur( instant *res, instant *pt, duration *pd ){
	*res = (*pt)+(*pd);
	return GDK_SUCCEED;
}

int instant_substract_dur( instant *res, instant *pt, duration *pd ){
	*res = (*pt)-(*pd);
	return GDK_SUCCEED;
}

int instant_substract_instant( duration *res, instant *pt1, instant *pt2 ){
	*res = (*pt1)-(*pt2);
	return GDK_SUCCEED;
}

int instant_fromepoch(instant *res, lng *secs){
	*res = instant(monettime_from_epoch((time_t) *secs));
	return GDK_SUCCEED;
}

int instant_toepoch(lng *res, instant *pt){
	*res = monettime_to_epoch((MonetTime*) pt);
	return GDK_SUCCEED;
}

int instant_fromdate(instant *res, str date){
	*res = instant(monettime_from_date(date));
	return GDK_SUCCEED;
}

int instant_fromday(instant *res, int *year, int *month, int *day){
        MonetTime t;
        if (*year < 0 || *month <= 0 || *day <= 0 || 
            *month > 12 || *day > NODAYS(*month, *year)) {
                t = *(MonetTime *) &int_nil;
        } else {
                t.ym  = MAKEYEAR(*year, *month);
                t.dhm = MAKEDAY(*day, 0, 0);
        }
        *res = instant(t);
        return GDK_SUCCEED;  
}

int instant_fromtime(instant *res, int *year, int *month, int *day,
                     int *hours, int *min){
        MonetTime t;
        if (*year < 0 || *month <= 0 || *day <= 0 || *hours < 0 || *min < 0 ||
            *month > 12 || *day > NODAYS(*month, *year) || 
            *hours > 23 || *min > 59) {
                t = *(MonetTime *) &int_nil;
        } else {
                t.ym  = MAKEYEAR(*year, *month);
                t.dhm = MAKEDAY(*day, *hours, *min);
        }
        *res = instant(t);
        return GDK_SUCCEED;  
}

int instant_toyear(int *res, instant *i){
	instant now = instant_gettime( );
	if ( monettime_eq(&i->timeinstant,&instant_now) )
		*res = GETYEAR(now.timeinstant);
	else
		*res = GETYEAR(i->timeinstant);
	return GDK_SUCCEED;
}

int instant_tomonth(int *res, instant *i){
	instant now = instant_gettime( );
	if ( monettime_eq(&i->timeinstant,&instant_now) )
		*res = GETMONTH(now.timeinstant);
	else
		*res = GETMONTH(i->timeinstant);
	return GDK_SUCCEED;
}

int instant_today(int *res, instant *i){
	instant now = instant_gettime( );
	if ( monettime_eq(&i->timeinstant,&instant_now) )
		*res = GETDAY(now.timeinstant);
	else
		*res = GETDAY(i->timeinstant);
	return GDK_SUCCEED;
}

int instant_tohour(int *res, instant *i){
	instant now = instant_gettime( );
	if ( monettime_eq(&i->timeinstant,&instant_now) )
		*res = GETHOUR(now.timeinstant);
	else
		*res = GETHOUR(i->timeinstant);
	return GDK_SUCCEED;
}

int instant_tominute(int *res, instant *i){
	instant now = instant_gettime( );
	if ( monettime_eq(&i->timeinstant,&instant_now) )
		*res = GETMIN(now.timeinstant);
	else
		*res = GETMIN(i->timeinstant);
	return GDK_SUCCEED;
}

int interval_add_dur( interval *res, interval *pt, duration *pd ){
	*res = (*pt)-(*pd);
	return GDK_SUCCEED;
}

int interval_substract_dur( interval *res, interval *ptv, duration *pd ){
	*res = (*ptv)-(*pd);
	return GDK_SUCCEED;
}
@
int  instant_equals_instant( bit *res, instant* pt1, instant* pt2)
{
	*res = ((*pt1)==(*pt2));
	return GDK_SUCCEED;
}

int  instant_notequals_instant( bit *res, instant* pt1, instant* pt2 )
{
	*res = ((*pt1)!=(*pt2));
	return GDK_SUCCEED;
}

int  instant_lt_instant( bit *res, instant* pt1, instant* pt2)
{
	*res = ((*pt1) < (*pt2));
	return GDK_SUCCEED;
}

int   instant_le_instant( bit *res, instant* pt1, instant* pt2)
{
	*res = (((*pt1) < (*pt2)) || ((*pt1)==(*pt2)));
	return GDK_SUCCEED;
}

int  instant_gt_instant( bit *res, instant* pt1, instant* pt2)
{
	*res = ((*pt1) > (*pt2));
	return GDK_SUCCEED;
}

int  instant_ge_instant (bit *res, instant* pt1, instant* pt2)
{
	*res = (((*pt1) > (*pt2)) || ((*pt1)==(*pt2)));
	return GDK_SUCCEED;
}
@C
int  instant_precede_interval( bit *res, instant* pti, interval* ptv)
{
	*res = ptv->succede( *pti );
	return GDK_SUCCEED;
}
@
int  interval_equals_interval( bit *res, interval* pt1, interval* pt2)
{
	*res = (*pt1)==(*pt2);
	return GDK_SUCCEED;
}

int  interval_notequals_interval( bit *res, interval* pt1, interval* pt2 )
{
	*res = (*pt1)!=(*pt2);
	return GDK_SUCCEED;
}
@C
int  instant_in_interval( bit *res, instant* pti, interval* ptv )
{
	*res = ptv->include( *pti );
	return GDK_SUCCEED;
}

int  instant_succede_interval( bit *res, instant* pti, interval* ptv)
{
	*res =	ptv->precede( *pti );
	return GDK_SUCCEED;
}

int  interval_start( instant *pti, interval* ptv )
{
	*pti =	ptv->start_instant;
	return GDK_SUCCEED;
}

int  interval_end( instant *pti, interval* ptv )
{
	*pti = ptv->end_instant;
	return GDK_SUCCEED;
}

int  interval_precede_interval( bit *res, interval* pt1, interval* pt2 )
{
	*res = pt1->precede( *pt2 );
	return GDK_SUCCEED;
}

int  interval_succede_interval( bit *res, interval* pt1, interval* pt2)
{
	*res = pt1->succede( *pt2 );
	return GDK_SUCCEED;
}

int interval_mul_flt( interval *res, interval *tv, flt *factor ){
	*res = (*tv)*(*factor);
	return GDK_SUCCEED;
}

int interval_intersect_interval( interval *res, interval *tv1, interval *tv2 ){
	*res = tv1->intersect(*tv2);	
	return GDK_SUCCEED;
}

int  interval_overlap_interval(	 bit *res, interval* pt1, interval* pt2 )
{
	*res = pt1->overlap( *pt2 );
	return GDK_SUCCEED;
}

int  interval_incl_interval(  bit *res, interval* pt1, interval* pt2 )
{
	*res = pt1->include( *pt2 );
	return GDK_SUCCEED;
}

int  interval_included_interval(  bit *res, interval* pt1, interval* pt2 )
{
	*res = pt1->included( *pt2 );
	return GDK_SUCCEED;
}

int build_interval( interval *res, instant *start, instant *end )
{
	interval temp;
	temp.set( *start, *end );	
	*res = temp;
	return GDK_SUCCEED;
}

#ifdef __cplusplus
}
#endif
@}
