@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@' 
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@' 
@' The Original Code is the Monet Database System.
@' 
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2003 CWI.
@' All Rights Reserved.
@' 
@' Contributor(s):
@' 		Martin Kersten <Martin.Kersten@cwi.nl>
@' 		Peter Boncz <Peter.Boncz@cwi.nl>
@' 		Niels Nes <Niels.Nes@cwi.nl>
@' 		Stefan Manegold  <Stefan.Manegold@cwi.nl>

@f pcl
@a N. Nes
@t Performance Counters Library
@T

             PCL - The Performance Counter Library
                   Version 2.2, January 2003

PCL (The Performance Counter Library) is a common interface to access
in a portable way performance counters built into modern
microprocessors. PCL supports query for functionality, start and stop
of counters, and reading the current values out of the
counters. Performance counting can be done in user mode, system, and
user-or-system mode. Functions are callable from C, C++, Fortran, and
Java.

Currently, the following systems are supported:

  -  Linux 2.x.x with Intel Pentium/PPro/Pentium II/Pentium III/Pentium 4
  -  Linux 2.x.x with AMD Athlon/Duron
  -  IBM AIX 4.x >= 4.3 with PowerPC 604, 604e, Power3, Power3-II
  -  SUN Solaris 2.x, Solaris 7, 8 with UltraSPARC I,II, III
  -  Digital Unix with Alpha 21164, 21264
  -  Cray T3E with Alpha 21164
  -  SGI IRIX with R10000, R12000

The homepage of PCL can be found at

    http://www.fz-juelich.de/zam/PCL/

were you can find the source and a detailled description of PCL
including a description of performance counters on various
microprocessors.

TODO

add pcl_cpu_info! (void,str bat) (max counters?)
later add low level api

@+ Module Definition
@m
.MODULE pcl;

.COMMAND pcl_start(BAT[int,any] events, int mode) = pcl_start;
  "start counting the given events"

.COMMAND pcl_stop(BAT[int,any] events) : BAT[int,lng] = pcl_stop;
  "stop counting and return the counts for the given events."

.COMMAND pcl_start_rates(BAT[int,any] rates, int mode) = pcl_start_rates;
  "start counting the events needed for the given rates"

.COMMAND pcl_stop_rates(BAT[int,any] rates) : BAT[int,dbl] = pcl_stop_rates;
  "stop event counters and return the requested rates."

.COMMAND pcl_query(BAT[int,any] events, int mode) : BAT[int,int] = pcl_query;
  "query for existing events"

.COMMAND pcl_try(BAT[int,any] events, int mode) : bit = pcl_try;
  "try wheter the events could be started together on this CPU"

.PRELUDE = pcl_init;
.EPILOGUE = pcl_exit;

.END pcl;

@mil

var pcl_events := new(str,int,100);

const PCL_MODE_USER := 1;
const PCL_MODE_SYSTEM := 2;
const PCL_MODE_BOTH := 3;

#/* Level-1-Cache */
pcl_events.insert( "PCL_L1CACHE_READ",            0);
pcl_events.insert( "PCL_L1CACHE_WRITE",           1);
pcl_events.insert( "PCL_L1CACHE_READWRITE",       2);
pcl_events.insert( "PCL_L1CACHE_HIT",             3);
pcl_events.insert( "PCL_L1CACHE_MISS",            4);

#/* Level-1-Data-Cache */
pcl_events.insert( "PCL_L1DCACHE_READ",           5);
pcl_events.insert( "PCL_L1DCACHE_WRITE",          6);
pcl_events.insert( "PCL_L1DCACHE_READWRITE",      7);
pcl_events.insert( "PCL_L1DCACHE_HIT",            8);
pcl_events.insert( "PCL_L1DCACHE_MISS",           9);

#/* Level-1-Instruction-Cache */
pcl_events.insert( "PCL_L1ICACHE_READ",           10);
pcl_events.insert( "PCL_L1ICACHE_WRITE",          11);
pcl_events.insert( "PCL_L1ICACHE_READWRITE",      12);
pcl_events.insert( "PCL_L1ICACHE_HIT",            13);
pcl_events.insert( "PCL_L1ICACHE_MISS",           14);

#/* Level-2-Cache */
pcl_events.insert( "PCL_L2CACHE_READ",            15);
pcl_events.insert( "PCL_L2CACHE_WRITE",           16);
pcl_events.insert( "PCL_L2CACHE_READWRITE",       17);
pcl_events.insert( "PCL_L2CACHE_HIT",             18);
pcl_events.insert( "PCL_L2CACHE_MISS",            19);

#/* Level-2-Data-Cache */
pcl_events.insert( "PCL_L2DCACHE_READ",           20);
pcl_events.insert( "PCL_L2DCACHE_WRITE",          21);
pcl_events.insert( "PCL_L2DCACHE_READWRITE",      22);
pcl_events.insert( "PCL_L2DCACHE_HIT",            23);
pcl_events.insert( "PCL_L2DCACHE_MISS",           24);

#/* Level-2-Instruction-Cache */
pcl_events.insert( "PCL_L2ICACHE_READ",           25);
pcl_events.insert( "PCL_L2ICACHE_WRITE",          26);
pcl_events.insert( "PCL_L2ICACHE_READWRITE",      27);
pcl_events.insert( "PCL_L2ICACHE_HIT",            28);
pcl_events.insert( "PCL_L2ICACHE_MISS",           29);

#/* TLB */
pcl_events.insert( "PCL_TLB_HIT",                 30);
pcl_events.insert( "PCL_TLB_MISS",                31);

#/* Instruction-TLB */
pcl_events.insert( "PCL_ITLB_HIT",                32);
pcl_events.insert( "PCL_ITLB_MISS",               33);

#/* Data-TLB */
pcl_events.insert( "PCL_DTLB_HIT",                34);
pcl_events.insert( "PCL_DTLB_MISS",               35);

#/* Cycles */
pcl_events.insert( "PCL_CYCLES",                  36);
pcl_events.insert( "PCL_ELAPSED_CYCLES",          37);

#/* Operations */
pcl_events.insert( "PCL_INTEGER_INSTR",           38);
pcl_events.insert( "PCL_FP_INSTR",                39);
pcl_events.insert( "PCL_LOAD_INSTR",              40);
pcl_events.insert( "PCL_STORE_INSTR",             41);
pcl_events.insert( "PCL_LOADSTORE_INSTR",         42);
pcl_events.insert( "PCL_INSTR",                   43);

#/* Jump Instructions */
pcl_events.insert( "PCL_JUMP_SUCCESS",            44);
pcl_events.insert( "PCL_JUMP_UNSUCCESS",          45);
pcl_events.insert( "PCL_JUMP",                    46);

#/* Atomic Instructions */
pcl_events.insert( "PCL_ATOMIC_SUCCESS",          47);
pcl_events.insert( "PCL_ATOMIC_UNSUCCESS",        48);
pcl_events.insert( "PCL_ATOMIC",                  49);

#/* Stalls */
pcl_events.insert( "PCL_STALL_INTEGER",           50);
pcl_events.insert( "PCL_STALL_FP",                51);
pcl_events.insert( "PCL_STALL_JUMP",              52);
pcl_events.insert( "PCL_STALL_LOAD",              53);
pcl_events.insert( "PCL_STALL_STORE",             54);
pcl_events.insert( "PCL_STALL",                   55);

#/* derived numbers */
pcl_events.insert( "PCL_MFLOPS",                  56);
pcl_events.insert( "PCL_IPC",                     57);
pcl_events.insert( "PCL_L1DCACHE_MISSRATE",       58);
pcl_events.insert( "PCL_L2DCACHE_MISSRATE",       59);
pcl_events.insert( "PCL_MEM_FP_RATIO",            60);

pcl_events := pcl_events.reverse;

  
@+ Implementation
@c
#include "gdk.h"

#ifndef HAVE_LIBPCL

void pcl_init(){ }
void pcl_exit(){ }

int pcl_start(BAT *event, int *mode){ return GDK_SUCCEED; }
int pcl_start_rates(BAT *event, int *mode){ return GDK_SUCCEED; }

int pcl_stop(BAT **result, BAT *event){ 
	*result = NULL; 
	return GDK_SUCCEED; 
}

int pcl_stop_rates(BAT **result, BAT *event){ 
	*result = NULL; 
	return GDK_SUCCEED; 
}

int pcl_query(BAT **result, BAT *event, int *mode){ 
	*result = NULL; 
	return GDK_SUCCEED; 
}

int pcl_try(bit *result, BAT *event, int *mode){ 
	*result = FALSE; 
	return GDK_SUCCEED; 
}
#else

#include "pcl.proto.h"
#include <pcl.h>

static PCL_DESCR_TYPE pcl_desc;

void pcl_init(){
	if (PCLinit(&pcl_desc) != PCL_SUCCESS){
		GDKwarning("couldn't initialize pcl library\n");
	}
}

void pcl_exit(){
	if (PCLexit(pcl_desc) != PCL_SUCCESS){
		GDKwarning("couldn't free pcl library resources\n");
	}
}

int pcl_start(BAT *event, int *mode){
	int clist[PCL_MAX_EVENT_PER_CALL];
	int res, i = 0, cnt = BATcount(event);
	BUN p,q;

	if (cnt > PCL_MAX_EVENT_PER_CALL){
		GDKwarning("Can only start %d events per call\n", 
			PCL_MAX_EVENT_PER_CALL);
		return GDK_FAIL;
	}
	BATloop(event,p,q){
		int ev = *(int*)BUNhloc(event,p);
		if (PCL_EVENT_IS_INT(ev)){
			clist[i] = ev;
			i++;
		}
	}
	res = PCLstart(pcl_desc, clist, i, *mode);
	if (res != PCL_SUCCESS){
		GDKwarning("pcl_start failed with %d\n", res);
		return GDK_FAIL;
	}
	return GDK_SUCCEED;
}

int pcl_start_rates(BAT *event, int *mode){
	int clist[PCL_MAX_EVENT_PER_CALL];
	int res, i = 0, cnt = BATcount(event);
	BUN p,q;

	if (cnt > PCL_MAX_EVENT_PER_CALL){
		GDKwarning("Can only start %d events per call\n", 
			PCL_MAX_EVENT_PER_CALL);
		return GDK_FAIL;
	}
	BATloop(event,p,q){
		int ev = *(int*)BUNhloc(event,p);
		if (!PCL_EVENT_IS_INT(ev)){
			clist[i] = ev;
			i++;
		}
	}
	res = PCLstart(pcl_desc, clist, i, *mode);
	if (res != PCL_SUCCESS){
		GDKwarning("pcl_start failed with %d\n", res);
		return GDK_FAIL;
	}
	return GDK_SUCCEED;
}

int pcl_stop(BAT **result, BAT *event){
	PCL_CNT_TYPE ilist[PCL_MAX_EVENT_PER_CALL];
	PCL_FP_CNT_TYPE flist[PCL_MAX_EVENT_PER_CALL];
	int res, i = 0, cnt = BATcount(event);
	BUN p,q;

	if (cnt > PCL_MAX_EVENT_PER_CALL){
		GDKwarning("Can only start %d events per call\n", 
			PCL_MAX_EVENT_PER_CALL);
		return GDK_FAIL;
	}
	res = PCLstop(pcl_desc, ilist, flist, cnt);
	if (res != PCL_SUCCESS){
		return GDK_FAIL;
	}
	*result = BATnew(TYPE_int, TYPE_lng, cnt);
	BATloop(event,p,q){
		int ev = *(int*)BUNhloc(event,p);
		if (PCL_EVENT_IS_INT(ev)){
			lng h = ilist[i];
			BUNins(*result, &ev, &h);
		}
		i++;
	}
	return GDK_SUCCEED;
}

int pcl_stop_rates(BAT **result, BAT *event){
	PCL_CNT_TYPE ilist[PCL_MAX_EVENT_PER_CALL];
	PCL_FP_CNT_TYPE flist[PCL_MAX_EVENT_PER_CALL];
	int res, i = 0, cnt = BATcount(event);
	BUN p,q;

	if (cnt > PCL_MAX_EVENT_PER_CALL){
		GDKwarning("Can only start %d events per call\n", 
			PCL_MAX_EVENT_PER_CALL);
		return GDK_FAIL;
	}
	res = PCLstop(pcl_desc, ilist, flist, cnt);
	if (res != PCL_SUCCESS){
		return GDK_FAIL;
	}
	*result = BATnew(TYPE_int, TYPE_dbl, cnt);
	BATloop(event,p,q){
		int ev = *(int*)BUNhloc(event,p);
		if (!PCL_EVENT_IS_INT(ev)){
			dbl h = flist[i];
			BUNins(*result, &ev, &h);
		}
		i++;
	}
	return GDK_SUCCEED;
}

int pcl_query(BAT **result, BAT *event, int *mode){
	int res, cnt = BATcount(event);
	int clist[1];
	BUN p,q;

	*result = BATnew(TYPE_int,TYPE_int,cnt);
	BATloop(event,p,q){
		int ev = *(int*)BUNhloc(event,p);
		clist[0] = ev;
		res = PCLquery(pcl_desc, clist, 1, *mode);
		BUNins(*result, &ev, &res);
	}
	return GDK_SUCCEED;
}

int pcl_try(bit *result, BAT *event, int *mode){
	int i, res, cnt = BATcount(event);
	int clist[PCL_MAX_EVENT_PER_CALL];
	BUN p,q;

	if (cnt > PCL_MAX_EVENT_PER_CALL){
		GDKwarning("Can only start %d events per call\n", 
			PCL_MAX_EVENT_PER_CALL);
		return GDK_FAIL;
	}
	BATloop(event,p,q){
		int ev = *(int*)BUNhloc(event,p);
		clist[i] = ev;
		i++;
	}
	res = PCLquery(pcl_desc, clist, i, *mode);
	if (res == PCL_SUCCESS)
	 	*result = TRUE;
	else
	 	*result = FALSE;
	return GDK_SUCCEED;
}
#endif

@mil

if (mod = "main"){
  names := bat(str,void);
  names.insert("PCL_L1CACHE_MISS",  nil);
  names.insert("PCL_L1DCACHE_MISS", nil);
  names.insert("PCL_L1ICACHE_MISS", nil);

  available := pcl_query(pcl_events.reverse.project(nil).reverse,1).select(0);

  L1MISS_EVENTS := pcl_events.reverse.semijoin(available).reverse.semijoin(names);
  L1MISS_EVENTS.print;

  events := L1MISS_EVENTS.reverse.project(nil).reverse();
  pcl_start(events,1);
  counts := pcl_stop(events);
  counts.print;
}

