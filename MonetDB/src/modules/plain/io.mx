@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at 
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@' 
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@' 
@' The Original Code is the Monet Database System.
@' 
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2002 CWI.  
@' All Rights Reserved.
@' 
@' Contributor(s):
@' 		Martin Kersten <Martin.Kersten@cwi.nl>
@' 		Peter Boncz <Peter.Boncz@cwi.nl>
@' 		Niels Nes <Niels.Nes@cwi.nl>
@' 		Stefan Manegold  <Stefan.Manegold@cwi.nl>

@f io
@t The io Module
@a N.J. Nes
@d 01/07/1996

@+ Introduction
@T
This module contains all the file access commands. The implementation
is very simple. All function call the stdio library function.

This module is seperated from the database kernel since some 
servers are not allowed to do file accesses.

{\tt fopen()} opens the file named by filename  and  associates  a
stream  with  it. {\tt fopen()}  returns  a  pointer to the FILE
structure associated with the stream. The resulting pointer is needed
by all other io function. So fopen should be called before any other 
function. 

The {\tt fclose()} command closes the associated stream. The Stream pointer 
given can not be used after calling this function. 

Pipes can be created with {\tt popen()}. This function returns the
identifier to a bidirectional pipe. You can then for instance {\tt fork()}
a new Monet session, passing this identifier.

Both sessions can then use the pipe to open a stream with {\tt fdpipe()}.
The one end should pass {\tt true} as the {\tt up} parameter, the other
{\tt down}. This function returns a stream, and can be used in combination
with any of the functions of this module.

The {\tt fflush()} command flushes the buffer of the associated stream.

{\tt feof()} returns non-zero when EOF has previously been
detected reading the named input stream, otherwise zero.

{\tt freopen()} substitutes the named file in place  of  the  open
stream. A flush is first attempted, and then the original
stream is closed, regardless of whether the open ultimately
succeeds. Failure to flush or close stream successfully is
ignored. It returns the new FILE pointer.

The {\tt fread()} and {\tt fwrite()} commands read/write a number of bytes 
to or from a associated stream. The read function returns a string 
containing the result. The write function returns the number of written bytes. 

The {\tt fseek()} function seeks an offset number of bytes form the start, the 
current position, or the end of the stream.
\footnote{See the mil script file for the correct constants.}
This function returns the number of bytes moved. 

The {\tt fprintf()} function print a variable number of 
arguments using the format string. They return the number of arguments 
printed. 

The {\tt fputs()} places a string on the given output stream. 
{\tt fgets()} reads a string until an end of line is found form the 
given input stream. 

Look at the related ANSI-C/POSIX manual pages to get the needed information.

@* Module Definition
@m
.MODULE io;
    .USE streams;
    .USE blob; # fread() and fwrite() need blobs

    .ATOM bipipe = lng;
    .END;

    .COMMAND stdin() : Stream = io_stdin; 
	"return the input stream to the database client"
    .COMMAND stderr() : Stream = io_stderr;
	"return the error stream for the database console"
    .COMMAND stdout() : Stream = io_stdout;
	"return the output stream for the database client"

    .COMMAND fopen ( str filename, str mode ) : Stream = io_fopen; 
	"See: man fopen. Returns stream, or stream(nil) on failure."
    .COMMAND freopen ( str filename, str mode, Stream ) : Stream = io_freopen;
	"See: man freopen. Returns stream, or stream(nil) on failure."
    .COMMAND popen( ) : bipipe = io_popen;
	"Open a bidirectional pipe. See: man pipe" 
    .COMMAND fdpipe(bipipe, bit up, str mode) : Stream = io_fdpipe;
        "Open a stream in one direction through a pipe." 
    .COMMAND ferror() : str = io_ferror;
   	"returns last error message. str(nil) if none. "

    .COMMAND fclose( Stream ) = io_fclose; 
	"See: man fclose"
    .COMMAND fflush( Stream ) = io_fflush; 
	"See: man fflush"
    .COMMAND feof( Stream ) : bit = io_feof; 
	"See: man feof"

    .COMMAND fread( Stream filep, int nbytes ) : blob = io_fread; 
	"See: man fread"
    .COMMAND fwrite( Stream filep, str buf, int nbytes ) = io_fwrite_str;
	"See: man fwrite"
    .COMMAND fwrite( Stream filep, blob buf, int nbytes ) = io_fwrite;
	"See: man fwrite"
    .COMMAND fseek( Stream filep, int pos, int offset ) : int = io_fseek; 
	"See: man fseek"
    .COMMAND ftell( Stream filep ) : int = io_ftell; 
	"See: man ftell"

    .COMMAND fsize( str filename ) : int = io_fsize;
	"Return the filesize, or -1 when there was some error"

    .COMMAND fprint( Stream filep, ... ) = io_fprint; 
	"Print a (comma seperated) list of arguments"

    .COMMAND fprintf( Stream filep, str format, ... ) = io_fprintf; 
	"See: man fprintf"

    .COMMAND fputs( str s, Stream filep ) = io_fputs; 
	"See: man fputs"
    .COMMAND fgets( Stream filep ): str = io_fgets; 
	"See: man fgets"

    .COMMAND fputc( int c, Stream filep ) = io_fputc; 
	"See: man fputs"
    .COMMAND fgetc( Stream filep ): chr = io_fgetc; 
	"See: man fgetc"

    .COMMAND ftable( Stream filep, ...BAT[any::1,any]... ) = io_ftable_default; 
	"Print an n-ary table to a file."

    .COMMAND ftable( Stream filep, int orderspec, ...BAT[any::1,any]... ) = io_ftable; 
	"Print an n-ary table to a file, using order of BAT [1..argc]."

@- MIL initializations 
The constants for the seek function.
@m
.LOAD
        const EOF      := -1;
        const SEEK_SET := 0;
        const SEEK_CUR := 1;
        const SEEK_END := 2;
.END;

.END io;

@* Example Script
@mil
setoid(oid(20000000));
module(io);

fp := fopen ( "test", "w+" );
fwrite( fp, "Dit is een test\n", 17 );
fp := freopen ( "test", "r+", fp );
fread( fp, 17 ).tostr.print;

fseek( fp, 0, 0);
fprintf( fp, "%s %d %c %d %f\n", "test", 10, 'c', 10, 7.0 );

s := "testing again and again\n";

fseek( fp, 0, 0);
fputs( s, fp );
fseek( fp, 0, 0);
s := fgets( fp );

fflush( fp );
fclose( fp );
printf( "%s %d %c %d %f\n", "test", 10, 'c', 10, 7.0 );
printf( "%s\n", s );

quit;
@{
@* Implementation Code
@h
#ifndef _IO_H_
#define _IO_H_

#include <stdio.h>
#include <stdarg.h>
#include <blob.h>

typedef struct {
	int up, down;
} bipipe;


#define STREAM_CHECK(fp) \
	if (!fp){ \
		GDKerror( "Incorrect file pointer\n"); \
		return(GDK_FAIL); \
	}


#include "io.proto.h"

#endif /* _IO_H_ */

@c
#include "io.h"
#include "monet.h"

int io_stdin (Stream *ret) { *(stream**)ret = GDKin;  return GDK_SUCCEED; }
int io_stdout(Stream *ret) { *(stream**)ret = GDKout; return GDK_SUCCEED; }
int io_stderr(Stream *ret) { *(stream**)ret = GDKerr; return GDK_SUCCEED; }

int io_fclose( Stream* filepp ){
   stream *fp = *(stream**) filepp; 
   STREAM_CHECK(fp);
   fp->destroy(fp);
   return(GDK_SUCCEED);
}

int io_fflush( Stream *filepp ){
   stream *fp = *(stream**) filepp; 
   STREAM_CHECK(fp);
   (void)fp->flush(fp);
   return(GDK_SUCCEED);
}

int io_popen(bipipe *retval){
   if (pipe((int*) retval) < 0) {
	GDKsyserror("io_popen:");
	return GDK_FAIL;
   }
   return GDK_SUCCEED;
}
int io_fdpipe(Stream *retval, bipipe* p, bit *up, str mode){
   if (mode && *mode){
	*mode = 'r'
   	*(stream**)retval = file_rastream(fdopen(up?p->up:p->down, mode), "pipe");
   } else {
   	*(stream**)retval = file_wastream(fdopen(up?p->up:p->down, mode), "pipe");
   }
   if (*retval != NULL) return GDK_SUCCEED;
   GDKsyserror("io_fdpipe:");
   return GDK_FAIL;
}

/*
int io_feof( bit *res, Stream *filepp ){
   stream *fp = *(stream**) filepp; 
   STREAM_CHECK(fp);
   *res = feof(fp)?TRUE:FALSE;
   return(GDK_SUCCEED);
}
*?

int io_fopen( fstream *res, str name, str mode ){
   *res = fopen(name,mode);
   if (!*res) *res = *(fstream*) ATOMnilptr(TYPE_fstream);
   return GDK_SUCCEED;
}

int io_freopen( fstream *res, str name, str mode, fstream *filepp ){
   FILE *fp = *(FILE**) filepp; 
   STREAM_CHECK(fp);
   *res = freopen(name,mode,fp);
   if (!*res) *res = *(fstream*) ATOMnilptr(TYPE_fstream);
   return GDK_SUCCEED;
}

int io_ferror( str *msg) {
   int r = MT_geterrno();
   if (r) {
    	*msg = GDKstrdup(strerror(r));
   } else { 
	*msg = str_nil;
   }
   return GDK_SUCCEED;
}

int io_fread( blob **res, fstream *filepp, int *nbytes ){
   FILE *fp = *(FILE**) filepp; 
   int err = -1;
   str buf;
   STREAM_CHECK(fp);
   buf = (str) GDKmalloc( sizeof(int) + *nbytes );
   if ((*res = (blob*) buf) != NULL){
   	err = fread(buf+sizeof(int),1,*nbytes,fp);
   }
   if (err<0){
      GDKsyserror("io_fread:");
      if (*res) GDKfree(*res);
      return(GDK_FAIL);
   }
   *(int*) (*res) = err;
   return(GDK_SUCCEED);
}

int io_fwrite_str(fstream *filepp, str buf, int *nbytes ){
   FILE *fp = *(FILE**) filepp; 
   int n = strlen(buf); 
   STREAM_CHECK(fp);
   if (*nbytes < n) n = *nbytes;
   if (fwrite(buf,1,n,fp) < (size_t) n) {
      GDKsyserror("io_fwrite_str:");
      return(GDK_FAIL);
   }
   return(GDK_SUCCEED);
}

int io_fwrite(fstream *filepp, blob *b, int *nbytes ){
   FILE *fp = *(FILE**) filepp; 
   int n = *nbytes;
   str buf = (str) b;
   STREAM_CHECK(fp);
   if (n> *(int*) buf) {
	n = MAX(0,*(int*) buf);
	GDKerror("io_fwrite: blob contains only %d bytes.\n", *(int*) buf);
   }
   if (fwrite(buf+sizeof(int),1,n,fp) < (size_t) n) {
      GDKsyserror("io_fwrite:");
      return(GDK_FAIL);
   }
   return(GDK_SUCCEED);
}

int io_fseek(int *res, fstream *filepp, int *pos, int *nbytes ){
   FILE *fp = *(FILE**) filepp; 
   STREAM_CHECK(fp);
   *res = fseek(fp, (long)*pos, *nbytes);
   if (*res < 0) {
      GDKsyserror("io_fseek:");
      return(GDK_FAIL);
   }
   return(GDK_SUCCEED);
}

int io_ftell(int *res, fstream *filepp ){
   FILE *fp = *(FILE**) filepp; 
   STREAM_CHECK(fp);
   *res = ftell(fp);
   if (*res < 0) {
      GDKsyserror("io_ftell:");
      return(GDK_FAIL);
   }
   return(GDK_SUCCEED);
}

int io_fsize(int* res, str filename){
#ifdef HAVE_FSTAT
	struct stat buf;
	if (stat(filename,&buf))
		*res = -1;
	else
		*res = (int)buf.st_size;
#else
        *res = -1;
#endif
	return(GDK_SUCCEED);
}


int io_fprintf(fstream *filepp, str format,  ...){
        va_list ap;
        int ret;
        str s;
 
	STREAM_CHECK(*filepp);
        va_start(ap,format);
        ret = monet_sprintf(&s, format, ap);
        va_end(ap);
        if (ret == GDK_FAIL) {
                return GDK_FAIL;
        }
        if (fputs(s, *filepp) < 0) {
                GDKsyserror("io_fprintf():");
                GDKfree(s);
                return GDK_FAIL;
        }
	GDKfree(s);
        return GDK_SUCCEED;
}

int io_fprint(fstream *filepp, ...){
        va_list ap;
        ptr val; 
	int type;
 
	STREAM_CHECK(*filepp);
        va_start(ap,filepp);

	val = va_arg (ap,ptr);
        if(val){
		type = va_arg(ap,int);
		if (ATOMstorage(type) != TYPE_str)
			fprintf( *filepp, "%s(\"", ATOMname(type) );
		ATOMprint(type, val, *filepp);
		if (ATOMstorage(type) != TYPE_str)
			fprintf( *filepp, "\")" );
		val = va_arg (ap,ptr);
        	while(val){
			type = va_arg(ap,int);
			if (ATOMstorage(type) != TYPE_str)
				fprintf( *filepp, ", %s(\"", ATOMname(type) );
			else
				fprintf( *filepp, ", ");
			ATOMprint(type, val, *filepp);
			if (ATOMstorage(type) != TYPE_str)
				fprintf( *filepp, "\")" );
			val = va_arg (ap,ptr);
		}
	}
        va_end(ap);
        return GDK_SUCCEED;
}



int io_fputs(str s, fstream *filepp ){
   STREAM_CHECK(*filepp);
   if (fputs(s,*(FILE**)filepp) < 0) {
      GDKsyserror("io_fputs: ");
      return GDK_FAIL;
   }
   return(GDK_SUCCEED);
}

int io_fputc(int *c, fstream *filepp ){
   FILE *fp = *(FILE**) filepp; 
   STREAM_CHECK(fp);
   if (fputc(*c, fp) < 0) {
      GDKsyserror("io_fputs: ");
      return GDK_FAIL;
   }
   return(GDK_SUCCEED);
}

int io_fgets( str *s, fstream *filepp ){
   FILE *fp = *(FILE**) filepp; 
   STREAM_CHECK(fp);
   *s = GDKmalloc( BUFSIZ );
   **s = 0;
   if (fgets(*s, BUFSIZ, fp) <= (char *) 0) {
      if (feof(fp)){
        **s = 0;
      	return(GDK_SUCCEED);
      }
      GDKsyserror("io_fgets: ");
      return GDK_FAIL;
   }
   return(GDK_SUCCEED);
}

int io_fgetc( chr *c, fstream *filepp ){
   FILE *fp = *(FILE**) filepp; 
   int ret;
   STREAM_CHECK(fp);
   ret = (int)fgetc(fp);
   if (ret <= 0) {
      GDKsyserror("io_fgetc: ");
      return GDK_FAIL;
   }
   *c = ret;
   return(GDK_SUCCEED);
}

typedef BAT* batptr;

int io_ftable( Stream* filepp, int *orderspec, ...){
        BAT *piv[MAXPARAMS];
        int argc = 0;
        va_list ap;

   	STREAM_CHECK(*filepp);
        va_start (ap, orderspec);
        do {
                piv[argc] = va_arg (ap,BAT*) ;
        } while(piv[argc++]);
        va_end (ap);
        BATmultiprintf(s, argc, piv, FALSE, *orderspec);
        return GDK_SUCCEED;
}

int io_ftable_default(Stream *filepp, ...) {
        BAT *piv[MAXPARAMS];
        int argc = 0;
        va_list ap;

   	STREAM_CHECK(*filepp);
        va_start (ap,filepp);
        do {
                piv[argc] = va_arg (ap,BAT*) ;
        } while(piv[argc++]);
        va_end (ap);
        BATmultiprintf(s, argc, piv, FALSE, 0);
        return GDK_SUCCEED;
}
@}
