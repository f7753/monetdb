@f vector
@a Wilko Quak, Arjen P. de Vries,Alex Van Ballegooij
@d 15/02/2001
@t A variable length vector for Monet

@* Introduction
The module defines some basic operations for a multidimensional vector type
for int, flt, or dbl.

{\em Given its ad-hockery nature, this module should not be considered as an example module. Additionally the porting from C++ to C hasn't improved readability... }

@* Module Definition
@m
.MODULE vector;

   .USE mmath;

@:vecmel(int)@
@:vecmel(flt)@
@:vecmel(dbl)@

@= vecmel

   .ATOM @1s;
      .TOSTR   = @1s_tostr;
      .FROMSTR = @1s_fromstr;
      .NEQUAL  = @1s_comp;
      .DEL     = @1s_del;
      .HASH    = @1s_hash;
      .NULL    = @1s_null;
      .PUT     = @1s_put;
      .LENGTH  = @1s_length;
      .HEAP    = @1s_heap;
   .END;

   .COMMAND dimension(@1s) 	: int	= @1Sdimension; 
     "Return the dimension of the vector."
   .COMMAND @1s_rancreate(int) 	: @1s	= @1Srancreate; 
     "Create a random vector of the requested dimension."
   .COMMAND getval(@1s,int)	: @1	= @1Sgetval;
     "Project the Ith element value out of the vector."

   .COMMAND L2distance(@1s,@1s) : dbl = @1SL2distance; 
     "Compute the L2 distance between two (feature) vectors."

@:vecaggrmel(@1,max)@
@:vecaggrmel(@1,min)@

@
@m

.END vector;

@= vecaggrmel
   .COMMAND @2range(bat[any,@1s] vecs) : @1s = @1S@2range; 
   "Determine the @2 values of each dimension in the vectors."
@
@* Example script
@mil

module( vector );

#
# create some data
vecs := new(void, flts);
vecs.insert( nil, flts_rancreate( 10 ) );
vecs.insert( nil, flts_rancreate( 10 ) );
vecs.insert( nil, flts_rancreate( 10 ) );
vecs.seqbase(0@0);

vecs.print;

# 
# project 5th dimension
[getval]( vecs, 4 ).print;

#
# range of data
xmax := maxrange( vecs );
xmin := minrange( vecs );

L2distance( xmin, xmax ).print;

quit;
@* Header file

We define for each of the supported basetypes a C++ class to implement the
behaviour. The actual functionality that is accessed from MIL is implemented
in {\tt static} class methods.
@h
#ifndef __VECTOR_H__
#define __VECTOR_H__

#include <gdk.h>

@:vecheader(int)@
@:vecheader(flt)@
@:vecheader(dbl)@

@= vecheader
typedef struct {
   int dimension;
   @1  data[1];
} @1s;

@1s* @1screate(int dim);

@
@h

#endif /* __VECTOR_H__ */

@c
#include <stdlib.h>
#include <string.h>
#include <math.h>

#include "vector.h"
#include "vector.proto.h"

static long get_long(const char* startp,char** endp)
{
   return(strtol(startp,endp,10));
}

static double get_double(const char* startp,char** endp)
{
   return(strtod(startp,endp));
}

@:vecimpl(int,get_long,%d,m,4)@
@:vecimpl(flt,get_double,%f,d,4)@
@:vecimpl(dbl,get_double,%f,d,8)@

@= vecimpl

size_t @1ssize(int dim) {
   return(sizeof(@1s) + (((dim>0)?(dim -1):(0))* sizeof(@1)));
}

@1s* @1screate(int dim) {
   @1s* rval = GDKmalloc(@1ssize(dim));
   rval->dimension = dim;
   return(rval);
}


int @1s_tostr(str* tostr,int* l,@1s* p) {
   char *s;
   int i;
   {
      int expectedlen = 20 + (p->dimension * 15);
      if (*l < expectedlen)
      {
         if (*tostr != NULL)
	    GDKfree(*tostr);
	 *tostr = GDKmalloc(expectedlen);
         *l = expectedlen;
      }
   }

   sprintf(*tostr,"(%d:", p->dimension);
   s = *tostr + strlen(*tostr);

   for(i=0;i<p->dimension;++i)
   {
      sprintf(s,"%s@3", ((i==0)?"":","), p->data[i]);
      s += strlen(s);
   }
   *s++ = ')';
   *s = '\0';
   return(s - *tostr);
}

int @1s_fromstr(str instr,int* l,@1s** val) {
   long         dim;
   char         *s;
   int          i;
   @1s     *result;

   for (i = 0, s = instr; *s && i < 1 && *s != ')' ; ++s)
   {
      if (*s == ',' || (*s == '(' && !i))
      {
         dim = atol(s + 1);
         ++i;
      }
   }

   if (*val == NULL)
   {
      *val = GDKmalloc(@1ssize(dim));
      (*val)->dimension = dim;
      *l   = @1ssize(dim);
   } else if (*l < (int)@1ssize(dim)) {
      GDKfree(*val);
      *val = GDKmalloc(@1ssize(dim));
      (*val)->dimension = dim;
      *l   = @1ssize(dim);
   }
   result = *val;

   for (i = 0; *s && i < result->dimension && *s != ')'; ++s)
   {
      if (*s == ',' || *s == ':')
      {
	 ++s;
         result->data[i] = @2(s,&s);
	 --s;
	 ++i;
      }
   }

   return s-instr;
}

void @1s_put(Heap* h,int* bun,@1s* val) {
   char* base;

   *bun  = HEAP_malloc(h,@1ssize(val->dimension));
   base = h->base;
   memcpy(&base[*bun],(char *)val,@1ssize(val->dimension));
}

int @1s_comp(@1s* l,@1s*  r) {
   int i,minlen = l->dimension;
   if (r->dimension < minlen) minlen = r->dimension;
   
   if (minlen == -1) return(0);

   for(i=0;i<minlen;++i) {
      if(l->data[i] != r->data[i]) {
	 if (l->data[i] > r->data[i]) return(1);
	 else                         return(-1);
      }
   }

   if (l->dimension == r->dimension)     return(0);
   else if (l->dimension < r->dimension) return(-1);
   else                                  return(1);
}

void @1s_del(Heap* h,int* index) {
   HEAP_free(h,*index);
}

static int @1war=0;
int @1s_hash(@1s* I) {
   return(I->dimension);
}

 @1s* @1s_null() {
   static @1s* nullptr = NULL;
   if (nullptr == NULL) { nullptr = GDKmalloc(@1ssize(0)); }
   return(nullptr);
}

int @1s_length(@1s* p) {
   return(@1ssize(p->dimension));
}


int @1s_heap(Heap* heap,int capacity) {
   HEAP_initialize(heap,capacity,0,@5);
   return 0;
}

double @1sL2distance(const @1s* I1,const @1s* I2) {
   double rval,tmp;
   int i,dim = I1->dimension;
   if (I1->dimension != I2->dimension) {
      GDKerror("L2distance between vectors of different length\n");
      if (I2->dimension < dim) dim = I2->dimension;
   }
   
   rval = 0;
   for(i=0;i<dim;++i) {
      tmp   = (double)(I2->data[i] - I1->data[i]);
      rval += tmp * tmp;
   }
   rval = sqrt(rval);
   return(rval);
}

int @1Sdimension(int* rval, @1s* i) {
   *rval = i->dimension;
   return(GDK_SUCCEED);
}

int @1Srancreate(@1s**  rval,int*  dim) {
   int i;
   *rval = @1screate(*dim);
   for(i=0;i<(*dim);++i) (*rval)->data[i] = @4rand48();
   return(GDK_SUCCEED);
}

int @1SL2distance(dbl*  rval,@1s*  I1,@1s*  I2) {
   *rval = @1sL2distance(I1,I2);
   return(GDK_SUCCEED);
}

int @1Sgetval(@1*  rval,@1s* I,int*  index) {
   if ((*index > I->dimension) || (*index < 0)) {
      GDKwarning("@1s index out of bounds\n");
      return(GDK_FAIL);
   }
   *rval = I->data[*index];
   return(GDK_SUCCEED);
}

@:vecaggrimpl(@1,max,MAX)@
@:vecaggrimpl(@1,min,MIN)@

@

@= vecaggrimpl
@1s* @1s@2range(BAT* vecs) {
  int  i,xx;
  BUN  p,q;
  BUN  firstbun = BUNfirst( vecs );
  @1s* vec      = (@1s*) ( BUNtvar( vecs, firstbun ) );
  int  dim      = vec->dimension;

  /* Make Copy... */
  @1s* rval    = @1screate(dim);
  for(i=0;i<dim;i++) rval->data[i] = vec->data[i];

  /* Compute aggregate */
  BATloopFast(vecs, p, q, xx) {
    vec = (@1s*) BUNtvar(vecs, p);
    if(vec->dimension != dim) {
      GDKerror( "Cannot compute @2range for vectors of different lengths\n");
      return NULL;
    }
    for(i=0;i<dim;i++) rval->data[i] = @3(rval->data[i],vec->data[i]);
  }

  return(rval);
}

int @1S@2range(@1s* *rval, BAT* vecs) {
  *rval = @1s@2range(vecs);
  if(*rval == NULL) return(GDK_FAIL);
  else              return(GDK_SUCCEED);
}
@

@

