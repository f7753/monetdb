@f vector
@a Wilko Quak, Arjen P. de Vries
@d 03/03/2000
@t A variable lenght vector for Monet

@* Introduction
The module defines some basic operations for a multidimensional vector type
for int, flt, or dbl.

{\em Given its ad-hockery nature, this module should not be considered as an example 
module.}

@* Module Definition
@m
.MODULE vector;

   .USE mmath;

@:vecmel(int)@
@:vecmel(flt)@
@:vecmel(dbl)@

@= vecmel

   .ATOM @1s;
      .TOSTR   = @1s_tostr;
      .FROMSTR = @1s_fromstr;
      .NEQUAL  = @1s_comp;
      .DEL     = @1s_del;
      .HASH    = @1s_hash;
      .NULL    = @1s_null;
      .PUT     = @1s_put;
      .LENGTH  = @1s_length;
      .HEAP    = @1s_heap;
   .END;

   .COMMAND dimension(@1s) 	: int	= @1Sdimension; 
     "Return the dimension of the vector."
   .COMMAND @1s_rancreate(int) 	: @1s	= @1Srancreate; 
     "Create a random vector of the requested dimension."
   .COMMAND getval(@1s,int)	: @1	= @1Sgetval;
     "Project the Ith element value out of the vector."

   .COMMAND L2distance(@1s,@1s) : dbl = @1SL2distance; 
     "Compute the L2 distance between two (feature) vectors."

@:vecaggrmel(@1,max)@
@:vecaggrmel(@1,min)@

@
@m

.END vector;

@= vecaggrmel
   .COMMAND @2range(bat[any,@1s] vecs) : @1s = @1S@2range; 
   "Determine the @2 values of each dimension in the vectors."
@
@* Example script
@mil

module( vector );

#
# create some data
vecs := new(void, flts);
vecs.insert( nil, flts_rancreate( 10 ) );
vecs.insert( nil, flts_rancreate( 10 ) );
vecs.insert( nil, flts_rancreate( 10 ) );
vecs.seqbase(0@0);

vecs.print;

# 
# project 5th dimension
[getval]( vecs, 4 ).print;

#
# range of data
xmax := maxrange( vecs );
xmin := minrange( vecs );

L2distance( xmin, xmax ).print;

quit;
@* Header file

We define for each of the supported basetypes a C++ class to implement the
behaviour. The actual functionality that is accessed from MIL is implemented
in {\tt static} class methods.
@h
#ifndef __VECTOR_H__
#define __VECTOR_H__

#include <gdk.h>

@:vecheader(int)@
@:vecheader(flt)@
@:vecheader(dbl)@

@= vecheader
class @1s
{
private:
   int dimension_v;

public:
   @1 data[1];

public:
   @1s(int dim);

   int dimension() const;
   @1 operator[](int index) const;
   @1& operator[](int index);
   void *operator new(size_t size,int dimension);
   void operator delete(void *ptr);

   static @1s* rancreate(int dim);
   static @1s* create(int dim);

@:vecaggrheader(@1,max)@
@:vecaggrheader(@1,min)@

   @1s* copy() const;
};

extern double L2distance(const @1s& I1,const @1s& I2);

inline @1s::@1s(int d)
{
   dimension_v = d;
}

inline int @1s::dimension() const
{
   return(dimension_v);
}

inline void @1s::operator delete( void *ptr )
{
   delete ptr;
}

inline void* @1s::operator new(size_t size,int dim)
{
   return ((void *)new char[size + ((dim -1)* sizeof(@1))]);
}

inline size_t @1ssize(int dim)
{
   return(sizeof(@1s) + (((dim>0)?(dim -1):(0))* sizeof(@1)));
}

inline @1s* @1s::copy() const
{
   @1s* rval = new(dimension()) @1s(dimension());
   memcpy(rval,this,@1ssize(dimension()));
   return(rval);
}
@
@= vecaggrheader
   static @1s* @2range( BAT *vecs );
@
@h

#endif /* __VECTOR_H__ */

@C
#include <stdlib.h>
#include <string.h>
#include <math.h>

// old: define HEAPindex(HEAP,INDEX,TYPE) ((TYPE *)(HEAP->base + INDEX))

#include "vector.h"
#include "vector.proto.h"

static long get_long(const char* startp,char** endp)
{
   return(strtol(startp,endp,10));
}

static double get_double(const char* startp,char** endp)
{
   return(strtod(startp,endp));
}

@:vecimpl(int,get_long,%d,m,4)@
@:vecimpl(flt,get_double,%f,d,4)@
@:vecimpl(dbl,get_double,%f,d,8)@

@= vecimpl

int @1s_tostr(str* tostr,int* l,@1s* p)
{
   {
      int expectedlen = 20 + (p->dimension() * 15);
      if (*l < expectedlen)
      {
         if (*tostr != NULL)
	    delete *tostr;
	 *tostr = new char[expectedlen];
         *l = expectedlen;
      }
   }

   sprintf(*tostr,"(%d:", p->dimension());
   char* s = *tostr + strlen(*tostr);

   for (int i=0;i<p->dimension();++i)
   {
      sprintf(s,"%s@3", ((i==0)?"":","), (*p)[i]);
      s += strlen(s);
   }
   *s++ = ')';
   *s = '\0';
   return(s - *tostr);
}

int @1s_fromstr(str instr,int* l,@1s** val)
{
   long         dim;
   char         *s;
   int          i;
   @1s     *result;

   //
   // Read the header of the @1s.
   //
   for (i = 0, s = instr; *s && i < 1 && *s != ')' ; ++s)
   {
      if (*s == ',' || (*s == '(' && !i))
      {
         dim = atol(s + 1);
         ++i;
      }
   }

   if (*val == NULL)
   {
      *val = new(dim) @1s(dim);
      *l = @1ssize(dim);
   }
   else if (*l < (int)@1ssize(dim))
   {
      delete *val;
      *val = new(dim) @1s(dim);
      *l = @1ssize(dim);
   }
   result = *val;

   //
   // Read the values of the @1s.
   //
   for (i = 0; *s && i < result->dimension() && *s != ')'; ++s)
   {
      if (*s == ',' || *s == ':')
      {
	 ++s;
         (*result)[i] = @2(s,&s);
	 --s;
	 ++i;
      }
   }

   return s-instr;
}

void @1s_put(Heap* h,int* bun,@1s* val)
{
   char* base;

   *bun  = HEAP_malloc(h,@1ssize(val->dimension()));
   base = h->base;
   memcpy(&base[*bun],(char *)val,@1ssize(val->dimension()));

}

/*
int @1s_get(Heap* h,int* bun,int* l,@1s** val)
{
   @1s* from = HEAPindex(h,*bun,@1s);
   int size = @1ssize(from->dimension());

   if (*val == NULL)
   {
      *val = (@1s *)(new char[size]);
      *l = size;
   }
   else if (*l < size)
   {
      delete *val;
      *val = (@1s *)(new char[size]);
      *l = size;
   }
   memcpy(*val,from,size);

   return (size);
}
*/

int @1s_comp(@1s* l,@1s*  r)
{
   int minlen = l->dimension();
   if (r->dimension() < minlen)
      minlen = r->dimension();
   
   if (minlen == -1)
      return(0);

   for(int i=0;i<minlen;++i)
   {
      // if ((*r)[i] != (*l)[i])
      if(l->data[i] != r->data[i])
      {
	 if ((*l)[i] > (*r)[i])
	    return(1);
	 else
	    return(-1);
      }
   }

   if (l->dimension() == r->dimension())
      return(0);
   else if (l->dimension() < r->dimension())
      return(-1);
   else
      return(1);
}

void @1s_del(Heap* h,int* index)
{
   HEAP_free(h,*index);
}

static int @1war=0;
int @1s_hash(@1s* I)
{
   return(I->dimension());

   if (@1war == 0)
   {
      ++@1war;
      GDKerror("@1s_hash badly implemented yet");
   }
   return 1;
}

 @1s* @1s_null()
{
   static @1s* nullptr = NULL;
   if (nullptr == NULL)
   {
      nullptr = new(0) @1s(0);
   }
   return(nullptr);
}

int @1s_length(@1s* p)
{
   return(@1ssize(p->dimension()));
}


int @1s_heap(Heap* heap,int capacity)
{
   HEAP_initialize(heap,capacity,0,@5);
   return 0;
}

double L2distance(const @1s& I1,const @1s& I2)
{
   int dim = I1.dimension();
   if (I1.dimension() != I2.dimension())
   {
      GDKerror("L2distance between vectors of different lenght\n");
      if (I2.dimension() < dim)
	 dim = I2.dimension();
   }
   
   double rval = 0;
   for(int i=0;i<dim;++i)
      rval += (I2[i] - I1[i]) * (I2[i] - I1[i]);
   rval = sqrt(rval);
   return(rval);
}

@1s* @1s::rancreate(int dim)
{
   @1s* rval = @1s::create(dim);
   for(int i=0;i<dim;++i)
      (*rval)[i] = @4rand48();
   return(rval);
}

extern int @1Sdimension(
   int*     	rval,
   @1s*	i)
{
   *rval = i->dimension();
   return(GDK_SUCCEED);
}

int @1Srancreate(
   @1s**  rval,
   int*  dim)

{
   *rval = @1s::rancreate(*dim);
   return(GDK_SUCCEED);
}

int @1SL2distance(
   dbl*  rval,
   @1s*  I1,
   @1s*  I2)

{
   *rval = L2distance(*I1,*I2);
   return(GDK_SUCCEED);
}

int @1Sgetval(
   @1*  rval,
   @1s* I,
   int*  index)

{
   if ((*index > I->dimension()) || (index < 0))
   {
      GDKwarning("@1s index out of bounds\n");
      return(GDK_FAIL);
   }
   *rval = (*I)[*index];
   return(GDK_SUCCEED);
}

 @1s* @1s::create(int dimension)
{
   @1s* rval = new(dimension) @1s(dimension);
   return(rval);
}

 @1& @1s::operator[](int index)
{
#ifdef DEBUG
   if ((index < 0) || (index >= dimension()))
      GDKerror("index %d out of bounds [0,%d] allowed in @1s::operator[]\n",
         index,dimension()-1);
#endif
   return(data[index]);
}

 @1 @1s::operator[](int index) const
{
#ifdef DEBUG
   if ((index < 0) || (index >= dimension()))
      GDKerror("index %d out of bounds [0,%d] allowed in @1s::operator[]\n",
         index,dimension()-1);
#endif
   return(data[index]);
}

@:vecaggrimpl(@1,max,MAX)@
@:vecaggrimpl(@1,min,MIN)@

@

@= vecaggrimpl
int @1S@2range(
   @1s* *rval,
   BAT* vecs)

{
  *rval = @1s::@2range(vecs);
  if ( *rval == NULL ) 
    return(GDK_FAIL);
  else
    return(GDK_SUCCEED);
}

@1s* @1s::@2range(BAT* vecs)
{
  BUN firstbun = BUNfirst( vecs );
  @1s* vec = (@1s*) ( BUNtvar( vecs, firstbun ) );
  int dim = vec->dimension();

  // compute aggregate
  @1s* rval = vec->copy();
  BUN p,q;
  int xx;
  BATloopFast(vecs, p, q, xx) {
    vec = (@1s*) BUNtvar(vecs, p);
    if ( vec->dimension() != dim ) {
      GDKerror( "Cannot compute @2range for vectors of different lengths\n");
      return NULL;
    }
    for(int i=0;i<dim;++i)
      (*rval)[i] = @3( (*rval)[i], (*vec)[i] );
  }
  
  return(rval);
}
@
