@f counters
@a S. Manegold, P. Boncz
@t Performance Counters
@T
This is a memory/cpu performance measurement tool for MIPS R10000 (IP27),
Sun UltraSparc (sun4u), and Intel Pentium (i586), PentiumPro/PentiumII
(i686) processors. It uses libperfex (IRIX) for R10000, libperfmon (Solaris,
by Richard Enbody, http://www.cse.msu.edu/~enbody/perfmon.html), and
libpperf (Linux, by M. Patrick Goda and Michael S. Warren,
http://qso.lanl.gov/~mpg/pperf.html) for Pentiums. Module counters provides
similar interface and facilities as Peter's R10000 perfex module, but it
offers no multiplexing of several events; only two events can be monitored
at a time. On non-Linux/Pentium, non-Solaris/UltraSparc, and non-IRIX/R10000
systems, only the elapsed time in microseconds is measured.

@+ Module Definition
@m
.MODULE counters;

.ATOM fill32[28,4]; .END;
.ATOM fill64[60,4]; .END;
.ATOM fill128[124,4]; .END;
.ATOM fill256[252,4]; .END;
.ATOM fill512[508,4]; .END;
.ATOM fill384[380,4]; .END;
.ATOM fill640[636,4]; .END;
.ATOM fill1024[1020,4]; .END;

.ATOM counter[64,8]; 
.COMP = compare_counter; 
.END;

.COMMAND create_counter(int event0, int event1) : counter = create_counter_number;
 "start counters for two events specified by number"

.COMMAND create_counter(str event0, str event1) : counter = create_counter_name;
 "start counters for two events specified by name"

.COMMAND get_counter(counter c) : counter = get_counter;
 "stop the counting and retrieve the results"

.COMMAND read_counter(counter c) : BAT[str,lng] = read_counter;
 "store the retrieved results in a BAT"

.COMMAND show_native_events() : BAT[int,str] = show_native_events;
 "all available events"

.COMMAND show_unified_events() : BAT[int,str] = show_unified_events;
 "all unified event names"

.COMMAND check_cpu() = check_cpu;
 "on Linux systems: check, whether CPU is P5, P6, or K7
  (to be used in .LOAD sequence, only)"

.LOAD

check_cpu();

const native_events := show_native_events();
const unified_events := show_unified_events();

.END;

.END counters;

@+ Implementation 
@h
#include "gdk.h"

typedef struct {
	lng status;	/* counter status */
	lng generation;	/* counter id (IRIX) */
	lng usec;	/* microseconds of elapsed time */
	lng clocks;	/* elapsed clock ticks (Linux) */
	lng event0;	/* event counters */
	lng count0;
	lng event1;
	lng count1;
} counter;
@c
#include "counters.h"
#include "counters.proto.h"
#include "errno.h"

int NumEvents = 0, NoEvent = 0;

#if defined(HWCOUNTERS)

 typedef struct {
 	int id0;	/* event id for counter 0 */
 	int id1;	/* event id for counter 1 */
 	str unified;	/* unified event name */
 	str native;	/* native event name */
 #if ( defined(SOLARIS) && defined(CPU_sun4u) )
 	int bits;	/* event code */
 #endif
 } event_t;

 event_t NO_event[1] = { { 00 , 00 , (str) &chr_nil , (str) &chr_nil } };
 event_t *event = NO_event;

 #if ( defined(LINUX) && ( defined(CPU_i568) || defined(CPU_i686) ) )

  #include <libpperf.h>
  #define CPL 2

  #define X_NUMEVENTS 0
  event_t *X_event=NO_event;

  /* P5 (i586) Pentium */

   #define P5_NUMEVENTS 40
   event_t P5_event[P5_NUMEVENTS+1] = {
    {  0 ,  0 , (str) &chr_nil   , "data_read_hits" } ,
    {  1 ,  1 , (str) &chr_nil   , "data_write_hits" } ,
    {  2 ,  2 , "TLB_misses"     , "data_TLB_misses" } ,
    {  3 ,  3 , (str) &chr_nil   , "data_read_misses" } ,
    {  4 ,  4 , (str) &chr_nil   , "data_write_misses" } ,
    {  5 ,  5 , (str) &chr_nil   , "writes_(hits)_to_M/E" } ,
    {  6 ,  6 , (str) &chr_nil   , "data_cache_lines_written_back" } ,
    {  7 ,  7 , (str) &chr_nil   , "external_snoops" } ,
    {  8 ,  8 , (str) &chr_nil   , "data_cache_snoop_hits" } ,
    {  9 ,  9 , (str) &chr_nil   , "memory_accesses_in_both_pipes" } ,
    { 10 , 10 , (str) &chr_nil   , "bank_conflicts" } ,
    { 11 , 11 , (str) &chr_nil   , "misaligned_data_memory_references" } ,
    { 12 , 12 , (str) &chr_nil   , "code_reads" } ,
    { 13 , 13 , (str) &chr_nil   , "code_TLB_misses" } ,
    { 14 , 14 , (str) &chr_nil   , "code_cache_misses" } ,
    { 15 , 15 , (str) &chr_nil   , "segment_register_loaded" } ,
    { 16 , 16 , (str) &chr_nil   , "segment_descriptor_cache_accesses" } ,
    { 17 , 17 , (str) &chr_nil   , "segment_descriptor_cache_hits" } ,
    { 18 , 18 , (str) &chr_nil   , "branches" } ,
    { 19 , 19 , (str) &chr_nil   , "BTB_hits" } ,
    { 20 , 20 , (str) &chr_nil   , "taken_branches_or_BTB_hits" } ,
    { 21 , 21 , (str) &chr_nil   , "pipeline_flushes" } ,
    { 22 , 22 , (str) &chr_nil   , "instructions_executed_in_both_pipes" } ,
    { 23 , 23 , (str) &chr_nil   , "instructions_executed_in_V-pipe" } ,
    { 24 , 24 , (str) &chr_nil   , "clocks_while_bus_cycle_in_progress" } ,
    { 25 , 25 , (str) &chr_nil   , "pipe_stalled_by_full_write_buffers" } ,
    { 26 , 26 , (str) &chr_nil   , "pipe_stalled_by_waiting_for_data_reads" } ,
    { 27 , 27 , (str) &chr_nil   , "pipe_stalled_by_writes_to_M/E" } ,
    { 28 , 28 , (str) &chr_nil   , "locked_bus_cycles" } ,
    { 29 , 29 , (str) &chr_nil   , "I/O_read_or_write_cycles" } ,
    { 30 , 30 , (str) &chr_nil   , "non-cacheable_memory_references" } ,
    { 31 , 31 , (str) &chr_nil   , "pipeline_stalled_by_AGI" } ,
    { 32 , 32 , (str) &chr_nil   , "floating-point_operations" } ,
    { 33 , 33 , (str) &chr_nil   , "breakpoint_matches_on_DR0" } ,
    { 34 , 34 , (str) &chr_nil   , "breakpoint_matches_on_DR1" } ,
    { 35 , 35 , (str) &chr_nil   , "breakpoint_matches_on_DR2" } ,
    { 36 , 36 , (str) &chr_nil   , "breakpoint_matches_on_DR3" } ,
    { 37 , 37 , (str) &chr_nil   , "hardware_interrupts" } ,
    { 38 , 38 , (str) &chr_nil   , "data_reads_or_writes" } ,
    { 39 , 39 , "L1_data_misses" , "data_read/write_misses" } ,
    { 00 , 39 , (str) &chr_nil   , (str) &chr_nil } };

  /* P6 (i686) PentiumPro/PentiumII/PentiumIII/Celeron */

   #define P6_NUMEVENTS 68
   event_t P6_event[P6_NUMEVENTS+1] = {
    {  0 ,  0 , (str) &chr_nil   , "all_memory_references,_cachable_and_non" } ,
    {  1 ,  1 , "L1_data_misses" , "total_lines_allocated_in_the_DCU" } ,
    {  2 ,  2 , (str) &chr_nil   , "number_of_M_state_lines_allocated_in_DCU" } ,
    {  3 ,  3 , (str) &chr_nil   , "number_of_M_lines_evicted_from_the_DCU" } ,
    {  4 ,  4 , (str) &chr_nil   , "number_of_cycles_while_DCU_miss_outstanding" } ,
    {  5 ,  5 , (str) &chr_nil   , "number_of_non/cachable_instruction_fetches" } ,
    {  6 ,  6 , (str) &chr_nil   , "number_of_instruction_fetch_misses" } ,
    {  7 ,  7 , (str) &chr_nil   , "number_of_ITLB_misses" } ,
    {  8 ,  8 , (str) &chr_nil   , "cycles_instruction_fetch_pipe_is_stalled" } ,
    {  9 ,  9 , (str) &chr_nil   , "cycles_instruction_length_decoder_is_stalled" } ,
    { 10 , 10 , (str) &chr_nil   , "number_of_L2_instruction_fetches" } ,
    { 11 , 11 , (str) &chr_nil   , "number_of_L2_data_loads" } ,
    { 12 , 12 , (str) &chr_nil   , "number_of_L2_data_stores" } ,
    { 13 , 13 , "L2_data_misses" , "number_of_allocated_lines_in_L2" } ,
    { 14 , 14 , (str) &chr_nil   , "number_of_recovered_lines_from_L2" } ,
    { 15 , 15 , (str) &chr_nil   , "number_of_modified_lines_allocated_in_L2" } ,
    { 16 , 16 , (str) &chr_nil   , "number_of_modified_lines_removed_from_L2" } ,
    { 17 , 17 , (str) &chr_nil   , "number_of_L2_requests" } ,
    { 18 , 18 , (str) &chr_nil   , "number_of_L2_address_strobes" } ,
    { 19 , 19 , (str) &chr_nil   , "number_of_cycles_data_bus_was_busy" } ,
    { 20 , 20 , (str) &chr_nil   , "cycles_data_bus_was_busy_in_xfer_from_L2_to_CPU" } ,
    { 21 , 21 , (str) &chr_nil   , "number_of_clocks_DRDY_is_asserted" } ,
    { 22 , 22 , (str) &chr_nil   , "number_of_clocks_LOCK_is_asserted" } ,
    { 23 , 23 , (str) &chr_nil   , "number_of_outstanding_bus_requests" } ,
    { 24 , 24 , (str) &chr_nil   , "number_of_burst_read_transactions" } ,
    { 25 , 25 , (str) &chr_nil   , "number_of_read_for_ownership_transactions" } ,
    { 26 , 26 , (str) &chr_nil   , "number_of_write_back_transactions" } ,
    { 27 , 27 , (str) &chr_nil   , "number_of_instruction_fetch_transactions" } ,
    { 28 , 28 , (str) &chr_nil   , "number_of_invalidate_transactions" } ,
    { 29 , 29 , (str) &chr_nil   , "number_of_partial_write_transactions" } ,
    { 30 , 30 , (str) &chr_nil   , "number_of_partial_transactions" } ,
    { 31 , 31 , (str) &chr_nil   , "number_of_I/O_transactions" } ,
    { 32 , 32 , (str) &chr_nil   , "number_of_deferred_transactions" } ,
    { 33 , 33 , (str) &chr_nil   , "number_of_burst_transactions" } ,
    { 34 , 34 , (str) &chr_nil   , "number_of_all_transactions" } ,
    { 35 , 35 , (str) &chr_nil   , "number_of_memory_transactions" } ,
    { 36 , 36 , (str) &chr_nil   , "bus_cycles_this_processor_is_receiving_data" } ,
    { 37 , 37 , (str) &chr_nil   , "bus_cycles_this_processor_is_driving_BNR_pin" } ,
    { 38 , 38 , (str) &chr_nil   , "bus_cycles_this_processor_is_driving_HIT_pin" } ,
    { 39 , 39 , (str) &chr_nil   , "bus_cycles_this_processor_is_driving_HITM_pin" } ,
    { 40 , 40 , (str) &chr_nil   , "cycles_during_bus_snoop_stall" } ,
    { 41 , -1 , (str) &chr_nil   , "number_of_computational_FP_operations_retired" } ,
    { 42 , -1 , (str) &chr_nil   , "number_of_computational_FP_operations_executed" } ,
    { -1 , 43 , (str) &chr_nil   , "number_of_FP_execptions_handled_by_microcode" } ,
    { -1 , 44 , (str) &chr_nil   , "number_of_multiplies" } ,
    { -1 , 45 , (str) &chr_nil   , "number_of_divides" } ,
    { 46 , -1 , (str) &chr_nil   , "cycles_divider_is_busy" } ,
    { 47 , 47 , (str) &chr_nil   , "number_of_store_buffer_blocks" } ,
    { 48 , 48 , (str) &chr_nil   , "number_of_store_buffer_drain_cycles" } ,
    { 49 , 49 , (str) &chr_nil   , "number_of_misaligned_data_memory_references" } ,
    { 50 , 50 , (str) &chr_nil   , "number_of_instructions_retired" } ,
    { 51 , 51 , (str) &chr_nil   , "number_of_UOPs_retired" } ,
    { 52 , 52 , (str) &chr_nil   , "number_of_instructions_decoded" } ,
    { 53 , 53 , (str) &chr_nil   , "number_of_hardware_interrupts_received" } ,
    { 54 , 54 , (str) &chr_nil   , "cycles_interrupts_are_disabled" } ,
    { 55 , 55 , (str) &chr_nil   , "cycles_interrupts_are_disabled_with_pending_interrupts" } ,
    { 56 , 56 , (str) &chr_nil   , "number_of_branch_instructions_retired" } ,
    { 57 , 57 , (str) &chr_nil   , "number_of_mispredicted_bracnhes_retired" } ,
    { 58 , 58 , (str) &chr_nil   , "number_of_taken_branches_retired" } ,
    { 59 , 59 , (str) &chr_nil   , "number_of_taken_mispredictions_branches_retired" } ,
    { 60 , 60 , (str) &chr_nil   , "number_of_branch_instructions_decoded" } ,
    { 61 , 61 , (str) &chr_nil   , "number_of_branches_that_miss_the_BTB" } ,
    { 62 , 62 , (str) &chr_nil   , "number_of_bogus_branches" } ,
    { 63 , 63 , (str) &chr_nil   , "number_of_times_BACLEAR_is_asserted" } ,
    { 64 , 64 , (str) &chr_nil   , "cycles_during_resource_related_stalls" } ,
    { 65 , 65 , (str) &chr_nil   , "cycles_or_events_for_partial_stalls" } ,
    { 66 , 66 , (str) &chr_nil   , "number_of_segment_register_loads" } ,
    { 67 , 67 , "cycles"         , "clocks_processor_is_not_halted" } ,
    { 00 , 67 , (str) &chr_nil   , (str) &chr_nil } };

  /* K7 (i686) Athlon */

   #define K7_NUMEVENTS 55
   event_t K7_event[K7_NUMEVENTS+1] = {
    {  0 ,  0 , (str) &chr_nil   , "data_mem_refs" } ,
    {  1 ,  1 , (str) &chr_nil   , "dcu_lines_in" } ,
    {  2 ,  2 , "L1_data_misses" , "L1_misses" } ,
    {  3 ,  3 , "L2_data_misses" , "L2_misses" } ,
    {  4 ,  4 , (str) &chr_nil   , "dcu_writebacks" } ,
    {  5 ,  5 , "TLB_misses"     , "TLB1_misses_proper" } ,
    {  6 ,  6 , (str) &chr_nil   , "TLB2_misses" } ,
    {  7 ,  7 , (str) &chr_nil   , "misalign_mem_ref" } ,
    {  8 ,  8 , (str) &chr_nil   , "ifu_ifetch" } ,
    {  9 ,  9 , (str) &chr_nil   , "ifu_ifetch_miss" } ,
    { 10 , 10 , (str) &chr_nil   , "ITLB1_misses_proper" } ,
    { 11 , 11 , (str) &chr_nil   , "ITLB2_misses" } ,
    { 12 , 12 , (str) &chr_nil   , "inst_retired" } ,
    { 13 , 13 , (str) &chr_nil   , "uops_retired" } ,
    { 14 , 14 , (str) &chr_nil   , "br_inst_retired" } ,
    { 15 , 15 , (str) &chr_nil   , "br_miss_pred_retired" } ,
    { 16 , 16 , (str) &chr_nil   , "br_taken_retired" } ,
    { 17 , 17 , (str) &chr_nil   , "br_miss_pred_taken_ret" } ,
    { 18 , 18 , (str) &chr_nil   , "far_ctrtf_retired" } ,
    { 19 , 19 , (str) &chr_nil   , "br_resync_retired" } ,
    { 20 , 20 , (str) &chr_nil   , "cycles_int_masked" } ,
    { 21 , 21 , (str) &chr_nil   , "hw_int_rx" } ,
    { 22 , 22 , (str) &chr_nil   , "seg_reg_loads" } ,
    { 23 , 23 , (str) &chr_nil   , "store_to_act_instr_stream" } ,
    { 24 , 24 , (str) &chr_nil   , "dram_sys_req" } ,
    { 25 , 25 , (str) &chr_nil   , "sys_req_type" } ,
    { 26 , 26 , (str) &chr_nil   , "snoop_hits" } ,
    { 27 , 27 , (str) &chr_nil   , "ecc_errors" } ,
    { 28 , 28 , (str) &chr_nil   , "cache_line_invalid" } ,
    { 29 , 29 , "cycles"         , "cyc_cpu_running" } ,
    { 30 , 30 , (str) &chr_nil   , "L2_requests" } ,
    { 31 , 31 , (str) &chr_nil   , "cyc_fill_stall" } ,
    { 32 , 32 , (str) &chr_nil   , "snoop_resyncs" } ,
    { 33 , 33 , (str) &chr_nil   , "instr_fetch_stall" } ,
    { 34 , 34 , (str) &chr_nil   , "rtrn_stack_hits" } ,
    { 35 , 35 , (str) &chr_nil   , "rtrn_stack_overflow" } ,
    { 36 , 36 , (str) &chr_nil   , "near_rtrn_retired" } ,
    { 37 , 37 , (str) &chr_nil   , "near_rtrn_miss_pred_retired" } ,
    { 38 , 38 , (str) &chr_nil   , "ind_br_target_miss_pred_retired" } ,
    { 39 , 39 , (str) &chr_nil   , "cyc_int_masked_pending" } ,
    { 40 , 40 , (str) &chr_nil   , "instr_dec_empty" } ,
    { 41 , 41 , (str) &chr_nil   , "dispatch_stall" } ,
    { 42 , 42 , (str) &chr_nil   , "br_aborts_retire" } ,
    { 43 , 43 , (str) &chr_nil   , "serialize" } ,
    { 44 , 44 , (str) &chr_nil   , "seg_load_stall" } ,
    { 45 , 45 , (str) &chr_nil   , "ICU_full" } ,
    { 46 , 46 , (str) &chr_nil   , "res_stations_full" } ,
    { 47 , 47 , (str) &chr_nil   , "FPU_full" } ,
    { 48 , 48 , (str) &chr_nil   , "LS_full" } ,
    { 49 , 49 , (str) &chr_nil   , "all_quiet_stall" } ,
    { 50 , 50 , (str) &chr_nil   , "far_tf_rs_br_pending" } ,
    { 51 , 51 , (str) &chr_nil   , "brk_pnt_DR0" } ,
    { 52 , 52 , (str) &chr_nil   , "brk_pnt_DR1" } ,
    { 53 , 53 , (str) &chr_nil   , "brk_pnt_DR2" } ,
    { 54 , 54 , (str) &chr_nil   , "brk_pnt_DR3" } ,
    { 00 , 54 , (str) &chr_nil   , (str) &chr_nil } };

 #elif ( defined(IRIX) && defined(CPU_IP27) ) /* R10k, R12k */

  #define X_NUMEVENTS 32
  event_t X_event[X_NUMEVENTS+1] = {
   {  0 , 16 , "cycles"         , "cycles" } ,
   {  1 , -1 , (str) &chr_nil   , "instructions" } ,
   {  2 , -1 , (str) &chr_nil   , "loads" } ,
   {  3 , -1 , (str) &chr_nil   , "stores" } ,
   {  4 , -1 , (str) &chr_nil   , "cond_stores" } ,
   {  5 , -1 , (str) &chr_nil   , "cond_stores_fail" } ,
   {  6 , -1 , (str) &chr_nil   , "branches_resolved" } ,
   {  7 , -1 , (str) &chr_nil   , "L2_writebacks" } ,
   {  8 , -1 , (str) &chr_nil   , "L2_ECCerrors" } ,
   {  9 , -1 , (str) &chr_nil   , "L1_ins_misses" } ,
   { 10 , -1 , (str) &chr_nil   , "L2_ins_misses" } ,
   { 11 , -1 , (str) &chr_nil   , "L2_ins_mispredicts" } ,
   { 12 , -1 , (str) &chr_nil   , "interventions_reqs" } ,
   { 13 , -1 , (str) &chr_nil   , "invalidations_reqs" } ,
   { 14 , -1 , (str) &chr_nil   , "func_completion_cycles" } ,
   { 15 , 17 , (str) &chr_nil   , "instructions_grad" } ,
   {  0 , 16 , "cycles"         , "cycles" } ,
   { 15 , 17 , (str) &chr_nil   , "instructions_grad" } ,
   { -1 , 18 , (str) &chr_nil   , "loads_grad" } ,
   { -1 , 19 , (str) &chr_nil   , "stores_grad" } ,
   { -1 , 20 , (str) &chr_nil   , "cond_stores_grad" } ,
   { -1 , 21 , (str) &chr_nil   , "fp_ops_grad" } ,
   { -1 , 22 , (str) &chr_nil   , "L1_writebacks" } ,
   { -1 , 23 , "TLB_misses"     , "TLB_misses" } ,
   { -1 , 24 , (str) &chr_nil   , "branches_mispredict" } ,
   { -1 , 25 , "L1_data_misses" , "L1_data_misses" } ,
   { -1 , 26 , "L2_data_misses" , "L2_data_misses" } ,
   { -1 , 27 , (str) &chr_nil   , "L2_data_mispredicts" } ,
   { -1 , 28 , (str) &chr_nil   , "intervention_hits" } ,
   { -1 , 29 , (str) &chr_nil   , "invalidation_hits" } ,
   { -1 , 30 , (str) &chr_nil   , "L2_clean_excl" } ,
   { -1 , 31 , (str) &chr_nil   , "L2_shared_excl" } ,
   { 00 , 31 , (str) &chr_nil   , (str) &chr_nil } };

 #elif ( defined(SOLARIS) && defined(CPU_sun4u) ) /* UltraSparc */

  #include <sys/types.h>
  #include <sys/processor.h>
  #include <sys/procset.h>
  #include <perfmon.h>
  #define X_NUMEVENTS 24
  event_t X_event[X_NUMEVENTS+1] = {
   {  0 , 12 , "cycles"         , "CYCLE_CNT"        , PCR_S0_CYCLE_CNT } ,
   {  1 , 13 , (str) &chr_nil   , "INSTR_CNT"        , PCR_S0_INSTR_CNT } ,
   {  2 , -1 , (str) &chr_nil   , "STALL_IC_MISS"    , PCR_S0_STALL_IC_MISS } ,
   {  3 , -1 , (str) &chr_nil   , "STALL_STORBUF"    , PCR_S0_STALL_STORBUF } ,
   {  4 , -1 , (str) &chr_nil   , "IC_REF"           , PCR_S0_IC_REF } ,
   {  5 , -1 , (str) &chr_nil   , "DC_READ"          , PCR_S0_DC_READ } ,
   {  6 , -1 , (str) &chr_nil   , "DC_WRITE"         , PCR_S0_DC_WRITE } ,
   {  7 , -1 , (str) &chr_nil   , "STALL_LOAD"       , PCR_S0_STALL_LOAD } ,
   {  8 , -1 , (str) &chr_nil   , "EC_REF"           , PCR_S0_EC_REF } ,
   {  9 , -1 , (str) &chr_nil   , "EC_WRITE_RO"      , PCR_S0_EC_WRITE_RO } ,
   { 10 , -1 , (str) &chr_nil   , "EC_SNOOP_INV"     , PCR_S0_EC_SNOOP_INV } ,
   { 11 , -1 , "L1_data_misses" , "EC_READ_HIT"      , PCR_S0_EC_READ_HIT } ,
   {  0 , 12 , "cycles"         , "CYCLE_CNT"        , PCR_S1_CYCLE_CNT } ,
   {  1 , 13 , (str) &chr_nil   , "INSTR_CNT"        , PCR_S1_INSTR_CNT } ,
   { -1 , 14 , (str) &chr_nil   , "STALL_MISPRED"    , PCR_S1_STALL_MISPRED } ,
   { -1 , 15 , (str) &chr_nil   , "STALL_FPDEP"      , PCR_S1_STALL_FPDEP } ,
   { -1 , 16 , (str) &chr_nil   , "IC_HIT"           , PCR_S1_IC_HIT } ,
   { -1 , 17 , (str) &chr_nil   , "DC_READ_HIT"      , PCR_S1_DC_READ_HIT } ,
   { -1 , 18 , (str) &chr_nil   , "DC_WRITE_HIT"     , PCR_S1_DC_WRITE_HIT } ,
   { -1 , 19 , (str) &chr_nil   , "LOAD_STALL_RAW"   , PCR_S1_LOAD_STALL_RAW } ,
   { -1 , 20 , (str) &chr_nil   , "EC_HIT"           , PCR_S1_EC_HIT } ,
   { -1 , 21 , "L2_data_misses" , "EC_WRITEBACK"     , PCR_S1_EC_WRITEBACK } ,
   { -1 , 22 , (str) &chr_nil   , "EC_SNOOP_COPYBCK" , PCR_S1_EC_SNOOP_COPYBCK } ,
   { -1 , 23 , (str) &chr_nil   , "EC_IC_HIT"        , PCR_S1_EC_IC_HIT } ,
   { 00 , 23 , (str) &chr_nil   , (str) &chr_nil     , PCR_S0_CYCLE_CNT | PCR_S1_EC_IC_HIT } };

 #else /* other OSs or CPUs */

  #undef HWCOUNTERS
  #define X_NUMEVENTS 0
  event_t *X_event=NO_event;

 #endif

#else /* no HWCOUNTERS */

 #define X_NUMEVENTS 0

#endif

extern int monet_modulesilent;

int check_cpu() {
    FILE *fp = NULL;

    NumEvents = NoEvent = 0;
#if ( defined(HWCOUNTERS) )
    event = NO_event;
 #if ( defined(LINUX) )
  #if ( defined(CPU_i586) )
    NumEvents = NoEvent = P5_NUMEVENTS;
    event = P5_event;
  #elif ( defined(CPU_i686) )
    if ( (fp = fopen("/proc/cpuinfo","r")) == NULL ) {
        if (!monet_modulesilent)
            GDKwarning("check_cpu: Cannot open /proc/cpuinfo to determine CPU.\n");
    } else {
        char buf[256];
        char *p1, *p2;
        int found = 0;
        while ( fgets(buf,sizeof(buf),fp) != NULL ) {
            /* Break the line up at ':' into two parts. */
            p1 = strtok(buf,":");
            p2 = strtok(NULL,":");
            /* Get rid of [TAB] in /proc/cpuinfo if it's there */
            p1 = strtok(p1,"\t");
            p2 = strtok(p2," ");
            p2 = strtok(p2,"\n");
            if (strcmp(p1,"vendor_id") == 0) {
                found++;
                if (!strcmp(p2,"GenuineIntel")) {
                    NumEvents = NoEvent = P6_NUMEVENTS;
                    event = P6_event;
                } else if (!strcmp(p2,"AuthenticAMD")) {
                    NumEvents = NoEvent = K7_NUMEVENTS;
                    event = K7_event;
                } else {
                    if (!monet_modulesilent)
                        GDKwarning("check_cpu: Unknown vendor_id '%s` in /proc/cpuinfo.\n",p2);
                }
      	    }
        }
        if ( (!found) && (!monet_modulesilent) )
            GDKwarning("check_cpu: No 'vendor_id` found in /proc/cpuinfo.\n");
	if (found > 1) {
	    if (!monet_modulesilent)
	        GDKwarning("check_cpu: Currently, there's no hardware counter support for Linux SMP machines.\n");
	    NumEvents = NoEvent = 0;
	    event = NO_event;
	}
        fclose(fp);
    }
    if ( (!NumEvents) && (!monet_modulesilent) )
        GDKwarning("check_cpu: Hardware counters will not be available.\n");
  #endif
 #else /* no Linux-PC */
    NumEvents = NoEvent = X_NUMEVENTS;
    event = X_event;
 #endif
#endif
    return GDK_SUCCEED;
}

int compare_counter(counter *c1, counter* c2) {
	return c1->usec - c2->usec; /* compare on time in usecs */
}


int create_counter_number(counter *retval, int *event0, int *event1) {
    int generation = -1, e0 = *event0, e1 = *event1, ee = NoEvent;
#if ( defined(HWCOUNTERS) && defined(SOLARIS) )
    int rtrn = -1;
    unsigned long long set = 0, val = 0;
#endif

    /* create the resulting counter object */
    memset(retval, 0, sizeof(counter));
#if defined(HWCOUNTERS)
    if (e0 < 0 || e0 >= NumEvents)  e0 = NoEvent;
    if (e1 < 0 || e1 >= NumEvents)  e1 = NoEvent;
    if (((event[e0].id0 < 0) && (event[e1].id0 >= 0)) ||
        ((event[e1].id1 < 0) && (event[e0].id1 >= 0))) {
        ee = e0;
        e0 = event[e1].id0;
        e1 = event[ee].id1;
    }
    if (event[e0].id0 < 0)  e0 = NoEvent; 
    if (event[e1].id1 < 0)  e1 = NoEvent;
    if ((e0 != NoEvent) || (e1 != NoEvent)) {
 #if defined(LINUX)
        if ((generation = start_counters(event[e0].id0,CPL,event[e1].id1,CPL)) != 0) {
            GDKerror("create_counter: start_counters failed with return value %d, errno %d.\n", 
                     generation,errno);
            fprintf(stderr,"! create_counter/start_counters: "); pstatus(generation);
            perror("! create_counter/start_counters");
            return GDK_FAIL;
        }
 #elif defined(IRIX)
        if ((generation = start_counters(event[e0].id0,event[e1].id1)) < 0) {
            GDKerror("create_counter: start_counters failed with return value %d, errno %d\n", 
                     generation,errno);
            perror("! create_counter/start_counters");
            return GDK_FAIL;
        }    
 #elif defined(SOLARIS)
        if ((rtrn = processor_bind(P_PID, P_MYID, 0, NULL)) < 0) {
            GDKerror("create_counter: processor_bind failed with return value %d, errno %d\n", 
                     rtrn,errno);
            perror("! create_counter/processor_bind");
            return GDK_FAIL;
        }
        if ((generation = open("/dev/perfmon", O_RDONLY)) < 0) {
            GDKerror("create_counter: open(/dev/perfmon,O_RDONLY) failed with return value %d, errno %d\n", 
                     generation,errno);
            perror("! create_counter/open");
            return GDK_FAIL;
        }
        set = ( PCR_USER_TRACE | event[e0].bits | event[e1].bits );
        if ((rtrn = ioctl(generation, PERFMON_SETPCR, &set)) < 0) {
            GDKerror("create_counter: ioctl(generation, PERFMON_SETPCR, &set) failed with return value %d, errno %d\n", 
                     rtrn,errno);
            perror("! create_counter/ioctl");
            close(generation);
            return GDK_FAIL;
        }
        clr_pic();
        cpu_sync();
        val = get_pic();
 #endif
    }
#endif
    retval->status = 1;
    retval->generation = (lng)generation;
    retval->event0 = (lng)(e0);
    retval->event1 = (lng)(e1);
    retval->usec = GDKusec();
#if ( defined(HWCOUNTERS) && defined(SOLARIS) )
    retval->count0 = (lng)(val & 0xffffffff);
    retval->count1 = (lng)(val >> 32);
    retval->clocks = (lng)get_tick();
#endif
#if ( defined(HWCOUNTERS) && defined(LINUX) )
    retval->clocks = rdtsc();
#endif
    return GDK_SUCCEED;
}


int create_counter_name(counter *retval, str event0, str event1) {
    int e0 = NoEvent, e1 = NoEvent, found = 0;
    
#if defined(HWCOUNTERS)
    for (e0 = 0; e0 < NumEvents; e0++)
        if (found = (!strcmp(event0, event[e0].unified) ||
                     !strcmp(event0, event[e0].native)))
            break;
    if (!found)  e0 = NoEvent;
    for (e1 = NumEvents-1; e1 >= 0; e1--)
        if (found = (!strcmp(event1, event[e1].unified) ||
                     !strcmp(event1, event[e1].native)))
            break;
    if (!found)  e1 = NoEvent;
#endif
    return create_counter_number(retval, &e0, &e1);
}


int get_counter(counter *retval, counter *c) {
#if ( defined(HWCOUNTERS) && defined(LINUX) )
    lng clocks = rdtsc() - c->clocks;
#elif ( defined(HWCOUNTERS) && defined(SOLARIS) )
    lng clocks = (lng)get_tick() - c->clocks;
    unsigned long long val = 0;
#else
    lng clocks = -1;
#endif
    lng usec = GDKusec() - c->usec;
    int generation = -1;
    lng count0 = -1, count1 = -1, noclocks = -1;
    dbl notimer = -1.0;

    if (c->status != 1) {
        GDKerror("get_counter: counter not started or already stopped.\n");
        return GDK_FAIL;
    }
#if defined(HWCOUNTERS)
    if ((c->event0 != NoEvent) || (c->event1 != NoEvent)) {
 #if defined(LINUX)
        if ((generation = read_counters(&count0,&count1,&notimer,&noclocks)) != 0) {
            GDKerror("get_counter: read_counters failed with return value %d, errno %d.\n", 
                     generation,errno);
            fprintf(stderr,"! get_counter/read_counters: "); pstatus(generation);
            perror("! get_counter/read_counters");
            return GDK_FAIL;
        }
 #elif defined(IRIX)
        if ((generation = read_counters((int)(event[c->event0].id0),&count0,
                                        (int)(event[c->event1].id1),&count1)) < 0) {
            GDKerror("get_counter: read_counters failed with return value %d, errno %d\n", 
                     generation,errno);
            perror("! get_counter/read_counters");
            return GDK_FAIL;
        }    
        if ((lng)generation != c->generation) {
            GDKerror("get_counter: lost event counter.\n");
            return GDK_FAIL;
        }
        if (event[c->event0].id0 ==  0)  clocks = count0;
        if (event[c->event1].id1 == 16)  clocks = count1;
 #elif defined(SOLARIS)
        cpu_sync();
        val = get_pic();
        count0 = (lng)(val & 0xffffffff) - c->count0;
        count1 = (lng)(val >> 32) - c->count1;
        close(c->generation);
 #endif
    }
#endif
    /* get the values */
    retval->status = 2;
    retval->usec = usec;
    retval->generation = c->generation;
    retval->event0 = c->event0;
    if (c->event0 == NoEvent)
        retval->count0 = lng_nil;
    else
        retval->count0 = count0;
    retval->event1 = c->event1;
    if (c->event1 == NoEvent)
        retval->count1 = lng_nil;
    else
        retval->count1 = count1;
    retval->clocks = clocks;
    return GDK_SUCCEED;
}


int read_counter(BAT **ret, counter *c) {
    lng ms;
    if (c->status != 2) {
        GDKerror("read_counter: counter not stopped.\n");
        return GDK_FAIL;
    }
    ms=c->usec/1000;
    *ret = BATnew(TYPE_str, TYPE_lng, 6);
    BUNins(*ret, "status", &c->status);
    BUNins(*ret, "generation", &c->generation);
    BUNins(*ret, "microsecs", &c->usec);
    BUNins(*ret, "millisecs", &ms);
    BUNins(*ret, "clock_ticks", &c->clocks);
#if defined(HWCOUNTERS)
    BUNins(*ret, event[(int)(c->event0)].native, &c->count0);
    BUNins(*ret, event[(int)(c->event1)].native, &c->count1);
#endif
/*
    (*ret)->halign = 3928437;
    BATkey(*ret, TRUE);
*/
    BATname(*ret, "counter");
    return GDK_SUCCEED;
}

int show_native_events(BAT **ret) {
    int i = 0;
    
    *ret = BATnew(TYPE_int, TYPE_str, NumEvents);
#if defined(HWCOUNTERS)
    for (i = 0; i < NumEvents; i++)
        BUNins(*ret, &i, event[i].native);
#endif
    BATkey(*ret, TRUE);
    BATname(*ret, "native_events");
    return GDK_SUCCEED;
}

int show_unified_events(BAT **ret) {
    int i = 0;
    
    *ret = BATnew(TYPE_int, TYPE_str, NumEvents);
#if defined(HWCOUNTERS)
    for (i = 0; i < NumEvents; i++)
        if (event[i].unified != str_nil)
            BUNins(*ret, &i, event[i].unified);
#endif
    BATkey(*ret, TRUE);
    BATname(*ret, "unified_events");
    return GDK_SUCCEED;
}


@+ Test Script	
@mil
module("counters");

sigs("counters");

var eu, en, ne, ne2, e0, e1, n0, n1;

en := native_events;
ne := count(en);
ne2 := ne / 2;

en.print;
show_native_events.print;

en@batloop {
	e0 := $h;
	if ( e0 < ne2 ) {
		e1 := e0 + ne2;
	} else {
		e1 := ( ne - e0 ) - 1;
	}
	n0 := en.find(e0);
	n1 := en.find(e1);
	create_counter(e0,e1).get_counter.read_counter.col_name(sprintf("counters %d & %d",e0,e1)).print;
	create_counter(n0,n1).get_counter.read_counter.col_name(sprintf("counters %d & %d",e0,e1)).print;
	create_counter(e0,e0).get_counter.read_counter.col_name(sprintf("counters %d & %d",e0,e0)).print;
	create_counter(n1,n1).get_counter.read_counter.col_name(sprintf("counters %d & %d",e0,e0)).print;
}

eu := unified_events;

eu.print;
show_unified_events.print;

eu@batloop {
	e0 := $h;
	e1 := $h;
	n0 := eu.find(e0);
	n1 := eu.find(e1);
	create_counter(e0,e1).get_counter.read_counter.col_name(sprintf("counters %d & %d",e0,e1)).print;
	create_counter(n0,n1).get_counter.read_counter.col_name(sprintf("counters %d & %d",e0,e1)).print;
}

quit;
