@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at 
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@' 
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@' 
@' The Original Code is the Monet Database System.
@' 
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2002 CWI.  
@' All Rights Reserved.
@' 
@' Contributor(s):
@' 		Martin Kersten <Martin.Kersten@cwi.nl>
@' 		Peter Boncz <Peter.Boncz@cwi.nl>
@' 		Niels Nes <Niels.Nes@cwi.nl>
@' 		Stefan Manegold  <Stefan.Manegold@cwi.nl>
@' 		Alex van Ballegooij <Alex.van.Ballegooij@cwi.nl>

@f mmath
@a N.J. Nes
@d 07/01/1996
@t The math module

@* Introduction
This module contains the math commands. The implementation is very simply,
the c math library functions are called. See for documentation the
ANSI-C/POSIX manuals of the equaly named functions.

@* Module Definition
@m
.MODULE mmath;

   .COMMAND acos(dbl) 	  : dbl = math_unary_ACOS;
"The acos(x) function calculates the arc cosine of x;
that is the value whose cosine is x. The value is returned in radians
and is mathematically defined to be between 0 and PI (inclusive)."
   .COMMAND asin(dbl)     : dbl = math_unary_ASIN;
"The asin(x) function calculates the arc sine of x;
that is the value whose sine is x. The value is returned in radians
and is mathematically defined to be between -PI/20 and -PI/2 (inclusive)."
   .COMMAND atan(dbl)     : dbl = math_unary_ATAN;
"The atan(x) function calculates the arc tangent of x;
that is the value whose tangent is x. The value is returned in radians
and is mathematically defined to be between -PI/2 and PI/2 (inclusive)."
  .COMMAND atan2(dbl,dbl): dbl = math_binary_ATAN2;
"The atan2(x,y) function calculates the arc tangent of the two
variables x and y. It is similar to calculating the arc
tangent of y / x, except that the signs of both arguments
are used to determine the quadrant of the result.
The value is returned in radians and is mathematically defined
to be between -PI/2 and PI/2 (inclusive)."

   .COMMAND cos(dbl)   	  : dbl = math_unary_COS;
"The cos(x) function returns the cosine of x,
where x is given in radians. The return value is between -1 and 1."
   .COMMAND sin(dbl)   	  : dbl = math_unary_SIN;
"The sin(x) function returns the cosine of x,
where x is given in radians. The return value is between -1 and 1."
   .COMMAND tan(dbl)   	  : dbl = math_unary_TAN;
"The tan(x) function returns the tangent of x,
where x is given in radians"

   .COMMAND cosh(dbl)     : dbl = math_unary_COSH;
"The cosh() function  returns the hyperbolic cosine of x,
which is defined mathematically as (exp(x) + exp(-x)) / 2."
   .COMMAND sinh(dbl)     : dbl = math_unary_SINH;
"The sinh() function  returns  the  hyperbolic sine of x,
which is defined mathematically as (exp(x) - exp(-x)) / 2."
   .COMMAND tanh(dbl)     : dbl = math_unary_TANH;
"The tanh() function returns the hyperbolic tangent of x,
which is defined mathematically as sinh(x) / cosh(x)."

   .COMMAND exp(dbl)   	  : dbl = math_unary_EXP;
"The exp(x) function returns the value of e
(the base of natural logarithms) raised to the power of x."
   .COMMAND log(dbl)   	  : dbl = math_unary_LOG;
"The log(x) function returns the natural logarithm of x."
   .COMMAND log10(dbl)    : dbl = math_unary_LOG10;
"The log10(x) function returns the base-10 logarithm of x."

   .COMMAND pow(dbl,dbl)  : dbl = math_binary_POW;
"The pow(x,y) function  returns the value of x raised to the power of y."
   .COMMAND sqrt(dbl)  	  : dbl = math_unary_SQRT;
"The sqrt(x) function returns the non-negative square root of x."

   .COMMAND ceil(dbl)     : dbl = math_unary_CEIL;
"The ceil(x) function rounds x upwards to the nearest integer."
   .COMMAND fabs(dbl)     : dbl = math_unary_FABS;
"The fabs(x) function  returns  the  absolute value of the 
floating-point number x."
   .COMMAND floor(dbl)    : dbl = math_unary_FLOOR;
"The floor(x) function rounds x downwards to the nearest integer."
   .COMMAND fmod(dbl,dbl) : dbl = math_binary_FMOD;
"The fmod(x,y) function computes the remainder of dividing x by y.
The return value is x - n * y, where n is the quotient of x / y,
rounded towards zero to an integer."
   .COMMAND round(dbl,int)     : dbl = math_binary_ROUND;
"The round(n, m) returns n rounded to m places to the right of the
decimal point; if m is omitted, to 0 places. m can be negative to
round off digits left of the decimal point. m must be an integer."


   .COMMAND isnan(dbl) : bit = math_unary_ISNAN;
"The isnan(x) function returns true if x is 'not-a-number' (NaN), and false otherwise."
   .COMMAND isinf(dbl) : int = math_unary_ISINF;
"The isinf(x) function returns -1 if x represents negative infinity, 1 if x represents positive infinity, and 0 otherwise."
   .COMMAND finite(dbl) : bit = math_unary_FINITE;
"The finite(x) function returns true if x is neither infinite nor a 'not-a-number' (NaN) value, and false otherwise."


@
The constants defined in math.h are defined using the following mil code.
@m
.LOAD
	const M_E 	:= 2.7182818284590452354LL;
	const M_LOG2E 	:= 1.4426950408889634074LL;
	const M_LOG10E 	:= 0.43429448190325182765LL;
	const M_LN2 	:= 0.69314718055994530942LL;
	const M_LN10 	:= 2.30258509299404568402LL;
	const M_PI	:= 3.14159265358979323846LL;
	const M_PI_2	:= 1.57079632679489661923LL;
	const M_PI_4	:= 0.78539816339744830962LL;
	const M_1_PI	:= 0.31830988618379067154LL;
	const M_2_PI	:= 0.63661977236758134308LL;
	const M_2_SQRTPI:= 1.12837916709551257390LL;
	const M_SQRT2	:= 1.41421356237309504880LL;
	const M_SQRT1_2	:= 0.70710678118654752440LL;
.END;
.END mmath;

@* Example Script
@mil
module(mmath);
setoid(oid(20000000));
asin(sin(M_PI)).print;
acos(cos(M_PI)).print;
atan(tan(M_PI_2)).print;
atan(tan(M_PI_4)).print;
tan(atan2(dbl(0.1),dbl(1.0))).print;
sqrt(pow(dbl(2),dbl(2))).print;

exp(dbl(10)).print;
log(dbl(10)).print;
log10(dbl(10)).print;

ceil(dbl(1.2)).print;
fabs(dbl(1.2)).print;
floor(dbl(1.2)).print;
fmod(dbl(15.2),dbl(2.5)).print;

log(-1.0LL).print;
(log(-1.0LL)=log(-1.0LL)).print;
isnan(log(-1.0LL)).print;

# NOTE: If there would be a system with large enough doubles than
#       the expression could actually produce a correct output...
#       (unlikely with IEEE(like) floating point types though)
pow(2.0LL,5000.0LL).print;
isinf(pow(2.0LL,5000.0LL)).print;
pow(-2.0LL,5001.0LL).print;
isinf(pow(-2.0LL,5001.0LL)).print;

finite(1.0LL).print;
finite(log(-1.0LL)).print;
finite(pow(2.0LL,5000.0LL)).print;
finite(pow(-2.0LL,5001.0LL)).print;

quit;
@{
@h
#ifndef __MMATH_H__
#define __MMATH_H__

#include <gdk.h>
#include "mmath.proto.h"

#endif /* __MMATH_H__ */
@}

@{
@* Implementation Code
@c

#include "mmath.h"
#include <math.h>

extern double sqrt(double x);
extern double cbrt(double x);
extern double sin(double x);
extern double cos(double x);
extern double fabs(double x);

#define acos_unary(x, z)      *z = acos(*x)
#define asin_unary(x, z)      *z = asin(*x)
#define atan_unary(x, z)      *z = atan(*x)
#define atan2_binary(x, y, z) *z = atan2(*x,*y)
#define cos_unary(x, z)       *z = cos(*x)
#define sin_unary(x, z)       *z = sin(*x)
#define tan_unary(x, z)       *z = tan(*x)

#define cosh_unary(x, z)       *z = cosh(*x)
#define sinh_unary(x, z)       *z = sinh(*x)
#define tanh_unary(x, z)       *z = tanh(*x)

#define exp_unary(x, z)       *z = exp(*x)
#define log_unary(x, z)       *z = log(*x)
#define log10_unary(x, z)     *z = log10(*x)

#define pow_binary(x, y, z)   *z = pow(*x,*y)
#define sqrt_unary(x, z)      *z = sqrt(*x)

#define ceil_unary(x, z)      *z = ceil(*x)
#define fabs_unary(x, z)      *z = fabs(*x)
#define floor_unary(x, z)     *z = floor(*x)
#define fmod_binary(x, y, z)  *z = fmod(*x,*y)

@:unop(_ACOS,acos)@
@:unop(_ASIN,asin)@
@:unop(_ATAN,atan)@
@:binop(_ATAN2,atan2)@
@:unop(_COS,cos)@
@:unop(_SIN,sin)@
@:unop(_TAN,tan)@

@:unop(_COSH,cosh)@
@:unop(_SINH,sinh)@
@:unop(_TANH,tanh)@

@:unop(_EXP,exp)@
@:unop(_LOG,log)@
@:unop(_LOG10,log10)@

@:binop(_POW,pow)@
@:unop(_SQRT,sqrt)@

@:unop(_CEIL,ceil)@
@:unop(_FABS,fabs)@
@:unop(_FLOOR,floor)@
@:binop(_FMOD,fmod)@

@= unop
int math_unary@1(dbl *res , dbl *a ) {
#ifdef DEBUG
	printf( "math_unary@1\n");
#endif
   if (*a == dbl_nil) {
	*res = dbl_nil;
   } else {
	@2_unary( a, res );
   }
   return(GDK_SUCCEED);
}
@

@= binop
int math_binary@1(dbl *res, dbl *a, dbl *b ) {
#ifdef DEBUG
	printf( "math_binary@1\n");
#endif
   if (*a == dbl_nil || *b == dbl_nil) {
	*res = dbl_nil;
   } else {
	@2_binary( a, b, res);
   }
   return(GDK_SUCCEED);
}
@

@c
int math_binary_ROUND(dbl *res, dbl *x, int *y) {
  if(*x == dbl_nil || *y == int_nil) {
    *res = dbl_nil;
  } else {
    double factor = pow(10,*y), integral;
    double tmp = *y>0?modf(*x,&integral):*x;

    tmp *= factor;
    if(tmp>=0)
      tmp = floor(tmp+0.5);
    else
      tmp = ceil(tmp-0.5);
    tmp /= factor;

    if(*y>0)
      tmp += integral;

    *res = tmp;
  }

  return(GDK_SUCCEED);
}

#ifdef HAVE_ISINF
#ifdef HAVE_FPCLASS
#undef HAVE_FPCLASS
#endif
#endif

/* Hardcoded replacement for what configure should set: */
#ifdef NATIVE_WIN32
#include <float.h>
/* Windows spells these differently */
#define isnan(x)	_isnan(x)
#define finite(x)	_finite(x)
/* NOTE: HAVE_FPCLASS assumed... */
#define fpclass(x)	_fpclass(x)
#define FP_NINF         _FPCLASS_NINF
#define FP_PINF         _FPCLASS_PINF
#else
#ifdef HAVE_FPCLASS
#include <ieeefp.h>
#endif
#endif

#ifdef HAVE_FPCLASS
static int isinf(double x) {
    int cl = fpclass(x);
    return ((cl == FP_NINF) || (cl == FP_PINF));
}
#endif

int math_unary_ISNAN(bit *res , dbl *a ) {
#ifdef DEBUG
    printf( "math_unary_ISNAN\n");
#endif
    if (*a == dbl_nil) {
	*res = bit_nil;
    } else {
	*res = isnan(*a);
    }
    return(GDK_SUCCEED);
}

int math_unary_ISINF(int *res , dbl *a ) {
#ifdef DEBUG
	printf( "math_unary_ISINF\n");
#endif
   if (*a == dbl_nil) {
	*res = int_nil;
   } else {
	if(isinf(*a)) {
        	*res = (*a < 0.0) ? -1 : 1;
        } else {
        	*res = 0;
        }
   }
   return(GDK_SUCCEED);
}

int math_unary_FINITE(bit *res , dbl *a ) {
#ifdef DEBUG
	printf( "math_unary_FINITE\n");
#endif
   if (*a == dbl_nil) {
	*res = bit_nil;
   } else {
	*res = finite(*a);
   }
   return(GDK_SUCCEED);
}
@}
