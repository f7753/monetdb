@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at 
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@' 
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@' 
@' The Original Code is the Monet Database System.
@' 
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2002 CWI.  
@' All Rights Reserved.
@' 
@' Contributor(s):
@' 		Martin Kersten <Martin.Kersten@cwi.nl>
@' 		Peter Boncz <Peter.Boncz@cwi.nl>
@' 		Niels Nes <Niels.Nes@cwi.nl>
@' 		Stefan Manegold  <Stefan.Manegold@cwi.nl>

@f str
@a N.J. Nes
@v 1.1
@t The "string" module

@* Introduction
@T
Strings can be created in many ways. Already in the build-in operations
each atom can be cast to a string using the str(atom) mil command.
The string module gives the possiblity of construction string as a
substring of the a given string (s). There are two such construction functions.
The first is the substring from some position (offset) until the end of
the string. The second start again on the given offset position but only
copies count number of bytes. The functions fail when the position and
count fall out of bounds. A negative position indicates that the position is
computed from the end of the source string.

The strings can be compared using the "=" and "!=" operators.

The operator "+" concatenates a string and an atom. The atom will be
converted to a string using the atom to string c function. The
string and the result of the conversion are concatenated to form a new
string. This string is returned.

The length function returns the length of the string. The length is
the number of characters in the string.

chrAt() returns the character at position index in the string s. The
function will fail when the index is out of range. The range is
from 0 to length(s)-1.

The startWith and endsWith functions test if the string s starts with or
ends with the given prefix or suffix.

The toLower and toUpper functions cast the string to lower or upper case
characters.

The search(str,chr) function searches for the first occurrence of a 
charachter from the begining of the string. The search(chr,str) searches
for the last occurence (or first from the end of the string). The last
search function locates the possition of first occurence of the string s2 
in string s. All search functions return -1 when the search failed.
Otherwise the position is returned.

All string functions fail when an incorrect string (.NULL pointer) is given.
In the current implementation, a fail is signaled by returning nil, since
this facilitates the use of the string module in bulk operations.

@* Module Definition
@m
.MODULE str;

.COMMAND string( str s, int offset ) : str = strTail; 
	"Return the tail s[offset..n] of a string s[0..n]."
.COMMAND string( str s, int offset, int count ) : str = strSubString; 
	"Return substring s[offset..offset+count] of a string s[0..n]"
.OPERATOR (str) "+" (any) : str = strConcat; 
	"Concatenate two strings."
.COMMAND length( str s ) : int = strLength; 
	"Return the length of a string."
.COMMAND chrAt( str s, int index ) : chr = strChrAt; 
	"String array lookup operation."

.COMMAND startsWith( str s, str prefix ) : bit = strPrefix;
        "Prefix check."
.COMMAND endsWith( str s, str suffix ) : bit = strSuffix; 
        "Suffix check."

.COMMAND toLower( str s ) : str = strLower; 
        "Convert a string to lower case."
.COMMAND toUpper( str s ) : str = strUpper; 
        "Convert a string to upper case."

.COMMAND search( str s, chr c ) : int = strChrSearch; 
	"Search for a character. Returns position, -1 if not found."
.COMMAND r_search( str s, chr c ) : int = strReverseChrSearch; 
	"Reverse search for a char. Returns position, -1 if not found."
.COMMAND search( str s, str s2 ) : int = strStrSearch; 
	"Search for a substring. Returns position, -1 if not found."
.COMMAND r_search( str s, str s2 ) : int = strReverseStrSearch; 
	"Reverse search for a substring. Returns position, -1 if not found."
.COMMAND trim( str s ) : str = strStrip; 
	"Strip whitespaces around a string."
.COMMAND ltrim( str s ) : str = strLtrim; 
	"Strip whitespaces from start of a string."
.COMMAND rtrim( str s ) : str = strRtrim; 
	"Strip whitespaces from end of a string."
.COMMAND substitute( str s, str src, str dst, bit repeated) : str = strSubstitute; 
	"Substitute first occurrence of substring 'src' by 'dst'.
         Iff repeated = true this is repeated while 'src' can be found in the result string.
 	 In order to prevent recursion and result strings of unlimited size, repeating
         is only done iff src is not a substring of dst."

.END str;


@* Example script
The following script is used for testing the string module. 

@mil
setoid(oid(20000000));

i1 := "This is a test";
i2 := "of the str atomic type";

(("concat an int "+1)+" with a string "+i1+(" with an dbl "+dbl(1.0))).print; 
(("concat an int "+1) + " with a string").print; 

length( i1 ).print;
sres := (i1 + " ") + i2;
sres.print;
len := length(sres);
string( sres, 10).print;
string( sres, -10).print;
string( sres, 10, len - 10 ).print;
string( sres, 10, 10 ).print;
string( sres, -10, 10 ).print;
string( sres, -10, 20 ).print;
string( sres, 10, len).print;
string( sres, len, 10).print;
string( sres, -(len), 10).print; 
string( sres, -(len + 5), 10).print; 
chrAt( sres, 5 ).print;
chrAt( sres, -3).print;
chrAt( sres, len + 20).print;
chrAt( sres, len).print;
chrAt( sres, len - 1).print;
chrAt( sres, 0).print;
startsWith( i2, "of the" ).print;
startsWith( i2, i2 ).print;
startsWith( i2, "k" ).print;
endsWith( i2, "type" ).print;
endsWith( i2, i2 ).print;
endsWith( i2, "k" ).print;
toLower( i1 ).print;
toUpper( i1 ).print;
search( "Hello this is a test for search", 'a' ).print;
r_search( "Hello this is a test for search", 'a' ).print;
search( "Hello this is a test for search", "ar" ).print;
r_search( "Hello this is a test for search", "ar" ).print;
search( "Hello this is a test for search", "is" ).print;
r_search( "Hello this is a test for search", "is" ).print;
search( "Hello this is a test for search", "Hello" ).print;
r_search( "Hello this is a test for search", "Hello" ).print;
search( "Hello this is a test for search", "arch" ).print;
r_search( "Hello this is a test for search", "arch" ).print;
search( "Hello this is a test for search", "xxx" ).print;
r_search( "Hello this is a test for search", "yyy" ).print;


trim("   f ").print;
trim("abc").print;
trim("   x").print;
trim("x   ").print;
trim("").print;
trim(str(nil)).print;

substitute("A.B.C",".","\\.",false).print;
substitute("A.B.C",".","\\.",true).print;

quit;

@{
@* Implementation Code
@h
#ifndef __string_H__
#define __string_H__

#include "str.proto.h"

#endif /* __string_H__ */
@}

@{
@c
#include <gdk.h>
#include "ctype.h"
#include "str.h"
#include <string.h>

#define RETURN_NIL_IF(b,t) \
	if (b) {\
	   if (ATOMextern(t)) {\
	      *(ptr*) res = (ptr) ATOMnil(t);\
	   } else {\
	      memcpy(res, ATOMnilptr(t), ATOMsize(t));\
 	   }\
	   return GDK_SUCCEED; \
	}

#ifdef MAX
#undef MAX
#endif
#define MAX(x, y) ((x) > (y) ? (x) : (y))

#ifdef MIN
#undef MIN
#endif
#define MIN(x, y) ((x) < (y) ? (x) : (y))

int strConcat(str *res, str s, ptr val, int t ){
	str valstr = NULL;
	int l1, l2 = 0;

	RETURN_NIL_IF(strNil(s)||ATOMcmp(t,val,ATOMnilptr(t))==0,TYPE_str);
	if (t <= 0) return GDK_FAIL;
	l1 = strlen(s);
	if (t != TYPE_str){
		BATatoms[t].atomToStr(&valstr,&l2,val);
		val = (ptr)valstr;
	} else {
		l2 = strlen((str) val);
	}
	*res = (str) GDKmalloc(l1+l2+1);
	memcpy(*res, s, l1);
	memcpy(*res + l1, (str)val, l2);
	(*res)[l1+l2] = '\0';
	if (valstr) GDKfree(valstr);
	return GDK_SUCCEED;
}

int strLength( int *res, str s ){
	RETURN_NIL_IF(strNil(s),TYPE_int);

	*res = strlen(s);
	return GDK_SUCCEED;
}

int strTail( str *res, str s, int *offset){
	int l;
	RETURN_NIL_IF(strNil(s)||*offset==int_nil,TYPE_str);
   	l = strlen(s);
	if (*offset >= 0) {
		if (l < (*offset)) {
			*res = GDKstrdup("");
			return GDK_SUCCEED;
		}
		l = l - *offset;
		*res = (char*)GDKmalloc( l+1 );
		strncpy( *res, s+(*offset), l );
		(*res)[l] = 0;
	} else {
		int len = MIN(-(*offset), l);
		*res = GDKmalloc(len + 1);
		l -= len;
		strncpy(*res, s + l, len);
		(*res)[len] = 0;
	} 
	return GDK_SUCCEED;
}

int strSubString( str *res, str s, int *offset, int *length ){
	int l, len;
	RETURN_NIL_IF(strNil(s)||*offset==int_nil||*length==int_nil,TYPE_str);
	if (*length < 0) {
		*res = GDKstrdup("");
		return GDK_SUCCEED;
	}
   	l = strlen(s);
	if (*offset >= 0) {
		if (l < *offset) {
			*res = GDKstrdup("");
			return GDK_SUCCEED;
		}
		len = MIN(*length, l - *offset);
 		*res = (char*)GDKmalloc( len+1 );
		strncpy( *res, s+(*offset), len );
		(*res)[len] = 0;
	} else {
		int o = l + *offset;
		len = MIN(l - o, *length);
		if (o < 0) {
			len -= -o;
			o = 0;	
		}
		*res = (char *)GDKmalloc(len + 1);
		strncpy(*res, s + o, len);
		(*res)[len] = 0;
	}
	return GDK_SUCCEED;
}

int strChrAt( chr *res, str s, int *at ){
	int l;
	RETURN_NIL_IF(strNil(s)||*at==int_nil,TYPE_chr);
   	l = strlen(s);
	RETURN_NIL_IF(l<=(*at)||(*at)<0, TYPE_chr);
	*res = s[*at];
	return GDK_SUCCEED;
}

int strPrefix( bit *res, str s, str prefix ){
	int pl, i;

	RETURN_NIL_IF(strNil(s)||strNil(prefix),TYPE_bit);
   	pl = strlen(prefix);
	if ((int)strlen(s)<pl){
		*res = 0;
		return GDK_SUCCEED;
	}
	*res = 1;
	for (i=0; i<pl; i++){
	   	if(s[i] != prefix[i]){
			*res = 0;
			return GDK_SUCCEED;
		}
	}
	return GDK_SUCCEED;
}

int strSuffix( bit *res, str s, str suffix ){
	int i, sl, sul;
	RETURN_NIL_IF(strNil(s)||strNil(suffix),TYPE_bit);
   	sl = strlen(s);
   	sul = strlen(suffix);

	if (sl<sul){
		*res = 0;
		return GDK_SUCCEED;
	}
	*res = 1;
	for (i=0; i<sul; i++){
	   	if(s[sl-1-i] != suffix[sul-1-i]){
			*res = 0;
			return GDK_SUCCEED;
		}
	}
	return GDK_SUCCEED;
}

int strLower( str *res, str s ){
	int l, i;
	RETURN_NIL_IF(strNil(s),TYPE_str);
   	l = strlen(s);
	*res = (char*)GDKmalloc(l+1);
	for(i = 0; i<l; i++)
		(*res)[i] = (char)tolower((char)s[i]);
	(*res)[l] = 0;
	return GDK_SUCCEED;
}

int strUpper( str *res, str s ){
	int l, i;
	RETURN_NIL_IF(strNil(s),TYPE_str);
   	l = strlen(s);
	*res = (char*)GDKmalloc(l+1);
	for(i = 0; i<l; i++)
		(*res)[i] = (char)toupper((char)s[i]);
	(*res)[l] = 0;
	return GDK_SUCCEED;
}

int strChrSearch( int *res, str s, chr *c ){
	char *p;
	RETURN_NIL_IF(strNil(s)||*c==chr_nil,TYPE_int);
	if ((p = strchr( s, (int)*c )) != 0)
		*res = p-s;
	else 
		*res = -1;
	return GDK_SUCCEED;
}

int strReverseChrSearch( int *res, str s, chr *c ){
	char *p;
	RETURN_NIL_IF(strNil(s)||*c==chr_nil,TYPE_int);
	if ((p = strrchr( s, (int)*c )) != 0)
		*res = p-s;
	else 
		*res = -1;
	return GDK_SUCCEED;
}

int strStrSearch( int *res, str s, str s2 ){
	char *p;
	RETURN_NIL_IF(strNil(s)||strNil(s2),TYPE_int);
	if ((p = strstr( s, s2 )) != 0)
		*res = p-s;
	else 
		*res = -1;
	return GDK_SUCCEED;
}

int strReverseStrSearch( int *res, str s, str s2 ){
	int len, slen;
	char *p, *q;
	int i;

	RETURN_NIL_IF(strNil(s)||strNil(s2),TYPE_int);
	
	*res = -1;
	len = strlen(s);
	slen = strlen(s2);
	for(p = s + len - slen; p >= s; p--) {
	    for(i = 0, q = p; i < slen && *q == s2[i]; i++, q++)
		;
	    if (i == slen) {
		*res = p - s;
		break;
	    }
	}
	
	return GDK_SUCCEED;
}

int strStrip(str *res, str s) {
	str start = s;
	int len;

	while (GDKisspace(*start))
		start++;

	/* Remove the trailing spaces.  Make sure not to pass the start */
	/* pointer in case a string only contains spaces.               */
	s = start + strlen(start);
	while (s > start && GDKisspace(*(s - 1)))
		s--;

	len = s - start + 1;
	*res = GDKmalloc(len);
	memcpy(*res, start, len - 1);
	(*res)[len - 1] = '\0';
	return GDK_SUCCEED;
}

int strLtrim(str *res, str s) {
	RETURN_NIL_IF(strNil(s), TYPE_str);
	while (GDKisspace(*s))
	   	s++;
	*res = GDKstrdup(s);
	return GDK_SUCCEED;
}

int strRtrim(str *res, str s) {
	int len = strlen(s);

	RETURN_NIL_IF(strNil(s), TYPE_str);
        while(len > 0 && GDKisspace(s[len-1])) len--;
	*res = GDKmalloc(len+1);
  	memcpy(*res, s, len);
  	(*res)[len] = '\0';
	return GDK_SUCCEED;
}

int strSubstitute(str *res, str s, str src, str dst, bit *g) {
	int repeat = *g, lsrc = strlen(src), ldst = strlen(dst);
	int l = strLen(s), n = l + ldst;
	str buf, fnd, end; 

	if (repeat && ldst > lsrc) {
		n = (ldst*l)/lsrc; /* max length */
	}
	buf = *res = (str) GDKmalloc(n);
	end = buf + l; 
	fnd = buf;
	strcpy(buf, s);
	do {
		fnd = strstr((fnd < buf)?buf:fnd, src);
		if (!fnd) break; 
		memmove(fnd+ldst, fnd+lsrc, end-fnd);
		memcpy(fnd, dst, ldst);
		end += ldst - lsrc;
		fnd += ldst; 
	} while(repeat);

	return GDK_SUCCEED;
}

int strSubstitute2(str *res, str s, str src, str dst, bit *g) {
	int repeat = *g, lsrc = strlen(src), ldst = strlen(dst);
	int l = strLen(s), n = l + ldst;
	str buf, fnd, end; 

	if (repeat && strstr(dst,src)) {
		repeat = FALSE; /* result would become unbounded */ 
	}
	if (repeat && ldst > lsrc) {
		n = (ldst*l)/lsrc; /* max length */
	}
	buf = *res = (str) GDKmalloc(n);
	end = buf + l; 
	fnd = buf;
	strcpy(buf, s);
	do {
		fnd = strstr((fnd < buf)?buf:fnd, src);
		if (!fnd) break; 
		memmove(fnd+ldst, fnd+lsrc, end-fnd);
		memcpy(fnd, dst, ldst);
		end += ldst - lsrc;
		fnd -= lsrc-1; /* we can actually do better */
	} while(repeat);

	return GDK_SUCCEED;
}
@
@}
