@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at 
@' http://monetdb.cwi.nl/Legal/MonetDBPL-1.0.html
@' 
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@' 
@' The Original Code is the Monet Database System.
@' 
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2002 CWI.  
@' All Rights Reserved.
@' 
@' Contributor(s):
@' 		Martin Kersten <Martin.Kersten@cwi.nl>
@' 		Peter Boncz <Peter.Boncz@cwi.nl>
@' 		Niels Nes <Niels.Nes@cwi.nl>
@' 		Stefan Manegold  <Stefan.Manegold@cwi.nl>

@f perfex
@a P. Boncz
@t Performance Counters
@T
This is a memory/cpu performance measurement tool for R10000 processors.

@+ Module Definition
@m
.MODULE perfex;

.ATOM fill32[28,4]; .END;
.ATOM fill64[60,4]; .END;
.ATOM fill128[124,4]; .END;
.ATOM fill256[252,4]; .END;
.ATOM fill512[508,4]; .END;
.ATOM fill384[380,4]; .END;
.ATOM fill640[636,4]; .END;
.ATOM fill1024[1020,4]; .END;

.ATOM counter[144,4]; 
.COMP = compare_counter; 
.END;

.COMMAND create_counter(int tid, ...str...) : counter = create_counter;
 "start a multiplexed counter for a thread on all specified events"

.COMMAND get_counter(counter c) : counter = get_counter;
 "stop the counting and retrieve all results"

.COMMAND read_counter(counter) : BAT[str,int] = read_counter;
 "stop the counting and retrieve all results"

.END perfex;
@+ Implementation 
@h
#include "gdk.h"

typedef struct {
	int fd; 	/* file descriptor for thread proc entry */
	int generation; /* prefex-id */
	int mask;	/* event mask for events to monitor */
	int ms;		/* milliseconds of elapsed time */
	int cnts[32];	/* event counters */
} counter;
@c
#include "perfex.h"
#include "perfex.proto.h"
#if (defined(IRIX) && SIZEOF_LONG==8 && !defined (__GNUC__))
#include <sys/procfs.h>
#include <sys/hwperftypes.h>
#include <sys/hwperfmacros.h>
#endif

int event_order[30] = { 
 0, 1, 15, 2, 18, 3, 19, 4, 5, 20, 21, 6, 24, 22, 9, 25, 7, 
 10, 11, 26, 27, 30, 31, 8, 23, 12, 28, 13, 29, 14 };

short_str event_name[32] = { 
 "cycles", "instructions", "loads", "stores", "cond_stores", "cond_stores_fail",
 "branches_resolved", "L2_writebacks", "L2_ECCerrors", "L1_ins_misses", 
 "L2_ins_misses", "L2_ins_mispredicts", "interventions_reqs", 
 "invalidations_reqs", "func_completion_cycles", "instructions_grad", "cycles", 
 "instructions_grad", "loads_grad", "stores_grad", "cond_stores_grad", 
 "fp_ops_grad", "L1_writebacks", "TLB_misses", "branches_mispredict",  
 "L1_data_misses", "L2_data_misses", "L2_data_mispredicts", "intervention_hits",
 "invalidation_hits", "L2_clean_excl", "L2_shared_excl" };

int event_num(str s) {
	int m = -1;
	if (isdigit(*s)) { 
		m = atoi(s);
	} else {
		for(m=0; m <32; m++) {
			if (strcmp(event_name[m], s) == 0) break;
		}
	}
	if (m < 0 || m > 31) {
		GDKerror("event_num(%s): illegal event.\n", s);
		return -1;
	}
	if (m == 16) m = 0;
	if (m == 17) m = 15;
PROPDEBUG
printf("create_num: see event %d (%s)\n", m, event_name[m]);
	return m;
}

int compare_counter(counter *c1, counter* c2) {
	return c1->ms - c2->ms; /* compare on time in msecs */
}

int create_counter(counter *retval, int *tid, ...) {
#if (defined(IRIX) && SIZEOF_LONG==8 && !defined (__GNUC__))
    hwperf_profevctrarg_t evctr_args;
    int generation, mask = -1, m, i, fd, pid = *tid;
    char pfile[PATHLENGTH], *s;
    va_list ap;

    sprintf(pfile, "/proc/%d", pid);
    fd	= open(pfile, O_RDWR);
    if (fd < 0) {
	GDKsyserror("create_counter: cannot find thread %d (%s)\n", pid, pfile);
	return GDK_FAIL;
    }
       
    va_start(ap,tid);
    if ((s =  va_arg(ap, ptr)) != NULL) {
	i = mask = 0;
	do {
	    m = event_num(s); 
	    if (m >= 0) { 
			mask |= 1 << m; 
			if (m < 16) i++;
	    }	
    	} while((s =  va_arg(ap, ptr)) != NULL);

	/* if possible, remap two request so they fall under indepedent 
         * counters => this provides full accuracy */
	if (i == 2) {
		if (mask&1) mask = (1<<16) | (mask & ~1);
		else if (mask& (1<<15)) mask = (1<<17) | (mask & ~(1<<15));
	} 
    }
    va_end(ap);

    /* fill the ioctl parameters */    
    memset(&evctr_args, 0, sizeof(evctr_args));
    for (m = 1, i = 0; i < 31; i++, m <<=1) if (mask&m) {
PROPDEBUG
printf("create_counter: monitor event %d (%s)\n", i, event_name[i]);
	evctr_args.hwp_evctrargs.hwp_evctrl[i].hwperf_creg.hwp_mode = 
							HWPERF_CNTEN_U;
	evctr_args.hwp_evctrargs.hwp_evctrl[i].hwperf_creg.hwp_ie = 1;
	evctr_args.hwp_evctrargs.hwp_evctrl[i].hwperf_creg.hwp_ev = i;
	evctr_args.hwp_ovflw_freq[i] = 0;
    }
PROPDEBUG
printf("create_counter: mask = %d %x\n\n", mask, mask);

    evctr_args.hwp_ovflw_sig =	0;
    generation = ioctl(fd, PIOCENEVCTRS, (void *)&evctr_args);
    if	(generation < 0) {
	 GDKsyserror("create_counter: failed to acquire counters (fd=%d)", fd);
	 close(fd);
	 return GDK_FAIL;
    }

    /* create the resulting counter object */
    memset(retval, 0, sizeof(counter));
    retval->fd = fd;
    retval->generation = generation;
    retval->mask = mask;
    retval->ms = GDKms();
    return GDK_SUCCEED;
#else
    GDKerror("create_counter: only works on R10000 processors\n");
    return GDK_FAIL;
#endif
}


int get_counter(counter *retval, counter *c) {
#if (defined(IRIX) && SIZEOF_LONG==8 && !defined (__GNUC__))
     int generation, mask = c->mask;
     int i, fd = c->fd, ms = GDKms() - c->ms;
     hwperf_cntr_t cnts;
     BAT *bn;

     if	((generation =	ioctl(fd, PIOCGETEVCTRS, (void *)&cnts)) < 0) {
	 GDKsyserror("PIOCGETEVCTRS returns error");
	 return GDK_FAIL;
     }

     /*	generation number should be the	same */
     if	(c->generation != generation) {
	 GDKerror("program lost event counters\n");
	 return GDK_FAIL;
     }

     /*	release	the counters */
     if	((ioctl(fd, PIOCRELEVCTRS)) < 0) {
	 GDKsyserror("prioctl PIOCRELEVCTRS returns error");
	 return GDK_FAIL;
     }
     close(fd);

     /* get the values */
     retval->fd = -42;
     retval->ms = ms;
     retval->mask = c->mask;
     retval->generation = c->generation;
     for(i=0; i<32; i++) { 
	retval->cnts[i] = cnts.hwp_evctr[i];
     }
     retval->cnts[0] += retval->cnts[16];
     retval->cnts[15] += retval->cnts[17];
     if ((mask&1) && (mask&(1<<16))) {
	retval->cnts[0] /= 2;
     }
     if ((mask&(1<<15)) && (mask&(1<<17))) {
	retval->cnts[15] /= 2;
     }
     return GDK_SUCCEED;
#else
     GDKerror("get_counter: only works on R10000 processors\n");
     return GDK_FAIL;
#endif
}

int read_counter(BAT **ret, counter *c) {
     int i, j;
     if (c->fd != -42) {
	GDKerror("read_counter: uninitialised counter\n");
	return GDK_FAIL;
     }
     *ret = BATnew(TYPE_str, TYPE_int, 32);
     for(i=0; i<30; i++) {
	j = event_order[i];
     	BUNins(*ret, event_name[j], &c->cnts[j]);
     }
     BUNins(*ret, "generation", &c->generation);
     BUNins(*ret, "event_mask", &c->mask);
     BUNins(*ret, "millisecs", &c->ms);
     (*ret)->halign = 3928437;
     BATkey(*ret, TRUE);
     return GDK_SUCCEED;
}

@+ Test Script	
works on the ddbench database. Create tables
of varying width with one column. The cX bats 
have a 1-byte column that is used for experiments, 
whereas the iX bats have one 4-byte (int) column 
that is used.

@f create
@mil
module(ddbench,unix,alarm,perfex);

var pid := view_gdk_thread.reverse.find("Interpreter");
var age_t := enum_load(age);
var v := str(nil);

var c0 := age_enum.reverse.copy.rename("c0").persists(true);
[c0~chr(v)].rename("c1").persists(true).unload;
[c0~sht(v)].rename("c2").persists(true).unload;
[c0~int(v)].rename("c3").persists(true).unload;
[c0~lng(v)].rename("c4").persists(true).unload;
[c0~fill32(v)].rename("c5").persists(true).unload;
[c0~fill64(v)].rename("c6").persists(true).unload;
[c0~fill128(v)].rename("c7").persists(true).unload;
[c0~fill256(v)].rename("c8").persists(true).unload;
[c0~fill512(v)].rename("c9").persists(true).unload;
[c0~fill384(v)].rename("c9a").persists(true).unload;
[c0~fill640(v)].rename("c9b").persists(true).unload;
[c0~fill1024(v)].rename("ca").persists(true).unload;

var i2 := [int](age_enum).reverse.rename("i2").persists(true);
[i2~int(v)].rename("i3").persists(true).unload;
[i2~lng(v)].rename("i4").persists(true).unload;
[i2~fill32(v)].rename("i5").persists(true).unload;
[i2~fill64(v)].rename("i6").persists(true).unload;
[i2~fill128(v)].rename("i7").persists(true).unload;
[i2~fill256(v)].rename("i8").persists(true).unload;
[i2~fill512(v)].rename("i9").persists(true).unload;

@f perfex_select
Select on each of the BATs. Age 100 does not exist in the ddbench,
so the results are empty. This experiments therefore measure pure 
read performance.
@mil
module(ddbench,mmath,unix,alarm,perfex);

var pid := view_gdk_thread.reverse.find("Interpreter");
var pid := view_gdk_thread.reverse.find("Server");
var age_t := enum_load(age);
var res_evn := new(void,int).seqbase(0@0);
var res_cnt := new(void,counter).seqbase(0@0);
var res_exp := new(void,str).seqbase(0@0);

proc stddev(bat[any,flt] b, flt mean) : flt {
        var y := 0.0;
        b@batloop() {
                var x := $t - mean;     
                y :+= x * x;
        }
        return flt(sqrt(dbl(y / flt(b.count))));
}
 
proc plus(bat[any,counter] b) : bat[str,int] {
        var res := nil;
        var n := new(void,flt);
        b@batloop() {
                var c := read_counter($t);
                n.insert(nil,flt(c.find("millisecs")));
                if (res.type != bat) {
                        res := c.access(BAT_WRITE);
                } else {
                        [:+=](res,c);
                }
        }
        var mean := flt(res.find("millisecs")) / flt(b.count);
        res.replace("millisecs", int(mean));
        res.insert("millisecs_dev", int(stddev(n, mean)));
        return res;
}
 
proc oidselect(bat[any::1,any] b, any::1 v, str id, int ev) {
        var x := b.mark(0@0).reverse;
        var c := create_counter(pid, str(ev), str(ev+17));
        uselect(x, v);
        res_cnt.insert(nil,get_counter(c));
        res_exp.insert(nil,id);
        res_evn.insert(nil,ev);
}
 
proc experiment(bat[str,bat] b, int n, any v) {
        var ev := 0;
        b@batloop() $t.count;
        while(ev < 15) {
            var run := 0;
            while(run < n) {
                b@batloop() {
                        oidselect($t, v, $h, ev);
                }
                run :+= 1;
            }
            ev :+= 1;
        }
        b@batloop() $t.unload;
}

proc summarize(stream fp, bat sel) {
  var tot := new(str, bat);
  sel.fetch(0)@batloop() {
        tot.insert($h,new(str,int));
  }
  sel@batloop() {
        var id := $h;
        $t@batloop() tot.find($h).insert(id,$t);
  }
  var res_max := [max](tot);
  sel@batloop() {
        fp.fprintf("%04d ", int($h.string(1,length($h) - 1)));
        $t@batloop() {
                var m := res_max.find($h);
                if (m = 0) m := 1;
                fp.fprintf("%04d ", int((lng($t) * lng(100))/lng(m)));
        }
        fp.fprintf("\n");
  }
}

var c_exp := new(str, bat);
var i_exp := new(str, bat);

c_exp.insert("c001", c0); 
c_exp.insert("c512", c9);
c_exp.insert("c002", c1);
c_exp.insert("c256", c8);
c_exp.insert("c004", c2);
c_exp.insert("c128", c7);
c_exp.insert("c008", c3);
c_exp.insert("c064", c6);
c_exp.insert("c016", c4);
c_exp.insert("c032", c5);

i_exp.insert("i008", i3);
i_exp.insert("i512", i9);
i_exp.insert("i016", i4);
i_exp.insert("i256", i8);
i_exp.insert("i032", i5);
i_exp.insert("i128", i7);
i_exp.insert("i064", i6);

#system("memclean");

experiment(c_exp, 3, age_t.encode(100));
experiment(i_exp, 10, 100);

res_exp.rename("opt_exp").persists(true);
res_evn.rename("opt_evn").persists(true);
res_cnt.rename("opt_cnt").persists(true);

# display results
var a := res_exp.CTgroup;
var b := a.CTgroup(res_evn);
a := a.reverse.join(b).sunique;;
d := b.reverse.join(res_cnt);
c := {min}(d);
b := {plus}(a.join(c));

#proc milli(c) return c.read_counter.find("millisecs");
#print(res_exp, res_evn, [milli](res_cnt));
#[read_counter](res_cnt)@batloop() $t.select(1,int(nil)).print;

res_exp.reverse.join(b).sort@batloop() {
	$t.select(1,int(nil)).col_name($h).print;
}

var sel := res_exp.reverse.join(b).sort;
var fp := fopen("/tmp/perfex_select_c.out", "w");
fp.summarize(sel.reverse.select("c","d").reverse);
fclose(fp);
 
fp := fopen("/tmp/perfex_select_i.out", "w");
fp.summarize(sel.reverse.select("i","j").reverse);
fclose(fp);
