@f ascii_io
@t The ascio io Module
@a Niels Nes
@d 12/01/2001
@m 
.module ascii_io;

.COMMAND load( str formatfile, str datafile, int nr ) = ascii_io_load; ""
.COMMAND dump( str formatfile, str datafile, int nr ) = ascii_io_dump; ""

.END ascii_io;
@h
#ifndef _ASCII_IO_H_
#define _ASCII_IO_H_

extern void ASCIIload( char *formatfile, char *datafile, int nr );
extern void ASCIIdump( char *formatfile, char *datafile, int nr );

extern void init_ascii_io(int debug);

#endif
@c

#include "ascii_io.h"
#include <config.h>
#include <gdk.h>

#include <stdio.h>
#include <string.h>
#include <ctype.h>
#ifdef HAVE_LIBZ
	#include <zlib.h>
#endif

#define MAXLINE 256
#define MAXATTR 256
#define EXT_LEN 4

typedef struct ascii_io_t {
	char *name;
	char *sep;
	int seplen;
	char *type;
	int  ptr;
	BAT *c;
	int reverse;
	int key;
} ascii_io;

typedef struct ascii_load_t {
	int nr;
	int nr_attrs;
	int key; 
	ascii_io format[MAXATTR];
	int merge;
} ascii_in;

typedef struct ascii_dump_t {
	int nr;
	int nr_attrs;
	int key; 
	ascii_io format[MAXATTR];
} ascii_out;


ptr bun_tail(BAT *b, int nr){
	REGISTER int _i = BUNindex((b),BUNfirst((b)));
	return BUNtail(b, BUNptr(b,_i+nr));
}


BAT *void_bat_create(int ctype,int ptr,int d1,int d2,int nr) {
	BAT *b = BATnew(TYPE_void,ptr,nr);
	BATseqbase(b,0);
	return b;
}

BAT *view_create(BAT *b1,BAT *b2,int cnt){
	/* todo check if b1 head != b1 tail (oid,seqbase)*/
	if (BATcount(b1)) return BATjoin(BATmirror(b1), b2); 
	return b2;
}
ptr *ADT_fromStr( int type, char *s){
        int l = 0;
        ptr *res = NULL;
        if (type == TYPE_str)
                res = (ptr*)GDKstrdup(s);
        else
                BATatoms[type].atomFromStr(s, &l, (ptr)&res);
        return res;
}
char *ADT_toStr( int type, ptr a){
	int l = 0;
	char *res = NULL;
        if (type == TYPE_str)
                res = (ptr*)GDKstrdup((char*)a);
        else
                BATatoms[type].atomToStr( &res, &l, a);
	return res;
}
void BAT_insert( BAT *b, ptr val ){
	BUNins(b,&int_nil,val);
}
void bat_persists( BAT *b ){
	BATmode(b, PERSISTENT);
}
void ADT_destroy(int type, ptr val){
	GDKfree(val);
}
void BATsetcount( BAT *b, int cnt){
}

#define bat_decref(b) 

static void get_extention( char *file, char *ext)
{
   	int j = 0;
	char *ext_start = strrchr( file, '.' );

	if (ext_start){
	    ext_start++;
            for (j = 0; j < EXT_LEN-1 && *ext_start; j++, ext_start++ )
                ext[j] = tolower(*ext_start);
        }
        ext[j] = '\0';
}


static int ascii_io_debug = 0;
  
char *next_field( char *s, char **end, char sep ){
	char *e = s;
	while (e && *e){
		if (*e == '"'){
			s = ++e;
			e = strchr( e, '"' );
			if (e){
				*e = 0;
				*end = strchr( ++e, sep );
				(*end)++;
			} else {
				fprintf( GDKerr, "Missing seperator '%c'\n", 
					sep );
			}
			return GDKstrdup( s );
		} else if (*e == sep || *e == '\n' ){
			*e = 0;
			*end = ++e;
			return GDKstrdup( s );
		}
		e++;
	}
	if (s)
		return GDKstrdup(s);
	return GDKstrdup("");
}

int parse_header_line( ascii_io *format, char *s ){
	format->name = next_field( s, &s, ',' );
	format->sep = next_field( s, &s, ',' );
	format->seplen = strlen( format->sep );
	format->type = next_field( s, &s, ',' );
	format->ptr = ATOMindex( format->type );
	format->reverse = 0;
	format->key = 0;
	if (*format->name == '-'){
		format->reverse = 1;
		format->name = format->name+1;
	}
	if (!strcmp(format->name, "key")){
		format->key = 1;
	}
	if (format->ptr < 0 ){
		fprintf(GDKerr, "Error: cannot find type %s\n", format->type );
		return -1;
	}
	if (ascii_io_debug)
	 fprintf(GDKerr,"%s %s %s\n", format->name, format->sep, format->type );
	return 0;
}

int parse_header( ascii_io *format, FILE *fd ){
	int i = 0;
	char line[MAXLINE];
	while( fgets(line, MAXLINE, fd) ){
		if (parse_header_line( &format[i++], line ) < 0)
			return -1;
	}
	return i;
}

int create_BATs( ascii_in *as ){
	ascii_io *fmt = as->format;
	int i, key = -1;
	int merge = -1;

	for (i=0; i<as->nr_attrs; i++){
	    if (fmt[i].key)
		key = i; 
	    if (merge != 0 ){ /* -1 or 1 */
	    	bat id = BBPindex(fmt[i].name);
	    	if (id > 0){ /* bat exist merge result */
			BAT *b = BATdescriptor(id);
			if (fmt[i].reverse ^ fmt[i].key)
				fmt[i].c = BATmirror(b);
			else
				fmt[i].c = (b);
			merge = 1;
	    	} else if (merge > 0){
			fprintf(GDKerr,"Missing bat %s\n", fmt[i].name );
			return -1;
		} else {
			merge = 0;
		}
	    }
  	    if (!merge){
		fmt[i].c = void_bat_create(0,fmt[i].ptr,0,0,as->nr);
	    }
	}
	if (key < 0){ /* added key column */
		key = i;
		fmt[key].ptr = TYPE_oid;
		if (merge){
	    		bat id = BBPindex(fmt[key-1].name);
	    		if (id > 0){ /* bat exist merge result */
				BAT *b = BATdescriptor(id);
				if (fmt[key-1].reverse)
					fmt[key].c = (b);
				else
					fmt[key].c = BATmirror(b);
				fmt[key].ptr = fmt[key].c->ttype;
	    		} else {
				fprintf(GDKerr,"Missing bat %s\n", 
					fmt[key-1].name );
				return -1;
			}
	    	} else {
			fmt[key].c = void_bat_create( TYPE_void, 
				TYPE_oid, 1, 0, as->nr );
			BATseqbase( fmt[key].c, 0);
			BATsetcount(fmt[key].c, 0);
		}
	}
	as->key = key;
	as->merge = merge;
	printf("merge %d\n", merge ); 
	return 0;
}

int find_BATs( ascii_out *as ){
	ascii_io *fmt = as->format;
	int res = as->nr;
	int i, key = -1;
	for (i=0; i<as->nr_attrs; i++){
	    if (fmt[i].key)
		key = i; 
	    else {
		BAT *b = BATdescriptor( BBPindex( fmt[i].name ));
		if (!b)
			return -1;
		if (fmt[i].reverse^fmt[i].key)
			fmt[i].c = BATmirror(b);
		else
			fmt[i].c = (b);
		if (res == -1 || BATcount(fmt[i].c)<res)
			res = BATcount(fmt[i].c);
	    }
	}
	as->key = key;
	if (key >= 0){ /* set key column */
	    	bat id = BBPindex(fmt[key+1].name);
	    	if (id > 0){ 
			BAT *b = BATdescriptor(id);
			if (fmt[key+1].reverse)
				fmt[key].c = (b);
			else
				fmt[key].c = BATmirror(b);
			fmt[key].ptr = fmt[key].c->ttype;
	    	} else {
			return -1;
		}
	}
	return res;
}

void persistent_bats( ascii_in *as ){
	int i;
	ascii_io *fmt = as->format;
	BAT *keys = fmt[as->key].c;
	BAT *bats = void_bat_create(0, TYPE_ptr, 2, 0, 100 );
	for (i = 0; i<as->nr_attrs; i++){
	    if (!as->merge && !fmt[i].key ){
		BAT *b; 
		if (fmt[i].reverse)
			b = view_create(fmt[i].c, keys, BATcount(keys));
		else
			b = view_create(keys, fmt[i].c, BATcount(keys));
		bat_persists(b);
		BATname(b, fmt[i].name );
		BAT_insert(bats, (ptr*)&b);
	     } else if (!fmt[i].key){
		BAT *b = BATdescriptor( BBPindex( fmt[i].name ));
		BAT_insert(bats, (ptr*)&b);
	     }
	}
	TMcommit();
	if (!as->merge){
	    int k = 0;
	    for (i =0; i<as->nr_attrs; i++){
		if (!fmt[i].key){
			BAT *b = *(BAT**)bun_tail( bats, k++ );
			bat_decref(b);
		}
	    }
	}
	BBPreclaim(bats);
}

INLINE
int myisspace(int s ){
        if (s==(int)' ' || s==(int)'\t' || s==(int)'\n'){
                return 1;
        }
        return 0;
}

INLINE
char *strip( char *s, char *e ){
        while(myisspace((int)*s)){
		s++;
	}
	e--;
        while(myisspace((int)*e)){
		e--;
	}
	e++;
	if (e && *e){
		*e = 0;
	}
	return s;
}

INLINE
void insert_val( ascii_io *fmt, char *s, char *e ){
	ptr *ptr;
	ptr = ADT_fromStr( fmt->ptr, strip(s,e) ); 
	BAT_insert( fmt->c, ptr);
	ADT_destroy( fmt->ptr, ptr );
}

INLINE
int insert_line( ascii_in *as, char *line ){
	ascii_io *fmt = as->format;
        char *s,*e;
	int i;
	for( i = 0; i<as->nr_attrs-1; i++){
		s=line;
		while(*line!=*(fmt[i].sep)) line++;
		e = strstr( line, fmt[i].sep ); 
		if (e){
			*e = 0;
			insert_val( &fmt[i], s, e );
			line = e + fmt[i].seplen;
		} else {
		        fprintf(GDKerr, "Error: missing sep %s\n", fmt->sep);
			return -1;
		}
	}
	s=line;
	while(*line!='\n') line++;
	e = line; /*strchr( line, '\n' );*/
	if (e){
		*e = 0;
		insert_val( &fmt[as->nr_attrs-1], s, e );
	} else {
	        fprintf(GDKerr, "Error: missing newline\n" );
		return -1;
	}
	return 0;
}

INLINE
int dump_line( ascii_io *fmt, FILE *fd, int nr_attrs, int id ){
	char *str;
	int i;
	for( i = 0; i<nr_attrs-1; i++){
		str = ADT_toStr(fmt[i].ptr, bun_tail(fmt[i].c,id));
		fprintf( fd, "%s%s", str, fmt[i].sep );
		GDKfree(str);
	}
	str = ADT_toStr(fmt[i].ptr, bun_tail(fmt[i].c,id));
	fprintf( fd, "%s\n", str );
	GDKfree(str);
	return 0;
}

#ifdef HAVE_LIBZ
INLINE
int dump_gzline( ascii_io *fmt, gzFile *fd, int nr_attrs, int id ){
	char *str;
	int i;
	for( i = 0; i<nr_attrs-1; i++){
		str = ADT_toStr(fmt[i].ptr, bun_tail(fmt[i].c,id));
		(void)gzputs( fd, str );
		(void)gzputs( fd, fmt[i].sep );
		GDKfree(str);
	}
	str = ADT_toStr(fmt[i].ptr, bun_tail(fmt[i].c,id));
	(void)gzputs( fd, str );
	gzprintf(fd, "\n");
	GDKfree(str);
	return 0;
}
#endif

int load_file( ascii_in *as, FILE *fd ){
        int i = 0;
	BAT *keys = as->format[as->key].c; 
	int cnt = BATcount(keys);
	char line[MAXLINE];
	for( i=0; i<as->nr && fgets(line, MAXLINE, fd); i++ ){
		if (strlen(line)>1 && insert_line( as, line ) < 0)
			return -1;
		if (ascii_io_debug && (i%1000000) == 0)
			fprintf(GDKerr, "inserted %d\n", i);
        } 
	if (keys->ttype == TYPE_void){
		if (BATcount( keys ) == 0)
			BATseqbase( keys, 0);
		BATsetcount(keys, cnt+i);
	}
	fprintf(GDKerr, "inserted %d\n", i);
	return 0;
}

#ifdef HAVE_LIBZ
int load_gzfile( ascii_in *as, gzFile *fd ){
        int i = 0;
	BAT *keys = as->format[as->key].c; 
	int cnt = BATcount(keys);
	char line[MAXLINE];
	for( i=0; i<as->nr && gzgets(fd, line, MAXLINE); i++ ){
		if (strlen(line)>1 && insert_line( as, line ) < 0)
			return -1;
		if (ascii_io_debug && (i%1000000) == 0)
			fprintf(GDKerr, "inserted %d\n", i);
        } 
	if (keys->ttype == TYPE_void){
		if (BATcount( keys ) == 0)
			BATseqbase( keys, 0);
		BATsetcount(keys, cnt+i);
	}
	return 0;
}
#endif

int dump_file( ascii_out *as, FILE *fd ){
        int i = 0;
	for( i=0; i<as->nr; i++ ){
		if (dump_line( as->format, fd, as->nr_attrs, i ) < 0)
			return -1;
		if (ascii_io_debug && (i%1000000) == 0)
			fprintf(GDKerr, "dumped %d lines\n", i);
        } 
	return 0;
}

#ifdef HAVE_LIBZ
int dump_gzfile( ascii_out *as, gzFile *fd ){
        int i = 0;
	for( i=0; i<as->nr; i++ ){
		if (dump_gzline( as->format, fd, as->nr_attrs, i ) < 0)
			return -1;
		if (ascii_io_debug && (i%1000000) == 0)
			fprintf(GDKerr, "dumped %d lines\n", i);
        } 
	return 0;
}
#endif

void ASCIIload( char *formatfile, char *datafile, int nr ){
	FILE *fd = fopen( formatfile, "r");
	if (fd){
		ascii_in as;
  		char    ext[EXT_LEN];

		as.nr_attrs = parse_header( as.format, fd);
  		get_extention(datafile, ext);

		if (as.nr_attrs < 0)
			return;
		fclose(fd);
		as.nr = nr;
		if (create_BATs( &as ) < 0)
			return;
#ifdef HAVE_LIBZ
  		if (!strcmp(ext,"gz" )){
			gzFile filep = gzopen( datafile, "r");
			if (filep && 	
		    	    load_gzfile( &as, filep )>=0)
			    persistent_bats( &as );
			if (filep == NULL){
			 	fprintf(GDKerr, 
				"could not open file %s\n", datafile );
			} else
				gzclose(filep);
			return;
		}
#endif
		{
			FILE *filep = fopen( datafile, "r");
			if (filep && 
			    load_file( &as, filep ) >=0 )
			    persistent_bats( &as );
			if (filep == NULL){
				fprintf(GDKerr, 
				 	"could not open file %s\n", datafile );
			} else
				fclose(filep);
		}
	}
}

void ASCIIdump( char *formatfile, char *datafile, int nr ){
	FILE *fd = fopen( formatfile, "r");
	if (fd){
		int cnt;
		ascii_out as;
  		char    ext[EXT_LEN];

		as.nr_attrs = parse_header( as.format, fd);

  		get_extention(datafile, ext);
		if (as.nr_attrs < 0)
			return;
		fclose(fd);
		as.nr = nr;
		if ((cnt = find_BATs( &as )) <0){
			return;
		}
		as.nr = cnt;
#ifdef HAVE_LIBZ
  		if (!strcmp(ext,"gz" )){
			gzFile filep = gzopen( datafile, "w");
			if (filep && 
			    dump_gzfile( &as, filep ) >= 0){
				printf("saved in %s\n", datafile );
			}
			gzclose(filep);
			return;
		}
#endif
		{
			FILE *filep = fopen( datafile, "w");
			if (filep && 
			    dump_file( &as, filep ) >= 0){
				printf("saved in %s\n", datafile );
			}
			fclose(filep);
		}
		
	}
}

void init_ascii_io(int debug){
	ascii_io_debug = debug;
}
int ascii_io_load( str formatfile, str datafile, int *nr){
	ASCIIload( formatfile, datafile, *nr );
	return GDK_SUCCEED;
}
int ascii_io_dump( str formatfile, str datafile, int *nr){
	ASCIIdump( formatfile, datafile, *nr );
	return GDK_SUCCEED;
}

@mil
module(ascii_io,io);

fp := fopen ( "format", "w+" );
fputs( "key,\",\",str\n", fp);
fputs( "a_io_test,\",\",dbl\n", fp);
fclose( fp );

fp := fopen ( "data", "w+" );
fputs( "test, 0.12345\n", fp);
fputs( "second line, 9.0\n", fp);
fclose( fp );

load("format","data",10);
dump("format","data",10);

fp := fopen ( "data", "r" );
s := fgets( fp ); 
s.print();
fclose( fp );
quit;
