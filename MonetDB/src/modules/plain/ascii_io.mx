@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@' 
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@' 
@' The Original Code is the Monet Database System.
@' 
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2004 CWI.
@' All Rights Reserved.
@' 
@' Contributor(s):
@' 		Martin Kersten <Martin.Kersten@cwi.nl>
@' 		Peter Boncz <Peter.Boncz@cwi.nl>
@' 		Niels Nes <Niels.Nes@cwi.nl>
@' 		Stefan Manegold  <Stefan.Manegold@cwi.nl>

@f ascii_io
@t The ascii io Module
@a Niels Nes
@* Ascii io Module

A database cannot live with out bulk load/store operations. The ascii io
module can be used bulk load from an ascii file or dump to one. 
The file can plain ascii, gzipped or bzipped, decided by the extention 
(none, gz or bz2).

The load operation is for bulk loading a table, each column will be loaded
into its own bat. The arguments are void-aligned bats describing the
input, ie the name of the column, the tuple seperator and the type.  
The nr argument can be -1 (The input (datafile) is read until the end)
or a maximum.

The dump operation is for dumping a set of bats, which are aligned.
Again with void-aligned arguments, with name (currently not used), 
tuple seperator (the last is the record seperator) and bat to be dumped. 
With the nr argument the dump can be limited (-1 for unlimited).

The output operation is for ordered output. A bat (possibly form the collection)
gives the order. For each element in the order bat the values in the bats are
searched, if all are found they are outputed in the datafile, with the given
seperators.

The scripts from the ascii_io.mil file are all there too for backward 
compatebility with the old Mload format files. 

The load_format loads the format file, since the old format file was
in a table format it can be loaded with the load command. 

The result from load_format can be used with load_data to load the data
into a set of new bats.

These bats can be made persistent with the make_pesistent script or
merge with existing bats with the merge_data script.

The dump_format scripts dump a format file for a given set of 
to be dumped bats. These bats can be dumped with dump_data.

@d 12/01/2001
@m 
.MODULE ascii_io;

.USE streams;

.COMMAND ascii_io_debug( int debug ) = init_ascii_io; ""

.COMMAND load( BAT[void,str] names, BAT[void,str] seps, BAT[void,str] types, str datafile, int nr ) : BAT[str,bat] = ascii_io_load; ""
.COMMAND input( BAT[void,str] names, BAT[void,str] seps, BAT[void,str] types, Stream s, int nr ) : BAT[str,bat] = ascii_io_input; ""
.COMMAND dump( BAT[void,str] names, BAT[void,str] seps, BAT[void,bat] bats, str datafile, int nr ) = ascii_io_dump; ""
.COMMAND output( BAT[any,any] order, BAT[void,str] seps, BAT[void,bat] bats, Stream s ) = ascii_io_output; ""

.END ascii_io;

@mil
proc load_format( str fmt ) : BAT[str,BAT] := {
	var names := new(void,str); names.seqbase(oid(0));
	var seps := new(void,str); seps.seqbase(oid(0));
	var types := new(void,str); types.seqbase(oid(0));
	names.insert(nil,"names");seps.insert(nil,",");types.insert(nil,"str");
	names.insert(nil,"seps");seps.insert(nil,",");types.insert(nil,"str");
	names.insert(nil,"types");seps.insert(nil,"\n");types.insert(nil,"str");
	return load(names, seps, types, fmt, 1000);
}

proc load_data( BAT[str,BAT] fmt, str data, int nr ) : BAT[str,BAT] := {
	var names := fmt.find("names");
	var seps := fmt.find("seps");
	var types := fmt.find("types");
	return load(names, seps, types, data, nr);
}

proc make_persistent( BAT[str,BAT] bats ) := {
	if (bats.exist("key")){
		var keybat := bats.find("key");
		var nbats := bats.diff(bats.reverse.select("key").reverse);
		nbats@batloop(){
			var b := keybat.reverse().join($t);
			b.rename($h);
			b.persists(true);
		}
	} else {
		bats@batloop(){
			$t.rename($h);
			$t.persists(true);
		}
	}
}

proc merge_data( BAT[str,BAT] bats ) := {
	if (bats.exist("key")){
		var keybat := bats.find("key");
		var nbats := bats.diff(bats.reverse.select("key").reverse);
		nbats@batloop(){
			var b := keybat.reverse().join($t);
			var o := bat($h);
			o.insert(b);
		}
	} else {
		bats@batloop(){
			var o := bat($h);
			o.insert($t);
		}
	}
}

proc dump_seps( BAT[void,BAT] bats ) : BAT[void,str] := {
	var seps := new(void,str); seps.seqbase(oid(0));
	var id := 0;
	var cnt := bats.count - 1;
	bats@batloop(){
		if (id != cnt) {
			seps.insert(nil,",");
		} else {
			seps.insert(nil,"\n");
		}
		id += 1;
	}
	return seps;
}

proc bat_ttype( bat b ) : str := {
	return monet_atomtbl.reverse.find(b.ttype);
}

proc dump_format( BAT[void,BAT] bats, str fmt ) : BAT[str,BAT] := {
	bats := [~bats].seqbase(oid(0));
	var names := [bbpname](bats);
	var seps  := dump_seps(bats);
	var types := [bat_ttype](bats);
	var fmtbats:= new(void,bat); fmtbats.seqbase(oid(0));
	fmtbats.insert(nil,names);
	fmtbats.insert(nil,seps);
	fmtbats.insert(nil,types);

	names := new(void,str); names.seqbase(oid(0));
	seps := new(void,str); seps.seqbase(oid(0));
	names.insert(nil,"names");seps.insert(nil,",");
	names.insert(nil,"seps");seps.insert(nil,",");
	names.insert(nil,"types");seps.insert(nil,"\n");
	dump(names, seps, fmtbats, fmt, 1000);
	names.insert(nil,"bats"); 
	fmtbats.insert(nil,bats);
	return names.reverse.join(fmtbats);
}

proc dump_data( BAT[str,BAT] fmt, str data, int cnt) := {
	var names := fmt.find("names");
	var seps := fmt.find("seps");
	var bats;
	if (fmt.exist("bats")){
		bats := fmt.find("bats");
	} else {
		bats := [load](names);
	}
	dump( names, seps, bats, data, cnt );
}

proc dump_data( BAT[str,BAT] fmt, BAT[str,BAT] bats, str data, int cnt) := {
	var names := fmt.find("names");
	var seps := fmt.find("seps");
	
	dump( names, seps, names.join(bats).reverse().mark().reverse(), data, cnt );
}

proc import( BAT[any,any] b, str filename ) : BAT[any,any] {

	var names := new(void,str).seqbase(0@0);
	names.insert(oid(nil),"head");
	names.insert(oid(nil),"tail");
	var seps := new(void,str).seqbase(0@0);
	seps.insert(oid(nil),",");
	seps.insert(oid(nil),"\n");
	var types := new(void,str).seqbase(0@0);
	types.insert(oid(nil),b.reverse.bat_ttype);
	types.insert(oid(nil),b.bat_ttype);

	var bats := load( names, seps, types, filename, -1);
	b.insert (bats.find("head").reverse.join(bats.find("tail")));
	return b;
}

proc export( BAT[any,any] b, str filename ) {
	var hb := b.mark(0@0).reverse;
	var tb := b.reverse.mark(0@0).reverse;

	var names := new(void,str).seqbase(0@0);
	names.insert(oid(nil),"head");
	names.insert(oid(nil),"tail");
	var seps := new(void,str).seqbase(0@0);
	seps.insert(oid(nil),",");
	seps.insert(oid(nil),"\n");
	var bats := new(void,bat).seqbase(0@0);
	bats.insert(oid(nil), hb);
	bats.insert(oid(nil), tb);

	dump( names, seps, bats, filename, b.count());
}

# todo add function to create a key (oid sequence) colom

@h
#ifndef _ASCII_IO2_H_
#define _ASCII_IO2_H_

#include <streams.h>
#include <ascii_io.proto.h>


typedef ptr *(*frStr)( void *extra, int type, char *s);
typedef int (*toStr)( void *extra, char **buf, int *len, int type, ptr a);

typedef struct ascii_io_t {
	char* name;
	char* sep;
	int   seplen;
	char* type;
	int   adt;
	BAT*  c;
	BUN   p;
	toStr tostr;
	frStr frstr;
	void* extra;
} ascii_io;

typedef struct ascii_load_t {
	size_t offset;
	size_t nr;
	size_t nr_attrs;
	ascii_io *format;
} ascii;

extern BAT *ASCIIload( BAT *names, BAT *seps, BAT *types, char *datafile, size_t nr );
ascii_io_export BAT *ASCIIinput( BAT *names, BAT *seps, BAT *types, bstream *s, size_t nr );
ascii_io_export size_t ASCIIoutput( BAT *order, BAT *seps, BAT *bats, stream *s );
extern void ASCIIdump( BAT *names, BAT *seps, BAT *bats, char *datafile, size_t nr );

@+ low level interface 
@h
ascii_io_export int ASCIIcreate_bats( ascii *as );
ascii_io_export size_t ASCIIassign_BATs( ascii *as, BAT *bats );
ascii_io_export int ASCIIload_file( ascii *as, bstream *b );
ascii_io_export BAT *ASCIIcollect_bats( ascii *as );
ascii_io_export void ASCIIdestroy_format( ascii *as );
ascii_io_export int ASCIIoutput_file( ascii *as, BAT *order, stream *s );

@+ Default from and to string functions
@h
ascii_io_export ptr *ASCIIadt_frStr( void *extra, int type, char *s);
ascii_io_export int ASCIIadt_toStr( void *extra, char **buf, int *len, int type, ptr a);

#endif
@c

#include <gdk.h>
#include "ascii_io.h"

#include <string.h>
#include <ctype.h>

static int ascii_io_debug = 0;

ptr bun_tail(BAT *b, size_t nr){
	REGISTER size_t _i = BUNindex((b),BUNfirst((b)));
	return (ptr)BUNtail(b, BUNptr(b,_i+nr));
}


BAT *void_bat_create(int adt, size_t nr) {
	BAT *b = BATnew(TYPE_void,adt,nr);
	BATseqbase(b,0);
	return b;
}

static char *sep_dup( char *sep ){
	size_t len = strlen(sep);
	char *res = GDKmalloc(len+1), *result = res;
	char *end = sep+len;

	while(sep < end){
		if (*sep == '\\'){
			++sep;
			switch(*sep++){
			case 'r': *res++ = '\r'; break;
			case 'n': *res++ = '\n'; break;
			case 't': *res++ = '\t'; break;
			}
		} else {
			*res++ = *sep++; 
		}
	}
	*res = '\0';
	return result;
}


char *str2monet ( char *src){
	int l = strlen(src) + 1;
	char *cur, *dst = GDKmalloc(l), *p = dst;
	int escaped = 0;

        /* copy it in, while performing the correct escapes */
        for(cur = src; *cur; cur++) {
                if (escaped) {
                        if (*cur == 'n') {
                                *p++ = '\n';
                        } else if (*cur == 't') {
                                *p++ = '\t';
                        } else if ((cur[0] >= '0' && cur[0] <= '7') &&
                                   (cur[1] >= '0' && cur[1] <= '7') &&
                                   (cur[2] >= '0' && cur[2] <= '7'))
                        {
                                *p++ =  (cur[2] & 7)     |
                                       ((cur[1] & 7) <<3)|
                                       ((cur[0] & 7) <<6);
                                cur += 2;
                        } else {
                                *p++ = *cur;
                        }
                        escaped = FALSE;
                } else if (*cur == '\\') {
                        escaped = TRUE;
                } else {
                        *p++ = *cur;
                }
        }
        *p++ = 0;
        return dst;
}

ptr *ASCIIadt_frStr( void *extra, int type, char *s){
        int l = 0;
        ptr *res = NULL;
	(void) extra;
        if (type == TYPE_str) {
        	if (s == NULL || strcmp(s,"nil") == 0)
        		res = (ptr*)ATOMnil(TYPE_str);
        	else
                	res = (ptr*)str2monet(s);
        } else
                (void) (*BATatoms[type].atomFromStr)(s, &l, (ptr)&res);
        return res;
}

int ASCIIadt_toStr( void *extra, char **buf, int *len, int type, ptr a){
	(void) extra;
/*
        if (type == TYPE_str){
		char *dst, *src = a;
		int l;
		if (GDK_STRNIL(src)) {
			src = "nil";
		}
		l = strlen(src);
		if (l+3 > *len){
			GDKfree(buf);
			*len = 2*l+3;
			*buf = GDKmalloc( *len );
		}
		dst = *buf;
		dst[0] = '"';
		strncpy(dst+1, src, l);
		dst[l+1] = '"';
		dst[l+2] = 0;
		return l+2;
	} else {
	}
*/
        	return (*BATatoms[type].atomToStr)(buf, len, a);
}

static
size_t create_loadformat( ascii *as, BAT *names, BAT *seps, BAT *types ){
	size_t p;
	size_t nr_attrs = BATcount(names);
	ascii_io *fmt = as->format =  
		(ascii_io*)GDKmalloc(sizeof(ascii_io) * (nr_attrs + 1) );

	as->offset = 0;
	as->nr_attrs = nr_attrs;
	/* assert(as->nr_attrs == nr_attrs); */ /* i.e. it fits */
	for (p=0; p<nr_attrs; p++){
		fmt[p].name = (char*)bun_tail(names, p);
		fmt[p].sep = sep_dup((char*)bun_tail(seps, p));
		fmt[p].seplen = (int) strlen( fmt[p].sep );
		fmt[p].type = (char*)bun_tail(types, p);
		fmt[p].adt = ATOMindex( fmt[p].type );
		fmt[p].tostr = &ASCIIadt_toStr;
		fmt[p].frstr = &ASCIIadt_frStr;
		fmt[p].extra = NULL;
		if (ascii_io_debug)
			stream_printf(GDKerr, "%s\n", fmt[p].name );
	}
	return as->nr_attrs;
}

static
size_t create_dumpformat( ascii *as, BAT *names, BAT *seps, BAT *bats ){
	size_t p;
	size_t nr_attrs = BATcount(bats);
	ascii_io *fmt = as->format =  
		(ascii_io*)GDKmalloc(sizeof(ascii_io) * (nr_attrs + 1) );

	as->offset = 0;
	as->nr_attrs = nr_attrs;
	/* assert(as->nr_attrs == nr_attrs); */ /* i.e. it fits */
	for (p=0; p<nr_attrs; p++){
		BAT *b = (BAT*)BATdescriptor(*(bat*)bun_tail(bats, p));

		if (!b) 
			return ~(size_t)0; /* (size_t)(-1) */
		fmt[p].name = NULL;
		if (names)
			fmt[p].name = (char*)bun_tail(names, p);
		fmt[p].sep = sep_dup((char*)bun_tail(seps, p));
		fmt[p].seplen = (int) strlen( fmt[p].sep );
		fmt[p].type = ATOMname(b->ttype);
		fmt[p].adt = (b)->ttype;
		fmt[p].tostr = &ASCIIadt_toStr;
		fmt[p].frstr = &ASCIIadt_frStr;
		fmt[p].extra = NULL;
	}
	return as->nr_attrs;
}

void ASCIIdestroy_format( ascii *as ){
	size_t p;
	ascii_io *fmt = as->format;

	for (p=0; p<as->nr_attrs; p++){
		if (fmt[p].c) 
			BBPunfix(fmt[p].c->batCacheid);
		GDKfree( fmt[p].sep );
	}
	GDKfree(fmt);
}

size_t ASCIIassign_BATs( ascii *as, BAT *bats ){
	ascii_io *fmt = as->format;
	size_t res = as->nr;
	size_t i;
	for (i=0; i<as->nr_attrs; i++){
		BAT *b = (BAT*)BATdescriptor(*(bat*)bun_tail(bats, i));
		fmt[i].c = (b);
		if (res == ~(size_t)0 || BATcount(fmt[i].c)<res)
			res = BATcount(fmt[i].c);
	}
	as->nr = res;
	return res;
}

static
oid check_BATs( ascii *as ){
	ascii_io *fmt = as->format;
	size_t i=0;
	size_t cnt;
	oid base;

	if(fmt[i].c==NULL) i++; 
	cnt = BATcount(fmt[i].c);
	base = fmt[i].c->hseqbase;

	if (!BAThdense(fmt[i].c)) return oid_nil;

	for (i=0; i<as->nr_attrs; i++){
		BAT *b;
		int offset;

		b = fmt[i].c;
		if(b == NULL) continue;
		offset = BUNindex(b, BUNfirst(b)) + as->offset;

		if (BATcount(b) != cnt ||
		    b->hseqbase != base)
			return oid_nil;

		fmt[i].p = BUNptr(b, offset);
	}
	return base;
}

int ASCIIcreate_bats( ascii *as ){
	ascii_io *fmt = as->format;
	size_t i;

	for (i=0; i<as->nr_attrs; i++){
		fmt[i].c = void_bat_create(fmt[i].adt,as->nr);
	}
	return 0;
}

BAT *ASCIIcollect_bats( ascii *as ){
	BAT *bats = BATnew(TYPE_str,TYPE_bat,as->nr_attrs);
	ascii_io *fmt = as->format;
	size_t i;
	size_t cnt = BATcount(fmt[0].c);

	for (i=0; i<as->nr_attrs; i++){
		BUNins(bats,(ptr)fmt[i].name, (ptr)&fmt[i].c->batCacheid);
		if (cnt != BATcount(fmt[i].c)){
		        GDKerror("Error: counts are not equal\n");
			return NULL;
		}
	}
	return bats;
}

static INLINE
int myisspace(int s ){
	return s == ' ' || s == '\t' || s == '\n';
}

static INLINE
char *strip( char *s, char *e ){
        while(myisspace((int)*s)){
		s++;
	}
	e--;
        while(myisspace((int)*e)){
		e--;
	}
	e++;
	if (e && *e){
		*e = 0;
	}
	return s;
}

static INLINE
int insert_val( ascii_io *fmt, char *s, char *e, int need2strip ){
	ptr *adt;
	oid on = oid_nil;	/* can't use &oid_nil because of the
				   way it's defined */
	if (need2strip) s = strip(s,e);
	adt = fmt->frstr( fmt->extra, fmt->adt, s );
	
	if (!adt){
		GDKerror("%lx not inserted %s\n", (size_t)adt, s);
		return 1;
	}

	BUNins(fmt->c,&on,adt);
	GDKfree(adt);
	return 0;
}

static char *find_quote(char *s, char quote ){
	while(*s != quote) 
		s++;
	return s;
}
static char *rfind_quote(char *s, char quote ){
	while(*s != quote) 
		s--;
	return s;
}
static char *skip_string(char *s, char quote ){
	int esc = 0;
	while(*s){
		if (*s == '\\' && !esc)
			esc = 1;
		else if (*s == quote && !esc)
			break;
		else
			esc = 0;
		s++;
	}
	if (*s) 
		s++;
	else
		return NULL;
	return s;
}

static INLINE
int insert_line( ascii *as, char *line ){
	int res = 0;
	ascii_io *fmt = as->format;
        char *s,*e = 0, quote = '\"';
	size_t i;
	int quotes = 0;
	int first = 0;
	for( i = 0; i<as->nr_attrs-1 && res == 0; i++){
		first = 1;
		s=line;
		while(*line){
			if (*line == *(fmt[i].sep) && 
			     strncmp( fmt[i].sep, line, fmt[i].seplen) == 0 ){
				e = line; /*strstr( line, fmt[i].sep ); */
				break;
		     	} else if(first && (*line == '\"' || *line == '\'') 
					&& *(line-1) != '\\'){
				quotes = 1;
				quote = *line;
				line++;
				line = skip_string( line, quote );
				if (!line) return -1;
				first = 0;
			} else {
				if (first && !isspace((int)(*line)))
					first = 0;
				line++;
			}
		}
		if (e){
			char *end = e;
			if (quotes){
				s = find_quote(s, quote);
				if (!s) return -1;
				s++;
				e = rfind_quote(e, quote);
			}
			*e = 0;
			res |= insert_val( &fmt[i], s, e, !quotes );
			quotes = 0;
			line = end + fmt[i].seplen;
		} else {
		        GDKerror("Error: missing sep %s line %d field %d\n", fmt->sep, BATcount(fmt->c), i);
			return -1;
		}
		e = 0;
	}
	s=line;
	first = 1;
	while(*line){
		if (*line == *(fmt[as->nr_attrs-1].sep) && 
		     strncmp( fmt[as->nr_attrs-1].sep, line, 
			      fmt[as->nr_attrs-1].seplen) == 0 ){
			e = line; /*strstr( line, fmt[as->nr_attrs-1].sep ); */
			break;
		} else if(first && (*line == '\"' || *line == '\'')
			        && *(line-1) != '\\'){
			quotes = 1;
			quote = *line;
			line++;
			line = skip_string( line, quote );
			if (!line) return -1;
			first = 0;
		} else {
			if (first && !isspace((int)(*line)))
				first = 0;
			line++;
		}
	}
	if (!e) e = line;
	if (e){
		char *end = e;
		if (quotes){
			s = find_quote(s, quote);
			if (!s) return -1;
			s++;
			e = rfind_quote(e, quote);
		}
		*e = 0;
		res |= insert_val( &fmt[as->nr_attrs-1], s, e, !quotes );
		quotes = 0;
		line = end + fmt[as->nr_attrs-1].seplen;
	} else {
		GDKerror("Error: missing sep %s line %d field %d\n", fmt->sep, BATcount(fmt->c), i);
		return -1;
	}
	e = 0;
	return res;
}

static int
ascii_io_error(stream *s)
{
	char *err = stream_error(s);

	stream_printf( GDKerr, "Stream error %s\n", err);
	/* use free as stream allocates out side GDK */
	if (err) free(err);
	return -1;
}

static INLINE int 
dump_line( char **buf, int *len, ascii_io *fmt, stream *fd, size_t nr_attrs, size_t id ){
	size_t i;
	for( i = 0; i<nr_attrs; i++){
		ascii_io *f;
		char *p;
		int l;

		f = fmt+i;
		if( f->c){
			p = (char*)bun_tail(f->c,id);
			l = f->tostr( f->extra, buf, len, f->adt, p);
			if (stream_write( fd, *buf, 1, l ) != l)
				return ascii_io_error(fd);
		} 
		if (stream_write( fd, f->sep, 1, f->seplen ) != f->seplen)
			return ascii_io_error(fd);
	}
	return 0;
}

static INLINE
int output_line( char **buf, int *len, ascii_io *fmt, stream *fd, size_t nr_attrs, ptr id ){
	size_t i;
	
	for( i = 0; i<nr_attrs; i++){
		if( fmt[i].c==NULL) continue;
		fmt[i].p = BUNfnd( fmt[i].c, id );
		if (fmt[i].p == 0)
			break;
	}
	if ( i == nr_attrs ){
	    for( i = 0; i<nr_attrs; i++){
		ascii_io *f;
		char *p;
		int l;

		f = fmt+i;
		if( f->c){
			p = BUNtail(f->c, f->p);
			l = f->tostr(f->extra, buf, len, f->adt, p);
			if (stream_write( fd, *buf, 1, l ) != l)
				return ascii_io_error(fd);
		}
		if (stream_write( fd, f->sep, 1, f->seplen ) != f->seplen)
			return ascii_io_error(fd);
	    }
	}
	return 0;
}

static INLINE
int output_line_dense( char **buf, int *len, ascii_io *fmt, stream *fd, size_t nr_attrs ){
	size_t i;
	for( i = 0; i<nr_attrs; i++){
		ascii_io *f = fmt+i;
		if( f->c){
			char *p = BUNtail(f->c, f->p);
			int l = f->tostr(f->extra, buf, len, f->adt, p);
			if (stream_write( fd, *buf, 1, l ) != l)
				return ascii_io_error(fd);
			f->p = BUNnext( f->c, f->p );
		}
		if (stream_write( fd, f->sep, 1, f->seplen ) != f->seplen)
			return ascii_io_error(fd);
	}
	return 0;
}

static INLINE
int output_line_lookup( char **buf, int *len, ascii_io *fmt, stream *fd, size_t nr_attrs, size_t id ){
	size_t i;
	for( i = 0; i<nr_attrs; i++){
		ascii_io *f = fmt+i;
		if( f->c){
			char *p = BUNtail(f->c, BUNptr(f->c,
					id+BUNindex(f->c,BUNfirst(f->c))));
			int l = f->tostr(f->extra, buf, len, f->adt, p);
			if (stream_write( fd, *buf, 1, l ) != l)
				return ascii_io_error(fd);
		}
		if (stream_write( fd, f->sep, 1, f->seplen ) != f->seplen)
			return ascii_io_error(fd);
	}
	return 0;
}


int ASCIIload_file( ascii *as, bstream *b ){
	int res = 0, done = 0;
	size_t i = 0;
	char *sep = as->format[as->nr_attrs-1].sep;
        int seplen = as->format[as->nr_attrs-1].seplen;

	if (ascii_io_debug)
		stream_printf( GDKerr, "ASCIIload_file\n");

	while((b->pos < b->len || !b->eof) && res == 0 && (as->nr == ~(size_t)0 || i < as->nr)){
		char *s, *end;
		if (b->pos >= b->len && !b->eof && bstream_read(b, b->size - (b->len - b->pos)) == 0) {
			GDKerror("read error\n");
			res = -1;
			break;
		}
		end = b->buf + b->len;
		s = b->buf + b->pos;
		*end = '\0';
		done = 0;
		while( s < end ){
			char *e = strstr( s, sep );
			if (e){
				*e = '\0';
				if ((e-s) <= 1){ /* empty line indicates eof */
					b->eof = 1;
					break;
				}
				if (insert_line(as, s ) < 0){
					GDKerror("value %s not inserted\n", s);	
					res = -1;
					break;
				}
				s = e + seplen;
				done = 1;
			} else if (b->eof && s + as->nr_attrs < end){
				if (insert_line(as, s ) < 0){
					GDKerror("value %s not inserted\n", s);	
					res = -1;
					break;
				}
				s = end;
			} else {
				if (!done){ /* nothing found in current buf
					     * ie. need to enlarge 
					     */
					int size = b->size;

					if (b->pos == 0 || (b->len - b->pos >
						b->size>>1) )
						size <<= 4;
					if (bstream_read(b, size) == 0) {
						GDKerror("read error\n");
						res = -1;
						break;
					}
					end = b->buf + b->len;
					s = b->buf + b->pos;
					*end = '\0';
					continue;
				}
				break;
			}
			b->pos = (s-b->buf);
			i++;
			if (ascii_io_debug && (i%100000) == 0)
				stream_printf(GDKerr, "inserted " SZFMT "\n", i);
			if (as->nr != ~(size_t)0 && i >= as->nr)
				break;
		}
	}
	as->nr = i;
	if (res < 0)
		return res;
	return as->nr;
}

static
int dump_file( ascii *as, stream *fd ){
        size_t i = 0;
	int len = BUFSIZ;
	char *buf = GDKmalloc(len);
	for( i=0; i<as->nr; i++ ){
		if (dump_line( &buf, &len, as->format, fd, as->nr_attrs, i )<0){
			GDKfree(buf);
			return -1;
		}
		if (ascii_io_debug && (i%1000000) == 0)
			stream_printf(GDKerr, "dumped " SZFMT " lines\n", i);
        } 
	GDKfree(buf);
	return 0;
}

static int 
output_file_default( ascii *as, BAT *order, stream *fd )
{
	int len = BUFSIZ, res = 0; 
	char *buf = GDKmalloc(len);
	BUN p,q;
        size_t i = 0;
	size_t offset = BUNindex(order, BUNfirst(order)) + as->offset;

	for(q = BUNptr(order, offset+as->nr), p = BUNptr(order, offset);
			p < q; p = BUNnext(order, p))
	{
		ptr h = BUNhead(order, p);
		if ((res = output_line( &buf, &len,as->format, fd, as->nr_attrs, h ))<0){
			GDKfree(buf);
			return res;
		}
		i++;
		if (ascii_io_debug && (i%1000000) == 0)
			stream_printf(GDKerr, "dumped " SZFMT " lines\n", i);
        } 
	GDKfree(buf);
	return res;
}

static int 
output_file_dense( ascii *as, stream *fd )
{
	int len = BUFSIZ, res = 0; 
	char *buf = GDKmalloc(len);
        size_t i = 0;
	
	for(i=0; i<as->nr; i++){
		if((res = output_line_dense( &buf, &len, as->format, fd, as->nr_attrs))<0){
			GDKfree(buf);
			return res;
		}
		if (ascii_io_debug && (i%1000000) == 0)
			stream_printf(GDKerr, "dumped " SZFMT " lines\n", i);
        } 
	GDKfree(buf);
	return res;
}

static int 
output_file_ordered( ascii *as, BAT *order, stream *fd, oid base )
{
	int len = BUFSIZ, res = 0; 
	char *buf = GDKmalloc(len);
	BUN p,q;
        size_t i = 0;
	size_t offset = BUNindex(order, BUNfirst(order)) + as->offset;

	for(q = BUNptr(order, offset+as->nr), p = BUNptr(order, offset);
			p < q; p = BUNnext(order, p))
	{
		size_t h = *(oid*)BUNhead(order, p) - base;
		if ((res = output_line_lookup( &buf, &len, as->format, fd, as->nr_attrs, h))<0){
			GDKfree(buf);
			return res;
		}
		if (ascii_io_debug && (i%1000000) == 0)
			stream_printf(GDKerr, "dumped " SZFMT " lines\n", i);
        } 
	GDKfree(buf);
	return res;
}

#define SIZE 1*1024*1024

BAT *
ASCIIload( BAT *names, BAT *seps, BAT *types, char *datafile, size_t nr )
{
	BAT *res;
	stream *s = open_rastream( datafile );
	bstream *b = NULL;

	if (s == NULL || stream_errnr(s)){
		GDKerror("could not open file %s\n", datafile );
		if (s) {
			stream_destroy(s);
		}
		return NULL;
	}
	res = ASCIIinput( names, seps, types, b=bstream_create(s, SIZE), nr );
	bstream_destroy(b);
	stream_close(s);
	stream_destroy(s);
	return res;
}

BAT *ASCIIinput( BAT *names, BAT *seps, BAT *types, bstream *s, size_t nr ){
	BAT *bats = NULL;
	ascii as;

	as.nr_attrs = 0;
	as.nr = nr;
	if (create_loadformat( &as, names, seps, types) != ~(size_t)0 && 
	    ASCIIcreate_bats( &as ) >= 0){
		if (ASCIIload_file( &as, s )>=0)
			bats = ASCIIcollect_bats( &as );
	}
	ASCIIdestroy_format( &as );
	return bats;
}

void ASCIIdump( BAT *names, BAT *seps, BAT *bats, char *datafile, size_t nr ){
	ascii as;

	as.nr_attrs = 0;
	as.nr = nr;
	if (create_dumpformat( &as, names, seps, bats) != ~(size_t)0 && 
	    ASCIIassign_BATs( &as, bats ) != ~(size_t)0){
		stream *s = open_wastream( datafile );
		if (s != NULL && !stream_errnr(s) && dump_file( &as, s ) >= 0){
			stream_printf(GDKerr, "saved in %s\n", datafile );
		}
		if (s == NULL || stream_errnr(s)){
		 	GDKerror("could not open file %s\n", datafile );
		} else {
			stream_close(s);
		}
		stream_destroy(s);
	}
	ASCIIdestroy_format( &as );
}

int 
ASCIIoutput_file( ascii *as, BAT *order, stream *s )
{
	oid base = oid_nil;
	if ((base = check_BATs( as )) != oid_nil ){
		if (BAThdense(order) && 
 		    order->hseqbase == base && BATcount(order) == as->nr)
			return output_file_dense( as, s );
		else
			return output_file_ordered( as, order, s, base );
	} else {
		return output_file_default( as, order, s ); 
	}
}

size_t 
ASCIIoutput( BAT *order, BAT *seps, BAT *bats, stream *s )
{
	int res = 0;
	ascii as;

	as.nr_attrs = 0;
	as.nr = ~(size_t)0;
	if (create_dumpformat( &as, NULL, seps, bats) != ~(size_t)0 && 
	    ASCIIassign_BATs( &as, bats ) != ~(size_t)0){
		res = ASCIIoutput_file(&as, order, s);
	}
	ASCIIdestroy_format( &as );
	if (res >= 0)
		return as.nr;
	return ~(size_t)0;
}

int init_ascii_io(int *debug){
	ascii_io_debug = *debug;
	return GDK_SUCCEED;
}
int ascii_io_load( BAT **bats, BAT *names, BAT* seps, BAT* types, str datafile, int *nr){
	*bats = ASCIIload( names, seps, types, datafile, *nr );
	if (*bats) {
		return GDK_SUCCEED;
	} else {
		return GDK_FAIL;
	}
}
int ascii_io_input( BAT **bats, BAT *names, BAT* seps, BAT* types, Stream * s, int *nr){
	bstream *b = NULL;

	*bats = ASCIIinput( names, seps, types, b=bstream_create(*(stream**)s, SIZE), *nr );
	bstream_destroy(b);
	if (*bats) {
		return GDK_SUCCEED;
	} else {
		return GDK_FAIL;
	}
}
int ascii_io_dump( BAT *names, BAT* seps, BAT* bats, str datafile, int *nr){
	ASCIIdump( names, seps, bats, datafile, *nr );
	return GDK_SUCCEED;
}
int ascii_io_output( BAT *order, BAT* seps, BAT* bats, Stream *s ){
	size_t res = ASCIIoutput( order, seps, bats, *(stream**)s );
	return ((res==~(size_t)0)?GDK_FAIL:GDK_SUCCEED);
}

@mil

PROC test_ascii_io() : void := {

    #ascii_io_debug(1);

    fp := fopen ( "format", "w+" );
    fputs( "key,\",\",str\n", fp);
    fputs( "a_io_test,\"\\n\",dbl\n", fp);
    fclose( fp );

    fp := fopen ( "data", "w+" );
    fputs( "test, 0.12345\n", fp);
    fputs( "second line, 9.0\n", fp);
    fclose( fp );

    bats := load_data(load_format("format"),"data",10);
    bats.print;
    a := bats.find("key").reverse().join( bats.find("a_io_test") );
    a.print;
    dump_data(load_format("format"), bats, "data", -1);

    fp := fopen ( "data", "r" );
    s := fgets( fp ); 
    s.print();
    fclose( fp );

    b:=new(int,str);
    b.insert(1,"import expor");
    b.insert(5,"are replaced by");
    b.insert(3,"scripts in ascii_io");
    b.print;
    b.export("/tmp/test");
    c:=new(int,str);
    c.import("/tmp/test");
    c.print;
}

