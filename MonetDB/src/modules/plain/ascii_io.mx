@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at 
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@' 
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@' 
@' The Original Code is the Monet Database System.
@' 
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2002 CWI.  
@' All Rights Reserved.
@' 
@' Contributor(s):
@' 		Martin Kersten <Martin.Kersten@cwi.nl>
@' 		Peter Boncz <Peter.Boncz@cwi.nl>
@' 		Niels Nes <Niels.Nes@cwi.nl>
@' 		Stefan Manegold  <Stefan.Manegold@cwi.nl>

@f ascii_io
@t The ascii io Module
@a Niels Nes
@* Ascii io Module

A database cannot live with out bulk load/store operations. The ascii io
module can be used bulk load from an ascii file or dump to one. 
The file can plain ascii, gzipped or bzipped, decided by the extention 
(none, gz or bz2).

The load operation is for bulk loading a table, each column will be loaded
into its own bat. The arguments are void-aligned bats describing the
input, ie the name of the column, the tuple seperator and the type.  
The nr argument can be -1 (The input (datafile) is read until the end)
or a maximum.

The dump operation is for dumping a set of bats, which are aligned.
Again with void-aligned arguments, with name (currently not used), 
tuple seperator (the last is the record seperator) and bat to be dumped. 
With the nr argument the dump can be limited (-1 for unlimited).

The output operation is for ordered output. A bat (possibly form the collection)
gives the order. For each element in the order bat the values in the bats are
searched, if all are found they are outputed in the datafile, with the given
seperators.

The scripts from the LOAD part are all there too for backward compatebility
with the old Mload format files. 

The load_format loads the format file, since the old format file was
in a table format it can be loaded with the load command. 

The result from load_format can be used with load_data to load the data
into a set of new bats.

These bats can be made persistent with the make_pesistent script or
merge with existing bats with the merge_data script.

The dump_format scripts dump a format file for a given set of 
to be dumped bats. These bats can be dumped with dump_data.

@d 12/01/2001
@m 
.MODULE ascii_io;

.USE streams;

.COMMAND ascii_io_debug( int debug ) = init_ascii_io; ""

.COMMAND load( BAT[void,str] names, BAT[void,str] seps, BAT[void,str] types, str datafile, int nr ) : BAT[str,bat] = ascii_io_load; ""
.COMMAND dump( BAT[void,str] names, BAT[void,str] seps, BAT[void,bat] bats, str datafile, int nr ) = ascii_io_dump; ""
.COMMAND output( BAT[any,any] order, BAT[void,str] seps, BAT[void,bat] bats, Stream s ) = ascii_io_output; ""

.LOAD

proc load_format( str fmt ) : BAT[str,BAT] := {
	var names := new(void,str); names.seqbase(oid(0));
	var seps := new(void,str); seps.seqbase(oid(0));
	var types := new(void,str); types.seqbase(oid(0));
	names.insert(nil,"names");seps.insert(nil,",");types.insert(nil,"str");
	names.insert(nil,"seps");seps.insert(nil,",");types.insert(nil,"str");
	names.insert(nil,"types");seps.insert(nil,"\n");types.insert(nil,"str");
	return load(names, seps, types, fmt, 1000);
}

proc load_data( BAT[str,BAT] fmt, str data, int nr ) : BAT[str,BAT] := {
	var names := fmt.find("names");
	var seps := fmt.find("seps");
	var types := fmt.find("types");
	return load(names, seps, types, data, nr);
}

proc make_persistent( BAT[str,BAT] bats ) := {
	if (bats.exist("key")){
		var keybat := bats.find("key");
		var nbats := bats.diff(bats.reverse.select("key").reverse);
		nbats@batloop(){
			var b := keybat.reverse().join($t);
			b.rename($h);
			b.persists(true);
		}
	} else {
		bats@batloop(){
			$t.rename($h);
			$t.persists(true);
		}
	}
}

proc merge_data( BAT[str,BAT] bats ) := {
	if (bats.exist("key")){
		var keybat := bats.find("key");
		var nbats := bats.diff(bats.reverse.select("key").reverse);
		nbats@batloop(){
			var b := keybat.reverse().join($t);
			var o := bat($h);
			o.insert(b);
		}
	} else {
		bats@batloop(){
			var o := bat($h);
			o.insert($t);
		}
	}
}

proc dump_seps( BAT[void,BAT] bats ) : BAT[void,str] := {
	var seps := new(void,str); seps.seqbase(oid(0));
	var id := 0;
	var cnt := bats.count - 1;
	bats@batloop(){
		if (id != cnt) {
			seps.insert(nil,",");
		} else {
			seps.insert(nil,"\n");
		}
		id += 1;
	}
	return seps;
}

proc bat_ttype( bat b ) : str := {
	return monet_atomtbl.reverse.find(b.ttype);
}

proc dump_format( BAT[void,BAT] bats, str fmt ) : BAT[str,BAT] := {
	bats := [~bats].seqbase(oid(0));
	var names := [bbpname](bats);
	var seps  := dump_seps(bats);
	var types := [bat_ttype](bats);
	var fmtbats:= new(void,bat); fmtbats.seqbase(oid(0));
	fmtbats.insert(nil,names);
	fmtbats.insert(nil,seps);
	fmtbats.insert(nil,types);

	names := new(void,str); names.seqbase(oid(0));
	seps := new(void,str); seps.seqbase(oid(0));
	names.insert(nil,"names");seps.insert(nil,",");
	names.insert(nil,"seps");seps.insert(nil,",");
	names.insert(nil,"types");seps.insert(nil,"\n");
	dump(names, seps, fmtbats, fmt, 1000);
	names.insert(nil,"bats"); 
	fmtbats.insert(nil,bats);
	return names.reverse.join(fmtbats);
}

proc dump_data( BAT[str,BAT] fmt, str data, int cnt) := {
	var names := fmt.find("names");
	var seps := fmt.find("seps");
	var bats;
	if (fmt.exist("bats")){
		bats := fmt.find("bats");
	} else {
		bats := [load](names);
	}
	dump( names, seps, bats, data, cnt );
}

# todo add function to create a key (oid sequence) colom
.END;

.END ascii_io;
@h
#ifndef _ASCII_IO2_H_
#define _ASCII_IO2_H_

#include <streams.h>
#include <ascii_io.proto.h>

extern BAT *ASCIIload( BAT *names, BAT *seps, BAT *types, char *datafile, int nr );
extern BAT *ASCIIinput( BAT *names, BAT *seps, BAT *types, bstream *s, int nr );
extern void ASCIIdump( BAT *names, BAT *seps, BAT *bats, char *datafile, int nr );
extern int ASCIIoutput( BAT *order, BAT *seps, BAT *bats, stream *s );

#endif
@c

#include <gdk.h>
#include "ascii_io.h"

#include <string.h>
#include <ctype.h>

typedef struct ascii_io_t {
	char* name;
	char* sep;
	int   seplen;
	char* type;
	int   adt;
	BAT*  c;
	BUN   p;
} ascii_io;

typedef struct ascii_load_t {
	int nr;
	int nr_attrs;
	ascii_io *format;
} ascii;

static int ascii_io_debug = 0;

ptr bun_tail(BAT *b, int nr){
	REGISTER int _i = BUNindex((b),BUNfirst((b)));
	return (ptr)BUNtail(b, BUNptr(b,_i+nr));
}


BAT *void_bat_create(int adt, int nr) {
	BAT *b = BATnew(TYPE_void,adt,nr);
	BATseqbase(b,0);
	return b;
}

static
ptr *ADT_fromStr( int type, char *s){
        int l = 0;
        ptr *res = NULL;
        if (type == TYPE_str)
                res = (ptr*)GDKstrdup(s);
        else
                BATatoms[type].atomFromStr(s, &l, (ptr)&res);
        return res;
}

static
int ADT_toStr( char **buf, int *len, int type, ptr a){
        return (int)BATatoms[type].atomToStr( buf, len, a);
}

static char *sep_dup( char *sep ){
	int len = strlen(sep);
	char *res = GDKmalloc(len+1), *result = res;
	char *end = sep+len;

	while(sep < end){
		if (*sep == '\\'){
			++sep;
			switch(*sep++){
			case 'r': *res++ = '\r'; break;
			case 'n': *res++ = '\n'; break;
			case 't': *res++ = '\t'; break;
			}
		} else {
			*res++ = *sep++; 
		}
	}
	*res = '\0';
	return result;
}

static
int create_loadformat( ascii *as, BAT *names, BAT *seps, BAT *types ){
	int p;
	int nr_attrs = BATcount(names);
	ascii_io *fmt = as->format =  
		(ascii_io*)GDKmalloc(sizeof(ascii_io) * (nr_attrs + 1) );

	as->nr_attrs = nr_attrs;
	for (p=0; p<as->nr_attrs; p++){
		fmt[p].name = (char*)bun_tail(names, p);
		fmt[p].sep = sep_dup((char*)bun_tail(seps, p));
		fmt[p].seplen = strlen( fmt[p].sep );
		fmt[p].type = (char*)bun_tail(types, p);
		fmt[p].adt = ATOMindex( fmt[p].type );
		if (ascii_io_debug)
			printf("%s\n", fmt[p].name );
	}
	return as->nr_attrs;
}

static
int create_dumpformat( ascii *as, BAT *names, BAT *seps, BAT *bats ){
	int p;
	int nr_attrs = BATcount(bats);
	ascii_io *fmt = as->format =  
		(ascii_io*)GDKmalloc(sizeof(ascii_io) * (nr_attrs + 1) );

	as->nr_attrs = nr_attrs;
	for (p=0; p<as->nr_attrs; p++){
		BAT *b = (BAT*)BATdescriptor(*(bat*)bun_tail(bats, p));
		fmt[p].name = NULL;
		if (names)
			fmt[p].name = (char*)bun_tail(names, p);
		fmt[p].sep = sep_dup((char*)bun_tail(seps, p));
		fmt[p].seplen = strlen( fmt[p].sep );
		fmt[p].type = ATOMname(b->ttype);
		fmt[p].adt = (b)->ttype;
	}
	return as->nr_attrs;
}

static
void destroy_format( ascii *as ){
	int p;
	ascii_io *fmt = as->format;

	for (p=0; p<as->nr_attrs; p++){
		GDKfree( fmt[p].sep );
	}
	GDKfree(fmt);
}

static
int assign_BATs( ascii *as, BAT *bats ){
	ascii_io *fmt = as->format;
	int res = as->nr;
	int i;
	for (i=0; i<as->nr_attrs; i++){
		BAT *b = (BAT*)BATdescriptor(*(bat*)bun_tail(bats, i));
		fmt[i].c = (b);
		if (res == -1 || BATcount(fmt[i].c)<res)
			res = BATcount(fmt[i].c);
	}
	as->nr = res;
	return res;
}

static
int check_BATs( ascii *as ){
	ascii_io *fmt = as->format;
	int i;
	int cnt = BATcount(fmt[0].c);
	oid base = fmt[0].c->hseqbase;

	if (!BAThdense(fmt[0].c)) return -1;

	for (i=0; i<as->nr_attrs; i++){
		if (BATcount(fmt[i].c) != cnt ||
		    fmt[i].c->hseqbase != base)
			return -1;

		fmt[i].p = (ptr)BUNfirst(fmt[i].c);
	}
	return base;
}

static
int create_bats( ascii *as ){
	ascii_io *fmt = as->format;
	int i;

	for (i=0; i<as->nr_attrs; i++){
		fmt[i].c = void_bat_create(fmt[i].adt,as->nr);
	}
	return 0;
}

static
BAT *collect_bats( ascii *as ){
	BAT *bats = BATnew(TYPE_str,TYPE_bat,as->nr_attrs);
	ascii_io *fmt = as->format;
	int i;
	int cnt = BATcount(fmt[0].c);

	for (i=0; i<as->nr_attrs; i++){
		BUNins(bats,(ptr)fmt[i].name, (ptr)&fmt[i].c->batCacheid);
		if (cnt != BATcount(fmt[i].c)){
		        GDKerror("Error: counts are not equal\n");
			return NULL;
		}
		BBPunfix( fmt[i].c->batCacheid );
	}
	return bats;
}

static INLINE
int myisspace(int s ){
        if (s==(int)' ' || s==(int)'\t' || s==(int)'\n'){
                return 1;
        }
        return 0;
}

static INLINE
char *strip( char *s, char *e ){
        while(myisspace((int)*s)){
		s++;
	}
	e--;
        while(myisspace((int)*e)){
		e--;
	}
	e++;
	if (e && *e){
		*e = 0;
	}
	return s;
}

static INLINE
void insert_val( ascii_io *fmt, char *s, char *e ){
	int c1, c = BATcount(fmt->c);
	ptr *adt;
	adt = ADT_fromStr( fmt->adt, strip(s,e) ); 
	
	BUNins(fmt->c,&int_nil,adt);
	c1 = BATcount(fmt->c);
	if (c1 != c+1)
		printf("%ld not inserted %s\n", (long)adt, s);
	GDKfree(adt);
}

static INLINE
int insert_line( ascii *as, char *line ){
	ascii_io *fmt = as->format;
        char *s,*e = 0;
	int i,quotes = 0;
	int first = 0;
	for( i = 0; i<as->nr_attrs-1; i++){
		first = 1;
		s=line;
		while(*line){
			if (*line == *(fmt[i].sep) && 
			     strncmp( fmt[i].sep, line, fmt[i].seplen) == 0 ){
				e = line; /*strstr( line, fmt[i].sep ); */
				break;
		     	} else if(first && *line == '\"' && *(line-1) != '\\'){
				quotes = 1;
				line++;
				while( *line && *line!='\"') line++;
				if (*line) line++;
				else return -1;
			} else {
				if (first && !isspace(*line))
					first = 0;
				line++;
			}
		}
		if (e){
			char *end = e;
			if (quotes){
				quotes = 0;
				s = strchr(s, '\"');
				if (!s) return -1;
				s++;
				e = strchr(s, '\"');
			}
			*e = 0;
			insert_val( &fmt[i], s, e );
			line = end + fmt[i].seplen;
		} else {
		        GDKerror("Error: missing sep %s line %d field %d\n", fmt->sep, BATcount(fmt->c), i);
			return -1;
		}
		e = 0;
	}
	s=line;
	first = 1;
	while(*line){
		if (*line == *(fmt[as->nr_attrs-1].sep) && 
		     strncmp( fmt[as->nr_attrs-1].sep, line, 
			      fmt[as->nr_attrs-1].seplen) == 0 ){
			e = line; /*strstr( line, fmt[as->nr_attrs-1].sep ); */
			break;
		} else if(first && *line == '\"' && *(line-1) != '\\'){
			quotes = 1;
			line++;
			while( *line && *line!='\"') line++;
			if (*line) line++;
			else return -1;
		} else {
			if (first && !isspace(*line))
				first = 0;
			line++;
		}
	}
	if (!e) e = line;
	if (e){
		char *end = e;
		if (quotes){
			quotes = 0;
			s = strchr(s, '\"');
			if (!s) return -1;
			s++;
			e = strchr(s, '\"');
		}
		*e = 0;
		insert_val( &fmt[as->nr_attrs-1], s, e );
		line = end + fmt[as->nr_attrs-1].seplen;
	} else {
		GDKerror("Error: missing sep %s line %d field %d\n", fmt->sep, BATcount(fmt->c), i);
		return -1;
	}
	e = 0;
	return 0;
}

static INLINE
int dump_line( char **buf, int *len, ascii_io *fmt, stream *fd, int nr_attrs, int id ){
	int i;
	for( i = 0; i<nr_attrs; i++){
		int l =
		 ADT_toStr(buf, len, fmt[i].adt, (char*)bun_tail(fmt[i].c,id));
		(void)fd->write( fd, *buf, 1, l );
		(void)fd->write( fd, fmt[i].sep, 1, fmt[i].seplen );
	}
	return 0;
}

static INLINE
int output_line( char **buf, int *len, ascii_io *fmt, stream *fd, int nr_attrs, ptr id ){
	int i;
	for( i = 0; i<nr_attrs; i++){
		fmt[i].p = BUNfnd( fmt[i].c, id );
		if (fmt[i].p == 0)
			break;
	}
	if ( i == nr_attrs ){
	    for( i = 0; i<nr_attrs; i++){
		if (fmt[i].adt == TYPE_str){
			char *s = (char*)BUNtail(fmt[i].c, fmt[i].p);
			(void)fd->write( fd, "\"", 1, 1 );
			if (GDK_STRNIL(s))
				(void)fd->write( fd, "nil", 1, 3 );
			else {
				int l = strlen(s);
				(void)fd->write( fd, s, 1, l );
			}
			(void)fd->write( fd, "\"", 1, 1 );
		} else {
			int l = ADT_toStr(buf, len, fmt[i].adt, 
			(char*)BUNtail(fmt[i].c,fmt[i].p));
			(void)fd->write( fd, *buf, 1, l );
		}
		(void)fd->write( fd, fmt[i].sep, 1, fmt[i].seplen );
	    }
	}
	return 0;
}

static INLINE
int output_line_dense( char **buf, int *len, ascii_io *fmt, stream *fd, int nr_attrs ){
	int i;
	for( i = 0; i<nr_attrs; i++){
		char *p = BUNtail(fmt[i].c, fmt[i].p);
		if (fmt[i].adt == TYPE_str){
			(void)fd->write( fd, "\"", 1, 1 );
			if (GDK_STRNIL(p))
				(void)fd->write( fd, "nil", 1, 3 );
			else {
				int l = strlen(p);
				(void)fd->write( fd, p, 1, l );
			}
			(void)fd->write( fd, "\"", 1, 1 );
		} else {
			int l = ADT_toStr(buf, len, fmt[i].adt, p);
			(void)fd->write( fd, *buf, 1, l );
		}
		(void)fd->write( fd, fmt[i].sep, 1, fmt[i].seplen );
		fmt[i].p = BUNnext( fmt[i].c, fmt[i].p );
	}
	return 0;
}

static INLINE
int output_line_lookup( char **buf, int *len, ascii_io *fmt, stream *fd, int nr_attrs, int id ){
	int i;
	for( i = 0; i<nr_attrs; i++){
		char *p = BUNtail(fmt[i].c, BUNptr(fmt[i].c,id+BUNindex(fmt[i].c,BUNfirst(fmt[i].c))));
		if (fmt[i].adt == TYPE_str){
			char *s = (char*)p;
			(void)fd->write( fd, "\"", 1, 1 );
			if (GDK_STRNIL(s))
				(void)fd->write( fd, "nil", 1, 3 );
			else {
				int l = strlen(s);
				(void)fd->write( fd, s, 1, l );
			}
			(void)fd->write( fd, "\"", 1, 1 );
		} else {
			int l = ADT_toStr(buf, len, fmt[i].adt, p);
			(void)fd->write( fd, *buf, 1, l );
		}
		(void)fd->write( fd, fmt[i].sep, 1, fmt[i].seplen );
	}
	return 0;
}


static
int load_file( ascii *as, bstream *b ){
	int eof = 0, done = 0, i = 0;
	char *sep = as->format[as->nr_attrs-1].sep;
        int seplen = as->format[as->nr_attrs-1].seplen;

	if (ascii_io_debug)
		stream_printf( GDKerr, "load_file\n");

	while(!eof && (as->nr < 0 || i < as->nr)){
		int l;
		char *s, *end;
		if ((l=bstream_read(b, b->size - (b->len - b->pos) )) == 0 )
			eof = 1;
		end = b->buf + b->len;
		s = b->buf + b->pos;
		*end = '\0';
		done = 0;
		while( s < end ){
			char *e = strstr( s, sep );
			if (e){
				*e = '\0';
				if (insert_line(as, s ) < 0)
					printf("value %s not inserted\n", s);	
				s = e + seplen;
				done = 1;
			} else if (eof && s + as->nr_attrs < end){
				if (insert_line(as, s ) < 0)
					printf("value %s not inserted\n", s);	
				s = end;
			} else {
				if (!done){ /* nothing found in current buf
					     * ie. need to enlarge 
					     */
					if ((l=bstream_read(b, b->size*16 )) == 0 )
						eof = 1;
					end = b->buf + b->len;
					s = b->buf + b->pos;
					*end = '\0';
					continue;
				}
				break;
			}
			b->pos = (s-b->buf);
			i++;
			if (ascii_io_debug && (i%100000) == 0)
				stream_printf(GDKerr, "inserted %d\n", i);
			if (as->nr > 0 && i >= as->nr)
				break;
		}
	}
	as->nr = i;
	return 0;
}

static
int dump_file( ascii *as, stream *fd ){
        int i = 0;
	int len = BUFSIZ;
	char *buf = GDKmalloc(len);
	for( i=0; i<as->nr; i++ ){
		if (dump_line( &buf, &len, as->format, fd, as->nr_attrs, i )<0){
			GDKfree(buf);
			return -1;
		}
		if (ascii_io_debug && (i%1000000) == 0)
			stream_printf(GDKerr, "dumped %d lines\n", i);
        } 
	GDKfree(buf);
	return 0;
}

static
int output_file( ascii *as, BAT *order, stream *fd ){
	int len = BUFSIZ; 
	char *buf = GDKmalloc(len);
	BUN p,q;
        int i = 0;
	as->nr = BATcount(order);
	
	BATloop( order, p, q){
		ptr h = BUNhead(order, p);
		if(output_line( &buf, &len,as->format, fd, as->nr_attrs, h )<0){
			GDKfree(buf);
			return -1;
		}
		i++;
		if (ascii_io_debug && (i%1000000) == 0)
			fprintf(stderr, "dumped %d lines\n", i);
        } 
	GDKfree(buf);
	return i;
}

static
int output_file_dense( ascii *as, stream *fd ){
	int len = BUFSIZ; 
	char *buf = GDKmalloc(len);
        int i = 0;
	
	for(i=0; i<as->nr; i++){
		if(output_line_dense( &buf, &len, as->format, fd, as->nr_attrs )<0){
			GDKfree(buf);
			return -1;
		}
		if (ascii_io_debug && (i%1000000) == 0)
			fprintf(stderr, "dumped %d lines\n", i);
        } 
	GDKfree(buf);
	return i;
}

static
int output_file_ordered( ascii *as, BAT *order, stream *fd, int base ){
	int len = BUFSIZ; 
	char *buf = GDKmalloc(len);
	BUN p,q;
        int i = 0;
	
	BATloop( order, p, q){
		oid h = *(oid*)BUNhead(order, p) - base;
		if(output_line_lookup( &buf, &len, as->format, fd, as->nr_attrs, h )<0){
			GDKfree(buf);
			return -1;
		}
		if (ascii_io_debug && (i%1000000) == 0)
			fprintf(stderr, "dumped %d lines\n", i);
        } 
	GDKfree(buf);
	return i;
}

#define SIZE 1*1024*1024
BAT *ASCIIload( BAT *names, BAT *seps, BAT *types, 
		 char *datafile, int nr ){
	BAT *res;
	stream *s = open_rastream( datafile );
	bstream *b = NULL;

	if (s->errnr){
		GDKerror("could not open file %s\n", datafile );
		return NULL;
	}
	res = ASCIIinput( names, seps, types, b=bstream_create(s, SIZE), nr );
	bstream_destroy(b);
	s->close(s);
	s->destroy(s);
	return res;
}

BAT *ASCIIinput( BAT *names, BAT *seps, BAT *types, bstream *s, int nr ){
	BAT *bats = NULL;
	ascii as;

	as.nr_attrs = 0;
	as.nr = nr;
	if (create_loadformat( &as, names, seps, types) >= 0 && 
	    create_bats( &as ) >= 0){
		if (load_file( &as, s )>=0)
			bats = collect_bats( &as );
	}
	destroy_format( &as );
	return bats;
}

void ASCIIdump( BAT *names, BAT *seps, BAT *bats, 
	      char *datafile, int nr ){
	ascii as;

	as.nr_attrs = 0;
	as.nr = nr;
	if (create_dumpformat( &as, names, seps, bats) >= 0 && 
	    assign_BATs( &as, bats ) >=  0){
		stream *s = open_wastream( datafile );
		if (!s->errnr && dump_file( &as, s ) >= 0){
			stream_printf(GDKerr, "saved in %s\n", datafile );
		}
		if (s->errnr){
		 	GDKerror("could not open file %s\n", datafile );
		} else {
			s->close(s);
		}
		s->destroy(s);
	}
	destroy_format( &as );
}
int ASCIIoutput( BAT *order, BAT *seps, BAT *bats, stream *s ){
	ascii as;
	int base = -1;

	as.nr_attrs = 0;
	as.nr = -1;
	if (create_dumpformat( &as, NULL, seps, bats) >= 0 && 
	    assign_BATs( &as, bats ) >=  0){
		if ((base = check_BATs( &as )) >= 0 ){
			if (BAThdense(order) && 
 			    order->hseqbase == base && BATcount(order) == as.nr)
				output_file_dense( &as, s );
			else
				output_file_ordered( &as, order, s, base );
		} else {
			output_file( &as, order, s ); 
		}
	}
	destroy_format( &as );
	return as.nr;
}

int init_ascii_io(int *debug){
	ascii_io_debug = *debug;
	return GDK_SUCCEED;
}
int ascii_io_load( BAT **bats, BAT *names, BAT* seps, BAT* types, str datafile, int *nr){
	*bats = ASCIIload( names, seps, types, datafile, *nr );
	if (*bats) {
		return GDK_SUCCEED;
	} else {
		return GDK_FAIL;
	}
}
int ascii_io_dump( BAT *names, BAT* seps, BAT* bats, str datafile, int *nr){
	ASCIIdump( names, seps, bats, datafile, *nr );
	return GDK_SUCCEED;
}
int ascii_io_output( BAT *order, BAT* seps, BAT* bats, Stream *s ){
	ASCIIoutput( order, seps, bats, *(stream**)s );
	return GDK_SUCCEED;
}

@mil
module(ascii_io,io);

#ascii_io_debug(1);

fp := fopen ( "format", "w+" );
fputs( "key,\",\",str\n", fp);
fputs( "a_io_test,\"\\n\",dbl\n", fp);
fclose( fp );

fp := fopen ( "data", "w+" );
fputs( "test, 0.12345\n", fp);
fputs( "second line, 9.0\n", fp);
fclose( fp );

bats := load("format","data",10);
bats := load_data(load_format(path+"/format"), path+"/test100k", 100000);
bats.print;
a := bats.find("key").reverse().join( bats.find("a_io_test") );
a.print;
dump_data(load_format("format"), "data", -1);

fp := fopen ( "data", "r" );
s := fgets( fp ); 
s.print();
fclose( fp );
quit;
