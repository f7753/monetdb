@f ascii_io
@t The ascio io Module
@a Niels Nes
@d 12/01/2001
@m 
.module ascii_io;

.COMMAND ascii_io_debug( int debug ) = ASCIIdebug; ""

.COMMAND load( str formatfile, str datafile, int nr ) : 
	BAT[str,BAT] = ASCIIload; ""
.COMMAND dump( BAT[str,BAT] bats, str formatfile, str datafile, int nr ) 
	= ASCIIdump; ""

.LOAD
	proc bat_persistent(b,name):={
		b.rename(name);
		b.persists(true);
	}

	proc bats_persistent(b):={
		if (b.exist("key")){
			var key := b.find("key");
			b := b.diff(b.reverse.select("key").reverse);
			b@batloop(){
				t := k.reverse.join($t);	
				bat_persistent(t,$h);
			}
		} else {
			b@batloop(){
				bat_persistent($t,$h);
			}
		}
	}
.END;

.END ascii_io;
@h
#ifndef _ASCII_IO_H_
#define _ASCII_IO_H_

#endif
@c

#include "ascii_io.h"
#include <config.h>
#include <gdk.h>

#include <stdio.h>
#include <string.h>
#include <ctype.h>
#ifdef HAVE_LIBZ
	#include <zlib.h>
#endif

#define MAXLINE 4096
#define MAXATTR 256
#define EXT_LEN 4

typedef struct ascii_io_t {
	char *name;
	char *sep;
	int seplen;
	char *type;
	int  adt;
	BAT *c;
	int reverse;
} ascii_io;

typedef struct ascii_load_t {
	int nr;
	int nr_attrs;
	ascii_io format[MAXATTR];
} ascii;

ptr bun_tail(BAT *b, int nr){
	REGISTER int _i = BUNindex((b),BUNfirst((b)));
	return BUNtail(b, BUNptr(b,_i+nr));
}

BAT *void_bat_create(int ctype,int type,int d1,int d2,int nr) {
	BAT *b = BATnew(TYPE_void,type,nr);
	BATseqbase(b,0);
	return b;
}

ptr *ADT_fromStr( int type, char *s){
        int l = 0;
        ptr *res = NULL;
        if (type == TYPE_str)
                res = (ptr*)GDKstrdup(s);
        else
                BATatoms[type].atomFromStr(s, &l, (ptr)&res);
        return res;
}

char *ADT_toStr( int type, ptr a){
	int l = 0;
	char *res = NULL;
        if (type == TYPE_str)
                res = (char*)GDKstrdup((char*)a);
        else
                BATatoms[type].atomToStr( &res, &l, a);
	return res;
}


static void get_extention( char *file, char *ext)
{
   	int j = 0;
	char *ext_start = strrchr( file, '.' );

	if (ext_start){
	    ext_start++;
            for (j = 0; j < EXT_LEN-1 && *ext_start; j++, ext_start++ )
                ext[j] = tolower(*ext_start);
        }
        ext[j] = '\0';
}


static int ascii_io_debug = 0;
  
char *next_field( char *s, char **end, char sep ){
	char *e = s;
	while (e && *e){
		if (*e == '"'){
			s = ++e;
			e = strchr( e, '"' );
			if (e){
				*e = 0;
				*end = strchr( ++e, sep );
				(*end)++;
			} else {
				fprintf( GDKerr, "Missing seperator '%c'\n", 
					sep );
			}
			return GDKstrdup( s );
		} else if (*e == sep || *e == '\n' ){
			*e = 0;
			*end = ++e;
			return GDKstrdup( s );
		}
		e++;
	}
	if (s)
		return GDKstrdup(s);
	return GDKstrdup("");
}

int parse_header_line( ascii_io *format, char *s ){
	format->name = next_field( s, &s, ',' );
	format->sep = next_field( s, &s, ',' );
	format->seplen = strlen( format->sep );
	format->type = next_field( s, &s, ',' );
	format->adt = ATOMindex( format->type );
	format->reverse = 0;
	if (*format->name == '-'){
		format->reverse = 1;
		format->name = format->name+1;
	}
	if (format->adt < 0 ){
		fprintf(GDKerr, "Error: cannot find type %s\n", format->type );
		return -1;
	}
	if (ascii_io_debug)
	 fprintf(GDKerr,"%s %s %s\n", format->name, format->sep, format->type );
	return 0;
}

int parse_header( ascii_io *format, FILE *fd ){
	int i = 0;
	char line[MAXLINE];
	while( fgets(line, MAXLINE, fd) ){
		if (parse_header_line( &format[i++], line ) < 0)
			return -1;
	}
	return i;
}

int create_bats( ascii *as ){
	ascii_io *fmt = as->format;
	int i;

	for (i=0; i<as->nr_attrs; i++){
		fmt[i].c = void_bat_create(0,fmt[i].adt,0,0,as->nr);
	}
	return 0;
}

int assign_bats( ascii *as, BAT *bats ){
	ascii_io *fmt = as->format;
	int i;

	for (i=0; i<as->nr_attrs; i++){
		bat *id = (bat*)BUNfnd(bats,fmt[i].name);
		if (id != NULL){
			fmt[i].c = BATdescriptor(*id);
			if (fmt[i].adt != fmt[i].c->ttype){
				fprintf(GDKerr, "wrong type %s\n", fmt[i].type);
				return -1;
			} 
		} else {
			fprintf(GDKerr, "missing bat %s\n", fmt[i].name );
			return -1;
		}
	}
	return 0;
}

BAT *bats( ascii *as ){
	int i;
	ascii_io *fmt = as->format;
	BAT *bats = BATnew(TYPE_str, TYPE_bat, as->nr_attrs );

	for (i = 0; i<as->nr_attrs; i++){
		BUNins(bats, fmt[i].name, (ptr)&fmt[i].c->batCacheid );
	}
	return bats;
}

INLINE
int myisspace(int s ){
        if (s==(int)' ' || s==(int)'\t' || s==(int)'\n'){
                return 1;
        }
        return 0;
}

INLINE
char *strip( char *s, char *e ){
        while(myisspace((int)*s)){
		s++;
	}
	e--;
        while(myisspace((int)*e)){
		e--;
	}
	e++;
	if (e && *e){
		*e = 0;
	}
	return s;
}

INLINE
void insert_val( ascii_io *fmt, char *s, char *e ){
	ptr *adt;
	adt = ADT_fromStr( fmt->adt, strip(s,e) ); 
	BAT_insert( fmt->c, adt);
	GDKfree( (char*)fmt->adt );
}

INLINE
int insert_line( ascii *as, char *line ){
	ascii_io *fmt = as->format;
        char *s,*e;
	int i;
	for( i = 0; i<as->nr_attrs-1; i++){
		s=line;
		while(*line!=*(fmt[i].sep)) line++;
		e = strstr( line, fmt[i].sep ); 
		if (e){
			*e = 0;
			insert_val( &fmt[i], s, e );
			line = e + fmt[i].seplen;
		} else {
		        fprintf(GDKerr, "Error: missing sep %s\n", fmt->sep);
			return -1;
		}
	}
	s=line;
	while(*line!='\n') line++;
	e = line; /*strchr( line, '\n' );*/
	if (e){
		*e = 0;
		insert_val( &fmt[as->nr_attrs-1], s, e );
	} else {
	        fprintf(GDKerr, "Error: missing newline\n" );
		return -1;
	}
	return 0;
}

INLINE
int dump_line( ascii_io *fmt, FILE *fd, int nr_attrs, int id ){
	char *str;
	int i;
	for( i = 0; i<nr_attrs-1; i++){
		str = ADT_toStr(fmt[i].adt, bun_tail(fmt[i].c,id));
		fprintf( fd, "%s%s", str, fmt[i].sep );
		GDKfree(str);
	}
	str = ADT_toStr(fmt[i].adt, bun_tail(fmt[i].c,id));
	fprintf( fd, "%s\n", str );
	GDKfree(str);
	return 0;
}

#ifdef HAVE_LIBZ
INLINE
int dump_gzline( ascii_io *fmt, gzFile *fd, int nr_attrs, int id ){
	char *str;
	int i;
	for( i = 0; i<nr_attrs-1; i++){
		str = ADT_toStr(fmt[i].adt, bun_tail(fmt[i].c,id));
		(void)gzputs( fd, str );
		(void)gzputs( fd, fmt[i].sep );
		GDKfree(str);
	}
	str = ADT_toStr(fmt[i].adt, bun_tail(fmt[i].c,id));
	(void)gzputs( fd, str );
	gzprintf(fd, "\n");
	GDKfree(str);
	return 0;
}
#endif

int load_file( ascii *as, FILE *fd ){
        int i = 0;
	char line[MAXLINE];
	for( i=0; i<as->nr && fgets(line, MAXLINE, fd); i++ ){
		if (strlen(line)>1 && insert_line( as, line ) < 0)
			return -1;
		if (ascii_io_debug && (i%1000000) == 0)
			fprintf(GDKerr, "inserted %d\n", i);
        } 
	fprintf(GDKerr, "inserted %d\n", i);
	return 0;
}

#ifdef HAVE_LIBZ
int load_gzfile( ascii *as, gzFile *fd ){
        int i = 0;
	char line[MAXLINE];
	for( i=0; i<as->nr && gzgets(fd, line, MAXLINE); i++ ){
		if (strlen(line)>1 && insert_line( as, line ) < 0)
			return -1;
		if (ascii_io_debug && (i%1000000) == 0)
			fprintf(GDKerr, "inserted %d\n", i);
        } 
	return 0;
}
#endif

#ifdef HAVE_LIBBZ
int load_bzfile( ascii *as, BZFILE *fd ){
        int i = 0;
	char buf[MAXLINE];
	char *curpos = 0;
	char line[MAXLINE];
	BZ2_bzread( fd, buf, MAXLINE);
	for( i=0; i<as->nr; i++ ){
		int pos = 0;
		while(buf[pos]!='\n' && pos+curpos<MAXLINE) pos++;
		if ((pos + curpos > MAXLINE) 

		insert_line( as, buf ) < 0)
			return -1;
		line =
		if (ascii_io_debug && (i%1000000) == 0)
			fprintf(GDKerr, "inserted %d\n", i);
        } 
	return 0;
}
#endif

int dump_file( ascii *as, FILE *fd ){
        int i = 0;
	for( i=0; i<as->nr; i++ ){
		if (dump_line( as->format, fd, as->nr_attrs, i ) < 0)
			return -1;
		if (ascii_io_debug && (i%1000000) == 0)
			fprintf(GDKerr, "dumped %d lines\n", i);
        } 
	return 0;
}

#ifdef HAVE_LIBZ
int dump_gzfile( ascii *as, gzFile *fd ){
        int i = 0;
	for( i=0; i<as->nr; i++ ){
		if (dump_gzline( as->format, fd, as->nr_attrs, i ) < 0)
			return -1;
		if (ascii_io_debug && (i%1000000) == 0)
			fprintf(GDKerr, "dumped %d lines\n", i);
        } 
	return 0;
}
#endif

int ASCIIload( BAT **res, char *formatfile, char *datafile, int nr ){
	FILE *fd = fopen( formatfile, "r");
	if (fd){
		ascii as;
  		char    ext[EXT_LEN];

		as.nr_attrs = parse_header( as.format, fd);
  		get_extention(datafile, ext);

		fclose(fd);
		as.nr = nr;
		if (as.nr_attrs < 0 || create_bats( &as ) < 0)
			return GDK_FAIL;
#ifdef HAVE_LIBZ
  		if (!strcmp(ext,"gz" )){
			gzFile filep = gzopen( datafile, "r");
			if (filep && load_gzfile( &as, filep )>=0)
			    *res = bats( &as );
			if (filep == NULL){
			 	fprintf(GDKerr, 
				"could not open file %s\n", datafile );
				return GDK_FAIL;
			}
			gzclose(filep);
			return GDK_SUCCEED;
		}
#endif

#ifdef HAVE_LIBBZ
  		if (!strcmp(ext,"bz2" )){
			BZFILE filep = BZ2_bzopen( datafile, "r");
			if (filep && load_bzfile( &as, filep )>=0)
			    *res = bats( &as );
			if (filep == NULL){
			 	fprintf(GDKerr, 
				"could not open file %s\n", datafile );
				return GDK_FAIL;
			}
			BZ2_bzclose(filep);
			return GDK_SUCCEED;
		}
#endif
		{
			FILE *filep = fopen( datafile, "r");
			if (filep && load_file( &as, filep ) >=0 )
			    *res = bats( &as );
			if (filep == NULL){
				fprintf(GDKerr, 
				 	"could not open file %s\n", datafile );
				return GDK_FAIL;
			}
			fclose(filep);
		}
	}
	return GDK_SUCCEED;
}

int ASCIIdump( BAT *bats, char *formatfile, char *datafile, int nr ){
	FILE *fd = fopen( formatfile, "r");
	if (fd){
		int cnt;
		ascii as;
  		char    ext[EXT_LEN];

		as.nr_attrs = parse_header( as.format, fd);

  		get_extention(datafile, ext);
		fclose(fd);

		as.nr = nr;
		if (as.nr_attrs < 0 ||
		   (cnt = BATcount( bats )) < nr || assign_bats( &as, bats )){
			return GDK_FAIL;
		}
#ifdef HAVE_LIBZ
  		if (!strcmp(ext,"gz" )){
			gzFile filep = gzopen( datafile, "w");
			if (filep && dump_gzfile( &as, filep ) >= 0){
				printf("saved in %s\n", datafile );
			}
			gzclose(filep);
			return GDK_SUCCEED;
		}
#endif
		{
			FILE *filep = fopen( datafile, "w");
			if (filep && dump_file( &as, filep ) >= 0){
				printf("saved in %s\n", datafile );
			}
			fclose(filep);
		}
		
	}
	return GDK_SUCCEED;
}

int ASCIIdebug(int *debug){
	ascii_io_debug = *debug;
	return GDK_SUCCEED;
}

@mil
module(ascii_io,io);

fp := fopen ( "format", "w+" );
fputs( "key,\",\",str\n", fp);
fputs( "a_io_test,\",\",dbl\n", fp);
fclose( fp );

fp := fopen ( "data", "w+" );
fputs( "test, 0.12345\n", fp);
fputs( "second line, 9.0\n", fp);
fclose( fp );

bats := load("format","data",10);
a := bats.find("key").reverse().join( bats.find("a_io_test") );
a.print;
dump(bats, "format","data",10);

fp := fopen ( "data", "r" );
s := fgets( fp ); 
s.print();
fclose( fp );
quit;
