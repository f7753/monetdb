@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at 
@' http://monetdb.cwi.nl/Legal/MonetDBPL-1.0.html
@' 
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@' 
@' The Original Code is the Monet Database System.
@' 
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2002 CWI.  
@' All Rights Reserved.
@' 
@' Contributor(s):
@' 		Martin Kersten <Martin.Kersten@cwi.nl>
@' 		Peter Boncz <Peter.Boncz@cwi.nl>
@' 		Niels Nes <Niels.Nes@cwi.nl>
@' 		Stefan Manegold  <Stefan.Manegold@cwi.nl>

@f streams
@a Niels Nes
@* An simple interface to streams 
This interface can be used to open 'non compressed, gzipped, bz2zipped' 
data files. 

@m
.MODULE streams;
.USE io;

    .ATOM stream = ptr;
    .END;

.COMMAND open_rstream( str filename ) : stream = stream_open_rstream;
	"open a file stream for reading"
.COMMAND open_wstream( str filename ) : stream = stream_open_wstream;
	"open a file stream for writing"
.COMMAND open_rastream( str filename ) : stream = stream_open_rastream; 
	"open ascii file stream for reading"
.COMMAND open_wastream( str filename ) : stream = stream_open_wastream; 
	"open ascii file stream for writing"

.COMMAND socket_rstream( int socket, str name ) : stream = 
	stream_socket_rstream; "open a socket stream for reading"
.COMMAND socket_wstream( int socket, str name ) : stream = 
	stream_socket_wstream; "open a socket stream for writing"
.COMMAND socket_rastream( int socket, str name ) : stream = 
	stream_socket_rastream; "open ascii socket stream for reading"
.COMMAND socket_wastream( int socket, str name ) : stream = 
	stream_socket_wastream; "open ascii socket stream for writing"

.COMMAND file_rstream( fstream file, str name ) : stream = 
	stream_file_rstream; "open a file stream for reading"
.COMMAND file_wstream( fstream file, str name ) : stream = 
	stream_file_wstream; "open a file stream for writing"
.COMMAND file_rastream( fstream file, str name ) : stream = 
	stream_file_rastream; "open ascii file stream for reading"
.COMMAND file_wastream( fstream file, str name ) : stream = 
	stream_file_wastream; "open ascii file stream for writing"

.COMMAND block_stream( stream s ) : stream = 
	open_block_stream; "open a block based stream"

.COMMAND stream_write( stream s, str data ) = stream_write_string;
	"write data on the stream"

.COMMAND stream_writeInt( stream s, int data ) = stream_writeInt_wrap;
	"write an integer on the stream"

.COMMAND stream_read( stream s ) : str = stream_read_string;
	"read data from the stream"

.COMMAND stream_flush( stream s ) = stream_flush;
	"flush the stream"

.COMMAND stream_close( stream s ) = stream_close_stream; 
	"close and destroy the stream s"

    .ATOM buffer = ptr;
    .END;

.COMMAND buffer_create( int size ) : buffer = buffer_create_wrap;
	"create a buffer of the given size"

.COMMAND buffer_destroy( buffer b ) = buffer_destroy_wrap;
	"destroy buffer"

.COMMAND buffer_rastream( buffer b, str name ) : stream = buffer_rastream_wrap;
	"create a buffer read stream"

.COMMAND buffer_wastream( buffer b, str name ) : stream = buffer_wastream_wrap; 
	"create a buffer write stream"

.END streams;
@h
#ifndef _STREAMS_H_
#define _STREAMS_H_

#include "stream.h"
#include <blob.h>
#include <io.h>
#include "streams.proto.h"

#endif /*_STREAMS_H_*/
@c
#include <gdk.h>
#include "streams.h"
#include <stdio.h>

int stream_open_rstream( stream *S, str filename ){
	if ((*(stream**)S = open_rstream( filename )) == NULL){
		return GDK_FAIL; 
	} else {
		return GDK_SUCCEED;
	}
}
int stream_open_wstream( stream *S, str filename ){
	if ((*(stream**)S = open_wstream( filename )) == NULL){
		return GDK_FAIL; 
	} else {
		return GDK_SUCCEED;
	}
}
int stream_open_rastream( stream *S, str filename ){
	if ((*(stream**)S = open_rastream( filename )) == NULL){
		return GDK_FAIL; 
	} else {
		return GDK_SUCCEED;
	}
}
int stream_open_wastream( stream *S, str filename ){
	if ((*(stream**)S = open_wastream( filename )) == NULL){
		return GDK_FAIL; 
	} else {
		return GDK_SUCCEED;
	}
}
int stream_socket_rstream( stream *S, int *socket, str name ){
	if ((*(stream**)S = socket_rstream( *socket, name )) == NULL){
		return GDK_FAIL; 
	} else {
		return GDK_SUCCEED;
	}
}
int stream_socket_wstream( stream *S, int *socket, str name ){
	if ((*(stream**)S = socket_wstream( *socket, name )) == NULL){
		return GDK_FAIL; 
	} else {
		return GDK_SUCCEED;
	}
}
int stream_socket_rastream( stream *S, int *socket, str name ){
	if ((*(stream**)S = socket_rastream( *socket, name )) == NULL){
		return GDK_FAIL; 
	} else {
		return GDK_SUCCEED;
	}
}
int stream_socket_wastream( stream *S, int *socket, str name ){
	if ((*(stream**)S = socket_wastream( *socket, name )) == NULL){
		return GDK_FAIL; 
	} else {
		return GDK_SUCCEED;
	}
}
int stream_file_rstream( stream *S, fstream *file, str name ){
	if ((*(stream**)S = file_rstream( *file, name )) == NULL){
		return GDK_FAIL; 
	} else {
		return GDK_SUCCEED;
	}
}
int stream_file_wstream( stream *S, fstream *file, str name ){
	if ((*(stream**)S = file_wstream( *file, name )) == NULL){
		return GDK_FAIL; 
	} else {
		return GDK_SUCCEED;
	}
}
int stream_file_rastream( stream *S, fstream *file, str name ){
	if ((*(stream**)S = file_rastream( *file, name )) == NULL){
		return GDK_FAIL; 
	} else {
		return GDK_SUCCEED;
	}
}
int stream_file_wastream( stream *S, fstream *file, str name ){
	if ((*(stream**)S = file_wastream( *file, name )) == NULL){
		return GDK_FAIL; 
	} else {
		return GDK_SUCCEED;
	}
}

int stream_write_string( stream *S, str data ){
	stream *s = *(stream**)S;
	s->write( s, data, 1, strlen(data));
	return GDK_SUCCEED;
}

int stream_writeInt_wrap( stream *S, int *data ){
	stream *s = *(stream**)S;
	s->writeInt( s, *data);
	return GDK_SUCCEED;
}

#define CHUNK (64*1024)
int stream_read_string( str *res, stream *S ){
	stream *s = *(stream**)S;
	int len = 0;
	int size = CHUNK + 1;
	char *buf = GDKmalloc(size), *start = buf;

	while ((len = s->read(s, start, 1, CHUNK)) == CHUNK){
		size += CHUNK;
		buf = GDKrealloc(buf, size); 
		start = buf + size - CHUNK - 1;
		*start = '\0';
	}
	start += len;
	*start = '\0';
	*res = buf;
	return GDK_SUCCEED;
}

int stream_flush( stream *S ){
	stream *s = *(stream**)S;
	s->flush( s );
	return GDK_SUCCEED;
}

int stream_close_stream( stream *S ){
	stream *s = *(stream**)S;
	s->close( s );
	s->destroy( s );
	return GDK_SUCCEED;
}

int open_block_stream( stream *S, stream *is ){
	if ((*(stream**)S = block_stream( *(stream**)is )) == NULL){
		return GDK_FAIL; 
	} else {
		return GDK_SUCCEED;
	}
}

int buffer_create_wrap( buffer *b, int *size){
	if ((*(buffer**)b = buffer_create( *size )) == NULL){
		return GDK_FAIL; 
	} else {
		return GDK_SUCCEED;
	}
}
int buffer_destroy_wrap( buffer *b ){
	buffer_destroy( *(buffer**)b );
	return GDK_SUCCEED;
}
int buffer_rastream_wrap( stream *S, buffer *b, str name ){
	if ((*(stream**)S = buffer_rastream( *(buffer**)b, name )) == NULL){
		return GDK_FAIL; 
	} else {
		return GDK_SUCCEED;
	}
}
int buffer_wastream_wrap( stream *S, buffer *b, str name ){
	if ((*(stream**)S = buffer_wastream( *(buffer**)b, name )) == NULL){
		return GDK_FAIL; 
	} else {
		return GDK_SUCCEED;
	}
}
@mil

module(streams);

s := open_wastream( "test.mil" );
stream_write( s, "test\n" );
stream_close( s );

s := open_rastream( "test.mil" );
st := stream_read( s );
stream_close( s );
print(st);
quit;

