@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@' 
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@' 
@' The Original Code is the Monet Database System.
@' 
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2003 CWI.
@' All Rights Reserved.
@' 
@' Contributor(s):
@' 		Martin Kersten <Martin.Kersten@cwi.nl>
@' 		Peter Boncz <Peter.Boncz@cwi.nl>
@' 		Niels Nes <Niels.Nes@cwi.nl>
@' 		Stefan Manegold  <Stefan.Manegold@cwi.nl>

@f streams
@a Niels Nes
@* An simple interface to streams 
This interface can be used to open 'non compressed, gzipped, bz2zipped' 
data files. 

@m
.MODULE streams;

    .ATOM Stream = ptr;
    .END;

.COMMAND stdin() : Stream = io_stdin; 
	"return the input stream to the database client"
.COMMAND stderr() : Stream = io_stderr;
	"return the error stream for the database console"
.COMMAND stdout() : Stream = io_stdout;
	"return the output stream for the database client"

.COMMAND open_rstream( str filename ) : Stream = stream_open_rstream;
	"open a file stream for reading"
.COMMAND open_wstream( str filename ) : Stream = stream_open_wstream;
	"open a file stream for writing"
.COMMAND open_rastream( str filename ) : Stream = stream_open_rastream; 
	"open ascii file stream for reading"
.COMMAND open_wastream( str filename ) : Stream = stream_open_wastream; 
	"open ascii file stream for writing"

.COMMAND socket_rstream( int socket, str name ) : Stream = 
	stream_socket_rstream; "open a socket stream for reading"
.COMMAND socket_wstream( int socket, str name ) : Stream = 
	stream_socket_wstream; "open a socket stream for writing"
.COMMAND socket_rastream( int socket, str name ) : Stream = 
	stream_socket_rastream; "open ascii socket stream for reading"
.COMMAND socket_wastream( int socket, str name ) : Stream = 
	stream_socket_wastream; "open ascii socket stream for writing"

.COMMAND block_stream( Stream s ) : Stream = 
	open_block_stream; "open a block based stream"

.COMMAND stream_write( Stream s, str data ) = stream_write_string;
	"write data on the stream"

.COMMAND stream_writeInt( Stream s, int data ) = stream_writeInt_wrap;
	"write an integer on the stream"

.COMMAND stream_readInt( Stream s ) : int = stream_readInt_wrap;
	"write an integer on the stream"

.COMMAND stream_read( Stream s ) : str = stream_read_string;
	"read data from the stream"

.COMMAND stream_flush( Stream s ) = stream_flush;
	"flush the stream"

.COMMAND stream_close( Stream s ) = stream_close_stream; 
	"close and destroy the stream s"

    .ATOM Buffer = ptr;
    .END;

@+ deprecated!
The buffer streams are deprecated (removed in 5.0). They are only used within 
the sqlserver, which in v5.x will output mal instructions (ie no ascii mil dump). 
@m
.COMMAND buffer_create( int size ) : Buffer = buffer_create_wrap;
	"create a buffer of the given size"

.COMMAND buffer_destroy( Buffer b ) = buffer_destroy_wrap;
	"destroy buffer"

.COMMAND buffer_rastream( Buffer b, str name ) : Stream = buffer_rastream_wrap;
	"create a buffer read stream"

.COMMAND buffer_wastream( Buffer b, str name ) : Stream = buffer_wastream_wrap; 
	"create a buffer write stream"

    .ATOM Bstream = ptr;
    .END;

.COMMAND bstream_create( Stream s, int bufsize ) : Bstream = bstream_create_wrap; 
	"create a buffered stream"

.COMMAND bstream_destroy( Bstream s ) = bstream_destroy_wrap;
	"destroy bstream"

.COMMAND bstream_read( Bstream s, int size ) : int = bstream_read_wrap; 
	"read atleast size bytes into the buffer of s"

    .COMMAND fprintf( Stream filep, str format, ... ) = io_fprintf; 
	"See: man fprintf"

    .COMMAND ftable( Stream filep, ...BAT[any::1,any]... ) = io_ftable_default; 
	"Print an n-ary table to a file."

    .COMMAND ftable( Stream filep, int orderspec, ...BAT[any::1,any]... ) = io_ftable; 
	"Print an n-ary table to a file, using order of BAT [1..argc]."

    .COMMAND fwrite( Stream filep, str buf, int nbytes ) = io_fwrite;
	"See: man fwrite"

    .COMMAND fgets( Stream filep ): str = io_fgets; 
	"See: man fgets"

    .COMMAND fgetc( Stream filep ): int = io_fgetc; 
	"See: man fgetc"

.END streams;

@mil
	module(_streams);

	# backward compatibility with old io module (alas: seek has gone..)
	const EOF := -1;
	proc fputs(str buf, Stream s):void		stream_write(s, buf);
	proc fclose(Stream s):void 			stream_close(s);
	proc fflush(Stream s):void 			stream_flush(s);
	proc fopen(str filename, str mode) : Stream {
		if (mode.startsWith("r")) {
			return open_rastream(filename);
		} else if (mode.startsWith("w")) {
			return open_wastream(filename);
		} 
		return Stream(ptr(0));
	}
@h
#ifndef _STREAMS_H_
#define _STREAMS_H_

#include <gdk.h>
#include <blob.h>

typedef ptr Stream;
typedef ptr Buffer;
typedef ptr Bstream;

#include "streams.proto.h"

#endif /*_STREAMS_H_*/
@c
#include <monet.h>
#include "streams.h"
#include <stdio.h>

int io_stdin (Stream *ret) { *(stream**)ret = GDKin;  return GDK_SUCCEED; }
int io_stdout(Stream *ret) { *(stream**)ret = GDKout; return GDK_SUCCEED; }
int io_stderr(Stream *ret) { *(stream**)ret = GDKerr; return GDK_SUCCEED; }

int stream_open_rstream( Stream *S, str filename ){
	if ((*(stream**)S = open_rstream( filename )) == NULL){
		return GDK_FAIL; 
	} else {
		return GDK_SUCCEED;
	}
}
int stream_open_wstream( Stream *S, str filename ){
	if ((*(stream**)S = open_wstream( filename )) == NULL){
		return GDK_FAIL; 
	} else {
		return GDK_SUCCEED;
	}
}
int stream_open_rastream( Stream *S, str filename ){
	if ((*(stream**)S = open_rastream( filename )) == NULL){
		return GDK_FAIL; 
	} else {
		return GDK_SUCCEED;
	}
}
int stream_open_wastream( Stream *S, str filename ){
	if ((*(stream**)S = open_wastream( filename )) == NULL){
		return GDK_FAIL; 
	} else {
		return GDK_SUCCEED;
	}
}
int stream_socket_rstream( Stream *S, int *socket, str name ){
	if ((*(stream**)S = socket_rstream( *socket, name )) == NULL){
		return GDK_FAIL; 
	} else {
		return GDK_SUCCEED;
	}
}
int stream_socket_wstream( Stream *S, int *socket, str name ){
	if ((*(stream**)S = socket_wstream( *socket, name )) == NULL){
		return GDK_FAIL; 
	} else {
		return GDK_SUCCEED;
	}
}
int stream_socket_rastream( Stream *S, int *socket, str name ){
	if ((*(stream**)S = socket_rastream( *socket, name )) == NULL){
		return GDK_FAIL; 
	} else {
		return GDK_SUCCEED;
	}
}
int stream_socket_wastream( Stream *S, int *socket, str name ){
	if ((*(stream**)S = socket_wastream( *socket, name )) == NULL){
		return GDK_FAIL; 
	} else {
		return GDK_SUCCEED;
	}
}
int stream_write_string( Stream *S, str data ){
	stream *s = *(stream**)S;
	s->write( s, data, 1, strlen(data));
	return GDK_SUCCEED;
}

int stream_writeInt_wrap( Stream *S, int *data ){
	stream *s = *(stream**)S;
	stream_writeInt( s, *data);
	return GDK_SUCCEED;
}

int stream_readInt_wrap( int *data, Stream *S ){
	stream *s = *(stream**)S;
	stream_readInt( s, data);
	return GDK_SUCCEED;
}

#define CHUNK (64*1024)
int stream_read_string( str *res, Stream *S ){
	stream *s = *(stream**)S;
	size_t len = 0;
	size_t size = CHUNK + 1;
	char *buf = GDKmalloc(size), *start = buf;

	while ((len = s->read(s, start, 1, CHUNK)) == CHUNK){
		size += CHUNK;
		buf = GDKrealloc(buf, size); 
		start = buf + size - CHUNK - 1;
		*start = '\0';
	}
	start += len;
	*start = '\0';
	*res = buf;
	return GDK_SUCCEED;
}

int stream_flush( Stream *S ){
	stream *s = *(stream**)S;
	s->flush( s );
	return GDK_SUCCEED;
}

int stream_close_stream( Stream *S ){
	stream *s = *(stream**)S;
	if (s && !s->errnr){
		s->close( s );
	} else if (s) {
		s->destroy( s );
	}
	return GDK_SUCCEED;
}

int open_block_stream( Stream *S, Stream *is ){
	if ((*(stream**)S = block_stream( *(stream**)is )) == NULL){
		return GDK_FAIL; 
	} else {
		return GDK_SUCCEED;
	}
}

int buffer_create_wrap( Buffer *b, int *size){
	if ((*(buffer**)b = buffer_create( (size_t) *size )) == NULL){
		return GDK_FAIL; 
	} else {
		return GDK_SUCCEED;
	}
}
int buffer_destroy_wrap( Buffer *b ){
	buffer_destroy( *(buffer**)b );
	return GDK_SUCCEED;
}
int buffer_rastream_wrap( Stream *S, Buffer *b, str name ){
	if ((*(stream**)S = buffer_rastream( *(buffer**)b, name )) == NULL){
		return GDK_FAIL; 
	} else {
		return GDK_SUCCEED;
	}
}
int buffer_wastream_wrap( Stream *S, Buffer *b, str name ){
	if ((*(stream**)S = buffer_wastream( *(buffer**)b, name )) == NULL){
		return GDK_FAIL; 
	} else {
		return GDK_SUCCEED;
	}
}

int bstream_create_wrap( Bstream *BS, Stream *S, int *bufsize ){
	if ((*(bstream**)BS = bstream_create( *(stream**)S, (size_t) *bufsize )) == NULL){
		return GDK_FAIL; 
	} else {
		return GDK_SUCCEED;
	}
}

int bstream_destroy_wrap( Bstream *BS ){
	bstream_destroy( *(bstream**)BS );
	return GDK_SUCCEED;
}

int bstream_read_wrap( int *res, Bstream *BS, int *size ){
	*res = bstream_read( *(bstream**)BS, (size_t) *size ); 
	return GDK_SUCCEED;
}

int io_fprintf(Stream *filepp, str format,  ...){
	stream *fp = *(stream**)filepp;
        va_list ap;
        int ret;
        str s;
 
        va_start(ap,format);
        ret = monet_sprintf(&s, format, ap);
        va_end(ap);
        if (ret == GDK_FAIL) {
                return GDK_FAIL;
        }
        if (fp->write(fp, s, ret, strlen(s)) == 0) {
                GDKsyserror("io_fprintf():");
                GDKfree(s);
                return GDK_FAIL;
        }
	GDKfree(s);
        return GDK_SUCCEED;
}

int io_fprint(Stream *filepp, ...){
	stream *fp = *(stream**)filepp;
        va_list ap;
        ptr val; 
	int type;
 
        va_start(ap,filepp);

	val = va_arg (ap,ptr);
        if(val){
		type = va_arg(ap,int);
		if (ATOMstorage(type) != TYPE_str)
			stream_printf( fp, "%s(\"", ATOMname(type) );
		ATOMprint(type, val, fp);
		if (ATOMstorage(type) != TYPE_str)
			stream_printf( fp, "\")" );
		val = va_arg (ap,ptr);
        	while(val){
			type = va_arg(ap,int);
			if (ATOMstorage(type) != TYPE_str)
				stream_printf( fp, ", %s(\"", ATOMname(type) );
			else
				stream_printf( fp, ", ");
			ATOMprint(type, val, fp);
			if (ATOMstorage(type) != TYPE_str)
				stream_printf( fp, "\")" );
			val = va_arg (ap,ptr);
		}
	}
        va_end(ap);
        return GDK_SUCCEED;
}

int io_ftable( Stream* filepp, int *orderspec, ...){
	stream *fp = *(stream**)filepp;
        BAT *piv[MAXPARAMS];
        int argc = 0;
        va_list ap;

        va_start (ap, orderspec);
        do {
                piv[argc] = va_arg (ap,BAT*) ;
        } while(piv[argc++]);
        va_end (ap);
        BATmultiprintf(fp, argc, piv, FALSE, *orderspec);
        return GDK_SUCCEED;
}

int io_ftable_default(Stream *filepp, ...) {
	stream *fp = *(stream**)filepp;
        BAT *piv[MAXPARAMS];
        int argc = 0;
        va_list ap;

        va_start (ap,filepp);
        do {
                piv[argc] = va_arg (ap,BAT*) ;
        } while(piv[argc++]);
        va_end (ap);
        BATmultiprintf(fp, argc, piv, FALSE, 0);
        return GDK_SUCCEED;
}

int io_fgetc(int *res, Stream *S){
	stream *s = *(stream**)S;
	char c;
	if (s->read(s, &c, 1, 1) == 1) {
		*res = c;
	} else {
		*res = -1; /* EOF */
	}
	return GDK_SUCCEED;
}

int io_fgets(str *res, Stream *S){
	stream *s = *(stream**)S;
	size_t size, len = 123;
	char *buf = (char*) GDKmalloc(1+len);

	for(size=0; s->read(s, buf + size, 1, 1) > 0; size++){
		if (buf[size] == 0 || buf[size] == '\n') break;
		if (size+1 == len) {
			buf = (char*) GDKrealloc(buf, 1+(len*=2)); 
		}
	}
	buf[size] = 0;
	*res = buf;
	return GDK_SUCCEED;
}

int io_fputc(int *c, stream *S){
	stream *s = *(stream**)S;
	char data[2];
	data[0] = (char) *(int*) c; 
	data[1] = 0;
	s->write( s, data, 1, 1);
	return GDK_SUCCEED;
}

int io_fwrite(Stream *S, str buf, int *nbytes ){
	stream *s = *(stream**)S;
	s->write( s, buf, 1, *nbytes);
	return(GDK_SUCCEED);
}
@mil

if (mod = "main"){
    s := open_wastream( "test.mil" );
    stream_write( s, "test\n" );
    stream_close( s );

    s := open_rastream( "test.mil" );
    st := stream_read( s );
    stream_close( s );
    print(st);
}
