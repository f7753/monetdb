@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@' 
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@' 
@' The Original Code is the Monet Database System.
@' 
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2004 CWI.
@' All Rights Reserved.
@' 
@' Contributor(s):
@' 		Martin Kersten <Martin.Kersten@cwi.nl>
@' 		Peter Boncz <Peter.Boncz@cwi.nl>
@' 		Niels Nes <Niels.Nes@cwi.nl>
@' 		Stefan Manegold  <Stefan.Manegold@cwi.nl>

@f malalgebra
@a Arjen P. de Vries
@v 1.0
@t Work around internal join algorithm selection
@* Introduction
@T
Too many bugs.

@m
.MODULE malalgebra;

@= join
  .COMMAND @1join ( BAT[any::1,any::2] left, BAT[any::2,any::3] right) :
                    BAT[any::1,any::3] = CMD@1join;
  "Hook directly into the @1 implementation of the join."
@m
@:join(fetch)@
@:join(merge)@
@:join(hash)@
@:join(lrhash)@
@:join(index)@

@= sum
.COMMAND {_csum}(BAT[oid,@1] b) : BAT[oid,@1] = CMDclustered_sum_@1; 
	"grouped tail sum"
@m
@:sum(sht)@
@:sum(int)@
@:sum(lng)@
@:sum(flt)@
@:sum(dbl)@

@= milsum
  PROC {csum}( BAT[oid,@1] b): BAT[oid,@1] := {
    IF ( b.ordered )
      RETURN {_csum}( b );
    ELSE
      RETURN {sum}( b );
  }
  ADDHELP("{csum}", "arjen", "Jul 18 2000",
          "Choose a different implementation if b is sorted on head.", 
          mod);
@mil
@:milsum(sht)@
@:milsum(int)@
@:milsum(lng)@
@:milsum(flt)@
@:milsum(dbl)@

@m
.END malalgebra;

@{
@* Implementation Code
@h
#ifndef __MALALGEBRA_H__
#define __MALALGEBRA_H__
#include "gdk.h"

#if defined (__GNUC__) && defined (__STDC__)
#define INLINE	inline
#else
#define INLINE
#endif

/* nothing much */


#endif /* __MALALGEBRA_H__ */

@c
#include "malalgebra.h"
#include "malalgebra.proto.h"

BAT*
BATmalfetchjoin(BAT *l, BAT *r) {
  int rfetch = (BAThdense(r) && ATOMstorage(l->ttype) <= ATOMstorage(TYPE_oid));
  int lfetch = (BATtdense(l) && ATOMstorage(r->htype) <= ATOMstorage(TYPE_oid));

  if (lfetch && !(rfetch && BATcount(l) < BATcount(r))) {
    return BATfetchjoin(l, r, oid_nil);
  } else if (rfetch) {
    return BATmirror(BATfetchjoin(BATmirror(r), BATmirror(l), oid_nil));
  }
  GDKerror( "Cannot perform fetchjoin.\n");
  return NULL;
}

BAT*
BATmalhashjoin(BAT *l, BAT *r) {
  size_t lsize = l->batBuns->size + (l->hheap.base?l->hheap.size:0) + 
				    (l->theap.base?l->theap.size:0);
  size_t rsize = r->batBuns->size + (r->hheap.base?r->hheap.size:0) + 
				    (r->theap.base?r->theap.size:0);
  if (rsize < lsize) {
    return BATmirror(BAThashjoin(BATmirror(r), BATmirror(l),oid_nil));
  }
  return BAThashjoin(l,r,oid_nil);
}

/* don't reorder! */
BAT*
BATmallrhashjoin(BAT *l, BAT *r) {
  return BAThashjoin(l,r,oid_nil);
}

BAT*
BATmalmergejoin(BAT *l, BAT *r) {
  if ( !((BATtordered(l)&1)||(BAThordered(r)&1)) ) {
    GDKerror( "Cannot perform mergejoin: neither left nor right bat is ordered.\n" );
    return NULL;
  }
/*
 * Stefan: There is no reason not to perform a mergejoin on voids, is there?
 *
  if ( (l->ttype==TYPE_void) || (r->htype==TYPE_void) ) {
    GDKerror( "Cannot perform mergejoin on void fields.\n" );
    return NULL;    
  }
*/
  return BATmergejoin(l,r,oid_nil);
}

BAT*
BATmalindexjoin(BAT *l, BAT *r) {
  return BATthetajoin(l,r,JOIN_EQ,oid_nil);
}

@= joincmd
int CMD@1join(BAT **result, BAT *left, BAT* right) {
  ERRORcheck(left == NULL, "@1-join: invalid left operand"); 
  ERRORcheck(right == NULL, "@1-join: invalid right operand"); 
  ERRORcheck(TYPEerror(left->ttype, right->htype), "@1-join: type conflict\n"); 
  return (*result = (BAT*) BATmal@1join(left, right))?GDK_SUCCEED:GDK_FAIL;
}
@c
@:joincmd(hash)@
@:joincmd(lrhash)@
@:joincmd(fetch)@
@:joincmd(merge)@
@:joincmd(index)@

@}

@= sumcmd
int CMDclustered_sum_@1(BAT **ret, BAT *b ) {
	BAT *bn = BATnew(b->htype, BATttype(b), BATcount(b));	
	BUN p, q;
	int xx;
	oid cur;
	@1 sum = 0;

	bn->hsorted = b->hsorted;
	bn->tsorted = 0;
	if (BATcount(b))
 		cur = *(oid*)BUNhead(b,BUNfirst(b));
	BATloopFast(b, p, q, xx) {
		oid *h = (oid*) BUNhead(b,p);
		@1 *t = (@1*) BUNtail(b,p);

		if (cur != *h){
			BUNfastins(bn, &cur, &sum );
			cur = *h;
			sum = 0;
		}
		sum += *t;
	}
	if (BATcount(b))
		BUNfastins(bn, &cur, &sum );

	*ret = bn;
	return GDK_SUCCEED;
}
@c
@:sumcmd(sht)@
@:sumcmd(int)@
@:sumcmd(lng)@
@:sumcmd(flt)@
@:sumcmd(dbl)@

@= jointest_void
VAR @1result_void := @1join( l, r );
@
@= jointest_oid
VAR @1result_oid := @1join( [oid](l), [oid](r.reverse).reverse );
@
@= compresults
@:jointest_@2(@1)
IF( not( isnil(@1result_@2) ) ) {
  Ndiff := diff( result_@2, @1result_@2 ).count;
  printf( "Algorithm @1 leads to %d different answers.\n", Ndiff );
  IF (Ndiff>0) Ntestfailed :+= 1;
}
@
@mil

PROC test_malalgebra() : void := {   
	#
	# Simple test of some algorithms against the baseline
	#
	VAR Ndiff, l, r;

	dj := new( void, oid ); tf := new( void, int );
	dj.insert( nil, 0@0 );  tf.insert( nil, 10 );
	dj.insert( nil, 0@0 );  tf.insert( nil, 20 );
	dj.insert( nil, 0@0 );  tf.insert( nil, 30 );
	dj.insert( nil, 1@0 );  tf.insert( nil, 30 );
	dj.insert( nil, 1@0 );  tf.insert( nil, 20 );
	dj.insert( nil, 1@0 );  tf.insert( nil, 10 );
	dj.insert( nil, 2@0 );  tf.insert( nil, 20 );
	dj.insert( nil, 2@0 );  tf.insert( nil, 30 );
	dj.insert( nil, 2@0 );  tf.insert( nil, 10 );
	dj.seqbase(0@0);        tf.seqbase(0@0);

	l := dj.reverse;
	r := tf;

	Ntestfailed := 0;

	@:jointest_oid()@
	@:compresults(hash,oid)@
	@:compresults(fetch,oid)@
	@:compresults(merge,oid)@
	@:compresults(index,oid)@

	@:jointest_void()@
	@:compresults(hash,void)@
	@:compresults(fetch,void)@
	@:compresults(merge,void)@
	@:compresults(index,void)@

	printf( "RESULT: %d tests failed.\n", Ntestfailed );
}
