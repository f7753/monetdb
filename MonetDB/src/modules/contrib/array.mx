@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@' 
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@' 
@' The Original Code is the Monet Database System.
@' 
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2004 CWI.
@' All Rights Reserved.
@' 
@' Contributor(s):
@' 		Martin Kersten <Martin.Kersten@cwi.nl>
@' 		Peter Boncz <Peter.Boncz@cwi.nl>
@' 		Niels Nes <Niels.Nes@cwi.nl>
@' 		Stefan Manegold  <Stefan.Manegold@cwi.nl>

@f array
@a A.R. van Ballegooij
@* Basic array support


@m
.MODULE array;

   .COMMAND grid(int,int,int,int) : bat[void,int] = grid;
      "Generates an index BAT, (grpcount,grpsize,clustersize,offset)"

   .COMMAND print_array(bat[any::1,any],...bat[any::1,int]...) : void = print_array;
      "Prints an array, using 1 value bat and N aligned index bats"

.END example;

@h
/*============================================================================*/
#ifndef __array_h__
#define __array_h__

#include <gdk.h>
#include <algebra.h> /* to include BATmin and BATmax */

#include "array.proto.h"

#define new_int_bat(b,s) {(b)=BATnew(TYPE_void,TYPE_int,(s)); \
                          BATseqbase((b),0);                  }
#define add_ints(b,n)    {(b)->batBuns->free+=(n)*sizeof(int);\
                          BATkey(BATmirror((b)),0);           \
                          (b)->tsorted = 0;                   }
#define get_int_ptr(b)   ((int*)(BUNfirst((b))))

/* The maximum number of dimensions that the print-function can handle... */
#define MAX_ARRAY_DIM 16

#endif 
/*============================================================================*/
@c
/*============================================================================*/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <time.h>

#include "array.h"

/*----------------------------------------------------------------------------*/

int grid(BAT **out,
         int *groups, int *groupsize, int *clustersize, int *offset) {
    register int *ptr;
    int i = *groups;
    int n = *groupsize + *offset;
    int r = *clustersize;
    int o = *offset;

#ifdef EXCESSIVE_DEBUGGING
fprintf(stderr,"[grid] (%d,%d,%d,%d)",i,n,r,o);
#endif

    new_int_bat(*out,(i*(n-o)*r));
    add_ints(*out,(i*(n-o)*r));
    ptr = get_int_ptr(*out);

    while(i--) {
       register int ni = o;
       while (ni<n) {
           register int ri = r;
           while(ri--) (*(ptr++)) = ni;
           ni++;
       }
    }

#ifdef EXCESSIVE_DEBUGGING
fprintf(stderr,"- done\n");
#endif

    return GDK_SUCCEED;
}

/*---------------------------------------------------------------------------*/
/*
   memory-hungry function;
   it internally builds the index to be able to print the array in-order.
*/

int print_array(BAT* val,...) {
    va_list ap;
    BAT     *tmp,*batptr[MAX_ARRAY_DIM];
    int     *minvector;
    int     *idxvector;
    int     *maxvector;
    int     *lenvector;
    oid     *arrayindex;
    int     i,j,c,dims;
    stream  *st     = GDKout;
    int     type_id = BATttype(val);

    va_start(ap,val);
    dims = 0;
    while((tmp = va_arg(ap,BAT*)) != NULL) {
        if(dims == MAX_ARRAY_DIM) {
            GDKerror("print_array: Error, too high dimensionality.\n");
            goto exit_err_none;
        }
        batptr[dims++] = tmp;
    }
    if(dims == 0) {
        GDKerror("print_array: Error, no index bats provided.\n");
        goto exit_err_none;
    }
    va_end(ap);

#ifdef EXCESSIVE_DEBUGGING
fprintf(stderr,"[PRINT_ARRAY] Dims = %d\n",dims);
#endif

    minvector = GDKmalloc(sizeof(ptr) * dims);
    idxvector = GDKmalloc(sizeof(int) * dims);
    maxvector = GDKmalloc(sizeof(ptr) * dims);
    lenvector = GDKmalloc(sizeof(ptr) * dims);

    c = 1;
    j = BATcount(val);
    for(i=0;i<dims;i++) {
        if(BATttype(batptr[i]) != TYPE_int) {
           GDKerror("print_array: Index %d error, not int type\n",i);
           goto exit_err_part;
        }
        if(BATcount(batptr[i]) != j) {
           GDKerror("print_array: Index %d error, count doesn't match\n",i);
           goto exit_err_part;
        }

        BATmin(batptr[i],&(minvector[i]));
        BATmax(batptr[i],&(maxvector[i]));
        lenvector[i] = maxvector[i] - minvector[i] + 1;
        c *= lenvector[i];
#ifdef EXCESSIVE_DEBUGGING
fprintf(stderr,"[PRINT_ARRAY] Axis %d = %d..%d\n",i,minvector[i],maxvector[i]);
#endif
    }

    if(c != j) {
        GDKerror("print_array: array size does not match array count\n");
        goto exit_err_part;
    }
    arrayindex = GDKmalloc(sizeof(oid) * c);

    /* Iterate over the first index BAT.              */
    /* And fetch additional indices (for a given oid) */
    /* building the full M-D structure (of oid's).    */
    {
        register BUN p,q;
        p = BUNfirst(batptr[0]);
        q = BUNlast(batptr[0]);
        while(p < q){
            register oid* o      = (oid*)BUNhead(batptr[0],p);
            register int  offset;
            offset = *((int*)BUNtail(batptr[0],p)) - minvector[0];
            for(i=1;i<dims;i++) {
                register ptr p = BUNfnd(batptr[i],o);
                if(p == NULL) {
                   GDKerror("print_array: Index %d missing for oid %d.\n",i,*o);
                   goto exit_err_full;
                }
                offset = (offset * lenvector[i]) +
                         ((*((int*)p)) - minvector[i]);
            }
            arrayindex[offset] = *o;
            p = BUNnext(batptr[0], p);
        }
    }

   /* Iterate over all valid indices             */
    /* (note: normalized to [0..l-1] ranges !)    */
    /* And print the values within the 'correct'  */
    /* bracket structure...                       */
#ifdef EXCESSIVE_DEBUGGING
fprintf(stderr,"[PRINT_ARRAY] ");
#endif
    for(i=0;i<dims;i++) idxvector[i] = 0;
    while(idxvector[dims-1] < lenvector[dims-1]) {
        int offset;
        for(i=0;i<dims;i++) {
            if(idxvector[i]!=0) {
#ifdef EXCESSIVE_DEBUGGING
fprintf(stderr,",");
#endif
                stream_printf(st,",");
                break;
            }
        }
        i=0;
        while(idxvector[i]==0) {
#ifdef EXCESSIVE_DEBUGGING
fprintf(stderr,"[");
#endif
           stream_printf(st,"[");
            i++;
        }
        for(offset=idxvector[0],i=1;i<dims;i++) {
            offset = (offset * lenvector[i]) + idxvector[i];
        }
        {
          register ptr p = BUNfnd(val,&arrayindex[offset]);
          if(p == NULL) {
            GDKerror("print_array: Value missing for oid %d.\n",
                     arrayindex[offset]);
            goto exit_err_full;
          }
#ifdef EXCESSIVE_DEBUGGING
fprintf(stderr,"%d\@0",arrayindex[offset]);
#endif
          ATOMprint(type_id,BUNtail(val,p),st);
	  if (stream_errnr(st))
		  goto exit_err_full;
        }
        i = 0;
        while((++idxvector[i]) == lenvector[i]) {
#ifdef EXCESSIVE_DEBUGGING
fprintf(stderr,"]");
#endif
            stream_printf(st,"]");
            if(i<dims-1) {
                idxvector[i] = 0;
                i++;
            }
        }
    }
#ifdef EXCESSIVE_DEBUGGING
fprintf(stderr,"\n");
#endif
    stream_printf(st,"\n");

    /* Exit strategies... */
    GDKfree(arrayindex);
    GDKfree(maxvector);
    GDKfree(idxvector);
    GDKfree(minvector);
    GDKfree(lenvector);
    return GDK_SUCCEED;

exit_err_full:
    GDKfree(arrayindex);
exit_err_part:
    GDKfree(maxvector);
    GDKfree(idxvector);
    GDKfree(minvector);
    GDKfree(lenvector);
exit_err_none:
    return GDK_FAIL;
}

/*============================================================================*/
@mil

PROC cons(int n,any::1 v) : bat[void,any::1] {
    return project(grid(1,n,1,0),v);
}
ADDHELP("cons", "A.R. van Ballegooij", "Sep 20 2003",
"generates a bat with a constant column", "array");

PROC concat(bat[oid,any::1] a,bat[oid,any::1] b,int o) : bat[oid,any::1] {
    return access(insert(access(copy(a),BAT_WRITE),
                  reverse([oid]([+]([int](reverse(b)),o))))
          ,BAT_READ);
}
ADDHELP("concat", "A.R. van Ballegooij", "Sep 20 2003",
"Adds 'offset' two second arrays indexes and merges tables", "array");

if (mod = "main"){
	print("Array module loaded...");
}

