@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at 
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@' 
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@' 
@' The Original Code is the Monet Database System.
@' 
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2002 CWI.  
@' All Rights Reserved.
@' 
@' Contributor(s):
@' 		Martin Kersten <Martin.Kersten@cwi.nl>
@' 		Peter Boncz <Peter.Boncz@cwi.nl>
@' 		Niels Nes <Niels.Nes@cwi.nl>
@' 		Stefan Manegold  <Stefan.Manegold@cwi.nl>

@f monet_options
@a N.J. Nes
@* A simple option handling library
@T
The monet server and clients make use of command line options and a (possibly)
shared config file. With this library a set (represented by set,setlen) of
options is created. An option is stored as name and value strings with a
special flag indicating the origin of the options, (builtin, system config
file, special config file or command line option). 

@h
#ifndef _MO_H_
#define _MO_H_

#include "monet_utils.h"
#ifndef HAVE_GETOPT_LONG 
#  include "monet_getopt.h"
#else
#  include "getopt.h"
#endif

typedef enum opt_kind
{
	opt_builtin 		= 0,
	opt_config 		= 1,
	opt_cmdline 		= 2
} opt_kind;

typedef struct opt 
{
	opt_kind  kind; 
	char *name;
	char *value;
} opt;

#ifdef __cplusplus
extern "C" {
#endif

/* mo_print_options will print the option set on stderr */
mutils_export void mo_print_options(opt *set, int setlen);

/* mo_find_option, finds the option with the given name in the option set
	(set,setlen). */

mutils_export char *mo_find_option( opt *set, int setlen, char *name );

/* the option values can contain ${prefix} and ${exec_prefix}, these will
   be substituted using the mo_substitute function */
mutils_export void mo_substitute( opt *set, int setlen, char *name );

/* mo_config_file adds all options int the given config file, to the current
   options set  (returns the new setlen) */
mutils_export int mo_config_file( opt **Set, int setlen, char *file );


/* mo_system_config will add the options from the system config file
   (returns the new setlen) */
mutils_export int mo_system_config( opt **Set, int setlen);

/* mo_builtin_settings, will place the builtin settings into a new
   option set (returns the length of this set). */ 
mutils_export int mo_builtin_settings( opt **Set );

/* mo_add_option will add a single option to the option set 
   (returns new length) */
mutils_export int mo_add_option( opt **Set, int setlen, 
		opt_kind kind, char *name, char *value );

/* mo_free_options will free the resouces take by the options set */
mutils_export void mo_free_options( opt *set, int setlen );

#ifdef __cplusplus
}
#endif

#endif

@c
#include <stdio.h>
#include <string.h>
#include "monet_options.h"

#ifndef HAVE_GETOPT_LONG
#  include "getopt.c"
#  include "getopt1.c"
#endif

void mo_print_options(opt *set, int setlen)
{
	int i = 0;

	for( i = 0; i<setlen; i++){
		if(set[i].kind == opt_builtin){
			fprintf(stderr, 
				"# builtin opt \t%s = %s\n", 
				set[i].name, set[i].value);
		}
	}
	for( i = 0; i<setlen; i++){
		if(set[i].kind == opt_config){
			fprintf(stderr,
				"# config opt \t%s = %s\n", 
				set[i].name, set[i].value);
		}
	}
	for( i = 0; i<setlen; i++){
		if(set[i].kind == opt_cmdline){
			fprintf(stderr,
				"# cmdline opt \t%s = %s\n", 
				set[i].name, set[i].value);
		}
	}
}


char *mo_find_option( opt *set, int setlen, char *name )
{
	opt *o = NULL;
	int i;
	for(i=0; i<setlen; i++){
		if (strcmp(set[i].name,name) == 0)
			if (!o || o->kind < set[i].kind)
				o = set+i;
	}
	if (o) return o->value;
	return NULL;
}

void mo_substitute( opt *set, int setlen, char *val )
{
	char *q = NULL;
	while( (q = strchr(val, '$')) != NULL ){
		if ( strncmp(q,"${exec_prefix}",strlen("${exec_prefix}")) == 0){
			char val2[BUFSIZ];
			char *p = mo_find_option(set, setlen, "exec_prefix");
			char *t = strchr(q,'}');
			if (!t || !p) return ;
			*q = '\0';
			snprintf(val2,BUFSIZ,"%s%s%s", val, p, t+1 );
			strncpy(val,val2,BUFSIZ);
		} else if ( strncmp(q,"${prefix}",strlen("${prefix}")) == 0){
			char val2[BUFSIZ];
			char *p = mo_find_option(set, setlen, "prefix");
			char *t = strchr(q,'}');
			if (!t || !p) return ;
			*q = '\0';
			snprintf(val2,BUFSIZ,"%s%s%s", val, p, t+1 );
			strncpy(val,val2,BUFSIZ);
		}
	}
}

int mo_config_file(opt **Set, int setlen, char *file )
{
        char buf[BUFSIZ];
        FILE *fd= NULL;
	opt *set = *Set;

        fd = fopen(file,"r");
        while(fd!=NULL && fgets(buf,BUFSIZ,fd) != NULL){
		char *s, *t, *val;
		int quote;

                for(s=buf; *s && isspace(*s); s++)
			;
                if( *s == '#') continue;  /* commentary */
                if( *s == 0) continue;   /* empty line */
                
                val = strchr(s,'=');
                if( val == NULL) {
                        fprintf(stderr, 
				"mo_config_file: syntax error in %s\n", file);
			fclose(fd);
			exit(1);
                }
                *val=0;

                for(t=s; *t && !isspace(*t); t++)
			;
                *t =0;

                /* skip any leading blancs in the value part */
                for(val++; *val && isspace(*val) ;val++)
			;

                /* search to unquoted # */
		quote = 0;
                for(t=val;*t;t++) {
			if (*t == '"')
				quote = !quote;
			else if (!quote && *t=='#')
				break;
		}
		if (quote) {
			fprintf(stderr,
				"mo_config_file: syntax error in %s\n", file);
			fclose(fd);
			exit(1);
		}
		/* remove trailing white space */
		while (isspace(t[-1]))
			t--;
                *t++ = 0;

		set = (opt*)realloc(set,(setlen+1)*sizeof(opt));
		set[setlen].kind = opt_config;
		set[setlen].name = strdup(s);
		set[setlen].value = malloc(t-val);
		for (t=val, s=set[setlen].value; *t; t++)
			if (*t != '"')
				*s++ = *t;
		*s = 0;
		setlen++;
        }
	if (fd == NULL){
		fprintf(stderr, "Could not open file %s\n", file );
	}
        if( fd != NULL) (void) fclose(fd);
	*Set = set;
	return setlen;
}

int mo_system_config( opt **Set, int setlen)
{
	char config[BUFSIZ];

	snprintf(config,BUFSIZ,"@Qsysconfdir@%cmonet.conf", DIR_SEP);
	mo_substitute(*Set, setlen, config);
	return mo_config_file(Set, setlen, config );
}
	

int mo_builtin_settings(opt **Set)
{
	int i = 0;
	opt *set = (opt*)malloc(sizeof(opt)*23);

	if (!set) return 0;

	set[i].kind = opt_builtin;
	set[i].name = strdup("gdk_arch");
	set[i].value = (char*)malloc(BUFSIZ);
        snprintf(set[i].value,BUFSIZ, "%dbit%s", (int)sizeof(char*)*8, HOST);
	i++;
	set[i].kind = opt_builtin;
	set[i].name = strdup("gdk_version");
	set[i].value = (char*)strdup(VERSION);
	i++;
	set[i].kind = opt_builtin;
	set[i].name = strdup("monet_pid");
	set[i].value = (char*)malloc(BUFSIZ);
        snprintf(set[i].value,BUFSIZ, "%d", getpid());
	i++;

	set[i].kind = opt_builtin;
	set[i].name = strdup("prefix");
	set[i].value = (char*)malloc(BUFSIZ);
	snprintf(set[i].value,BUFSIZ,"@Qprefix@" );
	i++;
	set[i].kind = opt_builtin;
	set[i].name = strdup("exec_prefix");
	set[i].value = (char*)malloc(BUFSIZ);
	snprintf(set[i].value,BUFSIZ,"@Qexec_prefix@" );
	i++;
	set[i].kind = opt_builtin;
	set[i].name = strdup("gdk_dbname");
	set[i].value = strdup("tst");
	i++;
	set[i].kind = opt_builtin;
	set[i].name = strdup("gdk_dbfarm");
	set[i].value = (char*)malloc(BUFSIZ);
	snprintf(set[i].value,BUFSIZ,"@Qlocalstatedir@%c@PACKAGE@", DIR_SEP);
	i++;
	set[i].kind = opt_builtin;
	set[i].name = strdup("gdk_debug");
	set[i].value = strdup("8");
	i++;
	set[i].kind = opt_builtin;
	set[i].name = strdup("gdk_mmap");
	set[i].value = strdup("32M");
	i++;
	set[i].kind = opt_builtin;
	set[i].name = strdup("monet_admin");
	set[i].value = strdup("adm");
	i++;
	set[i].kind = opt_builtin;
	set[i].name = strdup("monet_prompt");
	set[i].value = strdup(">");
	i++;
	set[i].kind = opt_builtin;
	set[i].name = strdup("monet_welcome");
	set[i].value = strdup("yes");
	i++;
	set[i].kind = opt_builtin;
	set[i].name = strdup("monet_mod_path");
	set[i].value = (char*)malloc(BUFSIZ);
	snprintf(set[i].value,BUFSIZ,"@Qlibdir@%c@PACKAGE@", DIR_SEP);
	i++;
	set[i].kind = opt_builtin;
	set[i].name = strdup("monet_deamon");
	set[i].value = strdup("yes");
	i++;
	set[i].kind = opt_builtin;
	set[i].name = strdup("host");
	set[i].value = strdup("localhost");
	i++;
	set[i].kind = opt_builtin;
	set[i].name = strdup("mapi_port");
	set[i].value = strdup("50000");
	i++;
	set[i].kind = opt_builtin;
	set[i].name = strdup("mapi_noheaders");
	set[i].value = strdup("no");
	i++;
	set[i].kind = opt_builtin;
	set[i].name = strdup("mapi_debug");
	set[i].value = strdup("0");
	i++;
	set[i].kind = opt_builtin;
	set[i].name = strdup("sql_port");
	set[i].value = strdup("45123");
	i++;
	set[i].kind = opt_builtin;
	set[i].name = strdup("sql_debug");
	set[i].value = strdup("0");
	i++;
	set[i].kind = opt_builtin;
	set[i].name = strdup("sql_api");
	set[i].value = strdup("sql(default-schema)");
	i++;
	set[i].kind = opt_builtin;
	set[i].name = strdup("sql_user");
	set[i].value = strdup("monetdb");
	i++;
	set[i].kind = opt_builtin;
	set[i].name = strdup("sql_schema");
	set[i].value = strdup("default-schema");
	i++;
	
	*Set = set;
	return i;
}

int mo_add_option( opt **Set, int setlen, 
		opt_kind kind, char *name, char *value )
{
	opt *set = (opt*)realloc(*Set,(setlen+1)*sizeof(opt));
	set[setlen].kind = kind;
	set[setlen].name = strdup(name);
	set[setlen].value = strdup(value);
	*Set = set;
	return setlen+1;
}

void mo_free_options( opt *set, int setlen )
{
	int i;
	for(i=0; i<setlen; i++){
		free(set[i].name);
		free(set[i].value);
	}
	free(set);
}
