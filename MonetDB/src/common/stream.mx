@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@' 
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@' 
@' The Original Code is the Monet Database System.
@' 
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2003 CWI.
@' All Rights Reserved.
@' 
@' Contributor(s):
@' 		Martin Kersten <Martin.Kersten@cwi.nl>
@' 		Peter Boncz <Peter.Boncz@cwi.nl>
@' 		Niels Nes <Niels.Nes@cwi.nl>
@' 		Stefan Manegold  <Stefan.Manegold@cwi.nl>

@f stream
@a Niels Nes
@* An simple interface to streams 
Processing files, streams, and sockets is quite different on Linux and Windows
platforms. To improve portability between both, we advise to replace the stdio
actions with the stream functionality provided here.

This interface can also be used to open 'non compressed, gzipped, bz2zipped' 
data files and sockets. Using this interface one could easily switch between
the various underlying storage types.

@h
#ifndef _STREAM_H_
#define _STREAM_H_

/*
 * File: stream.h 
 * Auteur: Niels J. Nes
 * Date: 09-01-2001
 * 
 * Version 0.1: start
 *
 * This is the general interface to input/output. Each stream will
 * contains some stream info (for now only byteorder). This is 
 * required for proper conversion on different byte order platforms.
 */

#include <monet_utils.h>

#include <ctype.h>
#include <assert.h>

#ifdef HAVE_MALLOC_H
#include <malloc.h>
#endif
#include <signal.h>

#ifdef _MSC_VER
#ifndef LIBSTREAM
#define stream_export extern __declspec(dllimport) 
#else
#define stream_export extern __declspec(dllexport) 
#endif
#else
#define stream_export extern 
#endif

#define EOT 4

#define ST_ASCII  0
#define ST_BIN 1

#define ST_READ  0
#define ST_WRITE 1

#ifdef HAVE_LONG_LONG
typedef long long	lng;
#else
#ifdef HAVE___INT64
typedef __int64		lng;
#endif
#endif

#define short_int_SWAP(s) (((0x00ff&(s))<<8) | ((0xff00&(s))>>8))

#define normal_int_SWAP(i) (((0x000000ff&(i))<<24) | ((0x0000ff00&(i))<<8) | \
	               ((0x00ff0000&(i))>>8)  | ((0xff000000&(i))>>24))

#define long_long_SWAP(l) \
		((((lng)normal_int_SWAP(l))<<32) |\
		 (0xffffffff&normal_int_SWAP(l>>32)))

typedef struct stream {
	short byteorder;
	short access;/* read/write */
	short type;/* ascii/binary */
	char *name;
	void *stream_data;
	int errnr;
	size_t (*read)( struct stream *s, char *buf, size_t elmsize, size_t cnt );
	size_t (*write)( struct stream *s, char *buf, size_t elmsize, size_t cnt );
	void (*close)( struct stream *s);
	char *(*error)( struct stream *s );
	void (*destroy)( struct stream *s );
	void (*flush)( struct stream *s );
} stream;

/* some os specific initialization */
stream_export int stream_init(void);

stream_export int stream_readSht( stream *s, short *val );
stream_export int stream_writeSht( stream *s, const short val );
stream_export int stream_readInt( stream *s, int *val );
stream_export int stream_writeInt( stream *s, const int val );
stream_export int stream_readLng( stream *s, lng *val );
stream_export int stream_writeLng( stream *s, const lng val );

stream_export int stream_readShtArray( stream *s, short *val, size_t cnt );
stream_export int stream_writeShtArray( stream *s, const short *val, size_t cnt );
stream_export int stream_readIntArray( stream *s, int *val, size_t cnt );
stream_export int stream_writeIntArray( stream *s, const int *val, size_t cnt );
stream_export int stream_readLngArray( stream *s, lng *val, size_t cnt );
stream_export int stream_writeLngArray( stream *s, const lng *val, size_t cnt );
stream_export int stream_printf( stream *s, const char *format, ...);

stream_export stream *open_rstream( char *filename );
stream_export stream *open_wstream( char *filename );
/* open in ascii stream in read mode */
stream_export stream *open_rastream( char *filename ); 
/* open in ascii stream in write mode*/
stream_export stream *open_wastream( char *filename ); 

#ifdef HAVE_LIBZ
stream_export stream *open_gzrstream( char *filename );
stream_export stream *open_gzwstream( char *filename );
stream_export stream *open_gzrastream( char *filename );
stream_export stream *open_gzwastream( char *filename );
#endif

#ifdef HAVE_LIBBZ2
stream_export stream *open_bzrstream( char *filename );
stream_export stream *open_bzwstream( char *filename );
stream_export stream *open_bzrastream( char *filename );
stream_export stream *open_bzwastream( char *filename );
#endif

stream_export void close_stream( stream *s );

stream_export stream *socket_rstream( int socket, char *name );
stream_export stream *socket_wstream( int socket, char *name );
stream_export stream *socket_rastream( int socket, char *name );
stream_export stream *socket_wastream( int socket, char *name );

stream_export stream *file_rstream( FILE *fp, char *name );
stream_export stream *file_wstream( FILE *fp, char *name );
stream_export stream *file_rastream( FILE *fp, char *name );
stream_export stream *file_wastream( FILE *fp, char *name );

typedef struct buffer {
	char *buf;
	size_t pos;
	size_t len;
} buffer;

stream_export buffer *buffer_create( size_t size );
stream_export char *buffer_get_buf( buffer *b );
stream_export void buffer_destroy( buffer *b );

stream_export stream *buffer_rastream( buffer *b, char *name );
stream_export stream *buffer_wastream( buffer *b, char *name );
stream_export buffer *stream_get_buffer( stream *s );

#define BLOCK 8192
/* 
   Block stream is a stream which sends data in blocks of a known
   size (BLOCK size or dynamically changed using CHANGE_BLOCK_SIZE msg).

   A block is writen once more then BLOCK size data has been writen using
   the write commands or when the flush command is send.

   All full blocks together with a single not full block from a major
   block. Major blocks can be used to synchronize the communication.
   Example server sends some reply, ie a major block consisting of
   verious minor blocks. The header of the major block can contain
   special info which the client can interpert.
   
   Each read attempt tries to return the number of bytes. Once a lower number
   of bytes can be read the end of the major block if found. The next
   read will then start with a new major block.
 */
stream_export stream *block_stream( stream *s );
stream_export size_t bs_read_next( stream *s, char *buf, int *last );

@+ buffered streams

The bstream (or buffered_stream) can be used for efficient reading
of a stream. Reading can be done in large chunks and 
access can be done in smaller bits, by directly accessing the underlying 
buffer.

@h
typedef struct bstream {
	stream *s;
	char *buf; 
	size_t size; /* size of buf */
	size_t pos; /* the data cursor (ie read uptil pos) */
	size_t len; /* len of the data (could < size but usually == size) */
	int eof;
} bstream;

stream_export bstream *bstream_create( stream *rs, size_t chunk_size );
stream_export void bstream_destroy( bstream *s );
stream_export size_t bstream_read( bstream *s, size_t size );

@+ bstream functions
The bstream_create gets a read stream (rs) as input and the initial chunk size
and creates a buffered stream from this. A spare byte is kept at the end 
of the buffer.
The bstream_read will atleast read the next 'size' bytes. If the not read data
(aka pos < len) together with the new data will not fit in the current buffer
it is resized. The spare byte is kept.

@h

typedef enum stream_errors {
	NO__ERROR = 0,
	OPEN_ERROR,
	READ_ERROR, 
	WRITE_ERROR
}stream_errors;
#endif /*_STREAM_H_*/
@c
#include "stream.h"
#include <string.h>

#ifdef HAVE_SYS_SOCKET_H
#include <sys/socket.h>
#endif

#ifdef HAVE_NETDB_H
# include <sys/types.h> 
# include <netinet/in_systm.h> 
# include <netinet/in.h> 
# include <netinet/ip.h> 
# include <netinet/tcp.h>
# include <netdb.h> 
#endif
#ifdef HAVE_FCNTL_H
#include <fcntl.h>
#endif
#ifdef HAVE_LIBZ
	#include <zlib.h>
#endif
#ifdef HAVE_LIBBZ2
	#include <bzlib.h>
#endif
#ifdef NATIVE_WIN32
#include <winsock.h>
#include <io.h>
#endif

#ifndef HAVE_SSIZE_T
#if SIZEOF_SIZE_T == SIZEOF_INT
typedef int ssize_t;
#else
typedef long ssize_t;
#endif
#define HAVE_SSIZE_T 1
#endif

int stream_init(void){
#ifdef NATIVE_WIN32
	int sockopt = SO_SYNCHRONOUS_NONALERT;
	WSADATA w;

	if (WSAStartup(0x0101, &w) != 0){
		return -1;
	}
	if ( setsockopt(INVALID_SOCKET, SOL_SOCKET, SO_OPENTYPE, 
		(void*)&sockopt, sizeof(sockopt)) < 0){
		WSACleanup();
		return -1;
	}
#endif
	return 0;
}

#define EXT_LEN 4
static void get_extention( char *file, char *ext)
{
   	int j = 0;
	char *ext_start = strrchr( file, '.' );

	if (ext_start){
	    ext_start++;
            for (j = 0; j < EXT_LEN-1 && *ext_start; j++, ext_start++ )
                ext[j] = tolower(*ext_start);
        }
        ext[j] = '\0';
}

static void stream_destroy( stream *s){
	free(s->name);
	free(s);
}

static stream *create_stream( char *name ){
	stream *s = (stream*)malloc(sizeof(stream));
	/*assert(s);*/
	s->byteorder = 1234;
	s->access = ST_READ;
	s->type = ST_ASCII;
	s->name = strdup(name); 
	s->stream_data = NULL;
	s->errnr = NO__ERROR;
	s->destroy = &stream_destroy;
	return s;
}

static char *stream_error( stream *s ){
	char buf [BUFSIZ];
	switch(s->errnr){
	case OPEN_ERROR:
		snprintf(buf, BUFSIZ, 
				"Error could not open file %s\n", s->name );
		return strdup(buf);
	case READ_ERROR:
		snprintf(buf, BUFSIZ, "Error reading file %s\n", s->name );
		return strdup(buf);
	case WRITE_ERROR:
		snprintf(buf, BUFSIZ, "Error writing file %s\n", s->name );
		return strdup(buf);
	}
	return strdup("Unkonwn error");
}

static size_t stream_read( stream *s, char *buf, size_t elmsize, size_t cnt ){
	FILE *fp = (FILE*)s->stream_data;
	if (!feof(fp))
		return fread( buf, elmsize, cnt, fp);
	return 0;
}

static size_t stream_write( stream *s, char *buf, size_t elmsize, size_t cnt ){
	size_t res = fwrite( buf, elmsize, cnt, (FILE*)s->stream_data);
	return res;
}

static void stream_close( stream *s ){
	FILE *fp = (FILE*)s->stream_data;
	if (!fp) return;
	if (fp != stdin && fp != stdout && fp != stderr)
		fclose( fp );
	else if (s->access == ST_WRITE)
		fflush( fp );
}

static void stream_flush( stream *s ){
	if (s->access == ST_WRITE)
		fflush( (FILE*)s->stream_data);
}

static stream *open_stream( char *filename, char *flags ){
	stream *s = create_stream(filename);
	FILE *fp = fopen( filename, flags );

	s->read  = &stream_read;
	s->write = &stream_write;
	s->close = &stream_close;
	s->error = &stream_error;
	s->flush = &stream_flush;
	if (fp != NULL){ 
		s->stream_data = (void*)fp;
		return s;
	}
	s->errnr = OPEN_ERROR;
	return s;
}

stream *open_rstream( char *filename ){
	stream *s;
  	char    ext[EXT_LEN];

  	get_extention(filename, ext);

#ifdef HAVE_LIBZ
  	if (!strcmp(ext,"gz" )){
		return open_gzrstream( filename );
	} else 
#else
  	if (!strcmp(ext,"gz" )){
		s = create_stream(filename);
		s->errnr = OPEN_ERROR;
		return s;
	} 
#endif
#ifdef HAVE_LIBBZ2
	if (!strcmp(ext,"bz2" )){
		return open_bzrstream( filename );
	} else 
#else
	if (!strcmp(ext,"bz2" )){
		s = create_stream(filename);
		s->errnr = OPEN_ERROR;
		return s;
	} 
#endif
	{
	  	s = open_stream( filename, "rb");
		s->type = ST_BIN;
		if (s->errnr == NO__ERROR)
	   		fread( (char*)&s->byteorder, sizeof(short), 
						1, (FILE*)s->stream_data);
		return s;
	}
}
stream *open_wstream( char *filename ){
	stream *s;
  	char    ext[EXT_LEN];

  	get_extention(filename, ext);

#ifdef HAVE_LIBZ
  	if (!strcmp(ext,"gz" )){
		return open_gzwstream( filename );
	} else
#else
  	if (!strcmp(ext,"gz" )){
		s = create_stream(filename);
		s->errnr = OPEN_ERROR;
		return s;
	} 
#endif
#ifdef HAVE_LIBBZ2
	if (!strcmp(ext,"bz2" )){
		return open_bzwstream( filename );
	} else 
#else
	if (!strcmp(ext,"bz2" )){
		s = create_stream(filename);
		s->errnr = OPEN_ERROR;
		return s;
	} 
#endif
	{
		s = open_stream( filename, "wb");
		s->access = ST_WRITE;
		s->type = ST_BIN;
		if (s->errnr == NO__ERROR)
	   		fwrite( (char*)&s->byteorder, sizeof(short), 
						1, (FILE*)s->stream_data);
		return s;
	}
}
stream *open_rastream( char *filename ){
	stream *s;
  	char    ext[EXT_LEN];

  	get_extention(filename, ext);

#ifdef HAVE_LIBZ
  	if (!strcmp(ext,"gz" )){
		return open_gzrastream( filename );
	} else
#else
  	if (!strcmp(ext,"gz" )){
		s = create_stream(filename);
		s->errnr = OPEN_ERROR;
		return s;
	} 
#endif
#ifdef HAVE_LIBBZ2
	if (!strcmp(ext,"bz2" )){
		return open_bzrastream( filename );
	} else 
#else
	if (!strcmp(ext,"bz2" )){
		s = create_stream(filename);
		s->errnr = OPEN_ERROR;
		return s;
	} 
#endif
	{
		s = open_stream( filename, "r");
		s->type = ST_ASCII;
		return s;
	}
}
stream *open_wastream( char *filename ){
	stream *s;
  	char    ext[EXT_LEN];

  	get_extention(filename, ext);

#ifdef HAVE_LIBZ
  	if (!strcmp(ext,"gz" )){
		return open_gzwastream( filename );
	} else
#else
  	if (!strcmp(ext,"gz" )){
		s = create_stream(filename);
		s->errnr = OPEN_ERROR;
		return s;
	} 
#endif
#ifdef HAVE_LIBBZ2
	if (!strcmp(ext,"bz2" )){
		return open_bzwastream( filename );
	} else 
#else
	if (!strcmp(ext,"bz2" )){
		s = create_stream(filename);
		s->errnr = OPEN_ERROR;
		return s;
	} 
#endif
	{
		s = open_stream( filename, "w");
		s->access = ST_WRITE;
		s->type = ST_ASCII;
		return s;
	}
}


#ifdef HAVE_LIBZ
static size_t stream_gzread( stream *s, char *buf, size_t elmsize, size_t cnt ){
	int size = (int)(elmsize*cnt);
	size = gzread( (gzFile*)s->stream_data, buf, size );
	if (size) return size/elmsize;
	return 0;
}
static size_t stream_gzwrite( stream *s, char *buf, size_t elmsize, size_t cnt ){
	int size = (int)(elmsize*cnt);
	size = gzwrite( (gzFile*)s->stream_data, buf, size );
	if (size) return size/elmsize;
	return 0;
}
static void stream_gzclose( stream *s ){
	gzclose( (gzFile*)s->stream_data);
}
static void stream_gzflush( stream *s ){
	if (s->access == ST_WRITE)
		gzflush( (gzFile*)s->stream_data, Z_SYNC_FLUSH);
}
stream *open_gzstream( char *filename, char *flags ){
	stream *s = create_stream(filename);
	gzFile *fp = gzopen( filename, flags );
	s->read  = &stream_gzread;
	s->write = &stream_gzwrite;
	s->close = &stream_gzclose;
	s->error = &stream_error;
	s->destroy = &stream_destroy;
	s->flush = &stream_gzflush;
	if (fp != NULL){ 
		s->stream_data = (void*)fp;
		return s;
	}
	s->errnr = OPEN_ERROR;
	return s;
}
stream *open_gzrstream( char *filename ){
	stream *s = open_gzstream( filename, "rb");
	s->type = ST_BIN;
	if (s->errnr == NO__ERROR)
	   gzread( (gzFile*)s->stream_data, (char*)&s->byteorder, sizeof(short));
	return s;
}
stream *open_gzwstream( char *filename ){
	stream *s = open_gzstream( filename, "wb");
	s->access = ST_WRITE;
	s->type = ST_BIN;
	if (s->errnr == NO__ERROR)
	   gzwrite( (gzFile*)s->stream_data, (char*)&s->byteorder, sizeof(short));
	return s;
}
stream *open_gzrastream( char *filename ){
	stream *s = open_gzstream( filename, "rb");
	s->type = ST_ASCII;
	return s;
}
stream *open_gzwastream( char *filename ){
	stream *s = open_gzstream( filename, "wb");
	s->access = ST_WRITE;
	s->type = ST_ASCII;
	return s;
}
#endif

#ifdef HAVE_LIBBZ2
static size_t stream_bzread( stream *s, char *buf, size_t elmsize, size_t cnt ){
	int size = (int)(elmsize*cnt);
	size = BZ2_bzread( (BZFILE*)s->stream_data, buf, size );
	if (size) return size/elmsize;
	return 0;
}
static size_t stream_bzwrite( stream *s, char *buf, size_t elmsize, size_t cnt ){
	int size = (int)(elmsize*cnt);
	size = BZ2_bzwrite( (BZFILE*)s->stream_data, buf, size );
	if (size) return size/elmsize;
	return 0;
}
static void stream_bzclose( stream *s ){
	BZ2_bzclose( (BZFILE*)s->stream_data);
}
static void stream_bzflush( stream *s ){
	if (s->access == ST_WRITE)
		BZ2_bzflush( (BZFILE*)s->stream_data);
}
stream *open_bzstream( char *filename, char *flags ){
	stream *s = create_stream(filename);
	BZFILE *fp = BZ2_bzopen( filename, flags );
	s->read  = &stream_bzread;
	s->write = &stream_bzwrite;
	s->close = &stream_bzclose;
	s->error = &stream_error;
	s->destroy = &stream_destroy;
	s->flush = &stream_bzflush;
	if (fp != NULL){ 
		s->stream_data = (void*)fp;
		return s;
	}
	s->errnr = OPEN_ERROR;
	return s;
}
stream *open_bzrstream( char *filename ){
	stream *s = open_bzstream( filename, "rb");
	s->type = ST_BIN;
	if (s->errnr == NO__ERROR) BZ2_bzread( 
		(BZFILE*)s->stream_data, (char*)&s->byteorder, sizeof(short) );
	return s;
}
stream *open_bzwstream( char *filename ){
	stream *s = open_bzstream( filename, "wb");
	s->access = ST_WRITE;
	s->type = ST_BIN;
	if (s->errnr == NO__ERROR) BZ2_bzwrite( 
		(BZFILE*)s->stream_data, (char*)&s->byteorder, sizeof(short) );
	return s;
}
stream *open_bzrastream( char *filename ){
	stream *s = open_bzstream( filename, "rb");
	s->type = ST_ASCII;
	return s;
}
stream *open_bzwastream( char *filename ){
	stream *s = open_bzstream( filename, "wb");
	s->access = ST_WRITE;
	s->type = ST_ASCII;
	return s;
}
#endif

static size_t socket_write( stream *s, char *buf, size_t elmsize, size_t cnt ){
	size_t size = elmsize*cnt;
#ifdef NATIVE_WIN32
	int sz = send( (int)s->stream_data, buf, size, 0 );
#else
	ssize_t sz = write( (int)s->stream_data, buf, size );
#endif
	if (sz > 0) return (size_t)sz/elmsize;
	return 0;
}
static size_t socket_read( stream *s, char *buf, size_t elmsize, size_t cnt ){
#ifdef NATIVE_WIN32
	int nr = 0;
#else
	ssize_t nr = 0;
#endif
	size_t res = 0, size = elmsize*cnt;
	while( res < size && (
#ifdef NATIVE_WIN32
		(nr = recv( (int)s->stream_data, buf+res, size-res, 0 ))
#else
		(nr = read( (int)s->stream_data, buf+res, size-res )) > 0
#endif
		|| errno == EAGAIN)
	){
		 res += (nr>0)?nr:0;
	}
	if (nr < 0) return 0;
	if (res) return res/elmsize;
	return 0;
}
static void socket_flush( stream *s ){
	/* not needed */
}
static void socket_close( stream *s ){
	int fd = (int)s->stream_data;
	if (s->access == ST_READ)
		shutdown(fd,0);
	else
		shutdown(fd,1);
}

static
stream *socket_open( int socket, char *name ){
	stream *s = create_stream(name);
	s->read  = &socket_read;
	s->write = &socket_write;
	s->close = &socket_close;
	s->error = &stream_error;
	s->flush = &socket_flush;
	s->stream_data = (void*)socket;

#ifdef SO_KEEPALIVE
	{ int opt = 0; 
	setsockopt(socket, SOL_SOCKET, SO_KEEPALIVE, (void *) &opt,
			                   sizeof(opt)); }
#endif
#ifdef IPTOS_THROUGHPUT
	{ int tos = IPTOS_THROUGHPUT; 
    	setsockopt(socket, IPPROTO_IP, IP_TOS, (void *) &tos, sizeof(tos)); }
#endif
#ifdef TCP_NODELAY
	{ int nodelay = 1;
    	setsockopt(socket, IPPROTO_TCP, TCP_NODELAY, (void *) &nodelay,
		                         sizeof(nodelay)); }
#endif
#ifndef NATIVE_WIN32
	{ int fl = fcntl(socket, F_GETFL);
	fl &= ~O_NONBLOCK;
	fcntl(socket, F_SETFL, fl ); }
#endif

	return s;
}
stream *socket_rstream( int socket, char *name ){
	stream *s = socket_open( socket, name );
	s->type = ST_BIN;
	if (s->errnr == NO__ERROR)
		read( socket, (char*)&s->byteorder, sizeof(short)); 
	return s;
}

stream *socket_wstream( int socket, char *name ){
	stream *s = socket_open( socket, name );
	s->access = ST_WRITE;
	s->type = ST_BIN;
	if (s->errnr == NO__ERROR)
	   	write( socket, (char*)&s->byteorder, sizeof(short));
	return s;
}

stream *socket_rastream( int socket, char *name ){
	stream *s = socket_open( socket, name );
	s->type = ST_ASCII;
	return s;
}

stream *socket_wastream( int socket, char *name ){
	stream *s = socket_open( socket, name );
	s->access = ST_WRITE;
	s->type = ST_ASCII;
	return s;
}

stream *file_stream( char *name ){
	stream *s = create_stream(name);
	s->read  = &stream_read;
	s->write = &stream_write;
	s->close = &stream_close;
	s->error = &stream_error;
	s->flush = &stream_flush;
	return s;
}
stream *file_rstream( FILE *fp, char *name ){
	stream *s = file_stream(name);
	s->type = ST_BIN;
	if (fp != NULL){ 
		s->stream_data = (void*)fp;

		if (s->errnr == NO__ERROR)
	   		fread( (char*)&s->byteorder, sizeof(short), 
						1, (FILE*)s->stream_data);
		return s;
	}
	s->errnr = OPEN_ERROR;
	return s;
}

stream *file_wstream( FILE *fp, char *name ){
	stream *s = file_stream(name);
	s->access = ST_WRITE;
	s->type = ST_BIN;
	if (fp != NULL){ 
		s->stream_data = (void*)fp;

		if (s->errnr == NO__ERROR){
	   		fwrite( (char*)&s->byteorder, sizeof(short), 
						1, (FILE*)s->stream_data);
		}
		return s;
	}
	s->errnr = OPEN_ERROR;
	return s;
}

stream *file_rastream( FILE *fp, char *name ){
	stream *s = file_stream(name);
	s->type = ST_ASCII;
	if (fp != NULL){ 
		s->stream_data = (void*)fp;
		return s;
	}
	s->errnr = OPEN_ERROR;
	return s;
}

stream *file_wastream( FILE *fp, char *name ){
	stream *s = file_stream(name);
	s->access = ST_WRITE;
	s->type = ST_ASCII;
	if (fp != NULL){ 
		s->stream_data = (void*)fp;
		return s;
	}
	s->errnr = OPEN_ERROR;
	return s;
} 

buffer *buffer_create( size_t size ){
	buffer *b = (buffer*)malloc(sizeof(buffer));
	b->pos = 0;
	b->buf = malloc(BUFSIZ);
	b->len = BUFSIZ;
	return b;
}

char *buffer_get_buf( buffer *b ){
	char *r = malloc(b->pos+1);
	memcpy(r,b->buf,b->pos);
	r[b->pos] = '\0';
	return r;
}

void buffer_destroy( buffer *b ){
	free(b->buf);
	free(b);
}

buffer *stream_get_buffer( stream *s ){
	return (buffer*)s->stream_data;
}

static size_t buffer_read( stream *s, char *buf, size_t elmsize, size_t cnt ){
	size_t size = elmsize*cnt;
	buffer *b = (buffer*)s->stream_data;
	if (b->pos+size <= b->len){
		memcpy(buf,b->buf+b->pos, size );
		b->pos += size;
		return size;
	} else {
		s->errnr = READ_ERROR;
		return 0;
	}
}
static size_t buffer_write( stream *s, char *buf, size_t elmsize, size_t cnt ){
	size_t size = elmsize*cnt;
	buffer *b = (buffer*)s->stream_data;
	if (b->pos+size > b->len){
		size_t ns = b->len;
		while(b->pos+size > ns) ns *= 2;
		b->buf = realloc(b->buf, ns);
		b->len = ns;
	}
	memcpy(b->buf+b->pos, buf, size );
	b->pos += size;
	return size;
}

static void buffer_close( stream *s ){ }
static void buffer_flush( stream *s ){ 
	buffer *b = (buffer*)s->stream_data;
	b->pos = 0;
}

stream *buffer_rastream( buffer *b, char *name ){
	stream *s = create_stream(name);
	s->type = ST_ASCII;
	s->read  = &buffer_read;
	s->write = &buffer_write;
	s->close = &buffer_close;
	s->error = &stream_error;
	s->flush = &buffer_flush;
	s->stream_data = (void*)b;
	return s;
}

stream *buffer_wastream( buffer *b, char *name ){
	stream *s = create_stream(name);
	s->access = ST_WRITE;
	s->type = ST_ASCII;
	s->read  = &buffer_read;
	s->write = &buffer_write;
	s->close = &buffer_close;
	s->error = &stream_error;
	s->flush = &buffer_flush;
	s->stream_data = (void*)b;
	return s;
}

typedef struct bs {
	stream *s;
	unsigned onr;
	unsigned inr;
	unsigned itotal;
	int eob; 
	char out[BLOCK];
	char in[BLOCK];
} bs;

static
bs *bs_create( stream *s ){
	/* should be a binary stream */
	bs *ns = (bs*)malloc(sizeof(bs));
	ns->s = s;
	ns->inr = 0;
	ns->itotal = 0;
	ns->onr = 0;
	ns->eob = 0;
	return ns;
}

static
size_t bs_write( stream *ss, char *buf, size_t elmsize, size_t cnt ){
	bs *s = (bs*)ss->stream_data;
	size_t todo = cnt * elmsize;
	if (s->onr + todo >= BLOCK){
		size_t rest = BLOCK - s->onr;
		memcpy( s->out+s->onr, buf, rest );
		buf += rest;
		todo -= rest;

		stream_writeInt( s->s, BLOCK);
		s->s->write( s->s, s->out, 1, BLOCK);
		s->onr = 0;

		while (todo >= BLOCK){
			stream_writeInt( s->s, BLOCK);
			s->s->write( s->s, buf, 1, BLOCK);
			buf += BLOCK;
			todo -= BLOCK;
		}
	}
	memcpy( s->out+s->onr, buf, todo );
	s->onr += todo;
	return cnt;
}

static
size_t bs_read( stream *ss, char *buf, size_t elmsize, size_t cnt ){
	bs *s = (bs*)ss->stream_data;
	unsigned nr = 0;

	size_t todo = cnt * elmsize;
	if (s->inr + todo < s->itotal) {
		memcpy( buf, s->in + s->inr, todo );

		s->inr += todo;
		return cnt;
	}
	if (todo + s->inr >= s->itotal) {
		size_t rest = s->itotal - s->inr;
		memcpy( buf, s->in + s->inr, rest );
		buf += rest;
		todo -= rest;

		s->inr = 0;
		s->itotal = 0;
	}
	if (s->eob){
		s->eob = 0;
		return cnt - (todo/elmsize);
	}
	while (todo >= BLOCK){
		stream_readInt( s->s, (int *) &nr );
		s->s->read( s->s, buf, 1, (size_t) nr);
		buf += nr;
		todo -= nr;
		if (nr < BLOCK){
			s->itotal = s->inr = 0;
			return cnt - (todo/elmsize);
		}
	} 
	if (todo){
		stream_readInt( s->s, (int *) &nr );

		if (nr < BLOCK)
			s->eob = 1;

		s->s->read( s->s, s->in, 1, (size_t) nr);
		if (nr < todo)
			memcpy( buf, s->in, (size_t) nr );
		else
			memcpy( buf, s->in, todo );
		s->itotal = nr;
                if (nr <= todo){
                        s->inr = nr;
			todo -= nr;
			s->eob = 0;
                } else {
                        s->inr = (int) todo; /* todo < BLOCK, i.e. will fit in int */
			todo = 0;
		}
	}
	if (todo){
		s->itotal = s->inr = 0;
		return cnt - (todo/elmsize);
	} else {
		return cnt;
	}
}

extern 
size_t bs_read_next( stream *ss, char *buf, int *last ){
	bs *s = (bs*)ss->stream_data;
	int nr = 0;

	*last = 0;
	if (s->itotal > s->inr ){
		size_t rest = s->itotal - s->inr;
		memcpy( buf, s->in + s->inr, rest );

		*last = (s->itotal != BLOCK);
		s->inr = 0;
		s->itotal = 0;
		s->eob = 0;
		return rest;
	} else {
		stream_readInt( s->s, &nr);
		s->s->read( s->s, buf, (size_t) 1, (size_t) nr);
		if (nr < BLOCK){
			*last = 1;
			s->itotal = s->inr = 0;
		} 
		return (size_t) nr;
	} 
}

static
void bs_flush(stream *ss){
	bs *s = (bs*)ss->stream_data;
	if (s->onr){
		stream_writeInt( s->s, s->onr);
		s->s->write( s->s, s->out, 1, s->onr );
	}
	s->onr = 0;
}

static
void bs_close( stream *ss ){
	bs *s = (bs*)ss->stream_data;
	s->s->close( s->s );
}
static
void bs_destroy( stream *ss ){
	bs *s = (bs*)ss->stream_data;
	s->s->destroy( s->s );
	free(s);
	stream_destroy(ss);
}

stream *block_stream( stream *s ){
	stream *ns = create_stream(s->name);
	bs *bs = bs_create(s);
	ns->type = s->type;
	ns->read  = &bs_read;
	ns->write = &bs_write;
	ns->close = &bs_close;
	ns->error = &stream_error;
	ns->flush = &bs_flush;
	ns->destroy = &bs_destroy;
	if (bs != NULL){ 
		ns->stream_data = (void*)bs;
		return ns;
	}
	ns->errnr = OPEN_ERROR;
	return ns;
}

int stream_readSht( stream *s, short *val ){
	int ok = s->read(s, (char*)val, sizeof(short), 1) == 1;
	if (!ok) s->errnr = READ_ERROR;
	if (s->byteorder != 1234)
		*val = short_int_SWAP(*val);	
	return ok;
}

int stream_writeSht( stream *s, const short val ){
	int ok = s->write(s, (char*)&val, sizeof(short), 1)==1;
	if (!ok) s->errnr = WRITE_ERROR;
	return ok;
}

extern int stream_readInt( stream *s, int *val ){
	int ok = s->read(s, (char*)val, sizeof(int), 1) == 1;
	if (!ok) s->errnr = READ_ERROR;
	if (s->byteorder != 1234)
		*val = normal_int_SWAP(*val);	
	return ok;
}
extern int stream_writeInt( stream *s, const int val ){
	int ok = s->write(s, (char*)&val, sizeof(int), (size_t)1)==1;
	if (!ok) s->errnr = WRITE_ERROR;
	return ok;
}

int stream_readLng( stream *s, lng *val ){
	int ok = s->read(s, (char*)val, sizeof(lng), (size_t)1) == 1;
	if (!ok) s->errnr = READ_ERROR;
	if (s->byteorder != 1234)
		*val = long_long_SWAP(*val);	
	return ok;
}

int stream_writeLng( stream *s, const lng val ){
	int ok = s->write(s, (char*)&val, sizeof(lng), (size_t)1)==1;
	if (!ok) s->errnr = WRITE_ERROR;
	return ok;
}

int stream_readShtArray( stream *s, short *val, size_t cnt ){
	int ok = s->read(s, (char*)val, sizeof(short), cnt) == cnt;
	if (!ok) s->errnr = READ_ERROR;
	if (s->byteorder != 1234){
		size_t i;
		for(i = 0; i<cnt; i++, val++)
			*val = short_int_SWAP(*val);	
	}
	return ok;
}

int stream_writeShtArray( stream *s, const short *val, size_t cnt ){
	int ok = s->write(s, (char*)val, sizeof(short), cnt)==cnt;
	if (!ok) s->errnr = WRITE_ERROR;
	return ok;
}

extern int stream_readIntArray( stream *s, int *val, size_t cnt ){
	int ok = s->read(s, (char*)val, sizeof(int), cnt) == cnt;
	if (!ok) s->errnr = READ_ERROR;
	if (s->byteorder != 1234){
		size_t i;
		for(i = 0; i<cnt; i++, val++)
			*val = normal_int_SWAP(*val);	
	}
	return ok;
}
extern int stream_writeIntArray( stream *s, const int *val, size_t cnt ){
	int ok = s->write(s, (char*)val, sizeof(int), cnt)==cnt;
	if (!ok) s->errnr = WRITE_ERROR;
	return ok;
}

int stream_readLngArray( stream *s, lng *val, size_t cnt ){
	int ok = s->read(s, (char*)val, sizeof(lng), cnt) == cnt;
	if (!ok) s->errnr = READ_ERROR;
	if (s->byteorder != 1234){
		size_t i;
		for(i = 0; i<cnt; i++, val++)
			*val = long_long_SWAP(*val);	
	}
	return ok;
}

int stream_writeLngArray( stream *s, const lng *val, size_t cnt ){
	int ok = s->write(s, (char*)val, sizeof(lng), cnt)==cnt;
	if (!ok) s->errnr = WRITE_ERROR;
	return ok;
}

extern int stream_printf( stream *s, const char *format, ...)
{
	char buf[BUFSIZ], *bf = buf;
	int i = 0;
	size_t bfsz = BUFSIZ;
	va_list ap; 

@= stream_printf_va_vsnprintf
	va_start(ap, format); 
	i = vsnprintf(bf, bfsz, format, ap);
	va_end (ap);
@c
	@:stream_printf_va_vsnprintf@
	while (i < 0 || (size_t) i >= bfsz) {
		if (i >= 0)		/* glibc 2.1 */
			bfsz = (size_t)i+1; /* precisely what is needed */
		else			/* glibc 2.0 */
			bfsz *= 2;	/* twice the old size */
		if (bf != buf) free(bf);
		bf = (char*) malloc (bfsz);
		assert(bf != NULL);
		@:stream_printf_va_vsnprintf@
	}
	s->write(s, bf, (size_t) i, (size_t) 1);
	if (bf != buf) free(bf);
	return i;
}


bstream *bstream_create( stream *s, size_t size )
{
	bstream *b = (bstream*)malloc(sizeof(bstream));
	b->s = s;
	b->buf = malloc(size + 1);
	b->size = size;
	b->pos = 0;
	b->len = 0;
	b->eof = 0;
	return b;
}

size_t bstream_read( bstream *s, size_t size )
{
	size_t len = 0, rd = 0;
	size_t used = s->len - s->pos;
	if (s->eof)
		return 0;
	while( size+used > s->size){
		s->size <<= 1; 
		s->buf = realloc(s->buf,s->size+1);
	}
	len = s->size - used;
	if (s->pos){
		memmove( s->buf, s->buf+s->pos, used);
		s->pos = 0; 
	}
	if ((rd = s->s->read(s->s, s->buf+used, 1, len)) < len) {
		s->eof = 1;
	}
	s->pos = 0;
	s->len = used + rd;
	s->buf[s->len] = 0; /* fill in the spare with EOS */
	return rd;
}

void bstream_destroy( bstream *s )
{
	free(s->buf);
	free(s);
}

void close_stream( stream *s )
{
	if (s && !s->errnr){
		s->close( s );
		s->destroy( s );
	} else if (s) {
		s->destroy( s );
	}
}

