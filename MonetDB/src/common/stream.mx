@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at 
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@' 
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@' 
@' The Original Code is the Monet Database System.
@' 
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2002 CWI.  
@' All Rights Reserved.
@' 
@' Contributor(s):
@' 		Martin Kersten <Martin.Kersten@cwi.nl>
@' 		Peter Boncz <Peter.Boncz@cwi.nl>
@' 		Niels Nes <Niels.Nes@cwi.nl>
@' 		Stefan Manegold  <Stefan.Manegold@cwi.nl>

@f stream
@a Niels Nes
@* An simple interface to streams 
This interface can be used to open 'non compressed, gzipped, bz2zipped' 
data files and sockets. Using this interface one could easily switch between
the various underlying storage types.

@h
#ifndef _STREAM_H_
#define _STREAM_H_

/*
 * File: stream.h 
 * Auteur: Niels J. Nes
 * Date: 09-01-2001
 * 
 * Version 0.1: start
 *
 * This is the general interface to input/output. Each stream will
 * contains some stream info (for now only byteorder). This is 
 * required for proper conversion on different byte order platforms.
 */

#include <monet_utils.h>

#include <ctype.h>

#ifdef HAVE_MALLOC_H
#include <malloc.h>
#endif
#include <signal.h>

#ifdef _MSC_VER
#ifndef LIBSTREAM
#define stream_export extern __declspec(dllimport) 
#else
#define stream_export extern __declspec(dllexport) 
#endif
#else
#define stream_export extern 
#endif

#define EOT 4

#define ST_ASCII  0
#define ST_BIN 1

#define ST_READ  0
#define ST_WRITE 1

typedef struct stream {
	short byteorder;
	short access;/* read/write */
	short type;/* ascii/binary */
	char *name;
	char *stream_data;
	int errnr;
	int (*read)( struct stream *s, char *buf, size_t elmsize, size_t cnt );
	int (*write)( struct stream *s, char *buf, size_t elmsize, size_t cnt );
	void (*close)( struct stream *s);
	char *(*error)( struct stream *s );
	void (*destroy)( struct stream *s );
	void (*flush)( struct stream *s );
} stream;

stream_export int stream_readInt( stream *s, int *val );
stream_export int stream_writeInt( stream *s, const int val );
stream_export int stream_printf( stream *s, const char *format, ...);

stream_export stream *open_rstream( char *filename );
stream_export stream *open_wstream( char *filename );
/* open in ascii stream in read mode */
stream_export stream *open_rastream( char *filename ); 
/* open in ascii stream in write mode*/
stream_export stream *open_wastream( char *filename ); 

#ifdef HAVE_LIBZ
stream_export stream *open_gzrstream( char *filename );
stream_export stream *open_gzwstream( char *filename );
stream_export stream *open_gzrastream( char *filename );
stream_export stream *open_gzwastream( char *filename );
#endif

#ifdef HAVE_LIBBZ2
stream_export stream *open_bzrstream( char *filename );
stream_export stream *open_bzwstream( char *filename );
stream_export stream *open_bzrastream( char *filename );
stream_export stream *open_bzwastream( char *filename );
#endif

stream_export stream *socket_rstream( int socket, char *name );
stream_export stream *socket_wstream( int socket, char *name );
stream_export stream *socket_rastream( int socket, char *name );
stream_export stream *socket_wastream( int socket, char *name );

stream_export stream *file_rstream( FILE *fp, char *name );
stream_export stream *file_wstream( FILE *fp, char *name );
stream_export stream *file_rastream( FILE *fp, char *name );
stream_export stream *file_wastream( FILE *fp, char *name );

typedef struct buffer {
	char *buf;
	int pos;
	int len;
} buffer;

stream_export buffer *buffer_create( int size );
stream_export char *buffer_get_buf( buffer *b );
stream_export void buffer_destroy( buffer *b );

stream_export stream *buffer_rastream( buffer *b, char *name );
stream_export stream *buffer_wastream( buffer *b, char *name );
stream_export buffer *stream_get_buffer( stream *s );

#define BLOCK 8192
/* 
   Block stream is a stream which sends data in blocks of a known
   size (BLOCK size or dynamically changed using CHANGE_BLOCK_SIZE msg).

   A block is writen once more then BLOCK size data has been writen using
   the write commands or when the flush command is send.

   All full blocks together with a single not full block from a major
   block. Major blocks can be used to synchronize the communication.
   Example server sends some reply, ie a major block consisting of
   verious minor blocks. The header of the major block can contain
   special info which the client can interpert.
   
   Each read attempt tries to return the number of bytes. Once a lower number
   of bytes can be read the end of the major block if found. The next
   read will then start with a new major block.
 */
stream_export stream *block_stream( stream *s );
stream_export int bs_read_next( stream *s, char *buf, int *last );

#endif /*_STREAM_H_*/
@c
#include <config.h>
#include "stream.h"
#include <string.h> 

#ifdef HAVE_NETDB_H
# include <sys/types.h> 
# include <netinet/in_systm.h> 
# include <netinet/in.h> 
# include <netinet/ip.h> 
# include <netinet/tcp.h>
# include <netdb.h> 
#endif
#ifdef HAVE_FCNTL_H
#include <fcntl.h>
#endif
#ifdef HAVE_LIBZ
	#include <zlib.h>
#endif
#ifdef HAVE_LIBBZ2
	#include <bzlib.h>
#endif

#include <dummy_gdk_utils.h>

#define convertInt(i) (((0x000000ff&(i))<<24) | ((0x0000ff00&(i))<<8) | \
                       ((0x00ff0000&(i))>>8)  | ((0xff000000&(i))>>24))


typedef enum steam_errors {
	NO__ERROR = 0,
	OPEN_ERROR,
	READ_ERROR, 
	WRITE_ERROR
}stream_errors;

#define EXT_LEN 4
static void get_extention( char *file, char *ext)
{
   	int j = 0;
	char *ext_start = strrchr( file, '.' );

	if (ext_start){
	    ext_start++;
            for (j = 0; j < EXT_LEN-1 && *ext_start; j++, ext_start++ )
                ext[j] = tolower(*ext_start);
        }
        ext[j] = '\0';
}

static void stream_destroy( stream *s){
	GDKfree(s->name);
	GDKfree(s);
}

static stream *create_stream( char *name ){
	stream *s = (stream*)GDKmalloc(sizeof(stream));
	/*assert(s);*/
	s->byteorder = 1234;
	s->access = ST_READ;
	s->type = ST_ASCII;
	s->name = GDKstrdup(name); 
	s->stream_data = NULL;
	s->errnr = NO__ERROR;
	s->destroy = &stream_destroy;
	return s;
}

static char *stream_error( stream *s ){
	char buf [BUFSIZ];
	switch(s->errnr){
	case OPEN_ERROR:
		sprintf(buf, "Error could not open file %s\n", s->name );
		return GDKstrdup(buf);
	case READ_ERROR:
		sprintf(buf, "Error reading file %s\n", s->name );
		return GDKstrdup(buf);
	case WRITE_ERROR:
		sprintf(buf, "Error writing file %s\n", s->name );
		return GDKstrdup(buf);
	}
	return GDKstrdup("Unkonwn error");
}

static int stream_read( stream *s, char *buf, size_t elmsize, size_t cnt ){
	return fread( buf, elmsize, cnt, (FILE*)s->stream_data);
}
static int stream_write( stream *s, char *buf, size_t elmsize, size_t cnt ){
	int res = fwrite( buf, elmsize, cnt, (FILE*)s->stream_data);
	fflush( (FILE*)s->stream_data );
	return res;
}

static void stream_close( stream *s ){
	FILE *fp = (FILE*)s->stream_data;
	if (!fp) return;
	if (fp != stdin && fp != stdout && fp != stderr)
		fclose( fp );
	else
		fflush( fp );
}
static void stream_flush( stream *s ){
	fflush( (FILE*)s->stream_data);
}
static stream *open_stream( char *filename, char *flags ){
	stream *s = create_stream(filename);
	FILE *fp = fopen( filename, flags );

	s->read  = &stream_read;
	s->write = &stream_write;
	s->close = &stream_close;
	s->error = &stream_error;
	s->flush = &stream_flush;
	if (fp != NULL){ 
		s->stream_data = (char*)fp;
		return s;
	}
	s->errnr = OPEN_ERROR;
	return s;
}

stream *open_rstream( char *filename ){
	stream *s;
  	char    ext[EXT_LEN];

  	get_extention(filename, ext);

#ifdef HAVE_LIBZ
  	if (!strcmp(ext,"gz" )){
		return open_gzrstream( filename );
	} else 
#else
  	if (!strcmp(ext,"gz" )){
		s = create_stream(filename);
		s->errnr = OPEN_ERROR;
		return s;
	} 
#endif
#ifdef HAVE_LIBBZ2
	if (!strcmp(ext,"bz2" )){
		return open_bzrstream( filename );
	} else 
#else
	if (!strcmp(ext,"bz2" )){
		s = create_stream(filename);
		s->errnr = OPEN_ERROR;
		return s;
	} 
#endif
	{
	  	s = open_stream( filename, "rb");
		s->type = ST_BIN;
		if (s->errnr == NO__ERROR)
	   		fread( (char*)&s->byteorder, sizeof(short), 
						1, (FILE*)s->stream_data);
		return s;
	}
}
stream *open_wstream( char *filename ){
	stream *s;
  	char    ext[EXT_LEN];

  	get_extention(filename, ext);

#ifdef HAVE_LIBZ
  	if (!strcmp(ext,"gz" )){
		return open_gzwstream( filename );
	} else
#else
  	if (!strcmp(ext,"gz" )){
		s = create_stream(filename);
		s->errnr = OPEN_ERROR;
		return s;
	} 
#endif
#ifdef HAVE_LIBBZ2
	if (!strcmp(ext,"bz2" )){
		return open_bzwstream( filename );
	} else 
#else
	if (!strcmp(ext,"bz2" )){
		s = create_stream(filename);
		s->errnr = OPEN_ERROR;
		return s;
	} 
#endif
	{
		s = open_stream( filename, "wb");
		s->access = ST_WRITE;
		s->type = ST_BIN;
		if (s->errnr == NO__ERROR)
	   		fwrite( (char*)&s->byteorder, sizeof(short), 
						1, (FILE*)s->stream_data);
		return s;
	}
}
stream *open_rastream( char *filename ){
	stream *s;
  	char    ext[EXT_LEN];

  	get_extention(filename, ext);

#ifdef HAVE_LIBZ
  	if (!strcmp(ext,"gz" )){
		return open_gzrastream( filename );
	} else
#else
  	if (!strcmp(ext,"gz" )){
		s = create_stream(filename);
		s->errnr = OPEN_ERROR;
		return s;
	} 
#endif
#ifdef HAVE_LIBBZ2
	if (!strcmp(ext,"bz2" )){
		return open_bzrastream( filename );
	} else 
#else
	if (!strcmp(ext,"bz2" )){
		s = create_stream(filename);
		s->errnr = OPEN_ERROR;
		return s;
	} 
#endif
	{
		s = open_stream( filename, "rb");
		s->type = ST_ASCII;
		return s;
	}
}
stream *open_wastream( char *filename ){
	stream *s;
  	char    ext[EXT_LEN];

  	get_extention(filename, ext);

#ifdef HAVE_LIBZ
  	if (!strcmp(ext,"gz" )){
		return open_gzwastream( filename );
	} else
#else
  	if (!strcmp(ext,"gz" )){
		s = create_stream(filename);
		s->errnr = OPEN_ERROR;
		return s;
	} 
#endif
#ifdef HAVE_LIBBZ2
	if (!strcmp(ext,"bz2" )){
		return open_bzwastream( filename );
	} else 
#else
	if (!strcmp(ext,"bz2" )){
		s = create_stream(filename);
		s->errnr = OPEN_ERROR;
		return s;
	} 
#endif
	{
		s = open_stream( filename, "wb");
		s->access = ST_WRITE;
		s->type = ST_ASCII;
		return s;
	}
}


#ifdef HAVE_LIBZ
static int stream_gzread( stream *s, char *buf, size_t elmsize, size_t cnt ){
	int size = elmsize*cnt;
	size = gzread( (gzFile*)s->stream_data, buf, size );
	if (size) return size/elmsize;
	return 0;
}
static int stream_gzwrite( stream *s, char *buf, size_t elmsize, size_t cnt ){
	int size = elmsize*cnt;
	size = gzwrite( (gzFile*)s->stream_data, buf, size );
	if (size) return size/elmsize;
	return 0;
}
static void stream_gzclose( stream *s ){
	gzclose( (gzFile*)s->stream_data);
}
static void stream_gzflush( stream *s ){
	gzflush( (gzFile*)s->stream_data, Z_SYNC_FLUSH);
}
stream *open_gzstream( char *filename, char *flags ){
	stream *s = create_stream(filename);
	gzFile *fp = gzopen( filename, flags );
	s->read  = &stream_gzread;
	s->write = &stream_gzwrite;
	s->close = &stream_gzclose;
	s->error = &stream_error;
	s->destroy = &stream_destroy;
	s->flush = &stream_gzflush;
	if (fp != NULL){ 
		s->stream_data = (char*)fp;
		return s;
	}
	s->errnr = OPEN_ERROR;
	return s;
}
stream *open_gzrstream( char *filename ){
	stream *s = open_gzstream( filename, "rb");
	s->type = ST_BIN;
	if (s->errnr == NO__ERROR)
	   gzread( (gzFile*)s->stream_data, (char*)&s->byteorder, sizeof(short));
	return s;
}
stream *open_gzwstream( char *filename ){
	stream *s = open_gzstream( filename, "wb");
	s->access = ST_WRITE;
	s->type = ST_BIN;
	if (s->errnr == NO__ERROR)
	   gzwrite( (gzFile*)s->stream_data, (char*)&s->byteorder, sizeof(short));
	return s;
}
stream *open_gzrastream( char *filename ){
	stream *s = open_gzstream( filename, "rb");
	s->type = ST_ASCII;
	return s;
}
stream *open_gzwastream( char *filename ){
	stream *s = open_gzstream( filename, "wb");
	s->access = ST_WRITE;
	s->type = ST_ASCII;
	return s;
}
#endif

#ifdef HAVE_LIBBZ2
static int stream_bzread( stream *s, char *buf, size_t elmsize, size_t cnt ){
	int size = elmsize*cnt;
	size = BZ2_bzread( (BZFILE*)s->stream_data, buf, size );
	if (size) return size/elmsize;
	return 0;
}
static int stream_bzwrite( stream *s, char *buf, size_t elmsize, size_t cnt ){
	int size = elmsize*cnt;
	size = BZ2_bzwrite( (BZFILE*)s->stream_data, buf, size );
	if (size) return size/elmsize;
	return 0;
}
static void stream_bzclose( stream *s ){
	BZ2_bzclose( (BZFILE*)s->stream_data);
}
static void stream_bzflush( stream *s ){
	BZ2_bzflush( (BZFILE*)s->stream_data);
}
stream *open_bzstream( char *filename, char *flags ){
	stream *s = create_stream(filename);
	BZFILE *fp = BZ2_bzopen( filename, flags );
	s->read  = &stream_bzread;
	s->write = &stream_bzwrite;
	s->close = &stream_bzclose;
	s->error = &stream_error;
	s->destroy = &stream_destroy;
	s->flush = &stream_bzflush;
	if (fp != NULL){ 
		s->stream_data = (char*)fp;
		return s;
	}
	s->errnr = OPEN_ERROR;
	return s;
}
stream *open_bzrstream( char *filename ){
	stream *s = open_bzstream( filename, "rb");
	s->type = ST_BIN;
	if (s->errnr == NO__ERROR) BZ2_bzread( 
		(BZFILE*)s->stream_data, (char*)&s->byteorder, sizeof(short) );
	return s;
}
stream *open_bzwstream( char *filename ){
	stream *s = open_bzstream( filename, "wb");
	s->access = ST_WRITE;
	s->type = ST_BIN;
	if (s->errnr == NO__ERROR) BZ2_bzwrite( 
		(BZFILE*)s->stream_data, (char*)&s->byteorder, sizeof(short) );
	return s;
}
stream *open_bzrastream( char *filename ){
	stream *s = open_bzstream( filename, "rb");
	s->type = ST_ASCII;
	return s;
}
stream *open_bzwastream( char *filename ){
	stream *s = open_bzstream( filename, "wb");
	s->access = ST_WRITE;
	s->type = ST_ASCII;
	return s;
}
#endif

static int socket_write( stream *s, char *buf, size_t elmsize, size_t cnt ){
	int size = elmsize*cnt;
#ifdef WIN32
	size = send( (int)s->stream_data, buf, size, 0 );
#else
	size = write( (int)s->stream_data, buf, size );
#endif
	if (size) return size/elmsize;
	return 0;
}
static int socket_read( stream *s, char *buf, size_t elmsize, size_t cnt ){
	int res = 0, size = elmsize*cnt, nr = 0;
	while( res < size && (
#ifdef WIN32
		(nr = recv( (int)s->stream_data, buf+res, size-res, 0 )) >= 0
#else
		(nr = read( (int)s->stream_data, buf+res, size-res )) > 0
#endif
		|| errno == EAGAIN)
	){
		 res += (nr>0)?nr:0;
	}
	if (nr < 0) return 0;
	if (size) return size/elmsize;
	return 0;
}
static void socket_flush( stream *s ){
	/* not needed */
}
static void socket_close( stream *s ){
	int fd = (int)s->stream_data;
	if (s->access == ST_READ)
		shutdown(fd,0);
	else
		shutdown(fd,1);
}

static
stream *socket_open( int socket, char *name ){
#ifndef NATIVE_WIN32
	int fl = fcntl(socket, F_GETFL);
#endif
	stream *s = create_stream(name);
	s->read  = &socket_read;
	s->write = &socket_write;
	s->close = &socket_close;
	s->error = &stream_error;
	s->flush = &socket_flush;
	s->stream_data = (char*)socket;

#ifdef SO_KEEPALIVE
	{ int opt = 0; 
	setsockopt(socket, SOL_SOCKET, SO_KEEPALIVE, (char *) &opt,
			                   sizeof(opt)); }
#endif
#ifdef IPTOS_THROUGHPUT
	{ int tos = IPTOS_THROUGHPUT; 
    	setsockopt(socket, IPPROTO_IP, IP_TOS, (void *) &tos, sizeof(tos)); }
#endif
#ifdef TCP_NODELAY
	{ int nodelay = 1;
    	setsockopt(socket, IPPROTO_TCP, TCP_NODELAY, (void *) &nodelay,
		                         sizeof(nodelay)); }
#endif
#ifndef NATIVE_WIN32
	fl &= ~O_NONBLOCK;
	fcntl(socket, F_SETFL, fl ); 
#endif

	return s;
}
stream *socket_rstream( int socket, char *name ){
	stream *s = socket_open( socket, name );
	s->type = ST_BIN;
	if (s->errnr == NO__ERROR)
		read( socket, (char*)&s->byteorder, sizeof(short)); 
	return s;
}

stream *socket_wstream( int socket, char *name ){
	stream *s = socket_open( socket, name );
	s->access = ST_WRITE;
	s->type = ST_BIN;
	if (s->errnr == NO__ERROR)
	   	write( socket, (char*)&s->byteorder, sizeof(short));
	return s;
}

stream *socket_rastream( int socket, char *name ){
	stream *s = socket_open( socket, name );
	s->type = ST_ASCII;
	return s;
}

stream *socket_wastream( int socket, char *name ){
	stream *s = socket_open( socket, name );
	s->access = ST_WRITE;
	s->type = ST_ASCII;
	return s;
}

stream *file_stream( char *name ){
	stream *s = create_stream(name);
	s->read  = &stream_read;
	s->write = &stream_write;
	s->close = &stream_close;
	s->error = &stream_error;
	s->flush = &stream_flush;
	return s;
}
stream *file_rstream( FILE *fp, char *name ){
	stream *s = file_stream(name);
	s->type = ST_BIN;
	if (fp != NULL){ 
		s->stream_data = (char*)fp;

		if (s->errnr == NO__ERROR)
	   		fread( (char*)&s->byteorder, sizeof(short), 
						1, (FILE*)s->stream_data);
		return s;
	}
	s->errnr = OPEN_ERROR;
	return s;
}

stream *file_wstream( FILE *fp, char *name ){
	stream *s = file_stream(name);
	s->access = ST_WRITE;
	s->type = ST_BIN;
	if (fp != NULL){ 
		s->stream_data = (char*)fp;

		if (s->errnr == NO__ERROR){
	   		fwrite( (char*)&s->byteorder, sizeof(short), 
						1, (FILE*)s->stream_data);
			fflush( (FILE*)s->stream_data );
		}
		return s;
	}
	s->errnr = OPEN_ERROR;
	return s;
}

stream *file_rastream( FILE *fp, char *name ){
	stream *s = file_stream(name);
	s->type = ST_ASCII;
	if (fp != NULL){ 
		s->stream_data = (char*)fp;
		return s;
	}
	s->errnr = OPEN_ERROR;
	return s;
}

stream *file_wastream( FILE *fp, char *name ){
	stream *s = file_stream(name);
	s->access = ST_WRITE;
	s->type = ST_ASCII;
	if (fp != NULL){ 
		s->stream_data = (char*)fp;
		return s;
	}
	s->errnr = OPEN_ERROR;
	return s;
} 

buffer *buffer_create( int size ){
	buffer *b = (buffer*)GDKmalloc(sizeof(buffer));
	b->pos = 0;
	b->buf = GDKmalloc(BUFSIZ);
	b->len = BUFSIZ;
	return b;
}

char *buffer_get_buf( buffer *b ){
	char *r = GDKmalloc(b->pos+1);
	memcpy(r,b->buf,b->pos);
	r[b->pos] = '\0';
	return r;
}

void buffer_destroy( buffer *b ){
	GDKfree(b->buf);
	GDKfree(b);
}

buffer *stream_get_buffer( stream *s ){
	return (buffer*)s->stream_data;
}

static int buffer_read( stream *s, char *buf, size_t elmsize, size_t cnt ){
	int size = elmsize*cnt;
	buffer *b = (buffer*)s->stream_data;
	if (b->pos+size <= b->len){
		memcpy(buf,b->buf+b->pos, size );
		b->pos += size;
		return size;
	} else {
		s->errnr = READ_ERROR;
		return 0;
	}
}
static int buffer_write( stream *s, char *buf, size_t elmsize, size_t cnt ){
	int size = elmsize*cnt;
	buffer *b = (buffer*)s->stream_data;
	if (b->pos+size > b->len){
		int ns = b->len;
		while(b->pos+size > ns) ns *= 2;
		b->buf = GDKrealloc(b->buf, ns);
		b->len = ns;
	}
	memcpy(b->buf+b->pos, buf, size );
	b->pos += size;
	return size;
}

static void buffer_close( stream *s ){ }
static void buffer_flush( stream *s ){ 
	buffer *b = (buffer*)s->stream_data;
	b->pos = 0;
}

stream *buffer_rastream( buffer *b, char *name ){
	stream *s = create_stream(name);
	s->type = ST_ASCII;
	s->read  = &buffer_read;
	s->write = &buffer_write;
	s->close = &buffer_close;
	s->error = &stream_error;
	s->flush = &buffer_flush;
	s->stream_data = (char*)b;
	return s;
}

stream *buffer_wastream( buffer *b, char *name ){
	stream *s = create_stream(name);
	s->access = ST_WRITE;
	s->type = ST_ASCII;
	s->read  = &buffer_read;
	s->write = &buffer_write;
	s->close = &buffer_close;
	s->error = &stream_error;
	s->flush = &buffer_flush;
	s->stream_data = (char*)b;
	return s;
}

typedef struct bs {
	stream *s;
	int onr;
	int inr;
	int itotal;
	char out[BLOCK];
	char in[BLOCK];
} bs;

static
bs *bs_create( stream *s ){
	/* should be a binary stream */
	bs *ns = (bs*)GDKmalloc(sizeof(bs));
	ns->s = s;
	ns->inr = 0;
	ns->itotal = 0;
	ns->onr = 0;
	return ns;
}

static
int bs_write( stream *ss, char *buf, size_t elmsize, size_t cnt ){
	bs *s = (bs*)ss->stream_data;
	int todo = cnt * elmsize;
	if (s->onr + todo >= BLOCK){
		int rest = BLOCK - s->onr;
		memcpy( s->out+s->onr, buf, rest );
		buf += rest;
		todo -= rest;

		stream_writeInt( s->s, BLOCK);
		s->s->write( s->s, s->out, 1, BLOCK);
		s->onr = 0;

		while (todo >= BLOCK){
			stream_writeInt( s->s, BLOCK);
			s->s->write( s->s, buf, 1, BLOCK);
			buf += BLOCK;
			todo -= BLOCK;
		}
	}
	memcpy( s->out+s->onr, buf, todo );
	s->onr += todo;
	return cnt;
}

static
int bs_read( stream *ss, char *buf, size_t elmsize, size_t cnt ){
	bs *s = (bs*)ss->stream_data;
	int nr = 0;

	int todo = cnt * elmsize;
	if (todo < s->itotal - s->inr){
		memcpy( buf, s->in + s->inr, todo );

		s->inr += todo;
		return cnt;
	}
	if (todo >= s->itotal - s->inr ){
		int rest = s->itotal - s->inr;
		memcpy( buf, s->in + s->inr, rest );
		buf += rest;
		todo -= rest;

		s->inr = 0;
		s->itotal = 0;
	}
	while (todo >= BLOCK){
		stream_readInt( s->s, &nr );
		s->s->read( s->s, buf, 1, nr);
		buf += nr;
		todo -= nr;
		if (nr < BLOCK){
			s->itotal = s->inr = 0;
			return cnt - (todo/elmsize);
		}
	} 
	if (todo){
		stream_readInt( s->s, &nr );
		s->s->read( s->s, s->in, 1, nr);
		if (nr < todo)
			memcpy( buf, s->in, nr );
		else
			memcpy( buf, s->in, todo );
		s->itotal = nr;
                if (nr <= todo){
                        s->inr = nr;
			todo -= nr;
                } else {
                        s->inr = todo;
			todo = 0;
		}
	}
	if (todo){
		s->itotal = s->inr = 0;
		return cnt - (todo/elmsize);
	} else {
		return cnt;
	}
}

extern 
int bs_read_next( stream *ss, char *buf, int *last ){
	bs *s = (bs*)ss->stream_data;
	int nr = 0;

	*last = 0;
	if (s->itotal > s->inr ){
		int rest = s->itotal - s->inr;
		memcpy( buf, s->in + s->inr, rest );

		*last = (s->itotal != BLOCK);
		s->inr = 0;
		s->itotal = 0;
		return rest;
	} else {
		stream_readInt( s->s, &nr);
		s->s->read( s->s, buf, 1, nr);
		if (nr < BLOCK){
			*last = 1;
			s->itotal = s->inr = 0;
		} 
		return nr;
	} 
}

static
void bs_flush(stream *ss){
	bs *s = (bs*)ss->stream_data;
	if (s->onr){
		stream_writeInt( s->s, s->onr);
		s->s->write( s->s, s->out, 1, s->onr );
	}
	s->onr = 0;
}

static
void bs_close( stream *ss ){
	bs *s = (bs*)ss->stream_data;
	s->s->close( s->s );
}
static
void bs_destroy( stream *ss ){
	bs *s = (bs*)ss->stream_data;
	s->s->destroy( s->s );
	GDKfree(s);
	stream_destroy(ss);
}

stream *block_stream( stream *s ){
	stream *ns = create_stream(s->name);
	bs *bs = bs_create(s);
	ns->type = s->type;
	ns->read  = &bs_read;
	ns->write = &bs_write;
	ns->close = &bs_close;
	ns->error = &stream_error;
	ns->flush = &bs_flush;
	ns->destroy = &bs_destroy;
	if (bs != NULL){ 
		ns->stream_data = (char*)bs;
		return ns;
	}
	ns->errnr = OPEN_ERROR;
	return ns;
}

extern int stream_readInt( stream *s, int *val ){
	int ok = s->read(s, (char*)val, sizeof(int), 1) == 1;
	if (!ok) s->errnr = READ_ERROR;
	if (s->byteorder != 1234)
		*val = convertInt(*val);	
	return ok;
}
extern int stream_writeInt( stream *s, const int val ){
	int ok = s->write(s, (char*)&val, sizeof(int), 1)==1;
	if (!ok) s->errnr = WRITE_ERROR;
	return ok;
}

extern int stream_printf( stream *s, const char *format, ...)
{
	char buf[BUFSIZ];
	int i = 0;
	va_list ap; 

	va_start(ap, format); 
	i = vsnprintf(buf, BUFSIZ-1, format, ap);
	va_end (ap); 

	if (i < BUFSIZ){
		s->write(s, buf, i, 1);
		return i;
	} else {
		char *a = GDKmalloc(i+1);

		va_start(ap, format); 
		i = vsnprintf(buf, i-1, format, ap);
		va_end (ap); 
		s->write(s, buf, i, 1);
		return i;
	}
}

