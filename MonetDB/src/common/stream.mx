@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@' 
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@' 
@' The Original Code is the Monet Database System.
@' 
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2003 CWI.
@' All Rights Reserved.
@' 
@' Contributor(s):
@' 		Martin Kersten <Martin.Kersten@cwi.nl>
@' 		Peter Boncz <Peter.Boncz@cwi.nl>
@' 		Niels Nes <Niels.Nes@cwi.nl>
@' 		Stefan Manegold  <Stefan.Manegold@cwi.nl>

@f stream
@a Niels Nes
@* An simple interface to streams 
Processing files, streams, and sockets is quite different on Linux and Windows
platforms. To improve portability between both, we advise to replace the stdio
actions with the stream functionality provided here.

This interface can also be used to open 'non compressed, gzipped, bz2zipped' 
data files and sockets. Using this interface one could easily switch between
the various underlying storage types.

@h
#ifndef _STREAM_H_
#define _STREAM_H_

/*
 * File: stream.h 
 * Auteur: Niels J. Nes
 * Date: 09-01-2001
 * 
 * Version 0.1: start
 *
 * This is the general interface to input/output. Each stream will
 * contains some stream info (for now only byteorder). This is 
 * required for proper conversion on different byte order platforms.
 */

#include <monet_utils.h>

#include <unistd.h>
#include <ctype.h>
#include <assert.h>

#ifdef HAVE_MALLOC_H
#include <malloc.h>
#endif
#include <signal.h>

#ifdef _MSC_VER
#ifndef LIBSTREAM
#define stream_export extern __declspec(dllimport) 
#else
#define stream_export extern __declspec(dllexport) 
#endif
#else
#define stream_export extern 
#endif

#define EOT 4

#define ST_ASCII  0
#define ST_BIN 1

#define ST_READ  0
#define ST_WRITE 1

#define short_int_SWAP(s) (((0x00ff&(s))<<8) | ((0xff00&(s))>>8))

#define normal_int_SWAP(i) (((0x000000ff&(i))<<24) | ((0x0000ff00&(i))<<8) | \
	               ((0x00ff0000&(i))>>8)  | ((0xff000000&(i))>>24))

#define long_long_SWAP(l) \
		((((lng)normal_int_SWAP(l))<<32) |\
		 (0xffffffff&normal_int_SWAP(l>>32)))

typedef struct stream stream;

/* some os specific initialization */
stream_export int stream_init(void);

stream_export int stream_readSht( stream *s, short *val );
stream_export int stream_writeSht( stream *s, short val );
stream_export int stream_readInt( stream *s, int *val );
stream_export int stream_writeInt( stream *s, int val );
stream_export int stream_readLng( stream *s, lng *val );
stream_export int stream_writeLng( stream *s, lng val );

stream_export int stream_readShtArray( stream *s, short *val, size_t cnt );
stream_export int stream_writeShtArray( stream *s, const short *val, size_t cnt );
stream_export int stream_readIntArray( stream *s, int *val, size_t cnt );
stream_export int stream_writeIntArray( stream *s, const int *val, size_t cnt );
stream_export int stream_readLngArray( stream *s, lng *val, size_t cnt );
stream_export int stream_writeLngArray( stream *s, const lng *val, size_t cnt );
stream_export int stream_printf( stream *s, const char *format, ...);
stream_export ssize_t stream_read(stream *s, void *buf, size_t elmsize, size_t cnt);
stream_export ssize_t stream_write(stream *s, void *buf, size_t elmsize, size_t cnt);
stream_export void stream_close(stream *s);
stream_export void stream_destroy(stream *s);
stream_export char *stream_error(stream *s);
stream_export void stream_flush(stream *s);
stream_export char *stream_name(stream *s);
stream_export int stream_errnr(stream *s);
stream_export int stream_byteorder(stream *s);
stream_export stream *stream_rstream(stream *s);
stream_export stream *stream_wstream(stream *s);

stream_export stream *open_rstream( const char *filename );
stream_export stream *open_wstream( const char *filename );
/* open in ascii stream in read mode */
stream_export stream *open_rastream( const char *filename ); 
/* open in ascii stream in write mode*/
stream_export stream *open_wastream( const char *filename ); 

#ifdef HAVE_LIBZ
stream_export stream *open_gzrstream( const char *filename );
stream_export stream *open_gzwstream( const char *filename );
stream_export stream *open_gzrastream( const char *filename );
stream_export stream *open_gzwastream( const char *filename );
#endif

#ifdef HAVE_LIBBZ2
stream_export stream *open_bzrstream( const char *filename );
stream_export stream *open_bzwstream( const char *filename );
stream_export stream *open_bzrastream( const char *filename );
stream_export stream *open_bzwastream( const char *filename );
#endif

stream_export void close_stream( stream *s );

stream_export stream *socket_rstream( int socket, const char *name );
stream_export stream *socket_wstream( int socket, const char *name );
stream_export stream *socket_rastream( int socket, const char *name );
stream_export stream *socket_wastream( int socket, const char *name );

#ifdef HAVE_OPENSSL
#include <openssl/ssl.h>
#include <openssl/err.h>

stream_export stream *ssl_rstream(SSL *ssl, const char *name);
stream_export stream *ssl_wstream(SSL *ssl, const char *name);
stream_export stream *ssl_rastream(SSL *ssl, const char *name);
stream_export stream *ssl_wastream(SSL *ssl, const char *name);
#endif

stream_export stream *file_rstream( FILE *fp, const char *name );
stream_export stream *file_wstream( FILE *fp, const char *name );
stream_export stream *file_rastream( FILE *fp, const char *name );
stream_export stream *file_wastream( FILE *fp, const char *name );

typedef struct buffer {
	char *buf;
	size_t pos;
	size_t len;
} buffer;

stream_export buffer *buffer_create( size_t size );
stream_export char *buffer_get_buf( buffer *b );
stream_export void buffer_destroy( buffer *b );

stream_export stream *buffer_rastream( buffer *b, const char *name );
stream_export stream *buffer_wastream( buffer *b, const char *name );
stream_export buffer *stream_get_buffer( stream *s );

#define BLOCK 8192
/* 
   Block stream is a stream which sends data in blocks of a known
   size (BLOCK size or dynamically changed using CHANGE_BLOCK_SIZE msg).

   A block is written once more then BLOCK size data has been written using
   the write commands or when the flush command is send.

   All full blocks together with a single not full block from a major
   block. Major blocks can be used to synchronize the communication.
   Example server sends some reply, ie a major block consisting of
   verious minor blocks. The header of the major block can contain
   special info which the client can interpert.
   
   Each read attempt tries to return the number of bytes. Once a lower number
   of bytes can be read the end of the major block if found. The next
   read will then start with a new major block.
 */
stream_export stream *block_stream( stream *s );
stream_export ssize_t bs_read_next( stream *s, void *buf, int *last );
stream_export int isa_block_stream(stream *s);

@+ buffered streams

The bstream (or buffered_stream) can be used for efficient reading
of a stream. Reading can be done in large chunks and 
access can be done in smaller bits, by directly accessing the underlying 
buffer.

@h
typedef struct bstream {
	stream *s;
	char *buf; 
	size_t size; /* size of buf */
	size_t pos; /* the data cursor (ie read uptil pos) */
	size_t len; /* len of the data (could < size but usually == size) */
	int eof;
} bstream;

stream_export bstream *bstream_create( stream *rs, size_t chunk_size );
stream_export void bstream_destroy( bstream *s );
stream_export size_t bstream_read( bstream *s, size_t size );

@+ bstream functions
The bstream_create gets a read stream (rs) as input and the initial chunk size
and creates a buffered stream from this. A spare byte is kept at the end 
of the buffer.
The bstream_read will atleast read the next 'size' bytes. If the not read data
(aka pos < len) together with the new data will not fit in the current buffer
it is resized. The spare byte is kept.

@h

typedef enum stream_errors {
	NO__ERROR = 0,
	OPEN_ERROR,
	READ_ERROR, 
	WRITE_ERROR
}stream_errors;
#endif /*_STREAM_H_*/
@c
#include "stream.h"
#include <string.h>

#ifdef HAVE_SYS_SOCKET_H
#include <sys/socket.h>
#endif

#ifdef HAVE_NETDB_H
# include <sys/types.h> 
# include <netinet/in_systm.h> 
# include <netinet/in.h> 
# include <netinet/ip.h> 
# include <netinet/tcp.h>
# include <netdb.h> 
#endif
#ifdef HAVE_FCNTL_H
#include <fcntl.h>
#endif
#ifdef HAVE_LIBZ
	#include <zlib.h>
#endif
#ifdef HAVE_LIBBZ2
	#include <bzlib.h>
#endif
#ifdef NATIVE_WIN32
#include <winsock.h>
#include <io.h>
#endif

struct stream {
	short byteorder;
	short access;/* read/write */
	short type;/* ascii/binary */
	char *name;
	union {
		void *p;
		int i;
	} stream_data;
	int errnr;
	ssize_t (*read)(stream *s, void *buf, size_t elmsize, size_t cnt);
	ssize_t (*write)(stream *s, void *buf, size_t elmsize, size_t cnt);
	void (*close)(stream *s);
	char *(*error)(stream *s);
	void (*destroy)(stream *s);
	void (*flush)(stream *s);
};

#if !HAVE_DECL_STRDUP
#ifdef HAVE_STRDUP
extern char *strdup(const char *);
#else
#define strdup(s)	strcpy(malloc(strlen(s)),(s))
#endif
#endif

int stream_init(void)
{
#ifdef NATIVE_WIN32
	int sockopt = SO_SYNCHRONOUS_NONALERT;
	WSADATA w;

	if (WSAStartup(0x0101, &w) != 0){
		return -1;
	}
	if ( setsockopt(INVALID_SOCKET, SOL_SOCKET, SO_OPENTYPE, 
		(void*)&sockopt, sizeof(sockopt)) < 0){
		WSACleanup();
		return -1;
	}
#endif
#ifdef HAVE_OPENSSL
	SSL_load_error_strings();
	(void) SSL_library_init();
#endif
	return 0;
}

/* #define STREAM_DEBUG 1 */

#ifdef STREAM_DEBUG
/* code adapted from gdk.mx */
/* define printf formats for printing size_t and ssize_t variables */
#if defined(__STDC_VERSION__) && __STDC_VERSION__ >= 199901
#define SZFMT "%zu"
#elif SIZEOF_SIZE_T == SIZEOF_INT
#define SZFMT "%u"
#elif SIZEOF_SIZE_T == SIZEOF_LONG
#define SZFMT "%lu"
#elif SIZEOF_SIZE_T == SIZEOF_LONG_LONG
#define SZFMT "%llu"
#elif SIZEOF_SIZE_T == SIZEOF___INT64
#define SZFMT "%I64u"
#else
#error no definition for SZFMT
#endif
/* define printf format for printing pointer values */
#if defined(__STDC_VERSION__) && __STDC_VERSION__ >= 199901
#define PTRFMT "%p"
#elif SIZEOF_VOID_P == SIZEOF_INT
#define PTRFMT "%x"
#elif SIZEOF_VOID_P == SIZEOF_LONG
#define PTRFMT "%lx"
#elif SIZEOF_VOID_P == SIZEOF_LONG_LONG
#define PTRFMT "%llx"
#elif SIZEOF_VOID_P == SIZEOF___INT64
#define PTRFMT "%I64x"
#else
#error no definition for PTRFMT
#endif
#endif	/* STREAM_DEBUG */

ssize_t stream_read(stream *s, void *buf, size_t elmsize, size_t cnt)
{
#ifdef STREAM_DEBUG
	printf("read %s " SZFMT " " SZFMT "\n", s->name ? s->name : "<unnamed>", elmsize, cnt);
#endif
	assert(s->access == ST_READ);
	return (*s->read)(s, buf, elmsize, cnt);
}

ssize_t stream_write(stream *s, void *buf, size_t elmsize, size_t cnt)
{
#ifdef STREAM_DEBUG
	printf("write %s " SZFMT " " SZFMT "\n", s->name ? s->name : "<unnamed>", elmsize, cnt);
#endif
	assert(s->access == ST_WRITE);
	return (*s->write)(s, buf, elmsize, cnt);
}

void stream_close(stream *s)
{
#ifdef STREAM_DEBUG
	printf("close %s\n", s->name ? s->name : "<unnamed>");
#endif
	(*s->close)(s);
}

void stream_destroy(stream *s)
{
#ifdef STREAM_DEBUG
	printf("destroy %s\n", s->name ? s->name : "<unnamed>");
#endif
	(*s->destroy)(s);
}

char *stream_error(stream *s)
{
	return (*s->error)(s);
}

void stream_flush(stream *s)
{
#ifdef STREAM_DEBUG
	printf("flush %s\n", s->name ? s->name : "<unnamed>");
#endif
	if (s->flush)
		(*s->flush)(s);
}

char *stream_name(stream *s)
{
	return s->name;
}

int stream_errnr(stream *s)
{
	return s->errnr;
}

int stream_byteorder(stream *s)
{
	return s->byteorder;
}

stream *stream_rstream(stream *s)
{
#ifdef STREAM_DEBUG
	printf("stream_rstream %s\n", s->name ? s->name : "<unnamed>");
#endif
	assert(s->access == ST_READ);
	s->type = ST_BIN;
	if (s->errnr == NO__ERROR)
		s->read(s, (void *) &s->byteorder, sizeof(short), 1);
	return s;
}

stream *stream_wstream(stream *s)
{
#ifdef STREAM_DEBUG
	printf("stream_wstream %s\n", s->name ? s->name : "<unnamed>");
#endif
	assert(s->access == ST_WRITE);
	s->type = ST_BIN;
	if (s->errnr == NO__ERROR)
		s->write(s, (void *) &s->byteorder, sizeof(short), 1);
	return s;
}

#define EXT_LEN 4
static void get_extention( const char *file, char *ext)
{
   	int j = 0;
	char *ext_start = strrchr( file, '.' );

	if (ext_start){
	    ext_start++;
            for (j = 0; j < EXT_LEN-1 && *ext_start; j++, ext_start++ )
                ext[j] = tolower(*ext_start);
        }
        ext[j] = '\0';
}

static void destroy( stream *s)
{
	free(s->name);
	free(s);
}

static stream *create_stream( const char *name )
{
	stream *s = (stream*)malloc(sizeof(stream));
	/*assert(s);*/
	s->byteorder = 1234;
	s->access = ST_READ;
	s->type = ST_ASCII;
	s->name = strdup(name); 
	s->stream_data.p = NULL;
	s->errnr = NO__ERROR;
	s->destroy = destroy;
#ifdef STREAM_DEBUG
	printf("create_stream %s -> " PTRFMT "\n", name ? name : "<unnamed>", s);
#endif
	return s;
}

static char *error( stream *s )
{
	char buf [BUFSIZ];
	switch(s->errnr){
	case OPEN_ERROR:
		snprintf(buf, BUFSIZ, 
				"Error could not open file %s\n", s->name );
		return strdup(buf);
	case READ_ERROR:
		snprintf(buf, BUFSIZ, "Error reading file %s\n", s->name );
		return strdup(buf);
	case WRITE_ERROR:
		snprintf(buf, BUFSIZ, "Error writing file %s\n", s->name );
		return strdup(buf);
	}
	return strdup("Unkonwn error");
}

static ssize_t file_read( stream *s, void *buf, size_t elmsize, size_t cnt )
{
	FILE *fp = (FILE*)s->stream_data.p;
	if (!feof(fp))
		return fread( buf, elmsize, cnt, fp);
	return 0;
}

static ssize_t file_write( stream *s, void *buf, size_t elmsize, size_t cnt )
{
	size_t res = fwrite( buf, elmsize, cnt, (FILE*)s->stream_data.p);
	return res;
}

static void file_close( stream *s )
{
	FILE *fp = (FILE*)s->stream_data.p;
	if (!fp) return;
	if (fp != stdin && fp != stdout && fp != stderr)
		fclose( fp );
	else if (s->access == ST_WRITE)
		fflush( fp );
	s->stream_data.p = NULL;
}

static void file_flush( stream *s )
{
	if (s->access == ST_WRITE)
		fflush( (FILE*)s->stream_data.p);
}

static stream *open_stream( const char *filename, const char *flags )
{
	stream *s = create_stream(filename);
	FILE *fp = fopen( filename, flags );

	s->read  = file_read;
	s->write = file_write;
	s->close = file_close;
	s->error = error;
	s->flush = file_flush;
	if (fp != NULL){ 
		s->stream_data.p = (void*)fp;
		return s;
	}
	s->errnr = OPEN_ERROR;
	return s;
}

stream *open_rstream( const char *filename )
{
	stream *s;
  	char    ext[EXT_LEN];

#ifdef STREAM_DEBUG
	printf("open_rstream %s\n", filename);
#endif
  	get_extention(filename, ext);

#ifdef HAVE_LIBZ
  	if (!strcmp(ext,"gz" )){
		return open_gzrstream( filename );
	} else 
#else
  	if (!strcmp(ext,"gz" )){
		s = create_stream(filename);
		s->errnr = OPEN_ERROR;
		return s;
	} 
#endif
#ifdef HAVE_LIBBZ2
	if (!strcmp(ext,"bz2" )){
		return open_bzrstream( filename );
	} else 
#else
	if (!strcmp(ext,"bz2" )){
		s = create_stream(filename);
		s->errnr = OPEN_ERROR;
		return s;
	} 
#endif
	{
	  	s = open_stream( filename, "rb");
		s->type = ST_BIN;
		if (s->errnr == NO__ERROR)
	   		fread( (void *) &s->byteorder, sizeof(short), 
						1, (FILE*)s->stream_data.p);
		return s;
	}
}
stream *open_wstream( const char *filename )
{
	stream *s;
  	char    ext[EXT_LEN];

#ifdef STREAM_DEBUG
	printf("open_wstream %s\n", filename);
#endif
  	get_extention(filename, ext);

#ifdef HAVE_LIBZ
  	if (!strcmp(ext,"gz" )){
		return open_gzwstream( filename );
	} else
#else
  	if (!strcmp(ext,"gz" )){
		s = create_stream(filename);
		s->errnr = OPEN_ERROR;
		return s;
	} 
#endif
#ifdef HAVE_LIBBZ2
	if (!strcmp(ext,"bz2" )){
		return open_bzwstream( filename );
	} else 
#else
	if (!strcmp(ext,"bz2" )){
		s = create_stream(filename);
		s->errnr = OPEN_ERROR;
		return s;
	} 
#endif
	{
		s = open_stream( filename, "wb");
		s->access = ST_WRITE;
		s->type = ST_BIN;
		if (s->errnr == NO__ERROR)
	   		fwrite( (void*)&s->byteorder, sizeof(short), 
						1, (FILE*)s->stream_data.p);
		return s;
	}
}
stream *open_rastream( const char *filename )
{
	stream *s;
  	char    ext[EXT_LEN];

#ifdef STREAM_DEBUG
	printf("open_rastream %s\n", filename);
#endif
  	get_extention(filename, ext);

#ifdef HAVE_LIBZ
  	if (!strcmp(ext,"gz" )){
		return open_gzrastream( filename );
	} else
#else
  	if (!strcmp(ext,"gz" )){
		s = create_stream(filename);
		s->errnr = OPEN_ERROR;
		return s;
	} 
#endif
#ifdef HAVE_LIBBZ2
	if (!strcmp(ext,"bz2" )){
		return open_bzrastream( filename );
	} else 
#else
	if (!strcmp(ext,"bz2" )){
		s = create_stream(filename);
		s->errnr = OPEN_ERROR;
		return s;
	} 
#endif
	{
		s = open_stream( filename, "r");
		s->type = ST_ASCII;
		return s;
	}
}
stream *open_wastream( const char *filename )
{
	stream *s;
  	char    ext[EXT_LEN];

#ifdef STREAM_DEBUG
	printf("open_wastream %s\n", filename);
#endif
  	get_extention(filename, ext);

#ifdef HAVE_LIBZ
  	if (!strcmp(ext,"gz" )){
		return open_gzwastream( filename );
	} else
#else
  	if (!strcmp(ext,"gz" )){
		s = create_stream(filename);
		s->errnr = OPEN_ERROR;
		return s;
	} 
#endif
#ifdef HAVE_LIBBZ2
	if (!strcmp(ext,"bz2" )){
		return open_bzwastream( filename );
	} else 
#else
	if (!strcmp(ext,"bz2" )){
		s = create_stream(filename);
		s->errnr = OPEN_ERROR;
		return s;
	} 
#endif
	{
		s = open_stream( filename, "w");
		s->access = ST_WRITE;
		s->type = ST_ASCII;
		return s;
	}
}


#ifdef HAVE_LIBZ
static ssize_t stream_gzread( stream *s, void *buf, size_t elmsize, size_t cnt )
{
	int size = (int)(elmsize*cnt);
	size = gzread( (gzFile*)s->stream_data.p, buf, size );
	if (size) return size/elmsize;
	return 0;
}
static ssize_t stream_gzwrite( stream *s, void *buf, size_t elmsize, size_t cnt)
{
	int size = (int)(elmsize*cnt);
	size = gzwrite( (gzFile*)s->stream_data.p, buf, size );
	if (size) return size/elmsize;
	return 0;
}
static void stream_gzclose( stream *s )
{
	if (s->stream_data.p)
		gzclose( (gzFile*)s->stream_data.p);
	s->stream_data.p = NULL;
}
static void stream_gzflush( stream *s )
{
	if (s->access == ST_WRITE)
		gzflush( (gzFile*)s->stream_data.p, Z_SYNC_FLUSH);
}
stream *open_gzstream( const char *filename, const char *flags )
{
	stream *s = create_stream(filename);
	gzFile *fp = gzopen( filename, flags );
	s->read  = stream_gzread;
	s->write = stream_gzwrite;
	s->close = stream_gzclose;
	s->error = error;
	s->destroy = destroy;
	s->flush = stream_gzflush;
	if (fp != NULL){ 
		s->stream_data.p = (void*)fp;
		return s;
	}
	s->errnr = OPEN_ERROR;
	return s;
}
stream *open_gzrstream( const char *filename )
{
	stream *s = open_gzstream( filename, "rb");
	s->type = ST_BIN;
	if (s->errnr == NO__ERROR)
	   gzread( (gzFile*)s->stream_data.p, (void*)&s->byteorder, sizeof(short));
	return s;
}
stream *open_gzwstream( const char *filename )
{
	stream *s = open_gzstream( filename, "wb");
	s->access = ST_WRITE;
	s->type = ST_BIN;
	if (s->errnr == NO__ERROR)
	   gzwrite( (gzFile*)s->stream_data.p, (void*)&s->byteorder, sizeof(short));
	return s;
}
stream *open_gzrastream( const char *filename )
{
	stream *s = open_gzstream( filename, "rb");
	s->type = ST_ASCII;
	return s;
}
stream *open_gzwastream( const char *filename )
{
	stream *s = open_gzstream( filename, "wb");
	s->access = ST_WRITE;
	s->type = ST_ASCII;
	return s;
}
#endif

#ifdef HAVE_LIBBZ2
static ssize_t stream_bzread( stream *s, void *buf, size_t elmsize, size_t cnt )
{
	int size = (int)(elmsize*cnt);
	size = BZ2_bzread( (BZFILE*)s->stream_data.p, buf, size );
	if (size) return size/elmsize;
	return 0;
}
static ssize_t stream_bzwrite( stream *s, void *buf, size_t elmsize, size_t cnt)
{
	int size = (int)(elmsize*cnt);
	size = BZ2_bzwrite( (BZFILE*)s->stream_data.p, buf, size );
	if (size) return size/elmsize;
	return 0;
}
static void stream_bzclose( stream *s )
{
	if (s->stream_data.p)
		BZ2_bzclose( (BZFILE*)s->stream_data.p);
	s->stream_data.p = NULL;
}
static void stream_bzflush( stream *s )
{
	if (s->access == ST_WRITE)
		BZ2_bzflush( (BZFILE*)s->stream_data.p);
}
stream *open_bzstream( const char *filename, const char *flags )
{
	stream *s = create_stream(filename);
	BZFILE *fp = BZ2_bzopen( filename, flags );
	s->read  = stream_bzread;
	s->write = stream_bzwrite;
	s->close = stream_bzclose;
	s->error = error;
	s->destroy = destroy;
	s->flush = stream_bzflush;
	if (fp != NULL){ 
		s->stream_data.p = (void*)fp;
		return s;
	}
	s->errnr = OPEN_ERROR;
	return s;
}
stream *open_bzrstream( const char *filename )
{
	stream *s = open_bzstream( filename, "rb");
	s->type = ST_BIN;
	if (s->errnr == NO__ERROR) BZ2_bzread( 
		(BZFILE*)s->stream_data.p, (void*)&s->byteorder, sizeof(short) );
	return s;
}
stream *open_bzwstream( const char *filename )
{
	stream *s = open_bzstream( filename, "wb");
	s->access = ST_WRITE;
	s->type = ST_BIN;
	if (s->errnr == NO__ERROR) BZ2_bzwrite( 
		(BZFILE*)s->stream_data.p, (void*)&s->byteorder, sizeof(short) );
	return s;
}
stream *open_bzrastream( const char *filename )
{
	stream *s = open_bzstream( filename, "rb");
	s->type = ST_ASCII;
	return s;
}
stream *open_bzwastream( const char *filename )
{
	stream *s = open_bzstream( filename, "wb");
	s->access = ST_WRITE;
	s->type = ST_ASCII;
	return s;
}
#endif

static ssize_t socket_write( stream *s, void *buf, size_t elmsize, size_t cnt )
{
	size_t size = elmsize*cnt;
	ssize_t sz;

	assert(!s->errnr);
#ifdef NATIVE_WIN32
	sz = send( s->stream_data.i, buf, size, 0 );
#else
	sz = write( s->stream_data.i, buf, size );
#endif
	if (sz > 0) return (size_t)sz/elmsize;
	if (sz < 0) 
		s->errnr = WRITE_ERROR;
	return sz;
}
static ssize_t socket_read( stream *s, void *buf, size_t elmsize, size_t cnt )
{
	ssize_t nr = 0;
	size_t res = 0, size = elmsize*cnt;

	assert(!s->errnr);
	while( res < size && (
#ifdef NATIVE_WIN32
		(nr = recv( s->stream_data.i, (void *) ((char *) buf + res), size-res, 0 )) > 0
#else
		(nr = read( s->stream_data.i, (void *) ((char *) buf + res), size-res )) > 0
#endif
		|| errno == EAGAIN)
	){
		 res += (nr>0)?nr:0;
	}
	if (nr < 0){
		s->errnr = READ_ERROR;
		return nr;
	}
	if (res) return res/elmsize;
	return 0;
}

static void socket_close( stream *s )
{
	int fd = s->stream_data.i;
	if (fd >= 0) {
		if (s->access == ST_READ)
			shutdown(fd, 0);
		else
			shutdown(fd, 1);
		close(fd);
	}
	s->stream_data.i = -1;
}

static
stream *socket_open( int socket, const char *name )
{
	stream *s = create_stream(name);
	s->read  = socket_read;
	s->write = socket_write;
	s->close = socket_close;
	s->error = error;
	s->flush = NULL;
	s->stream_data.i = socket;

#ifdef SO_KEEPALIVE
	{ int opt = 0; 
	setsockopt(socket, SOL_SOCKET, SO_KEEPALIVE, (void *) &opt,
			                   sizeof(opt)); }
#endif
#ifdef IPTOS_THROUGHPUT
	{ int tos = IPTOS_THROUGHPUT; 
    	setsockopt(socket, IPPROTO_IP, IP_TOS, (void *) &tos, sizeof(tos)); }
#endif
#ifdef TCP_NODELAY
	{ int nodelay = 1;
    	setsockopt(socket, IPPROTO_TCP, TCP_NODELAY, (void *) &nodelay,
		                         sizeof(nodelay)); }
#endif
#ifndef NATIVE_WIN32
	{ int fl = fcntl(socket, F_GETFL);
	fl &= ~O_NONBLOCK;
	fcntl(socket, F_SETFL, fl ); }
#endif

	return s;
}
stream *socket_rstream( int socket, const char *name )
{
	stream *s;
#ifdef STREAM_DEBUG
	printf("socket_rstream %d %s\n", socket, name);
#endif
	s = socket_open( socket, name );
	s->type = ST_BIN;
	if (s->errnr == NO__ERROR)
		socket_read(s, (void*)&s->byteorder, sizeof(short), 1);
	return s;
}

stream *socket_wstream( int socket, const char *name )
{
	stream *s;
#ifdef STREAM_DEBUG
	printf("socket_wstream %d %s\n", socket, name);
#endif
	s = socket_open( socket, name );
	s->access = ST_WRITE;
	s->type = ST_BIN;
	if (s->errnr == NO__ERROR)
		socket_write(s, (void*)&s->byteorder, sizeof(short), 1);
	return s;
}

stream *socket_rastream( int socket, const char *name )
{
	stream *s;
#ifdef STREAM_DEBUG
	printf("socket_rastream %d %s\n", socket, name);
#endif
	s = socket_open( socket, name );
	s->type = ST_ASCII;
	return s;
}

stream *socket_wastream( int socket, const char *name )
{
	stream *s;
#ifdef STREAM_DEBUG
	printf("socket_wastream %d %s\n", socket, name);
#endif
	s = socket_open( socket, name );
	s->access = ST_WRITE;
	s->type = ST_ASCII;
	return s;
}

#ifdef HAVE_OPENSSL
struct ssl_data {
	int error;
	int ret;
	SSL *ssl;
};

static ssize_t ssl_read(stream *s, void *buf, size_t elmsize, size_t cnt)
{
	SSL *ssl;
	size_t res = 0, size = elmsize * cnt;

	assert(s->stream_data.p);
	ssl = ((struct ssl_data *) s->stream_data.p)->ssl;
	assert(ssl);
	assert(!s->errnr);
	while (res < size) {
		int nr, err;

		nr = SSL_read(ssl, (void *) ((char *) buf + res),
			      (int) (size - res));
		err = SSL_get_error(ssl, nr);
		switch (err) {
		case SSL_ERROR_WANT_READ:
		case SSL_ERROR_WANT_WRITE:
		case SSL_ERROR_WANT_CONNECT:
		case SSL_ERROR_WANT_ACCEPT:
		case SSL_ERROR_WANT_X509_LOOKUP:
			/* try again with the same args */
			continue;
		case SSL_ERROR_NONE:
			/* successful read */
			res += nr;
			break;
		default:
			/* some error occurred */
			s->errnr = READ_ERROR;
			((struct ssl_data *) s->stream_data.p)->error = err;
			((struct ssl_data *) s->stream_data.p)->ret = nr;
			return -1;
		}
	}
	return res / elmsize;
}

static ssize_t ssl_write(stream *s, void *buf, size_t elmsize, size_t cnt)
{
	SSL *ssl;
	int size = (int) (elmsize * cnt);

	assert(s->stream_data.p);
	ssl = ((struct ssl_data *) s->stream_data.p)->ssl;
	assert(ssl);
	for (;;) {
		int nr, err;

		nr = SSL_write(ssl, buf, size);
		err = SSL_get_error(ssl, nr);
		switch (err) {
		case SSL_ERROR_WANT_READ:
		case SSL_ERROR_WANT_WRITE:
		case SSL_ERROR_WANT_CONNECT:
		case SSL_ERROR_WANT_ACCEPT:
		case SSL_ERROR_WANT_X509_LOOKUP:
			/* try again with the same args */
			continue;
		case SSL_ERROR_NONE:
			/* successful write */
			return cnt;
		default:
			/* some error occurred */
			s->errnr = READ_ERROR;
			((struct ssl_data *) s->stream_data.p)->error = err;
			((struct ssl_data *) s->stream_data.p)->ret = nr;
			return -1;
		}
	}
}

static void ssl_destroy(stream *s)
{
	if (s->stream_data.p)
		free(s->stream_data.p);
	s->stream_data.p = NULL;
	destroy(s);
}

static void ssl_close(stream *s)
{
	struct ssl_data *ssl_data = (struct ssl_data *) s->stream_data.p;

	if (ssl_data && ssl_data->ssl) {
		int sock = SSL_shutdown(ssl_data->ssl);

		if (sock == 0)
			sock = SSL_shutdown(ssl_data->ssl);
#ifdef REPORT_SSL_SHUTDOWN_ERROR /* usually undefined */
		if (sock == -1) {
			int err = SSL_get_error(ssl_data->ssl, sock);
			char *errstr = error(err, sock);

			fprintf(stderr, "SSL_shutdown: %s\n", errstr);
			free(errstr);
		}
#endif
		sock = SSL_get_fd(ssl_data->ssl);
		if (s->access == ST_READ)
			shutdown(sock, 0);
		else
			shutdown(sock, 1);
		close(sock);
		if (ssl_data->ssl)
			SSL_free(ssl_data->ssl);
		ssl_data->ssl = NULL;
	}
}

static char *ssl_error(stream *s)
{
	char *errstr;
	char buf[120];
	unsigned long e;

	assert(s->stream_data.p);
	switch (((struct ssl_data *) s->stream_data.p)->error) {
	case SSL_ERROR_ZERO_RETURN:
		errstr = "TLS/SSL connection has been closed";
		break;
	case SSL_ERROR_WANT_READ:
		errstr = "The operation did not complete (read)";
		break;
	case SSL_ERROR_WANT_WRITE:
		errstr = "The operation did not complete (write)";
		break;
	case SSL_ERROR_WANT_X509_LOOKUP:
		errstr = "The operation did not complete (X509 lookup)";
		break;
	case SSL_ERROR_WANT_CONNECT:
		errstr = "The operation did not complete (connect)";
		break;
	case SSL_ERROR_SYSCALL:
		e = ERR_get_error();
		if (e == 0) {
			if (((struct ssl_data *) s->stream_data.p)->ret == 0) {
				errstr = "EOF occurred in violation of protocol";
			} else if (((struct ssl_data *) s->stream_data.p)->ret == -1) {
				/* the underlying BIO reported an I/O error */
				errstr = "I/O error";
			} else {  /* possible? */
				errstr = "Some I/O error occurred";
			}
		} else {
			errstr = ERR_error_string(e, buf);
		}
		break;
	case SSL_ERROR_SSL:
		e = ERR_get_error();
		if (e != 0) 
			errstr = ERR_error_string(e, buf);
		else { /* possible? */
			errstr = "A failure in the SSL library occurred";
		}
		break;
	default:
		errstr = "Invalid error code";
	}
	return strdup(errstr);
}

stream *ssl_open(SSL *ssl, const char *name)
{
	struct ssl_data *ssl_data;
	stream *s = create_stream(name);

	assert(ssl);
	s->read = ssl_read;
	s->write = ssl_write;
	s->close = ssl_close;
	s->error = ssl_error;
	s->flush = NULL;
	s->destroy = ssl_destroy;

	ssl_data = malloc(sizeof(struct ssl_data));
	ssl_data->ret = 0;
	ssl_data->error = 0;
	ssl_data->ssl = ssl;
	s->stream_data.p = (void *) ssl_data;
	return s;
}

stream *ssl_rstream(SSL *ssl, const char *name)
{
	stream *s;
#ifdef STREAM_DEBUG
	printf("ssl_rstream " PTRFMT " %s\n", ssl, name);
#endif
	s = ssl_open(ssl, name);
	s->access = ST_READ;
	s->type = ST_BIN;
	if (s->errnr == NO__ERROR) {
		ssl_read(s, (void*)&s->byteorder, sizeof(short), 1);
	}
	return s;
}

stream *ssl_wstream(SSL *ssl, const char *name)
{
	stream *s;
#ifdef STREAM_DEBUG
	printf("ssl_wstream " PTRFMT " %s\n", ssl, name);
#endif
	s = ssl_open(ssl, name);
	s->access = ST_WRITE;
	s->type = ST_BIN;
	if (s->errnr == NO__ERROR) {
		ssl_write(s, (void*)&s->byteorder, sizeof(short), 1);
	}
	return s;
}

stream *ssl_rastream(SSL *ssl, const char *name)
{
	stream *s;

#ifdef STREAM_DEBUG
	printf("ssl_rastream " PTRFMT " %s\n", ssl, name);
#endif
	s = ssl_open(ssl, name);
	s->access = ST_READ;
	s->type = ST_ASCII;
	return s;
}

stream *ssl_wastream(SSL *ssl, const char *name)
{
	stream *s;
#ifdef STREAM_DEBUG
	printf("ssl_wastream " PTRFMT " %s\n", ssl, name);
#endif
	s = ssl_open(ssl, name);
	s->access = ST_WRITE;
	s->type = ST_ASCII;
	return s;
}
#endif	/* HAVE_OPENSSL */

stream *file_stream( const char *name )
{
	stream *s;
	s = create_stream(name);
	s->read  = file_read;
	s->write = file_write;
	s->close = file_close;
	s->error = error;
	s->flush = file_flush;
	return s;
}
stream *file_rstream( FILE *fp, const char *name )
{
	stream *s;
#ifdef STREAM_DEBUG
	printf("file_rstream %s\n", name);
#endif
	s = file_stream(name);
	s->type = ST_BIN;
	if (fp != NULL){ 
		s->stream_data.p = (void*)fp;

		if (s->errnr == NO__ERROR)
	   		fread( (void*)&s->byteorder, sizeof(short), 
						1, (FILE*)s->stream_data.p);
		return s;
	}
	s->errnr = OPEN_ERROR;
	return s;
}

stream *file_wstream( FILE *fp, const char *name )
{
	stream *s;
#ifdef STREAM_DEBUG
	printf("file_wstream %s\n", name);
#endif
	s = file_stream(name);
	s->access = ST_WRITE;
	s->type = ST_BIN;
	if (fp != NULL){ 
		s->stream_data.p = (void*)fp;

		if (s->errnr == NO__ERROR){
	   		fwrite( (void*)&s->byteorder, sizeof(short), 
						1, (FILE*)s->stream_data.p);
		}
		return s;
	}
	s->errnr = OPEN_ERROR;
	return s;
}

stream *file_rastream( FILE *fp, const char *name )
{
	stream *s;
#ifdef STREAM_DEBUG
	printf("file_rastream %s\n", name);
#endif
	s = file_stream(name);
	s->type = ST_ASCII;
	if (fp != NULL){ 
		s->stream_data.p = (void*)fp;
		return s;
	}
	s->errnr = OPEN_ERROR;
	return s;
}

stream *file_wastream( FILE *fp, const char *name )
{
	stream *s;
#ifdef STREAM_DEBUG
	printf("file_wastream %s\n", name);
#endif
	s = file_stream(name);
	s->access = ST_WRITE;
	s->type = ST_ASCII;
	if (fp != NULL){ 
		s->stream_data.p = (void*)fp;
		return s;
	}
	s->errnr = OPEN_ERROR;
	return s;
} 

buffer *buffer_create( size_t size )
{
	buffer *b = (buffer*)malloc(sizeof(buffer));
	(void) size;
	b->pos = 0;
	b->buf = malloc(BUFSIZ);
	b->len = BUFSIZ;
	return b;
}

char *buffer_get_buf( buffer *b )
{
	char *r = b->buf;

	r[b->pos] = '\0';
	b->buf = malloc(BUFSIZ);
	b->len = BUFSIZ;
	b->pos = 0;
	return r;
}

void buffer_destroy( buffer *b )
{
	free(b->buf);
	free(b);
}

buffer *stream_get_buffer( stream *s )
{
	return (buffer*)s->stream_data.p;
}

static ssize_t buffer_read( stream *s, void *buf, size_t elmsize, size_t cnt )
{
	size_t size = elmsize*cnt;
	buffer *b = (buffer*)s->stream_data.p;
	if (b->pos+size <= b->len){
		memcpy(buf, b->buf + b->pos, size);
		b->pos += size;
		return size;
	} else {
		s->errnr = READ_ERROR;
		return 0;
	}
}
static ssize_t buffer_write( stream *s, void *buf, size_t elmsize, size_t cnt )
{
	size_t size = elmsize*cnt;
	buffer *b = (buffer*)s->stream_data.p;
	if (b->pos+size > b->len){
		size_t ns = b->len;
		while(b->pos+size > ns) ns *= 2;
		b->buf = realloc(b->buf, ns);
		b->len = ns;
	}
	memcpy(b->buf + b->pos, buf, size);
	b->pos += size;
	return size;
}

static void buffer_close( stream *s )
{
	(void) s;
}
static void buffer_flush( stream *s )
{ 
	buffer *b = (buffer*)s->stream_data.p;
	b->pos = 0;
}

stream *buffer_rastream( buffer *b, const char *name )
{
	stream *s;
#ifdef STREAM_DEBUG
	printf("buffer_rastream %s\n", name);
#endif
	s = create_stream(name);
	s->type = ST_ASCII;
	s->read  = buffer_read;
	s->write = buffer_write;
	s->close = buffer_close;
	s->error = error;
	s->flush = buffer_flush;
	s->stream_data.p = (void*)b;
	return s;
}

stream *buffer_wastream( buffer *b, const char *name )
{
	stream *s;
#ifdef STREAM_DEBUG
	printf("buffer_wastream %s\n", name);
#endif
	s = create_stream(name);
	s->access = ST_WRITE;
	s->type = ST_ASCII;
	s->read  = buffer_read;
	s->write = buffer_write;
	s->close = buffer_close;
	s->error = error;
	s->flush = buffer_flush;
	s->stream_data.p = (void*)b;
	return s;
}

typedef struct bs {
	stream *s;
	unsigned onr;
	unsigned inr;
	unsigned itotal;
	int eob; 
	char out[BLOCK];
	char in[BLOCK];
} bs;

static
bs *bs_create( stream *s )
{
	/* should be a binary stream */
	bs *ns = (bs*)malloc(sizeof(bs));
	ns->s = s;
	ns->inr = 0;
	ns->itotal = 0;
	ns->onr = 0;
	ns->eob = 0;
	return ns;
}

static ssize_t 
bs_write( stream *ss, void *buf, size_t elmsize, size_t cnt )
{
	bs *s = (bs*)ss->stream_data.p;
	size_t todo = cnt * elmsize;
	if (s->onr + todo >= BLOCK){
		size_t rest = BLOCK - s->onr;
		memcpy( s->out+s->onr, buf, rest );
		buf = (void *) ((char *) buf + rest);
		todo -= rest;

		if (!stream_writeInt( s->s, BLOCK) ||
		     s->s->write( s->s, s->out, 1, BLOCK) != BLOCK){
			ss->errnr = WRITE_ERROR;
			return -1;
		}
		s->onr = 0;

		while (todo >= BLOCK){
			if (!stream_writeInt( s->s, BLOCK) ||
			    s->s->write( s->s, buf, 1, BLOCK) != BLOCK){
				ss->errnr = WRITE_ERROR;
				return -1;
			}
			buf = (void *) ((char *) buf + BLOCK);
			todo -= BLOCK;
		}
	}
	memcpy( s->out+s->onr, buf, todo );
	s->onr += todo;
	return cnt;
}

static ssize_t 
bs_read( stream *ss, void *buf, size_t elmsize, size_t cnt )
{
	bs *s = (bs*)ss->stream_data.p;
	unsigned nr = 0;

	size_t todo = cnt * elmsize;
	if (s->inr + todo < s->itotal) {
		memcpy( buf, s->in + s->inr, todo );

		s->inr += todo;
		return cnt;
	}
	if (todo + s->inr >= s->itotal) {
		size_t rest = s->itotal - s->inr;
		memcpy( buf, s->in + s->inr, rest );
		buf = (void *) ((char *) buf + rest);
		todo -= rest;

		s->inr = 0;
		s->itotal = 0;
	}
	if (s->eob){
		s->eob = 0;
		return cnt - (todo/elmsize);
	}
	while (todo >= BLOCK){
		if (!stream_readInt( s->s, (int *) &nr )
		    || s->s->read( s->s, buf, 1, (size_t) nr) != nr){
			ss->errnr = READ_ERROR;
			return -1;
		}
		buf = (void *) ((char *) buf + nr);
		todo -= nr;
		if (nr < BLOCK){
			s->itotal = s->inr = 0;
			return cnt - (todo/elmsize);
		}
	} 
	if (todo){
		if (!stream_readInt( s->s, (int *) &nr ) ||
		    s->s->read( s->s, s->in, 1, (size_t) nr) != nr){
			ss->errnr = READ_ERROR;
			return -1;
		}

		if (nr < BLOCK)
			s->eob = 1;

		if (nr < todo)
			memcpy( buf, s->in, (size_t) nr );
		else
			memcpy( buf, s->in, todo );
		s->itotal = nr;
                if (nr <= todo){
                        s->inr = nr;
			todo -= nr;
			s->eob = 0;
                } else {
                        s->inr = (int) todo; /* todo < BLOCK, i.e. will fit in int */
			todo = 0;
		}
	}
	if (todo){
		s->itotal = s->inr = 0;
		return cnt - (todo/elmsize);
	} else {
		return cnt;
	}
}

ssize_t bs_read_next( stream *ss, void *buf, int *last )
{
	bs *s = (bs*)ss->stream_data.p;
	int nr = 0;

	*last = 0;
	if (s->itotal > s->inr ){
		size_t rest = s->itotal - s->inr;
		memcpy( buf, s->in + s->inr, rest );

		*last = (s->itotal != BLOCK);
		s->inr = 0;
		s->itotal = 0;
		s->eob = 0;
		return rest;
	} else {
		if (!stream_readInt( s->s, &nr) ||
		   s->s->read( s->s, buf, (size_t) 1, (size_t) nr) != nr){
			ss->errnr = READ_ERROR;
			return -1;
		}
		if (nr < BLOCK){
			*last = 1;
			s->itotal = s->inr = 0;
		} 
		return (size_t) nr;
	} 
}

static
void bs_flush(stream *ss)
{
	bs *s = (bs*)ss->stream_data.p;
	if (s->onr){
		if (!stream_writeInt( s->s, s->onr) ||
			s->s->write( s->s, s->out, 1, s->onr ) != s->onr){
			ss->errnr = WRITE_ERROR;
		}
	}
	s->onr = 0;
}

static
void bs_close( stream *ss )
{
	bs *s = (bs*)ss->stream_data.p;
	s->s->close( s->s );
}
static
void bs_destroy( stream *ss )
{
	bs *s = (bs*)ss->stream_data.p;
	s->s->destroy( s->s );
	free(s);
	destroy(ss);
}

stream *block_stream( stream *s )
{
	stream *ns;
	bs *bs;
#ifdef STREAM_DEBUG
	printf("block_stream %s\n", s->name ? s->name : "<unnamed>");
#endif
	ns = create_stream(s->name);
	bs = bs_create(s);
	ns->type = s->type;
	ns->access = s->access;
	ns->read  = bs_read;
	ns->write = bs_write;
	ns->close = bs_close;
	ns->error = error;
	ns->flush = bs_flush;
	ns->destroy = bs_destroy;
	if (bs != NULL){ 
		ns->stream_data.p = (void*)bs;
		return ns;
	}
	ns->errnr = OPEN_ERROR;
	return ns;
}
int isa_block_stream(stream *s)
{
	return s->read == bs_read || s->write == bs_write;
}

int stream_readSht( stream *s, short *val )
{
	int ok = s->read(s, (void*)val, sizeof(short), 1) == 1;
	if (!ok) s->errnr = READ_ERROR;
	if (s->byteorder != 1234)
		*val = short_int_SWAP(*val);	
	return ok;
}

int stream_writeSht( stream *s, const short val )
{
	int ok = s->write(s, (void*)&val, sizeof(short), 1)==1;
	if (!ok) s->errnr = WRITE_ERROR;
	return ok;
}

int stream_readInt( stream *s, int *val )
{
	int ok = s->read(s, (void*)val, sizeof(int), 1) == 1;
	if (!ok) s->errnr = READ_ERROR;
	if (s->byteorder != 1234)
		*val = normal_int_SWAP(*val);	
	return ok;
}
int stream_writeInt( stream *s, const int val )
{
	int ok = s->write(s, (void*)&val, sizeof(int), (size_t)1)==1;
	if (!ok) s->errnr = WRITE_ERROR;
	return ok;
}

int stream_readLng( stream *s, lng *val )
{
	int ok = s->read(s, (void*)val, sizeof(lng), (size_t)1) == 1;
	if (!ok) s->errnr = READ_ERROR;
	if (s->byteorder != 1234)
		*val = long_long_SWAP(*val);	
	return ok;
}

int stream_writeLng( stream *s, const lng val )
{
	int ok = s->write(s, (void*)&val, sizeof(lng), (size_t)1)==1;
	if (!ok) s->errnr = WRITE_ERROR;
	return ok;
}

int stream_readShtArray( stream *s, short *val, size_t cnt )
{
	int ok = s->read(s, (void*)val, sizeof(short), cnt) == cnt;
	if (!ok) s->errnr = READ_ERROR;
	if (s->byteorder != 1234){
		size_t i;
		for(i = 0; i<cnt; i++, val++)
			*val = short_int_SWAP(*val);	
	}
	return ok;
}

int stream_writeShtArray( stream *s, const short *val, size_t cnt )
{
	int ok = s->write(s, (void*)val, sizeof(short), cnt)==cnt;
	if (!ok) s->errnr = WRITE_ERROR;
	return ok;
}

int stream_readIntArray( stream *s, int *val, size_t cnt )
{
	int ok = s->read(s, (void*)val, sizeof(int), cnt) == cnt;
	if (!ok) s->errnr = READ_ERROR;
	if (s->byteorder != 1234){
		size_t i;
		for(i = 0; i<cnt; i++, val++)
			*val = normal_int_SWAP(*val);	
	}
	return ok;
}
int stream_writeIntArray( stream *s, const int *val, size_t cnt )
{
	int ok = s->write(s, (void*)val, sizeof(int), cnt)==cnt;
	if (!ok) s->errnr = WRITE_ERROR;
	return ok;
}

int stream_readLngArray( stream *s, lng *val, size_t cnt )
{
	int ok = s->read(s, (void*)val, sizeof(lng), cnt) == cnt;
	if (!ok) s->errnr = READ_ERROR;
	if (s->byteorder != 1234){
		size_t i;
		for(i = 0; i<cnt; i++, val++)
			*val = long_long_SWAP(*val);	
	}
	return ok;
}

int stream_writeLngArray( stream *s, const lng *val, size_t cnt )
{
	int ok = s->write(s, (void*)val, sizeof(lng), cnt)==cnt;
	if (!ok) s->errnr = WRITE_ERROR;
	return ok;
}

int stream_printf( stream *s, const char *format, ...)
{
	char buf[BUFSIZ], *bf = buf;
	int i = 0;
	size_t bfsz = BUFSIZ;
	va_list ap; 

@= stream_printf_va_vsnprintf
	va_start(ap, format); 
	i = vsnprintf(bf, bfsz, format, ap);
	va_end (ap);
@c
	@:stream_printf_va_vsnprintf@
	while (i < 0 || (size_t) i >= bfsz) {
		if (i >= 0)		/* glibc 2.1 */
			bfsz = (size_t)i+1; /* precisely what is needed */
		else			/* glibc 2.0 */
			bfsz *= 2;	/* twice the old size */
		if (bf != buf) free(bf);
		bf = malloc (bfsz);
		assert(bf != NULL);
		@:stream_printf_va_vsnprintf@
	}
	s->write(s, (void *) bf, (size_t) i, (size_t) 1);
	if (bf != buf) free(bf);
	return i;
}


bstream *bstream_create( stream *s, size_t size )
{
	bstream *b = (bstream*)malloc(sizeof(bstream));
	b->s = s;
	b->buf = malloc(size + 1);
	b->size = size;
	b->pos = 0;
	b->len = 0;
	b->eof = 0;
	return b;
}

size_t bstream_read( bstream *s, size_t size )
{
	size_t len = 0, rd = 0;
	size_t used = s->len - s->pos;
	if (s->eof)
		return 0;
	while( size+used > s->size){
		s->size <<= 1; 
		s->buf = realloc(s->buf,s->size+1);
	}
	len = s->size - used;
	if (s->pos){
		memmove( s->buf, s->buf + s->pos, used);
		s->pos = 0; 
	}
	if ((rd = s->s->read(s->s, s->buf + used, 1, len)) < len) {
		s->eof = 1;
	}
	s->pos = 0;
	s->len = used + rd;
	s->buf[s->len] = 0;	/* fill in the spare with EOS */
	return rd;
}

void bstream_destroy( bstream *s )
{
	free(s->buf);
	free(s);
}

void close_stream( stream *s )
{
	if (s && !s->errnr){
		s->close( s );
		s->destroy( s );
	} else if (s) {
		s->destroy( s );
	}
}

