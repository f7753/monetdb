@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2004 CWI.
@' All Rights Reserved.

@f gdk_relop
@a M. L. Kersten, P. Boncz, S. Manegold
@* BAT relational operators
The basic relational operators are implemented for BATs.
Particular attention has been paid to speed-up processing
joins, such that navigational access and object re-assembly
are not being harmed too much.
@c
#include "gdk.h"

#define SAMPLE_TRESHOLD_LOG 17
#define SAMPLE_SLICE_SIZE 1000
@{
@+ Join Algorithms
@{
All join related operations have the same prelude to check
domain compatibility and to creates the BAT to hold the result.

New: we do some dynamic effort to estimate the result size. Good 
estimates enhance performance and reduce the memory hunger of the join.
Method: we sample on l, and join on the whole r. This macro is called by 
the physical join algorithms, hence we already decided on the algorithm 
and join method, so the initial costs on r (e.g. hash creation) would have 
to be paid anyway, and are reused later in the real join phase. 

Sampling was made more robust by using a logarithmic number of slices
taken at equal-spaced intervals across l. The results are then analyzed
and checked for outliers. If outliers are present, a real sample is taken
and executed with the generic join algorithm to obtain an better estimate.

On small joins we just assume 1-N joins with a limited (=3) hit rate. 

@= joincheck
	ERRORcheck(l == NULL, "@1: invalid left operand"); 
	ERRORcheck(r == NULL, "@1: invalid right operand"); 
	ERRORcheck(TYPEerror(@2,@3), "@1: type conflict\n"); 
@= joinestimate
if (@3 == (size_t) oid_nil) {
	size_t _lcount = BATcount(l);
	size_t _rcount = BATcount(r);
	size_t _slices = 0; 

	/* limit estimate with simple bounds first; only spend effort if the join result might be big */
	if (@1 == JOIN_EQ) {
		if (l->tkey) @3 = r->hkey?MIN(_rcount,_lcount):_rcount;
		else if (r->hkey) @3 = _lcount;
	}
	if (@3 == oid_nil) {
		size_t _heuristic = 3*MIN(_lcount, _rcount);
		if (_heuristic <= (1 << SAMPLE_TRESHOLD_LOG)) @3 = _heuristic;
	} 
	if (@3 == oid_nil) {
		size_t _idx;
		for(_idx=_lcount; _idx > 0; _idx >>= 1) _slices++;
	}
	if (_slices > SAMPLE_TRESHOLD_LOG) {
                 /* use cheapo sampling by taking a number of slices and joining those with the algo */
		size_t _idx = 0, _tot=0, _step, _lo, _avg, _sample, *_cnt;
		BAT *_tmp1 = l, *_tmp2, *_tmp3 = NULL; 
		_step = _lcount / (_slices -= SAMPLE_TRESHOLD_LOG);
		_sample = _slices * SAMPLE_SLICE_SIZE;
		_cnt = (size_t*) alloca(_slices*sizeof(size_t));
		for(_lo=0; _idx < _slices; _lo += _step) {
			size_t _size = 0, _hi = _lo + SAMPLE_SLICE_SIZE; 
			l = BATslice(_tmp1, _lo, _hi); /* slice keeps all parent properties */ 
			if (l == NULL) return NULL;
			_tmp2 = @2; /* @2 = e.g. BATXjoin(l,r) */
			if (_tmp2) {
				_size = BATcount(_tmp2); 
				BBPreclaim(_tmp2);
			}
			_tot += (_cnt[_idx++] = _size);
			BBPreclaim(l); 
		}
		/* do outlier detection on sampling results; this guards against skew */
		if (@1 == JOIN_EQ) {
			for(_avg=_tot/_slices, _idx=0; _idx < _slices; _idx++) {
				size_t _diff = _cnt[_idx] - _avg;
				if (_avg > _cnt[_idx]) _diff = _avg - _cnt[_idx];
				if (_diff > MAX(SAMPLE_SLICE_SIZE, _avg)) break; 
			}
			if (_idx < _slices) {
				/* outliers detected, compute a real sample on at most 1% of the data */
				_sample = MIN(_lcount/100, (1 << SAMPLE_TRESHOLD_LOG)/3);
				_tmp2 = BATsample(_tmp1, _sample); 
				if (_tmp2) {
					_tmp3 = BATjoin(_tmp2, r, oid_nil); /* might be expensive */
					if (_tmp3) {
						_tot = BATcount(_tmp3);
						BBPreclaim(_tmp3);
					}
					BBPreclaim(_tmp2);
				}
				if (_tmp3 == NULL) return NULL;
			}
		}
		/* overestimate always by 5% */
		@3 = (size_t) ((double) (((lng) _tot) * ((lng) _lcount)) / (0.95 * (double) _sample)); 
		l = _tmp1;
	}
}
@= joinbat
{	size_t _estimate = @3;
	@:joinestimate(@1, @2, _estimate)@
	bn = BATnew(BAThtype(l), BATttype(r), _estimate);
	if (bn == NULL) {
		return bn; 
	}
}

@- merge join
In the case that both join columns are ordered, we can do a merging
(@%BATmergejoin@). The merge is opportunistic in that it tries to do
merge between l and r, but if for a long time no matching tuples are
found in r, it uses binary search. It also allows joining of an 
unsorted l with a sorted r; in that case it always uses binary search.

@= mergejoin
if (((!BATtvoid(l)) || l->tseqbase != oid_nil) && 
    ((!BAThvoid(r)) || r->hseqbase != oid_nil || nil_on_miss)) 
{ 
	while(l_start < l_last) {
	    ptr v2, v1 = BUNt@2(l,l_start);
	    int neq = 1;

	    /* lookup range in l */
	    l_end = l_start;
	    if (l_key) {
		l_end += l_next;
	    } else do {
		if ((l_end += l_next) >= l_last) break;  
		v2 = BUNt@2(l,l_end);
	    } while(@1_EQ(v1,v2,@4));

	    /* lookup value in r (if not nil, that is) */
	    if (!@1_EQ(v1,nil,@4))  {
		if (r_scan > 0) {
		    /* first try scanning; but give up after a while */
		    for(r_lim = MIN(r_last, r_end + r_scan); r_end < r_lim; r_end += r_next) {
			v2 = BUNh@3(r,r_end);
			neq = @1_CMP(v1,v2,@4);
			if (neq <= 0) break;
		    }
		    r_start = r_end;
		}
		if (neq == 1) {
		    /* use binary search after failed scan or if scanning is impossible (l not sorted) */
		    if (r_scan < 0 || r_start < r_last) { /* if merge not ended (or if no merge at all) */
		        r_start = (BUN) SORTfndfirst_@4(rr, v1); 
		    }
		    if (r_start < r_last) {
			v2 = BUNh@3(r,r_start);
			neq = !@1_EQ(v1,v2,@4);
		    } else if (r_scan >= 0) {
			break;  /* r is already at end => break off merge join */
		    }
		}
	    }
	    if (neq == 0) {
	        /* lookup range in r */
	        r_end = r_start + r_next;
		if (r_key == 0)
		while (r_end < r_last) {
		   v2 = BUNh@3(r,r_end);
		   if (!@1_EQ(v1,v2,@4)) break;
		   r_end += r_next;
	        }
	        /* generate match-product as join result */
	        for(; l_start < l_end; l_start+=l_next) 
		    for(r_cur=r_start; r_cur<r_end; r_cur+=r_next) 
		        bunfastins(bn, BUNhead(l,l_start), BUNtail(r,r_cur));
	    } else if (nil_on_miss) {
		/* outerjoin inserts nils on a miss */
		hasnils = 1;
	        for(; l_start < l_end; l_start+=l_next) 
		        bunfastins(bn, BUNhead(l,l_start), nil_on_miss);
	    } else {
		l_start = l_end; /* no match found in equi-join */
	    }
	}
}
@c
/* serves both normal equi-join (nil_on_miss==NULL) and outerjoin (nil_on_miss=nil) */
static BAT* mergejoin(BAT *l, BAT *r, BAT *bn, ptr nil_on_miss, size_t estimate) {
	ptr nil = ATOMnilptr(r->htype);
	int r_scan = -1; /* no scanning in r */
        BAT *rr = BATmirror(r);
	BUN l_last, r_last;   /* last BUN of the BAT */
	BUN l_start, r_start; /* start of current chunk  */
	BUN l_end, r_end;     /* end of current chunk */
	int r_next = BUNsize(r);
	int l_next = BUNsize(l);
	int l_key = l->tkey;
	int r_key = r->hkey;
	BUN r_cur, r_lim;
	int loc, var, hasnils = 0;

	if (BATtordered(l)&1) {
		int i, logr = 4; 
		/* 4*log2(r.count) = estimation of the cost of binary search in units of scan comparisons */
		for(i=BATcount(r); i > 0; logr++) i >>= 1; 
		r_scan = logr*BUNsize(r); /* opportunistic scan window in r */
	}
	if (!(BAThordered(r)&1)) {
		GDKerror("mergejoin: right input is not sorted.\n"); 
		return NULL; 
	}
	if (bn == NULL) {
		@:joinbat(JOIN_EQ, mergejoin(l,r,NULL,nil_on_miss,oid_nil), estimate)@
	}

	/* the algorithm */
	loc = ATOMstorage(l->ttype);

	l_last = BUNlast(l); 
	r_last = BUNlast(r); 
	l_start = l_end = BUNfirst(l);
	r_start = r_end = BUNfirst(r);

	switch(loc) {
#ifndef NOEXPAND_CHR
	case TYPE_chr: @:mergejoin(simple,loc,loc,chr)@; break;
#endif
#ifndef NOEXPAND_SHT
	case TYPE_sht: @:mergejoin(simple,loc,loc,sht)@; break;
#endif
#ifndef NOEXPAND_INT
	case TYPE_int: @:mergejoin(simple,loc,loc,int)@; break;
#endif
#ifndef NOEXPAND_FLT
	case TYPE_flt: @:mergejoin(simple,loc,loc,flt)@; break;
#endif
#ifndef NOEXPAND_LNG
	case TYPE_lng: @:mergejoin(simple,loc,loc,lng)@; break;
#endif
#ifndef NOEXPAND_DBL
	case TYPE_dbl: @:mergejoin(simple,loc,loc,dbl)@; break;
#endif
	default: if (l->tvarsized) {
		       var = ATOMstorage(l->ttype);
		       if (r->hvarsized) {
			   @:mergejoin(atom,var,var,var)@
		       } else {
			   loc = ATOMstorage(r->htype);
			   @:mergejoin(atom,var,loc,loc)@
		       }
		 } else {
		       loc = ATOMstorage(l->ttype); 	
		       if (r->hvarsized) {
			   var = ATOMstorage(r->htype);
      		           @:mergejoin(atom,loc,var,var)@
		       } else {	
      		           @:mergejoin(atom,loc,loc,loc)@
		       }
	         }
		 break;
	}

	if (nil_on_miss) {
	    for(; l_start < l_last; l_start+=l_next) 
		bunfastins(bn, BUNhead(l,l_start), nil_on_miss);
	}

	/* propagate properties */
	bn->hsorted = BAThordered(l);
	bn->tsorted = FALSE;
	if (r->hkey) {
	    if (BATcount(bn) == BATcount(l)) {
		ALIGNsetH(bn, l);
	    } else if (l->hkey) {
		BATkey(bn, TRUE);
	    }
	} 
	if (l->tkey) {
	    bn->tsorted = BATtordered(r) & BATtordered(l) & 1;
	    if (!nil_on_miss) {
	    	if (BATcount(bn) == BATcount(r)) {
		    ALIGNsetT(bn, r);
	        } else if (r->tkey) {
		    BATkey(BATmirror(bn), TRUE);
		}
	    } else if (hasnils) {
	        bn->tsorted = 0; /* nils destroy the ordering */
	    }
	}
	return bn;
bunins_failed:
	BBPreclaim(bn);
	return NULL;
}

static BAT *batmergejoin(BAT *l, BAT *r, size_t estimate, bit swap) {
        @:joincheck(BATmergejoin, l->ttype, r->htype)@
	if ( swap && (((BAThordered(r)&1)==0) || ((BATtordered(l)&1) && (BATcount(l) > BATcount(r)))) ) {
		/* reverse join if required (r not sorted) or if l is larger (quick jump through l with binary search) */
		BAT *bn = mergejoin(BATmirror(r), BATmirror(l), NULL, NULL, estimate);
		return bn?BATmirror(bn):NULL;
	}
	return mergejoin(l, r, NULL, NULL, estimate);
}

BAT *BATmergejoin(BAT *l, BAT *r, size_t estimate) {
	/* allows swapping of left and right input for faster processing */
	return batmergejoin(l, r, estimate, TRUE);
}

BAT *BATleftmergejoin(BAT *l, BAT *r, size_t estimate) {
	/* do not swap left and right input, 
	   and hence maintain order of left head in result */
	return batmergejoin(l, r, estimate, FALSE);
}

@- hash join
These macros encode the core of the join algorithm. They are
the fast inner loops, optimized towards their type.

@= hashjoin
{	int xx;
	hash_t yy;
        BATloopFast(l, p, q, xx) {
                v = BUN@3(l,p);
		if (@1_EQ(v,nil,@2)) {
			continue; /* skip nil */
		}
                HASHloop_@2(r, r->hhash, yy, v, w) {
                        bunfastins(bn, BUNhead(l,p), BUNtail(r,w));
                }
        }
	/* set sorted flags by hand, because we used BUNfastins() */
	bn->hsorted = BAThordered(l);
        bn->tsorted = FALSE;
        break;
}
@c
BAT* BAThashjoin(BAT* l, BAT* r, size_t estimate) {
	ptr	v, nil = ATOMnilptr(r->htype); 
	BUN	p, q, w;
	int	any;
	BAT	*bn = NULL;

        @:joincheck(BAThashjoin, l->ttype, r->htype)@
	@:joinbat(JOIN_EQ, BAThashjoin(l,r,oid_nil), estimate)@

        if (BATprepareHash(r)) return NULL;
        switch(any = ATOMstorage(l->ttype)) {
#ifndef NOEXPAND_CHR
        case TYPE_chr: @:hashjoin(simple,chr,tloc)@
#endif
#ifndef NOEXPAND_SHT
        case TYPE_sht: @:hashjoin(simple,sht,tloc)@
#endif
#if !defined(NOEXPAND_INT) || !defined(NOEXPAND_FLT)
        case TYPE_int: 
        case TYPE_flt: @:hashjoin(simple,int,tloc)@
#endif
#if !defined(NOEXPAND_DBL) || !defined(NOEXPAND_LNG)
        case TYPE_dbl:
        case TYPE_lng: @:hashjoin(simple,lng,tloc)@
#endif
        default:       @:hashjoin(atom,any,tail);
        }

	/* propagate alignment info */
	bn->hsorted = BAThordered(l);
	if (BAThkey(r)) {
		if (BATcount(bn) == BATcount(l)) ALIGNsetH(bn, l);
		if (BAThkey(l)) BATkey(bn, TRUE);
	}
        ESTIDEBUG THRprintf(GDKout, "BAThashjoin: actual resultsize: " SZFMT "\n",BATcount(bn));
	return bn;
bunins_failed:
	BBPreclaim(bn);
	return NULL;
	
}

@- fetch-join 
@T
The @`BATfetchjoin@5(l,r) does a join on the basis of positional lookup. 
It looks up index numbers from the second parameter in first parameter BAT.
The right parameter may contain OIDs, in which case their base is
subtracted. 

In a typical join(BAT[any::1,oid) L, BATvoid,any::2] R) : BAT[any::1,any::2]
we expect each tuple of L to hit exactly once in R. Now if any::1=void
this void column can be carried over to the result. We do that.

However, it is possible that an tail-oid is out of range with respect
to R; in that case some tuples will be missing and we cannot carry on
producing a void column. In that case, we have to switch back
on-the-fly to the non-dense implementation.

The aftermath -- property setting -- is relatively straightforward here.

@c
#define HLATOMput(bn, dst) ATOMput(bn->htype, &bn->hheap, dst, BUNhloc(l,l_cur))
#define HVATOMput(bn, dst) ATOMput(bn->htype, &bn->hheap, dst, BUNhvar(l,l_cur))
#define TLATOMput(bn, dst) ATOMput(bn->ttype, &bn->theap, dst, BUNtloc(r,r_cur))
#define TVATOMput(bn, dst) ATOMput(bn->ttype, &bn->theap, dst, BUNtvar(r,r_cur))

@= SIMPLEput
#define H@1put(bn,dst)	*(@1*) (dst) = *(@1*) (BUNhloc(l,l_cur))
#define T@1put(bn,dst)	*(@1*) (dst) = *(@1*) (BUNtloc(r,r_cur))
@c
@:SIMPLEput(chr)@
@:SIMPLEput(sht)@
@:SIMPLEput(int)@
@:SIMPLEput(lng)@

@= bunfastins_nocheck_
		H@1put(bn, BUNhloc(bn, dst));
		T@2put(bn, BUNtloc(bn, dst));
@c
@= fetchjoin
BAT *densefetchjoin_@1_@2( BAT *bn, BAT *l, BAT *r ){
	BUN l_cur, l_end, r_cur, dst;
	ssize_t offset;
	size_t base, xx;
	int yy, zz;
	BAT *ret = NULL;

        zz = BUNsize(bn);
	yy = BUNsize(r);
        dst = BUNfirst(bn);
        base = BUNindex(r, BUNfirst(r));
        offset = (ssize_t) (base - r->hseqbase);
	r_cur = BUNptr(r, offset + *(oid*) BUNtail(l,BUNfirst(l)));

	ALGODEBUG THRprintf(GDKout, "BATfetchjoin: densefetchjoin(@1,@2);\n");
	BATloopFast(l, l_cur, l_end, xx) {
		@:bunfastins_nocheck_(@1,@2)@
		r_cur += yy;
		dst += zz;
	}
	ret = bn;
bunins_failed:
	bn->batBuns->free = dst - bn->batBuns->base;
	if (!ret) BBPreclaim(bn);
	return ret;
}
BAT *orderedfetchjoin_@1_@2( BAT *bn, BAT *l, BAT *r ){
	BUN l_cur, l_end, r_cur, dst;
	ssize_t offset;
	size_t base, xx, yy;
	int zz;
	BAT *ret = NULL;

        zz = BUNsize(bn);
        dst = BUNfirst(bn);
        base = BUNindex(r, BUNfirst(r));
        offset = (ssize_t) (base - r->hseqbase);

        ALGODEBUG THRprintf(GDKout, "BATfetchjoin: orderedfetchjoin(@1,@2);\n");
        BATloopFast(l, l_cur, l_end, xx) {
                yy = offset + *(oid*) BUNtail(l,l_cur);
                r_cur = BUNptr(r, yy);
		@:bunfastins_nocheck_(@1,@2)@
                dst += zz;
        }
	ret = bn;
bunins_failed:
        bn->batBuns->free = dst - bn->batBuns->base;
	if (!ret) BBPreclaim(bn);
	return ret;
}
BAT *defaultfetchjoin_@1_@2( BAT *bn, BAT *l, BAT *r ){
	BUN l_cur, l_end, r_cur, dst;
	ssize_t offset;
	size_t xx,yy, base, end;
	int zz;
	BAT *ret = NULL;

        zz = BUNsize(bn);

        dst = BUNfirst(bn);
        base = BUNindex(r, BUNfirst(r));
        offset = (ssize_t) (base - r->hseqbase);
        end = base + BATcount(r);

        ALGODEBUG THRprintf(GDKout, "BATfetchjoin: defaultfetchjoin(@1,@2);\n");
        BATloopFast(l, l_cur, l_end, xx) {
                yy = offset + *(oid*) BUNtail(l,l_cur);
                if (yy < base || yy >= end) {
                        continue;
                }
                r_cur = BUNptr(r, yy);
		@:bunfastins_nocheck_(@1,@2)@
                dst += zz;
        }
	ret = bn;
bunins_failed:
	bn->batBuns->free = dst - bn->batBuns->base;
	if (!ret) BBPreclaim(bn);
	return ret;
}
@c
@= fetchjoin2
	@:fetchjoin(@1,chr)@
	@:fetchjoin(@1,sht)@
	@:fetchjoin(@1,int)@
	@:fetchjoin(@1,lng)@
	@:fetchjoin(@1,VATOM)@
	@:fetchjoin(@1,LATOM)@
@c
	@:fetchjoin2(chr)@
	@:fetchjoin2(sht)@
	@:fetchjoin2(int)@
	@:fetchjoin2(lng)@
	@:fetchjoin2(VATOM)@
	@:fetchjoin2(LATOM)@
@c

@= fetchjoin_switch_rtt
	if (ATOMstorage(rtt) == TYPE_chr) {
                bn = @1fetchjoin_@2_chr(bn,l,r);
        } else if (ATOMstorage(rtt) == TYPE_sht) {
                bn = @1fetchjoin_@2_sht(bn,l,r);
        } else if (rtt != TYPE_bat && (ATOMstorage(rtt) == TYPE_int || ATOMstorage(rtt) == TYPE_flt
#if SIZEOF_OID == SIZEOF_INT
		   || ATOMstorage(rtt) == TYPE_oid
#endif
		   )) {
	        /* ensure use of ATOMput for TYPE_bat */
                bn = @1fetchjoin_@2_int(bn,l,r);
        } else if (ATOMstorage(rtt) == TYPE_lng || ATOMstorage(rtt) == TYPE_dbl
#if SIZEOF_OID == SIZEOF_LNG 
		   || ATOMstorage(lht) == TYPE_oid
#endif
) {
                bn = @1fetchjoin_@2_lng(bn,l,r);
        } else if (r->tvarsized) {
                bn = @1fetchjoin_@2_VATOM(bn,l,r);
        } else {
                bn = @1fetchjoin_@2_LATOM(bn,l,r);
        }
@c
@= fetchjoin_switch_lht
        if (ATOMstorage(lht) == TYPE_chr) {
                @:fetchjoin_switch_rtt(@1,chr)@
        } else if (ATOMstorage(lht) == TYPE_sht) {
                @:fetchjoin_switch_rtt(@1,sht)@
        } else if (lht != TYPE_bat && (ATOMstorage(lht) == TYPE_int || ATOMstorage(lht) == TYPE_flt
#if SIZEOF_OID == SIZEOF_INT
		   || ATOMstorage(lht) == TYPE_oid
#endif
		   )) {
                /* ensure use of ATOMput for TYPE_bat */
                @:fetchjoin_switch_rtt(@1,int)@
        } else if (ATOMstorage(lht) == TYPE_lng || ATOMstorage(lht) == TYPE_dbl
#if SIZEOF_OID == SIZEOF_LNG
		   || ATOMstorage(lht) == TYPE_oid
#endif
		   ) {
                @:fetchjoin_switch_rtt(@1,lng)@
        } else if (l->hvarsized) {
                @:fetchjoin_switch_rtt(@1,VATOM)@
        } else {
                @:fetchjoin_switch_rtt(@1,LATOM)@
        }
@c
@= densevoidfetchjoin
    ALGODEBUG THRprintf(GDKout, "BATfetchjoin: densevoidfetchjoin(@1,@2,@3);\n");
    r_cur = BUNptr(r, offset + *(oid*) BUNtloc(l,BUNfirst(l)));
    yy = BUNsize(r);
    BATloopFast(l, l_cur, l_end, xx) {
        @3put(@2, &bn->theap, dst, BUN@1(r, r_cur));
        r_cur += yy;
        dst += zz;
    }
@c
@= orderedvoidfetchjoin
    ALGODEBUG THRprintf(GDKout, "BATfetchjoin: orderedvoidfetchjoin(@1,@2,@3);\n");
    BATloopFast(l, l_cur, l_end, xx) {
        size_t yy = offset + *(oid*) BUNtloc(l,l_cur);
        r_cur = BUNptr(r, yy);
        @3put(@2, &bn->theap, dst, BUN@1(r, r_cur));
        dst += zz;
    }
@c
@= defaultvoidfetchjoin
    ALGODEBUG THRprintf(GDKout, "BATfetchjoin: defaultvoidfetchjoin(@1,@2,@3);\n");
    BATloopFast(l, l_cur, l_end, xx) {
        size_t yy = offset + *(oid*) BUNtloc(l,l_cur);
        if (yy < base || yy >= end) {
            bn->batBuns->free = dst - bn->batBuns->base;
            BBPreclaim(bn);
            nondense = 1;
	    break;
        }
        r_cur = BUNptr(r, yy);
        @3put(@2, &bn->theap, dst, BUN@1(r, r_cur));
        dst += zz;
    }
    if (nondense) {
        /* not (yet?) completely typ-optimized ! */
        ALGODEBUG THRprintf(GDKout, "BATfetchjoin: defaultvoidfetchjoin(@1,@2,@3): discovered non-density, resuming with non-void head\n");
        bn = BATnew(BAThtype(l), ATOMtype(tpe), BATcount(l));
	if( bn == NULL) return bn;
        dst = BUNfirst(bn);
        zz = BUNsize(bn);
        BATloopFast(l, l_cur, l_end, xx) {
                size_t yy = offset + *(oid*) BUNtail(l,l_cur);
                if (yy < base || yy >= end) {
                        continue;
                }
                r_cur = BUNptr(r, yy);
		ATOMput(bn->htype, &bn->hheap, BUNhloc(bn, dst), BUNhead(l, l_cur));
		@3put(  @2,        &bn->theap, BUNtloc(bn, dst), BUN@1(  r, r_cur));
                dst += zz;
        }    	
    }
@c
@= voidfetchjoin
	if (BATtdense(l)) {
		/* dense => ordered, i.e., we did check the bounderies already above */
		/* and we can do a "synchronized walk" through l & r */
		ALGODEBUG THRprintf(GDKout, "BATfetchjoin: BAThvoid(l) && !BATtvoid(l) && BATtdense(l)\n");
		@:densevoidfetchjoin(@1,@2,@3)@
	} else if (BATtordered(l)&1) {
		/* we did check the bounderies already above */
		ALGODEBUG THRprintf(GDKout, "BATfetchjoin: BAThvoid(l) && !BATtvoid(l) && !BATtdense(l) && BATtordered(l)&1\n");
		@:orderedvoidfetchjoin(@1,@2,@3)@
	} else {
		ALGODEBUG THRprintf(GDKout, "BATfetchjoin: BAThvoid(l) && !BATtvoid(l) && !BATtdense(l) && !BATtordered(l)&1\n");
		@:defaultvoidfetchjoin(@1,@2,@3)@
	}
@c
#define SIMPLEput(tpe,hp,dst,src) *(tpe*) (dst) = *(tpe*) (src)

static BAT* batfetchjoin(BAT *l, BAT *r, size_t estimate, bit swap) {
        int xx, yy, zz, lht, rtt;
	size_t base, end;
	ssize_t offset;
        BUN r_cur, l_cur, l_end, dst;
        oid seqbase;
        BAT *ret = NULL, *bn = NULL, *l_orig = l;

        BATcheck(l, "BATfetchjoin: l");
        BATcheck(r, "BATfetchjoin: r");

	if  (estimate == oid_nil) {
		estimate = BATcount(l);
	}

	if (swap) {
            if (!BAThdense(r)) {
                ERRORcheck(!BATtdense(l), "BATfetchjoin: one join column must be dense");
		ALGODEBUG THRprintf(GDKout, "BATfetchjoin: BATmirror(BATfetchjoin(BATmirror(r),BATmirror(l)));\n");
                return BATmirror(BATfetchjoin(BATmirror(r),BATmirror(l), estimate));
            }
	} else {
		ERRORcheck(!BAThdense(r), "BATleftfetchjoin: head column of right input must be dense");
	}
        if ((BATcount(l) == 0) || (BATcount(r) == 0)) {
		/* below range checking do not support empty bats. so treat them separately (easy) */
                bn = BATnew(l->htype, l->htype?r->ttype:ATOMtype(r->ttype), 0); 
		bn->hsorted = bn->tsorted = GDK_SORTED;
		BATkey(bn, TRUE);
		BATkey(BATmirror(bn), TRUE);
		if ( bn->htype == TYPE_void || bn->htype == TYPE_oid ) {
			bn->hdense = TRUE;
			BATseqbase(bn, l->hseqbase);
		}
		if ( bn->ttype == TYPE_void || bn->ttype == TYPE_oid ) {
			bn->tdense = TRUE;
			BATseqbase(BATmirror(bn), l->tseqbase);
		}
                return bn;
	} else if (BATtordered(l)&1) {
                /* optimization to be able to carry over more void head columns */
                /* (only needed if neither operand is empty) */
                ssize_t r_lo = *(ssize_t*) BUNhead(r, BUNfirst(r));
                ssize_t r_hi = *(ssize_t*) BUNhead(r, BUNlast(r)-BUNsize(r));
                ssize_t l_lo = *(ssize_t*) BUNtail(l, BUNfirst(l));
                ssize_t l_hi = *(ssize_t*) BUNtail(l, BUNlast(l)-BUNsize(l));
	        ALGODEBUG THRprintf(GDKout, "BATfetchjoin: BATtordered(l)&1\n");
		ALGODEBUG THRprintf(GDKout, "r_lo=" SSZFMT ", r_hi=" SSZFMT ", l_lo=" SSZFMT ", l_hi=" SSZFMT ".\n", r_lo, r_hi, l_lo, l_hi);
                if (r_lo > l_lo || r_hi < l_hi) {
			ALGODEBUG THRprintf(GDKout, "shrinking!\n");
	        	ALGODEBUG THRprintf(GDKout, "BATfetchjoin: l = BATselect(l, &r_lo, &r_hi);\n");
                        l = BATselect(l, &r_lo, &r_hi); /* sorted, so it will be a slice */
			if (l == NULL) return NULL;
                }
        }
	ALGODEBUG THRprintf(GDKout, "BATfetchjoin: 1\n");
        base = BUNindex(r, BUNfirst(r));
        offset = (ssize_t) (base - r->hseqbase);
        end = base + BATcount(r);
	/* only BUNhead crashes on empty bats with TYPE != virtual oid */
	seqbase = (l->htype == TYPE_void)?l->hseqbase:
			(BATcount(l)?(l->htype==TYPE_int?(oid)*(int*)BUNhead(l,BUNfirst(l)):(l->htype==TYPE_oid?*(oid*)BUNhead(l,BUNfirst(l)):(l->htype==TYPE_lng?(oid)*(lng*)BUNhead(l,BUNfirst(l)):oid_nil))):oid_nil);

	ALGODEBUG THRprintf(GDKout, "BATfetchjoin: 2\n");
        if (!BAThvoid(l)) {
		ALGODEBUG THRprintf(GDKout, "BATfetchjoin: !BAThvoid(l)\n");
                /* default case: no void column to propagate */
                lht = l->htype;
                rtt = r->ttype;
                bn = BATnew(BAThtype(l), BATttype(r), estimate);
		if( bn == NULL) goto ready;
                ESTIDEBUG THRprintf(GDKout, "BATfetchjoin: estimated resultsize: " SZFMT "\n",BATcount(l));
                dst = BUNfirst(bn);
                zz = BUNsize(bn);
                /* TODO: apply the "string trick" (see below) here too */
		if (BATtdense(l)) {
			/* dense => ordered, i.e., we did check the bounderies already above */
			/* and we can do a "synchronized walk" through l & r */
			ALGODEBUG THRprintf(GDKout, "BATfetchjoin: !BAThvoid(l) && BATtdense(l)\n");
			@:fetchjoin_switch_lht(dense)@
		} else if (BATtordered(l)&1) {
			/* we did check the bounderies already above */
			ALGODEBUG THRprintf(GDKout, "BATfetchjoin: !BAThvoid(l) && !BATtdense(l) && BATtordered(l)&1\n");
			@:fetchjoin_switch_lht(ordered)@
		} else {
			ALGODEBUG THRprintf(GDKout, "BATfetchjoin: !BAThvoid(l) && !BATtdense(l) && !BATtordered(l)&1\n");
			@:fetchjoin_switch_lht(default)@
		}
                bn->hsorted = (BATtordered(l)&BAThordered(r)&1)?BAThordered(l):0;
        } else if (!BATtvoid(l)) {
                /* propagation of void columns in the result */
		int nondense = 0;
                int tpe = r->ttype;
		BAT *ret = NULL;
		ALGODEBUG THRprintf(GDKout, "BATfetchjoin: BAThvoid(l) && !BATtvoid(l)\n");
                if (ATOMstorage(tpe) == TYPE_str && GDK_ELIMDOUBLES(&r->theap)) {
                        tpe = TYPE_var; /* insert double-eliminated strings as ints */
                }
                bn = BATnew(TYPE_void, ATOMtype(tpe), estimate);
		if (bn==NULL) goto ready;
                ESTIDEBUG THRprintf(GDKout, "BATfetchjoin: estimated resultsize: " SZFMT "\n",BATcount(l));
                dst = BUNfirst(bn);
                zz = BUNsize(bn);

                if (ATOMstorage(tpe) == TYPE_chr) {
                        @:voidfetchjoin(tloc,chr,SIMPLE)@
                } else if (ATOMstorage(tpe) == TYPE_sht) {
                        @:voidfetchjoin(tloc,sht,SIMPLE)@
                } else if (tpe != TYPE_bat && (ATOMstorage(tpe) == TYPE_int || ATOMstorage(tpe) == TYPE_flt)) {
	                /* ensure use of ATOMput for TYPE_bat */   
                        @:voidfetchjoin(tloc,int,SIMPLE)@
                } else if (ATOMstorage(tpe) == TYPE_lng || ATOMstorage(tpe) == TYPE_dbl) {
                        @:voidfetchjoin(tloc,lng,SIMPLE)@
                } else if (r->tvarsized) {
                        @:voidfetchjoin(tvar,bn->ttype,ATOM)@
                } else {
                        @:voidfetchjoin(tloc,bn->ttype,ATOM)@
                }
		ret = bn;
bunins_failed:
    		bn->batBuns->free = dst - bn->batBuns->base;
		if (ret == NULL) {
			BBPreclaim(bn);
			goto ready; 
		}
                /* handle string trick */
                if (tpe == TYPE_var && ATOMstorage(r->ttype) == TYPE_str) {
                        BAT *bm = BATmirror(bn);
                        if (HEAPcopy(&bn->theap, &r->theap) < 0) {
				BBPreclaim(bn);
				goto ready; 
			}
                        bn->ttype = bm->htype = r->ttype;
                        bn->tvarsized = bm->hvarsized = 1;
                        strcpy(bn->tatom, ATOMname(r->ttype));
                }
                if (nondense) {
                	bn->hsorted = (BATtordered(l)&BAThordered(r)&1)?BAThordered(l):0;
                } else {
                	BATseqbase(bn, seqbase);
                	if (seqbase != oid_nil) BATkey(bn, TRUE);
                	bn->hsorted = GDK_SORTED;
                }
        } else if (l->tseqbase != oid_nil) {
                /* execute using slice */
                BAT *v = BATmirror(VIEWhead(BATmirror(r)));
                oid lo_val = MAX(l->tseqbase,r->hseqbase);
                oid hi_val = MIN(l->tseqbase+BATcount(l),r->hseqbase+BATcount(r));
                size_t lo_pos = lo_val - r->hseqbase;
                size_t hi_pos = hi_val;
		if (hi_pos > r->hseqbase)
			hi_pos -= r->hseqbase;
		else
			hi_pos = 0;
		ALGODEBUG THRprintf(GDKout, "BATfetchjoin: BAThvoid(l) && BATtvoid(l) && l->tseqbase != oid_nil  =>  bn = BATslice(BATmirror(VIEWhead(BATmirror(r))), lo_pos=" SZFMT ", hi_pos=" SZFMT ");\n", lo_pos, hi_pos);
                bn = BATslice(v, lo_pos, hi_pos);
                if (seqbase != oid_nil) seqbase += lo_val - l->tseqbase;
                BATseqbase(bn, seqbase);
		BBPunfix(v->batCacheid);
        } else {
                /* nil join column => empty result */
		ALGODEBUG THRprintf(GDKout, "BATfetchjoin: BAThvoid(l) && BATtvoid(l) && l->tseqbase == oid_nil\n");
                bn = BATnew(ATOMtype(l->htype), ATOMtype(r->ttype), 10);
		if (bn == NULL) goto ready;
                ESTIDEBUG THRprintf(GDKout, "BATfetchjoin: estimated resultsize: %d\n",10);
        }
        /* property propagation */
        if (BATcount(bn) == BATcount(l)) {
                ALIGNsetH(bn, l); /* BAThkey(r), remember? */
        } else {
                bn->hsorted = l->hsorted;
        }
        bn->tsorted = BATtordered(l)&BATtordered(r)&1;
        if (BATtkey(l)) {
                /* if BATtkey(l) elements of r match at most once */
                if ((BATtordered(l)&1) && BATcount(bn) == BATcount(r)) {
                        ALIGNsetT(bn, r);
                } else {
                        BATkey(BATmirror(bn), BATtkey(r));
                }
        }
	ret = bn;
ready:
        if (l != l_orig) {
                BBPreclaim(l); /* was created as a temporary (slice) select on l */
        }
        ESTIDEBUG THRprintf(GDKout, "BATfetchjoin: actual resultsize: " SZFMT "\n",BATcount(bn));
        return ret;
}

BAT* BATfetchjoin(BAT *l, BAT *r, size_t estimate) {
	/* allows swapping of left and right input for faster processing */
	return batfetchjoin(l, r, estimate, TRUE);
}

BAT* BATleftfetchjoin(BAT *l, BAT *r, size_t estimate) {
	/* do not swap left and right input, 
	   and hence maintain order of left head in result */
	return batfetchjoin(l, r, estimate, FALSE);
}

@-
This routine does the join optimization. TODO: it should be expressed in MIL.
@c
static BAT *batthetajoin(BAT *l, BAT *r, int op, size_t estimate, bit swap);

static BAT *batjoin(BAT *l, BAT *r, size_t estimate, bit swap) {
	size_t i, lsize, rsize;
        int lfetch, rfetch, must_hash; 
        lng logr, logl;
 
	ERRORcheck(l == NULL, "BATjoin: invalid left operand"); 
	ERRORcheck(r == NULL, "BATjoin: invalid right operand"); 
	ERRORcheck(TYPEerror(l->ttype, r->htype), "BATjoin: type conflict\n"); 
@-
collect statistics that help us decide what to do 
@c
	lsize = l->batBuns->size + (l->hheap.base?l->hheap.size:0) + 
				   (l->theap.base?l->theap.size:0);
	rsize = r->batBuns->size + (r->hheap.base?r->hheap.size:0) + 
				   (r->theap.base?r->theap.size:0);
	for(logr=4, i=BATcount(r); i > 0; logr++) i >>= 1; 
	for(logl=4, i=BATcount(l); i > 0; logl++) i >>= 1; 

	rfetch = BAThdense(r);
	lfetch = BATtdense(l);
	/* in case of fetchjoin, make sure we propagate a non-join void column */
	if (lfetch && rfetch) {
		if (BAThvoid(l) && !BATtvoid(r)) lfetch = 0;
		if (BATtvoid(r) && !BAThvoid(l)) rfetch = 0;
	}
	must_hash = (swap && (rsize < lsize)) ? l->thash_heap != NULL : r->hhash_heap != NULL;
@-
In special cases (equal join columns, void join columns, or ordered 
join columns), we take special action.
@c
	if (swap && lfetch && !(rfetch && BATcount(l) < BATcount(r))) {
		ALGODEBUG THRprintf(GDKout, "BATjoin: BATmirror(BATfetchjoin(BATmirror(r), BATmirror(l), " SZFMT "));\n", estimate);
		return BATmirror(BATfetchjoin(BATmirror(r), BATmirror(l), estimate));
	} else if (rfetch) {
		ALGODEBUG THRprintf(GDKout, "BATjoin: BATfetchjoin(l, r, " SZFMT ");\n", estimate);
		return batfetchjoin(l, r, estimate, swap);
	}
@-
If both are ordered we do merge-join, or if hash-join is not possible right 
away and one input is ordered and the other is much smaller, we do nested
loop binary search (both implemented by BATmergejoin).
@c
	if ((BATtordered(l)&BAThordered(r)&1) || (must_hash &&
		  (((BATtordered(l)&1) && ((lng)BATcount(l) > logl*(lng)BATcount(r)) && swap) ||
		   ((BAThordered(r)&1) && ((lng)BATcount(r) > logr*(lng)BATcount(l))))))
	{ 
		ALGODEBUG THRprintf(GDKout, "BATjoin: BATmergejoin(l,r," SZFMT ");\n", estimate);
		return batmergejoin(l, r, estimate, swap);
	}
@-
if hash join is not right away possible and we have a binary tree index,
we do nested loop index lookup join.
@c
	if (must_hash && ((l->tidx_heap && swap) || r->hidx_heap)) {
		ALGODEBUG THRprintf(GDKout, "BATjoin: batthetajoin(l,r,JOIN_EQ," SZFMT ",swap);\n", estimate);
		return batthetajoin(l, r, JOIN_EQ, estimate, swap);
	}
@-
hash join: the bread&butter join of monet
@c
	if ( swap && (rsize < lsize)) { /* assume largest fits memory */
		ALGODEBUG THRprintf(GDKout, "BATjoin: BATmirror(BAThashjoin(BATmirror(r), BATmirror(l)," SZFMT "));\n", estimate);
		return BATmirror(BAThashjoin(BATmirror(r), BATmirror(l), estimate));
        }
	ALGODEBUG THRprintf(GDKout, "BATjoin: BAThashjoin(l,r," SZFMT ");\n",estimate);
	return BAThashjoin(l, r, estimate);
}

BAT *BATjoin(BAT *l, BAT *r, size_t estimate) {
	/* allows swapping of left and right input for faster processing */
        BAT *b = batjoin(l, r, estimate, TRUE);
        BATpropcheck(b, BATPROPS_ALL);
        return b;
}

BAT *BATleftjoin(BAT *l, BAT *r, size_t estimate) {
	/* do not swap left and right input, 
	   and hence maintain order of left head in result */
        BAT *b = batjoin(l, r, estimate, FALSE);
        BATpropcheck(b, BATPROPS_ALL);
        return b;
}
@
@}
@+  Outerjoin
The left outerjoin between two BAT is also supported. The code is
identical to the hashjoin algorithm with the extension to insert a BUN
if no match can be found.
@{
@= outerjoinloop
{	ptr	v, nilh = ATOMnilptr(r->htype), nilt = ATOMnilptr(r->ttype); 
	hash_t	xx;
	int	yy;
	BUN	p, q, w; 

	BATloopFast(l, p, q, yy) { 
		size_t i = 0; 
       		v = (ptr) BUNtail(l, p); 
		if (!@1_EQ(v, nilh, @2)) 
	   	HASHloop_@2(r, r->hhash, xx, v, w) { 
			bunfastins(bn, BUNhead(l, p), BUNtail(r, w));
			i++; 
		}
		if (i == 0) {
       			bunfastins(bn, BUNhead(l, p), nilt);
       		}
	}
}
break;
@
@-
The baseline join algorithm creates a hash on the smallest element and
probes it using the larger one. [TODO]
@c
BAT *BATouterjoin(BAT *l, BAT *r, size_t estimate) {
	BAT	*bn = NULL; 
	
	@:joincheck(BATouterjoin, l->ttype, r->htype)@
	if (BAThdense(l) && BAThkey(r)) {
		if (estimate == oid_nil) estimate = BATcount(l);
		bn = BATnew(TYPE_void, ATOMtype(r->ttype), estimate);
		if(bn==NULL) return bn;
        	ESTIDEBUG THRprintf(GDKout, "BATouterjoin: estimated resultsize: " SZFMT "\n", estimate);
		BATseqbase(bn, l->hseqbase);
	}
	if (BAThdense(r) == FALSE && BAThordered(r)&1) {
		/* use the merge-join; it takes care of the rest */
		bn = mergejoin(l, r, bn, ATOMnilptr(r->ttype), estimate);
  		ESTIDEBUG THRprintf(GDKout, "BATouterjoin: actual resultsize: " SZFMT "\n",BATcount(bn));
		return bn; 
	} else if (bn == NULL) {
		@:joinbat(JOIN_EQ, BATouterjoin(l,r,oid_nil), estimate)@
	} 
	if (BAThdense(r)) {
		/* positional algorithm: hash on void column would give error and is stupid */
		ptr nilt = ATOMnilptr(r->ttype); 
		BUN p, q, w, s = BUNfirst(bn);
		int yy, xx = BUNsize(bn);;
		BATloopFast(l, p, q, yy) { 
       			oid v = *(oid*) BUNtail(l, p); 
			ptr t = nilt;

			if (v != oid_nil) {
				BUNfndVOID(w, r, &v);	 
				if (w) t = BUNtail(r, w);
			}
			bunfastins_nocheck(bn, s, BUNhead(l, p), t, xx); s += xx;
		}
		bn->tsorted = BATtordered(l) & BATtordered(r) & 1;
	} else {
		/* hash based algorithm (default) */
		int any = ATOMstorage(r->htype);
		if (BATprepareHash(r)) {
			BBPreclaim(bn);
			return NULL;
		}
		switch(any) {
#ifndef NOEXPAND_CHR
		case TYPE_chr: @:outerjoinloop(simple,chr)@ 
#endif
#ifndef NOEXPAND_SHT
		case TYPE_sht: @:outerjoinloop(simple,sht)@ 
#endif
#if !defined(NOEXPAND_INT) || !defined(NOEXPAND_FLT)
		case TYPE_int: 
		case TYPE_flt: @:outerjoinloop(simple,int)@ 
#endif
#if !defined(NOEXPAND_DBL) || !defined(NOEXPAND_LNG)
		case TYPE_dbl: 
		case TYPE_lng: @:outerjoinloop(simple,lng)@
#endif
		default:       @:outerjoinloop(atom,any)@
		}
		bn->tsorted = 0;
	}
	/* set sorted flags by hand, because we used BUNfastins() */
	if (r->hkey) {
		ALIGNsetH(bn, l); /* always 1 hit, so columns are equal */
	} else {
		bn->hsorted = BAThordered(l);
	}
  	ESTIDEBUG THRprintf(GDKout, "BATouterjoin: actual resultsize: " SZFMT "\n",BATcount(bn));
	return bn; 
bunins_failed:
	BBPreclaim(bn);
	return NULL;
}
@
@}

@+ ThetaJoin 
Current predicates supported are: JOIN_EQ, JOIN_LT,
JOIN_GE, JOIN_LE and JOIN_GT. The JOIN_EQ will pass the control to the
normal @:BATjoin@ equijoin. The is and index-based join: if an index
is not present, it will be created on the smallest relation.  

We do lots of code-inlining: first of all on join type (4), and
furthermore on left-tail (equal right-head) type (5), which are the
join columns.  We factor out more by splitting on storage strategy
(variable-sized/fixed-size) of both the left-head, and right tail
columns (2*2).

In the end, this results in 4*5*2*2 = 80 different inner loops.

@- 
Thetajoin implementation uses IDXs to compute a thetajoin on two bats.
@{
@= thetaloop
BATloopFast(l, p, q, xx) {
	v = (BUN*) BUNtail(l,p);
	if ((*cmp)(v,nil) == 0) {
	    continue;
	} 
	@1;
	IDXloop(r, lo, hi) { 
	    if (binner) if (BUNfastins(binner, BUNtail(l,p), BUNhead(r,*lo)) == NULL) return -1;
	    if (bouter) if (BUNfastins(bouter, BUNhead(l,p), BUNtail(r,*lo)) == NULL) return -1;
	}
}
break;
@c
static int IDXthetajoin(BAT *binner, BAT *bouter, BAT *l, BAT *r, int op) {
	BUN p, q, *lo, *hi, *first = IDXfirst(r), *last = IDXlast(r);
	int (*cmp)(ptr,ptr) = BATatoms[l->ttype].atomCmp;
	ptr v, nil = ATOMnilptr(l->ttype);
	int xx;
	
	/* skip nils */
	while(first < last && (*cmp)(BUNhead(r,*first),nil) == 0) {
		first++;
	}
       	switch(op) {
       	case JOIN_EQ: @:thetaloop(IDXrng(r,v,v,&lo,&hi))@
       	case JOIN_LE: @:thetaloop(lo=IDXfndfirst(r,v);hi=last)@
       	case JOIN_LT: @:thetaloop(lo=IDXfndlast(r,v);hi=last)@
       	case JOIN_GE: @:thetaloop(lo=first;hi=IDXfndlast(r,v))@
       	case JOIN_GT: @:thetaloop(lo=first;hi=IDXfndfirst(r,v))@
	}
	if (bouter) {
		bouter->hsorted = BAThordered(l); bouter->tsorted = FALSE;
	}
	if (binner) {
		binner->hsorted = BATtordered(l); binner->tsorted = FALSE;
	} 
	return 0;
}

static int battheta(BAT* inner, BAT* outer, BAT* l, BAT* r, int op, bit swap) {
	int leftinner = 1;
	
	BATcheck(l, "BATtheta"); 
	BATcheck(r, "BATtheta"); 

	if (TYPEerror(l->ttype, r->htype) ||
	    (inner && (TYPEerror(inner->htype, l->ttype) ||
                       TYPEerror(inner->ttype, r->htype))) ||
	    (outer && (TYPEerror(outer->htype, l->htype) ||
                       TYPEerror(outer->ttype, r->ttype))))
	{
		GDKerror("BATtheta: argument types incompatible\n");
		return -1;
	}

	if (!swap || r->hidx_heap || (BAThordered(r)&1)) {
		leftinner = 0;
	} else if (l->tidx_heap || (BATtordered(l)&1)) {
		BATflipflop(l);
		BATflipflop(r);
	} else if (BATcount(l) < BATcount(r)) {
		BATflipflop(l);
		BATflipflop(r);
	} else { 
		leftinner = 0;
	}

	if (leftinner) {
		if (inner) BATflipflop(inner);
		if (outer) BATflipflop(outer);
		if (BATidx(l,0) == 0) return -2;
		if (IDXthetajoin(inner, outer, r, l, -op) < 0) return -1;
		if (inner) BATflipflop(inner);
		if (outer) BATflipflop(outer);
		BATflipflop(l);
		BATflipflop(r);
	} else {
		if (BATidx(r,0) == 0) return -2;
		if (IDXthetajoin(inner, outer, l, r, op) < 0) return -1;
	}
	return 0;
}

int BATtheta(BAT* inner, BAT* outer, BAT* l, BAT* r, int op) {
	return battheta(inner, outer, l, r, op, TRUE);
}

static BAT *batthetajoin(BAT *l, BAT *r, int op, size_t estimate, bit swap) {
	BAT	*bn; 
	
	@:joinbat(op, batthetajoin(l,r,op,estimate,swap), estimate)@
	if (battheta(NULL, bn, l, r, op, swap) < 0) {
		BBPreclaim(bn);
		return NULL;
	}
        ESTIDEBUG THRprintf(GDKout, "batthetajoin: actual resultsize: " SZFMT "\n",BATcount(bn));
	return bn;
}

BAT *BATthetajoin(BAT *l, BAT *r, int op, size_t estimate) {
	@:joincheck(BATthetajoin, l->ttype, r->htype)@
	if (op == JOIN_EQ) { 
		/* exploit all equi-join optimizations */
		ALGODEBUG THRprintf(GDKout, "BATthetajoin(l,r,JOIN_EQ): BATjoin(l, r);\n");
		return BATjoin(l, r, estimate);
	}
	return batthetajoin(l, r, op, estimate, TRUE);
}

BAT *BATleftthetajoin(BAT *l, BAT *r, int op, size_t estimate) {
	@:joincheck(BATleftthetajoin, l->ttype, r->htype)@
	if (op == JOIN_EQ) {
		/* exploit all equi-join optimizations */
		ALGODEBUG THRprintf(GDKout, "BATleftthetajoin(l,r,JOIN_EQ): BATleftjoin(l, r);\n");
		return BATleftjoin(l, r, estimate);
	}
	return batthetajoin(l, r, op, estimate, FALSE);
}

BAT *BATindexjoin(BAT *l, BAT *r, size_t estimate) {
        /* allows swapping of left and right input for faster processing */
	return batthetajoin(l, r, JOIN_EQ, estimate, TRUE);
}

BAT *BATleftindexjoin(BAT *l, BAT *r, size_t estimate) {
	/* do not swap left and right input, 
	   and hence maintain order of left head in result */
	return batthetajoin(l, r, JOIN_EQ, estimate, FALSE);
}

/* nested loop join; finally MonetDB can enjoy the virtues of this algorithm as well! */
BAT *nlthetajoin(BAT *l, BAT *r, int op, size_t estimate) {
        BAT *bn = BATnew(ATOMtype(l->htype), ATOMtype(r->ttype), estimate);
        int (*cmp)(ptr,ptr) = BATatoms[l->ttype].atomCmp;
        ptr nil = ATOMnilptr(l->ttype);
        int rx, lx, lo = 0, hi = 0;
        BUN rp, rq, lp, lq;

        if (op == JOIN_GT) {
                lo = 1; hi = GDK_int_max;
        } else if (op == JOIN_GE) {
                lo = 0; hi = GDK_int_max;
        } else if (op == JOIN_LT) {
                lo = GDK_int_min; hi = -1;
        } else if (op == JOIN_LE) {
                lo = GDK_int_min; hi = 0;
        }
        /* we are not going to optimize this by type; not worth it! */
        BATloopFast(l, lp, lq, lx) {
                ptr v = (ptr) BUNtail(l,lp);
                if ((*cmp)(v,nil) == 0) {
                    continue;
                }
                BATloopFast(r, rp, rq, rx) {
                        ptr w = (ptr) BUNhead(r,rp);
                        int c = (*cmp)(v,w);
                        if ((c >= lo) & (c <= hi)) {
                                bunfastins(bn, BUNhead(l,lp), BUNtail(r,rp));
                        }
                }
        }
        bn->hsorted = l->hsorted;
        bn->tsorted = 0;
        return bn;
bunins_failed:
        BBPreclaim(bn);
        return NULL;
}
@}

@+ Bandjoin
A non-equi join of two relations R and S is called a Band-join if
the join predicate requires the values of R to fall within a given range.
This kind of joins is encountered in real world domains, such as those 
involved with time and distance.

The boundary conditions for the bandjoin are constants or a NULL value.
The latter enables encoding of arbitrary theta joins using the more
general bandjoin.
Incidentally note that c1 = c2 = 0 leads to an equi-join.

The straight forward implementation uses a nested loop.
The current implementation does not optimize processing, because
the impact of the choices is not yet clear.

The hash indexing routines have been extended with a Band argument.
@{
@c
BAT *BATbandjoin(BAT *l, BAT *r, ptr c1, ptr c2) {
	BAT *bn; 
	BUN p, q;
	BUN v, w;
	
	@:joincheck(BATbandjoin, l->ttype, r->htype)@
	@:joinbat(JOIN_BAND, BATbandjoin(l,r,c1,c2), oid_nil)@
	switch(ATOMstorage(r->htype)) {
	case TYPE_chr: @:bandjoin(chr)@
	case TYPE_sht: @:bandjoin(sht)@
	case TYPE_int: @:bandjoin(int)@
	case TYPE_flt: @:bandjoin(flt)@
	case TYPE_dbl: @:bandjoin(dbl)@ 
	case TYPE_lng: @:bandjoin(lng)@
	default: GDKerror("BATbandjoin: type not implemented\n");
		 return NULL;
	}
	/* set sorted flags by hand, because we used BUNfastins() */
	bn->hsorted = BAThordered(l);
	bn->tsorted = FALSE;

  	ESTIDEBUG THRprintf(GDKout, "BATbandjoin: actual resultsize: " SZFMT "\n",BATcount(bn));
	return bn; 
}
@
@}
@- 
The easiest case is to implement a nested loop for band operations.
Choice point is to determine the status of the NULL values in the final
result.
@{
@= bandjoin
{	int	xx, yy;
	@1	*x1;
	@1	*x2;
 
	BATloopFast(l, p, q, xx) {
		x1 = (@1 *) BUNtloc(l, p); 
		BATloopFast(r, v, w, yy) {
			x2 = (@1 *) BUNhloc(r, v); 
			if ((*x1 >= *x2 -  *(@1 *) c1) && 
			    (*x1 <= *x2 + *(@1 *) c2)) 
			{
				if (BUNfastins(bn, BUNhead(l,p), BUNtail(r, v)) == NULL) {
					BBPreclaim(bn);
					return NULL;
				} 
			}
		}
       	}
	break;
}
@
@}
@+ Semijoin 

The @%BATsemijoin@ performs a semijoin over @%l@ and @%r@. It returns
a subset of @%l@ that matches at least one element in @%r@.
The result inherits the integrity properties.

Various algorithms exist. The main one BATkintersect() resides
outside this file, in the set-operations implementation (gdk_setop).
Other variants for the semijoin include the fetch-semijoin
(for dense join columns), the reverse semijoin that loops over r
instead of l, and semijoin using binary search in r.
@{
@= semijoinbat
	bn = BATnew(BAThtype(@1), BATttype(@1), MAX(BATTINY, MIN(BATcount(l), BATcount(r)))); 
  	ESTIDEBUG THRprintf(GDKout, "%s.semijoinbat: estimated resultsize: " SZFMT "\n",@4,MAX(BATTINY, MIN(BATcount(l), BATcount(r))));
	if (bn == NULL) {
		return bn; 
	}
	BATkey(bn, BAThkey(@1));
	BATkey(BATmirror(bn), BATtkey(@1));
	bn->hsorted = @2;
	bn->tsorted = @3;

@- sort semijoin
In the sorted cases with a low semijoin hit-rate, we do lookup using 
probe-based binary search, instead of a full merge scan.
Normal merge-semijoin with a full scan on both is handled by kintersect
(default exit) if both relations are large or if their sizes do not 
differ significantly.

@= binsemijoin
{	BUN lp, lq;
	int xx;
	ptr nil = ATOMnilptr(l->htype);

        if (cpy == l) {
   		BATloopFast(l, lp, lq, xx) {
			ptr v = BUNh@1(l,lp);
			if (!@3_EQ(v, nil, @2) && SORTfnd_@2(r, v)) {
				bunfastins(bn, v, BUNtail(l,lp));
			}
		}
	} else {
		BATloopFast(l, lp, lq, xx) {
			BUN rp, rq;
			ptr v = BUNh@1(l,lp);
			if (!@3_EQ(v, nil, @2)) {
				int yy;
				SORTloop_@2(BATmirror(r), rp, rq, v, v, yy) {
			    		bunfastins(bn, v, BUNtail(r,rp));
				}
			}
		}
	} 
}
break;
@c
BAT *BATbinsemijoin(BAT *l, BAT *r, BAT *cpy) {
	BAT *bn, *del = NULL;
	int loc, var;

	@:joincheck(BATbinsemijoin, l->htype, r->htype)@
	@:semijoinbat(cpy, TRUE,(l == cpy && (BATtordered(l)&1)), "BATbinsemijoin")@ 

	if (!(BAThordered(r)&1)) {
		del = r = BATsort(r);
		if( del == NULL) return NULL;
	}

	switch(loc=var=ATOMstorage(l->htype)) {
#ifndef NOEXPAND_CHR
	case TYPE_chr: @:binsemijoin(loc,chr,simple)@
#endif
#ifndef NOEXPAND_SHT
	case TYPE_sht: @:binsemijoin(loc,sht,simple)@
#endif
#ifndef NOEXPAND_INT
	case TYPE_int: @:binsemijoin(loc,int,simple)@
#endif
#ifndef NOEXPAND_FLT
	case TYPE_flt: @:binsemijoin(loc,flt,simple)@
#endif
#ifndef NOEXPAND_DBL
	case TYPE_dbl: @:binsemijoin(loc,dbl,simple)@
#endif
#ifndef NOEXPAND_LNG
	case TYPE_lng: @:binsemijoin(loc,lng,simple)@
#endif
	default: if (l->hvarsized) {
		   if (r->hvarsized) {
		       @:binsemijoin(var,var,atom)@
		   } else {
		       @:binsemijoin(var,loc,atom)@
		   }
		 } else {
		   if (r->hvarsized) {
		       @:binsemijoin(loc,var,atom)@
		   } else {
		       @:binsemijoin(loc,loc,atom)@
		   }
		 }
	}
	/* propagate properties */
	bn->hsorted = l->hsorted;
	bn->tsorted = 0;
	if (BATcount(bn) == BATcount(l)) {
		if (l == cpy) {
			ALIGNset(bn,l);
		} else if (BAThkey(l) && BAThkey(r)) {
			ALIGNsetH(bn,l);
		}
	}
	if (del) BBPreclaim(del);
  	ESTIDEBUG THRprintf(GDKout, "BATbinsemijoin: actual resultsize: " SZFMT "\n",BATcount(bn));
	return bn;
bunins_failed:
	BBPreclaim(bn);
	return NULL;
} 

@- idx semijoin
similar to binsemijoin, but now using an existing idx accelerator 
for the binary search.

@= idxsemijoin
{	BUN lp, lq;
	int xx;
	ptr nil = ATOMnilptr(l->htype);

	if (cpy == l) {
		BATloopFast(l, lp, lq, xx) {
			ptr v = BUNh@1(l,lp);
			if (!@3_EQ(v, nil, @2) && IDXfnd_@2(r, v)) {
				if (BUNfastins(bn, v, BUNtail(l,lp)) == NULL) {
					BBPreclaim(bn);
					return NULL;
				}
			}
		}
	} else {
		BATloopFast(l, lp, lq, xx) {
			BUN *rp, *rq;
			ptr v = BUNh@1(l,lp);
			if (!@3_EQ(v, nil, @2)) {
				IDXrng(r, v, v, &rp, &rq);
				IDXloop(r, rp, rq) {
					if (BUNfastins(bn, v, BUNtail(r,*rp)) == NULL) {
						BBPreclaim(bn);
						return NULL;
					}
				}
			}
		}
	} 
}
break;
@c
BAT *BATidxsemijoin(BAT *l, BAT *r, BAT *cpy) {
	BAT *bn;
	int loc, var;

	@:joincheck(BATidxsemijoin, l->htype, r->htype)@
	@:semijoinbat(cpy, TRUE,FALSE, "BATidxsemijoin")@
	if (r->hidx_heap == NULL) {
		BATidx(r, 0);
	}

	switch(loc=var=ATOMstorage(l->htype)) {
#ifndef NOEXPAND_CHR
	case TYPE_chr: @:idxsemijoin(loc,chr,simple)@
#endif
#ifndef NOEXPAND_SHT
	case TYPE_sht: @:idxsemijoin(loc,sht,simple)@
#endif
#ifndef NOEXPAND_INT
	case TYPE_int: @:idxsemijoin(loc,int,simple)@
#endif
#ifndef NOEXPAND_FLT
	case TYPE_flt: @:idxsemijoin(loc,flt,simple)@
#endif
#ifndef NOEXPAND_DBL
	case TYPE_dbl: @:idxsemijoin(loc,dbl,simple)@
#endif
#ifndef NOEXPAND_LNG
	case TYPE_lng: @:idxsemijoin(loc,lng,simple)@
#endif
	default: if (l->hvarsized) {
		   if (r->hvarsized) {
		       @:idxsemijoin(var,var,atom)@
		   } else {
		       @:idxsemijoin(var,loc,atom)@
		   }
		 } else {
		   if (r->hvarsized) {
		       @:idxsemijoin(loc,var,atom)@
		   } else {
		       @:idxsemijoin(loc,loc,atom)@
		   }
		 }
	}
	/* propagate properties */
	bn->hsorted = l->hsorted;
	bn->tsorted = 0;
	if (BATcount(bn) == BATcount(l)) {
		if (l == cpy) {
			ALIGNset(bn,l);
		} else if (l->hkey && r->hkey) {
			ALIGNsetH(bn,l);
		}
	}
  	ESTIDEBUG THRprintf(GDKout, "BATidxsemijoin: actual resultsize: " SZFMT "\n",BATcount(bn));
	return bn;
} 

@- reverse semijoin
The semijoin done from the other side. Is only better if the other side (r) is much
smaller than l, and iff you already have the hash table on l. It uses hash tables on
both relations: on r to check that no item is processed twice (not necessary to check 
iff BAThkey(r) and one on l to find the matching tuples.

@= revsemijoin
{	int xx;
	hash_t yy;
	BUN lp = 0, rp = 0, rq = 0, rr = 0;
	ptr nil = ATOMnilptr(l->htype);

	if (merge) {
		ALGODEBUG THRprintf(GDKout, "BATrevsemijoin: merge\n");
		BATloopFast(r, rp, rq, xx) {
			ptr v = BUN@3(r,rp);
			rr = rp + xx;
			if (rr < rq && @1_EQ(v,BUN@3(r,rr),@2)) continue;
			if (!@1_EQ(v, nil, @2)) {
				HASHloop_@2(l, l->hhash, yy, v, lp)
					bunfastins(bn, v, BUNtail(l, lp));
			}
		}
	} else if (rdoubles) {
		ALGODEBUG THRprintf(GDKout, "BATrevsemijoin: rdoubles\n");
		BATloopFast(r, rp, rq, xx) {
			ptr v = BUN@3(r,rp);
			HASHloop_@2(r, r->hhash, yy, v, rr) break;
			if (rr != rp) continue; 
			if (!@1_EQ(v, nil, @2)) {
				HASHloop_@2(l, l->hhash, yy, v, lp)
					bunfastins(bn, v, BUNtail(l, lp));
			}
		}
	} else {
		BATloopFast(r, rp, rq, xx) {
			ptr v = BUN@3(r,rp);
			if (!@1_EQ(v, nil, @2)) {
				HASHloop_@2(l, l->hhash, yy, v, lp)
					bunfastins(bn, v, BUNtail(l, lp));
			}
		}
	}
}
break;
@c
BAT *BATrevsemijoin(BAT *l, BAT *r) {
	int any, rdoubles = (BAThkey(r) == 0), merge = rdoubles&BAThordered(r);
	BAT *bn;

	@:joincheck(BATrevsemijoin, l->htype, r->htype)@
	@:semijoinbat(l, FALSE, FALSE, "BATrevsemijoin")@
	if (BATprepareHash(l)) return NULL;
	if (rdoubles && BATprepareHash(r)) return NULL;
	switch(any = ATOMstorage(l->htype)) {
#ifndef NOEXPAND_CHR
	case TYPE_chr:	@:revsemijoin(simple,chr,hloc)@
#endif
#ifndef NOEXPAND_SHT
	case TYPE_sht:	@:revsemijoin(simple,sht,hloc)@
#endif
#if !defined(NOEXPAND_INT) || !defined(NOEXPAND_FLT)
	case TYPE_int: 
	case TYPE_flt:	@:revsemijoin(simple,int,hloc)@
#endif
#if !defined(NOEXPAND_DBL) || !defined(NOEXPAND_LNG)
	case TYPE_dbl: 
	case TYPE_lng:	@:revsemijoin(simple,lng,hloc)@
#endif
	default:        @:revsemijoin(atom,any,head);
	}
	/* propagate properties */
	bn->hsorted = bn->tsorted = 0;
	if (BAThkey(r) && BATtkey(l) && BATcount(bn) == BATcount(r)) {
		ALIGNsetH(bn,r);
	}
  	ESTIDEBUG THRprintf(GDKout, "BATrevsemijoin: actual resultsize: " SZFMT "\n",BATcount(bn));
	return bn;
bunins_failed:
	BBPreclaim(bn);
	return NULL;
}

@- positional semijoin 
the below routine performs a semijoin using positional lookup.
This implementation is dirty as it also allows fetches with 
hard integer positions, rather than oid matching on a dense-oid column.
@c
static BAT* BATfetchsemijoin(BAT *l, BAT *r, BAT *cpy, int denselookup) {
	int xx;
	size_t base, end, yy;
	ssize_t offset;
	BUN l_cur, l_end, r_cur;
        BAT *bn;

	BATcheck(l, "BATfetchsemijoin: l");
	BATcheck(r, "BATfetchsemijoin: r");

	if (denselookup && !BAThdense(r)) {
                GDKerror("BATfetchsemijoin: left column must be dense.\n");
                return NULL;
        } else if (ATOMstorage(l->htype) != ATOMstorage(TYPE_oid)) {
		GDKerror("BATfetchsemijoin: illegal index type %s.\n", ATOMname(l->htype));
                return NULL;
	}
	if (denselookup && BAThvoid(l)) {
		/* redirect semijoin on two dense regions to a select (and hence to BATslice) */
		oid min = oid_nil, max = oid_nil; 
		BAT *other = (cpy==l)?r:l;
		if (BATcount(other)) {
			min = *(oid*) BUNhead(l, BUNfirst(other));
			max = *(oid*) BUNhead(l, BUNlast(other)-BUNsize(other));
		}
		return BATmirror(BAT_select(BATmirror(cpy), &min, &max, TRUE));
	} 
        base = BUNindex(r, BUNfirst(r));
        end = base + BATcount(r);
        bn = BATnew(BAThtype(cpy), BATttype(cpy), MIN(BATcount(r), BATcount(l)));
	if(bn==NULL) return bn;
  	ESTIDEBUG THRprintf(GDKout, "BATfetchsemijoin: estimated resultsize: " SZFMT "\n",MIN(BATcount(r), BATcount(l)));
        if (bn == NULL) {
                return NULL;
        }
        if (denselookup) {
                offset = (ssize_t) (base - r->hseqbase); /* translate oid to BUN position */
        } else {
		offset = (ssize_t) base; /* fetch by hard BUNindex */
	} 

	/* iterate r; positional fetch in l */
        BATloopFast(l, l_cur, l_end, xx) {
		yy = offset + *(oid*) BUNhloc(l,l_cur);
               	if (yy < base || yy >= end) {
			continue;
               	}
		r_cur = BUNptr(r, yy);
		if (cpy == r) {
			bunfastins(bn, BUNhead(r,r_cur), BUNtail(r,r_cur));
		} else {
			bunfastins(bn, BUNhead(r,r_cur), BUNtail(l,l_cur));
		}
	}
	
	/* property propagation */
	bn->hsorted = BAThordered(l)&BAThordered(r)&1;
	bn->tsorted = bn->hsorted&BATtordered(cpy)&1;


	if (denselookup && BATcount(bn) == BATcount(l)) {
		ALIGNsetH(bn, l);
	} else {
		BATkey(bn, BAThkey(l) && BAThkey(r));
	}
	if (BAThkey(l)) {
		if (BATcount(bn) == BATcount(cpy) && (BAThordered(r)&BAThordered(l)&1)) {
			ALIGNsetT(bn, cpy);
		} else {
			BATkey(BATmirror(bn), BATtkey(cpy));
		}
	}
  	ESTIDEBUG THRprintf(GDKout, "BATfetchsemijoin: actual resultsize: " SZFMT "\n",BATcount(bn));
        return bn;
bunins_failed:
	BBPreclaim(bn);
	return NULL;
}

BAT* BATfetch(BAT *l, BAT *r) {
	return BATfetchsemijoin(r, l, l, TRUE);
}

@-
The BATsemijoin chooses between various alternatives.  
TODO: this should be moved to MIL.
@c
BAT *BATsemijoin(BAT *l, BAT *r) {
	int reverse1, reverse2;
	size_t countr, countl, i;
        lng logr, logl;
	BAT *bn, *tmp = NULL;
	
	ERRORcheck(l == NULL, "BATsemijoin"); 
	ERRORcheck(r == NULL, "BATsemijoin"); 
	ERRORcheck(TYPEerror(l->htype,r->htype),"BATsemijoin: type conflict\n");

@- algorithm selection
We have 10 algorithms implementing semijoin. Their conditions are checked in order
of efficiency. Some algorithms reverse the semijoin (loop over r, lookup in l).
To do that r should be unique. To that end, doubles may sometimes be eliminated from r.
@c
	for(logr=4, i=countr=BATcount(r); i > 0; logr++) i >>= 1; 
	for(logl=4, i=countl=BATcount(l); i > 0; logl++) i >>= 1; 
	reverse1 = countr < countl && (BAThkey(r) || (lng)countr*8 < (lng)countl);
	reverse2 = (lng)countr*logl < (lng)countl && (BAThkey(r) 
                           || (lng)countr*(logl+8) < (lng)countl);

        if (ALIGNsynced(l,r)) {
		ALGODEBUG THRprintf(GDKout, "BATsemijoin: BATrcopy(l);\n");
		bn = BATrcopy(l);	
	} else if ((BAThordered(l)&1) && BAThdense(r)) {
		oid lo = r->hseqbase;
                oid hi = r->hseqbase + countr - 1;
		ALGODEBUG THRprintf(GDKout, "BATsemijoin: BATmirror(BATselect(BATmirror(l), &lo, &hi));\n");
		bn = BATmirror(BATselect(BATmirror(l), &lo, &hi)); 
	} else if (BAThdense(r)) {
		ALGODEBUG THRprintf(GDKout, "BATsemijoin: BATfetchsemijoin(l, r, l);\n");
		bn = BATfetchsemijoin(l, r, l, FALSE);
	} else if (BAThdense(l) && reverse1) {
		if (!BAThkey(r)) {
			BAT *v = VIEWhead_(r,BAT_WRITE); tmp = r = BATkunique(v); BBPreclaim(v);
		}
		ALGODEBUG THRprintf(GDKout, "BATsemijoin: BATfetchsemijoin(r, l, l);\n");
		bn = BATfetchsemijoin(r, l, l, FALSE);
	} else if (l->hhash_heap && reverse1) {
		ALGODEBUG THRprintf(GDKout, "BATsemijoin: BATrevsemijoin(l,r);\n");
		bn = BATrevsemijoin(l,r); 
	} else if ((BAThordered(r)&1) && countl*logr < countr) {
		ALGODEBUG THRprintf(GDKout, "BATsemijoin: BATbinsemijoin(l, r, l);\n");
	        bn = BATbinsemijoin(l, r, l);
	} else if ((BAThordered(l)&1) & reverse2) {
		if (!BAThkey(r)) {
			BAT *v = VIEWhead_(r,BAT_WRITE); tmp = r = BATkunique(v); BBPreclaim(v);
		}
		ALGODEBUG THRprintf(GDKout, "BATsemijoin: BATbinsemijoin(r, l, l);\n");
		bn = BATbinsemijoin(r, l, l);
	} else if (r->hidx_heap && (lng)countl*logr < (lng)countr) {
		ALGODEBUG THRprintf(GDKout, "BATsemijoin: BATidxsemijoin(l, r, l);\n");
	        bn = BATidxsemijoin(l, r, l);
	} else if (l->hidx_heap && reverse2) {
		if (!BAThkey(r)) {
			BAT *v = VIEWhead_(r,BAT_WRITE); tmp = r = BATkunique(v); BBPreclaim(v);
		}
		ALGODEBUG THRprintf(GDKout, "BATsemijoin: BATidxsemijoin(r, l, l);\n");
		bn = BATidxsemijoin(r, l, l);
	} else {
		ALGODEBUG THRprintf(GDKout, "BATsemijoin: BATkintersect(l, r);\n");
	        bn = BATkintersect(l, r); /* merge-semijoin or nested hashlookup in r */
	}
	if (tmp) {
		BBPreclaim(tmp);
	}
	return bn;
}


@* Cross Product
@T
This operation computes the cross product of two BATs, returning only the
head-value from the 'left' operand and then tail-value from the 'right'
operand.

@= cross2
BAT* cross_@1_@2( BAT *bn, BAT *l, BAT *r ){
	BUN l_cur, l_end, r_cur, r_end, dst;
	int l_sz, r_sz, bn_sz;

        bn_sz = BUNsize(bn);
        dst = BUNfirst(bn);

	ALGODEBUG THRprintf(GDKout, "BATcross: cross_@1_@2();\n");
	BATloopFast(l, l_cur, l_end, l_sz) {
		BATloopFast(r, r_cur, r_end, r_sz) {
			@:bunfastins_nocheck_(@1,@2)@
			dst += bn_sz;
		}
	}
	bn->batBuns->free = dst - bn->batBuns->base;
	return bn;

bunins_failed:
	BBPreclaim(bn);
	return NULL;
}
@= cross1
	@:cross2(@1,chr)@
	@:cross2(@1,sht)@
	@:cross2(@1,int)@
	@:cross2(@1,lng)@
	@:cross2(@1,VATOM)@
	@:cross2(@1,LATOM)@
@c
	@:cross1(chr)@
	@:cross1(sht)@
	@:cross1(int)@
	@:cross1(lng)@
	@:cross1(VATOM)@
	@:cross1(LATOM)@
@c

@= cross_switch_rtt
{
	int rtt = r->ttype;
	int rts = ATOMstorage(rtt);
	if (rts == TYPE_chr) {
                bn = cross_@1_chr(bn,l,r);
        } else if (rts == TYPE_sht) {
                bn = cross_@1_sht(bn,l,r);
        } else if (rtt != TYPE_bat && (rts == TYPE_int || rts == TYPE_flt
#if SIZEOF_OID == SIZEOF_INT
		   || rts == TYPE_oid
#endif
		   )) {
	        /* ensure use of ATOMput for TYPE_bat */
                bn = cross_@1_int(bn,l,r);
        } else if (rts == TYPE_lng || rts == TYPE_dbl
#if SIZEOF_OID == SIZEOF_LNG 
		   || ATOMstorage(lht) == TYPE_oid
#endif
) {
                bn = cross_@1_lng(bn,l,r);
        } else if (r->tvarsized) {
                bn = cross_@1_VATOM(bn,l,r);
        } else {
                bn = cross_@1_LATOM(bn,l,r);
        }
}
@c
@= cross_switch_lht
{
	int lht = l->htype;
	int lhs = ATOMstorage(lht);
        if (lhs == TYPE_chr) {
                @:cross_switch_rtt(chr)@
        } else if (lhs == TYPE_sht) {
                @:cross_switch_rtt(sht)@
        } else if (lht != TYPE_bat && (lhs == TYPE_int || lhs == TYPE_flt
#if SIZEOF_OID == SIZEOF_INT
		   || lhs == TYPE_oid
#endif
		   )) {
                /* ensure use of ATOMput for TYPE_bat */
                @:cross_switch_rtt(int)@
        } else if (lhs == TYPE_lng || lhs == TYPE_dbl
#if SIZEOF_OID == SIZEOF_LNG
		   || lhs == TYPE_oid
#endif
		   ) {
                @:cross_switch_rtt(lng)@
        } else if (l->hvarsized) {
                @:cross_switch_rtt(VATOM)@
        } else {
                @:cross_switch_rtt(LATOM)@
        }
}
@c
BAT *BATcross(BAT *l, BAT *r) {
	BAT *bn;
	size_t lc, rc, estimate;

        ERRORcheck(l == NULL, "BATcross: invalid left operand");
        ERRORcheck(r == NULL, "BATcross: invalid right operand");
        lc = BATcount(l);
        rc = BATcount(r);
	estimate = lc * rc;

	if (estimate > 0) {
		/* try to keep void columns where possible */
		if (rc == 1)
			return BATconst(l, BATttype(r), BUNtail(r,BUNfirst(r)));
		if (lc == 1)
			return BATmirror(BATconst(BATmirror(r), BAThtype(l), BUNhead(l,BUNfirst(l))));
	}

	@:joinbat(0, 0, estimate)@
	if (estimate == 0)
		return bn;
	
	@:cross_switch_lht@

	if (bn) {
		bn->hsorted = l->hsorted;
		bn->tsorted = (lc==1?r->tsorted:FALSE);
		bn->hdense = (rc==1?l->hdense:FALSE);
		bn->tdense = (lc==1?r->tdense:FALSE);
		BATkey(bn,(rc==1?l->hkey:FALSE));
		BATkey(BATmirror(bn),(lc==1?r->tkey:FALSE));
		if (!bn->batDirty) bn->batDirty = TRUE;
	}

	return bn;
}


@* MultiColumn Join 
@T
Computes the n-ary equijoin over the head columns of multiple BATs.
This function is complex, and uses nested functions calls, 
for the specific stuff, it uses the stack for generating the 
Cartesian product on each hit tuple. Most of all, it emits tuples one 
at a time, in a pipeline rather than bulk fashion. For all these reasons, 
it is not main-memory efficient. It does things that Monet actually 
specifically was designed to avoid.

USE THIS FUNCTION ONLY WHEN YOU REALLY REALLY HAVE TO:
\begin{itemize}
\item
printing a multicolumn table to a watching end-user is one such example
\item
the unoptimized [X](bat,bat,..) MIL multiplex construct is another example
\end{itemize}
The below structures are used for keeping track of the matching process.
@c
typedef struct _column_t {
        BAT*    b;              /* BAT of this column */
        BUN     cur;            /* current BUN in b */
        size_t	nhits;          /* number of matched BUNs */
	Index   idx;		/* binary index tree (b->hidx) */

        /* clustered */
        BUN     lo;             /* first BUN that matches */
        BUN     hi;             /* past last BUN that matches */
        /* nonclustered */
        BUN*	hit;           /* BUN array pointer */
        size_t	hitsize;        /* size of hit array */

	/* properties */
	ssize_t	offset;         /* BUNindex of BUNfirst  */ 
        struct _column_t* sync; /* iff > 0: column with synchronous BAT */
	size_t 	size;           /* size of the BAT */ 
	char 	binsearch;      /* sparse matching expected? */
	char 	ordered;        /* merge matching */
} column_t;

typedef struct {
	RowFcn    tuple_fcn;   /* function to invoke per match */
	ptr       tuple_data;  /* application-specific data */
	ColFcn*   value_fcn;   /* for each col: function to invoke per value */ 
	ptr*      value_data;  /* for each col: application-specific data */
        column_t *c;           /* array of columns */
        int       argc;        /* size of c */
} table_t;

@+ Cartesian product
@T
The matching algorithms tries to construct non-empty matches on all head 
columns. Each time this succeeds, it calls the Cartesian routine to
construct a join result that consists of the Cartesian product of these
matches.

The matching tuples can be encoded in two ways: 
\begin{description}
\item[clustered] here we have two BUN pointers 'hi' and 'lo' that point
to a consecutive range of BUNs in a BAT that match.
\item[nonclustered] here we have a hit pointer that points to an array 
of BUN {\bf pointers} that match.
\end{description}
@c
static void column_result(table_t* t, int i) {
    if (++i > t->argc) {
	/* end of recursion: invoke tuple-match routine */
        t->tuple_fcn(t->tuple_data, t->value_data);
    } else { 
        /* recurse over all matches on this column */
        column_t *c = t->c + (i-1);
	BUN q, *p = c->hit;
        size_t j;

	if (p == NULL) { /* clustered */
	    for(q=c->lo; q<c->hi; q+=BUNsize(c->b)) {
                t->value_fcn[i](t->value_data[i], BUNtail(c->b,q));
                column_result(t, i);
            }
	} else {
	    for(j=0; j<c->nhits; j++, p++) {
                t->value_fcn[i](t->value_data[i], BUNtail(c->b,*p));
                column_result(t, i);
	    }
        }
     }
}

@+ multijoin entry routine
@T
The multijoin will cause a cascade of value\_fcn() calls putting 
values in to place, rounded off each time by a tuple\_fcn() that is
executed on each produced tuple. If this corresponds 1-1 with 
the elements of one of the parameter BAT, the 'result' of the
operation would be aligned with it.

The return value of this operation contains this status information.
It is an integer, of which all 4 bytes are used:
\begin{itemize}
\item ret[0] == 1, if a mergejoin was used, 0 otherwise
\item ret[1] == 1, if all bats had the key property set, 0 otherwise
\item ret[2] == 1 if there was a 1-1 join, 0 otherwise
\item ret[3] == the parameter number of the BAT which was used as leader
\end{itemize}
@c
#define COLSIZE(c)\
	(((c)->b->htype!=TYPE_void || (c)->b->hseqbase!=oid_nil)?(c)->size:0)
#define REALLOCBUNS(c,n) if (c->hitsize <= n)\
	c->hit = (BUN*) GDKrealloc(c->hit, (c->hitsize+=n)*sizeof(BUN))

#define LEAD_INTERRUPT_END  1
#define LEAD_TRAVERSE_SSK   3  /* seq, sorted, key */
#define LEAD_TRAVERSE_SNK   4  /* seq, nonsorted, key */
#define LEAD_TRAVERSE_SEQ   6  /* enforced seq (for order purposes) */
#define LEAD_TRAVERSE_SRT   9  /* traverse by sorted chunk */
#define LEAD_TRAVERSE_IDX   11 /* traverse by binary tree chunks */

int BATmultijoin(
	int 	argc,
	BAT     *argv[],
	RowFcn  tuple_fcn,
	ptr	tuple_data,
	ColFcn  value_fcn[],
	ptr	value_data[],
	int 	orderby)
{
        column_t *lead_col, *c = (column_t*) alloca(argc*(int)sizeof(column_t));
        column_t **reorder = (column_t**) alloca(argc*(int)sizeof(column_t*));
	int	status=0, algo = LEAD_TRAVERSE_SEQ;
	int	i, k;
        BUN     p, q, r;
        table_t t;

@- 
Init the table descriptor.
@c
        memset(c,0,argc*sizeof(column_t));
        t.tuple_data = tuple_data;
        t.value_data = value_data;
        t.tuple_fcn = tuple_fcn;
        t.value_fcn = value_fcn;
        t.argc = argc;
        t.c = c;
@- 
order columns by their size (smallest first)
@c
        for(i=0; i < argc; i++) {
		int j;
		c[i].b = argv[i];
		c[i].nhits = 1; /* default value */
		c[i].offset = (ssize_t) BUNindex(c[i].b, BUNfirst(c[i].b));
		c[i].size = BATcount(c[i].b);

		/* positional lookup possible => ignore other alternatives */
		if (!BAThdense(c[i].b)) { 
			c[i].ordered = BAThordered(c[i].b)&1;
			if (c[i].b->hidx_heap)
				c[i].idx = &c[i].b->hidx;
		}

		/* insertion sort on size */
		for(j=0; j<i; j++) { 
			if (COLSIZE(reorder[j]) > COLSIZE(c+i)) {
				for(k=i; k>j; k--) {
					reorder[k] = reorder[k-1];
				}
				break; 
			}
		}
		reorder[j] = c+i;
        }

@- handle explicit ordering requests
@T
An 'orderby' specification tells that the multijoin should match in the
order of one specific BAT parameter. 

Notice that we *respect* the ordering of the orderby column rather than we 
sort it explicitly (ie; you should order the most significant column beforehand). 
This allows for both for join results ordered on some tail column as results 
ordered on head column, or even 'reverse' or other specific orderings.
One such specific ordering is the SQL ORDER BY multi-column ordering that
can be obtained with the CTorderby command from the xtables module.
@c
	if (orderby) { /* order on tail of some column */
		int lead = orderby - 1;
		for(i=0; i<argc; i++) 	
			if (reorder[i] == c + lead) break;
		while(--i >= 0) {
			reorder[i+1] = reorder[i];
		}
		reorder[0] = c + lead;
	}
	lead_col = reorder[0];

@- lead column traversal mode
@T
The default action is to do LEAD\_TRAVERSE\_SEQ: 1-by-1 traversal of the lead\_col,
and for each head value use the best possible matching algorithm. 
A local optimization is to signal a sorted head column in the lead column, 
so we can switch to LEAD\_TRAVERSE\_SRT; if double lead values occur we do them
in one match iteration. 
Finally, if we are not obliged to follow the current order (lead == 0) and
there is a binary tree present, then we do LEAD\_TRAVERSE\_IDX matching. 

We record in MULTIJOIN\_SORTED(status) whether the chosen traversal method
visits the head values in the lead column in order. This is important 
for the matching algorithms of the other columns (only if the head
values are visited in order, merge algorithms may be employed).
@c
	if (BAThordered(lead_col->b)&1) {
                if (!BAThkey(lead_col->b)) {
			algo = LEAD_TRAVERSE_SRT;
		}
		MULTIJOIN_SORTED(status) = TRUE;
        } else if (!BAThkey(lead_col->b) && lead_col->idx && orderby == 0) {
                algo = LEAD_TRAVERSE_IDX;
		MULTIJOIN_SORTED(status) = TRUE;
        }  
	if (algo == LEAD_TRAVERSE_IDX) {
		lead_col->cur = (BUN) lead_col->idx->first;
		q = (BUN) lead_col->idx->last; 
	} else {
		lead_col->hi = lead_col->cur = BUNfirst(lead_col->b); 
		q = BUNlast(lead_col->b);
		MULTIJOIN_KEY(status) = BAThkey(lead_col->b);
		MULTIJOIN_LEAD(status) = lead_col - c;
		MULTIJOIN_SYNCED(status) = 1;
	}
	if (algo == LEAD_TRAVERSE_SEQ && BAThkey(lead_col->b)) {
		algo = (BAThordered(lead_col->b)&1)?
			LEAD_TRAVERSE_SSK:LEAD_TRAVERSE_SNK;
	}

@- matching algorithms for the other columns
@T
Finally, the issue of choosing matching-algorithms for the other columns
is treated. There are a number of possibilities. If a column is
synced with a previous column, this is registered, so it can copy the 
matching results of that previous column. If not, we use the fact that a
column is ordered and if not, has an binary index on it. Both cases
fall into two sub cases: merge-lookup or binary-search; depending on
whether we visit the head elements in order (MULTIJOIN\_SORTED(status)).
If none of this is the case, we do hash-lookup using an on-the-fly hash-table.
@c
        for(k=1; k < argc; k++) {
		column_t *n = reorder[k];
		int j;
		for(j=(algo==LEAD_TRAVERSE_SEQ); j<k; j++) {
			if (ALIGNsynced(reorder[j]->b, n->b)) {
				n->sync = (struct _column_t*) reorder[j];
				n->offset -= reorder[j]->offset;
                	}
		}
		if (!BAThkey(n->b)) {
			MULTIJOIN_KEY(status) = 0;
			MULTIJOIN_SYNCED(status) = 0;
		}
		if (!MULTIJOIN_SORTED(status)) {
			if (n->size < 4*lead_col->size) {
				n->ordered = FALSE;
			} else {
				n->binsearch = TRUE;
			}
		} else if (n->size > 40*lead_col->size) {
			n->binsearch = TRUE;
		}
		if (n->ordered) {
                	n->cur = BUNfirst(n->b);
            	} else if (n->idx) {
			n->cur = (BUN) n->idx->first;
		} else if (!BAThkey(n->b) && n->sync == NULL) {
			if (BATprepareHash(n->b)) {
				GDKerror("BATmultijoin: could not hash '%s'\n", BBP_logical(n->b->batCacheid));
				return 0;
			}
			n->hitsize = 20;
			n->hit = (BUN*) GDKmalloc(n->hitsize*sizeof(BUN));
		}
	}

@- the matching phase
We optimize in the case that the head-columns are OID. Below
macro's help to separate the two cases cleanly.
@c
#define OIDcmp(v1,v2)	simple_CMP(v1,v2,oid)
#define STDcmp(v1,v2)	(*cmp)(v1,v2)

	if (ATOMstorage(lead_col->b->htype)==ATOMstorage(TYPE_oid)) {
		@:multijoin(hloc,OID,_oid,_oid)@
	} else {
        	int (*cmp)(ptr,ptr) = BATatoms[lead_col->b->htype].atomCmp;
		@:multijoin(head,STD,_any)@
	}
@-
Cleanup & exit.
@c
        for(i=0; i < argc; i++) {
                if (c[i].hitsize) GDKfree(c[i].hit);
        }
        return status;
}

@+ The Matching Algorithm
@T
In multi-column join, all Monet accelerators are put to use when 
equi-lookup is done on a number of head columns.  In order of 
preference, it:

\begin{itemize}
\item does positional lookup on {\em virtual oid} columns (void).
\item reuses lookup info on {\em synced columns}.
\item uses merge scan on {\em ordered columns}.
\item uses binary tree leaf scan on {\em indexed columns}.
\item uses hash lookup in other cases. If a hash-table does not
exist; it is created on the fly.
\end{itemize}

The algorithm goes one by one, for unique head values in the smallest-sized 
BAT. The strategy is for each column to find a range of BUNs that match it. 

The algorithm is intelligent in that it processes the columns in order 
of cardinality. If a column has no matches, you can cut off the matching 
process for the current ID (head value) and go to the next. Smallest BATs 
first means highest miss probability first.

Another optimization is that when a column has a cardinality much larger 
than the smallest column, you can expect sparse matching (e.g. you selected 
1% tuples out of a 1M tuple BAT, and re-joins both with this routine). In 
those cases the merge algorithms use binary search instead of mergescan.

In non-empty matching ranges are found in all head columns, a recursive 
routine is used to go over all combinations of matching BUNs. This recursive 
routine calls for every match (the Cartesian product) a special-purpose 
routine that is passed all matching BUN pointers. This sequence of calls 
represents the result of the multijoin.

Normally you want to perform an action on each value (like formatting or 
copying), but many values reoccur in the same place when the Cartesian product 
over all columns is formed.  For instance, when we have 5 attributes in which 
each has 2 matches on the current id, we have 2*2*2*2*2=32 result tuples for 
this one id. A simple-minded strategy would then do 32*5 value actions, when 
processing these result tuples. This multijoin reduces that to just 32, by 
calling whenever a value is 'changed' in the result-tuple-under-construction,
a value specific function, provided by the user. Since each column can have 
a different value function, this also allows for factoring out type-checking 
overhead.

@= multijoin
while(algo) {
    ptr h; /* points to current ID */
    /*
     * find the next leader bun 
     */ 
    if (algo == LEAD_TRAVERSE_IDX) {
    	if (lead_col->cur >= q) break; 
    	p = *(BUN*) lead_col->cur;
    } else { 
    	p = lead_col->hi;
    	if (p >= q) break; 
    } 
    h = BUNhead(lead_col->b, p);
    
    /* FIND MATCHING COLUMN RANGES
     * For each column, find all matches for this head value
     */
    for(i=0; i<argc; i++) {
    	column_t *m,*n = reorder[i]; /* use BATcount() order */
    	BAT *b = n->b;
    
	/* one-by-one traversal of the lead column? => no matching done.
	 */
	if (n == lead_col) {
		if (argc > 1 && ATOMcmp(b->htype, h, ATOMnilptr(b->htype)) == 0) {
    			n->lo = n->hi = p + BUNsize(b);
			break;
		} else if (algo <= LEAD_TRAVERSE_SEQ) { 
    			n->lo = p;
			n->hi = p + BUNsize(b);
			continue;
		}
	}
	/* Synced lookup
	 * If some BAT is synced with a BAT we already handled ('parent'),
	 * we can simply copy and convert the BUNlists of the parent.
	 */
	if ((m=n->sync) != NULL) {
    		if (m->hit) {
			size_t j;
    			REALLOCBUNS(n, m->nhits);
    			for(j=0; j < m->nhits; j++) {
    				n->hit[j] = BUNptr(n->b, n->offset +
						   BUNindex(m->b,m->hit[j]));
    			}
    			n->nhits = m->nhits;
    		} else {
    			n->lo = BUNptr(n->b, n->offset + BUNindex(m->b,m->lo));
    			n->hi = BUNptr(n->b, n->offset + BUNindex(m->b,m->hi));
    		}
	/* Sorted lookup
	 * We perform a merge scan over the tail column.
	 */
    	} else if (n->ordered) {
    		BUN last = BUNlast(b);
    		int xx = BUNsize(b);

		if (n->binsearch) {
    			n->cur = (BUN) SORTfndfirst@4(BATmirror(b), h);
    			if (n->cur >= last) break; /* NOT FOUND */
    		} else {
    			int yy = 1;
		    	for(; n->cur < last; n->cur += xx) 
    			    if ((yy = @2cmp(BUN@1(b,n->cur),h)) >= 0) 
    				break;
    			if (yy != 0) break; /* NOT FOUND */
		}
    		n->lo = n->cur;
		for(n->nhits=1; (n->cur += xx) < last; n->nhits++) {
    			if (@2cmp(BUN@1(b,n->cur),h))  break;
    		}
		if (n->cur>=last && (algo&LEAD_INTERRUPT_END)) algo = 0; 
    		n->hi = n->cur;
	/* IDX lookup
	 * We perform a merge scan over the binary index
	 */
    	} else if (n->idx) {
    		BUN last = (BUN) n->idx->last;
    		int yy = -1;
    			
    		if (n->binsearch) {
    			n->cur = (BUN) IDXfndfirst@4(b, h);
    			if (n->cur == NULL) break; /* NOT FOUND */
    		} else {
			for(; n->cur < last; n->cur += sizeof(BUN))
    			    if ((yy= @2cmp(BUN@1(b,*(BUN*)n->cur),h)) >= 0)
    				break;
    			if (yy == -1) break; /* NOT FOUND */
    		}
    		n->hit = (BUN*) n->cur;
    		while((n->cur += sizeof(BUN)) < last) {
    			if (@2cmp(BUN@1(b,*(BUN*) n->cur),h)) break;
    		}
		if (n->cur>=last && (algo&LEAD_INTERRUPT_END)) algo = 0; 
    		n->nhits = ((BUN*) n->cur) - n->hit;
    
	/* Single Hash lookup
	 */
    	} else if (BAThkey(n->b)) {
    		BUNfnd@2(n->cur, b, h);
    		if (!n->cur) break; /* NOT FOUND */
    		n->lo = n->cur; 
		n->hi = n->cur + BUNsize(b);
	/* Multiple Hash lookup
	 */
    	} else {
		hash_t j;
    		n->nhits = 0;
    		HASHloop@3(b, b->hhash, j, h, r) {
    			REALLOCBUNS(n, n->nhits+1);
    			n->hit[n->nhits++] = r;
    		}
    		if (n->nhits == 0) break; /* NOT FOUND */
    	}
    }
    /* Recursively print the Cartesian product of all match collections of h.
     */
    if (i >= argc) {
    	t.value_fcn[0](t.value_data[0], h);
    	column_result(&t, 0);
    } else {
	MULTIJOIN_SYNCED(status) = 0; /* a miss occurred somewhere! */
    }
}
if (lead_col->hi < q) {
    MULTIJOIN_SYNCED(status) = 0; /* an interrupt occurred! */ 
}
@}
