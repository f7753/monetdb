@f gdk_relop
@a M. L. Kersten, P. Boncz
@* BAT relational operators
The basic relational operators are implemented for BATs.
Particular attention has been paid to speed-up processing
joins, such that navigational access and object re-assembly
are not being harmed too much.
@h
#ifndef _GDK_RELOP_H
#define _GDK_RELOP_H
#include "gdk.h"

#endif /* _GDK_RELOP_H */
@c
#include "gdk_relop.h"

@{
@+ Join Algorithms

@{
All join related operations have the same prelude to check
domain compatibility and to creates the reseult BAT to hold the result.

@= joincheck
	ERRORcheck(l == NULL, "@1: invalid left operand"); 
	ERRORcheck(r == NULL, "@1: invalid right operand"); 
	ERRORcheck(TYPEerror(@2,@3), "@1: type conflict\n"); 
@= joinbat
	/* TODO: parametrize with estimate */
	bn = BATnew(BAThtype(l), BATttype(r), MIN(BATcount(l), BATcount(r))); 
	if (bn == NULL) {
		return bn; 
	}

@- merge join
In the case that both join columns are ordered, we can do a merging
(@%BATmergejoin@). The merge consists of two cases, one doing a 
full merge scan on both inputs, the other on a full scan and
a binary search.

@= mergejoin
{	BAT *rr = BATmirror(r);
	BUN l_last, r_last;   /* last BUN of the BAT */
	BUN l_start, r_start; /* start of current chunk  */
	BUN l_end, r_end;     /* end of current chunk */
	int r_next = BUNsize(r);
	int l_next = BUNsize(l);
	BUN r_cur;

	l_last = BUNlast(l); 
	r_last = BUNlast(r); 
	l_start = l_end = BUNfirst(l);
	r_start = r_end = BUNfirst(r);

	while(l_start < l_last) {
	    ptr v2, v1 = BUNt@2(l,l_start);
	    int neq = 1;

	    /* lookup range in l */ 
	    if (l->tkey) {
		l_end = l_start + l_next;
	    } else {
	        l_end = l_start;
		do {
		    if ((l_end += l_next) >= l_last) break;  
		    v2 = BUNt@2(l,l_end);
		} while(@1_EQ(v1,v2,@3));
	    }

	    /* lookup value in r */
	    if (!@1_EQ(v1,nil,@3))  {
	    if (sporadic) {
	    	r_start = (BUN) SORTfndfirst_@3(rr, v1); /* use binary search */
		if (r_start >= r_last) {
		    break;
		} else {
	    	    v2 = BUNh@2(r,r_start);
		    neq = !@1_EQ(v1,v2,@3);
	   	}
	    } else if (r_end >= r_last) {
		break;  /* merge while r is already at end */
	    } else {
		do {
	    	    v2 = BUNh@2(r,r_end);
		    neq = @1_CMP(v1,v2,@3);
	    	    if (neq <= 0) break;
		} while((r_end += r_next) < r_last);
	        r_start = r_end;
	    }}
	    if (neq) {
		l_start = l_end; 
		continue;
	    }

	    /* lookup range in r */
	    r_end = r_start + r_next;
	    if (!r->hkey) {
		while (r_end < r_last) {
		    v2 = BUNh@2(r,r_end);
		    if (!@1_EQ(v1,v2,@3)) break;
		    r_end += r_next;
		}
	    }

	    /* generate match-product as join result */
	    for(; l_start < l_end; l_start+=l_next) 
		for(r_cur=r_start; r_cur<r_end; r_cur+=r_next) 
		    BUNfastins(bn, BUNhead(l,l_start), BUNtail(r,r_cur));
	}
} break;
@c
BAT *BATmergejoin(BAT *l, BAT *r) {
	int i, sporadic, logr=0;
	BAT *bn, *reverse = NULL; 
	ptr nil = ATOMnilptr(r->htype);
	
        @:joincheck(BATmergejoin, l->ttype, r->htype)@

	/* cost estimation: full mergejoin vs loop-binsearch
         * full merge = l+r                    
         * binsearch = l + (CONST+logr) CONST=5 
         *(CONST rationale: const 1 binsearch iteration~=5 merge iterations 
         */
	if ((BAThordered(r)&1)==0 || 
	    ((BATtordered(l)&1) && (BATcount(l) > BATcount(r)))) 
	{
		reverse = BATmirror(l); l = BATmirror(r); r = reverse; 
	}
	for(i=BATcount(r); i > 0; logr++) i >>= 1; 
	sporadic = ((BATtordered(l)&1)==0) || (BATcount(l)*4*logr < BATcount(r));

	if (!(BAThordered(r)&1)) {
		GDKerror("BATmergejoin: right input is not sorted.\n"); 
		return NULL; 
	}
	bn = BATnew(BAThtype(l), BATttype(r), MAX(BATTINY, MIN(BATcount(l), BATcount(r)))); 
	if (bn == NULL) {
		return bn; 
	}

	/* the algorithm */
	switch(ATOMstorage(l->ttype)) {
	case TYPE_chr: @:mergejoin(simple,loc,chr)@
	case TYPE_sht: @:mergejoin(simple,loc,sht)@
	case TYPE_int: @:mergejoin(simple,loc,int)@
	case TYPE_flt: @:mergejoin(simple,loc,flt)@
	case TYPE_lng: @:mergejoin(simple,loc,lng)@
	case TYPE_dbl: @:mergejoin(simple,loc,dbl)@
	default: if (l->hvarsized) {
		       int var = ATOMstorage(l->ttype); 	
      		       @:mergejoin(atom,var,var)@
		 } else {
		       int loc = ATOMstorage(l->ttype); 	
      		       @:mergejoin(atom,loc,loc)@
	         }
	}

	/* propagate properties */
	bn->hsorted = bn->tsorted = FALSE;
	if (r->hkey) {
	    bn->hsorted = BAThordered(l);
	    if (l->hkey) BATkey(bn, TRUE);
	    if (BATcount(bn) == BATcount(l)) {
		ALIGNsetH(bn, l);
	    }
	} 
	if (l->tkey) {
	    bn->tsorted = BATtordered(r);
	    if (r->tkey) BATkey(BATmirror(bn), TRUE);
	    if (BATcount(bn) == BATcount(r)) {
		ALIGNsetT(bn, r);
	    }
	}
	return reverse?BATmirror(bn):bn; 
}


@-
These macros encode the core of the join algorithm. They are
the fast innerloops, optimized towards their type.

@= hashjoin
{	int xx, yy;
        BATloopFast(l, p, q, xx) {
                v = BUN@3(l,p);
		if (@1_EQ(v,nil,@2)) {
			continue; /* skip nil */
		}
                HASHloop_@2(r, r->hhash, yy, v, w) {
                        BUNfastins(bn, BUNhead(l,p), BUNtail(r,w));
                }
        }
	/* set sorted flags by hand, because we used BUNfastins() */
	bn->hsorted = BAThordered(l);
        bn->tsorted = FALSE;
        break;
}
@c
BAT* BAThashjoin(BAT* l, BAT* r) {
	ptr	v, nil = ATOMnilptr(r->htype); 
	BUN	p, q, w;
	int	any;
	BAT	*bn;

        @:joincheck(BAThashjoin, l->ttype, r->htype)@
        @:joinbat@

        if (BATprepareHash(r) == 0)
        switch(any = ATOMstorage(l->ttype)) {
        case TYPE_chr: @:hashjoin(simple,chr,tloc)@
        case TYPE_sht: @:hashjoin(simple,sht,tloc)@
        case TYPE_int: 
        case TYPE_flt: @:hashjoin(simple,int,tloc)@
        case TYPE_dbl:
        case TYPE_lng: @:hashjoin(simple,lng,tloc)@
        default:       @:hashjoin(atom,any,tail);
        }

	/* propagate alignment info */
	bn->hsorted = BAThordered(l);
	if (r->hkey) {
		if (BATcount(bn) == BATcount(l)) ALIGNsetH(bn, l);
		if (l->hkey) BATkey(bn, TRUE);
	}
	return bn;
}

@- fetch-join 
@T
The @`BATfetchjoin@5(l,r) does a join on the basis of positional lookup. 
It looks up index numers from the second parameter in first parameter BAT.
The right parameter may contain OIDs, in which case their base is
subtracted. The left may also contain voids, in which case a
OID base is added to the index number.

Implementation starts with specifying the t(tail) = 3rd param of
s = 2nd param to produce the tail column of the result. 
Execution is left top the @#batfetch@ macro, which also handles the 
join case.

Typically, a fetchjoin is done on a large BAT[void,any] that holds a
large collection of values in the tail. If the other join relation  
is a BAT[void,oid] that is smaller. Many times all tail-oids of the latter
will match with a void of the first. In that case, the result can
be expressed as a BAT[void,any] instead of BAT[oid,any]. This is
embodied by the variable 'denseresult', which is the 4th parameter in 
the call macro. 

If denseresult=TRUE, the implementation will try to build a void result;
if there is a miss during the matching, it will start over with 
denseresult=FALSE.

To avoid confusion, please take notice that in order to reuse the code
of the semijoin fetch, we work with a reversed 'b'. Matching is done on
both head columns; the result is formed by both tail columns.

The aftermath -- property setting -- is relatively straightforward here.
@c
BAT* BATfetchjoin(BAT *l, BAT *r) {
        int xx, yy, base, offset, end;
        BUN r_cur, l_cur, l_end;
        BAT *bn;

        BATcheck(l, "BATfetchjoin: l");
        BATcheck(r, "BATfetchjoin: r");
	if (!BAThdense(r)) {
        	ERRORcheck(!BATtdense(l), "BATfetchjoin: one join column must be dense");
		return BATmirror(BATfetchjoin(BATmirror(r),BATmirror(l)));
	}
	base = BUNindex(r, BUNfirst(r)); 
	offset = base - r->hseqbase;
	end = base + BATcount(r);

	/* optimize for propagation of void columns in the result */	
	if (l->tkey && r->hkey && BAThvoid(l)) {
		bn = BATnew(TYPE_void, BATttype(r), BATcount(l));
        	BATloopFast(l, l_cur, l_end, xx) {
                	yy = offset + *(unsigned int*) BUNtail(l,l_cur);
                	if (yy < base || yy >= end) {
				BBPreclaim(bn); 
				goto nondense;
                	}
                	r_cur = BUNptr(r, yy);
			BUNfastins(bn, NULL, BUNtail(r,r_cur));
        	}
		BATseqbase(bn, *(oid*) BUNhead(l,BUNfirst(l))); 
		if (bn->hseqbase != oid_nil) BATkey(bn, TRUE);
		bn->hsorted = GDK_SORTED; 
	} else {
nondense:	bn = BATnew(BAThtype(l), BATttype(r), BATcount(l));
        	BATloopFast(l, l_cur, l_end, xx) {
                	yy = offset + *(unsigned int*) BUNtail(l,l_cur);
                	if (yy < base || yy >= end) {
				continue;
                	}
                	r_cur = BUNptr(r, yy);
			BUNfastins(bn, BUNhead(l,l_cur), BUNtail(r,r_cur));
		}
		bn->hsorted = (BATtordered(l)&BAThordered(r)&1)?BAThordered(l):0;
	}

	/* property propagation */
	bn->hsorted = bn->tsorted = FALSE;
	if (BATcount(bn) == BATcount(l)) {
		ALIGNsetH(bn, l); /* r->hkey, remember? */
	} 
	if (l->tkey) {
		/* if l->tkey elements of r match at most once */
		BATkey(BATmirror(bn), r->tkey);
		if ((BATtordered(l)&1) && BATcount(bn) == BATcount(r)) {
			ALIGNsetT(bn, r);
		}
	}
        return bn;
}

@-
This routine does the join optimization. TODO: it should be expressed in MIL.
@c
BAT *BATjoin(BAT *l, BAT *r) {
        int i, logr, logl, lsize, rsize, lfetch, rfetch, must_hash; 
 
	ERRORcheck(l == NULL, "BATjoin: invalid left operand"); 
	ERRORcheck(r == NULL, "BATjoin: invalid right operand"); 
	ERRORcheck(TYPEerror(l->ttype, r->htype), "BATjoin: type conflict\n"); 
@-
collect statistics that help us decide what to do 
@c
	lsize = l->batBuns->size + (l->hheap.base?l->hheap.size:0) + 
				   (l->theap.base?l->theap.size:0);
	rsize = r->batBuns->size + (r->hheap.base?r->hheap.size:0) + 
				   (r->theap.base?r->theap.size:0);
	for(logr=4, i=BATcount(r); i > 0; logr++) i >>= 1; 
	for(logl=4, i=BATcount(l); i > 0; logl++) i >>= 1; 

	rfetch = (BAThdense(r) && ATOMstorage(l->ttype) <= TYPE_int);
	lfetch = (BATtdense(l) && ATOMstorage(r->htype) <= TYPE_int);

	must_hash = (int) ((rsize < lsize)?l->thash_heap:r->hhash_heap);
@-
In special cases (equal join columns, void join columns, or ordered 
join columns), we take special action.
@c
	if (lfetch && !(rfetch && BATcount(l) < BATcount(r))) {
		return BATfetchjoin(l, r);
	} else if (rfetch) {
		return BATmirror(BATfetchjoin(BATmirror(r), BATmirror(l)));
	}
@-
If both are ordered we do merge-join, or if hash-join is not possible right 
away and one input is ordered and the other is much smaller, we do nested
loop binary search (both implemented by BATmergejoin).
@c
	if ((BATtordered(l)&BAThordered(r)&1) || (must_hash &&
		  (((BATtordered(l)&1) && (BATcount(l) > logl*BATcount(r))) ||
		   ((BAThordered(r)&1) && (BATcount(r) > logr*BATcount(l))))))
	{ 
		return BATmergejoin(l,r);
	}
@-
if hash join is not right away possible and we have a binary tree index,
we do nested loop index lookup join.
@c
	if (must_hash && (l->tidx_heap || r->hidx_heap)) {
		return BATthetajoin(l,r,JOIN_EQ);
	}
@-
hash join: the bread&butter join of monet
@c
	if (rsize < lsize) { /* assume largest fits memory */
		return BATmirror(BAThashjoin(BATmirror(r), BATmirror(l)));
        }
	return BAThashjoin(l,r);
}
@
@}
@+  Outerjoin
The left outerjoin between two BAT is also supported. The code is
identical to the hashjoin algorithm with the extension to insert a BUN
if no match can be found.
@{
@= outerjoinloop
{	ptr	v, nilh = ATOMnilptr(r->htype), nilt = ATOMnilptr(r->ttype); 
	int	xx, yy;
	BUN	p, q, w; 

	BATloopFast(l, p, q, yy) { 
		int i = 0; 
       		v = (ptr) BUNtail(l, p); 
		if (!@1_EQ(v, nilh, @2)) 
	   	HASHloop_@2(r, r->hhash, xx, v, w) { 
			BUNfastins(bn, BUNhead(l, p), BUNtail(r, w));
			i++; 
		}
		if (i == 0) {
       			BUNfastins(bn, BUNhead(l, p), nilt);
       		}
	}
	/* set sorted flags by hand, because we used BUNfastins() */
	bn->hsorted = BAThordered(l);
	bn->tsorted = FALSE;
} break;
@
@-
The baseline join algorithm creates a hash on the smallest element and
probes it using the larger one. [TODO]
@c
BAT *BATouterjoin(BAT *l, BAT *r) {
	int	any; 
	BAT	*bn; 
	
	@:joincheck(BATouterjoin, l->ttype, r->htype)@
 	if (BAThdense(l) && l->tkey && r->hkey) {
		bn = BATnew(TYPE_void, BATttype(r), BATcount(l));
		BATseqbase(bn, l->hseqbase);
	} else {
		@:joinbat@
	} 

	if (BAThdense(r)) {
		/* proceeding with hash on void column would give error and is stupid */
		ptr nilt = ATOMnilptr(r->ttype); 
		BUN p, q, w;
		int yy;
		BATloopFast(l, p, q, yy) { 
       			oid v = *(oid*) BUNtail(l, p); 
			ptr t = nilt;

			if (v != oid_nil) {
				BUNfndVOID(w, r, &v);	 
				if (w) t = BUNtail(r, w);
			}
			BUNfastins(bn, BUNhead(l, p), t);
		}
		/* set sorted flags by hand, because we used BUNfastins() */
		bn->hsorted = BAThordered(l);
		bn->tsorted = BATtdense(l) && BATtordered(r);
		return bn;
	}

	/* propagate alignment info */
	bn->hsorted = BAThordered(l);
	if (BATprepareHash(r)) {
		return(bn); 
	}
	switch(any = ATOMstorage(r->htype)) {
	case TYPE_chr: @:outerjoinloop(simple,chr)@ 
	case TYPE_sht: @:outerjoinloop(simple,sht)@ 
	case TYPE_int: 
	case TYPE_flt: @:outerjoinloop(simple,int)@ 
	case TYPE_dbl: 
	case TYPE_lng: @:outerjoinloop(simple,lng)@
	default:       @:outerjoinloop(atom,any)@
	}
	return bn; 
}
@
@}

@+ ThetaJoin 
Current predicates supported are: JOIN_EQ, JOIN_LT,
JOIN_GE, JOIN_LE and JOIN_GT. The JOIN_EQ will pass the control to the
normal @:BATjoin@ equijoin. The is and index-based join: if an index
is not present, it will be created on the smallest relation.  

We do lots of code-inlining: first of all on join type (4), and
furthermore on left-tail (equal right-head) type (5), which are the
join columns.  We factor out more by splitting on storage strategy
(variable-sized/fixed-size) of both the left-head, and right tail
columns (2*2).

In the end, this results in 4*5*2*2 = 80 different inner loops.

@- 
Thetajoin implementation uses IDXs to compute a thetajoin on two bats.
@{
@= thetaloop
BATloopFast(l, p, q, xx) {
	v = (BUN*) BUNtail(l,p);
	if ((*cmp)(v,nil) == 0) {
	    continue;
	} 
	@1;
	IDXloop(r, lo, hi) { 
	    if (binner) BUNfastins(binner, BUNtail(l,p), BUNhead(r,*lo));
	    if (bouter) BUNfastins(bouter, BUNhead(l,p), BUNtail(r,*lo));
	}
} break;
@c
static void IDXthetajoin(BAT *binner, BAT *bouter, BAT *l, BAT *r, int op) {
	BUN p, q, *lo, *hi, *first = IDXfirst(r), *last = IDXlast(r);
	int (*cmp)(ptr,ptr) = BATatoms[l->ttype].atomCmp;
	ptr v, nil = ATOMnilptr(l->ttype);
	int xx;
	
	/* skip nils */
	while(first <= last && (*cmp)(BUNhead(r,*first),nil) == 0) {
		first++;
	}
       	switch(op) {
       	case JOIN_EQ: @:thetaloop(IDXrng(r,v,v,&lo,&hi))@
       	case JOIN_LE: @:thetaloop(lo=IDXfndfirst(r,v);hi=last)@
       	case JOIN_LT: @:thetaloop(lo=IDXfndlast(r,v);hi=last)@
       	case JOIN_GE: @:thetaloop(lo=first;hi=IDXfndlast(r,v))@
       	case JOIN_GT: @:thetaloop(lo=first;hi=IDXfndfirst(r,v))@
	}
	if (bouter) {
		bouter->hsorted = BAThordered(l); bouter->tsorted = FALSE;
	}
	if (binner) {
		binner->hsorted = BATtordered(l); binner->tsorted = FALSE;
	} 
}

int BATtheta(BAT* inner, BAT* outer, BAT* l, BAT* r, int op) {
	int leftinner = 1;
	
	BATcheck(l, "BATtheta"); 
	BATcheck(r, "BATtheta"); 

	if (TYPEerror(l->ttype, r->htype) ||
	    (inner && (TYPEerror(inner->htype, l->ttype) ||
                       TYPEerror(inner->ttype, r->htype))) ||
	    (outer && (TYPEerror(outer->htype, l->htype) ||
                       TYPEerror(outer->ttype, r->ttype))))
	{
		GDKerror("BATtheta: type unequality\n");
		return 0;
	}

	if (r->hidx_heap || (BAThordered(r)&1)) {
		leftinner = 0;
	} else if (l->tidx_heap || (BATtordered(l)&1)) {
		BATflipflop(l);
		BATflipflop(r);
	} else if (BATcount(l) < BATcount(r)) {
		BATflipflop(l);
		BATflipflop(r);
	} else { 
		leftinner = 0;
	}

	if (leftinner) {
		if (inner) BATflipflop(inner);
		if (outer) BATflipflop(outer);
		if (BATidx(l,0) == 0) return 0;
		IDXthetajoin(inner, outer, r, l, -op);
		if (inner) BATflipflop(inner);
		if (outer) BATflipflop(outer);
		BATflipflop(l);
		BATflipflop(r);
	} else {
		if (BATidx(r,0) == 0) return 0;
		IDXthetajoin(inner, outer, l, r, op);
	}
	return 1;
}

BAT *BATthetajoin(BAT *l, BAT *r, int op) {
	BAT	*bn; 
	
	@:joincheck(BATthetajoin, l->ttype, r->htype)@
	if ((op == JOIN_EQ) && (r->hhash_heap || !r->hidx_heap)) { 
		/* go for the hash solution */
		return BAThashjoin(l, r);
	}
	@:joinbat@
	BATtheta(NULL, bn, l, r, op);
	return bn;
}
@}

@+ Bandjoin
A non-equi join of two relations R and S is called a Band-join if
the join predicate requires the values of R to fall within a given range.
This kind of joins is encountered in real world domains, such as those 
involved with time and distance.

The boundary conditions for the bandjoin are constants or a NULL value.
The latter enables encoding of arbitrary theta joins using the more
general bandjoin.
Incidently note that c1 = c2 = 0 leads to an equi-join.

The straight forward implementation uses a nested loop.
The current implementation does not optimize processing, because
the impact of the choices is not yet clear.

The hash indexing routines have been extended with a Band argument.
@{
@c
BAT *BATbandjoin(BAT *l, BAT *r, ptr c1, ptr c2) {
	BAT *bn; 
	BUN p, q;
	BUN v, w;
	
	@:joincheck(BATbandjoin, l->ttype, r->htype)@
	@:joinbat@
	switch(ATOMstorage(r->htype)) {
	case TYPE_chr: @:bandjoin(chr)@
	case TYPE_sht: @:bandjoin(sht)@
	case TYPE_int: @:bandjoin(int)@
	case TYPE_flt: @:bandjoin(flt)@
	case TYPE_dbl: @:bandjoin(dbl)@ 
	case TYPE_lng: @:bandjoin(lng)@
	default: GDKerror("BATbandjoin: type not implemented\n");
		 return NULL;
	}
	/* set sorted flags by hand, because we used BUNfastins() */
	bn->hsorted = BAThordered(l);
	bn->tsorted = FALSE;

	return bn; 
}
@
@}
@- 
The easiest case is to implement a nested loop for band operations.
Choice point is to determine the status of the NULL values in the final
result.
@{
@= bandjoin
{	int	xx, yy;
	@1	*x1;
	@1	*x2;
 
	BATloopFast(l, p, q, xx) {
		x1 = (@1 *) BUNtloc(l, p); 
		BATloopFast(r, v, w, yy) {
			x2 = (@1 *) BUNhloc(r, v); 
			if ((*x1 >= *x2 -  *(@1 *) c1) && 
			    (*x1 <= *x2 + *(@1 *) c2)) 
			{
				BUNfastins(bn, BUNhead(l,p), BUNtail(r, v)); 
			}
		}
       	}
	break;
}
@
@}
@+ Semijoin 

The @%BATsemijoin@ performs a semijoin over @%l@ and @%r@. It returns
a subset of @%l@ that matches at least one element in @%r@.
The result inherits the integrity properties.

Various algorithms exist. The main one BATkintersect() resides
outside this file, in the set-operations implementation (gdk_setop).
Other variants for the semijoin include the fetch-semijoin
(for dense join columns), the reverse semijoin that loops over r
instead of l, and semijoin using binary search in r.
@{
@= semijoinbat
	bn = BATnew(BAThtype(@1), BATttype(@1), MAX(BATTINY, MIN(BATcount(l), BATcount(r)))); 
	if (bn == NULL) {
		return bn; 
	}
	BATkey(bn, l->hkey);
	BATkey(BATmirror(bn), l->tkey);
	bn->hsorted = @2;
	bn->tsorted = @3;

@- sort semijoin
In the sorted cases with a low semijoin hit-rate, we do lookup using 
probe-based binary search, instead of a full merge scan.
Normal merge-semijoin with a full scan on both is handled by kintersect
(default exit) if both relations are large or if their sizes do not 
differ significantly.

@= binsemijoin
{	BUN lp, lq, rp, rq;
	BAT *rr = BATmirror(r);
	int xx, yy;

	BATloopFast(l, lp, lq, xx) {
		ptr v = BUNh@1(l,lp);
		SORTloop_@2(rr, rp, rq, v, v, yy) {
		     BUNfastins(bn, v, BUNtail(cpy,(cpy==l)?lp:rp));
		}
	} 
} break;
@c
BAT *BATbinsemijoin(BAT *l, BAT *r, BAT *cpy) {
	BAT *bn, *del = NULL;;

	@:joincheck(BATbinsemijoin, l->htype, r->htype)@
	@:semijoinbat(cpy, TRUE,(l == cpy && (BATtordered(l)&1)))@ 

	if (!(BAThordered(r)&1)) {
		del = r = BATsort(r);
	}
	bn->halign = NOID_MULT(l->halign,r->halign);
        bn->talign = NOID_MULT(cpy->talign,r->halign);

	switch(ATOMstorage(l->htype)) {
	case TYPE_chr: @:binsemijoin(loc,chr)@
	case TYPE_sht: @:binsemijoin(loc,sht)@
	case TYPE_int: @:binsemijoin(loc,int)@
	case TYPE_flt: @:binsemijoin(loc,flt)@
	case TYPE_dbl: @:binsemijoin(loc,dbl)@
	case TYPE_lng: @:binsemijoin(loc,lng)@
	default: if (l->hvarsized) {
		       @:binsemijoin(var,var)@
		 } else {
		       @:binsemijoin(loc,loc)@
		 }
	}
	/* propagate properties */
	bn->hsorted = l->hsorted;
	bn->tsorted = 0;
	if (BATcount(bn) == BATcount(l)) {
		if (l == cpy) {
			ALIGNset(bn,l);
		} else if (l->hkey && r->hkey) {
			ALIGNsetH(bn,l);
		}
	}
	if (del) BBPreclaim(del);
	return bn;
} 

@- idx semijoin
similar to binsemijoin, but now using an existing idx accelerator 
for the binary search.

@= idxsemijoin
{	BUN lp, lq, *rp, *rq;
	int xx;

	BATloopFast(l, lp, lq, xx) {
		ptr v = BUNh@1(l,lp);
		IDXrng(r, v, v, &rp, &rq);
		IDXloop(r, rp, rq) {
		     BUNfastins(bn, v, BUNtail(cpy,(cpy==l)?lp:*rp));
		}
	 } 
} break;
@c
BAT *BATidxsemijoin(BAT *l, BAT *r, BAT *cpy) {
	BAT *bn;

	@:joincheck(BATidxsemijoin, l->htype, r->htype)@
	@:semijoinbat(cpy, TRUE,FALSE)@
	if (r->hidx_heap == NULL) {
		BATidx(r, 0);
	}
        bn->halign = NOID_MULT(l->halign,r->halign);
        bn->talign = NOID_MULT(l->talign,r->halign);

	switch(ATOMstorage(l->htype)) {
	case TYPE_chr: @:idxsemijoin(loc,chr)@
	case TYPE_sht: @:idxsemijoin(loc,sht)@
	case TYPE_int: @:idxsemijoin(loc,int)@
	case TYPE_flt: @:idxsemijoin(loc,flt)@
	case TYPE_dbl: @:idxsemijoin(loc,dbl)@
	case TYPE_lng: @:idxsemijoin(loc,lng)@
	default: if (l->hvarsized) {
		       @:idxsemijoin(var,var)@
		 } else {
		       @:idxsemijoin(loc,loc)@
		 }
	}
	/* propagate properties */
	bn->hsorted = l->hsorted;
	bn->tsorted = 0;
	if (BATcount(bn) == BATcount(l)) {
		if (l == cpy) {
			ALIGNset(bn,l);
		} else if (l->hkey && r->hkey) {
			ALIGNsetH(bn,l);
		}
	}
	return bn;
} 

@- reverse semijoin
The semijoin done from the other side. Is only better if the other side (r) is much
smaller than l, and iff you already have the hash table on l. It uses hash tables on
both relations: on r to check that no item is processed twice (not necessary to check 
iff r->hkey) and one on l to find the matching tuples.

@= revsemijoin
{	int xx, yy;
	BUN lp = 0, rp = 0, rq = 0, rr = 0;

	if (merge) {
		BATloopFast(r, rp, rq, xx) {
			ptr v = BUN@3(r,rp);
			rr = rp + xx;
			if (rr < rq && @1_EQ(v,BUN@3(r,rr),@2)) continue;
			HASHloop_@2(l, l->hhash, yy, v, lp)
				BUNfastins(bn, v, BUNtail(l, lp));
		}
	} else if (rdoubles) {
		BATloopFast(r, rp, rq, xx) {
			ptr v = BUN@3(r,rp);
			HASHloop_@2(r, r->hhash, yy, v, rr) break;
			if (rr != rp) continue; 
			HASHloop_@2(l, l->hhash, yy, v, lp)
				BUNfastins(bn, v, BUNtail(l, lp));
		}
	} else {
		BATloopFast(r, rp, rq, xx) {
			ptr v = BUN@3(r,rp);
			HASHloop_@2(l, l->hhash, yy, v, lp)
				BUNfastins(bn, v, BUNtail(l, lp));
		}
	}
} break;
@c
BAT *BATrevsemijoin(BAT *l, BAT *r) {
	int any, rdoubles = (r->hkey == 0), merge = rdoubles&BAThordered(r);
	BAT *bn;

	@:joincheck(BATrevsemijoin, l->htype, r->htype)@
	@:semijoinbat(l, FALSE, FALSE)@
	if (BATprepareHash(l) == 0 && (rdoubles == 0 || BATprepareHash(r) == 0))
	switch(any = ATOMstorage(l->htype)) {
	case TYPE_chr:	@:revsemijoin(simple,chr,hloc)@
	case TYPE_sht:	@:revsemijoin(simple,sht,hloc)@
	case TYPE_int: 
	case TYPE_flt:	@:revsemijoin(simple,int,hloc)@
	case TYPE_dbl: 
	case TYPE_lng:	@:revsemijoin(simple,lng,hloc)@
	default:        @:revsemijoin(atom,any,head);
	}
	/* propagate properties */
	bn->hsorted = bn->tsorted = 0;
	if (r->hkey && l->hkey && BATcount(bn) == BATcount(r)) {
		ALIGNsetH(bn,r);
	}
	return bn;
}

@- positional semijoin 
the below routine performs a semijoin using positional lookup.
This implementation is dirty as it also alows fetches with 
hard integer positions, rather than oid matching on a dense-oid column.
@c
BAT* BATfetchsemijoin(BAT *l, BAT *r, BAT *cpy) {
	int denselookup, base, end, offset, xx, yy;
	BUN l_cur, l_end, r_cur;
        BAT *bn;

	BATcheck(l, "BATfetchsemijoin: l");
	BATcheck(r, "BATfetchsemijoin: r");

	denselookup = (ATOMtype(l->htype) == TYPE_oid);
	if (denselookup && !BAThdense(r)) {
                GDKerror("BATfetchsemijoin: left column must be dense.\n");
                return NULL;
        } else if (ATOMstorage(l->htype) != TYPE_int) {
		GDKerror("BATfetchsemijoin: illegal index type %s.\n", ATOMname(l->htype));
                return NULL;
	}
	if (denselookup && BAThvoid(l)) {
		/* redirect semijoin on two dense regions to a select (and hence to BATslice) */
		oid min = oid_nil, max = oid_nil; 
		BAT *other = (cpy==l)?r:l;
		if (BATcount(other)) {
			min = *(oid*) BUNhead(l, BUNfirst(other));
			max = *(oid*) BUNhead(l, BUNlast(other)-BUNsize(other));
		}
		return BATmirror(BAT_select(BATmirror(cpy), &min, &max, TRUE));
	} 
        base = BUNindex(r, BUNfirst(r));
        end = base + BATcount(r);
        bn = BATnew(BAThtype(cpy), BATttype(cpy), MIN(BATcount(r), BATcount(l)));
        if (bn == NULL) {
                return NULL;
        }
        if (denselookup) {
                offset = base - r->hseqbase; /* translate oid to BUN position */
        } else {
		offset = base; /* fetch by hard BUNindex */
	} 

	/* iterate r; positional fetch in l */
        BATloopFast(l, l_cur, l_end, xx) {
		yy = offset + *(int*) BUNhloc(l,l_cur);
               	if (yy < base || yy >= end) {
			continue;
               	}
		r_cur = BUNptr(r, yy);
		if (cpy == r) {
			BUNfastins(bn, BUNhead(r,r_cur), BUNtail(r,r_cur));
		} else {
			BUNfastins(bn, BUNhead(r,r_cur), BUNtail(l,l_cur));
		}
	}
	
	/* property propagation */
	bn->hsorted = BAThordered(l);
	bn->tsorted = (BAThordered(l)&BAThordered(r)&1)?BATtordered(cpy):0;
        bn->halign = NOID_MULT(r->halign,l->halign);

	if (BATcount(bn) == BATcount(l)) {
		ALIGNsetH(bn, l);
	} else {
		BATkey(bn, l->hkey);
	}
	if (l->hkey) {
		if (BATcount(bn) == BATcount(cpy) && (BAThordered(r)&BAThordered(l)&1)) {
			ALIGNsetT(bn, cpy);
		} else {
			BATkey(BATmirror(bn), cpy->tkey);
		}
	}
        return bn;
}

BAT* BATfetch(BAT *l, BAT *r) {
	return BATfetchsemijoin(r, l, l);
}

@-
The BATsemijoin chooses between various alternatives.  
TODO: this should be moved to MIL.
@c
BAT *BATsemijoin(BAT *l, BAT *r) {
	int reverse1, reverse2, countr, countl, logl, logr, i;
	BAT *bn, *tmp = NULL;
	
	ERRORcheck(l == NULL, "BATsemijoin"); 
	ERRORcheck(r == NULL, "BATsemijoin"); 
	ERRORcheck(TYPEerror(l->htype,r->htype),"BATsemijoin: type conflict\n");

@- algorithm selection
We have 10 algorithms implementing semijoin. Their conditions are checked in order
of efficiency. Some algorithms reverse the semijoin (loop over r, lookup in l).
To do that r should be unique. To that end, doubles may sometimes be eliminated from r.
@c
	for(logr=4, i=countr=BATcount(r); i > 0; logr++) i >>= 1; 
	for(logl=4, i=countl=BATcount(l); i > 0; logl++) i >>= 1; 
	reverse1 = countr < countl && (r->hkey || countr*8 < countl);
	reverse2 = countr*logl < countl && (r->hkey || countr*(logl+8) < countl);

        if (ALIGNsynced(l,r)) {
		bn = BATrcopy(l);	
	} else if ((BAThordered(l)&1) && BAThdense(r)) {
		int lo = r->hseqbase;
                int hi = r->hseqbase + countr - 1;
		bn = BATmirror(BATselect(BATmirror(l), &lo, &hi)); 
	} else if (BAThdense(r)) {
		bn = BATfetchsemijoin(l, r, l);
	} else if (BAThdense(l) && reverse1) {
		if (!r->hkey) {
			BAT *v = VIEWhead_(r,BAT_WRITE); tmp = r = BATkunique(v); BBPreclaim(v);
		}
		bn = BATfetchsemijoin(r, l, l);
	} else if (l->hhash_heap && reverse1) {
		bn = BATrevsemijoin(l,r); 
	} else if ((BAThordered(r)&1) && countl*logr < countr) {
	        bn = BATbinsemijoin(l, r, l);
	} else if ((BAThordered(l)&1) & reverse2) {
		if (!r->hkey) {
			BAT *v = VIEWhead_(r,BAT_WRITE); tmp = r = BATkunique(v); BBPreclaim(v);
		}
		bn = BATbinsemijoin(r, l, l);
	} else if (r->hidx_heap && countl*logr < countr) {
	        bn = BATidxsemijoin(l, r, l);
	} else if (l->hidx_heap && reverse2) {
		if (!r->hkey) {
			BAT *v = VIEWhead_(r,BAT_WRITE); tmp = r = BATkunique(v); BBPreclaim(v);
		}
		bn = BATidxsemijoin(r, l, l);
	} else {
	        bn = BATkintersect(l, r); /* merge-semijoin or nested hashlookup in r */
	}
	if (tmp) {
		BBPreclaim(tmp);
	}
	return bn;
}


@* MultiColumn Join 
@T
Computes the n-ary equijoin over the head columns of multiple BATs.
This function is complex, and uses nested functions calls, 
for the specific stuff, it uses the stack for generating the 
cartesian product on each hit tuple. Most of all, it emits tuples one 
at a time, in a pipeline rather than bulk fashion. For all these reasons, 
it is not main-memory efficient. It does things that Monet actually 
specifically was designed to avoid.

USE THIS FUNCTION ONLY WHEN YOU REALLY REALLY HAVE TO:
\begin{itemize}
\item
printing a multicolumn table to a watching end-user is one such example
\item
the unoptimized [X](bat,bat,..) MIL multiplex construct is another example
\end{itemize}
The below structures are used for keeping track of the matching process.
@c
typedef struct _column_t {
        BAT*    b;              /* BAT of this column */
        BUN     cur;            /* current BUN in b */
        int     nhits;          /* number of matched BUNs */
	Index   idx;		/* binary index tree (b->hidx) */

        /* clustered */
        BUN     lo;             /* first BUN that matches */
        BUN     hi;             /* past last BUN that matches */
        /* nonclustered */
        BUN*	hit;           /* BUN array pointer */
        int     hitsize;        /* size of hit array */

	/* properties */
	int 	offset;         /* BUNindex of BUNfirst  */ 
        struct _column_t* sync; /* iff > 0: column with synchronous BAT */
	int 	size;           /* size of the BAT */ 
	char 	binsearch;      /* sparse matching expected? */
	char 	ordered;        /* merge matching */
} column_t;

typedef struct {
	RowFcn    tuple_fcn;   /* function to invoke per match */
	ptr       tuple_data;  /* application-specific data */
	ColFcn*   value_fcn;   /* for each col: function to invoke per value */ 
	ptr*      value_data;  /* for each col: application-specific data */
        column_t *c;           /* array of columns */
        int       argc;        /* size of c */
} table_t;

@+ carthesian product
@T
The matching algorithms tries to construct non-empty matches on all head 
columns. Each time this succeeds, it calls the cartesian routine to
construct a join result that consists of the cartesian product of these
matches.

The maching tuples can be encoded in two ways: 
\begin{description}
\item[clustered] here we have two BUN pointers 'hi' and 'lo' that point
to a consecutive range of BUNs in a BAT that match.
\item[nonclustered] here we have a hit pointer that points to an array 
of BUN {\bf pointers} that match.
\end{description}
@c
static void column_result(table_t* t, int i) {
    if (++i > t->argc) {
	/* end of recursion: invoke tuple-match routine */
        t->tuple_fcn(t->tuple_data, t->value_data);
    } else { 
        /* recurse over all matches on this column */
        column_t *c = t->c + (i-1);
	BUN q, *p = c->hit;
        int j;

	if (p == NULL) { /* clustered */
	    for(q=c->lo; q<c->hi; q+=BUNsize(c->b)) {
                t->value_fcn[i](t->value_data[i], BUNtail(c->b,q));
                column_result(t, i);
            }
	} else {
	    for(j=0; j<c->nhits; j++, p++) {
                t->value_fcn[i](t->value_data[i], BUNtail(c->b,*p));
                column_result(t, i);
	    }
        }
     }
}

@+ multijoin entry routine
@T
The multijoin will cause a cascade of value_fcn() calls putting 
values in to place, rounded off each time by a tuple_fcn() that is
executed on each produced tuple. If this corresponds 1-1 with 
the elements of one of the parameter BAT, the 'result' of the
operation would be aligned with it.

The return value of this operation contains this status information.
It is an integer, of which all 4 bytes are used:
\begin{itemize}
\item ret[0] == 1, if a mergejoin was used, 0 otherwise
\item ret[1] == 1, if all bats had the key property set, 0 otherwise
\item ret[2] == 1 if there was a 1-1 join, 0 otherwise
\item ret[3] == the parameter number of the BAT which was used as leader
\end{itemize}
@c
#define COLSIZE(c)\
	(((c)->b->htype!=TYPE_void || (c)->b->hseqbase!=oid_nil)?(c)->size:0)
#define REALLOCBUNS(c,n) if (c->hitsize <= n)\
	c->hit = (BUN*) GDKrealloc((int*)c->hit, (c->hitsize+=n)*sizeof(BUN))

#define LEAD_INTERRUPT_NIL   1
#define LEAD_INTERRUPT_END   3
#define LEAD_TRAVERSE_SSK    3  /* seq, sorted, key */
#define LEAD_TRAVERSE_SNK   13  /* seq, nonsorted, key */
#define LEAD_TRAVERSE_SEQ   14  /* enforced seq (for order purposes) */
#define LEAD_TRAVERSE_SRT   15  /* traverse by sorted chunk */
#define LEAD_TRAVERSE_IDX   16  /* traverse by binary tree chunks */

int BATmultijoin(
	int 	argc,
	BAT     *argv[],
	RowFcn  tuple_fcn,
	ptr	tuple_data,
	ColFcn  value_fcn[],
	ptr	value_data[],
	int 	orderby)
{
        column_t *lead_col, *c = (column_t*) alloca(argc*sizeof(column_t));
        column_t **reorder = (column_t**) alloca(argc*sizeof(column_t*));
	int	status=0, algo = LEAD_TRAVERSE_SEQ;
	int	i, k, j=0;
        BUN     p, q, r;
        table_t t;

@- 
Init the table descriptor.
@c
        memset(c,0,argc*sizeof(column_t));
        t.tuple_data = tuple_data;
        t.value_data = value_data;
        t.tuple_fcn = tuple_fcn;
        t.value_fcn = value_fcn;
        t.argc = argc;
        t.c = c;
@- 
order columns by their size (smallest first)
@c
        for(i=0; i < argc; i++) {
		c[i].b = argv[i];
		c[i].nhits = 1; /* default value */
		c[i].offset = BUNindex(c[i].b, BUNfirst(c[i].b));
		c[i].size = BATcount(c[i].b);

		/* positional lookup possible => ignore other alternatives */
		if (!BAThdense(c[i].b)) { 
			c[i].ordered = BAThordered(c[i].b)&1;
			if (c[i].b->hidx_heap)
				c[i].idx = &c[i].b->hidx;
		}

		/* insertion sort on size */
		for(j=0; j<i; j++) { 
			if (COLSIZE(reorder[j]) > COLSIZE(c+i)) {
				for(k=i; k>j; k--) {
					reorder[k] = reorder[k-1];
				} break; 
			}
		} reorder[j] = c+i;
        }

@- handle explicit ordering requests
@T
Ad 'orderby' specification tells that the multijoin should match in the
order of one specific BAT parameter. 

Notice that we *respect* the ordering of the orderby column rather than we 
sort it explicitly (ie; you should order the most significant column beforehand). 
This allows for both for join results ordered on some tail column as results 
ordered on head column, or even 'reverse' or other specific orderings.
One such specific ordering is the SQL ORDER BY multi-column ordering that
can be obtained with the CTorderby command from the xtables module.
@c
	if (orderby) { /* order on tail of some column */
		int lead = orderby - 1;
		for(i=0; i<argc; i++) 	
			if (reorder[i] == c + lead) break;
		while(--i >= 0) {
			reorder[i+1] = reorder[i];
		}
		reorder[0] = c + lead;
	}
	lead_col = reorder[0];

@- lead column traversal mode
@T
The default action is to do LEAD_TRAVERSE_SEQ: 1-by-1 traversal of the lead_col,
and for each head value use the best possible matching algorithm. 
A local optimization is to signal a sorted head column in the lead column, 
so we can switch to LEAD_TRAVERSE_SRT; if double lead values occur we do them
in one match iteration. 
Finally, if we are not obliged to follow the current order (lead == 0) and
there is a binary tree present, then we do LEAD_TRAVERSE_IDX matching. 

We record in MULTIJOIN_SORTED(status) whether the chosen traversal method
visits the head values in the lead column in order. This is important 
for the matching algorithms of the other columns (only if the head
values are visited in order, merge algorithms may be employed).
@c
	if (BAThordered(lead_col->b)&1) {
                if (lead_col->b->hkey == FALSE) {
			algo = LEAD_TRAVERSE_SRT;
		}
		MULTIJOIN_SORTED(status) = TRUE;
        } else if (lead_col->b->hkey == FALSE && lead_col->idx && orderby == 0) {
                algo = LEAD_TRAVERSE_IDX;
		MULTIJOIN_SORTED(status) = TRUE;
        }  
	if (algo == LEAD_TRAVERSE_IDX) {
		lead_col->cur = (BUN) lead_col->idx->first;
		q = (BUN) lead_col->idx->last; 
	} else {
		lead_col->hi = lead_col->cur = BUNfirst(lead_col->b); 
		q = BUNlast(lead_col->b);
		MULTIJOIN_KEY(status) = lead_col->b->hkey;
		MULTIJOIN_LEAD(status) = lead_col - c;
		MULTIJOIN_SYNCED(status) = 1;
	}
	if (algo == LEAD_TRAVERSE_SEQ && lead_col->b->hkey) {
		algo = (BAThordered(lead_col->b)&1)?
			LEAD_TRAVERSE_SSK:LEAD_TRAVERSE_SNK;
	}

@- matching algorithms for the other columns
@T
Finally, the issue of choosing matching-algorithms for the other columns
is treated. There are a number of possibilities. If a column is
synced with a previous column, this is registered, so it can copy the 
matching results of that previous column. If not, we use the fact that a
column is ordered and if not, has an binary index on it. Both cases
fall into two subcases: merge-lookup or binary-search; depending on
whether we visit the head elements in order (MULTIJOIN_SORTED(status)).
If none of this is the case, we do hash-lookup using an on-the-fly hash-table.
@c
        for(k=1; k < argc; k++) {
		column_t *n = reorder[k];
		for(j=(algo==LEAD_TRAVERSE_SEQ); j<k; j++) {
			if (ALIGNsynced(reorder[j]->b, n->b)) {
				n->sync = (struct _column_t*) reorder[j];
				n->offset -= reorder[j]->offset;
                	}
		}
		if (!c->b->hkey) {
			MULTIJOIN_KEY(status) = 0;
			MULTIJOIN_SYNCED(status) = 0;
		}
		if (!MULTIJOIN_SORTED(status)) {
			if (n->size < 4*lead_col->size) {
				n->ordered = FALSE;
			} else {
				n->binsearch = TRUE;
			}
		} else if (n->size > 40*lead_col->size) {
			n->binsearch = TRUE;
		}
		if (n->ordered) {
                	n->cur = BUNfirst(n->b);
            	} else if (n->idx) {
			n->cur = (BUN) n->idx->first;
		} else if (n->b->hkey == 0 && n->sync == NULL) {
    			(void) BATprepareHash(n->b);
			n->hitsize = 20;
			n->hit = (BUN*) GDKmalloc(n->hitsize*sizeof(BUN));
		}
	}

@- the matching phase
We optimize in the case that the head-columns are OID. Below
macro's help to separate the two cases cleanly.
@c
#define OIDcmp(v1,v2)	simple_CMP(v1,v2,oid)
#define STDcmp(v1,v2)	(*cmp)(v1,v2)

	if (ATOMstorage(ATOMtype(lead_col->b->htype))==ATOMstorage(TYPE_oid)) {
		@:multijoin(hloc,OID,_oid,_oid)@
	} else {
        	int (*cmp)(ptr,ptr) = BATatoms[lead_col->b->htype].atomCmp;
		@:multijoin(head,STD,_any)@
	}
@-
Cleanup & exit.
@c
        for(i=0; i < argc; i++) {
                if (c[i].hitsize) GDKfree(c[i].hit);
        }
        return status;
}

@+ The Matching Algorithm
@T
In multi-column join, all Monet accellerators are put to use when 
equi-lookup is done on a number of head columns.  In order of 
preference, it:

\begin{itemize}
\item does positional lookup on {\em virtual oid} columns (void).
\item reuses lookup info on {\em synced columns}.
\item uses merge scan on {\em ordered columns}.
\item uses binary tree leaf scan on {\em indexed columns}.
\item uses hash lookup in other cases. If a hash-table does not
exist; it is created on the fly.
\end{itemize}

The algorithm goes one by one, for unique head values in the smallest-sized 
BAT. The strategy is for each column to find a range of BUNs that match it. 

The algorithm is intelligent in that it processes the columns in order 
of cardinality. If a column has no matches, you can cut off the matching 
process for the current ID (head value) and go to the next. Smallest BATs 
first means highest miss probability first.

Another optimization is that when a column has a cardinality much larger 
than the smallest column, you can expect sparse matching (e.g. you selected 
1% tuples out of a 1M tuple BAT, and re-joins both with this routine). In 
those cases the merge algorithms use binary search instead of mergescan.

In non-empty matching ranges are found in all head columns, a recursive 
routine is used to go over all combinations of matching BUNs. This recursive 
routine calls for every match (the cartesian product) a special-purpose 
routine that is passed all matching BUN pointers. This sequence of calls 
represents the result of the multijoin.

Normally you want to perform an action on each value (like formatting or 
copying), but many values reoccur in the same place when the cartesian product 
over all columns is formed.  For instance, when we have 5 attributes in which 
each has 2 matches on the current id, we have 2*2*2*2*2=32 result tuples for 
this one id. A simple-minded strategy would then do 32*5 value actions, when 
processing these result tuples. This multijoin reduces that to just 32, by 
calling whenever a value is 'changed' in the result-tuple-under-construction,
a value specific function, provided by the user. Since each column can have 
a different value function, this also allows for factoring out type-checking 
overhead.

@= multijoin
while(algo) {
    ptr h; /* points to current ID */
    /*
     * find the next leader bun 
     */ 
    if (algo == LEAD_TRAVERSE_IDX) {
    	if (lead_col->cur >= q) break; 
    	p = *(BUN*) lead_col->cur;
    } else { 
    	p = lead_col->hi;
    	if (p >= q) break; 
    } 
    h = BUNhead(lead_col->b, p);
    
    /* FIND MATCHING COLUMN RANGES
     * For each column, find all matches for this head value
     */
    for(i=0; i<argc; i++) {
    	column_t *m,*n = reorder[i]; /* use BATcount() order */
    	BAT *b = n->b;
    
	/* one-by-one traversal of the lead column? => no matching done.
	 */
	if (n == lead_col && algo <= LEAD_TRAVERSE_SEQ) { 
		n->lo = p;
    		n->hi = p + BUNsize(b);
		continue;
	}
	/* Synced lookup
	 * If some BAT is synced with a BAT we already handled ('parent'),
	 * we can simply copy and convert the BUNlists of the parent.
	 */
	if ((m=n->sync) != NULL) {
    		if (m->hit) {
    			REALLOCBUNS(n, m->nhits);
    			for(j=0; j < m->nhits; j++) {
    				n->hit[j] = BUNptr(n->b, n->offset +
						   BUNindex(m->b,m->hit[j]));
    			}
    			n->nhits = m->nhits;
    		} else {
    			n->lo = BUNptr(n->b, n->offset + BUNindex(m->b,m->lo));
    			n->hi = BUNptr(n->b, n->offset + BUNindex(m->b,m->hi));
    		}
	/* Sorted lookup
	 * We perform a merge scan over the tail column.
	 */
    	} else if (n->ordered) {
    		BUN last = BUNlast(b);
    		int xx = BUNsize(b);

	        if (b->htype == TYPE_void) { /* special case: all nil column */
			if (algo&LEAD_INTERRUPT_NIL) algo = 0;
			if (*(oid*) h != oid_nil) break; /* NOT FOUND */
			n->lo = BUNfirst(b); n->nhits = n->size; 
			n->hi = last; continue;
	        } else if (n->binsearch) {
    			n->cur = (BUN) SORTfnd@4(b, h);
    			if (n->cur == NULL) break; /* NOT FOUND */
    		} else {
    			int yy = 1;
		    	for(; n->cur < last; n->cur += xx) 
    			    if ((yy = @2cmp(BUN@1(b,n->cur),h)) >= 0) 
    				break;
    			if (yy != 0) break; /* NOT FOUND */
		}
    		n->lo = n->cur;
		for(n->nhits=1; (n->cur += xx) < last; n->nhits++) {
    			if (@2cmp(BUN@1(b,n->cur),h))  break;
    		}
		if (n->cur>=last && (algo&LEAD_INTERRUPT_END)) algo = 0; 
    		n->hi = n->cur;
	/* IDX lookup
	 * We perform a merge scan over the binary index
	 */
    	} else if (n->idx) {
    		BUN last = (BUN) n->idx->last;
    		int yy = -1;
    			
    		if (n->binsearch) {
    			n->cur = (BUN) IDXfnd@4(b, h);
    			if (n->cur == NULL) break; /* NOT FOUND */
    		} else {
			for(; n->cur < last; n->cur += sizeof(BUN))
    			    if ((yy= @2cmp(BUN@1(b,*(BUN*)n->cur),h)) >= 0)
    				break;
    			if (yy == -1) break; /* NOT FOUND */
    		}
    		n->hit = (BUN*) n->cur;
    		while((n->cur += sizeof(BUN)) < last) {
    			if (@2cmp(BUN@1(b,*(BUN*) n->cur),h)) break;
    		}
		if (n->cur>=last && (algo&LEAD_INTERRUPT_END)) algo = 0; 
    		n->nhits = ((BUN*) n->cur) - n->hit;
    
	/* Single Hash lookup
	 */
    	} else if (n->b->hkey) {
    		BUNfnd@2(n->cur, b, h);
    		if (!n->cur) break; /* NOT FOUND */
    		n->lo = n->cur; 
		n->hi = n->cur + BUNsize(b);
	/* Multiple Hash lookup
	 */
    	} else {
    		n->nhits = 0;
    		HASHloop@3(b, b->hhash, j, h, r) {
    			REALLOCBUNS(n, n->nhits+1);
    			n->hit[n->nhits++] = r;
    		}
    		if (n->nhits == 0) break; /* NOT FOUND */
    	}
    }
    /* Recursively print the carthesian product of all match collections of h.
     */
    if (i >= argc) {
    	t.value_fcn[0](t.value_data[0], h);
    	column_result(&t, 0);
    } else {
	MULTIJOIN_SYNCED(status) = 0; /* a miss occurred somewhere! */
    }
}
if (lead_col->hi < q) {
    MULTIJOIN_SYNCED(status) = 0; /* an interrupt occurred! */ 
}
@}
