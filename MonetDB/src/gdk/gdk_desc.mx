@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2005 CWI.
@' All Rights Reserved.

@f gdk_desc
@a Peter Boncz
@v 1.0
@+ BAT Descriptor Versions
Changes to the BAT descriptors cause problems, as persistent
BATs with older descriptor versions may still be around. BAT versions
are marked in the first field of a BAT. We only recognize the current BAT
format, all older versions are discarded (please use dump/restore).

To solve networking problems we can convert between little-endian and 
big-endian formats. This problem is resolved using a lazy approach.
Intel saves BATs in different format than Sun, but when one loads the other,
they do on-the-fly conversions using the new routine @%BATconvert@.
This routine uses little/big-endian conversion functionality newly
introduced to the atom ADT (atomConvert and atomHeapConvert).
@h
#ifndef _GDK_DESC_H_
#define _GDK_DESC_H_
@+ BAT versions
Three BAT formats are currently supported:
@h
#define GDKLIBRARY	050410	/* 64-bits BAT */

#define GDKversionOK(x)	((x)==GDKLIBRARY)

@
If BATs need to be added to an old BBP directory, we might need
to save BATs in the old format. This is currently controlled
by the below function:
@
We also use these numbers, which are always the first 32-int the
BAT image, to check whether the image is in big endian or little endian format.
@{
@c
#include "gdk.h"

@+ BAT Conversion functions
These functions save/load a BAT descriptor to/from disk.
@h
int BATsavedesc(BAT *b, str nme);
BAT *BATloaddesc(str nme);

@
Convert a BAT that contains little-endian data into big endian (or vice versa).
@h
gdk_export BAT *BATconvert(BAT *b, int direction);


@- defines
@h
@{
typedef unsigned int normal_int;

#define strcpy_COPY(x,y)	strcpy(x,y);
#define short_int_COPY(x)	x
#define normal_int_COPY(x)	x
#define normal_bat_COPY(x)	x
#define long_long_COPY(x)	x
#define normal_oid_COPY(x)	x
#define normal_sizet_COPY(x)	x
#define normal_hasht_COPY(x)	x
#define normal_BUN_COPY(x)	x

#define strcpy_SWAP(x,y)
#define normal_bat_SWAP(x)	((bat) normal_int_SWAP((int) x))
#if SIZEOF_OID == SIZEOF_INT
#define normal_oid_SWAP(x)	((oid) normal_int_SWAP((int)x))
#else
#define normal_oid_SWAP(x)	((oid) long_long_SWAP((lng)x))
#endif
#if SIZEOF_SIZE_T == SIZEOF_INT
#define normal_sizet_SWAP(x)	((size_t) normal_int_SWAP((int)x))
#define normal_vart_SWAP(x)	((var_t) normal_int_SWAP((int)x))
#define normal_hasht_SWAP(x)	((hash_t) normal_int_SWAP((int)x))
#define normal_BUN_SWAP(x)	((BUN) normal_int_SWAP((int)x))
#else
#define normal_sizet_SWAP(x)	((size_t) long_long_SWAP((lng)x))
#define normal_vart_SWAP(x)	((var_t) long_long_SWAP((lng)x))
#define normal_hasht_SWAP(x)	((hash_t) long_long_SWAP((lng)x))
#define normal_BUN_SWAP(x)	((BUN) long_long_SWAP((lng)x))
#endif

#endif /* _GDK_DESC_H_ */
@}

@+ implementations
@- BATsavedesc
@c
int
BATsavedesc(BAT *b, str nme)
{
	BATstore *bs = (BATstore *) b;
	int ret = 0;

	DELTAsave(b);
	if (b->GDKversion == GDKLIBRARY) {
		ret = GDKsave(nme, "desc", (void *) bs, sizeof(BATstore), STORE_MEM);
	}
	/* a saved bat could still be used so reset the delta status */
	DELTAload(b);
	return (ret < 0) ? ret : 0;
}

@- BATloaddesc
@c
BAT *
BATloaddesc(str nme)
{
	BATstore *src = (BATstore *) GDKload(nme, "desc", sizeof(BATstore),
					     sizeof(BATstore), STORE_MEM);
	BATstore *dst = src;
	int ver;
	BAT *b;

	if (src == NULL) {
		return NULL;
	}
	ver = src->B.GDKversion;
	if (!GDKversionOK(ver)) {
		GDKerror("GDKload: incompatible version %d.\n", src->B.GDKversion);
		GDKfree(src);
		return NULL;
	}
	b = (BAT *) dst;
	b->H = &dst->H;
	b->T = &dst->T;
	b->P = &dst->P;
	b->U = &dst->U;
	b->batBuns = &b->U->buns;
	b->batBuns->base = NULL;
	b->batBuns->filename = NULL;
	b->H->heap.base = NULL;
	b->T->heap.base = NULL;
	b->batId = dst->fullid;
	b->batCopiedtodisk = 1;
	b->batElmshift = BATelmshift(b);
	b->H->props = NULL;
	b->T->props = NULL;
	return b;
}

@}
@- big endian vs little endian
This function uses the byte order conversion ADT functions
to convert a little endian BAT to big endian (or vice versa).
@{
@= swap
	{
		@2 *_p = (@2*) @3, _i=*_p;
		*_p = @1_SWAP(_i);
	}
@c
static int
batswap(BAT *b, int direction)
{
	void (*fcn) (ptr, int) = BATatoms[b->htype].atomConvert;
	BUN p, q;
	int xx;

	switch (ATOMstorage(b->htype)) {
	case TYPE_void:
	case TYPE_chr:
		break;
	case TYPE_sht:
		DELloop(b, p, q, xx) @:swap(short_int,sht,BUNhloc(b,p))@
		BATloopFast(b, p, q, xx) @:swap(short_int,sht,BUNhloc(b,p))@

		break;
	case TYPE_int:
	case TYPE_flt:
		DELloop(b, p, q, xx) @:swap(normal_int,int,BUNhloc(b,p))@
		BATloopFast(b, p, q, xx) @:swap(normal_int,int,BUNhloc(b,p))@

		break;
	case TYPE_lng:
	case TYPE_dbl:
		DELloop(b, p, q, xx) @:swap(long_long,lng,BUNhloc(b,p))@
		BATloopFast(b, p, q, xx) @:swap(long_long,lng,BUNhloc(b,p))@

		break;
	default:
		ATOMheapConvert(b->htype, &b->hheap, direction);
		DELloop(b, p, q, xx) {
			@:swap(normal_int,int,BUNhloc(b,p))@

			if (fcn != NULL)
				(*fcn) (BUNhead(b, p), direction);
		}
		BATloopFast(b, p, q, xx) {
			@:swap(normal_int,int,BUNhloc(b,p))@

			if (fcn != NULL)
				(*fcn) (BUNhead(b, p), direction);
		}
	}
	return TRUE;
}

BAT *
BATconvert(BAT *b, int direction)
{
	if (batswap(b, direction)) {
		if (!batswap(BATmirror(b), direction)) {
			batswap(b, direction == CONV_HTON ? CONV_NTOH : CONV_HTON);
		}
	}
	b->batDirty = 1;
	return b;
}

@}
