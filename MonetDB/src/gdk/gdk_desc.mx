@f gdk_desc
@t BAT Descriptor Versions
@a Peter Boncz
@v 1.0
@* Introduction
Changes to the BAT descriptors cause problems as persistent
BATs with older descriptor versions may be still around. BAT versions
are marked in the first field of a BAT. Apart from the current BAT
format, we keep recognizing two historic formats.

Changes in the BAT image are not only introduced by developers, 
but also by different systems. Two factors are of incluence:
32- or 64-bits operating systems, and little-endian or big-endian
hardware. Both issues are resolved by code in this file.

The 32- vs 64-bits issue is resolved by saving the 32
bits image. 64-bits versions swizzle this when they get
loaded and saved.

The little-endian and big endian problem is resolved using a lazy approach.
Intel saves BATs in different format than Sun, but when one loads the other, 
they do on-the-fly conversions using the new routine @%BATconvert@. 
This routine uses little/big endian conversion functionality newly
introduced to the atom ADT (atomConvert and atomHeapConvert).
@h
#ifndef _GDK_DESC_H_
#define _GDK_DESC_H_
#include "gdk.h"

@+ BAT versions
Three BAT formats are currently supported:
@h
#define GDKLIBRARY	980714 /* new 64-bits BAT */

#define GDKversionOK(x)	((x)==GDKLIBRARY)

/*
extern char GDKlegalversions[1024];
*/
@
If BATs need to be added to an old BBP directory, we might need
to save BATs in the old format. This is currently controlled 
by the below function:  
@
We also use these numbers, which are always the first 32-int the 
BAT image, to check whether the image is in big endian or little endian format.
@c
#include "gdk_desc.h"

@+ BAT Conversion functions
These functions save/load a BAT descriptor to/from disk.
@h
int  strHeapOldHash (BAT *b);
int  strHeapHash    (BAT *b);

int  BATsavedesc    (BAT *b, str nme);
BAT *BATloaddesc    (str nme);
@
Convert a BAT that contains little endian data into big endian (or vice versa).
@h
extern BAT* BATconvert     (BAT *b);


@- defines
@h
@{
typedef unsigned int normal_int;
typedef size_t long_int;

#define strcpy_COPY(x,y)	strcpy(x,y);
#define short_int_COPY(x)	x
#define normal_int_COPY(x)	x
#define long_int_COPY(x)	x

#define strcpy_SWAP(x,y)	
#define short_int_SWAP(x)	(((0x00ff&(x))<<8) | ((0xff00&(x))>>8))
#define normal_int_SWAP(x)	(((0x000000ff&(x))<<24) |\
				 ((0x0000ff00&(x))<<8)  |\
               		         ((0x00ff0000&(x))>>8)  |\
				 ((0xff000000&(x))>>24))

#define long_long_SWAP(x)	((normal_int_SWAP(x)<<32)|\
				 (0xFFFFFFFF&normal_int_SWAP(x>>32)))

#if SIZEOF_LONG==8
#define long_int_SWAP(x)	long_long_SWAP(x)
#else
#define long_int_SWAP(x)	normal_int_SWAP(x)
#endif

#endif /* _GDK_DESC_H_ */
@}


@- 64 vs 32 BIT conversion
The current BAT descriptor structures now work with full 64 bits 
pointers, directly in the format. We still support loading and saving
of old BATs that use the 32-bit format(s). The old definitions
are below (in a shortened format). We have macros that copy all
relevant fields from a (new) 64-bit BAT structure to an (old) 32-bits
BAT, and vice versa.
@c
#if SIZEOF_LONG==8
#undef _GDK_H_
#define BAT32IMAGE
#include "gdk.h"
#undef BAT32IMAGE
#endif

@= Hash_ALL
                  (@2)->type = normal_int_@6(((@4))->type);
                   (@2)->lim = normal_int_@6(((@4))->lim);
                  (@2)->mask = normal_int_@6(((@4))->mask);
        *(@1*) (&(@2)->hash) = (@1) (*(@3*) (&((@4))->hash))?-1:0;
        *(@1*) (&(@2)->link) = (@1) (*(@3*) (&((@4))->link))?-1:0;

@= IDX_ALL
         *((@1*) (&(@2)->root)) = (@1) (*((@3*) (&(@4)->root)))?-1:0;
        *((@1*) (&(@2)->stack)) = (@1) (*((@3*) (&(@4)->stack)))?-1:0;
         *((@1*) (&(@2)->free)) = (@1) (*((@3*) (&(@4)->free))?-1:0);
         *((@1*) (&(@2)->base)) = (@1) (*((@3*) (&(@4)->base)))?-1:0;
        *((@1*) (&(@2)->first)) = (@1) (*((@3*) (&(@4)->first)))?-1:0;
         *((@1*) (&(@2)->last)) = (@1) (*((@3*) (&(@4)->last)))?-1:0;

@= Heap_ALL
                  (@2)->offset = normal_int_@6(((@4))->offset);
                 (@2)->maxsize = normal_int_@6(((@4))->maxsize);
                    (@2)->free = normal_int_@6(((@4))->free);
                    (@2)->size = normal_int_@6(((@4))->size);
                 (@2)->storage = normal_int_@6(((@4))->storage);
        *((@1*) (&(@2)->base)) = (@1) (*((@3*) (&(@4)->base)))?-1:0;
    *((@1*) (&(@2)->filename)) = (@1) (*((@3*) (&(@4)->filename)))?-1:0;

@= BUNrec_ALL
        @:Heap_@5(@1,&(@2)->buns,@3,&(@4)->buns,@5,@6)@
         *((@1*) (&(@2)->deleted)) = long_int_@6(*((@3*) (&(@4)->deleted)));
            *((@1*) (&(@2)->hole)) = long_int_@6(*((@3*) (&(@4)->hole)));
        *((@1*) (&(@2)->inserted)) = long_int_@6(*((@3*) (&(@4)->inserted)));
                    (@2)->sharecnt = normal_int_@6((@4)->sharecnt);

@= COLrec_ALL
        strcpy_@6((@2)->id,(@4)->id)
        strcpy_@6((@2)->atom,(@4)->atom)
        strcpy_@6((@2)->accname,(@4)->accname)
        @:Heap_@5(@1,&(@2)->heap,@3,&(@4)->heap,@5,@6)@
        @:Hash_@5(@1,&(@2)->hash,@3,&(@4)->hash,@5,@6)@
        @:IDX_@5(@1,(&(@2)->idx),@3,(&(@4)->idx),@5,@6)@
        @:Heap_@5(@1,&(@2)->accelerator,@3,&(@4)->accelerator,@5,@6)@
           (@2)->heapdirty = (@4)->heapdirty;
            (@2)->accdirty = (@4)->accdirty;
             (@2)->acctype = short_int_@6((@4)->acctype);
              (@2)->sorted = (@4)->sorted;
               (@2)->align = normal_int_@6((@4)->align);
        (@2)->alignflushed = normal_int_@6((@4)->alignflushed);
            (@2)->nokey[0] = normal_int_@6((@4)->nokey[0]);
            (@2)->nokey[1] = normal_int_@6((@4)->nokey[1]);
            (@2)->nosorted = normal_int_@6((@4)->nosorted);
             (@2)->nodense = normal_int_@6((@4)->nodense);
               (@2)->dense = (@4)->dense;
     (@2)->accCopiedtodisk = (@4)->accCopiedtodisk;

@= Dimensions_ALL
             (@2).headtype = short_int_@6((@4).headtype);
             (@2).tailtype = short_int_@6((@4).tailtype);
              (@2).headloc = normal_int_@6((@4).headloc);
              (@2).tailloc = normal_int_@6((@4).tailloc);
              (@2).headkey = (@4).headkey;
              (@2).tailkey = (@4).tailkey;
         (@2).headvarsized = (@4).headvarsized;
         (@2).tailvarsized = (@4).tailvarsized;
             (@2).bunshift = short_int_@6((@4).bunshift);
             (@2).bunwidth = short_int_@6((@4).bunwidth);
	(@2).hseq = normal_int_@6((@4).hseq);
	(@2).tseq = normal_int_@6((@4).tseq);

@= BAT_ALL
	(@2)->GDKversion = normal_int_@6((@4)->GDKversion);
	(@2)->batCacheid = normal_int_@6((@4)->batCacheid);
	@:Dimensions_@5(@1,(@2)->dims,@3,(@4)->dims,@5,@6)@

@= BATrec_ALL
        strcpy_@6((@2)->id,(@4)->id)
        (@2)->dirtyflushed = (@4)->dirtyflushed;
        (@2)->copiedtodisk = (@4)->copiedtodisk;
               (@2)->stamp = normal_int_@6((@4)->stamp);
         (@2)->persistence = short_int_@6((@4)->persistence);
                 (@2)->set = short_int_@6((@4)->set);
          (@2)->restricted = short_int_@6((@4)->restricted);
            (@2)->lastused = normal_int_@6((@4)->lastused);
               (@2)->dirty = (@4)->dirty;
           (@2)->descdirty = (@4)->descdirty;
           (@2)->bunsdirty = (@4)->bunsdirty;
            (@2)->parentid = normal_int_@6((@4)->parentid);

@= BATstore_ALL
	@:BAT_@5(@1,&(@2)->B,@3,&(@4)->B,@5,@6)@
	@:COLrec_@5(@1,&(@2)->H,@3,&(@4)->H,@5,@6)@
	@:COLrec_@5(@1,&(@2)->T,@3,&(@4)->T,@5,@6)@
	@:BATrec_@5(@1,&(@2)->P,@3,&(@4)->P,@5,@6)@
	@:BUNrec_@5(@1,&(@2)->U,@3,&(@4)->U,@5,@6)@
	strcpy_@6((@2)->fullid,@4->fullid)	

@- misc remappings
Absolute pointers need to be mapped to byte offsets when a BAT is saved.
That is where the DELTA macros are for.

@+ implementations
@- BATsavedesc 
@c
int BATsavedesc(BAT *b, str nme) {
	BATstore *bs = (BATstore*) b;
        int ret = 0;

	DELTAsave(b);

@- restrictions on what can be saved
Ptr cause a problem when trying to share a repository between 32 and 64 bits systems. As
pointers should be transient objects anyway, we do not allow them to be saved.

Bat values (meaning recursive bats) have specific restrictions. At system startup, all
recursive bats *must* be loaded to check and count their references. At that point; no 
user-defined types are loaded. Hence we prohibit recursive bats to be saved, if they
have an extension type in their other column.
@c
	if (b->htype == TYPE_ptr) {
		b->htype = ATOMstorage(TYPE_ptr);
		GDKwarning("BATsave(%s): convert ptr-htype (transient type) to %s.", 
			b->batId, ATOMname(b->htype)); 
	} else if (b->htype == TYPE_bat && b->ttype > TYPE_str) {
		b->htype = TYPE_int;
		GDKwarning("BATsave(%s): convert bat-htype (cannot be used with %s ttype) to int.", 
			b->batId, ATOMname(b->ttype)); 
	}
	if (b->ttype == TYPE_ptr) {
		b->ttype = ATOMstorage(TYPE_ptr);
		GDKwarning("BATsave(%s): convert ptr-htype (transient type) to %s.", 
			b->batId, ATOMname(b->ttype)); 
	} else if (b->ttype == TYPE_bat && b->htype > TYPE_str) {
		b->ttype = TYPE_int;
		GDKwarning("BATsave(%s): convert bat-htype (cannot be used with %s ttype) to int.", 
			b->batId, ATOMname(b->htype)); 
	}
	if (b->ttype == TYPE_bat || b->htype == TYPE_bat) {
		b->hacctype = b->tacctype = 0;
	}
	if (b->GDKversion == GDKLIBRARY) {
#if SIZEOF_LONG==8
		BATstore_32IMAGE buf, *src= &buf;

		@:BATstore_ALL(normal_int,src,long_int,bs,ALL,COPY)@
#else
		BATstore *src = bs;
#endif
		ret = GDKsave(nme, "desc", (str)src, (int) sizeof(*src),STORE_MEM);
        }
	return ret;
}

@- BATloaddesc 
@c
BAT* BATloaddesc(str nme) {
#if SIZEOF_LONG==8
        BATstore_32IMAGE *src = (BATstore_32IMAGE *) 
#else
        BATstore *src = (BATstore *) 
#endif
		GDKload(nme, "desc", (int) sizeof(BATstore), 
				(int) sizeof(BATstore), 256|STORE_MEM);
        BATstore *dst = (BATstore*) src;
	int ver, conv=FALSE;
	BAT *b;

	if (src == NULL) {
                return NULL;
        }
	ver = *(int*) src;
        if (!GDKversionOK(ver)) {
		ver = normal_int_SWAP(ver);
		conv = TRUE;
	} 
        if (!GDKversionOK(ver)) {
		GDKerror("GDKload: incompatible version %d.\n", *(int*) src);
		GDKfree(src);
		conv = FALSE;
                return NULL;
        }
#if SIZEOF_LONG==8
	  else {
		dst = (BATstore*) GDKmalloc(sizeof(BATstore));
		if (conv) {
			@:BATstore_ALL(long_int,dst,long_int,src,ALL,SWAP)@
		} else {
			@:BATstore_ALL(long_int,dst,normal_int,src,ALL,COPY)@
		}
		GDKfree(src);
	}
#else
	if (conv) {
		@:BATstore_ALL(long_int,dst,long_int,dst,ALL,SWAP)@
	}
#endif
	b = (BAT*) dst;
        b->H = &dst->H;
        b->T = &dst->T;
        b->P = &dst->P;
        b->U = &dst->U;
        b->batBuns = &b->U->buns;
	b->batId = dst->fullid;
	b->batDirtyflushed = b->batDirty?TRUE:FALSE;
	b->batCopiedtodisk = 1;
        b->batElmshift = BATelmshift(b);
	b->batConvert = conv;
	DELTAload(b);

        return b;
}

@- big endian vs little endian
This function uses the byte order conversion ADT functions
to convert a little endian BAT to big endian (or vice versa).
@= swap
{ @2 *_p = (@2*) @3, _i=*_p; *_p = @1_SWAP(_i); }
@c
static int batswap(BAT* b){
	void (*fcn)() = BATatoms[b->htype].atomConvert;
        BUN p,q; 
	int xx;
 
	switch(ATOMstorage(b->htype)) {
	case TYPE_void:
	case TYPE_chr: 
		break;
	case TYPE_sht: 
		DELloop(b,p,q,xx)     @:swap(short_int,sht,BUNhloc(b,p))@
		BATloopFast(b,p,q,xx) @:swap(short_int,sht,BUNhloc(b,p))@
		break;
	case TYPE_int: 
	case TYPE_flt: 
		DELloop(b,p,q,xx)     @:swap(normal_int,int,BUNhloc(b,p))@
		BATloopFast(b,p,q,xx) @:swap(normal_int,int,BUNhloc(b,p))@
		break;
	case TYPE_lng: 
	case TYPE_dbl: 
		DELloop(b,p,q,xx)     @:swap(long_int,lng,BUNhloc(b,p))@
		BATloopFast(b,p,q,xx) @:swap(long_int,lng,BUNhloc(b,p))@
		break;
	default:ATOMheapConvert(b->htype,&b->hheap);
		DELloop(b,p,q,xx) {
			@:swap(normal_int,int,BUNhloc(b,p))@
     			if (fcn != NULL) (*fcn)(BUNhead(b,p));
		}
	        BATloopFast(b,p,q,xx) {
			@:swap(normal_int,int,BUNhloc(b,p))@
     			if (fcn != NULL) (*fcn)(BUNhead(b,p));
		}
	}
	return TRUE;
}

BAT* BATconvert(BAT* b){
	if (batswap(b)) {
		if (!batswap(BATmirror(b))) {
			batswap(b);
		}
	}
	b->batDirty = 1;
	return b;
}
