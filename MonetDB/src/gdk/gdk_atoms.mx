@f gdk_atoms
@a M. L. Kersten, P. Boncz
@* Atomic types
The Binary Association Table library assumes efficient implementation of
the atoms making up the binary association.
This section describes the preliminaries for handling
both built-in and user-defined atomic types. 
New types, such as point and polygons, can be readily added to this
collection.
@h
#ifndef _GDK_ATOMS_H_
#define _GDK_ATOMS_H_
#include "gdk.h"
 
#define MAXATOMS	1024

@- comparsion macro's
In order to get maximum performance, we extensively use out-factoring
of typechecks using Mx macros. To catch diverging code in one Mx macro
we use the following #defines for comparing atoms:
@h
#define simple_CMP(x,y,tpe)     (simple_LT(x,y,tpe)?-1:simple_GT(x,y,tpe))
#define simple_EQ(x,y,tpe)      ((*(tpe*) (x)) == (*(tpe*) (y)))
#define simple_LT(x,y,tpe)      ((*(tpe*) (x))  < (*(tpe*) (y)))
#define simple_GT(x,y,tpe)      ((*(tpe*) (x))  > (*(tpe*) (y)))
#define simple_LE(x,y,tpe)      ((*(tpe*) (x)) <= (*(tpe*) (y)))
#define simple_GE(x,y,tpe)      ((*(tpe*) (x)) >= (*(tpe*) (y)))
#define atom_CMP(x,y,id)        (*BATatoms[id].atomCmp)(x,y)
#define atom_EQ(x,y,id)         ((*BATatoms[id].atomCmp)(x,y) == 0)
#define atom_LT(x,y,id)         ((*BATatoms[id].atomCmp)(x,y) < 0)
#define atom_GT(x,y,id)         ((*BATatoms[id].atomCmp)(x,y) > 0)
#define atom_LE(x,y,id)         ((*BATatoms[id].atomCmp)(x,y) <= 0)
#define atom_GE(x,y,id)         ((*BATatoms[id].atomCmp)(x,y) >= 0)
#define simple_HASH(v,tpe,dst)  ((dst) *(tpe *) (v))
#define atom_HASH(v,id,dst)     ((dst) (*BATatoms[id].atomHash)(v))

@- maximum atomic string lengths
@h
#define bitStrlen	8
#define chrStrlen	8
#define shtStrlen	12
#define intStrlen	24
#define oidStrlen	24
#define ptrStrlen	24
#define lngStrlen	48
#define fltStrlen	48
#define dblStrlen	96

@- 
The system comes with the traditional atomic types: int (4 bytes), bool(1 
byte) and str (variable). In addition, we support the notion of an OID 
type, which ensures uniques of its members.
This leads to the following type descriptor table.
@{
@h

#ifdef __cplusplus
extern "C" {
#endif
int		voidFromStr    (str  src, int* len, void** dst);
int		voidToStr      (str* dst, int* len, void* src);

int		lngFromStr     (str  src, int* len, lng** dst);
int		lngToStr       (str* dst, int* len, lng*  src);
int		lngCmp         (lng* r, lng* l);
void 		lngConvert     (lng* s);
unsigned int 	lngHash        (lng *l);

int		intFromStr     (str  src, int* len, int** dst);
int		intToStr       (str* dst, int* len, int*  src);
int		intCmp         (int* r, int* l);
void 		intConvert     (int* s);
unsigned int 	intHash        (int *i);

int		batFromStr     (str  src, int* len, bat** dst);
int		batToStr       (str* dst, int* len, bat*  src);

int		ptrFromStr     (str  src, int* len, ptr** dst);
int		ptrToStr       (str* dst, int* len, ptr*  src);

int		bitFromStr     (str  src, int* len, bit** dst);
int		bitToStr       (str* dst, int* len, bit*  src);

int		OIDfromStr     (str  src, int* len, oid** dst);
int		OIDtoStr       (str* dst, int* len, oid*  src);

int		shtFromStr     (str  src, int* len, sht** dst);
int		shtToStr       (str* dst, int* len, sht*  src);
void 		shtConvert     (sht* s);
int		shtCmp         (sht* r, sht* l);
unsigned int	shtHash        (sht *s);

int		chrFromStr     (str  src, int* len, chr** dst);
int		chrToStr       (str* dst, int* len, chr*  src);
int		chrCmp         (chr* r, chr* l);
unsigned int 	chrHash        (chr *c);

int		fltFromStr     (str  src, int* len, flt** dst);
int		fltToStr       (str* dst, int* len, flt*  src);
int		fltCmp         (flt* r, flt* l);

int		dblFromStr     (str  src, int* len, dbl** dst);
int		dblToStr       (str* dst, int* len, dbl*  src);
int		dblCmp         (dbl* r, dbl* l);

int		strFromStr     (str  src, int* len, str*  dst);
int		strToStr       (str* dst, int* len, str   src);
unsigned int 	strHash        (str s); 
int		strGet         (Heap* b, int *off, int *len, str *dst);
int		strPut         (Heap* b, int *off, str src);
void 		strHeap        (Heap* d, int cap);
int		strLen         (str s);
int		strCmp         (str r, str l);
int		strNil         (str s);
void 		strHeapConvert (Heap *h);
int		strElimDoubles (Heap *h);
int 		strLocate      (Heap *h, str v);
int		strHeapCheck   (Heap *h, HeapRepair *hr);

extern Heap	str_smallHeap;

#ifdef __cplusplus
}
#endif

@- inline comparison routines
Return 0 on l==r, < 0 iff l < r, >0 iff l > r  
@c
#include "gdk_atoms.h"
#include "gdk_bat.h"
#include "gdk_desc.h"

int chrCmp(chr* l, chr* r) { return simple_CMP(l,r,chr); }
int shtCmp(sht* l, sht* r) { return simple_CMP(l,r,sht); }
int intCmp(int* l, int* r) { return simple_CMP(l,r,int); }
int fltCmp(flt* l, flt* r) { return simple_CMP(l,r,flt); }
int lngCmp(lng* l, lng* r) { return simple_CMP(l,r,lng); }
int dblCmp(dbl* l, dbl* r) { return simple_CMP(l,r,dbl); }

@- inline hash routines
Return some positive integer derived from one atom value.
@c
unsigned int chrHash(chr *v) { return *(unsigned char*) v; }
unsigned int shtHash(sht *v) { return mix_sht(*(unsigned short*) v); }
unsigned int intHash(int *v) { return mix_int(*(unsigned int*) v); }
unsigned int lngHash(lng *v) { return mix_int(((unsigned int*) v)[0]^((unsigned int*) v)[1]); }

@+ Standard Atoms
@c
INLINE void shtConvert(sht* s) { *s = short_int_SWAP(*s); }
INLINE void intConvert(int* s) { *s = normal_int_SWAP(*s); }
INLINE void lngConvert(lng* s) { *s = long_long_SWAP(*s); }
INLINE int  batFix(bat* b)     { return BBPfix(*b); }
INLINE int  batUnfix(bat* b)   { return BBPunfix(*b); }

atomDesc BATatoms[MAXATOMS] = {
  { "void",  	TYPE_void, 1, 0, /* sizeof(@`void@7) */ 0, 1, (ptr) &int_nil, NULL,
		(int  (*)()) OIDfromStr,	(int (*)()) OIDtoStr,
 		(int  (*)()) intCmp,		
 		(unsigned int (*)()) intHash, 	(void (*)()) 0,
 		(int  (*)()) 0,			(int  (*)()) 0,
 		(void (*)()) 0,			(void (*)()) 0,
 		(int (*)()) 0,			(int  (*)()) 0,
 		(void (*)()) 0,			(int  (*)()) 0},			
  { "bit",  	TYPE_chr, 1, sizeof(bit), sizeof(@`bit@7), 0, (ptr) &chr_nil, NULL,				
		(int  (*)()) bitFromStr,	(int (*)()) bitToStr,
 		(int  (*)()) chrCmp,		
 		(unsigned int  (*)()) chrHash,	(void (*)()) 0,		
		(int  (*)()) 0, 		(int  (*)()) 0,
		(void (*)()) 0,			(void (*)()) 0,
 		(int (*)()) 0,			(int  (*)()) 0,
 		(void (*)()) 0,			(int  (*)()) 0},
  { "chr",  	TYPE_chr, 1, sizeof(chr), sizeof(@`chr@7), 0, (ptr) &chr_nil, NULL,
		(int  (*)()) @`chrFromStr@5,	(int (*)()) @`chrToStr@5,
	 	(int  (*)()) chrCmp,		
 		(unsigned int  (*)()) chrHash,	(void (*)()) 0,		
		(int  (*)()) 0, 		(int  (*)()) 0,
		(void (*)()) 0,			(void (*)()) 0,
 		(int (*)()) 0,			(int  (*)()) 0,
 		(void (*)()) 0,			(int  (*)()) 0},
  { "sht",	TYPE_sht, 1, sizeof(sht), sizeof(@`sht@7), 0, (ptr) &sht_nil, NULL,
		(int  (*)()) @`shtFromStr@5,	(int (*)()) @`shtToStr@5,
 		(int  (*)()) shtCmp,		
 		(unsigned int  (*)()) shtHash, 	(void (*)()) shtConvert,
		(int  (*)()) 0, 		(int  (*)()) 0,
		(void (*)()) 0,			(void (*)()) 0,
 		(int (*)()) 0,			(int  (*)()) 0,
 		(void (*)()) 0,			(int  (*)()) 0},
  { "BAT",  	TYPE_int, 1, sizeof(bat), sizeof(@`bat@7), 0, (ptr) &int_nil, NULL,
 		(int  (*)()) batFromStr,	(int (*)()) batToStr,
 		(int  (*)()) intCmp, 		
 		(unsigned int  (*)()) intHash,	(void (*)()) intConvert,
		(int  (*)()) batFix,		(int  (*)()) batUnfix,
 		(void (*)()) 0,			(void (*)()) 0,
 		(int (*)()) 0,			(int  (*)()) 0,
 		(void (*)()) 0,			(int  (*)()) 0},
  { "int",  	TYPE_int, 1, sizeof(int), sizeof(@`int@7), 0, (ptr) &int_nil, NULL,
		(int  (*)()) intFromStr,	(int (*)()) @`intToStr@5,
	 	(int  (*)()) intCmp,		
 		(unsigned int  (*)()) intHash, 	(void (*)()) intConvert,
		(int  (*)()) 0, 		(int  (*)()) 0,
 		(void (*)()) 0, 		(void (*)()) 0,
 		(int (*)()) 0,			(int  (*)()) 0,
 		(void (*)()) 0,			(int  (*)()) 0},
  { "oid",  	TYPE_int, 1, sizeof(oid), sizeof(@`oid@7), 0, (ptr) &int_nil, NULL,
 		(int  (*)()) OIDfromStr,	(int (*)()) OIDtoStr,
 		(int  (*)()) intCmp,		
 		(unsigned int  (*)()) intHash,	(void (*)()) intConvert,
		(int  (*)()) 0, 		(int  (*)()) 0,
 		(void (*)()) 0,			(void (*)()) 0,
 		(int (*)()) 0,			(int  (*)()) 0,
 		(void (*)()) 0,			(int  (*)()) 0},
#if SIZEOF_LONG==8
  { "ptr",  	TYPE_lng, 1, sizeof(ptr), sizeof(@`ptr@7), 0, (ptr) &lng_nil, NULL,
		(int  (*)()) @`ptrFromStr@5,	(int (*)()) @`ptrToStr@5,
	 	(int  (*)()) lngCmp,		
		(unsigned int  (*)()) lngHash,	(void (*)()) lngConvert,		
#else
  { "ptr",  	TYPE_int, 1, sizeof(ptr), sizeof(@`ptr@7), 0, (ptr) &int_nil, NULL,
		(int  (*)()) @`ptrFromStr@5,	(int (*)()) @`ptrToStr@5,
	 	(int  (*)()) intCmp,		
		(unsigned int  (*)()) intHash,	(void (*)()) intConvert,			
#endif
		(int  (*)()) 0, 		(int  (*)()) 0,
		(void (*)()) 0, 		(void (*)()) 0,
 		(int (*)()) 0,			(int  (*)()) 0,
 		(void (*)()) 0,			(int  (*)()) 0},
  { "flt",  	TYPE_flt, 1, sizeof(flt), sizeof(@`flt@7), 0, (ptr) &flt_nil, NULL,
		(int  (*)()) @`fltFromStr@5,	(int (*)()) @`fltToStr@5,
	 	(int  (*)()) fltCmp,		
 		(unsigned int  (*)()) intHash, 	(void (*)()) intConvert,
		(int  (*)()) 0,			(int  (*)()) 0,
 		(void (*)()) 0,			(void (*)()) 0,
 		(int (*)()) 0,			(int  (*)()) 0,
 		(void (*)()) 0,			(int  (*)()) 0},
  { "dbl",  	TYPE_dbl, 1, sizeof(dbl), sizeof(@`dbl@7), 0, (ptr) &dbl_nil, NULL,
		(int  (*)()) @`dblFromStr@5,	(int (*)()) @`dblToStr@5,
		(int  (*)()) dblCmp,		
 		(unsigned int  (*)()) lngHash, 	(void (*)()) lngConvert,
		(int  (*)()) 0,			(int  (*)()) 0,
 		(void (*)()) 0,			(void (*)()) 0,
 		(int (*)()) 0,			(int  (*)()) 0,
 		(void (*)()) 0,			(int  (*)()) 0},
  { "lng",  	TYPE_lng, 1, sizeof(lng), sizeof(@`lng@7), 0, (ptr) &lng_nil, NULL,
		(int  (*)()) lngFromStr,	(int (*)()) lngToStr,
 		(int  (*)()) lngCmp,		
 		(unsigned int  (*)()) lngHash,	(void (*)()) lngConvert,
		(int  (*)()) 0,			(int  (*)()) 0,
 		(void (*)()) 0,			(void (*)()) 0,
 		(int (*)()) 0,			(int  (*)()) 0,
 		(void (*)()) 0,			(int  (*)()) 0},
  { "str",  	TYPE_str, 1, sizeof(int), sizeof(int), 1, (ptr) &chr_nil, &str_smallHeap,			
		(int  (*)()) strFromStr,	(int (*)()) strToStr,
		(int  (*)()) strCmp,		
	    	(unsigned int  (*)()) strHash,	(void (*)()) 0,
		(int  (*)()) 0, 		(int  (*)()) 0,
 		(void (*)()) strPut,		(void (*)()) 0,
 		(int (*)()) strLen,		(int (*)()) strHeap,
 		(void (*)()) strHeapConvert,	(int  (*)()) strHeapCheck} ,
};
int     GDKatomcnt = TYPE_str + 1;
@
@}
@+ Atomic Type Interface
The collection of built-in types supported for BATs can be extended easily.
In essence, the user should specify conversion routines from values stored
anywhere in memory to its equivalent in the BAT, and vice verse.
Some routines are required for coercion and to support the BAT
administration.

A new type is incrementally build using the 
routine @%ATOMproperty(id, propery, value)@.
The parameter @%id@ denotes the type name; an entry is created if the type
is so far unknown. The @%property@ argument is a string identifying the
type description property to be updated. Valid property
names are @%size, tostr, fromstr, put, get, cmp, eq, del, hash, null@,
@%new, and heap@.

The size describes the amount of space to be reserved in the BUN.

The routine @%put@ takes a pointer to a memory resident copy and prepares
a persistent copy in the BAT passed. 
The inverse operation is @%get@. 
A new value can be directly included into the BAT using @%new@, which should
prepare a null-value representation.
A value is removed from the BAT
store using @%del@, which can take care of garbage collection and 
BAT administration. 

The pair @%tostr@ and @%fromstr@ should convert a reference to a persistent
value to a memory resident string equivalent. @%FromStr@ takes a 
string and applies a @%put@ to store it within a BAT. 
They are used to prepare for readable output/input and to support coercion.

The routines @%cmp@ and @%eq@ are comparisons routines used to build access 
structures. The @%null@ returns a reference to a null value representation.
@- 
The incremental atom construction uses hardwired properties.
This should be improved later on.
@c
void ATOMdelete(int id) {
	if (BATatoms[id].storage == id && BATatoms[id].smallHeap) {
		GDKfree(BATatoms[id].smallHeap);
		HEAPfree(BATatoms[id].smallHeap);
	}
	memset(BATatoms+id, 0, sizeof(atomDesc));
	if (id == GDKatomcnt-1) GDKatomcnt--;
}

int align(int n) {
        if (n==0) return 0;
        if ((n%8)==0) return 8;
        if ((n%4)==0) return 4;
        if ((n%2)==0) return 2;
        return 1;
}

void ATOMproperty(str id, str property, int (*arg) ()) {
	int t;
	MT_set_lock(GDKthreadLock, "ATOMproperty");
	t = ATOMindex(id); 
	if (t < 0) {
	    t = -t;
	    if (t == GDKatomcnt) {
		GDKatomcnt++; 
	    }
	    FATALcheck(GDKatomcnt==MAXATOMS, "ATOMproperty:too many types");
	    FATALcheck(strlen(id)>=IDLENGTH, "ATOMproperty:name too long");
	    memset(BATatoms+t, 0, sizeof(atomDesc));
	    strcpy(BATatoms[t].name, id); 
	    BATatoms[t].size = sizeof(int); /* default */
	    BATatoms[t].align = sizeof(int); /* default */
	    BATatoms[t].linear = 1; /* default */
	    BATatoms[t].storage = t;  /* default */
	}
	if (strcmp("size", property) == 0) {
	    if ((int) arg) {
		BATatoms[t].size = (int) arg; 
		BATatoms[t].varsized = 0; 
		BATatoms[t].align = align((int) arg); 
	    } else { 
		BATatoms[t].size = sizeof(int); 
		BATatoms[t].varsized = 1; 
		BATatoms[t].align = sizeof(int); 
	    } 
	} else if (strcmp("linear", property) == 0) {
		BATatoms[t].linear = (int) arg; 
	} else if (strcmp("align", property) == 0) {
		BATatoms[t].align = (int) arg; 
	} else if (strcmp("storage", property) == 0) {
	    	BATatoms[t] = BATatoms[(int) arg]; /* copy from example */
	    	strcpy(BATatoms[t].name, id); /* restore name */ 
	} else if (strcmp("fromstr", property) == 0) {
		BATatoms[t].atomFromStr = (int (*)()) arg; 
	} else if (strcmp("tostr", property) == 0) {
		BATatoms[t].atomToStr = (int (*)()) arg; 
	} else if (strcmp("fix", property) == 0) {
		BATatoms[t].atomFix = (int (*)()) arg; 
	} else if (strcmp("unfix", property) == 0) {
		BATatoms[t].atomUnfix = (int (*)()) arg; 
	} else {
#define atomset(dst,val) oldval = (ptr) dst; if (val == NULL || dst == val) goto out; dst = val;
  	    ptr oldval = NULL;

	    if (strcmp("heap", property) == 0) {
		BATatoms[t].varsized = 1;
		atomset(BATatoms[t].atomHeap, (int (*)()) arg); 
		if (BATatoms[t].smallHeap) {
			HEAPfree(BATatoms[t].smallHeap);
			GDKfree(BATatoms[t].smallHeap);
		}
		if (BATatoms[t].atomHeap) {
			BATatoms[t].smallHeap = (Heap*) GDKmalloc(sizeof(Heap));
		 	(*BATatoms[t].atomHeap)(BATatoms[t].smallHeap,1);
		}
	    } else if (strcmp("heapconvert", property) == 0) {
		atomset(BATatoms[t].atomHeapConvert, (void (*)()) arg); 
	    } else if (strcmp("check", property) == 0) {
		atomset(BATatoms[t].atomHeapCheck, (int (*)()) arg); 
	    } else if (strcmp("del", property) == 0) {
		atomset(BATatoms[t].atomDel, (void (*)()) arg); 
	    } else if (strcmp("convert", property) == 0) {
		atomset(BATatoms[t].atomConvert, (void (*)()) arg); 
	    } else if (strcmp("put", property) == 0) {
		atomset(BATatoms[t].atomPut, (void (*)()) arg); 
	    }
	    if (oldval) goto out; 

	    /* these ADT functions *must* be equal for overloaded types */
	    if (strcmp("cmp", property) == 0) {
		atomset(BATatoms[t].atomCmp, (int (*)()) arg); 
	    } else if (strcmp("null", property) == 0) {
		atomset(BATatoms[t].atomNull, (ptr) (*arg)()); 
	    } else if (strcmp("hash", property) == 0) {
		atomset(BATatoms[t].atomHash, (unsigned int (*)()) arg); 
	    } else if (strcmp("length", property) == 0) {
		atomset(BATatoms[t].atomLen, (int (*)()) arg); 
	    }
/*
    if (BATatoms[t].storage != t)
    GDKerror("ATOMproperty(%s): overload of %s violates inheritance from %s.\n",
		ATOMname(t), property, ATOMname(BATatoms[t].storage));
*/
	    BATatoms[t].storage = t;  /* critical redefine: undo remapping */
	}
out:	MT_unset_lock(GDKthreadLock, "ATOMproperty");
}

int ATOMindex(str nme) {
	int t, j=GDKatomcnt; 

	for (t = 0; t < GDKatomcnt; t++) {
		if (!BATatoms[t].name[0]) {
			if (j == GDKatomcnt) j = t;
		} else if (strcmp(nme, BATatoms[t].name) == 0) {
			return t; 
		}
		
	}
	if (strcmp(nme, "bat") == 0) {
		return TYPE_bat;
	}
	return -j; 
}

char *ATOMname(int t) {
        return  (t>=0 && t<GDKatomcnt && BATatoms[t].name)?
                               BATatoms[t].name:"null";
}

int ATOMdump() {
	int t; 
	for (t = 0; t < GDKatomcnt; t++) {
		fprintf(GDKout, "%2d '%9s' (%3d) ", t, BATatoms[t].name, BATatoms[t].size); 
		if (BATatoms[t].atomFromStr) {
			fprintf(GDKout, "\"FromStr\" "); 
		}
		if (BATatoms[t].atomToStr) {
			fprintf(GDKout, "\"ToStr\" "); 
		}
		if (BATatoms[t].atomCmp) {
			fprintf(GDKout, "\"Cmp\" "); 
		}
		if (BATatoms[t].atomNull) {
			fprintf(GDKout, "\"Null\" "); 
		}
		if (BATatoms[t].atomHash) {
			fprintf(GDKout, "\"Hash\" "); 
		}
		if (BATatoms[t].atomPut) {
			fprintf(GDKout, "\"Put\" "); 
		}
		if (BATatoms[t].atomDel) {
			fprintf(GDKout, "\"Del\" "); 
		}
		if (BATatoms[t].atomLen) {
			fprintf(GDKout, "\"Len\" "); 
		}
		if (BATatoms[t].atomConvert) {
			fprintf(GDKout, "\"Convert\" "); 
		}
		if (BATatoms[t].atomHeap) {
			fprintf(GDKout, "\"NewHeap\" "); 
		}
		fprintf(GDKout, "\n"); 
	}
	return 0;
}


@- nil values
All types have a single value designated as a NIL value. It designates
a missing value and it is ignored (forbidden) in several primitives.
The current policy is to use the smallest value in any ordered domain.
The routine atomnil returns a pointer to the nil value representation.
@{
@h
#define	GDK_chr_max ((chr) 127)
#define	GDK_chr_min ((chr) -128)
#define	GDK_sht_max ((sht) 32767)
#define	GDK_sht_min ((sht) -32768)
#define	GDK_int_max ((int) 2147483647)
#define	GDK_int_min ((int) (-2147483647-1))
#define	GDK_flt_max ((flt) 3.402823466E+38F)
#define	GDK_flt_min (-GDK_flt_max)
#define	GDK_lng_max ((lng) 9223372036854775807LL)
#define	GDK_lng_min ((lng) (-9223372036854775807LL-1LL))
#define	GDK_dbl_max ((dbl) 1.7976931348623157E+308)
#define	GDK_dbl_min (-GDK_dbl_max)
@c
chr		chr_nil = GDK_chr_min;
sht		sht_nil = GDK_sht_min;
int		int_nil = GDK_int_min;
flt		flt_nil = GDK_flt_min;
dbl		dbl_nil = GDK_dbl_min;
lng		lng_nil = GDK_lng_min;
str		str_nil = (str) &chr_nil;

ptr ATOMnil(int t) { 
	ptr src = ATOMnilptr(t);
	int len = ATOMlen(ATOMtype(t), src);
	ptr dst = GDKmalloc(len);
	memcpy(dst, src, len);
	return dst;
}

@- derived types
@T
In all algorithms accross GDK, you will switches on the types
\{ chr, sht, int, flt, dbl, lng, str\}. They respectively represent 
an octet, a 16-bit int, a 32-bit int, a 32-bit float, a 64-bit double,
a 64-bit int, and a pointer-sized location of a char-buffer (ended by 
a zero char).
\\
In contrast, the types \{ bit, ptr, bat, oid\} are derived types. They 
do not occur in the switches. The @%ATOMstorage@ macro maps them respectively
onto a {\tt chr}, {\tt int} (pointers are 32-bit), {\tt int}, and
{\tt int} (OIDs are 32-bit}.
\\
This approach makes it tractable to switch to 64-bits OIDs,
or to a fully 64-bits OS easily. One only has to map the {\tt oid}
and {\tt ptr} types to {\tt lng} instead of {\tt int}. 
\\
Derived types mimick their fathers in many ways. They inherit the {\tt size},
{\tt varsized}, {\tt linear}, {\tt null} and {\tt align} properties of their 
father.  The same goes for the ADT functions HASH, CMP, PUT, NULL,
DEL, LEN, and HEAP. So, a derived type differs in only two ways
from its father:
\begin{description}
\item [string representation]
the only two ADT operations specific for a derived type are FROMSTR
and TOSTR.
\item [identity]
(a {\tt bit} is really of a different type than {\tt chr}). The set of
operations on derived type values or BATs of such types may differ
from the sets of operations on the father type. 
\end{description}
@h
@{
#define ATOMstorage(t)		BATatoms[t].storage
#define ATOMsize(t)		BATatoms[t].size
#define ATOMalign(t)		BATatoms[t].align
#define ATOMfromstr(t,s,l,src)	BATatoms[t].atomFromStr(src,l,s)
#define ATOMnilptr(t)		BATatoms[t].atomNull
#define ATOMhash(t,src)		BATatoms[t].atomHash(src)
#define ATOMdel(t,hp,src)	if (BATatoms[t].atomDel) BATatoms[t].atomDel(hp,src)
#define ATOMvarsized(t)		((t != TYPE_void) && BATatoms[t].varsized)
#define ATOMlinear(t)		BATatoms[t].linear
#define ATOMtype(t)		((t == TYPE_void)?TYPE_oid:t)
#define ATOMfix(t,v)		if (BATatoms[t].atomFix)\
				BATatoms[t].atomFix(v)
#define ATOMunfix(t,v)		if (BATatoms[t].atomUnfix)\
				BATatoms[t].atomUnfix(v)
#define ATOMconvert(t,v,d)	if (BATatoms[t].atomConvert)\
				BATatoms[t].atomConvert(v,d)
#define ATOMheapConvert(t,hp)	if (BATatoms[t].atomHeapConvert)\
				BATatoms[t].atomHeapConvert(hp)

#define CONV_HTON               1
#define CONV_NTOH               0

@- 
Recursive BATs are a special case. You should modify their reference count.
@h
#define ATOMput(P1, P2, P3, P4)				\
{ int t_ = (P1);                                 	\
  if (t_ == TYPE_oid || t_ == TYPE_ptr || t_ > TYPE_str)\
        t_ = ATOMstorage(t_);                           \
  if (t_ <= TYPE_bat) {					\
	if (t_ <= TYPE_chr) {				\
		if (t_ != TYPE_void)			\
		*(chr *) (P3) = * (chr *) (P4);		\
	} else if (t_ == TYPE_sht) {			\
		*(sht *) (P3) = * (sht *) (P4);		\
	} else if (t_ == TYPE_bat) {			\
		BBPfix(*(bat*) (P4));			\
		*(int *) (P3) = * (int *) (P4); 	\
	}						\
} else {						\
	if (t_ <= TYPE_flt) {				\
		*(int *) (P3) = *(int *) (P4); 		\
	} else if (t_ <= TYPE_lng) {			\
		*(lng *) (P3) = * (lng *) (P4); 	\
	} else if (t_ == TYPE_str) {			\
		(void) strPut(P2, (int*) (P3), (str) (P4));\
	} else {                                        \
	    if (ATOMvarsized(t_)) {			\
		(*BATatoms[t_].atomPut)(P2, P3, P4);	\
	    } else {					\
		memcpy(P3, P4, ATOMsize(P1));		\
	    }						\
	    ATOMfix(t_, P4); 				\
} }    }

#define ATOMreplace(P1,	P2, P3, P4)			\
{ int t_ = (P1);                                 	\
  if (t_ == TYPE_oid || t_ == TYPE_ptr || t_ > TYPE_str)\
        t_ = ATOMstorage(t_);                           \
  if (t_ <= TYPE_bat) {					\
	if (t_ <= TYPE_chr) {				\
		if (t_ != TYPE_void)			\
		*(chr *) (P3) = * (chr *) (P4);		\
	} else if (t_ == TYPE_sht) {			\
		*(sht *) (P3) = * (sht *) (P4);		\
	} else if (t_ == TYPE_bat) {			\
		BBPunfix(*(bat*) (P3));			\
		BBPfix(*(bat*) (P4));			\
		*(int *) (P3) = *(int *) (P4); 		\
	}						\
  } else {						\
	if (t_ <= TYPE_flt) {				\
		*(int *) (P3) = *(int *) (P4); 		\
	} else if (t_ <= TYPE_lng) {			\
		*(lng *) (P3) = * (lng *) (P4); 	\
	} else if (t_ == TYPE_str) {			\
		(void) strPut(P2, (int*) (P3), (str) (P4));\
	} else {					\
	    ATOMunfix(t_, P3);				\
	    if (ATOMvarsized(t_)) {			\
		ATOMdel(t_, P2,(int*) P3);		\
		(*BATatoms[t_].atomPut) (P2, (int*) (P3), P4);\
	    } else {					\
		memcpy(P3, P4, ATOMsize(P1));		\
	    }						\
	    ATOMfix(t_, P4);				\
} }     }

#define STRHASHTABLE	(1<<10)
#define STRHASHMASK	(STRHASHTABLE-1)
#define AVGSTRLEN	12
#define MAXCHAIN	20
#define AVGSTRSPACE	(sizeof(int) + AVGSTRLEN + 1)
#define ELIMLIMIT	(STRHASHTABLE*(sizeof(int)+MAXCHAIN*AVGSTRSPACE))
#define ELIMDOUBLES(h)	((h)->free < ELIMLIMIT)

#endif /* _GDK_ATOMS_H_ */

@- Atomic ADT functions
@c
int ATOMlen(int t, ptr src) {
	int (*l)() = BATatoms[t].atomLen;
	return (l)?(*l)(src):ATOMsize(t);
}

int ATOMheap(int t, Heap* hp, int cap) {
	int (*h)() = BATatoms[t].atomHeap;
	return (h)?(*h)(hp, cap):0;
}

int ATOMcmp(int t, ptr l, ptr r) {
	switch(ATOMstorage(t)) {
	case TYPE_chr: return simple_CMP(l,r,chr);
	case TYPE_sht: return simple_CMP(l,r,sht);
	case TYPE_int: return simple_CMP(l,r,int);
	case TYPE_flt: return simple_CMP(l,r,flt);
	case TYPE_lng: return simple_CMP(l,r,lng);
	case TYPE_dbl: return simple_CMP(l,r,dbl);
	}
	return (l == r) ? 0 : atom_CMP(l,r,t);
}
@}

@
Atom print avoids coercion to strings for built-in types.
The comparison against the NULL value is hard coded for speed.
@c
#define LINE_LEN	60

int ATOMprint(int t, ptr p, FILE* fp) {
	int (*tostr)();
	
	if (p && (t>=0) && (t<GDKatomcnt) && (tostr=BATatoms[t].atomToStr)) {
	    if (t != TYPE_bat && t < TYPE_str) {
		char buf[dblStrlen], *addr=buf; /* use memory from stack */
		int sz = dblStrlen, l = (*tostr)(&addr, &sz, p);
		fputs(buf, fp);
		return l;
	    } else {
		char *buf = 0;
		int sz = 0, l = (*tostr)(&buf, &sz, p);
		fputs(buf, fp);
		GDKfree(buf);
		return l;
	    }
	} 
	fputs("nil", fp);
	return 3;
}


int ATOMformat(int t, ptr p, char** buf) {
	int (*tostr)();
	
	if (p && (t>=0) && (t<GDKatomcnt) && (tostr=BATatoms[t].atomToStr)) {
		int sz = 0, l = (*tostr)(buf, &sz, p);
		return l;
	} 
	strcpy(*buf=GDKmalloc(4), "nil");
	return 3;
}

ptr ATOMdup(int t, ptr p) {
   	int len = ATOMlen(t, p);
	ptr n = GDKmalloc(len);
	memcpy(n,p,len);
	return n;
}

@* Builtin Atomic Operator Implementations

@+ Atom-from-String Conversions 
These routines convert from string to atom. They are used during 
conversion and BAT import. In order to avoid unnecesarry malloc()/free()
sequences, the conversion functions have a meta 'dst' pointer to a
destination region, and an integer* 'len' parameter, that denotes the 
length of that region (a char region for ToStr functions, an atom region
from FromStr conversions). Only if necessary will the conversion
routine do a GDKfree()/GDKmalloc() sequence, and increment the 'len'.
Passing a pointer to a nil-ptr as 'dst' and/or a *len==0 is valid; the 
conversion function will then alloc some region for you.
@= atommem
	if (!*dst) {
		*dst = (@1 *) GDKmalloc(*len = @2);
	} else if (*len < (int) @2) {
		GDKfree(*dst);
		*dst = (@1 *) GDKmalloc(*len = @2);
	}
@= atomtostr
int @1ToStr(char ** dst, int *len, @1 *src) {
	@:atommem(char,@1Strlen)@
	if (*src == @1_nil) {
		strcpy(*dst, "nil");
		return 3;
	}
	sprintf(*dst, "@2", (@3) *src);
	return strlen(*dst);
}
@c
#define num08(x)	((x) >= '0' && (x) <= '7')
#define num10(x)	GDKisdigit(x)
#define num16(x)	(GDKisdigit(x) || ((x)  >= 'a' && (x)  <= 'z') || ((x)  >= 'A' && (x)  <= 'Z'))
#define base10(x)	((x) - '0')
#define base08(x)	((x) - '0')
#define base16(x)	(((x) >= 'a')?((x) - 'a'):((x) >= 'A')?((x) - 'A'):(x)-'0')
#define mult08(x)	((x) << 3)
#define mult16(x)	((x) << 4)
#define mult10(x)	((x) + (x) + ((x) << 3))
#define mult7(x)	(((x) << 3) - (x))

int voidFromStr(str src, int *len, void **dst)
{
	return 0;
}

int voidToStr(str *dst, int *len, void *src) {
	@:atommem(char,3)@
	strcpy(*dst, "nil");
	return 3;
}

int chrFromStr(char *src, int *len, chr **dst) {
	int error = 0;
	chr base = 0;
	str p = src;

	@:atommem(chr,sizeof(chr))@
	while(GDKisspace(*p)) p++; 
	if (p[0] == 'n' && p[1] == 'i' && p[2] == 'l') {
		base = chr_nil; p += 3;
	} else if (p[0] && p[1] == 0) {
		base = *p++; 
	} else {
		if (*p != '\'') {
		    error = 1;
		} else if (p[1] == '\\' && num08(p[2])) { 
		    p += 2;
		    while (error == 0) {
			chr val = mult08(base) + base08(*p);
			if (val < base) error = 1;
			base = val; p++;
			if (!num08(*p)) break;
		    }
		} else {
		    base = p[1];
		}
		if (*p != '\'') {
			error = 1; p = src; 
		}
	} **dst = error?chr_nil:base;
	return p-src;
}

@:atomtostr(chr,'%c',chr)@

int bitFromStr(str src, int *len, bit **dst) {
	char *p=src;

	@:atommem(bit,sizeof(bit))@
	while(GDKisspace(*p)) p++;
	**dst = bit_nil;
	if (*p == '0') {
	   **dst = FALSE; p++;
	} else if(*p == '1') {
	   **dst = TRUE; p++;
	} else if (p[0] == 't' && p[1] == 'r' && p[2] == 'u' && p[3] == 'e') {
	   **dst = TRUE; p += 4;
	} else if (p[0] == 'f' && p[1] == 'a' && p[2] == 'l' && p[3] == 's' && p[4] == 'e') {
	   **dst = FALSE; p += 5;
	} else if (p[0] == 'n' && p[1] == 'i' && p[2] == 'l') {
	   p += 3;
	}
	return p-src;
}

int bitToStr(char **dst, int *len, bit *src) {
	@:atommem(char,6)@
	if (*src == chr_nil) {
	    strcpy(*dst, "nil");
	    return 3;
	} else if (*src) {
	    strcpy(*dst, "true");
	    return 4;
	}
	strcpy(*dst, "false");
	return 5;
}
	
int batFromStr(char *src, int *len, bat **dst) {
	char *s, *t, *r=src;
	int c, sign = 1, bid;

	@:atommem(bat,sizeof(bat))@
	while(GDKisspace(*r)) r++;
	if (*r == '<') r++;
	if (*r == '~') {
		r++; sign = -1;
	}
	t = r;
	while((c=*t) && (c=='_' || GDKisalnum(c))) t++;
	s = (char*) alloca(1+t-r);
	strncpy(s,r,t-r);
	s[t-r] = 0;
	bid = BBPindex(s);
	**dst = (bid==0)?int_nil:sign*bid;
	return t+(c=='>'?1:0)-src;
}

int batToStr(char **dst, int *len, bat *src) {
 	int i=*src;
	str s;
	if (*(bat*) src == bat_nil || (s = BBPname(i)) == NULL || *s == 0) {
		@:atommem(char,4)@
		strcpy(*dst,"nil");
		return 3;
	}
	i = strlen(s)+4;
	@:atommem(char,i)@
	sprintf(*(dst), "<%s%s>", (*src<0)?"~":"", s);	
	return strlen(*dst);
}


@= numfromstr
int @1FromStr(char* src, int * len, @1 **dst) {
	int minus = 0, error = 0;
	@1 base = 0;
	str p = src;

	@:atommem(@1,sizeof(@1))@
	while(GDKisspace(*p)) p++; 
	if (p[0] == 'n' && p[1] == 'i' && p[2] == 'l') {
		base = @1_nil; p += 3;
	} else {
	 	if (*p == '-' || *p == '+') {
			if (*p++ == '-') minus = 1;
		}
		if (!num10(*p)) {
			error = 1; p = src;
		}
		while (error == 0) {
			@1 val = mult10(base) + base10(*p);
			if (val < base) error = 1;
			base = val; p++;
			if (!num10(*p)) break;
		}
		if (sizeof(@1) == 8 && p[0] == 'L' && p[1] == 'L') {
			p += 2;
		}
	} **dst = error?@1_nil:(minus?-base:base);
	return p-src;
}
@c
@:numfromstr(sht)@
@:atomtostr(sht,%hd,int)@

@:numfromstr(int)@
@:atomtostr(int,%d,int)@

@:numfromstr(lng)@
#ifndef __CYGWIN32__
@:atomtostr(lng,%lld,lng)@
#else
int lngToStr(char **dst, int *len, lng *src) {
	char *p;
	int l=0;
    
	long ll; /* it turned out to be nontrivial to get a long long printed */
	@:atommem(char,lngStrlen)@
	p = *dst; *p = 0;
    	if (*src == lng_nil) {
		strcpy(p, "nil");
		return 3;
	} 
	if (*src < 0LL) {
		*p++ = '-'; *p = 0;
	}
	ll = (*(lng*)src)/100000000000000LL;
	if (ll) {
		sprintf(p, "%ld", (ll<0)?-ll:ll); 
		l += strlen(p);
	}
	ll = ((*(lng*) src) % 100000000000000LL) / 10000000LL;
	if (l) {
		sprintf(p+l, "%07ld", (ll<0)?-ll:ll);	
	} else if (ll) {
		sprintf(p, "%ld", (ll<0)?-ll:ll);	
	}
@c
	l += strlen(p+l);
	ll = (long) ((*(lng*) src) % 10000000LL);
	if (l) {
		sprintf(p+l, "%07ld", (ll<0)?-ll:ll);	
	} else {
		sprintf(p, "%ld", (ll<0)?-ll:ll);	
	}
	return strlen(*dst);
}
#endif

int ptrFromStr(char* src, int * len, ptr **dst) {
	int error = 0;
	long base = 0;
	str p = src;

	@:atommem(ptr,sizeof(ptr))@
	while(GDKisspace(*p)) p++; 
	if (p[0] == 'n' && p[1] == 'i' && p[2] == 'l') {
		error = 1; p += 3;
	} else {
	 	if (p[0] == '0' && (p[1] == 'x' || p[1] == 'X')) {
			p += 2;
		}
		if (!num16(*p)) {
			error = 1; p = src;
		}
		while (error == 0) {
			long val = mult16(base) + base16(*p);
			if (val < base) error = 1;
			base = val; p++;
			if (!num16(*p)) break;
		}
	} **dst = error?((ptr) ptr_nil):((ptr) base);
	return p-src;
}
@:atomtostr(ptr,%x,unsigned int)@

static dbl pow10_dbl[8] = 
  { 1.0, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, 10000000.0 };
static flt pow10_flt[8] = 
  { 1.0, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, 10000000.0 };

@= fltfromstr
int @1FromStr(char* src, int* len, @1 **dst) {
	int scale = 0, digits=0, numseen=0, minus = 0;
	char buf[@5], *q=buf, *p = src;
	@4 num = 0;

	/* alloc memory */
	@:atommem(@1,sizeof(@1))@
	**dst = @1_nil; /* default return value is nil */

	if (*p == '-' || *p == '+') {
		minus = (*p++ == '-');
	} 
	if (GDKisdigit(p[0]) == 0 || (p[0] == '.' && GDKisdigit(p[1]) == 0)) {
		return 0; /* syntax error */
	}

	/* parse number part */
	while(GDKisdigit(*p)) {
		if (*p != '0' || numseen) {
		    	if (digits < @5) {
				num = (*p - '0') + mult10(num);
				*q++ = *p;
				digits++;
			} else {
				scale++;
			} numseen = TRUE;
		} p++;
	} 

	/* parse part after comma */
	if (*p == '.') {
		int maxpos=0, pos=0;
		p++;
		while(GDKisdigit(*p)) {
			pos++;
		    	if (*p != '0' || numseen) {
				if (digits < @5) {
					num = (*p - '0') + mult10(num);
					*q++ = *p;
					digits++;
					maxpos = pos;
				} numseen = TRUE;
			} p++; 
		} 
		scale -= maxpos;
	} *q = 0;

	/* parse scale (a simple integer) */
	if (*p == 'e' || *p == 'E') {
		int add=0, *sp = &add, l=8;
		int pos = intFromStr(++p, &l, &sp); 
		p += pos; 
		if (add != int_nil) scale += add;
	}

	/* if the parsed value is within bounds, assign it to the return value */
	digits = MAX(0,digits+scale);
	if (digits < @2 || (digits == @2 && strcmp(buf,@3) < 0)) {
                int itr = ABS(scale);
		@1 val = (@1) (minus?-num:num);
		@1 scl = pow10_@1[itr&7];

		for(itr>>=3; itr > 0; itr--) {
                        scl *= 100000000.0;
                }
                if (scale < 0) {
                        val /= scl;
                } else {
                        val *= scl;
                }
                **dst = val;
		if (sizeof(@1) == 8 && p[0] == 'L' && p[1] == 'L') {
			p += 2;
		}
	}
	return p-src;
}
@c
@:fltfromstr(flt, 39, "3402823466", int, 9)@
@:atomtostr(flt,%g,float)@

@:fltfromstr(dbl, 309, "17976931348623157", lng, 18)@
@:atomtostr(dbl,%g,double)@


@}
@+ String Atom Implementation
The Built-in type string is funnelled partly through the atom extension
library. The main reason is to limit the number of built-in types
in the BAT library kernel. Moreover, an extra indirection for strings is less
harmfull then for manipulation of, lets' say int.

The internal representation of strings is without escape sequences.
When the string is printed we should add the escapes back into it.

The current escape policy is that '"' and "'" can be prepended by a
backslash. Furthermode, the backslash may be followed by three
digit octal number to denote a character.

@- Automatic Double Elimination
Because in many typical situations lots of double string values occur
in tables, the string insertion provides automatic double elimination.
To do this, a STRHASHTABLE(=1024) bucketet hashtable is hidden in the first 
4096 bytes of the string heap, consisting of integer offsets of the first 
string hashing on that bucket in the heap. Furthermore, the first 4 bytes 
before each string in the heap is an integer offset to the next string hashing 
on the same number.
@
@
In situations with all uniquely different strings (as in some TPCD tables)
this double elimination becomes very expensive. HACK: with a simple trick it
is turned off: if the hash-chains become larger than 20, double-elimination
is stopped (crudely assuming strings to have some mean length, one EOS char,
and one integer for each next-pointer). In this way the binary format of the 
string heaps did not have to be changed, in order to do the check.
WARNING: any algorithm assuming doubles eliminated should check first with
@%strElimDoubles(Heap*)@. If this returns FALSE, it is a no-go!!
@c
int strElimDoubles(Heap *h) {
	return ELIMDOUBLES(h);
} 

@- Nil Value
The nil value for strings equates with the empty string. Future extensions may
consider using a <length,value> pair where the length can be used to indicate
a missing value.
@{
@c
int strNil(str s)  	 { return (!(s) || *(chr*) (s) == GDK_chr_min); }
int strLen (str s)       { return strNil(s)?2:1+strlen(s); }
int strCmp (str r,str l) { return strNil(r)?(strNil(l)?0:-1):(strNil(l)?1:
                                  strcmp(r,l)); }


Heap str_smallHeap;

void strHeap(Heap *d, int cap) {
	int size;
	int *h, *e; 

	cap = MAX(cap, BATTINY);
	size = STRHASHTABLE*sizeof(int) +
		MIN(STRHASHTABLE*MAXCHAIN, cap)*AVGSTRSPACE;
	HEAPalloc(d, size, 1);
	d->free = STRHASHTABLE*sizeof(int); 
	h = (int*) d->base; 
	for (e = h; e < h + STRHASHTABLE; e++) {
		*e = 0; 
	}
}


@- Hash Function 
@T
Given the diversity of string applications, this is a delicate one,
because the hash function should work well on as many data distributions 
as possible, yet be very fast to compute. Therefore:
\begin{itemize}
\item we use a fixed maximum of 10 probes,
\item with a uniform distribution of probes along the string,
\item including at least first and last character.
\item exclude leading and trailing spaces from the string
\end{itemize}
In an earlier version we used prime multiplication with p=19,
but then 19^10 gets you over max(int), so we scaled that down to p=7. 
@c
unsigned int strHash(str s) {
	unsigned int h, len; 
	char *t;

	if (strNil(s)) {
		return 0; 
	}
	while(*s == ' ') {
		s++; /* discard leading spaces */
	}
	for(t=s; *t; t++);
	while(t > s && t[-1] == ' ') {
		t--; /* discard trailing spaces */
	}
	len = t-s;
	h = *s++; /* get first char */
	if (len-- > 1) {
	    h = mult7(h) + t[-1]; /* get last char */
	    if (len-- > 1) {
		int i=0, j = MAX(len,8), k = j*MIN(len, 8); 
		/* get 8 intermediate chars. 8==2^3 */
		for(i=0; i < k; i+=j) {
			h = mult7(h) + s[i >> 3];
		}
	    }
	}
	return h & 0x7fffffff;
} 

@- 
The @%strPut@ routine. The routine @%strLocate@ can be used to identify
the location of a string in the heap if it exists. Otherwise it returns
zero.
@c
int strLocate(Heap *h, str v) {
	int *htab;
	int *e;
	int *l; 

	htab = (int*) h->base; 
	e = htab + (strHash(v) & STRHASHMASK); 
	if (*e) {
		for (l = e; *l; l = (int*) (((char*) h->base)  + *l)) {
			if (!strCmp(v, (((char*) h->base)+*l+sizeof(int)))) {
				return *l + sizeof(int); 
			}
		}
	}
	return 0; 
}

/* convert the integers in the implicit hash table structure */ 
void strHeapConvert(Heap *h) {
	int *htab = (int*) h->base; 
	int *l, i, j; 

	if (ELIMDOUBLES(h))
	for(i=0; i<STRHASHTABLE; i++) {
		for (l= htab+i; (j=*l) != 0; l=(int*) (((char*) h->base)+ *l)) {
			*l = normal_int_SWAP(j);
		}
	}
}

int strPut(Heap *h, int *dst, str v) {
	int *l, off, i = strLen(v);
	int len = (((i-1) >> 2) + 1) << 2; /* round up to 4-byte alignment */

	/* search hash-table, if double-elimination is still in place */
	if (ELIMDOUBLES(h)) {
		off = strHash(v) & STRHASHMASK; 
		for (l = ((int*) h->base) + off; *l; l = (int*) (h->base + *l)) {
			str x = (str) (h->base + *l + 4); 
			if ((*v == *x) && (strCmp(v, x) == 0)) {
				*dst = *l + 4; /* already in heap; do not insert! */
				return 0; 
			}
 		}
	}

	/* check heap for space and determine destination pointer */
	if (h->free + len + 4 >= h->size) {
		size_t newsize = len+4+h->size*BATMARGIN;
		if (h->free + len + 4 < h->maxsize) {
			/* if there is reserved space, first use the reserved space */
			newsize = MIN(newsize,h->maxsize); 
        	}
		HEAPextend(h, newsize);
	}
	l = (int*) (h->base + h->free); 

	/* add chain link offset in front of string in 4bytes extra space */
	if (ELIMDOUBLES(h)) {
		int *htab = (int*) h->base; 
		*(l++) = htab[off]; htab[off] = h->free; 
		h->free += 4;
	}

	/* copy the string in */
	*dst = h->free;
	h->free += len;
	memcpy((char*) l, v, i); 

	return 0; 
}

@- 
Though it should not be possible, it was noted that sometimes BATs had corrupted
string heaps. These supposedly were the product of half saves at a crashed commit. 
The resulting inconsistent BAT can then again cause a crash! (e.g. when the hash 
table is not cleared well; this causes havoc on new values inserts). This routine 
thoroughly examines the head string heap of a BAT and makes corrections were necessary.

Currently all non-control characters of the ASCII/Latin 1 character table
are allowed.
@c
#define STRHASHSIZE (int) (STRHASHTABLE*sizeof(int))

#define allowed_chr(ch) ((ch)==0 || GDKisgraph((ch)) || GDKisspace((ch)) || \
		         GDKisspecial((ch)) || GDKisupperl((ch)) || GDKislowerl((ch)))

int strHeapCheck(Heap *hp, HeapRepair *hr) {
	unsigned int pos, mask = 1+((hp->free-STRHASHSIZE)>>7), *valid = (unsigned int*) GDKmalloc(mask*4);
	unsigned int xx, yy, ret = TRUE, hash = ELIMDOUBLES(hp), scan = !hash;
        str base = hp->base + STRHASHSIZE;
	str elim = hp->base + ELIMLIMIT;
        str last = hp->base + hp->free;

	/* empty the bitvector that records valid heap positions */
	for(xx=0; xx<mask; xx++) valid[xx] = 0;

	/* check the hashtable to find all valid string positions */
	if (hash)
	for(xx=0; xx<STRHASHTABLE; xx++ ) {
		for(yy = *(int*) (hp->base+ (xx<<2)); yy; yy = *(int*) (hp->base+yy)){
			if ((yy < STRHASHSIZE) || (hp->base+yy >= elim) || (yy&3)) {
				GDKwarning("strHeapCheck: strheap[%d..%d] illegal link=%d.\n", STRHASHSIZE, hp->free, yy);
                        } else {
                                str s = hp->base + yy + 4;
				if (strNil(s)) {
					s++;
				} else while (s < last && *s && allowed_chr(*s)) {
                                        s++;
                                }
                                if (*s == 0) {
                                        mask = ((yy-STRHASHSIZE)>>2) + 1;
                                        pos = mask >> 5;
                                        mask = 1 << (mask & 31);
                                        valid[pos] |= mask;
                                        continue; /* A-OK */
                                }
                        }
			/* error detected; hence we must scan and repair */
			scan = TRUE; break;
		}
	}
	/* we scan either if the hash table is not functioning anymore (!ELIMDOUBLES) or 
	 * if it was found to be corrupt in the above code. In the latter case, we not only 
	 * scan the heap for strings but also rebuild the hash table .
	 */
	if (scan) {
		str cur = base;
		if (hash) {
			memset(hp->base, 0, STRHASHSIZE);
			ret = FALSE;
		}
		while(cur < last) {
			str s = cur, err = NULL;

			/* advance 4 positions if in ELIMDOUBLES range */
			s += (s < elim)<<2; 

			/* mark this position as legal */
			mask = (s-base) >> 2;
			pos = mask >> 5;
			mask = 1 << (mask & 31);
			valid[pos] |= mask; 

			/* check correctness of string */
			if (strNil(s)) {
				s++;
			} else while(s < last && *s) {
				if (!allowed_chr(*s)) err = s;
				s++;
			}
			if (err) {
				GDKerror("strHeapCheck: illegal char '%d' at position %d.\n", 
									*err, err - hp->base);
				memset(cur, 'Z', s-cur); /* we cannot zero it! */
				ret = FALSE; 
			}
			/* insert in the hash table */
			if (hash) {
				int *e = ((int*) hp->base) + (strHash(cur+4) & STRHASHMASK);
				*e = cur - hp->base; 
				*(int*) cur = *e;
			} 
			/* advance to the next string, which is at next 4-aligned position */
			pos = ++s - base;
			if (pos&3) pos += 4 - (pos&3);
			cur = base + pos;
		}
        }
	hr->alignment = 4;
	hr->minpos = STRHASHSIZE;
	hr->maxpos = hp->free;
	hr->validmask = valid;
	return ret;
}
@-
Convert an "" separated string to a GDK string value.
@c

int strFromStr(char *src, int *len, char** dst) {
	str p, start = NULL, cur = src;
	int l = 1, escaped = FALSE;

	while(GDKisspace(*cur)) cur++;
	if (*cur != '"') {
		if (*dst != NULL && *dst != str_nil) {
			GDKfree(*dst);
		}
		*dst = ATOMnil(TYPE_str);
		*len = 2;
		return strncmp(cur,"nil",3)?0:((cur+3)-src);
	} 

	/* scout the string to find out its length and correctness */
	for(start = ++cur; *cur != '"' || escaped; cur++) {
		if (*cur == 0) { 
			start = NULL; break;
		} else if (*cur == '\\' && escaped == FALSE) {
			escaped = TRUE;
		} else {
			escaped = FALSE; l++;
		}
	}

	/* alloc new memory */
	p = *dst;
	if (*dst == NULL || (*dst==str_nil)) {
		p = *dst = (char *) GDKmalloc(*len = l);
	} else if (*len < l) {
		GDKfree(*dst);
		p = *dst = (char *) GDKmalloc(*len = l);
	}

	/* copy it in, while performing the correct escapes */
	if (start == NULL) {
		*p = GDK_chr_min; /* error => str_nil */
	} else for(cur = start; *cur != '"' || escaped ; cur++) {
		if (escaped) {
			if (*cur == 'n') { 
				*p++ = '\n';
			} else if (*cur == 't') { 
				*p++ = '\t';
			} else if ((cur[0] >= '0' && cur[0] <= '9') &&
				   (cur[1] >= '0' && cur[1] <= '9') &&
				   (cur[2] >= '0' && cur[2] <= '9'))
			{
				*p++ = (cur[2] + (cur[1]<<3) + (cur[0]<<6));
			} else {
			        *p++ = *cur;
			}
			escaped = FALSE;
		} else if (*cur == '\\') {
			escaped = TRUE;
		} else {
			*p++ = *cur;
		}
	}
	*p++ = 0;
	return (cur + 1) - src;
}

@-
Convert a GDK string value to something printable.
@c
int strToStr(char** dst, int *len, char* src) {
	int l=1;
	if (strNil((str) src)) {
		@:atommem(char,4)@
		strcpy(*dst, "nil");
		return 3;
	} else {
		char *s, *r = (char*) src;
		int cur=0, end, sz=0;
		for(end=0; src[end]; end++) 
		    if (src[end] == '\t' || src[end] == '\n' ||
		        src[end] == '\\' || src[end] == '"') 
		    {   sz += 2;
		    } else if (!allowed_chr(src[end])) {
			sz += 4;
		    } else {
			sz++;
		    }
		@:atommem(char,sz+3)@
		
		for(s=*dst; cur<end; cur++)
		    if (r[cur] == '\t') {
		        s[l++] = '\\'; s[l++] = 't';
		    } else if (r[cur] == '\n') {
		        s[l++] = '\\'; s[l++] = 'n';
		    } else if (r[cur] == '\\') {
		        s[l++] = '\\'; s[l++] = '\\';
		    } else if (r[cur] == '"') {
		        s[l++] = '\\'; s[l++] = '"';
		    } else if (!allowed_chr(r[cur])) {
        		sprintf(s+l, "\\%03o", r[cur]); l+=4;
		    } else {
		        s[l++] = r[cur];
		    }
		s[0] = s[l++] = '"';
		s[l] = 0;
	}
	return l;
}

@+ Unique OIDs
The basic type OID represents unique values. Refinements should be
considered to link oids in time order.
@c
@{
oid	GDKoid[GDKMAXDB], GDKflushed[GDKMAXDB];
int	GDKdb;
@-
Init the shared array of oid bases.
@c
int OIDinit(){
        int i = GDKMAXDB;
        while(i--) GDKflushed[i] = GDKoid[i] = 0;
	return 0;
}

@-
Make up some new OID for a specified database, based on the current time.
@c
oid OIDrand(int db) { 
	return (db << SERVERBITS) + (OIDnumber & 1000000);
} 
@-
Initialize the current OID number to be starting at 'o'. 
@c
oid OIDbase(oid o){
	MT_set_lock(MT_system_lock, "OIDbase");
	GDKdb = (OIDserver & o) >> SERVERBITS;	
	GDKoid[GDKdb] = o;
	MT_unset_lock(MT_system_lock, "OIDbase");
	return (oid) o;
}

oid OIDseed(unsigned int o) {
	oid t, *p = (oid*) GDKoid;

	MT_set_lock(MT_system_lock, "OIDseed");
	GDKdb = (OIDserver & o) >> SERVERBITS;	
 	t = OIDrand(GDKdb);
	if (o > t) t = o;
	if (p[GDKdb] >= t) t = p[GDKdb];
	else p[GDKdb] = t; 
	MT_unset_lock(MT_system_lock, "OIDseed");
	return (oid) t;
}
@-
Initialize a sequence of OID seeds (for a sequence of database)
as stored in a string.
@c
int OIDread(str s) {
	oid new, *p=&new;
	int l=sizeof(oid);

	while (GDKisspace(*s)) s++;
	while (GDKisdigit(*s)) {
		s += OIDfromStr(s, &l, &p);
		while(GDKisspace(*s)) s++;
		new = OIDseed(new);
	}
	return new;
}
@-
Write the current sequence of OID seeds to a file in string format.
@c
int OIDflushdelta = 100000;

int OIDwrite(FILE *fp) {
	int i, ret = 0;
	MT_set_lock(MT_system_lock, "OIDwrite");
	for(i=0; i < GDKMAXDB; i++) { 
		if (GDKoid[i]) {
			GDKflushed[i] = GDKoid[i] + OIDflushdelta;
			ATOMprint(TYPE_oid, GDKflushed+i, fp);
			if (fputc(' ', fp) < 0) ret = -1;
		}
	}
	MT_unset_lock(MT_system_lock, "OIDwrite");
	return ret;
}

int OIDdirty() {
	int i;
	for(i=0; i < GDKMAXDB; i++) { 
		if (GDKoid[i] && GDKoid[i] > GDKflushed[i]) {
			return TRUE;
		}
	}
	return FALSE;
}
@-
Reserve a range of unique OIDs for a specified database.
@c
oid OIDnewdb(int inc, int db) {
	oid ret;
	MT_set_lock(MT_system_lock, "OIDnewdb");
	if (!GDKoid[db]) GDKoid[db] = OIDrand(db);
	ret = GDKoid[db]; 
	GDKoid[db] += inc; 
	MT_unset_lock(MT_system_lock, "OIDnewdb");
	return ret; 
}
@-
Reserve a range of unique OIDs for the current database.
@c
oid OIDnew(int inc) {
	return OIDnewdb(inc, GDKdb);
}
@-
String conversion routines. 
@c
int OIDfromStr(char *src, int *len, oid **dst) {
	int ui, *uip = &ui, db=0, *dbp = &db, l=sizeof(int), pos = 0;
	str p = src;

	@:atommem(oid,sizeof(oid))@
	**dst = oid_nil;
	while(GDKisspace(*p)) p++;
	if (GDKisdigit(*p)) {
		pos = intFromStr(p,&l,&uip); p += pos;
		if (pos > 0 && p[0] == '@') {
			if (!GDKisdigit(p[1])) pos = 0;
			else pos = intFromStr(++p,&l,&dbp); 
			p += pos;
		}
		if (pos > 0 && ui >= 0 && ui < (1<<SERVERBITS) && db >= 0 && db < 4) {
		 	**dst = ui | (db<<SERVERBITS);
		}
	} 
	if (pos <= 0) p = src;
	return p - src;
}

int OIDtoStr(char** dst, int *len, oid *src) {
	unsigned int ui;
	@:atommem(char,oidStrlen)@
	if (*src == oid_nil) {
		strcpy(*dst, "nil");
		return 3;
	}
	ui = *(oid*)src;
	sprintf(*dst, "%u\@%d", ui&OIDnumber, (ui&OIDserver)>>SERVERBITS);
	return strlen(*dst);
}
@
@}
