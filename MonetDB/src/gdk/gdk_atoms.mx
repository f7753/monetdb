@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at 
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@' 
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@' 
@' The Original Code is the Monet Database System.
@' 
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2002 CWI.  
@' All Rights Reserved.
@' 
@' Contributor(s):
@' 		Martin Kersten <Martin.Kersten@cwi.nl>
@' 		Peter Boncz <Peter.Boncz@cwi.nl>
@' 		Niels Nes <Niels.Nes@cwi.nl>
@' 		Stefan Manegold  <Stefan.Manegold@cwi.nl>

@f gdk_atoms
@a M. L. Kersten, P. Boncz
@* Atomic types
The Binary Association Table library assumes efficient implementation of
the atoms making up the binary association.
This section describes the preliminaries for handling
both built-in and user-defined atomic types. 
New types, such as point and polygons, can be readily added to this
collection.
@h
#ifndef _GDK_ATOMS_H_
#define _GDK_ATOMS_H_
#include "gdk.h"
 
#define MAXATOMS	1024

@- comparsion macro's
In order to get maximum performance, we extensively use out-factoring
of typechecks using Mx macros. To catch diverging code in one Mx macro
we use the following #defines for comparing atoms:
@h
#define simple_CMP(x,y,tpe)     (simple_LT(x,y,tpe)?-1:simple_GT(x,y,tpe))
#define simple_EQ(x,y,tpe)      ((*(tpe*) (x)) == (*(tpe*) (y)))
#define simple_LT(x,y,tpe)      ((*(tpe*) (x))  < (*(tpe*) (y)))
#define simple_GT(x,y,tpe)      ((*(tpe*) (x))  > (*(tpe*) (y)))
#define simple_LE(x,y,tpe)      ((*(tpe*) (x)) <= (*(tpe*) (y)))
#define simple_GE(x,y,tpe)      ((*(tpe*) (x)) >= (*(tpe*) (y)))
#define atom_CMP(x,y,id)        (*BATatoms[id].atomCmp)(x,y)
#define atom_EQ(x,y,id)         ((*BATatoms[id].atomCmp)(x,y) == 0)
#define atom_LT(x,y,id)         ((*BATatoms[id].atomCmp)(x,y) < 0)
#define atom_GT(x,y,id)         ((*BATatoms[id].atomCmp)(x,y) > 0)
#define atom_LE(x,y,id)         ((*BATatoms[id].atomCmp)(x,y) <= 0)
#define atom_GE(x,y,id)         ((*BATatoms[id].atomCmp)(x,y) >= 0)
#define simple_HASH(v,tpe,dst)  ((dst) *(tpe *) (v))
#define atom_HASH(v,id,dst)     ((dst) (*BATatoms[id].atomHash)(v))

@- maximum atomic string lengths
@h
#define bitStrlen	8
#define chrStrlen	8
#define shtStrlen	12
#define intStrlen	24
#define oidStrlen	24
#define ptrStrlen	24
#define lngStrlen	48
#define fltStrlen	48
#define dblStrlen	96

@- 
The system comes with the traditional atomic types: int (4 bytes), bool(1 
byte) and str (variable). In addition, we support the notion of an OID 
type, which ensures uniques of its members.
This leads to the following type descriptor table.
@{
@h

#ifdef __cplusplus
extern "C" {
#endif
gdk_export int		voidFromStr    (str  src, int* len, void** dst);
gdk_export int		voidToStr      (str* dst, int* len, void* src);

gdk_export int		lngFromStr     (str  src, int* len, lng** dst);
gdk_export int		lngToStr       (str* dst, int* len, lng*  src);
int		lngCmp         (lng* r, lng* l);
void 		lngConvert     (lng* s);
unsigned int 	lngHash        (lng *l);

gdk_export int		intFromStr     (str  src, int* len, int** dst);
gdk_export int		intToStr       (str* dst, int* len, int*  src);
int		intCmp         (int* r, int* l);
void 		intConvert     (int* s);
unsigned int 	intHash        (int *i);

gdk_export int		batFromStr     (str  src, int* len, bat** dst);
gdk_export int		batToStr       (str* dst, int* len, bat*  src);

gdk_export int		ptrFromStr     (str  src, int* len, ptr** dst);
gdk_export int		ptrToStr       (str* dst, int* len, ptr*  src);

gdk_export int		bitFromStr     (str  src, int* len, bit** dst);
gdk_export int		bitToStr       (str* dst, int* len, bit*  src);

gdk_export int		OIDfromStr     (str  src, int* len, oid** dst);
gdk_export int		OIDtoStr       (str* dst, int* len, oid*  src);

gdk_export int		shtFromStr     (str  src, int* len, sht** dst);
gdk_export int		shtToStr       (str* dst, int* len, sht*  src);
void 		shtConvert     (sht* s);
int		shtCmp         (sht* r, sht* l);
unsigned int	shtHash        (sht *s);

gdk_export int		chrFromStr     (str  src, int* len, chr** dst);
gdk_export int		chrToStr       (str* dst, int* len, chr*  src);
int		chrCmp         (chr* r, chr* l);
unsigned int 	chrHash        (chr *c);

gdk_export int		fltFromStr     (str  src, int* len, flt** dst);
gdk_export int		fltToStr       (str* dst, int* len, flt*  src);
int		fltCmp         (flt* r, flt* l);

gdk_export int		dblFromStr     (str  src, int* len, dbl** dst);
gdk_export int		dblToStr       (str* dst, int* len, dbl*  src);
int		dblCmp         (dbl* r, dbl* l);

gdk_export int		strFromStr     (str  src, int* len, str*  dst);
gdk_export int		strToStr       (str* dst, int* len, str   src);
gdk_export unsigned int strHash        (str s); 
gdk_export int		strPut         (Heap* b, int *off, str src);
gdk_export void 	strHeap        (Heap* d, int cap);
gdk_export int		strLen         (str s);
gdk_export int		strCmp         (str l, str r);
gdk_export int		strNil         (str s);
gdk_export void 	strHeapConvert (Heap *h, int directon);
gdk_export int		strElimDoubles (Heap *h);
gdk_export int 		strLocate      (Heap *h, str v);

#ifdef __cplusplus
}
#endif

@- inline comparison routines
Return 0 on l==r, < 0 iff l < r, >0 iff l > r  
@c
#include "gdk_atoms.h"
#include "gdk_bat.h"
#include "gdk_desc.h"

int chrCmp(chr* l, chr* r) { return simple_CMP(l,r,chr); }
int shtCmp(sht* l, sht* r) { return simple_CMP(l,r,sht); }
int intCmp(int* l, int* r) { return simple_CMP(l,r,int); }
int fltCmp(flt* l, flt* r) { return simple_CMP(l,r,flt); }
int lngCmp(lng* l, lng* r) { return simple_CMP(l,r,lng); }
int dblCmp(dbl* l, dbl* r) { return simple_CMP(l,r,dbl); }

@- inline hash routines
Return some positive integer derived from one atom value.
@c
unsigned int chrHash(chr *v) { return *(unsigned char*) v; }
unsigned int shtHash(sht *v) { return mix_sht(*(unsigned short*) v); }
unsigned int intHash(int *v) { return mix_int(*(unsigned int*) v); }
unsigned int lngHash(lng *v) { return mix_int(((unsigned int*) v)[0]^((unsigned int*) v)[1]); }

@+ Standard Atoms
@c
INLINE void shtConvert(sht* s) { *s = short_int_SWAP(*s); }
INLINE void intConvert(int* s) { *s = normal_int_SWAP(*s); }
INLINE void lngConvert(lng* s) { *s = long_long_SWAP(*s); }
INLINE int  batFix(bat* b)     { return BBPpersistent(*b,FALSE); }
INLINE int  batUnfix(bat* b)   { return BBPtransient(*b,FALSE); }

atomDesc BATatoms[MAXATOMS] = {
  { "void",  	TYPE_void, 1, 0, /* sizeof(@`void@7) */ 0, 1, (ptr) &int_nil, 
		(int  (*)()) OIDfromStr,	(int (*)()) OIDtoStr,
 		(int  (*)()) intCmp,		
 		(unsigned int (*)()) intHash, 	(void (*)()) 0,
 		(int  (*)()) 0,			(int  (*)()) 0,
 		(void (*)()) 0,			(void (*)()) 0,
 		(int (*)()) 0,			(int  (*)()) 0,
 		(void (*)()) 0,			(int  (*)()) 0},			
  { "bit",  	TYPE_chr, 1, sizeof(bit), sizeof(@`bit@7), 0, (ptr) &chr_nil, 
		(int  (*)()) bitFromStr,	(int (*)()) bitToStr,
 		(int  (*)()) chrCmp,		
 		(unsigned int  (*)()) chrHash,	(void (*)()) 0,		
		(int  (*)()) 0, 		(int  (*)()) 0,
		(void (*)()) 0,			(void (*)()) 0,
 		(int (*)()) 0,			(int  (*)()) 0,
 		(void (*)()) 0,			(int  (*)()) 0},
  { "chr",  	TYPE_chr, 1, sizeof(chr), sizeof(@`chr@7), 0, (ptr) &chr_nil, 
		(int  (*)()) @`chrFromStr@5,	(int (*)()) @`chrToStr@5,
	 	(int  (*)()) chrCmp,		
 		(unsigned int  (*)()) chrHash,	(void (*)()) 0,		
		(int  (*)()) 0, 		(int  (*)()) 0,
		(void (*)()) 0,			(void (*)()) 0,
 		(int (*)()) 0,			(int  (*)()) 0,
 		(void (*)()) 0,			(int  (*)()) 0},
  { "sht",	TYPE_sht, 1, sizeof(sht), sizeof(@`sht@7), 0, (ptr) &sht_nil,
		(int  (*)()) @`shtFromStr@5,	(int (*)()) @`shtToStr@5,
 		(int  (*)()) shtCmp,		
 		(unsigned int  (*)()) shtHash, 	(void (*)()) shtConvert,
		(int  (*)()) 0, 		(int  (*)()) 0,
		(void (*)()) 0,			(void (*)()) 0,
 		(int (*)()) 0,			(int  (*)()) 0,
 		(void (*)()) 0,			(int  (*)()) 0},
  { "BAT",  	TYPE_int, 1, sizeof(bat), sizeof(@`bat@7), 0, (ptr) &int_nil,
 		(int  (*)()) batFromStr,	(int (*)()) batToStr,
 		(int  (*)()) intCmp, 		
 		(unsigned int  (*)()) intHash,	(void (*)()) intConvert,
		(int  (*)()) batFix,		(int  (*)()) batUnfix,
 		(void (*)()) BATpersistent,	(void (*)()) BATtransient,
 		(int (*)()) 0,			(int  (*)()) 0,
 		(void (*)()) 0,			(int  (*)()) 0},
  { "int",  	TYPE_int, 1, sizeof(int), sizeof(@`int@7), 0, (ptr) &int_nil, 
		(int  (*)()) intFromStr,	(int (*)()) @`intToStr@5,
	 	(int  (*)()) intCmp,		
 		(unsigned int  (*)()) intHash, 	(void (*)()) intConvert,
		(int  (*)()) 0, 		(int  (*)()) 0,
 		(void (*)()) 0, 		(void (*)()) 0,
 		(int (*)()) 0,			(int  (*)()) 0,
 		(void (*)()) 0,			(int  (*)()) 0},
  { "oid",  	TYPE_int, 1, sizeof(oid), sizeof(@`oid@7), 0, (ptr) &int_nil, 
 		(int  (*)()) OIDfromStr,	(int (*)()) OIDtoStr,
 		(int  (*)()) intCmp,		
 		(unsigned int  (*)()) intHash,	(void (*)()) intConvert,
		(int  (*)()) 0, 		(int  (*)()) 0,
 		(void (*)()) 0,			(void (*)()) 0,
 		(int (*)()) 0,			(int  (*)()) 0,
 		(void (*)()) 0,			(int  (*)()) 0},
#if SIZEOF_LONG==8
  { "ptr",  	TYPE_lng, 1, sizeof(ptr), sizeof(@`ptr@7), 0, (ptr) &lng_nil, 
		(int  (*)()) @`ptrFromStr@5,	(int (*)()) @`ptrToStr@5,
	 	(int  (*)()) lngCmp,		
		(unsigned int  (*)()) lngHash,	(void (*)()) lngConvert,	
#else
  { "ptr",  	TYPE_int, 1, sizeof(ptr), sizeof(@`ptr@7), 0, (ptr) &int_nil,
		(int  (*)()) @`ptrFromStr@5,	(int (*)()) @`ptrToStr@5,
	 	(int  (*)()) intCmp,		
		(unsigned int  (*)()) intHash,	(void (*)()) intConvert,	
#endif
		(int  (*)()) 0, 		(int  (*)()) 0,
		(void (*)()) 0, 		(void (*)()) 0,
 		(int (*)()) 0,			(int  (*)()) 0,
 		(void (*)()) 0,			(int  (*)()) 0},
  { "flt",  	TYPE_flt, 1, sizeof(flt), sizeof(@`flt@7), 0, (ptr) &flt_nil, 
		(int  (*)()) @`fltFromStr@5,	(int (*)()) @`fltToStr@5,
	 	(int  (*)()) fltCmp,		
 		(unsigned int  (*)()) intHash, 	(void (*)()) intConvert,
		(int  (*)()) 0,			(int  (*)()) 0,
 		(void (*)()) 0,			(void (*)()) 0,
 		(int (*)()) 0,			(int  (*)()) 0,
 		(void (*)()) 0,			(int  (*)()) 0},
  { "dbl",  	TYPE_dbl, 1, sizeof(dbl), sizeof(@`dbl@7), 0, (ptr) &dbl_nil, 
		(int  (*)()) @`dblFromStr@5,	(int (*)()) @`dblToStr@5,
		(int  (*)()) dblCmp,		
 		(unsigned int  (*)()) lngHash, 	(void (*)()) lngConvert,
		(int  (*)()) 0,			(int  (*)()) 0,
 		(void (*)()) 0,			(void (*)()) 0,
 		(int (*)()) 0,			(int  (*)()) 0,
 		(void (*)()) 0,			(int  (*)()) 0},
  { "lng",  	TYPE_lng, 1, sizeof(lng), sizeof(@`lng@7), 0, (ptr) &lng_nil, 
		(int  (*)()) lngFromStr,	(int (*)()) lngToStr,
 		(int  (*)()) lngCmp,		
 		(unsigned int  (*)()) lngHash,	(void (*)()) lngConvert,
		(int  (*)()) 0,			(int  (*)()) 0,
 		(void (*)()) 0,			(void (*)()) 0,
 		(int (*)()) 0,			(int  (*)()) 0,
 		(void (*)()) 0,			(int  (*)()) 0},
  { "str",  	TYPE_str, 1, sizeof(int), sizeof(int), 1, (ptr) &chr_nil,	
		(int  (*)()) strFromStr,	(int (*)()) strToStr,
		(int  (*)()) strCmp,		
	    	(unsigned int  (*)()) strHash,	(void (*)()) 0,
		(int  (*)()) 0, 		(int  (*)()) 0,
 		(void (*)()) strPut,		(void (*)()) 0,
 		(int (*)()) strLen,		(int (*)()) strHeap,
 		(void (*)()) strHeapConvert,	(int  (*)()) 0} ,
};
int     GDKatomcnt = TYPE_str + 1;
@
@}
@+ Atomic Type Interface
The collection of built-in types supported for BATs can be extended easily.
In essence, the user should specify conversion routines from values stored
anywhere in memory to its equivalent in the BAT, and vice verse.
Some routines are required for coercion and to support the BAT
administration.

A new type is incrementally build using the 
routine @%ATOMproperty(id, propery, value)@.
The parameter @%id@ denotes the type name; an entry is created if the type
is so far unknown. The @%property@ argument is a string identifying the
type description property to be updated. Valid property
names are @%size, tostr, fromstr, put, get, cmp, eq, del, hash, null@,
@%new, and heap@.

The size describes the amount of space to be reserved in the BUN.

The routine @%put@ takes a pointer to a memory resident copy and prepares
a persistent copy in the BAT passed. 
The inverse operation is @%get@. 
A new value can be directly included into the BAT using @%new@, which should
prepare a null-value representation.
A value is removed from the BAT
store using @%del@, which can take care of garbage collection and 
BAT administration. 

The pair @%tostr@ and @%fromstr@ should convert a reference to a persistent
value to a memory resident string equivalent. @%FromStr@ takes a 
string and applies a @%put@ to store it within a BAT. 
They are used to prepare for readable output/input and to support coercion.

The routines @%cmp@ and @%eq@ are comparisons routines used to build access 
structures. The @%null@ returns a reference to a null value representation.
@- 
The incremental atom construction uses hardwired properties.
This should be improved later on.
@c
void ATOMdelete(int id) {
	memset(BATatoms+id, 0, sizeof(atomDesc));
	if (id == GDKatomcnt-1) GDKatomcnt--;
}

int align(int n) {
        if (n==0) return 0;
        if ((n%8)==0) return 8;
        if ((n%4)==0) return 4;
        if ((n%2)==0) return 2;
        return 1;
}

void ATOMproperty(str id, str property, int (*arg) ()) {
	int t;
	MT_set_lock(GDKthreadLock, "ATOMproperty");
	t = ATOMindex(id); 
	if (t < 0) {
	    t = -t;
	    if (t == GDKatomcnt) {
		GDKatomcnt++; 
	    }
	    FATALcheck(GDKatomcnt==MAXATOMS, "ATOMproperty:too many types");
	    FATALcheck(strlen(id)>=IDLENGTH, "ATOMproperty:name too long");
	    memset(BATatoms+t, 0, sizeof(atomDesc));
	    strcpy(BATatoms[t].name, id); 
	    BATatoms[t].size = sizeof(int); /* default */
	    BATatoms[t].align = sizeof(int); /* default */
	    BATatoms[t].linear = 1; /* default */
	    BATatoms[t].storage = t;  /* default */
	}
	if (strcmp("size", property) == 0) {
	    if ((long) arg) {
		BATatoms[t].size = (int) (long) arg; 
		BATatoms[t].varsized = 0; 
		BATatoms[t].align = align((int) (long) arg); 
	    } else { 
		BATatoms[t].size = sizeof(int); 
		BATatoms[t].varsized = 1; 
		BATatoms[t].align = sizeof(int); 
	    } 
	} else if (strcmp("linear", property) == 0) {
		BATatoms[t].linear = (int) (long) arg; 
	} else if (strcmp("align", property) == 0) {
		BATatoms[t].align = (int) (long) arg; 
	} else if (strcmp("storage", property) == 0) {
	    	BATatoms[t] = BATatoms[(int)(long) arg]; /* copy from example */
	    	strcpy(BATatoms[t].name, id); /* restore name */ 
	} else if (strcmp("fromstr", property) == 0) {
		BATatoms[t].atomFromStr = (int (*)()) arg; 
	} else if (strcmp("tostr", property) == 0) {
		BATatoms[t].atomToStr = (int (*)()) arg; 
	} else if (strcmp("fix", property) == 0) {
		BATatoms[t].atomFix = (int (*)()) arg; 
	} else if (strcmp("unfix", property) == 0) {
		BATatoms[t].atomUnfix = (int (*)()) arg; 
	} else {
#define atomset(dst,val) oldval = (ptr) dst; if (val == NULL || dst == val) goto out; dst = val;
  	    ptr oldval = NULL;

	    if (strcmp("heap", property) == 0) {
		BATatoms[t].varsized = 1;
		atomset(BATatoms[t].atomHeap, (int (*)()) arg); 
	    } else if (strcmp("heapconvert", property) == 0) {
		atomset(BATatoms[t].atomHeapConvert, (void (*)()) arg); 
	    } else if (strcmp("check", property) == 0) {
		atomset(BATatoms[t].atomHeapCheck, (int (*)()) arg); 
	    } else if (strcmp("del", property) == 0) {
		atomset(BATatoms[t].atomDel, (void (*)()) arg); 
	    } else if (strcmp("convert", property) == 0) {
		atomset(BATatoms[t].atomConvert, (void (*)()) arg); 
	    } else if (strcmp("put", property) == 0) {
		atomset(BATatoms[t].atomPut, (void (*)()) arg); 
	    } else if (strcmp("null", property) == 0) {
		ptr atmnull = ((ptr (*)())arg)();
		atomset(BATatoms[t].atomNull, atmnull); 
	    }
	    if (oldval) goto out; 

	    /* these ADT functions *must* be equal for overloaded types */
	    if (strcmp("cmp", property) == 0) {
		atomset(BATatoms[t].atomCmp, (int (*)()) arg); 
	    } else if (strcmp("hash", property) == 0) {
		atomset(BATatoms[t].atomHash, (unsigned int (*)()) arg); 
	    } else if (strcmp("length", property) == 0) {
		atomset(BATatoms[t].atomLen, (int (*)()) arg); 
	    }
    if (BATatoms[t].storage != t)
    GDKerror("ATOMproperty(%s): overload of %s violates inheritance from %s.\n",
		ATOMname(t), property, ATOMname(BATatoms[t].storage));
/*
*/
	    BATatoms[t].storage = t;  /* critical redefine: undo remapping */
	}
out:	MT_unset_lock(GDKthreadLock, "ATOMproperty");
}

int ATOMindex(str nme) {
	int t, j=GDKatomcnt; 

	for (t = 0; t < GDKatomcnt; t++) {
		if (!BATatoms[t].name[0]) {
			if (j == GDKatomcnt) j = t;
		} else if (strcmp(nme, BATatoms[t].name) == 0) {
			return t; 
		}
		
	}
	if (strcmp(nme, "bat") == 0) {
		return TYPE_bat;
	}
	return -j; 
}

char *ATOMname(int t) {
        return  (t>=0 && t<GDKatomcnt && BATatoms[t].name)?
                               BATatoms[t].name:"null";
}

int ATOMdump() {
	int t; 
	for (t = 0; t < GDKatomcnt; t++) {
		stream_printf(GDKout, "%2d '%9s' (%3d) ", t, BATatoms[t].name, BATatoms[t].size); 
		if (BATatoms[t].atomFromStr) {
			stream_printf(GDKout, "\"FromStr\" "); 
		}
		if (BATatoms[t].atomToStr) {
			stream_printf(GDKout, "\"ToStr\" "); 
		}
		if (BATatoms[t].atomCmp) {
			stream_printf(GDKout, "\"Cmp\" "); 
		}
		if (BATatoms[t].atomNull) {
			stream_printf(GDKout, "\"Null\" "); 
		}
		if (BATatoms[t].atomHash) {
			stream_printf(GDKout, "\"Hash\" "); 
		}
		if (BATatoms[t].atomPut) {
			stream_printf(GDKout, "\"Put\" "); 
		}
		if (BATatoms[t].atomDel) {
			stream_printf(GDKout, "\"Del\" "); 
		}
		if (BATatoms[t].atomLen) {
			stream_printf(GDKout, "\"Len\" "); 
		}
		if (BATatoms[t].atomConvert) {
			stream_printf(GDKout, "\"Convert\" "); 
		}
		if (BATatoms[t].atomHeap) {
			stream_printf(GDKout, "\"NewHeap\" "); 
		}
		stream_printf(GDKout, "\n"); 
	}
	return 0;
}


@- nil values
All types have a single value designated as a NIL value. It designates
a missing value and it is ignored (forbidden) in several primitives.
The current policy is to use the smallest value in any ordered domain.
The routine atomnil returns a pointer to the nil value representation.
@{
@h
#define	GDK_chr_max ((chr) 127)
#define	GDK_chr_min ((chr) -128)
#define	GDK_sht_max ((sht) 32767)
#define	GDK_sht_min ((sht) -32768)
#define	GDK_int_max ((int) 2147483647)
#define	GDK_int_min ((int) (-2147483647-1))
#define	GDK_flt_max ((flt) 3.402823466E+38F)
#define	GDK_flt_min (-GDK_flt_max)
#define	GDK_lng_max (LL_CONSTANT( 9223372036854775807))
#define	GDK_lng_min (LL_CONSTANT(-9223372036854775807)-LL_CONSTANT(1))
#define	GDK_dbl_max ((dbl) 1.7976931348623157E+308)
#define	GDK_dbl_min (-GDK_dbl_max)
@c
chr		chr_nil = GDK_chr_min;
sht		sht_nil = GDK_sht_min;
int		int_nil = GDK_int_min;
flt		flt_nil = GDK_flt_min;
dbl		dbl_nil = GDK_dbl_min;
lng		lng_nil = GDK_lng_min;
str		str_nil = (str) &chr_nil;

ptr ATOMnil(int t) { 
	ptr src = ATOMnilptr(t);
	int len = ATOMlen(ATOMtype(t), src);
	ptr dst = GDKmalloc(len);
	memcpy(dst, src, len);
	return dst;
}

@- derived types
@T
In all algorithms accross GDK, you will switches on the types
\{ chr, sht, int, flt, dbl, lng, str\}. They respectively represent 
an octet, a 16-bit int, a 32-bit int, a 32-bit float, a 64-bit double,
a 64-bit int, and a pointer-sized location of a char-buffer (ended by 
a zero char).
\\
In contrast, the types \{ bit, ptr, bat, oid\} are derived types. They 
do not occur in the switches. The @%ATOMstorage@ macro maps them respectively
onto a {\tt chr}, {\tt int} (pointers are 32-bit), {\tt int}, and
{\tt int} {OIDs are 32-bit}.
\\
This approach makes it tractable to switch to 64-bits OIDs,
or to a fully 64-bits OS easily. One only has to map the {\tt oid}
and {\tt ptr} types to {\tt lng} instead of {\tt int}. 
\\
Derived types mimick their fathers in many ways. They inherit the {\tt size},
{\tt varsized}, {\tt linear}, {\tt null} and {\tt align} properties of their 
father.  The same goes for the ADT functions HASH, CMP, PUT, NULL,
DEL, LEN, and HEAP. So, a derived type differs in only two ways
from its father:
\begin{description}
\item [string representation]
the only two ADT operations specific for a derived type are FROMSTR
and TOSTR.
\item [identity]
(a {\tt bit} is really of a different type than {\tt chr}). The set of
operations on derived type values or BATs of such types may differ
from the sets of operations on the father type. 
\end{description}
@h
@{
#define ATOMstorage(t)		BATatoms[t].storage
#define ATOMsize(t)		BATatoms[t].size
#define ATOMalign(t)		BATatoms[t].align
#define ATOMfromstr(t,s,l,src)	BATatoms[t].atomFromStr(src,l,s)
#define ATOMnilptr(t)		BATatoms[t].atomNull
#define ATOMhash(t,src)		BATatoms[t].atomHash(src)
#define ATOMdel(t,hp,src)	if (BATatoms[t].atomDel) BATatoms[t].atomDel(hp,src)
#define ATOMvarsized(t)		((t != TYPE_void) && BATatoms[t].varsized)
#define ATOMlinear(t)		BATatoms[t].linear
#define ATOMtype(t)		((t == TYPE_void)?TYPE_oid:t)
#define ATOMfix(t,v)		if (BATatoms[t].atomFix)\
				BATatoms[t].atomFix(v)
#define ATOMunfix(t,v)		if (BATatoms[t].atomUnfix)\
				BATatoms[t].atomUnfix(v)
#define ATOMconvert(t,v,d)	if (BATatoms[t].atomConvert)\
				BATatoms[t].atomConvert(v,d)
#define ATOMheapConvert(t,hp,d)	if (BATatoms[t].atomHeapConvert)\
				BATatoms[t].atomHeapConvert(hp,d)

#define CONV_HTON               1
#define CONV_NTOH               0

@- 
Recursive BATs are a special case. You should modify their reference count.
@h
#define ATOMput(P1, P2, P3, P4)				\
{ int t_ = (P1);                                 	\
  if (t_ == TYPE_oid || t_ == TYPE_ptr || t_ > TYPE_str)\
        t_ = ATOMstorage(t_);                           \
  if (t_ <= TYPE_bat) {					\
	if (t_ <= TYPE_chr) {				\
		if (t_ != TYPE_void)			\
		*(chr *) (P3) = * (chr *) (P4);		\
	} else if (t_ == TYPE_sht) {			\
		*(sht *) (P3) = * (sht *) (P4);		\
	} else if (t_ == TYPE_bat) {			\
		BBPpersistent(*(bat*) (P4),TRUE);	\
		*(int *) (P3) = * (int *) (P4); 	\
	}						\
} else {						\
	if (t_ <= TYPE_flt) {				\
		*(int *) (P3) = *(int *) (P4); 		\
	} else if (t_ <= TYPE_lng) {			\
		*(lng *) (P3) = * (lng *) (P4); 	\
	} else if (t_ == TYPE_str) {			\
		(void) strPut(P2, (int*) (P3), (str) (P4));\
	} else {                                        \
	    if (BATatoms[t_].atomPut) {			\
		(*BATatoms[t_].atomPut)(P2, (int*) P3, P4);	\
	    } else {					\
		memcpy(P3, P4, ATOMsize(P1));		\
	    }						\
} }    }

#define ATOMreplace(P1,	P2, P3, P4)			\
{ int t_ = (P1);                                 	\
  if (t_ == TYPE_oid || t_ == TYPE_ptr || t_ > TYPE_str)\
        t_ = ATOMstorage(t_);                           \
  if (t_ <= TYPE_bat) {					\
	if (t_ <= TYPE_chr) {				\
		if (t_ != TYPE_void)			\
		*(chr *) (P3) = * (chr *) (P4);		\
	} else if (t_ == TYPE_sht) {			\
		*(sht *) (P3) = * (sht *) (P4);		\
	} else if (t_ == TYPE_bat) {			\
		BBPtransient(*(bat*) (P3), TRUE);	\
		BBPpersistent(*(bat*) (P4), TRUE);	\
		*(int *) (P3) = *(int *) (P4); 		\
	}						\
  } else {						\
	if (t_ <= TYPE_flt) {				\
		*(int *) (P3) = *(int *) (P4); 		\
	} else if (t_ <= TYPE_lng) {			\
		*(lng *) (P3) = * (lng *) (P4); 	\
	} else if (t_ == TYPE_str) {			\
		(void) strPut(P2, (int*) (P3), (str) (P4));\
	} else {					\
	    if (BATatoms[t_].atomDel) {		\
		ATOMdel(t_, P2,(int*) P3);		\
	    } 						\
	    if (BATatoms[t_].atomPut) {		\
		(*BATatoms[t_].atomPut) (P2, (int*) (P3), P4);\
	    } else {					\
		memcpy(P3, P4, ATOMsize(P1));		\
	    }						\
} }     }

#define GDK_STRHASHTABLE	(1<<10)
#define GDK_STRHASHMASK		(GDK_STRHASHTABLE-1)
#define GDK_STRHASHSIZE 	(GDK_STRHASHTABLE << 2)
#define GDK_ELIMDOUBLES(h)	((h)->free < GDK_ELIMLIMIT)
#define GDK_ELIMLIMIT		(1<<GDK_ELIMPOWER)
#define GDK_ELIMBASE(x)		(((x) >> GDK_ELIMPOWER) << GDK_ELIMPOWER)
#define GDK_ELIMPOWER		18	/* makes for a max 256KB hash table 
					 * ie 256 string bytes per hash bucket 
				 	 * ~ 16 strings of UP4(8<=len<=11)=12 + 4 bytes 
					 */

#endif /* _GDK_ATOMS_H_ */

@- Atomic ADT functions
@c
int ATOMlen(int t, ptr src) {
	int (*l)() = BATatoms[t].atomLen;
	return (l)?(*l)(src):ATOMsize(t);
}

int ATOMheap(int t, Heap* hp, int cap) {
	int (*h)() = BATatoms[t].atomHeap;
	return (h)?(*h)(hp, cap):0;
}

int ATOMcmp(int t, ptr l, ptr r) {
	switch(ATOMstorage(t)) {
	case TYPE_chr: return simple_CMP(l,r,chr);
	case TYPE_sht: return simple_CMP(l,r,sht);
	case TYPE_int: return simple_CMP(l,r,int);
	case TYPE_flt: return simple_CMP(l,r,flt);
	case TYPE_lng: return simple_CMP(l,r,lng);
	case TYPE_dbl: return simple_CMP(l,r,dbl);
	}
	return (l == r) ? 0 : atom_CMP(l,r,t);
}
@}

@
Atom print avoids coercion to strings for built-in types.
The comparison against the NULL value is hard coded for speed.
@c
#define LINE_LEN	60

int ATOMprint(int t, ptr p, stream* s) {
	int (*tostr)();
	
	if (p && (t>=0) && (t<GDKatomcnt) && (tostr=BATatoms[t].atomToStr)) {
	    if (t != TYPE_bat && t < TYPE_str) {
		char buf[dblStrlen], *addr=buf; /* use memory from stack */
		int sz = dblStrlen, l = (*tostr)(&addr, &sz, p);
		s->write(s, buf, l, 1);
		return l;
	    } else {
		char *buf = 0;
		int sz = 0, l = (*tostr)(&buf, &sz, p);
		s->write(s, buf, l, 1);
		GDKfree(buf);
		return l;
	    }
	} 
	s->write(s, "nil", 3, 1);
	return 3;
}


int ATOMformat(int t, ptr p, char** buf) {
	int (*tostr)();
	
	if (p && (t>=0) && (t<GDKatomcnt) && (tostr=BATatoms[t].atomToStr)) {
		int sz = 0, l = (*tostr)(buf, &sz, p);
		return l;
	} 
	strcpy(*buf=GDKmalloc(4), "nil");
	return 3;
}

ptr ATOMdup(int t, ptr p) {
   	int len = ATOMlen(t, p);
	ptr n = GDKmalloc(len);
	memcpy(n,p,len);
	return n;
}

@* Builtin Atomic Operator Implementations

@+ Atom-from-String Conversions 
These routines convert from string to atom. They are used during 
conversion and BAT import. In order to avoid unnecesarry malloc()/free()
sequences, the conversion functions have a meta 'dst' pointer to a
destination region, and an integer* 'len' parameter, that denotes the 
length of that region (a char region for ToStr functions, an atom region
from FromStr conversions). Only if necessary will the conversion
routine do a GDKfree()/GDKmalloc() sequence, and increment the 'len'.
Passing a pointer to a nil-ptr as 'dst' and/or a *len==0 is valid; the 
conversion function will then alloc some region for you.
@= atommem
	if (!*dst) {
		*dst = (@1 *) GDKmalloc(*len = @2);
	} else if (*len < (int) @2) {
		GDKfree(*dst);
		*dst = (@1 *) GDKmalloc(*len = @2);
	}
@= atomtostr
int @1ToStr(char ** dst, int *len, @1 *src) {
	@:atommem(char,@1Strlen)@
	if (*src == @1_nil) {
		strcpy(*dst, "nil");
		return 3;
	}
	snprintf(*dst, *len, "@2", (@3) *src);
	return strlen(*dst);
}
@c
#define num08(x)	((x) >= '0' && (x) <= '7')
#define num10(x)	GDKisdigit(x)
#define num16(x)	(GDKisdigit(x) || ((x)  >= 'a' && (x)  <= 'z') || ((x)  >= 'A' && (x)  <= 'Z'))
#define base10(x)	((x) - '0')
#define base08(x)	((x) - '0')
#define base16(x)	(((x) >= 'a')?((x) - 'a'):((x) >= 'A')?((x) - 'A'):(x)-'0')
#define mult08(x)	((x) << 3)
#define mult16(x)	((x) << 4)
#define mult10(x)	((x) + (x) + ((x) << 3))
#define mult7(x)	(((x) << 3) - (x))

int voidFromStr(str src, int *len, void **dst)
{
	return 0;
}

int voidToStr(str *dst, int *len, void *src) {
	@:atommem(char,3)@
	strcpy(*dst, "nil");
	return 3;
}

int chrFromStr(char *src, int *len, chr **dst) {
	int error = 0;
	chr base = 0;
	str p = src;

	@:atommem(chr,sizeof(chr))@
	while(GDKisspace(*p)) p++; 
	if (p[0] == 'n' && p[1] == 'i' && p[2] == 'l') {
		base = chr_nil; p += 3;
	} else if (p[0] && p[1] == 0) {
		base = *p++; 
	} else {
		if (*p != '\'') {
		    error = 1;
		} else if (p[1] == '\\' && num08(p[2])) { 
		    p += 2;
		    while (error == 0) {
			chr val = mult08(base) + base08(*p);
			if (val < base) error = 1;
			base = val; p++;
			if (!num08(*p)) break;
		    }
		} else {
		    base = p[1];
		}
		if (*p != '\'') {
			error = 1; p = src; 
		}
	} **dst = error?chr_nil:base;
	return p-src;
}

@:atomtostr(chr,'%c',chr)@

int bitFromStr(str src, int *len, bit **dst) {
	char *p=src;

	@:atommem(bit,sizeof(bit))@
	while(GDKisspace(*p)) p++;
	**dst = bit_nil;
	if (*p == '0') {
	   **dst = FALSE; p++;
	} else if(*p == '1') {
	   **dst = TRUE; p++;
	} else if (p[0] == 't' && p[1] == 'r' && p[2] == 'u' && p[3] == 'e') {
	   **dst = TRUE; p += 4;
	} else if (p[0] == 'f' && p[1] == 'a' && p[2] == 'l' && p[3] == 's' && p[4] == 'e') {
	   **dst = FALSE; p += 5;
	} else if (p[0] == 'n' && p[1] == 'i' && p[2] == 'l') {
	   p += 3;
	}
	return p-src;
}

int bitToStr(char **dst, int *len, bit *src) {
	@:atommem(char,6)@
	if (*src == chr_nil) {
	    strcpy(*dst, "nil");
	    return 3;
	} else if (*src) {
	    strcpy(*dst, "true");
	    return 4;
	}
	strcpy(*dst, "false");
	return 5;
}
	
int batFromStr(char *src, int *len, bat **dst) {
	char *s, *t, *r=src;
	int c, sign = 1, bid;

	@:atommem(bat,sizeof(bat))@
	while(GDKisspace(*r)) r++;
	if (*r == '<') r++;
	if (*r == '~') {
		r++; sign = -1;
	}
	t = r;
	while((c=*t) && (c=='_' || GDKisalnum(c))) t++;
	s = (char*) alloca(1+t-r);
	strncpy(s,r,t-r);
	s[t-r] = 0;
	bid = BBPindex(s);
	**dst = (bid==0)?int_nil:sign*bid;
	return t+(c=='>'?1:0)-src;
}

int batToStr(char **dst, int *len, bat *src) {
 	int i=*src;
	str s;
	if (*(bat*) src == bat_nil || (s = BBPname(i)) == NULL || *s == 0) {
		@:atommem(char,4)@
		strcpy(*dst,"nil");
		return 3;
	}
	i = strlen(s)+4;
	@:atommem(char,i)@
	snprintf(*(dst), *len, "<%s%s>", (*src<0)?"~":"", s);	
	return strlen(*dst);
}


@= numfromstr
int @1FromStr(char* src, int * len, @1 **dst) {
	int minus = 0, error = 0;
	@1 base = 0;
	str q, p = src;

	@:atommem(@1,sizeof(@1))@
	while(GDKisspace(*p)) p++; 
	if (p[0] == 'n' && p[1] == 'i' && p[2] == 'l') {
		base = @1_nil; p += 3;
	} else {
	 	if (*p == '-' || *p == '+') {
			if (*p++ == '-') minus = 1;
		}
		if (!num10(*p)) {
			error = 1; p = src;
		}
		while(*p == '0') p++;
		for(q=p; num10(*p); p++) {
			base = mult10(base) + base10(*p);
		}
		if (q-p > @2  || (q-p == @2 && strncmp(q,"@3",@2) > 0)) {
			error = 1; /* overflow */
		}
		if (sizeof(@1) == 8 && p[0] == 'L' && p[1] == 'L') {
			p += 2;
		}
	} **dst = error?@1_nil:(minus?-base:base);
	return p-src;
}
@c
@:numfromstr(sht,5,32767)@
@:atomtostr(sht,%hd,int)@

@:numfromstr(int,10,2147483647)@
@:atomtostr(int,%d,int)@

@:numfromstr(lng,19,9223372036854775807)@
@:atomtostr(lng,%lld,lng)@
@
int lngToStr(char **dst, int *len, lng *src) {
	char *p;
	int l=0;
    
	long ll; /* it turned out to be nontrivial to get a long long printed */
	@:atommem(char,lngStrlen)@
	p = *dst; *p = 0;
    	if (*src == lng_nil) {
		strcpy(p, "nil");
		return 3;
	} 
	if (*src < LL_CONSTANT(0)) {
		*p++ = '-'; *p = 0;
	}
	ll = (*(lng*)src)/LL_CONSTANT(100000000000000);
	if (ll) {
		sprintf(p, "%ld", (ll<0)?-ll:ll); 
		l += strlen(p);
	}
	ll = ((*(lng*) src) % LL_CONSTANT(100000000000000)) / LL_CONSTANT(10000000);
	if (l) {
		sprintf(p+l, "%07ld", (ll<0)?-ll:ll);	
	} else if (ll) {
		sprintf(p, "%ld", (ll<0)?-ll:ll);	
	}
	l += strlen(p+l);
	ll = (long) ((*(lng*) src) % LL_CONSTANT(10000000));
	if (l) {
		sprintf(p+l, "%07ld", (ll<0)?-ll:ll);	
	} else {
		sprintf(p, "%ld", (ll<0)?-ll:ll);	
	}
	return strlen(*dst);
}
@c
int ptrFromStr(char* src, int * len, ptr **dst) {
	int error = 0;
	long base = 0;
	str p = src;

	@:atommem(ptr,sizeof(ptr))@
	while(GDKisspace(*p)) p++; 
	if (p[0] == 'n' && p[1] == 'i' && p[2] == 'l') {
		error = 1; p += 3;
	} else {
	 	if (p[0] == '0' && (p[1] == 'x' || p[1] == 'X')) {
			p += 2;
		}
		if (!num16(*p)) {
			error = 1; p = src;
		}
		while (error == 0) {
			long val = mult16(base) + base16(*p);
			if (val < base) error = 1;
			base = val; p++;
			if (!num16(*p)) break;
		}
	} **dst = error?((ptr) ptr_nil):((ptr) base);
	return p-src;
}
@:atomtostr(ptr,%lx,unsigned long)@

int dblFromStr(char* src, int* len, dbl **dst) {
	char *p = src;
	dbl d = strtod(src, &p); 	

	/* alloc memory */
	@:atommem(dbl,sizeof(dbl))@

	if (p == src || d > GDK_dbl_max || d <= GDK_dbl_min) {
		**dst = dbl_nil; /* default return value is nil */
	} else {
		**dst = d;
	}
	return p-src;
}
@:atomtostr(dbl,%g,double)@

int fltFromStr(char* src, int* len, flt **dst) {
	char *p = src;
	dbl d = strtod(src, &p); 	

	/* alloc memory */
	@:atommem(flt,sizeof(flt))@

	if (p == src || d > GDK_flt_max || d <= GDK_flt_min) {
		**dst = flt_nil; /* default return value is nil */
	} else {
		**dst = (flt) d;
	}
	return p-src;
}
@:atomtostr(flt,%g,float)@
@}

@+ String Atom Implementation
The Built-in type string is funnelled partly through the atom extension
library. The main reason is to limit the number of built-in types
in the BAT library kernel. Moreover, an extra indirection for strings is less
harmfull then for manipulation of, lets' say int.

The internal representation of strings is without escape sequences.
When the string is printed we should add the escapes back into it.

The current escape policy is that '"' and "'" can be prepended by a
backslash. Furthermode, the backslash may be followed by three
digit octal number to denote a character.

@- Automatic Double Elimination

Because in many typical situations lots of double string values occur
in tables, the string insertion provides automatic double elimination.
To do this, a GDK_STRHASHTABLE(=1024) bucketet hashtable is hidden in the first 
4096 bytes of the string heap, consisting of integer offsets of the first 
string hashing on that bucket in the heap. Furthermore, the first 4 bytes 
before each string in the heap is an integer offset to the next string hashing 
on the same number.
@
@
However, in many other situations the cardinality of string columns is large,
or the string values might even be unique. In this case, our fixed-size hash 
table will start to overflow quickly. Therefore, after the hash table is full
(this is measured very simplisticly by looking whether the string heap exceeds a 
heap size = GDK\_ELIMLIMIT -- done this way to keep compatability with old bat images) 
we flush the hash table. If one views the string heaps as consequent chunks
of size GDK\_ELIMLIMIT bytes, then all strings within one chunk are double-eliminated.
There is a macro GDK\_ELIMBASE(offset) that computes the base of the chunk in which
a certain byte-offset falls.
@
@  
This is a departure from our previous policy of not looking at the hash tables at 
all after overflow occured. The advantage of the new approach is that if we have 
a value distribution that is skewed (ie some values are very frequent), these 
values will always be double eliminated, saving a considerable amount of space. 
Disadvantage of the approach is that we always have to reserve space for the next 
pointer (4 byte integer offset) that is stored right in front of the string (and 
consequently have to keep all string chunks and offsets aligned to 4). All this 
translates into some wasted space. However, if there are that many different strings 
that the hash table overflows, the strings must be relatively long and the relative 
storage overhead should be low.
@
@
Notice that this mechanism enables keeps a certain linear storage property
in the string heaps. This is important if we want to take a BATslice on a BAT
by simply loading or mmap()ping slices of the BAT files on disk into memory.
This is relevant in order to process a very large BAT iteratively by taking slices
in order top reduce memory consumption. Notice that if there are few different string 
values, the hash table has not overflowed, and the string heap size will be small 
(ie $<$ GDK\_ELIMLIMIT), so in those cases it is not a problem to load the entire string heap.
If the hash table *has* overflowed, we want to be able to only map a slice of the 
string heap as well. Now, given that the first string in the BAT-slice is called F1 
and its heap offset is O1 and the last string in the slice is F2 and its 
offset is O2, then the slice we should take from the string heap is: 
@
@
\begin{verbatim}
GDK_ELIMBASE(F1) .. MAX(GDK_ELIMBASE(F2)+GDK_ELIMLIMIT), O2+strlen(F2))
\end{verbatim}
@
@
The below routine strElimDoubles() can be used to check whether all 
strings are still being double-eliminated in the original hash-table.
Only then, we know that unequal offset-integers in the BUN array means
guarantee different strings in the heap. This optimization is made at some 
points in the GDK. Make sure you check GDK\_ELIMDOUBLES before assuming this!
@c
int strElimDoubles(Heap *h) {
	return GDK_ELIMDOUBLES(h);
} 

@- Nil Value
The nil value for strings equates with the empty string. Future extensions may
consider using a <length,value> pair where the length can be used to indicate
a missing value.
@{
@h
#define GDK_STRNIL(s)	 ((s) == NULL || *(chr*) (s) == GDK_chr_min)
#define GDK_STRLEN(s)	 ((GDK_STRNIL(s)?1:strlen(s))+1)
#define GDK_STRCMP(l,r)	 ((*(l) < *(r))?-1:(*(l) > *(r))?1:(GDK_STRNIL(l) && GDK_STRNIL(r))?0:strcmp(l,r))
@c
int strNil(str s)   	 { return GDK_STRNIL(s); }
int strLen(str s)        { return GDK_STRLEN(s); }
int strCmp(str l, str r) { return GDK_STRCMP(l,r); }

void strHeap(Heap *d, int cap) {
	int size;
	int *h, *e; 

	cap = MAX(cap, BATTINY);
	size = (GDK_STRHASHTABLE+1)*sizeof(int) + MIN(GDK_ELIMLIMIT, cap*12);
	HEAPalloc(d, size, 1);
	d->free = GDK_STRHASHTABLE*sizeof(int); 
	h = (int*) d->base; 
	for (e = h; e < h + GDK_STRHASHTABLE; e++) {
		*e = 0; 
	}
}


@- Hash Function 
@T
The old hash function takes a maximum of 10 probes at equal distance and 
multiplies these together. This hash function does not take all characters into
account and may therefore run into trouble (e.g. on sets of strings that have
a long mean length and where only a small portion of the characters differs).

Therefore we switch to new simple hash function that xors and rotates all 
characters together. 

We preserve the old hash function for use inside string heaps. This ensures that
old bats with these string heaps will still be compatible. TODO: replace by strHash.
@h
#define GDK_ROTATE(x,y,z,m) ((((x) << (y)) & ~(m)) | (((x) >> (z)) & (m)))

#define GDK_STRHASH(x,y) {                   \
    str _s = (str) (x);                      \
    for((y)=0; *_s; _s++) {                  \
        (y) = GDK_ROTATE(y, 4, 28, 15) ^ *_s;\
    }}
@c
unsigned int strHash(str s) {
    unsigned int res;
    GDK_STRHASH(s,res);
    return res;
}

static INLINE 
unsigned int strOldHash(str s) {
	unsigned int h, len; 
	char *t;

	if (GDK_STRNIL(s)) {
		return 0; 
	}
	while(*s == ' ') {
		s++; /* discard leading spaces */
	}
	for(t=s; *t; t++);
	while(t > s && t[-1] == ' ') {
		t--; /* discard trailing spaces */
	}
	len = t-s;
	h = *s++; /* get first char */
	if (len-- > 1) {
	    h = mult7(h) + t[-1]; /* get last char */
	    if (len-- > 1) {
		int i=0, j = MAX(len,8), k = j*MIN(len, 8); 
		/* get 8 intermediate chars. 8==2^3 */
		for(i=0; i < k; i+=j) {
			h = mult7(h) + s[i >> 3];
		}
	    }
	}
	return h & 0x7fffffff;
} 

@- 
The @%strPut@ routine. The routine @%strLocate@ can be used to identify
the location of a string in the heap if it exists. Otherwise it returns
zero.
@c
int strLocate(Heap *h, str v) {
	int *htab = (int*) h->base; 
	int *l, *e = htab + (strOldHash(v) & GDK_STRHASHMASK); 

	if (*e) {
		for (l = e; *l; l = (int*) (h->base + *l)) {
			str x = (str) (h->base + *l + sizeof(int)); 
			if (GDK_STRCMP(v, x) == 0) {
				return *l + sizeof(int); 
			}
		}
	}
	return 0; 
}

/* convert the integers in the implicit hash table structure */ 
void strHeapConvert(Heap *h,int dir) {
	int *htab = (int*) h->base; 
	int *l, i, j; 

	if (dir == CONV_HTON){
	    for(i=0; i<GDK_STRHASHTABLE; i++) {
		for (l= htab+i; (j=*l) != 0; l=(int*) (h->base + j)) {
			*l = normal_int_SWAP(j);
		}
	    }
	} else {
	    for(i=0; i<GDK_STRHASHTABLE; i++) {
		for (l= htab+i; (j=*l) != 0; l=(int*) (h->base + *l)) {
			*l = normal_int_SWAP(j);
		}
	    }
	}
}

int strPut(Heap *h, int *dst, str v) {
	int *l, off, i = GDK_STRLEN(v);
	int len = (((i-1) >> 2) + 2) << 2; /* round up to 4-byte alignment + 4 (next pointer) */
	int elimlimit = GDK_ELIMBASE(h->free) + GDK_ELIMLIMIT;

	/* search hash-table, if double-elimination is still in place */
	off = strOldHash(v) & GDK_STRHASHMASK; 
	for (l = ((int*) h->base) + off; *l; l = (int*) (h->base + *l)) {
		str x = (str) (h->base + *l + sizeof(int)); 
		if (GDK_STRCMP(v, x) == 0) {
			*dst = *l + sizeof(int); /* already in heap; do not insert! */
			return 0; 
		}
 	}

	/* flush the hash table if it becomes too big (implies !GDK_ELIMDOUBLES) */ 
	if (h->free + len > elimlimit) {
		memset(h->base, 0, GDK_STRHASHSIZE); 
	} 

	/* check heap for space (limited to a certain maximum after which nils are inserted) */
	if (h->free + len >= h->size) {
		size_t newsize = len + h->size*BATMARGIN;

		/* XXX: if the heap just becomes too big, insert a nil (last 4 bytes are free) */
		if (newsize > GDK_VM_MAXSIZE) {
			h->free = h->size;
			h->base[h->size - 4] = GDK_chr_min;
			*dst = h->size - 4;
			return 0;
		}
		if (h->free + len < h->maxsize) {
			/* if there is reserved space, first use the reserved space */
			newsize = MIN(newsize,h->maxsize); 
        	}
		HEAPextend(h, newsize);
	}

	/* insert string in hash table and copy into int the heap */
	l = (int*) (h->base + h->free);
	*(l++) = ((int*) h->base)[off]; 
	((int*) h->base)[off] = h->free;
	*dst = h->free + sizeof(int);
	h->free += len;
	memcpy((char*) l, v, i); 

	return 0; 
}

@-
Convert an "" separated string to a GDK string value.
@c

int strFromStr(char *src, int *len, char** dst) {
	str p, start = NULL, cur = src;
	int l = 1, escaped = FALSE;

	while(GDKisspace(*cur)) cur++;
	if (*cur != '"') {
		if (*dst != NULL && *dst != str_nil) {
			GDKfree(*dst);
		}
		*dst = ATOMnil(TYPE_str);
		*len = 2;
		return strncmp(cur,"nil",3)?0:((cur+3)-src);
	} 

	/* scout the string to find out its length and correctness */
	for(start = ++cur; *cur != '"' || escaped; cur++) {
		if (*cur == 0) { 
			start = NULL; break;
		} else if (*cur == '\\' && escaped == FALSE) {
			escaped = TRUE;
		} else {
			escaped = FALSE; l++;
		}
	}

	/* alloc new memory */
	p = *dst;
	if (*dst == NULL || (*dst==str_nil)) {
		p = *dst = (char *) GDKmalloc(*len = l);
	} else if (*len < l) {
		GDKfree(*dst);
		p = *dst = (char *) GDKmalloc(*len = l);
	}

	/* copy it in, while performing the correct escapes */
	if (start == NULL) {
		*p = GDK_chr_min; /* error => str_nil */
	} else for(cur = start; *cur != '"' || escaped ; cur++) {
		if (escaped) {
			if (*cur == 'n') { 
				*p++ = '\n';
			} else if (*cur == 't') { 
				*p++ = '\t';
			} else if ((cur[0] >= '0' && cur[0] <= '7') &&
				   (cur[1] >= '0' && cur[1] <= '7') &&
				   (cur[2] >= '0' && cur[2] <= '7'))
			{
				*p++ =  (cur[2] & 7 	  | 
				       ((cur[1] & 7) <<3) | 
				       ((cur[0] & 7) <<6));
				cur += 2;
			} else {
			        *p++ = *cur;
			}
			escaped = FALSE;
		} else if (*cur == '\\') {
			escaped = TRUE;
		} else {
			*p++ = *cur;
		}
	}
	*p++ = 0;
	return (cur + 1) - src;
}

@-
Convert a GDK string value to something printable.
@c
#define allowed_chr(ch) ((ch)==0 || GDKisgraph((ch)) || GDKisspace((ch)) || \
		         GDKisspecial((ch)) || GDKisupperl((ch)) || GDKislowerl((ch)))

int strToStr(char** dst, int *len, char* src) {
	int l=1;
	if (GDK_STRNIL((str) src)) {
		@:atommem(char,4)@
		strcpy(*dst, "nil");
		return 3;
	} else {
		char *s, *r = (char*) src;
		int cur=0, end, sz=0;
		for(end=0; src[end]; end++) 
		    if (src[end] == '\t' || src[end] == '\n' ||
		        src[end] == '\\' || src[end] == '"') 
		    {   sz += 2;
		    } else if (!allowed_chr(src[end])) {
			sz += 4;
		    } else {
			sz++;
		    }
		@:atommem(char,sz+3)@
		
		for(s=*dst; cur<end; cur++)
		    if (r[cur] == '\t') {
		        s[l++] = '\\'; s[l++] = 't';
		    } else if (r[cur] == '\n') {
		        s[l++] = '\\'; s[l++] = 'n';
		    } else if (r[cur] == '\\') {
		        s[l++] = '\\'; s[l++] = '\\';
		    } else if (r[cur] == '"') {
		        s[l++] = '\\'; s[l++] = '"';
		    } else if (!allowed_chr(r[cur])) {
        		sprintf(s+l, "\\%03o", (unsigned char) r[cur]); l+=4;
		    } else {
		        s[l++] = r[cur];
		    }
		s[0] = s[l++] = '"';
		s[l] = 0;
	}
	return l;
}

@+ Unique OIDs
The basic type OID represents unique values. Refinements should be
considered to link oids in time order.
@c
@{
oid	GDKoid[GDKMAXDB], GDKflushed[GDKMAXDB];
int	GDKdb;
@-
Init the shared array of oid bases.
@c
int OIDinit(){
        int i = GDKMAXDB;
        while(i--) GDKflushed[i] = GDKoid[i] = 0;
	return 0;
}

@-
Make up some new OID for a specified database, based on the current time.
@c
oid OIDrand(int db) { 
	return (db << SERVERBITS) + (OIDnumber & 1000000);
} 
@-
Initialize the current OID number to be starting at 'o'. 
@c
oid OIDbase(oid o){
	MT_set_lock(MT_system_lock, "OIDbase");
	GDKdb = (OIDserver & o) >> SERVERBITS;	
	GDKoid[GDKdb] = o;
	MT_unset_lock(MT_system_lock, "OIDbase");
	return (oid) o;
}

oid OIDseed(unsigned int o) {
	oid t, *p = (oid*) GDKoid;

	MT_set_lock(MT_system_lock, "OIDseed");
	GDKdb = (OIDserver & o) >> SERVERBITS;	
 	t = OIDrand(GDKdb);
	if (o > t) t = o;
	if (p[GDKdb] >= t) t = p[GDKdb];
	else p[GDKdb] = t; 
	MT_unset_lock(MT_system_lock, "OIDseed");
	return (oid) t;
}
@-
Initialize a sequence of OID seeds (for a sequence of database)
as stored in a string.
@c
int OIDread(str s) {
	oid new, *p=&new;
	int l=sizeof(oid);

	while (GDKisspace(*s)) s++;
	while (GDKisdigit(*s)) {
		s += OIDfromStr(s, &l, &p);
		while(GDKisspace(*s)) s++;
		new = OIDseed(new);
	}
	return new;
}
@-
Write the current sequence of OID seeds to a file in string format.
@c
int OIDflushdelta = 100000;

int OIDwrite(stream *s) {
	int i, ret = 0;
	MT_set_lock(MT_system_lock, "OIDwrite");
	for(i=0; i < GDKMAXDB; i++) { 
		if (GDKoid[i]) {
			GDKflushed[i] = GDKoid[i] + OIDflushdelta;
			ATOMprint(TYPE_oid, GDKflushed+i, s);
			if (s->write(s, " ", 1, 1) < 0) ret = -1;
		}
	}
	MT_unset_lock(MT_system_lock, "OIDwrite");
	return ret;
}

int OIDdirty() {
	int i;
	for(i=0; i < GDKMAXDB; i++) { 
		if (GDKoid[i] && GDKoid[i] > GDKflushed[i]) {
			return TRUE;
		}
	}
	return FALSE;
}
@-
Reserve a range of unique OIDs for a specified database.
@c
oid OIDnewdb(int inc, int db) {
	oid ret;
	MT_set_lock(MT_system_lock, "OIDnewdb");
	if (!GDKoid[db]) GDKoid[db] = OIDrand(db);
	ret = GDKoid[db]; 
	GDKoid[db] += inc; 
	MT_unset_lock(MT_system_lock, "OIDnewdb");
	return ret; 
}
@-
Reserve a range of unique OIDs for the current database.
@c
oid OIDnew(int inc) {
	return OIDnewdb(inc, GDKdb);
}
@-
String conversion routines. 
@c
int OIDfromStr(char *src, int *len, oid **dst) {
	int ui, *uip = &ui, db=0, *dbp = &db, l=sizeof(int), pos = 0;
	str p = src;

	@:atommem(oid,sizeof(oid))@
	**dst = oid_nil;
	while(GDKisspace(*p)) p++;
	if (GDKisdigit(*p)) {
		pos = intFromStr(p,&l,&uip); p += pos;
		if (pos > 0 && p[0] == '@') {
			if (!GDKisdigit(p[1])) pos = 0;
			else pos = intFromStr(++p,&l,&dbp); 
			p += pos;
		}
		if (pos > 0 && ui >= 0 && ui < (1<<SERVERBITS) && db >= 0 && db < 4) {
		 	**dst = ui | (db<<SERVERBITS);
		}
	} 
	if (pos <= 0) p = src;
	return p - src;
}

int OIDtoStr(char** dst, int *len, oid *src) {
	unsigned int ui;
	@:atommem(char,oidStrlen)@
	if (*src == oid_nil) {
		strcpy(*dst, "nil");
		return 3;
	}
	ui = *(oid*)src;
	snprintf(*dst, *len, "%u\@%d", ui&OIDnumber, (ui&OIDserver)>>SERVERBITS);
	return strlen(*dst);
}
@
@}
