@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2004 CWI.
@' All Rights Reserved.

@f gdk
@T
% define titlepage @t The Goblin Database Kernel
@v Version 3.05
@a Martin L. Kersten & Peter Boncz

@* The Inner Core
@T
The innermost library of the Monet Database System is formed by
the library called GDK, an abbreviation of Goblin Database Kernel.
Its development was originally rooted in the design of a pure
active-object-oriented programming language, before development
was shifted towards a re-usable database kernel engine.

GDK is a C/C++ library that provides ACID
properties on a DSM model~\cite{Copeland85}, using main-memory
database algorithms~\cite{Garcia-Molina92}, built on virtual-memory
OS primitives and multi-threaded parallelism.
Its implementation has undergone various changes over its decade
of development, many of which were driven by external needs to
obtain a robust and fast database system.

The coding scheme explored in GDK has also laid a foundation to
communicate over time experiences and to provide (hopefully)
helpful advice near to the place where the code-reader needs it.
Of course, over such a long time the documentation diverges from
reality. Especially in areas where the environment of this package
is being described. 
Consider such deviations as historic landmarks, e.g. crystallization
of brave ideas and mistakes rectified at a later stage.

@+ Short Outline
The facilities provided in this implementation are:
@T
\begin{itemize}
\item[-] GDK or Goblin Database Kernel routines for session management
\item[-] BAT routines that define the primitive operations on the
database tables (BATs).
\item[-] BBP routines to manage the BAT Buffer Pool (BBP).
\item[-] ATOM routines to manipulate primitive types, define new types
using an ADT interface.
\item[-] HEAP routines for manipulating heaps: linear spaces of memory
that are GDK's vehicle of mass storage (on which BATs are built).
\item[-] DELTA routines to access inserted/deleted elements within a
transaction.
\item[-] HASH routines for manipulating GDK's built-in linear-chained
hash tables, for accelerating lookup searches on BATs.
\item[-] IDX routines for manipulating GDK's built-in binary-tree
indexes, for accelerating range searches on BATs.
\item[-] ACC routines that define the ADT for user defined search
accelerators.
\item[-] TM routines that provide basic transaction management primitives.
\item[-] TRG routines that provided active database support.
\item[-] ALIGN routines that implement BAT alignment management.
\end{itemize}
@T
The Binary Association Table (BAT) is the lowest level of storage
considered in the Goblin runtime system~\cite{Goblin}.  A BAT is a
self-descriptive main-memory structure that represents the {\bf binary
relationship} between two atomic types.  
@
The association can be defined over:
@T
\begin{description}
\item[void:] virtual-OIDs: a densely ascending column of OIDs (takes zero-storage).
            Values start from the "seqbase" (usually 0@0). A nil seqbase makes the 
            entire column nil.  Monet's BUN accessmethods BUNhead(b,p)/BUNtail(b,p) 
            instantiate a value on-the-fly by looking at the position p in BAT b.
\item[bit:] Booleans, implemented as one byte values.
\item[chr:] A single character (8 bits {\tt integer}s). 
            DEPRECATED: for storing text (Unicode not supported).
\item[sht:] Short integers (16-bit {\tt integer}s).
\item[int:] This is the C {\tt int} type (32-bit). 
\item[oid:] Unique {\tt long int} values uses as object identifier. Highest bit cleared always.
	    Thus, oids-s are 31-bit numbers on 32-bit systems, and 63-bit numbers on 64-bit systems.
\item[ptr:] Memory pointer values. DEPRECATED.
            CAN ONLY BE STORED IN TRANSIENT BATs (pointers are supposed to be transient).
\item[flt:] The IEEE {\tt float} type.
\item[dbl:] The IEEE {\tt double} type.
\item[lng:] Longs: the C {\tt long long} type (64-bit integers).
\item[str:] UTF-8 strings (Unicode). A zero-terminated byte sequence.
\item[bat:] Bat descriptor. This allows for recursive tables. 
            CAN ONLY BE STORED IN TRANSIENT BATs (not to complicate transaction mgmt).
\end{description}
@T 
This model can be used as a back-end model underlying other -- higher
level -- models, in order to achieve {\bf better performance} and 
{\bf data independence} in one go. The relational model and
the object-oriented model can be mapped on BATs by vertically
splitting every table (or class) for each attribute. Each such a
column is then stored in a BAT with type {\bf bat[oid,attribute]}, where
the unique object identifiers link tuples in the different BATs.
Relationship attributes in the object-oriented model hence are
mapped to {\bf bat[oid,oid]} tables, being equivalent to the concept of
{\em join indexes}~\cite{Valduriez87}.
@
The set of built-in types can be extended with user-defined types
through an ADT interface.  They are linked with the kernel to obtain
an enhanced library, or they are dynamically loaded upon request.
@T
Types can be derived from other types. They represent something different
than that from which they are derived, but their internal storage management
is equal. This feature facilitates the work of extension programmers, by
enabling reuse of implementation code, but is also used to keep the GDK code
portable from 32-bits to 64-bits machines: the {\tt oid} and {\tt ptr} types
are derived from {\tt int} on 32-bits machines, but is derived from {\tt lng}
on 64 bits machines. This requires changes in only two lines of code each.
@T
To accelerate lookup and search in BATs, GDK supports two built-in
search accelerators: hash tables and index trees. We chose
implementations efficient for main-memory: bucket chained hash and
binary AVL trees~\cite{LehCar86,Analyti92}. 
@
An ADT mechanism for extending the supported search accelerators
exists,analogous to atomic type extensibility.
@
BATs are built on the concept of heaps, which are large pieces of main
memory. They can also consist of virtual memory, in case the working
set exceeds main-memory. In this case, GDK supports operations that
cluster the heaps of a BAT, in order to improve performance of its
main-memory.


@- Rationale

The rationale for choosing a BAT as the building block for both
relational and object-oriented system is based on the following
observations: 

@T 
\begin{itemize} 
\item Given the fact that CPU speed and main-memory increase in
current workstation hardware for the last years has been exceeding 
IO access speed increase, traditional disk-page oriented algorithms 
do no longer take best advantage of hardware, in most database operations. 

Instead of having a disk-block oriented kernel with a large memory
cache, we choose to build a main-memory kernel, that only under large data
volumes slowly degrades to IO-bound performance, comparable to
traditional systems~\cite{boncz95,boncz96}.

\item Traditional (disk-based) relational systems move too much data
around to save on (main-memory) join operations.

The fully decomposed store (DSM~\cite{Copeland85})
assures that only those attributes of a relation that are needed,
will have to be accessed.

\item In a distributed system one should avoid passing large amounts
of useless data around, which calls for semi-join based algorithms
instead of the commonly used full joins.

\item The data management issues for a binary association is much
easier to deal with than traditional {\em struct}-based approaches
encountered in relational systems.

\item Object-oriented systems often maintain a double cache, one with the 
disk-based representation and a C pointer-based main-memory structure. 
This causes expensive conversions and replicated storage management.

GDK does not do such 'pointer swizzling'. It used virtual-memory ({\tt
mmap()}) and buffer management advice ({\tt madvise()}) OS primitives to
cache only once. Tables take the same form in memory as on disk,
making the use of this technique transparent~\cite{oo7}.
\end{itemize}
@
A RDBMS or OODBMS based on BATs strongly depends on our ability
to efficiently support tuples and to handle small joins, respectively.

@T
The remainder of this document describes the Goblin Database kernel
implementation at greater detail. It is organized as follows:
\begin{itemize}
\item{\bf\ref{GDK Interface}:}\\

It describes the global interface with which GDK sessions can be
started and ended, and environment variables used.

\item{\bf\ref{Binary Association Tables}:}\\

As already mentioned, these are the primary data structure of GDK.
This chapter describes the kernel operations for creation, destruction
and basic manipulation of BATs and BUNs (i.e. tuples: Binary UNits).

\item{\bf\ref{BAT Buffer Pool}:}\\

All BATs are registered in the BAT Buffer Pool. This directory is used
to guide swapping in and out of BATs. Here we find routines that guide
this swapping process.

\item{\bf\ref{GDK Extensibility}:}\\

Atoms and Search Accelerators can be defined using an ADT interface.
For using them, there are also unified interfaces. We will add an
interface for user-defined storage modes (multi-level storage) here.

There is also an interface to extend the GDK library with 
dynamically linked object code.

\item{\bf\ref{GDK Utilities}:}\\

Memory allocation and error handling primitives are provided. Layers
built on top of GDK should use them, for proper system monitoring.
Thread management is also included here.

\item{\bf\ref{Transaction Management}:}\\

For the time being, we just provide BAT-grained concurrency and global
transactions. Work is needed here.

\item{\bf\ref{BAT Alignment}:}\\
Due to the mapping of multi-ary datamodels onto the BAT model, 
we expect many correspondences among BATs, e.g.  {\em bat(oid,attr1),.. 
bat(oid,attrN)} vertical decompositions. Frequent activities will be
to jump from one attribute to the other ('bunhopping'). If the head
columns are equal lists in two BATs, merge or even array lookups
can be used instead of hash lookups. The alignment interface makes
these relations explicitly manageable. 

In GDK, complex data models are mapped with DSM on binary tables.
Usually, one decomposes {\em N}-ary relations into {\em N} BATs with
an {\bf oid} in the head column, and the attribute in the tail column.
There may well be groups of tables that have the same sets of {\bf
oid}s, equally ordered. The alignment interface is intended to make
this explicit.  Implementations can use this interface to detect this
situation, and use cheaper algorithms (like merge-join, or even array
lookup) instead.

\item{\bf\ref{BAT Iterators}:}\\

Iterators are C macros that generally encapsulate a complex for-loop. 
They would be the equivalent of cursors in the SQL model. The macro
interface (instead of a function call interface) is chosen to achieve
speed when iterating main-memory tables.

\item{\bf\ref{Common BAT Operations}:}\\

These are much used operations on BATs, such as aggregate functions
and relational operators. They are implemented in terms of BAT- and
BUN-manipulation GDK primitives.  
\end{itemize}
@

@+ Interface Files
@T
\label{GDK Interface}
In this section we summarize the user interface to the GDK library.
It consist of a header file (gdk.h) and an object library (gdklib.a),
which implements the required functionality. The header file must be
included in any program that uses the library. The library must be
linked with such a program.

@- Database Context

The databases are administered in a central ASCII file accessible through
the environment variable MONETHOME. 
The context of the server is derived from the real user id.
The first entry in the context file that matches the user name
(and optionally the database name) is used for initialization.
@
The Goblin database kernel should be initialized before being used.
First, the database
directory is closed for other servers running at the same time.
Second, performance enhancements may take effect, such as locking
the code into memory (if the OS permits) and preloading the 
data dictionary.
An error at this stage normally lead to an abort.
@{
@h
#ifndef _GDK_H_
#define _GDK_H_

#include <monet_utils.h>

/* standard includes upon which all configure tests depend */
#include <stdio.h>
#if HAVE_SYS_TYPES_H
# include <sys/types.h>
#endif
#if HAVE_SYS_STAT_H
# include <sys/stat.h>
#endif
#if STDC_HEADERS
# include <stdlib.h>
# include <stddef.h>
#else
# if HAVE_STDLIB_H
#  include <stdlib.h>
# endif
#endif
#if HAVE_STRING_H
# if !STDC_HEADERS && HAVE_MEMORY_H
#  include <memory.h>
# endif
# include <string.h>
#endif
#if HAVE_STRINGS_H
# include <strings.h>
#endif
#if HAVE_INTTYPES_H
# include <inttypes.h>
#else
# if HAVE_STDINT_H
#  include <stdint.h>
# endif
#endif
#if HAVE_UNISTD_H
# include <unistd.h>
#endif

#include <ctype.h>      /* isspace etc. */

#ifdef HAVE_SYS_FILE_H
# include <sys/file.h>
#endif
#ifdef HAVE_SYS_PARAM_H
# include <sys/param.h>  /* MAXPATHLEN */
#endif

#if HAVE_DIRENT_H
# include <dirent.h>
# define NAMLEN(dirent) strlen((dirent)->d_name)
#else
# define dirent direct
# define NAMLEN(dirent) (dirent)->d_namlen
# if HAVE_SYS_NDIR_H
#  include <sys/ndir.h>
# endif
# if HAVE_SYS_DIR_H
#  include <sys/dir.h>
# endif
# if HAVE_NDIR_H
#  include <ndir.h>
# endif
#endif

#if HAVE_SYS_WAIT_H
# include <sys/wait.h>
#endif
#ifndef WEXITSTATUS
# define WEXITSTATUS(stat_val) ((unsigned)(stat_val) >> 8)
#endif
#ifndef WIFEXITED
# define WIFEXITED(stat_val) (((stat_val) & 255) == 0)
#endif

#ifdef __cplusplus
extern "C" { 
#endif

#include "gdk_system.h"	
#include "gdk_posix.h"	
#include <stream.h>	

#undef MIN
#undef MAX
#define MAX(A,B)	((A)<(B)?(B):(A))
#define MIN(A,B)	((A)>(B)?(B):(A))

/* defines from ctype with casts that allow passing char values */
#define GDKisprint(c)   isprint((int) ((unsigned char) (c)))
#define GDKisspace(c)   isspace((int) ((unsigned char) (c)))
#define GDKisalnum(c)   isalnum((int) ((unsigned char) (c)))
#define GDKisgraph(c)   isgraph((int) ((unsigned char) (c)))
#define GDKisdigit(c)   (((unsigned char) (c)) >= '0' && ((unsigned char) (c)) <= '9')
#define GDKisxcntrl(c)  (((unsigned char) (c)) >= 128 && ((unsigned char) (c)) <= 160)
#define GDKisspecial(c) (((unsigned char) (c)) >= 161 && ((unsigned char) (c)) <= 191)
#define GDKisupperl(c)  (((unsigned char) (c)) >= 192 && ((unsigned char) (c)) <= 223)
#define GDKislowerl(c)  (((unsigned char) (c)) >= 224 && ((unsigned char) (c)) <= 255)

#define GDKPROP		6	/*	use one spare! */
#define MONETHOME	"MONETHOME"
#ifndef NATIVE_WIN32
#define BATDIR          "bat/"
#define DELDIR          "bat/DELETE_ME/"
#define BAKDIR          "bat/BACKUP/"
#define LEFTDIR         "bat/LEFTOVERS/"
#else
#define BATDIR          "bat\\"
#define DELDIR          "bat\\DELETE_ME\\"
#define BAKDIR          "bat\\BACKUP\\"
#define LEFTDIR         "bat\\LEFTOVERS\\"
#endif
#define DBLOGFILE	"MonetLog"

#define PATHLENGTH	256		/* maximum file pathname length */ 

@
@}

@- GDK session handling
@T
{\tt \begin{tabular}{|lll|}\hline
int & GDKinit & (char *db, char *dbfarm)\\
int & GDKexit & (int status)\\
\hline\end{tabular}}
@
The session is bracketed by @%GDKinit@ and @%GDKexit@. Initialization involves
setting up the administration for database access, such as memory allocation
for the database buffer pool.
During the exit phase any pending transaction is aborted and the database is
freed for access by other users.
A zero is returned upon encountering an erroneous situation.
@
During system startup some environment variables are set.
@- Definitions
The interface definitions for the application programs are shown
below.  The global variables should not be modified directly.
@{
@h
#define NEG(A)	(((int)(A))>0?-((int)(A)):((int)(A)))
#define ABS(A)	(((int)(A))>0?((int)(A)):-((int)(A)))

#ifndef TRUE
#define TRUE	1
#define FALSE	0
#endif
#define BOUND2BTRUE	2		/* TRUE, and bound to be so */

#define IDLENGTH	64		/* maximum BAT id length */
#define OLDLENGTH	32		/* old max  BAT id length */
#define BATMARGIN	1.2		/* extra free margin for new heaps */ 
#define BATTINY		50		/* extra fixed margin for BATS */

#define TYPE_void	0		
#define TYPE_bit	1		
#define TYPE_chr	2		
#define TYPE_sht	3		
#define TYPE_bat	4		/* BAT id: index in BBPcache */
#define TYPE_int	5		
#define TYPE_oid	6		
#define TYPE_ptr	7		/* C pointer! */
#define TYPE_flt	8
#define TYPE_dbl	9		
#define TYPE_lng	10		
#define TYPE_str	11		
#define TYPE_any	255		/* limit types to <255! */

typedef signed char	bit; 		
typedef signed char	chr; 		
typedef short		sht;
typedef size_t		oid; 		
#define SIZEOF_OID	SIZEOF_SIZE_T
typedef int		bat; 		/* Index into BBP */
typedef void*		ptr; 		/* Internal coding of types */
typedef float		flt; 		
typedef double		dbl;
typedef char*		str; 		

#if SIZEOF_INT==8
#	define LL_CONSTANT(val)     (val)
#elif SIZEOF_LONG==8
#	define LL_CONSTANT(val)     (val##L)
#elif defined(HAVE_LONG_LONG)
#	define LL_CONSTANT(val)     (val##LL)
#elif defined(HAVE___INT64)
#	define LL_CONSTANT(val)     (val##i64)
#endif

/* Base types for all architectures.  These types work on IRIX (64 & 32)
   and for gcc on Linux. */
typedef unsigned char gdk_uint8;
typedef char gdk_int8;

typedef unsigned short gdk_uint16;
typedef short gdk_int16;

typedef unsigned int gdk_uint32;
typedef int gdk_int32;

#ifdef HAVE_LONG_LONG
typedef unsigned long long gdk_uint64;
typedef long long gdk_int64;
#define LLFMT "%lld"		/* format to print a long long */
#define ULLFMT "%llu"		/* format to print a unsigned long long */
#else
#ifdef HAVE___INT64
typedef unsigned __int64 gdk_uint64;
typedef __int64 gdk_int64;
#define LLFMT "%I64d"		/* format to print a __int64 */
#define ULLFMT "%I64u"		/* format to print a unsigned __int64 */
#endif
#endif

/* define printf formats for printing size_t and ssize_t variables */
#if defined(__STDC_VERSION__) && __STDC_VERSION__ >= 199901
#define SZFMT "%zu"
#define SSZFMT "%zd"
#elif SIZEOF_SIZE_T == SIZEOF_INT
#define SZFMT "%u"
#define SSZFMT "%d"
#elif SIZEOF_SIZE_T == SIZEOF_LONG
#define SZFMT "%lu"
#define SSZFMT "%ld"
#elif SIZEOF_SIZE_T == SIZEOF_LONG_LONG || SIZEOF_SIZE_T == SIZEOF___INT64
#define SZFMT ULLFMT
#define SSZFMT LLFMT
#else
#error no definition for SZFMT/SSZFMT
#endif

/* define printf formats for printing ptrdiff_t variables */
#if defined(__STDC_VERSION__) && __STDC_VERSION__ >= 199901
#define PDFMT "%td"
#elif SIZEOF_PTRDIFF_T == SIZEOF_INT
#define PDFMT "%d"
#elif SIZEOF_PTRDIFF_T == SIZEOF_LONG
#define PDFMT "%ld"
#elif SIZEOF_PTRDIFF_T == SIZEOF_LONG_LONG || SIZEOF_PTRDIFF_T == SIZEOF___INT64
#define PDFMT LLFMT
#else
#error no definition for PDFMT
#endif

/* define printf format for printing pointer values */
#if defined(__STDC_VERSION__) && __STDC_VERSION__ >= 199901
#define PTRFMT		"%p"
#define PTRFMTCAST	/* no cast needed */
#elif SIZEOF_VOID_P == SIZEOF_INT
#define PTRFMT		"%x"
#define PTRFMTCAST	(unsigned int)
#elif SIZEOF_VOID_P == SIZEOF_LONG
#define PTRFMT		"%lx"
#define PTRFMTCAST	(unsigned long)
#elif SIZEOF_VOID_P == SIZEOF_LONG_LONG
#define PTRFMT		"%llx"
#define PTRFMTCAST	(unsigned long long)
#elif SIZEOF_VOID_P == SIZEOF___INT64
#define PTRFMT		"%I64x"
#define PTRFMTCAST	(unsigned __int64)
#else
#error no definition for PTRFMT
#endif

typedef char 		*BUN; 		/* pointer in some heap. */
typedef	char		long_str[IDLENGTH];/* standard GDK static string */
typedef	char		short_str[OLDLENGTH];/* old GDK small static string */

typedef size_t hash_t;		/* type used for hash tables */
typedef size_t var_t;		/* type used for heap index of var-sized BAT */
#if SIZEOF_SIZE_T == SIZEOF_INT	/* a type compatible with var_t */
#define TYPE_var	TYPE_int
#else
#define TYPE_var	TYPE_lng
#endif

@- Checking and Error definitions:
@h
typedef enum { GDK_FAIL, GDK_SUCCEED } gdk_return;

gdk_export int 		GDKsilent; 	/* should GDK shut up? */

#define FATALcheck(tst,	msg) if (tst) GDKfatal(msg);
#define ERRORcheck(tst,	msg) if (tst) { GDKerror(msg); return 0; }
#define WARNcheck(tst,	msg)  if (tst) GDKwarning(msg)
#define BATcheck(tst,	msg) if (tst == NULL) {				\
                               	GDKerror("%s: BAT required.\n",msg);	\
                               	return 0;				\
                       	   }

/* needed for mel */
#define ATOMextern(t)	(ATOMstorage(t) >= TYPE_str)

#define TYPEcastable(t1,t2)	(ATOMtype(t1)==ATOMtype(t2))
#define TYPEequal(t1,t2)	(ATOMtype(t1)==ATOMtype(t2))
#define TYPEcomp(t1,t2)	(ATOMstorage(ATOMtype(t1))==ATOMstorage(ATOMtype(t2)))
#define TYPEerror(t1,t2)	(!TYPEcomp(t1,t2))
#define TYPEcheck(t1,t2)						\
	if (TYPEerror(t1,t2)) {						\
		GDKerror("TYPEcheck: Incompatible types %s and %s.\n",		\
			ATOMname(t2), ATOMname(t1));			\
		return 0;						\
	} else if (!TYPEcomp(t1,t2)) {					\
		GDKwarning("Interpreting %s as %s.\n",			\
			ATOMname(t2), ATOMname(t1));			\
	}
#define BATcompatible(P1,P2) {						\
	ERRORcheck(P1 == NULL, "BATcompatible: BAT required\n");	\
	ERRORcheck(P2 == NULL, "BATcompatible: BAT required\n");	\
	if (TYPEerror(BAThtype(P1),BAThtype(P2)) ||			\
	    TYPEerror(BATttype(P1),BATttype(P2)))			\
	{								\
		GDKerror("Incompatible operands.\n");			\
		return 0;						\
	}								\
	if (BAThtype(P1) != BAThtype(P2) &&                             \
            ATOMtype((P1)->htype) != ATOMtype((P2)->htype)) {           \
		GDKwarning("Interpreting %s as %s.\n",			\
			ATOMname(BAThtype(P2)), ATOMname(BAThtype(P1)));\
	}								\
	if (BATttype(P1) != BATttype(P2) &&                             \
            ATOMtype((P1)->ttype) != ATOMtype((P2)->ttype)) {           \
		GDKwarning("Interpreting %s as %s.\n",			\
			ATOMname(BATttype(P2)), ATOMname(BATttype(P1)));\
	}								\
}
@}
@{
@h
typedef struct TN {
 	BUN 		v; 		/* value associated with this node. */
	struct TN 	*l;		/* left subtree: smaller nodes. */
	struct TN	*r; 		/* rigth subtree: bigger nodes. */
} Tnode; 

typedef struct {
	int 		type; 		/* type of index entity */
	size_t	 	lim; 		/* collision list size */
	hash_t	 	mask; 		/* number of hash buckets-1 (power of 2) */
	hash_t*		hash;		/* hash table */
	hash_t*		link;		/* collision list */
} Hash; 

typedef struct {
	Tnode*		root;		/* root of index structure. */
	Tnode*		stack;		/* stack with space for nodes */
	Tnode*		free;		/* index of first free node. */	
	BUN*		base;		/* lowest BUN in heap. */
	BUN*		first;		/* first BUN in index order. */
	BUN*		last;	 	/* last BUN in index order. */
} IDX, *Index;

typedef struct {
	size_t		offset;		/* offset from start of file (bytes).*/
       	size_t		maxsize;	/* maximum realloc size (bytes) */
	size_t		free;		/* index where free area starts. */
	size_t		size; 		/* size of the heap (bytes)*/
	BUN		base; 		/* base pointer in memory. */
	sht		storage; 	/* storage status. */
	bit		copied; 	/* a copy of an existing map. */
	chr		padding; 	/* not used. */
	str		filename;	/* file containing image of the heap */
} Heap;
@
@}

@+ Binary Association Tables
@T
\label{Binary Association Tables}
Having gone to the previous preliminary definitions, we will
now introduce the structure of Binary Association Tables (BATs)
in detail. They are the basic storage unit on which GDK is modeled.
@T
The BAT holds an unlimited number of binary associations, called
BUNs ({\bf Binary UNits}).  The two attributes of a BUN are called 
{\bf head} (left) and {\bf tail} (right) in the remainder of this 
document.  

\begin{center}
{\hspace{10pt}\epsfxsize=0.55\textwidth
\epsffile{bat1.eps}
\label{fig1}{\em The BAT}}
\end{center}

The above figure shows what a BAT looks like. It consists of two
columns, called head and tail, such that we have always binary tuples
(BUNs). The overlooking structure is the {\bf BAT
record}.  It points to a heap structure called the {\bf BUN heap}.
This heap contains the atomic values inside the two columns. If they
are fixed-sized atoms, these atoms reside directly in the BUN heap. If
they are variable-sized atoms (such as string or polygon), however,
the columns has an extra heap for storing those (such 
{\bf variable-sized atom heaps} are then
referred to as {\bf Head Heap}s and {\bf Tail Heap}s). The BUN heap then
contains integer byte-offsets (fixed-sized, of course) into a head-
or tail-heap.
@
The BAT record can also contain pointers to search accelerators
associated with one of the columns.
@T
The BUN heap contains a contiguous range of BUNs. It starts after
the {\tt hole} pointer, and finishes at the end in the {\tt free}
area of the BUN. All BUNs after the {\tt inserted} pointer have been
added in the last transaction (and will be deleted on a transaction
abort). All BUNs between the {\tt deleted} pointer and the {\tt hole}
have been deleted in this transaction (and will be reinserted at a
transaction abort).

@-
The location of a certain BUN in a BAT
may change between successive library routine invocations.  Therefore, one
should avoid keeping references into the BAT storage area for long
periods.
@
Passing values between the library routines and the enclosing C
program is primarily through value pointers of type @%ptr@. Pointers
into the BAT storage area should only be used for retrieval. Direct
updates of data stored in a BAT is forbidden. The user should adhere
to the interface conventions to guarantee the integrity rules and to
maintain the (hidden) auxiliary search structures.

@- The BAT record

The elements of the BAT structure are introduced in the remainder.
Instead of using the underlying types hidden beneath it, one should 
use a @%BAT@ type that is supposed to look like this:
@T
\begin{verbatim}  
typedef struct {
          /* static BAT properties */
          str    batId;            /* bat name */
          bat    batCacheid;       /* bat id: index in BBPcache */
          int    batPersistence;   /* persistence mode */
          bit    batCopiedtodisk;  /* BAT is saved on disk? */
          bit    batSet;           /* all tuples in the BAT are unique? */
          int    batStore;         /* multi-level storage mode */
          sht    batElmshift       /* log2 of width  */ 
          sht    batElmsize        /* width in byte of the BUNs */ 
          /* dynamic BAT properties */
          int    batHeat;          /* heat of BAT in the BBP */
          sht    batDirty;         /* BAT modified after last commit? */
          bit    batDirtydesc;     /* BAT descriptor specific dirty flag */
          bit    batDirtybuns;     /* BUN heap specific dirty flag */
          Heap*  batBuns;          /* Heap where the buns are stored */
          /* DELTA status */
          BUN    batDeleted;       /* first deleted BUN */
          BUN    batHole;          /* empty BUN before the first alive BUN */
          BUN    batInserted;      /* first inserted BUN */
          /* Head properties */
          int    htype;            /* Head type number */
          str    hatom;            /* name of head type */
          str    hident;           /* name for head column */
          bit    hkey;             /* head values shoul be unique? */
          bit    hsorted;          /* are head values currently ordered? */
          bit    hvarsized;        /* for speed: head type is varsized? */
	  oid	 halign;	   /* alignment OID for head. */
	  oid	 halignflushed;	   /* alignment in previous transaction */
          bit    hheapdirty;       /* head heap specific dirty flag */
          bit    haccdirty;        /* head accelerator specific dirty flag */
          /* Head storage */
          int    hloc;             /* byte-offset in BUN for head elements */
          Heap   hheap;            /* heap for varsized head values */
          Hash   hhash;            /* linair chained hash table on head */
          Index  hidx;             /* binary tree index on head */
          int    hacctype;         /* user-defined accelerator on head */
          str    haccname;         /* accelerator name */
          Heap   haccelerator;     /* storage for head accelerator */
          /* Tail properties */
          int    ttype;            /* Tail type number */
          str    tatom;            /* name of tail type */
          str    tident;           /* name for tail column */
          bit    tkey;             /* tail values should be unique? */
          bit    tsorted;          /* are tail values currently ordered? */
          bit    tvarsized;        /* for speed: tail type is varsized? */
	  oid	 talign;	   /* alignment OID for head. */
	  oid	 talignflushed;	   /* alignment in previous transaction */
          bit    theapdirty;       /* tail heap specific dirty flag */
          bit    taccdirty;        /* tail accelerator specific dirty flag */
          /* Tail storage */
          int    tloc;             /* byte-offset in BUN for tail elements */
          Heap   theap;            /* heap for varsized tail values */
          Hash   thash;            /* linair chained hash table on tail */
          Index  tidx;             /* binary tree index on tail */
          int    tacctype;         /* user-defined accelerator on tail */
          str    taccname;         /* accelerator name */
          Heap   taccelerator;     /* storage for tail accelerator */
 } BAT;
\end{verbatim}

The internal structure of the {\bf BAT} record is in fact much more complex, 
but GDK programmers should refrain of making use of that. 

This complex structure has two reasons:
\begin{itemize} 
\item to allow for a BAT to exist in two incarnations at the time: the 
{\em normal view} and the {\em reversed view}. Each bat {\bf b} has a 
{\tt BATmirror({\bf b})} which has the negative {\tt cacheid} of b in the BBP.

Since we don't want to pay cost to keep both views in line with each other
under BAT updates, we work with shared pieces of memory between
the two views. An update to one will thus automatically update the other.

\begin{center}
{\hspace{10pt}\epsfxsize=0.55\textwidth
\epsffile{bat2.eps}

\label{fig2}{\em How the BAT is perceived, and how it is laid out in reality.}}
\end{center}

\item in the same line, we allow {\tt synchronized BATs} (BATs with identical 
head columns, and marked as such in the {\bf BAT Alignment} interface) now to 
be clustered horizontally. 
\end{itemize} 
@

@{
@h
typedef struct {
	sht		headtype;	/* type id. */
	sht		tailtype;	/* type id. */
	int		headloc; 	/* offset into bun. */
	int		tailloc; 	/* offset into bun. */
	bit		headkey;	/* duplicates allowed? */
	bit		tailkey;	/* duplicates allowed? */
	bit		headvarsized; 	/* varsized(>0) or fixedsized(0). */
	bit		tailvarsized; 	/* varsized(>0) or fixedsized(0). */
	sht		bunshift;	/* log2 of bunwidth */
	unsigned short	bunwidth;	/* byte-width of BUN array */
	oid		hseq;		/* start of dense head sequence */
	oid		tseq;		/* start of dense tail sequence */
} Dimensions; 

typedef struct {
	short_str	id; 		/* BAT id storage. */
	chr 		dirtyflushed;	/* saved dirty marker */
	chr		copiedtodisk;   /* once written */
	sht		persistence;	/* should the BAT persist on disk? */
	int		stamp;		/* BAT recent creation stamp */
	sht		set;  		/* real set semantics */
	sht		restricted;	/* access priviliges */
	MT_Id 		tid;		/* which thread created it */
	bit             keeparound;     /* keeparound even if refcnt == 0 */
	chr             dummy[3];       /* not used yet */
	chr 		convert;	/* endian-conversion needed? */
	chr 		dirty;		/* general dirty marker */
        chr             descdirty;  	/* bat descriptor dirty marker */
        chr             bunsdirty;  	/* bun heap dirty marker */
	bat		parentid;	/* cache id of VIEW parent bat */ 
} BATrec;

typedef struct {
	/* bunheap data */	
	Heap		buns;		/* space for the buns. */ 
	/* delta status administration */	
        BUN		deleted;	/* start of deleted elements */
        BUN		hole;		/* to store next deletion */
        BUN		inserted;	/* start of inserted elements */
	int		sharecnt;	/* VIEW share count */
	char		map_dirty;	/* new mmap mode present */
	char		map_buns;	/* mmap mode for bun heap */
	char		map_hheap;	/* mmap mode for head atom heap */
	char		map_theap;	/* mmap mode for tail atom heap */
	char		map_hacc;	/* mmap mode for head accelerator heap */
	char		map_tacc;	/* mmap mode for tail accelerator heap */
} BUNrec;

typedef struct {
	short_str	id;	 	/* label for head/tail column */
	short_str	atom; 		/* head atom name */
	Heap		heap;		/* space for the head/tail column. */
	Hash		hash;		/* hash index on head/tail column. */
	IDX		idx;		/* tree index on head/tail column. */ 
	Heap		accelerator;	/* contains heap accelerator. */ 
	chr		heapdirty;	/* specific heap dirty marker */
	chr		accdirty;	/* specific accelerator dirty marker */
	sht		acctype;	/* accelerator-type */
	short_str	accname;	/* accelerator-name */
        bit             sorted;         /* 0=false, 1=true; */
        bit             dense;          /* 0=false, 1=true; */
	oid		align;		/* OID for sync alignment */
	oid		alignflushed;	/* OID for sync alignment */
	size_t		nokey[2]; 	/* positions that prove key ==FALSE */
	size_t		nosorted; 	/* position that proves sorted==FALSE */
	size_t		nodense; 	/* position that proves dense==FALSE */
	int             aggr[3];        /* space for keeping size, card and hasnil aggregates */
	int		accCopiedtodisk;
} COLrec;

typedef struct {
	/* static bat properties */
	int		GDKversion; 	/* FIRST! */
	str		batId;		/* BAT id: points to P->id */
        bat		batCacheid;    	/* index into BBP */ 
	Dimensions	dims;		/* BAT dimensions */	
	Heap*		batBuns;	/* pointer to U->buns */
	/* static column properties */
	Heap*		hhash_heap;	/* hash table: points into H->hash */
	Heap*		thash_heap;	/* hash table: points into T->hash */
	Heap*		hidx_heap;	/* index tree: points into H->idx */
	Heap*		tidx_heap;	/* index tree: points into T->idx */
	/* dynamic column properties */
	COLrec*		H;		/* column info */
	COLrec*		T;		/* column info */
	/* dynamic bat properties */
	BATrec*		P;		/* cache and sort info */
	BUNrec*		U;		/* cache and sort info */
	/* void hack fields */
	int 		void_tid;	/* thread that reads this bat */
	int 		void_cnt;	/* nr of reads */
	oid		void_seq1;
	oid 		void_seq2;
} BAT;

@-
The different parts of which a BAT consists are physically stored 
next to each other in the @%BATstore@ type.
@h
typedef struct {
        BAT		B;		/* storage for BAT descriptor */
        COLrec		H;		/* storage for head column */
        COLrec		T;		/* storage for tail column */
        BATrec		P;		/* storage for BATrec */
        BUNrec		U;		/* storage for BUNrec */
	long_str	fullid;		/* new full bat name */
} BATstore;

typedef int (*GDKfcn)();

/* macros's to hide complexity of BAT structure */
#define batKeeparound	P->keeparound	
#define batPersistence	P->persistence	
#define batCopiedtodisk	P->copiedtodisk	
#define batSet		P->set	
#define batStore	P->store
#define batDirtyflushed	P->dirtyflushed
#define batDirty	P->dirty
#define batConvert	P->convert
#define batDirtydesc	P->descdirty
#define batDirtybuns	P->bunsdirty
#define hhash		H->hash
#define thash		T->hash
#define hidx		H->idx
#define tidx		T->idx
#define hheapdirty	H->heapdirty
#define theapdirty	T->heapdirty
#define haccdirty	H->accdirty
#define taccCopiedtodisk T->accCopiedtodisk
#define haccCopiedtodisk H->accCopiedtodisk
#define taccdirty	T->accdirty
#define batHole		U->hole
#define batInserted	U->inserted
#define batDeleted	U->deleted
#define batParentid	P->parentid
#define batStamp	P->stamp
#define batSharecnt	U->sharecnt
#define batRestricted	P->restricted
#define batLastused	P->lastused
#define creator_tid	P->tid
#define batSaved	U->saved
#define batElmsize	dims.bunwidth	
#define batElmshift	dims.bunshift	
#define htype		dims.headtype
#define ttype		dims.tailtype
#define hloc		dims.headloc
#define tloc		dims.tailloc
#define hkey		dims.headkey
#define tkey		dims.tailkey
#define hvarsized	dims.headvarsized
#define tvarsized	dims.tailvarsized
#define hseqbase	dims.hseq
#define tseqbase	dims.tseq
#define hsorted		H->sorted
#define tsorted		T->sorted
#define hdense		H->dense
#define tdense		T->dense
#define hheap		H->heap		
#define theap		T->heap
#define hident		H->id
#define tident		T->id
#define hacctype	H->acctype
#define tacctype	T->acctype
#define haccname	H->accname
#define taccname	T->accname
#define haccelerator	H->accelerator
#define taccelerator	T->accelerator
#define hatom		H->atom
#define tatom		T->atom
#define halign		H->align
#define talign		T->align
#define halignflushed	H->alignflushed
#define talignflushed	T->alignflushed

#define batMapdirty	U->map_dirty
#define batMapbuns	U->map_buns
#define batMaphheap	U->map_hheap
#define batMaptheap	U->map_theap
#define batMaphacc	U->map_hacc
#define batMaptacc	U->map_tacc
@
@}

@- Heap Management
Heaps are the low-level entities of mass storage in BATs. Currently,
they can either be stored on disk, loaded into memory, or memory mapped.
@T
{\tt \begin{tabular}{|lll|}\hline
int & HEAPalloc & (Heap *h, size\_t nitems, size\_t itemsize);\\
int & HEAPfree & (Heap *h);\\
int & HEAPextend & (Heap *h, size\_t size);\\
int & HEAPload & (Heap *h, str nme,ext, int trunc);\\
int & HEAPsave & (Heap *h, str nme,ext);\\
int & HEAPcopy & (Heap *dst,*src);\\
int & HEAPdelete & (Heap *dst, str o, str ext);\\
\hline\end{tabular}}

@
These routines should be used to alloc free or extend heaps;
they insulate you from the different ways heaps can be accessed. 
@{
@h
gdk_export int	HEAPalloc   (Heap *h, size_t nitems, size_t itemsize);
gdk_export int	HEAPfree    (Heap *h);
gdk_export int	HEAPextend  (Heap *h, size_t size);
gdk_export int	HEAPload    (Heap *h, str nme, str ext, int trunc);
gdk_export int	HEAPsave    (Heap *h, str nme, str ext);
gdk_export int	HEAPcopy    (Heap *dst, Heap *src);
gdk_export size_t HEAPsubcopy (Heap *dst, Heap *src, size_t size, size_t offset);
gdk_export int	HEAPdelete  (Heap *h, str o, str ext);
gdk_export size_t HEAPvmsize  (Heap *h);
gdk_export size_t HEAPmemsize (Heap *h);
@}
@- Internal HEAP Chunk Management
@T
Heaps are used in BATs to store data for variable-size atoms.
The implementor must manage malloc()/free() functionality for
atoms in this heap. A standard implementation is provided here.

{\tt \begin{tabular}{|lll|}\hline
void & HEAP\_initialize  & (Heap* h, size\_t nbytes, size\_t nprivate, int align )\\
void & HEAP\_destroy     & (Heap* h)\\
int  & HEAP\_malloc      & (Heap* heap, size\_t nbytes)\\
void & HEAP\_free        & (Heap *heap, size\_t block)\\
int  & HEAP\_private     & (Heap* h)\\
void & HEAP\_printstatus & (Heap* h)\\
void & HEAP\_check       & (Heap* h)\\
\hline\end{tabular}}
@
The heap space starts with a private space that is left untouched by
the normal chunk allocation.  You can use this private space e.g. to 
store the root of an rtree 
@%HEAP_malloc@ allocates a chunk of memory on the heap, and return an 
index to it.  @%HEAP_free@ frees a previously allocated chunk 
@%HEAP_private@ returns an integer index to private space.
@{
@h
/* structure used by HEAP_check functions */
typedef struct {
	size_t minpos;		/* minimum block byte-index */
	size_t maxpos;		/* maximum block byte-index */
	int alignment;		/* block index alignment */
	size_t *validmask;	/* bitmap with all valid byte-indices 
	                         * first bit corresponds with 'minpos';
                                 * 2nd bit with 'minpos+alignment', etc
				 */
} HeapRepair;

gdk_export void HEAP_initialize(
	Heap* heap,	/* nbytes -- Initial size of the heap. */
	size_t nbytes,	/* alignment -- for objects on the heap. */
	size_t nprivate,   /* nprivate -- Size of private space */
	int alignment   /* alignment restriction for allocated chunks */
);

gdk_export void HEAP_initialize_compact(
	Heap* heap,	/* nbytes -- Initial size of the heap. */
	size_t nbytes,	/* alignment -- for objects on the heap. */
	size_t nprivate,   /* nprivate -- Size of private space */
	int alignment,  /* alignment restriction for allocated chunks */
	int (*sizefcn)(ptr)  /* BATatoms[].atomLen function */
);

gdk_export var_t HEAP_malloc     (Heap* heap, size_t nbytes);
gdk_export void HEAP_free        (Heap *heap, var_t block);  
gdk_export size_t HEAP_private   (Heap* h);   
gdk_export void HEAP_checkformat (Heap* h);
gdk_export int  HEAP_check       (Heap* h, HeapRepair *hr);
gdk_export void HEAP_init        (Heap *heap, int tpe);  
gdk_export int  HEAP_mmappable   (Heap *heap);  

#define HEAP_index(HEAP,INDEX,TYPE)	((TYPE *)((char *) (HEAP)->base + (INDEX)))

@}
@- BAT construction 
@T
{\tt \begin{tabular}{|lll|}\hline
BAT * & BATnew & (int headtype, int tailtype, size\_t cap)   \\
BAT * & BATtmp & (BAT *b, int mode)\\
BAT * & BATextend & (BAT *b, size\_t newcap)\\
\hline\end{tabular}}
@
A temporary BAT is instantiated using @%BATnew@ with the type aliases of
the required binary association. The aliases include the built-in
types, such as @%TYPE_int@....@%TYPE_ptr@, and the atomic types introduced 
by the user. The initial capacity to be accommodated within a BAT is 
indicated by @%cap@. 
Their extend is automatically incremented upon storage overflow.
@
Failure to create the BAT results in a NULL pointer.
@
The routine @%BATtmp@ creates an empty BAT storage area with the properties
inherited from its argument. However, its default retention period is the 
transaction in which it is created.
@{
@h
#define BATDELETE	-9999

gdk_export BAT*	     	BATnew     (int hdtype, int tltype, size_t capacity); 
gdk_export BAT*		BATtmp     (BAT *b, int mode); 
gdk_export BAT*		BATextend  (BAT *b, size_t newcap); 

		/* internal */
gdk_export BAT*		BATnewstorage (int ht, int tt, size_t cap);
gdk_export BAT*		BATcreatedesc (int ht, int tt, int heapnames); 
gdk_export int 		BATfree       (BAT *b);
gdk_export int 		BATelmshift   (BAT *b);
gdk_export void 		BATsetdims    (BAT *b);
gdk_export int  		BBPreclaim    (BAT *b);
@
@}



@- BUN manipulation
@T
{\tt \begin{tabular}{|lll|}\hline
BAT * & BATins & (BAT *b, *c)\\
BAT * & BATdel & (BAT *b, *c)\\
BAT * & BUNins & (BAT *b, ptr left, ptr right)\\
BAT * & BUNreplace & (BAT *b, ptr left, ptr right)\\
int & BUNdel & (BAT *b, ptr left, ptr right)\\
int & BUNdelHead & (BAT *b, ptr left)\\
BUN & BUNfnd & (BAT *b, ptr head)\\
void & BUNfndOID & (BUN result, BAT *b, oid *head)\\
void & BUNfndSTD & (BUN result, BAT *b, ptr head)\\
BUN & BUNlocate & (BAT *b, ptr head, ptr tail)\\
ptr & BUNhead & (BAT *b, BUN p)\\
ptr & BUNtail & (BAT *b, BUN p)\\
\hline\end{tabular}}
@
The BATs contain a number of fixed-sized slots to store the binary
associations.  These slots are called BUNs or BAT units. A BUN
variable is a pointer into the storage area of the BAT, but it has
limited validity. After a BAT modification, previously obtained BUNs
may no longer reside at the same location.
@
The association list does not contain holes.  This density permits
users to quickly access successive elements without the need to test
the items for validity. Moreover, it simplifies transport to disk and
other systems. The negative effect is that the user should be aware of
the evolving nature of the sequence, which may require copying the BAT
first.
@
The update operations come in three flavors. Element-wise updates
can use @%BUNins@, @%BUNreplace@, @%BUNdel@, and @%BUNdelHead@. 
The batch update are @%BATins@ and @%BATdel@.
@
Only experts interested in speed may use @%BUNfastins@, since it skips most 
consistency checks, does not update search accelerators, and does
not maintain the @%hsorted@ and @%tsorted@ flags. Beware!
@
The routine @%BUNfnd@ provides fast access to a single BUN providing
a value for the head of the binary association. 
A very fast shortcut for @%BUNfnd@ if the selection type is known to be
integer or OID, is provided in the form of the macro @%BUNfndOID@.
@
To select on a tail, one should use the reverse view obtained by
@%BATmirror@.
@
The routines @%BUNhead@ and @%BUNtail@ return a pointer to the first
and second value in an association, respectively.  To guard against
side effects on the BAT, one should normally copy this value into a
scratch variable for further processing.
@{
@T
Behind the interface we use several macros to access the BUN fixed
part and the variable part. The BUN operators always require a BAT pointer
and BUN identifier.
\begin{itemize}
\item BAThtype(b) and  BATttype(b) find out the head and tail type of a BAT.
\item BUNfirst(b) returns a BUN pointer to the first BUN as a BAT.
\item BUNlast(b) returns the BUN pointer directly after the last BUn
in the BAT.
\item BUNsize(b) gives the size in bytes of each BUN.
\item BUNindex(b, p) computes the index number of a given BUN. 
\item BUNptr(b, i) computes the address of the i-th BUN in the BAT. 
\item BUNhead(b, p) and BUNtail(b, p) return pointers to the
head-value and tail-value in a given BUN.
\item BUNhloc(b, p) and BUNtloc(b, p) do the same thing, but knowing
in advance that the head-atom resp. tail-atom of a BAT is fixed size.
\item BUNhvar(b, p) and BUNtvar(b, p) do the same thing, but knowing
in advance that the head-atom resp. tail-atom of a BAT is variable sized.
\end{itemize}
@h
#define bunfastins_nocheck(b, p, h, t, s) {\
            (b)->batBuns->free += s;\
            ATOMput((b)->htype, &(b)->hheap, BUNhloc(b, p), h);\
            ATOMput((b)->ttype, &(b)->theap, BUNtloc(b, p), t);\
	}

#define bunfastins(b, h, t) {\
            REGISTER BUN _p = BUNlast(b);\
            REGISTER size_t _bunsize = BUNsize(b);\
            if ((b)->batBuns->free + _bunsize > (b)->batBuns->size) {\
                if (BATextend((b), BATgrows(b)) == NULL) goto bunins_failed;\
                _p = BUNlast(b);\
            }\
	    bunfastins_nocheck(b, _p, h, t, _bunsize);\
	}

gdk_export BAT*		BUNfastins (BAT *b, ptr left, ptr right); 
gdk_export BAT*		BUNins     (BAT *b, ptr left, ptr right); 
gdk_export BAT*		BATins     (BAT *b, BAT *c); 
gdk_export BAT*		BUNdel     (BAT *b, ptr left, ptr right); 
gdk_export BAT*		BUNdelHead (BAT *b, ptr left); 
gdk_export BUN		BUNdelete  (BAT *b, BUN p); 
gdk_export BAT*		BATdel     (BAT *b, BAT *c); 
gdk_export BAT*		BATdelHead (BAT *b, BAT *c); 

gdk_export BAT*		BUNreplace (BAT *b, ptr left, ptr right); 
gdk_export BAT*		BUNinplace (BAT *b, BUN p, ptr left, ptr right); 
gdk_export BAT*		BATreplace (BAT *b, BAT *n);

gdk_export BUN 		BUNlocate  (BAT *b, ptr left, ptr right); 
gdk_export BUN 		BUNfnd     (BAT *b, ptr left); 

#define BUNfndVOID(p,b,v) \
	if ((*(oid*) (v) == oid_nil) != ((b)->hseqbase == oid_nil)) {\
		/* (v == ni) XOR (seqbase == nil) ! */\
		/* What about (v == nil) AND (seqbase == nil) ? */\
		p = NULL;\
	} else {\
		REGISTER size_t _i = BUNindex((b),BUNfirst((b))) + (*(oid*) (v) - (b)->hseqbase);\
        	p = BUNptr((b), _i);  if (p < BUNfirst(b) || p >= BUNlast(b)) p = NULL;\
	}
#if SIZEOF_OID == SIZEOF_INT
#define BUNfndOID(p,b,v) \
	if (BAThdense(b)) {\
		BUNfndVOID(p,b,v);\
	} else {\
		HASHfnd_int(p,b,(int*)v);\
	}
#else
#define BUNfndOID(p,b,v) \
	if (BAThdense(b)) {\
		BUNfndVOID(p,b,v);\
	} else {\
		HASHfnd_lng(p,b,(lng*)v);\
	}
#endif
#define BUNfndSTD(p,b,v) ((p) = BUNfnd(b,v))

#define BAThtype(b)	((b)->htype == TYPE_void && (b)->hseqbase == oid_nil ?\
				TYPE_void : ATOMtype((b)->htype))
#define BATttype(b)	((b)->ttype == TYPE_void && (b)->tseqbase == oid_nil ?\
				TYPE_void : ATOMtype((b)->ttype))
#define BAThstore(b)	(BAThdense(b) ? TYPE_void : (b)->htype)
#define BATtstore(b)	(BATtdense(b) ? TYPE_void : (b)->ttype)
#define Bunbase(b)	((b)->batBuns->base)
#define Hbase(b)	((b)->hheap.base)
#define Tbase(b)	((b)->theap.base)

#define BUNhead(b,p)	((b)->hvarsized ? BUNhvar(b,p) : BUNhloc(b,p))
#define BUNtail(b,p)	((b)->tvarsized ? BUNtvar(b,p) : BUNtloc(b,p))

#define BUNsize(b)	((b)->dims.bunwidth)
#define BUNptr(b,i)	((BUN) ((char *) Bunbase(b) + ((b)->batElmshift < 0 ? \
				(i) * BUNsize(b) : (i) << (b)->batElmshift)))
#define BUNindex(b,p)	((size_t) ((b)->batElmshift < 0 ? \
                        	(((char*)(p)-(char*)Bunbase(b))/BUNsize(b)) :\
                        	(((char*)(p)-(char*)Bunbase(b)) >> (b)->batElmshift)))

#define BUNhloc(b,p)	((BUN) (((char *) (p)) + (b)->hloc))
#define BUNtloc(b,p)	((BUN) (((char *) (p)) + (b)->tloc))
#define BUNhvar(b,p)	((b)->htype?(BUN)((char *) Hbase(b)+*(var_t*)BUNhloc(b,p)):(BUN)BUNhpos(b,p))
#define BUNtvar(b,p)	((b)->ttype?(BUN)((char *) Tbase(b)+*(var_t*)BUNtloc(b,p)):(BUN)BUNtpos(b,p))

#define BUNfirst(b)	((BUN) ((char *) (b)->batHole + BUNsize(b)))
#define BUNlast(b)	((BUN) ((char *) Bunbase(b) + (b)->batBuns->free))
#define BUNnext(b,p)	((BUN) ((char *) (p) + BUNsize(b)))
#define BUNprev(b,p)	((BUN) ((char *) (p) - BUNsize(b)))

#define BUNgetpos(b,p)	(((b)->batElmshift < 0)?\
				((p-BUNfirst(b)) / BUNsize(b)):\
				((p-BUNfirst(b)) >> (b)->batElmshift))
@
@}

@- BAT properties 
@T
{\tt \begin{tabular}{|lll|}\hline
size\_t & BATcount & (BAT *b)\\
size\_t & BATbuncount & (BAT *b)\\
str & BATrename & (BAT *b; str nme)\\
BAT * & BATkey & (BAT *b; int onoff)\\
BAT * & BATset & (BAT *b; int onoff)\\
BAT * & BATmode & (BAT *b; int mode)\\
BAT * & BATsetaccess & (BAT *b; int mode)\\
int & BATdirty & (BAT *b)\\
int & BATgetaccess & (BAT *b)\\
int & BATversion & (BAT *b)\\
\hline\end{tabular}}
@
The function @%BATcount@ returns the number of associations
stored in the BAT. 
@
The function @%BATbuncount@ returns the space that is occupied in
associations in the BAT. This is not the same as @%BATcount@, 
since the first N associations may be unused or delta data.
@
The BAT is given a new logical name using @%BATrename@. 
@
The integrity properties to be maintained for the BAT are controlled separately.
A key property indicates that duplicates
in the association dimension are not permitted. The BAT is turned into 
an set of associations using @%BATset@. Key and set properties 
are orthogonal integrity constraints.
The strongest reduction is obtained by making the BAT a set with key
restrictions on both dimensions.
@
The persistency indicator tells indicates the retention period of BATs.
The system support four modes: 
@T
\begin{itemize}
\item {\small PERSISTENT}, 
\item {\small TRANSIENT}, and 
\item {\small SESSION}
\end{itemize}
@
The PERSISTENT BATs are automatically saved upon session boundary or 
transaction commit. 
@
Thereafter they are lost. TRANSIENT BATs are removed upon transaction boundary.
They are normally used to maintain temporary results.
@
All BATs are initially TRANSIENT unless their mode is changed 
using the routine @%BATmode@.
@
The BAT properties may be changed at any time using @%BATkey@, @%BATset@, 
and @%BATmode@.
@-
Valid BAT access properties can be set with BATsetaccess and BATgetaccess:
@T
\begin{itemize}
\item {\small BAT\_READ}, 
\item {\small BAT\_APPEND}, and 
\item {\small BAT\_WRITE}.
\end{itemize}
@
BATs can be designated to be read-only. In this case some 
memory optimizations may be made (slice and fragment bats can point
to stable subsets of a parent bat).
A special mode is append-only. It is then allowed to insert BUNs
at the end of the BAT, but not to modify anything that already 
was in there.
@{ 
@h
gdk_export str		BATrename    (BAT *b, str nme); 
gdk_export size_t	BATcount     (BAT *b); 
gdk_export size_t	BATcount_no_nil (BAT *b); 
gdk_export size_t	BATbuncount  (BAT *b); 
gdk_export size_t	BATguess     (BAT *b); 
gdk_export size_t	BATgrows     (BAT *b); 
gdk_export BAT*		BATkey       (BAT *b, int onoff); 
gdk_export BAT*		BATset       (BAT *b, int onoff); 
gdk_export BAT*		BATmode      (BAT *b, int onoff); 
gdk_export BAT*		BATroles     (BAT *b, str hnme,str tnme);
gdk_export int		BATname	     (BAT *b, str nme);
gdk_export BAT*		BATseqbase   (BAT *b, oid o); 
gdk_export BAT*		BATsetaccess (BAT *b, int mode); 
gdk_export int		BATgetaccess (BAT *b); 
gdk_export int		BATcheckmodes(BAT *b, int persistent, int unloadable); 


#define BATdirty(b)	((b)->batCopiedtodisk == 0 || (b)->batDirty ||\
			(b)->batDirtydesc || (b)->batDirtybuns ||\
			(b)->hheapdirty || (b)->theapdirty ||\
			(b)->haccdirty || (b)->taccdirty)

#define PERSISTENT	4096
#define SESSION		2048
#define TRANSIENT	1024

#define BAT_WRITE		0	/* all kinds of access allowed */	
#define BAT_READ		1	/* only read-access allowed */
#define BAT_APPEND		2	/* only reads and appends allowed */

#define BATversion(b)	(b)->GDKversion
#define BATcapacity(b)	((size_t) (((b)->batElmshift<0)?\
                        	(((b)->batBuns->size)/BUNsize(b)):\
                        	(((b)->batBuns->size) >> (b)->batElmshift)))
@
@}

@- BAT manipulation
@T
{\tt \begin{tabular}{|lll|}\hline
BAT * & BATclear & (BAT *b)\\
BAT * & BATcopy & (BAT *b)\\
BAT * & BATrcopy & (BAT *b)\\
BAT * & BATmark & (BAT *b, oid base)\\
BAT * & BATmark\_grp & (BAT *b, BAT *g)\\
BAT * & BATnumber & (BAT *b)\\
\hline
BAT * & BATmirror & (BAT *b)\\
BAT * & BATreverse & (BAT *b)\\
BAT * & BATreset & (BAT *b)\\
BAT * & BATflipflop & (BAT *b); \\
\hline\end{tabular}}
@
The routine @%BATclear@ removes the binary associations, leading
to an empty, but (re-)initialized BAT. Its properties are retained.
A temporary copy is obtained with @%BATcopy@. The new BAT has an unique name.
The routine @%BATmark@ creates a binary association that
introduces a new tail column of fresh densely ascending OIDs.
The base OID can be given explicitly, or if oid_nil is passed,
is chosen as a new unique range by the system.
A similar routine is @%BATnumber@, which copies the heads and
assigns an integer index to the tail.
It plays a crucial role in administration of query results.
@
The routine @%BATmirror@ returns the mirror image BAT (where tail is head
and head is tail) of that same BAT. This does not involve
a state change in the BAT (as previously): both views on the BAT
exist at the same time. To keep old code compatible
there are now macro's for @%BATreverse@ (which assigns the mirrored BAT
to its parameter), @%BATreset@ (which assigns the standard view),
and @%BATflipflop@ (which assigns to the alternate view).
@{
@h
gdk_export BAT*		BATclear  (BAT *b); 
gdk_export BAT*		BATcopy   (BAT *b); 
gdk_export BAT*		BATrcopy  (BAT *b); 
gdk_export BAT*		BATmark   (BAT *b, oid base); 
gdk_export BAT*		BATnumber (BAT *b); 
gdk_export BAT*		BATgroup (BAT *b, int start, int incr, int grpsize); 
@-
Retain old-style source-level functionality where the BAT reversal 
induced a state change of the BAT parameter to it.
@h
#define BATreverse(b)	((b) = (((b)->batCacheid<0)?(b):BATmirror(b)))
#define BATreset(b)	((b) = BBP_cache(ABS((b)->batCacheid)))
#define BATflipflop(b)	((b) = BATmirror(b))
@
@}


@- BAT Input/Output
@T
{\tt \begin{tabular}{|lll|}\hline
BAT * & BATload & (str name)\\
BAT * & BATsave & (BAT *b)\\
int & BATmmap & (BAT *b, int bn, int hh, int th, int ha, int ta)\\
int & BATmadvise & (BAT *b, int bn, int hh, int th, int ha, int ta)\\
int & BATdelete & (BAT *b)\\
BAT * & BATconvert & (str name, int direction)\\
\hline\end{tabular}}
@-
A BAT created by @%BATnew@ is considered temporary until one calls the
routine @%BATsave@ or @%BATmode@.  This routine reserves disk space
and checks for name clashes in the BAT directory. It also makes the
BAT persistent. The empty BAT is initially marked as ordered on both 
columns.
@
Failure to read or write the BAT results in a NULL, otherwise it
returns the BAT pointer.  
@
The @%BATconvert@ converts a BAT that contains data saved on
hardware with a different byte order (little endian vs big endian),
into the correct format. Direction is either CONV\_NTOH or CONV\_HTON,
indication conversion from network to host or host to network format.

@- Heap Storage Modes
The discriminative storage modes are memory-mapped, compressed, or in 
loaded in memory. 
@T
The {\tt BATmmap()} changes the storage mode of each heaps associated to a BAT
As can be seen in the bat record, each BAT has one BUN-heap ({\em bn}), and
possibly two heaps ({\em hh} and {\em th}) for variable-sized atoms, and 
possibly two heaps ({\em ha} and {\em ta}) for persistent user-defined
search accelerators.  
@
The @%BATmadvise@ call works in the same way. Using the @%madvise()@ system
call it issues buffer management advise to the OS kernel, as for the
expected usage pattern of the memory in a heap.
@{
@h
/* Heap storage modes */
#define STORE_MODEMASK	0xFF	/* mask for below bits */
#define STORE_MEM	0	/* load into GDKmalloced memory */
#define STORE_MMAP	1	/* mmap() into virtual memory */
#define STORE_COMPR	2	/* compressed STORE_MEM: currently ignored */
#define STORE_PRIV	3	/* BAT copy of copy-on-write mmap */

/* Flags to be ORed into above mode bits */
#define STORE_VARSIZE	0x100	/* variable sized */

/* Buffer management advise for heaps */
#define BUF_NORMAL	0     /* No further special treatment */
#define BUF_RANDOM	1     /* Expect random page references */
#define BUF_SEQUENTIAL	2     /* Expect sequential page references */
#define BUF_WILLNEED	3     /* Will need these pages */
#define BUF_DONTNEED	4     /* Don't need these pages */

gdk_export BAT*	BATload       (str nme);
gdk_export BAT*	BATload_intern(bat bid);
gdk_export BAT*	BATsave       (BAT *b);
gdk_export int      BATmmap       (BAT *b, int bn, int hh, int th, int ha, int ta);
gdk_export int      BATmadvise    (BAT *b, int bn, int hh, int th, int ha, int ta);
gdk_export int      BATdelete     (BAT* b);
gdk_export size_t	BATvmsize     (BAT *b, int dirty);
gdk_export size_t	BATmemsize    (BAT *b, int dirty);

gdk_export int      GDKfdlocate   (str nme, str mode, str ext);
gdk_export FILE*    GDKfilelocate (str nme, str mode, str ext);
gdk_export void     GDKfilepath   (str path, str nme, str mode, str ext);
gdk_export int      GDKcreatedir  (str nme);
gdk_export int      GDKremovedir  (str nme);

gdk_export char*    GDKload   (str nme, str ext, size_t size, size_t chunk, int mode);
gdk_export int      GDKsave   (str nme, str ext, void *buf, size_t size, int mode);
gdk_export int      GDKunlink (str dir, str nme, str extension);
gdk_export int      GDKmove   (str dir1, str nme1, str ext1, str dir2, str nme2, str ext2);
@
@}

@- Printing 
@T
{\tt \begin{tabular}{|lll|}\hline
int & BATprintf & (stream *f, BAT *b)\\
int & BATmultiprintf & (stream *f, int argc, BAT *b[], int printoid, int order)\\
\hline\end{tabular}}
@
The functions to convert BATs into ASCII and the reverse use
internally defined formats. They are primarily meant for ease of
debugging and to a lesser extent for output processing.
@
Printing a BAT is done essentially by looping through its components, 
printing each association. 
If an index is available, it will be used.
@
The @%BATmultiprintf@ command assumes a set of BATs with
corresponding oid-s in the head columns. It performs the multijoin
over them, and prints the multi-column result on the file.

@{
@h
gdk_export int	BATprint      (BAT *b); 
gdk_export int	BATprintf     (stream *f, BAT *b); 
gdk_export int	BATmultiprintf(stream *f, int argc, BAT *argv[], int printoid, int order);
@
@}

@- BAT clustering 
@T
{\tt \begin{tabular}{|lll|}\hline
BAT * & BATsort & (BAT *b)\\
BAT * & BATsort\_rev & (BAT *b)\\
BAT * & BATorder & (BAT *b)\\
BAT * & BATorder\_rev & (BAT *b)\\
BAT * & BATrevert & (BAT *b)\\
int & BATordered & (BAT *b)\\
\hline\end{tabular}}
@
When working in a main-memory situation, clustering of data on disk-pages
is not important. Whenever mmap()-ed data is used intensively, reducing
the number of page faults is a hot issue.
@ 
The below functions rearrange data in Monet heaps (used for storing
BUNs var-sized atoms, or accelerators). Applying these clusterings will
allow that Monet's main-memory oriented algorithms work efficient  also
in such a disk-oriented context.
@
The @%BATsort@ functions returns a copy of the input BAT, sorted
in ascending order on the head column. @%BATordered@ starts a 
check on the head values to see if their are ordered. The result
is returned and stored in the @%hsorted@ field of the BAT. 
@%BATorder@ is similar to @%BATsort@, but sorts the BAT itself, rather
than returning a copy (BEWARE: this operation destroys the 
delta information. TODO:fix). The @%BATrevorder@ puts all the live 
BUNs of a BAT in reverse order. It just reverses the sequence, so
this does not mean that they are sorted in reverse order! 
@{
@h
#define 		GDK_SORTED_REV	128 /* reversely sorted */
#define 		GDK_SORTED	65 /* 65 = (32 bits radix_clustered)<<1 + 1 */

gdk_export BAT*		BATsort          (BAT *b); 
gdk_export BAT*		BATsort_rev      (BAT *b); 
gdk_export BAT*		BATorder         (BAT *b); 
gdk_export BAT*		BATorder_rev     (BAT *b); 
gdk_export BAT*		BATrevert        (BAT *b); 
gdk_export int		BATordered       (BAT *b); 
gdk_export int		BATordered_rev   (BAT *b); 

gdk_export void GDKqsort (void *a, void* base, size_t n, int width, int tpe, int loc);
gdk_export void GDKqsort_rev (void *a, void* base, size_t n, int width, int tpe, int loc);

#define BAThordered(b)	(((b)->htype == TYPE_void)?GDK_SORTED:(b)->hsorted)
#define BATtordered(b)	(((b)->ttype == TYPE_void)?GDK_SORTED:(b)->tsorted)
#define BAThdense(b)	(BAThvoid(b) && (b)->hseqbase != oid_nil)
#define BATtdense(b)	(BATtvoid(b) && (b)->tseqbase != oid_nil)
#define BAThvoid(b)	(((b)->hdense&(b)->hsorted&1) || (b)->htype==TYPE_void)
#define BATtvoid(b)	(((b)->tdense&(b)->tsorted&1) || (b)->ttype==TYPE_void)
#define BAThkey(b)	(b->hkey != FALSE || BAThdense(b))
#define BATtkey(b)	(b->tkey != FALSE || BATtdense(b))
@
@}

@+ BAT Buffer Pool
@T
\label{BAT Buffer Pool}
{\tt \begin{tabular}{|lll|}\hline
int & BBPfix & (bat bi)\\
int & BBPunfix & (bat bi)\\
int & BBPincref & (bat bi, int logical)\\
int & BBPdecref & (bat bi, int logical)\\
void & BBPhot & (bat bi)\\
void & BBPcold & (bat bi)\\
str & BBPname & (bat bi)\\
\hline
bat & BBPindex  & (str nme)\\
BAT* & BATdescriptor & (bat bi)\\
bat & BBPcacheid & (BAT *b)\\
\hline\end{tabular}}
@
The BAT Buffer Pool module contains the code to manage the storage
location of BATs. It uses two tables @%BBPlogical@ and @%BBphysical@
to relate the BAT name with its corresponding file system name.
This information is retained in an ASCII file within the database home 
directory for ease of inspection. It is loaded upon restart 
of the server and saved upon transaction commit (if necessary).
@
The remaining BBP tables contain status information to load, swap and
migrate the BATs. The core table is 
@%BBPcache@ which contains a pointer to the BAT descriptor with its heaps.
A zero entry means that the file resides on disk. Otherwise it has been read
or mapped into memory.
@
BATs loaded into memory are retained in a BAT buffer pool.  They
retain their position within the cache during their life cycle, which
make indexing BATs a stable operation.  Their descriptor can be
obtained using @%BBPcacheid@.
@
The @%BBPindex@ routine checks if a BAT with a certain name is
registered in the buffer pools. If so, it returns its BAT id.
The @%BATdescriptor@ routine has a  BAT id parameter, and returns 
a pointer to the corresponding BAT record (after incrementing the reference 
count). The BAT will be loaded into memory, if necessary.
@
@{
The structure of the BBP file obeys the tuple format for GDK. 

The status and BAT persistency information is encoded in the status field.
@h
typedef struct {
        BAT	*b[2];		/* if loaded: BAT* handle + reverse */
        str     nme[2];		/* logical name + reverse */
        bat     next[2];	/* next BBP slot in link list */
        BATstore *cache;	/* cached header info */
        str     path;		/* dir + basename for storage */ 
        int     refs;		/* in-memory references on which the loaded status of a BAT relies */
	int	lrefs;		/* logical references on which the existence of a BAT relies */
	int     lastused;       /* BBP LRU stamp */
	volatile int status;    /* status mask used for spin locking */
} BBPrec;

gdk_export bat 		BBPmaxsize;
gdk_export bat 		BBPlimit;
gdk_export bat		BBP_free;
gdk_export int		BBP_dirty;	/* BBP table dirty? */
gdk_export bat		BBPsize;	/* current size of BBP tables */
gdk_export BBPrec*       	BBP;

/* fast defines without checks; internal use only  */
#define BBP_cache(i)    BBP[ABS(i)].b[(i)<0]
#define BBP_logical(i)  BBP[ABS(i)].nme[(i)<0]
#define BBP_next(i)     BBP[ABS(i)].next[(i)<0]
#define BBP_physical(i) BBP[ABS(i)].path
#define BBP_desc(i)	BBP[ABS(i)].cache
#define BBP_refs(i)     BBP[ABS(i)].refs
#define BBP_lrefs(i)    BBP[ABS(i)].lrefs
#define BBP_lastused(i) BBP[ABS(i)].lastused
#define BBP_status(i)   BBP[ABS(i)].status

/* macros that nicely check parameters */
#define BBPdirty(x)	 (BBP_dirty=(x))
#define BBPcacheid(b)	 ((b)->batCacheid)
#define BBPstatus(i)	 (BBPcheck((i),"BBPstatus")?BBP_status(i):-1)
#define BBPcurstamp()	 BBP_curstamp
#define BBPrefs(i)	 (BBPcheck((i),"BBPrefs")?BBP_refs(i):-1)
#define BBPcache(i)	 (BBPcheck((i),"BBPcache")?BBP_cache(i):(BAT*) NULL)
#define BBPname(i)	 (BBPcheck((i),"BBPname")?((i) > 0 || BBP_logical(i))?BBP_logical(i):BBP_logical(-(i)):"")
#define BBPfix(i) 	 BBPincref(i, FALSE)
#define BBPunfix(i) 	 BBPdecref(i, FALSE)
 
#define BBPRENAME_ALREADY	-1
#define BBPRENAME_ILLEGAL	-2
#define BBPRENAME_LONG		-3

gdk_export void BBPlock       (str s);

gdk_export int  BBPrename     (bat b, str s);
gdk_export int  BBPincref     (bat b, int logical);
gdk_export int  BBPdecref     (bat b, int logical);
gdk_export void BBPhot        (bat b);
gdk_export void BBPcold       (bat b);
gdk_export void BBPtrim       (size_t memdelta, size_t vmdelta);
gdk_export void BBPunlock     (str s);

gdk_export bat  BBPindex      (str nme);
gdk_export BAT* BBPdescriptor (bat b);
gdk_export str  BBPlogical    (bat b, str buf); 
gdk_export str  BBPphysical   (bat b, str buf); 
gdk_export int  BBP_curstamp;
gdk_export BATstore* BBPgetdesc(bat i); 
gdk_export BAT* BBPquickdesc  (bat b, int delaccess);
@
@}

@+ GDK Extensibility
@T
\label{GDK Extensibility}
GDK can be extended with new atoms, search accelerators and storage
modes.

@- Atomic Type Descriptors
The atomic types over which the binary associations are maintained
are described by an atom descriptor. 
@T
{\tt \begin{tabular}{|lll|}\hline
void& ATOMproperty    & (str   nme, char *property, int (*fcn)()));\\
int & ATOMindex       & (char *nme));\\
int & ATOMdump        & ());\\
void& ATOMdelete      & (int id);\\
\hline
str & ATOMname        & (int id);\\
int & ATOMsize        & (int id);\\
int & ATOMalign       & (int id);\\
int & ATOMvarsized    & (int id);\\
ptr & ATOMnilptr      & (int id);\\
int & ATOMfromstr     & (int id, str s, int* len, ptr* v\_dst);\\
int & ATOMtostr       & (int id, str s, int* len, ptr* v\_dst);\\
int & ATOMhash        & (int id, ptr val, in mask);\\
int & ATOMcmp         & (int id, ptr val\_1, ptr val\_2);\\
int & ATOMconvert     & (int id, ptr v, int direction);\\
int & ATOMfix         & (int id, ptr v);\\
int & ATOMunfix       & (int id, ptr v);\\
\hline
int & ATOMheap        & (int id, Heap *hp, size\_t cap);\\
void& ATOMheapconvert & (int id, Heap *hp, int direction);\\
int & ATOMheapcheck   & (int id, Heap *hp, HeapRepair *hr);\\
int & ATOMput         & (int id, Heap *hp, BUN pos\_dst, ptr val\_src);\\
int & ATOMdel         & (int id, Heap *hp, BUN v\_src);\\
int & ATOMlen         & (int id, ptr val);\\
\hline
ptr & ATOMnil         & (int id);\\
int & ATOMformat      & (int id, ptr val, char** buf);\\
int & ATOMprint       & (int id, ptr val, stream *fd);\\
ptr & ATOMdup         & (int id, ptr val );\\
\hline\end{tabular}}
@
@- Atom Definition
User defined search accelerators can be added to a running system with
the following interface:.
@T
\begin{itemize}
\item {\em ATOMproperty()} registers a new atom definition, if there is no one 
registered
yet under than name. It then installs the attribute of the named property.
Valid names are "size", "align", "null", "fromstr", "tostr", "cmp", 
"hash", "put", "get", "del", "length" and "heap".

\item {\em ATOMdelete()} unregisters an atom definition.

\item {\em ATOMindex()} looks up the atom descriptor with a certain name.
\end{itemize}
@
@- Atom Manipulation
@T
\begin{itemize}
\item The {\em ATOMname()} operation retrieves the name of an atom using its id.

\item The {\em ATOMsize()} operation returns the atoms fixed size.

\item The {\em ATOMalign()} operation returns the atoms minimum alignment. If the
alignment info was not specified explicitly during atom install, it 
GDK assumes the maximum value of {1,2,4,8} smaller than the atom size.

\item  The {\em ATOMnilptr()} operation returns a pointer to the nil-value of an
atom. We usually take one dedicated value halfway down the negative
extreme of the atom range (if such a concept fits), as the nil value.

\item  The {\em ATOMnil()} operation returns a copy of the nil value,
allocated with GDKmalloc().

\item The {\em ATOMheap()} operation creates a new var-sized atom heap in 'hp' 
with capacity 'cap'.

\item The {\em ATOMhash()} computes a hash index for a value. 'val' is a direct
pointer to the atom value. Its return value should be an integer
between 0 and 'mask'.

\item The {\em ATOMcmp()} operation computes two atomic values. Its parameters
are pointers to atomic values.

\item The {\em ATOMlen()} operation computes the byte length for a value.  'val'
is a direct pointer to the atom value. Its return value should be an
integer between 0 and 'mask'.

\item The {\em ATOMdel()} operation deletes a var-sized atom from its heap 'hp'. 
The integer byte-index of this value in the heap is pointed to by 'val\_src'.

\item The {\em ATOMput()} operation inserts an atom 'src\_val' in a BUN at
'dst\_pos'. This involves copying the fixed sized part in the BUN. In
case of a var-sized atom, this fixed sized part is an integer
byte-index into a heap of var-sized atoms. The atom is then also
copied into that heap 'hp'.

\item The {\em ATOMfix()} and {\em ATOMunfix()} operations do bookkeeping
on the number of references that a GDK application maintains to the atom.
In Monet, we use this to count the number of references by MIL variables
directly, or through BATs that have columns of these atoms. The only operator
for which this is currently relevant is BAT. The operators return the 
POST reference count to the atom. BATs with fixable atoms may not be
stored persistently. 

\item The {\em ATOMfromstr()} parses an atom value from string 's'. The memory
allocation policy is the same as in {\em ATOMget()}. The return value is
the number of parsed characters.

\item The {\em ATOMprint()} prints an ASCII description of the atom value pointed
to by 'val' on file descriptor 'fd'. The return value is the number of
parsed characters.

\item The {\em ATOMformat()} is similar to {\em ATOMprint()}. It prints an atom on a
newly allocated string. It must later be freed with {\tt GDKfree}.
The number of characters written is returned. This is minimally the
size of the allocated buffer.

\item The {\em ATOMdup()} makes a copy of the given atom. The storage
needed for this is allocated and should be removed by the user.
\end{itemize}

These wrapper functions correspond closely to the interface functions
one has to provide for a user-defined atom. They basically (with
exception of {\em ATOMput()}, {\em ATOMprint()} and {\em ATOMformat()})
just have the atom id parameter prepended to them.
@
@{
@h 
typedef struct {
	/* simple attributes */
	char	name[IDLENGTH]; 
	int	storage;		/* stored as another type? */
	short	linear;			/* atom can be ordered linearly */
	short	size;			/* fixed size of atom */
	short	align;			/* alignment condition for values */
	short	deleting;		/* set if unloading */
	int	varsized;		/* variable-size or fixed-sized */

	/* automatically generated fields */
	ptr	atomNull;		/* global nil value */

	/* generic (fixed + varsized atom) ADT functions */
	int	(*atomFromStr)		(str s, int* len, ptr* dst); 
	int	(*atomToStr)		(str* s, int* len, ptr src); 
	void	*(*atomRead)		(ptr a, stream* s, size_t cnt); 
	void	(*atomWrite)		(ptr a, stream* s, size_t cnt); 
	int	(*atomCmp)		(ptr v1, ptr v2); 
	hash_t	(*atomHash)		(ptr v); 
	/* optional functions */ 
	void	(*atomConvert)		(ptr v, int direction); 
	int	(*atomFix)		(ptr atom);
	int	(*atomUnfix)		(ptr atom);

	/* varsized atom-only ADT functions */
	var_t	(*atomPut)		(Heap*, var_t* off, ptr src); 
	void	(*atomDel)		(Heap*, size_t* atom); 
	int	(*atomLen)		(ptr atom); 
	void	(*atomHeap)		(Heap*, size_t); 
	/* optional functions */
	void	(*atomHeapConvert)	(Heap*, int direction); 
	int	(*atomHeapCheck) 	(Heap*, HeapRepair*); 
} atomDesc; 

gdk_export atomDesc		BATatoms[]; 
gdk_export int 		GDKatomcnt; 

gdk_export void ATOMdelete    (int id);
gdk_export void ATOMproperty  (char* nme, char *property, GDKfcn fcn);
gdk_export int  ATOMindex     (char* nme);
gdk_export int  ATOMstorage   (int id);
gdk_export int  ATOMisdescendant (int id, int parentid);
gdk_export int  ATOMdump      (void);

gdk_export int  ATOMheap      (int id, Heap *hp, size_t cap); 
gdk_export str  ATOMname      (int id);
gdk_export int  ATOMlen       (int id, ptr v);
gdk_export ptr  ATOMnil	  (int id);
gdk_export int  ATOMcmp	  (int id, ptr v_1,  ptr v_2);
gdk_export int  ATOMprint     (int id, ptr val,  stream*  fd);
gdk_export int  ATOMformat    (int id, ptr val,  char** buf);

gdk_export ptr  ATOMdup	  (int id, ptr val);
@
@}

@- Unique OIDs 
@T
{\tt \begin{tabular}{|lll|}\hline
oid  &  OIDseed & (oid seed);\\ 
oid  &  OIDnew  & (size\_t inc);\\
\hline\end{tabular}}

OIDs are special kinds of unsigned integers because the system
guarantees uniqueness. For system simplicity and performance, OIDs
are now represented as (signed) integers; however this is hidden 
in the system internals and shouldn't affect semantics. 
\\ 
@
The @%OIDnew(N)@ claims a range of N contiguous unique,
unused OIDs, and returns the starting value of this range.
@
@- highest OIDBITS designate site. 
Derived from that: 
@{
@h
gdk_export int      	OIDinit  (void);
gdk_export oid		OIDrand  (void);
gdk_export oid      	OIDbase  (oid base);
gdk_export oid      	OIDseed  (oid seed);
gdk_export oid      	OIDnew   (size_t inc);
gdk_export oid      	OIDread  (str buf);
gdk_export int      	OIDwrite (stream *fp);
gdk_export int      	OIDdirty (void);
@
@}

@- Search Accelerators
@T
{\tt \begin{tabular}{|lll|}\hline
void & ACCproperty & (str name, str prop, int (*fcn)());\\
void & ACCdelete & (accid int);\\
int & ACCindex & (str name);\\
void & ACCunloadall & (BAT *b);\\
void & ACCremoveall & (BAT *b);\\
\hline
str & ACCname & (int id);\\
void &	ACCbuild    &(int id, BAT *b, Heap* acc, ptr extra);\\
void &	ACCdestroy  & (int id, BAT *b, Heap* acc);\\
void &	ACCins   & (int id, BAT *b, Heap* acc, int idx, ptr val);\\
void &	ACCdel   & (int id, BAT *b, Heap* acc, int idx, ptr val);\\
void &	ACCmove  & (int id, BAT *b, Heap* acc, int from, int to, ptr val);\\
void &	ACCsave     & (int id, BAT *b, Heap* acc, str name);\\
void &	ACCcluster  & (int id, BAT *b, Heap* acc);\\
void &	ACCbuncluster & (int id, BAT *b, Heap* acc);\\
int &	ACCrepair    & (int id, BAT *b, Heap* acc);\\
\hline\end{tabular}}
@
@- Accelerator Definition
@T
User defined search accelerators can be added to a running system with
the above interface:.
\begin{itemize}
\item {\em ACCproperty()} registers a new accelerator, if there is no one registered
yet under than name. It then installs the attribute of the named property.
Valid names are "destroy","insert","save","commit","abort" and "buncluster".

\item {\em ACCdelete()} unregisters an accelerator definition.

\item{\em ACCindex()} looks up the accelerator id with a certain name.
\end{itemize}
@
The @%ACCremoveall()@ routine destroys all search accelerators
associated with a BAT.
@
@- Accelerator Manipulation
@T
\begin{itemize}
\item {\em ACCbuild()} builds an accelerator on the head column of a BAT.

\item {\em ACCdestroy()} destroys an accelerator on the head column of a BAT.

\item {\em ACCins()} notifies of the insertion of a new value at BUN position
{\em i} in the heap column. 

\item {\em ACCdel()} notifies of the deletion of a new value at BUN position
{\em i} in the heap column. 

\item {\em ACCmove()} combines ACCdel and ACCinsert. This function
is not obligatory to implement.

\item {\em ACCcluster()} orders an accelerator reclustering of the internal
structures of the accelerator, in order to minimize page faults
in a memory mapped situation.

\item {\em ACCbuncluster()} is intended to guide reclustering of the BUNs of a
BAT to an accelerators traversal order, in order to minimize page faults
in a memory mapped situation. 

\item {\em ACCrepair()} checks the consistency of an accelerator. If it is
consistent, it returns GDK\_SUCCEED, else GDK\_FAIL, WHILE BRINGING
THE ACCELERATOR IN A CONSISTENT STATE (most probably by deleting it).
\end{itemize}
These functions are just wrappers for the operations one has to
provide for a user-defined search accelerator, with the accelerator id
as a prepended parameter.
@
@{
@h 
typedef struct {
	char		name[IDLENGTH]; 
	int		deleting;
	void		(*accBuild)   (Heap*, BAT*, void *param);
	void		(*accDestroy) (Heap*, BAT*);
	void		(*accInsert)  (Heap*, size_t pos, BAT*, ptr val);
	void		(*accDelete)  (Heap*, size_t pos, BAT*, ptr val);
	void		(*accSave)    (Heap*, BAT*);
	void		(*accCommit)  (Heap*, BAT*);
	void		(*accAbort)   (Heap*, BAT*);
	void		(*accCluster) (Heap*, BAT*);
	int             (*accBuncluster)(Heap*, BAT*);
	int		(*accRepair)  (Heap*, BAT*);
	void		(*accMove)    (Heap*, size_t from, size_t to, BAT*, ptr val);
} accDesc; 

gdk_export accDesc	BATaccelerators[];
gdk_export int 		GDKacc_cnt; 

gdk_export int	ACCindex      (str name);
gdk_export void	ACCproperty   (str name, str prop, ptr fcn);
gdk_export void	ACCdelete     (int id);
gdk_export str	ACCname       (int id);

gdk_export int	ACCbuild      (int id, BAT *b, Heap *acc, ptr extra);
gdk_export int	ACCdestroy    (int id, BAT *b, Heap *acc);
/*
gdk_export int	ACCrepair     (int id, BAT *b, Heap *acc);
*/
gdk_export int  	ACCrepairSTD  ( Heap* h, BAT *b);                

gdk_export void 	ACCremoveall  (BAT *b);
gdk_export void 	ACCunloadall  (BAT *b);
/*
gdk_export void 	ACCexit       (BAT *b);
*/
@
@}

@- Built-in Accelerator Functions

@T
{\tt \begin{tabular}{|lll|}\hline
BAT* & BAThash & (BAT *b, int coll)\\
int & BATidx & (BAT *b, BAT *histo)\\
BAT * & BAThashsplit & (BAT *b, size\_t n, int unary)\\
BAT * & BATrangesplit & (BAT *b, int n)\\
\hline\end{tabular}}
@
The current BAT implementation supports two search accelerators:
hashing and indexing. The routine @%BAThash@ makes sure that a hash
accelerator on the head of the BAT exists. Likewise @%BATidx@
updates the index data structure maintained. A zero is returned upon
failure to create the supportive structures.
@
The hash data structures are currently maintained during update operations..
The index data structures are discarded upon a modification of the
underlying BAT.
@
A @%BAT@ can be redistributed over @%n@ buckets using a hash
function with @%BAThashsplit@. The return value is a list of BAT
pointers.  Similarly, a range partitioning based on the index is
supported.

@{
@h
gdk_export BAT*       BAThash      (BAT *b, int *collision);
gdk_export BAT*	BATidx        (BAT *b, BAT *h);
gdk_export BAT*	BAThashsplit  (BAT *b, size_t n, int unary); 
gdk_export BAT*	BATrangesplit (BAT *b, size_t n, int unary); 
gdk_export BAT* BAThashjoin   (BAT* l, BAT* r, size_t estimate);

/* low level functions */
gdk_export BUN	SORTfnd      (BAT *b, ptr v);
gdk_export BUN	SORTfndfirst (BAT *b, ptr v);
gdk_export BUN	SORTfndlast  (BAT *b, ptr v);
gdk_export BUN	IDXfnd       (BAT *b, ptr v);
gdk_export BUN*	IDXfndfirst  (BAT *b, ptr v);
gdk_export BUN*	IDXfndlast   (BAT *b, ptr v);
gdk_export void	IDXrng_      (BAT *b, ptr v, ptr w, bit li, bit hi, BUN **p, BUN **q);
gdk_export void	IDXrng       (BAT *b, ptr v, ptr w, BUN **p, BUN **q);
gdk_export void    IDXdestroy    (BAT *b);
gdk_export void    IDXremove     (BAT *b);

#define BATprepareHash(X) (((X)->hhash_heap == NULL) && !BAThash(X, NULL))
@
@}

@- Multilevel Storage Modes

We should bring in the compressed mode as the first, maybe built-in,
mode. We could than add for instance HTTP remote storage, SQL storage,
and READONLY (cd-rom) storage.

@+ GDK Utilities
@T
\label{GDK Utilities}
Interfaces for memory management, error handling, thread management
and system information.

@- GDK memory management
@T
{\tt \begin{tabular}{|lll|}\hline
void* & GDKmalloc & (size\_t size)\\
void* & GDKmallocmax & (size\_t size, size\_t *maxsize, int emergency)\\
void* & GDKrealloc & (void* pold, size\_t size)\\
void* & GDKreallocmax & (void* pold, size\_t size, size\_t *maxsize, int emergency)\\
void & GDKfree & (void* blk)\\
str & GDKstrdup & (str s)\\
\hline
void* & GDKvmalloc & (size\_t size, size\_t *maxsize, int emergency)\\
void* & GDKvmrealloc & (void* pold, size\_t oldsize, size\_t newsize, size\_t oldmax, size\_t *maxsize, int emergency)\\
void & GDKvmfree & (void* blk, size\_t size, size\_t maxsize)\\
\hline\end{tabular}}
@
These utilities are primarily used to maintain control over critical interfaces
to the C library.  Moreover, the statistic routines help in identifying 
performance and bottlenecks in the current implementation.
@
Compiled with -DMEMLEAKS the GDK memory management log their activities,
and are checked on inconsistent frees and memory leaks.
@{
@h
#define GDK_HISTO_MAX_BIT             ((int) (sizeof(size_t)<<3))

/* we prefer to use vm_alloc routines on size > GDKmmap */
gdk_export void *GDKmmap(char* path, int mode, off_t off, size_t len, void *fixed);
gdk_export int	GDKmunmap(void* addr, size_t len);

gdk_export              ptr     GDK_mem_start;          /* sbrk(0) at start of the program */
gdk_export		size_t 	GDK_mem_bigsize;	/* size after which we use VM rather than heap */
gdk_export		size_t	GDK_mem_maxsize;	/* max allowed size of committed memory */
gdk_export		size_t 	GDK_vm_minsize;		/* smallest size allowed for a vm block */
gdk_export		size_t 	GDK_vm_maxsize;		/* max allowed size of reserverd vm */

gdk_export size_t	GDKmem_inuse(void); /* RAM/swapmem that Monet is really using now */
gdk_export size_t	GDKmem_cursize(void); /* RAM/swapmem that Monet has claimed from OS */
gdk_export size_t	GDKvm_cursize(void); /* current Monet VM address space usage */
gdk_export size_t 	GDKvm_heapsize(void);
gdk_export size_t 	GDKmem_heapsize(void);
gdk_export size_t 	GDKmem_heapinuse(void);

gdk_export void* 	GDKmalloc  (size_t size); 
gdk_export void* 	GDKmallocmax (size_t size, size_t *maxsize, int emergency); 
gdk_export void* 	GDKrealloc (void* pold, size_t size); 
gdk_export void* 	GDKreallocmax (void* pold, size_t size, size_t *maxsize, int emergency); 
gdk_export void		GDKfree    (void* blk); 
gdk_export str		GDKstrdup  (const char *s);

gdk_export void*	GDKvmalloc  (size_t size, size_t *maxsize, int emergency);
gdk_export void*	GDKvmrealloc(void* pold, size_t oldsize, size_t newsize, size_t oldmax, size_t *maxsize, int emergency);
gdk_export void		GDKvmfree   (void* blk, size_t size, size_t maxsize);
@
@}

@- GDK error handling
@T
{\tt \begin{tabular}{|lll|}\hline
str & GDKmessage & \\
bit & GDKsilent & \\
int & GDKfatal & (str msg)\\
int & GDKwarning & (str msg)\\
int & GDKerror & (str msg)\\
int & GDKgoterrors & ()\\
int & GDKsyserror & (str msg)\\
str & GDKerrbuf & \\
 & GDKsetbuf& (str buf)  \\
\hline\end{tabular}}
@
The error handling mechanism is not sophisticated yet. Experience should 
show if this mechanism is sufficient.
Most routines return a pointer with zero to indicate an error.
@
The error messages are also copied to standard output unless
@%GDKsilent@ is set to a non-zero value.
The last error message is kept around in a global variable.
@
Error messages can also be collected in a user-provided buffer,
instead of being echoed to a stream. This is a thread-specific issue;
you want to decide on the error mechanism on a thread-specific basis. 
This effect is established with @%GDKsetbuf@. The memory (de)allocation 
of this buffer, that must at least be 1024 chars long, is entirely 
by the user. A pointer to this buffer is kept in the pseudo-variable
@%GDKerrbuf@. Normally, this is a NULL pointer.
@
@{
@h
#define GDKMAXERRLEN	10240
#define GDKWARNING	"!WARNING: "
#define GDKERROR	"!ERROR: "
#define GDKMESSAGE	"!OS: "
#define GDKFATAL	"!FATAL: "

/* Data Distilleries uses ICU for internationalization of some Monet error messages */
#ifdef MONET_ICU_I18N
gdk_export void   GDKvsnprintf(char *buf, int maxlen, const char* format, va_list ap);
#else
#define GDKvsnprintf(buf, maxlen, format, ap) vsnprintf(buf, maxlen, format, ap)
#endif

gdk_export void	GDKaddbuf   (const char* msg);
gdk_export int	GDKwarning  (const char* format, ... );
gdk_export int	GDKerror    (const char* format, ... );
gdk_export int	GDKsyserror (const char* format, ... );
gdk_export int	GDKfatal    (const char* format, ... );
gdk_export int	GDKerrorCount ();
@
@h
#define BBPLOCKMASK     7

#include "gdk_delta.h"
#include "gdk_search.h"
#include "gdk_atoms.h"
#include "gdk_bbp.h"
#include "gdk_desc.h" 
#include "gdk_utils.h"
#include "gdk_bat.h"

gdk_export MT_Lock		GDKthreadLock;
gdk_export MT_Lock		GDKstatusLock[BBPLOCKMASK+1]; 
gdk_export MT_Lock		GDKswapLock[BBPLOCKMASK+1]; 
gdk_export MT_Lock		GDKidxLock[BBPLOCKMASK+1]; 
gdk_export MT_Lock		GDKhashLock[BBPLOCKMASK+1]; 
gdk_export MT_Lock		GDKunloadLock; 
gdk_export MT_Lock		GDKunloadBarrier; 
gdk_export MT_Lock		GDKcacheLock; 
gdk_export MT_Lock		GDKtrimLock; 
gdk_export MT_Lock		GDKtmLock; 

#define CHECKDEBUG      if (GDKdebug&2)
#define MEMDEBUG        if (GDKdebug&4)
#define PROPDEBUG       if (GDKdebug&8)
#define IODEBUG         if (GDKdebug&16)
#define BATDEBUG        if (GDKdebug&32)
#define PARSEDEBUG      if (GDKdebug&64)
#define PARDEBUG        if (GDKdebug&128)
#define TRGDEBUG        if (GDKdebug&256)
#define TMDEBUG         if (GDKdebug&512)
#define TEMDEBUG        if (GDKdebug&1024)
#define DLDEBUG	        if (GDKdebug&2048)
#define PERFDEBUG	if (GDKdebug&4096)
#define DELTADEBUG	if (GDKdebug&8192)
#define LOADDEBUG	if (GDKdebug&16384)
#define YACCDEBUG	if (GDKdebug&32768)
/*
#define ?tcpip?		if (GDKdebug&65536)
#define ?monet_multiplex?	if (GDKdebug&131072)
#define ?ddbench?	if (GDKdebug&262144)
#define ?ddbench?	if (GDKdebug&524288)
#define ?ddbench?	if (GDKdebug&1048576)
*/
#define ALGODEBUG	if (GDKdebug&2097152)
#define ESTIDEBUG	if (GDKdebug&4194304)
#define XPROPDEBUG      if (GDKdebug&8388608)

gdk_export int		GDKnrofthreads; 
gdk_export int		GDKdebug; 
@}
@-
The kernel maintains a central table of all active threads.
They are indexed by their tid. The structure contains information on the
input/output file descriptors, which should be set before a
database operation is started. It ensures that output is delivered to the
proper client.
@
The Thread structure should be ideally made directly accessible to each 
thread. This speeds up access to tid and file descriptors.
@{
@h
#define THREADS	64
#define THREADDATA	16

typedef struct threadStruct{
	int		tid; /* logical ID by Monet; val == index into this array + 1 (0 is invalid) */ 
	MT_Id		pid; /* physical thread id (pointer-sized) from the OS thread library */
	str		name; 
	ptr		data[THREADDATA];
	size_t		sp;
	void		(*cleanup)(ptr thr);
} ThreadRec, *Thread; 


gdk_export ThreadRec        GDKthreads[THREADS];

gdk_export int		THRgettid    (void);
gdk_export Thread	THRget       (int tid);
gdk_export Thread	THRnew       (MT_Id pid, str name);
gdk_export void		THRdel       (Thread t);
gdk_export int		THRinit      (void);
gdk_export int		THRexit      (str nme);
gdk_export int		THRcnt       (void);
gdk_export void		THRsetdata   (int,ptr);
gdk_export void*	THRgetdata   (int);
gdk_export int		THRhighwater (void);
gdk_export int		THRprintf    (stream *s, const char* format, ... );

gdk_export void*    THRdata[16];

#define GDKstdout	((stream*)THRdata[0])
#define GDKstdin	((stream*)THRdata[1])

#define GDKout	        ((stream*)THRgetdata(0))
#define GDKin	        ((stream*)THRgetdata(1))
#define GDKerrbuf	((char*)THRgetdata(2))
#define GDKsetbuf(x)	THRsetdata(2,(ptr)(x))
#define GDKerr	        GDKout

#ifndef GDK_NOLINK
#ifdef __cplusplus
extern "C" {
#endif

static INLINE bat BBPcheck(REGISTER bat x, REGISTER const char *y)
{
	if (x && x != bat_nil) {
		REGISTER bat z = ABS(x);

		if (z >= BBPsize || BBP[z].nme[0] == NULL) {
			GDKwarning("%s: range error %d\n", y, x);
		} else  {
			return z;
		}
	}
	return 0;
}

static INLINE BAT* BATdescriptor(REGISTER bat i)
{
	REGISTER BAT *b = NULL;

	if (BBPcheck(i,"BATdescriptor")) {
		BBPfix(i);
		b = BBP_cache(i);
		if (b == NULL)
			b = BBPdescriptor(i);
	}
	return b;
}

static INLINE ptr BUNhpos(REGISTER BAT *b, REGISTER BUN p)
{
	oid *ip = &b->void_seq1; 

	*ip = b->hseqbase;
	if (*ip != oid_nil) {
		*ip += BUNgetpos(b,p);
	}
	return (ptr) ip; 
}

static INLINE ptr BUNtpos(REGISTER BAT *b, REGISTER BUN p)
{
	oid *ip = &b->void_seq2; 

	*ip = b->tseqbase;
	if (*ip != oid_nil) {
		*ip += BUNgetpos(b,p);
	}
	return (ptr) ip; 
}

static INLINE BAT* BATmirror(REGISTER BAT *b)
{
	return BBP_cache(-(b)->batCacheid);
}

#ifdef __cplusplus
}
#endif
#endif

@
@}

@+ Transaction Management
@T
\label{Transaction Management}
{\tt \begin{tabular}{|lll|}\hline
int & TMnew & (str cntxt)\\
int & TMcommit & (str cntxt)\\
int & TMabort & (str cntxt)\\
int & TMresume & (str cntxt)\\
\hline\end{tabular}}
@
The current implementation of the Goblin Database Kernel
assumes a single transaction environment.
@
A transaction starts by announcing it to the transaction manager
with the routine @%TMnew@. The argument is a name for the transaction
context, which should be unique among the active transactions.
Thereafter, all  BATs created or modified are added to the context
on an exclusive basis. Failure leads to an error message.
@
The transaction ends with either @%TMabort@ or @%TMcommit@.
For the moment, we assume that all BATs being modified are kept memory 
resident to simplify recovery. 
@
During a transaction a context switch occurs upon encountering 
another @%TMnew@ before commit or abort has been received.
One can switch between transactions by issuing @%TMresume@.
@
The rationale for this scheme is its simplicity in testing transaction
management, i.e. simulation of a multi-user systems.
Ideally, it should become possible to specify the transaction protocol in more
detail by the user.
@{
@h
gdk_export int	TMnew       (str cntxt); 
gdk_export int	TMcommit    (void); 
gdk_export int	TMabort     (void); 
gdk_export int	TMresume    (str cntxt); 
gdk_export str	TMcntxt     (void); 
@
@}

@- Delta Management
@T
{\tt \begin{tabular}{|lll|}\hline
BAT * & BATprecommit & (BAT *b)\\
BAT * & BATcommit & (BAT *b)\\
BAT * & BATfakeCommit & (BAT *b)\\
BAT * & BATfakeRestart & (BAT *b)\\
BAT * & BATundo & (BAT *b)\\
BAT * & BATalpha & (BAT *b)\\
BAT * & BATdelta & (BAT *b)\\
\hline\end{tabular}}
@
The updates on a single BAT are kept separately from the stable
partition until the user issues a @%BATcommit@ operation.
@
The routine @%BATprecommit@ ensures that the information for recovery
is safely stored away on a log. @%BATundo@ discards all updates made
so-far.
@
The delta(s) provides the handle to drive the trigger manager later
on.  Since the delta lead to an ever growing BAT storage structure,
one should occasionally trim it.
@
At any time the user sees the most accurate state of the BAT, as if
all insertions and deletions take place immediately.
@
The routine @%BATfakeCommit@ simply updates the delta information
on BATs and clears the dirty bit. This avoids any
copying to disk.
@
The routine @%BATfakeRestart@ is like @%BATfakeCommit@, but
marks all BUNs in the BAT as if they were newly inserted.
@{
@h
gdk_export BAT*	BATprecommit  (BAT *b); 
gdk_export BAT*	BATcommit     (BAT *b); 
gdk_export BAT*	BATundo       (BAT *b); 
gdk_export BAT*	BATalpha      (BAT *b); 
gdk_export BAT*	BATdelta      (BAT *b); 
gdk_export BAT*	BATfakeCommit (BAT *b);

@}
@+ BAT Alignment and BAT views
@T
\label{BAT Alignment}
{\tt \begin{tabular}{|lll|}\hline
int  & ALIGNsynced  & (BAT* b1, BAT* b2)\\
int  & ALIGNsync    & (BAT *b1, BAT *b2)\\
int  & ALIGNrelated & (BAT *b1, BAT *b2)\\
int  & ALIGNsetH    & ((BAT *dst, BAT *src)\\
\hline
BAT * & BATpropcheck & (BAT *b, int mode)\\
\hline
BAT* & VIEWcreate   & (BAT *b)\\
bat  & VIEWparent   & (BAT *b)\\
BAT* & VIEWhead     & (BAT *b)\\
BAT* & VIEWcombine  & (BAT *b)\\
BAT* & VIEWreset    & (BAT *b)\\
BAT* & BATmaterialize    & (BAT *b, size\_t size)\\
\hline\end{tabular}}
@
Alignments of two columns of a BAT means that the system knows
whether these two columns are exactly equal. Relatedness of two
BATs means that one pair of columns (either head or tail) of
both BATs is aligned. The first property is checked by @%ALIGNsynced@,
the latter by @%ALIGNrelated@.
@
The @%BATpropcheck@ examines a BAT and tries to set all applicable
properties (key,sorted,align,dense). 
@
All algebraic BAT commands propagate the properties - including 
alignment properly on their results.
@
VIEW BATs are BATs that lend their storage from a parent BAT.
They are just a descriptor that points to the data in this
parent BAT. A view is created with @%VIEWcreate@. The cache
id of the parent (if any) is returned by @%VIEWparent@ (otherwise
it returns 0). 
@
VIEW bats are read-only!!
@
The @%VIEWcombine@ gives a view on a BAT that has two head 
columns of the parent.
The @%VIEWhead@ constructs a BAT view that has the same
head column as the parent, but has a void column with seqbase=nil
in the tail. @%VIEWreset@ creates a normal BAT with the same contents
as its view parameter (it converts void columns with seqbase!=nil
to materialized oid columns).

The @%BATmaterialize@ materializes a VIEW (TODO) or void bat inplace. The
size parameter can be used to hint the new size. This is useful as 
materialization is usually needed for updates.

@{
@h
gdk_export int      ALIGNsynced     (BAT *b1, BAT *b2);
gdk_export int      ALIGNrelated    (BAT *b1, BAT *b2);
gdk_export int      ALIGNsetH	(BAT *dst, BAT *src);

gdk_export BAT*	BATpropcheck	(BAT *b, int mode); 
#define BATPROPS_QUICK  0 /* only derive easy (non-resource consuming) properties */
#define BATPROPS_ALL    1 /* derive all possible properties; no matter what cost (key=hash) */
#define BATPROPS_CHECK  3 /* BATPROPS_ALL, but start from scratch and report illegally set properties */

gdk_export BAT*	VIEWcreate	(BAT *b);
gdk_export BAT*	VIEWcreate_	(BAT *b, int stable);
gdk_export BAT*	VIEWhead	(BAT *b);
gdk_export BAT*	VIEWhead_	(BAT *b, int mode);
gdk_export BAT*	VIEWcombine	(BAT *b);
gdk_export BAT*	VIEWreset	(BAT *b);
gdk_export BAT*	BATmaterialize	(BAT *b, size_t size);
gdk_export void	VIEWdestroy	(BAT *b);
gdk_export void	VIEWunlink	(BAT *b);

/* low level functions */
gdk_export int      ALIGNundo       (BAT *b);
gdk_export int      ALIGNcommit     (BAT *b);
gdk_export int      ALIGNsetH       (BAT *b1, BAT *b2);
#define ALIGNsetT(x,y)	ALIGNsetH(BATmirror(x),BATmirror(y))
#define ALIGNdel(x,y)	{ALIGNchk(x,y);(x)->halign=(x)->talign=0; }
#define ALIGNins(x,y)	{VIEWchk(x,y,BAT_READ);(x)->halign=(x)->talign=0; }
#define ALIGNdelH(x,y)	{ALIGNchk(x,y);(x)->halign=0;}
#define ALIGNdelT(x,y)	{ALIGNchk(x,y);(x)->talign=0;}
#define ALIGNset(x,y)	{ALIGNsetH(x,y);ALIGNsetT(x,y);}

#define BATrestricted(b) (VIEWparent(b)?BBP_cache(VIEWparent(b))->batRestricted:(b)->batRestricted)

/* The batRestricted field indicates whether a BAT is readonly.
 * we have modes: BAT_WRITE  = all permitted
 *                BAT_APPEND = append-only 
 *                BAT_READ   = read-only 
 * VIEW bats are always mapped read-only.
 */
#define	VIEWchk(x,y,z)\
    if (((x)->batRestricted & (z)) || (x)->batSharecnt > 0) {\
	GDKerror("%s: access denied to %s, aborting.\n", y, x->batId);\
	return 0;\
    }

/* the parentid in a VIEW is correct for the normal view. We must correct
 * for the reversed view. A special case are the VIEWcombine bats, these
 * always refer to the same parent column (i.e. no correction needed)
 */
#define VIEWparent(x)	(((x)->H == (x)->T || (x)->batCacheid >= 0)?\
				(x)->batParentid:-(x)->batParentid)

/* VIEWparentcol(b) tells whether the head column was inherited from the parent
 * "as is". We must check whether the type was not overridden in the view.
 */
#define VIEWparentcol(b) ((VIEWparent(b) && (b)->htype\
                          && (b)->htype == BBP_cache(VIEWparent(b))->htype\
                          && (b)->hloc == BBP_cache(VIEWparent(b))->hloc)\
                                        ?VIEWparent(b):0)

#define ALIGNchk(x,y)	VIEWchk(x,y,BAT_APPEND|BAT_READ)
@
@}


@+ BAT Iterators
@T
\label{BAT Iterators}
{\tt \begin{tabular}{|lll|}\hline
BATloop & (BAT *b; BUN p, BUN q)\\
BATloopDEL & (BAT *b; BUN p; BUN q; int dummy)\\
DELloop & (BAT *b; BUN p, BUN q, int dummy)\\
\hline
HASHloop & (BAT *b; Hash *h, size\_t dummy; ptr value)\\
HASHloop\_bit & (BAT *b; Hash *h, size\_t idx; bit *value, BUN w)\\
HASHloop\_chr & (BAT *b; Hash *h, size\_t idx; char *value, BUN w)\\
HASHloop\_sht & (BAT *b; Hash *h, size\_t idx; sht *value, BUN w)\\
HASHloop\_bat & (BAT *b; Hash *h, size\_t idx; bat *value, BUN w)\\
HASHloop\_ptr & (BAT *b; Hash *h, size\_t idx; ptr *value, BUN w)\\
HASHloop\_int & (BAT *b; Hash *h, size\_t idx; int *value, BUN w)\\
HASHloop\_oid & (BAT *b; Hash *h, size\_t idx; oid *value, BUN w)\\
HASHloop\_flt & (BAT *b; Hash *h, size\_t idx; flt *value, BUN w)\\
HASHloop\_lng & (BAT *b; Hash *h, size\_t idx; lng *value, BUN w)\\
HASHloop\_dbl & (BAT *b; Hash *h, size\_t idx; dbl *value, BUN w)\\
HASHloop\_str & (BAT *b; Hash *h, size\_t idx; str value, BUN w)\\
HASHlooploc & (BAT *b; Hash *h, size\_t idx; ptr value, BUN w)\\
HASHloopvar & (BAT *b; Hash *h, size\_t idx; ptr value, BUN w)\\
\hline
SORTloop& (BAT *b,p,q,tl,th,s) \\
\hline
IDXloop & (BAT *b, BUN p, BUN q)\\
IDXfrom & (BAT *b, BUN p, BUN q)\\
IDXstart & (BAT *b, BUN p, BUN q)\\
IDXend & (BAT *b, BUN p, BUN q)\\
IDXfirst & (BAT *b)\\
IDXlast & (BAT *b)\\
\hline\end{tabular}}

The {\em BATloop()} looks like a function call, but is actually a macro. 
The following example gives an indication of how they are to be used:
\begin{verbatim}
void print\_a\_bat (b)
BAT *b; 
{
        BUN p, q; 

        BATloop(b, p, q) 
        printf("Element %3d has value %d\n", 
                *(int*) BUNhead(b, p), *(int*) BUNtail(b, p)); 
}
\end{verbatim}

@{
@- simple sequential scan
The first parameter is a BAT, the p and q are BUN pointers, where
p is the iteration variable. 
@h
#define BATloop(r,	p, q) \
	for(q = BUNlast(r), p = BUNfirst(r);p < q; p = BUNnext(r, p))
#define BATloopFast(r,	p, q, x) \
	for(q = BUNlast(r), x = BUNsize(r), p = BUNfirst(r); p < q; p += x)

@- batloop where the current element can be deleted/updated
Normally it is @#strictly forbidden@ to update the BAT over which 
is being iterated, or delete the current element. This can only 
be done with the specialized batloop below. When doing a delete,
do not forget to update the current pointer with a p = @%BUNdelete@(b,p) 
(the delete may modify the current pointer p).
After the delete/update has taken place, the pointer p is in an 
inconsistent state till the next iteration of the batloop starts.
@h
#define BATloopDEL(r, p, q, x) \
	for(p = BUNfirst(r), q = BUNlast(r), x = BUNsize(r); p < q;\
	    q=MIN(q,BUNlast(r)), p += x)

@- sequential scan over deleted BUNs
Stable BUNS that were deleted, are conserved to transaction end. You may
inspect these data items.
Again, the b is a BAT, p and q are BUNs, where p is the iteration variable.
@h
#define DELloop(b,	p, q, x)\
	for(q = (b)->batHole, p = (b)->batDeleted, x=BUNsize(b); p < q; p += x)

@- hash-table supported loop over BUNs with a certain head-value 
The first parameter 'b' is a BAT, the second ('h') should point to
'b->hhash', and 'v' a pointer to an atomic value (corresponding to the
head column of 'b'). The 'hb' is an integer index, pointing out the
'hb'-th BUN. You should translate this index with @%BUNptr(b,hb)@ to
obtain a BUN from the iteration variable.
@h
#define HASHloop(b, h, hb, v) \
        for (hb = h.hash[HASHprobe(&h, v)]; hb; hb = h.link[hb])\
                if (ATOMcmp(h.type, v, BUNhead(b, BUNptr(b, hb))) == 0)
#define HASHloop_str(b,	h, hb, v) \
        for (hb = h.hash[strHash(v)&h.mask]; hb; hb = h.link[hb])\
                if (strcmp(v, BUNhvar(b, BUNptr(b, hb))) == 0)
@-
For string search, we can optimize if the string heap has eliminated
all doubles. This is the case when not too many different strings are
stored in the heap. You can check this with the macro @%strElimDoubles()@
If so, we can just compare integer index numbers instead of strings:
@h
#define HASHloop_fstr(b, h, hb, idx, v) \
        for (hb = h.hash[strHash(v)&h.mask], idx = strLocate(&(b)->hheap,v);\
	     hb; hb = h.link[hb]) if (*(var_t*) BUNhloc(b, BUNptr(b, hb)) == idx)
@
The following example shows how the hashloop is used:
@T
\begin{verbatim}
void print\_books (author\_books, author)
BAT *author\_books; 
str author;
{
        BAT *b = author\_books;
        size_t i; 

        printf("%s\n==================\n", author);
        HASHloop(b, (b)->hhash, i, author) 
                 printf("%s\n", ((str) BUNtail(b, BUNptr(b,i)));
}
\end{verbatim}
@
Note that for optimization purposes, we could have used a
@%HASHloop_str@ instead, and also a @%BUNtvar@ instead of
a @%BUNtail@ (since we know the tail-type of @%author_books@
is string, hence variable-sized). However, this would make the code
less general.

@- specialized hashloops
HASHloops come in various flavors, from the general @%HASHloop@, as
above, to specialized versions (for speed) where the type is known 
(e.g. @%HASHloop_int@), or the fact that the atom is fixed-sized 
(@%HASHlooploc@) or variable-sized (@%HASHloopvar@).
@
These hashloops have one extra parameter, a BUN pointer 'w' (again for
speed) which already points at the current BUN (i.e. w == @%BUNptr(b,hb)@).
@h
#define HASHlooploc(b,	h, hb, v, w) \
        for (hb = h.hash[HASHprobe(&h, v)]; hb; hb = h.link[hb])\
                if ((w=BUNptr(b, hb)) != NULL && ATOMcmp(h.type, v, BUNhloc(b, w)) == 0)
#define HASHloopvar(b,	h, hb, v, w) \
        for (hb = h.hash[HASHprobe(&h, v)]; hb; hb = h.link[hb])\
                if ((w=BUNptr(b, hb)) != NULL && ATOMcmp(h.type, v, BUNhvar(b, w)) == 0)

@:hashloop(bit,chr,simple,chr,hloc)@
@:hashloop(chr,chr,simple,chr,hloc)@
@:hashloop(sht,sht,simple,sht,hloc)@
@:hashloop(int,int,simple,int,hloc)@
#if SIZEOF_OID == SIZEOF_INT
@:hashloop(oid,int,simple,int,hloc)@ /* OIDDEPEND */
#else
@:hashloop(oid,lng,simple,lng,hloc)@ /* OIDDEPEND */
#endif
@:hashloop(bat,int,simple,int,hloc)@
#if SIZEOF_VOID_P == SIZEOF_INT
@:hashloop(ptr,int,simple,int,hloc)@
#else /* SIZEOF_VOID_P == SIZEOF_LNG */
@:hashloop(ptr,lng,simple,lng,hloc)@
#endif
@:hashloop(flt,int,simple,int,hloc)@
@:hashloop(lng,lng,simple,lng,hloc)@
@:hashloop(dbl,lng,simple,lng,hloc)@
@:hashloop(any,any,atom,(b)->htype,head)@

@= hashloop
#define HASHloop_@1(b,h,hb,v,w) \
        for (hb = h.hash[hash_@2(h,v)]; hb; hb = h.link[hb])\
                if ((w=BUNptr(b, hb)) != NULL && @3_EQ(v, BUN@5(b, w), @4))

@- loop over a BAT with ordered tail 
Here we loop over a BAT with an ordered tail column (see for instance 
@%BATsort@). Again, 'p' and 'q' are iteration variables, where 'p'
points at the current BUN. 'tl' and 'th' are pointers to atom 
corresponding to the minimum (included) and maximum (included) bound
in the selected range of BUNs. A nil-value means that there is no bound.
The 's' finally is an integer denoting the bunsize, used for speed.
@h
#define SORTloop(b,p,q,tl,th,s)\
	if (!(BATtordered(b)&1)) GDKerror("SORTloop: BAT not sorted.\n"); else\
        for (p = (ATOMcmp((b)->ttype,tl,ATOMnilptr((b)->ttype))?\
                SORTfndfirst(b,tl):BUNfirst(b)),\
             q = (ATOMcmp((b)->ttype,th,ATOMnilptr((b)->ttype))?\
                SORTfndlast(b,th):BUNlast(b)),\
             s = BUNsize(b); p < q; p += s)

@:sortloop(chr,chr,chr,simple,&chr_nil)@
@:sortloop(sht,sht,sht,simple,&sht_nil)@
@:sortloop(int,int,int,simple,&int_nil)@
@:sortloop(flt,flt,flt,simple,&flt_nil)@
@:sortloop(lng,lng,lng,simple,&lng_nil)@
@:sortloop(dbl,dbl,dbl,simple,&dbl_nil)@
@:sortloop(loc,loc,(b)->ttype,atom,ATOMnilptr((b)->ttype))@
@:sortloop(var,var,(b)->ttype,atom,ATOMnilptr((b)->ttype))@

@= sortloop
#define SORTloop_@1(b,p,q,tl,th,s)\
	if (!(BATtordered(b)&1)) GDKerror("SORTloop_@1: BAT not sorted.\n"); else\
        for (p = @4_EQ(tl,@5,@3)?BUNfirst(b):SORTfndfirst_@2(b,tl),\
             q = @4_EQ(th,@5,@3)?BUNfirst(b):SORTfndlast_@2(b,th),\
             s = BUNsize(b); p < q; p += s)

@- loops over BATs with a binary index
The @%IDXloop@ can be used to traverse BUNs of a BAT in order. You
need to have called @%BATidx@ first to create an index tree. Here you
need to initialize 'p' to the first BUN you want to traverse, and 'q'
to the last one. @%IDXfirst(b)@ gets you the first BUN in the index,
@%IDXlast(b)@ to the position after the last BUN. @%IDXfndfirst(b,v)@
goes to a first occurrence of a value, and @%IDXfndlast(b,v)@ to one
position after the  last occurrence of that value. 
@h
#define IDXfirst(b)	(b)->hidx.first
#define IDXlast(b)	(b)->hidx.last
#define IDXloop(b,p,q)	for (; p < q; p++)
#define IDXfrom(b,p,q)	for (p = IDXfndfirst(b, p); p < q; p++)
#define IDXstart(b,p,q)	for (p = IDXfirst(b); p < q; p++)
#define IDXend(b,p,q)	for (p = IDXlast(b)-1; p >= q; p--)

/* OIDDEPEND */
#if SIZEOF_OID == SIZEOF_INT
#define SORTfnd_oid(b,v)	SORTfnd_int(b,v) 
#define SORTfndfirst_oid(b,v)	SORTfndfirst_int(b,v) 
#define SORTfndlast_oid(b,v)	SORTfndlast_int(b,v) 
#define IDXfnd_oid(b,v)		IDXfnd_int(b,v)
#define IDXfndfirst_oid(b,v)	IDXfndfirst_int(b,v)
#define IDXfndlast_oid(b,v)	IDXfndlast_int(b,v)
#define SORTloop_oid(b,p,q,tl,th,s) SORTloop_int(b,p,q,tl,th,s) 
#else
#define SORTfnd_oid(b,v)	SORTfnd_lng(b,v) 
#define SORTfndfirst_oid(b,v)	SORTfndfirst_lng(b,v) 
#define SORTfndlast_oid(b,v)	SORTfndlast_lng(b,v) 
#define IDXfnd_oid(b,v)		IDXfnd_lng(b,v)
#define IDXfndfirst_oid(b,v)	IDXfndfirst_lng(b,v)
#define IDXfndlast_oid(b,v)	IDXfndlast_lng(b,v)
#define SORTloop_oid(b,p,q,tl,th,s) SORTloop_lng(b,p,q,tl,th,s) 
#endif
#define SORTloop_bit(b,p,q,tl,th,s) SORTloop_chr(b,p,q,tl,th,s) 
@
@}


@+ Common BAT Operations
@T
\label{Common BAT Operations}
Much used, but not necessarily kernel-operations on BATs.

@- BAT aggregates
@T
{\tt \begin{tabular}{|lll|}\hline
BAT* & BAThistogram & (BAT *b)\\
BAT* & BATsample& (BAT* b,size\_t n)\\
\hline\end{tabular}}
@
The routine @%BAThistogram@ produces a new BAT with a frequency distribution
of the tail of its operand.
@
The routine @%BATsample@ returns a random sample on n BUNs of a BAT.
@
For each BAT we maintain its dimensions as separately accessible
properties. They can be used to improve query processing at higher levels.

@{
@h

#define GDK_AGGR_SIZE 1
#define GDK_AGGR_CARD 2
#define GDK_AGGR_HASNIL 3 

gdk_export int		BATgetaggr   (BAT *b, int idx);
gdk_export int		BATsetaggr   (BAT *b, int idx, int val);
gdk_export BAT*		BATsample    (BAT *b, size_t n);
gdk_export BAT*		BAThistogram (BAT *b); 
gdk_export size_t 	BATtopN(BAT *b, size_t topN);         /* used in monet5/src/modules/kernel/algebra.mx */
 
@}
@- alignment-id transformations
@T
Some classes of algebraic operators transform a sequence in an input BAT 
always in the same way in the output result. An example are the \{X\}()
function (including histogram(b), which is identical to \{count\}(b.reverse)).

That is to say, if synced(b2,b2) => synced(\{X\}(b1),\{Y\}(b2)) 

Another example is b.fetch(position-bat). If synced(b2,b2) and the same
position-bat is fetched with, the results will again be synced.

This can be mimicked by transforming the {\em alignment-id} of the input
BAT with a one-way function onto the result.

We use {\bf output->halign = NOID\_AGGR(input->halign)} for the 
{\bf output = \{X\}(input)} case, and
{\bf output->align = NOID\_MULT(input1->align,input2->halign)} for 
the fetch. 
@{
@h
#define AGGR_MAGIC	111
#define NOID(x)		((oid)(x))
#define NOID_AGGR(x)	NOID_MULT(AGGR_MAGIC,x)
#define NOID_MULT(x,y)	NOID( (lng)(y)*(lng)(x) )


@}
@- BAT relational operators
@T
{\tt \begin{tabular}{|lll|}\hline
BAT * & BATjoin & (BAT *l, BAT *r, size\_t estimate)\\
BAT * & BATouterjoin & (BAT *l, BAT *r, size\_t estimate)\\
BAT * & BATbandjoin & (BAT *l, BAT *r, ptr c1, ptr c2)\\
BAT * & BATthetajoin & (BAT *l, BAT *r, int mode, size\_t estimate)\\
BAT * & BATsemijoin & (BAT *l, BAT *r)\\
BAT * & BATselect & (BAT *b, ptr tl, ptr th)\\
BAT * & BATfragment & (BAT *b, ptr l, ptr h, ptr L, ptr H)\\
\hline
BAT * & BATsunique & (BAT *b)\\
BAT * & BATkunique & (BAT *b)\\
BAT * & BATsunion & (BAT *b, BAT *c)\\
BAT * & BATkunion & (BAT *b, BAT *c)\\
BAT * & BATsintersect & (BAT *b, BAT *c)\\
BAT * & BATkintersect & (BAT *b, BAT *c)\\
BAT * & BATsdiff & (BAT *b, BAT *c)\\
BAT * & BATkdiff & (BAT *b, BAT *c)\\
\hline\end{tabular}}
@
The BAT library comes with a full-fledged collection of relational
operators. The two selection operators @%BATselect@ and
@%BATfragment@ produce a partial copy of the BAT. The former performs
a search on the tail; the latter considers both dimensions.  The
@%BATselect@ operation takes two inclusive ranges as search arguments.
Interpretation of a NULL argument depends on the position, i.e. a
domain lower or upper bound.
@
The operation @%BATsort@ sorts the BAT on the header and produces a new
BAT. A side effect is the clustering of the BAT store on the sort key.
@
The @%BATjoin@ over R[A, B] and S[C, D] performs an equi-join over B
and C. It results in a BAT over A and D.  The @%BATouterjoin@
implements a left outerjoin over the BATs involved.  The
@%BATbandjoin@ produces the associations [A, D] such that S.C-c1 <=
R.b <= S.C + c2.  The special case c1 = 0 and c2 = infinite leads to a
thetajoin.  The @%BATsemijoin@ over R[A, B] and S[C, D] produces the
subset of R[A, B] that satisfies the semijoin over A and C.
@
The full-materialization policy intermediate results in Monet means that a 
join can produce an arbitrarily large result and choke the system. The Data 
Distilleries tool therefore first computes the join result size before the 
actual join (better waste time than crash the server). To exploit that perfect 
result size knowledge, an result-size estimate parameter was added to all 
equi-join implementations.  
TODO: add this for semijoin/select/unique/diff/intersect
@
The routine @%BATsunique@ considers both dimensions in the double
elimination it performs; it produces a set.
The routine @%BATtunique@ considers only the head column,
and produces a unique head column.
@
BATs that satisfy the set property can be further processed with the
set operations @%BATsunion@, @%BATsintersect@, and @%BATsdiff@.  
The same operations are also available in versions that only
look at the head column:@%BATkunion@, @%BATkdiff@, and
@%BATkintersect@ (which shares its implementation with @%BATsemijoin@). 
@{
@- modes for thethajoin 
@h
#define JOIN_EQ	0
#define JOIN_LT	-1
#define JOIN_LE	-2
#define JOIN_GT	1
#define JOIN_GE	2
#define JOIN_BAND 3

gdk_export BAT*	BATfragment  (BAT *b, ptr hl, ptr hh, ptr tl, ptr th); 
gdk_export BAT*	BAT_select_  (BAT *b, ptr tl, ptr th, bit li, bit hi, bit tail, bit preserve_order); 
gdk_export BAT*	BAT_select   (BAT *b, ptr tl, ptr th, bit tail); 
gdk_export BAT*	BATselect_   (BAT *b, ptr tl, ptr th, bit li, bit hi); 
gdk_export BAT*	BATuselect_  (BAT *b, ptr tl, ptr th, bit li, bit hi); 
gdk_export BAT*	BATselect    (BAT *b, ptr tl, ptr th); 
gdk_export BAT*	BATuselect   (BAT *b, ptr tl, ptr th); 
gdk_export BAT*	BATrestrict  (BAT *b, ptr hl, ptr hh, ptr tl, ptr th); 

gdk_export BAT*	BATconst     (BAT *l, int tt, ptr val);
gdk_export BAT*	BATindexjoin (BAT *l, BAT *r, size_t estimate); 
gdk_export BAT*	BATleftindexjoin (BAT *l, BAT *r, size_t estimate); 
gdk_export BAT*	BATthetajoin (BAT *l, BAT *r, int mode, size_t estimate); 
gdk_export int	BATtheta     (BAT* in, BAT* out, BAT *l, BAT *r, int mode);
gdk_export BAT*	BATbandjoin  (BAT *l, BAT *r, ptr c1, ptr c2);  /* should bandjoin remain in the kernel? */
gdk_export BAT*	BATsemijoin  (BAT *l, BAT *r); 
gdk_export BAT*	BATmergejoin (BAT *l, BAT *r, size_t estimate); 
gdk_export BAT*	BATleftmergejoin (BAT *l, BAT *r, size_t estimate); 
gdk_export BAT*	BATjoin      (BAT *l, BAT *r, size_t estimate); 
gdk_export BAT*	BATleftjoin  (BAT *l, BAT *r, size_t estimate); 
gdk_export BAT*	BATouterjoin (BAT *l, BAT *r, size_t estimate); 
gdk_export BAT*	BATcross     (BAT *l, BAT *r); 

gdk_export BAT* 	BATslice     (BAT* b, size_t low, size_t high);
gdk_export BAT* 	BATfetch     (BAT* b, BAT *s);
gdk_export BAT* 	BATfetchjoin (BAT* b, BAT *s, size_t estimate);
gdk_export BAT* 	BATleftfetchjoin (BAT* b, BAT *s, size_t estimate);

gdk_export BAT*	BATsunique   (BAT *b); 
gdk_export BAT*	BATkunique   (BAT *b); 
gdk_export BAT*	BATukunique  (BAT *b); 
gdk_export BAT*	BATsintersect(BAT *b, BAT *c); 
gdk_export BAT*	BATkintersect(BAT *b, BAT *c); 
gdk_export BAT*	BATsunion    (BAT *b, BAT *c); 
gdk_export BAT*	BATkunion    (BAT *b, BAT *c); 
gdk_export BAT*	BATsdiff     (BAT *b, BAT *c); 
gdk_export BAT*	BATkdiff     (BAT *b, BAT *c); 

/* generic n-ary multijoin beast, with defines to interpret retval */
#define MULTIJOIN_SORTED(r)	((char*) &r)[0]
#define MULTIJOIN_KEY(r)	((char*) &r)[1]
#define MULTIJOIN_SYNCED(r)	((char*) &r)[2]
#define MULTIJOIN_LEAD(r)	((char*) &r)[3]

typedef void (*ColFcn)(ptr,ptr);
typedef void (*RowFcn)(ptr,ptr*);

gdk_export int	BATmultijoin (int argc, BAT *argv[], RowFcn tuple_fcn,
				ptr tuple_data, ColFcn value_fcn[],
				ptr value_data[], int orderspec);

#ifdef __cplusplus
}
#endif
@
@- GDK variant record type
When manipulating values, Monet puts them into value records.
The built-in types have a direct entry in the union. Others should 
be represented as a pointer of memory in pval or as a string, which
is basically the same. In such cases the @%len@ field indicates
the size of this piece of memory.

@h
typedef struct {
	bat	id;
	int	stamp;
} batrec;

typedef struct {
	union {                 /* storage is first in the record */
		int	ival;
		oid	oval;
		sht	shval;
		chr	cval[4];
		flt	fval;
		ptr	pval;
		bat	bval;
		batrec	br;	/* bval + stamp */
		str    	sval;
		dbl	dval;
		lng	lval;
	} val;
	int 		vtype;
	int 	       	len;
} *ValPtr, ValRecord;

#define VALptr(v) (ATOMextern((v)->vtype)?(v)->val.pval:(ptr)&(v)->val.ival)
#define VALnil(v,t) VALset(v,t,ATOMextern(t)?ATOMnil(t):ATOMnilptr(t))

/* interface definitions */
gdk_export ValPtr	VALnew		(void);
gdk_export ptr	VALconvert	(int typ, ValPtr t);
gdk_export int	VALformat	(char **buf, ValPtr res);
gdk_export int	VALprint	(stream *fd, ValPtr res);
gdk_export ValPtr	VALcopy		(ValPtr dst, ValPtr src);
gdk_export void	VALempty	(ValPtr v);
gdk_export void	VALclear	(ValPtr v);
gdk_export ValPtr	VALset		(ValPtr v, int t, ptr p);
gdk_export void	*VALget		(ValPtr v);

#define ILLEGALVALUE	((ptr)-1L)
#define MAXPARAMS	32

#endif /* _GDK_H_ */
@
@}
@T
%\bibliographystyle{plain}
\bibliography{gdk}
@}
