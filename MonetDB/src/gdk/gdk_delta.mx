@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2005 CWI.
@' All Rights Reserved.

@f gdk_delta
@a M. L. Kersten, P. Boncz
@* Delta management
The basis for transaction management is to keep track of
elements inserted, deleted, and replaced.
This information is stored within the BAT structure using three
delta markers.
Inserted denotes
the first added BUN since the last commit. Deleted points to the BUNs removed.
The deletion list is terminated at @%hole@, where space is reserved for swapping
BUNs upon deletion. Initialization of the BAT is extended as follows:

@{
@h
#ifndef _GDK_DELTA_H_
#define _GDK_DELTA_H_
#include "gdk.h"

@-
We make sure here that the BUNs section of a BAT at least starts 
4 bytes from the BUN start.  This ensures that the first data 
item of e.g. a BAT[void,bit] is (at least) integer aligned. 
This optimizes processing on such BATs (DDBENCH).
@h
#define DELTAprintf DELTADEBUG printf
#define DELTAinit(P1)	{						      \
	(P1)->batBuns->free = MAX(sizeof(int), (P1)->dims.bunwidth);	      \
	(P1)->batDeleted = (P1)->batHole = (BUN) ((char*) Bunbase(P1) +	      \
			((P1)->batBuns->free - (P1)->dims.bunwidth));	      \
	(P1)->batInserted = BUNlast((P1));				      \
	(P1)->batElmshift = BATelmshift((P1));				      \
	DELTAprintf(							      \
	 	"#DELTAinit %s free " SZFMT " ins " PTRFMT " del " PTRFMT " hole " PTRFMT " base " PTRFMT "\n", \
		(P1)->batId,				      \
		(P1)->batBuns->free,			      \
		PTRFMTCAST (P1)->batInserted,		      \
		PTRFMTCAST (P1)->batDeleted,		      \
		PTRFMTCAST (P1)->batHole,		      \
		PTRFMTCAST (P1)->batBuns->base );	      \
	memset((P1)->batHole, 0, BUNsize(P1));		      \
}
@

Upon saving a BAT, we should convert the delta marker BUN pointers into indexes
and convert them back into pointers upon reload.

@h
#define DELTAsave(P1)	{						      \
	if ((P1)->batBuns->base) {					      \
		(P1)->batInserted = (BUN) BUNindex((P1), (P1)->batInserted);  \
		(P1)->batDeleted = (BUN) BUNindex((P1), (P1)->batDeleted);    \
		(P1)->batHole = (BUN) BUNindex((P1), (P1)->batHole);	      \
	}								      \
	DELTAprintf(							      \
	 	"#DELTAsave %s free " SZFMT " ins " PTRFMT " del " PTRFMT " hole " PTRFMT " base " PTRFMT "\n", \
		(P1)->batId,				      \
		(P1)->batBuns->free,			      \
		PTRFMTCAST (P1)->batInserted,		      \
		PTRFMTCAST (P1)->batDeleted,		      \
		PTRFMTCAST (P1)->batHole,		      \
		PTRFMTCAST (P1)->batBuns->base );	      \
}

#define DELTAload(P1)	{						      \
	DELTAprintf(							      \
		"#DELTAload %s free " SZFMT " ins " PTRFMT " del " PTRFMT " hole " PTRFMT " base " PTRFMT "\n", \
		(P1)->batId,				      \
		(P1)->batBuns->free,			      \
		PTRFMTCAST (P1)->batInserted,		      \
		PTRFMTCAST (P1)->batDeleted,		      \
		PTRFMTCAST (P1)->batHole,		      \
		PTRFMTCAST (P1)->batBuns->base );	      \
	if ((P1)->batBuns->base) {					      \
		(P1)->batInserted = BUNptr((P1), (size_t) (P1)->batInserted); \
		(P1)->batDeleted = BUNptr((P1), (size_t) (P1)->batDeleted);   \
		(P1)->batHole = BUNptr((P1), (size_t) (P1)->batHole);	      \
	}								      \
}
@	
@}
@-
The b->batDirty field tells you whether a BATs main memory representation
differs from its saved image on stable storage. But *not* whether it has
changed since last transaction commit (it can be storage-clean, but 
transaction-dirty). For this we have @%DELTAdirty(b)@.
@-
@{
@h
#define DELTAdirty(b)	(((b)->batDeleted != (b)->batHole) ||\
	((b)->batInserted < (b)->batBuns->base+(b)->batBuns->free)) 

#define DELTAnexthole(b)						\
	DELTAprintf( "#DELTAnexthole %s \n", (b)->batId );		\
	(b)->batHole = (b)->batHole + BUNsize(b);			\
	if (b->batInserted <= b->batHole) {				\
		b->batInserted = (b)->batHole + BUNsize(b);		\
	}
#define DELTAhole(b)							\
       	(b)->batHole
#define DELTAloop(b,	p, q)						\
	for (p = b->batDeleted; p < b->batHole; BUNnext(b, p))
@-
@%DELTAstart@ marks all BUNs as committed;
@h
#define DELTAstart(b)	(b)->batInserted = BUNlast(b);
@-
@%DELTArestart@ marks all BUNs as were they newly inserted.
@h
#define DELTArestart(b)	(b)->batInserted = BUNfirst(b);

#endif /* _GDK_DELTA_H_ */
@

@- 
Impact on hashing and indexing.
The hash structure is maintained for all elements to be deleted ?.

@c
#include "gdk.h"


BAT *BATprecommit (BAT *b) {
	GDKwarning("BATprecommit:nyi\n"); 
	return b; 
}
@- 
batcommit really forgets the atoms guarded for an undo; we just need to free their heap space (only if necessary).
@c
BAT *BATcommit(BAT *b) {
	BATcheck(b, "BATcommit");
	DELTAprintf(
		"#BATcommit1 %s free " SZFMT " ins " PTRFMT " del " PTRFMT " hole " PTRFMT " base " PTRFMT "\n", 
		b->batId, b->batBuns->free,
		PTRFMTCAST b->batInserted, PTRFMTCAST b->batDeleted,
		PTRFMTCAST b->batHole, PTRFMTCAST b->batBuns->base);
	ALIGNcommit(b);
	if (b->batDeleted < b->batHole  && BBP_cache(b->batCacheid)) {
		int (*hunfix)(ptr) = BATatoms[b->htype].atomUnfix;
		int (*tunfix)(ptr) = BATatoms[b->ttype].atomUnfix;
		void (*hatmdel)(Heap*,var_t*) = BATatoms[b->htype].atomDel;
		void (*tatmdel)(Heap*,var_t*) = BATatoms[b->ttype].atomDel;
		BUN p,q;
		int xx;

		if (hatmdel || hunfix || tatmdel || tunfix) {
		DELloop(b, p, q, xx) {
			ptr h = BUNhead(b,p);
			ptr t = BUNtail(b,p);

			if (hunfix) {
				(*hunfix)(h);
			}
			if (hatmdel) {
				(*hatmdel)(&b->hheap,(var_t*)(h));
			}
			if (tunfix) {
				(*tunfix)(t);
			}
			if (tatmdel) {
				(*tatmdel)(&b->theap,(var_t*)(t));
			}
		}}
	}
        if (!BATdirty(b)) {
		b->batDirtyflushed = 0;
	}
	if (DELTAdirty(b)) {
		b->batDirtydesc = 1;
	}
	b->batDeleted = b->batHole; 
	if (b->batBuns->base) {
		b->batInserted = BUNlast(b); 
	} else {
		b->batInserted = (BUN) (b->batBuns->free / BUNsize(b));
	}
	DELTAprintf(
		"#BATcommit2 %s free " SZFMT " ins " PTRFMT " del " PTRFMT " hole " PTRFMT " base " PTRFMT "\n", 
		b->batId, b->batBuns->free,
		PTRFMTCAST b->batInserted, PTRFMTCAST b->batDeleted,
		PTRFMTCAST b->batHole, PTRFMTCAST b->batBuns->base);
	return b; 
}
@-
BATfakeCommit() flushed the delta info, but leaves the BAT marked clean.
@c 
BAT *BATfakeCommit(BAT *b) {
	if (b) { 
		BATcommit(b);
		b->batDirty = 0;
		b->batDirtydesc = b->batDirtybuns = 0;
		b->haccdirty = b->taccdirty = 0;
		b->hheapdirty = b->theapdirty = 0;
	}
	return b;
}
@
@}
@- 
The routine @%BATundo@ restores the BAT to the previous commit point.
The inserted elements are removed from the accelerators, deleted from the
heap. The guarded elements from uncommitted deletes are
inserted into the accelerators.
@-
@{
@c
BAT *BATundo(BAT *b) {
	int bunsize = BUNsize(b);
	BUN p, bunlast, bunfirst; 
	BAT *m = BATmirror(b);

	BATcheck(b, "BATundo");
	DELTAprintf( "#BATundo %s \n", b->batId );		
	ALIGNundo(b);
	if (b->hidx_heap || b->tidx_heap) {
		IDXdestroy(b); 
	}
	if (b->batDirtyflushed) {
		b->batDirtydesc = b->batDirtybuns = 1;
		b->haccdirty = b->taccdirty = 1;
	} else {
		b->batDirty = 0;
		b->batDirtydesc = b->batDirtybuns = 0;
		b->haccdirty = b->taccdirty = 0;
		b->hheapdirty = b->theapdirty = 0;
	}
	bunfirst = b->batInserted;
	bunlast = BUNlast(b) - BUNsize(b); 
	if (bunlast >= b->batInserted) {
		size_t i = BUNindex(b, bunfirst);
		int (*hunfix)(ptr) = BATatoms[b->htype].atomUnfix;
		int (*tunfix)(ptr) = BATatoms[b->ttype].atomUnfix;
		void (*hatmdel)(Heap*, var_t*) = BATatoms[b->htype].atomDel;
		void (*tatmdel)(Heap*, var_t*) = BATatoms[b->ttype].atomDel;
		void (*haccdel)(Heap*,var_t,BAT*,ptr) = 
			BATaccelerators[(b->hacctype>0)?b->hacctype:0].accDelete;
		void (*taccdel)(Heap*,var_t,BAT*,ptr) = 
			BATaccelerators[(b->tacctype>0)?b->tacctype:0].accDelete;
               
		if (hunfix || tunfix || hatmdel || tatmdel || haccdel || taccdel) {
		for(p = bunfirst; p <= bunlast; p += bunsize, i++) { 
			ptr h = BUNhead(b,p);
			ptr t = BUNtail(b,p);

                	if (b->hhash_heap) {
				HASHdel(b->hhash, i, h, p < bunlast);
			}
			if (hunfix) {
				(*hunfix)(h);
			}
			if (haccdel) {
				(*haccdel)(&b->haccelerator, i, b, h);
			}
			if (hatmdel) {
				(*hatmdel)(&b->hheap, (var_t*) (p+b->hloc));
			}
                	if (b->thash_heap) {
				HASHdel(b->thash, i, t, p < bunlast);
			}
			if (tunfix) {
				(*tunfix)(t);
			}
			if (taccdel) {
				(*taccdel)(&b->taccelerator, i, b, t);
			}
			if (tatmdel) {
				(*tatmdel)(&b->theap, (var_t*) (p+b->tloc));
			}
		}}
	}
	b->batBuns->free = (char *) b->batInserted - (char *) Bunbase(b);

	bunfirst = b->batDeleted+bunsize;
	bunlast = b->batHole;
	if (bunlast > b->batDeleted) { 
		size_t i = BUNindex(b, bunfirst);
		void (*haccins)(Heap*,var_t,BAT*,ptr) = 
			BATaccelerators[(b->hacctype>0)?b->hacctype:0].accInsert;
		void (*taccins)(Heap*,var_t,BAT*,ptr) = 
			BATaccelerators[(b->tacctype>0)?b->tacctype:0].accInsert;

		memcpy(b->batHole, b->batDeleted, bunsize);

		/* elements are 'inserted' => zap properties */
		if (b->hsorted&1) b->hsorted = FALSE;
		if (b->tsorted&1) b->tsorted = FALSE;
		if (b->hkey) BATkey(b, FALSE);
		if (b->tkey) BATkey(BATmirror(b), FALSE);

		for(p = bunfirst; p < bunlast; p += bunsize, i++) { 
			ptr h = BUNhead(b,p);
			ptr t = BUNtail(b,p);

			if (b->hhash_heap) {
				HASHins(b->hhash, i, h);
	    		} 
			if (haccins) {
				(*haccins)(&b->hheap, i, m, h);
			}
            		if (b->thash_heap) {
				HASHins(b->thash, i, t);
	    		}
			if (taccins) {
				(*taccins)(&b->theap, i, m, t);
	    		}
		}
	}
	b->batHole = b->batDeleted; 
	return b; 
}
@}
@- 
The proposed modifications can be obtained through the @%BATalpha@
and @%BATdelta@ routines , which return the inserted and deleted BUNs, 
respectively.
@{
@c
BAT *BATalpha(BAT *b) {
	BUN	p; 
	BAT	*bn; 
	
	BATcheck(b, "BATalpha");
	bn = BATnew(BAThtype(b), BATttype(b), BATcapacity(b)); 
	if (bn == NULL) {
		return bn; 
	}
	for (p = b->batInserted; p < BUNlast(b); p = BUNnext(b, p)) {
		if (BUNins(bn, BUNhead(b, p), BUNtail(b, p)) == NULL) {
			BBPreclaim(bn);
			return NULL;
		} 
	}
	return bn; 
}

BAT *BATdelta(BAT *b) {
	BUN	p; 
	BAT	*bn; 
	
	BATcheck(b, "BATdelta");
	bn = BATnew(BAThtype(b), BATttype(b), BATcapacity(b)); 
	if (bn == NULL) {
		return bn; 
	}
	for (p = b->batDeleted; p < b->batHole; p = BUNnext(b, p)) {
		if (BUNins(bn, BUNhead(b, p), BUNtail(b, p)) == NULL) {
			BBPreclaim(bn);
			return NULL;
		} 
	}
	return bn; 
}
@
@- 
The event status associated with a BAT can be inspected by simple routines.
@c
int BATdeltaEvent(BAT *b) {
	BATcheck(b, "BATdeltaEvent");
	return BUNindex(b, b->batHole) > BUNindex(b, b->batDeleted); 
}

int BATalphaEvent(BAT *b) {
	BATcheck(b, "BATalphaEvent");
	return BUNindex(b, BUNlast(b)) > BUNindex(b, b->batInserted); 
}

@}
