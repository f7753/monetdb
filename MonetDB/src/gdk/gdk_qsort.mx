@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@' 
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@' 
@' The Original Code is the Monet Database System.
@' 
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2003 CWI.
@' All Rights Reserved.
@' 
@' Contributor(s):
@' 		Martin Kersten <Martin.Kersten@cwi.nl>
@' 		Peter Boncz <Peter.Boncz@cwi.nl>
@' 		Niels Nes <Niels.Nes@cwi.nl>
@' 		Stefan Manegold  <Stefan.Manegold@cwi.nl>

@f gdk_qsort
@a Peter Boncz et al
@* Qsort
@T
There were two problems with the OS provided qsort() library routine:
\begin{description}
\item[unreliable] on certain OSs (e.g. SunOS), the qsort somehow degenerates
if there are a very small number of different values (on 132K elements with 7 
values, I never saw it return). This is a serious bug.
\item[atom format] when comparing GDK atoms (e.g. in BATs) it was not
possible to use qsort on varsized atoms (as monet stores them as
integer offsets from a global base pointer that qsort does not know about),
nor if the values were not placed at the start of the record (e.g.
if the column is the tail column of a BAT).
\end{description}

Both these problems are fixed in the new @7GDKqsort@ function, that
is based on the standard Berkeley qsort (see copyright notice below).

The routine was "monet"-ified with macro code expansions for the specific
datatypes to obtain extra speed (we know more about our data than the stdlib 
qsort() ever can).
@c
#include "gdk.h"

/*-
 * Copyright (c) 1992, 1993
 *      The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by the University of
 *      California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

@-
Record containing all data-specific info.
Introduced to reduce number of qsort parameters 
@c
typedef struct {
	int		(*cmp)();	/* routine that compares two atoms */
	char*		offset;		/* NULL or start of varsized heap */ 
	int		loc;		/* byte-offset of sort atom in record */
	int 		shift;		/* log2 if width is a power of two, else -1 */ 
	int		width;		/* byte-width of record */
} buf_t; 

/* fast arithmetic on the record width */
#define MULT_WIDTH(d)					\
	((buf->shift == -1)?				\
		((d) * buf->width):			\
		((d) << buf->shift))

#define DIV_WIDTH(d)					\
	((buf->shift == -1)?				\
		((d) / buf->width):			\
		((d) >> buf->shift))


/* fast record swapping */
#define register_SWAP(TYPE, a, b) {			\
	lng *_pa = (lng *) (((char*) (a)) - buf->loc);	\
	lng *_pb = (lng *) (((char*) (b)) - buf->loc);	\
	lng _tmp = *_pa;				\
	*_pa = *_pb;					\
	*_pb = _tmp;					\
}

#define tpe_SWAP(TYPE, a, b, n) {			\
	int _i = (n)/sizeof(TYPE);			\
	TYPE *_pa = (TYPE*) (((char*) (a)) - buf->loc);	\
	TYPE *_pb = (TYPE*) (((char*) (b)) - buf->loc);	\
	do { 						\
		TYPE _tmp = *_pa;			\
		*_pa++ = *_pb;				\
		*_pb++ = _tmp;				\
        } while (--_i > 0);				\
}

#define iterate_SWAP(TYPE, a, b)			\
	tpe_SWAP(TYPE, a, b, buf->width)

#define multi_SWAP(TYPE, a, b, n)			\
	if ((n) > 0) tpe_SWAP(TYPE, a, b, n)

@T
qsort is macro expanded in three dimensions:
\begin{description}
\item[type:7] 
	in order to factor out a type-specific check, or a function call for each 
	value comparison, we separate different qsort implementations by the comparision 
	type, of which each has the comparision hard-coded. We factor out the types 
	\{chr,sht,int,flt,lng,dbl,any\} (the latter uses an adt function call).
\item[storage:2]
	denoted \{direct,offset\}, means whether the array to be sorted contains the 
	(fixed-width) values itself, or whether it contains integer byte-offets, that point 
	into some heap. Note that we support byte-offset qsort also on fixed-size types, 
	as this is handy in many cases.
\item[swapmethod:2]
	qsort sorts an array by continually swapping entries. To do this, two
	implementations of the swap action are supported: \{iterate,register\}. 
	The default implementation takes the comparision type and does the swapping by 
	iterating a number of times per entry, copying one comparsion value per iteration. 
	One often-occurring special case is when the entry width is 8 (two integers). These 
	can be copied by one long integer load and store; without the loop overhead.
\end{description}
Thus, there are 7 * 2 * 2 = 28 GDKqsort implementation routines.
@c
#define offset(p) 		(buf->offset + *(int*) (p))
#define direct(p) 		(p)

#define any_CMP(a,b)		(buf->cmp)(a,b)
#define any_MED3(a,b,c,A,B,C)				\
	(buf->cmp)(a,b) < 0 ?				\
		((buf->cmp)(b,c) < 0 ?			\
			(B):				\
			((buf->cmp)(a,c) < 0 ?		\
				(C):			\
				(A))):			\
		((buf->cmp)(c,b) < 0 ?			\
			(B):				\
			((buf->cmp)(a,c) < 0 ?		\
				(A):			\
				(C)))
typedef chr any;
@:qsort_storage(any)@
@:qsort_cmptype(chr)@
@:qsort_cmptype(sht)@
@:qsort_cmptype(int)@
@:qsort_cmptype(flt)@
@:qsort_cmptype(dbl)@
@:qsort_cmptype(lng)@

@= qsort_cmptype
#define @1_CMP(a,b)                                     \
	((*(@1*) (a) < *(@1*) (b))?                     \
 		-1:                                     \
		(*(@1*) (a) != *(@1*) (b)))
#define @1_MED3(a,b,c,A,B,C)                            \
	((*(@1*) (a) < *(@1*) (b))?                     \
		((*(@1*) (b) < *(@1*) (c))?             \
			(B):                            \
			((*(@1*) (a) < *(@1*) (c))?     \
				(C):                    \
				(A))):                  \
		((*(@1*) (c) < *(@1*) (b))?             \
			(B):                            \
			((*(@1*) (a) < *(@1*) (c))?     \
				(A):                    \
				(C))))
@:qsort_storage(@1)@

@= qsort_storage
@:qsort_swap(direct,@1)@
@:qsort_swap(offset,@1)@

@= qsort_swap
#define @1_@2_MED3(a,b,c,buf)	@2_MED3(@1(a),@1(b),@1(c),a,b,c)
#define @1_@2_CMP(a,b)		@2_CMP(@1(a),@1(b))

@:qsort_algo(register,@1,@2)@
@:qsort_algo(iterate,@1,@2)@

@= qsort_algo
static 
void GDKqsort_@1_@2_@3(char *a, size_t n, buf_t *buf) {
	char *pa, *pb, *pc, *pd, *pl, *pm, *pn;
	int d, r, swap_cnt;

	/* Qsort routine from Bentley & McIlroy's "Engineering a Sort Function".  */
loop:	swap_cnt = 0;
	if (n < 7) {
		for (pm = (char *) a + buf->width; pm < (char *) a + MULT_WIDTH(n); pm += buf->width)
			for (pl = pm; pl > (char *) a && @2_@3_CMP(pl - buf->width, pl) > 0;
			     pl -= buf->width)
				@1_SWAP(@3, pl, pl - buf->width);
		return;
	}
	pm = (char *) a + MULT_WIDTH(n >> 1);
	if (n > 7) {
		pl = a;
		pn = (char *) a + MULT_WIDTH(n - 1);
		if (n > 40) {
			d = MULT_WIDTH(n >> 3);
			pl = @2_@3_MED3(pl, pl + d, pl + 2 * d, buf);
			pm = @2_@3_MED3(pm - d, pm, pm + d, buf);
			pn = @2_@3_MED3(pn - 2 * d, pn - d, pn, buf);
		}
		pm = @2_@3_MED3(pl, pm, pn, buf);
	}
	@1_SWAP(@3, a, pm);
	pa = pb = (char *) a + buf->width;
	pc = pd = (char *) a + MULT_WIDTH(n - 1);

	while(TRUE) {
		while (pb <= pc && (r = @2_@3_CMP(pb, a)) <= 0) {
			if (r == 0) {
				swap_cnt = 1;
				@1_SWAP(@3, pa, pb);
				pa += buf->width;
			}
			pb += buf->width;
		}
		while (pb <= pc && (r = @2_@3_CMP(pc, a)) >= 0) {
			if (r == 0) {
				swap_cnt = 1;
				@1_SWAP(@3, pc, pd);
				pd -= buf->width;
			}
			pc -= buf->width;
		}
		if (pb > pc) {
			break;
		}
		@1_SWAP(@3, pb, pc);
		swap_cnt = 1;
		pb += buf->width;
		pc -= buf->width;

	}
	if (swap_cnt == 0) {  /* Switch to insertion sort */
		for (pm = (char *) a + buf->width; pm < (char *) a + MULT_WIDTH(n); pm += buf->width)
			for (pl = pm; pl > (char *) a && @2_@3_CMP(pl - buf->width, pl) > 0; 
			     pl -= buf->width)
				@1_SWAP(@3, pl, pl - buf->width);
		return;
	}

	pn = (char *) a + MULT_WIDTH(n);
	r = MIN(pa - (char *)a, pb - pa);
	multi_SWAP(@3, a, pb - r, r);
	r = MIN(pd - pc, pn - pd - buf->width);
	multi_SWAP(@3, pb, pn - r, r);
	if ((r = pb - pa) > buf->width)
		GDKqsort_@1_@2_@3(a, DIV_WIDTH(r), buf);
	if ((r = pd - pc) > buf->width) { 
		/* Iterate rather than recurse to save stack space */
		a = pn - r;
		n = DIV_WIDTH(r);
		goto loop;
	}
}

@= call_qsort2
/* factorization by storage mode */
if (base) {
	GDKqsort_@2_offset_@1(((char*) a)+loc, n, &buf); /* array of integers, that are byte-offsets from some base */
} else {
	GDKqsort_@2_direct_@1(((char*) a)+loc, n, &buf); /* array of fixed-size values */
} 

@= call_qsort1
/* factorization by array swap implementation */
if ((((long) a)&7) || width != 8) {
	@:call_qsort2(@1,iterate)@	/* array is non-aligned or entries are not one 64-bit integer wide */
} else {
	@:call_qsort2(@1,register)@	/* we can swap array entries by one 64-bit integer swap */
} break;
@c
void GDKqsort(void *a, void* base, int n, int width, int tpe, int loc) {
	int i = 0;
	buf_t buf;

	/* init the qsort record */
	buf.cmp = BATatoms[tpe].atomCmp;
	buf.offset = base;
	buf.width = width;
	buf.loc = loc;
	buf.shift = -1;
	do {
		int mask = 1 << i; 
		if ((width&mask) && (width & ~mask) == 0) {
			buf.shift = i; break;
		}
	} while(++i < 32);

	/* factorization by comparsion type */
	switch(ATOMstorage(tpe)) {
	case TYPE_chr: @:call_qsort1(chr)@
	case TYPE_sht: @:call_qsort1(sht)@
	case TYPE_int: @:call_qsort1(int)@
	case TYPE_flt: @:call_qsort1(flt)@
	case TYPE_lng: @:call_qsort1(lng)@
	case TYPE_dbl: @:call_qsort1(dbl)@
	default:       @:call_qsort1(any)@
	}
}

@ test
main(int argc, char** argv) {
        int i, n = atoi(argv[1]), m = atoi(argv[2]);
        float d = 0.0, f = d, *buf = (float*) malloc(2*n*sizeof(float));

        for(i=0; i < n; i++) {
                buf[i+i] = f++;
		buf[i+i+1] = d++;
		if (d > m) d = 0.0;
	}
	printf("start sort\n");
	GDKqsort(buf, NULL, n, 8, TYPE_flt, 4);
	printf("end sort\n");
	for(i=0; i < n; i++) {
		printf("% 9i [% 9d,% 9d]\n", i, (int) buf[i+i], (int) buf[i+i+1]);
	}
}
