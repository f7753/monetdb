@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2005 CWI.
@' All Rights Reserved.

@f gdk_tm
@a M. L. Kersten, P. Boncz, N. J. Nes

@* Transaction management
The Transaction Manager maintains the buffer of (permanent) BATS held resident.
Entries from the BAT buffer are always accessed by BAT id.
A BAT becomes permanent by assigning a name with @%BATrename@.
Access to the transaction table is regulated by a semaphore.
@{
@h
#ifndef _GDK_TM_H_
#define _GDK_TM_H_
#include "gdk.h"

#define SYSTRANSACTION	"tmp"
#define MAXTM		10

#endif /* _GDK_TM_H_ */
@c
#include "gdk.h"
#include "gdk_tm.h"

char TMname[MAXTM][IDLENGTH] = { SYSTRANSACTION };

int
TMnew(str s)
{
	THRprintf(GDKout, "begin transaction %s\n", s);
	strcpy(TMname[0], s);

	return 0;
}

int
TMresume(str s)
{
	strcpy(TMname[0], s);
	return 0;
}

str
TMcntxt(void)
{
	return TMname[0];
}

@
@}
@- 
The physical (disk) commit protocol is handled mostly by BBPsync. Once a commit
succeeded, there is the task of removing ex-persistent bats (those that still
were persistent in the previous commit, but were made transient in this transaction).
Notice that such ex- (i.e. non-) persistent bats are not backed up by the BBPsync
protocol, so we cannot start deleting after we know the commit will succeed.

Another hairy issue are the delta statuses in BATs. These provide a fast way
to perform a transaction abort (HOT-abort, instead of COLD-abort, which is achieved
by the BBP recovery in a database restart). Hot-abort functionality has not been 
important in MonetDB for now, so it is not well-tested. The problem here is that 
if a commit fails in the physical part (BBPsync), we have not sufficient information 
to roll back the delta statuses. 

So a 'feature' of the abort is that after a failed commit, in-memory we
*will* commit the transaction. Subsequent commits can retry to achieve a physical
commit. The only way to abort in such a situation is COLD-abort: quit the server and 
restart, so you get the recovered disk images.
@{
@c
int
TMcommit(void)
{
	int i, ret = 0;

	/* Acquire BBP locks */
	BBPlock("TMcommit");

	/* commit the delta status of each BAT; we cannot soft-abort after this anymore */
	for (i = 1; i < BBPsize; i++) {
		if (BBP_status(i) & BBPPERSISTENT) {
			BAT *b = BBP_cache(i);

			if (b == NULL && (BBP_status(i) & BBPSWAPPED)) {
				b = BBPquickdesc(i, TRUE);
				if (b == NULL) {
					ret = 1;
				}
			}
			if (b) {
				BATcommit(b);
			}
		}
	}
	/* make sure the stable image of the persistent bATs is committed to disk */
	if (ret == 0) {
		ret = BBPsync(TRUE);
	}
	/* in case the commit succeeded; delete the disk images of ex-persistent bats */
	if (ret == 0) {
		for (i = 1; i < BBPsize; i++) {
			if (BBP_status(i) & BBPPERSISTENT) {
				BBP_status_on(i, BBPEXISTING, "TMcommit");
			} else if ((BBP_status(i) & (BBPDELETED | BBPTMP)) && BBP_refs(i) <= 0 && BBP_lrefs(i) <= 0) {
				BAT *b = BBPquickdesc(i, TRUE);

				/* the unloaded ones are deleted without loading */
				/* delete disk images */
				BATdelete(b);	
				if (BBP_cache(i)) {
					/* those that quickdesc decides to load => free memory */
					BATfree(b);
				}
				BBPclear(i);	/* clear with locking */
			}
			BBP_status_off(i, BBPDELETED | BBPSWAPPED | BBPNEW, "TMcommit");
		}
	}
	BBPunlock("TMcommit");
	return ret;
}

@- 
Transaction abort is cheap. We use the delta statuses
to go back to the previous version of each BAT. Also
for BATs that are currently swapped out. Persistent BATs 
that were made transient in this transaction become
persistent again.
@c
int
TMabort(void)
{
	int i;

	BBPlock("TMabort");
	for (i = 1; i < BBPsize; i++) {
		if (BBP_status(i) & BBPNEW) {
			BAT *b = BBPquickdesc(i, FALSE);

			if (b) {
				if (b->batPersistence == PERSISTENT)
					BBPdecref(i, TRUE);
				b->batPersistence = TRANSIENT;
				b->batDirtydesc = 1;
			}
		}
	}
	for (i = 1; i < BBPsize; i++) {
		if (BBP_status(i) & (BBPPERSISTENT | BBPDELETED | BBPSWAPPED)) {
			BAT *b = BBPquickdesc(i, TRUE);

			if (b == NULL)
				continue;

			BBPfix(i);
			if (BATdirty(b) || DELTAdirty(b)) {
				/* BUN move-backes need a real BAT! */
				/* Stefan: 
				 * Actually, in case DELTAdirty(b), i.e., a
				 * BAT with differences that is
				 * saved/swapped-out but not yet committed,
				 * we (AFAIK) don't have to load the BAT and
				 * apply the undo, but rather could simply
				 * discard the delta and revive the backup;
				 * however, I don't know how to do this
				 * (yet), hence we stick with this solution
				 * for the time being --- it should be
				 * correct though it might not be the most
				 * efficient way...
				 */
				b = BBPdescriptor(i);
				BATundo(b);
			}
			if (BBP_status(i) & BBPDELETED) {
				BBP_status_on(i, BBPEXISTING, "TMabort");
				if (b->batPersistence != PERSISTENT)
					BBPincref(i, TRUE);
				b->batPersistence = PERSISTENT;
				b->batDirtydesc = 1;
			}
			BBPunfix(i);
		}
		BBP_status_off(i, BBPDELETED | BBPSWAPPED | BBPNEW, "TMabort");
	}
	BBPunlock("TMabort");
	return 0;
}

@}
