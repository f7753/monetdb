@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at 
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@' 
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@' 
@' The Original Code is the Monet Database System.
@' 
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2002 CWI.  
@' All Rights Reserved.
@' 
@' Contributor(s):
@' 		Martin Kersten <Martin.Kersten@cwi.nl>
@' 		Peter Boncz <Peter.Boncz@cwi.nl>
@' 		Niels Nes <Niels.Nes@cwi.nl>
@' 		Stefan Manegold  <Stefan.Manegold@cwi.nl>

@f gdk_tm
@a M. L. Kersten, P. Boncz, N. J. Nes

@* Transaction management
The Transaction Manager maintains the buffer of (permanent) BATS held resident.
Entries from the BAT buffer are always accessed by BAT id.
A BAT becomes permanent by assigning a name with @%BATrename@.
Access to the transaction table is regulated by a semaphore.
@{
@h
#ifndef _GDK_TM_H_
#define _GDK_TM_H_
#include "gdk.h"

#define SYSTRANSACTION	"tmp"
#define MAXTM		10

#endif /* _GDK_TM_H_ */
@c
#include "gdk_tm.h"
#include "gdk_bbp.h"

char			TMname[MAXTM][IDLENGTH] = { SYSTRANSACTION }; 

int TMnew(str s) {
	stream_printf(GDKout, "begin transaction %s\n", s); 
	strcpy(TMname[0], s); 

	return 0; 
}

int TMresume(str s) {
	strcpy(TMname[0], s); 
	return 0;
}

str TMcntxt() {
	return TMname[0]; 
}
@
@}
@- 
Upon transaction commit all dirty BATs should be saved on disk. The saving
of bats is done by BBPsync. Dirty bats on disc (ie unloaded bats) are 
only loaded if needed; in most cases it is enough to handle 
the (cached) BAT descriptor. 

The commit goes to a number of steps.
First the memory versions need to be commited, ie. a commit of 
the delta status for persistent bats and a clean contents for non 
persistent bats. Second step is the atomic BBPsync (ie store the 
correct current bats on disk). Then the BBP status change can be done,
ie. switch from BBPPERSISTENT to BPPEXISTING and delete the no longer
persistent bats from disk and memory.
@{
@
TMfakeCommit updates the BBP_status to a new transaction. It collects old bats which
can be destroyed. The resulting array of bat's can be given to TMkill to destroy these
bats.
@c
int *TMfakeCommit(){
	int i, nkills=0, maxkills = 1024, *kills = GDKmalloc((maxkills+1)*sizeof(int));

        /* succeeded: adapt BBPstatus of all bats while we're still locked */
        for (i = 1; i < BBPsize; i++) {
		if (BBP_status(i)&BBPPERSISTENT) {
			BBP_status_on(i, BBPEXISTING, "TMfakeCommit");
		} else if ((BBP_status(i)&BBPDELETED) && 
			BBP_refs(i) <= 0 && BBP_lrefs(i) <= 0 ){
			/* We cannot kill here, because some complex accelerators (histolink)
                         * need BBP locks in their delete sequence. Hence we must postpone 
                         * their destruction until after the commit has released all locks.
                         */
			if (nkills >= maxkills) {
				kills = (int*) GDKrealloc(kills, ((maxkills*=2)+1)*sizeof(int));
			}
			kills[nkills++] = i;
			BBP_refs(i) = 1; /* make unkillable; so nobody else can kill it */
                        BBP_status_on(i, BBPUNLOADING, "TMfakeCommit"); /* make unloadable */
		}
		BBP_status_off(i, BBPDELETED|BBPSWAPPED|BBPNEW, "TMfakeCommit");
        }
	kills[nkills] = 0;
	return kills;
}


/* kill removes the disk copy of bats. */
void TMkill(int *kills){
	int *killbuf = kills;
	while(*kills){
                BAT *b = BBP_cache(*kills);

		if (b){
			/* Loaded bats need a proper unfix */
                        BBPunfix(*kills);
                } else {
                        /* the unloaded ones are deleted without loading */

			b = BBPquickdesc(*kills, FALSE);
                        BATdelete(b); /* delete disk images */
                        BBPclear(*kills); /* clear with locking */
                }
		kills++;
        }
	if (killbuf) {
		GDKfree(killbuf);
	}
}

int TMcommit() {
	int cur = 0;
	int i, ret = 0, *kills = NULL;

	/* Acquire commit lock */
	MT_set_lock(GDKtmLock, "TMcommit"); 
	
        /* Commit the delta status of each persistent BAT 
         * Clear the BUNs of those BATs which used to be persistent 
	 *
	 * Clearing means other BATs could become transient, ie.
	 * needing the same clear treatment (so we repeat the loop
	 * until no more BBPclean calls are done). 
	 */
        for (i = 1; i < BBPsize; i++) {
		BAT *b;
		bat bid = i;

		if ( (BBP_status(bid) & BBPPERSISTENT) ||
		     (BBP_status(bid) & BBPDELETED)) {
	
			BBPfix(bid);
			b = BBPcache(bid);
			if (b == NULL) {
				b = BBPquickdesc(bid, TRUE);
				if (b == NULL) { 
					ret = 1; 
					BBPunfix(bid);
					break; 
				}
			}
			if (b){
				if (BBP_status(bid) & BBPPERSISTENT) {
					if (i > cur) BATcommit(b);
				} else if (BBP_status(bid) & BBPDELETED) {
					BBPclean(b);
					if (i > cur){
						cur = i;
						i = 1; /* restart */
					}
				}
			}
			BBPunfix(bid);
		}
	}

        /* atomic write of all dirty BATs and BBP.dir */
	if (ret == 0) ret = BBPsync(TRUE);
	if (ret == 0) kills = TMfakeCommit();
	MT_unset_lock(GDKtmLock, "TMcommit"); 
	/* outside the lock: now kill all ex-persistent bats */
	if (ret == 0) TMkill(kills);
	return ret;
}

@- 
Transaction abort is cheap. We use the delta statuses
to go back to the previous version of each BAT. Also
for BATs that are currently swapped out. Persistent BATs 
that were made transient in this transaction become
persistent again.
@c
int TMabort() {
	int i; 

	MT_set_lock(GDKtmLock, "TMabort"); 
	for (i = 1; i < BBPsize; i++) { 
		if (BBP_status(i) & BBPNEW) {
			BAT *b = BBPcache(i);
			if (b == NULL) {
				b = BATload_intern(i);
			}
			if (b) {
				BBP_plevel(i)--; 
				b->batDirtydesc = 1;
			}
		}
	}
	for (i = 1; i < BBPsize; i++) { 
		if (BBP_status(i) & (BBPPERSISTENT|BBPDELETED|BBPSWAPPED)) {
			BAT *b = BBPcache(i);
			if (b == NULL) {
				b = BATload_intern(i);
			}
			ALIGNundo(b);
			BATundo(b); 
			if (BBP_status(i)&BBPDELETED) {
				BBP_status_on(i, BBPEXISTING, "TMabort");
				BBP_plevel(i)++; 
				b->batDirtydesc = 1;
			}					
		}
		BBP_status_off(i, BBPDELETED|BBPSWAPPED|BBPNEW, "TMabort");
	}
	MT_unset_lock(GDKtmLock, "TMabort"); 
	return 0; 
}

BAT *BATmode(BAT *b, int mode) {
	BATcheck(b, "BATmode"); 

	MT_set_lock(GDKtmLock, "BATmode"); 
	if ((b->batPersistence&mode) == 0){
		int oldmode = b->batPersistence;
		b->batPersistence = mode;
		BBPdirty(1);
		if (mode&PERSISTENT) {
			if (VIEWparent(b)) {
				VIEWreset(b);
			}
			BBPpersistent(b->batCacheid, TRUE);
		} else if (oldmode&PERSISTENT) {
			BBPtransient(b->batCacheid, TRUE);
		}
	}
	MT_unset_lock(GDKtmLock, "BATmode"); 
	return b; 
}


@}
