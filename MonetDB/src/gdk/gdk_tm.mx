@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at 
@' http://monetdb.cwi.nl/Legal/MonetDBPL-1.0.html
@' 
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@' 
@' The Original Code is the Monet Database System.
@' 
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2002 CWI.  
@' All Rights Reserved.
@' 
@' Contributor(s):
@' 		Martin Kersten <Martin.Kersten@cwi.nl>
@' 		Peter Boncz <Peter.Boncz@cwi.nl>
@' 		Niels Nes <Niels.Nes@cwi.nl>
@' 		Stefan Manegold  <Stefan.Manegold@cwi.nl>

@f gdk_tm
@a M. L. Kersten, P. Boncz

@* Transaction management
The Transaction Manager maintains the buffer of (permanent) BATS held resident.
Entries from the BAT buffer are always accessed by BAT id.
A BAT becomes permanent by assigning a name with @%BATrename@.
Access to the transaction table is regulated by a semaphore.
@{
@h
#ifndef _GDK_TM_H_
#define _GDK_TM_H_
#include "gdk.h"

#define SYSTRANSACTION	"tmp"
#define MAXTM		10

#endif /* _GDK_TM_H_ */
@c
#include "gdk_tm.h"
#include "gdk_bbp.h"

char			TMname[MAXTM][IDLENGTH] = { SYSTRANSACTION }; 

int TMnew(str s) {
	fprintf(GDKout, "begin transaction %s\n", s); 
	strcpy(TMname[0], s); 

	return 0; 
}

int TMresume(str s) {
	strcpy(TMname[0], s); 
	return 0;
}

str TMcntxt() {
	return TMname[0]; 
}
@
@}
@- 
Upon transaction commit all dirty BATs should be saved on disk.
Dirty bats on disc are only loaded if needed; in most cases
it is enough to handle the (cached) BAT descriptor. 
@{
@
TMfakeCommit updates the BBP_status to a new transaction. It collects old bats which
can be destroyed. The resulting array of bat's can be given to TMkill to destroy these
bats.
@c
int *TMfakeCommit(){
	int i, nkills=0, maxkills = 1024, *kills = GDKmalloc((maxkills+1)*sizeof(int));

        /* succeeded: adapt BBPstatus of all bats while we're still locked */
        for (i = 1; i < BBPsize; i++) {
		if (BBP_status(i)&BBPPERSISTENT) {
			BBP_status_on(i, BBPEXISTING, "TMfakeCommit");
		} else if ((BBP_status(i)&BBPDELETED) && BBP_refs(i) <= 0) {
			/* We cannot kill here, because some complex accelerators (histolink)
                         * need BBP locks in their delete sequence. Hence we must postpone 
                         * their destruction until after the commit has released all locks.
                         */
			if (nkills >= maxkills) {
				kills = (int*) GDKrealloc(kills, ((maxkills*=2)+1)*sizeof(int));
			}
			kills[nkills++] = i;
			BBP_refs(i) = 1; /* make unkillable; so nobody else can kill it */
                        BBP_status_on(i, BBPUNLOADING, "TMfakeCommit"); /* make unloadable */
		}
		BBP_status_off(i, BBPDELETED|BBPSWAPPED|BBPNEW, "TMfakeCommit");
        }
	kills[nkills] = 0;
	return kills;
}


void TMkill(int *kills){
	int *killbuf = kills;
	while(*kills){
                BAT *b = BBPquickdesc(*kills, FALSE);

                if (BBP_cache(*kills)) {
			/* those that quickdesc decides to load => proper unfix */
                        BBPunfix(*kills);
                } else {
                        /* the unloaded ones are deleted without loading */
                        BATdelete(b); /* delete disk images */
                        BBPclear(*kills, TRUE); /* clear with locking */
                }
		kills++;
        }
	if (killbuf) {
		GDKfree(killbuf);
	}
}

int TMcommit() {
	int i, ret = 0, *kills = NULL;

	/* Acquire commit lock */
	MT_set_lock(GDKtmLock, "TMcommit"); 
	
        /* commit the delta status of each BAT */
        for (i = 1; i < BBPsize; i++)  
	if (BBP_status(i) & BBPPERSISTENT) {
		BAT *b;
		BBPfix(i);
		b = BBPcache(i);
		if (b == NULL && (BBP_status(i)&BBPSWAPPED)) {
			b = BBPquickdesc(i, FALSE);
			if (b == NULL) { 
				ret = 1; 
				BBPunfix(i);
				break; 
			}
		}
		if (b) BATcommit(b);
		BBPunfix(i);
	}

        /* atomic write of all dirty BATs and BBP.dir */
	if (ret == 0) ret = BBPsync(TRUE);
	if (ret == 0) kills = TMfakeCommit();
	MT_unset_lock(GDKtmLock, "TMcommit"); 
	/* outside the lock: now kill all ex-persistent bats */
	if (ret == 0) TMkill(kills);
	return ret;
}

@- 
Transaction abort is cheap. We use the delta statuses
to go back to the previous version of each BAT. Also
for BATs that are currently swapped out. Persistent BATs 
that were made transient in this transaction become
persistent again.
@c
int TMabort() {
	int i; 

	MT_set_lock(GDKtmLock, "TMabort"); 
	for (i = 1; i < BBPsize; i++) { 
		if (BBP_status(i) & BBPNEW) {
			BAT *b = BBPcache(i);
			if (b == NULL) {
				b = BATload_intern(i);
			}
			if (b) {
				BBP_plevel(i) = 0; 
				b->batDirtydesc = 1;
			}
		}
	}
	for (i = 1; i < BBPsize; i++) { 
		if (BBP_status(i) & (BBPPERSISTENT|BBPDELETED|BBPSWAPPED)) {
			BAT *b = BBPcache(i);
			if (b == NULL) {
				b = BATload_intern(i);
			}
			ALIGNundo(b);
			BATundo(b); 
			if (BBP_status(i)&BBPDELETED) {
				BBP_status_on(i, BBPEXISTING, "TMabort");
				BBP_plevel(i) = 1; 
				b->batDirtydesc = 1;
			}					
		}
		BBP_status_off(i, BBPDELETED|BBPSWAPPED|BBPNEW, "TMabort");
	}
	MT_unset_lock(GDKtmLock, "TMabort"); 
	return 0; 
}
@}
