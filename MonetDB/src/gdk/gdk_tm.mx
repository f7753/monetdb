@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@' 
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@' 
@' The Original Code is the Monet Database System.
@' 
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2003 CWI.
@' All Rights Reserved.
@' 
@' Contributor(s):
@' 		Martin Kersten <Martin.Kersten@cwi.nl>
@' 		Peter Boncz <Peter.Boncz@cwi.nl>
@' 		Niels Nes <Niels.Nes@cwi.nl>
@' 		Stefan Manegold  <Stefan.Manegold@cwi.nl>

@f gdk_tm
@a M. L. Kersten, P. Boncz, N. J. Nes

@* Transaction management
The Transaction Manager maintains the buffer of (permanent) BATS held resident.
Entries from the BAT buffer are always accessed by BAT id.
A BAT becomes permanent by assigning a name with @%BATrename@.
Access to the transaction table is regulated by a semaphore.
@{
@h
#ifndef _GDK_TM_H_
#define _GDK_TM_H_
#include "gdk.h"

#define SYSTRANSACTION	"tmp"
#define MAXTM		10

#endif /* _GDK_TM_H_ */
@c
#include "gdk.h"
#include "gdk_tm.h"

char			TMname[MAXTM][IDLENGTH] = { SYSTRANSACTION }; 

int TMnew(str s) {
	THRprintf(GDKout, "begin transaction %s\n", s); 
	strcpy(TMname[0], s); 

	return 0; 
}

int TMresume(str s) {
	strcpy(TMname[0], s); 
	return 0;
}

str TMcntxt(void) {
	return TMname[0]; 
}
@
@}
@- 
Upon transaction commit all dirty BATs should be saved on disk.
Dirty bats on disc are only loaded if needed; in most cases
it is enough to handle the (cached) BAT descriptor. 
@{
@c
void TMfakeCommit(void) {
	int i;
        for (i = 1; i < BBPsize; i++) {
		if (BBP_status(i)&BBPPERSISTENT) {
			BBP_status_on(i, BBPEXISTING, "TMcommit");
		} else if ((BBP_status(i)&(BBPDELETED|BBPTMP)) && BBP_refs(i) <= 0 && BBP_lrefs(i) <= 0) {
                	BAT *b = BBPquickdesc(i, TRUE);
                	if (BBP_cache(i)) {
				/* those that quickdesc decides to load => proper unfix */
                        	BBPunfix(i);
                	} else {
				/* the unloaded ones are deleted without loading */
				BATdelete(b); /* delete disk images */
				BBPclear(i); /* clear with locking */
			}
		}
		BBP_status_off(i, BBPDELETED|BBPSWAPPED|BBPNEW, "TMcommit");
        }
}

int TMcommit(void) {
	int i, ret = 0;

	/* Acquire BBP locks */
	BBPlock("TMcommit");

        /* commit the delta status of each BAT */
        for (i = 1; i < BBPsize; i++)  
	if (BBP_status(i) & BBPPERSISTENT) {
		BAT *b = BBPcache(i);
		if (b == NULL && (BBP_status(i)&BBPSWAPPED)) {
			b = BBPquickdesc(i, TRUE);
			if (b == NULL) {
				ret = 1;
				break;

			}
		}
		if (b) {
			BATcommit(b);
		}
	}

        /* atomic write of all dirty BATs and BBP.dir */
	if (ret == 0)
		TMfakeCommit();
	ret = BBPsync(TRUE);

        /* succeeded: adapt BBPstatus of all bats while we're still locked */
	if (ret == 0) 
		BBPunlock("TMcommit");
	return ret; 
}
@- 
Transaction abort is cheap. We use the delta statuses
to go back to the previous version of each BAT. Also
for BATs that are currently swapped out. Persistent BATs 
that were made transient in this transaction become
persistent again.
@c
int TMabort(void) {
	int i; 

	BBPlock("TMabort");
	for (i = 1; i < BBPsize; i++) { 
		if (BBP_status(i) & BBPNEW) {
			BAT *b = BBPquickdesc(i, FALSE);
			if (b) {
				if (b->batPersistence == PERSISTENT)
					BBPdecref(i, TRUE);
				b->batPersistence = TRANSIENT;
				b->batDirtydesc = 1;
			}
		}
	}
	for (i = 1; i < BBPsize; i++) { 
		if (BBP_status(i) & (BBPPERSISTENT|BBPDELETED|BBPSWAPPED)) {
			BAT *b = BBPquickdesc(i, TRUE); 
			if (b == NULL) continue;
	
			BBPfix(i);
			if (BATdirty(b) || DELTAdirty(b)) {
 				/* BUN move-backes need a real BAT! */
				/* Stefan: 
				 * Actually, in case DELTAdirty(b), i.e., a
				 * BAT with differences that is
				 * saved/swapped-out but not yet committed,
				 * we (AFAIK) don't have to load the BAT and
				 * apply the undo, but rather could simply
				 * discard the delta and revive the backup;
				 * however, I don't know how to do this
				 * (yet), hence we stick with this solution
				 * for the time being --- it should be
				 * correct though it might not be the most
				 * efficient way...
				 */
				b = BBPdescriptor(i);
				BATundo(b); 
			}
			if (BBP_status(i)&BBPDELETED) {
				BBP_status_on(i, BBPEXISTING, "TMabort");
				if (b->batPersistence != PERSISTENT)
					BBPincref(i, TRUE);
				b->batPersistence = PERSISTENT;
				b->batDirtydesc = 1;
			}					
			BBPunfix(i);
		}
		BBP_status_off(i, BBPDELETED|BBPSWAPPED|BBPNEW, "TMabort");
	}
	BBPunlock("TMabort");
	return 0; 
}
@}
