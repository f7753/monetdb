@f gdk_batop
@a M. L. Kersten, P. Boncz
@* Common BAT Operations
@T
This module contains the following BAT algebra operations:
\begin{description}
\item[bulk updates] multi-insert, multi-delete, multi-replace
\item[common aggregates] min, max and histogram
\item[oid column manipulations] mark, number and split.
\item[bat selections] select, slice, sample, fragment and restrict.
\item[bat partitioning] hash partition, range partitioning
\end{description}
@h
#ifndef _GDK_BATOP_H
#define _GDK_BATOP_H
#include "gdk.h"

#endif /* _GDK_BATOP_H */

@T
As you probably noticed :-), we try to factor out all possible 
overhead by inlining code. This includes the macros BUNhead and BUNtail, 
which do a test to see whether the atom resides in the buns or in a 
variable storage heap. The updateloop(dstbat, srcbat, operation) macro 
invokes operation(dstbat, BUNhead(srcbat), BUNtail(srcbat)) on all buns
of the srcbat, but testing only once where they reside.
@c
#include "gdk_bat.h"
#include "gdk_batop.h"

@= updateloop
{	BUN p, q; 
 	int xx;
	BATloopFast(@2, p, q, xx) {
		@3(@1, BUNhead(@2, p), BUNtail(@2, p)); 
	}
}

@+ BAT insert/delete/replace
The content of a BAT can be appended to (removed from) another using
@%BATins@ (@%BATdel@).
@c
BAT *BATins(BAT *b, BAT *n) {
	int needed = 0;

	if (b == NULL || n == NULL || BATcount(n) == 0) {
		return b;
	}
        ALIGNins(b, "BATins");
	BATcompatible(b, n);

	if (b->htype != TYPE_void && (b->ttype == TYPE_void ||
		(!b->hhash_heap && b->thash_heap &&
		ATOMstorage(b->ttype) == TYPE_int))) /* OIDDEPEND */
	{
		return BATmirror(BATins(BATmirror(b),BATmirror(n)));
	}

	needed = BATcount(n) - (((b)->batBuns->size - (b)->batBuns->free)/BUNsize(b));
  	if (needed > 0)
		BATextend(b, BATcapacity(b) + needed); /* allocation hint */ 

	if (b->hidx_heap || b->tidx_heap) {
                IDXdestroy(b);
	}
	if (b->thash_heap==NULL && b->hacctype==0 && b->tacctype==0 && b->batSet==0 
	    && (b->hkey&BOUND2BTRUE)==0 && (b->tkey&BOUND2BTRUE)==0 && 
		(b->hhash_heap==NULL || ATOMstorage(b->htype) == TYPE_int))
	{
		BUN p, q, r = BUNlast(b); 
 		int xx, yy = BUNsize(b);

		if (BATcount(b) == 0) {
		    ALIGNset(b, n);
		} else if (BATcount(n)) {
		    BUN last = BUNlast(b) - BUNsize(b);
		    int idx = BUNindex(b,BUNlast(b)); 

		    xx = ATOMcmp(b->htype, BUNhead(n,BUNfirst(n)), 
					   BUNhead(b, last));
		    if ((BAThordered(n)&1)==0 || ((BAThordered(b)&1) && xx<0)) {
		    	b->hsorted = FALSE; 
		    	b->H->nosorted = idx;
		    }
		    if ((BAThordered(b)&1)==0 || n->hkey==0 || xx==0) {
			if (b->hkey) BATkey(b, FALSE);
		    } 
		    if (b->htype != TYPE_void && (b->hsorted&b->hdense&1) &&
			(BAThdense(n)==0 || *(oid*) BUNhloc(b,last) != 1 + 
					    *(oid*) BUNhead(n,BUNfirst(n))))  
		    {
		    	b->hdense = FALSE; 
		    	b->H->nodense = idx;
		    }

		    xx = ATOMcmp(b->ttype, BUNtail(n,BUNfirst(n)), 
					   BUNtail(b, last));
		    if ((BATtordered(n)&1)==0 || ((BATtordered(b)&1) && xx<0)) {
		    	b->tsorted = FALSE; 
		    	b->T->nosorted = idx;
		    }
		    if ((BATtordered(b)&1)==0 || n->tkey==0 || xx==0) {
			if (b->tkey) BATkey(BATmirror(b), FALSE);
		    } 
		    if (b->ttype != TYPE_void && (b->tsorted&b->tdense&1) &&
			(BATtdense(n)==0 || *(oid*) BUNtloc(b,last) != 1 + 
					    *(oid*) BUNtail(n,BUNfirst(n))))  
		    {
		    	b->tdense = FALSE; 
		    	b->T->nodense = idx;
		    }
		}
		if (b->htype == TYPE_void) {
			BATloopFast(n, p, q, xx) {
				bunfastins_nocheck(b, r, NULL, BUNtail(n, p), yy); 
				r += yy;
			}
		} else if (b->hhash_heap) {
			int i = BUNindex(b, BUNlast(b));
			BATloopFast(n, p, q, xx) {
				ptr v = BUNhloc(n,p);
				bunfastins_nocheck(b, r, v, BUNtail(n, p), yy); 
				HASHins_int(b->hhash, i, v); 
				r += yy; i++; 
			}
		} else {
			BATloopFast(n, p, q, xx) {
				bunfastins_nocheck(b, r, BUNhead(n, p), BUNtail(n, p), yy); 
				r += yy;
			}
		}
		b->batDirty = 1;
	} else {
		@:updateloop(b,n,BUNins)@
	}
	return b;
}

BAT *BATdel(BAT *b, BAT *n) {
	ERRORcheck(b == NULL, "set:BAT required\n");
	ERRORcheck(n == NULL, "set:BAT required\n");
	if (BATcount(n) == 0) {
		return b;
	}
        ALIGNdel(b, "BATdel");
	TYPEcheck(b->htype, n->htype);
	TYPEcheck(b->ttype, n->ttype);
	@:updateloop(b,n,BUNdel)@
	return b;
}

#define _BUNdelHead(b, x, y) BUNdelHead(b, x)

BAT *BATdelHead(BAT *b, BAT *n) {
	ERRORcheck(b == NULL, "set:BAT required\n");
	ERRORcheck(n == NULL, "set:BAT required\n");
	if (BATcount(n) == 0) {
		return b;
	}
        ALIGNdel(b, "BATdelHead");
	TYPEcheck(b->htype, n->htype);
	@:updateloop(b,n,_BUNdelHead)@
	return b;
}
@-
The last in this series is a BATreplace, which replaces all the
buns mentioned.
@c
BAT *BATreplace(BAT *b, BAT *n) {
	if (b == NULL || n == NULL || BATcount(n) == 0) {
		return b;
	}
        ALIGNdel(b, "BATreplace");
	BATcompatible(b, n);
	@:updateloop(b,n,BUNreplace)@
	
	return b;
}
@}

@+ Introducing OID Columns
The @%BATmark@ operation is normally used to prepare a class of query
results. Likewise, @%BATnumber@ is heavily used in the SQL front-end.
@c
#define BUNmark(bx,	hx, tx) BUNfastins(bn, hx, NULL); 
BAT *BATmark(BAT *b, oid oid_base) {
        BAT     *bn;
 
        BATcheck(b, "BATmark");
	if (BATrestricted(b) == BAT_READ) {
		bn = VIEWhead(b);
	} else {
		int xx;
		if (b->htype == TYPE_void) {
			oid *base, cur = oid_base; 
			bn = BATnew(TYPE_void, TYPE_oid, xx=BATcount(b)); 
			bn->batBuns->free += xx*sizeof(oid);
			for(base=(oid*) BUNfirst(bn); xx--; cur++,base++) 
				*base = cur; 
		} else {
			bn = BATnew(b->htype, TYPE_void, BATcount(b)); 
			@:updateloop(bn,b,BUNmark)@
		}
		ALIGNsetH(bn,b);
		bn->tsorted = GDK_SORTED;
		bn->tdense = TRUE;
		BATkey(BATmirror(bn), TRUE);
	}
	BATseqbase(BATmirror(bn), oid_base);
        return bn;
}
 
#define BUNnumber(bx,hx,tx)	BUNfastins(bx, hx, (ptr)&i); i++;
BAT *BATnumber(BAT *b) {
        int     i = 0;
        BAT     *bn;
 
        BATcheck(b, "BATnumber");
        bn = BATnew(b->htype, TYPE_int, BATcount(b));
        if (bn == NULL) {
                return NULL;
        }
	ALIGNsetH(bn,b);
        @:updateloop(bn,b,BUNnumber)@
	bn->hsorted = BAThordered(b);
	bn->tsorted = GDK_SORTED;
        return bn;
}

BAT* BATconst(BAT *b, int tailtype, ptr v) {
        BAT *bn;
        BUN p,q;
        int xx;

	if (BATrestricted(b) == BAT_READ &&
           (tailtype == TYPE_void || (tailtype == TYPE_oid && *(oid*) v == oid_nil)))
	{
		oid seqbase = (tailtype==TYPE_void)?oid_nil:*(oid*) v;
		bn = VIEWhead(b);
		BATseqbase(BATmirror(bn), seqbase);
		return bn;
	}
	if (tailtype == TYPE_bat) {
		v = &((BAT*) v)->batCacheid;
	} else if (tailtype == TYPE_void && b->htype == TYPE_void) {
		tailtype = TYPE_oid;
		v = (ptr) oid_nil;
	}
        bn = BATnew(b->htype, tailtype, BATcount(b));
	if (bn == NULL) {
		return bn; 
	}
        BATloopFast(b, p, q, xx) {
		BUNfastins(bn, BUNhead(b,p), v);
	}
	ALIGNsetH(bn,b);
	bn->tsorted = GDK_SORTED;
        return bn;
}

@+ BAT Aggregates

The @%BAThistogram@ function calculates the frequency distribution of the
tail values in its operand bat. Notice, that updates on the result do
not affect the delta administration.
Construction of a histogram over a string (or complex object)
can be sped up using the reference information in the BUN
and bulk copying the heap.
@
@
There are now seperate versions for each type, and for each a 
hash- and a merge-algorithms. 

@= histoloop_inner
	if (b->tkey) { yy=1;
		BATloopFast(b, p, q, xx) 
			BUNfastins(bn, BUNt@1(b,p), &yy);
	} else if (!BATtordered(b)) {
		BATloopFast(b, p, q, xx) {
			ptr v =  (ptr) BUNt@1(b,p);
			(void) BATprepareHash(bn);
			HASHloop@2(bn, bn->hhash, tt, v, r)
				goto found@3@2; 
			BUNins(bn, v, &yy);
			r = BUNlast(bn) - BUNsize(bn);
found@3@2:		(*(int*) BUNtloc(bn,r))++;
		}
		HASHdestroy(bn); 
	} else if (BATcount(b)) {
		ptr prev = (ptr) BUNt@1(b, BUNfirst(b));
		BATloopFast(b, p, q, xx) {
			ptr v = (ptr) BUNt@1(b,p);
			if (@3_CMP(v, prev, @4) == 0) {
				yy++;
			} else {
				BUNfastins(bn, prev, &yy);
				yy = 1;
			} prev = v;
		} 
		BUNfastins(bn, prev, &yy);
	} break;
@= histoloop
{	int tt, xx, yy=0;
	BUN p, q, r;

	switch(ATOMstorage(tt=bn->htype)) {
	case TYPE_chr:	@:histoloop_inner(loc,_chr,simple,chr)@
	case TYPE_sht:  @:histoloop_inner(loc,_sht,simple,sht)@
	case TYPE_int:
	case TYPE_flt:	@:histoloop_inner(loc,_int,simple,int)@
	case TYPE_lng: 
	case TYPE_dbl:  @:histoloop_inner(loc,_lng,simple,lng)@
	default: if (bn->hvarsized) {
			@:histoloop_inner(var,var,atom,tt)@
        	 } else {
			@:histoloop_inner(loc,loc,atom,tt)@
        	 }
}	}
@c
BAT *BAThistogram(BAT *b) {
	BAT *bn; 
	int 	tricky = 0;
	
	BATcheck(b, "BAThistogram"); 

	tricky = (b->ttype==TYPE_str && strElimDoubles(&b->theap));
	if (b->talign==0) {
		b->talign = OIDnew(1);
	}
	bn = BATnew(tricky?TYPE_int:b->ttype, TYPE_int, 200); 
	if (bn == NULL) {
		return bn;
	}

	@:histoloop()@
@- 
And now correct the interpretation of the values encountered
by bulk copying the heap as well
@c
	if (tricky) {
		BAT *bm = BATmirror(bn);
		bm->ttype = bn->htype = b->ttype;
		bm->tvarsized = bn->hvarsized = 1;
		strcpy(bn->hatom, ATOMname(b->ttype));
		HEAPcopy(&bn->hheap, &b->theap);
	}
	BATkey(bn,TRUE);
	bn->hsorted = BATtordered(b);
	bn->tsorted = FALSE;
        bn->halign = NOID_AGGR(b->talign); 
        if (BATcount(bn) == BATcount(b)) {
		BAT *bm = BATmirror(b);
                ALIGNsetH(bn,bm);
        }

	return bn; 
}
@}
@+ Minimum and Maximum
The routines @`BATmin@5(b) and @`BATmax@5(b) compute the minimum and
maximum value of the tail column of a BAT.
Aggregate values are calculated just before they are requested by
the user. They are not maintained continuously, because we expect
them to be used sparsely.

@= atomaggr
    if (s > 0 && !BATtordered(b)) {
	char* nil = BATatoms[t].atomNull;
	BUN p,q;
	int xx;
        BATloopFast(b, p, q, xx) {
            x = (ptr) BUNt@2(b, p);
            if (@3_CMP(x, nil, @4) == 0) {
                v = nil; break;
            }
            if (@3_@5(x, v, @4)) {
                v = x; 
            }
        }	
    }
    if (aggr) {
       memcpy(aggr, x=v, ATOMsize(t));
    } else {
       /* alloc new space and copy the atom into it */
       s = ATOMlen(t, v);
       memcpy(x = (ptr) GDKmalloc(s), v, s);
   } 
@= voidaggr
    if (aggr) {
        *(oid *) aggr = *(oid *) (x=v);
    } else {
        /* alloc new space and copy the atom into it */
        memcpy(x = (ptr) GDKmalloc(sizeof(oid)), v, s);
    } 
@= aggrmin
    v = (s == 0)?ATOMnilptr(t):BUNtail(b, BUNfirst(b));
    @:@5aggr(@1,@2,@3,@4,LT)@
@= aggrmax
    v = (s == 0)?ATOMnilptr(t):BUNtail(b, BUNlast(b)-BUNsize(b));
    @:@5aggr(@1,@2,@3,@4,GT)@

@= BATaggr
ptr BAT@1(BAT *b, ptr aggr) {
	int t,s; 
	ptr v, x;

	BATcheck(b, "BAT@1"); 
	s = BATcount(b);	
	t = b->ttype;
	if (BATtvoid(b)) {
	    @:aggr@1(chr,loc,simple,chr,void)@ 
	} else {
	    switch(ATOMstorage(t)) {
	    case TYPE_chr: @:aggr@1(chr,loc,simple,chr,atom)@ break;
	    case TYPE_sht: @:aggr@1(sht,loc,simple,sht,atom)@ break;
	    case TYPE_int: @:aggr@1(int,loc,simple,int,atom)@ break;
	    case TYPE_flt: @:aggr@1(flt,loc,simple,flt,atom)@ break;
	    case TYPE_dbl: @:aggr@1(dbl,loc,simple,dbl,atom)@ break;
	    case TYPE_lng: @:aggr@1(lng,loc,simple,lng,atom)@ break;
	    default: if (b->tvarsized) {
			   @:aggr@1(chr,var,atom,t,atom)@ break;
		     } else {
			   @:aggr@1(chr,loc,atom,t,atom)@ break;
	    }        }
	}
	return x;
}
@c
@:BATaggr(min)@
@:BATaggr(max)@

@+ BAT sum operation
The sum aggregate only works for int anf float fields.
The routines below are a hack, because they assume that
that the caller knows that type already.
A better version requires a solution to management of
arbitrary typed variables.
Note that it ignores the NIL values of the underlying type.
@= dosum
	case TYPE_@1: 
	{   @1 *value, result=@2;
	    BATloopFast(b, p, q, xx) {
		value = (@1*) BUNtloc(b, p);
		if (*value == @1_nil) {
			result = @1_nil; break;
		} else {
			result += *value;
		}
	    }
	    *(@1*) aggr = result;
	    return aggr;
	}
@c
ptr BATsum(BAT *b, ptr aggr) {
	BUN p,q;
	int xx;

	BATcheck(b,"BATsumInt");
	switch(ATOMstorage(b->ttype)){
	@:dosum(sht,0)@
 	@:dosum(int,0)@
	@:dosum(flt,0.0)@
	@:dosum(lng,0)@
	@:dosum(dbl,0.0)@
	default: GDKerror("BATsum:illegal type\n");
	}
	return 0;
}

@
@}

@+ BAT Selections
The BAT selectors are among the most heavily used operators. 
Their efficient implementation is therefore mandatory.

The interface supports seven operations: @%BATslice@, @%BATselect@, 
@%BATfragment@, @%BATsample@, @%BATproject@, @%BATrestrict@.

@- BAT slice
@T
This function returns a horizontal slice from a BAT. It optimizes
execution by avoiding to copy when the BAT is memory mapped (in this 
case, an independent submap is created) or else when it is read-only, 
then a VIEW bat is created as a result.

If a new copy has to be created, this function takes care to preserve
void-columns (in this case, the seqbase has to be recomputed in the result).

Note that the BATslice() is used indirectly as well as a special 
case for BATselect (range selection on sorted column), BATrangesplit
(fragmentation on sorted column) and BATsemijoin (when two dense columns
are semijoined).
@c
BAT *BATslice(BAT *b, int *l, int *h) {
        int xx, i = *l, j = *h;
	BAT *bn;

        if (i < 0) i = 0; 
	if (j >= BATcount(b)) j = BATcount(b)-1;
	if (j < i) j = i-1;
        i += BUNindex(b, BUNfirst(b));
        j += BUNindex(b, BUNfirst(b));

@- optimization
If a BAT is memory mapped it, a slice can be taken without copying.
The @%HEAPsubcopy@ uses the mmap_private for obtaining a second and 
independent view on the virtual memory.
@c
#if 0 && defined(NOEXTEND_PRIVMAP)
	/* commented out because when the access  mode of b is changed later, this bn is
         * not detactable and will suffer side effects from updates in b.
	 * besides, for most query evaulation pruposes, the horizontal view creation
         * below is suffiecient. Peter/dec99
	 */
	if (i <= j && (BATrestricted(b) != BAT_WRITE && b->batBuns->storage == STORE_MMAP)) {
		BUN start = BUNptr(b,i-1);
		BUN end = BUNptr(b,j+1);
		int add;
	        bn = BATcreatedesc(b->htype, b->ttype);
		bn->dims = b->dims;
		add = HEAPsubcopy(bn->batBuns, b->batBuns, end-start, start-b->batBuns->base);
		if (b->hheap.base)
			HEAPsubcopy(&bn->hheap, &b->hheap, b->hheap.free, 0);
		if (b->theap.base)
			HEAPsubcopy(&bn->theap, &b->theap, b->theap.free, 0);
                bn->batHole = bn->batDeleted = BUNptr(bn, 0) + add;  
                bn->batInserted = BUNptr(bn, 1) + add;  
        	BBPcacheit(bn,TRUE);
	} else 
#endif
@-
Alternatively, if the source BAT is readonly, then we can obtain a VIEW
that just reuses the memory of the source. 
@c
	if (BATrestricted(b) == BAT_READ) {
		bn = VIEWcreate(b); 
		bn->batBuns->base = BUNptr(b, i-1);  
                bn->batInserted = BUNptr(b, i);  
                bn->batHole = bn->batDeleted = bn->batBuns->base; 
		bn->batBuns->maxsize = bn->batBuns->size = 
		    bn->batBuns->free = BUNptr(b,j+1) - bn->batBuns->base; 
@-
We have to do it: create a new BAT and put everything into it.
@c
	} else {
		BUN p = BUNptr(b,i);
		BUN q = BUNptr(b,j);

        	bn = BATnew(b->htype, b->htype?b->ttype:ATOMtype(b->ttype), j-i);
		if (bn == NULL) {
			return bn;
		}
        	for (xx=BUNsize(b); p<=q; p+=xx) {
                	BUNfastins(bn, BUNhead(b,p), BUNtail(b,p));
        	}
	}
        bn->hsorted = BAThordered(b);
        bn->tsorted = BATtordered(b);
	if (BAThdense(b)) {
		BATseqbase(bn, b->hseqbase+*l); 
	}
	if (BATtdense(b)) {
		BATseqbase(BATmirror(bn), b->tseqbase+*l);
	}
        return bn;
}

@-  Value Selections
@{
The string search is optimized for the degenerated case
that th = tl, and double elimination in the string heap. 

We allow value selections on the nil atom. This is focrmally
not correct, as in MIL (nil = nil) != true.  However, we do 
need an implementation for selecting nil (in MIL, this is done 
through is the "isnil" predicate). So we implement it here.

@= valselect
        HASHloop@2(b, b->hhash, i, tl, p) {
	    if (q < r) bunfastins_nocheck(bn, q, BUNt@1(b, p), tl, bs);
	    q += bs;
        } break;
@= stringselect
	if (strElimDoubles(&b->hheap)) {
	    HASHloop_fstr(b, b->hhash, i, j, tl) {
		p = BUNptr(b, i);
		if (q < r) bunfastins_nocheck(bn, q, BUNt@1(b, p), tl, bs);
		q += bs;
	    }
	} else {
            HASHloop_str(b, b->hhash, i, tl) { 
		p = BUNptr(b, i);
		if (q < r) bunfastins_nocheck(bn, q, BUNt@1(b, p), tl, bs);
		q += bs;
	    }
	} break;
@= hashselect
	switch(ATOMstorage(b->htype)) {
	case TYPE_chr: @:valselect(@1,_chr)@
	case TYPE_sht: @:valselect(@1,_sht)@
	case TYPE_int: @:valselect(@1,_int)@
	case TYPE_flt: @:valselect(@1,_flt)@
	case TYPE_dbl: @:valselect(@1,_dbl)@
	case TYPE_lng: @:valselect(@1,_lng)@
	case TYPE_str: @:stringselect(@1)@
	default:    if (b->hvarsized) {
			@:valselect(@1,var)@
		    } else {
			@:valselect(@1,loc)@
		    }
	}
@c
BAT *BAT_hashselect(BAT *b, BAT *bn, ptr tl) {
	int ht = bn->htype, tt = bn->ttype, size = BATcount(bn);
	int i, j;

	BATflipflop(b);
	(void) BATprepareHash(b);
	while(bn) {
	    BUN p, q = BUNfirst(bn), r = Bunbase(bn) + bn->batBuns->size;
	    int bs = BUNsize(bn);

	    if (b->tvarsized) {
	        @:hashselect(var)@
	    } else {
	        @:hashselect(loc)@
	    }
	    if (q <= r) break;
	    size = (q - BUNfirst(bn)) / bs;
	    BBPreclaim(bn); 
	    bn = BATnew(ht, tt, size);
	}
	return bn;
}


@- Range Selections
The routine @%BATselect@ locates the BAT subset whose tail component
satisfies the range condition @T$l <= tail <= h$. A nil value in
either dimension defines infinity.  The value is set accordingly.

Range selections without lower or upper bound use the nil atom
to indicate this (this is somewhat confusing). Note, however, that
through the definition of MIL we do not want the nils to appear in
the result (as (nil {<,=,>} ANY) = bit(nil) != true).

@= bunins_notnil
	if (@3_CMP(nil, v, @1)) BUNfastins(bn, @2, v);
@= select
        if (b->tidx_heap) {
	    BAT *m = BATmirror(b);
            BUN *x, *y;
            IDXrng(m, tl, th, &x, &y);
	    if (equi == 0) {
		while(x < y && @4_EQ(nil, BUNt@3(b, *x), @1)) {
			x++; /* if this is a range-select, we skip nil */
		}
	    }
            IDXloop(m, x, y) {
		BUNfastins(bn, BUNh@2(b, *x), BUNt@3(b, *x)); 
            }
	} else if (equi == 0) { /* here we always skip nil */
            int xx;
	    if (BAThvoid(b)) {
		oid yy = b->hseqbase;
                BATloopFast(b, p, q, xx) {
                    ptr v = BUNt@3(b, p); 
                    if ((!lval || @4_LE(tl,v,@1)) && (!hval || @4_LE(v,th,@1)))
		    	@:bunins_notnil(@1,&yy,@4)@
		    /* avoid computing BUNpos many times over */
		    if (yy != oid_nil) yy++; 
                }
	    } else {
                BATloopFast(b, p, q, xx) {
                    ptr v = BUNt@3(b, p); 
                    if ((!lval || @4_LE(tl,v,@1)) && (!hval || @4_LE(v,th,@1)))
		    	@:bunins_notnil(@1,BUNh@2(b,p),@4)@
                }
            }
	/* Build a hash-table on the fly for equi-select if the selectivity is low
         * and there is sufficient memory available */
	} else if (equi && estimate*100 < batcnt && batcnt*2*sizeof(int) < (GDKmem_inuse() - GDK_mem_maxsize)) { 
	    bn = BAT_hashselect(b, bn, tl);
	} else 
@-
Single-valued sequential scans for strings are optimized when double
elemination is in effect, by scanning for the correct integer index value.

@= scanstr
	if (@1 == TYPE_str && strElimDoubles(&b->theap)) {
	    int xx, yy = strLocate(&b->theap, tl);
	    BATloopFast(b, p, q, xx)
		if (*(int*) BUNtloc(b,p) == yy) 
		    BUNfastins(bn, BUNh@2(b, p), tl);
	} else 
@= scaneq
{	int xx; 
	if (BAThvoid(b)) {
		oid yy = b->hseqbase; 
            	BATloopFast(b, p, q, xx) {
		    if (@4_EQ(tl, BUNt@3(b,p), @1))
		        BUNfastins(bn, (ptr) &yy, tl);
		    /* increment instead of compute BUNpos */
		    if (yy != oid_nil) yy++; 
	        }
	} else {
            	BATloopFast(b, p, q, xx) 
		    if (@4_EQ(tl, BUNt@3(b,p), @1))
		        BUNfastins(bn, BUNh@2(b, p), tl);
}	}
@-
General select macro(type, hloc/hvar, tloc/tvar, simple/atom, HASHloop): 
uses the atom comparison macros from gdk_search.mx. 

@= stdselect
	@:select(@1,@2,@3,@4)@ 
      	@:scaneq(@1,@2,@3,@4)@
	break;
@= rangeselect
	switch(ATOMstorage(t)) {
	case TYPE_chr:	@:stdselect(chr,@1,loc,simple)@ 
	case TYPE_sht:	@:stdselect(sht,@1,loc,simple)@ 
	case TYPE_int:	@:stdselect(int,@1,loc,simple)@ 
	case TYPE_flt:	@:stdselect(flt,@1,loc,simple)@ 
	case TYPE_dbl:	@:stdselect(dbl,@1,loc,simple)@ 
	case TYPE_lng:	@:stdselect(lng,@1,loc,simple)@ 
	default:    if (b->tvarsized) {
	    		@:select(t,@1,var,atom)@
			@:scanstr(t,@1)@ /* try strLocate().. */
			@:scaneq(t,@1,var,atom)@
	    	    } else {
			@:stdselect(t,@1,loc,atom)@
		    }
	}
@c
BAT *BAT_select(BAT *b, ptr tl, ptr th, int tail) {
	int	hval, lval, equi, offset, t, ht, tt;
	int 	batcnt, estimate = 0;
	ptr	nil;
	BAT	*bn; 
	BUN	 p,q;

	BATcheck(b,"BATselect: \n");
        BATcheck(tl,"BATselect: tl value required\n");
@-
Examine type, and values for lower- and higher-bound.
@c
	batcnt = BATcount(b);
	t = b->ttype; 
	nil = ATOMnilptr(t);
	lval = ATOMcmp(t, tl, nil) || (th == NULL);
	equi = ((th == NULL) || (lval && !ATOMcmp(t,tl,th)));
	if (equi) {
		th = tl; hval = 1; /* equi-select */
	} else {
		hval = ATOMcmp(t, th, nil);
	}

	/* preliminarily determine result types */
	ht = BAThtype(b);
	tt = tail?BATttype(b):TYPE_void;
	if (ht == TYPE_void && tt == TYPE_void) {
	    ht = TYPE_oid; 
	}

        if (hval && (ATOMcmp(t, tl,th) > 0)) {
	    /* empty range */
	    return BATnew(ht, tt, 10);
	}

@- Slice Implementations
When the result is a dense slice of the BAT, we can optimize.
A slice does not need to copy the BAT selected on, it can just
give back a 'view' on the memory of the existing BAT. See BATslice(). 
@c
	if (BATtordered(b)) {
	    BAT *v = tail?b:VIEWhead_(b,b->batRestricted); 
	    int high = batcnt-1;
	    int low = 0;

	    if (BATtdense(b)) {
	       /* Selections on voids are positional. */
		if (hval) {
		    int h = (*(oid*) th) - b->tseqbase;
		    if (h < high) high = h;
		
		} 
		if (lval) {
		    int l = (*(oid*) tl) - b->tseqbase;
		    if (l > low) low = l;
		}
	    } else {
		/* Use probe-based binary search */
		offset = BUNindex(b,BUNfirst(b));
		if (lval) {
		    p = SORTfndfirst(b,tl);
		} else {
		   /* No lower bound, we must still exclude nils. They are in 
                    * front, so we can still slice, by starting after them.
		    */
		    p = SORTfndlast(b,nil);
		}
		low = BUNindex(b,p) - offset;
		if (hval) {
		    q = SORTfndlast(b,th);
		    high = BUNindex(b,q) - (offset+1);
		}
	    }
	    bn = BATslice(v, &low, &high);
	    if (!tail) {
		BBPreclaim(v);
	    }
	    return bn;
	}
@-
Use sampling to determine a good result size, when the bat is large.
We do not sample in an equi-select on a BAT with a hash table, as the
BAT_hashselect code already ensures a good allocation estimate. 
@c
	if (batcnt > 10000 && (equi == 0 || b->thash_heap == NULL)) {
            int _lo = batcnt/2, _hi = _lo + 104;
            BAT *tmp1 = BATslice(b, &_lo, &_hi); /* slice keeps all parent properties */
            if (tmp1) {
                BAT *tmp2 = BAT_select(tmp1, tl, th, tail);
                if (tmp2) {
		    /* reserve 105% of what has been estimated */
                    estimate = (((lng) BATcount(tmp2)) * (lng) batcnt)/100LL;
                    BBPreclaim(tmp2);
                }
                BBPreclaim(tmp1);
	    }
	} 
	estimate = MAX(estimate, BATguess(b));
@-
Create the result BAT and execute the select algorithm.
@c
        bn = BATnew(ht, tt, estimate);
	if (bn) {
	    if (equi && b->thash_heap) {
	    	bn = BAT_hashselect(b, bn, tl);
	    } else if (b->hvarsized) {
		@:rangeselect(var)@
	    } else {
		@:rangeselect(loc)@
	    }
	}
	if (bn == NULL) {
	    return NULL; /* error occurred */
	} 
@-
Propagate alignment info. Key properties are inherited from the parent. 
Hash changes the order; IDX yields ordered tail; scan respects original order.
@c
        BATkey(bn, b->hkey);
        BATkey(BATmirror(bn), b->tkey);

	if (equi && b->thash_heap) {
	    bn->hsorted = bn->tsorted = FALSE;
        } else if (b->tidx_heap) {
            bn->hsorted = FALSE;
            bn->tsorted = GDK_SORTED;
	} else {
            if (BATcount(bn)==BATcount(b)) ALIGNset(bn, b);
            bn->hsorted = BAThordered(b);
            bn->tsorted = BATtordered(b);
	}
	return bn; 
}

BAT* BATselect(BAT *b, ptr h, ptr t) {
	return BAT_select(b, h, t, TRUE);
}

BAT* BATuselect(BAT *b, ptr h, ptr t) {
	return BAT_select(b, h, t, FALSE);
}

@- Random Selections 
@c
BAT* BATsample(BAT *b, int size) {
	unsigned int cnt, i, r = 0;
	int j, n, *choice, *dst;
	BAT *bn; 

	BATcheck(b, "BATsample: source BAT");

	cnt = BATcount(b);
	n = MIN(size, BATcount(b));

	bn = BATnew(BAThtype(b), BATttype(b), n);
	BATcheck(bn, "BATsample: dest BAT");

	if (n <=0) return bn;
  	dst = choice = (int*) GDKmalloc(n*sizeof(int));
 
	if (n*2 < BATcount(b)) {  /* nondense sample */
            char *vec = (char *) GDKmalloc(1 + (cnt/8));
            memset(vec, 0, 1 + (cnt/8));
            for(j=0; j<n; j++) {
                r += rand();
		i = r % cnt;
		while (1) {
			int mask = 1 << (i & 7);
			if (vec[i>>3] & mask) {
				if (++i == cnt) i = 0;
			} else {
				vec[i>>3] |= mask; break;
			}
		}
		*(dst++) = i;
            }
            GDKfree(vec);
	} else if (cnt < 65536) {
            unsigned short *vec = 
		(unsigned short *) GDKmalloc(cnt*sizeof(unsigned short));
            for(i=0; i<cnt; i++) vec[i] = i;
            for(j=0; j<n; j++) {
                r += rand();
		i = r % cnt;
		*(dst++) = vec[i];
                vec[i] = vec[--cnt];
            }
            GDKfree(vec);
	} else {
            int *vec = (int *) GDKmalloc(cnt*sizeof(int));
            for(i=0; i<cnt; i++) vec[i] = i;
            for(j=0; j<n; j++) {
                r += rand();
		i = r % cnt;
		*(dst++) = vec[i];
                vec[i] = vec[--cnt];
            }
            GDKfree(vec);
	}

	/* merge all positions into a sorted list */
	qsort((void*) choice, (size_t) n, (size_t) sizeof(int), (int (*)(const void*, const void*)) intCmp);

	/* insert the sorted sample */
	cnt = BUNindex(b, BUNfirst(b));
	for(j=0; j<n ; j++) {
                BUN p = BUNptr(b, cnt+choice[j]);       
                BUNfastins(bn, BUNhead(b,p), BUNtail(b,p));
	}
	GDKfree(choice); /* clean up choice array of BUN positions */

        /* set sorted flags by hand, because we used BUNfastins() */
        bn->hsorted = BAThordered(b);
	bn->tsorted = BATtordered(b);
	BATkey(bn, b->hkey);
	BATkey(BATmirror(bn), b->tkey);

	return bn;
}

@- Horizontal Fragmentation 
@c
BAT *BATfragment(BAT *b, ptr hl, ptr hh, ptr tl, ptr th) {
	BATcheck(b, "BATfragment:BAT required\n"); 
	if ((hl == NULL) && (hh == NULL)) {
		return BATselect(b, tl, th); 
	} 
        if ((BAThordered(b)&1) == FALSE &&
            ((BATtordered(b)&1) || (b->hidx_heap == NULL && b->tidx_heap)))
        {
                return BATmirror(BATrestrict(BATmirror(b), tl, th, hl, hh));
        }
	return BATrestrict(b, hl, hh, tl, th); 
}
@
@}
@- 
The baseline algorithm for fragment location is a two-phase process. 
First we search on the 1st
dimension and collect the qualifying BUNs in a marking on the
stack. In the second phase, the tail is analysed for all items
already marked and qualifying associations are copied into the result.
An index is exploited when possible.


@{
@= restrict1
	if (BAThordered(b)&1) {
		int offset;
		BUN p,q;
		BATflipflop(b);
		SORTloop(b, p, q, hl, hh, offset) {
			*m++ = p; 
		}
		BATflipflop(b);
		break;
	} 
{	int lval = !@1_EQ(ATOMnilptr(t),hl,@2);
	int hval = !@1_EQ(ATOMnilptr(t),hh,@2);
	if (hval && lval && @1_GT(hl,hh,@2)) {
		GDKerror("BATrestrict: illegal head range.\n");
		break;
	}
	if (b->hidx_heap && lval && hval) {
		BUN	*x, *y;

		IDXrng(b, hl, hh, &x, &y); 
		IDXloop(b, x, y) {
			*m++ = p; 
		}
		break;
	} 
{	int xx;
	BATloopFast(b, p, l, xx) {
		if ((!lval || @1_LE(hl, BUNh@3(b, p),@2)) &&
		    (!hval || @1_LE(BUNh@3(b, p), hh,@2)))
	       	{
			*m++ = p; 
		}
	}
}}
break;
@
@= restrict2
{	tl = @1_EQ(ATOMnilptr(t),tl,@2)?0:tl;
	th = @1_EQ(ATOMnilptr(t),th,@2)?0:th;
	if (th && tl && @1_GT(tl,th,@2)) {
		GDKerror("BATrestrict: illegal tail range.\n");
		break;
	}
	for (; i < m; i++) {
		ptr v = BUNt@4(b, *i); 
		if ((!tl || @1_LE(tl, v, @2)) && (!th || @1_LE(v, th, @2)))
		{
			BUNfastins(bn, BUNh@3(b, *i), v); 
		}
	}
}
break;
@c
BAT *BATrestrict(BAT *b, ptr hl, ptr hh, ptr tl, ptr th) {
	BAT	*bn; 
	BUN	p = NULL, l; 
	BUN	*mark, *m, *i; 
	int	t; 

	BATcheck(hl,"BATrestrict:hl is null");
	BATcheck(hh,"BATrestrict:hh is null");
	BATcheck(tl,"BATrestrict:tl is null");
	BATcheck(th,"BATrestrict:th is null");
	bn = BATnew(BAThtype(b), BATttype(b), BATguess(b));
	if (bn == NULL) {
		return NULL; 
	}
	BATkey(bn, b->hkey);
	BATkey(BATmirror(bn), b->tkey);
	bn->hsorted = BAThordered(b);
	bn->tsorted = BATtordered(b);

	t = BATcount(b); 
	if (t == 0) {
		return bn; 
	}
	mark = (BUN*) GDKmalloc((unsigned) t*sizeof(BUN)); 
	m = mark;
	i = mark; 
	switch(ATOMstorage(t = b->htype)) {
	case TYPE_chr: @:restrict1(simple,chr,loc)@
	case TYPE_sht: @:restrict1(simple,sht,loc)@
	case TYPE_int: @:restrict1(simple,int,loc)@
	case TYPE_flt: @:restrict1(simple,flt,loc)@ 
	case TYPE_dbl: @:restrict1(simple,dbl,loc)@ 
	case TYPE_lng: @:restrict1(simple,lng,loc)@ 
	default:
		if (b->hvarsized) {
			@:restrict1(atom,t,var)@
		} else {
			@:restrict1(atom,t,loc)@
		}	
	}

	/* second phase */
	if (b->hvarsized) {
		switch(ATOMstorage(t = b->ttype)) {
		case TYPE_chr: @:restrict2(simple,chr,var,loc)@
		case TYPE_sht: @:restrict2(simple,sht,var,loc)@
		case TYPE_int: @:restrict2(simple,int,var,loc)@
		case TYPE_flt: @:restrict2(simple,flt,var,loc)@ 
		case TYPE_dbl: @:restrict2(simple,dbl,var,loc)@ 
		case TYPE_lng: @:restrict2(simple,lng,var,loc)@ 
		default:
		    if (b->tvarsized) {
			@:restrict2(atom,t,var,var)@
		    } else {
			@:restrict2(atom,t,var,loc)@
		    }
       		}
	} else {
		switch(ATOMstorage(t = b->ttype)) {
		case TYPE_chr: @:restrict2(simple,chr,loc,loc)@
		case TYPE_sht: @:restrict2(simple,sht,loc,loc)@
		case TYPE_int: @:restrict2(simple,int,loc,loc)@
		case TYPE_flt: @:restrict2(simple,flt,loc,loc)@ 
		case TYPE_dbl: 
		case TYPE_lng: @:restrict2(simple,lng,loc,loc)@ 
		default:
		    if (b->tvarsized) {
			@:restrict2(atom,t,loc,var)@
		    } else {
			@:restrict2(atom,t,loc,loc)@
		    }
       		}
	}
	GDKfree(mark); 

	/* propagate alignment info */
	if (BATcount(bn)==BATcount(b)) ALIGNset(bn,b);

	return bn; 
}


@+ BAT Sorting
@{
@= idxloop
IDXloop(b, p, q) {
        if (*p) BUNfastins(c, BUNh@1(b, (*p)), BUNt@2(b, (*p)));
}
@
@- check on order
@c
int BATordered(BAT *b) {
	BATcheck(b, "BATordered: BAT"); 
	PROPDEBUG BATpropcheck(b);
	return (BAThordered(b)&1);
}

@- return a sorted copy
@c
BAT *BATsort(BAT *b) {
	int tt = b->ttype;

	BATcheck(b, "BATsort: BAT"); 
	if (BATordered(b)) {
		return BATrcopy(b);
        } 
	/* a void tail column 0,1,2,3,... must be materialized to oid before sorting */
	if (tt == TYPE_void && b->tseqbase != oid_nil) {
		tt = TYPE_oid;
	}
	return BATorder(batcopy(b, b->htype, tt, TRUE));
}


@- sort in place
@%BATorder@ sorts the BAT itself. 
@c
BAT *BATorder(BAT *b) {
	BATcheck(b, "BATorder: BAT"); 
        if (BATordered(b)) {
		return b;
	}
	b->tseqbase = oid_nil; /* ignore the void case here */
	GDKqsort(BUNfirst(b), b->hheap.base, BATcount(b), BUNsize(b), b->htype, b->hloc); 
        ACCremoveall(b);
        ALIGNdel(b, "BATorder");
	b->hsorted = GDK_SORTED;
	b->tsorted = FALSE;
	b->hdense = FALSE;
	b->batDirtydesc = b->batDirtybuns = TRUE;

	return b;
}

@- reverse in place
@%BATrevert@ rearranges a BAT in reverse order on head.
@c
BAT* BATrevert(BAT *b) {
        int xx;
        char *buf;
        BUN p,q;
     
        BATcheck(b, "BATrevorder");
        ALIGNdel(b, "BATrevorder");
	BATorder(b);
        xx = BUNsize(b);
        buf = (char*) GDKmalloc(xx);
        for(p=BUNlast(b)-xx, q=BUNfirst(b); p > q; p -=xx, q+=xx) {
                memcpy(buf, p, xx);
                memcpy(p, q, xx);
                memcpy(q, buf, xx);
        }
        ACCremoveall(b);
        b->hsorted = b->tsorted = FALSE;
        GDKfree(buf);
	return b;
}

@
@}

@+ BAT partitioning
For distributed processing we support hash and range 
partitioning operators: @%BATsplithash@ and @%BATsplitrange@.
@{
@-
The @%part_bat@ function creates a partition BAT. 
@c
BAT *part_bat(BAT *b, int ht, int tt, int expected_size, int respect_order){
        BAT *bn = BATnew(ht, tt, (int) (expected_size*BATMARGIN));
	if (bn) {
	    BATkey(bn, b->hkey);
	    BATkey(BATmirror(bn), b->tkey);
            bn->hsorted = respect_order && (BAThordered(b)&1);
            bn->tsorted = respect_order && (BATtordered(b)&1);
@-
On big bats, we force memory mapped storage by swapping the dirty bat out.
If there is memory shortage, it will be read in mapped. We also give 
memory advice for sequental access (sequential inserts).

            bat bid = bn->batCacheid;
	    int memuse = b->batBuns->size + (b->hheap.base?b->hheap.size:0) +
				        (b->theap.base?b->theap.size:0);
	    if (memuse > GDK_BIGMEM) {
        	bn->batBuns->free = MIN(16384, bn->batBuns->size);
        	BBPcold(bid);
        	bn = BATdescriptor(bid);
        	bn->batBuns->free = BUNsize(bn);
	        b->batDirtydesc = TRUE;
        	BATmadvise(bn, BUF_SEQUENTIAL, -1, -1, -1, -1);
		BBP_refs(bid)--;
	    }
@c
	}
        return bn;
}
@- hash partitioning
@c
#define BUNhash(bx,hx,tx)\
	i = HASHprobe(&h,tx);if ((r = BUNfnd(bx, &i)) != NULL)\
		BUNfastins(BBPcache(*(bat*) BUNtloc(bx,r)), hx, tx);

BAT *BAThashsplit(BAT *b, int n, int unary) {
	BAT	*metabat, *bn, *bf; 
	BUN	r;
	Hash	h;
	int	cnt,i=0; 

	BATcheck(b, "BAThashsplit");
	metabat = BATnew(TYPE_int, TYPE_bat, n);
	bn = unary?VIEWhead_(b,b->batRestricted):b;
	if (n <= 1) {
	    BUNins(metabat, &i, &bn->batCacheid);
	} else {
            h.mask = n;
            h.type = BATttype(b);
	    cnt = BATMARGIN*BATbuncount(b)/n; 
	    for (i = 0; i < n; i++) {
		bf = part_bat(bn, BAThtype(bn), BATttype(bn), cnt, TRUE);
		if (bf == NULL) {
			BBPreclaim(metabat);
			return NULL;
		}
		BUNins(metabat, &i, &bf->batCacheid); 
	    }
	    @:updateloop(metabat,b,BUNhash)@
	}
	return metabat; 
}

@- range partitioning
Range parititioning ensures that identical values appear in one
partition only. The routine also tries to deliver partitions of
uniform size.
@c
BAT *BATrangesplit(BAT *b, int n, int unary) {
	BAT	*metabat, *slice, *histo, *bf = NULL, *bn, *m;
	int 	target, tpe, maxsize, *sizes;
	int	xx, yy=0, zz=0;
	ptr 	*seps, nilval;
	BUN	r, s;
	dbl	scale;
	int 	thorough = (n<=1 || BATtvoid(b) || BATtordered(b))?1:10;

	BATcheck(b, "BATrangesplit");

	bn = unary?VIEWhead_(b,b->batRestricted):b;
	m = BATmirror(b);
	metabat = BATnew(BATttype(b), TYPE_bat, n);
	nilval = ATOMnilptr(BATttype(b));

@- 
We use sampling to determine bucket sizes. 
Uniform bucket sizes are the ideal to be achieved. 
If necessary though, we deliver less than n buckets.
@c
        slice  = BATsample(b, MIN(MAX(30*n*thorough,100*thorough),BATcount(b)));
        histo  = BAThistogram(slice);
	target = BATcount(b)/n;
	scale  = ((dbl) BATcount(b))/((dbl) BATcount(slice));
        BBPreclaim(slice);
	BATmax(histo, &maxsize);
	maxsize *= scale;
	target = MAX(target, maxsize);
        sizes  = (int*) GDKmalloc(2*n*sizeof(int));
        seps   = (ptr*) GDKmalloc(2*n*sizeof(ptr));
@-
Use the histogram to determine good split boundaries on b.
@c
        BATorder(histo);
        BATloopFast(histo, r, s, xx) {
		int cnt = *(int*) BUNtloc(histo,r);
		int add = scale * cnt;
		if (zz + add > target) {
			if ((zz + add - target) < (target-zz)) {
				sizes[yy] = zz+add;
                    		seps[yy] = ATOMdup(histo->htype,
 						   BUNhead(histo,r));
				add = 0;
			} else {
				sizes[yy] = zz;
                    		seps[yy] = ATOMdup(histo->htype,
 						   BUNhead(histo,(r-xx)));
			}
			zz = 0; yy++;
		}
		zz += add;
	}
	if ((sizes[yy-1] + zz - target) > (target - zz)) {
		sizes[yy] = zz;
	} else {
		yy--; /* join with the last */
	}
	seps[yy] = nilval;
        BBPreclaim(histo);
	if (n != yy +1) {
		GDKwarning("rangesplit: delivering %d instead of %d fragments\n"
				,yy+1, n); 
		n = yy + 1;
	}

@- 
CASE 1: just one bucket.
This is done without copying b.
@c
	if (n <= 1) {
	    BUNins(metabat, nilval, &bn->batCacheid);

@- 
CASE 2: sorted on fragmentation column.
We can again avoid copying, by giving slices (views) on the source BAT.
Virtual oids (void) is a special subcase with positional lookup instead
of binary search.
@c
	} else if (BATtvoid(b) || BATtordered(b)) {
	    int l, h = -1, o = BUNindex(b,BUNfirst(b));

	    for(yy=0; yy<n; yy++) {
		l = h+1;
		if (yy == n-1) {
			r = BUNlast(m);
			h = BUNindex(b,r) - (o+1);
		} else if (BATtdense(b)) {
			h = ((*(oid*) seps[yy]) - b->tseqbase);
		} else {
			r = SORTfndlast(m, seps[yy]);
			h = BUNindex(b,r) - (o+1);
		}
		bf = BATslice(bn, &l, &h); /* produces view bat */
		BUNins(metabat, seps[yy], &bf->batCacheid); 
	    }

@- 
CASE 3: binary index on fragmentation column.
If a binary index exist on the split column, it is quite easy to split and 
achieve totally sorted chunks at the same time. 
@c
	} else if (b->tidx_heap) {
		BUN *q, *p = IDXfirst(m);
		
		for(yy=0; yy<n; yy++) {
			if (yy == n-1) {
				q = IDXlast(m);
			} else {
				q = IDXfndlast(m, seps[yy]);
			}
	    		bf = part_bat(bn,BAThtype(bn),BATttype(bn),q-p,FALSE);
			if (bf == NULL) {
				BBPreclaim(metabat);
				return NULL;
			}
		        if (!unary) bf->tsorted = GDK_SORTED; 
	    		BUNins(metabat, seps[yy], &bf->batCacheid);
			IDXloop(m, p, q) {
				BUNfastins(bf, BUNhead(b, *p), BUNtail(b, *p));
			}
			p = q + 1;
		}

@- 
CASE 4: full scan.
If it ain't sorted then we gotta scan the whole thing and split.
This is heavy stuff so we optimize execution according to datatype.
@
DELETED: simple walk-through list approach
		for(yy=0; yy<n-1; yy++) {
			if (@1_LE(val, seps[yy], @3)) break;
		}
		BUNfastins(bats[yy], BUNhead(b,r), val);
@
We now use binary search for getting to the right bucket, so
that this routine also works efficiently on many buckets. 

@= rangesplit
BATloopFast(b, r, s, xx) {
	ptr val = BUNt@2(b,r);
	int lo = 0; 
	int hi = n-1;
	while(TRUE) {
		yy = (lo+hi)/2;
		if (yy < n-1 && @1_GT(val, seps[yy], @3)) {
			lo = yy + 1;
			if (lo >= hi) { yy = hi; break; }
		} else if (yy > 0 && @1_LE(val, seps[yy-1], @3)) {
			hi = yy - 1;
			if (hi <= lo) { yy = lo; break; }
		} else {
			break;
		}
	} 
	BUNfastins(bats[yy], BUNhead(b,r), val);
} break;
@c
	} else {
            BAT **bats = (BAT**) GDKmalloc(n*sizeof(BAT*));
	    for(yy=0; yy<n; yy++) {
		bats[yy] = part_bat(bn,BAThtype(bn),bn->ttype,sizes[yy],TRUE);
		if (bf == NULL) {
			BBPreclaim(metabat);
			return NULL;
		}
		BUNins(metabat, seps[yy], &bats[yy]->batCacheid);
		GDKfree(seps[yy]);
	    }
            switch(tpe = ATOMstorage(b->ttype)) {
            case TYPE_chr:  @:rangesplit(simple,loc,chr)@
            case TYPE_sht:  @:rangesplit(simple,loc,sht)@
            case TYPE_int:  @:rangesplit(simple,loc,int)@
            case TYPE_flt:  @:rangesplit(simple,loc,flt)@
            case TYPE_dbl:  @:rangesplit(simple,loc,dbl)@
            case TYPE_lng:  @:rangesplit(simple,loc,lng)@
            default:if (b->tvarsized) {
                            @:rangesplit(atom,var,tpe)@
                    } else {
                            @:rangesplit(atom,loc,tpe)@
                    }
        
	    }
            GDKfree(bats);
	}
        GDKfree(seps);
        GDKfree(sizes);

	return metabat; 
}
@
@}
