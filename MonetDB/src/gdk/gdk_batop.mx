@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@' 
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@' 
@' The Original Code is the Monet Database System.
@' 
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2003 CWI.
@' All Rights Reserved.
@' 
@' Contributor(s):
@' 		Martin Kersten <Martin.Kersten@cwi.nl>
@' 		Peter Boncz <Peter.Boncz@cwi.nl>
@' 		Niels Nes <Niels.Nes@cwi.nl>
@' 		Stefan Manegold  <Stefan.Manegold@cwi.nl>

@f gdk_batop
@a M. L. Kersten, P. Boncz, S. Manegold
@* Common BAT Operations
@T
This module contains the following BAT algebra operations:
\begin{description}
\item[bulk updates] multi-insert, multi-delete, multi-replace
\item[common aggregates] min, max and histogram
\item[oid column manipulations] mark, number and split.
\item[bat selections] select, slice, sample, fragment and restrict.
	Note: non hash-/index-supported scanselects have been "outsourced"
	to gdk\_scanselect.mx as the fully expanded code grows to large to be
	(conveniently) compiled in a single file.
\item[bat partitioning] hash partition, range partitioning
\end{description}
@T
As you probably noticed :-), we try to factor out all possible 
overhead by inlining code. This includes the macros BUNhead and BUNtail, 
which do a test to see whether the atom resides in the buns or in a 
variable storage heap. The updateloop(dstbat, srcbat, operation) macro 
invokes operation(dstbat, BUNhead(srcbat), BUNtail(srcbat)) on all buns
of the srcbat, but testing only once where they reside.
@c
#include "gdk.h"
#include "gdk_scanselect.h"

@= updateloop
{	BUN p, q; 
 	int xx;
	BATloopFast(@2, p, q, xx) {
		@3(@1, BUNhead(@2, p), BUNtail(@2, p)); 
	}
}

@+ BAT insert/delete/replace
The content of a BAT can be appended to (removed from) another using
@%BATins@ (@%BATdel@).
@c
BAT *BATins(BAT *b, BAT *n) {
	ssize_t needed = 0;

	if (b == NULL || n == NULL || BATcount(n) == 0) {
		return b;
	}
        ALIGNins(b, "BATins");
	BATcompatible(b, n);

	if (b->htype != TYPE_void && (b->ttype == TYPE_void ||
		(!b->hhash_heap && b->thash_heap &&
		ATOMstorage(b->ttype) == TYPE_int))) /* OIDDEPEND */
	{
		return BATmirror(BATins(BATmirror(b),BATmirror(n)));
	}

	if (BAThdense(b) && b->htype == TYPE_void){
		oid t = *(oid*)BUNhead(b,BUNlast(b)-BUNsize(b));
		oid h = *(oid*)BUNhead(n,BUNfirst(n));
		if ((t+1) != h)
			b = BATmaterialize(b, BATcount(b)+ BATcount(n));
	}

	needed = BATcount(n) - (((b)->batBuns->size - (b)->batBuns->free)/BUNsize(b));
  	if (needed > 0){
		/* if needed exceeds a normal growth extend just with needed */
		size_t ncap = BATcapacity(b) + needed;
		size_t grows = BATgrows(b);
		if (ncap > grows)
			grows = ncap;
		BATextend(b, grows); /* allocation hint */ 
	}

	if (b->hidx_heap || b->tidx_heap) {
                IDXdestroy(b);
	}
	if (b->thash_heap==NULL && b->hacctype==0 && b->tacctype==0 && b->batSet==0 
	    && (b->hkey&BOUND2BTRUE)==0 && (b->tkey&BOUND2BTRUE)==0 && 
		(b->hhash_heap==NULL || ATOMstorage(b->htype) == TYPE_int))
	{
		BUN p, q, r = BUNlast(b); 
 		int xx, yy = BUNsize(b);

		if (BATcount(b) == 0) {
		    ALIGNset(b, n);
		} else if (BATcount(n)) {
		    BUN last = BUNlast(b) - BUNsize(b);
		    size_t idx = BUNindex(b,BUNlast(b)); 

		    xx = ATOMcmp(b->htype, BUNhead(n,BUNfirst(n)), 
					   BUNhead(b, last));
		    if ((BAThordered(n)&1)==0 || ((BAThordered(b)&1) && xx<0)) {
		    	b->hsorted = FALSE; 
		    	b->H->nosorted = idx;
			if (b->hdense&1){ 
		    		b->hdense = FALSE; 
		    		b->H->nodense = idx;
			}
		    }
		    if ((BAThordered(b)&1)==0 || n->hkey==0 || xx==0) {
			if (b->hkey) BATkey(b, FALSE);
		    } 
		    if (b->htype != TYPE_void && (b->hsorted&b->hdense&1) &&
			(BAThdense(n)==0 || *(oid*) BUNhloc(b,last) != 1 + 
					    *(oid*) BUNhead(n,BUNfirst(n))))  
		    {
		    	b->hdense = FALSE; 
		    	b->H->nodense = idx;
		    }

		    xx = ATOMcmp(b->ttype, BUNtail(n,BUNfirst(n)), 
					   BUNtail(b, last));
		    if ((BATtordered(n)&1)==0 || ((BATtordered(b)&1) && xx<0)) {
		    	b->tsorted = FALSE; 
		    	b->T->nosorted = idx;
			if (b->tdense&1){
		    		b->tdense = FALSE; 
		    		b->T->nodense = idx;
			}
		    }
		    if ((BATtordered(b)&1)==0 || n->tkey==0 || xx==0) {
			if (b->tkey) BATkey(BATmirror(b), FALSE);
		    } 
		    if (b->ttype != TYPE_void && (b->tsorted&b->tdense&1) &&
			(BATtdense(n)==0 || *(oid*) BUNtloc(b,last) != 1 + 
					    *(oid*) BUNtail(n,BUNfirst(n))))  
		    {
		    	b->tdense = FALSE; 
		    	b->T->nodense = idx;
		    }
		}
		if (b->htype == TYPE_void) {
			BATloopFast(n, p, q, xx) {
				bunfastins_nocheck(b, r, NULL, BUNtail(n, p), yy); 
				r += yy;
			}
		} else if (b->hhash_heap) {
			size_t i = BUNindex(b, BUNlast(b));
			BATloopFast(n, p, q, xx) {
				ptr v = BUNhloc(n,p);
				bunfastins_nocheck(b, r, v, BUNtail(n, p), yy); 
				HASHins_int(b->hhash, (hash_t)i, v); 
				r += yy; i++; 
			}
		} else {
			BATloopFast(n, p, q, xx) {
				bunfastins_nocheck(b, r, BUNhead(n, p), BUNtail(n, p), yy); 
				r += yy;
			}
		}
		b->batDirty = 1;
	} else {
		@:updateloop(b,n,BUNins)@
	}
	return b;
}

BAT *BATdel(BAT *b, BAT *n) {
	ERRORcheck(b == NULL, "set:BAT required\n");
	ERRORcheck(n == NULL, "set:BAT required\n");
	if (BATcount(n) == 0) {
		return b;
	}
        ALIGNdel(b, "BATdel");
	TYPEcheck(b->htype, n->htype);
	TYPEcheck(b->ttype, n->ttype);
	@:updateloop(b,n,BUNdel)@
	return b;
}

#define _BUNdelHead(b, x, y) BUNdelHead(b, x)

BAT *BATdelHead(BAT *b, BAT *n) {
	ERRORcheck(b == NULL, "set:BAT required\n");
	ERRORcheck(n == NULL, "set:BAT required\n");
	if (BATcount(n) == 0) {
		return b;
	}
        ALIGNdel(b, "BATdelHead");
	TYPEcheck(b->htype, n->htype);
	@:updateloop(b,n,_BUNdelHead)@
	return b;
}
@-
The last in this series is a BATreplace, which replaces all the
buns mentioned.
@c
BAT *BATreplace(BAT *b, BAT *n) {
	if (b == NULL || n == NULL || BATcount(n) == 0) {
		return b;
	}
        ALIGNdel(b, "BATreplace");
	BATcompatible(b, n);
	@:updateloop(b,n,BUNreplace)@
	
	return b;
}
@}

@+ Introducing OID Columns
The @%BATmark@ operation is normally used to prepare a class of query
results. Likewise, @%BATnumber@ is heavily used in the SQL front-end.
@c
#define BUNmark(bx,	hx, tx) BUNfastins(bn, hx, NULL); 
BAT *BATmark(BAT *b, oid oid_base) {
        BAT     *bn;
 
        BATcheck(b, "BATmark");
	if (BATrestricted(b) == BAT_READ) {
		bn = VIEWhead(b);
	} else if (oid_base == oid_nil) {
		return BATconst(b, TYPE_oid, (ptr)&oid_base);
	} else {
		size_t xx;
		if (b->htype == TYPE_void) {
			oid *base, cur = oid_base; 
			bn = BATnew(TYPE_void, TYPE_oid, xx=BATcount(b)); 
			bn->batBuns->free += xx*sizeof(oid);
			for(base=(oid*) BUNfirst(bn); xx--; cur++,base++) 
				*base = cur; 
		} else {
			bn = BATnew(b->htype, TYPE_void, BATcount(b)); 
			@:updateloop(bn,b,BUNmark)@
		}
		ALIGNsetH(bn,b);
		bn->tsorted = GDK_SORTED;
		bn->tdense = TRUE;
		BATkey(BATmirror(bn), TRUE);
	}
	BATseqbase(BATmirror(bn), oid_base);
        return bn;
}
 
#define BUNnumber(bx,hx,tx)	BUNfastins(bx, hx, (ptr)&i); i++;
BAT *BATnumber(BAT *b) {
        int     i = 0;
        BAT     *bn;
 
        BATcheck(b, "BATnumber");
	/* assert(BATcount(b) <= MAXINT); */
        bn = BATnew(b->htype, TYPE_int, BATcount(b));
        if (bn == NULL) {
                return NULL;
        }
	ALIGNsetH(bn,b);
        @:updateloop(bn,b,BUNnumber)@
	BATsetaggr(bn, GDK_AGGR_CARD, i);
	bn->hsorted = BAThordered(b);
	bn->tsorted = GDK_SORTED;
        return bn;
}

BAT *BATgroup(BAT *b, int start, int incr, int grpsize) {
        BUN p, q;
        int ngroups = 1, i = 0, xx;
        BAT *bn;

        BATcheck(b, "BATgroup");
        bn = BATnew(b->htype, TYPE_int, BATcount(b));
        if (bn == NULL) {
                return NULL;
        }

        ALIGNsetH(bn,b);
   
        BATloopFast(b, p, q, xx) {
            BUNfastins(bn, BUNhead(b, p), (ptr)&start);
            if(i == grpsize-1) { start += incr; i = 0; ngroups++; } else { i++; }
        }
	if (i == 0) ngroups--;
	BATsetaggr(bn, GDK_AGGR_CARD, ngroups);
        bn->hsorted = BAThordered(b);
        bn->tsorted = GDK_SORTED;

        return bn;
}

BAT* BATconst(BAT *b, int tailtype, ptr v) {
        BAT *bn;
        BUN p,q;
        int xx;

	if (BATrestricted(b) == BAT_READ &&
           (tailtype == TYPE_void || (tailtype == TYPE_oid && *(oid*) v == oid_nil)))
	{
		oid seqbase = (tailtype==TYPE_void)?oid_nil:*(oid*) v;
		bn = VIEWhead(b);
		BATseqbase(BATmirror(bn), seqbase);
		return bn;
	}
	if (tailtype == TYPE_bat) {
		v = &((BAT*) v)->batCacheid;
	} else if (tailtype == TYPE_void && b->htype == TYPE_void) {
		tailtype = TYPE_oid;
		v = ATOMnilptr(TYPE_oid);
	}
        bn = BATnew(b->htype, tailtype, BATcount(b));
	if (bn == NULL) {
		return bn; 
	}
        BATloopFast(b, p, q, xx) {
		BUNfastins(bn, BUNhead(b,p), v);
	}
	ALIGNsetH(bn,b);
	bn->tsorted = GDK_SORTED;
	BATsetaggr(bn, GDK_AGGR_CARD, BATcount(b) > 0);
	if (tailtype == TYPE_bit) {
		BATsetaggr(bn, GDK_AGGR_SIZE, (*(bit*) v == TRUE)?BATcount(b):0);
	}
        return bn;
}


@+ BAT Aggregates

We retain the size() and card() agggregate results in the column descriptor.
We would like to have such functionality in an extensible way for many aggregates, 
for DD (1) we do not want to change the binary BAT format on disk and (2) aggr
and size are the most relevant aggregates. 

It is all hacked into the aggr[3] records; three adjacent integers that 
were left over in the column record. We refer to these as if it where an int aggr[3] array.
The below routines set and retrieve the aggregate values from the tail of the BAT, as many 
aggregate-manipulating BAT functions work on tail.

The rules are as follows: aggr[0] contains the alignment ID of the column (if set i.e. nonzero).
Hence, if this value is nonzero and equal to b->talign, the precomputed aggregate values in 
aggr[GDK_AGGR_SIZE] and aggr[GDK_AGGR_CARD] hold. However, only one of them may be set
at the time. This is encoded by the value int_nil, which cannot occur in these two aggregates.

This was now extended to record the property whether we know there is a nil value present
by mis-using the highest bits of both GDK_AGGR_SIZE and GDK_AGGR_CARD.
@c
#define GDK_NIL_BIT (1 << 31)

/* later to evolve into a more sophisticated aggregate retention system */
int BATgetaggr(BAT *b, int idx) {
        int *aggr = b->T->aggr;
        if (aggr[0] && aggr[0] == (int) b->talign) {
		if (idx == GDK_AGGR_HASNIL) {
			if (aggr[1] & GDK_NIL_BIT) {
                		return (aggr[2] & GDK_NIL_BIT)?TRUE:FALSE;
}
		} else {
			int val = (int) (aggr[idx] & ~GDK_NIL_BIT);
			if (val != ~GDK_NIL_BIT) {
				return val;
			}
		}
        }
        return (idx == GDK_AGGR_HASNIL)?((int) bit_nil):int_nil;
}

int BATsetaggr(BAT *b, int idx, int val) {
        int *aggr = b->T->aggr;
        if (aggr[0] == 0 || aggr[0] != (int) b->talign || BATgetaggr(b, idx) != val) {
                if (b->talign == 0) {
			b->talign = OIDnew(1);
		}
		if (aggr[0] != (int) b->talign) {
                	aggr[0] = (int) b->talign;
			aggr[GDK_AGGR_SIZE] = aggr[GDK_AGGR_CARD] = ~GDK_NIL_BIT;
		} 
		if (idx != GDK_AGGR_HASNIL) {
                	aggr[idx] &= GDK_NIL_BIT;
                	aggr[idx] |= (val == int_nil)?~GDK_NIL_BIT:(val & ~GDK_NIL_BIT);
		} else if (val != (int) bit_nil) {
                	aggr[1] |= GDK_NIL_BIT;
                	aggr[2] = (val & ~GDK_NIL_BIT) | (val?GDK_NIL_BIT:0);
		} else {
                	aggr[1] &= ~GDK_NIL_BIT;
		}
                b->batDirtydesc = TRUE;
        }
        return val;
}
@-
The @%BAThistogram@ function calculates the frequency distribution of the
tail values in its operand bat. Notice, that updates on the result do
not affect the delta administration.
Construction of a histogram over a string (or complex object)
can be sped up using the reference information in the BUN
and bulk copying the heap.
@
@
There are now seperate versions for each type, and for each a 
hash- and a merge-algorithms. 

@= histoloop_inner
	if (b->tkey) { yy=1;
		BATloopFast(b, p, q, xx) 
			BUNfastins(bn, BUNt@1(b,p), &yy);
	} else if (!(BATtordered(b)&1)) {
		BATloopFast(b, p, q, xx) {
			ptr v =  (ptr) BUNt@1(b,p);
			(void) BATprepareHash(bn);
			HASHloop@2(bn, bn->hhash, tt, v, r)
				goto found@3@2; 
			BUNins(bn, v, &yy);
			r = BUNlast(bn) - BUNsize(bn);
found@3@2:		(*(int*) BUNtloc(bn,r))++;
		}
		HASHdestroy(bn); 
	} else if (BATcount(b)) {
		ptr prev = (ptr) BUNt@1(b, BUNfirst(b));
		BATloopFast(b, p, q, xx) {
			ptr v = (ptr) BUNt@1(b,p);
			if (@3_CMP(v, prev, @4) == 0) {
				yy++;
			} else {
				BUNfastins(bn, prev, &yy);
				yy = 1;
			} prev = v;
		} 
		BUNfastins(bn, prev, &yy);
	} break;
@= histoloop
{	hash_t tt;
	int xx, yy=0;
	BUN p, q, r;

	switch(ATOMstorage(tt=bn->htype)) {
	case TYPE_chr:	@:histoloop_inner(loc,_chr,simple,chr)@
	case TYPE_sht:  @:histoloop_inner(loc,_sht,simple,sht)@
	case TYPE_int:
	case TYPE_flt:	@:histoloop_inner(loc,_int,simple,int)@
	case TYPE_lng: 
	case TYPE_dbl:  @:histoloop_inner(loc,_lng,simple,lng)@
	default: if (bn->hvarsized) {
			@:histoloop_inner(var,var,atom,tt)@
        	 } else {
			@:histoloop_inner(loc,loc,atom,tt)@
        	 }
}	}
@c
BAT *BAThistogram(BAT *b) {
	BAT *bn; 
	int 	tricky = 0;
	
	BATcheck(b, "BAThistogram"); 

	tricky = (b->ttype==TYPE_str && strElimDoubles(&b->theap));
	if (b->talign==0) {
		b->talign = OIDnew(1);
	}
	bn = BATnew(tricky?TYPE_var:b->ttype, TYPE_int, 200); 
	if (bn == NULL) {
		return bn;
	}

	@:histoloop()@
@- 
And now correct the interpretation of the values encountered
by bulk copying the heap as well
@c
	if (tricky) {
		BAT *bm = BATmirror(bn);
		bm->ttype = bn->htype = b->ttype;
		bm->tvarsized = bn->hvarsized = 1;
		strcpy(bn->hatom, ATOMname(b->ttype));
		HEAPcopy(&bn->hheap, &b->theap);
	}
	BATkey(bn,TRUE);
	bn->hsorted = BATtordered(b);
	bn->tsorted = FALSE;
        bn->halign = NOID_AGGR(b->talign); 
        if (BATcount(bn) == BATcount(b)) {
		BAT *bm = BATmirror(b);
                ALIGNsetH(bn,bm);
        }
	if (ATOMstorage(b->ttype) == TYPE_bit) {
		bit trueval = TRUE;
		BUN p = BUNfnd(bn, &trueval);
		BATsetaggr(b,GDK_AGGR_SIZE,p?*(int*)BUNtloc(bn,p):0);
	}
	BATsetaggr(b,GDK_AGGR_CARD,BATcount(bn));
	return bn; 
}

@- 
The @%BATcount_no_nil@ function counts all BUN in a BAT that have a non-nil tail value.
@= cntloop
	BATloopFast(b, p, q, xx) {
		if (!@1_EQ(nil,BUNt@2(b, p),@3)) {
			cnt++;
		}
	}
	break;
@c
size_t BATcount_no_nil(BAT *b) {
	size_t cnt = (size_t)0;
	BUN p,q;
	int xx;
	hash_t tt = b->ttype;
	ptr nil = ATOMnilptr(tt);

	BATcheck(b,"BATcnt");
	switch(ATOMstorage(tt)) {
	case TYPE_chr:  @:cntloop(simple,loc,chr)@
	case TYPE_sht:  @:cntloop(simple,loc,sht)@
	case TYPE_int:  @:cntloop(simple,loc,int)@
	case TYPE_flt:  @:cntloop(simple,loc,flt)@
	case TYPE_lng:  @:cntloop(simple,loc,lng)@
	case TYPE_dbl:  @:cntloop(simple,loc,dbl)@
	default: if (b->hvarsized) {
			@:cntloop(atom,var,tt)@
        	 } else {
			@:cntloop(atom,loc,tt)@
        	 }
	}
	return cnt;
}

@}
@+ BAT Selections
The BAT selectors are among the most heavily used operators. 
Their efficient implementation is therefore mandatory.

The interface supports seven operations: @%BATslice@, @%BATselect@, 
@%BATfragment@, @%BATsample@, @%BATproject@, @%BATrestrict@.

@- BAT slice
@T
This function returns a horizontal slice from a BAT. It optimizes
execution by avoiding to copy when the BAT is memory mapped (in this 
case, an independent submap is created) or else when it is read-only, 
then a VIEW bat is created as a result.

If a new copy has to be created, this function takes care to preserve
void-columns (in this case, the seqbase has to be recomputed in the result).

Note that the BATslice() is used indirectly as well as a special 
case for BATselect (range selection on sorted column), BATrangesplit
(fragmentation on sorted column) and BATsemijoin (when two dense columns
are semijoined).

NOTE new semantics, the selected range is excluding the high value.
@c
BAT *BATslice(BAT *b, size_t l, size_t h) {
	size_t low = l;
        int xx;
	BAT *bn;

	if (h > BATcount(b)) h = BATcount(b);
	if (h < l) h = l;
        l += BUNindex(b, BUNfirst(b));
        h += BUNindex(b, BUNfirst(b));

@- optimization
If a BAT is memory mapped it, a slice can be taken without copying.
The @%HEAPsubcopy@ uses the mmap_private for obtaining a second and 
independent view on the virtual memory.
@c
#if 0 && defined(NOEXTEND_PRIVMAP)
	/* commented out because when the access  mode of b is changed later, this bn is
         * not detactable and will suffer side effects from updates in b.
	 * besides, for most query evaulation pruposes, the horizontal view creation
         * below is suffiecient. Peter/dec99
	 */
	if (i < h && (BATrestricted(b) != BAT_WRITE && b->batBuns->storage == STORE_MMAP)) {
		BUN start = BUNptr(b,l-1);
		BUN end = BUNptr(b,h);
		size_t add;
	        bn = BATcreatedesc(b->htype, b->ttype);
		bn->dims = b->dims;
		add = HEAPsubcopy(bn->batBuns, b->batBuns, end-start, start-b->batBuns->base);
		if (b->hheap.base)
			HEAPsubcopy(&bn->hheap, &b->hheap, b->hheap.free, 0);
		if (b->theap.base)
			HEAPsubcopy(&bn->theap, &b->theap, b->theap.free, 0);
                bn->batHole = bn->batDeleted = BUNptr(bn, 0) + add;  
                bn->batInserted = BUNptr(bn, 1) + add;  
        	BBPcacheit(bn,TRUE);
	} else 
#endif
@-
Alternatively, if the source BAT is readonly, then we can obtain a VIEW
that just reuses the memory of the source. 
@c
	if (BATrestricted(b) == BAT_READ || BATrestricted(b) == BAT_APPEND) {
		bn = VIEWcreate(b); 
		bn->batBuns->base = BUNptr(b, l-1);  
                bn->batInserted = BUNptr(b, l);  
                bn->batHole = bn->batDeleted = bn->batBuns->base; 
		bn->batBuns->maxsize = bn->batBuns->size = 
		    bn->batBuns->free = BUNptr(b,h) - bn->batBuns->base; 
@-
We have to do it: create a new BAT and put everything into it.
@c
	} else {
		BUN p = BUNptr(b,l);
		BUN q = BUNptr(b,h);

        	bn = BATnew(b->htype, b->htype?b->ttype:ATOMtype(b->ttype), h-l);
		if (bn == NULL) {
			return bn;
		}
        	for (xx=BUNsize(b); p<q; p+=xx) {
                	BUNfastins(bn, BUNhead(b,p), BUNtail(b,p));
        	}
	}
        bn->H->aggr[0] =  bn->H->aggr[1] = bn->H->aggr[2] = 0;
        bn->T->aggr[0] =  bn->T->aggr[1] = bn->T->aggr[2] = 0;
        bn->hsorted = BAThordered(b);
        bn->tsorted = BATtordered(b);
	BATkey(bn, BAThkey(b));
	BATkey(BATmirror(bn), BATtkey(b));
	if (BAThdense(b)) {
		BATseqbase(bn, b->hseqbase+low); 
	}
	if (BATtdense(b)) {
		BATseqbase(BATmirror(bn), b->tseqbase+low);
	}
        return bn;
}

@-  Value Selections
@{
The string search is optimized for the degenerated case
that th = tl, and double elimination in the string heap. 

We allow value selections on the nil atom. This is focrmally
not correct, as in MIL (nil = nil) != true.  However, we do 
need an implementation for selecting nil (in MIL, this is done 
through is the "isnil" predicate). So we implement it here.

@= valselect
        HASHloop@2(b, b->hhash, i, tl, p) {
	    if (q < r) bunfastins_nocheck(bn, q, BUNt@1(b, p), tl, bs);
	    q += bs;
        } break;
@= stringselect
	if (strElimDoubles(&b->hheap)) {
	    HASHloop_fstr(b, b->hhash, i, j, tl) {
		p = BUNptr(b, i);
		if (q < r) bunfastins_nocheck(bn, q, BUNt@1(b, p), tl, bs);
		q += bs;
	    }
	} else {
            HASHloop_str(b, b->hhash, i, tl) { 
		p = BUNptr(b, i);
		if (q < r) bunfastins_nocheck(bn, q, BUNt@1(b, p), tl, bs);
		q += bs;
	    }
	} break;
@= hashselect
	switch(ATOMstorage(b->htype)) {
	case TYPE_chr: @:valselect(@1,_chr)@
	case TYPE_sht: @:valselect(@1,_sht)@
	case TYPE_int: @:valselect(@1,_int)@
	case TYPE_flt: @:valselect(@1,_flt)@
	case TYPE_dbl: @:valselect(@1,_dbl)@
	case TYPE_lng: @:valselect(@1,_lng)@
	case TYPE_str: @:stringselect(@1)@
	default:    if (b->hvarsized) {
			@:valselect(@1,var)@
		    } else {
			@:valselect(@1,loc)@
		    }
	}
@c
BAT *BAT_hashselect(BAT *b, BAT *bn, ptr tl) {
	int ht = bn->htype, tt = bn->ttype;
	size_t size = BATcount(bn);
	hash_t i;
	size_t j;

	BATflipflop(b);
	(void) BATprepareHash(b);
	while(bn) {
	    BUN p, q = BUNfirst(bn);
	    BUN r = (BUN) ((char *) Bunbase(bn) + bn->batBuns->size);
	    int bs = BUNsize(bn);

	    if (b->tvarsized) {
	        @:hashselect(var)@
	    } else {
	        @:hashselect(loc)@
	    }
	    if (q <= r) break;
	    size = (q - BUNfirst(bn)) / bs;
	    BBPreclaim(bn); 
	    bn = BATnew(ht, tt, size);
	}
	return bn;
}


@- Range Selections
The routine @%BATselect@ locates the BAT subset whose tail component
satisfies the range condition @T$l <[=] tail <[=] h$. Either boundary
is included in the result iff the respective bit parameter "li"/"hi"
is TRUE. A nil value in either dimension defines infinity.  The value 
is set accordingly.

Range selections without lower or upper bound use the nil atom
to indicate this (this is somewhat confusing). Note, however, that
through the definition of MIL we do not want the nils to appear in
the result (as (nil {<,=,>} ANY) = bit(nil) != true).

@= indexselect
	IDXrng(m, tl, th, &x, &y);
	if (equi == 0) {
	    while(x < y && @3_EQ(nil, BUNt@2(b, *x), @1)) {
	    	x++; /* if this is a range-select, we skip nil */
	    }
	}
	if (b->hvarsized) {
	    IDXloop(m, x, y) {
	        BUNfastins(bn, BUNhvar(b, *x), BUNt@2(b, *x)); 
	    }
	} else {
	    IDXloop(m, x, y) {
	        BUNfastins(bn, BUNhloc(b, *x), BUNt@2(b, *x)); 
	    }
	} break;
@c
BAT *BAT_indexselect(BAT *b, BAT *bn, ptr tl, ptr th, bit li, bit hi, int equi) {
	BAT *m = BATmirror(b);
	BUN *x, *y;
        ptr nil = ATOMnilptr(b->ttype);
        int t = b->ttype; 
        
        FATALcheck(b->tidx_heap == NULL, "BAT_indexselect: tail-tree expected"); 
		
	switch(ATOMstorage(b->ttype)) {
	case TYPE_chr:	@:indexselect(chr,loc,simple)@ 
	case TYPE_sht:	@:indexselect(sht,loc,simple)@ 
	case TYPE_int:	@:indexselect(int,loc,simple)@
	case TYPE_flt:	@:indexselect(flt,loc,simple)@ 
	case TYPE_dbl:	@:indexselect(dbl,loc,simple)@ 
	case TYPE_lng:	@:indexselect(lng,loc,simple)@ 
	default:    if (b->tvarsized) {
	    		@:indexselect(t,var,atom)@
	    	    } else {
			@:indexselect(t,loc,atom)@
		    }
	}
	return bn;
}

BAT *BAT_select_(BAT *b, ptr tl, ptr th, bit li, bit hi, bit tail) {
	int	hval, lval, equi, t, ht, tt;
	size_t 	offset, batcnt, estimate = 0;
	ptr	nil;
	BAT	*bn; 
	BUN	 p,q;

	BATcheck(b,"BATselect: \n");
        BATcheck(tl,"BATselect: tl value required\n");
@-
Examine type, and values for lower- and higher-bound.
@c
	batcnt = BATcount(b);
	t = b->ttype; 
	nil = ATOMnilptr(t);
	lval = ATOMcmp(t, tl, nil) || (th == NULL);
	equi = ((th == NULL) || (lval && !ATOMcmp(t,tl,th)));
	if (equi) {
		if (th == NULL) hi = li;
		th = tl; hval = 1; /* equi-select */
	} else {
		hval = ATOMcmp(t, th, nil);
	}

	/* preliminarily determine result types */
	ht = BAThtype(b);
	tt = tail?BATttype(b):TYPE_void;
	if (ht == TYPE_void && tt == TYPE_void) {
	    ht = TYPE_oid; 
	}

        if ( hval && ( (ATOMcmp(t, tl,th) > 0) || (equi && !(li && hi)) ) ) {
	    /* empty range */
 	    ALGODEBUG THRprintf(GDKout, "BAT_select_(b=%s): empty range;\n",b->batId);
	    return BATnew(ht, tt, 10);
	}

@- Slice Implementations
When the result is a dense slice of the BAT, we can optimize.
A slice does not need to copy the BAT selected on, it can just
give back a 'view' on the memory of the existing BAT. See BATslice(). 
@c
	if (BATtordered(b)&1) {
	    BAT *v = tail?b:VIEWhead_(b,b->batRestricted); 
	    size_t high = batcnt;
	    size_t low = 0;

	    if (BATtdense(b)) {
	       /* Selections on voids are positional. */
		if (hval) {
		    size_t h = (*(oid*) th) + (hi?1:0);
		    if (h > b->tseqbase)
			h -= b->tseqbase;
		    else
			h = 0;
		    if (h < high) high = h;
		
		} 
		if (lval) {
		    size_t l = (*(oid*) tl) + (li?0:1);
		    if (l > b->tseqbase)
			l -= b->tseqbase;
		    else
			l = 0;
		    if (l > low) low = l;
		}
	    } else {
		/* Use probe-based binary search */
		offset = BUNindex(b,BUNfirst(b));
		if (lval) {
		    if (li) p = SORTfndfirst(b,tl);
		    else    p = SORTfndlast(b,tl);
		} else {
		   /* No lower bound, we must still exclude nils. They are in 
                    * front, so we can still slice, by starting after them.
		    */
		    p = SORTfndlast(b,nil);
		}
		low = BUNindex(b,p);
		if (low > offset)
 			low -= offset;
		else
			low = 0;
		if (hval) {
		    if (hi) q = SORTfndlast(b,th);
		    else    q = SORTfndfirst(b,th);
		    high = BUNindex(b,q);
		    if (high > offset)
		    	high -= offset;
		    else
			high = 0;
		}
	    }
	    ALGODEBUG THRprintf(GDKout, "BAT_select_(b=%s): BATslice(v=%s, low=%u, high=%u);\n",
	                                b->batId, v->batId, low, high);
	    bn = BATslice(v, low, high);
	    if (!tail) {
		BBPreclaim(v);
	    }
	    return bn;
	}
@-
Use sampling to determine a good result size, when the bat is large.
@c
	if (batcnt > 10000) {
            size_t _lo = batcnt/2, _hi = _lo + 105;
	    BAT *tmp1;
	    ALGODEBUG THRprintf(GDKout, "BAT_select_(b=%s): sampling: tmp1 = BATslice(b=%s, _lo=%u, _hi=%u);\n",
	                                b->batId, b->batId, _lo, _hi);
            tmp1 = BATslice(b, _lo, _hi); /* slice keeps all parent properties */
            if (tmp1) {
		BAT *tmp2;
	        ALGODEBUG THRprintf(GDKout, "BAT_select_(b=%s): sampling: tmp2 = BAT_select_(tmp1=%s, tl, th, tail);\n",
	                                    b->batId, tmp1->batId);
                tmp2 = BAT_select_(tmp1, tl, th, li, hi, tail);
                if (tmp2) {
		    /* reserve 105% of what has been estimated */
                    estimate = (size_t) ((((lng) BATcount(tmp2)) * (lng) batcnt)/LL_CONSTANT(100));
                    BBPreclaim(tmp2);
                }
                BBPreclaim(tmp1);
	    }
	} 
	estimate = MAX(estimate, BATguess(b));
@-
Create the result BAT and execute the select algorithm.
@c
        bn = BATnew(ht, tt, estimate);
	if (bn) {
	    int nocheck = (estimate >= batcnt);
	    if (equi && b->thash_heap) {
 	        ALGODEBUG THRprintf(GDKout, "BAT_select_(b=%s): BAT_hashselect(b=%s, bn=%s, tl); (using existing hash-table)\n",
		                            b->batId, b->batId, bn->batId);
	    	bn = BAT_hashselect(b, bn, tl);
	    } else if (b->tidx_heap) {
	    	ALGODEBUG THRprintf(GDKout, "BAT_select_(b=%s): BAT_indexselect(b=%s, bn=%s, tl, th);\n",
	    	                            b->batId, b->batId, bn->batId);
	    	bn = BAT_indexselect(b, bn, tl, th, li, hi, equi);
	    } else if (equi && estimate*100 < batcnt && batcnt*2*sizeof(int) < (GDK_mem_maxsize/4)) { 
	        /* Build a hash-table on the fly for equi-select if the selectivity is low
                 * and it is not too big */
 	        ALGODEBUG THRprintf(GDKout, "BAT_select_(b=%s): BAT_hashselect(b=%s, bn=%s, tl); (building hash-table on the fly)\n",
 	                                    b->batId, b->batId, bn->batId);
	        bn = BAT_hashselect(b, bn, tl);
	    } else {
                ALGODEBUG THRprintf(GDKout, "BAT_select_(b=%s): BAT_scanselect(b=$s, bn=$s, tl, th, equi=%d, lval=%d, hval=%d, nocheck=%d);\n",
                                            b->batId, b->batId, bn->batId, equi, lval, hval, nocheck);
		bn = BAT_scanselect(b, bn, tl, th, li, hi, equi, lval, hval, nocheck);
	    }
	}
	if (bn == NULL) {
	    return NULL; /* error occurred */
	} 
@-
Propagate alignment info. Key properties are inherited from the parent. 
Hash changes the order; IDX yields ordered tail; scan respects original order.
@c
	if (BATcount(bn)){
        	BATkey(bn, b->hkey);
        	BATkey(BATmirror(bn), b->tkey);
	} else {
		BATkey(bn,TRUE);
        	BATkey(BATmirror(bn), TRUE);
	}
        if (equi && tail) {
            BATsetaggr(bn, GDK_AGGR_CARD, BATcount(bn) > 0);
            if (b->ttype == TYPE_bit) {
                BATsetaggr(bn, GDK_AGGR_SIZE, (*(bit*) tl == TRUE)?BATcount(bn):0);
            }
        }
	if (equi && b->thash_heap) {
	    bn->hsorted = bn->tsorted = FALSE;
        } else if (b->tidx_heap) {
            bn->hsorted = FALSE;
            bn->tsorted = GDK_SORTED;
	} else {
            if (BATcount(bn)==BATcount(b)) ALIGNset(bn, b);
            bn->hsorted = BAThordered(b);
            bn->tsorted = BATtordered(b);
	}
	ALGODEBUG THRprintf(GDKout, "BAT_select_(b=%s): %s: hkey=%d, tkey=%d, hsorted=%d, tsorted=%d.\n",
	                            b->batId, bn->batId, bn->hkey, bn->tkey, bn->hsorted, bn->tsorted);
	ESTIDEBUG THRprintf(GDKout, "BAT_select_(b=%s): resultsize: estimated %d, got %d.\n",
	                            b->batId,estimate,BATcount(bn));
	return bn; 
}

BAT* BAT_select(BAT *b, ptr h, ptr t, bit tail) {
	return BAT_select_(b, h, t, TRUE, TRUE, tail);
}

BAT* BATselect_(BAT *b, ptr h, ptr t, bit li, bit hi) {
	return BAT_select_(b, h, t, li, hi, TRUE);
}

BAT* BATuselect_(BAT *b, ptr h, ptr t, bit li, bit hi) {
	return BAT_select_(b, h, t, li, hi, FALSE);
}

BAT* BATselect(BAT *b, ptr h, ptr t) {
	return BAT_select_(b, h, t, TRUE, TRUE, TRUE);
}

BAT* BATuselect(BAT *b, ptr h, ptr t) {
	return BAT_select_(b, h, t, TRUE, TRUE, FALSE);
}

@- Random Selections 
@c
BAT* BATsample(BAT *b, size_t size) {
	size_t cnt, i, r = 0, n, j;
	size_t *choice, *dst;
	BAT *bn; 

	BATcheck(b, "BATsample: source BAT");

	cnt = BATcount(b);
	n = MIN(size, BATcount(b));

	bn = BATnew(BAThtype(b), BATttype(b), n);
	BATcheck(bn, "BATsample: dest BAT");

	if (n == 0)
		return bn;
  	dst = choice = (size_t*) GDKmalloc(n*sizeof(size_t));
 
	if (n*2 < BATcount(b)) {  /* nondense sample */
            char *vec = (char *) GDKmalloc(1 + (cnt/8));
            memset(vec, 0, 1 + (cnt/8));
            for(j=0; j<n; j++) {
                r += rand();
		i = r % cnt;
		for (;;) {
			int mask = 1 << (i & 7);
			if (vec[i>>3] & mask) {
				if (++i == cnt) i = 0;
			} else {
				vec[i>>3] |= mask; break;
			}
		}
		*dst++ = i;
            }
            GDKfree(vec);
	} else if (cnt < 65536) {
            unsigned short *vec = 
		(unsigned short *) GDKmalloc(cnt*sizeof(unsigned short));
            for(i=0; i<cnt; i++) vec[i] = (unsigned short) i;
            for(j=0; j<n; j++) {
                r += rand();
		i = r % cnt;
		*dst++ = vec[i];
                vec[i] = vec[--cnt];
            }
            GDKfree(vec);
	} else {
            size_t *vec = (size_t *) GDKmalloc(cnt*sizeof(size_t));
            for(i=0; i<cnt; i++) vec[i] = i;
            for(j=0; j<n; j++) {
                r += rand();
		i = r % cnt;
		*dst++ = vec[i];
                vec[i] = vec[--cnt];
            }
            GDKfree(vec);
	}

	/* merge all positions into a sorted list */
	qsort((void*) choice, n, sizeof(size_t),
#if SIZEOF_SIZE_T == SIZEOF_INT
		    (int (*)(const void*, const void*)) intCmp
#else
		    (int (*)(const void*, const void*)) lngCmp
#endif
		    );

	/* insert the sorted sample */
	cnt = BUNindex(b, BUNfirst(b));
	for(j=0; j<n ; j++) {
                BUN p = BUNptr(b, cnt+choice[j]);       
                BUNfastins(bn, BUNhead(b,p), BUNtail(b,p));
	}
	GDKfree(choice); /* clean up choice array of BUN positions */

        /* set sorted flags by hand, because we used BUNfastins() */
        bn->hsorted = BAThordered(b);
	bn->tsorted = BATtordered(b);
	BATkey(bn, b->hkey);
	BATkey(BATmirror(bn), b->tkey);

	return bn;
}

@- Horizontal Fragmentation 
@c
BAT *BATfragment(BAT *b, ptr hl, ptr hh, ptr tl, ptr th) {
	BATcheck(b, "BATfragment:BAT required\n"); 
	if ((hl == NULL) && (hh == NULL)) {
		return BATselect(b, tl, th); 
	} 
        if ((BAThordered(b)&1) == FALSE &&
            ((BATtordered(b)&1) || (b->hidx_heap == NULL && b->tidx_heap)))
        {
                return BATmirror(BATrestrict(BATmirror(b), tl, th, hl, hh));
        }
	return BATrestrict(b, hl, hh, tl, th); 
}
@
@}
@- 
The baseline algorithm for fragment location is a two-phase process. 
First we search on the 1st
dimension and collect the qualifying BUNs in a marking on the
stack. In the second phase, the tail is analysed for all items
already marked and qualifying associations are copied into the result.
An index is exploited when possible.


@{
@= restrict1
	if (BAThordered(b)&1) {
		int offset;
		BUN p,q;
		BATflipflop(b);
		SORTloop(b, p, q, hl, hh, offset) {
			*m++ = p; 
		}
		BATflipflop(b);
		break;
	} 
{	int lval = !@1_EQ(ATOMnilptr(t),hl,@2);
	int hval = !@1_EQ(ATOMnilptr(t),hh,@2);
	if (hval && lval && @1_GT(hl,hh,@2)) {
		GDKerror("BATrestrict: illegal head range.\n");
		break;
	}
	if (b->hidx_heap && lval && hval) {
		BUN	*x, *y;

		IDXrng(b, hl, hh, &x, &y); 
		IDXloop(b, x, y) {
			*m++ = p; 
		}
		break;
	} 
{	int xx;
	BATloopFast(b, p, l, xx) {
		if ((!lval || @1_LE(hl, BUNh@3(b, p),@2)) &&
		    (!hval || @1_LE(BUNh@3(b, p), hh,@2)))
	       	{
			*m++ = p; 
		}
	}
}}
break;
@
@= restrict2
{	tl = @1_EQ(ATOMnilptr(t),tl,@2)?0:tl;
	th = @1_EQ(ATOMnilptr(t),th,@2)?0:th;
	if (th && tl && @1_GT(tl,th,@2)) {
		GDKerror("BATrestrict: illegal tail range.\n");
		break;
	}
	for (; i < m; i++) {
		ptr v = BUNt@4(b, *i); 
		if ((!tl || @1_LE(tl, v, @2)) && (!th || @1_LE(v, th, @2)))
		{
			BUNfastins(bn, BUNh@3(b, *i), v); 
		}
	}
}
break;
@c
BAT *BATrestrict(BAT *b, ptr hl, ptr hh, ptr tl, ptr th) {
	BAT	*bn; 
	BUN	p = NULL, l; 
	BUN	*mark, *m, *i; 
	size_t	s;
	int	t;

	BATcheck(hl,"BATrestrict:hl is null");
	BATcheck(hh,"BATrestrict:hh is null");
	BATcheck(tl,"BATrestrict:tl is null");
	BATcheck(th,"BATrestrict:th is null");
	bn = BATnew(BAThtype(b), BATttype(b), BATguess(b));
  	ESTIDEBUG THRprintf(GDKout, "BATrestrict: estimated resultsize: %d\n",BATguess(b));
	if (bn == NULL) {
		return NULL; 
	}
	BATkey(bn, b->hkey);
	BATkey(BATmirror(bn), b->tkey);
	bn->hsorted = BAThordered(b);
	bn->tsorted = BATtordered(b);

	s = BATcount(b); 
	if (s == 0) {
  		ESTIDEBUG THRprintf(GDKout, "BATrestrict: actual resultsize: %d\n",BATcount(bn));
		return bn; 
	}
	mark = (BUN*) GDKmalloc((unsigned) s*sizeof(BUN)); 
	m = mark;
	i = mark; 
	switch(ATOMstorage(t = b->htype)) {
	case TYPE_chr: @:restrict1(simple,chr,loc)@
	case TYPE_sht: @:restrict1(simple,sht,loc)@
	case TYPE_int: @:restrict1(simple,int,loc)@
	case TYPE_flt: @:restrict1(simple,flt,loc)@ 
	case TYPE_dbl: @:restrict1(simple,dbl,loc)@ 
	case TYPE_lng: @:restrict1(simple,lng,loc)@ 
	default:
		if (b->hvarsized) {
			@:restrict1(atom,t,var)@
		} else {
			@:restrict1(atom,t,loc)@
		}	
	}

	/* second phase */
	if (b->hvarsized) {
		switch(ATOMstorage(t = b->ttype)) {
		case TYPE_chr: @:restrict2(simple,chr,var,loc)@
		case TYPE_sht: @:restrict2(simple,sht,var,loc)@
		case TYPE_int: @:restrict2(simple,int,var,loc)@
		case TYPE_flt: @:restrict2(simple,flt,var,loc)@ 
		case TYPE_dbl: @:restrict2(simple,dbl,var,loc)@ 
		case TYPE_lng: @:restrict2(simple,lng,var,loc)@ 
		default:
		    if (b->tvarsized) {
			@:restrict2(atom,t,var,var)@
		    } else {
			@:restrict2(atom,t,var,loc)@
		    }
       		}
	} else {
		switch(ATOMstorage(t = b->ttype)) {
		case TYPE_chr: @:restrict2(simple,chr,loc,loc)@
		case TYPE_sht: @:restrict2(simple,sht,loc,loc)@
		case TYPE_int: @:restrict2(simple,int,loc,loc)@
		case TYPE_flt: @:restrict2(simple,flt,loc,loc)@ 
		case TYPE_dbl: 
		case TYPE_lng: @:restrict2(simple,lng,loc,loc)@ 
		default:
		    if (b->tvarsized) {
			@:restrict2(atom,t,loc,var)@
		    } else {
			@:restrict2(atom,t,loc,loc)@
		    }
       		}
	}
	GDKfree(mark); 

	/* propagate alignment info */
	if (BATcount(bn)==BATcount(b)) ALIGNset(bn,b);

  	ESTIDEBUG THRprintf(GDKout, "BATrestrict: actual resultsize: %d\n",BATcount(bn));
	return bn; 
}


@+ BAT Sorting
@{
@= idxloop
IDXloop(b, p, q) {
        if (*p) BUNfastins(c, BUNh@1(b, (*p)), BUNt@2(b, (*p)));
}
@
@- sorting 
@%BATsort@ returns a sorted copy. @%BATorder@ sorts the BAT itself. 
@c
@:sort(1)@
@:sort(GDK_SORTED,_REV,_rev)@

@= sort
int BATordered@3(BAT *b) {
	BATcheck(b, "BATordered@3: BAT"); 
	PROPDEBUG BATpropcheck(b, BATPROPS_QUICK);
	return (BAThordered(b)&(@1@2));
}

BAT *BATsort@3(BAT *b) {
	int tt = b->ttype;

	BATcheck(b, "BATsort@3: BAT"); 
	if (BATordered@3(b)) {
		return BATrcopy(b);
        } 
	/* a void tail column 0,1,2,3,... must be materialized to oid before sorting */
	if (tt == TYPE_void && b->tseqbase != oid_nil) {
		tt = TYPE_oid;
	}
	return BATorder@3(batcopy(b, b->htype, tt, TRUE));
}

BAT *BATorder@3(BAT *b) {
	BATcheck(b, "BATorder@3: BAT"); 
        if (BATordered@3(b)) {
		return b;
	}
	b->tseqbase = oid_nil; /* ignore the void case here */
	GDKqsort@3(BUNfirst(b), b->hheap.base, BATcount(b), BUNsize(b), b->htype, b->hloc); 
        ACCremoveall(b);
        ALIGNdel(b, "BATorder@3");
	b->hsorted = GDK_SORTED@2;
	b->tsorted = FALSE;
	b->hdense = FALSE;
	b->batDirtydesc = b->batDirtybuns = TRUE;

	return b;
}

@- reverse in place
@%BATrevert@ rearranges a BAT in reverse order on head.
@c
BAT* BATrevert(BAT *b) {
        int xx;
        char *buf;
        BUN p,q;
     
        BATcheck(b, "BATrevorder");
	if ((b->htype == TYPE_void && b->hseqbase != oid_nil) ||
            (b->ttype == TYPE_void && b->tseqbase != oid_nil)) 
        {
	  GDKwarning( "Cannot reverse order on void columns.\n" );
	  return b;
	}
        ALIGNdel(b, "BATrevorder");
        xx = BUNsize(b);
        buf = (char*) GDKmalloc(xx);
        for(p=BUNlast(b)-xx, q=BUNfirst(b); p > q; p -=xx, q+=xx) {
                memcpy(buf, p, xx);
                memcpy(p, q, xx);
                memcpy(q, buf, xx);
        }
        ACCremoveall(b);
        b->hsorted = b->tsorted = FALSE;
        GDKfree(buf);
	return b;
}

@
@}

@+ BAT partitioning
For distributed processing we support hash and range 
partitioning operators: @%BATsplithash@ and @%BATsplitrange@.
@{
@-
The @%part_bat@ function creates a partition BAT. 
@c
BAT *part_bat(BAT *b, int ht, int tt, size_t expected_size, int respect_order){
        BAT *bn = BATnew(ht, tt, (size_t) ((double)expected_size*BATMARGIN));
	if (bn) {
	    BATkey(bn, b->hkey);
	    BATkey(BATmirror(bn), b->tkey);
            bn->hsorted = (respect_order && (BAThordered(b)&1));
            bn->tsorted = (respect_order && (BATtordered(b)&1));
	}
        return bn;
}
@- hash partitioning
@c
#define BUNhash(bx,hx,tx)\
	/* assert(n <= 0x40000000); */\
	i = (int)(HASHprobe(&h,tx)%n); \
	if ((r = BUNfnd(bx, &i)) != NULL){\
		bat bid = *(bat*)BUNtloc(bx,r); \
		BUNfastins(BBPdescriptor(bid), hx, tx);\
	}

BAT *BAThashsplit(BAT *b, size_t n, int unary) {
	BAT	*metabat, *bn, *bf; 
	BUN	r;
	Hash	h;
	size_t	cnt;
	int	i=0;

	/* assert(n <= 0x40000000); */
	BATcheck(b, "BAThashsplit");
	metabat = BATnew(TYPE_int, TYPE_bat, n);
	bn = unary?VIEWhead_(b,b->batRestricted):b;
	if (n <= 1) {
	    BUNins(metabat, &i, &bn->batCacheid);
	} else {
	    BUN p, q;
	    for (i=2; i<n; i*=2);
            h.mask = i-1;
            h.type = BATttype(b);
	    cnt = (size_t) (BATMARGIN*(double)BATbuncount(b)/(double)n);
	    for (i = 0; i < n; i++) {
		bf = part_bat(bn, BAThtype(bn), BATttype(bn), cnt, TRUE);
		if (bf == NULL) {
			BBPreclaim(metabat);
			return NULL;
		}
		BUNins(metabat, &i, &bf->batCacheid); 
	    }
	    @:updateloop(metabat,b,BUNhash)@
	    BATloop(metabat, p, q){
		bat bf = *(bat*)BUNtail(metabat,p);
		BBPunfix(bf);
	    }
	}
	return metabat; 
}

@- range partitioning
Range parititioning ensures that identical values appear in one
partition only. The routine also tries to deliver partitions of
uniform size.
@c
BAT *BATrangesplit(BAT *b, size_t n, int unary) {
	BAT	*metabat, *slice, *histo, *bf = NULL, *bn, *m;
	int 	target, tpe, *sizes;
	int	xx, zz=0;
	size_t	yy=0;
	ptr 	*seps, nilval;
	BUN	r, s;
	dbl	scale;
	size_t 	thorough = (n<=1 || BATtvoid(b) || (BATtordered(b)&1))?1:10;

	BATcheck(b, "BATrangesplit");

	/* assert(BATcount(b)/n <= 0x7fffffff); */
	bn = unary?VIEWhead_(b,b->batRestricted):b;
	m = BATmirror(b);
	metabat = BATnew(BATttype(b), TYPE_bat, n);
	nilval = ATOMnilptr(BATttype(b));

@- 
We use sampling to determine bucket sizes. 
Uniform bucket sizes are the ideal to be achieved. 
If necessary though, we deliver less than n buckets.
@c
        slice  = BATsample(b, MIN(MAX(30*n*thorough,100*thorough),BATcount(b)));
        histo  = BAThistogram(slice);
	target = (int) (BATcount(b)/n);	/* see assert above */
	scale  = ((dbl) BATcount(b))/((dbl) BATcount(slice));
        BBPreclaim(slice);
        sizes  = (int*) GDKmalloc(2*n*sizeof(int));
        seps   = (ptr*) GDKmalloc(2*n*sizeof(ptr));
@-
Use the histogram to determine good split boundaries on b.
@c
        BATorder(histo);
        BATloopFast(histo, r, s, xx) {
		int cnt = *(int*) BUNtloc(histo,r);
		int add = (int) (scale * cnt);
		if (zz + add > target) {
			if ((zz + add - target) < (target-zz)) {
				sizes[yy] = zz+add;
                    		seps[yy] = ATOMdup(histo->htype,
 						   BUNhead(histo,r));
				add = 0;
			} else {
				sizes[yy] = zz;
                    		seps[yy] = ATOMdup(histo->htype,
 						   BUNhead(histo,(r-xx)));
			}
			zz = 0; yy++;
		}
		zz += add;
	}
	if ((sizes[yy-1] + zz - target) > (target - zz)) {
		sizes[yy] = zz;
	} else {
		yy--; /* join with the last */
	}
	seps[yy] = nilval;
        BBPreclaim(histo);
	if (n != yy +1) {
		GDKwarning("rangesplit: delivering %lu instead of %lu fragments\n", yy+1, n); 
		n = yy + 1;
	}

@- 
CASE 1: just one bucket.
This is done without copying b.
@c
	if (n <= 1) {
	    BUNins(metabat, nilval, &bn->batCacheid);

@- 
CASE 2: sorted on fragmentation column.
We can again avoid copying, by giving slices (views) on the source BAT.
Virtual oids (void) is a special subcase with positional lookup instead
of binary search.
@c
	} else if (BATtvoid(b) || (BATtordered(b)&1)) {
	    size_t l, h = 0, o = BUNindex(b,BUNfirst(b));

	    for(yy=0; yy<n; yy++) {
		l = h;
		if (yy == n-1) {
			r = BUNlast(m);
			h = BUNindex(b,r) - o;
		} else if (BATtdense(b)) {
			h = ((*(oid*) seps[yy]) - b->tseqbase) +1;
		} else {
			r = SORTfndlast(m, seps[yy]);
			h = BUNindex(b,r) - o;
		}
		bf = BATslice(bn, l, h); /* produces view bat */
		BUNins(metabat, seps[yy], &bf->batCacheid); 
	    }

@- 
CASE 3: binary index on fragmentation column.
If a binary index exist on the split column, it is quite easy to split and 
achieve totally sorted chunks at the same time. 
@c
	} else if (b->tidx_heap) {
		BUN *q, *p = IDXfirst(m);
		
		for(yy=0; yy<n; yy++) {
			if (yy == n-1) {
				q = IDXlast(m);
			} else {
				q = IDXfndlast(m, seps[yy]);
			}
	    		bf = part_bat(bn, BAThtype(bn), BATttype(bn), (size_t)(q-p),FALSE);
			if (bf == NULL) {
				BBPreclaim(metabat);
				return NULL;
			}
		        if (!unary) bf->tsorted = GDK_SORTED; 
	    		BUNins(metabat, seps[yy], &bf->batCacheid);
			IDXloop(m, p, q) {
				BUNfastins(bf, BUNhead(b, *p), BUNtail(b, *p));
			}
			BBPunfix(bf->batCacheid);
			p = q + 1;
		}

@- 
CASE 4: full scan.
If it ain't sorted then we gotta scan the whole thing and split.
This is heavy stuff so we optimize execution according to datatype.
@
DELETED: simple walk-through list approach
		for(yy=0; yy<n-1; yy++) {
			if (@1_LE(val, seps[yy], @3)) break;
		}
		BUNfastins(bats[yy], BUNhead(b,r), val);
@
We now use binary search for getting to the right bucket, so
that this routine also works efficiently on many buckets. 

@= rangesplit
BATloopFast(b, r, s, xx) {
	ptr val = BUNt@2(b,r);
	size_t lo = 0; 
	size_t hi = n-1;
	for (;;) {
		yy = (lo+hi)/2;
		if (yy < n-1 && @1_GT(val, seps[yy], @3)) {
			lo = yy + 1;
			if (lo >= hi) { yy = hi; break; }
		} else if (yy > 0 && @1_LE(val, seps[yy-1], @3)) {
			hi = yy - 1;
			if (hi <= lo) { yy = lo; break; }
		} else {
			break;
		}
	} 
	BUNfastins(bats[yy], BUNhead(b,r), val);
} break;
@c
	} else {
            BAT **bats = (BAT**) GDKmalloc(n*sizeof(BAT*));
	    for(yy=0; yy<n; yy++) {
		bats[yy] = part_bat(bn,BAThtype(bn),bn->ttype,sizes[yy],TRUE);
		if (bats[yy] == NULL) {
			BBPreclaim(metabat);
			return NULL;
		}
		BUNins(metabat, seps[yy], &bats[yy]->batCacheid);
	    }
            switch(tpe = ATOMstorage(b->ttype)) {
            case TYPE_chr:  @:rangesplit(simple,loc,chr)@
            case TYPE_sht:  @:rangesplit(simple,loc,sht)@
            case TYPE_int:  @:rangesplit(simple,loc,int)@
            case TYPE_flt:  @:rangesplit(simple,loc,flt)@
            case TYPE_dbl:  @:rangesplit(simple,loc,dbl)@
            case TYPE_lng:  @:rangesplit(simple,loc,lng)@
            default:if (b->tvarsized) {
                            @:rangesplit(atom,var,tpe)@
                    } else {
                            @:rangesplit(atom,loc,tpe)@
                    }
        
	    }
	    for(yy=0; yy<n; yy++)
		BBPunfix(bats[yy]->batCacheid);
            GDKfree(bats);
	}
	for(yy=0; yy<(n-1); yy++)
		GDKfree(seps[yy]);
        GDKfree(seps);
        GDKfree(sizes);

	return metabat; 
}
@
@}
