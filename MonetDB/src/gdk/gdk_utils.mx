@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@' 
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@' 
@' The Original Code is the Monet Database System.
@' 
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2004 CWI.
@' All Rights Reserved.
@' 
@' Contributor(s):
@' 		Martin Kersten <Martin.Kersten@cwi.nl>
@' 		Peter Boncz <Peter.Boncz@cwi.nl>
@' 		Niels Nes <Niels.Nes@cwi.nl>
@' 		Stefan Manegold  <Stefan.Manegold@cwi.nl>

@f gdk_utils
@a M. L. Kersten, P. Boncz

@* Utilities
The utility section contains functions to initialize the Monet database
system, memory allocation details, and a basic system logging scheme.

@h
#ifndef _GDK_UTILS_H_
#define _GDK_UTILS_H_

gdk_export void GDKlog       (const char *format, ...);
gdk_export void GDKlockHome  (void);
gdk_export void GDKunlockHome(void);
gdk_export int  GDKgetHome   (void);

gdk_export lng  GDKusec      (void);
gdk_export int  GDKms        (void);
gdk_export int  GDKstamp     (void);
gdk_export void GDKsetstamp  (int newstamp);

gdk_export BAT *GDKenv;

gdk_export RETSIGTYPE BATSIGcrash(int);

@c
#ifndef GDK_NOLINK
#include "gdk.h"

#else /* GDK_NOLINK */

#undef GDKmalloc
#undef GDKrealloc
#undef GDKfree
#undef GDKcalloc

#define GDKmalloc(size)	malloc(size)
#define GDKrealloc(buf,size)	realloc(buf,size)
#define GDKfree(buf)	free(buf)
#define GDKcalloc(nmemb,size) calloc(nmemb,size);
#endif

char	GDKdbfarmStr[PATHLENGTH] = { "dbfarm" };
char	GDKdbnameStr[PATHLENGTH] = { 0 };

BAT 	*GDKenv = NULL;

#ifdef HAVE_FCNTL_H
#include <fcntl.h>
#endif

#ifdef HAVE_FTIME
#include <sys/timeb.h>
#endif

#if TIME_WITH_SYS_TIME
# include <sys/time.h>
# include <time.h>
#else
# if HAVE_SYS_TIME_H
#  include <sys/time.h>
# else
#  include <time.h>
# endif
#endif

#ifdef HAVE_PWD_H
# include <pwd.h>
#endif

@- Monet configuration file
Parse a possible .monet.conf file lying around in the current directory,
the home directory of the user, or passed around as the preferred one
to extract pre-settings of system variables.
Un-recognized parameters are simply skipped, because they  may be
picked up by other components of the system.
The consequence is that making a typing error in the configuration file
may be unnoticed for a long time.
Syntax errors are immediately flagged, though.

Since the GDK kernel moves into the database directory, we need
to keep the absolute path to the .monet.conf file for top-levels
to access its information.
@c

void GDKusage(){
	fprintf(stderr,"usage: <program> [--dbname=<db_name>] [--config=<file>]\n");
	fprintf(stderr,"<program>\tprogram using the GDK library\n");
	fprintf(stderr,"<db-name>\tdatabase to open\n");
	fprintf(stderr,"<file>\t\tsystem variable settings\n");
	fprintf(stderr,"\t\tdefault: .monet.conf in current/home directory\n");
	fprintf(stderr,"Other arguments are dealt with in the application startup routine\n");
}

static int GDKenvironment(str dbname, str dbfarm)
{
	if (dbname == 0) {
	    	fprintf(stderr, "GDKenvironment: database name missing.\n");
		return 0;
	}
	if (dbfarm == 0) {
	    	fprintf(stderr, "GDKenvironment: dbfarm missing.\n" ); 
		return 0;
	}

	if (!MT_path_absolute(dbfarm)){
	    	fprintf(stderr, 
			"GDKenvironment: wrong directory %s.\n", dbfarm ); 
		return 0;
	}

	strncpy(GDKdbnameStr, dbname, PATHLENGTH);
	strncpy(GDKdbfarmStr, dbfarm, PATHLENGTH);
	return 1;
}

@h
gdk_export char *GDKgetenv(const char *name);
@c
char *GDKgetenv(const char *name){
	BUN b = BUNfnd(GDKenv, (ptr) name);

	if (b) return BUNtail(GDKenv,b);
	return NULL;
}

@h
gdk_export int GDKgetenv_isyes(const char *name);
@c
int GDKgetenv_isyes(const char *name){
	char *val = GDKgetenv(name);

	if (val && strcasecmp(val,"yes") == 0){
		return 1;
	}
	return 0;
}

@h
gdk_export void GDKsetenv(str name, str value);
@c
void GDKsetenv(str name, str value){
	BUNins(GDKenv,name,value);
        BATfakeCommit(GDKenv);
}


@+ System logging
Per database a log file can be maintained for collection
of system management information. Its contents is driven
by the upper layers, which encode information such as
who logged on and how long the session went on.
The lower layers merely store error information on the file.
It should not be used for crash recovery, because this should be
dealt with on a per client basis.

@-
A system log can be maintained in the database to keep track
of session and crash information. It should be regulary be
refreshed to avoid disk overflow.
@c
#define GDKLOCK	".gdk_lock"

static FILE* GDKlockFile = 0; 

#define GDKLOGOFF	"LOGOFF"
#define GDKFOUNDDEAD	"FOUND	DEAD"
#define GDKLOGON	"LOGON"
#define GDKCRASH	"CRASH"

@-
Single-lined comments can now be logged safely, together with process, thread
and user ID, and the current time.
@c
/* VARARGS */
void GDKlog(const char *format, ...) {
	va_list	ap; 
	char	*p= 0, buf[1024];
	int	mustopen = GDKgetHome();
	time_t	tm = time(0);

	if (MT_system_lock == NULL) return;

	va_start (ap,format); 
	vsprintf(buf, format, ap); 
	va_end (ap); 

	/* remove forbidden characters from message */
	for(p=buf; (p=strchr(p,'\n')) != NULL; *p = ' ');
	for(p=buf; (p=strchr(p,'\@')) != NULL; *p = ' ');

	fseek(GDKlockFile, 0, SEEK_END);
#ifndef HAVE_GETUID
#define getuid() 0
#endif
	fprintf(GDKlockFile, "%s \@ USR=%d PID=%d THR=" SZFMT " TIME=%s", buf, 
		(int) getuid(), (int) getpid(), (size_t) MT_getpid(), ctime(&tm));
	fflush(GDKlockFile);

	if (mustopen) GDKunlockHome();
}

@+ Interrupt handling
The current version simply catches signals and prints a warning.
It should be extended to cope with the specifics of the interrupt
received.
@c
#include <signal.h>
RETSIGTYPE BATSIGignore(int nr) {
	GDKsyserror("! ERROR signal %d caught by thread %lx\n", 
		nr, (size_t) MT_getpid()); 
}

RETSIGTYPE BATSIGabort(int nr) {
	GDKfatal("signal %d caught by thread %lx\n", nr, (size_t) MT_getpid()); 
}

#ifdef SIGCHLD
RETSIGTYPE BATSIGchild(int nr) {
	int	status; 
	(void) nr;

	while (waitpid(-1, &status, WNOHANG) > 0)
		;
	PARDEBUG THRprintf(GDKerr, "CHILD EXITED \n"); 
	(void) signal(SIGPIPE, BATSIGchild); 
}
#endif


RETSIGTYPE BATSIGcrash(int nr) {
	static int crash = 0;
	(void) nr;
	if (!crash++) {
		GDKlog(GDKCRASH);
		MT_global_exit(1);
	}
}

int BATSIGinit(void) {
	(void) signal(SIGINT,  BATSIGabort); 
/*
	(void) signal(SIGBUS,  BATSIGcrash); 
	(void) signal(SIGSEGV, BATSIGcrash); 
*/
#ifdef SIGCHLD
	(void) signal(SIGCHLD, BATSIGchild); 
#endif
#ifdef SIGPIPE
	(void) signal(SIGPIPE, SIG_IGN);
#endif
#ifdef SIGHUP
	(void) signal(SIGHUP,  MT_exit_thread);
#endif
	return 0;
}

@+ Memory management
Memory management in GDK mostly relies on the facilities offered by the 
underlying OS.  The below routines monitor the available memory resources
which consist of physical swapspace and logical vm space.
@T
There are three kinds of memory, that affect these two resources in different ways: 
\begin{description}

\item[memory mapping] which ask for a logical region of virtual memory space.
In principal, no physical memory is needed to keep the system afloat here,
as the memory mapped file is swapped onto a disk object that already exists.

Actually, there are two kings of memory mapping used in GDK, namely 
read-only direct mapped and writeable copy-on write. For the dirty
pages, the latter actually also consumes physical memory resources, 
but that is ignored here for simplicity.

\item[anonymous virtual memory]
This is virtual memory that is mapped on the swapfile. Hence, this consumes
both logical VM space resources and physical memory space.

\item[malloced memory] 
comes from the heap and directly consumes physical memory resources.
\end{description}

We check the resource consumption with preset target values, and if these 
are exceeded, the routine BBPtrim is called that will unload the
least recently used BATs in order to decrease memory usage.

The malloc routine checks the memory consumption every 1000 calls,
or for calls larger that 50000 bytes. Consequently, at least every
50MB increase, alloc memory is checked. The VM calls always check
the memory consumption.
@h
/* default setting to administer everything */
#define GDK_MEM_NULLALLOWED

#if (defined(WIN32))
#define GDK_MEM_BIGSIZE LL_CONSTANT(32768)   /* very fragile malloc */
#elif (defined(__sgi) || defined(_AIX))
#define GDK_MEM_BIGSIZE LL_CONSTANT(131072)  /* offload malloc fragmentation pressure */
#else
#define GDK_MEM_BIGSIZE LL_CONSTANT(33554432)/* robust malloc: use up till 32MB */
#endif

#if SIZEOF_VOID_P==8
#define GDK_VM_MAXSIZE	LL_CONSTANT(137438953472) /* :-) a 64-bit OS: 128 GB */
#elif defined(WIN32) 
#define GDK_VM_MAXSIZE	LL_CONSTANT(536870912) /* :-( New Technology DOS extender: 512MB */
#else
#define GDK_VM_MAXSIZE	LL_CONSTANT(1610612736) /* :-| a 32-bit OS: 1.5GB */
#endif

#define SEG_SIZE(x,y)   ((x)+(((x)&((1<<(y))-1))?(1<<(y))-((x)&((1<<(y))-1)):0))
#define MAX_BIT         ((int) (sizeof(ssize_t)<<3))
@c
volatile size_t	GDK_mem_cursize = 0;
	 size_t	GDK_mem_maxsize = 0;
	 size_t	GDK_mem_bigsize = GDK_MEM_BIGSIZE;
volatile size_t	GDK_vm_cursize = 0;
	 size_t	GDK_vm_minsize = 131072;
	 size_t	GDK_vm_maxsize = GDK_VM_MAXSIZE;
#ifdef GDK_VM_KEEPHISTO
volatile size_t GDK_vm_nallocs[MAX_BIT] = { 0 };
#endif
#ifdef GDK_MEM_KEEPHISTO
volatile size_t	GDK_nmallocs[MAX_BIT] = { 0 };
#endif

size_t GDKvm_heapsize(void) {
#ifdef _CYGNUS_H_
	return ((size_t) (96<<20));
#else
	/* on Linux, malloc apparently steals space from mmap(anon) */
	size_t heapsize = GDKmem_heapsize();
	size_t heapinuse = GDKmem_heapinuse();
	return MAX(heapsize, heapinuse);
#endif
}

size_t GDKmem_heapsize(void) {
	size_t heapsize = (MT_heapcur() - MT_heapbase);
	return (size_t) SEG_SIZE(heapsize,MT_VMUNITLOG);
}

#ifdef GDK_MEM_SIMPLE
size_t GDKmem_heapinuse(void) {
	/* we do not keep statistics ourselves; so we ask mallinfo */
	struct mallinfo m = MT_mallinfo();
        return (size_t) (m.usmblks + m.uordblks);
}
#else 
size_t	GDK_heap_inuse = 0;

size_t GDKmem_heapinuse(void) {
	return GDK_heap_inuse;
}
#endif

static int GDK_vm_allocs = 0;
static int GDK_mem_allocs = 0;

/* histogram update macro */
#define GDKmallidx(idx,size)\
{ int _mask;\
  if (size < 128) {\
    _mask = (1<<6);\
    idx = 7;\
  } else {\
    _mask = (1<<(MAX_BIT-1));\
    idx = MAX_BIT;\
  }\
  while(idx-- > 4) {\
        if (_mask&size) break;\
        _mask >>=1;\
  }\
}

@+ NIELS testing unload all
#define CHKMEM(meminc, vminc) {\
	int memchk = (meminc>0 && (++GDK_mem_allocs>=0 || meminc>LL_CONSTANT(50000)));\
	int vmchk = (vminc>0 && (++GDK_vm_allocs>=0 || vminc>LL_CONSTANT(5000000)));\
	if (memchk || vmchk) GDKmemchk(memchk, vmchk);\
}
@c
/* at least each 50M of memory increase, BBPtrim is run */
#define CHKMEM(meminc, vminc) {\
	int memchk = (meminc>0 && (++GDK_mem_allocs>=1000 || meminc>LL_CONSTANT(50000)));\
	int vmchk = (vminc>0 && (++GDK_vm_allocs>=10 || vminc>LL_CONSTANT(5000000)));\
	if (memchk || vmchk) GDKmemchk(memchk, vmchk);\
}
	
void GDKmemchk(int memchk, int vmchk) {
	size_t memtarget = GDKmem_inuse();
	size_t vmtarget = GDKvm_cursize();
	MEMDEBUG {
	  /* Protect from being called recursivly because THRprintf
	     allocates memory */
	  static int printing[THREADS];
	  int tid = THRgettid();
	  if (!printing[tid - 1]) {
		printing[tid - 1] = TRUE;
		THRprintf(GDKerr, "GDKmemchk (memcur=" SZFMT ",memmax=" SZFMT ") (vmcur=" SZFMT ",vmmax=" SZFMT ")\n",
			memtarget, GDK_mem_maxsize, GDK_vm_cursize, GDK_vm_maxsize);
		printing[tid - 1] = FALSE;
	  }
	}
	memtarget = (memchk && memtarget > GDK_mem_maxsize) ? memtarget - GDK_mem_maxsize : 0;
	vmtarget = (vmchk && vmtarget > GDK_vm_maxsize) ? vmtarget - GDK_vm_maxsize : 0;
	if (memtarget > 0 || vmtarget > 0 || BBP_desc_count[0] > (BBP_desc_max + (BBP_desc_max>>3))) {
		BBPtrim(memtarget, vmtarget);
		GDK_mem_allocs = GDK_vm_allocs = 0;
	} else {
		if (memchk) GDK_mem_allocs = 0;
		if (vmchk) GDK_vm_allocs = 0;
	}
}

void GDKmeminc(size_t memdelta, size_t vmdelta) {
	size_t segsize = (size_t) SEG_SIZE(vmdelta,MT_VMUNITLOG);

	GDK_mem_cursize += memdelta;
#ifdef GDK_VM_KEEPHISTO
{	int idx;
        GDKmallidx(idx, segsize);
        GDK_vm_nallocs[idx]++; }
#endif
        GDK_vm_cursize += segsize;
	CHKMEM(memdelta,vmdelta);
}

void GDKmemdec(size_t memdelta, size_t vmdelta) {
	size_t segsize = (size_t) SEG_SIZE(vmdelta,MT_VMUNITLOG);

	GDK_mem_cursize -= memdelta;
#ifdef GDK_VM_KEEPHISTO
{	int idx;
        GDKmallidx(idx, segsize);
        GDK_vm_nallocs[idx]--; }
#endif
        GDK_vm_cursize -= segsize;
}

@- tracing

Very simple malloc tracing implementation. Two bats are used:
stackBat: Contains a DAG of all methods used for memory allocation.
memBat: contains a mapping from allocated memory adresses to an index
in the stackBat which indicates the place the memory is allocated.

@c
#ifdef GDK_MEM_TRACE

static BAT *stackBat = NULL;
static BAT *memBat   = NULL;

static int mtrace    = 0;
typedef ptr mem_t;

char *
stack_test(int i, int j) {
	if(--i == 0)
		return (char *)GDKmalloc(j);

	return stack_test(i,j);
}


void
mtrace_test()
{
	char *t = stack_test(1,1);
	GDKfree(t);
	GDKfree(t);                /* double delete */
	t = stack_test(2,2);       
	t = GDKrealloc(t,20);         /* leaked */
}


int
GDKmtrace(bit *enable) {
	if(*enable) {
		if(memBat == NULL) {
			memBat   = BATnew(TYPE_ptr,TYPE_int,16384);
			stackBat = BATnew(TYPE_ptr,TYPE_ptr,16384);
			BBPrename(memBat->batCacheid,"mem_trace");
			BBPrename(stackBat->batCacheid,"mem_stack");
			memBat->hsorted = memBat->tsorted = 0;
			BATkey(memBat,TRUE);
			stackBat->hsorted = stackBat->tsorted = 0;
			BATset(stackBat,TRUE);
		}
		mtrace++;
	} else if(mtrace > 0)
		mtrace--;

	memBat->batDirty = TRUE;
	stackBat->batDirty = TRUE;

	if(*enable == bit_nil) {
		printf("testing mtrace:\n");
		mtrace_test();
		--mtrace;
	}

	return GDK_SUCCEED;
}


BUN
add_dag(BAT *b, BUN p, mem_t current, mem_t parent)
{
	const static int bunsize = sizeof(mem_t) + sizeof(mem_t);
	BUN last = BUNlast(b);

	while(p != last) {
		if((*(mem_t*)BUNhloc(b,p)) == current &&
		   (*(mem_t*)BUNtloc(b,p)) == parent)
			return p;
		p += bunsize;
	}

	if (b->batBuns->free + bunsize > b->batBuns->size) {
		int tmp = mtrace; mtrace = 0;
		BATextend(b, BATgrows(b));
		mtrace = tmp;
		last = BUNlast(b);
	}
	bunfastins_nocheck(b, last, &current, &parent, bunsize);
	return last;
}


#define MAX_STACK_ADDR 16
#define STACK_LIST(STACK_ENTRY) \
        STACK_ENTRY(1) STACK_ENTRY(2) STACK_ENTRY(3) \
        STACK_ENTRY(4) STACK_ENTRY(5) STACK_ENTRY(6) STACK_ENTRY(7) \
        STACK_ENTRY(8) STACK_ENTRY(9) STACK_ENTRY(10) STACK_ENTRY(11) \
        STACK_ENTRY(12) STACK_ENTRY(13) STACK_ENTRY(14) STACK_ENTRY(15)

#define STACK_READ(X) \
if (continue_stack_trace && \
    ((mem_t)__builtin_frame_address((X)) != 0L) && \
    ((X) < MAX_STACK_ADDR)) { \
	parent = current; \
	current = (mem_t)__builtin_return_address((X)); \
	if(parent) \
		p = add_dag(b, p, current, parent); \
} else if (continue_stack_trace) { \
	continue_stack_trace = FALSE; \
}

int
add_stack(BAT *b)
{
	mem_t current = 0, parent = 0;
	bit continue_stack_trace = TRUE;
	BUN p = BUNfirst(b);
	STACK_LIST(STACK_READ);
	return BUNindex(b,p);
}

#define __USE_GNU 1
#include <dlfcn.h>
void
print_address(ptr address)
{
  Dl_info dlip;
  char *filename;

  dladdr(address,&dlip);

  filename = 0; /* strrchr(dlip.dli_fname,'/'); */
  printf(PTRFMT "\t%s\t%s\n",address,dlip.dli_sname,
	 filename?filename+1:dlip.dli_fname);
}

int
GDKmprint(int *pidx)
{
        int idx = *pidx;
	BUN p = BUNptr(stackBat,idx), first = BUNfirst(stackBat);
	const static int bunsize = sizeof(mem_t) + sizeof(mem_t);
	mem_t *a;

	if(p == NULL) printf("No stack for index %d\n",idx);

	a = (mem_t *)BUNhloc(stackBat,p);
        print_address(*a);
	a = (mem_t *)BUNtloc(stackBat,p);
	print_address(*a);

        while(p > first) {
	  p -= bunsize;
	  if(*(mem_t *)BUNhloc(stackBat,p) == *a) {
	    a = (mem_t *)BUNtloc(stackBat,p);
	    print_address(*a);
	  }
	}

	return GDK_SUCCEED;
}


void
add_mem(BAT *b, mem_t mem, int idx)
{
	REGISTER BUN last;
	const static int bunsize = sizeof(mem_t) + sizeof(int);
	if (b->batBuns->free + bunsize > b->batBuns->size) {
		int tmp = mtrace; mtrace = 0;
		BATextend(b, BATgrows(b));
		mtrace = tmp;
	}
	last = BUNlast(b);
	bunfastins_nocheck(b, last, &mem, &idx, bunsize);
}


void
del_mem(BAT *b, mem_t mem)
{
	REGISTER BUN first = BUNfirst(b), p = BUNlast(b);
	const static int bunsize = sizeof(mem_t) + sizeof(int);
	for(p -= bunsize; p >= first; p -= bunsize) {
		if(*(mem_t*)BUNhloc(b,p) == mem) {
			int idx = -*(int *)BUNtloc(b,p);
			if(idx > 0) {
				printf("Double deletion of memory " PTRFMT ", "
				       "size: " SSZFMT ", stack:%d\n",
				       (void *) mem,((ssize_t *)mem)[-1],idx);
				if(mtrace > 1) GDKmprint(&idx);
			} else {
				BUNdelete(b,p);
				/* BUNinplace(b,p,&mem,&idx); */
			}
			return;
		}
	}
	printf("Free of unknown memory " PTRFMT ", size: " SSZFMT "\n",
		(size_t)mem,((ssize_t *)mem)[-1]);
}
#else
int GDKmtrace(bit *enable){ (void)enable; return GDK_SUCCEED; }
int GDKmprint(int *pidx)  { (void)pidx;   return GDK_SUCCEED; }
#endif

@- Malloc 
@T
Malloc normally maps through directly to the OS provided malloc/free/realloc
calls. Where possible, we want to use the -lmalloc library on Unix systems, 
because it allows to influence the memory allocation strategy. This can prevent
fragmentation and greatly help enhance performance.

The only "added-value" of the GDKmalloc/GDKfree/GDKrealloc over the standard OS
primitives is that the GDK versions try to do recovery from failure to malloc by 
initiating a BBPtrim (to unload BAts and make space in the memory). This basic 
behaviour is obtained by defining GDK\_MEM\_SIMPLE. 

A number of different strategies are available using different switches, however:
\begin{description}

\item[zero sized blocks]
Normally, GDK gives fatal errors on illegal block sizes.
This can be overridden with  GDK\_MEM\_NULLALLOWED.

\item[resource tracking]
Many malloc interfaces lack a routine that tells the size of a blobk
by the pointer. We need this information for correct malloc statistics.

Some systems (like cygnus) already store the blocksize in front of
the pointer (and do not have alignment problemes described below). In
that case, we save the overhead of redoing this ourselves by defining 
GDK\_MEM\_QUERYSIZE.

\item[outstanding block histograms]
In order to solve the problem, we allocate extra memory in front of the 
returned block. With te resource tracking in place, we keep a total of 
allocated bytes.  Also, if GDK\_MEM\_KEEPHISTO is defined, we keep a histogram 
of the outsanding blocks on the log2 of the blocksize (similarly for virtual.
memory blocks; define GDK\_VM\_KEEPHISTO).

\item[ensuring 8-byte alignment]
While doing the resource tracking, we can in one go solve the problem
of 32-bit systems that return non-8 bytes algigned pointers. This is
encoded by storing a size + 1 (we always normalize sizes to multiples of 
8, so this is easily recognized). This check is done automatically when
GDK\_MEM\_SIMPLE is {\bf not} enabled.

\item[redirection to anonymous VM]
Sometimes, fragmentation problems arise on mallocs that are not tuneable.
In that case, it makes sense to redirect large block requests (taken to be
larger than GDK\_mem\_bigsize) to anonymous virtual memory. The seamless
implmentation of this stores the {\bf negative} blocksize in front of the
pointer (as well as the VM maxsize), so the malloc primitives can recognize
these redirected blocks.This behavior is enabled by defining GDK\_MEM\_VMREDIRECT.
\end{description}
@c
#ifdef GDK_MEM_QUERYSIZE
#define GDK_MEM_BLKSIZE(p) GDK_MEM_QUERYSIZE(p)
#else
#define GDK_MEM_BLKSIZE(p) ((ssize_t*) (p))[-1]
#endif

static 
void GDKmemdump(void) {
	struct mallinfo m = MT_mallinfo();

	THRprintf(GDKerr, "\n!mallinfo.arena = " SSZFMT "\n", (ssize_t) m.arena);
	THRprintf(GDKerr, "!mallinfo.ordblks = " SSZFMT "\n", (ssize_t) m.ordblks);
	THRprintf(GDKerr, "!mallinfo.smblks = " SSZFMT "\n", (ssize_t) m.smblks);
	THRprintf(GDKerr, "!mallinfo.hblkhd = " SSZFMT "\n", (ssize_t) m.hblkhd);
	THRprintf(GDKerr, "!mallinfo.hblks = " SSZFMT "\n", (ssize_t) m.hblks);
	THRprintf(GDKerr, "!mallinfo.usmblks = " SSZFMT "\n", (ssize_t) m.usmblks);
	THRprintf(GDKerr, "!mallinfo.fsmblks = " SSZFMT "\n", (ssize_t) m.fsmblks);
	THRprintf(GDKerr, "!mallinfo.uordblks = " SSZFMT "\n", (ssize_t) m.uordblks);
	THRprintf(GDKerr, "!mallinfo.fordblks = " SSZFMT "\n", (ssize_t) m.fordblks);
#ifdef GDK_MEM_KEEPHISTO
{	int i;
	THRprintf(GDKerr, "!memory histogram\n");
        for (i = 3; i < GDK_HISTO_MAX_BIT - 1; i++) {
                size_t j = 1 << i;
		THRprintf(GDKerr, "! " SZFMT " " SZFMT "\n", j, GDK_nmallocs[i]);
        }}
#endif
#ifdef GDK_VM_KEEPHISTO
{	int i;
	THRprintf(GDKerr, "\n!virtual memory histogram\n");
        for (i = 12; i < GDK_HISTO_MAX_BIT - 1; i++) {
                size_t j = 1 << i;
		THRprintf(GDKerr, "! " SZFMT " " SZFMT "\n", j, GDK_vm_nallocs[i]);
        }
#endif
}

static
void GDKmemfail(str s, size_t len, size_t memtarget, size_t vmtarget) {
	int bak = GDKdebug;

	/* bumped your nose against the wall; try to prevent repetition by adjusting maxsizes */
	if (memtarget < 0.3 * GDKmem_inuse()) {
		size_t newmax = (size_t) (0.7 * (double)GDKmem_inuse());
		if (newmax < GDK_mem_maxsize) GDK_mem_maxsize = newmax;
	}
	if (vmtarget < 0.3 * GDKvm_cursize()) {
		size_t newmax = (size_t) (0.7 * (double)GDKvm_cursize());
		if (newmax < GDK_vm_maxsize) GDK_vm_maxsize = newmax;
	}

        if (GDKthreadLock) MT_set_lock(GDKthreadLock, "GDKmemfail");
	THRprintf(GDKerr, "%s(" SZFMT ") fail => BBPtrim(enter) usage[mem=" SZFMT ",vm=" SZFMT "]\n", 
			s, len, GDKmem_inuse(), GDKvm_cursize());
	GDKmemdump();
	GDKdebug |= 4;
        if (GDKthreadLock) MT_unset_lock(GDKthreadLock, "GDKmemfail");

        BBPtrim(memtarget, vmtarget);

        if (GDKthreadLock) MT_set_lock(GDKthreadLock, "GDKmemfail");
	GDKdebug = MIN(GDKdebug,bak);
	THRprintf(GDKerr, "%s(" SZFMT ") fail => BBPtrim(ready) usage[mem=" SZFMT ",vm=" SZFMT "]\n", 
			s, len, GDKmem_inuse(), GDKvm_cursize());
	GDKmemdump();
        if (GDKthreadLock) MT_unset_lock(GDKthreadLock, "GDKmemfail");
}


#if defined(GDK_MEM_QUERYSIZE) || defined(GDK_MEM_SIMPLE)
#define GDKmalloc_prefixsize(s,size) 					\
	s = (ssize_t*) malloc(size)
#else
#define GDKmalloc_prefixsize(s, size) {					\
	/* round up to multiple of 4 and add 8: */			\
	size_t realsize = ((size) + 11) & ~3;				\
	char *p = (char *) malloc(realsize);				\
	if (p == NULL) {						\
		s = NULL;						\
	} else if (((size_t) p) & 4) { /* misaligned */			\
		s = (ssize_t*) (p + 4); /* place 4 bytes before it */	\
		s[-1] = (ssize_t) (realsize + 1);  /* 1 is a marker */	\
	} else {							\
		s = (ssize_t*) (p + 8); /* place 8 bytes before it */	\
		s[-1] = (ssize_t) realsize;				\
	}								\
}
#endif


void* GDKmallocmax(size_t size, size_t maxsize) {
	ssize_t *s;

        if (size == 0) {
#ifdef GDK_MEM_NULLALLOWED
		return NULL;
#else
		GDKfatal("GDKmalloc called with size " SZFMT "", size);
#endif
	}
	CHKMEM(size,0);

	if (size > GDK_mem_bigsize) {
		size += 16;
		maxsize = MAX(maxsize, size);
		s = (ssize_t*) GDKvmalloc(size, &maxsize);
		MT_alloc_register(s, maxsize, 'S');
		s += 2;
		s[-2] = (ssize_t) maxsize;
		s[-1] = -((ssize_t) size);
	} else { 
		GDKmalloc_prefixsize(s, size);
	}
       	if (s == NULL) {
		GDKmemfail("GDKmalloc", size, BBPTRIM_ALL, 0);
		GDKmalloc_prefixsize(s, size);
		if (s == NULL) { 
			MT_alloc_print();
               		GDKfatal("GDKmalloc failed for %u bytes",size);
		} else {
			THRprintf(GDKerr, "GDKmalloc: recovery ok. Continuing..\n");
		}
	}
#ifndef GDK_MEM_SIMPLE
{	ssize_t realsize = GDK_MEM_BLKSIZE(s);
	if (realsize > 0) {	
#ifdef GDK_MEM_KEEPHISTO
		int idx;
		GDKmallidx(idx, realsize);
		GDK_nmallocs[idx]++; 
#endif
		GDK_heap_inuse += realsize;
#ifdef GDK_MEM_TRACE
		if(mtrace) {
			int idx = add_stack(stackBat);
			add_mem(memBat,s,idx);
		}
#endif
	}}
#endif
        return (void*) s;
}

void* GDKmalloc(size_t size) {
	return GDKmallocmax(size, size);
}
	
 
void GDKfree (void *blk) {
	ssize_t size, *s = (ssize_t*) blk;

        if (s == NULL) return;
	size = GDK_MEM_BLKSIZE(s);

	if (size > 0) {
#ifdef GDK_MEM_KEEPHISTO
		int idx;

#if !(defined(GDK_MEM_QUERYSIZE) || defined(GDK_MEM_SIMPLE))
	/* wdk: add check for double deletes */
        assert((size&2) == 0);
        s[-1] |= 2;
#endif

		GDKmallidx(idx,size);
		GDK_nmallocs[idx]--;
#endif
		GDK_heap_inuse -= size; 
#ifdef GDK_MEM_TRACE
		if(mtrace)
			del_mem(memBat,blk);
#endif
	}
	if (size < 0) {
		size_t maxsize = (size_t) s[-2];
		size = -size;
		MT_alloc_register(((char*) s) - 16, maxsize, 's');
		GDKvmfree(((char*) s)- 16, (size_t) size, maxsize);
	} else
#ifndef GDK_MEM_QUERYSIZE
	if (size&1) {
		free(((char*) s) - 4);
	} else {
		free(((char*) s) - 8);
	}
#else
	free(blk);
#endif
}

ptr GDKrealloc(void* blk, size_t size) {
        if (blk == NULL) {
		return GDKmalloc(size);
	}
#ifdef GDK_MEM_NULLALLOWED
        if (size == 0) {
		GDKfree(blk);
		return NULL;
	}
#endif
        if (size <= 0) {
                GDKfatal("GDKrealloc called with size %u", size);
        }
#ifdef GDK_MEM_SIMPLE
        CHKMEM(size,0);
        blk = realloc(blk, size);
#else
{       size_t cpysize, *s = (size_t*) blk;
        ssize_t oldsize = GDK_MEM_BLKSIZE(s);
	if (oldsize < 0) {
		ssize_t *s = (ssize_t*) blk;
		size_t oldmax = (size_t) s[-2];
		size_t newmax = MAX(size+16,oldmax);
		s = (ssize_t*) GDKvmrealloc((ptr) (s-2), (size_t) -oldsize, size+16, oldmax, &newmax);
		s[0] = newmax;
		s[1] = -((ssize_t) size);
		return (ptr) (s+2);
	} 
#ifdef GDK_MEM_QUERYSIZE
	cpysize = MIN(size, (size_t) oldsize);
#else
	if (oldsize&1) {
		cpysize = MIN(size, (size_t) oldsize - 5);
	} else {
		cpysize = MIN(size, (size_t) oldsize - 8);
	}
#endif
	/* the bad news is that the alignment problems on 32-bit systems prevent us from using realloc 
         * the good news is that we know our block sizes; so we can at least copy it to the new location
         */
        blk = (void* ) GDKmalloc(size);
        memcpy(blk, s, cpysize);
        GDKfree(s);
}
#endif
        return blk;
}

void* GDKcalloc(size_t nmemb, size_t size) {
	if (nmemb && size) {
		size_t n = nmemb * size; /* wdk XXX: overflow? */
		void *res = GDKmalloc(n);
		if (res) {
			return memset(res, 0, n);
		}
	}
	return 0;
}


char *GDKstrdup(const char *s) {
        int l = strLen(s);
        char *n = (char *) GDKmalloc(l);
        memcpy(n,s, l);
        return n;
}
 

@- virtual memory
allocations affect only the logical VM resources.
@c
void *GDKmmap(char* path, int mode, off_t off, size_t len, void *fixed) {
        void *ret = MT_mmap(path, mode, off, len, fixed);
        if (ret == (void*) -1L) {
                GDKmemfail("GDKmmap", len, 0, BBPTRIM_ALL);
                ret = MT_mmap(path, mode, off, len, fixed);
                if (ret != (void*) -1L) {
                    THRprintf(GDKerr, "GDKmmap: recovery ok. Continuing..\n");
                }
        }
        if (ret != (void*) -1L) {
                MT_alloc_register(ret, len, 'M');
                GDKmeminc((size_t) 0, len);
        }
        return (void*) ret;
}

int GDKmunmap(void* addr, size_t size) {
        int ret;
        MT_alloc_register(addr, size, 'm');
        ret = MT_munmap(addr, size);
        if (ret == 0) {
                GDKmemdec((size_t) 0, size);
        }
        return ret;
}

 
@- VM alloc
this affects both physical and logical memory resources.
@c
void* GDKvmalloc(size_t size, size_t *maxsize) {
	void *ret = MT_vmalloc(size, maxsize);
        if (ret == NULL) {
                GDKmemfail("GDKvmalloc", size, BBPTRIM_ALL, BBPTRIM_ALL);
                ret = MT_vmalloc(size, maxsize);
                if (ret == NULL) {
                        MT_alloc_print();
                        GDKfatal("GDKvmalloc failed for %u bytes",size);
                } else {
                        THRprintf(GDKerr, "GDKvmalloc(" SZFMT "): recovery ok. Continuing..\n", size);
                }
        }
        if (ret != NULL) {
                GDKmeminc(size, *maxsize);
	}
	return ret;
}

void* GDKvmrealloc(void* pold, size_t oldsize, size_t newsize, size_t oldmax, size_t *maxsize) {
	void *ret = MT_vmrealloc(pold, oldsize, newsize, maxsize);
        if (ret == NULL) {
                GDKmemfail("GDKvrealloc", newsize, BBPTRIM_ALL, BBPTRIM_ALL);
                ret = MT_vmrealloc(pold, oldsize, newsize, maxsize);
                if (ret == NULL) {
                        MT_alloc_print();
                        GDKfatal("GDKvrealloc failed for %u bytes (from %u)", newsize, oldsize);
                } else  {
                        THRprintf(GDKerr, "GDKvmrealloc(" SZFMT "): recovery ok. Continuing..\n", newsize);
                }
        }
        if (ret != NULL) {
                GDKmemdec(oldsize,oldmax);
                GDKmeminc(newsize,*maxsize);
	}
	return ret;
}

void GDKvmfree(void* blk, size_t size, size_t maxsize){
	MT_vmfree(blk, maxsize);
	GDKmemdec(size, maxsize);
}

@+ Session Initialization
The parameter @%db@ is followed by the database name relative to
the environment variable dbfarm.
The parameter @%monetrc@ tells that the system variables setting
should be overruled by the specification given in the file argument.
This format is only necessary to temporarely experiment with variable settings,
without disturbing a system/site default setting.

The interface code to the operating system is highly dependent on
the processing environment. It can be filtered away with compiletime flags.
Suicide is necessary due to some system implementation errors.

The kernel requires file descriptors for I/O with the user.
They are thread specific and should be obtained by a function.

The arguments relevant for the kernel are extracted from the list. 
Their value is turned into a blanc space.
@h
gdk_export int GDKrecovery;
@c
int GDKtime_startsec, GDKrecovery = 0; 

@h
gdk_export int GDKinit(char *dbname, char *dbfarm, int alloc_map);
@c
int GDKinit(char *dbname, char *dbfarm, int alloc_map) {
	int 	i;

	errno = 0;
	if (!GDKenvironment(dbname, dbfarm))
		return 0;

	stream_init();
	MT_init_posix(alloc_map);
	THRinit();
	BATSIGinit(); 
	GDKlockHome(); 

	/* init time */
#ifdef HAVE_GETTIMEOFDAY
	{
	struct timeval tp;
	gettimeofday(&tp, NULL);
	GDKtime_startsec = tp.tv_sec;
	}
#else
#ifdef HAVE_FTIME
	{
	struct timeb tb;
	ftime(&tb);
	GDKtime_startsec = tb.time;
	}
#endif
#endif

	GDKthreadLock = MT_create_lock(); 
	for(i=0; i<= BBPLOCKMASK; i++) {
		GDKstatusLock[i] = MT_create_lock(); 
		GDKswapLock[i] = MT_create_lock(); 
		GDKidxLock[i] = MT_create_lock(); 
		GDKhashLock[i] = MT_create_lock(); 
	}
	GDKcacheLock = MT_create_lock(); 
	GDKunloadLock = MT_create_lock(); 
	GDKunloadBarrier = MT_create_lock(); 
	GDKtrimLock = MT_create_lock(); 
	GDKtmLock = MT_create_lock(); 

	/* Mserver intends to rob 85% of all memory as a default */
 	GDK_mem_maxsize = (size_t) ((double)MT_npages() * (double)MT_pagesize() * 0.85); 
/* NIELS testing unload all
	GDK_mem_maxsize = 0;
*/

	GDKremovedir(DELDIR);  
	BBPinit(); 
	GDKenv = BATnew(TYPE_str,TYPE_str,100);
	BATrename(GDKenv, "monet_environment");
	BATmode(GDKenv, TRANSIENT);

	return 1;
}

@- 
Upon closing the session, all persistent BATs should be saved and
the transcient BATs should be removed.
The buffer pool manager takes care of this.
@h
gdk_export int GDKstopped;
@c
int GDKstopped = 1;

@h
gdk_export void GDKexit(int status);
@c
void GDKexit(int status) {
        if (GDKthreadLock) MT_set_lock(GDKthreadLock, "GDKexit");
        if (GDKstopped == 0) {
                GDKstopped++; /* shouldn't there be a lock here? */
                GDKnrofthreads = 0;
                if (GDKthreadLock) MT_unset_lock(GDKthreadLock, "GDKexit");

		/* Kill all threads except myself */
		if(status == 0) {
			MT_Id pid = MT_getpid();
			Thread t, s;
			for (t = GDKthreads, s = t + THREADS; t < s; t++) {
				if (t->pid) {
					MT_Id victim = t->pid; 
					if(t->pid != pid)
						MT_kill_thread(victim); 
				}
			}
		}
		(void) GDKgetHome();
		BBPexit(); 
		GDKlog(GDKLOGOFF);
		GDKunlockHome(); 
		MT_global_exit(status); 
	} 
	if (GDKthreadLock) MT_unset_lock(GDKthreadLock, "GDKexit");
}

@
All semaphores used by the application should be mentioned here.
They are initialized during system initialization.
@c
int		GDKdebug = 0; 

MT_Lock		GDKthreadLock = NULL; 
MT_Lock		GDKstatusLock[BBPLOCKMASK+1]; 
MT_Lock		GDKswapLock[BBPLOCKMASK+1]; 
MT_Lock		GDKidxLock[BBPLOCKMASK+1]; 
MT_Lock		GDKhashLock[BBPLOCKMASK+1]; 
MT_Lock		GDKcacheLock, GDKtrimLock; 
MT_Lock		GDKunloadLock, GDKunloadBarrier; 
MT_Lock		GDKtmLock; 

@+ Concurrency control
Concurrency control requires actions at several levels of the system.
First, it should be ensured that each database  is controlled by a single
server process (group). Subsequent attempts should be stopped.
This is regulated throught file locking against ".gdk_lock".
Furthermore, the server process is moved to the database directory
for improved speed.
@-
Before the locks and threads are initiated, we cannot use the 
normal routines yet. So we have a local fatal here instead of GDKfatal. 
@c
void GDKlockHome(void) {
	char *p=0, buf[1024], host[PATHLENGTH];
	char GDKdirStr[PATHLENGTH];
@-
Go there and obtain the global database lock.
@c
	/* The DIR_SEP at the end of the path is needed for a succesfull
	   call to GDKcreatedir */

	snprintf(GDKdirStr, PATHLENGTH, "%s%c%s%c",
			GDKdbfarmStr, DIR_SEP, GDKdbnameStr, DIR_SEP);

	if (chdir(GDKdirStr) < 0 ){
	    if (!GDKcreatedir(GDKdirStr) || chdir(GDKdirStr) < 0)
	        GDKfatal("GDKlockHome: could not move to %s\n", GDKdirStr);
	    GDKwarning("GDKlockHome: created directory %s\n", GDKdirStr);
	}
	if (GDKrecovery  && unlink(GDKLOCK) < 0) {
	    GDKfatal("GDKlockHome: unlock DB failed\n"); 
	}
	umask(0000);
	if (MT_lockf(GDKLOCK, F_TLOCK, 4, 1) < 0) {
	    GDKlockFile = 0;
	    GDKfatal("GDKlockHome: Database lock '%s' denied\n", GDKLOCK); 
	}
	if ((GDKlockFile = fopen(GDKLOCK, "rb+")) == NULL) {
	    GDKfatal("GDKlockHome: Could not open %s\n", GDKLOCK); 
	}
	if (fgets(buf, 1024, GDKlockFile) && (p=strchr(buf, ':'))) *p = 0;
	if (p) {
	    sprintf(host, " from '%s'", buf);
	} else {
	    GDKwarning("GDKlockHome: ignoring empty or invalid %s.\n", GDKLOCK);
	    host[0] = 0;
	}
@-
We have the lock, are the only process currently allowed in this section.
@c
	MT_init();
	OIDinit();
@-
Print the new process list in the global lockfile.
@c
	fseek(GDKlockFile, 0, SEEK_SET);
	ftruncate(fileno(GDKlockFile), 0);
	fflush(GDKlockFile);
	GDKlog(GDKLOGON);
@-
In shared mode, we allow more parties to join. Release the lock. 
@c
	GDKstopped = 0;
}

void GDKunlockHome(void) {
	if (GDKlockFile) {
		MT_lockf(GDKLOCK, F_ULOCK, 4, 1); 
		fclose(GDKlockFile); 
		GDKlockFile = 0; 
	}
}
@-
Really really get the lock. Now!!
@c
int GDKgetHome(void) {
	if (GDKlockFile) return 0;
	if (MT_system_lock==NULL) return 0;
	while ((GDKlockFile = fopen(GDKLOCK, "r+")) == NULL) {
		GDKerror("GDKgetHome: PANIC on open %s. sleep(1)\n", GDKLOCK);
		MT_sleep_ms(1000);
	}
	if (MT_lockf(GDKLOCK, F_TLOCK, 4, 1) < 0){
		GDKwarning("GDKgetHome: blocking on lock '%s'.\n", GDKLOCK);
		MT_lockf(GDKLOCK, F_LOCK, 4, 1);
	}
	return 1;
}

@+ Error handling
Errors come in three flavors: warnings, non-fatal and fatal errors.
A fatal error leaves a core dump behind after trying to
safe the content of the relation.
A non-fatal error returns a message to the user
and aborts the current transaction.
Fatal errors are also recorded on the system log for post-mortem
analysis.
@c
int GDKsilent = 0;

/* do the real work for GDKaddbuf below. */
static void doGDKaddbuf(const char *prefix, const char *message, int messagelen, const char *suffix)
{
	char *buf = GDKerrbuf;

	if (buf) {
		char *dst = buf + strlen(buf);
		size_t maxlen = GDKMAXERRLEN - (dst - buf) - 1;
		if (prefix && *prefix && dst < buf + GDKMAXERRLEN) {
			size_t preflen;
			strncpy(dst, prefix, maxlen);
			dst[maxlen] = '\0';
			preflen = strlen(dst);
			maxlen -= preflen;
			dst += preflen;
		}
		if (maxlen > messagelen)
			maxlen = messagelen;
		strncpy(dst, message, maxlen);
		dst += maxlen;
		if (suffix && *suffix && dst < buf + GDKMAXERRLEN) {
			size_t sufflen;
			maxlen = buf + GDKMAXERRLEN - dst - 1;
			strncpy(dst, suffix, maxlen);
			dst[maxlen] = '\0';
			sufflen = strlen(dst);
			maxlen -= sufflen;
			dst += sufflen;
		}
		*dst = '\0';
	} else if (!GDKsilent) {
		/* construct format string because the format string
		   must start with ! */
		char format[32];
		snprintf(format, sizeof(format), "%s%%.*s%s",
			 prefix ? prefix : "", suffix ? suffix : "");
                THRprintf(GDKerr, format, messagelen, message);
	}
}

/* print an error or warning message, making sure the message ends in
   a newline, and also that every line in the message (if there are
   multiple), starts with an exclamation point.
   One of the problems complicating this whole issue is that each line
   should be printed using a single call to THRprintf, and moreover,
   the format string should start with a "!".  This is because
   THRprintf adds a "#" to the start of the printed text if the format
   string doesn't start with "!".
   Another problem is that we're religious about bounds checking.
   It would probably also not be quite as bad if we could write in the
   message buffer.
 */
void GDKaddbuf(const char *message)
{
	const char *p, *q;
	char prefix[16];

	if (message == NULL || *message == '\0') /* empty message, nothing to do */
		return;
	p = message;
	strcpy(prefix, "!");	/* default prefix */
	while (p && *p) {
		if (*p == '!') {
			int preflen;

			/* remember last ! prefix (e.g. "!ERROR: ")
			   for any subsequent lines that start without ! */
			message = p;
			/* A prefix consists of a ! immediately
			   followed by some text, followed by a : and
			   a space.  Anything else results in no
			   prefix being remembered */
			while (*++p && *p != ':' && *p != '\n' && *p != ' ')
				;
			if (*p == ':' && *++p == ' ') {
				/* found prefix, now remember it */
				preflen = (int) (p - message) + 1;
				if (preflen > sizeof(prefix) - 1)
					preflen = sizeof(prefix) - 1;
				strncpy(prefix, message, preflen);
				prefix[preflen] = 0;
			} else {
				/* there is a ! but no proper prefix */
				strcpy(prefix, "!");
				preflen = 1;
			}
			p = message + preflen;
		}

		/* find end of line */
		q = strchr(p, '\n');
		if (q) {
			/* print line including newline */
			q++;
			doGDKaddbuf(prefix, p, (int) (q - p), "");
		} else {
			/* no newline at end of buffer: print all the
			   rest and add a newline */
			doGDKaddbuf(prefix, p, (int) strlen(p), "\n");
			/* we're done since there were no more newlines */
			break;
		}
		p = q;
	}
}

/*VARARGS*/
int GDKwarning(const char *format, ...)
{
	char message[GDKMAXERRLEN];	
	size_t len = strlen(GDKWARNING);
	va_list ap; 

	strcpy(message, GDKWARNING);
	va_start(ap, format); 
	vsnprintf(message + len, GDKMAXERRLEN-(len+2), format, ap); 
	va_end (ap); 

	GDKaddbuf(message);

	return 0;
}


/*VARARGS*/
int GDKerror(const char *format, ...)
{
	char message[GDKMAXERRLEN];	
	size_t len = strlen(GDKERROR);
	va_list ap; 

	strcpy(message, GDKERROR);
	va_start(ap, format); 
	vsnprintf(message + len, GDKMAXERRLEN-(len+2), format, ap); 
	va_end(ap); 

	GDKaddbuf(message);

	return 0;
}

/*VARARGS*/
int GDKsyserror(const char *format, ...)
{
        char message[GDKMAXERRLEN];
        size_t len = strlen(GDKERROR);

        int     err = errno;
        va_list ap;

	strcpy(message, GDKERROR);
	va_start(ap,format); 
	vsnprintf(message + len, GDKMAXERRLEN-(len+2), format, ap); 
	va_end(ap); 
	if (err > 0 && err < 1024) {
		char *osmsg = strerror(err);
		size_t len1  = strlen(message);
		size_t len2  = len1 + strlen(GDKMESSAGE);
		size_t len3  = len2 + strlen(osmsg);

		if (len3 + 2 < GDKMAXERRLEN) {
			strcpy(message + len1, GDKMESSAGE);
			strcpy(message + len2, osmsg);
			message[len3] = '\n';
			message[len3+1] = 0;
		}
	}
	GDKaddbuf(message);

	errno = 0;
	return err;
}

/*VARARGS*/
int GDKfatal(const char *format, ...) {
	char message[GDKMAXERRLEN];	
	size_t len = strlen(GDKFATAL);
	va_list ap; 
	FILE *fd=stderr;

	GDKdebug |= 16;
	BATSIGinit();	
	strcpy(message, GDKFATAL);
	va_start(ap, format); 
	vsnprintf(message + len, GDKMAXERRLEN-(len+2), format, ap); 
	va_end(ap); 

	if (GDKsilent == 0) {
            fputs(message, fd); 
	    fputs("\n", fd);
            fflush(fd); 
	}
@-
Real errors should be saved in the lock file for post-crash inspection.
@c
	if (GDKstopped) {
        	fflush(stderr);
		MT_exit_thread(1);
        	/* exit(1); */
	} else {
		GDKlog(message);
#ifdef COREDUMP
        	abort(); 
#else
        	GDKexit(1); 
	}
#endif
	return -1;
}

@- Timers
The following relative timers are available for inspection.
Note that they may consume recognizable overhead.
@c

lng GDKusec(void) {
#ifdef HAVE_GETTIMEOFDAY
	struct timeval tp;
	gettimeofday(&tp, NULL);
	return ((lng) (tp.tv_sec-GDKtime_startsec))*
		LL_CONSTANT(1000000) + (lng) tp.tv_usec;
#else
#ifdef HAVE_FTIME
	struct timeb tb;
	ftime(&tb);
	return ((lng) (tb.time-GDKtime_startsec))*LL_CONSTANT(1000000) +
	       ((lng) tb.millitm)*LL_CONSTANT(1000);
#endif
#endif
}


int GDKms(void) {
#ifdef HAVE_GETTIMEOFDAY
	struct timeval tp;
	gettimeofday(&tp, NULL);
        return (tp.tv_sec-GDKtime_startsec)*1000 + tp.tv_usec/1000;
#else
#ifdef HAVE_FTIME
	struct timeb tb;
	ftime(&tb);
	return (tb.time-GDKtime_startsec)*1000 + tb.millitm;
#endif
#endif
}

static int stamp = 0;
int GDKstamp(void)
{
	return ++stamp;
}
void GDKsetstamp(int newstamp)
{
	stamp = newstamp;
}


@+ Logical Thread management

All semaphores used by the application should be mentioned here.
They are initialized during system initialization.

@- 
The first action upon thread creation is to add it to the pool
of known threads. This should be done by the thread itself.
Subsequently, the thread descriptor can be obtained usign @%THRget@.
Note that the users should have gained exclusive access already.
A new entry is initialized automatically when not found.
Its file descriptors are the same as for the server and should be
subsequently reset.
@c
int		GDKnrofthreads; 
ThreadRec 	GDKthreads[THREADS]; 
void *		THRdata[THREADDATA] = { 0 };

Thread THRget(int tid) {
	assert(0 < tid && tid <= THREADS);
	return (GDKthreads+tid-1);
}

static INLINE 
size_t THRsp(void){
	int l = 0;
	size_t sp = (size_t)(&l);
	
	return sp;
}

Thread THRnew(MT_Id pid, str name) {
	MT_Id tid = 0;
 	Thread 	t;
	Thread	s; 

	MT_set_lock(GDKthreadLock, "THRnew"); 
	for (s = GDKthreads, t = s + THREADS; s < t; s++) {
		if (s->pid == pid) {
			MT_unset_lock(GDKthreadLock, "THRnew"); 
			GDKwarning("THRnew:duplicate %d\n", pid); 
			return s; 
		}
	}
	for (s = GDKthreads, t = s + THREADS; s < t; s++) {
		if (s->pid == 0) {
			break; 
		}
	}
	if (s == t) {
		MT_unset_lock(GDKthreadLock, "THRnew"); 
		GDKfatal("THRnew:too many threads\n"); 
	}

	tid = s->tid;
	memset((char*) s, 0, sizeof(*s)); 
	s->pid = pid; 
	s->tid = tid;
	s->data[1] = THRdata[1]; 
	s->data[0] = THRdata[0]; 
	s->name = name; 
	s->cleanup = NULL;
	s->sp = THRsp();
	PARDEBUG THRprintf(GDKerr, "%x " SZFMT " sp = " SZFMT "\n", 
			s->tid, (size_t) pid, s->sp); 
	PARDEBUG THRprintf(GDKerr, "nrofthreads %d\n", GDKnrofthreads); 
	GDKnrofthreads++; 
	MT_alloc_register(&tid, 1, (char) ('0'+ ((int)tid) - 1));
	MT_unset_lock(GDKthreadLock, "THRnew"); 

	return s; 
}

void THRdel(Thread t) {	
	if (t < GDKthreads || t > GDKthreads + THREADS) {
		GDKfatal("THRdel\n"); 
	}
	MT_set_lock(GDKthreadLock, "THRdel"); 
	if (t->cleanup) {
		(*t->cleanup)(t);
	}
	PARDEBUG 
	THRprintf(GDKerr, "pid = " SZFMT ", disconnected, %d left\n", 
		(size_t) t->pid, GDKnrofthreads); 
	t->pid = 0; 
	GDKnrofthreads--; 
	MT_unset_lock(GDKthreadLock, "THRdel"); 
}
@- 
The easiest way to terminate a thread is to identify its name
A zero is returned when the thread could not be found
@c
static Thread GDK_find_thread(MT_Id pid){
   	Thread t, s;
	for (t = GDKthreads, s = t + THREADS; t < s; t++) {
		if (t->pid && t->pid == pid ){
			return t; 
		}
	}
   	return NULL;
}

int THRexit(str nme) {
	Thread	t;
	Thread	s; 

	for (t = GDKthreads, s = t + THREADS; t < s; t++) {
		if (t->pid && t->name && strcmp(t->name, nme) == 0) {
			MT_Id victim = t->pid; 
			THRdel(t); 
			MT_kill_thread(victim); 
			return 1; 
		}
	}
	return 0; 
}

int THRcnt(void) {
	return GDKnrofthreads; 
}

int THRhighwater(void) {
	size_t c = THRsp();
	Thread s = GDK_find_thread(MT_getpid());
	size_t diff = (c<s->sp)?s->sp-c:c-s->sp;
	if (diff > (THREAD_STACK_SIZE-2048)){
		return 1;
	}
	return 0;
}

@{
@- 
I/O is organized per thread, because users may gain access through
the internet.
The code below should be improved to gain speed.
@c

int THRinit(void) {
	int i = 0;
	THRdata[0] = (void*) file_wastream(stdout, "stdout");
	THRdata[1] = (void*) file_rastream(stdin, "stdin");
	for ( i = 0; i<THREADS; i++ ){
		GDKthreads[i].tid = (MT_Id)(i+1);
	}
	return 0;
}

void THRsetdata(int n, ptr val) {
	Thread s = GDK_find_thread(MT_getpid());
	if (s) s->data[n] = val;
}

void*  THRgetdata(int n) {
	Thread s = GDK_find_thread(MT_getpid());
	return (s?s->data[n]:THRdata[n]);
}

int THRgettid(void){
	Thread s = GDK_find_thread(MT_getpid());
	return s?s->tid:1;
}

static char THRprintbuf[BUFSIZ];

/*VARARGS*/
int THRprintf(stream *s, const char *format, ...) {
	str bf = THRprintbuf, p = 0;
	size_t bfsz = BUFSIZ;
	int n = 0;
	ptrdiff_t m = 0;
	char c;
        va_list ap;

	if (MT_system_lock) {
		MT_set_lock(MT_system_lock, "THRprintf");
	}
	if (*format != '!') {
	        c = '#';
	} else {
	        c = '!'; format++;
	}

@= THRprintf_va_vsnprintf
	p = bf;
	*p++ = c;
	if (GDKdebug&1) {
		sprintf(p, "%02d ", THRgettid());
		while(*p) p++;
	}
	m = p-bf;
        va_start (ap,format);
        n = vsnprintf (p, bfsz-m, format, ap);
        va_end (ap);
@c
	@:THRprintf_va_vsnprintf@
	while (n < 0 || (size_t) n >= bfsz-m) {
		if (n >= 0)		/* glibc 2.1 */
			bfsz = m+n+1;	/* precisely what is needed */
		else			/* glibc 2.0 */
			bfsz *= 2;	/* twice the old size */
		if (bf != THRprintbuf) free(bf);
		bf = (str) malloc(bfsz);
		assert(bf != NULL);
		@:THRprintf_va_vsnprintf@
	}
	p += n;
	
	n = 0;
	if (stream_write(s, bf, p-bf, 1 ) != 1 ||
	    stream_flush(s) != 0)
		n = -1;
	if (bf != THRprintbuf) free(bf);
	if (MT_system_lock) {
		MT_unset_lock(MT_system_lock, "THRprintf");
	}
        return n;
}

@}
@h
#endif /* _GDK_UTILS_H_ */
