@f gdk_utils
@a M. L. Kersten, P. Boncz

@* Utilities
The purpose of the homes file is to centralize all information on the
whereabouts of the database. Detailed information for database and
session initialization are stored within the database.
@h
#ifndef _GDK_UTILS_H_
#define _GDK_UTILS_H_

gdk_export void GDKlog       (char *format, ...);
gdk_export void GDKlockHome  ();
gdk_export void GDKunlockHome();
gdk_export int  GDKgetHome   ();

gdk_export lng  GDKusec      ();
gdk_export int  GDKms        ();
gdk_export int  GDKcsec      ();
gdk_export int  GDKsec       ();

#endif /* _GDK_UTILS_H_ */
@c
#ifndef GDK_NOLINK
#include "gdk.h"
#include "gdk_utils.h"
#include "gdk_posix.h"

@-
Include the generic GDK home management code. This code can be imported
by other utility programs without the need to link the entire gdk.
Remap the malloc/free calls to their GDK equivalents. 
@
@
@%GDKhomeScan(usr,db,home)@ scans the 'homes' file  for a (usr,db,home) entry.
It expects an empty @%GDKenviron@ array. If @GDKport@ and @%GDKdir@ are set,
however, it changes to 'creation-mode', and scans the homes file for previous
definitions for database 'db'. If it exists, it assumes that the 'usr' will be 
added to it, and keeps the stored database parameters. If it is not found,
the values passed in @%GDKport@ and @%GDKdir@ are used.
It returns TRUE if the entry was found, FALSE if not.
@
@
The @%GDKhomeIns(usr,db,home)@ inserts a database declaration for a user in
the 'homes 'file.
@
@
The @%GDKhomeDel(users,db,home)@ deletes user entries for a database in the 
'homes' file for named users, or all entries for a database (if no user is 
named). 
@c
#else /* GDK_NOLINK */

#undef GDKmalloc
#undef GDKrealloc
#undef GDKfree

#define GDKmalloc(size)	malloc(size)
#define GDKrealloc(buf,size)	realloc(buf,size)
#define GDKfree(buf)	free(buf)
#endif

char	GDKdirStr[PATHLENGTH] = { 0 };
char	GDKserverStr[PATHLENGTH] = { 0 };
char	GDKportStr[IDLENGTH] = { 0 };
char	GDKownerStr[IDLENGTH] = { 0 };
char	GDKnameStr[IDLENGTH] = { 0 };

char	*GDKenviron[GDKPROP] = { 
	GDKnameStr, GDKserverStr, GDKportStr,
	GDKdirStr, GDKownerStr, 0 }; 

char	*GDKenvironName[GDKPROP] = {
	"dbname", "server", "port", 
	"directory", "owner", 0 }; 

#ifdef HAVE_FCNTL_H
#include <fcntl.h>
#endif

#if TIME_WITH_SYS_TIME
# include <sys/time.h>
# include <time.h>
#else
# if HAVE_SYS_TIME_H
#  include <sys/time.h>
# else
#  include <time.h>
# endif
#endif

#ifdef HAVE_PWD_H
# include <pwd.h>
#endif

#ifdef __CYGWIN32__
extern int gethostname(char *s, int len);
#endif

#ifndef HAVE_SETENV
#ifdef HAVE_PUTENV
int setenv(char *name, char *value, int overwrite) {
        int ret = 0;
        if (overwrite || getenv(name) == NULL) {
                char *p = (char*) GDKmalloc(2+strlen(name)+strlen(value));
                strcpy(p, name);
                strcat(p, "=");
                strcat(p, value);
                ret = putenv(p);
                /* GDKfree(p); */
        }
        return ret;
}
#endif
#endif

int GDKhomeScan(str usr, str db, str home) {
	int	dbpresent=0, dbcreate = (*GDKportStr && *GDKdirStr);
	char	buf[1024], *env[GDKPROP], *s;
	int	line;
@= openhome
	FILE	*fp; 
	if (!home) {
	    fprintf(stderr, "@1: no 'homes' file specified.\n");
	    exit(1);
	}
	fp = fopen(home, @2);
	if (fp == NULL) {
	    fprintf(stderr, "@1: could not open 'homes' file '%s'.\n", home);
	    exit(1);
	}
@-
Perform checks.
@c
	@:openhome(GDKhomeScan,"r")@
	if (dbcreate && !db) {
	    fprintf(stderr, "GDKhomeScan: cannot create NULL database.\n");
	    exit(1);
	}
@-
Set standard values.
@c
	gethostname(GDKserverStr, (size_t) PATHLENGTH-1); /* not read from file */
	if (usr) {
	    strcpy(GDKownerStr, usr);
	} else {
	    struct passwd *pwd;
	    pwd = getpwuid(getuid());
	    strcpy(GDKownerStr, pwd?pwd->pw_name:"guest");
	}
@-
Scan the file for db entries.
@c
#define setenv(x)	(env[x] && *env[x])
	for (line=1; (s=fgets(buf, 1024, fp)) != NULL; line++) {
		int n = GDKPROP;
		while(GDKisspace(*s)) s++;
		if (*s == 0 || *s == '#') continue;
		while(n > 1) env[--n] = 0; 
	       	env[0] = s; 
	       	while (*s && n < GDKPROP)
	       	    if (*s == '\n' || *s == '#') {
	       		*s++ = 0;
	       		break;
	       	    } else if (*s == PATH_SEP) { 
	       		*s++ = 0; 
			while(GDKisspace(*s)) s++;
	       		env[n++] = s; 
	       	    } else s++;
@-
Check minimum requirements for entry.
@c
		if (setenv(GDKdbname) == 0) {
		    fprintf(stderr, 
			"GDKhomeScan: %s, line %d:  database name missing.\n",
			home, line); continue;
		}
		if (setenv(GDKdir) == 0) {
		    fprintf(stderr,
			"GDKhomeScan: %s, line %d: directory name missing.\n",
			home, line); continue;
		}
	       	if (db && strcmp(db, env[GDKdbname])) {
			continue;
		}
@-
Partial match: collect info about this database.
@c
		dbpresent = 1;
		strcpy(GDKnameStr, env[GDKdbname]);
		strcpy(GDKdirStr,  env[GDKdir]);
		if (setenv(GDKport)) strcpy(GDKportStr, env[GDKport]);
	       	if (setenv(GDKowner) && !strcmp(GDKownerStr,env[GDKowner])) {
			break; /* total match */
		}
	}
@-
Epilogue: return whether a matching entry existed, or exit on fatal error.
@c
	(void) fclose(fp);
	if (s) {
	    return 1;
	} else if (db == NULL) { 
	    fprintf(stderr, 
		"GDKhomeScan: user '%s' has no access to any database.\n", 
		GDKownerStr); /* failure of unspecified db scan */ 
	} else if (dbcreate) {
 	    strcpy(GDKnameStr, db);
	    return 0;
	} else if (dbpresent) { 
	    fprintf(stderr, 
		"GDKhomeScan: user '%s' has no access to database '%s'.\n", 
		GDKownerStr, db); /* db exists, but not for you */
	} else { 
	    fprintf(stderr, 
		"GDKhomeScan: database '%s' not found in '%s'.\n", db, home); 
	}
	exit(1); /* fatal error */
	return 1;
}

int GDKhomeIns(str user, str db, str home) {
	@:openhome(GDKhomeIns,"a")@
	fprintf(fp, "%s%c%c%s%c%s%c%s%c\n", 
		GDKenviron[GDKdbname], PATH_SEP, PATH_SEP,
		GDKenviron[GDKport], PATH_SEP,
		GDKenviron[GDKdir], PATH_SEP,
		user?user:GDKenviron[GDKowner], PATH_SEP);
	fclose(fp);
	return 0;
}


int GDKhomeDel(str users[], str db, str home) {
	int homelines=0, i, j=0, k, lusr = 0, ldb;
	str homeline[1024];
	@:openhome(GDKhomeDel,"r+")@
@-
Read the homes file.
@c
        for(homelines=0; homelines<1024; homelines++) {
		homeline[homelines] = (str) GDKmalloc(1024);
                if (!fgets(homeline[homelines], 1024, fp)) {
                        homeline[homelines] = 0;
                        break;
                }
	}
@-
Delete all occurences of (db,user).
@c
	ldb = strlen(db);
	do {
		if (users[j]) {
		    lusr = strlen(users[j]);
		}
		for(i=0; i < homelines; i++) {
		    do {
			str s = homeline[i];
			while(GDKisspace(*s)) s++;
			if (strncmp(s, db, ldb)) continue;
			if (s[ldb] != PATH_SEP || GDKisspace(s[ldb])) continue; 
			if (users[j] == NULL) break;
			for(k=0; k < 4; s++, k++)
			    if ((s=strchr(s,PATH_SEP)) == NULL) continue;
			while(GDKisspace(*s)) s++;
			if (strncmp(s, users[j], lusr)) continue;
			if (s[lusr]==PATH_SEP || GDKisspace(s[lusr])) break; 
		    } while(++i < homelines);
		    GDKfree(homeline[i]);
		    homeline[i] = 0;
		}
	} while(users[++j]);
@-
Write the homes file.
@c
        fseek(fp, 0, SEEK_SET);
        for(i=0; i<homelines; i++) {
                if (homeline[i] == NULL) {
			continue; 
		}
		fputs(homeline[i], fp);
		GDKfree(homeline[i]);
        }
        fflush(fp);
        ftruncate(fileno(fp), ftell(fp));
	return 0;
}

@+ System logging
Per database a log file can be maintained for collection
of system management information. Its contents is driven
by the upper layers, which encode information such as
who logged on and how long the session went on.
The lower layers merely store error information on the file.
It should not be used for crash recovery, because this should be
dealt with on a per client basis.

@-
A system log can be maintained in the database to keep track
of session and crash information. It should be regulary be
refreshed to avoid disk overflow.
@c
#ifndef GDK_NOLINK
#define GDKLOCK	".gdk_lock"

static FILE* GDKlockFile = 0; 

#define GDKLOGOFF	"LOGOFF"
#define GDKFOUNDDEAD	"FOUND	DEAD"
#define GDKLOGON	"LOGON"
#define GDKCRASH	"CRASH"

#define GDKlethal(p)	(strncmp(p, GDKLOGOFF, strlen(GDKLOGOFF)) == 0 ||\
		strncmp(p, GDKCRASH, strlen(GDKCRASH)) == 0 ||\
		strncmp(p, GDKFOUNDDEAD, strlen(GDKFOUNDDEAD)) == 0) 
@-
The @%GDKcountfromLog()@ routine examines the log file, and does
a double-check with the @%MT_alive(pid)@ function in order
to count the live process groups accessing the shared arena.

@c
int GDKcountfromLog(FILE* fp) {
	int i, alive=0, n=0, user[256], process[256], thread[256];
	char *p, buf[1024];
	time_t tm = time(0);

	fseek(fp, 0, SEEK_SET);
	if (fgets(buf, 1024, fp) == NULL) {
	    fprintf(fp, "%s:%s\n", GDKenviron[GDKserver], GDKenviron[GDKport]);
	} else while (fgets(buf, 1024, fp) && (p=strchr(buf,'\@'))) {
	    *p++ = 0;
	    if (sscanf(p, " USR=%d PID=%d THR=%d",
		user+n, process+n, thread+n) != 3) continue; 
	    if (strncmp(buf, GDKLOGON, strlen(GDKLOGON)) == 0) {
		n++;
	    } else if (GDKlethal(buf)) {
		for(i=0; i < n; i++) 
		if (process[i]==process[n]) 
			{ process[i] = 0; break; }
	    }
	}
	for(i=0; i < n; i++) if (process[i]) {
	    if (MT_alive(process[i]) == 0) {
	        fprintf(fp, "%s \@ USR=%d PID=%d THR=%d TIME=%s", 
		    GDKFOUNDDEAD, user[i], process[i], thread[i], ctime(&tm));
	    } else alive++;
	}
	return alive;
}
@-
Single-lined comments can now be logged safely, together with process, thread
and user ID, and the current time.
@c
/* VARARGS */
void GDKlog(char *format, ...) {
	va_list	ap; 
	char	*p= 0, buf[1024];
	int	mustopen = GDKgetHome();
	time_t	tm = time(0);

	if (MT_system_lock == NULL) return;

	va_start (ap,format); 
	vsprintf(buf, format, ap); 
	va_end (ap); 
	if (GDKlethal(buf)) {
		GDKcountfromLog(GDKlockFile);
	} else if (mustopen) {
		fseek(GDKlockFile, 0, SEEK_END);
	}
	/* remove forbidden characters from message */
	for(p=buf; (p=strchr(p,'\n')) != NULL; *p = ' ');
	for(p=buf; (p=strchr(p,'\@')) != NULL; *p = ' ');

	fprintf(GDKlockFile, "%s \@ USR=%d PID=%d THR=%d TIME=%s", buf, 
		(int) getuid(), (int) getpid(), (int) MT_getpid(), ctime(&tm));
	fflush(GDKlockFile);

	if (mustopen) GDKunlockHome();
}

@+ Interrupt handling
The current version simply catches signals and prints a warning.
It should be extended to cope with the specifics of the interrupt
received.
@c
#include <signal.h>
void BATSIGignore(int nr) {
	GDKsyserror("! ERROR signal %d caught by thread %d\n", nr, (int) MT_getpid()); 

}

void BATSIGabort(int nr) {
	GDKfatal("signal %d caught by thread %d\n", nr, (int) MT_getpid()); 
}

void BATSIGpipe() {
	int	pid;
	int	status; 

	while ((pid = waitpid(-1, &status, WNOHANG)) > 0)
	PARDEBUG THRprintf(GDKerr, "BROKEN PIPE \n"); 
	(void) signal(SIGPIPE, (void (*)()) BATSIGpipe); 
}


int BATSIGcrash() {
	static int crash = 0;
	if (!crash++) {
		GDKlog(GDKCRASH); 
		MT_global_exit(1);
	}
	return 0;
}

int BATSIGinit() {
	(void) signal(SIGINT,  (void (*)()) BATSIGabort); 
/*
	(void) signal(SIGBUS,  (void (*)()) BATSIGcrash); 
	(void) signal(SIGSEGV, (void (*)()) BATSIGcrash); 
*/
	(void) signal(SIGPIPE, (void (*)()) BATSIGpipe); 
	(void) signal(SIGHUP,  (void (*)()) MT_exit_thread);
	return 0;
}

@+ Memory management
Memory management in GDK mostly relies on the facilities offered by the 
underlying OS.  The below routines monitor the available memory resources
which consist of physical swapspace and logical vm space.
@T
There are three kinds of memory, that affect these two resources in different ways: 
\begin{description}

\item[memory mapping] which ask for a logical region of virtual memory space.
In principal, no physical memory is needed to keep the system afloat here,
as the memory mapped file is swapped onto a disk object that already exists.

Actually, there are two kings of memory mapping used in GDK, namely 
read-only direct mapped and writeable copy-on write. For the dirty
pages, the latter actually also consumes physical memory resources, 
but that is ignored here for simplicity.

\item[anonymous virtual memory]
This is virtual memory that is mapped on the swapfile. Hence, this consumes
both logical VM space resources and physical memory space.

\item[malloced memory] 
comes from the heap and directly consumes physical memory resources.
\end{description}

We check the resource consumption with preset target values, and if these 
are exceeded, the routine BBPtrim is called that will unload the
least recently used BATs in order to decrease memory usage.

The malloc routine checks the memory consumption every 1000 calls,
or for calls larger that 50000 bytes. Consequently, at least every
50MB increase, alloc memory is checked. The VM calls always check
the memory consumption.
@c
/* default setting to administer everything */
#define GDK_MEM_NULLALLOWED
#ifdef DDI_PATCH
#define GDK_MEM_KEEPHISTO
#define GDK_VM_KEEPHISTO
#endif

#define SEG_SIZE(x,y)	((x)+(((x)&((1<<(y))-1))?(1<<(y))-((x)&((1<<(y))-1)):0))
#define MAX_BIT		((int) (sizeof(long)<<3))

#if (defined(WIN32) || defined(__sgi) || defined(_AIX))
#define GDK_MEM_BIGSIZE	LL_CONSTANT(131072)     /* offload malloc fragmentation pressure */
#else
#define GDK_MEM_BIGSIZE	LL_CONSTANT(33554432)   /* robust malloc: use up till 32MB */ 
#endif

#if SIZEOF_LONG==8
#define GDK_VM_MAXSIZE	LL_CONSTANT(137438953472) /* :-) a 64-bit OS: 128 GB */
#elif defined(WIN32) 
#define GDK_VM_MAXSIZE	LL_CONSTANT(536870912) /* :-( New Technology DOS extender: 512MB */
#else
#define GDK_VM_MAXSIZE	LL_CONSTANT(1610612736) /* :-| a 32-bit OS: 1.5GB */
#endif
	 ptr	GDK_mem_start = NULL; 
volatile lng	GDK_mem_cursize = LL_CONSTANT(0);
	 lng	GDK_mem_maxsize = LL_CONSTANT(0);
	 lng	GDK_mem_bigsize = GDK_MEM_BIGSIZE;
volatile lng	GDK_vm_cursize = LL_CONSTANT(0);
	 lng	GDK_vm_minsize = 131072;
	 lng	GDK_vm_maxsize = GDK_VM_MAXSIZE;
#ifdef GDK_VM_KEEPHISTO
	 BAT*	GDK_vm_histo = NULL;
volatile int GDK_vm_nallocbuf[MAX_BIT<<2] = { 0 };
volatile int* GDK_vm_nallocs = GDK_vm_nallocbuf;
#endif
#ifdef GDK_MEM_KEEPHISTO
	 BAT*	GDK_mem_histo = NULL;
volatile int	GDK_nmallocbuf[MAX_BIT<<2] = { 0 };
volatile int*	GDK_nmallocs = GDK_nmallocbuf;
#endif

lng GDKmem_heapsize() {
	lng heapsize = (((char*) sbrk(0)) - ((char*) GDK_mem_start));
	return (lng) SEG_SIZE(heapsize,16);
}

#ifdef GDK_MEM_SIMPLE
lng GDKmem_heapinuse() {
	/* we do not keep statistics ourselves; so we ask malloinfo */
	struct mallinfo m = MT_mallinfo();
        return (lng) (m.usmblks + m.uordblks);
}
#else 
lng	GDK_heap_inuse = LL_CONSTANT(0);

lng GDKmem_heapinuse() {
	return GDK_heap_inuse;
}
#endif

static int GDK_vm_allocs = 0;
static int GDK_mem_allocs = 0;

/* histogram update macro */
#define GDKmallidx(idx,size)\
{ int _mask;\
  if (size < 128) {\
    _mask = (1<<6);\
    idx = 7;\
  } else {\
    _mask = (1<<(MAX_BIT-1));\
    idx = MAX_BIT;\
  }\
  while(idx-- > 4) {\
        if (_mask&size) break;\
        _mask >>=1;\
  }\
  idx <<= 2;\
}

/* at least each 50M of memory increase, BBPtrim is run */
#define CHKMEM(meminc, vminc) {\
	int memchk = (meminc>LL_CONSTANT(0) && (++GDK_mem_allocs>=1000 || meminc>LL_CONSTANT(50000)));\
	int vmchk = (vminc>LL_CONSTANT(0) && (++GDK_vm_allocs>=10 || vminc>LL_CONSTANT(5000000)));\
	if (memchk || vmchk) GDKmemchk(memchk, vmchk);\
}
	
void GDKmemchk(int memchk, int vmchk) {
	lng memtarget = memchk?(GDKmem_inuse() - GDK_mem_maxsize):0;
	lng vmtarget = vmchk?(GDKvm_cursize() - GDK_vm_maxsize):0;
	MEMDEBUG {
		THRprintf(GDKerr, "GDKmemchk (memcur=%u,memmax=%u) (vmcur=%u,vmmax=%u)\n",
			(unsigned int) GDKmem_inuse(), (unsigned int) GDK_mem_maxsize, 
			(unsigned int) GDK_vm_cursize, (unsigned int) GDK_vm_maxsize);
	}
	if (memtarget < LL_CONSTANT(0)) {
		memtarget = LL_CONSTANT(0);
	}
	if (vmtarget < LL_CONSTANT(0)) {
		vmtarget = LL_CONSTANT(0);
	}
	if (memtarget > 0 || vmtarget > 0) {
		BBPtrim(memtarget, vmtarget);
	}
	GDK_mem_allocs = GDK_vm_allocs = 0;
}

void GDKmeminc(lng memdelta, lng vmdelta) {
	long segsize = (lng) SEG_SIZE(vmdelta,16);

	GDK_mem_cursize += memdelta;
#ifdef GDK_VM_KEEPHISTO
{	int idx;
        GDKmallidx(idx, segsize);
        GDK_vm_nallocs[idx]++; }
#endif
        GDK_vm_cursize += segsize;
	CHKMEM(memdelta,vmdelta);
}

void GDKmemdec(lng memdelta, lng vmdelta) {
	long segsize = (lng) SEG_SIZE(vmdelta,16);

	GDK_mem_cursize -= memdelta;
#ifdef GDK_VM_KEEPHISTO
{	int idx;
        GDKmallidx(idx, segsize);
        GDK_vm_nallocs[idx]--; }
#endif
        GDK_vm_cursize -= segsize;
}

@- Malloc 
@T
Malloc normally maps through directly to the OS provided malloc/free/realloc
calls. Where possible, we want to use the -lmalloc library on Unix systems, 
because it allows to influence the memory allocation strategy. This can prevent
fragmentation and greatly help enhance performance.

The only "added-value" of the GDKmalloc/GDKfree/GDKrealloc over the standard OS
primitives is that the GDK versions try to do recovery from failure to malloc by 
initiating a BBPtrim (to unload BAts and make space in the memory). This basic 
behaviour is obtained by defining GDK\MEM\_SIMPLE. 

A number of different strategies are available using different switches, however:
\begin{description}

\item[zero sized blocks]
Normally, GDK gives fatal errors on illegal block sizes.
This can be overridden with  GDK\_MEM\_NULLALLOWED.

\item[resource tracking]
Many malloc interfaces lack a routine that tells the size of a blobk
by the pointer. We need this information for correct malloc statistics.

Some systems (like cygnus) already store the blocksize in front of
the pointer (and do not have alignment problemes described below). In
that case, we save the overhead of redoing this ourselves by defining 
GDK\_MEM\_PREFIXSIZE.

\item[outstanding block histograms]
In order to solve the problem, we allocate extra memory in front of the 
returned block. With te resource tracking in place, we keep a total of 
allocated bytes.  Also, if GDK\_MEM\_KEEPHISTO is defined, we keep a histogram 
of the outsanding blocks on the log2 of the blocksize (similarly for virtual.
memory blocks; define GDK\_VM\_KEEPHISTO).

\item[ensuring 8-byte alignment]
While doing the resource tracking, we can in one go solve the problem
of 32-bit systems that return non-8 bytes algigned pointers. This is
encoded by storing a size + 1 (we always normalize sizes to multiples of 
8, so this is easily recognized). This check is done automatically when
GDK\_MEM\_SIMPLE is {\bf not} enabled.

\item[redirection to anonymous VM]
Sometimes, fragmentation problems arise on mallocs that are not tuneable.
In that case, it makes sense to redirect large block requests (taken to be
larger than GDK\_mem\_bigsize) to anonymous virtual memory. The seamless
implmentation of this stores the {\bf negative} blocksize in front of the
pointer (as well as the VM maxsize), so the malloc primitives can recognize
these redirected blocks.This behavior is enabled by defining GDK\_MEM\_VMREDIRECT.
\end{description}
@c
static 
void GDKmemdump() {
	struct mallinfo m = MT_mallinfo();

	THRprintf(GDKerr, "\n!mallinfo.arena = %d\n", m.arena);
	THRprintf(GDKerr, "!mallinfo.ordblks = %d\n", m.ordblks);
	THRprintf(GDKerr, "!mallinfo.smblks = %d\n", m.smblks);
	THRprintf(GDKerr, "!mallinfo.hblkhd = %d\n", m.hblkhd);
	THRprintf(GDKerr, "!mallinfo.hblks = %d\n", m.hblks);
	THRprintf(GDKerr, "!mallinfo.usmblks = %d\n", m.usmblks);
	THRprintf(GDKerr, "!mallinfo.fsmblks = %d\n", m.fsmblks);
	THRprintf(GDKerr, "!mallinfo.uordblks = %d\n", m.uordblks);
	THRprintf(GDKerr, "!mallinfo.fordblks = %d\n", m.fordblks);
#ifdef GDK_MEM_KEEPHISTO
	if (GDK_mem_histo) {	
		BUN p,q;
		THRprintf(GDKerr, "!memory histogram\n");
		BATloop(GDK_mem_histo, p, q) {
			THRprintf(GDKerr, "! %d %d\n", 
				*(int*) BUNhloc(GDK_mem_histo,p), 
				*(int*) BUNtloc(GDK_mem_histo,p));
		}
	}
#endif
#ifdef GDK_MEM_KEEPHISTO
	if (GDK_vm_histo) {	
		BUN p,q;
		THRprintf(GDKerr, "\n!virtual memory histogram\n");
		BATloop(GDK_vm_histo, p, q) {
			THRprintf(GDKerr, "! %d %d\n", 
				*(int*) BUNhloc(GDK_vm_histo,p), 
				*(int*) BUNtloc(GDK_vm_histo,p));
		}
	}
#endif
}

static
void GDKmemfail(str s, int len, lng memtarget, lng vmtarget) {
	int bak = GDKdebug;

	/* bumped your nose against the wall; try to prevent repetition by adjusting maxsizes */
	if (memtarget) {
		lng newmax = 0.7 * GDKmem_inuse();
		if (newmax < GDK_mem_maxsize) GDK_mem_maxsize = newmax;
	}
	if (vmtarget) {
		lng newmax = 0.7 * GDKvm_cursize();
		if (newmax < GDK_vm_maxsize) GDK_vm_maxsize = newmax;
	}

        if (GDKthreadLock) MT_set_lock(GDKthreadLock, "GDKmemfail");
	THRprintf(GDKerr, "%s(%d) fail => BBPtrim(enter) usage[mem=%u,vm=%u]\n", s, len, 
			(unsigned int) GDKmem_inuse(), (unsigned int) GDKvm_cursize());
	GDKmemdump();
	GDKdebug |= 4;
        if (GDKthreadLock) MT_unset_lock(GDKthreadLock, "GDKmemfail");

        BBPtrim(memtarget, vmtarget);

        if (GDKthreadLock) MT_set_lock(GDKthreadLock, "GDKmemfail");
	GDKdebug = MIN(GDKdebug,bak);
	THRprintf(GDKerr, "%s(%d) fail => BBPtrim(ready) usage[mem=%u,vm=%u]\n", s, len, 
			(unsigned int) GDKmem_inuse(), (unsigned int) GDKvm_cursize());
	GDKmemdump();
        if (GDKthreadLock) MT_unset_lock(GDKthreadLock, "GDKmemfail");
}


#if defined(GDK_MEM_PREFIXSIZE) || defined(GDK_MEM_SIMPLE)
#define GDKmalloc_prefixsize(s,size) 					\
	s = (long*) malloc(size)
#else
#define GDKmalloc_prefixsize(s, size) {					\
	long realsize = size + ((size&3)?12-(size&3):8);		\
	char *p = (char *) malloc((size_t) realsize);			\
	if (p == NULL) {						\
		s = NULL;						\
	} else if (((long) p) & 4) { /* misaligned */			\
		s = (long*) (p + 4); /* place 4 bytes before it */ 	\
		s[-1] = realsize + 1;  /* 1 is a marker */		\
	} else {							\
		s = (long*) (p + 8); /* place 8 bytes before it */ 	\
		s[-1] = realsize;					\
	}								\
}
#endif

void* GDKmalloc(size_t size) {
	long *s;

#ifdef GDK_MEM_NULLALLOWED
        if (size == 0) {
		return NULL;
	}
#endif
        if (size <= 0) {
                GDKfatal("GDKmalloc called with size %u", size);
        }
	CHKMEM(((lng)size),LL_CONSTANT(0));

#ifdef GDK_MEM_VMREDIRECT
	if (size > GDK_mem_bigsize) {
		long maxsize = (size += 16);
		char *p = (char*) GDKvmalloc((size_t) size, (size_t*) &maxsize);
		s = (long*) (p + 16);
		s[-2] = maxsize;
		s[-1] = -((long) size);
	} else 
#endif
	GDKmalloc_prefixsize(s, size);

       	if (s == NULL) {
		GDKmemfail("GDKmalloc", size, BBPTRIM_ALL, 0);
		GDKmalloc_prefixsize(s, size);
		if (s == NULL) { 
               		GDKfatal("GDKmalloc failed for %u bytes",size);
		} else {
			THRprintf(GDKerr, "GDKmalloc: recovery ok. Continuing..\n");
		}
	}
#ifndef GDK_MEM_SIMPLE
{	long realsize = s[-1];
	if (realsize > 0) {	
#ifdef GDK_MEM_KEEPHISTO
		int idx;
		GDKmallidx(idx, realsize);
		GDK_nmallocs[idx]++; 
#endif
		GDK_heap_inuse += realsize;
	}}
#endif
        return (void*) s;
}
 
void GDKfree (void *blk) {
	long size, *s = (long*) blk;

        if (s == NULL) return;
	size = s[-1];
	if (size > 0) {
#ifdef GDK_MEM_KEEPHISTO
		int idx;
		GDKmallidx(idx,size);
		GDK_nmallocs[idx]--;
/*		if (GDK_mallocs[idx]-- <= 0) {
			GDKwarning("free(%p): unused pointer\n", blk);
		} else */
#endif
		GDK_heap_inuse -= size; 
	}
#ifdef GDK_MEM_VMREDIRECT
	if (size < 0) {
		long maxsize = s[-2];
		size = -size;
		GDKvmfree(((char*) s)- 16, (size_t) size, (size_t) maxsize);
	} else
#endif
#ifndef GDK_MEM_PREFIXSIZE
	if (size&1) {
		free(((char*) s) - 4);
	} else {
		free(((char*) s) - 8);
	}
#else
	free(blk);
#endif
}

ptr GDKrealloc(void* blk, size_t size) {
        if (blk == NULL) {
		return GDKmalloc(size);
	}
#ifdef GDK_MEM_NULLALLOWED
        if (size == 0) {
		GDKfree(blk);
		return NULL;
	}
#endif
        if (size <= 0) {
                GDKfatal("GDKrealloc called with size %u", size);
        }
#ifdef GDK_MEM_SIMPLE
        CHKMEM(((lng)size),LL_CONSTANT(0));
        blk = realloc(blk, size);
#else
{       long cpysize, *s = (long*) blk;
        long oldsize = s[-1];
#ifdef GDK_MEM_VMREDIRECT
	if (oldsize < 0) {
		cpysize = MIN(((long) size), (-oldsize) - 16);
	} else 
#endif
#ifdef GDK_MEM_PREFIXSIZE
	cpysize = MIN(((long) size), oldsize);
#else
	if (oldsize&1) {
		cpysize = MIN(((long) size), oldsize - 5);
	} else {
		cpysize = MIN(((long) size), oldsize - 8);
	}
#endif
	/* the bad news is that the alignment problems on 32-bit systems prevent us from using realloc 
         * the good news is that we know our block sizes; so we can at least copy it to the new location
         */
        blk = (void* ) GDKmalloc(size);
        memcpy(blk, s, cpysize);
        GDKfree(s);
}
#endif
        return blk;
}

char *GDKstrdup(char *s) {
        int l = strLen(s);
        char *n = (char *) GDKmalloc(l);
        memcpy(n,s, l);
        return n;
}
 

@- virtual memory
allocations affect only the logical VM resources.
@c
void *GDKmmap(char* path, int mode, size_t off, size_t len, void *fixed) {
        void *ret = MT_mmap(path, mode, off, len, fixed);
        if (ret == (void*) -1) {
		GDKmemfail("GDKmmap", len, 0, BBPTRIM_ALL);
        	ret = MT_mmap(path, mode, off, len, fixed);
        	if (ret != (void*) -1) {
		    THRprintf(GDKerr, "GDKmmap: recovery ok. Continuing..\n");
		}
	}
        if (ret != (void*) -1) {
        	GDKmeminc(len, len);
        }
        return (void*) ret;
}

int GDKmunmap(void* addr, size_t size) {
        int ret = MT_munmap(addr, size);
        if (ret == 0) {
                GDKmemdec(size, size);
        }
        return ret;
}

 
@- VM alloc
this affects both physical and logical memory resources.
@c
void* GDKvmalloc(size_t size, size_t *maxsize) {
	void *ret = MT_vmalloc(size, maxsize);
        if (ret == NULL) {
		GDKmemfail("GDKvmalloc", size, BBPTRIM_ALL, BBPTRIM_ALL);
		ret = MT_vmalloc(size, maxsize);
		if (ret != NULL) {
			THRprintf(GDKerr, "GDKvmalloc(%d): recovery ok. Continuing..\n", size);
		}
	}
        if (ret != NULL) {
                GDKmeminc(size, *maxsize);
	}
	return ret;
}

void* GDKvmrealloc(void* pold, size_t oldsize, size_t newsize, size_t oldmax, size_t *maxsize) {
	void *ret = MT_vmrealloc(pold, oldsize, newsize, maxsize);
        if (ret == NULL) {
		GDKmemfail("GDKvrealloc", newsize, BBPTRIM_ALL, BBPTRIM_ALL);
		ret = MT_vmrealloc(pold, oldsize, newsize, maxsize);
		if (ret != NULL) {
			THRprintf(GDKerr, "GDKvmrealloc(%d): recovery ok. Continuing..\n", newsize);
		}
	}
        if (ret != NULL) {
                GDKmemdec(oldsize,oldmax);
                GDKmeminc(newsize,*maxsize);
	}
	return ret;
}

void GDKvmfree(void* blk, size_t size, size_t maxsize){
	MT_vmfree(blk, maxsize);
	GDKmemdec(size, maxsize);
}

@+ Session Initialization
GDK parameters often come directly from the command line.
Meaningful parameters are identified and processed.
The parameter @%home@ is followed by the database home.
The parameter @%db@ is followed by the database name.
The parameter @%recover@ removes any pending lock file.

The interface code to the operating system is highly dependent on
the processing environment. It can be filtered away with compiletime flags.
Suicide is necessary due to some system implementation errors.

The kernel requires file descriptors for I/O with the user.
They are thread specific and should be obtained by a function.

The arguments relevant for the kernel are extracted from the list. 
The remaining numner of unparsed arguments is returned.
@c
#ifndef HAVE_TM_ZONE
int GDKtime_zero = 0;
#else
struct timezone GDKtime_zero = { 0 };
#endif
int GDKtime_startsec, GDKrecovery = 0; 

int GDKinit(int argc, char** argv) {
	extern int errno; 
	struct timeval tp;
	int 	i;
	str 	usr = 0; 
	str 	home = 0; 
	str 	db = 0; 

	MT_seterrno(0); 
	for (i = 0; i < argc; i++) {
		if (argv[i][0] != '-')
			continue;
		switch(argv[i][1]) {
		case 'd': if (strcmp("-db", argv[i]) == 0) 
				db = argv[++i]; 
			break; 
		case 'h': if (strcmp("-home", argv[i]) == 0) 
				home = argv[++i]; 
			break; 
		case 'r': if (strcmp("-recover", argv[i]) == 0)
				GDKrecovery = 1; 
			break;
		case 'u': if (strcmp("-user", argv[i]) == 0)
				usr = argv[++i]; 
			break;
		}
	}
	PROPDEBUG GDKdebug |= 2; 
	GDKhomeScan(usr, db, home); 
	MT_init_posix();
	THRinit();
	BATSIGinit(); 
	GDKlockHome(); 

	/* init time */
	gettimeofday(&tp, &GDKtime_zero);
	GDKtime_startsec = tp.tv_sec;

	if (GDK_mem_start == NULL) {
		GDK_mem_start = (ptr) sbrk(0); 
	}
	GDKthreadLock = MT_create_lock(); 
	for(i=0; i<= BBPLOCKMASK; i++) {
		GDKswapLock[i] = MT_create_lock(); 
		GDKidxLock[i] = MT_create_lock(); 
		GDKhashLock[i] = MT_create_lock(); 
	}
	GDKcacheLock = MT_create_lock(); 
	GDKtrimLock = MT_create_lock(); 

	/* Mserver intends to rob 85% of all memory as a default */
 	GDK_mem_maxsize = ((lng) MT_npages()) * ((lng) MT_pagesize())*0.85; 

	GDKremovedir(DELDIR);  
	BBPinit(); 
#ifdef GDK_MEM_KEEPHISTO
	GDK_mem_histo = BATnew(TYPE_lng,TYPE_int,MAX_BIT);
	BATrename(GDK_mem_histo, "monet_histo_mem");
	BATmode(GDK_mem_histo, TRANSIENT);
	for(i=3; i<22; i++) {
		lng j = 1<<i;
		BUNins(GDK_mem_histo, (ptr)&j, (ptr)(GDK_nmallocs+(4*i)));
	}
        BATfakeCommit(GDK_mem_histo);
	GDK_nmallocs = ((int*) GDK_mem_histo->batBuns->base) - 6;
#endif
#ifdef GDK_VM_KEEPHISTO
#ifdef __CYGWIN32__
	GDKmallidx(i, 67108864);
	GDK_vm_nallocs[i]++; 
#endif
	GDK_vm_histo = BATnew(TYPE_lng,TYPE_int,MAX_BIT);
	BATrename(GDK_vm_histo, "monet_histo_vm");
	BATmode(GDK_vm_histo, TRANSIENT);
	for(i=12; i<31; i++) {
		lng j = 1<<i;
		BUNins(GDK_vm_histo, &j, GDK_vm_nallocs+(4*i));
	}
	BATfakeCommit(GDK_vm_histo);
	GDK_vm_nallocs = ((int*) GDK_vm_histo->batBuns->base) - 42; 
#endif
	return 0; 
}

@- 
Upon closing the session, all persistent BATs should be saved and
the transcient BATs should be removed.
The buffer pool manager takes care of this.
@c
int GDKstopped = 1;

void GDKexit() {
        if (GDKthreadLock) MT_set_lock(GDKthreadLock, "GDKexit");
        if (GDKstopped == 0) {
                GDKstopped++; /* shouldn't there be a lock here? */
                GDKnrofthreads = 0;
                if (GDKthreadLock) MT_unset_lock(GDKthreadLock, "GDKexit");
		(void) GDKgetHome();
		BBPexit(); 
		GDKlog(GDKLOGOFF);
		GDKunlockHome(); 
		MT_global_exit(0); 
	} 
	if (GDKthreadLock) MT_unset_lock(GDKthreadLock, "GDKexit");
}

@
All semaphores used by the application should be mentioned here.
They are initialized during system initialization.
@c
int		GDKdebug = 2; 

MT_Lock		GDKthreadLock = NULL; 
MT_Lock		GDKswapLock[BBPLOCKMASK+1]; 
MT_Lock		GDKidxLock[BBPLOCKMASK+1]; 
MT_Lock		GDKhashLock[BBPLOCKMASK+1]; 
MT_Lock		GDKcacheLock, GDKtrimLock; 

@+ Concurrency control
Concurrency control requires actions at several levels of the system.
First, it should be ensured that each database  is controlled by a single
server process (group). Subsequent attempts should be stopped.
This is regulated throught file locking against ".gdk_lock".
Furthermore, the server process is moved to the database directory
for improved speed.
@c
@-
Before the locks and threads are initiated, we cannot use the 
normal routines yet. So we have a local fatal here instead of GDKfatal. 
@c
void GDKlockHome() {
	char *p=0, buf[1024], host[PATHLENGTH];
	int first=1, fd;
@-
Go there and obtain the global database lock.
@c
	if (chdir(dbhome) < 0 ){
	    GDKfatal("GDKlockHome: could not move to %s\n", dbhome);
	}
	if (GDKrecovery  && unlink(GDKLOCK) < 0) {
	    GDKfatal("GDKlockHome: unlock DB failed\n"); 
	}
	umask(0000);
	fd = open(GDKLOCK, O_CREAT|O_RDWR, 0662);
	if ((fd < 0) || !(GDKlockFile = fdopen(fd, "rb+")))  {
	    GDKfatal("GDKlockHome: Could not open %s\n", GDKLOCK); 
	}
	if (lockf(fileno(GDKlockFile), F_TLOCK, 1) < 0) {
	    GDKlockFile = 0;
	    GDKfatal("GDKlockHome: Database lock '%s' denied\n", GDKLOCK); 
	}
	if (fgets(buf, 1024, GDKlockFile) && (p=strchr(buf, ':'))) *p = 0;
	if (p) {
	    sprintf(host, " from '%s'", buf);
	} else {
	    GDKwarning("GDKlockHome: ignoring empty or invalid %s.\n", GDKLOCK);
	    host[0] = 0;
	}
@-
We have the lock, are the only process currently allowed in this section.
@c
	MT_init();
	strHeap(&str_smallHeap, 1);
	OIDinit();
@-
Print the new process list in the global lockfile.
@c
	if (first) {
	    fseek(GDKlockFile, 0, SEEK_SET);
	    sprintf(buf, " %s:%s\n", GDKenviron[GDKserver], GDKenviron[GDKport]);
	    fputs(buf, GDKlockFile);
	    ftruncate(fileno(GDKlockFile), strlen(buf));
	}
	GDKlog(GDKLOGON);
@-
In shared mode, we allow more parties to join. Release the lock. 
@c
	GDKstopped = 0;
}

void GDKunlockHome() {
	if (GDKlockFile) {
		fseek(GDKlockFile, 0, SEEK_SET);
		lockf(fileno(GDKlockFile), F_ULOCK, 1); 
		fclose(GDKlockFile); GDKlockFile = 0; 
	}
}
@-
Really really get the lock. Now!!
@c
int GDKgetHome() {
	if (GDKlockFile) return 0;
	if (MT_system_lock==NULL) return 0;
	while ((GDKlockFile = fopen(GDKLOCK, "r+")) == NULL) {
		GDKerror("GDKgetHome: PANIC on open %s. sleep(1)\n", GDKLOCK);
		sleep(1);
	}
	if (lockf(fileno(GDKlockFile), F_TLOCK, 1) < 0){
		GDKwarning("GDKgetHome: blocking on lock '%s'.\n", GDKLOCK);
		lockf(fileno(GDKlockFile), F_LOCK, 1);
	}
	return 1;
}

@+ Error handling
Errors come in three flavors: warnings, non-fatal and fatal errors.
A fatal error leaves a core dump behind after trying to
safe the content of the relation.
A non-fatal error returns a message to the user
and aborts the current transaction.
Fatal errors are also recorded on the system log for post-mortem
analysis.
@c
int GDKsilent = 0;

void GDKaddbuf(char *message) {
	char *buf = GDKerrbuf;

	if (buf) {
		char *dst = buf + strlen(buf);
		int maxlen = GDKMAXERRLEN - (dst - buf);
		strncpy(dst, message, maxlen);
		dst[maxlen - 1] = '\0';
	} else if (!GDKsilent) {
                THRprintf(GDKerr, message); 
	}
}

/*VARARGS*/
int GDKwarning(char *format, ...) {
	char message[GDKMAXERRLEN];	
	va_list ap; 

	strcpy(message, GDKWARNING);
	va_start(ap, format); 
	vsprintf(message + strlen(GDKWARNING), format, ap); 
	va_end (ap); 

	GDKaddbuf(message);

	return 0;
}


/*VARARGS*/
int GDKerror(char *format, ...) {
	char message[GDKMAXERRLEN];	
	va_list ap; 

	strcpy(message, GDKERROR);
	va_start(ap, format); 
	vsprintf(message + strlen(GDKERROR), format, ap); 
	va_end(ap); 

	GDKaddbuf(message);

	return 0;
}

/*VARARGS*/
int GDKsyserror(char *format, ...)
{
	char message[GDKMAXERRLEN];	

	int	err = MT_geterrno(); 
	va_list ap; 

	strcpy(message, GDKERROR);
	va_start(ap,format); 
	vsprintf(message + strlen(GDKERROR), format, ap); 
	va_end(ap); 
	if (err > 0 && err < 1024) {
		strcat(message, GDKMESSAGE);
		strcat(message, strerror(err)); 
		strcat(message, "\n"); 
	}
	GDKaddbuf(message);

	MT_seterrno(0); 
	return err;
}

/*VARARGS*/
int GDKfatal(char *format, ...) {
	char message[GDKMAXERRLEN];	
	va_list ap; 
	FILE *fd=stderr;

	GDKdebug |= 16;
	BATSIGinit();	
	strcpy(message, GDKFATAL);
	va_start(ap, format); 
	vsprintf(message, format, ap); 
	va_end(ap); 
	if (GDKsilent == 0) {
            fputs(message, fd); 
	    fputs("\n", fd);
            fflush(fd); 
	}
@-
Real errors should be saved in the lock file for post-crash inspection.
@c
	if (GDKstopped) {
        	fflush(stderr);
		MT_exit_thread(1);
        	/* exit(1); */
	} else {
		GDKlog(message);
#ifdef COREDUMP
        	abort(); 
#else
        	GDKexit(); 
	}
#endif
	return -1;
}

@- Timers
The following relative timers are available for inspection.
Note that they may consume recognizable overhead.
@c

lng GDKusec() {
	struct timeval tp;
	gettimeofday(&tp, &GDKtime_zero);
        return ((lng) (tp.tv_sec-GDKtime_startsec))*
		LL_CONSTANT(1000000) + (lng) tp.tv_usec;
}


int GDKms() {
	struct timeval tp;
	gettimeofday(&tp, &GDKtime_zero);
        return (tp.tv_sec-GDKtime_startsec)*1000 + tp.tv_usec/1000;
}

int GDKcsec() {
	struct timeval tp;
	gettimeofday(&tp, &GDKtime_zero);
        return (tp.tv_sec-GDKtime_startsec)*100 + tp.tv_usec/10000;
}


int GDKsec() {
	struct timeval tp;
	gettimeofday(&tp, &GDKtime_zero);
	return tp.tv_sec - GDKtime_startsec;
}


@+ Logical Thread management

All semaphores used by the application should be mentioned here.
They are initialized during system initialization.

@- 
The first action upon thread creation is to add it to the pool
of known threads. This should be done by the thread itself.
Subsequently, the thread descriptor can be obtained usign @%THRget@.
Note that the users should have gained exclusive access already.
A new entry is initialized automatically when not found.
Its file descriptors are the same as for the server and should be
subsequently reset.
@c
int		GDKnrofthreads; 
ThreadRec 	GDKthreads[THREADS]; 
void *		THRdata[THREADDATA] = { 0 };

Thread THRget(MT_Id tid) {
	return (GDKthreads+(int)tid-1);
}

static INLINE 
unsigned long THRsp(){
	int l = 0;
	unsigned long sp = (unsigned long)(&l);
	
	return sp;
}

Thread THRnew(MT_Id pid, str name) {
	MT_Id tid = 0;
 	Thread 	t;
	Thread	s; 

	MT_set_lock(GDKthreadLock, "THRnew"); 
	for (s = GDKthreads, t = s + THREADS; s < t; s++) {
		if (s->pid == pid) {
			MT_unset_lock(GDKthreadLock, "THRnew"); 
			GDKwarning("THRnew:duplicate %d\n", pid); 
			return s; 
		}
	}
	for (s = GDKthreads, t = s + THREADS; s < t; s++) {
		if (s->pid == 0) {
			break; 
		}
	}
	if (s == t) {
		MT_unset_lock(GDKthreadLock, "THRnew"); 
		GDKfatal("THRnew:too many threads\n"); 
	}

	tid = s->tid;
	memset((char*) s, 0, sizeof(*s)); 
	s->pid = pid; 
	s->tid = tid;
	s->data[1] = stdin; 
	s->data[0] = stdout; 
	s->name = name; 
	s->cleanup = NULL;
	s->sp = THRsp();
	PARDEBUG THRprintf(GDKerr, "%lu sp = %lu\n", 
			(unsigned long) s->tid, (unsigned long) pid, s->sp); 
	PARDEBUG THRprintf(GDKerr, "nrofthreads %d\n", GDKnrofthreads); 
	GDKnrofthreads++; 
	MT_unset_lock(GDKthreadLock, "THRnew"); 

	return s; 
}

void THRdel(Thread t) {	
	if (t < GDKthreads || t > GDKthreads + THREADS) {
		GDKfatal("THRdel\n"); 
	}
	MT_set_lock(GDKthreadLock, "THRdel"); 
	if (t->cleanup) {
		(*t->cleanup)(t);
	}
	PARDEBUG 
	THRprintf(GDKerr, "pid = %lu, disconnected, %d left\n", 
		(unsigned long) t->pid, GDKnrofthreads); 
	t->pid = 0; 
	GDKnrofthreads--; 
	MT_unset_lock(GDKthreadLock, "THRdel"); 
}
@- 
The easiest way to terminate a thread is to identify its name
A zero is returned when the thread could not be found
@c
static Thread GDK_find_thread(MT_Id pid){
   	Thread t, s;
	for (t = GDKthreads, s = t + THREADS; t < s; t++) {
		if (t->pid && t->pid == pid ){
			return t; 
		}
	}
   	return NULL;
}

int THRexit(str nme) {
	Thread	t;
	Thread	s; 

	for (t = GDKthreads, s = t + THREADS; t < s; t++) {
		if (t->pid && t->name && strcmp(t->name, nme) == 0) {
			MT_Id victim = t->pid; 
			THRdel(t); 
			MT_kill_thread(victim); 
			return 1; 
		}
	}
	return 0; 
}

int THRcnt() {
	return GDKnrofthreads; 
}

int THRhighwater() {
	unsigned long c = THRsp();
	Thread s = GDK_find_thread(MT_getpid());
	unsigned long diff = (c<s->sp)?s->sp-c:c-s->sp;
	if (diff > (THREAD_STACK_SIZE-1024)){
		return 1;
	}
	return 0;
}

@{
@- 
I/O is organized per thread, because users may gain access through
the internet.
The code below should be improved to gain speed.
@c

int THRinit() {
	int i = 0;
	THRdata[0] = (void*) stdout;
	THRdata[1] = (void*) stdin;
	for ( i = 0; i<THREADS; i++ ){
		GDKthreads[i].tid = (MT_Id)(i+1);
	}
	return 0;
}

void THRsetdata(int n, ptr val) {
	Thread s = GDK_find_thread(MT_getpid());
	if (s) s->data[n] = val;
}

void*  THRgetdata(int n) {
	Thread s = GDK_find_thread(MT_getpid());
	return (s?s->data[n]:THRdata[n]);
}

MT_Id THRgettid(){
	Thread s = GDK_find_thread(MT_getpid());
	return (s?s->tid:(MT_Id)1);
}

static char THRprintbuf[1024];

/*VARARGS*/
int THRprintf(FILE *fp, char *format, ...) {
	str p = THRprintbuf; 
        va_list ap;
	*p = 0;
	if (MT_system_lock) {
		MT_set_lock(MT_system_lock, "THRprintf");
	}
	if (*format != '!') {
	        *p++ = '#';
	} else {
	        *p++ = '!'; format++;
	}
	if (GDKdebug&1) {
		sprintf(p, "%02d ", (int) THRgettid());
		while(*p) p++;
	}
        va_start (ap,format);
               vsprintf (p, format, ap);
        va_end (ap);
	fputs(THRprintbuf, fp);
	fflush(fp);
	if (MT_system_lock) {
		MT_unset_lock(MT_system_lock, "THRprintf");
	}
        return 0;
}

#endif
