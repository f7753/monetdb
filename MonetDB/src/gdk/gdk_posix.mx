@f gdk_posix
@a Niels Nes, Peter Boncz
@* System Independent Layer

GDK is built on POSIX. Exceptions are made for memory mapped files and 
anonynmous
virtual memory, for which somewhat higher-level functions are defined 
here.

Most of this file concerns itself with emulation POSIX functionality on 
the WIN32 native platform.
@h
#ifndef GDK_POSIX_H
#define GDK_POSIX_H

#include "gdk_system.h"

#ifdef HAVE_CONFIG_H 
#include "config.h"
#endif

#include <sys/types.h>

#ifdef HAVE_MALLOC_H
# include <malloc.h>	/* mallopt, mallinfo, and  malloc, free etc. */
#endif

#if TIME_WITH_SYS_TIME
# include <sys/time.h>
# include <time.h>
#else
# if HAVE_SYS_TIME_H
#  include <sys/time.h>
# else
#  include <time.h>
# endif
#endif

#ifdef HAVE_NOMALLINFO
#define M_MXFAST	1  /* set size of blocks to be fast */
#define M_NLBLKS	2  /* set number of block in a holding block */
#define M_GRAIN		3  /* set number of sizes mapped to one, for */
                           /* small blocks */
#define M_KEEP		4  /* retain contents of block after a free */
                           /* until another allocation */
struct mallinfo  {
        int arena;      /* total space in arena */
        int ordblks;    /* number of ordinary blocks */
        int smblks;     /* number of small blocks */
        int hblks;      /* number of holding blocks */
        int hblkhd;     /* space in holding block headers */
        int usmblks;    /* space in small blocks in use */
        int fsmblks;    /* space in free small blocks */
        int uordblks;   /* space in ordinary blocks in use */
        int fordblks;   /* space in free ordinary blocks */
        int keepcost;   /* cost of enabling keep option */
};
typedef struct mallinfo mallinfo_t;

#define mallopt(cmd,value)	0
#endif

#define NOMALLOPT

#ifndef WIN32
#define DIR_SEP '/' 
#define DIR_SEP_STR "/" 
#else /* WIN32 native */
#define DIR_SEP '\\' 
#define DIR_SEP_STR "\\" 
#endif 

/* the new mmap modes, mimick default MADV_* madvise POSIX constants */
#define MMAP_NORMAL     	0               /* no further special treatment */
#define MMAP_RANDOM     	1               /* expect random page references */
#define MMAP_SEQUENTIAL 	2               /* expect sequential page references */
#define MMAP_WILLNEED   	3               /* will need these pages */
#define MMAP_DONTNEED   	4               /* don't need these pages */

#define MMAP_READ		1024		/* region is readable (default if ommitted) */
#define MMAP_WRITE		2048		/* region may be written into */
#define MMAP_COPY		4096		/* writable, but changes never reach file */
#define MMAP_ASYNC		8192		/* asynchronous writes (default if ommitted) */
#define MMAP_SYNC		16384		/* writing is done synchronously */ 

/* in order to be sure of madvise and msync modes, pass them to mmap() call as well */

extern void* MT_mmap(char *path, int mode, size_t off, size_t len, void *fixed);
extern int   MT_munmap(void* p, size_t off);
extern int   MT_msync(void* p, size_t len, int mode);
extern int   MT_madvise(void* p, size_t len, int advise);

extern void *MT_vmalloc(size_t size, size_t *maxsize);
extern void  MT_vmfree(void *p, size_t size);
extern void *MT_vmrealloc(void *voidptr, size_t oldsize, size_t newsize, size_t *maxsize);

extern struct mallinfo MT_mallinfo();

#ifdef WIN32
#define RTLD_LAZY	1
#define RTLD_NOW	2
#define RTLD_GLOBAL	4

extern void *dlopen  (const char *__file, int __mode);
extern int dlclose   (void *__handle);
extern void *dlsym   (void * __handle, const char * __name);
extern char *dlerror (void);

extern int win_ftruncate (int  fd, unsigned int size);
extern DIR* win_opendir (const char *dirname);
extern struct direct* win_readdir (DIR *dir);
extern void win_rewinddir (DIR *dir);
extern int win_closedir (DIR *dir);

#include <winsock.h>
extern int MT_gettimeofday(struct timeval *tv, int *ignore_zone); 
#define gettimeofday(x,y)	MT_gettimeofday(x,y)
#endif

#endif /* GDK_POSIX_H */
@c
#include "gdk_posix.h"

#include <stdio.h>
#ifdef HAVE_SYS_MMAN_H
#include <sys/mman.h>
#endif
#ifdef HAVE_FCNTL_H
#include <fcntl.h>
#endif

#ifndef HAVE_MADVISE
# define madvise(x,y,z)	0
# ifndef MADV_RANDOM
#  define MADV_RANDOM	0
# endif
#endif 

#define MMAP_ADVISE		7
#define MMAP_WRITABLE		(MMAP_WRITE|MMAP_COPY)

#ifndef WIN32

#ifndef MAP_NORESERVE
#define MAP_NORESERVE MAP_PRIVATE
#endif 

#define MT_PAGESIZE(s)  ((((s-1)/MT_pagesize())+1)*MT_pagesize())

void* MT_mmap(char *path, int mode, size_t off, size_t len, void *fixed){
	FILE *fp = fopen(path, (mode&MMAP_WRITABLE)?"rb+":"rb" );
	void *ret = (void*) -1;
	if (fp) {
	    ret = mmap(fixed, len, 
		((mode&MMAP_WRITABLE)?PROT_WRITE:0)|PROT_READ, 
		((mode&MMAP_COPY)?MAP_PRIVATE:MAP_SHARED)|(fixed?MAP_FIXED:0),
	        fileno(fp), off);
	    fclose(fp);
	    if (ret != (void*) -1 && (mode&MMAP_ADVISE)) {
		madvise(fixed+off, len, mode&MMAP_ADVISE);
	    }
        }
	return ret;
}

int MT_munmap(void* p, size_t off) {
	return munmap(p, off);
} 

int MT_msync(void* p, size_t len, int mode) {
	return msync(p, len, (mode&MMAP_SYNC)?MS_SYNC:MS_ASYNC);
} 

int MT_madvise(void* p, size_t len, int advise) {
	return madvise(p, len, advise); 
}

void *MT_vmalloc(size_t size, size_t *maxsize) {
        int fd = open("/dev/zero", O_RDWR, 0666);
        char *q, *r = (char*) -1;

        if (fd < 0) {
                return NULL;
        }
        size = MT_PAGESIZE(size);
        *maxsize = MT_PAGESIZE(*maxsize);
        if (*maxsize > size) {
                r = (char*) mmap(NULL, *maxsize, PROT_NONE, 
				MAP_PRIVATE|MAP_NORESERVE, fd, 0);
        }
        if (r == (char*) -1) {
                *maxsize = size;
                q = (char*) mmap(NULL, size, PROT_READ|PROT_WRITE, 
				MAP_PRIVATE, fd, 0);
        } else {
                q = (char*) mmap(r, size, PROT_READ|PROT_WRITE, 
				MAP_PRIVATE|MAP_FIXED, fd, 0);
        }
        close(fd);
        return (void*) (q == (char*) -1)?NULL:q;
}

void MT_vmfree(void *p, size_t size) {
        size = MT_PAGESIZE(size);
        munmap(p, size);
}

void *MT_vmrealloc(void *voidptr, size_t oldsize, size_t newsize, size_t *maxsize) {
        char *p=(char*)voidptr;
        char *q = (char*) -1;

        oldsize = MT_PAGESIZE(oldsize);
        newsize = MT_PAGESIZE(newsize);
        *maxsize = MT_PAGESIZE(*maxsize);

        if (oldsize > newsize) {
                munmap(p+oldsize, oldsize-newsize);
        }
        if (oldsize >= newsize) {
                return p;
        }
        if (newsize < *maxsize) {
                int fd = open("/dev/zero", O_RDWR, 0666);
                if (fd >= 0) {
                        q = (char*) mmap(p+oldsize, newsize-oldsize,
                                PROT_READ|PROT_WRITE,
                                MAP_PRIVATE|MAP_FIXED, fd, oldsize);
                        close(fd);
                }
        }
        if (q == (char*) -1) {
                int oldmaxsize = *maxsize;
                q = p; p = (char*) MT_vmalloc(newsize, maxsize);
                if (p != NULL) {
                        memcpy(p, q, oldsize);
                        MT_vmfree(q, oldmaxsize);
                }
        }
        return p;
}

struct mallinfo 
MT_mallinfo(){
	return mallinfo();
}

#else /* WIN32 native */
#include <windows.h>

#define MT_PAGESIZE(s)		(((((s)-1) >> 12) + 1) << 12)
#define MT_SEGSIZE(s)		((((((s)-1) >> 16) & 65535) + 1) << 16)

void* MT_mmap(char *path, int mode, size_t off, size_t len, void* fixed) {
	void *ret = NULL;
	int mode0 = GENERIC_READ;
	int mode1 = FILE_SHARE_READ;
	int mode2 = mode & MMAP_ADVISE;
	int mode3 = PAGE_READONLY;
	int mode4 = FILE_MAP_READ;
        SECURITY_ATTRIBUTES sa;
        HANDLE h1, h2;

	if (mode & MMAP_WRITABLE) {
		mode0 |= GENERIC_WRITE;
		mode1 |= FILE_SHARE_WRITE;
	}
        if (mode2 == MMAP_RANDOM || mode2 == MMAP_DONTNEED) {
                mode2 = FILE_FLAG_RANDOM_ACCESS;
        } else if (mode2 == MMAP_SEQUENTIAL || mode2 == MMAP_WILLNEED) {
                mode2 = FILE_FLAG_SEQUENTIAL_SCAN;
        } else {
                mode2 = FILE_FLAG_NO_BUFFERING;
        }
	if (mode & MMAP_SYNC) {
		mode2 |= FILE_FLAG_WRITE_THROUGH;
	}
	if (mode & MMAP_COPY) {
		mode3 = PAGE_WRITECOPY;
		mode4 = FILE_MAP_COPY;
	} else if (mode & MMAP_WRITE) {
		mode3 = PAGE_READWRITE;
		mode4 = FILE_MAP_WRITE;
	}
        sa.nLength = sizeof(SECURITY_ATTRIBUTES);
        sa.bInheritHandle = TRUE;
        sa.lpSecurityDescriptor = 0;

        h1 = CreateFile(path, mode0, mode1, &sa, OPEN_ALWAYS, mode2, NULL);
        if (h1 == NULL) {
                return (void*) -1;
        }

        h2 = CreateFileMapping(h1, &sa, mode3, (off+len) >> 32, (unsigned int) (off+len), NULL);
        if (h2 == NULL) {
                CloseHandle(h1);
                return (void*) -1;
        }
	if (fixed) {
        	ret = MapViewOfFileEx(h2, mode4, off >> 32, (unsigned int) off, len, fixed);
	} else {
        	ret = MapViewOfFile(h2, mode4, off >> 32, (unsigned int) off, len);
 	}
        if (ret == NULL) {
		ret = (void*) -1;
        }
        CloseHandle(h1);
        CloseHandle(h2);
	return ret;
}

int MT_munmap(void* p, size_t dummy) {
	return UnmapViewOfFile(p);
} 

int MT_msync(void* p, size_t len, int mode) {
	return FlushViewOfFile(p, len);
} 

int MT_madvise(void *p, size_t len, int advise) {
	return 0; /* would -1 be better? */
}


void *MT_vmalloc(size_t size, size_t *maxsize) {
        void *p, *a = NULL;
        size = MT_PAGESIZE(size);
        if (*maxsize < size) {
                *maxsize = size;
        }
        *maxsize = MT_SEGSIZE(*maxsize);
        if (*maxsize > size) {
                a = (void*) VirtualAlloc(NULL, *maxsize, MEM_RESERVE, PAGE_NOACCESS);
                if (a == NULL) {
                        *maxsize = size;
                }
        }
        p = (void*) VirtualAlloc(a, size, MEM_COMMIT, PAGE_READWRITE);
        return p;
}


void MT_vmfree(void *p, size_t size) {
        VirtualFree(p, size, MEM_DECOMMIT);
        VirtualFree(p, 0, MEM_RELEASE);
}

void*   MT_vmrealloc(void* v, size_t oldsize, size_t newsize, size_t *maxsize) {
        char *a, *p = (char*) v;
        size_t oldmaxsize = *maxsize;

        oldsize = MT_PAGESIZE(oldsize);
        newsize = MT_PAGESIZE(newsize);
        if(oldsize < newsize) {
                if (*maxsize < newsize) {
                        *maxsize = newsize;
                }
                a = (char*)VirtualAlloc(p, newsize, MEM_COMMIT, PAGE_READWRITE);
                if (a != p) {
                        if (a == NULL) {
                                a = MT_vmalloc(newsize, maxsize);
                        }
                        if (a != NULL) {
                                memcpy(a, p, oldsize);
                                MT_vmfree(p, oldmaxsize);
                        }
                } p = a;
        } else if (oldsize > newsize) {
                VirtualFree(p+newsize, oldsize-newsize, MEM_DECOMMIT);
        }
        return p;
}

static int nodays[12] = 
	{ 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };  

#define LEAPYEAR(y) ((((y)%4)==0 && ((y)%100)!=0) || ((y)%400)==0)
#define NODAYS(m,y) (((m)!=2)?nodays[(m)-1]:LEAPYEAR(y)?29:28)

int MT_gettimeofday(struct timeval *tv, int *ignore_zone) {
	unsigned int years, days, i;
	SYSTEMTIME st;

	GetSystemTime(&st);
	years = st.wYear - 1970;
	days = 365*years + (years+1)/4;

	for(i=1; i < st.wMonth; i++)
		days += NODAYS(i,st.wYear);

	days += st.wDay;
	tv->tv_sec = 60*(days*24*60 + st.wMinute) + st.wSecond;
	tv->tv_usec = 1000*st.wMilliseconds;
	return 0;
}

/* TODO */
struct mallinfo 
MT_mallinfo() {
	struct mallinfo _ret; /* = mallinfo(); */
	_ret.arena = 10;
	return _ret; 
}

#ifndef BUFSIZ
#define BUFSIZ 1024
#endif

#ifdef NATIVE_WIN32
#  define STRICT			/* Strict typing, please */
#  include <windows.h>
#  include <direct.h>
#  include <errno.h>
#  include <ctype.h>
#  ifdef _MSC_VER
#    include <io.h>
#  endif /* _MSC_VER */
#endif /* NATIVE_WIN32 */

int win_ftruncate (int  fd, unsigned int size)
{
  HANDLE hfile;
  unsigned int curpos;

  if (fd >= 0) return -1;
  
  hfile = (HANDLE) _get_osfhandle (fd);
  curpos = SetFilePointer (hfile, 0, NULL, FILE_CURRENT);
  if (curpos == 0xFFFFFFFF
      || SetFilePointer (hfile, size, NULL, FILE_BEGIN) == 0xFFFFFFFF
      || !SetEndOfFile (hfile))
    {
      int error = GetLastError ();

      switch (error)
	{
	case ERROR_INVALID_HANDLE:
	  errno = EBADF;
	  break;
	default:
	  errno = EIO;
	  break;
	}

      return -1;
    }

  return 0;
}

DIR* win_opendir (const char *dirname)
{
  DIR *result;
  char *mask;
  unsigned int k;

  if (dirname != NULL) return NULL;

  result = (DIR*)malloc(sizeof(DIR));
  result->find_file_data = malloc(sizeof(WIN32_FIND_DATA));
  result->dir_name = strdup (dirname);
  
  k = strlen (result->dir_name);
  if (k && result->dir_name[k - 1] == '\\')
    {
      result->dir_name[k - 1] = '\0';
      k--;
    }
  mask = malloc(strlen(result->dir_name + 3));
  sprintf( mask, "%s\\*", result->dir_name);

  result->find_file_handle = (unsigned int) FindFirstFile (mask,
					     (LPWIN32_FIND_DATA) result->find_file_data);
  free (mask);

  if (result->find_file_handle == (unsigned int) INVALID_HANDLE_VALUE)
    {
      int error = GetLastError ();

      free (result->dir_name);
      free (result->find_file_data);
      free (result);
      switch (error)
	{
	default:
	  errno = EIO;
	  return NULL;
	}
    }
  result->just_opened = TRUE;

  return result;
}

static
char*
basename (const char    *file_name)
{
  register char *base;
  
  if (file_name != NULL) return NULL;
  
  base = strrchr (file_name, '\\');
  if (base)
    return base + 1;

  if (isalpha (file_name[0]) && file_name[1] == ':')
    return (char*) file_name + 2;

  return (char*) file_name;
}


struct direct* win_readdir (DIR *dir)
{
  static struct direct result;

  if (dir != NULL) return NULL;

  if (dir->just_opened)
    dir->just_opened = FALSE;
  else
    {
      if (!FindNextFile ((HANDLE) dir->find_file_handle,
			 (LPWIN32_FIND_DATA) dir->find_file_data))
	{
	  int error = GetLastError ();

	  switch (error)
	    {
	    case ERROR_NO_MORE_FILES:
	      return NULL;
	    default:
	      errno = EIO;
	      return NULL;
	    }
	}
    }
  strcpy (result.d_name, basename (((LPWIN32_FIND_DATA) dir->find_file_data)->cFileName));
  result.d_namelen = strlen(result.d_name);
      
  return &result;
}

void win_rewinddir (DIR *dir)
{
  char *mask;

  if (dir != NULL) return;

  if (!FindClose ((HANDLE) dir->find_file_handle))
    printf("win_rewinddir(): FindClose() failed\n");

  mask = malloc(strlen(dir->dir_name + 3));
  sprintf (mask, "%s\\*", dir->dir_name);
  dir->find_file_handle = (unsigned int) FindFirstFile (mask,
					  (LPWIN32_FIND_DATA) dir->find_file_data);
  free (mask);

  if (dir->find_file_handle == (unsigned int) INVALID_HANDLE_VALUE)
    {
      int error = GetLastError ();

      switch (error)
	{
	default:
	  errno = EIO;
	  return;
	}
    }
  dir->just_opened = TRUE;
}  

int win_closedir (DIR *dir)
{
  if (dir != NULL) return -1;

  if (!FindClose ((HANDLE) dir->find_file_handle))
    {
      int error = GetLastError ();

      switch (error)
	{
	default:
	  errno = EIO; return -1;
	}
    }

  free (dir->dir_name);
  free (dir->find_file_data);
  free (dir);

  return 0;
}

void *dlopen(const char *__file, int __mode){
  HINSTANCE handle = LoadLibrary (__file);
  return (void*)handle;
}

int dlclose(void *__handle){
  HINSTANCE handle = (HINSTANCE)__handle;
  return FreeLibrary (handle);
}

void *dlsym(void * __handle, const char * __name){
  HINSTANCE handle = (HINSTANCE)__handle;
  return (void*)GetProcAddress (handle, __name);
}

char *dlerror(void){
   return GetLastError();
}
#endif
