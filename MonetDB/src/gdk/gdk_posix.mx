@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@' 
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@' 
@' The Original Code is the Monet Database System.
@' 
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2004 CWI.
@' All Rights Reserved.
@' 
@' Contributor(s):
@' 		Martin Kersten <Martin.Kersten@cwi.nl>
@' 		Peter Boncz <Peter.Boncz@cwi.nl>
@' 		Niels Nes <Niels.Nes@cwi.nl>
@' 		Stefan Manegold  <Stefan.Manegold@cwi.nl>

@f gdk_posix
@a Niels Nes, Peter Boncz
@* System Independent Layer

GDK is built on POSIX. Exceptions are made for memory mapped files and 
anonynmous virtual memory, for which somewhat higher-level functions are 
defined here.

Most of this file concerns itself with emulation of POSIX functionality on 
the WIN32 native platform.
@h
#ifndef GDK_POSIX_H
#define GDK_POSIX_H

#include "gdk_system.h"

#include <sys/types.h>

#ifdef HAVE_MALLOC_H
# include <malloc.h>	/* mallopt, mallinfo, and  malloc, free etc. */
#endif

#if TIME_WITH_SYS_TIME
# include <sys/time.h>
# include <time.h>
#else
# if HAVE_SYS_TIME_H
#  include <sys/time.h>
# else
#  include <time.h>
# endif
#endif

#ifdef NATIVE_WIN32
#include <io.h>
#include <direct.h>
#endif

/* Some systems (SGI, Sun) call malloc before we get a chance to call
   mallopt, and mallopt should be called before the first call to
   malloc.  Therefore we do as if we don't have mallopt, even though
   in reality we do.
 */
#ifdef HAVE_MALLOPT
#undef HAVE_MALLOPT
#endif

#ifndef HAVE_MALLINFO
#ifndef M_MXFAST
#define M_MXFAST	1  /* set size of blocks to be fast */
#endif
#ifndef M_NLBLKS
#define M_NLBLKS	2  /* set number of block in a holding block */
#endif
#ifndef M_GRAIN
#define M_GRAIN		3  /* set number of sizes mapped to one, for */
                           /* small blocks */
#endif
#ifndef M_KEEP
#define M_KEEP		4  /* retain contents of block after a free */
                           /* until another allocation */
#endif
#ifndef HAVE_STRUCT_MALLINFO
struct mallinfo  {
        int arena;      /* total space in arena */
        int ordblks;    /* number of ordinary blocks */
        int smblks;     /* number of small blocks */
        int hblks;      /* number of holding blocks */
        int hblkhd;     /* space in holding block headers */
        int usmblks;    /* space in small blocks in use */
        int fsmblks;    /* space in free small blocks */
        int uordblks;   /* space in ordinary blocks in use */
        int fordblks;   /* space in free ordinary blocks */
        int keepcost;   /* cost of enabling keep option */
};
#endif

#define mallinfo() 		{0}
#define mallopt(cmd,value)	0

#endif /* ! HAVE_MALLINFO */

gdk_export struct mallinfo MT_mallinfo(void);

@- locking, sleep
@h
#define F_TLOCK 2 /* test and lock a region for exclusive use */
#define F_ULOCK 0 /* unlock a previously locked region */
#define F_LOCK 1 /* lock a region for exclusive use */

gdk_export int 	MT_lockf(char *filename, int mode, off_t off, off_t len);
gdk_export void MT_sleep_ms(unsigned int ms);

@- virtual memory
@h
#define MT_VMUNITLOG 	16
#define MT_VMUNITSIZE 	(1 << MT_VMUNITLOG)

gdk_export int MT_alloc_register(void *p, size_t size, char mode);
gdk_export int MT_alloc_print(void);
gdk_export int MT_alloc_table(void);

/* the new mmap modes, mimick default MADV_* madvise POSIX constants */
#define MMAP_NORMAL     	0               /* no further special treatment */
#define MMAP_RANDOM     	1               /* expect random page references */
#define MMAP_SEQUENTIAL 	2               /* expect sequential page references */
#define MMAP_WILLNEED   	3               /* will need these pages */
#define MMAP_DONTNEED   	4               /* don't need these pages */

#define MMAP_READ		1024		/* region is readable (default if ommitted) */
#define MMAP_WRITE		2048		/* region may be written into */
#define MMAP_COPY		4096		/* writable, but changes never reach file */
#define MMAP_ASYNC		8192		/* asynchronous writes (default if ommitted) */
#define MMAP_SYNC		16384		/* writing is done synchronously */ 

/* in order to be sure of madvise and msync modes, pass them to mmap() call as well */

/* a hook function to add any initialization required for the MT_ functionality */
gdk_export char *MT_heapbase;
gdk_export char *MT_heapcur(void);

gdk_export void MT_init_posix(int alloc_map);

gdk_export void* MT_mmap(char *path, int mode, off_t off, size_t len, void *fixed);
gdk_export int   MT_munmap(void* p, size_t len);
gdk_export int   MT_msync(void* p, size_t len, int mode);
gdk_export int   MT_madvise(void* p, size_t len, int advise);

gdk_export void *MT_vmalloc(size_t size, size_t *maxsize);
gdk_export void  MT_vmfree(void *p, size_t size);
gdk_export void *MT_vmrealloc(void *voidptr, size_t oldsize, size_t newsize, size_t oldmaxsize, size_t *newmaxsize);
gdk_export int   MT_path_absolute(char *path);

@- Posix under WIN32 
@T
WIN32 actually supports many posix functions directly.  Some it does not, though. 

For some functionality we move in Monet from posix calls to MT\_\*() calls, which translate easier 
to WIN32.  Examples are MT\_mmap() , MT\_sleep\_ms() and MT\_path\_absolute(). Why? In the case
of mmap() it is much easier for WIN32 to get a filename parameter rather than a file-descriptor. 
That is the reason in the case of mmap() to go for a MT\_mmap() solution.

For some other funtionality, we do not need to abandon the posix interface, though. Two cases can
be distuinguished:
\begin{itemize}
\item missing functions in WIN32, which are directly implemented (e.g. dlopen()/dlsym()/dlclose()).
\item posix functions in WIN32 whose functionlity should be changed a bit. Examples are 
      stat()/rename()/mkdir()/rmdir() who under WIN32 do not work if the path ends with a directory 
      separator, but should work according to posix. We remap such functions using a define
      to an equivalent win\_\*() function (which in its implementation calls through to the WIN32
      function).
\end{itemize}
@h
#ifdef NATIVE_WIN32

#define RTLD_LAZY	1
#define RTLD_NOW	2
#define RTLD_GLOBAL	4

gdk_export void*	dlopen (const char *__file, int __mode);
gdk_export int		dlclose (void *__handle);
gdk_export void*	dlsym (void * __handle, const char * __name);
gdk_export char*	dlerror (void);
gdk_export int 		gettimeofday(struct timeval *tv, int *ignore_zone);
gdk_export int		win_stat(const char*, struct stat *);
gdk_export int		win_rmdir(const char*);
gdk_export int		win_mkdir(const char*, const int mode);
#define stat(x,y)	win_stat(x,y)
#define mkdir		win_mkdir
#define rmdir		win_rmdir

#define NAME_MAX 255

struct DIR {
  char    	*dir_name;
  int       	just_opened;
  unsigned int  find_file_handle;
  char		*find_file_data;
};

typedef struct DIR DIR;
struct direct {
  char  d_name[NAME_MAX + 1];
  int   d_namelen;
};

#ifndef HAVE_FTRUNCATE
gdk_export int ftruncate (int  fd, off_t size);
#endif
#ifndef HAVE_OPENDIR
gdk_export DIR* opendir (const char *dirname);
gdk_export struct direct* readdir (DIR *dir);
gdk_export void rewinddir (DIR *dir);
gdk_export int closedir (DIR *dir);
#endif

#endif 

#endif /* GDK_POSIX_H */
@c
#include "gdk.h"

static void MT_alloc_init(void);

#include <stdio.h>

#ifdef HAVE_SYS_MMAN_H
# include <sys/mman.h>
#endif

#ifdef HAVE_FCNTL_H
# include <fcntl.h>
#endif

#ifndef HAVE_MADVISE
# define madvise(x,y,z)	0
# ifndef MADV_RANDOM
#  define MADV_RANDOM	0
# endif
#endif 

#ifndef MAP_NORESERVE
# define MAP_NORESERVE 		MAP_PRIVATE
#endif 

#define MMAP_ADVISE		7
#define MMAP_WRITABLE		(MMAP_WRITE|MMAP_COPY)

/* DDALERT: AIX4.X 64bits needs HAVE_SETENV==0 due to a AIX bug, but it probably isn't detected so by configure */

#ifdef HAVE_SETENV
int setenv(const char *name, const char *value, int overwrite) {
	int ret = 0;
	if (overwrite || getenv(name) == NULL) {
		char *p = (char*) GDKmalloc(2+strlen(name)+strlen(value));
		strcpy(p, name);
		strcat(p, "=");
		strcat(p, value);
		ret = putenv(p);
		/* GDKfree(p); LEAK INSERTED DUE TO SOME WEIRD CRASHES */
	}
	return ret;
}
#endif

char* MT_heapbase = NULL;

#ifndef NATIVE_WIN32

void MT_init_posix(int alloc_map){
	MT_heapbase = (char*) sbrk(0);
	if (alloc_map)
		MT_alloc_init();
}

char* MT_heapcur(void){
	return (char*) sbrk(0);
}

void* MT_mmap(char *path, int mode, off_t off, size_t len, void *fixed){
	FILE *fp = fopen(path, (mode&MMAP_WRITABLE)?"rb+":"rb" );
	void *ret = (void*) -1L;
	if (fp) {
	    ret = mmap(fixed, len, 
		((mode&MMAP_WRITABLE)?PROT_WRITE:0)|PROT_READ, 
		((mode&MMAP_COPY)?MAP_PRIVATE:MAP_SHARED)|(fixed?MAP_FIXED:0),
	        fileno(fp), off);
	    fclose(fp);
	    if (ret != (void*) -1L && (mode&MMAP_ADVISE)) {
		(void) madvise(ret, len, mode&MMAP_ADVISE);
	    }
        }
	return ret;
}

int MT_munmap(void* p, size_t len) {
	return munmap(p, len);
} 

int MT_msync(void* p, size_t len, int mode) {
	return msync(p, len, (mode&MMAP_SYNC)?MS_SYNC:MS_ASYNC);
} 

int MT_madvise(void* p, size_t len, int advise) {
	(void) p; (void) len; (void) advise;
	return madvise(p, len, advise); 
}

struct mallinfo 
MT_mallinfo(void){
	struct mallinfo _ret;
#ifdef HAVE_MALLINFO
	_ret = mallinfo();
#else
	memset(&_ret, 0, sizeof(_ret));
#endif
	if (_ret.uordblks + _ret.fordblks > _ret.arena) {
		MT_alloc_register(MT_heapbase, _ret.arena, 'H');
	}
	return _ret;
}

int MT_path_absolute(char *pathname) {
	return (*pathname == DIR_SEP);
}

#ifdef WIN32
#include <windows.h>
#endif

#else /* WIN32 native */

#ifndef BUFSIZ
#define BUFSIZ 1024
#endif

#undef _errno
#undef stat
#undef rmdir
#undef mkdir

#undef NAME_MAX

#include <windows.h>

#ifdef _MSC_VER
#include <io.h>
#endif /* _MSC_VER */

#define MT_SMALLBLOCK 256

void MT_init_posix(int alloc_map){
	MT_heapbase = 0;

/*
	_set_sbh_threshold(MT_SMALLBLOCK);
*/
	if (alloc_map)
		MT_alloc_init();
}

char* MT_heapcur(void){
	return (char*)0;
}

void* MT_mmap(char *path, int mode, off_t off, size_t len, void* fixed) {
	void *ret = NULL;
	int mode0 = GENERIC_READ;
	int mode1 = FILE_SHARE_READ;
	int mode2 = mode & MMAP_ADVISE;
	int mode3 = PAGE_READONLY;
	int mode4 = FILE_MAP_READ;
        SECURITY_ATTRIBUTES sa;
        HANDLE h1, h2;

	if (mode & MMAP_WRITABLE) {
		mode0 |= GENERIC_WRITE;
		mode1 |= FILE_SHARE_WRITE;
	}
        if (mode2 == MMAP_RANDOM || mode2 == MMAP_DONTNEED) {
                mode2 = FILE_FLAG_RANDOM_ACCESS;
        } else if (mode2 == MMAP_SEQUENTIAL || mode2 == MMAP_WILLNEED) {
                mode2 = FILE_FLAG_SEQUENTIAL_SCAN;
        } else {
                mode2 = FILE_FLAG_NO_BUFFERING;
        }
	if (mode & MMAP_SYNC) {
		mode2 |= FILE_FLAG_WRITE_THROUGH;
	}
	if (mode & MMAP_COPY) {
		mode3 = PAGE_WRITECOPY;
		mode4 = FILE_MAP_COPY;
	} else if (mode & MMAP_WRITE) {
		mode3 = PAGE_READWRITE;
		mode4 = FILE_MAP_WRITE;
	}
        sa.nLength = sizeof(SECURITY_ATTRIBUTES);
        sa.bInheritHandle = TRUE;
        sa.lpSecurityDescriptor = 0;

        h1 = CreateFile(path, mode0, mode1, &sa, OPEN_ALWAYS, mode2, NULL);
        if (h1 == INVALID_HANDLE_VALUE) {
		GDKsyserror("MT_mmap: CreateFile('%s', %d, %d, &sa, %d, %d, NULL) failed\n",
		                              path, mode0, mode1, OPEN_ALWAYS, mode2);
                return (void*) -1L;
        }

        h2 = CreateFileMapping(h1, &sa, mode3, (DWORD) ((((__int64)off+(__int64)len) >> 32) & 0xFFFFFFFFi64), (DWORD) ((off+len) & 0xFFFFFFFFi64), NULL);
        if (h2 == NULL) {
		GDKsyserror("MT_mmap: CreateFileMapping(%x, &sa, %d, %d, %u, NULL) failed\n",
		                        h1, mode3, (DWORD) ((((__int64)off+(__int64)len) >> 32) & 0xFFFFFFFFi64), (DWORD) ((off+len) & 0xFFFFFFFFi64));
                CloseHandle(h1);
                return (void*) -1L;
        }
	if (fixed) {
        	ret = MapViewOfFileEx(h2, mode4, off >> 32, (unsigned int) off, len, fixed);
	} else {
        	ret = MapViewOfFile(h2, mode4, off >> 32, (unsigned int) off, len);
 	}
        if (ret == NULL) {
		GDKsyserror("MT_mmap: MapViewOfFile%s(%x, %d, %d, %u, %d, %x) failed\n",
		            h2, (fixed?"Ex":""), mode4, off >> 32, (unsigned int) off, len, fixed);
		ret = (void*) -1L;
        }
        CloseHandle(h1);
        CloseHandle(h2);
	return ret;
}

int MT_munmap(void* p, size_t dummy) {
	return ( UnmapViewOfFile(p) ? 0 : -1 );
	/*       Windows' UnmapViewOfFile returns success!=0, error== 0,
	 * while Unix's   munmap          returns success==0, error==-1. */
} 

int MT_msync(void* p, size_t len, int mode) {
	return ( FlushViewOfFile(p, len) ? 0 : -1 );
	/*       Windows' FlushViewOfFile returns success!=0, error== 0,
	 * while Unix's   msync           returns success==0, error==-1. */
} 

int MT_madvise(void *p, size_t len, int advise) {
	return 0; /* would -1 be better? */
}




/* TODO */
struct mallinfo MT_mallinfo(void) {
	struct mallinfo _ret; 
	_HEAPINFO hinfo;
	int heapstatus;

	hinfo._pentry = NULL;
	memset(&_ret, 0, sizeof(struct mallinfo));

	while( (heapstatus = _heapwalk( &hinfo ) ) == _HEAPOK ) { 
		_ret.arena += hinfo._size;
		if (hinfo._size > MT_SMALLBLOCK) {
			_ret.smblks++;
			if (hinfo._useflag == _USEDENTRY) {
				_ret.usmblks += hinfo._size;
				MT_alloc_register(hinfo._pentry, hinfo._size, 'H');
			} else {
				_ret.fsmblks += hinfo._size;
				MT_alloc_register(hinfo._pentry, hinfo._size, 'h');
			}
		} else {
			_ret.ordblks++;
			if (hinfo._useflag == _USEDENTRY) {
				_ret.uordblks += hinfo._size;
				MT_alloc_register(hinfo._pentry, hinfo._size, 'H');
			} else {
				_ret.fordblks += hinfo._size;
				MT_alloc_register(hinfo._pentry, hinfo._size, 'h');
			}
		}
	}
	if (heapstatus == _HEAPBADPTR || 
	    heapstatus == _HEAPBADBEGIN ||
	    heapstatus == _HEAPBADNODE)
	{
	
		GDKerror("mallinfo(): heap is corrupt.");
	}
	_heapmin();
	return _ret;
}

int MT_path_absolute(char *pathname) {
	char *drive_end = strchr(pathname, ':');
	char *path_start = strchr(pathname, '\\');

	if (path_start == NULL) {
		return 0;
	}
	return (path_start == pathname || drive_end == (path_start-1));
}


#ifndef HAVE_FTRUNCATE
int ftruncate (int  fd, off_t size)
{
  HANDLE hfile;
  unsigned int curpos;

  if (fd < 0) return -1;
  
  hfile = (HANDLE) _get_osfhandle (fd);
  curpos = SetFilePointer (hfile, 0, NULL, FILE_CURRENT);
  if (curpos == 0xFFFFFFFF
      || SetFilePointer (hfile, (LONG) size, NULL, FILE_BEGIN) == 0xFFFFFFFF
      || !SetEndOfFile (hfile))
    {
      int error = GetLastError ();
      if (error && error != ERROR_INVALID_HANDLE) 
	SetLastError(ERROR_OPEN_FAILED); /* enforce EIO */
      return -1;
    }

  return 0;
}
#endif

#ifndef HAVE_OPENDIR
DIR* opendir (const char *dirname)
{
  DIR *result = NULL;
  char *mask;
  unsigned int k;

  if (dirname == NULL) return NULL;

  result = (DIR*)malloc(sizeof(DIR));
  result->find_file_data = malloc(sizeof(WIN32_FIND_DATA));
  result->dir_name = strdup (dirname);
  
  k = strlen (result->dir_name);
  if (k && result->dir_name[k - 1] == '\\')
    {
      result->dir_name[k - 1] = '\0';
      k--;
    }
  mask = malloc(strlen(result->dir_name) + 3);
  sprintf( mask, "%s\\*", result->dir_name);

  result->find_file_handle = (unsigned int) FindFirstFile (mask,
					     (LPWIN32_FIND_DATA) result->find_file_data);
  free (mask);

  if (result->find_file_handle == (unsigned int) INVALID_HANDLE_VALUE)
    {
      free (result->dir_name);
      free (result->find_file_data);
      free (result);
      SetLastError(ERROR_OPEN_FAILED); /* enforce EIO */
      return NULL;
    }
  result->just_opened = TRUE;

  return result;
}

static
char*
basename (const char    *file_name)
{
  register char *base;
  
  if (file_name == NULL) return NULL;
  
  base = strrchr (file_name, '\\');
  if (base)
    return base + 1;

  if (isalpha (file_name[0]) && file_name[1] == ':')
    return (char*) file_name + 2;

  return (char*) file_name;
}


struct direct* readdir (DIR *dir)
{
  static struct direct result;

  if (dir == NULL) return NULL;

  if (dir->just_opened)
    dir->just_opened = FALSE;
  else
    {
      if (!FindNextFile ((HANDLE) dir->find_file_handle,
			 (LPWIN32_FIND_DATA) dir->find_file_data))
	{
	  int error = GetLastError ();
	  if (error) {
            if (error != ERROR_NO_MORE_FILES) 
	      SetLastError(ERROR_OPEN_FAILED); /* enforce EIO */
	    return NULL;
	  }
	}
    }
  strcpy (result.d_name, basename (((LPWIN32_FIND_DATA) dir->find_file_data)->cFileName));
  result.d_namelen = strlen(result.d_name);
      
  return &result;
}

void rewinddir (DIR *dir)
{
  char *mask;

  if (dir == NULL) return;

  if (!FindClose ((HANDLE) dir->find_file_handle))
    printf("rewinddir(): FindClose() failed\n");

  mask = malloc(strlen(dir->dir_name) + 3);
  sprintf (mask, "%s\\*", dir->dir_name);
  dir->find_file_handle = (unsigned int) FindFirstFile (mask,
					  (LPWIN32_FIND_DATA) dir->find_file_data);
  free (mask);

  if (dir->find_file_handle == (unsigned int) INVALID_HANDLE_VALUE)
    {
      SetLastError(ERROR_OPEN_FAILED); /* enforce EIO */
      return;
    }
  dir->just_opened = TRUE;
}  

int closedir (DIR *dir)
{
  if (dir == NULL) return -1;

  if (!FindClose ((HANDLE) dir->find_file_handle))
    {
      SetLastError(ERROR_OPEN_FAILED); /* enforce EIO */
      return -1;
    }

  free (dir->dir_name);
  free (dir->find_file_data);
  free (dir);

  return 0;
}
#endif /* HAVE_OPENDIR */

static int nodays[12] = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };  

#define LEAPYEAR(y) ((((y)%4)==0 && ((y)%100)!=0) || ((y)%400)==0)
#define NODAYS(m,y) (((m)!=2)?nodays[(m)-1]:LEAPYEAR(y)?29:28)

int gettimeofday(struct timeval *tv, int *ignore_zone) {
	unsigned int year, day, month;
	SYSTEMTIME st;

	(void) ignore_zone;
	GetSystemTime(&st);
	day = 0;
	for(year=1970; year<st.wYear; year++)
		day += LEAPYEAR(year)?366:365;

	for(month=1; month < st.wMonth; month++)
		day += NODAYS(month,st.wYear);

	day += st.wDay;
	tv->tv_sec = 60*(day*24*60 + st.wMinute) + st.wSecond;
	tv->tv_usec = 1000*st.wMilliseconds;
	return 0;
}

void *dlopen(const char *__file, int __mode){
  if (__file != NULL){
  	HINSTANCE handle = LoadLibrary (__file);
  	return (void*)handle;
  }
  return NULL;
}

int dlclose(void *__handle){
  if (__handle != NULL){
  	HINSTANCE handle = (HINSTANCE)__handle;
  	return FreeLibrary (handle);
  }
  return -1;
}

void *dlsym(void * __handle, const char * __name){
  if (__handle != NULL){
  	HINSTANCE handle = (HINSTANCE)__handle;
  	return (void*)GetProcAddress (handle, __name);
  }
  return NULL;
}

char *dlerror(void){
  return strerror(errno);
}

/* dir manipulations fail in WIN32 if file name contains trailing
 * slashes; work around this */
static char* reduce_dir_name(const char* src, char* dst, size_t cap)
{
	size_t len = strlen(src);
	char *buf = dst;

	if (len >= cap)
		buf = malloc(len + 1);
	while (--len > 0 && src[len-1] != ':' && src[len] == DIR_SEP)
		;
	for (buf[++len] = 0; len > 0; buf[len] = src[len])
		len--;
	return buf;
}

int win_stat(const char* pathname, struct stat *st)
{
	char buf[128], *p = reduce_dir_name(pathname, buf, sizeof(buf));
	int ret = stat(p, st);

	if (p != buf)
		free(p);
	return ret;
}

int win_rmdir(const char* pathname)
{
	char buf[128], *p = reduce_dir_name(pathname, buf, sizeof(buf));
	int ret = rmdir(p);

	if (p != buf)
		free(p);
	return ret;
}

int win_mkdir(const char* pathname, const int mode)
{
	char buf[128], *p = reduce_dir_name(pathname, buf, sizeof(buf));
	int ret = mkdir(p);

	if (p != buf)
		free(p);
	return ret;
}

typedef struct {
    int w;		 /* windows version of error */
    const char *s;	 /* text of windows version */
    int e;		 /* errno version of error */
} win_errmap_t;

#ifndef EBADRQC
#define EBADRQC 56
#endif
#ifndef ENODATA
#define ENODATA 61
#endif
#ifndef ENONET
#define ENONET 64
#endif
#ifndef ENOTUNIQ
#define ENOTUNIQ 76
#endif
#ifndef ECOMM
#define ECOMM 70
#endif
#ifndef ENOLINK
#define ENOLINK 67
#endif
win_errmap_t win_errmap[] = {
  { ERROR_INVALID_FUNCTION, "ERROR_INVALID_FUNCTION", EBADRQC  },
  { ERROR_FILE_NOT_FOUND, "ERROR_FILE_NOT_FOUND", ENOENT  },
  { ERROR_PATH_NOT_FOUND, "ERROR_PATH_NOT_FOUND", ENOENT  },
  { ERROR_TOO_MANY_OPEN_FILES, "ERROR_TOO_MANY_OPEN_FILES", EMFILE  },
  { ERROR_ACCESS_DENIED, "ERROR_ACCESS_DENIED", EACCES  },
  { ERROR_INVALID_HANDLE, "ERROR_INVALID_HANDLE", EBADF  },
  { ERROR_NOT_ENOUGH_MEMORY, "ERROR_NOT_ENOUGH_MEMORY", ENOMEM  },
  { ERROR_INVALID_DATA, "ERROR_INVALID_DATA", EINVAL  },
  { ERROR_OUTOFMEMORY, "ERROR_OUTOFMEMORY", ENOMEM  },
  { ERROR_INVALID_DRIVE, "ERROR_INVALID_DRIVE", ENODEV  },
  { ERROR_NOT_SAME_DEVICE, "ERROR_NOT_SAME_DEVICE", EXDEV  },
  { ERROR_NO_MORE_FILES, "ERROR_NO_MORE_FILES", ENFILE  },
  { ERROR_WRITE_PROTECT, "ERROR_WRITE_PROTECT", EROFS  },
  { ERROR_BAD_UNIT, "ERROR_BAD_UNIT", ENODEV  },
  { ERROR_SHARING_VIOLATION, "ERROR_SHARING_VIOLATION", EACCES  },
  { ERROR_LOCK_VIOLATION, "ERROR_LOCK_VIOLATION", EACCES  },
  { ERROR_SHARING_BUFFER_EXCEEDED, "ERROR_SHARING_BUFFER_EXCEEDED", ENOLCK  },
  { ERROR_HANDLE_EOF, "ERROR_HANDLE_EOF", ENODATA  },
  { ERROR_HANDLE_DISK_FULL, "ERROR_HANDLE_DISK_FULL", ENOSPC  },
  { ERROR_NOT_SUPPORTED, "ERROR_NOT_SUPPORTED", ENOSYS  },
  { ERROR_REM_NOT_LIST, "ERROR_REM_NOT_LIST", ENONET  },
  { ERROR_DUP_NAME, "ERROR_DUP_NAME", ENOTUNIQ  },
  { ERROR_BAD_NETPATH, "ERROR_BAD_NETPATH", ENXIO  },
  { ERROR_FILE_EXISTS, "ERROR_FILE_EXISTS", EEXIST  },
  { ERROR_CANNOT_MAKE, "ERROR_CANNOT_MAKE", EPERM  },
  { ERROR_INVALID_PARAMETER, "ERROR_INVALID_PARAMETER", EINVAL  },
  { ERROR_NO_PROC_SLOTS, "ERROR_NO_PROC_SLOTS", EAGAIN  },
  { ERROR_BROKEN_PIPE, "ERROR_BROKEN_PIPE", EPIPE  },
  { ERROR_OPEN_FAILED, "ERROR_OPEN_FAILED", EIO  },
  { ERROR_NO_MORE_SEARCH_HANDLES, "ERROR_NO_MORE_SEARCH_HANDLES", ENFILE  },
  { ERROR_CALL_NOT_IMPLEMENTED, "ERROR_CALL_NOT_IMPLEMENTED", ENOSYS  },
  { ERROR_INVALID_NAME, "ERROR_INVALID_NAME", ENOENT  },
  { ERROR_WAIT_NO_CHILDREN, "ERROR_WAIT_NO_CHILDREN", ECHILD  },
  { ERROR_CHILD_NOT_COMPLETE, "ERROR_CHILD_NOT_COMPLETE", EBUSY  },
  { ERROR_DIR_NOT_EMPTY, "ERROR_DIR_NOT_EMPTY", ENOTEMPTY  },
  { ERROR_SIGNAL_REFUSED, "ERROR_SIGNAL_REFUSED", EIO  },
  { ERROR_BAD_PATHNAME, "ERROR_BAD_PATHNAME", EINVAL  },
  { ERROR_SIGNAL_PENDING, "ERROR_SIGNAL_PENDING", EBUSY  },
  { ERROR_MAX_THRDS_REACHED, "ERROR_MAX_THRDS_REACHED", EAGAIN  },
  { ERROR_BUSY, "ERROR_BUSY", EBUSY  },
  { ERROR_ALREADY_EXISTS, "ERROR_ALREADY_EXISTS", EEXIST  },
  { ERROR_NO_SIGNAL_SENT, "ERROR_NO_SIGNAL_SENT", EIO  },
  { ERROR_FILENAME_EXCED_RANGE, "ERROR_FILENAME_EXCED_RANGE", EINVAL  },
  { ERROR_META_EXPANSION_TOO_LONG, "ERROR_META_EXPANSION_TOO_LONG", EINVAL  },
  { ERROR_INVALID_SIGNAL_NUMBER, "ERROR_INVALID_SIGNAL_NUMBER", EINVAL  },
  { ERROR_THREAD_1_INACTIVE, "ERROR_THREAD_1_INACTIVE", EINVAL  },
  { ERROR_BAD_PIPE, "ERROR_BAD_PIPE", EINVAL  },
  { ERROR_PIPE_BUSY, "ERROR_PIPE_BUSY", EBUSY  },
  { ERROR_NO_DATA, "ERROR_NO_DATA", EPIPE  },
  { ERROR_PIPE_NOT_CONNECTED, "ERROR_PIPE_NOT_CONNECTED", ECOMM  },
  { ERROR_MORE_DATA, "ERROR_MORE_DATA", EAGAIN  },
  { ERROR_DIRECTORY, "ERROR_DIRECTORY", EISDIR  },
  { ERROR_PIPE_CONNECTED, "ERROR_PIPE_CONNECTED", EBUSY  },
  { ERROR_PIPE_LISTENING, "ERROR_PIPE_LISTENING", ECOMM  },
  { ERROR_NO_TOKEN, "ERROR_NO_TOKEN", EINVAL  },
  { ERROR_PROCESS_ABORTED, "ERROR_PROCESS_ABORTED", EFAULT  },
  { ERROR_BAD_DEVICE, "ERROR_BAD_DEVICE", ENODEV  },
  { ERROR_BAD_USERNAME, "ERROR_BAD_USERNAME", EINVAL  },
  { ERROR_NOT_CONNECTED, "ERROR_NOT_CONNECTED", ENOLINK  },
  { ERROR_OPEN_FILES, "ERROR_OPEN_FILES", EAGAIN  },
  { ERROR_ACTIVE_CONNECTIONS, "ERROR_ACTIVE_CONNECTIONS", EAGAIN  },
  { ERROR_DEVICE_IN_USE, "ERROR_DEVICE_IN_USE", EAGAIN  },
  { ERROR_INVALID_AT_INTERRUPT_TIME, "ERROR_INVALID_AT_INTERRUPT_TIME", EINTR},
  { ERROR_IO_DEVICE, "ERROR_IO_DEVICE", EIO },
};

#define GDK_WIN_ERRNO_TLS 13

@h
#define _errno		win_errno

gdk_export int *win_errno(void);
@c
int *win_errno(void){
  /* get address of thread-local POSIX errno; refresh its value from WIN32 error code */
  int i, err = GetLastError() & 0xff;
  int *result = TlsGetValue(GDK_WIN_ERRNO_TLS);

  if (result == NULL) {
	result = (int*) malloc(sizeof(int));
	*result = 0;
	TlsSetValue(GDK_WIN_ERRNO_TLS, result);
  }
  for (i = 0; win_errmap[i].w != 0; ++i) {
      if (err == win_errmap[i].w) {
         *result = win_errmap[i].e;
         break;
      }
  }
  SetLastError(err);
  return result;
} 
#endif

#ifndef WIN32

#define MT_PAGESIZE(s)		((((s-1)/MT_pagesize())+1)*MT_pagesize())

#if defined(MAP_ANON) 
#define MMAP_FLAGS(f)		f|MAP_ANON
#define MMAP_FD			-1
#define MMAP_OPEN_DEV_ZERO	int fd = 1
#define MMAP_CLOSE_DEV_ZERO	(void)fd
#else
#define MMAP_FLAGS(f)		f
#define MMAP_FD			fd
#define MMAP_OPEN_DEV_ZERO	int fd = open("/dev/zero", O_RDWR, 0666)
#define MMAP_CLOSE_DEV_ZERO	close(fd)
#endif

void *MT_vmalloc(size_t size, size_t *maxsize) {
        MMAP_OPEN_DEV_ZERO;
        char *q, *r = (char*) -1L;

        if (fd < 0) {
                return NULL;
        }
        size = MT_PAGESIZE(size);
        *maxsize = MT_PAGESIZE(*maxsize);
        if (*maxsize > size) {
                r = (char*) mmap(NULL, *maxsize, PROT_NONE, 
				MMAP_FLAGS(MAP_PRIVATE|MAP_NORESERVE), MMAP_FD, 0);
        }
        if (r == (char*) -1L) {
                *maxsize = size;
                q = (char*) mmap(NULL, size, PROT_READ|PROT_WRITE, 
				MMAP_FLAGS(MAP_PRIVATE), MMAP_FD, 0);
        } else {
                q = (char*) mmap(r, size, PROT_READ|PROT_WRITE, 
				MMAP_FLAGS(MAP_PRIVATE|MAP_FIXED), MMAP_FD, 0);
        }
        MMAP_CLOSE_DEV_ZERO;
        return (void*) ((q == (char*) -1L)?NULL:q);
}

void MT_vmfree(void *p, size_t size) {
        size = MT_PAGESIZE(size);
        munmap(p, size);
}

void *MT_vmrealloc(void *voidptr, size_t oldsize, size_t newsize, size_t oldmaxsize, size_t *newmaxsize) {
        char *p=(char*)voidptr;
        char *q = (char*) -1L;

	/* sanitize sizes */
        oldsize = MT_PAGESIZE(oldsize);
        newsize = MT_PAGESIZE(newsize);
        oldmaxsize = MT_PAGESIZE(oldmaxsize);
        *newmaxsize = MT_PAGESIZE(*newmaxsize);
	if (*newmaxsize < newsize) {
		*newmaxsize = newsize;
	}

        if (oldsize > newsize) {
                munmap(p+oldsize, oldsize-newsize);
        } else if (oldsize < newsize) {
		if (newsize < oldmaxsize) {
                	MMAP_OPEN_DEV_ZERO;
                	if (fd >= 0) {
                        	q = (char*) mmap(p+oldsize, newsize-oldsize, PROT_READ|PROT_WRITE, 
						 MMAP_FLAGS(MAP_PRIVATE|MAP_FIXED), MMAP_FD, (off_t)oldsize);
                        	MMAP_CLOSE_DEV_ZERO;
			}
		}
        	if (q == (char*) -1L) {
			q = (char*) MT_vmalloc(newsize, newmaxsize);
                	if (q != NULL) {
                       		memcpy(q, p, oldsize);
                       		MT_vmfree(p, oldmaxsize);
				return q;
			}
		}
	}
	*newmaxsize = MAX(oldmaxsize,newsize);
        return p;
}

#if defined(HAVE_LOCKF) && defined(__MACH__)
/* lockf() seems to be there, but I didn't find any header file that declares the prototype ... */
extern int lockf (int __fd, int __cmd, off_t __len);
#endif

#ifndef HAVE_LOCKF
/* Cygwin implementation: struct flock is there, but lockf() is
   missing.
 */
static int lockf(int fd, int cmd, off_t len)
{
	struct flock l;
	if (cmd == F_LOCK || cmd == F_TLOCK)
		l.l_type = F_WRLCK;
	else if (cmd == F_ULOCK)
		l.l_type = F_UNLCK;
	l.l_whence = SEEK_CUR;
	l.l_start = 0;
	l.l_len = len;
	return fcntl(fd, cmd == F_TLOCK ? F_SETLKW : F_SETLK, &l);
}
#endif
/* return -1 when locking failed */
int MT_lockf(char *filename, int mode, off_t off, off_t len){
	int ret = -1, fd = open(filename, O_CREAT|O_RDWR, 0662);
	if (fd < 0) return fd;
	if (lseek(fd, off, SEEK_SET) == off) 
		ret = (lockf(fd, mode, len) == 0)?1:-1;
	/* do not close else we lose the lock we want */
	return ret;
}

void MT_sleep_ms(unsigned int ms) {
#ifdef HAVE_NANOSLEEP
        struct timespec ts;
        ts.tv_sec = (time_t) (ms/1000);
        ts.tv_nsec = 1000000*(ms%1000);
        while(nanosleep(&ts, &ts) == -1 && errno == EINTR);
#else
	struct timeval tv;
	tv.tv_sec = ms/1000;
	tv.tv_usec = ms % 1000;
	(void) select(0, NULL, NULL, NULL, &tv);
#endif
}

#else  /* WIN32 */

#define MT_PAGESIZE(s)		(((((s)-1) >> 12) + 1) << 12)
#define MT_SEGSIZE(s)		((((((s)-1) >> 16) & 65535) + 1) << 16)

#ifndef MEM_TOP_DOWN
#define MEM_TOP_DOWN 0
#endif

void *MT_vmalloc(size_t size, size_t *maxsize) {
       	void *p, *a = NULL;
	int mode = 0;
	size = MT_PAGESIZE(size);
	if (*maxsize < size) {
		*maxsize = size;
	}
	*maxsize = MT_SEGSIZE(*maxsize);
	if (*maxsize < 1000000)	{
		mode = MEM_TOP_DOWN; /* help NT in keeping memory defragmented */
	}
	if (*maxsize > size) {
		a = (void*) VirtualAlloc(NULL, *maxsize, MEM_RESERVE|mode, PAGE_NOACCESS);
		if (a == NULL) {
			*maxsize = size;
		}
	}
	p = (void*) VirtualAlloc(a, size, MEM_COMMIT|mode, PAGE_READWRITE);
	if (p == NULL) {
		fprintf(MT_out, "VirtualAlloc(" PTRFMT "," SZFMT ",MEM_COMMIT,PAGE_READWRITE): failed\n", PTRFMTCAST a, size);
	}
	return p; 
}
 

void MT_vmfree(void *p, size_t size) {
	if (VirtualFree(p, size, MEM_DECOMMIT) == 0)
	fprintf(MT_out, "VirtualFree(" PTRFMT "," SZFMT ",MEM_DECOMMIT): failed\n", PTRFMTCAST p, size);
	if (VirtualFree(p, 0, MEM_RELEASE) == 0)
	fprintf(MT_out, "VirtualFree(" PTRFMT ",0,MEM_RELEASE): failed\n", PTRFMTCAST p);
}

void* MT_vmrealloc(void* v, size_t oldsize, size_t newsize, size_t oldmaxsize, size_t *newmaxsize) {
	char *p = (char*) v, *a = p;

	/* sanitize sizes */
	oldsize = MT_PAGESIZE(oldsize);
	newsize = MT_PAGESIZE(newsize);
	oldmaxsize = MT_PAGESIZE(oldmaxsize);
	*newmaxsize = MT_PAGESIZE(*newmaxsize);
	if (*newmaxsize < newsize) {
		*newmaxsize = newsize;
	}

	if (oldsize > newsize) {
 		size_t ret = VirtualFree(p+newsize, oldsize-newsize, MEM_DECOMMIT);
 		if (ret == 0) 
			fprintf(MT_out, "VirtualFree(" PTRFMT "," SSZFMT ",MEM_DECOMMIT): failed\n", 
				PTRFMTCAST (p+newsize), (ssize_t) (oldsize-newsize));
        } else if (oldsize < newsize) {
 		a = (char*) VirtualAlloc(p, newsize, MEM_COMMIT, PAGE_READWRITE);
		if (a != p) {
			char *q = a;
			if (a == NULL) {
				q = MT_vmalloc(newsize, newmaxsize);
			}
			if (q != NULL) {
				memcpy(q, p, oldsize);
				MT_vmfree(p, oldmaxsize);
			} 
			if (a == NULL)  return q;
		}
	} 
	*newmaxsize = MAX(oldmaxsize,newsize);
	return a;
}

int MT_lockf(char *filename, int mode, off_t off, off_t len) {
	int ret = 1, illegalmode = 0;
	OVERLAPPED ov;
	OSVERSIONINFO os;
	HANDLE fh = CreateFile(filename, 
			GENERIC_READ|GENERIC_WRITE, 0,
			NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
	    
	os.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
	GetVersionEx(&os);
	memset(&ov, 0, sizeof(ov));
	ov.Offset = (unsigned int) off;
#if 0
	ov.OffsetHigh = off >> 32;
#else
	ov.OffsetHigh = 0;	/* sizeof(off) == 4, i.e. off >> 32 is not possible */
#endif

	if (fh == NULL) {
	    return -1;
        } 
        if (mode == F_ULOCK) {
	    if (os.dwPlatformId != VER_PLATFORM_WIN32_WINDOWS)
	    ret = UnlockFileEx(fh, 0, 0, len, &ov);
        } else if(mode == F_TLOCK) {
	    if (os.dwPlatformId != VER_PLATFORM_WIN32_WINDOWS)
	    ret = LockFileEx(fh, LOCKFILE_FAIL_IMMEDIATELY|LOCKFILE_EXCLUSIVE_LOCK, 0, 0, len, &ov);
        } else if(mode == F_LOCK) {
	    if (os.dwPlatformId != VER_PLATFORM_WIN32_WINDOWS)
	    ret = LockFileEx(fh, LOCKFILE_EXCLUSIVE_LOCK, 0, 0, len, &ov);
        } else {
	    illegalmode = 1;
	}
	CloseHandle(fh);
	if (illegalmode) {
	    SetLastError(ERROR_INVALID_DATA);
	}
        return ret?0:-1;
}

void MT_sleep_ms(unsigned int ms) {
        Sleep(ms);
}


@-
cygnus1.1.X has a bug in the semaphore routines. we work around it by directly using the WIN32 primitives.
@c
#ifndef NATIVE_WIN32

int sem_init (sem_t * sem, int pshared, unsigned int value) {
	(void) pshared;
	*sem = (sem_t) CreateSemaphore(NULL, value, 128, NULL);
	return (*sem)?0:-1;
}

int sem_destroy (sem_t * sem) {
	return CloseHandle((HANDLE) *sem)?0:-1;
}

int sem_wait (sem_t * sem) {
	return (WaitForSingleObject((HANDLE) *sem, (unsigned int) INFINITE) != WAIT_FAILED)?0:-1;
}

int sem_trywait (sem_t * sem) {
	return (WaitForSingleObject((HANDLE) *sem, 0) == 0)?0:EBUSY;
}

int sem_post (sem_t * sem) {
	return (ReleaseSemaphore((HANDLE) *sem, 1, NULL) == 0)?-1:0;
}
#endif
#endif

@- memory fragmentation monitoring
@T
On 32-bits systems, Monet's aggressive use of virtual memory may bring it into
trouble as the limits of what is addreassable in a 32-bits system are reached 
(an 32-bits OS only allows 2 to 4GB of memory to be used). In order to aid debugging
situations where VM allocs fail (due to memory fragmentation), a monitoring
system was established. To this purpose, a map is made for the VM addresses
between 0 and 3GB, in tiles of MT\_VMUNITSIZE (64KB). These tiles have a byte
value from the following domain:

\begin{verbatim}
0-9 - thread stack space of thread <num>
B - in use for a large BAT heap.
b - free (last usage was B)
S - in use for a malloc block
s - free (last usage was S)
P - in use for the BBP array
p - free (last usage was P)
M - in use as memory mapped region
m - free (last usage was M)
C - in use as MIL context buffer
c - free (last usage was C)
\end{verbatim}

The MT\_alloc\_printmap condenses the map by printing a char for each MB,
hence combining info from 16 tiles. On NT, we can check in real-time which 
tiles are actually in use (in case our own tile administration is out-of-sync 
with reality, eg due to a memory leak). This real-life usage is printed in a 
second line with encodingw .=free, *=inuse, X=unusable. On Unix systems,
*=inuse is not testable (unless with complicated signal stuff). On 64-bits
systems, this administation is disfunctional. 
@c
#if SIZEOF_VOID_P == 4
unsigned char MT_alloc_map[49600]= { 0 };
#endif

int MT_alloc_register(void *addr, size_t size, char mode) {
#if SIZEOF_VOID_P == 4
        size_t p = (size_t) addr;
        if (p > 0 && p < 3*((size_t) 1024*1024*1024) && size > 0) {
                size_t i, base = p >> 16;
                size = (size-1) >> 16;
                for(i=0; i<=size; i++)
                        MT_alloc_map[base+i] = (MT_alloc_map[base+i]&128) | mode;
        }
#else
	(void) addr; (void) size; (void) mode;
#endif
        return 0;
}

#define INUSEMODE(x) ((x >= '0' && x <= ('9'+4)) || (x >= 'A' && x <= 'Z'))

int MT_alloc_print(void) {
#if SIZEOF_VOID_P == 4
#ifdef WIN32
        char *p = NULL;
#endif
        int i, j, k;

	if (MT_alloc_map[0] == 0)
		return 0;

        for(i=0; i<31; i++) {
                fprintf(MT_out, "%02d00MB ", i);
                for(j=0; j<100; j++) {
                        int mode = '.';
                        for(k=0; k<16; k++)  {
                                int m = MT_alloc_map[k + 16*(j + 100*i)]&127;
                                if (mode == '.' || INUSEMODE(m)) mode = m;
                        }
                        fprintf(MT_out, "%c", mode);
                }
#ifdef WIN32
                fprintf(MT_out, "\n       ");
                for(j=0; j<100; j++) {
                        int mode = '.';
                        for(k=0; k<16; k++,p+=1<<16)
                                if (!IsBadReadPtr(p, 1)) {
                                        mode = '*';
                                } else if (MT_alloc_map[k + 16*(j + 100*i)]&128) {
                                        mode = 'X';
                                }
                        fprintf(MT_out, "%c", mode);
                }
#endif
                fprintf(MT_out, "\n");
        }
#endif
        return 0;
}

@-
The memory table dump can also be produced in tuple format
to enable front-ends to analys it more easily.
@c
struct{
	char tag;
	char *color;
	char *info;
} Encoding[]={
{ '.', "0x00FFFDFE",  "free"},
{ '0', "0x000035FC", "thread stack space of thread 0"},
{ '1', "0x000067FE", "thread stack space of thread 1"},
{ '2', "0x000095FE", "thread stack space of thread 2"},
{ '3', "0x0000BDFC", "thread stack space of thread 3"},
{ '4', "0x0000DCF8", "thread stack space of thread 4"},
{ '5', "0x002735FC", "thread stack space of thread 5"},
{ '6', "0x002767FE", "thread stack space of thread 6"},
{ '7', "0x002795FE", "thread stack space of thread 7"},
{ '8', "0x0027BDFC", "thread stack space of thread 8"},
{ '9', "0x0027DCF8", "thread stack space of thread 9"},
{ 'B', "0x0000672D", "in use for a large BAT heap."},
{ 'b', "0x004EF2A7", "free (last usage was B)"},
{ 'S', "0x00B4006E", "in use for a malloc block"},
{ 's', "0x00F2BDE0", "free (last usage was S)"},
{ 'P', "0x00F26716", "in use for the BBP array"},
{ 'p', "0x00F2BD16", "free (last usage was P)"},
{ 'M', "0x00959516", "in use as memory mapped region"},
{ 'm', "0x00CEDC16", "free (last usage was M)"},
{ 'C', "0x004EFDC7", "in use as MIL context buffer"},
{ 'c', "0x00FFFD2D", "free (last usage was M)"},
{ 0, "0x00FFFDFE",  "free"}
};

int MT_alloc_table(void) {
#if SIZEOF_VOID_P == 4
#ifdef WIN32
        char *p = NULL;
#endif
        int i, j, k;

	if (MT_alloc_map[0] == 0)
		return 0;

	stream_printf(GDKout,"# addr\tX\tY\tcolor\tmode\tcomment\t# name\n");
	stream_printf(GDKout,"# str\tint\tint\tcolor\tstr\tstr\t# type\n");
        for(i=0; i<31; i++) {
                for(j=0; j<100; j++) {
                        int mode = '.';
                        for(k=0; k<16; k++)  {
                                int m = MT_alloc_map[k + 16*(j + 100*i)]&127;
                                if (mode == '.' || INUSEMODE(m)) mode = m;
                        }
			for(k=0; k>= 0; k++)
			if( Encoding[k].tag==mode || Encoding[k].tag==0){
				if(mode==0) mode=' ';
				stream_printf(GDKout, "[ \"%d\",\t%d,\t%d,\t", 
						k + 16*(j+ 100*i), j, i);
				stream_printf(GDKout, "\"%s\",\t",
					Encoding[k].color);
				stream_printf(GDKout, "\"%c\",\t\"%s\"\t]\n",
					mode, Encoding[k].info);
				break;
			}
                }
		stream_flush(GDKout);
#ifdef WIN32
                fprintf(MT_out, "\n       ");
                for(j=0; j<100; j++) {
                        int mode = '.';
                        for(k=0; k<16; k++,p+=1<<16)
                                if (!IsBadReadPtr(p, 1)) {
                                        mode = '*';
                                } else if (MT_alloc_map[k + 16*(j + 100*i)]&128) {
                                        mode = 'X';
                                }
                        fprintf(MT_out, "%c", mode);
                }
                fprintf(MT_out, "\n");
#endif
        }
#endif
        return 0;
}

static void MT_alloc_init(void) {
#if SIZEOF_VOID_P == 4
        char* p = NULL;
        int i;
        for(i=0; i<49600; i++, p+=MT_VMUNITSIZE) {
		int mode = '.';
#ifdef WIN32
                if (!VirtualAlloc(p, MT_VMUNITSIZE, MEM_RESERVE, PAGE_NOACCESS)) {
			mode |= 128;
                } else {
                        VirtualFree(p, 0, MEM_RELEASE);
                }
#else
		MMAP_OPEN_DEV_ZERO;
                void *q = (char*) mmap(p, MT_VMUNITSIZE, PROT_NONE, MMAP_FLAGS(MAP_NORESERVE), MMAP_FD, 0);
		MMAP_CLOSE_DEV_ZERO;
		if (q != p) mode |= 128;
		if (q != (char*) -1L) munmap(q, MT_VMUNITSIZE);
#endif
                MT_alloc_map[i] = mode;
        }
#endif
}

