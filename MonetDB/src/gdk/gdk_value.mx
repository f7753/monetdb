@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@' 
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@' 
@' The Original Code is the Monet Database System.
@' 
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2003 CWI.
@' All Rights Reserved.
@' 
@' Contributor(s):
@' 		Martin Kersten <Martin.Kersten@cwi.nl>
@' 		Peter Boncz <Peter.Boncz@cwi.nl>
@' 		Niels Nes <Niels.Nes@cwi.nl>
@' 		Stefan Manegold  <Stefan.Manegold@cwi.nl>

@f gdk_value
@t Monet Values
@a Martin L. Kersten & Peter Boncz
@v 2.0 
@* Introduction

 
When manipulating values, Monet puts them into value records.
The built-in types have a direct entry in the union. Others should 
be represented as a pointer of memory in pval or as a string, which
is basically the same. In such cases the @%len@ field indicates
the size of this piece of memory.

Monet Extenders will use value records for passing parameters to
their new operators. Monet algebraic commands receive an 
(argc, argv) combination, where
argc is an integer indicating the size of the the argv array of value 
records. On call, the first record, argv[0], is always empty. The
routine must place its return value - if any - there. The other
values are the parameters.

@{
Actually, the gdk value type defined here should become a built-in
type in the kernel. Next step will be to define the corresponding
extension module.
@}

@{
@+ Value operations
The following primitives are required to manipulate value records.
Note that binding a BAT requires upgrading its reference count.
The receiver of the value should have been cleared or represent
free space.
@c
#include "gdk.h"

ValPtr VALnew(void){
	ValPtr v = (ValPtr) GDKmalloc(sizeof(ValRecord));
	VALempty(v);
	return v;
}

ValPtr VALset(ValPtr v, int t, ptr p){
	switch(ATOMstorage(v->vtype = t)) {
	case TYPE_chr: v->val.cval[0] = *(chr*) p; 
		       v->val.cval[1] = 0;
		       v->val.cval[2] = 0;
		       v->val.cval[3] = 0;
		       break;
	case TYPE_sht: v->val.shval = *(sht*) p; break;
	case TYPE_bit:
	case TYPE_int: v->val.ival = *(int*) p; break;
	case TYPE_flt: v->val.fval = *(flt*) p; break;
	case TYPE_dbl: v->val.dval = *(dbl*) p; break;
	case TYPE_lng: v->val.lval = *(lng*) p; break;
	default:       v->val.pval = p;
		       v->len = ATOMlen(t, p);
	}
	return v;
}

void *VALget(ValPtr v){
	switch(ATOMstorage(v->vtype)) {
	case TYPE_chr: return (void*) &v->val.cval[0];
	case TYPE_sht: return (void *) &v->val.shval;
	case TYPE_void:
	case TYPE_bit:
	case TYPE_int: return (void *) &v->val.ival;
	case TYPE_flt: return (void *) &v->val.fval;
	case TYPE_dbl: return (void *) &v->val.dval;
	case TYPE_lng: return (void *) &v->val.lval;
	case TYPE_str: return (void *) v->val.pval;
	}
	return NULL;
}

void VALclear(ValPtr v){
        switch(ATOMstorage(v->vtype)) {
        case TYPE_str:
        case TYPE_ptr:
                if(v->val.pval && v->val.pval != str_nil) GDKfree(v->val.pval);
                v->val.pval = 0;
        }
	VALempty(v);
}

void VALempty(ValPtr v){
	v->len = 0;
	v->val.oval = oid_nil;
	v->vtype = TYPE_void;
}

ValPtr VALcopy(ValPtr d, ValPtr s){
	if (ATOMextern(s->vtype) == 0) {
		*d = *s;
	} else if (s->val.pval == 0) {
                d->val.pval = ATOMnil(s->vtype);
                d->vtype = s->vtype;
	} else if (s->vtype == TYPE_str) {
		d->vtype = TYPE_str;
		d->val.sval = GDKstrdup(s->val.sval);
		d->len = strLen(d->val.sval);
	} else {
                ptr p = s->val.pval;
                d->vtype = s->vtype;
                d->len = ATOMlen(d->vtype,p);
                d->val.pval = GDKmalloc(d->len);
		memcpy(d->val.pval, p, d->len);
	}
	return d;
}
@-
Moving a value from a BUN into a value record, making proper copies
on the way.
@c
ValPtr VALinit(ValPtr d, int tpe, ptr s){
        if (ATOMextern(tpe) == 0) {
                d->vtype= tpe;
                memcpy(&d->val.ival, s, ATOMlen(tpe,s));
        } else
        if (s == 0) {
                GDKerror("VALinit:unsupported init\n");
                d->vtype= TYPE_int;
        } else if( ATOMstorage(tpe) == TYPE_str) {
                d->vtype = TYPE_str;
                d->val.sval = GDKstrdup(s);
                d->len = strLen(s);
        } else {
                d->vtype= tpe;
                d->len = ATOMlen(tpe,s);
                d->val.pval = GDKmalloc(d->len);
                memcpy(d->val.pval, s, d->len);
        }
        return d;
}
@-
VALprint shows the contents of a value record, but without
expanding the BAT contents.
@c
int VALprint(stream *s, ValPtr res){
	int t = ATOMstorage(res->vtype);
	return ATOMprint(t, VALptr(res), s);
}	


int VALformat(char **buf, ValPtr res){
	int t = res->vtype;
	*buf = 0;
	return ATOMformat(t, VALptr(res), buf);
}

@-
The routine @%VALconvert@ transforms a value for interpretation
in a certain type. It uses some standard cast conventions to do this.
The result, a pointer to a value, is returned. If there are
illegal values, or type combinations involved, it gives
up with an ILLEGALVALUE.

@= valconvert
	if (dst_tpe == TYPE_chr) {
		t->val.cval[0] = (char) @1; 
	} else if (dst_tpe == TYPE_sht) {
		t->val.shval = (short) @1; 
	} else if (dst_tpe == TYPE_bat) {
		bat bid = (bat) @1;
		if (ABS(bid) > BBPsize || BBP_logical(bid) == NULL) {
			bid = 0;
			p = ILLEGALVALUE;
		} else {
			p = (ptr) BATdescriptor(bid);
		} t->val.bval = bid; 
	} else if (dst_tpe == TYPE_int) {
		t->val.ival = (int) @1; 
	} else if (dst_tpe == TYPE_flt) {
		t->val.fval = (float) @1; 
	} else if (dst_tpe == TYPE_lng) {
		t->val.lval = (lng) @1; 
	} else if (dst_tpe == TYPE_dbl) {
		t->val.dval = (dbl) @1; 
	}
	warning = (sizeof(dst_tpe) < sizeof(@2));
@c
ptr VALconvert(int typ, ValPtr t, int silent){
	int src_tpe = ATOMstorage(t->vtype), dst_tpe = typ, warning = 0;
	ptr p = VALptr(t);

        if (dst_tpe != TYPE_bat) {
		dst_tpe = ATOMstorage(dst_tpe);
	}  
	if (src_tpe != dst_tpe && t->vtype != typ && dst_tpe != TYPE_void) { 
		if (src_tpe >= TYPE_str || dst_tpe >= TYPE_str) { 
			if (ATOMcmp(src_tpe, ATOMnilptr(src_tpe), p) == 0) {
				VALclear(t);
				VALset(t, dst_tpe, p = ATOMnil(dst_tpe));
			} else { 
				return ILLEGALVALUE; 
			}
		} else if ((t->vtype == TYPE_bat && t->val.bval == 0 ) ||
	    	           ATOMcmp(src_tpe, ATOMnilptr(src_tpe), p) == 0) 
		{
			memcpy(p, ATOMnilptr(dst_tpe), ATOMsize(dst_tpe));
		} else if (src_tpe == TYPE_chr) {
			@:valconvert(t->val.cval[0], chr)@;
		} else if (src_tpe == TYPE_sht) {
			@:valconvert(t->val.shval, sht)@;
		} else if (src_tpe == TYPE_int) {
			@:valconvert(t->val.ival, int)@;
		} else if (src_tpe == TYPE_flt) {
			@:valconvert(t->val.fval, flt)@;
		} else if (src_tpe == TYPE_lng) {
			@:valconvert(t->val.lval, lng)@;
		} else if (src_tpe == TYPE_dbl) {
			@:valconvert(t->val.dval, dbl)@;
		}
        	if (!silent && t->vtype && warning) {
                	GDKwarning("VALconvert: converted type '%s' to '%s'.\n",
                        	ATOMname(t->vtype), ATOMname(typ));
        	}
	}
	t->vtype = typ;
	return p;
}

@}
@
