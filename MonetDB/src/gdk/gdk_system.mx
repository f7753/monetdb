@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at 
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@' 
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@' 
@' The Original Code is the Monet Database System.
@' 
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2002 CWI.  
@' All Rights Reserved.
@' 
@' Contributor(s):
@' 		Martin Kersten <Martin.Kersten@cwi.nl>
@' 		Peter Boncz <Peter.Boncz@cwi.nl>
@' 		Niels Nes <Niels.Nes@cwi.nl>
@' 		Stefan Manegold  <Stefan.Manegold@cwi.nl>

@f gdk_system
@a Niels Nes, Peter Boncz
@+ Threads
@T
This file contains the threads implementation based on the posix 
thread library interface, consisting of posix standaard thread 
functions. 

@- Pthread Definitions
@h
#ifndef _GDK_SYSTEM_H_
#define _GDK_SYSTEM_H_

#include <monet_utils.h>

#ifdef _MSC_VER
#ifndef LIBGDK
#define gdk_export extern __declspec(dllimport) 
#else
#define gdk_export extern __declspec(dllexport) 
#endif
#else
#define gdk_export extern 
#endif

#if HAVE_UNISTD_H
# include <unistd.h>     /* io functions */
#endif
#ifdef HAVE_FCNTL_H
#include <fcntl.h>
#endif

@- pthreads Includes and Definitions
@h
#include <sys/types.h>
#ifdef HAVE_SIGNAL_H
# include <signal.h>
#endif

#ifdef HAVE_PTHREAD_H
/* don't re-include config.h; on Windows, don't redefine pid_t in an
   incompatible way 
 */
#undef HAVE_CONFIG_H
#ifdef pid_t
#undef pid_t
#endif
# include <pthread.h>
#endif

#ifdef HAVE_SEMAPHORE_H
# include <semaphore.h>
#endif

typedef void    *MT_Lock;
typedef void    *MT_Sema;
typedef void    *MT_Id;

#define THREAD_STACK_SIZE	((unsigned long)512*1024)

#define MAXLOCKS	256
#define MAXSEMAS	64

@- Environment Specific Defines
Define your error reporting routine @%MT_error(str message)@.
@h
#define MT_error	GDKsyserror	
#define MT_warning	GDKwarning	
@-
Define your error integer debug flag @%MT_debug@.
@h
#define MT_debug	GDKdebug
gdk_export int GDKdebug;
@-
Define your debug printing stream @%MT_out@.
@h
gdk_export void *THRgetdata	(int);
#define MT_out		stderr

@- Global Variables
The are part of the interface (i.e. you may use them).
@h
gdk_export MT_Lock	MT_system_lock;	/* system administration lock */

@+ Interface Definition
The routines that are available for use for thread and process management.
@-
Init the package. Must be called once before any of the other operations.
@h
gdk_export void 	MT_init ();

@-
Set which signals should be blocked, ignores  SIGINT, SIGQUIT, SIGALRM
@h
#ifdef HAVE_PTHREAD_SIGMASK
gdk_export void MT_thread_sigmask( sigset_t *new_mask, sigset_t *orig_mask );
#endif

@-
Create a new thread executing 'function' with single parameter 'arg'. 
May return an error, in which case no thread is created.
@h
gdk_export int 	MT_create_thread(MT_Id *t, void (*function)(void *), void *arg);

@-
Exit the current thread. The status will be ignored, unless some thread
wait()-s for you to finish.
a wait()
@h
gdk_export void 	MT_exit_thread(int status);

@-
Exit the process. All threads are terminated.
@h
gdk_export void 	MT_global_exit(int status);

@-
Ask your thread id.
@h
gdk_export MT_Id 	MT_getpid();


@-
Kill a thread.
@h
gdk_export int 	MT_kill_thread(MT_Id t);

@-
Destroy an inter-process lock;
@h
gdk_export void	MT_destroy_lock(MT_Lock l);     

@-
Create a new thread-lock. Initial status: unset.
@h
gdk_export MT_Lock	MT_create_lock();

@-
Set a lock. The calling thread in this process blocks till the lock is set.
@h
gdk_export void 	MT_set_lock(MT_Lock l, char *name);
 
@-
Unset a lock.
@h
gdk_export void 	MT_unset_lock(MT_Lock l, char *name);
 
@-
Try a lock. Returns error (EBUSY) if the lock was already 
set. Else, the lock is set.
@h
gdk_export int	MT_try_lock(MT_Lock l);

@-
Dump info about the lock named 'name' on stream 'fp'.
@h
gdk_export void 	MT_dump_lock(MT_Lock l, FILE *fp, char *name);

@- Mthreads Macro Implementations

@-
Create a counting thread semaphore, set the number of resources.
@h
gdk_export MT_Sema	MT_create_sema(int nresources);     


@-
Destroy a counting thread semaphore;
@h
gdk_export void	MT_destroy_sema(MT_Sema s);     

@-
Increment a semaphore.
@h
gdk_export void	MT_up_sema(MT_Sema s, char *name);
 
@-
Decrement a semaphore. If it already has value 0, the thread is
blocked until a decrement is possible again.
@h
gdk_export void	MT_down_sema(MT_Sema s, char *name);

@-
Try to decrement a semaphore. If it already has value 0, an error
(EBUSY) is returned. Else, the semaphore is decremented.
@h
gdk_export int 	MT_try_sema(MT_Sema s);

@-
Dump info about the semaphore named 'name' on stream 'fp'.
@h
gdk_export void 	MT_dump_sema(MT_Sema s, FILE *fp, char *name);

@-
Check if some process is still alive.
@h
gdk_export int 	MT_alive(int pid);

@-
Allocate anonymous virtual memory.
@h
#define MT_geterrno()		errno
#define MT_seterrno(x)		errno=x

gdk_export size_t _MT_npages;
gdk_export size_t _MT_pagesize;
 
#define MT_pagesize()	_MT_pagesize
#define MT_npages()	_MT_npages

#endif /*_GDK_SYSTEM_H_*/


@- Mthreads Routine implemtations
@c
#include "gdk_system.h"
#include "gdk_posix.h"

#if !defined(HAVE_SYSCONF) && defined(HAVE_GETRLIMIT) && defined(HAVE_SYS_RESOURCE_H)
# include <sys/resource.h>
#endif

MT_Lock		MT_system_lock = NULL;		/* system administration lock */

pthread_mutex_t	MT_firstlock[MAXLOCKS];
sem_t		MT_firstsema[MAXSEMAS];

int MT_curlock=0, MT_nextlock[MAXLOCKS];
int MT_cursema=0, MT_nextsema[MAXSEMAS];

size_t     _MT_pagesize = 0;               /* variable holding memory size */
size_t     _MT_npages = 0;                 /* variable holding page size */
 
void MT_init() {
	static pthread_mutex_t l;
	int i;

#if defined(HAVE_SYSCONF) && defined(_SC_PAGESIZE)
        _MT_pagesize = sysconf(_SC_PAGESIZE);
	if (_MT_pagesize <= 0)
#endif
		_MT_pagesize = 4096;   /* default */ 

#if defined(HAVE_SYSCONFIG) && defined(_SC_PHYS_PAGES)
	_MT_npages = sysconf(_SC_PHYS_PAGES);
#else
#ifdef HAVE_GETRLIMIT
        {
		struct rlimit rl;
		getrlimit(RLIMIT_RSS, &rl);
		_MT_npages = rl.rlim_cur / _MT_pagesize;
        }
#else
	_MT_npages = 0;		/* XXX */
#endif
#endif
	
	pthread_mutex_init(&l, 0);
	for(i=1; i<MAXLOCKS; i++) {
		MT_nextlock[i-1] = i;
	}
	MT_nextlock[MAXLOCKS-1] = -1;

	for(i=1; i<MAXSEMAS; i++) {
		MT_nextsema[i-1] = i;
	}
	MT_nextsema[MAXSEMAS-1] = -1;

	MT_system_lock = (MT_Lock) &l;
}

#ifdef HAVE_PTHREAD_SIGMASK
void 	MT_thread_sigmask( sigset_t *new_mask, sigset_t *orig_mask ){
        (void)sigdelset(new_mask, SIGINT);
        (void)sigdelset(new_mask, SIGQUIT);
        (void)sigdelset(new_mask, SIGALRM); /* else sleep doesn't work */
        (void)pthread_sigmask(SIG_SETMASK, new_mask, orig_mask);
}
#endif

int	MT_create_thread (MT_Id *t, void (*f)(void *), void *arg) {
#ifdef HAVE_PTHREAD_SIGMASK
	sigset_t new_mask, orig_mask;
#endif
	pthread_attr_t attr;
	int  ret;

#ifdef HAVE_PTHREAD_SIGMASK
        (void)sigfillset(&new_mask);
	MT_thread_sigmask(&new_mask, &orig_mask);
#endif
	pthread_attr_init(&attr);
#ifdef PTHREAD_CREATE_DETACHED
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
#endif
        pthread_attr_setstacksize(&attr, 1024*1024);
	ret = pthread_create((pthread_t*)t, &attr, (void*(*)(void*))f, arg);
        if (ret == 0) (*(int*)t)++; /* use pthread-id + 1 */
#ifdef HAVE_PTHREAD_SIGMASK
	MT_thread_sigmask(&orig_mask, NULL);
#endif
	return ret;
}

void MT_global_exit(int s) {
#if 0
	/*(void) kill(0, SIGHUP);*/
	pthread_kill_other_threads_np();
#endif
	exit(s);
}


void MT_exit_thread(int s) {
	int st=0;
	pthread_exit(&st);
}


int MT_kill_thread (MT_Id t) {
#ifdef HAVE_PTHREAD_KILL
	long id = (long)t-1;
	return pthread_kill((pthread_t)id, SIGHUP);
#else
	return -1;		/* XXX */
#endif
}

MT_Lock	MT_create_lock() {
	pthread_mutex_t *new_mutex;

	MT_set_lock(MT_system_lock, "MT_create_lock");
	if (MT_curlock == -1) {
	    fprintf(MT_out, "MT_create_lock: ran out of locks.\n");
	    MT_global_exit(-1);
	}
	new_mutex = MT_firstlock + MT_curlock;
	MT_curlock = MT_nextlock[MT_curlock];
	MT_unset_lock(MT_system_lock, "MT_create_lock");
	pthread_mutex_init(new_mutex, 0);

	return (MT_Lock) new_mutex;
}


void MT_destroy_lock (MT_Lock l) {
	int idx = (int) (((pthread_mutex_t*) l) - MT_firstlock);
	if (l == NULL) return;
	pthread_mutex_destroy(l);
	MT_set_lock(MT_system_lock, "MT_destroy_lock");
	MT_nextlock[idx] = MT_curlock;
	MT_curlock = idx;
	MT_unset_lock(MT_system_lock, "MT_destroy_lock");
}

void MT_set_lock(MT_Lock l, char *name){
    	int t = 0;
    	if (MT_debug & 1024) {
        	fprintf(MT_out,"MT_set_lock(%lu\@%s) %ld %d\n", 
			(long)MT_getpid(), name, (long)l, t);
        	fflush(MT_out);
    	}
	(void)pthread_mutex_lock((pthread_mutex_t*)l);
}

void MT_unset_lock(MT_Lock l, char *name)	{
   	int t = 0;
    	if (MT_debug & 1024) {
        	fprintf(MT_out,"MT_unset_lock(%lu\@%s) %ld %d\n", 
			(long)MT_getpid(), name, (long)l,t);
        	fflush(MT_out);
	}   
 	t = pthread_mutex_unlock((pthread_mutex_t*)l);
}
 
int MT_try_lock (MT_Lock l) {
	if (MT_debug & 1024) {
		fprintf(MT_out,"MT_try_lock:%lu %ld\n", 
			(long)MT_getpid(), (long) l);
		fflush(MT_out);
	}
	if (l == NULL) return 0;
	return pthread_mutex_trylock(l);
}


void MT_dump_lock (MT_Lock l, FILE *fp, char* name) {
	fprintf(fp, "%s: MT_dump_lock() not implemented.\n", name);
}

void MT_up_sema(MT_Sema s, char *name){
	(void)sem_post((sem_t*)s);
    	if (MT_debug &  1024) {
        	fprintf(MT_out,"MT_up_sema(%lu\@%s) %ld\n", 
			(long)MT_getpid(), name, (long)s);
        	fflush(MT_out);
    	}
}
 
void MT_down_sema(MT_Sema s, char *name){
	(void)sem_wait((sem_t*)s);
    	if (MT_debug &  1024) {
        	fprintf(MT_out,"MT_down_sema(%lu\@%s) %ld\n", 
			(long)MT_getpid(), name, (long)s);
        	fflush(MT_out);
	}   
}

int MT_try_sema (MT_Sema s){
	if (MT_debug & 1024) {
		fprintf(MT_out,"MT_try_sema:%lu %ld\n", 
			(long) MT_getpid(), (long) s);
		fflush(MT_out);
	}
	if (s == NULL) return 0;
	return (sem_trywait(s));
}


MT_Sema	MT_create_sema (int nresources) {
	sem_t *new_sema;

	MT_set_lock(MT_system_lock, "MT_create_sema");
	if (MT_cursema == -1) {
	    fprintf(MT_out, "MT_create_sema: ran out of semaphores.\n");
	    MT_global_exit(-1);
	}
	new_sema = MT_firstsema + MT_cursema;
	MT_cursema = MT_nextsema[MT_cursema];
	MT_unset_lock(MT_system_lock, "MT_create_sema");

	(void)sem_init( new_sema, 0, nresources );
	return (MT_Sema) new_sema;
}


void	MT_destroy_sema (MT_Sema s) {
	int idx = (int) (((sem_t*) s) - MT_firstsema);

	if (s == NULL) return;
	(void)sem_destroy( s );

	MT_set_lock(MT_system_lock, "MT_destroy_sema");
	MT_nextsema[idx] = MT_cursema;
	MT_cursema = idx;
	MT_unset_lock(MT_system_lock, "MT_destroy_sema");
}

void 	MT_dump_sema (MT_Sema s, FILE *fp, char *name) {
	fprintf(fp, "%s: MT_dump_sema() not implemented.\n",name);
}

MT_Id MT_getpid(){
	return (MT_Id)((long)pthread_self()+1);
}

int MT_alive(int pid) {
#ifdef HAVE_GETPGID
	int st = getpgid(pid);
	return (st >= 0 && st != ESRCH);
#else
	return 0;		/* XXX */
#endif
}

