@f gdk_system
@a Niels Nes, Peter Boncz
@+ Threads
@T
This file contains the threads implementation based on the posix 
thread library interface, consisting of posix standaard thread 
functions. 

@- Pthread Definitions
@h
#ifndef _GDK_SYSTEM_H_
#define _GDK_SYSTEM_H_

#include <config.h>

#ifdef _MSC_VER
#ifndef LIBGDK
#define gdk_export extern __declspec(dllimport) 
#else
#define gdk_export extern __declspec(dllexport) 
#endif
#else
#define gdk_export extern 
#endif

#if HAVE_UNISTD_H
# include <unistd.h>     /* io functions */
#endif
#ifdef HAVE_FCNTL_H
#include <fcntl.h>
#endif

#include <stdio.h>

#ifndef HAVE_GETPGID
#define getpgid __getpgid
#endif 

@- pthreads Includes and Definitions
@h
#include <sys/types.h>
#ifdef HAVE_SYS_SIGNAL_H
# include <sys/signal.h>
#endif

typedef void    *MT_Lock;
typedef void    *MT_Sema;
typedef void    *MT_Id;

#define MAXLOCKS	128
#define MAXSEMAS	64

@- Environment Specific Defines
Define your error reporting routine @%MT_error(str message)@.
@h
#define MT_error	GDKsyserror	
#define MT_warning	GDKwarning	
@-
Define your error integer debug flag @%MT_debug@.
@h
#define MT_debug	GDKdebug
gdk_export int GDKdebug;
@-
Define your debug printing stream @%MT_out@.
@h
gdk_export void *THRgetdata	(int);
#define MT_out		stderr

@- Global Variables
The are part of the interface (i.e. you may use them).
@h
gdk_export MT_Lock	MT_system_lock;	/* system administration lock */

@+ Interface Definition
The routines that are available for use for thread and process management.
@-
Init the package. Must be called once before any of the other operations.
@h
gdk_export void 	MT_init ();

@-
Create a new thread executing 'function' with single parameter 'arg'. 
May return an error, in which case no thread is created.
@h
gdk_export int 	MT_create_thread(MT_Id *t, void (*function)(void *), void *arg);

@-
Exit the current thread. The status will be ignored, unless some thread
wait()-s for you to finish.
a wait()
@h
gdk_export void 	MT_exit_thread(int status);

@-
Exit the process. All threads are terminated.
@h
gdk_export void 	MT_global_exit(int status);

@-
Ask your thread id.
@h
gdk_export MT_Id 	MT_getpid();


@-
Kill a thread.
@h
gdk_export int 	MT_kill_thread(MT_Id t);

@-
Destroy an inter-process lock;
@h
gdk_export void	MT_destroy_lock(MT_Lock l);     

@-
Create a new thread-lock. Initial status: unset.
@h
gdk_export MT_Lock	MT_create_lock();

@-
Set a lock. The calling thread in this process blocks till the lock is set.
@h
gdk_export void 	MT_set_lock(MT_Lock l, char *name);
 
@-
Unset a lock.
@h
gdk_export void 	MT_unset_lock(MT_Lock l, char *name);
 
@-
Try a lock. Returns error (EBUSY) if the lock was already 
set. Else, the lock is set.
@h
gdk_export int	MT_try_lock(MT_Lock l);

@-
Dump info about the lock named 'name' on stream 'fp'.
@h
gdk_export void 	MT_dump_lock(MT_Lock l, FILE *fp, char *name);

@- Mthreads Macro Implementations

@-
Create a counting thread semaphore, set the number of resources.
@h
gdk_export MT_Sema	MT_create_sema(int nresources);     


@-
Destroy a counting thread semaphore;
@h
gdk_export void	MT_destroy_sema(MT_Sema s);     

@-
Increment a semaphore.
@h
gdk_export void	MT_up_sema(MT_Sema s, char *name);
 
@-
Decrement a semaphore. If it already has value 0, the thread is
blocked until a decrement is possible again.
@h
gdk_export void	MT_down_sema(MT_Sema s, char *name);

@-
Try to decrement a semaphore. If it already has value 0, an error
(EBUSY) is returned. Else, the semaphore is decremented.
@h
gdk_export int 	MT_try_sema(MT_Sema s);

@-
Dump info about the semaphore named 'name' on stream 'fp'.
@h
gdk_export void 	MT_dump_sema(MT_Sema s, FILE *fp, char *name);

@-
Check if some process is still alive.
@h
gdk_export int 	MT_alive(int pid);

@-
Allocate anonymous virtual memory.
@h
#define MT_geterrno()		errno
#define MT_seterrno(x)		errno=x

gdk_export int _MT_npages;
gdk_export int _MT_pagesize;
 
#define MT_pagesize()	_MT_pagesize
#define MT_npages()	_MT_npages

#endif /*_GDK_SYSTEM_H_*/

@- Mthreads Routine implemtations
@c
#include "gdk_system.h"

#ifdef HAVE_PTHREAD_H
# include <pthread.h>
# include <semaphore.h>
#endif

#include <errno.h>

typedef sem_t pthread_sema_t;

static void pthread_sema_up( pthread_sema_t *s );
static void pthread_sema_down( pthread_sema_t *s );

MT_Lock		MT_system_lock = NULL;		/* system administration lock */

pthread_mutex_t	MT_firstlock[MAXLOCKS];
pthread_sema_t	MT_firstsema[MAXSEMAS];

int MT_curlock=0, MT_nextlock[MAXLOCKS];
int MT_cursema=0, MT_nextsema[MAXSEMAS];

int     _MT_pagesize = 0;               /* variable holding memory size */
int     _MT_npages = 0;                 /* variable holding page size */
 
void MT_init() {
	static pthread_mutex_t l;
	int i;

        _MT_pagesize = sysconf(_SC_PAGESIZE);
	if (_MT_pagesize <= 0) _MT_pagesize = 4096; /* default */ 

#ifdef _SC_PHYS_PAGES
                _MT_npages = sysconf(_SC_PHYS_PAGES);
#else
        {
#ifdef HAVE_RLIMIT
#ifdef HAVE_SYS_RESOURCE_H
                #include <sys/resource.h>
#endif
                struct rlimit rl;
                getrlimit(RLIMIT_RSS, &rl);
                _MT_npages = rl.rlim_cur / _MT_pagesize;
#endif
        }
#endif
	
	pthread_mutex_init(&l, 0);
	for(i=1; i<MAXLOCKS; i++) {
		MT_nextlock[i-1] = i;
	}
	MT_nextlock[MAXLOCKS-1] = -1;

	for(i=1; i<MAXSEMAS; i++) {
		MT_nextsema[i-1] = i;
	}
	MT_nextsema[MAXSEMAS-1] = -1;

	MT_system_lock = (MT_Lock) &l;
}

int	MT_create_thread (MT_Id *t, void (*f)(void *), void *arg) {
	sigset_t new_mask, orig_mask;
	pthread_attr_t attr;
	int  ret;

        (void)sigfillset(&new_mask);
        (void)sigdelset(&new_mask, SIGINT);
        (void)sigdelset(&new_mask, SIGQUIT);
        (void)pthread_sigmask(SIG_SETMASK, &new_mask, &orig_mask);
	pthread_attr_init(&attr);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	ret = pthread_create((pthread_t*)t, &attr, (void*(*)(void*))f, arg);
        if (ret == 0) (*(int*)t)++; /* use pthread-id + 1 */
        (void)pthread_sigmask(SIG_SETMASK, &orig_mask, NULL);
	return ret;
}

void 	MT_global_exit(int s) {
#if 0
	(void) kill(0, SIGHUP);
	pthread_kill_other_threads_np();
#endif
	exit(s);
}


void 	MT_exit_thread(int s) {
	int st=0;
	pthread_exit(&st);
}


int 	MT_kill_thread (MT_Id t) {
	int id = (int)t-1;
	return pthread_kill((pthread_t)id, SIGHUP);
}

MT_Lock	MT_create_lock() {
	pthread_mutex_t *new_mutex;

	MT_set_lock(MT_system_lock, "MT_create_lock");
	if (MT_curlock == -1) {
	    fprintf(MT_out, "MT_create_lock: ran out of locks.\n");
	    MT_global_exit(-1);
	}
	new_mutex = MT_firstlock + MT_curlock;
	MT_curlock = MT_nextlock[MT_curlock];
	MT_unset_lock(MT_system_lock, "MT_create_lock");
	pthread_mutex_init(new_mutex, 0);

	return (MT_Lock) new_mutex;
}


void	MT_destroy_lock (MT_Lock l) {
	int idx = (int) (((pthread_mutex_t*) l) - MT_firstlock);
	if (l == NULL) return;
	pthread_mutex_destroy(l);
	MT_set_lock(MT_system_lock, "MT_destroy_lock");
	MT_nextlock[idx] = MT_curlock;
	MT_curlock = idx;
	MT_unset_lock(MT_system_lock, "MT_destroy_lock");
}

void MT_set_lock(MT_Lock l, char *name){
    	int t = pthread_mutex_lock((pthread_mutex_t*)l);
    	if (MT_debug & 1024) {
        	fprintf(MT_out,"MT_set_lock(%lu\@%s) %ld %d\n", 
			(long)MT_getpid(), name, (long)l, t);
        	fflush(MT_out);
    	}
}

void MT_unset_lock(MT_Lock l, char *name)	{
   	int t = pthread_mutex_unlock((pthread_mutex_t*)l);
    	if (MT_debug & 1024) {
        	fprintf(MT_out,"MT_unset_lock(%lu\@%s) %ld %d\n", 
			(long)MT_getpid(), name, (long)l,t);
        	fflush(MT_out);
	}   
}
 
int	MT_try_lock (MT_Lock l) {
	if (MT_debug & 1024) {
		fprintf(MT_out,"MT_try_lock:%u %d\n", 
			(unsigned int) THRgettid(), (int) l);
		fflush(MT_out);
	}
	if (l == NULL) return 0;
	return pthread_mutex_trylock(l);
}


void 	MT_dump_lock (MT_Lock l, FILE *fp, char* name) {
	fprintf(fp, "%s: MT_dump_lock() not implemented.\n", name);
}

void pthread_sema_init( pthread_sema_t *s, int nresources ) {
	(void)sem_init( s, 0, nresources );
}

void pthread_sema_destroy( pthread_sema_t *s ){
	(void)sem_destroy( s );
}

void pthread_sema_up( pthread_sema_t *s ) {
	(void)sem_post(s);
}

void pthread_sema_down( pthread_sema_t *s ) {
	(void)sem_wait(s);
}

void MT_up_sema(MT_Sema s, char *name){
    	pthread_sema_up((pthread_sema_t*)s);
    	if (MT_debug &  1024) {
        	fprintf(MT_out,"MT_up_sema(%lu\@%s) %ld\n", 
			(long)MT_getpid(), name, (long)s);
        	fflush(MT_out);
    	}
}
 
void MT_down_sema(MT_Sema s, char *name){
    	pthread_sema_down((pthread_sema_t*)s);
    	if (MT_debug &  1024) {
        	fprintf(MT_out,"MT_down_sema(%lu\@%s) %ld\n", 
			(long)MT_getpid(), name, (long)s);
        	fflush(MT_out);
	}   
}

int	MT_try_sema (MT_Sema s){
	if (MT_debug & 1024) {
		fprintf(MT_out,"MT_try_sema:%u %d\n", 
			(unsigned int) THRgettid(), (int) s);
		fflush(MT_out);
	}
	if (s == NULL) return 0;
	return (sem_wait(s));
}


MT_Sema	MT_create_sema (int nresources) {
	pthread_sema_t *new_sema;

	MT_set_lock(MT_system_lock, "MT_create_sema");
	if (MT_cursema == -1) {
	    fprintf(MT_out, "MT_create_sema: ran out of semaphores.\n");
	    MT_global_exit(-1);
	}
	new_sema = MT_firstsema + MT_cursema;
	MT_cursema = MT_nextsema[MT_cursema];
	MT_unset_lock(MT_system_lock, "MT_create_sema");

	pthread_sema_init(new_sema, nresources );
	return (MT_Sema) new_sema;
}


void	MT_destroy_sema (MT_Sema s) {
	int idx = (int) (((pthread_sema_t*) s) - MT_firstsema);

	if (s == NULL) return;
	pthread_sema_destroy(s);
	MT_set_lock(MT_system_lock, "MT_destroy_sema");
	MT_nextsema[idx] = MT_cursema;
	MT_cursema = idx;
	MT_unset_lock(MT_system_lock, "MT_destroy_sema");
}

void 	MT_dump_sema (MT_Sema s, FILE *fp, char *name) {
	fprintf(fp, "%s: MT_dump_sema() not implemented.\n",name);
}

MT_Id MT_getpid(){
	return (MT_Id)((int)pthread_self()+1);
}

int MT_alive(pid)
int pid;
{
	int st = getpgid(pid);
	return (st >= 0 && st != ESRCH);
}
