@f gdk_system
@+ Pthreads Mthreads Dependencies
@T
This file contains the Mthreads implementation based on the posix 
thread library interface, consisting of posix standaard thread 
functions. 

@- Pthread Definitions
@h
#ifndef _GDK_SYSTEM_H_
#define _GDK_SYSTEM_H_

#include <config.h>

#ifdef HAVE_MALLOC_H
# include <malloc.h>	/* mallopt, mallinfo, and  malloc, free etc. */
#endif

#ifdef HAVE_SYS_MMAN_H
# include <sys/mman.h>
#endif

#if HAVE_UNISTD_H
# include <unistd.h>     /* io functions */
#endif
#ifdef HAVE_FCNTL_H
#include <fcntl.h>
#endif

#include <stdio.h>

#ifndef MAP_NORESERVE
#define MAP_NORESERVE MAP_PRIVATE
#endif 

#ifndef HAVE_GETPGID
#define getpgid __getpgid
#endif 

#ifndef HAVE_MADVISE
# define madvise(x,y,z)	0
# ifndef MADV_RANDOM
#  define MADV_RANDOM	0
# endif
#endif 

#define NOMALLOPT

#ifdef HAVE_NOMALLINFO
#define M_MXFAST	1  /* set size of blocks to be fast */
#define M_NLBLKS	2  /* set number of block in a holding block */
#define M_GRAIN		3  /* set number of sizes mapped to one, for */
                           /* small blocks */
#define M_KEEP		4  /* retain contents of block after a free */
                           /* until another allocation */

typedef struct mallinfo  {
        int arena;      /* total space in arena */
        int ordblks;    /* number of ordinary blocks */
        int smblks;     /* number of small blocks */
        int hblks;      /* number of holding blocks */
        int hblkhd;     /* space in holding block headers */
        int usmblks;    /* space in small blocks in use */
        int fsmblks;    /* space in free small blocks */
        int uordblks;   /* space in ordinary blocks in use */
        int fordblks;   /* space in free ordinary blocks */
        int keepcost;   /* cost of enabling keep option */
} mallinfo_t;
extern struct mallinfo mallinfo();

#define mallopt(cmd,value)	0
#endif

@- pthreads Includes and Definitions
@h
#include <sys/types.h>
#ifdef HAVE_SYS_SIGNAL_H
# include <sys/signal.h>
#endif

#ifdef HAVE_PTHREAD_H
# include <pthread.h>
# include <semaphore.h>
#endif

typedef void    *MT_Lock;
typedef void    *MT_Sema;
typedef void    *MT_Id;
typedef sem_t pthread_sema_t;

extern void pthread_sema_up( pthread_sema_t *s );
extern void pthread_sema_down( pthread_sema_t *s );

#define MAXLOCKS	128
#define MAXSEMAS	64

@- Environment Specific Defines
Define your error reporting routine @%MT_error(str message)@.
@h
#define MT_error	GDKsyserror	
#define MT_warning	GDKwarning	
@-
Define your error integer debug flag @%MT_debug@.
@h
#define MT_debug	GDKdebug
extern int GDKdebug;
@-
Define your debug printing stream @%MT_out@.
@h
void *THRgetdata	(int);
#define MT_out		stderr

@- Global Variables
The are part of the interface (i.e. you may use them).
@h
extern MT_Lock	MT_system_lock;	/* system administration lock */

@+ Interface Definition
The routines that are available for use for thread and process management.
@-
Init the package. Must be called once before any of the other operations.
@h
void 	MT_init ();

@-
Create a new thread executing 'function' with single parameter 'arg'. 
May return an error, in which case no thread is created.
@h
int 	MT_create_thread(MT_Id *t, void (*function)(void *), void *arg);

@-
Exit the current thread. The status will be ignored, unless some thread
wait()-s for you to finish.
a wait()
@h
void 	MT_exit_thread(int status);

@-
Exit the process. All threads are terminated.
@h
void 	MT_global_exit(int status);

@-
Ask your thread id.
@h
MT_Id 	MT_getpid();


@-
Kill a thread.
@h
int 	MT_kill_thread(MT_Id t);

@-
Create a new inter-process lock. Initial status: unset.
@h
MT_Lock	MT_create_lock();

@-
Destroy an inter-process lock;
@h
void	MT_destroy_lock(MT_Lock l);     

@-
Create a new thread-lock. Initial status: unset.
@h
MT_Lock	MT_create_lock();


@-
Destroy a thread-lock;
@h
void	MT_destroy_lock(MT_Lock l);     

@-
Set a lock. The calling thread in this process blocks till the lock is set.
@h
#define MT_set_lock(x,y)	{\
    int t = pthread_mutex_lock((pthread_mutex_t*)x);\
    if (MT_debug & 1024) {\
        fprintf(MT_out,"MT_set_lock(%lu\@%s) %ld %d\n", (long)MT_getpid(), y, (long)x, t);\
        fflush(MT_out);\
    }\
}
 
 
@-
Unset a lock.
@h
#define MT_unset_lock(x,y)	{\
    int t = pthread_mutex_unlock((pthread_mutex_t*)x);\
    if (MT_debug & 1024) {\
        fprintf(MT_out,"MT_unset_lock(%lu\@%s) %ld %d\n", (long)MT_getpid(), y, (long)x,t);\
        fflush(MT_out);\
}   }
 
@-
Try a lock. Returns error (EBUSY) if the lock was already 
set. Else, the lock is set.
@h
int	MT_try_lock(MT_Lock l);

@-
Dump info about the lock named 'name' on stream 'fp'.
@h
void 	MT_dump_lock(MT_Lock l, FILE *fp, char *name);

@- Mthreads Macro Implementations

@-
Create a counting thread semaphore, set the number of resources.
@h
MT_Sema	MT_create_sema(int nresources);     


@-
Destroy a counting thread semaphore;
@h
void	MT_destroy_sema(MT_Sema s);     

@-
Increment a semaphore.
@h
#define MT_up_sema(x,y)	{\
    pthread_sema_up((pthread_sema_t*)x);\
    if (MT_debug &  1024) {\
        fprintf(MT_out,"MT_up_sema(%lu\@%s) %ld\n", (long)MT_getpid(), y, (long)x);\
        fflush(MT_out);\
}   }
 
 
@-
Decrement a semaphore. If it already has value 0, the thread is
blocked until a decrement is possible again.
@h
#define MT_down_sema(x,y)	{\
    pthread_sema_down((pthread_sema_t*)x);\
    if (MT_debug &  1024) {\
        fprintf(MT_out,"MT_down_sema(%lu\@%s) %ld\n", (long)MT_getpid(), y, (long)x);\
        fflush(MT_out);\
}   }

@-
Try to decrement a semaphore. If it already has value 0, an error
(EBUSY) is returned. Else, the semaphore is decremented.
@h
int 	MT_try_sema(MT_Sema s);

@-
Dump info about the semaphore named 'name' on stream 'fp'.
@h
void 	MT_dump_sema(MT_Sema s, FILE *fp, char *name);

@-
Check if some process is still alive.
@h
int 	MT_alive(int pid);

@-
Allocate anonymous virtual memory.
@h
void* 	MT_vmalloc(size_t size, size_t *maxsize);
void 	MT_vmfree(void* p, size_t size);
void* 	MT_vmrealloc(void* p, size_t oldsize, size_t newsize, size_t *maxsize);

#define MT_geterrno()		errno
#define MT_seterrno(x)		errno=x
#define MT_getpid()		(MT_Id)((int)pthread_self()+1)

extern int _MT_npages;
extern int _MT_pagesize;
 
#define MT_pagesize()	_MT_pagesize
#define MT_npages()	_MT_npages

#endif /*_GDK_SYSTEM_H_*/

@- Mthreads Routine implemtations
@c
#include "gdk_system.h"

#include <errno.h>

MT_Lock		MT_system_lock = NULL;		/* system administration lock */

pthread_mutex_t	MT_firstlock[MAXLOCKS];
pthread_sema_t	MT_firstsema[MAXSEMAS];

int MT_curlock=0, MT_nextlock[MAXLOCKS];
int MT_cursema=0, MT_nextsema[MAXSEMAS];

int     _MT_pagesize = 0;               /* variable holding memory size */
int     _MT_npages = 0;                 /* variable holding page size */
 
void MT_init() {
	static pthread_mutex_t l;
	int i;

        _MT_pagesize = sysconf(_SC_PAGESIZE);
	if (_MT_pagesize <= 0) _MT_pagesize = 4096; /* default */ 

#ifdef _SC_PHYS_PAGES
                _MT_npages = sysconf(_SC_PHYS_PAGES);
#else
        {
#ifdef HAVE_RLIMIT
#ifdef HAVE_SYS_RESOURCE_H
                #include <sys/resource.h>
#endif
                struct rlimit rl;
                getrlimit(RLIMIT_RSS, &rl);
                _MT_npages = rl.rlim_cur / _MT_pagesize;
#endif
        }
#endif
	
	pthread_mutex_init(&l, 0);
	for(i=1; i<MAXLOCKS; i++) {
		MT_nextlock[i-1] = i;
	}
	MT_nextlock[MAXLOCKS-1] = -1;

	for(i=1; i<MAXSEMAS; i++) {
		MT_nextsema[i-1] = i;
	}
	MT_nextsema[MAXSEMAS-1] = -1;

	MT_system_lock = (MT_Lock) &l;
}


int	MT_create_thread (MT_Id *t, void (*function)(void *), void *arg) {
	sigset_t new_mask, orig_mask;
	pthread_attr_t attr;
	int  ret;

	void *(*func)(void*)=(void*(*)(void*))function;
        (void)sigfillset(&new_mask);
        (void)sigdelset(&new_mask, SIGINT);
        (void)sigdelset(&new_mask, SIGQUIT);
        (void)pthread_sigmask(SIG_SETMASK, &new_mask, &orig_mask);
	pthread_attr_init(&attr);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	ret = pthread_create((pthread_t*)t, &attr, func, arg);
        if (ret == 0) (*(int*)t)++; /* use pthread-id + 1 */
        (void)pthread_sigmask(SIG_SETMASK, &orig_mask, NULL);
	return ret;
}

void 	MT_global_exit(int s) {
#if 0
	(void) kill(0, SIGHUP);
	pthread_kill_other_threads_np();
#endif
	exit(s);
}


void 	MT_exit_thread(int s) {
	int st=0;
	pthread_exit(&st);
}


int 	MT_kill_thread (MT_Id t) {
	int id = (int)t-1;
	return pthread_kill((pthread_t)id, SIGHUP);
}

MT_Lock	MT_create_lock() {
	pthread_mutex_t *new_mutex;

	MT_set_lock(MT_system_lock, "MT_create_lock");
	if (MT_curlock == -1) {
	    fprintf(MT_out, "MT_create_lock: ran out of locks.\n");
	    MT_global_exit(-1);
	}
	new_mutex = MT_firstlock + MT_curlock;
	MT_curlock = MT_nextlock[MT_curlock];
	MT_unset_lock(MT_system_lock, "MT_create_lock");
	pthread_mutex_init(new_mutex, 0);

	return (MT_Lock) new_mutex;
}


void	MT_destroy_lock (MT_Lock l) {
	int idx = (int) (((pthread_mutex_t*) l) - MT_firstlock);
	if (l == NULL) return;
	pthread_mutex_destroy(l);
	MT_set_lock(MT_system_lock, "MT_destroy_lock");
	MT_nextlock[idx] = MT_curlock;
	MT_curlock = idx;
	MT_unset_lock(MT_system_lock, "MT_destroy_lock");
}

int	MT_try_lock (MT_Lock l) {
	if (MT_debug & 1024) {
		fprintf(MT_out,"MT_try_lock:%u %d\n", 
			(unsigned int) THRgettid(), (int) l);
		fflush(MT_out);
	}
	if (l == NULL) return 0;
	return pthread_mutex_trylock(l);
}


void 	MT_dump_lock (MT_Lock l, FILE *fp, char* name) {
	fprintf(fp, "%s: MT_dump_lock() not implemented.\n", name);
}

void pthread_sema_init( pthread_sema_t *s, int nresources ) {
	(void)sem_init( s, 0, nresources );
}

void pthread_sema_destroy( pthread_sema_t *s ){
	(void)sem_destroy( s );
}

void pthread_sema_up( pthread_sema_t *s ) {
	(void)sem_post(s);
}

void pthread_sema_down( pthread_sema_t *s ) {
	(void)sem_wait(s);
}

int	MT_try_sema (MT_Sema s){
	if (MT_debug & 1024) {
		fprintf(MT_out,"MT_try_sema:%u %d\n", 
			(unsigned int) THRgettid(), (int) s);
		fflush(MT_out);
	}
	if (s == NULL) return 0;
	return (sem_wait(s));
}


MT_Sema	MT_create_sema (int nresources) {
	pthread_sema_t *new_sema;

	MT_set_lock(MT_system_lock, "MT_create_sema");
	if (MT_cursema == -1) {
	    fprintf(MT_out, "MT_create_sema: ran out of semaphores.\n");
	    MT_global_exit(-1);
	}
	new_sema = MT_firstsema + MT_cursema;
	MT_cursema = MT_nextsema[MT_cursema];
	MT_unset_lock(MT_system_lock, "MT_create_sema");

	pthread_sema_init(new_sema, nresources );
	return (MT_Sema) new_sema;
}


void	MT_destroy_sema (MT_Sema s) {
	int idx = (int) (((pthread_sema_t*) s) - MT_firstsema);

	if (s == NULL) return;
	pthread_sema_destroy(s);
	MT_set_lock(MT_system_lock, "MT_destroy_sema");
	MT_nextsema[idx] = MT_cursema;
	MT_cursema = idx;
	MT_unset_lock(MT_system_lock, "MT_destroy_sema");
}

void 	MT_dump_sema (MT_Sema s, FILE *fp, char *name) {
	fprintf(fp, "%s: MT_dump_sema() not implemented.\n",name);
}


int MT_alive(pid)
int pid;
{
	int st = getpgid(pid);
	return (st >= 0 && st != ESRCH);
}


#define MT_PAGESIZE(s)	((((s-1)/MT_pagesize())+1)*MT_pagesize())
 

/*
#ifdef HAVE_MAP_ANONYMOUS

void *MT_vmalloc(size_t size, size_t *maxsize) {
        char *q, *r = (char*) -1;
 
        size = MT_PAGESIZE(size);
        *maxsize = MT_PAGESIZE(*maxsize);
        if (*maxsize > size) {
                r = (char*) mmap(NULL, *maxsize, PROT_NONE,
                                MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);
        }
        if (r == (char*) -1) {
                *maxsize = size;
                q = (char*) mmap(NULL, size, PROT_READ|PROT_WRITE,
                                MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);
        } else {
                q = (char*) mmap(r, size, PROT_READ|PROT_WRITE,
                                MAP_PRIVATE|MAP_ANONYMOUS|MAP_FIXED, -1, 0);
        }
        return (void*) (q == (char*) -1)?NULL:q;
}

 
void MT_vmfree(void *p, size_t size) {
        size = MT_PAGESIZE(size);
        munmap(p, size);
}

void *MT_vmrealloc(void *pt, size_t oldsize, size_t newsize, size_t *maxsize) {
	char *p = (char*)pt;
        char *q = (char*) -1;
 
        oldsize = MT_PAGESIZE(oldsize);
        newsize = MT_PAGESIZE(newsize);
        *maxsize = MT_PAGESIZE(*maxsize);
 
        if (oldsize > newsize) {
                munmap(p+oldsize, oldsize-newsize);
        }
        if (oldsize >= newsize) {
                return p;
        }
        if (newsize < *maxsize) {
		q = (char*) mmap(p+oldsize, newsize-oldsize,
			PROT_READ|PROT_WRITE,
			MAP_PRIVATE|MAP_ANONYMOUS|MAP_FIXED, -1, oldsize);
        }
        if (q == (char*) -1) {
                int oldmaxsize = *maxsize;
                q = p; p = (char*) MT_vmalloc(newsize, maxsize);
                if (p != NULL) {
                        memcpy(p, q, oldsize);
                        MT_vmfree(q, oldmaxsize);
                }
        }
        return p;
}

#else /* NO MAP_ANONYMOUS */

void *MT_vmalloc(size_t size, size_t *maxsize) {
	int fd = open("/dev/zero", O_RDWR, 0666);
	char *q, *r = (char*) -1;

	if (fd < 0) {
		return NULL;
	}
	size = MT_PAGESIZE(size);
	*maxsize = MT_PAGESIZE(*maxsize);
	if (*maxsize > size) {
		r = (char*) mmap(NULL, *maxsize, PROT_NONE,
				MAP_PRIVATE|MAP_NORESERVE, fd, 0);
	}
	if (r == (char*) -1) {
		*maxsize = size;
		q = (char*) mmap(NULL, size, PROT_READ|PROT_WRITE, 
				MAP_PRIVATE, fd, 0);
	} else {
		q = (char*) mmap(r, size, PROT_READ|PROT_WRITE, 
				MAP_PRIVATE|MAP_FIXED, fd, 0);
	}
	close(fd);
	return (void*) (q == (char*) -1)?NULL:q;
}

void MT_vmfree(void *p, size_t size) {
	size = MT_PAGESIZE(size);
	munmap(p, size);
}

void *MT_vmrealloc(void *voidptr, size_t oldsize, size_t newsize, size_t *maxsize) {
        char *p=(char*)voidptr;
	char *q = (char*) -1;

	oldsize = MT_PAGESIZE(oldsize);
	newsize = MT_PAGESIZE(newsize);
	*maxsize = MT_PAGESIZE(*maxsize);

	if (oldsize > newsize) {
		munmap(p+oldsize, oldsize-newsize);
	} 
        if (oldsize >= newsize) {
                return p;
        }
	if (newsize < *maxsize) {
		int fd = open("/dev/zero", O_RDWR, 0666);
		if (fd >= 0) {
			q = (char*) mmap(p+oldsize, newsize-oldsize, 
				PROT_READ|PROT_WRITE, 
				MAP_PRIVATE|MAP_FIXED, fd, oldsize);
			close(fd);
		}
	}	
	if (q == (char*) -1) {
		int oldmaxsize = *maxsize;
                q = p; p = (char*) MT_vmalloc(newsize, maxsize);
                if (p != NULL) {
                        memcpy(p, q, oldsize);
                        MT_vmfree(q, oldmaxsize);
                }
	}
	return p;
}
/*
#endif /* NO MAP_ANONYMOUS */

