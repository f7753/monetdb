@f gdk_storage
@a M. L. Kersten, P. Boncz

@* Database Storage Management
Contains routines for writing and reading GDK data to and from disk.
This section contains the primitives to manage the disk-based images
of the BATs. It relies on the existence of a UNIX file system, including
memory mapped files. Solaris and IRIX have different implementations of
madvise().

The current version assumes that all BATs are stored on a single disk
partition. This simplistic assumption should be replaced in the near
future by a multi-volume version. The intension is to use several
BAT home locations.

The files should be owned by the database server. Otherwise, IO operations are
likely to fail. This is accomplished by setting the GID and UID upon 
system start.
@{ 
@h
#ifndef _GDK_STORAGE_H_
#define _GDK_STORAGE_H_
#include "gdk.h"

#endif /* _GDK_STORAGE_H_ */
@c
#include "gdk_bat.h"
#include "gdk_delta.h"
#include "gdk_atoms.h"
#include "gdk_bbp.h"
#include "gdk_search.h"
#include "gdk_utils.h"
#include "gdk_storage.h"
#include "gdk_posix.h"
@}

@
@{
@c
void GDKfilepath(str path, str dir, str name, str ext) {
	*path = 0;
	if (dir && *name != DIR_SEP) {
		strcpy(path, dir);
		path += strlen(dir); 
	}
	strcpy(path, name);
	if (ext) {
		path += strlen(name); 
		*path++ = '.';
		strcpy(path, ext);
	}
}

int GDKcreatedir(char *dir) {
	long_str path;
	char *r;
	int ret = TRUE;

	strcpy(path, dir);
 	r = strrchr(path, DIR_SEP);
        IODEBUG THRprintf(GDKerr, "GDKcreatedir(%s)\n", path);
	if (r) {
		DIR *dirp;
		*r = 0;
		dirp = opendir(path);
		if (dirp) {
			closedir(dirp);
		} else {
			GDKcreatedir(path);
			ret = mkdir(path, 0755);
        		IODEBUG THRprintf(GDKerr, "mkdir %s = %d\n", path, ret);
		}
 		*r = DIR_SEP;
	}
	return !ret;
}

int GDKremovedir(str dirname) {
        DIR *dirp = opendir(dirname);
        long_str path;
        struct dirent *dent;
	int ret;
 
        IODEBUG THRprintf(GDKerr, "GDKremovedir(%s)\n", dirname);
        if (dirp == NULL) return 0;
        while((dent = readdir(dirp)) != NULL) {
		if ((dent->d_name[0] == '.') && ((dent->d_name[1] == 0) ||
			    (dent->d_name[1] == '.' && dent->d_name[2] == 0)))
		{
			continue;
		} 
		GDKfilepath(path, dirname, dent->d_name, NULL);
                ret = unlink(path);
        	IODEBUG THRprintf(GDKerr, "unlink %s = %d\n", path, ret);
        }
        closedir(dirp);
        ret = rmdir(dirname);
        if (ret < 0) {
                GDKsyserror("GDKremovedir: rmdir(%s) failed.\n", DELDIR);
        }
        IODEBUG THRprintf(GDKerr, "rmdir %s = %d\n", dirname, ret);
        return ret;
}
 
#define _FUNBUF         0x040000
#define _FWRTHR         0x080000
#define _FRDSEQ         0x100000

int GDKfdlocate(str nme, str mode, str extension) {
	char buf[PATHLENGTH], *path=buf; 
	int fd, flags = 0;

	if ((nme == NULL) || (*nme == 0) ) {
		return 0; 
	}
	GDKfilepath(path,BATDIR,nme,extension);

	if (*mode == 'm') { /* file open for mmap? */
		mode++;
#ifdef _CYGNUS_H_
	} else {
		flags = _FRDSEQ; /* WIN32 CreateFile(FILE_FLAG_SEQUENTIAL_SCAN) */
#endif
	}

	if (strchr(mode, 'w')) {
		flags |= O_WRONLY|O_CREAT;
	} else if (!strchr(mode, '+')) {
		flags |= O_RDONLY;
	} else {
		flags |= O_RDWR;
	}
#ifdef WIN32
	if (strchr(mode, 'b')) {
		flags |= O_BINARY;
	}
#endif
	fd = open(path, flags, 0644);
	if (fd < 0 && *mode == 'w') { 
		/* try to create the directory, if that was the problem */
		char tmp[PATHLENGTH];
		strcpy(tmp, buf);
		if (GDKcreatedir(tmp)) { 
			fd = open(path,flags,0644);
		}
	}
	return fd;
}

FILE *GDKfilelocate(str nme, str mode, str extension) {
	int fd = GDKfdlocate(nme, mode, extension);
	if (*mode == 'm') mode++; 
	return (fd<0)?NULL:fdopen(fd,mode);
}


@-
Unlink the file. It starts with trying to removed the uncompressed
version. If it fails then the compressed file is removed
This way we save about half the system calls, because each file can 
only be in one state.
@c
int GDKunlink(str dir, str nme, str ext) {
	long_str path;
	int err, t0 = GDKms();

	if ((nme == NULL) || (*nme == 0) ) {
		return -1; 
	}
	GDKfilepath(path,dir,nme,ext);
	err = unlink(path); 
	IODEBUG THRprintf(GDKerr, "unlink %s = %d (%dms)\n", path, err, GDKms() - t0); 
	if (err < 0) {
		long_str path2;
		strcpy(path2, path); strcat(path2, ".Z");
		err = unlink(path2); 
		if (err) GDKsyserror("GDKunlink(%s)\n", path);
		IODEBUG THRprintf(GDKerr, "2nd unlink %s = %d\n", path2, err); 
	}
	return err;
}

@-
The UNIX link routine is overloaded to deal with extensions.
@c
int GDKlink(str dir1, str nme1, str ext1, str dir2, str nme2, str ext2) {
	char	path1[PATHLENGTH]; 
	char	path2[PATHLENGTH]; 
	int	ret, t0 = GDKms();

	if ((nme1 == NULL) || (*nme1 == 0) ) {
		return -1; 
	}
	GDKfilepath(path1,dir1,nme1,ext1);
	GDKfilepath(path2,dir2,nme2,ext2);

	ret = link(path1, path2);
	if (ret) {
		GDKsyserror("GDKlink(%s,%s)\n", path1, path2);
	}
	IODEBUG THRprintf(GDKerr, "link %s %s = %d (%dms)\n", path1, path2, ret, GDKms()-t0); 
	return ret;
}

@+ Save and load.
The BAT is saved on disk in several files. The extension DESC
denotes the descriptor, BUNs the bun heap, and HHEAP and THEAP
the other heaps. The storage mechanism on file is either compressed or
memory-layout. The latter is required for memory mapped files.
The mode is either STORE_COMPR, STORE_MMAP, or STORE_MEM.

The mode indicates the disk-layout and the intended mapping.
The primary concern here is to handle STORE_MMAP and STORE_MEM.
@c
extern int compress   (str buf, str end, FILE* fp);
extern int decompress (FILE* fp, str dst);

int GDKsave(str nme, str ext, str buf, int size, int mode) { 
	int fd = -1, err = 0;
	FILE *fp = NULL; 

	IODEBUG THRprintf(GDKerr, "GDKsave: name=%s, ext=%s, mode %d\n", nme,ext?ext:"", mode);
	if (mode == STORE_MMAP) {
@-
Only dirty pages must be written to disk. Unchanged block will still be mapped
on the file, reading those will be cheap.  Only the changed blocks are now 
mapped to swap space. PUSHED OUT: due to rather horrendous performance 
caused by updating the image on disk.
@
Maybe it is better to make use of @%msync()@. But then, we would need to
bring in a backup mechanism, in which stable images of the BATs are created
at commit-time.
@c
		err = MT_msync(buf, size, 0);
		if (err) GDKsyserror("GDKsave: error on: name=%s, ext=%s, mode=%d\n", 
				     nme,ext?ext:"", mode );
		IODEBUG THRprintf(GDKerr, "msync(buf %d, size %d, MS_ASYNC) = %d\n", 
							(int) buf, size, err);
	} else if (mode == STORE_COMPR) {
		char extension[PATHLENGTH];
        	sprintf(extension, "%s.Z", ext); 
		if ((fp = GDKfilelocate(nme, "wb", extension)) != NULL) {
	                if (compress((char *) buf, ((char *) buf) + size, fp) <  0) { 
				err = -1;
			}
			if (err) GDKsyserror("GDKsave: error on: name=%s, ext=%s, mode=%d\n", 
				     nme,ext?ext:"", mode );
			IODEBUG THRprintf(GDKerr, "compress(buf %d, size %d, fd %d) = %d\n", 
							(int) buf, size, fileno(fp), err);
	       	}  else {
			err = -1;
		}
	} else {
		if ((fd = GDKfdlocate(nme, "wb", ext)) >= 0) {
			if (write(fd, buf, size)  != size) {
				err = -1;
			}
			if (err) GDKsyserror("GDKsave: error on: name=%s, ext=%s, mode=%d\n", 
				     nme,ext?ext:"", mode );
			IODEBUG THRprintf(GDKerr, "fwrite(buf %d, size %d, fd %d) = %d\n", 
							(int) buf, size, fd, err);
	       	}  else {
			err = -1;
		}
	}
	if (fp) {
		err |= fclose(fp); 
	} else if (fd >= 0) {
		err |= close(fd); 
	} else if (mode != STORE_MMAP) {
                char buf[MAXPATHLEN];
		GDKfilepath(buf,BATDIR,nme,ext);
		GDKerror("GDKsave: could not open: name=%s, ext=%s, mode %d\n", 
							nme, ext?ext:"", mode);
        }
	return err;
}

@
Space for the load is directly allocated and the heaps are mapped.
Further initialization of the atom heaps require a separate action
defined in their implementation.
@c
char *GDKload(str nme, str ext, int size, int chunk, int mode){
        char	extension[PATHLENGTH], *buf;
	int 	fd = -1, n, n_expected = 0; 
	int	varsize = mode&256;
	int	store = mode&255;
	FILE*	fp = NULL;

	IODEBUG {
	    THRprintf(GDKerr, "GDKload: name=%s, ext=%s, mode %d\n", nme, ext?ext:"", store);
	}
	sprintf(extension, "%s.Z", ext); 

	if (store == STORE_MEM) {
	    if ((fd = GDKfdlocate(nme, "rb+", ext)) >= 0) {
		/* some systems do not give you all at once */
		char *dst = buf = (char *) GDKmalloc(chunk); 

		for(n_expected = size; n_expected > 0; n_expected -= n){
                        n = read(fd, dst, n_expected);
			IODEBUG THRprintf(GDKerr, "read(dst %d, n_expected %d, fd %d) = %d\n", 
							(int) dst, n_expected, fd, n);
			if (n <= 0) break;
			dst += n;
		}
	    }
	} else {
	    if ((fp = GDKfilelocate(nme, "mrb+", ext)) != NULL) {
		long_str path; 
		int tpe = 0;
		/*
	        int tpe = (store==STORE_MMAP)?MAP_SHARED:MAP_PRIVATE;
	        int mod = (PROT_READ|PROT_WRITE);
		*/
		int mod = (store==STORE_MMAP)?(MMAP_READ):(MMAP_WRITE);
	        /* hack for STORE_MMAP & BAT_APPEND. This re-introduces the risk of stray
                 * memory writes into read-only heaps. In order to limit risk we might want 
                 * to only make the last part PROT_WRITE 
		 * int mod = (store==STORE_MMAP)?PROT_READ:(PROT_READ|PROT_WRITE); 
 		 */
		fseek(fp, (long) chunk, SEEK_SET);
               	fputc('\n',fp); fflush(fp);
	
		fclose(fp);
	        GDKfilepath(path,BATDIR,nme,ext);
		buf = (char *)MT_mmap(path, mod, 0, chunk, (void*)0);	
		/*
	       	buf = (char *) GDKmmap((caddr_t) 0, chunk, mod, tpe, fileno(fp),0);
		*/
		if (buf == (char *) -1)  {
       	    	    GDKsyserror("GDKload: cannot mmap(): name=%s, ext=%s\n", nme, ext?ext:"");
     		    buf = NULL;
		}
		IODEBUG THRprintf(GDKerr, "mmap(NULL, 0, chunk %d, mod %d, tpe %d, fd %d, 0) = %d\n",
						chunk, mod, tpe, fileno(fp), (int) buf);
		n_expected = 0;
	    }
	}
	if (fd < 0 && fp == NULL) { 
	if ((fp = GDKfilelocate(nme, "rb", extension)) != NULL) {
	    buf = (char *) GDKmalloc(chunk); 
	    n_expected = size - decompress(fp, buf); 
	} else {
       	    GDKsyserror("GDKload: cannot access: name=%s, extension=%s\n", nme,extension);
	    return 0; 
	}}
	if (n_expected >  0 && !varsize) {
       	    GDKerror("GDKload: read error: name=%s, ext=%s\n", nme,ext?ext:"");
	    return 0;
       	} else if (n_expected < 0) {
       	    GDKwarning("GDKload: file larger than expected: name=%s, ext=%s\n", nme, ext?ext:"");
	}
	if (fd >= 0) close(fd); 
	if (fp != NULL) fclose(fp); 
	return buf;
}

@+ BAT disk storage

Between sessions the BATs comprising the database are saved on disk.
To simplify code, we assume a UNIX directory called its  physical @%home@
where they are to be located.
The subdirectories BAT and PRG contain what its name says.

A BAT created by @%BATnew@ is considered temporary until one calls
the routine @%BATsave@. This routine reserves disk space and checks
for name clashes.

Saving and restoring BATs is left to the upper layers. The library merely
copies the data into place. 
Failure to read or write the BAT results in a NULL, otherwise
it returns the BAT pointer. 

Notice that the BAT may have been declared as (de) compressed.
In that case, we should change the disk layout structure with care.
@c
static BAT *DESCload(str nme, int i) {
	BATstore *bs;
	BAT *b = NULL;
	str s;

        if (BBP_physical(i)) {
		nme = BBP_physical(i);
	}
        IODEBUG {
                THRprintf(GDKerr, "DESCload %s\n", nme);
        }
	bs = BBPgetdesc(i, nme);
	if (bs == NULL) return 0;	
	b = &bs->B;
    
	if ((*b->hatom && ((b->htype = ATOMindex(s=b->hatom)) < 0)) ||
            (*b->tatom && ((b->ttype = ATOMindex(s=b->tatom)) < 0))) 
	{
                GDKerror("atom '%s' unknown, in BAT '%s'.\n",s,nme);
                return 0;
	}
    	b->hacctype = (b->hacctype && *b->haccname)?ACCindex(b->haccname):0;
    	b->tacctype = (b->tacctype && *b->taccname)?ACCindex(b->taccname):0;
    	if (b->hacctype < 0) {
                GDKwarning("accelerator '%s' unknown, in BAT '%s'.\n",	
			b->haccname, nme); *b->haccname = 0; b->hacctype = 0;
	}
    	if (b->tacctype < 0) {
                GDKwarning("accelerator '%s' unknown, in BAT '%s'.\n",	
			b->taccname, nme); *b->taccname = 0; b->tacctype = 0;
	}
	b->hhash_heap = b->thash_heap = NULL; 
	b->hidx_heap = b->tidx_heap = NULL; 
	b->batSharecnt = b->batStamp = b->void_cnt = 0;
	return b;
}

@-
implement heap mmap rules. return whether something changed.
@c
#define HEAPcurmode(x) ((x)->size?((x)->filename?(x)->storage:STORE_MEM):-1)

static int HEAPcheckmode(Heap *h, char storage, int writeable) {
	if (storage != (char) -1) {	
		if (storage == STORE_MMAP && writeable) {
			h->storage = STORE_PRIV; /* writable mmap needs copy-on-write */
			return 1;
		}
		if ((storage&STORE_MMAP) && h->free < GDKvm_minsize()) {
			h->storage = STORE_MEM;  /* avoid VM memory waste with a lowerbound */
			return 1;
		} 
	}
	h->storage = storage;
	return 0;
}

static void DESCsetmodes(BAT *b, BAT *img) {
	/* sanity check: if nothing proposed, set proposed modes to current modes */
	if (b->batMapdirty == 0 || b->batMapbuns == (char) -1) {
		b->batMapbuns = HEAPcurmode(b->batBuns);
	}
	if (b->batMapdirty == 0 || b->batMaphheap == (char) -1) {
		b->batMaphheap = HEAPcurmode(&b->hheap);
	}
	if (b->batMapdirty == 0 || b->batMaptheap == (char) -1) {
		b->batMaptheap = HEAPcurmode(&b->theap);
	}
	if (b->batMapdirty == 0 || b->batMaphacc == (char) -1) {
		b->batMaphacc = HEAPcurmode(&b->haccelerator);
	}
	if (b->batMapdirty == 0 || b->batMaptacc == (char) -1) {
		b->batMaptacc = HEAPcurmode(&b->taccelerator);
	}

	/* change modes into legal modes */
	b->batMapdirty |= HEAPcheckmode(img->batBuns, b->batMapbuns, b->batRestricted == BAT_WRITE);
	b->batMapdirty |= HEAPcheckmode(&img->hheap, b->batMaphheap, b->batRestricted == BAT_WRITE ||
				(b->batRestricted == BAT_APPEND && 
	  	 		(BATatoms[b->htype].atomHeapCheck != HEAP_check || !HEAP_mmappable(&img->hheap)) && 
				(ATOMstorage(b->htype) != TYPE_str || ELIMDOUBLES((&b->hheap)))));
	b->batMapdirty |= HEAPcheckmode(&img->theap, b->batMaptheap, b->batRestricted == BAT_WRITE ||
				(b->batRestricted == BAT_APPEND && 
	  	 		(BATatoms[b->ttype].atomHeapCheck != HEAP_check || !HEAP_mmappable(&img->theap)) && 
				(ATOMstorage(b->ttype) != TYPE_str || ELIMDOUBLES((&b->theap)))));
	b->batMapdirty |= HEAPcheckmode(&img->haccelerator, b->batMaphacc, b->batRestricted != BAT_READ);
	b->batMapdirty |= HEAPcheckmode(&img->taccelerator, b->batMaptacc, b->batRestricted != BAT_READ);
}

void DESCclean(BAT* b) {
	b->batDirtyflushed = DELTAdirty(b)?TRUE:FALSE;
	b->batDirty = 0;
	b->batDirtydesc = 0;
	b->batDirtybuns = 0;
	b->hheapdirty = 0;
	b->theapdirty = 0;
	b->haccdirty = 0;
	b->taccdirty = 0;
}

#define PERSISTENT_TYPE(fcn, col, tpe)\
	if (tpe != TYPE_bat && (BATatoms[tpe].atomFix||BATatoms[tpe].atomUnfix)) {\
		GDKerror("%s: %s[%s,%s] has transient %s type.\n", \
		    fcn, b->batId, ATOMname(b->htype), ATOMname(b->ttype), col);\
		return b;\
	}

BAT *BATsave(BAT *bd) {
	int     err = 0, remap = 0, hsaved = 0, tsaved = 0;
	char    *nme;
	BATstore bs;
	BAT *b = bd;
	
	BATcheck(b, "BATsave"); 
	if (VIEWparent(b) || !BATdirty(b)) {
		return b; 
	}
	if (b->batCacheid < 0) {
		b = BATmirror(b);
	}
	if (!DELTAdirty(b)) ALIGNcommit(b);
	if (!b->halign) b->halign = OIDnew(1);
	if (!b->talign) b->talign = OIDnew(1);
	PERSISTENT_TYPE("@1", "head", ATOMstorage(b->htype));
	PERSISTENT_TYPE("@1", "tail", ATOMstorage(b->htype));

	/* copy the descriptor to a local variable in order to let our messing in
	 * the BAT descriptor not affect other threads that only read it. */
	bs = *(BATstore*) b; 
	b = &bs.B;
	b->U = &bs.U;
	b->P = &bs.P;
	b->H = &bs.H;
	b->T = &bs.T;
	b->batBuns = &b->U->buns;

	/* check the legality of the heap modes */
	DESCsetmodes(bd, b);

	/* try to cut off unused bytes at the start of the heap */
	remap = (!(b->batBuns->storage & STORE_MMAP || b->batRestricted)) && 
	    b->hacctype == 0 && b->tacctype == 0;
	if (remap) {
		remap = (b->batDeleted - b->batBuns->base) / BUNsize(b);
		if (BUNsize(b) < sizeof(int)) {
			int x = sizeof(int)/BUNsize(b);
			remap = (remap/x)*x;
		}
		if (remap) {
			b->batBuns->free -= remap*BUNsize(b);
			b->batBuns->base += remap*BUNsize(b);
		}
	}

	/* start saving data */
	nme = BBP_physical(b->batCacheid);
	if (b->batCopiedtodisk == 0 || b->batDirty || b->batDirtybuns) {
		if (err == 0) err = HEAPsave(b->batBuns, nme, "buns");
	}
	if (b->batCopiedtodisk == 0 || b->batDirty || b->hheapdirty)
	if (b->htype && b->hvarsized)  {
		if (err == 0) err = HEAPsave(&b->hheap, nme, "hheap");
	}
	if (b->batCopiedtodisk == 0 || b->batDirty || b->theapdirty) 
	if (b->ttype && b->tvarsized) {
		if (err == 0) err = HEAPsave(&b->theap, nme, "theap");
	}
	if (b->batCopiedtodisk == 0 || b->batDirty || b->haccdirty) 
	if (b->haccelerator.base) {
                void (*fcn)(Heap*, BAT*) = BATaccelerators[b->hacctype].accSave;
                if (fcn) {
		    strcpy(b->haccname, ACCname(b->hacctype));
                    (*fcn)(&b->haccelerator, b);
                    if (err == 0) err = HEAPsave(&b->haccelerator, nme, "hacc");
                    if (err == 0) hsaved = TRUE;
                }
	}
	if (b->batCopiedtodisk == 0 || b->batDirty || b->taccdirty)
	if (b->taccelerator.base) {
                void (*fcn)(Heap*, BAT*) = BATaccelerators[b->tacctype].accSave;
                if (fcn) {
		    strcpy(b->taccname, ACCname(b->tacctype));
                    (*fcn)(&b->taccelerator, b);
                    if (err == 0) err = HEAPsave(&b->taccelerator, nme, "tacc");
                    if (err == 0) tsaved = TRUE;
                }
	}
	if (b->batCopiedtodisk == 0 || b->batDirty || b->batDirtydesc) { 
		DESCclean(b);
		b->batCopiedtodisk = 1;
		b->haccCopiedtodisk |= hsaved;
		b->taccCopiedtodisk |= tsaved;
		if (err == 0) err = BATsavedesc(b,nme);
	}
	if (err == 0) {
		bd->batCopiedtodisk = 1;
		bd->haccCopiedtodisk |= hsaved;
		bd->taccCopiedtodisk |= tsaved;
		return bd;
	}
	return NULL;
}


BAT *BATload_intern(bat bid, int lock) {
	str nme = BBP_physical(bid);
	BAT *b = DESCload(nme, bid);
	int err;

	if (b == NULL) {
		return NULL;
	}
	/* LOAD bun heap */
	if (b->batBuns->base) {
		DELTAsave(b);
	}
	err = HEAPload(b->batBuns, nme, "buns");
	if (b->batBuns->base) {
		DELTAload(b);
	}

	/* LOAD head heap */
	if (ATOMvarsized(b->htype)) {
		err += HEAPload(&b->hheap, nme, "hheap");
		if (BATatoms[b->htype].atomHeapCheck == HEAP_check) 
			if (!err) HEAP_init(&b->hheap, b->htype);
	} else {
		memset(&b->hheap, 0, sizeof(Heap));
	}

	/* LOAD tail heap */
	if (ATOMvarsized(b->ttype)) {
		err += HEAPload(&b->theap, nme, "theap");
		if (BATatoms[b->ttype].atomHeapCheck == HEAP_check) 
			if (!err) HEAP_init(&b->theap, b->ttype);
	} else {
		memset(&b->theap, 0, sizeof(Heap));
	}

	/* LOAD head accelerator heap */
	if (b->hacctype && (BATaccelerators[b->hacctype].accSave==NULL 
		|| b->batConvert || HEAPload(&b->haccelerator, nme, "hacc")))  
	{
		IODEBUG GDKwarning("BATload: ignoring %s on head of %s.\n",
			BATaccelerators[b->hacctype].name, b->batId);
		b->hacctype = 0;
	} 
	if (b->hacctype == 0) {
		memset(&b->haccelerator, 0, sizeof(Heap));
	} else {
		b->haccCopiedtodisk = TRUE; /* correct if not set yet */
	}

	/* LOAD tail accelerator heap */
	if (b->tacctype &&(BATaccelerators[b->tacctype].accSave==NULL 
		|| b->batConvert || HEAPload(&b->taccelerator, nme, "tacc"))) 
	{
		IODEBUG GDKwarning("BATload: ignoring %s on tail of %s.\n",
			BATaccelerators[b->tacctype].name, b->batId);
		b->tacctype = 0;
	} 
	if (b->tacctype == 0) {
		memset(&b->taccelerator, 0, sizeof(Heap));
	} else {
		b->taccCopiedtodisk = TRUE; /* correct if not set yet */
	}
	if ( err ) {
		HEAPfree(b->batBuns);
		HEAPfree(&b->hheap);
		HEAPfree(&b->theap);
		return NULL;
	}
	/* load succeeded; register it in BBP  */
	b->batParentid = b->batSharecnt = 0;
	b->batCacheid = 0; 
	b->batMapdirty = 0;
	BBPcacheit(b, lock);

	if (b->batConvert) {
		BATconvert(b);
	} 
	if (!DELTAdirty(b)) {
		ALIGNcommit(b);
	}
	return b;
}

BAT *BATload(str nme) {
	str s = strrchr(nme,DIR_SEP);
	int i = BBPindex(s?s+1:nme);
	BAT *b = BBP_cache(i);

	if (i==0 || b != NULL) {
		return b; /* inexistent bat or already loaded */
	}
	b = BATload_intern(ABS(i), TRUE); 
	if (b == NULL) {
		return NULL;
	}
	if ((b->batRestricted == BAT_WRITE && (GDKdebug&2)) || (GDKdebug&8)) {
		/* BATrepair(b); causes more trouble than good */ 
		BATpropcheck_(b,TRUE); 
	}
	return (i<0)?BATmirror(b):b; 	
}


@+ Memory Mapped Storage
@T
Changing the storage status of heaps in a BAT is done in @:BATmmap@. 
The new semantics is that the mapping only takes effect the next time 
the bat is loaded. 

This makes the BATmmap safer&simpler as it is now
incorporated in the normal bat loading and saving mechanism.

It also makes the mmap faster as when through caching you
are finished with the BAT before it is ever swapped to disk
it will never heva been written, whereas the old mmap obliged you to 
save a BAT directly.
@c
int BATmmap(BAT *b, int bns, int hhp, int thp, int hacc, int tacc){
        BATcheck(b, "BATmmap");
       	IODEBUG {
		THRprintf(GDKerr, "BATmmap(%s,%d,%d,%d,%d,%d)\n", b->batId,bns,hhp,thp,hacc,tacc); 
	}
	/* Reverse back if required, as this determines which heap is saved in the 
	 * "hheap" file and which in the "theap" file (and haccelerator/taccelerator).
       	 */
	if (b->batCacheid < 0) {
		int swap=hhp; hhp=thp; thp=swap;
		swap=hacc; hacc=tacc; tacc=swap;
		b = BATmirror(b);
	}
	b->batMapdirty = TRUE;
	b->batMapbuns = bns;
	b->batMaphheap = hhp;
	b->batMaptheap = thp;
	b->batMaphacc = hacc;
	b->batMaptacc = tacc;

	b->batDirtydesc = 1;
	return 0;
}

@= madvise
	if ((@1 >=0) && (@2)->base && ((@2)->storage==STORE_MMAP)) {
	    if (madvise((@2)->base, (@2)->free, @1)) {
		GDKsyserror("madvise on %s @1 failed.\n");
		return -1;
	    }
	}
@c
int BATmadvise(BAT *b, int bns, int hhp, int thp, int hacc, int tacc) {
	@:madvise(bns, b->batBuns)@
	@:madvise(hhp, &b->hheap)@
	@:madvise(thp, &b->theap)@
	@:madvise(hacc, &b->haccelerator)@
	@:madvise(tacc, &b->taccelerator)@
	return 0;
}


@- BATdelete
new behavior is to let the routine produce warnings but always succeed.
rationale: on a delete, we must get rid of *all* the files. We do not have to care
about preserving them or be too much concerned if a file that had to be deleted was
not found (end result is still that it does not exist). The pas behavior to delete 
some files and then fail was erroneous. The BAT would continue to exist with an 
incorrect disk status, causing havoc later on.
@c
int BATdelete(BAT* b) {
	str o = BBP_physical(b->batCacheid); 

	if (o && b->batCopiedtodisk) {
	    IODEBUG THRprintf(GDKerr, "BATdelete %s\n", o); 
	    if (b->batCacheid < 0) {
		b = BATmirror(b);
	    }
	    if (GDKunlink(BATDIR, o, "desc")) {
		GDKwarning("BATdelete(%s): descriptor\n", b->batId);
	    }
	    if (HEAPdelete(b->batBuns, o, "buns")) {
		GDKwarning("BATdelete(%s): bun heap\n", b->batId);
	    }
	    if (HEAPdelete(&b->hheap, o, "hheap")) {
		GDKwarning("BATdelete(%s): head heap\n", b->batId);
	    }
	    if (HEAPdelete(&b->theap, o, "theap")) {
		GDKwarning("BATdelete(%s): tail heap\n", b->batId);
	    }
	    if (b->haccCopiedtodisk && HEAPdelete(&b->haccelerator, o, "hacc")) {
		GDKwarning("BATdelete(%s): head accelerator\n", b->batId);
	    }
	    if (b->taccCopiedtodisk && HEAPdelete(&b->taccelerator, o, "tacc")) {
		GDKwarning("BATdelete(%s): tail accelerator\n", b->batId);
	    }
/* PETER: freeing this field yields an illegal BATdesc, and is done in BBPclear

 
	    BBP_physical(b->batCacheid) = NULL;
	    GDKfree(o);
*/
            b->batCopiedtodisk = FALSE;
            b->haccCopiedtodisk = FALSE;
            b->taccCopiedtodisk = FALSE;
	}
	return 0;
}

@
@}

@+ Printing and debugging
@T
Printing BATs is based on the multi-join on heads. The multijoin
exploits all possible Monet properties and accelerators. Due
to this property, the n-ary table printing is quite fast and
can be used for producing ASCII dumps of large tables.

It all works with hooks.  The multijoin routine finds matching ranges 
of rows. For each found match in a column it first calls a value-routine
hook. This routine we use to format a substring. 

For each found match-tuple (the carthesian product of all matches
accross columns) a match routine hook is called. We use this routine
to print a line.

Due to this setup, we only format each value once, though it
might participate in may lines (due to the carthesian product).

The multijoin is quite complex, and we use a @%col_format_t@
struct to keep track of column specific data.

The multiprint can now indicate arbitrary orderings. This is done 
by passing a pattern-string that matches the following regexp: 

	"[X:] Y0 {,Yi}"

where X and Yi are column numbers, {\bf starting at 1} for the first 
BAT parameter.

The table ordering has two aspects:

\begin{enumerate}
\item 	the order in which the matches appear (a.k.a. the major ordering). 
	This is equivalent to the order of the head values of the BATs 
	(as we match=multijoin on head value).
\item	within each match, the order in which the carthesian 
   	product is produced. This is used to sub-order on 
	the tail values of the BATs = the columns in the table. 
\end{enumerate}

Concerning (1), the multijoin limits itself to *respecting*
the order one one elected BAT, that can be identified with X.
Using this, a major ordering on tail value can be enforced,
by first passing "Bx.reverse.sort.reverse" (BAT ordered on tail).
As the multijoin will respect the order of X, its tail values
will be printed in sorted order.

Concerning sub-ordering on other columns (2), the multijoin
itself employs qsort() to order the carthesian product on
the matched tail values.
@{
@c
#define LINE(fp,	X)     { int n=X-1; fputc('#',fp); while(n-->0)\
                                fputc('-',fp); fputs("#\n",fp); }
#define TABS(fp,	X)     { int n=X; while(n-->0) fputc('\t',fp);  }

typedef int (*strFcn)(str* s, int* len, ptr val); 

typedef struct {
        int     tabs;   /* tab width of output */
        strFcn  format; /* tostr function */
	/* dynamic fields, set by print_format */
	str	buf; /* tail value as string */
	str	tpe; /* type of this column as string */
	int 	size; /* size of buf */
	int	len; /* strlen(buf) */
} col_format_t;

static 
int print_nil(char** dst, int *len, ptr dummy) {
	if (*len < 3) {
		if (*dst) GDKfree(*dst);
		*dst = (char*) GDKmalloc(*len = 40);
	}
	strcpy(*dst, "nil");
	return 3;
}

#define printfcn(b)	((b->ttype==TYPE_void && b->tseqbase==oid_nil)?\
			          print_nil:BATatoms[b->ttype].atomToStr)

extern int rand();

static 
int print_tabwidth(BAT *b, str title, col_format_t *c) {
        strFcn tostr = printfcn(b);
        int cnt = BATcount(b);
        int max, t = BATttype(b);
	
	c->tpe = ATOMname(b->ttype);	
        c->buf = (char*) GDKmalloc(c->size = strLen(title)); 
        max = MAX((2+strlen(c->tpe)), strlen(title));
 
        if (t >= 0 && t < GDKatomcnt && tostr) {
            int off = BUNindex(b, BUNfirst(b));
            int j, k, i, probe = MIN(10000,MAX(200,cnt/100));
            for(i=0; i < probe; i++) {
		if (i >= cnt) break;
                j = off + ((cnt < probe)?i:(rand() % cnt));
                k = (*tostr)(&c->buf, &c->size,  BUNtail(b,BUNptr(b,j)));
                if (k > max) max=k;
            }
        }
	strcpy(c->buf, title);
	max += 2; /* account for ", " separator */
	/* if (max > 60) max = 60; */
        return 1 + (max-1)/8;
}

static 
void print_line(FILE* fp, col_format_t** l) {
	col_format_t *c = *(l++);
        fputs("[ ", fp);
        if (c->format) {
                fputs(c->buf, fp);
                fputc(',', fp);
                TABS(fp, c->tabs-((c->len+3)/8));
                if (c->tabs*8 >= c->len+3) fputc(' ', fp);
                fputc(' ', fp);
        }
        for (c=*l; *(++l); c=*l) {
                fputs(c->buf, fp);
                fputc(',', fp);
                TABS(fp, c->tabs-((c->len+3)/8));
                if (c->tabs*8 >= c->len+3) fputc(' ', fp);
                fputc(' ', fp);
        }
        fputs(c->buf, fp);
        TABS(fp, c->tabs-((c->len+2)/8));
        fputs("  ]\n", fp);
}

static 
void print_format(col_format_t *c, ptr v) {
	if (c->format) 
	c->len = (*c->format)(&c->buf, &c->size, v);
}

@= print_head
	str s = @1?argv[@2].tpe:argv[@2].buf; /* contains column title */
	if (@1) fputc('(', fp);
	fputs(s, fp);
	if (@1) fputc(')', fp);
	TABS(fp, argv[@2].tabs-((2+@1+strlen(s))/8));
@= print_header
	int k = 1; 
	fputs("# ", fp);
	if (argv[0].format) {
		@:print_head(@1,0)@
		fputs("  ",fp);
	}
	while(TRUE) {
		@:print_head(@1,k)@
		if (k++ < argc) fputs("| ", fp);
		else break;
        } 
	fputs("  #\n", fp);
@c
static 
int print_header(int argc, col_format_t* argv, FILE* fp) {
	@:print_header(0)@
	if (argv[0].format) {
		@:print_header(2)@
	}
	return 0;
}

@- 
The simple BAT printing routines make use of the complex case.
@c
int BATprint(BAT* b) {
	ERRORcheck(b == NULL, "BATprint: BAT expected"); 
	return BATmultiprintf(stdout, 2, &b, TRUE, 0);
}

int BATprintf(FILE* fp, BAT*b) {
	ERRORcheck(b == NULL, "BATprintf: BAT expected"); 
	return BATmultiprintf(fp, 2, &b, TRUE, 0);
}

@+ Multi-Bat Printing
This routines uses the multi-join operation to print 
an n-ary table. Such a table is the reconstruction of
the relational model from Monet's BATs, and consists of 
all tail values of matching head-values in n-ary equijoin.
@c
static
str batname(BAT *b) {
	str sn = BBP_logical(b->batCacheid);
	str sr = BBP_logical(-b->batCacheid);
        str id = b->batId;

        if (sn && strncmp(id, sn, IDLENGTH) == 0)  {
		return sn;
	}
	if (sr && strncmp(id, sr, IDLENGTH) == 0) {
		return sr;
        }       
	return id;
}

int BATmultiprintf(
	FILE    *fp,		/* output fd */
	int     argc, 		/* #ncolumns = #nbats +  */
	BAT     *argv[],	/* the bats 2b printed */
	int     printhead,	/* boolean: print the head column? */
	int	order		/* respect order of bat X (X=0 is none)*/
){
	col_format_t *c = (col_format_t*) alloca(argc*sizeof(col_format_t));
	col_format_t **cp = (col_format_t**) alloca((argc+1)*sizeof(void*));
	ColFcn *value_fcn = (ColFcn*) alloca(argc*sizeof(ColFcn));
	int ret, j, total = 0;
@-
Init the column descriptor of the head column.
@c
	cp[argc] = NULL; /* terminator */
	cp[0] = c;
        memset(c,0,(argc--)*sizeof(col_format_t));
@-
Init the column descriptors of the tail columns.
@c
        value_fcn[0] = (ColFcn) print_format;
        if (printhead) {
	    BAT *b = BATmirror(argv[0]);
            total = c[0].tabs = print_tabwidth(b, "BAT:", c+0);
            c[0].format = printfcn(b);
        }
        for(j=0; j < argc; j++, total += c[j].tabs) {
	    cp[j+1] = c+(j+1);
            c[j+1].format = printfcn(argv[j]);
            c[j+1].tabs = print_tabwidth(argv[j], batname(argv[j]), c+(j+1));
            value_fcn[j+1] = (ColFcn) print_format;
        }
        total = 2+(total*8);
@-
Print the table header and then the multijoin.
@c
        LINE(fp, total);
	print_header(argc, c, fp);
        LINE(fp, total);
	if (argc == 1) {
		BAT *b = argv[0];
		BUN p,q;
		BATloop(b,p,q) {
			print_format(cp[0], BUNhead(b,p));
			print_format(cp[1], BUNtail(b,p));
			print_line(fp, cp);
		}
		MULTIJOIN_LEAD(ret) = 1;
		MULTIJOIN_SORTED(ret) = (BAThordered(b)&1);
		MULTIJOIN_KEY(ret) = b->hkey;
		MULTIJOIN_SYNCED(ret) = 1;
	} else {
		ret = BATmultijoin(argc, argv, (RowFcn) print_line, (void*)fp, 
					value_fcn, (void**)cp, order);
	}
@-
Cleanup.
@c
	(void) fflush(fp);
        for(j=0; j <= argc; j++) {
		if (c[j].buf) GDKfree(c[j].buf);
	}
	return ret;
}
@}
