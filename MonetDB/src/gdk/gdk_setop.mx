@f gdk_setop
@a Peter Boncz

@* Set Operations
@T
Set operations are provided in two series:
\begin{itemize}
\item k-{\tt operand}, which look only at the head column.
\item s-{\tt operand} series, that look at the whole BUN.
\end{itemize}
Operands provided are:
\begin{itemize}
\item {\tt\{s,k\}unique}(bat[any::1,any::2]) : bat[any::1,any::2]\\
produces a copy of the bat, with double elimination
\item {\tt\{s,k\}union(bat[any::1,any::2],bat[any::1,any::2]) : bat[any::1,any::2]\\
bat union.
\item {\tt\{s,k\}diff}}(bat[any::1,any::2],bat[any::1,any::2]) : bat[any::1,any::2]\\
bat difference.
\item {\tt\{s,k\}intersection}(bat[any::1,any::2],bat[any::1,any::2]) : bat[any::1,any::2]\\
bat intersection.
\end{itemize}
Implementations typically take two forms: if the input relation(s) is/are
ordered, a merge-algorithm is used. Otherwise, hash-indices are produced 
on demand for the hash-based versions.
\\
The {\tt \{k,s\}intersect(l,r)} operations result in all BUNs of {\tt l} that 
are also in {\tt r}. They do not do double-elimination over the {\tt l} BUNs.
\\
The {\tt \{k,s\}diff(l,r)} operations result in all BUNs of {\tt l} that are 
not in {\tt r}. They do not do double-elimination over the {\tt l} BUNs.
\\
The {\tt \{k,s\}union(l,r)} operations result in all BUNs of {\tt l} that are 
not in {\tt r}, plus all BUNs of {\tt r}. They do not do double-elimination 
over the {\tt l} nor {\tt r} BUNs.
\\
Operations with double-elimination can be formed by performing 
{\tt \{k,s\}unique(l)} on their operands.
\\
The {\tt kintersect(l,r)} is used also as implementation for the 
{\tt semijoin()}.
@h
#ifndef _GDK_SETOP_H
#define _GDK_SETOP_H
#include "gdk.h"

#define HITk(t1,t2)             TRUE
#define HITs(t1,t2)             ((*cmp)(t1,t2) == 0)
#define TAILCHECKs(l,r)         TYPEerror(BATttype(l),	BATttype(r))
#define TAILCHECKk(l,r)         FALSE		
#define EQUALs(t1,t2)           ((*cmp)(t1,t2) == 0)
#define EQUALk(t1,t2)           TRUE
#define FLIPs(l,r)              TRUE
#define FLIPk(l,r)              FALSE

#define HITintersect(h,t)       BUNfastins(bn,h,t)
#define HITdiff(h,t)		
#define MISSintersect(h,t)
#define MISSdiff(h,t)           BUNfastins(bn,h,t)
#define ENDintersect(h,t)
#define ENDdiff(h,t)            for(;p1<q1;p1+=s1) BUNfastins(bn,h,t)
#define RALIGNdiff(bn,l,r)      FALSE
#define RALIGNintersect(bn,l,r) ((BAThordered(l)&BAThordered(r)&1) && l->hkey\
                                && BATcount(bn)==BATcount(r)) 
#endif /* _GDK_SETOP_H */

@c
#include "gdk_setop.h"

@+ Double Elimination
Comes in two flavors: looking at one column, or at two at-a-time.
Implementation is either merge- or hash-based.
@= mergeelim
	BATloopFast(b, p, q, xx) {
		ptr h = BUNh@2(b,p);
		ptr t = BUNt@3(b,p);
		for(r=p+xx; (r < q) && (@4 == 0); r+=xx) {
		    if (HIT@1(t, BUNt@3(b,r))) goto next@2@3@5;
		}
		BUNfastins(bn, h, t);
next@2@3@5:;
	}
@= hashelim
	zz = BUNindex(bn, BUNfirst(bn));
	if (!bn->hhash_heap){
		int one=1; /* using direct hashing (coll. list length=1) */
		BAThash(bn, &one);
	}
	BATloopFast(b, p, q, xx) {
		ptr h = BUNh@2(b,p);
		ptr t = BUNt@3(b,p);
		int ins = 1, yy;
		(void) BATprepareHash(bn);
		HASHloop@4(bn, bn->hhash, yy, h, r) {
		    if (HIT@1(t, BUNt@3(bn,r))) {
			ins=0; break;
		    }
		}
		if (ins) {
			BUNfastins(bn, h, t);
			if (bn->hhash_heap) HASHins@4(bn->hhash, zz, h);
			zz++;
		}
	}
@= elim
{	int zz, xx, (*cmp)() = BATatoms[b->ttype].atomCmp;
	BUN p, q, r; 
	if (BAThordered(b)&1) {
	    if (b->tvarsized) {
		@:mergeelim(@1,@2,var,@4,@3)@
	    } else {
		@:mergeelim(@1,@2,loc,@4,@3)@
	    }
	} else if (b->tvarsized) {
		@:hashelim(@1,@2,var,@3)@
	} else {
		@:hashelim(@1,@2,loc,@3)@
	} 
	return (((int)cmp) && 0); /* fooling the stupid compiler */
}
@= elim_doubles
	switch(ATOMstorage(b->htype)) {
	case TYPE_bit:	@:elim(@1,loc,_chr,simple_CMP(h,BUNhloc(b,r),chr))@
	case TYPE_sht:	@:elim(@1,loc,_sht,simple_CMP(h,BUNhloc(b,r),sht))@
	case TYPE_int:	@:elim(@1,loc,_int,simple_CMP(h,BUNhloc(b,r),int))@
	case TYPE_flt:	@:elim(@1,loc,_flt,simple_CMP(h,BUNhloc(b,r),flt))@
	case TYPE_dbl:	@:elim(@1,loc,_dbl,simple_CMP(h,BUNhloc(b,r),dbl))@
	case TYPE_lng:	@:elim(@1,loc,_lng,simple_CMP(h,BUNhloc(b,r),lng))@
	default: 
	    {	int (*merge)()= BATatoms[b->htype].atomCmp;
		if (b->hvarsized) {
			@:elim(@1,var,var,((*merge)(h,BUNhvar(b,r))))@
		} else {
			@:elim(@1,loc,loc,((*merge)(h,BUNhloc(b,r))))@
		}
	    }  
	}
@c
int BATins_kunique(BAT *bn, BAT *b) {
	@:elim_doubles(k)@
}

int BATins_sunique(BAT *bn, BAT *b) {
	BUN fst1 = BUNfirst(bn), lst1 = BUNlast(bn) - BUNsize(bn);
	BUN fst2 = BUNfirst(b), lst2 = BUNlast(b) - BUNsize(b);

	if (BATcount(b) && (BAThordered(b)&1) && ATOMcmp(b->htype,BUNhead(b,fst2),BUNhead(b,lst2)) == 0 &&
	   (BATcount(bn) == 0 || (ATOMcmp(bn->htype,BUNhead(bn,fst1),BUNhead(b,fst2)) == 0 &&
	   (BAThordered(bn)&1) && ATOMcmp(bn->htype,BUNhead(bn,fst1),BUNhead(bn,lst1)) == 0)))
	{
		return BATins_kunique(BATmirror(bn), BATmirror(b));
	}
	if (BATcount(b) && (BATtordered(b)&1) && ATOMcmp(b->ttype,BUNtail(b,fst2),BUNtail(b,lst2)) == 0 &&
	   (BATcount(bn) == 0 || (ATOMcmp(bn->ttype,BUNtail(bn,fst1),BUNtail(b,fst2)) == 0 &&
	   (BATtordered(bn)&1) && ATOMcmp(bn->ttype,BUNtail(bn,fst1),BUNtail(bn,lst1)) == 0)))
	{
		return BATins_kunique(bn, b);
	}
	if ((BATtordered(b)&1) && ATOMstorage(b->ttype) < TYPE_str) {
		BATflipflop(bn); BATflipflop(b);
	}
	@:elim_doubles(s)@
}


@- Unique  
The routine @`BATsunique@5 removes duplicate BUNs,
The routine @`BATkunique@5 removes duplicate head entries. 
@c
BAT *BATkunique(BAT *b) {
	BAT	*bn;
	BATcheck(b, "BATkunique:");

        if (b->hkey) {
	    bn = BATrcopy(b);
	} else {
	    int cnt = BATcount(b);
	    if (cnt > 10000) {
		BAT *tmp0 = VIEWhead_(b, BAT_WRITE);
		BAT *tmp1 = BATsample(b, 1000);
		BAT *tmp2 = BATkunique(tmp1);
		cnt = (((lng) BATcount(tmp2)) * cnt)/900;
		BBPreclaim(tmp0);
		BBPreclaim(tmp1);
		BBPreclaim(tmp2);
	    }
	    bn = BATnew(BAThtype(b), BATttype(b), cnt);
	    BATins_kunique(bn, b);
	}

	/* property management */
	if (b->halign == 0) {
		b->halign = OIDnew(1);
	}
	BATkey(bn, TRUE); /* this we accomplished */ 
	BATkey(BATmirror(bn), b->tkey);
	bn->hsorted = BAThordered(b);
	bn->tsorted = BATtordered(b);
	bn->halign = NOID_AGGR(b->halign);
	if (BATcount(bn)==BATcount(b)) {
		ALIGNset(bn, b);
	}
	return bn; 
}

BAT *BATukunique(BAT *b) {
	BAT *v, *bn;
	BATcheck(b, "BATukunique:");
	bn = BATkunique(v = VIEWhead(b));
	BBPreclaim(v);
	return bn;
}

BAT *BATsunique (BAT *b) {
	BAT	*bn;
	BATcheck(b, "BATsnique:");

	if (b->hkey || b->tkey || b->batSet) {
	    bn = BATrcopy(b);
	} else {
	    int cnt = BATcount(b);
	    if (cnt > 10000) {
		BAT *tmp1 = BATsample(b, 1000);
		BAT *tmp2 = BATkunique(tmp1);
		cnt = BATcount(tmp2) * (cnt/1000);
		BBPreclaim(tmp1);
		BBPreclaim(tmp2);
	    }
	    bn = BATnew(BAThtype(b), BATttype(b), cnt);
	    BATins_sunique(bn, b);
	}

	/* property management */
	BATset(bn, TRUE); /* this we accomplished */ 
	BATkey(bn, b->hkey);
	BATkey(BATmirror(bn), b->tkey);
	bn->hsorted = BAThordered(b);
	bn->tsorted = BATtordered(b);
	if (BATcount(bn)==BATcount(b)) {
		ALIGNset(bn, b);
	}
	return bn; 
}

@+ Difference and Intersect
Difference and Intersection are handled together. For each routine
there are two versions: @`BATkdiff@5(l,r) and @`BATkintersect@5(l,r) (which 
look at the head column only), versus @`BATsdiff@5(l,r) and 
@`BATsintersect@5(l,r) (looking at both columns).
TODO synced/key case..
@{

@= mergecheck
	BUN p1 = BUNfirst(l), p2 = BUNfirst(r);
	BUN q1 = BUNlast(l),  q2 = BUNlast(r);
	int s1 = BUNsize(l),  s2 = BUNsize(r);

	if (p2 < q2) BATloopFast(l, p1, q1, s1) {
            ptr  h = BUNh@2(l,p1);
	    ptr  t = BUNtail(l,p1); 
	    ptr h2 = BUNh@2(r,p2);
	    int c;
 	    while ((c = @4) > 0) {
		if ((p2 += s2) >= q2) goto end@2@3;
	    	h2 = BUNh@2(r,p2);
	    }
 	    if (c == 0) {
		BUN pb = p2;
		while(1) {
		    if (EQUAL@5(t, BUNtail(r,pb))) {
			HIT@1(h, t); break;
		    } 
		    if ((pb += s2) >= q2) {
			MISS@1(h, t); break;
		    }
		    h2 = BUNh@2(r,pb); 
		    if (@4) { 
			MISS@1(h, t); break;
		    }
		}
	    } else {
		MISS@1(h, t); 
	    }
	}
end@2@3:;
	END@1(BUNh@2(l,p1), BUNtail(l,p1));
@= hashcheck
	BUN p1, q1, w; 
	int ins, s1, s2;
	ptr h, t, t2 = NULL;

	(void) BATprepareHash(r);
	BATloopFast(l, p1, q1, s1) {
	    h = BUNh@2(l, p1);
	    t = BUNtail(l,p1);
	    ins = TRUE; 
	    HASHloop@4(r, r->hhash, s2, h, w) {
		t2 = BUNtail(r,w);
	 	if (EQUAL@5(t,t2)) {
		    HIT@1(h, t); ins=FALSE; break;
		} 
	    }
	    if (!ins) continue;
	    MISS@1(h,t);
	}
	if (t2) ins = 0; /* dummy action for the compiler */

@= voidcheck
{   BUN p1 = BUNfirst(r), q1 = BUNlast(r);
    oid rl = *(oid*) BUNhead(r,p1); 
    oid rh = rl + BATcount(r);
    ptr h, t=NULL, t2=NULL;

    if (BAThdense(l)) {
	oid ll = *(oid*) BUNhead(l,(p1=BUNfirst(l))); 
    	oid lh = ll + BATcount(l);
	BUN hit_start = (q1=BUNlast(l)), hit_end = q1, w = BUNfirst(r);
	int s1 = BUNsize(l);
	int s2 = BUNsize(r);
	int off = BUNindex(l,p1);
	h = (ptr) &ll;

	if (rl >= ll && rl < lh) {
		hit_start = BUNptr(l, off+(rl-ll)); 
	} else if (rl < ll) {
		hit_start = p1;
		w += s2*(ll-rl);
	}
	if (rh >= ll && rh < lh) {
		hit_end = BUNptr(l, off+(rh-ll)); 
	}
	while(p1 < hit_start) {
		t = BUNtail(l,p1);
		MISS@1(h,t);
 		ll++; p1 += s1;
	}
	while(p1 < hit_end) {
		t = BUNtail(l,p1);
		t2 = BUNtail(r,w);
		if (EQUAL@2(t,t2)) {
			HIT@1(h,t);
		} else {
			MISS@1(h,t);
		}
		ll++; p1 += s1; w += s2; 
	}
	while(p1 < q1) {
		t = BUNtail(l,p1);
		MISS@1(h,t);
 		ll++; p1 += s1;
	}
    } else {
	int s1, off = BUNindex(r,p1);
	BATloopFast(l, p1, q1, s1) {
	    oid o = *(oid*) BUNhloc(l, p1);
	    h = (ptr) &o;
	    t = BUNtail(l,p1);
	  
	    if (o >= rl && o < rh) {
		BUN w = BUNptr(r,off+(o-rl));
		t2 = BUNtail(r,w);
	 	if (EQUAL@2(t,t2)) {
		    HIT@1(h, t); continue;
		} 
	    }
	    MISS@1(h,t);
	}
}   } 

@= check
	if (BAThdense(l)) {
	    @:hashcheck(@1,pos,@2,@3,@5)@
	} else if (!merge) {
	    @:hashcheck(@1,@2,@2,@3,@5)@
	} else {
	    @:mergecheck(@1,@2,@3,@4,@5)@
	} break;

@= batcheck
int BATins_@1@2(BAT *bn, BAT *l, BAT *r) {
	int (*cmp)(), (*merge)()=0;

	/* determine how to do the intersect */
	if (BAThordered(l)&BAThordered(r)&1) {
	    merge = BATatoms[l->htype].atomCmp;
	} else if (FLIP@1(l,r)) {
	    int flip = (BATtordered(l)&BATtordered(r)&1);
	    if (flip) {
	        merge = BATatoms[l->ttype].atomCmp;
	    } else {
		flip = (r->hhash_heap == NULL && r->thash_heap != NULL);
	    }
	    if (flip) {
		BATflipflop(r); BATflipflop(l); 
		BATflipflop(bn); 
	    }
	} 
	cmp = BATatoms[l->ttype].atomCmp;

	if (BAThdense(r)) {
	    @:voidcheck(@2,@1)@
	} else
	switch(ATOMstorage(r->htype)) {
	case TYPE_bit:	@:check(@2,loc,_chr,simple_CMP(h,h2,chr),@1)@
	case TYPE_sht:	@:check(@2,loc,_sht,simple_CMP(h,h2,sht),@1)@
	case TYPE_int:	@:check(@2,loc,_int,simple_CMP(h,h2,int),@1)@
	case TYPE_flt:	@:check(@2,loc,_flt,simple_CMP(h,h2,flt),@1)@
	case TYPE_dbl:	@:check(@2,loc,_dbl,simple_CMP(h,h2,dbl),@1)@	
	case TYPE_lng:	@:check(@2,loc,_lng,simple_CMP(h,h2,lng),@1)@
	default:       
            if (l->hvarsized) {
			@:check(@2,var,var,((*merge)(h,h2)),@1)@
	    } else {
			@:check(@2,loc,loc,((*merge)(h,h2)),@1)@
	    }
	}
	return 0;
}

BAT *BAT@1@2(BAT *l, BAT *r) {
	BAT	*bn;
	int	smaller;

	ERRORcheck(l == NULL, "BAT@1@2: left is null"); 
	ERRORcheck(r == NULL, "BAT@1@2: right is null"); 
        ERRORcheck(TYPEerror(BAThtype(l), BAThtype(r)), 
		"BUN@1: incompatible head-types");
	ERRORcheck(TAILCHECK@1(l,r),
		"BUN@1@2: incompatible tail-types");

	smaller = MIN(BATcount(l), BATcount(r));

	/* create result BAT */
	bn = BATnew(BAThtype(l), BATttype(l), MAX(smaller,BATTINY)); 
        bn->halign = NOID_MULT(l->halign,@3r->halign);
        bn->talign = NOID_MULT(l->talign,@3r->halign);

	/* fill it */
	BATins_@1@2(bn, l, r);

	/* propagate alignment info */
	if (BATcount(bn)==BATcount(l)) {
		ALIGNset(bn, l); 
	}
	if (RALIGN@2(bn, l, r)) {
		ALIGNsetH(bn, r); 
	}
	bn->hsorted = BAThordered(l);
	bn->tsorted = BATtordered(l);
	BATkey(bn, l->hkey);
	BATkey(BATmirror(bn), l->tkey);
  	return bn;
}
@c
@:batcheck(s,intersect,)@
@:batcheck(s,diff,-)@
@:batcheck(k,intersect,)@
@:batcheck(k,diff,-)@

@+ Union
Union also consists of two versions: @`BATkunion@5(l,r), which
unites with double elimination over the head column only, and 
@`BATsunion@5(l,r), that looks at both columns. Their
implementation uses the s/kdiff() and s/kunique() code for efficient
double elimination.
@c
#define KEYk	TRUE
#define KEYs	FALSE

BAT* BATmaterialize(BAT *b, int size){
	BAT *bn = BATnew(TYPE_oid, ATOMtype(b->ttype), size);
	BUN p,q; int xx;
	oid base = b->hseqbase;

	if (b->hseqbase == oid_nil) {
		BATloopFast(b,p,q,xx) {
		    BUNfastins(bn, &base, BUNtail(b,p)); 
		}
	} else {
		BATloopFast(b,p,q,xx) {
		    BUNfastins(bn, &base, BUNtail(b,p)); 
		    base++;
		}
	}
	ALIGNsetH(bn,b);
	ALIGNsetT(bn,b);
	return bn;
}

@:union(k)@
@:union(s)@

@= union
BAT *BAT@1union(BAT *l, BAT *r) {
	int hdisjunct, tdisjunct;
	BAT *bn, *b=0;
	BUN p,q;
	int xx;

	BATcompatible(l, r);
	if (BATcount(l) == 0) {
		BAT* swap = l; l = r; r = swap;
	}
	if (BATcount(r) == 0) {
		return BATrcopy(l);
	}
	if (l->htype == TYPE_void) {
		bn = BATmaterialize(l, BATcount(l)+BATcount(r));
	} else if (l->ttype == TYPE_void) {
		bn = BATmirror(BATmaterialize(BATmirror(l), 
			     		      BATcount(l)+BATcount(r)));
	} else {
		bn = BATcopy(l); 
	}

	hdisjunct = (BAThordered(r)&BAThordered(l)&1) && (ATOMcmp(l->htype, 
	      BUNhead(l,BUNlast(l)-BUNsize(l)), BUNhead(r,BUNfirst(r))) < 0);
	tdisjunct = (BATtordered(r)&BATtordered(l)&1) && (ATOMcmp(l->htype, 
	      BUNtail(l,BUNlast(l)-BUNsize(l)), BUNtail(r,BUNfirst(r))) < 0);

	if (!hdisjunct) {
	      b = r = BAT@1diff(r, bn); 
	}
	BATloopFast(r,p,q,xx) { 
		BUNfastins(bn, BUNhead(r,p), BUNtail(r,p));
	}
	if (b) BBPreclaim(b);
	ACCremoveall(bn); 

	/* set alignment info */
	bn->hsorted = hdisjunct?GDK_SORTED:FALSE;
	bn->tsorted = tdisjunct?GDK_SORTED:FALSE;
	bn->talign = bn->halign = 0;
	if (KEY@1 == FALSE && hdisjunct == FALSE) BATkey(bn, FALSE);
	BATkey(BATmirror(bn), tdisjunct?(l->tkey&&r->tkey):0);

	return bn; 
}
@}
