#!/usr/bin/env python

# The contents of this file are subject to the MonetDB Public
# License Version 1.0 (the "License"); you may not use this file
# except in compliance with the License. You may obtain a copy of
# the License at
# http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
# 
# Software distributed under the License is distributed on an "AS
# IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
# implied. See the License for the specific language governing
# rights and limitations under the License.
# 
# The Original Code is the Monet Database System.
# 
# The Initial Developer of the Original Code is CWI.
# Portions created by CWI are Copyright (C) 1997-2003 CWI.
# All Rights Reserved.
# 
# Contributor(s):
# 		Martin Kersten <Martin.Kersten@cwi.nl>
# 		Peter Boncz <Peter.Boncz@cwi.nl>
# 		Niels Nes <Niels.Nes@cwi.nl>
# 		Stefan Manegold  <Stefan.Manegold@cwi.nl>

#TODO:
#=====
# - check all TODO's below
# - tidy -up HTML-generation by "keeping in mind" during testing,
#   which OUT/ERR differ or not and which tests were skipped.
#   dump HTML-stuff only at end
#   print an ascii summary at end, too
# - if no diffs, but warnings, say so at end
# - produce, keep & reference LOG
# - add a "grep-like" function and replace "inlined" grep
#   contains(<file>,<string>)
# - replace pure boldface (<B>) by red-boldface
#   (also in Mdiff)
# - do multi-level prompting?
# - normalize all path's used
# - remove one of milM, milS

try:
    True
except NameError:
    # provide values for old Python versions
    False, True = 0, 1

import os
import sys
import getopt
import fileinput
import popen2
import shutil
import re
import string
import random
import time
import socket
import select
#import signal
#import getpass
import Mfilter
import prof

def _configure(str):
    # expand configure variables in str and return result
    config = [
        ('${source}', '@QMONET_SOURCE@'),
        ('${build}', '@QMONET_BUILD@'),

        ('${bindir}', '@Qbindir@'),
##        ('${sbindir}', '@Qsbindir@'),
        ('${libexecdir}', '@Qlibexecdir@'),
        ('${datadir}', '@Qdatadir@'),
        ('${sysconfdir}', '@Qsysconfdir@'),
##        ('${sharedstatedir}', '@Qsharedstatedir@'),
        ('${localstatedir}', '@Qlocalstatedir@'),
        ('${libdir}', '@Qlibdir@'),
        ('${includedir}', '@Qincludedir@'),
##        ('${oldincludedir}', '@Qoldincludedir@'),
        ('${infodir}', '@Qinfodir@'),
        ('${mandir}', '@Qmandir@'),
        ('${Qbindir}', '@Qbindir@'),
##        ('${Qsbindir}', '@Qsbindir@'),
        ('${Qlibexecdir}', '@Qlibexecdir@'),
        ('${Qdatadir}', '@Qdatadir@'),
        ('${Qsysconfdir}', '@Qsysconfdir@'),
##        ('${Qsharedstatedir}', '@Qsharedstatedir@'),
        ('${Qlocalstatedir}', '@Qlocalstatedir@'),
        ('${Qlibdir}', '@Qlibdir@'),
        ('${Qincludedir}', '@Qincludedir@'),
##        ('${Qoldincludedir}', '@Qoldincludedir@'),
        ('${Qinfodir}', '@Qinfodir@'),
        ('${Qmandir}', '@Qmandir@'),
        # put these at end (in this order!) for efficiency
        ('${exec_prefix}', '@Qexec_prefix@'),
        ('${Qexec_prefix}', '@Qexec_prefix@'),
        ('${prefix}', '@Qprefix@'),
        ('${Qprefix}', '@Qprefix@'),
        ]
    changed = True
    while '$' in str and changed:
        changed = False
        for key, val in config:
            nstr = string.replace(str, key, val)
            changed = changed or str != nstr
            str = nstr
    return str

# add dir where monet_options is installed to sys.path
# we must expand configure variables in the process
sys.path.append(_configure(os.path.join('@Qdatadir@','@PACKAGE@','python')))
import monet_options

STDOUT = sys.stdout
STDERR = sys.stdout     # err

TIMES = []

random.seed(time.time())

def Usage (options) :
    try:
        monet_options.usage(options, '%s [options] ( [<dir>] [<tests>] | [<dirs>] )' % THISFILE)
    except monet_options.Error:
        pass

    sys.stderr.write("""
 <dir>   : if present, %(prog)s behaves as if called in <dir>
 <tests> : list of tests to be processed; if none or 'All' is given,
            all tests listed in 'Tests/All' are processed
            (defaults to 'All' if -r is used)
 <dirs>  : list of directories to be processed; if present, %(prog)s
            processes 'All' tests in each directory of <dirs>; -r may be used also

         See  %(readme)s
         for details about  %(prog)s.
""" % {'prog': THISFILE,
       'readme': os.path.join(GetMonetConfig('--source'),'src','testing','README'),
       })
    raise

### Usage () #

#TODO:
#class TimeoutError:
#       def __init__(self, text):
#               self.text = text
#       def __str__(self):
#               return self.text
#
#def AlarmHandler(signum, frame) :
#       raise TimeoutError, "Timeout"
#### AlarmHandler(signum, frame) #

def ErrMsg(TEXT) :
    STDOUT.flush()
    STDERR.write("\n"+THISFILE+":  ERROR:  %s\n\n" % TEXT)
    STDERR.flush()
### ErrMsg(TEXT) #

def ErrXit(TEXT) :
    ErrMsg(TEXT)
    sys.exit(1)
### ErrXit(TEXT) #

def Warn(TEXT) :
    STDOUT.flush()
    STDERR.write("\n"+THISFILE+"  Warning:  %s\n\n" % TEXT)
    STDERR.flush()
### Warn(TEXT) #

def startswith(str,pre) :
    return str[:len(pre)] == pre
### startswith(str,pre) #

import urllib
##def path(str) :
##    return string.replace(str, '/', os.sep)
path = urllib.url2pathname
### path(str) #

##def url(str) :
##    return string.replace(str, os.sep, '/')
url = urllib.pathname2url
### url(str) #

def CreateHtmlIndex (env) :
    TSTDIR=env['TSTDIR']
    TSTTRGBASE=env['TSTTRGBASE']
    TSTTRGDIR=env['TSTTRGDIR']

    if TSTDIR:
        INDEX=".index"
    else:
        INDEX="index"

    if os.path.isfile(os.path.join(TSTTRGDIR,INDEX+".head.html")):
        BACK = os.getcwd()
        os.chdir(TSTTRGDIR)

        f = open(INDEX+".head.html","r")
        BODY = f.readlines()
        f.close()
        f = open(INDEX+".head.html","w")
        f.write("""\
<HTML>
<HEAD><TITLE>%s</TITLE></HEAD>
<BODY BGCOLOR=#ffffff TEXT=#000000 LINK=#00AA00 VLINK=#005500 ALINK=#00ff00>
<CENTER>
<TABLE ALIGN=ABSCENTER BORDER=1 CELLSPACING=0 CELLPADDING=3>
<TR>
<TH ALIGN=CENTER><FONT FACE='helvetica, arial'>
""" % HTMLTITLE)
        if TSTDIR:
            f.write("""\
<A HREF='%s%s/%s' TARGET='%s%s_%s_body'><FONT COLOR=#000000>%s</FONT></A><BR>
""" % (URLPREFIX, url(TSTDIR), TSTSUFF, URLSUFFIX_D, OSVER, TSTDIR, TSTDIR))
            #TODO ?
            #<A HREF='.$THISFILE.Slave.Log.OutErr' TARGET='${OSVER}_${TSTDIR}_body'><FONT COLOR=#000000><I>(log)</I></FONT></A>
        else:
            f.write("<FONT COLOR=#000000>%s</FONT>" % OSVER)
            #TODO ?
            #f.write("""\
                        #<A HREF='.$THISFILE.Master.Log.OutErr' TARGET='${OSVER}_${TSTDIR}_body'><FONT COLOR=#000000>$OSVER</FONT></A>
                        #""")
        f.write("</FONT></TH>\n")
        for l in BODY:
            f.write(l)
        f.write("</TR>\n")
        f.write("</TABLE>\n")
        f.write("</CENTER>\n")
        f.write("</BODY>\n")
        f.write("</HTML>\n")
        f.close()

        if TSTDIR:
            ROWS="72"
        else:
            ROWS="54"
        f = open(INDEX+".html","w")
        f.write("""\
<HTML>
<HEAD><TITLE>%s</TITLE></HEAD>
<FRAMESET ROWS='%s,*' FRAMEBORDER=yes BORDER=1 BORDERCOLOR=#ffffff MARGINWIDTH=0 MARGINHEIGHT=0>
<FRAME SRC='%s.head.html' SCROLLING=auto NAME='%s_%s_head' FRAMEBORDER=yes BORDERCOLOR=#ffffff MARGINWIDTH=0 MARGINHEIGHT=0>
<FRAME SRC='%s' SCROLLING=auto NAME='%s_%s_body' FRAMEBORDER=yes BORDERCOLOR=#ffffff MARGINWIDTH=0 MARGINHEIGHT=0>
</FRAMESET>
</HTML>
""" % (HTMLTITLE, ROWS, INDEX, OSVER, TSTDIR,
       url(env['_'+TSTDIR+'_BODY_'][0]),
       OSVER, TSTDIR))
        f.close()
        env['_'+TSTDIR+'_BODY_'] = ["",0]
        os.chdir(BACK)
### CreateHtmlIndex (env) #

def CreateTstWhatXhtml (env, TST, stableWHAT, EXT) :
    WHAT = stableWHAT[7:11]
    TSTDIR    = env['TSTDIR']
    TSTSRCDIR = env['TSTSRCDIR']

    testT = re.compile("^/"+TST+EXT+"/([^/]*)/", re.MULTILINE)
    testS = re.compile("^/"+TST+stableWHAT+"/([^/]*)/", re.MULTILINE)
    REVt="?"
    REVs="?"
    entries = os.path.join(TSTSRCDIR,"CVS","Entries")
    if os.path.isfile(entries):
        for l in fileinput.input(entries):
            mT = testT.match(l)
            if mT:
                REVt=mT.group(1)
            mS = testS.match(l)
            if mS:
                REVs=mS.group(1)
    for l in fileinput.input(TST+WHAT+".diff.html"):
        pass
    if   l[:14] == '<!--NoDiffs-->':
        DIFF = "No differences"
    elif l[:17] == '<!--MinorDiffs-->':
        DIFF = "<B>Minor differences</B>"
    elif l[:17] == '<!--MajorDiffs-->':
        DIFF = "<B><I>Major differences</I></B>"
    else:
        ErrXit("Unexpected last line in %s:\n%s" % (TST+WHAT+".diff.html",l))
    SYSTEM = OSVER+":"
    if COMPILER:
        SYSTEM = COMPILER+", "+SYSTEM

    xWHAT = WHAT
    if THISFILE == "Mprofile.py":
        test = re.compile("^"+TST+"(_[sp][0-9][0-9])?\..*mil.*\.prof\.diff\.html$", re.MULTILINE)
        d = os.listdir(os.getcwd())
        d.sort()
        rows = ""
        frames = ""
        for f in d:
            if test.match(f):
                rows = rows+",*"
                frames = frames + "<FRAME SRC='"+f+"' SCROLLING=auto FRAMEBORDER=yes BORDERCOLOR=#ffffff MARGINWIDTH=0 MARGINHEIGHT=0>\n"
        if rows:
            xWHAT = ".prof-"+WHAT[1:]
            rows = "*"+rows
            frames = "<FRAME SRC='"+TST+WHAT+".diff.html' SCROLLING=auto FRAMEBORDER=yes BORDERCOLOR=#ffffff MARGINWIDTH=0 MARGINHEIGHT=0>\n"+frames
            f = open(TST+xWHAT+".diff.html","w")
            f.write("""\
<HTML>
<HEAD><TITLE>%s</TITLE></HEAD>
<FRAMESET ROWS='%s' FRAMEBORDER=yes BORDER=1 BORDERCOLOR=#ffffff MARGINWIDTH=0 MARGINHEIGHT=0>
%s
</FRAMESET>
</HTML>
""" % (HTMLTITLE, rows, frames))
            f.close()

    f = open(".%s%s.html" % (TST, WHAT),"w")
    f.write("""\
<HTML>
<HEAD><TITLE>%s</TITLE></HEAD>
<FRAMESET ROWS='42,*' FRAMEBORDER=yes BORDER=1 BORDERCOLOR=#ffffff MARGINWIDTH=0 MARGINHEIGHT=0>
<FRAME SRC='.%s%s.head.html' SCROLLING=auto NAME='%s_%s_%s_%s_head' FRAMEBORDER=yes BORDERCOLOR=#ffffff MARGINWIDTH=0 MARGINHEIGHT=0>
<FRAME SRC='%s%s.diff.html' SCROLLING=auto NAME='%s_%s_%s_%s_body' FRAMEBORDER=yes BORDERCOLOR=#ffffff MARGINWIDTH=0 MARGINHEIGHT=0>
</FRAMESET>
</HTML>
""" % (HTMLTITLE, TST, WHAT, OSVER, TSTDIR, TST, WHAT[1:], TST, xWHAT, OSVER, TSTDIR, TST, WHAT[1:]))
    f.close()
    f = open(".%s%s.head.html" % (TST, WHAT),"w")
    f.write("""\
<HTML>
<HEAD><TITLE>%(title)s</TITLE></HEAD>
<BODY BGCOLOR=#ffffff TEXT=#000000 LINK=#00AA00 VLINK=#005500 ALINK=#00ff00>
<CENTER>
<FONT FACE='helvetica, arial'>
%(system)s
<A HREF='%(tst)s%(xwhat)s.diff.html' TARGET='%(osver)s_%(tstdir)s_%(tst)s_%(what1)s_body'>%(diff)s</A>
between
<A HREF='%(tst)s%(stablewhat)s' TARGET='%(osver)s_%(tstdir)s_%(tst)s_%(what1)s_body'>%(stablewhat1)s (r%(revs)s)</A>
and
<A HREF='%(tst)s.test%(what)s' TARGET='%(osver)s_%(tstdir)s_%(tst)s_%(what1)s_body'>test%(what)s</A>
of
<A HREF='%(tst)s%(ext)s' TARGET='%(osver)s_%(tstdir)s_%(tst)s_%(what1)s_body'>%(tst)s%(ext)s (r%(revt)s)</A>
in
<A HREF='./' TARGET='%(osver)s_%(tstdir)s_%(tst)s_%(what1)s_body'>%(tstdir)s</A>
(<A HREF='%(urlprefix)s%(urltstdir)s/%(tstsuff)s%(urlsuffix)s' TARGET='%(osver)s_%(tstdir)s_%(tst)s_%(what1)s_body'>CVS</A>,
 <A HREF='%(urlrelsrcdir)s' TARGET='%(osver)s_%(tstdir)s_%(tst)s_%(what1)s_body'>SRC</A>""" % {'title':HTMLTITLE, 'system':SYSTEM, 'tst':TST, 'xwhat':xWHAT, 'osver':OSVER, 'tstdir':TSTDIR, 'what1':WHAT[1:], 'diff':DIFF, 'stablewhat':stableWHAT, 'stablewhat1':stableWHAT[1:], 'revs':REVs, 'what':WHAT, 'ext':EXT, 'revt':REVt, 'urlprefix':URLPREFIX, 'urltstdir':url(TSTDIR), 'tstsuff':TSTSUFF, 'urlsuffix':URLSUFFIX_D, 'urlrelsrcdir':url(env['RELSRCDIR'])})
    for d in env['RELBLDDIR'], os.path.dirname(env['RELBLDDIR']), env['RELBLDBASE']:
        if os.path.isdir(d):
            f.write(""",
 <A HREF='%s' TARGET='%s_%s_%s_%s_body'>BLD</A>""" % (url(d), OSVER, TSTDIR, TST, WHAT[1:]))
    f.write(""").
</FONT>
</CENTER>
</BODY>
</HTML>
""")
    f.close()
#TODO?
# <A HREF='.Mtest.Slave.Log.OutErr' TARGET='"""+OSVER+"_"+TSTDIR+"_"+TST+"_"+WHAT[1:]+"""_body'>LOG</A>).
### CreateTstWhatXhtml (env, TST, stableWHAT, EXT) #

def CreateSrcIndex (env, TST, EXT) :
    TSTSRCDIR = env['TSTSRCDIR']
    TSTDIR    = env['TSTDIR']

    f = open("."+TST+".src.index.html","w")
    f.write("""\
<HTML>
<HEAD><TITLE>%s</TITLE></HEAD>
<FRAMESET ROWS='54,*' FRAMEBORDER=yes BORDER=1 BORDERCOLOR=#ffffff MARGINWIDTH=0 MARGINHEIGHT=0>
<FRAME SRC='.%s.src.index.head.html' SCROLLING=auto NAME='%s_%s_%s_head' FRAMEBORDER=yes BORDERCOLOR=#ffffff MARGINWIDTH=0 MARGINHEIGHT=0>
<FRAME SRC='%s%s/%s/%s%s%s'
  SCROLLING=auto NAME='%s_%s_%s_body' FRAMEBORDER=yes BORDERCOLOR=#ffffff MARGINWIDTH=0 MARGINHEIGHT=0>
</FRAMESET>
</HTML>
""" % (HTMLTITLE, TST, OSVER, TSTDIR, TST, URLPREFIX, url(TSTDIR), TSTSUFF, TST, EXT, URLSUFFIX_F, OSVER, TSTDIR, TST))
    f.close()
    f = open("."+TST+".src.index.head.html","w")
    f.write("""\
<HTML>
<HEAD><TITLE>%s</TITLE></HEAD>
<BODY BGCOLOR=#ffffff TEXT=#000000 LINK=#00AA00 VLINK=#005500 ALINK=#00ff00>
<CENTER>
<TABLE ALIGN=ABSCENTER BORDER=1 CELLSPACING=0 CELLPADDING=3>
<TR>
<TH ALIGN=CENTER><FONT FACE='helvetica, arial'>%s</FONT></TH>
""" % (HTMLTITLE, TST))
    for s in os.listdir(TSTSRCDIR):
        if len(s) >= len(TST)  and  s[:len(TST)] == TST:
            f.write("""\
<TD><FONT FACE='helvetica, arial'>
  <A HREF='%s%s/%s/%s%s'
    TARGET='%s_%s_%s_body'>%s</A></FONT></TD>
""" % (URLPREFIX, url(TSTDIR), TSTSUFF, s, URLSUFFIX_F, OSVER, TSTDIR, TST, s))
    f.write("""\
</TR>
</TABLE>
</CENTER>
</BODY>
</HTML>
""")
    f.close()
### CreateSrcIndex (env, TST, EXT) #

def AddHref (TSTDIR, TST, WHAT, diff) :
    STRING = "<A HREF='."+TST+WHAT+".html' TARGET='"+OSVER+"_"+TSTDIR+"_body'>"+WHAT[1:]+"</A>"
    if   diff==2:
        return "<B><I>"+STRING+"</I></B>"
    elif diff==1:
        return "<B>"+STRING+"</B>"
    else:
        return "("+STRING+")"
### AddHref (TSTDIR, TST, WHAT, diff) #

def AddTstToHtmlIndex (env, TST, STABLEout, STABLEerr, EXT) :
    TSTDIR = env['TSTDIR']

    CreateTstWhatXhtml(env, TST, STABLEout, EXT)
    CreateTstWhatXhtml(env, TST, STABLEerr, EXT)

    f = open(".index.head.html","a")
    f.write("<TD ALIGN=CENTER><FONT FACE='helvetica, arial'><A HREF='."+TST+".src.index.html' TARGET='"+OSVER+"_"+TSTDIR+"_body'><FONT COLOR=#000000>")
    for l in fileinput.input(TST+".out.diff.html"):
        pass
    if   l[:14] == '<!--NoDiffs-->':
        o = 0
    elif l[:17] == '<!--MinorDiffs-->':
        o = 1
    elif l[:17] == '<!--MajorDiffs-->':
        o = 2
    else:
        ErrXit("Unexpected last line in %s:\n%s" % (TST+".out.diff.html",l))
    for l in fileinput.input(TST+".err.diff.html"):
        pass
    if   l[:14] == '<!--NoDiffs-->':
        e = 0
    elif l[:17] == '<!--MinorDiffs-->':
        e = 1
    elif l[:17] == '<!--MajorDiffs-->':
        e = 2
    else:
        ErrXit("Unexpected last line in %s:\n%s" % (TST+".err.diff.html",l))
    if   o==2 or e==2:
        f.write("<B><I>"+TST+"</I></B>")
    elif o==1 or e==1:
        f.write("<B>"+TST+"</B>")
    else:
        f.write(TST)
    f.write("</FONT></A><BR>")
    f.write(AddHref(TSTDIR, TST, ".out", o))
    f.write("&nbsp;|&nbsp;")
    f.write(AddHref(TSTDIR, TST, ".err", e))
    f.write("</FONT></TD>\n")
    f.close()
    if not env.has_key('_'+TSTDIR+'_BODY_')  or  \
       not env['_'+TSTDIR+'_BODY_'][0]  or  \
       ( (not env['_'+TSTDIR+'_BODY_'][1])  and  (o or e) ):
        if e and not o:
            env['_'+TSTDIR+'_BODY_'] = ["."+TST+".err.html", e]
        else:
            env['_'+TSTDIR+'_BODY_'] = ["."+TST+".out.html", o]

    CreateSrcIndex(env, TST, EXT)

    return max(o,e)
### AddTstToHtmlIndex (env, TST, STABLEout, STABLEerr, EXT) #

def AddSubToHtmlIndex (env, TSTDIR) :
    TSTTRGBASE = env['TSTTRGBASE']
    TSTPREF = env['TSTPREF']

    if os.path.isfile(os.path.join(TSTTRGBASE,TSTPREF,TSTDIR,".index.html")):
        BACK = os.getcwd()
        os.chdir(os.path.join(TSTTRGBASE,TSTPREF))
        f = open("index.head.html","a")
        f.write("<TD><FONT FACE='helvetica, arial'>")
        STRING = "<A HREF='"+url(TSTDIR)+"/.index.html' TARGET='"+OSVER+"__body'>"+TSTDIR+"</A>"
        test = ( re.compile("^.*><B><I>.*</I></B><.*$", re.MULTILINE)
               , re.compile("^.*><B>.*</B><.*$", re.MULTILINE) )
        diff = 0
        for l in fileinput.input(os.path.join(TSTDIR,".index.head.html")):
            if   diff<2 and test[0].match(l):
                diff = 2
            elif diff<1 and test[1].match(l):
                diff = 1
        if   diff==2:
            f.write("<B><I>"+STRING+"</I></B>")
        elif diff==1:
            f.write("<B>"+STRING+"</B>")
        else:
            f.write("("+STRING+")")
        f.write("</FONT></TD>\n")
        f.close()
        if not env.has_key('__BODY_')  or  \
           not env['__BODY_'][0]  or  \
           ( (not env['__BODY_'][1])  and  diff ):
            env['__BODY_'] = [TSTDIR+"/.index.html", diff]
        os.chdir(BACK)
### AddSubToHtmlIndex (env, TSTDIR) #

def SkipTest(env, TST, EXT, REASON) :
    TSTDIR = env['TSTDIR']
    TEXT="Skipping test "+TST+EXT+" "+REASON
    Warn(TEXT)
    f = open("."+TST+".SKIPPED","w")
    f.write("\n"+THISFILE+"  Warning:  %s\n\n" % TEXT)
    f.close()
    f = open(".index.head.html","a")
    f.write("""\
<TD ALIGN=CENTER><FONT FACE='helvetica, arial'><A HREF='.%(tst)s.src.index.html' TARGET='%(osver)s_%(tstdir)s_body'><FONT COLOR=#000000>
%(tst)s</FONT></A><BR><A HREF='.%(tst)s.SKIPPED' TARGET='%(osver)s_%(tstdir)s_body'>(skipped)</A></FONT></TD>
""" % {'tst':TST, 'osver':OSVER, 'tstdir':TSTDIR})
    f.close()
    if not env.has_key('_'+TSTDIR+'_BODY_')  or  \
       not env['_'+TSTDIR+'_BODY_'][0]  or  \
       not env['_'+TSTDIR+'_BODY_'][1]:
        env['_'+TSTDIR+'_BODY_'] = ["."+TST+".SKIPPED", 1]
    CreateSrcIndex(env, TST, EXT)
### SkipTest(env, TST, EXT, REASON) #

def find_test_dirs(thisdir) :
    testdirs = []
    thisdir = os.path.abspath(thisdir)
    dirnme = os.path.basename(thisdir)
    dirlst = os.listdir(thisdir)
    if dirnme == TSTSUFF  and  "All" in dirlst  and  os.path.isfile(os.path.join(thisdir,"All")):
        testdirs.append(os.path.dirname(thisdir))
    for d in dirlst:
        d = os.path.join(thisdir,d)
        if os.path.isdir(d):
            testdirs = testdirs + find_test_dirs(d)
    return testdirs
### find_test_dirs(thisdir) #

def PerformDir(env, testdir, testlist, BusyPorts) :
    td = 0
    Fd = -1
    TSTSRCBASE = env['TSTSRCBASE']
    TSTPREF = env['TSTPREF']
    if testdir == TSTSRCBASE:
        TSTDIR = os.curdir
    else:
        TSTDIR = testdir[len(TSTSRCBASE+os.sep):]
    TSTSRCDIR = os.path.normpath(os.path.join(testdir,TSTSUFF))
    TSTBLDDIR = os.path.normpath(os.path.join(env['TSTBLDBASE'],TSTDIR,TSTSUFF))
    TSTTRGDIR = os.path.normpath(os.path.join(env['TSTTRGBASE'],TSTPREF,TSTDIR))

    if THISFILE in ["Mtest.py", "Mprofile.py"]:
        TSTDB = TSTPREF+"_"+string.replace(TSTDIR, os.sep, '_')
    else: # THISFILE == "Mapprove.py"
        TSTDB = ""

    if not testlist:
        for tst in fileinput.input(os.path.join(TSTSRCDIR,"All")):
            tst = string.strip(tst)
            if tst  and  tst[0] != "#":
                testlist.append(tst)
    if not testlist:
        Warn("No tests found in '"+TSTSRCDIR+"`; skipping directory!")
        return td

    env['TSTDB']     = TSTDB
    env['TSTDIR']    = TSTDIR
    env['TSTSRCDIR'] = TSTSRCDIR
    env['TSTBLDDIR'] = TSTBLDDIR
    env['TSTTRGDIR'] = TSTTRGDIR
    env['RELSRCDIR'] = os.path.join(((os.pardir+os.sep)*(len(string.split(TSTDIR,os.sep))+1))+env['RELSRCBASE'],TSTDIR,TSTSUFF)
    env['RELBLDDIR'] = os.path.join(((os.pardir+os.sep)*(len(string.split(TSTDIR,os.sep))+1))+env['RELBLDBASE'],TSTDIR,TSTSUFF)
    os.environ['TSTDB']     = TSTDB
    os.environ['TSTDIR']    = TSTDIR
    os.environ['TSTSRCDIR'] = TSTSRCDIR
    os.environ['TSTBLDDIR'] = TSTBLDDIR
    os.environ['TSTTRGDIR'] = TSTTRGDIR
    os.environ['RELSRCDIR'] = env['RELSRCDIR']
    os.environ['RELBLDDIR'] = env['RELBLDDIR']

    if THISFILE in ["Mtest.py", "Mprofile.py"]:
        if os.path.exists(os.path.join(env['GDK_DBFARM'],TSTDB)):
            try:
                shutil.rmtree(os.path.join(env['GDK_DBFARM'],TSTDB))
            except:
                Warn("database '"+TSTDB+"` exists, but destroying it failed; skipping tests in '"+TSTSRCDIR+"`!")
                #TODO:
                # add "something" to HTML output
                return td
        try:
            os.makedirs(os.path.join(env['GDK_DBFARM'],TSTDB))
        except:
            Warn("creating database '"+TSTDB+" failed; skipping tests in '"+TSTSRCDIR+"`!")
            #TODO:
            # add "something" to HTML output
            return td
        if not os.path.exists(TSTTRGDIR):
            #TODO: set mode to umask
            os.makedirs(TSTTRGDIR)

        for TST in testlist:
            os.environ['TST'] = TST
            tt,Ft = RunTest(env, TST, BusyPorts)
            if tt:
                t = "%7.3f" % tt
            else:
                t = '-.---'
            TIMES.append([TSTDIR,TST,t,Ft])
            td = td + tt
            Fd = max(Fd,Ft)
        TIMES.append([TSTDIR,'',"%7.3f" % td,Fd])

        if THISFILE in ["Mtest.py", "Mprofile.py"]:
            CreateHtmlIndex(env)
            AddSubToHtmlIndex(env, TSTDIR)

    else: # THISFILE == "Mapprove.py"
        if not os.path.exists(TSTTRGDIR):
            Warn("Output directory '"+TSTTRGDIR+"` missing; skipping directory!")
            return td

        for TST in testlist:
            td = td + ApproveOutput(env, TST)

    return td
### PerformDir(env, testdir, testlist, BusyPorts) #

def ApproveOutput (env, TST) :
    sem = 0
    TSTDB = env['TSTDB']
    TSTDIR  = env['TSTDIR']
    TSTSRCDIR = env['TSTSRCDIR']
    TSTTRGDIR = env['TSTTRGDIR']
    os.chdir(TSTSRCDIR)
    EXTENSIONS = par['EXTENSION']
    SYSTEM = par['SYSTEM']
    FORCE = par['FORCE']

#       filter = re.compile( "^!WARNING: TCPlisten\([0-9]*\): stopped.$"        "|"
#                            "^!WARNING: TCPepilogue: terminate [01] listeners$", re.MULTILINE)

    for WHAT in EXTENSIONS:
        testOUTPUT   = os.path.join(TSTTRGDIR,TST+".test."+WHAT)
        stableOUTPUT = os.path.join(TSTSRCDIR,TST+".stable."+WHAT+SYSTEM)
        if os.path.isfile(testOUTPUT):
#                       print "Approving "+testOUTPUT+" -> "+stableOUTPUT
            if os.path.isfile(stableOUTPUT):
                oc = 'overwriting old'
            else:
                oc = 'creating new'
            print "Approving %s -> stable.%s%s  (%s file)" % (os.path.join(TSTDIR,TST+".test."+WHAT), WHAT, SYSTEM, oc)
            f = open(stableOUTPUT, "w")
            for l in fileinput.input(testOUTPUT):
                if len(l) == 0  or  l[0] != '!':        # or  filter.match(ln):
                    f.write(l)
                else:
                    if FORCE:
                        f.write(l)
                        as = 'Approving'
                    else:
                        as = 'Skipping'
                    Warn('%s error message: "%s"' % (as,string.replace(l, os.linesep, '')))
                    sem = 1
            f.flush()
            f.close()
        else:
            Warn("Output file missing: '"+testOUTPUT+"`; skipping test!")
    return sem
### ApproveOutput (env, TST) #

def isexecutable(TST) :
    if   os.name == "nt":
        for ext in ".exe", ".com", ".bat", ".cmd":
            if os.path.isfile(TST+ext):
                return [ 1, ext ]
    elif os.name == "posix":
        #TODO:
        # check with "file", and set executable
        if os.path.isfile(TST)  and  os.access(TST,os.X_OK):
            return [ 1, "" ]
    #TODO:
    #else:
        # ???
    return [ 0, "" ]
### isexecutable(TST) #

def GetBitsAndModsAndStatic(env) :
    TSTPREF = env['TSTPREF']
    pOut,pIn,pErr = popen2.popen3('%s%s --dbname=%s' % (env['exe']['Mtimeout'][1], env['exe']['Mserver'][1], TSTPREF))
    pIn.write('''\
        loaded;
        help("kunion");
        {
            # print a list of all modules found
            # "Modules: mod1, mod2, ..."
            MODs := kunion([~monet_mod_nme].reverse,[~view_modules].reverse).kunique;
            printf("\\nModules: ");
            x := "";
            MODs@batloop{
                printf("%s\'%s\'",x,$h);
                x:=",";
            }
            printf("\\n");
        }
        quit;
    ''')
    ##module("NoModule");
    pIn.close()
    qOut, qErr = ReadMultiple([pOut, pErr])
    env['TST_BITS'] = ""
    env['TST_MODS'] = []
    env['TST_STATIC'] = ""
    if qOut:
        tbs = re.compile("^# compiled for .*/([63][42]bit); (.*) linked", re.MULTILINE)
        tm = re.compile("^Modules: (.*)$", re.MULTILINE)
        #ts = re.compile("^!ERROR: DL_open: library not found \(STATIC\).$", re.MULTILINE)
        for l in string.split(qOut, '\n'):
            bs = tbs.match(l)
            if bs:
                env['TST_BITS'] = bs.group(1)
                os.environ['TST_BITS'] = env['TST_BITS']
                if bs.group(2) == "statically":
                    env['TST_STATIC'] = "1"
                    os.environ['TST_STATIC'] = env['TST_STATIC']
            m = tm.match(l)
            if m:
                env['TST_MODS'] = eval(m.group(1))
            #s = ts.match(l)
            #if s:
            #       env['TST_STATIC'] = "1"
            #       os.environ['TST_STATIC'] = env['TST_STATIC']
        if not env['TST_BITS']:
            Warn("Checking for Bits failed!")
        if not env['TST_MODS']:
            Warn("Checking for Modules failed!")
        if not env['TST_BITS'] or not env['TST_MODS']:
            STDERR.write(qOut)
            STDERR.write("\n")
            STDERR.write(qErr)
            STDERR.write("\n")
            STDERR.flush()
    else:
        Warn("No output from Mserver when checking for Bits & Modules!?")
        if qErr:
            STDERR.write(qErr)
            STDERR.write("\n")
            STDERR.flush()
    os.environ['TST_MODS'] = str(env['TST_MODS'])
    return env['TST_BITS'], env['TST_MODS'], env['TST_STATIC']
### GetBitsAndModsAndStatic(env) #

def CheckMods(env, TST, SERVER) :
    missing = []
    if os.path.isfile(TST+".modules"):
        for m in fileinput.input(TST+".modules"):
            m = string.strip(m)
            if m  and  m[0] != "#"  and  m not in env['TST_MODS']:
                missing.append(m)
    if SERVER == "MAPI":
        for m in "str", "mapi":
            if m not in env['TST_MODS']:
                missing.append(m)
    if SERVER == "SQL":
        for m in "str", "sqlserver", "ascii_io", "alarm", "unix", "xtables", "aggrX3", "monettime", "uchr", "mmath":
            if m not in env['TST_MODS']:
                missing.append(m)
    return missing
### CheckMods(env, TST, SERVER) #

def CheckBATs(env, TST, TSTDB) :
    pOut,pIn,pErr = popen2.popen3('%s%s --dbname=%s' % (env['exe']['Mtimeout'][1], env['exe']['Mserver'][1], TSTDB))
    pIn.write('''\
        {
            # print a list of all persisten BATs
            # "BATs: bat1, bat2, ..."
            BATs := view_bbp_name;
            printf("\\nBATs: ");
            x := "";
            BATs@batloop{
                printf("%s\'%s\'",x,$t);
                x:=",";
            }
            printf("\\n");
        }
        quit;
    ''')
    pIn.close()
    qOut, qErr = ReadMultiple([pOut, pErr])
    TST_BATS = []
    if qOut:
        tb = re.compile("^BATs: (.*)$", re.MULTILINE)
        for l in string.split(qOut, '\n'):
            b = tb.match(l)
            if b:
                TST_BATS = eval(b.group(1))
    else:
        Warn("No output from Mserver when checking for Bats!?")
        if qErr:
            STDERR.write(qErr)
            STDERR.write("\n")
            STDERR.flush()

    missing = []
    if os.path.isfile(TST+".BATs"):
        for b in fileinput.input(TST+".BATs"):
            b = string.strip(b)
            if b  and  b[0] != "#"  and  b not in TST_BATS:
                missing.append(b)
    return missing
### CheckBATs(env, TST, TSTDB) #

def StartAt(cmd) :
    pOut,pIn,pErr = popen2.popen3(cmd)
    pIn.close()
    qOut, qErr = ReadMultiple([pOut, pErr])
    return string.strip(string.split(qOut, '\n', 1)[0])
### StartAt(cmd) #

def StopAt(ATJOB,ME) :
    while  os.path.isfile(path("/tmp/.MkillUsers."+ME)):
        time.sleep(9)
    if OS == "IRIX" or OS == "IRIX64":
        ATRM = 'at -r '
    else:
        ATRM = 'atrm '
    os.system(ATRM+ATJOB)
    #TODO:
    #LOG1x at -l >&2
### StopAt(ATJOB,ME) #

def RunTest(env, TST, BusyPorts) :
    Failed = -1
    TSTDB = env['TSTDB']
    TSTDIR  = env['TSTDIR']
    TSTSRCDIR = env['TSTSRCDIR']
    TSTTRGDIR = env['TSTTRGDIR']
    TSTTRGBASE = env['TSTTRGBASE']
    os.chdir(TSTSRCDIR)

    TX = 0
    EXT = CALL = SERVER = ""
    x  = isexecutable(TST)
    xS = isexecutable(TST+".SQL")
    xM = isexecutable(TST+".MAPI")
    if   x[0]:
        EXT = x[1]          ; CALL = "other"
    elif xS[0]:
        EXT = ".SQL"+xS[1]  ; CALL = "other"  ; SERVER = "SQL"
    elif xM[0]:
        EXT = ".MAPI"+xM[1] ; CALL = "other"  ; SERVER = "MAPI"
    elif os.path.isfile(TST+".py")          or  os.path.isfile(TST+".py.src"):
        EXT = ".py"         ; CALL = "python"
    elif os.path.isfile(TST+".SQL"+".py")   or  os.path.isfile(TST+".SQL"+".py.src"):
        EXT = ".SQL.py"     ; CALL = "python" ; SERVER = "SQL"
    elif os.path.isfile(TST+".MAPI"+".py")  or  os.path.isfile(TST+".MAPI"+".py.src"):
        EXT = ".MAPI.py"    ; CALL = "python" ; SERVER = "MAPI"
    elif os.path.isfile(TST+".milM")        or  os.path.isfile(TST+".milM.src"):
        EXT = ".milM"       ; CALL = "milM"
    elif os.path.isfile(TST+".milS")        or  os.path.isfile(TST+".milS.src"):
        EXT = ".milS"       ; CALL = "milS"
    elif os.path.isfile(TST+".milC")        or  os.path.isfile(TST+".milC.src"):
        EXT = ".milC"       ; CALL = "milC"   ; SERVER = "MAPI"
    elif os.path.isfile(TST+"_s00.milM")    or  os.path.isfile(TST+"_s00.milM.src"):
        EXT = ".milM"       ; CALL = "milMXs"
    elif os.path.isfile(TST+"_s00.milS")    or  os.path.isfile(TST+"_s00.milS.src"):
        EXT = ".milS"       ; CALL = "milSXs"
    elif os.path.isfile(TST+"_s00.milC")    or  os.path.isfile(TST+"_s00.milC.src"):
        EXT = ".milC"       ; CALL = "milCXs" ; SERVER = "MAPI"
    elif os.path.isfile(TST+"_p00.milC")    or  os.path.isfile(TST+"_p00.milC.src"):
        EXT = ".milC"       ; CALL = "milCXp" ; SERVER = "MAPI"
    elif os.path.isfile(TST+".sql")         or  os.path.isfile(TST+".sql.src"):
        EXT = ".sql"        ; CALL = "sql"    ; SERVER = "SQL"
    elif os.path.isfile(TST+"_s00.sql")     or  os.path.isfile(TST+"_s00.sql.src"):
        EXT = ".sql"        ; CALL = "sqlXs"  ; SERVER = "SQL"
    elif os.path.isfile(TST+"_p00.sql")     or  os.path.isfile(TST+"_p00.sql.src"):
        EXT = ".sql"        ; CALL = "sqlXp"  ; SERVER = "SQL"
        #TODO:
        #elif [ -f "$TST.java"       ] ; then  EXT="java" ; CALL="Java   "+TST+" "+EXT
        #elif [ -f "${TST}_s00.java" ] ; then  EXT="java" ; CALL="JavaXs "+TST+" "+EXT
        #elif [ -f "${TST}_p00.java" ] ; then  EXT="java" ; CALL="JavaXp "+TST+" "+EXT
        #elif [ -f "$TST.odmg"       ] ; then  EXT="odmg" ; CALL="odmg   "+TST+" "+EXT
    else:
        EXT = CALL = SERVER = ""
        if os.name == "nt":
            ErrMsg("test missing: '"+os.path.join(TSTSRCDIR,TST)+".(exe|com|bat|cmd|py|milM|milS|milC)`")
            #TODO:
            #elif os.name == "posix":
        else:
            ErrMsg("test missing: '"+os.path.join(TSTSRCDIR,TST)+"[.py|.milM|.milS|.milC]`")
        return TX,Failed

    MissingMods = CheckMods(env, TST, SERVER)
    MissingBATs = CheckBATs(env, TST, TSTDB)

    os.chdir(TSTTRGDIR)

    NotOnNT = []
    #\
    #       ["src/modules/plain/tcpip1", "src/modules/plain/tcpip2"]
    #\
    #       "src/modules/plain/salgebra", "tests/by_Peter/tst_priv", \
    #       "scripts/gold/tst100", "scripts/gold/tstvoid", "src/gdk/reload", "src/modules/plain/mprof", "src/modules/plain/mprof2", \
    #       "tests/Availability/00_Mserver", "tests/BugReports/no.073", "tests/BugReports/no.089"]
    NotOnCYG = [ "tests/BugReports/no.147", "tests/by_Peter/recursion" ]
    ReqMshdn = ["MAPI"]

    if   os.name == "nt"  and  url(TSTDIR)+"/"+TST in NotOnNT:
        SkipTest(env, TST, EXT, "as it currently crashes/hangs on WindowsNT.")
    elif sys.platform == "cygwin"  and  url(TSTDIR)+"/"+TST in NotOnCYG:
        SkipTest(env, TST, EXT, "as it currently crashes/hangs on CYGWIN.")
    elif SERVER in ReqMshdn  and  not env['exe']['Mshutdown'][0]:
        SkipTest(env, TST, EXT, "as Mshutdown is not available.")
    elif SERVER == "MAPI" and  not env['MAPI_MIL']:
        SkipTest(env, TST, EXT, "as 'mapi.mil' is not available.")
        #elif SERVER == "MAPI" and  os.name == "nt":
        #SkipTest(env, TST, EXT, "as Mapi is (currently?) not working on WindowsNT.")
    elif EXT == ".milC" and  not env['exe']['Mapi_Client'][0]:
        SkipTest(env, TST, EXT, "as "+string.split(env['MAPICLIENT'])[0]+" is not available.")
    elif CALL == "python"  and  not env['exe']['python'][0]:
        SkipTest(env, TST, EXT, "as python is not available.")
        #TODO:
        #elif EXT == ".milC":
        #SkipTest(env, TST, EXT, "as MapiClient-tests are temporary not supported by "+THISFILE+".")
        ##elif EXT == ".milC"  and  os.name == "nt":
        ###SkipTest(env, TST, EXT, "as MapiClient is currently not working on WindowsNT.")
        #TODO:
        #elif [ "$EXT" = "java"  -a  ! "`type -path java`" ] ; then
        #SkipTest(env, TST, EXT, "as java is not in $PATH.")
    elif SERVER == "SQL" and  not env['SQLSERVER_MIL']:
        SkipTest(env, TST, EXT, "as sqlserver.mil is not available.")
    elif EXT == ".sql" and  not env['exe']['SQL_client'][0]:
        SkipTest(env, TST, EXT, "as "+string.split(env['SQLCLIENT'])[0]+" is not available.")
    elif MissingMods:
        SkipTest(env, TST, EXT, "as modules '"+str(MissingMods)+"` are missing.")
    elif MissingBATs:
        SkipTest(env, TST, EXT, "as BATs '"+str(MissingBATs)+"` are missing in database '"+TSTDB+"`.")
    elif CALL == "milCXp":
        SkipTest(env, TST, EXT, "as multiple MapiClients in parallel are currently not supported by "+THISFILE+".")
    elif CALL == "sqlXp":
        SkipTest(env, TST, EXT, "as multiple SQL clients in parallel are currently not supported by "+THISFILE+".")
    elif SERVER in BusyPorts:
        if SERVER == "SQL":
            SkipTest(env, TST, EXT, "as SQLPORT=%s and/or MAPIPORT=%s are not available." % (env['SQLPORT'],env['MAPIPORT']))
        else:
            SkipTest(env, TST, EXT, "as %sPORT=%s is not available." % (SERVER,env[SERVER+'PORT']))
    else:
        test = re.compile("^"+TST+"((_[sp][0-9][0-9])?\..*)?$", re.MULTILINE)
        for f in os.listdir(TSTSRCDIR):
            if test.match(f):
                shutil.copy(os.path.join(TSTSRCDIR,f),TSTTRGDIR)
        if os.path.isfile(TST+EXT+".src")  and not os.path.isfile(TST+EXT):
            f = open(TST+EXT+".src","r")
            TSTSRC = os.path.expandvars(path(string.strip(f.readline())))
            f.close()
            if os.path.isfile(TSTSRC):
                shutil.copy(TSTSRC,TST+EXT)
            else:
                SkipTest(env, TST, EXT+".src", "as source file '"+TSTSRC+"` is missing.")
                return TX,Failed
        test = re.compile("^"+TST+"((_[sp][0-9][0-9])?\..*)?\.src$", re.MULTILINE)
        for ff in os.listdir(TSTTRGDIR):
            if test.match(ff) and not os.path.isfile(ff[:-4]):
                f = open(ff,"r")
                TSTSRC = os.path.expandvars(path(string.strip(f.readline())))
                f.close()
                if os.path.isfile(TSTSRC):
                    shutil.copy(TSTSRC,ff[:-4])
                else:
                    Warn("source file '"+TSTSRC+"` is missing.")

        if THISFILE == "Mprofile.py":
            test = re.compile("^"+TST+"(_[sp][0-9][0-9])?\..*mil.*$", re.MULTILINE)
            d = os.listdir(os.getcwd())
            for f in d:
                if test.match(f)  and  f != TST+EXT+".src":
                    prof.prof(f, env['CMDLST'])
                    os.rename(f,f+".no_prof")
                    os.rename("prof_"+f,f)
                    os.system('%s -I"%s" %s -A%d %s.no_prof %s %s.prof.diff.html' % (env['exe']['Mdiff'][1],par['IGNORE'],par['CONTEXT'],par['ACCURACY'],f,f,f))

        BITS = env['TST_BITS']
        ACCURACYout = par['ACCURACY']
        ACCURACYerr = par['ACCURACY']
        if env['TST_STATIC']:
            STATIC = "(\.STATIC)?"
        else:
            STATIC = ""
        dir,file = os.path.split(TST)
        outre = re.compile('^'+re.escape(file)+'\.stable\.(?P<tp>out|err)(\.%s(%s)?)?(\.%s)?%s$' % (re.escape(OS), re.escape(RELEASE), BITS, STATIC))
        bestout = besterr = ''
        for f in os.listdir(dir or os.curdir):
            res = outre.match(f)
            if res is not None:
                if res.group('tp') == 'out':
                    if len(bestout) < len(f):
                        bestout = f
                else:                   # res.group('tp') == 'err'
                    if len(besterr) < len(f):
                        besterr = f
        if bestout:
            STABLEout = os.path.join(dir, bestout)[len(TST):]
        else:
            STABLEout = ''
        if besterr:
            STABLEerr = os.path.join(dir, besterr)[len(TST):]
        else:
            STABLEerr = ''
        if not os.path.isfile(TST+STABLEout):
            open(TST+STABLEout,"w").close()
            ACCURACYout = 0
        if not os.path.isfile(TST+STABLEerr):
            open(TST+STABLEerr,"w").close()
            ACCURACYerr = 0

        if os.path.isfile(TST+".prelude")  and  EXT not in  ['.milC','.sql']:
            PRELUDE = TST+".prelude"
        else:
            PRELUDE = ""

        TIMEOUTED = "Mtimeout"
        for v in env['exe'].keys():
            TIMEOUTED = TIMEOUTED+"|"+string.upper(v)
        test = re.compile("^[^#]*("+TIMEOUTED+")[^#]*(# ([0-9]+)x|#.*)?$", re.MULTILINE)
        TIMEOUT = par['TIMEOUT']
        if os.path.isfile(TST+".timeout"):
            for f in fileinput.input(TST+".timeout"):
                TOf = int(string.strip(f))
                if TOf > 1:
                    TIMEOUT = TIMEOUT * TOf
        if env['exe']['Mtimeout'][0]:
            env['exe']['Mtimeout'] = env['exe']['Mtimeout'][0], 'Mtimeout -timeout '+str(TIMEOUT)+' '
            SetExecEnv(env['exe'],0)
        CTIMEOUT = 0
        if   CALL in ["other", "python"]:
            CTIMEOUT = CTIMEOUT + 60
            for l in fileinput.input(TST+EXT):
                TOm = test.match(l)
                if TOm:
                    TOx = TOm.group(3)
                    if TOx and (int(TOx) > 1):
                        TOx = int(TOx)
                    else:
                        TOx = 1
                    CTIMEOUT = CTIMEOUT + ( TOx * TIMEOUT )
        elif CALL in ["milMXs", "milSXs", "milCXs", "sqlXs"]:
            test = re.compile("^"+TST+"_s[0-9][0-9]"+EXT+"$", re.MULTILINE)
            d = os.listdir(os.getcwd())
            for f in d:
                if test.match(f):
                    CTIMEOUT = CTIMEOUT + TIMEOUT
        elif CALL in ["milM", "milS", "milC", "sql"]:
            CTIMEOUT = CTIMEOUT + TIMEOUT
        if  CTIMEOUT < TIMEOUT:
            CTIMEOUT = TIMEOUT
        STIMEOUT = CTIMEOUT
        if  SERVER in ["MAPI", "SQL"]:
            STIMEOUT = STIMEOUT + TIMEOUT + 60

        ME = ""
        ATJOB1 = ""
        MkillUsers = ""
        if os.name != "nt" and sys.platform != 'cygwin':
            for f in TST+".KILLED.out", TST+".KILLED.err":
                if os.path.isfile(f):
                    os.remove(f)
            ME = str(os.getpid())
            WAIT = str(int(STIMEOUT / 60) + 2)
            FILES = os.path.join(TSTTRGDIR,TST)+" "+os.path.join(TSTTRGDIR,TST)+".*"
            for f in ["bat/\\*", '.gdk_lock']:
                FILES = FILES+" "+os.path.join(env['GDK_DBFARM'],TSTDB,path(f))
            WHAT = os.path.join(THISPATH,"MkillUsers")+" -l"+ME+" -p"+ME+" "+FILES+r" \>\>"+os.path.join(TSTTRGDIR,TST+".KILLED.out")+r" 2\>\>"+os.path.join(TSTTRGDIR,TST+".KILLED.err")
            WHEN = "now + "+WAIT+" minutes"
            cmd  = "echo  "+WHAT+"  2>/dev/null | at "+WHEN+" 2>&1 | awk '/^[Jj]ob/{print $2}'"
            ATJOB1 = StartAt(cmd)
            #TODO:
            #LOG1x at -l >&2
            MkillUsers = "echo  "+WHAT+"  2>/dev/null | at now + 1 minute 2>&1 | awk '/^[Jj]ob/{print $2}'"

        #if THISFILE == "Mtest.py":
        TestOutFile = TST+".test.out"
        TestErrFile = TST+".test.err"
        TestOut = open(TestOutFile,"w")
        TestErr = open(TestErrFile,"w")
        #else:  # THISFILE == "Mprofile.py"
        #       TestOut = open(TST+".profile.out","w")
        #       TestErr = open(TST+".profile.err","w")
        TestOut.write("stdout of test '"+TST+"` in directory '"+url(TSTDIR)+"` itself:\n\n")
        TestErr.write("stderr of test '"+TST+"` in directory '"+url(TSTDIR)+"` itself:\n\n")
        TestOut.close()
        TestErr.close()

        t0 = time.time()
        DoIt (env, SERVER, CALL, TST, EXT, PRELUDE, TestOutFile, TestErrFile, STIMEOUT, CTIMEOUT, TIMEOUT, MkillUsers, ME)
        t1 = time.time()
        TX = t1 - t0
        STDOUT.write(" %7.3fs " % TX)

        if os.name != "nt" and sys.platform != 'cygwin':
            StopAt(ATJOB1,ME)
            os.system(string.replace(string.replace(WHAT, '\\', ''), " -p"+ME+" ", ' '))
        else:
            while os.path.exists(os.path.join(TSTTRGBASE,".KILLED.lck")):
                time.sleep(1)

        killed = 0
        n = TST+".KILLED."
        for (x,txf) in [("out",TestOutFile),("err",TestErrFile)]:
            f = n+x
            if os.name == "nt":
                for t in os.path.join(TSTTRGBASE,f), os.path.join(TSTTRGBASE,".KILLED."+x):
                    if os.path.isfile(t):
                        shutil.copy(t,f)
                        os.remove(t)
                        break
            if os.path.isfile(f):
                p = open(txf, 'a')
                for l in fileinput.input(f):
                    p.write("! "+l)
                    killed = 1
                p.close()

        #TODO:
        ##if [ ! -f $TSTTRGBASE/Tests/.old.left-over.tmp.bats. ] ; then  touch $TSTTRGBASE/Tests/.old.left-over.tmp.bats. ; fi
        ##LEFTOVERTMPBATS="`find $MONETFARM/dbfarm/*/bat/ -name tmp_\* -print 2> /dev/null`"
        ##if [ "$LEFTOVERTMPBATS" ] ; then
        ##      ls -alF $LEFTOVERTMPBATS 2> /dev/null > .all.left-over.tmp.bats.
        ##      diff -u0 $TSTTRGBASE/Tests/.old.left-over.tmp.bats. .all.left-over.tmp.bats. | grep '^\+[^\+]' > .new.left-over.tmp.bats.
        ##fi
        ##if [ -s .new.left-over.tmp.bats. ] ; then
        ##      echo -e "\n!ERROR: persistent temporary bats remained:" >> $LOGFILE.err
        ##      sed 's|^\+|! |g' .new.left-over.tmp.bats.               >> $LOGFILE.err
        ##      echo                                                    >> $LOGFILE.err
        ##fi
        ##rm -f .new.left-over.tmp.bats. $TSTTRGBASE/Tests/.old.left-over.tmp.bats.
        ##if [ -f .all.left-over.tmp.bats. ] ; then  mv -f .all.left-over.tmp.bats. $TSTTRGBASE/Tests/.old.left-over.tmp.bats. ; fi

        timeout = 0
        mto = re.compile("^!(Mtimeout:)? Timeout:", re.MULTILINE)
        for l in fileinput.input(TestErr.name):
            if mto.match(l):
                timeout = 1

        if timeout:
            STDOUT.write("(Timeout!) ")
        if killed:
            STDOUT.write("(Killed!) ")
        STDOUT.write("\n")
        STDOUT.flush()

        if env['exe']['Mtimeout'][0]:
            env['exe']['Mtimeout'] = env['exe']['Mtimeout'][0], 'Mtimeout -timeout '+str(par['TIMEOUT'])+' '
            SetExecEnv(env['exe'],0)

        if THISFILE in ["Mtest.py", "Mprofile.py"]:
            Mfilter.mFilter(TST+STABLEout,par['IGNORE'])
            Mfilter.mFilter(TST+STABLEerr,par['IGNORE'])
            Mfilter.mFilter(TST+".test.out",par['IGNORE'])
            Mfilter.mFilter(TST+".test.err",par['IGNORE'])

            testO = re.compile("^/"+TST+STABLEout+"/([^/]*)/", re.MULTILINE)
            testE = re.compile("^/"+TST+STABLEerr+"/([^/]*)/", re.MULTILINE)
            REVo="?"
            REVe="?"
            entries = os.path.join(TSTSRCDIR,"CVS","Entries")
            if os.path.isfile(entries):
                for l in fileinput.input(entries):
                    mO = testO.match(l)
                    if mO:
                        REVo=mO.group(1)
                    mE = testE.match(l)
                    if mE:
                        REVe=mE.group(1)
            REVo=" (r"+REVo+")"
            REVe=" (r"+REVe+")"

            MDIFF0 = env['exe']['Mdiff'][1]
            MDIFF1 = MDIFF0
            if env['exe']['Mtimeout'][0]:
                MDIFF1 = env['exe']['Mtimeout'][1]+' '+MDIFF0

            #TODO:
            #timedout = 1
            #while timedout and ACCURACY >= 0:
            #       timedout = 0
            #       signal.alarm(par['TIMEOUT'])
            #       try:
            #               os.system(MDIFF+' -I"'+par['IGNORE']+'" '+par['CONTEXT']+' -A'+str(ACCURACY)+' -r"'+REVo+'" '+TST+STABLEout+'.FILTERED '+TST+'.test.out.FILTERED '+TST+'.out.diff.html')
            #       except TimeoutError, t:
            #               timedout = 1
            #       signal.alarm(0)
            #       ACCURACY = ACCURACY - 1
            MDIFF = MDIFF1
            timedout = 1
            while timedout and ACCURACYout >= 0:
                if ACCURACYout == 0:
                    MDIFF = MDIFF0
                timedout = os.system(MDIFF+' -I"'+par['IGNORE']+'" '+par['CONTEXT']+' -A'+str(ACCURACYout)+' -r"'+REVo+'" '+TST+STABLEout+'.FILTERED '+TST+'.test.out.FILTERED '+TST+'.out.diff.html')
                ACCURACYout = ACCURACYout - 1

            #TODO:
            #timedout = 1
            #while timedout and ACCURACY >= 0:
            #       timedout = 0
            #       signal.alarm(par['TIMEOUT'])
            #       try:
            #               os.system(MDIFF+' -I"'+par['IGNORE']+'" '+par['CONTEXT']+' -A'+str(ACCURACY)+' -r"'+REVe+'" '+TST+STABLEerr+'.FILTERED '+TST+'.test.err.FILTERED '+TST+'.err.diff.html')
            #       except TimeoutError, t:
            #               timedout = 1
            #       signal.alarm(0)
            #       ACCURACY = ACCURACY - 1
            MDIFF = MDIFF1
            timedout = 1
            while timedout and ACCURACYerr >= 0:
                if ACCURACYerr == 0:
                    MDIFF = MDIFF0
                timedout = os.system('%s -I"%s" %s -A%d -r"%s" %s%s.FILTERED %s.test.err.FILTERED %s.err.diff.html' % (MDIFF, par['IGNORE'], par['CONTEXT'], ACCURACYerr, REVe, TST, STABLEerr, TST, TST))
                ACCURACYerr = ACCURACYerr - 1

            Failed = AddTstToHtmlIndex(env, TST, STABLEout, STABLEerr, EXT)

    return TX,Failed
### RunTest(env, TST, BusyPorts) #

def CheckPort(host,port) :
    busy = 0
    Serrno = 0
    Serrstr = ""
    S = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    try:
        S.bind((host,port))
    except socket.error, (Serrno,Serrstr):
        busy = 1
    S.close()
    return busy, Serrno, Serrstr
### CheckPort(host,port) #

def randomPort(l,h) :
    repeat = 9
    host = ''
    port = 0
    rpt = 0
    while rpt < repeat:
        port = random.randrange(l,h,1)
        if CheckPort(host,port)[0]:
            rpt = rpt + 1
        else:
            break
    return port
### randomPort(l,h) #

def CheckSocket(env,SERVER,SrvrErr,LogLine) :
#       if OS == "SunOS":
#               wait = 241
#       else:
#               wait = 61
    wait = 61
    repeat = 5
    host = ''
    port = int(env[SERVER+'PORT'])
    rpt = 0
    while rpt < repeat:
        busy, Serrno, Serrstr = CheckPort(host,port)
        if busy:
            rpt = rpt + 1
            Smsg = """
! Socket-Check failed for %sserver on <%s:%d> with #%d; '%s' !
! Waiting %d seconds (%d/%d) ... """ % (SERVER, host, port, Serrno, Serrstr, wait, rpt, repeat)
            STDERR.write(Smsg)
            STDERR.flush()
            SrvrErr.write(Smsg)
            SrvrErr.flush()
            time.sleep(wait)
        else:
            break
    if rpt != 0:
        SrvrErr.write("Done.\n\n")
        SrvrErr.flush()
        STDERR.write("Done.\n"+prompt()+LogLine)
        STDERR.flush()
### CheckSocket(env,SERVER,SrvrErr,LogLine) #

def prompt() :
    return time.strftime('%H:%M:%S> ',time.localtime(time.time()))
### prompt() #

def Prompt(cmd) :
    prmpt = time.strftime('\n# %H:%M:%S >  ',time.localtime(time.time()))
    return prmpt+prmpt+cmd+prmpt+"\n\n"
### Prompt(cmd) #

def LaunchIt(cmd, TestIn, TestOut, TestErr) :
    if type(TestOut) is type('') and type(TestErr) is type(''):
        f = open(TestOut, 'a')
        f.write(Prompt(cmd))
        f.close()
        f = open(TestErr, 'a')
        f.write(Prompt(cmd))
        f.close()
        cmd = '%s >> %s 2>> %s' % (cmd, TestOut, TestErr)
        pIn = os.popen(cmd, 'w')
        pOut = pErr = None
    else:
        TestOut.write(Prompt(cmd))
        TestOut.flush()
        TestErr.write(Prompt(cmd))
        TestErr.flush()
        pOut,pIn,pErr = popen2.popen3(cmd)
    pIn.write(TestIn)
    pIn.flush()
    return pIn, pOut, pErr
### LaunchIt(cmd, TestIn, TestOut, TestErr) #

def ReadMultiple(inpipes, outpipes = None):
    if outpipes is None:
        # we will return a list of strings, one for each of the pipes,
        # with the input from the corresponding pipe
        outbuffers = [''] * len(inpipes)
    else:
        # we will return nothing.  the input from the pipes will be
        # written to the correspondging outpipes.
        outbuffers = None
        # in this case it may be that inpipes are all None and
        # outpipes are all strings
        if inpipes == [None]*len(inpipes):
            # we only check inpipes
            # we're done
            return
    if os.name == 'nt':
        # On Windows, select only works on sockets.
        # We must hope that reading the pipes in order won't cause
        # deadlock.
        for i in range(len(inpipes)):
            if outpipes is None:
                outbuffers[i] = inpipes[i].read()
            else:
                outpipes[i].write(inpipes[i].read())
            inpipes[i].close()
    else:
        readlist = inpipes[:]
        while readlist:
            readers, dummy1, dummy2 = select.select(readlist, [], [])
            todelete = []
            for r in readers:
                data = os.read(r.fileno(), 1024)
                if not data:
                    # we hit EOF on this pipe
                    todelete.append(r)
                else:
                    for i in range(len(inpipes)):
                        if r is inpipes[i]:
                            if outpipes is None:
                                outbuffers[i] = outbuffers[i] + data
                            else:
                                outpipes[i].write(data)
            for r in todelete:
                # remove the pipe from consideration and close it
                readlist.remove(r)
                r.close()
    if outpipes is not None:
        for p in outpipes:
            p.flush()
    return outbuffers
### ReadMultiple(inpipes, outpipes = None) #

def CollectIt(pOut, pErr, TestOut, TestErr) :
    ReadMultiple([pOut, pErr], [TestOut, TestErr])
### CollectIt(pOut, pErr, TestOut, TestErr) #

def RunIt(cmd, TestIn, TestOut, TestErr) :
    pIn, pOut, pErr = LaunchIt(cmd, TestIn, TestOut, TestErr)
    pIn.close()
    CollectIt(pOut, pErr, TestOut, TestErr)
### RunIt(cmd, TestIn, TestOut, TestErr) #

def Log() :
    time.strftime('%H:%M:%S> ',time.localtime(time.time()))
### Log() #

def DoIt(env, SERVER, CALL, TST, EXT, PRELUDE, TestOutFile, TestErrFile, STIMEOUT, CTIMEOUT, TIMEOUT, MkillUsers, ME) :
    ATJOB2 = ""
    LogLine = os.path.join(env['TSTDIR'],TST+EXT)+' '+PRELUDE+' (<='+str(STIMEOUT+60)+'s) ...'
    STDERR.flush()
    STDOUT.write(prompt()+LogLine)
    STDOUT.flush()
    TSTDB = env['TSTDB']
    exe = env['exe']
    if exe['Mtimeout'][0]:
        MTO = "Mtimeout -timeout "
        TOT = TIMEOUT
        STO = STIMEOUT
        CTO = CTIMEOUT
    else:
        MTO = ""
        TOT = ""
        STO = ""
        CTO = ""

    ServerReady = True
    if SERVER in ["MAPI", "SQL"]:
        PROLOGUE = ""
        if os.path.isfile(TST+".prologue"):
            PROLOGUE = " "+TST+".prologue"

        Srvr = '%s%s %s "--dbname=%s" --set %s_port=%s' % (MTO, str(STO), exe['Mserver'][1], TSTDB, string.lower(SERVER), env[SERVER+'PORT'])
        if SERVER == "MAPI":
            Srvr = '%s "%s"' % (Srvr, env['MAPI_MIL'])
        if SERVER == "SQL":
            Srvr = '%s --set mapi_port=%s' % (Srvr, env['MAPIPORT'])
            Srvr = '%s "%s"' % (Srvr, env['SQLSERVER_MIL'])
        Srvr = Srvr+PROLOGUE
        #-background"
        if os.name == "nt":
            Srvr = Srvr+' & echo.& '
        else:
            Srvr = Srvr+' ; echo ; '
        Srvr = Srvr+'echo Over..'

        SrvrOutFile = TST+".server.out"
        SrvrErrFile = TST+".server.err"
        SrvrOut = open(SrvrOutFile,"w")
        SrvrErr = open(SrvrErrFile,"w")
        ClntOutFile = TST+".client.out"
        ClntErrFile = TST+".client.err"
        open(ClntOutFile,"w").close()
        open(ClntErrFile,"w").close()

        CheckSocket(env, SERVER, SrvrErr, LogLine)
        if SERVER == "SQL":
            CheckSocket(env, "MAPI", SrvrErr, LogLine)

        pSrvrIn, pSrvrOut, pSrvrErr = LaunchIt(Srvr, 'printf("\\nReady.\\n");\n', SrvrOut, SrvrErr)
        ln=""
        while len(ln) < 6 or ln[:6] not in ['Ready.','Over..']:
            ln=pSrvrOut.readline()
            SrvrOut.write(ln)
            SrvrOut.flush()
        if ln[:6] != 'Ready.':
            ServerReady = False

    else:
        ClntOutFile = TestOutFile
        ClntErrFile = TestErrFile

    if ServerReady:
        if   CALL == "other":
            cmd = MTO+str(CTO)+" "+os.path.join(".",TST+EXT)+" "+TST+" "+PRELUDE
            RunIt(cmd, "", ClntOutFile, ClntErrFile)
        elif CALL == "python":
            cmd = MTO+str(CTO)+" "+exe['python'][1]+" "+TST+EXT+" "+TST+" "+PRELUDE
            RunIt(cmd, "", ClntOutFile, ClntErrFile)
        elif CALL in ["milM", "milS", "milMXs", "milSXs"]:
            cmd = '%s%s %s --dbname=%s %s < ' % (MTO, str(TOT), exe['Mserver'][1], TSTDB, PRELUDE)
            if CALL in ["milM", "milS"]:
                X=""
            else:
                X="_s[0-9][0-9]"
            test = re.compile("^"+TST+X+EXT+"$", re.MULTILINE)
            d = os.listdir(os.getcwd())
            d.sort()
            for f in d:
                if test.match(f):
                    RunIt(cmd+f, "", ClntOutFile, ClntErrFile)
        elif CALL in ["milC", "milCXs"]:
            TSTs = []
            if CALL == "milC":
                X=""
            else:
                X="_s[0-9][0-9]"
            test = re.compile("^"+TST+X+EXT+"$", re.MULTILINE)
            d = os.listdir(os.getcwd())
            d.sort()
            for f in d:
                if test.match(f):
                    TSTs.append(f)

            Clnt = MTO+str(TOT)+" "+exe['Mapi_Client'][1]+" < "
            for f in TSTs:
                RunIt(Clnt+f, "", ClntOutFile, ClntErrFile)

            #TODO
            #elif CALL == "milCXp":
        elif CALL in ["sql", "sqlXs"]:
            TSTs = []
            if CALL == "sql":
                X=""
            else:
                X="_s[0-9][0-9]"
            test = re.compile("^"+TST+X+EXT+"$", re.MULTILINE)
            d = os.listdir(os.getcwd())
            d.sort()
            for f in d:
                if test.match(f):
                    TSTs.append(f)

            Clnt = MTO+str(TOT)+" "+exe['SQL_client'][1]+" < "
            for f in TSTs:
                RunIt(Clnt+f, "", ClntOutFile, ClntErrFile)

    else:
	for fn in ClntOutFile,ClntErrFile:
	    fp = open(fn,'a')
	    fp.write('\n\n! Server not ready; skipping attempt to start client!\n\n')
	    fp.close()
	
    if SERVER in ["MAPI", "SQL"]:
        if os.path.isfile(TST+".epilogue"):
            EPILOGUE = open(TST+".epilogue",'r')
            EpiFailed = ""
            try:
                pSrvrIn.writelines(EPILOGUE.readlines())
                pSrvrIn.flush()
                pSrvrIn.write(';\nprintf("\\nDone..\\n");\n')
                pSrvrIn.flush()
            except IOError, (IOerrNo, IOerrStr):
                EpiFailed = EpiFailed+"\n! Executing "+TST+".epilogue failed with #"+str(IOerrNo)+": '"+IOerrStr+"'. !"
                EpiFailed = EpiFailed+"\n! Probably, Mserver has died before or during. !\n"
            ln=""
            while len(ln) < 6 or ln[:6] not in ['Done..','Over..']:
                ln=pSrvrOut.readline()
                SrvrOut.write(ln)
                SrvrOut.flush()
            SrvrOut.write(EpiFailed)
            SrvrOut.flush()
            EPILOGUE.close()

        if SERVER == "MAPI":
            Shwn = MTO+str(TOT)+" "+exe['Mshutdown'][1]
            ShwnOutFile = TST+".shutdown.out"
            ShwnErrFile = TST+".shutdown.err"
            open(ShwnOutFile,"w").close()
            open(ShwnErrFile,"w").close()
            RunIt(Shwn, "", ShwnOutFile, ShwnErrFile)
            time.sleep(1)             # give it time to actually shut down

        try:
            if SERVER == "MAPI":
                pSrvrIn.write("# All but the first (#) and the last (\\n) character of this line seem to get swallowed on/by Windows ... #\n")
                pSrvrIn.write("# In case the previous line contains just a '#', all but the first and the last character got swallowed by someone ... #\n")
                pSrvrIn.write("# In case the output ends after the following line, containing just a ';', Mshutdown might have been successful, #\n")
                pSrvrIn.write("# but the Mserver's stdin was still open and got closed only after the first MIL command-end, i.e., ';'+'\\n' is reached ... #\n")
                pSrvrIn.write(';\n')
                pSrvrIn.write('printf("\\n! Mserver still running after Mshutdown. Quitting now. !\\n");\n')
            pSrvrIn.write('quit;\n')
            pSrvrIn.flush()
        except IOError:
            pass
        pSrvrIn.close()

        if os.name != "nt":
            ATJOB2 = StartAt(MkillUsers)
        CollectIt(pSrvrOut, pSrvrErr, SrvrOut, SrvrErr)
        if os.name != "nt" and sys.platform != 'cygwin':
            StopAt(ATJOB2,ME)

        if SERVER == "MAPI":
            AllOut = [SrvrOut, ClntOutFile, ShwnOutFile]
            AllErr = [SrvrErr, ClntErrFile, ShwnErrFile]
        else:
            AllOut = [SrvrOut, ClntOutFile]
            AllErr = [SrvrErr, ClntErrFile]
        TestOut = open(TestOutFile, 'a')
        for q in AllOut:
            if type(q) is type(''):
                n = q
            else:
                n = q.name
                q.close()
            q = open(n,'r')
            TestOut.write(q.read())
            TestOut.flush()
            q.close()
        TestErr = open(TestErrFile, 'a')
        for q in AllErr:
            if type(q) is type(''):
                n = q
            else:
                n = q.name
                q.close()
            q = open(n,'r')
            TestErr.write(q.read())
            TestErr.flush()
            q.close()
    else:
        TestOut = open(TestOutFile, 'a')
        TestErr = open(TestErrFile, 'a')

    TestOut.write(Prompt('Done.'))
    TestOut.close()
    TestErr.write(Prompt('Done.'))
    TestErr.close()
### DoIt(env, SERVER, CALL, TST, EXT, PRELUDE, TestOut, TestErr, STIMEOUT, CTIMEOUT, TIMEOUT, MkillUsers, ME) #

def Check(command, input) :
    pOut,pIn,pErr = popen2.popen3(command+" || echo ! Exit 1")
    pIn.write(input)
    pIn.close()
    qOut, qErr = ReadMultiple([pOut, pErr])
    qOut = string.split(qOut, '\n')
    qErr = string.split(qErr, '\n')
    test = re.compile( r"^!WARNING: BATpropcheck: "                                          "|"
                       r"^!WARNING: monet_checkbat: "                                        "|"
                       r"^!WARNING: GDKlockHome: ignoring empty or invalid .gdk_lock."       "|"
                       r"^!WARNING: BBPdir: initializing BBP.",                               
                       re.MULTILINE)
    noErr = []
    for l in qOut+qErr:
        if l[:1] == "!":
            if test.match(l):
                if l[:10] != "!WARNING: ":
                    noErr.append(l+"\n")
            else:
                ErrMsg("'"+command+"` failed:")
                if qOut and len(qOut[-1]) >= 8 and qOut[-1][:8] == "! Exit 1":
                    qErr.append(qOut.pop())
                for l in qOut+qErr:
                    STDERR.write(l)
                    STDERR.write("\n")
                STDERR.write("\n")
                STDERR.flush()
                #sys.exit(1)
                return 1
    if noErr:
        STDOUT.flush()
        STDERR.writelines(noErr)
        STDERR.flush()
    return 0
### Check(command, input) #

def CheckExec(cmd) :
    for p in string.split(os.environ['PATH'],os.pathsep):
        x = isexecutable(os.path.join(p,cmd))
        if x[0]:
            return os.path.join(p,cmd+x[1])
    return ""
### CheckExec(cmd) #

def SetExecEnv(exe,verbose) :
    if os.name == "nt":
        CALL = "call "
    else:
        CALL = ""
    if verbose:
        STDERR.flush()
    for v in exe.keys():
        V = string.upper(v)
        if  v != 'Mtimeout':
            os.environ[V] = CALL+exe['Mtimeout'][1]+exe[v][1]
        elif exe[v][0]:
            os.environ[V] = CALL+exe[v][1]
        else:
            os.environ[V] = ""
        if verbose:
            print "%s = %s : %s" % (V, exe[v][0], exe[v][1])
    if verbose:
        STDOUT.flush()
### SetExecEnv(exe,verbose) #

#############################################################################
#       MAIN

THISFILE = os.path.basename(sys.argv[0])
THISPATH = os.path.abspath(os.path.dirname(sys.argv[0]))
if THISFILE == "Mprofile.py":
    dftTSTPREF = "mProfiles"
    TSTDBG = str(0)
    dftIGNORE = '^[#~]'
else:
    dftIGNORE = '^#'
    TSTDBG = str(2+8)
    dftTSTPREF = "mTests"
TSTSUFF = "Tests"

if os.environ.has_key('HOST'):
    HOST = os.environ['HOST']
elif os.name != "nt":
    HOST = os.uname()[1]
elif os.environ.has_key('COMPUTERNAME'):
    HOST = os.environ['COMPUTERNAME']
else:
    HOST = "BATMAN"
HOST = string.split(HOST,'.')[0]

if os.name == "nt":
    OS    = "WindowsNT"
    RELEASE = "5.0"
else:
    OS    = string.split(os.uname()[0],"_NT-")[0]
    if OS == "AIX":
        RELEASE = os.uname()[3]+"."+os.uname()[2]
    else:
        RELEASE = string.split(os.uname()[2],"(")[0]
OSVER = OS+RELEASE
os.environ['OS'] = OS
os.environ['OSVER'] = OSVER

if os.environ.has_key('COMPILER'):
    COMPILER = os.environ['COMPILER']
else:
    COMPILER = ""

if os.environ.has_key('HTMLTITLE'):
    HTMLTITLE = os.environ['HTMLTITLE']
else:
    HTMLTITLE = ""
    if COMPILER:
        HTMLTITLE = " for "+COMPILER
    HTMLTITLE = ""+THISFILE+" results"+HTMLTITLE+" on "+OSVER       #"+ ("`date`")"

URLPREFIX   = 'http://cvs.sourceforge.net/cgi-bin/viewcvs.cgi/monetdb/MonetDB/'
##URLSUFFIX_F = '?cvsroot=Monet-4.3'
URLSUFFIX_F = ''
##URLSUFFIX_D = '?cvsroot=Monet-4.3'
URLSUFFIX_D = ''

par = {}

def FindCmdLst(env) :
    dirs = [ os.path.join(os.getcwd(),"."), os.path.join(env['TSTSRCBASE'],".") ]
    if os.environ.has_key('HOME'):
        dirs.append(os.path.join(os.environ['HOME'],"."))
    dirs.append(path(env['MONET_PREFIX']+"/share/MonetDB/"))
    for d in dirs:
        f = d+'Mprofile-commands.lst'
        if os.path.isfile(f):
            return f
    return ""
### FindCmdLst(env) #

_MonetConfigDict = {
    '--source': '@QMONET_SOURCE@',
    '--build': '@QMONET_BUILD@',
    '--prefix': '@Qprefix@',
    }
def GetMonetConfig(arg) :
    # this works for arg in ('--source', '--build', '--prefix')
    return _configure(_MonetConfigDict[arg])
##    value = ""
##    #pOut,pIn = popen2.popen2(os.path.join(THISPATH,'monet-config')+' '+arg)
##    pOut,pIn = popen2.popen2('monet-config '+arg)
##    pIn.close()
##    qOut = pOut.readlines()
##    pOut.close()
##    if len(qOut):
##        value = string.strip(qOut[0])
##    return value
### GetMonetConfig(arg) #

SQLprefix = ''
dft = {}

def main(argv) :
    #TODO:
    #signal.signal(signal.SIGALRM, AlarmHandler)

    SQLprefix = os.environ.get('SQL_PREFIX', '')

    vars = ['MONET_SOURCE', 'MONET_BUILD', 'MONET_PREFIX',
            'TSTSRCBASE'  , 'TSTBLDBASE' , 'TSTTRGBASE'  ,
            'SQL_PREFIX'                                   ]
    if THISFILE in ["Mtest.py", "Mprofile.py"]:
        vars = vars + [ 'MAPIPORT', 'SQLPORT', 'SQLCLIENT', 'MAPICLIENT' ]    #, 'MONET_MOD_PATH' ]
    if THISFILE == "Mprofile.py":
        vars = vars + ['CMDLST']

    # most intuitive (?) default settings
    dft['MONET_SOURCE']   = "GetMonetConfig('--source')"
    dft['MONET_BUILD']    = "GetMonetConfig('--build')"
    dft['MONET_PREFIX']   = "GetMonetConfig('--prefix')"    # or THISPATH ?
    dft['SQL_PREFIX']     = "SQLprefix"
    dft['TSTSRCBASE']     = "env['MONET_SOURCE']"
    dft['TSTBLDBASE']     = "env['MONET_BUILD']"
    dft['TSTTRGBASE']     = "env['MONET_PREFIX']"   # or os.getcwd() ?
    if THISFILE in ["Mtest.py", "Mprofile.py"]:
        dft['GDK_DEBUG']      = "TSTDBG"
        dft['MONET_MOD_PATH'] = "''"   #"os.path.join(env['MONET_PREFIX'],'lib')+os.pathsep+os.path.join(env['MONET_PREFIX'],'lib','MonetDB')"
        dft['setMONET_MOD_PATH'] = "'--set \"monet_mod_path='+env['MONET_MOD_PATH']+'\"'"
        dft['setGDK_DBFARM'] = "'--dbfarm \"'+env['GDK_DBFARM']+'\"'"
        dft['MAPIPORT']       = "str(randomPort(50000,59999))"
        dft['SQLPORT']        = "str(randomPort(50000,59999))"
        dft['SQLCLIENT']      = "'Msql'" # --port='+env['SQLPORT']"
        dft['MAPICLIENT']     = "'MapiClient'" # --port='+env['MAPIPORT']"
    if THISFILE == "Mprofile.py":
        dft['CMDLST']         = "FindCmdLst(env)"
    env = {}

    #par = {}
    # get current environment
    for v in vars:
        if os.environ.has_key(v):
            env[v] = os.environ[v]
            #TODO:
            # make sure, that PATHs ar absolute

    # commandline options overrule environment
    cmd_options = [
        # long name, short name, GDK option, argument, comment
        (None, 'r', 'recursive', None,
         "recurse into subdirectories (implies 'All')"),
        ('MONET_SOURCE', None, 'MONET_SOURCE', '<path>',
         'default: "%s"' % GetMonetConfig('--source')),
        ('MONET_BUILD', None, 'MONET_BUILD', '<path>',
         'default: "%s"' % GetMonetConfig('--build')),
        ('MONET_PREFIX', None, 'MONET_PREFIX', '<path>',
         'default: "%s"' % GetMonetConfig('--prefix')),
        ('SQL_PREFIX', None, 'SQL_PREFIX', '<path>',
         'default: "%s"' % SQLprefix),
        ('TSTSRCBASE', None, 'TSTSRCBASE', '<path>',
         'default: <MONET_SOURCE>'),
        ('TSTBLDBASE', None, 'TSTBLDBASE', '<path>',
         'default: <MONET_BUILD>'),
        ('TSTTRGBASE', None, 'TSTTRGBASE', '<path>',
         'default: <MONET_PREFIX>'),
        ]

    if THISFILE in ["Mtest.py", "Mprofile.py"]:
        common_options = cmd_options + [
            (None, 'I', 'ignore', '<exp>',
             "ignore lines matching <exp> during diff (default: '%s')" % dftIGNORE),
            (None, 'C', 'context', '<num>',
             "use <num> lines of context during diff (default: -C1)"),
            (None, 'A', 'accuracy', '<num>',
             "accuracy for diff: 0=lines, 1=words, 2=chars (default: -A1)"),
            (None, 't', 'timeout', '<sec>',
             "timeout: kill (hanging) tests after <sec> seconds;\n"
             "-t0 means no timeout (default: -t60)"),
            ('debug', 'd', 'debug', '<num>',
             ("debug value to be used by Mserver (default: -d%s)\n"
              "(see `Mserver --help' for details)") % TSTDBG),
            ('monet_mod_path', None, 'monet_mod_path', '<pathlist>',
             "override Mserver's default module search path"),
            ('dbfarm', None, 'gdk_dbfarm', '<directory>',
             "override default location of database directory"),
            ('MAPIPORT', None, 'mapiport', '<port-no.>',
             'default: %s' % dft['MAPIPORT']),
            ('MAPICLIENT', None, 'mapiclient', '<mapi-client program>',
             'default: %s' % dft['MAPICLIENT']),
            ('SQLPORT', None, 'sqlport', '<port-no.>',
             'default: %s' % dft['SQLPORT']),
            ('SQLCLIENT', None, 'sqlclient', '<sql-client program>',
             'default: %s' % dft['SQLCLIENT']),
            ]

    if THISFILE == 'Mtest.py':
        options = common_options # + []
    elif THISFILE == "Mprofile.py":
        options = common_options + [
            ('CMDLIST', None, 'cmdlist', '<path>',
             "location of .Mprofile-commands.lst file; default is the first of\n" +
             "\t%s\n" % os.path.join(os.getcwd(), '.Mprofile-commands.lst') +
             "\t%s\n" % os.path.join('<TSTSRCBASE>', '.Mprofile-commands.lst') +
             "\t%s\n" % os.path.join(os.environ['HOME'],'.Mprofile-commands.lst') +
             "\t%s" % os.path.join(GetMonetConfig('--prefix'),'share','MonetDB','Mprofile-commands.lst')
             ),
            ]
    elif THISFILE == 'Mapprove.py':
        options = cmd_options + [
            (None, 'x', 'ext', '<ext>',
             "consider only output files *.<ext><sys> (<ext> = 'out' or 'err')\n"
             "(default: <ext> = 'out' & 'err')"),
            (None, 's', 'sys', '<sys>',
             "consider only output files *.<ext><sys>\n"
             "(<sys> = '', '.%s', '.%s', '.%s.(32|64)bit,'\n"
             "\tor any of these plus suffix '.STATIC')\n"
             "(default: <sys> = '')" % (OS, OSVER, OSVER)),
            (None, 'f', 'force', None,
             "force approval of error messages (i.e., lines starting with '!')"),
            ]
    else:
        options = []

    try:
        opts, args = monet_options.parse_options(argv[1:], options, Usage)
    except monet_options.Error:
        sys.exit(1)
    par['RECURSIVE'] = opts.get('recursive', 0)
    if THISFILE in ["Mtest.py", "Mprofile.py"]:
        par['IGNORE'] = opts.get('ignore', dftIGNORE)
        par['CONTEXT'] = '-C%d' % int(opts.get('context', 1))
        a = int(opts.get('accuracy', (os.name != 'nt' and 1) or 0))
        if a not in (0,1,2):
            ErrExit('Accuracy for diff (-A) must be one of: 0=lines, 1=words, 2=chars !')
        if os.name == "nt" and a != 0:
            Warn("Currently only '-A0` is supported on WindowsNT!")
            a = 0
        par['ACCURACY'] = a
        par['TIMEOUT'] = int(opts.get('timeout', 60))
        a = opts.get('debug')
        if a is not None:
            env['GDK_DEBUG'] = str(int(a))
        a = opts.get('monet_mod_path')
        if a is not None:
            env['MONET_MOD_PATH'] = a
        a = opts.get('gdk_dbfarm')
        if a is not None:
            env['GDK_DBFARM'] = a
    if THISFILE == 'Mapprove.py':
        a = opts.get('ext')
        if a is None:
            par['EXTENSION'] = ['out', 'err']
        elif a in ('out', 'err'):
            par['EXTENSION'] = [a]
        else:
            ErrXit("Extension (-x) must be one of: 'out', 'err' !")
        par['FORCE'] = opts.get('force', False)
        XTS = []
        for xts in ('', '.'+OS, '.'+OSVER, '.'+OSVER+'.32bit', '.'+OSVER+'.64bit'):
            XTS.append(xts)
            XTS.append(xts+'.STATIC')
        a = opts.get('sys')
        if a is None:
            par['SYSTEM'] = ''
        elif a in XTS:
            par['SYSTEM'] = a
        else:
            ErrXit("System (-s) must be one of: "+str(XTS)[1:-1]+" !")
    for v in vars:
        a = opts.get(v)
        if a is not None:
            env[v] = a

    # display par's
    STDERR.flush()
    for v in par.keys():
        #os.environ[v] = par[v]
        print "%s = %s" % (v, str(par[v]))
    STDOUT.flush()
    #env['par'] = par

    if env.has_key('MONET_PREFIX'):
        bp = os.path.join(env['MONET_PREFIX'],"bin")
        if os.environ.has_key('PATH'):
            bp = bp+os.pathsep+os.environ['PATH']
        os.environ['PATH'] = bp

    if env.has_key('SQL_PREFIX'):
        bp = os.path.join(env['SQL_PREFIX'],"bin")
        if os.environ.has_key('PATH'):
            bp = bp+os.pathsep+os.environ['PATH']
        os.environ['PATH'] = bp

    # tidy-up and fall-back to defaults where necessary
    if THISFILE in ["Mtest.py", "Mprofile.py"]:
        vars_ = vars + ['GDK_DEBUG', 'MONET_MOD_PATH']
    else: # THISFILE == "Mapprove.py"
        vars_ = vars
    for v in vars_:
        if not env.has_key(v):
            env[v] = eval(dft[v])
            #TODO:
            # make sure, that PATHs ar absolute
    if THISFILE in ["Mtest.py", "Mprofile.py"]:
        if env['MONET_MOD_PATH']:
            env['setMONET_MOD_PATH'] = eval(dft['setMONET_MOD_PATH'])
        else:
            env['setMONET_MOD_PATH'] = ''
        if env.has_key('GDK_DBFARM'):
            env['setGDK_DBFARM'] = eval(dft['setGDK_DBFARM'])
        else:
            env['setGDK_DBFARM'] = ''

    if THISFILE == "Mprofile.py"  and  not env['CMDLST']:
        try:
            Usage(options)
        except monet_options.Error:
            pass
        ErrXit("No .Mprofile-commands.lst found!")

    #TODO:
    ## in case of inconsistencies, try to fallback to "save" settings
    #
    #if not os.path.indir(TSTSRCBASE):
    #       ErrXit("Illegal TSTSRCBASE: directory '"+a"` does not exist!")
    #if not os.path.indir(MONET_SOURCE):
    #       ErrXit("Illegal MONET_SOURCE: directory '"+a"` does not exist!")
    #if not os.path.indir(MONET_BUILD):
    #       ErrXit("Illegal MONET_BUILD: directory '"+a"` does not exist!")
    #if not os.path.indir(MONET_PREFIX):
    #       ErrXit("Illegal MONET_PREFIX: directory '"+a"` does not exist!")

    # ensure consistent TSTSRCBASE
    if os.path.basename(env['TSTSRCBASE']) == TSTSUFF  and  os.path.isfile(os.path.join(env['TSTSRCBASE'],"All")):
        ErrXit('TSTSRCBASE itself must not be a test-directory, i.e., called "%s" and contain an "All" file!' % TSTSUFF)

    # make TSTxxxBASE absolute physical paths
    BACK = os.getcwd()
    for p in 'TSTSRCBASE', 'TSTBLDBASE', 'TSTTRGBASE':
        if os.path.isdir(env[p]):
            os.chdir(env[p])
            if (os.getcwd() != env[p]):
                Warn(p+": Replacing logical path  "+env[p]+
                     "  by absolute physical path  "+os.getcwd())
                env[p] = os.getcwd()
        else:
            ErrXit("Illegal "+p+": directory '"+env[p]+"' does not exist!")
    os.chdir(BACK)

    if THISFILE == "Mapprove.py" \
       and not os.path.exists(os.path.join(env['TSTTRGBASE'],dftTSTPREF )) \
       and     os.path.isfile(os.path.join(env['TSTTRGBASE'],'times.lst')):
        env['TSTPREF'] = os.path.basename(env['TSTTRGBASE'])
        env['TSTTRGBASE'] = os.path.dirname(env['TSTTRGBASE'])
    else:
        env['TSTPREF'] = dftTSTPREF
    TSTPREF = env['TSTPREF']

    # some relative path's for relocatable HTML output
    if env['TSTSRCBASE'] == env['TSTBLDBASE']  and  env['TSTBLDBASE'] == env['TSTTRGBASE']:
        RELSRCBASE = os.curdir
        RELBLDBASE = os.curdir
    else:
        TSTBASE = os.path.dirname(os.path.commonprefix([env['TSTSRCBASE'],env['TSTBLDBASE'],env['TSTTRGBASE']]))
        RELBASE = ((os.sep+os.pardir)*len(string.split(env['TSTTRGBASE'][len(TSTBASE+os.sep):],os.sep)))[len(os.sep):]
        RELSRCBASE = RELBASE+env['TSTSRCBASE'][len(TSTBASE):]
        RELBLDBASE = RELBASE+env['TSTBLDBASE'][len(TSTBASE):]
    env['RELSRCBASE'] = RELSRCBASE
    env['RELBLDBASE'] = RELBLDBASE

    #STDERR.flush()
    #for v in 'RELSRCBASE', 'RELBLDBASE':
    #       print v+" = "+str(env[v])
    #STDOUT.flush()

    # find mil script for MAPI and SQL server
    if THISFILE in ["Mtest.py", "Mprofile.py"]:
        mapi_mil = env['MONET_PREFIX']+path("/lib/MonetDB/mapi.mil")
        if not os.path.isfile(mapi_mil):
            mapi_mil = env['MONET_BUILD']+path("/src/mapi/mapi.mil")
            if not os.path.isfile(mapi_mil):
                mapi_mil = ''
        env['MAPI_MIL'] = mapi_mil
        sqlserver_mil = env['SQL_PREFIX']+path("/lib/MonetDB/sqlserver.mil")
        if not os.path.isfile(sqlserver_mil):
            sqlserver_mil = env['TSTBLDBASE']+path("/src/server/sqlserver.mil")
            if not os.path.isfile(sqlserver_mil):
                sqlserver_mil = ''
        env['SQLSERVER_MIL'] = sqlserver_mil

    # export and display env
    STDERR.flush()
    if THISFILE in ["Mtest.py", "Mprofile.py"]:
        vars_ = vars_ + ['GDK_DBFARM','setMONET_MOD_PATH','MAPI_MIL','SQLSERVER_MIL'] 
    else: # THISFILE == "Mapprove.py"
        vars_ = vars_
    for v in vars_:
        os.environ[v] = env[v]
        print "%s = %s" % (v, env[v])
    STDOUT.flush()

    ## set/extend PATH & LD_LIBRARY_PATH
    #bp = ""        #os.path.join(env['MONET_PREFIX'],"bin")
    #if THISFILE in ["Mtest.py", "Mprofile.py"]:
    #       lp = env['MONET_MOD_PATH']
    #else: # THISFILE == "Mapprove.py"
    #       lp = ""
    #if os.name == "nt"  and  lp:
    #       if bp:
    #               bp = bp+os.pathsep+lp
    #       else:
    #               bp = lp
    #if os.environ.has_key('PATH'):
    #       if bp:
    #               bp = bp+os.pathsep+os.environ['PATH']
    #       else:
    #               bp = os.environ['PATH']
    #os.environ['PATH'] = bp
    #print "PATH = "+bp
    #if os.name == "posix":
    #       if os.environ.has_key('LD_LIBRARY_PATH'):
    #               if lp:
    #                       lp = lp+os.pathsep+os.environ['LD_LIBRARY_PATH']
    #               else:
    #                       lp = os.environ['LD_LIBRARY_PATH']
    #       os.environ['LD_LIBRARY_PATH'] = lp
    #       print "LD_LIBRARY_PATH = "+lp

    if not startswith(os.getcwd()+os.sep, env['TSTSRCBASE']+os.sep):
        Warn("Current directory "+os.getcwd()+" is no descendant of TSTSRCBASE="+env['TSTSRCBASE']+";")
        Warn("changing to TSTSRCBASE="+env['TSTSRCBASE']+", now.")
        os.chdir(env['TSTSRCBASE'])

    # check for executables, set their standard options and export them
    if THISFILE in ["Mtest.py", "Mprofile.py"]:
        exe = {}
        exe['Mtimeout']    = CheckExec('Mtimeout')     , 'Mtimeout -timeout %d ' % par['TIMEOUT']
        exe['Mserver']     = CheckExec('Mserver')      , 'Mserver "--config=%s" --debug=%s %s %s --set monet_prompt= --trace' % (opts.config, env['GDK_DEBUG'], env['setMONET_MOD_PATH'], env['setGDK_DBFARM'])
        exe['Mshutdown']   = CheckExec('Mshutdown.py') , 'Mshutdown.py "--config=%s" --host=%s --port=%s' % (opts.config, HOST, env['MAPIPORT'])
        exe['Mdiff']       = CheckExec('Mdiff')        , 'Mdiff'
        exe['python']      = CheckExec('python')       , 'python'
        exe['Mapi_Client'] = CheckExec(string.split(env['MAPICLIENT'])[0]), '%s "--config=%s" --host=%s --port=%s' % (env['MAPICLIENT'], opts.config, HOST, env['MAPIPORT'])
        exe['SQL_client']  = CheckExec(string.split(env['SQLCLIENT'])[0]) , '%s -u monetdb -P monetdb --host=%s --port=%s' % (env['SQLCLIENT'], HOST, env['SQLPORT'])
        if not exe['Mtimeout'][0]:
            exe['Mtimeout'] = '', ''
        env['exe'] = exe
        SetExecEnv(exe,1)

        #TODO:
        #exe['JAVA']       = 'java'
        #exe['JAVAC']      = 'javac'

    # parse commandline arguments
    testdirs = []
    testlist = []
    dirlist = []
    if   len(args) == 1:
        if   os.path.isdir(args[0]):
            d = os.path.abspath(args[0])
            if startswith(d+os.sep, env['TSTSRCBASE']+os.sep):
                dirlist.append(d)
            #TODO:
            #else:
                # WARNING/ERROR
        elif string.find(args[0], os.sep) != -1:
            ErrXit("'"+args[0]+"` is neither a valid directory in "+os.getcwd()+" nor a valid test-name!")
        elif args[0] != "All":
            #TODO:
            # check, whether args[0] in All
            testlist.append(args[0])
    elif len(args) > 1:
        i = 0
        while i < len(args)  and  os.path.isdir(args[i]):
            d = os.path.abspath(args[i])
            if startswith(d+os.sep, env['TSTSRCBASE']+os.sep):
                dirlist.append(os.path.abspath(args[i]))
            #TODO:
            #else:
                # WARNING/ERROR
            i = i + 1
        if len(dirlist) == 1  and  i < len(args)  and  args[i] != "All":
            while i < len(args):
                if string.find(args[i], os.sep) == -1:
                    #TODO:
                    # check, whether args[i] in All
                    testlist.append(args[i])
                #TODO
                #else:
                    # ERROR/WARNING
                i = i + 1
        else:
            if i < len(args)  and  args[i] == "All":
                i = i + 1
            #TODO:
            #if i < len(args):
                #if len(dirlist) > 1:
                    # Warn: dirlist => ignore testlist, assume All
                #else:
                    # Warn: All => ignore testlist
    if not dirlist:
        dirlist.append(os.getcwd())
    if par['RECURSIVE']:
        #TODO
        #if testlist:
            # WARNING
        testlist = []
        for d in dirlist:
            for t in find_test_dirs(d):
                if t not in testdirs:
                    testdirs.append(t)
    else:
        for d in dirlist:
            if   os.path.basename(d) == TSTSUFF  and  os.path.isfile(os.path.join(d,"All")):
                testdirs.append(os.path.dirname(os.path.abspath(d)))
            elif os.path.isdir(os.path.join(d,TSTSUFF))  and  os.path.isfile(os.path.join(d,TSTSUFF,"All")):
                testdirs.append(os.path.abspath(d))
            else:
                Warn("No tests found in '"+d+"`; skipping directory!")

    if len(testdirs) > 1  and  testlist:
        testlist = []
        #TODO
        # WARNING
    if not testdirs:
        Warn("No tests found in "+str(dirlist)+"!")
        sys.exit(1)

    BusyPorts = []

    if THISFILE in ["Mtest.py", "Mprofile.py"]:

        if os.name == "nt":
            n = os.path.join(THISPATH,"MkillNT.")
            for x in "bat", "py":
                f = n+x
                if os.path.isfile(f):
                    shutil.copy(f,"D:"+os.sep+"Tools")

        if os.path.exists(os.path.join(env['TSTTRGBASE'],TSTPREF)):
            try:
                shutil.rmtree(os.path.join(env['TSTTRGBASE'],TSTPREF))
            except:
                ErrXit("Failed to remove %s" % os.path.join(env['TSTTRGBASE'],TSTPREF))
        if not os.path.exists(env['GDK_DBFARM']):
            #TODO: set mode to umask
            os.makedirs(env['GDK_DBFARM'])

        if os.path.exists(os.path.join(env['GDK_DBFARM'],TSTPREF)):
            try:
                shutil.rmtree(os.path.join(env['GDK_DBFARM'],TSTPREF))
            except:
                ErrXit("Failed to remove %s" % os.path.join(env['GDK_DBFARM'],TSTPREF))
        try:
            os.makedirs(os.path.join(env['GDK_DBFARM'],TSTPREF))
        except:
            ErrXit("Failed to create %s" % os.path.join(env['GDK_DBFARM'],TSTPREF))

        os.makedirs(os.path.join(env['TSTTRGBASE'],TSTPREF))
        if Check('%s%s --dbname=%s' % (env['exe']['Mtimeout'][1], env['exe']['Mserver'][1], TSTPREF), "quit;\n"):
            sys.exit(1)
        GetBitsAndModsAndStatic(env)
        STDERR.flush()
        print "Bits: ", env['TST_BITS']
        print "Modules: ", env['TST_MODS']
        STDOUT.flush()

        host = ''
        for S in 'MAPI', 'SQL':
            port = int(env[S+'PORT'])
            busy, Serrno, Serrstr = CheckPort(host,port)
            if busy:
                Warn("Skipping %s tests as %sPORT=%s is not available (Error #%d: '%s')!" % (S,S,env[S+'PORT'],Serrno,Serrstr))
                BusyPorts.append(S)
        if 'SQL' not in BusyPorts  and  'MAPI' in BusyPorts:
            Warn("Skipping SQL tests as MAPIPORT=%s is not available!" % env['MAPIPORT'])
            BusyPorts.append('SQL')

    STDERR.flush()
    t_ = 0
    if len(testdirs) == 1:
        if testlist:
            tsts = "tests "+str(testlist)
        else:
            tsts = "all tests"
        print "\nRunning %s in directory %s.\n" % (tsts , testdirs[0])
        t_ = PerformDir(env, testdirs[0], testlist, BusyPorts)
    else:
        testdirs.sort()
        print "\nRunning all tests in directories %s.\n" % str(testdirs)
        for d in testdirs:
            t_ = t_ + PerformDir(env, d, [], BusyPorts)

    if THISFILE in ["Mtest.py", "Mprofile.py"]:
        fn = os.path.join(env['TSTTRGBASE'],TSTPREF,"times.")
        fl = open(fn+"lst","w")
        Failure = [0,0,0,0]
        for TSTDIR,TST,tt,Ft in TIMES:
            fl.write(url(os.path.join(TSTDIR,TST))+":\t"+tt+"\n")
            if TST != '':
                Failure[Ft] += 1 
        fl.write(":\t%7.3f\n" % t_)
        fl.close()

    if THISFILE in ["Mtest.py", "Mprofile.py"]:
        env['TSTDIR'] = ""
        env['TSTTRGDIR'] = os.path.join(env['TSTTRGBASE'],TSTPREF)
        CreateHtmlIndex(env)

        test = ( re.compile("^.*<B><I>.*$", re.MULTILINE)
               , re.compile("^.*<B>.*$", re.MULTILINE) )
        Failed = 0
        for f in Failure[1:]:
            Failed += f
        num_tests = 0
        for f in Failure:
            num_tests += f
        how = ""
        what = ""
        if Failure[-1]:
            what += "  %3d out of %3d tests could not be executed\n" % (Failure[-1],num_tests)
        if Failure[1]:
            how = "slightly"
            what += "  %3d out of %3d tests produced %s different output\n" % (Failure[1],num_tests,how)
        if Failure[2]:
            how = "SIGNIFICANTLY"
            what += "  %3d out of %3d tests produced %s different output\n" % (Failure[2],num_tests,how)
        STDERR.flush()
        if Failed:
            print """\

 !ERROR:  Testing FAILED %s ! 

%s
 First, check the testing results in  %s  ! 

 Then, fix the problems by: 
  - fixing sources and test scripts 
  - fixing stable output by hand 
  - approving test output by Mapprove.py (cf. Mapprove.py -?) 

 After that, re-run Mtest. 
""" % (how, what, os.path.join(env['TSTTRGBASE'],TSTPREF,"index.html"))
            sys.exit(1)
        else:
            print """\

 No differences encountered during testing. 

 If necessary, you can checkin your modifications, now. 
"""
            sys.exit(0)

    if THISFILE == "Mapprove.py":
        print """\

 First, run 'cvs -q diff` to check what you have changed.

 Then, re-run Mtest.py.
"""
        if t_:
            if par['FORCE']:
                print """\
 In case (some of) the approved error messages are not correct/expected,
 re-run Mapprove.py without -f to skip their approval.
"""
            else:
                print """\
 In case (some of) the skipped error messages are correct/expected,
 re-run Mapprove.py with -f to force their approval.
"""
### main(argv) #

if __name__ == "__main__":
    if '--trace' in sys.argv:
        sys.argv.remove('--trace')
        import trace
        t = trace.Trace(trace=1, count=0)
        t.runfunc(main, sys.argv)
    else:
        main(sys.argv)

#       END
#############################################################################
