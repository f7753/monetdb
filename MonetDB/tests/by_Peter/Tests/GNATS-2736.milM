# the following implementation paths in the standard pump implementation exist:
#
# proc_sorted
# proc_hash
# packed_sorted
# packed_hash
# direct_sorted_chr
# direct_sorted_sht
# direct_sorted_int
# direct_sorted_void
# direct_hash_chr
# direct_hash_sht
# direct_hash_int
# direct_idx_chr
# direct_idx_sht
# direct_idx_int
#
# this script intends to test them all.
module(aggr);

b_int := bat(int,str).insert(1,"1").insert(2,"2").insert(1,"1");
b_int.insert(3,"3").insert(4,"4").insert(5,"5").insert(6,"6");
b_int.insert(3,"3").insert(4,"4").insert(5,"5").insert(6,"6");
b_sht := [sht](b_int.reverse).reverse;
b_chr := [chr](b_int.reverse).reverse;
b_str := [str](b_int.reverse).reverse;
v_oid := bat(void,str).insert(nil,"1").insert(nil,"2").insert(nil,"3");
v_oid.insert(nil,"4").insert(nil,"5").insert(nil,"6").seqbase(1@0);

e_int := bat(int,void).insert(1,nil).insert(3,nil).insert(4,nil).insert(5,nil);
e_int.insert(6,nil).insert(7,nil).insert(8,nil).col_name("e_int");
e_sht := [sht](e_int.reverse).reverse.col_name("e_sht");
e_chr := [chr](e_int.reverse).reverse.col_name("e_chr");
e_str := [str](e_int.reverse).reverse.col_name("e_str");
e_oid := [oid](e_int.reverse).reverse.col_name("e_oid");


tests := bat(bat,bat);
tests.insert(b_int.col_name("b_int"), e_int);
tests.insert(b_sht.col_name("b_sht"), e_sht);
tests.insert(b_chr.col_name("b_chr"), e_chr);
tests.insert(b_str.col_name("b_str"), e_str);
tests.insert(v_oid.col_name("v_oid"), e_oid);

tests.insert(b_int.sort.col_name("s_int"), e_int);
tests.insert(b_sht.sort.col_name("s_sht"), e_sht);
tests.insert(b_chr.sort.col_name("s_chr"), e_chr);
tests.insert(b_str.sort.col_name("s_str"), e_str);

proc idx(bat[any,any] b) {
	b.accbuild(index);
	return b;
}

tests.insert(b_int.copy.idx.col_name("i_int"), e_int);
tests.insert(b_sht.copy.idx.col_name("i_sht"), e_sht);
tests.insert(b_chr.copy.idx.col_name("i_chr"), e_chr);
tests.insert(b_str.copy.idx.col_name("i_str"), e_str);

proc ku(bat[any,any] b) : bat[any,any] {
	return kunique(b);
}

proc mstr(int i) : str {
	if (isnil(i)) return "nil";
	return str(i);
}

proc mset_print(bat[any,bat] m) {
    m@batloop() {
        var h := $h;
        var t := $t;
        t@batloop() {
            printf("\t%s\t%s\n", mstr(int(h)), mstr(int($t)));
        }
    }
}

proc set_print(bat[any,any] b) {
    b@batloop() {
        printf("\t%s\t%s\n", mstr(int($h)), mstr(int($t)));
    }
}

# start testing, switch mask that tells us which implementation is actually used
debugmask(131072);

tests@batloop() {
	printf("\n# test proc {kunique}(%s)\n", $h.bbpname);
	{ku}($h).mset_print;
}

tests@batloop() {
	printf("\n# test proc {kunique}(%s,%s)\n", $h.bbpname, $t.bbpname);
	{ku}($h,$t).mset_print;
}

tests@batloop() {
	printf("\n# test packed {kunique}(%s)\n", $h.bbpname);
	{kunique}($h).mset_print;
}

tests@batloop() {
	printf("\n# test packed {max}(%s,%s)\n", $h.bbpname, $t.bbpname);
	{max}($h,$t).set_print;
}

tests@batloop() {
	printf("\n# test direct {max}(%s)\n", $h.bbpname);
	{max}([int]($h)).set_print;
}

tests@batloop() {
	printf("\n# test direct {max}(%s,%s)\n", $h.bbpname, $t.bbpname);
	{max}([int]($h),$t).set_print;
}

quit;
