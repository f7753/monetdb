stdout of test 'GNATS-2736` in directory 'tests/by_Peter` itself:

#> Mtest:	milM GNATS-2736 milM
#> Mtest:	Mtimeout -timeout 600 Mserver -modulesilent -yaccsilent -d8 -db tests_by_Peter GNATS-2736.milM
# Monet Database Server V4.1
# Copyright (c) 1993-1999, CWI & SION. All rights reserved.
# compiled for Linux2.2.12-20smp/32bit on Mon May 22 05:44:53 CEST 2000.
#script:GNATS-2736.milM

# 17:08:31 >  
# 17:08:31 >  Mtimeout -timeout 60 Mserver "--config=/var/tmp/MonetDB/_PREFIX_d_/etc/monet.conf" --debug=10 --set "monet_mod_path=/var/tmp/MonetDB/_PREFIX_d_/lib/MonetDB" --dbfarm "/var/tmp/MonetDB/_PREFIX_d_/var/dbfarm" --set monet_prompt= /ufs/manegold/tmp/Tests-d10/Tests/trace.mil --dbname=Tests_tests_by_Peter  < GNATS-2736.milM
# 17:08:31 >  

# Monet Database Server V4.3.5
# Copyright (c) 1993-2002, CWI. All rights reserved.
# compiled for i686-pc-linux-gnu/32bit; dynamically linked.
# the following implementation paths in the standard pump implementation exist:
#
# proc_sorted
# proc_hash
# packed_sorted
# packed_hash
# direct_sorted_chr
# direct_sorted_sht
# direct_sorted_int
# direct_sorted_void
# direct_hash_chr
# direct_hash_sht
# direct_hash_int
# direct_idx_chr
# direct_idx_sht
# direct_idx_int
#
# this script intends to test them all.
module(aggr);

b_int := bat(int,str).insert(1,"1").insert(2,"2").insert(1,"1");
b_int.insert(3,"3").insert(4,"4").insert(5,"5").insert(6,"6");
b_int.insert(3,"3").insert(4,"4").insert(5,"5").insert(6,"6");
b_sht := [sht](b_int.reverse).reverse;
b_chr := [chr](b_int.reverse).reverse;
b_str := [str](b_int.reverse).reverse;
v_oid := bat(void,str).insert(nil,"1").insert(nil,"2").insert(nil,"3");
v_oid.insert(nil,"4").insert(nil,"5").insert(nil,"6").seqbase(1@0);

e_int := bat(int,void).insert(1,nil).insert(3,nil).insert(4,nil).insert(5,nil);
e_int.insert(6,nil).insert(7,nil).insert(8,nil).col_name("e_int");
e_sht := [sht](e_int.reverse).reverse.col_name("e_sht");
e_chr := [chr](e_int.reverse).reverse.col_name("e_chr");
e_str := [str](e_int.reverse).reverse.col_name("e_str");
e_oid := [oid](e_int.reverse).reverse.col_name("e_oid");


tests := bat(bat,bat);
tests.insert(b_int.col_name("b_int"), e_int);
tests.insert(b_sht.col_name("b_sht"), e_sht);
tests.insert(b_chr.col_name("b_chr"), e_chr);
tests.insert(b_str.col_name("b_str"), e_str);
tests.insert(v_oid.col_name("v_oid"), e_oid);

tests.insert(b_int.sort.col_name("s_int"), e_int);
tests.insert(b_sht.sort.col_name("s_sht"), e_sht);
tests.insert(b_chr.sort.col_name("s_chr"), e_chr);
tests.insert(b_str.sort.col_name("s_str"), e_str);

proc idx(bat[any,any] b) {
	b.accbuild(index);
	return b;
}

tests.insert(b_int.copy.idx.col_name("i_int"), e_int);
tests.insert(b_sht.copy.idx.col_name("i_sht"), e_sht);
tests.insert(b_chr.copy.idx.col_name("i_chr"), e_chr);
tests.insert(b_str.copy.idx.col_name("i_str"), e_str);

proc ku(bat[any,any] b) : bat[any,any] {
	return kunique(b);
}

proc mstr(int i) : str {
	if (isnil(i)) return "nil";
	return str(i);
}

proc mset_print(bat[any,bat] m) {
    m@batloop() {
        var h := $h;
        var t := $t;
        t@batloop() {
            printf("\t%s\t%s\n", mstr(int(h)), mstr(int($t)));
        }
    }
}

proc set_print(bat[any,any] b) {
    b@batloop() {
        printf("\t%s\t%s\n", mstr(int($h)), mstr(int($t)));
    }
}

# start testing, switch mask that tells us which implementation is actually used
debugmask(131072);

tests@batloop() {
	printf("\n# test proc {kunique}(%s)\n", $h.bbpname);
	{ku}($h).mset_print;
}

# test proc {kunique}(b_int)
#setaggr impl: non-optimized hash
	1	1
	2	2
	3	3
	4	4
	5	5
	6	6

# test proc {kunique}(b_sht)
#setaggr impl: non-optimized hash
	1	1
	2	2
	3	3
	4	4
	5	5
	6	6

# test proc {kunique}(b_chr)
#setaggr impl: non-optimized hash
	1	1
	2	2
	3	3
	4	4
	5	5
	6	6

# test proc {kunique}(b_str)
#setaggr impl: non-optimized hash
	1	1
	2	2
	3	3
	4	4
	5	5
	6	6

# test proc {kunique}(v_oid)
#setaggr impl: non-optimized sort
	1	1
	2	2
	3	3
	4	4
	5	5
	6	6

# test proc {kunique}(s_int)
#setaggr impl: non-optimized sort
	1	1
	2	2
	3	3
	4	4
	5	5
	6	6

# test proc {kunique}(s_sht)
#setaggr impl: non-optimized sort
	1	1
	2	2
	3	3
	4	4
	5	5
	6	6

# test proc {kunique}(s_chr)
#setaggr impl: non-optimized sort
	1	1
	2	2
	3	3
	4	4
	5	5
	6	6

# test proc {kunique}(s_str)
#setaggr impl: non-optimized sort
	1	1
	2	2
	3	3
	4	4
	5	5
	6	6

# test proc {kunique}(i_int)
#setaggr impl: non-optimized hash
	1	1
	2	2
	3	3
	4	4
	5	5
	6	6

# test proc {kunique}(i_sht)
#setaggr impl: non-optimized hash
	1	1
	2	2
	3	3
	4	4
	5	5
	6	6

# test proc {kunique}(i_chr)
#setaggr impl: non-optimized hash
	1	1
	2	2
	3	3
	4	4
	5	5
	6	6

# test proc {kunique}(i_str)
#setaggr impl: non-optimized hash
	1	1
	2	2
	3	3
	4	4
	5	5
	6	6

tests@batloop() {
	printf("\n# test proc {kunique}(%s,%s)\n", $h.bbpname, $t.bbpname);
	{ku}($h,$t).mset_print;
}

# test proc {kunique}(b_int,e_int)
#setaggr impl: non-optimized hash
	1	1
	3	3
	4	4
	5	5
	6	6

# test proc {kunique}(b_sht,e_sht)
#setaggr impl: non-optimized hash
	1	1
	3	3
	4	4
	5	5
	6	6

# test proc {kunique}(b_chr,e_chr)
#setaggr impl: non-optimized hash
	1	1
	3	3
	4	4
	5	5
	6	6

# test proc {kunique}(b_str,e_str)
#setaggr impl: non-optimized hash
	1	1
	3	3
	4	4
	5	5
	6	6

# test proc {kunique}(v_oid,e_oid)
#setaggr impl: non-optimized sort
	1	1
	3	3
	4	4
	5	5
	6	6

# test proc {kunique}(s_int,e_int)
#setaggr impl: non-optimized sort
	1	1
	3	3
	4	4
	5	5
	6	6

# test proc {kunique}(s_sht,e_sht)
#setaggr impl: non-optimized sort
	1	1
	3	3
	4	4
	5	5
	6	6

# test proc {kunique}(s_chr,e_chr)
#setaggr impl: non-optimized sort
	1	1
	3	3
	4	4
	5	5
	6	6

# test proc {kunique}(s_str,e_str)
#setaggr impl: non-optimized sort
	1	1
	3	3
	4	4
	5	5
	6	6

# test proc {kunique}(i_int,e_int)
#setaggr impl: non-optimized hash
	1	1
	3	3
	4	4
	5	5
	6	6

# test proc {kunique}(i_sht,e_sht)
#setaggr impl: non-optimized hash
	1	1
	3	3
	4	4
	5	5
	6	6

# test proc {kunique}(i_chr,e_chr)
#setaggr impl: non-optimized hash
	1	1
	3	3
	4	4
	5	5
	6	6

# test proc {kunique}(i_str,e_str)
#setaggr impl: non-optimized hash
	1	1
	3	3
	4	4
	5	5
	6	6

tests@batloop() {
	printf("\n# test packed {kunique}(%s)\n", $h.bbpname);
	{kunique}($h).mset_print;
}

# test packed {kunique}(b_int)
#setaggr impl: non-optimized hash
	1	1
	2	2
	3	3
	4	4
	5	5
	6	6

# test packed {kunique}(b_sht)
#setaggr impl: non-optimized hash
	1	1
	2	2
	3	3
	4	4
	5	5
	6	6

# test packed {kunique}(b_chr)
#setaggr impl: non-optimized hash
	1	1
	2	2
	3	3
	4	4
	5	5
	6	6

# test packed {kunique}(b_str)
#setaggr impl: non-optimized hash
	1	1
	2	2
	3	3
	4	4
	5	5
	6	6

# test packed {kunique}(v_oid)
#setaggr impl: non-optimized sort
	1	1
	2	2
	3	3
	4	4
	5	5
	6	6

# test packed {kunique}(s_int)
#setaggr impl: non-optimized sort
	1	1
	2	2
	3	3
	4	4
	5	5
	6	6

# test packed {kunique}(s_sht)
#setaggr impl: non-optimized sort
	1	1
	2	2
	3	3
	4	4
	5	5
	6	6

# test packed {kunique}(s_chr)
#setaggr impl: non-optimized sort
	1	1
	2	2
	3	3
	4	4
	5	5
	6	6

# test packed {kunique}(s_str)
#setaggr impl: non-optimized sort
	1	1
	2	2
	3	3
	4	4
	5	5
	6	6

# test packed {kunique}(i_int)
#setaggr impl: non-optimized hash
	1	1
	2	2
	3	3
	4	4
	5	5
	6	6

# test packed {kunique}(i_sht)
#setaggr impl: non-optimized hash
	1	1
	2	2
	3	3
	4	4
	5	5
	6	6

# test packed {kunique}(i_chr)
#setaggr impl: non-optimized hash
	1	1
	2	2
	3	3
	4	4
	5	5
	6	6

# test packed {kunique}(i_str)
#setaggr impl: non-optimized hash
	1	1
	2	2
	3	3
	4	4
	5	5
	6	6

tests@batloop() {
	printf("\n# test packed {max}(%s,%s)\n", $h.bbpname, $t.bbpname);
	{max}($h,$t).set_print;
}

# test packed {max}(b_int,e_int)
#setaggr impl: non-optimized hash
	1	1
	3	3
	4	4
	5	5
	6	6
	7	nil
	8	nil

# test packed {max}(b_sht,e_sht)
#setaggr impl: non-optimized hash
	1	1
	3	3
	4	4
	5	5
	6	6
	7	nil
	8	nil

# test packed {max}(b_chr,e_chr)
#setaggr impl: non-optimized hash
	1	1
	3	3
	4	4
	5	5
	6	6
	7	nil
	8	nil

# test packed {max}(b_str,e_str)
#setaggr impl: non-optimized hash
	1	1
	3	3
	4	4
	5	5
	6	6
	7	nil
	8	nil

# test packed {max}(v_oid,e_oid)
#setaggr impl: non-optimized sort
	1	1
	3	3
	4	4
	5	5
	6	6
	7	nil
	8	nil

# test packed {max}(s_int,e_int)
#setaggr impl: non-optimized sort
	1	1
	3	3
	4	4
	5	5
	6	6
	7	nil
	8	nil

# test packed {max}(s_sht,e_sht)
#setaggr impl: non-optimized sort
	1	1
	3	3
	4	4
	5	5
	6	6
	7	nil
	8	nil

# test packed {max}(s_chr,e_chr)
#setaggr impl: non-optimized sort
	1	1
	3	3
	4	4
	5	5
	6	6
	7	nil
	8	nil

# test packed {max}(s_str,e_str)
#setaggr impl: non-optimized sort
	1	1
	3	3
	4	4
	5	5
	6	6
	7	nil
	8	nil

# test packed {max}(i_int,e_int)
#setaggr impl: non-optimized hash
	1	1
	3	3
	4	4
	5	5
	6	6
	7	nil
	8	nil

# test packed {max}(i_sht,e_sht)
#setaggr impl: non-optimized hash
	1	1
	3	3
	4	4
	5	5
	6	6
	7	nil
	8	nil

# test packed {max}(i_chr,e_chr)
#setaggr impl: non-optimized hash
	1	1
	3	3
	4	4
	5	5
	6	6
	7	nil
	8	nil

# test packed {max}(i_str,e_str)
#setaggr impl: non-optimized hash
	1	1
	3	3
	4	4
	5	5
	6	6
	7	nil
	8	nil

tests@batloop() {
	printf("\n# test direct {max}(%s)\n", $h.bbpname);
	{max}([int]($h)).set_print;
}

# test direct {max}(b_int)
#setaggr impl: int-optimized loop
	1	1
	2	2
	3	3
	4	4
	5	5
	6	6

# test direct {max}(b_sht)
#setaggr impl: sht-optimized loop
	1	1
	2	2
	3	3
	4	4
	5	5
	6	6

# test direct {max}(b_chr)
#setaggr impl: chr-optimized loop
	1	1
	2	2
	3	3
	4	4
	5	5
	6	6

# test direct {max}(b_str)
#setaggr impl: non-optimized hash
	1	1
	2	2
	3	3
	4	4
	5	5
	6	6

# test direct {max}(v_oid)
#setaggr impl: void-optimized sort
	1	1
	2	2
	3	3
	4	4
	5	5
	6	6

# test direct {max}(s_int)
#setaggr impl: int-optimized sort
	1	1
	2	2
	3	3
	4	4
	5	5
	6	6

# test direct {max}(s_sht)
#setaggr impl: sht-optimized sort
	1	1
	2	2
	3	3
	4	4
	5	5
	6	6

# test direct {max}(s_chr)
#setaggr impl: chr-optimized sort
	1	1
	2	2
	3	3
	4	4
	5	5
	6	6

# test direct {max}(s_str)
#setaggr impl: non-optimized sort
	1	1
	2	2
	3	3
	4	4
	5	5
	6	6

# test direct {max}(i_int)
#setaggr impl: int-optimized loop
	1	1
	2	2
	3	3
	4	4
	5	5
	6	6

# test direct {max}(i_sht)
#setaggr impl: sht-optimized loop
	1	1
	2	2
	3	3
	4	4
	5	5
	6	6

# test direct {max}(i_chr)
#setaggr impl: chr-optimized loop
	1	1
	2	2
	3	3
	4	4
	5	5
	6	6

# test direct {max}(i_str)
#setaggr impl: non-optimized hash
	1	1
	2	2
	3	3
	4	4
	5	5
	6	6

tests@batloop() {
	printf("\n# test direct {max}(%s,%s)\n", $h.bbpname, $t.bbpname);
	{max}([int]($h),$t).set_print;
}

# test direct {max}(b_int,e_int)
#setaggr impl: int-optimized hash
	1	1
	3	3
	4	4
	5	5
	6	6
	7	nil
	8	nil

# test direct {max}(b_sht,e_sht)
#setaggr impl: sht-optimized hash
	1	1
	3	3
	4	4
	5	5
	6	6
	7	nil
	8	nil

# test direct {max}(b_chr,e_chr)
#setaggr impl: chr-optimized hash
	1	1
	3	3
	4	4
	5	5
	6	6
	7	nil
	8	nil

# test direct {max}(b_str,e_str)
#setaggr impl: non-optimized hash
	1	1
	3	3
	4	4
	5	5
	6	6
	7	nil
	8	nil

# test direct {max}(v_oid,e_oid)
#setaggr impl: void-optimized sort
	1	1
	3	3
	4	4
	5	5
	6	6
	7	nil
	8	nil

# test direct {max}(s_int,e_int)
#setaggr impl: int-optimized sort
	1	1
	3	3
	4	4
	5	5
	6	6
	7	nil
	8	nil

# test direct {max}(s_sht,e_sht)
#setaggr impl: sht-optimized sort
	1	1
	3	3
	4	4
	5	5
	6	6
	7	nil
	8	nil

# test direct {max}(s_chr,e_chr)
#setaggr impl: chr-optimized sort
	1	1
	3	3
	4	4
	5	5
	6	6
	7	nil
	8	nil

# test direct {max}(s_str,e_str)
#setaggr impl: non-optimized sort
	1	1
	3	3
	4	4
	5	5
	6	6
	7	nil
	8	nil

# test direct {max}(i_int,e_int)
#setaggr impl: int-optimized hash
	1	1
	3	3
	4	4
	5	5
	6	6
	7	nil
	8	nil

# test direct {max}(i_sht,e_sht)
#setaggr impl: sht-optimized hash
	1	1
	3	3
	4	4
	5	5
	6	6
	7	nil
	8	nil

# test direct {max}(i_chr,e_chr)
#setaggr impl: chr-optimized hash
	1	1
	3	3
	4	4
	5	5
	6	6
	7	nil
	8	nil

# test direct {max}(i_str,e_str)
#setaggr impl: non-optimized hash
	1	1
	3	3
	4	4
	5	5
	6	6
	7	nil
	8	nil

quit;

# 17:08:32 >  
# 17:08:32 >  Done.
# 17:08:32 >  

