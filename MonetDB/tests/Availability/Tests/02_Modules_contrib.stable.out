stdout of test '02_Modules_contrib` in directory 'tests/Availability` itself:


# 15:30:10 >  
# 15:30:10 >  Mtimeout -timeout 60 Mserver "--config=/ufs/boncz/MonetDB/linux/etc/monet.conf" --debug=10 --set "monet_mod_path=/ufs/boncz/MonetDB/linux/lib/MonetDB" --set "gdk_dbfarm=/ufs/boncz/MonetDB/linux/var/MonetDB/dbfarm" --set "sql_logdir=/ufs/boncz/MonetDB/linux/var/MonetDB/log" --set mapi_port=55437 --set sql_port=50559 --set monet_prompt= --trace --dbname=mTests_tests_Availability  < 02_Modules_contrib.milS
# 15:30:10 >  

# Monet Database Server V4.3.13
# Copyright (c) 1993-2003, CWI. All rights reserved.
# compiled for i686-pc-linux-gnu/32bit; dynamically linked.
setoid(oid(20000000));

Static_fcn:=monet_fcntbl.reverse.copy;

Fname:=new(oid,str);Fname.col_name("function");
FnameS:=new(oid,str);FnameS.col_name("function");
Ftype:=new(oid,str);Ftype.col_name("type");
Fsig:=new(oid,str);Fsig.col_name("signature");
Fhelp:=new(oid,str);Fhelp.col_name("help");
Fnts:=new(oid,str);

Plain_mods:=MODULES.select("contrib").sort.copy;
table(Plain_mods.reverse.col_name(sprintf("%i modules",Plain_mods.count)));
#-----------------#
# 13 modules	  #
#-----------------#
[ "bitset"	  ]
[ "bitvector"	  ]
[ "cluster"	  ]
[ "ddbench"	  ]
[ "iterator"	  ]
[ "malalgebra"	  ]
[ "mel"		  ]
[ "mprof"	  ]
[ "oo7"		  ]
[ "qt"		  ]
[ "tpcd"	  ]
[ "vector"	  ]
[ "wisc"	  ]
Plain_mods@batloop {
	The_mod:=$h;
	printf("\nModule: \"%s\"\n\n",The_mod);
	module($h);

	Mod_fcn:=sdiff(monet_fcntbl.reverse,Static_fcn).reverse;
	Mod_fcn.sort@batloop {
	    addThis:=false;
	    if (not(monet_fcn_mid.exist($t))) {
		addThis:=true;
	    } else {
		m:=monet_mod_nme.find(monet_fcn_mid.find($t));
		if (m.startsWith("_")) {
		    m:=string(m,1);
		}
		if (m = The_mod) {
		    addThis:=true;
		}
	    }
	    if (addThis) {
		Tname:=$h;
		Ttype:=help_tpe(monet_fcn_tpe.find($t));
		Tsig:=format_fcn_sig($t);
		Thelp:="";
		if (monet_fcn_dsc.exist($t)) {
			Thelp:=monet_fcn_dsc.find($t);
		} else {
			Thelp:="not available";
		}
		Fname.insert($t,Tname);
		Ftype.insert($t,Ttype);
		Fsig.insert($t,Tsig);
		Fhelp.insert($t,Thelp);
		Fnts.insert($t,sprintf("%s %s %s",Tname,Ttype,Tsig));
	    }
	}

	drop($h);
	Static_fcn:=sunion(Static_fcn,monet_fcntbl.reverse);

	Fnts.count.print;
	Fnts.reverse.sort.reverse@batloop {
		FnameS.insert($h,Fname.find($h));
	}
	FnameS.count.print; table(1,FnameS,Ftype,Fsig,Fhelp);

	Fname.delete;
	FnameS.delete;
	Ftype.delete;
	Fsig.delete;
	Fhelp.delete;
	Fnts.delete;
}

Module: "bitset"

[ 13 ]
[ 13 ]
#-------------------------------------------------------------------------------------------------------------------------------------------------#
# function		| type		| signature					| help							  #
#-------------------------------------------------------------------------------------------------------------------------------------------------#
[ "bitset_and",		  "COMMAND:   ",  "bitset_and(bitset, bitset) : bitset",	  "AND this BitSet with an other BitSet."		  ]
[ "bitset_clearBit",	  "COMMAND:   ",  "bitset_clearBit(bitset, int) : bitset",	  "Clear the specified bit in this BitSet."		  ]
[ "bitset_flipBit",	  "COMMAND:   ",  "bitset_flipBit(bitset, int) : bitset",	  "Flip the specified bit in this BitSet."		  ]
[ "bitset_getBit",	  "COMMAND:   ",  "bitset_getBit(bitset, int) : bit",		  "Get the specified bit from this BitSet."		  ]
[ "bitset_not",		  "COMMAND:   ",  "bitset_not(bitset) : bitset",		  "NOT this BitSet."					  ]
[ "bitset_or",		  "COMMAND:   ",  "bitset_or(bitset, bitset) : bitset",		  "OR this BitSet with an other BitSet."		  ]
[ "bitset_setBit",	  "COMMAND:   ",  "bitset_setBit(bitset, int) : bitset",	  "Set the specified bit from this BitSet."		  ]
[ "bitset_toInt",	  "COMMAND:   ",  "bitset_toInt(bitset) : int",			  "Convert this BitSet to an integer."			  ]
[ "bitset_toStr",	  "PROC:      ",  "bitset_toStr(any) : any",			  "not available"					  ]
[ "bitset_xor",		  "COMMAND:   ",  "bitset_xor(bitset, bitset) : bitset",	  "XOR this BitSet with an other BitSet."		  ]
[ "newBitset",		  "COMMAND:   ",  "newBitset() : bitset",			  "Create a new empty BitSet."				  ]
[ "newBitset",		  "COMMAND:   ",  "newBitset(int) : bitset",			  "Create a new BitSet from an existing integer."	  ]
[ "test_bitset",	  "PROC:      ",  "test_bitset() : void",			  "not available"					  ]

Module: "bitvector"

[ 12 ]
[ 12 ]
#---------------------------------------------------------------------------------------------------------------------------------------------------------#
# function		| type		| signature						| help							  #
#---------------------------------------------------------------------------------------------------------------------------------------------------------#
[ "[allocate]",		  "COMMAND:   ",  "[allocate](int, bit) : BAT[void,lng]",		  "Allocate a new and empty bitvector"			  ]
[ "[and]",		  "COMMAND:   ",  "[and](BAT[void,lng], BAT[void,lng]) : BAT[void,lng]",  "Logically ANDs two bitvectors"			  ]
[ "[clr]",		  "COMMAND:   ",  "[clr](BAT[any::1,lng], int) : void",			  "Clear a bit in a bitvector"				  ]
[ "[count]",		  "COMMAND:   ",  "[count](BAT[void,lng]) : int",			  "Count the number of bits set"			  ]
[ "[decode]",		  "COMMAND:   ",  "[decode](BAT[void,lng]) : BAT[oid,oid]",		  "Decodes a bitvector into a real BAT"			  ]
[ "[encode]",		  "COMMAND:   ",  "[encode](BAT[any::1,oid]) : BAT[void,lng]",		  "Encode a BAT with tail values into a bitvector"	  ]
[ "[isclr]",		  "COMMAND:   ",  "[isclr](BAT[any::1,lng], int) : bit",		  "Is bit bnum not set?"				  ]
[ "[isset]",		  "COMMAND:   ",  "[isset](BAT[any::1,lng], int) : bit",		  "Is bit bnum set?"					  ]
[ "[or]",		  "COMMAND:   ",  "[or](BAT[void,lng], BAT[void,lng]) : BAT[void,lng]",	  "Logically ORs two bitvectors"			  ]
[ "[prt]",		  "COMMAND:   ",  "[prt](BAT[void,lng]) : void",			  "Print a bitvector"					  ]
[ "[set]",		  "COMMAND:   ",  "[set](BAT[any::1,lng], int) : void",			  "Set a bit in a bitvector"				  ]
[ "test_bitvector",	  "PROC:      ",  "test_bitvector() : void",				  "not available"					  ]

Module: "cluster"

[ 3 ]
[ 3 ]
#-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------#
# function		| type		| signature						| help																																																																																  #
#-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------#
[ "acccluster",		  "COMMAND:   ",  "acccluster(BAT[any,any], int) : void",		  "Call the accelerator-specific cluster function to rearrange the\n cause less page faults."																																																																					  ]
[ "heapclustercopy",	  "COMMAND:   ",  "heapclustercopy(BAT[any,any], BAT[any,any]) : void",	  "Rearrange the *tail* atoms -- that are supposed to of a variable sized\n typle like 'str' -- in the tail heap of the first BAT. They are put in\n order of appearance of the head elements of the second BAT. That is,\n for each head element from the second BAT we look up the appearance of\n this head element in the first BAT, and re-insert the corresponding tail\n element.\n WARNING: the second BAT *must* be a superset of the first, otherwise\n tuples will be lost!\n WARNING: you better work with head-unique BAts for this, otherwise\n the semantics are very vague.\n NOTE: the two BATs may be equal, in which case lookup is trivial."  ]
[ "order",		  "COMMAND:   ",  "order(BAT[any::1,any::2], int) : BAT[any::1,any::2]",  "Fast order() on BATs that exceed main-memory, using partitioning. Returns b."																																																																						  ]

Module: "ddbench"

[ 57 ]
[ 57 ]
#---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------#
# function		| type		| signature										| help																																													  #
#---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------#
[ "CTorderby",		  "PROC:      ",  "CTorderby(BAT[oid,any], BAT[oid,any]) : BAT[oid,oid]",				  "not available"																																											  ]
[ "CTorderby_rev",	  "PROC:      ",  "CTorderby_rev(BAT[oid,any], BAT[oid,any]) : BAT[oid,oid]",				  "not available"																																											  ]
[ "CTsubgroup",		  "PROC:      ",  "CTsubgroup(BAT[oid,oid], BAT[oid,any], BAT[oid,any]) : BAT[oid,oid]",		  "not available"																																											  ]
[ "enum_group",		  "COMMAND:   ",  "enum_group(BAT[void,any], BAT[void,any]) : BAT[void,any]",				  "optimized group: use a byte-array[card(ct)*card(b)] instead of a hash\n\t           table and directly create enumerated group oid-s"																												  ]
[ "enum_join",		  "COMMAND:   ",  "enum_join(BAT[any::1,void], BAT[any,any::2]) : BAT[any::1,any::2]",			  "positional join if the b2 head type is an enumerated oid"																																						  ]
[ "enum_semijoin",	  "COMMAND:   ",  "enum_semijoin(BAT[void,any::1], BAT[any,any]) : BAT[oid,any::1]",			  "positional semijoin if the b2 head type is an enumerated oid"																																					  ]
[ "enum_view",		  "COMMAND:   ",  "enum_view(BAT[void,any]) : BAT[oid,int]",						  "produces a histogram that is an adaptation of the enum-lookup table\n  of the tail of b. Its head column differs: it contains oids; namely \n  the first oid of 'b' where the original lookup head value occured\n  in the tail of 'b'. In other words :-), this produces the lookup\n  table needed to create an 'enumeration view' that represents CTgroup(b)."	  ]
[ "fclose",		  "PROC:      ",  "fclose(Stream) : void",								  "not available"																																											  ]
[ "fflush",		  "PROC:      ",  "fflush(Stream) : void",								  "not available"																																											  ]
[ "fopen",		  "PROC:      ",  "fopen(str, str) : Stream",								  "not available"																																											  ]
[ "fputs",		  "PROC:      ",  "fputs(str, Stream) : void",								  "not available"																																											  ]
[ "group",		  "PROC:      ",  "group(BAT[oid,any]) : BAT[oid,oid]",							  "not available"																																											  ]
[ "group",		  "PROC:      ",  "group(BAT[oid,any], BAT[oid,any]) : BAT[oid,any]",					  "not available"																																											  ]
[ "group",		  "PROC:      ",  "group(BAT[void,any]) : BAT[oid,oid]",						  "not available"																																											  ]
[ "group",		  "PROC:      ",  "group(BAT[void,any], BAT[void,any]) : BAT[oid,any]",					  "not available"																																											  ]
[ "kintersect",		  "COMMAND:   ",  "kintersect(BAT[oid,any::1], BAT[void,bit32]) : BAT[oid,any::1]",			  "do b.semijoin(sel.tobat); b must be dense and sel must correspond to it.\n"																																				  ]
[ "mjoin",		  "PROC:      ",  "mjoin(BAT[any::1,any::3], BAT[any::3,any::2]) : BAT[any::1,any::2]",			  "not available"																																											  ]
[ "mjoin",		  "PROC:      ",  "mjoin(BAT[any::1,any], BAT[void,any::2]) : BAT[any::1,any::2]",			  "not available"																																											  ]
[ "mjoin",		  "PROC:      ",  "mjoin(BAT[any::1,void], BAT[any,any::2]) : BAT[any::1,any::2]",			  "not available"																																											  ]
[ "not",		  "PROC:      ",  "not(BAT[void,bit32]) : BAT[void,bit32]",						  "not available"																																											  ]
[ "orderby_table",	  "PROC:      ",  "orderby_table(str, str, ..BAT[any::1,any]..) : any",					  "not available"																																											  ]
[ "print",		  "PROC:      ",  "print(str, BAT[any::1,any], ..BAT[any::1,any]..) : any",				  "not available"																																											  ]
[ "refine",		  "COMMAND:   ",  "refine(BAT[oid,void], BAT[oid,any::1], any::1) : BAT[oid,void]",			  "like val_oidsubsel(sel,b,v), but *OVERWRITES* sel with result."																																					  ]
[ "refine",		  "COMMAND:   ",  "refine(BAT[oid,void], BAT[oid,any::1], any::1, any::1) : BAT[oid,void]",		  "like rng_oidsubsel(sel,b,lo,hi), but *OVERWRITES* sel with result."																																					  ]
[ "refine",		  "COMMAND:   ",  "refine(BAT[void,bit32], BAT[oid,any::1], any::1) : BAT[void,bit32]",			  "like val_bitsubsel(sel,b,v), but *OVERWRITES* sel with result."																																					  ]
[ "refine",		  "COMMAND:   ",  "refine(BAT[void,bit32], BAT[oid,any::1], any::1, any::1) : BAT[void,bit32]",		  "like rng_bitsubsel(sel,b,lo,hi), but *OVERWRITES* sel with result."																																					  ]
[ "rng_bitselect",	  "COMMAND:   ",  "rng_bitselect(BAT[oid,any::1], any::1, any::1) : BAT[void,bit32]",			  "do a range-scan rangeselect, but output the result as a bitmask, partitioned\n  in 32-bits integers. "																																  ]
[ "rng_oidselect",	  "COMMAND:   ",  "rng_oidselect(BAT[oid,any::1], any::1, any::1) : BAT[void,oid]",			  "uselect, optimized for enumeration types"																																								  ]
[ "rngs_bitselect",	  "COMMAND:   ",  "rngs_bitselect(BAT[oid,any::1], any::1, any::1, ..any::1..) : BAT[int,BAT]",		  "computes multiple bitmasks for each equi-select 'v' on 'sel'"																																					  ]
[ "rngs_oidselect",	  "COMMAND:   ",  "rngs_oidselect(BAT[oid,any::1], any::1, any::1, ..any::1..) : BAT[int,BAT]",		  "uselect, optimized for enum types, on multiple range-select predicates"																																				  ]
[ "semijoin",		  "PROC:      ",  "semijoin(BAT[void,any::1], BAT[any,any]) : BAT[oid,any::1]",				  "not available"																																											  ]
[ "semijoin",		  "PROC:      ",  "semijoin(BAT[void,bit32], BAT[void,bit32]) : BAT[void,bit32]",			  "not available"																																											  ]
[ "stats",		  "COMMAND:   ",  "stats(BAT[void,bit32]) : BAT[str,lng]",						  "produce info on this bit-selection"																																									  ]
[ "subhisto",		  "COMMAND:   ",  "subhisto(BAT[oid,any::1], BAT[oid,any]) : BAT[any,int]",				  "computes a subset-histogram on b, receiving the subset as a selection BAT"																																				  ]
[ "subhisto",		  "COMMAND:   ",  "subhisto(BAT[oid,any::1], BAT[void,bit32]) : BAT[any,int]",				  "computes a subset-histogram on b, receiving the subset as a bitmask"																																					  ]
[ "subhistos",		  "COMMAND:   ",  "subhistos(BAT[oid,any::1], ..BAT[void,bit32]..) : BAT[int,BAT]",			  "computes multiple subset-histograms on b, receiving multiple bitmasks"																																				  ]
[ "subselect",		  "COMMAND:   ",  "subselect(BAT[oid,void], BAT[oid,any::1], any::1) : BAT[oid,void]",			  "uselect, on b.semijoin(sel), optimized for enum types"																																						  ]
[ "subselect",		  "COMMAND:   ",  "subselect(BAT[oid,void], BAT[oid,any::1], any::1, any::1) : BAT[oid,void]",		  "uselect, on b.semijoin(sel), optimized for enum types"																																						  ]
[ "subselect",		  "COMMAND:   ",  "subselect(BAT[void,bit32], BAT[oid,any::1], any::1) : BAT[void,bit32]",		  "do a bitselect on the subset indicated by the first BAT param"																																					  ]
[ "subselect",		  "COMMAND:   ",  "subselect(BAT[void,bit32], BAT[oid,any::1], any::1, any::1) : BAT[void,bit32]",	  "do a bitselect on the subset indicated by the first BAT param"																																					  ]
[ "table",		  "PROC:      ",  "table(str, BAT[any::1,any], ..BAT[any::1,any]..) : any",				  "not available"																																											  ]
[ "test_ddbench",	  "PROC:      ",  "test_ddbench() : void",								  "not available"																																											  ]
[ "test_streams",	  "PROC:      ",  "test_streams() : void",								  "not available"																																											  ]
[ "test_xtables",	  "PROC:      ",  "test_xtables() : void",								  "not available"																																											  ]
[ "tobat",		  "COMMAND:   ",  "tobat(BAT[void,bit32]) : BAT[oid,void]",						  "convert a bat[void,bit32] bitmap selection into a BAT of oids"																																					  ]
[ "val_bitselect",	  "COMMAND:   ",  "val_bitselect(BAT[oid,any::1], any::1) : BAT[void,bit32]",				  "do a range-scan equiselect, but output the result as a bitmask, partitioned\n  in 32-bits integers. "																																  ]
[ "val_oidselect",	  "COMMAND:   ",  "val_oidselect(BAT[oid,any::1], any::1) : BAT[void,oid]",				  "uselect, optimized for enumeration types"																																								  ]
[ "vals_bitselect",	  "COMMAND:   ",  "vals_bitselect(BAT[oid,any::1], any::1, ..any::1..) : BAT[int,BAT]",			  "computes multiple bitmasks for each equi-select 'v' on 'sel'"																																					  ]
[ "vals_oidselect",	  "COMMAND:   ",  "vals_oidselect(BAT[oid,any::1], any::1, ..any::1..) : BAT[int,BAT]",			  "uselect, optimized for enum types, on multiple equi-select predicates"																																				  ]
[ "xtable_histo_direct",  "PROC:      ",  "xtable_histo_direct(..any..) : any",							  "not available"																																											  ]
[ "xtable_histo_remap",	  "PROC:      ",  "xtable_histo_remap(..any..) : any",							  "not available"																																											  ]
[ "xtable_print",	  "PROC:      ",  "xtable_print(..any..) : any",							  "not available"																																											  ]
[ "xtable_realloc",	  "PROC:      ",  "xtable_realloc(any, any) : any",							  "not available"																																											  ]
[ "xtable_test",	  "PROC:      ",  "xtable_test(any, any, any, any) : any",						  "not available"																																											  ]
[ "{count}",		  "PROC:      ",  "{count}(BAT[any::1,any]) : BAT[any::1,int]",						  "not available"																																											  ]
[ "{count}",		  "PROC:      ",  "{count}(BAT[oid,bit], BAT[oid,oid], BAT[oid,int]) : BAT[oid,int]",			  "not available"																																											  ]
[ "{count}",		  "PROC:      ",  "{count}(BAT[void,bit], BAT[void,oid], BAT[oid,int]) : BAT[oid,int]",			  "not available"																																											  ]

Module: "iterator"

[ 16 ]
[ 16 ]
#-----------------------------------------------------------------------------------------------------------------------------------------------------------------#
# function		| type		| signature						| help								  #
#-----------------------------------------------------------------------------------------------------------------------------------------------------------------#
[ "aggr",		  "COMMAND:   ",  "aggr(iter, str, BAT[oid,any::1]) : BAT[any,any::1]",	  "groupby-aggregate(attr), aggr in {max,min,sum,avg}"		  ]
[ "chunk",		  "COMMAND:   ",  "chunk(iter) : BAT[any,any]",				  "get the next chunk"						  ]
[ "chunksize",		  "COMMAND:   ",  "chunksize() : int",					  "return the iterator chunksize (default=1)"			  ]
[ "chunksize",		  "COMMAND:   ",  "chunksize(int) : void",				  "set the iterator chunksize"					  ]
[ "collect",		  "COMMAND:   ",  "collect(iter) : BAT[any,any]",			  "recursively execute an iterator; collect results in a bat"	  ]
[ "count",		  "COMMAND:   ",  "count(iter) : int",					  "recursively execute an iterator; just count the elements"	  ]
[ "histo",		  "COMMAND:   ",  "histo(iter) : BAT[any,int]",				  "groupby-count on tail"					  ]
[ "join",		  "COMMAND:   ",  "join(iter, BAT[any,any]) : iter",			  "hash-join iterator"						  ]
[ "mark",		  "COMMAND:   ",  "mark(iter, oid) : iter",				  "mark tail buns of the input iterator"			  ]
[ "mirror",		  "COMMAND:   ",  "mirror(iter) : iter",				  "mirror buns (both head) in the input iterator"		  ]
[ "next",		  "COMMAND:   ",  "next(iter) : bit",					  "false: no more chunks / true: iter contains next chunk"	  ]
[ "reverse",		  "COMMAND:   ",  "reverse(iter) : iter",				  "reverse the buns in the input iterator"			  ]
[ "scan",		  "COMMAND:   ",  "scan(BAT[any,any]) : iter",				  "sequential-scan on bat"					  ]
[ "select",		  "COMMAND:   ",  "select(iter, bit, str, any) : iter",			  "select on tail (fcn in {eq,=,!=,<,>,<=,>=,..})"		  ]
[ "select",		  "COMMAND:   ",  "select(iter, bit, str, any, any) : iter",		  "select on tail (fcn in {rng,..})"				  ]
[ "test_iterator",	  "PROC:      ",  "test_iterator() : void",				  "not available"						  ]

Module: "malalgebra"

[ 16 ]
[ 16 ]
#-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------#
# function		| type		| signature									| help								  #
#-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------#
[ "fetchjoin",		  "COMMAND:   ",  "fetchjoin(BAT[any::1,any::2], BAT[any::2,any::3]) : BAT[any::1,any::3]",	  "Hook directly into the fetch implementation of the join."	  ]
[ "hashjoin",		  "COMMAND:   ",  "hashjoin(BAT[any::1,any::2], BAT[any::2,any::3]) : BAT[any::1,any::3]",	  "Hook directly into the hash implementation of the join."	  ]
[ "indexjoin",		  "COMMAND:   ",  "indexjoin(BAT[any::1,any::2], BAT[any::2,any::3]) : BAT[any::1,any::3]",	  "Hook directly into the index implementation of the join."	  ]
[ "lrhashjoin",		  "COMMAND:   ",  "lrhashjoin(BAT[any::1,any::2], BAT[any::2,any::3]) : BAT[any::1,any::3]",	  "Hook directly into the lrhash implementation of the join."	  ]
[ "mergejoin",		  "COMMAND:   ",  "mergejoin(BAT[any::1,any::2], BAT[any::2,any::3]) : BAT[any::1,any::3]",	  "Hook directly into the merge implementation of the join."	  ]
[ "test_malalgebra",	  "PROC:      ",  "test_malalgebra() : void",							  "not available"						  ]
[ "{_csum}",		  "COMMAND:   ",  "{_csum}(BAT[oid,dbl]) : BAT[oid,dbl]",					  "grouped tail sum"						  ]
[ "{_csum}",		  "COMMAND:   ",  "{_csum}(BAT[oid,flt]) : BAT[oid,flt]",					  "grouped tail sum"						  ]
[ "{_csum}",		  "COMMAND:   ",  "{_csum}(BAT[oid,int]) : BAT[oid,int]",					  "grouped tail sum"						  ]
[ "{_csum}",		  "COMMAND:   ",  "{_csum}(BAT[oid,lng]) : BAT[oid,lng]",					  "grouped tail sum"						  ]
[ "{_csum}",		  "COMMAND:   ",  "{_csum}(BAT[oid,sht]) : BAT[oid,sht]",					  "grouped tail sum"						  ]
[ "{csum}",		  "PROC:      ",  "{csum}(BAT[oid,dbl]) : BAT[oid,dbl]",					  "Choose a different implementation if b is sorted on head."	  ]
[ "{csum}",		  "PROC:      ",  "{csum}(BAT[oid,flt]) : BAT[oid,flt]",					  "Choose a different implementation if b is sorted on head."	  ]
[ "{csum}",		  "PROC:      ",  "{csum}(BAT[oid,int]) : BAT[oid,int]",					  "Choose a different implementation if b is sorted on head."	  ]
[ "{csum}",		  "PROC:      ",  "{csum}(BAT[oid,lng]) : BAT[oid,lng]",					  "Choose a different implementation if b is sorted on head."	  ]
[ "{csum}",		  "PROC:      ",  "{csum}(BAT[oid,sht]) : BAT[oid,sht]",					  "Choose a different implementation if b is sorted on head."	  ]

Module: "mel"

[ 2 ]
[ 2 ]
#---------------------------------------------------------------------------------#
# function	| type		| signature		| help			  #
#---------------------------------------------------------------------------------#
[ "mel_test",	  "PROC:      ",  "mel_test() : any",	  "not available"	  ]
[ "test_mel",	  "PROC:      ",  "test_mel() : void",	  "not available"	  ]

Module: "mprof"

[ 31 ]
[ 31 ]
#-------------------------------------------------------------------------------------------------------------------------------------------------#
# function		| type		| signature					| help							  #
#-------------------------------------------------------------------------------------------------------------------------------------------------#
[ "-",			  "OPERATOR:  ",  "-(Mallinfo, Mallinfo) : Mallinfo",		  "Subtract the memory info records"			  ]
[ "-",			  "OPERATOR:  ",  "-(Rusage, Rusage) : Rusage",			  "Subtract the io and swap records"			  ]
[ "-",			  "OPERATOR:  ",  "-(Tms, Tms) : Tms",				  "Subtract the timing records"				  ]
[ "Ma_arena",		  "COMMAND:   ",  "Ma_arena(Mallinfo) : int",			  "Dynamic allocated arena size"			  ]
[ "Ma_fordblks",	  "COMMAND:   ",  "Ma_fordblks(Mallinfo) : int",		  "Free ordinary blocks in arena"			  ]
[ "Ma_fsmblks",		  "COMMAND:   ",  "Ma_fsmblks(Mallinfo) : int",			  "Free small blocks in arena"				  ]
[ "Ma_new",		  "COMMAND:   ",  "Ma_new() : Mallinfo",			  "Get malloc information"				  ]
[ "Ma_uordblks",	  "COMMAND:   ",  "Ma_uordblks(Mallinfo) : int",		  "Used ordinary blocks in arena"			  ]
[ "Ma_usmblks",		  "COMMAND:   ",  "Ma_usmblks(Mallinfo) : int",			  "Used small blocks in arena"				  ]
[ "Ru_inblock",		  "COMMAND:   ",  "Ru_inblock(Rusage) : int",			  "Extract the actual physical read count"		  ]
[ "Ru_majflt",		  "COMMAND:   ",  "Ru_majflt(Rusage) : int",			  "Extract the major page faults"			  ]
[ "Ru_maxrss",		  "COMMAND:   ",  "Ru_maxrss(Rusage) : int",			  "Extract the maximum resident set size utilized"	  ]
[ "Ru_minflt",		  "COMMAND:   ",  "Ru_minflt(Rusage) : int",			  "Extract the minor page faults"			  ]
[ "Ru_new",		  "COMMAND:   ",  "Ru_new() : Rusage",				  "Extract system resource usage record"		  ]
[ "Ru_nivcsw",		  "COMMAND:   ",  "Ru_nivcsw(Rusage) : int",			  "Extract the non-voluntary context switch count"	  ]
[ "Ru_nswap",		  "COMMAND:   ",  "Ru_nswap(Rusage) : int",			  "Extract the actual process swap count"		  ]
[ "Ru_nvcsw",		  "COMMAND:   ",  "Ru_nvcsw(Rusage) : int",			  "Extract the voluntary context switch count"		  ]
[ "Ru_oublock",		  "COMMAND:   ",  "Ru_oublock(Rusage) : int",			  "Extract the actual physical write count"		  ]
[ "Tms_new",		  "COMMAND:   ",  "Tms_new() : Tms",				  "Create a new Tms record"				  ]
[ "Tms_stime",		  "COMMAND:   ",  "Tms_stime(Tms) : int",			  "Extract the system time part from the record"	  ]
[ "Tms_utime",		  "COMMAND:   ",  "Tms_utime(Tms) : int",			  "Extract the user time part from the record"		  ]
[ "emptyMallinfo",	  "PROC:      ",  "emptyMallinfo(..any..) : any",		  "not available"					  ]
[ "insB",		  "COMMAND:   ",  "insB(str, int, Tms, Rusage, Mallinfo) : int",  "Insert the begin of a new labelled time period"	  ]
[ "insE",		  "COMMAND:   ",  "insE(str, int, Tms, Rusage, Mallinfo) : int",  "Insert the end of a new labelled time period"	  ]
[ "pmB",		  "COMMAND:   ",  "pmB(str) : int",				  "Start a new labelled timing period"			  ]
[ "pmClear",		  "COMMAND:   ",  "pmClear() : void",				  "Clear the performance bats"				  ]
[ "pmE",		  "COMMAND:   ",  "pmE(str) : int",				  "End a labelled timing period"			  ]
[ "pmPrint",		  "PROC:      ",  "pmPrint(..any..) : any",			  "not available"					  ]
[ "pmSummary",		  "PROC:      ",  "pmSummary(..any..) : any",			  "not available"					  ]
[ "pmTag",		  "COMMAND:   ",  "pmTag(str, str) : void",			  "Add comment to a timing period"			  ]
[ "test_mprof",		  "PROC:      ",  "test_mprof() : void",			  "not available"					  ]

Module: "oo7"

[ 5 ]
[ 5 ]
#-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------#
# function	| type		| signature									| help																																		  #
#-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------#
[ "closure",	  "COMMAND:   ",  "closure(BAT[any::1,any::1]) : BAT[any::1,any::1]",				  "Computes the transitive closure of all points in the 'edges'\ngraph. Breadth-first traversal is used (repeated forward joins)."																		  ]
[ "oo7create",	  "COMMAND:   ",  "oo7create(str) : void",							  "Create the OO7 database schema and fill it. Run with -help for info."																									  ]
[ "oo7delete",	  "COMMAND:   ",  "oo7delete() : void",								  "Delete all OO7 tables."																															  ]
[ "subgraph",	  "COMMAND:   ",  "subgraph(BAT[any::2,any::1], BAT[any::1,any::1]) : BAT[any::1,any::1]",	  "Uses the tail values from 'in' as starting points, and\ndetermines by recursive traversal which subgraph of 'edges'\ncan be reached from there. This subgraph is returned.\n\nTraversal order is currently breadth-first.\n\nWorks only on ANY::1 e {int,oid,flt,bat,ptr}. "	  ]
[ "traverse",	  "COMMAND:   ",  "traverse(BAT[any::2,any::1], BAT[any::1,any::1]) : BAT[any::1,any::1]",	  "From the starting points in 'in' (tail), compute all\nreachable points by (dag!) 'edges'."																							  ]

Module: "qt"

[ 9 ]
[ 9 ]
#---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------#
# function			| type		| signature																					| help																																																															  #
#---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------#
[ "[qt_cross_pre_select]",	  "COMMAND:   ",  "[qt_cross_pre_select](int, int, int) : BAT[oid,oid]",															  "Select images that _may_ satisfy the cross's color transitions"																																																							  ]
[ "[qt_debug]",			  "COMMAND:   ",  "[qt_debug](int) : void",																			  "Set debuging on/off"																																																													  ]
[ "[qt_delcross]",		  "COMMAND:   ",  "[qt_delcross](int) : void",																			  "Delete a cross."																																																													  ]
[ "[qt_ir_cluster]",		  "COMMAND:   ",  "[qt_ir_cluster](BAT[void,oid], BAT[void,int], BAT[void,int], BAT[void,uchr], BAT[void,uchr], BAT[void,uchr], int) : void",							  "Cluster all images in a set of bit vectors with 3 color transitions in\n  the Itten-Runge color space.  The clusters themselves are named \n  IR_[N|W]_C0_C1_C2"																																											  ]
[ "[qt_makecross]",		  "COMMAND:   ",  "[qt_makecross](BAT[int,uchr], BAT[int,uchr], BAT[int,uchr], int) : int",													  "Construct a cross from a spot quad tree.  When IR space is set, the \n  cross is stored in IR color space."																																																		  ]
[ "[qt_match]",			  "COMMAND:   ",  "[qt_match](int, oid, BAT[void,oid], BAT[void,int], BAT[void,int], BAT[void,uchr], BAT[void,uchr], BAT[void,uchr], BAT[oid,oid], BAT[oid,int], BAT[oid,int], int, flt) : void", "Look for a matching color cross, which is described by the cross \n  referenced by crossid, in the ID, H, S, and V table.  The requested quad\n  tree is presented in the tables qt_ioffs and qt_inum (offset and number\n  of features, respectively) at entry image_oid.  Fill in the r_* BATS\n  with matching images, number of colors and the IDs of the matched\n  features, respectively if more than or equal to the number of different\n  colors from the spot time the fraction match in the image."	  ]
[ "[qt_pre_select]",		  "COMMAND:   ",  "[qt_pre_select](int, int, int) : BAT[oid,oid]",																  "Select images that _may_ satisfy the cross's color transitions"																																																							  ]
[ "[qt_stats]",			  "COMMAND:   ",  "[qt_stats](int, str) : void",																		  "Control statistics output"																																																												  ]
[ "test_bitvector",		  "PROC:      ",  "test_bitvector() : void",																			  "not available"																																																													  ]

Module: "tpcd"

[ 34 ]
[ 34 ]
#-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------#
# function	| type		| signature										| help																		  #
#-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------#
[ "avg",	  "PROC:      ",  "avg(..any..) : any",									  "not available"																  ]
[ "debug",	  "PROC:      ",  "debug(..any..) : any",								  "not available"																  ]
[ "dvjoin",	  "COMMAND:   ",  "dvjoin(BAT[oid,void], BAT[void,any::1], BAT[oid,any::2]) : BAT[any::1,any::2]",	  "Performs join(A.extent,A.vector,B) using a datavector on A.tail. \n     Creates a vextoridx on the head of B; if not present already."	  ]
[ "dvsemijoin",	  "COMMAND:   ",  "dvsemijoin(BAT[oid,void], BAT[void,any::1], BAT[oid,any::2]) : BAT[oid,any::1]",	  "Performs semijoin(A.extent,A.vector,B) using a datavector on A.tail. \n     Creates a vextoridx on the head of B; if not present already."	  ]
[ "extent",	  "COMMAND:   ",  "extent(BAT[oid,any::1]) : BAT[oid,void]",						  "If there is a datavector on the tail of the BAT, this returns\n     the associated extent BAT, else it gives an error."			  ]
[ "gjoin",	  "PROC:      ",  "gjoin() : <predefinition>",								  "not available"																  ]
[ "gjoin",	  "PROC:      ",  "gjoin(any, any) : any",								  "not available"																  ]
[ "gorder",	  "PROC:      ",  "gorder(any) : any",									  "not available"																  ]
[ "gselect",	  "PROC:      ",  "gselect(..any..) : any",								  "not available"																  ]
[ "gsemijoin",	  "PROC:      ",  "gsemijoin(any, any) : any",								  "not available"																  ]
[ "gsum",	  "PROC:      ",  "gsum(any) : any",									  "not available"																  ]
[ "guselect",	  "PROC:      ",  "guselect(..any..) : any",								  "not available"																  ]
[ "udiff",	  "PROC:      ",  "udiff(..any..) : any",								  "not available"																  ]
[ "uintersect",	  "PROC:      ",  "uintersect(..any..) : any",								  "not available"																  ]
[ "uunion",	  "PROC:      ",  "uunion(..any..) : any",								  "not available"																  ]
[ "uunique",	  "PROC:      ",  "uunique(..any..) : any",								  "not available"																  ]
[ "vector",	  "COMMAND:   ",  "vector(BAT[oid,any::1]) : BAT[void,any::1]",						  "If there is a datavector on the tail of the BAT, this returns\n     the associated unary vector BAT, else it gives an error."		  ]
[ "{avg}",	  "COMMAND:   ",  "{avg}(BAT[int,flt], BAT[int,any]) : BAT[int,flt]",					  "grouped tail average"															  ]
[ "{avg}",	  "COMMAND:   ",  "{avg}(BAT[int,int], BAT[int,any]) : BAT[int,int]",					  "grouped tail average"															  ]
[ "{avg}",	  "COMMAND:   ",  "{avg}(BAT[oid,flt], BAT[oid,any]) : BAT[oid,flt]",					  "grouped tail average"															  ]
[ "{avg}",	  "COMMAND:   ",  "{avg}(BAT[oid,int], BAT[oid,any]) : BAT[oid,int]",					  "grouped tail average"															  ]
[ "{count}",	  "PROC:      ",  "{count}(..any..) : any",								  "not available"																  ]
[ "{max}",	  "COMMAND:   ",  "{max}(BAT[int,flt], BAT[int,any]) : BAT[int,flt]",					  "grouped tail maximum"															  ]
[ "{max}",	  "COMMAND:   ",  "{max}(BAT[int,int], BAT[int,any]) : BAT[int,int]",					  "grouped tail maximum"															  ]
[ "{max}",	  "COMMAND:   ",  "{max}(BAT[oid,flt], BAT[oid,any]) : BAT[oid,flt]",					  "grouped tail maximum"															  ]
[ "{max}",	  "COMMAND:   ",  "{max}(BAT[oid,int], BAT[oid,any]) : BAT[oid,int]",					  "grouped tail maximum"															  ]
[ "{min}",	  "COMMAND:   ",  "{min}(BAT[int,flt], BAT[int,any]) : BAT[int,flt]",					  "grouped tail minimum"															  ]
[ "{min}",	  "COMMAND:   ",  "{min}(BAT[int,int], BAT[int,any]) : BAT[int,int]",					  "grouped tail minimum"															  ]
[ "{min}",	  "COMMAND:   ",  "{min}(BAT[oid,flt], BAT[oid,any]) : BAT[oid,flt]",					  "grouped tail minimum"															  ]
[ "{min}",	  "COMMAND:   ",  "{min}(BAT[oid,int], BAT[oid,any]) : BAT[oid,int]",					  "grouped tail minimum"															  ]
[ "{sum}",	  "COMMAND:   ",  "{sum}(BAT[int,flt], BAT[int,any]) : BAT[int,flt]",					  "grouped tail sum"																  ]
[ "{sum}",	  "COMMAND:   ",  "{sum}(BAT[int,int], BAT[int,any]) : BAT[int,int]",					  "grouped tail sum"																  ]
[ "{sum}",	  "COMMAND:   ",  "{sum}(BAT[oid,flt], BAT[oid,any]) : BAT[oid,flt]",					  "grouped tail sum"																  ]
[ "{sum}",	  "COMMAND:   ",  "{sum}(BAT[oid,int], BAT[oid,any]) : BAT[oid,int]",					  "grouped tail sum"																  ]

Module: "vector"

[ 140 ]
[ 140 ]
#-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------#
# function			| type		| signature							| help												  #
#-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------#
[ "*",				  "OPERATOR:  ",  "*(dbl_vector32, dbl) : dbl_vector32",			  "Multiplication of vector of dbls with scalar"						  ]
[ "*",				  "OPERATOR:  ",  "*(dbls, dbl) : dbls",					  "Multiplication of vector of dbls with scalar"						  ]
[ "*",				  "OPERATOR:  ",  "*(flts, flt) : flts",					  "Multiplication of vector of flts with scalar"						  ]
[ "*",				  "OPERATOR:  ",  "*(int_vector64, int) : int_vector64",			  "Multiplication of vector of ints with scalar"						  ]
[ "*",				  "OPERATOR:  ",  "*(ints, int) : ints",					  "Multiplication of vector of ints with scalar"						  ]
[ "+",				  "OPERATOR:  ",  "+(dbl_vector32, dbl_vector32) : dbl_vector32",		  "Addition of vectors of dbl_vector32"								  ]
[ "+",				  "OPERATOR:  ",  "+(dbls, dbls) : dbls",					  "Addition of vectors of dbls"									  ]
[ "+",				  "OPERATOR:  ",  "+(flts, flts) : flts",					  "Addition of vectors of flts"									  ]
[ "+",				  "OPERATOR:  ",  "+(int_vector64, int_vector64) : int_vector64",		  "Addition of vectors of int_vector64"								  ]
[ "+",				  "OPERATOR:  ",  "+(ints, ints) : ints",					  "Addition of vectors of ints"									  ]
[ "-",				  "OPERATOR:  ",  "-(dbl_vector32, dbl_vector32) : dbl_vector32",		  "Subtraction of vectors of dbls (param 1 - param 2)"						  ]
[ "-",				  "OPERATOR:  ",  "-(dbls, dbls) : dbls",					  "Subtraction of vectors of dbls (param 1 - param 2)"						  ]
[ "-",				  "OPERATOR:  ",  "-(flts, flts) : flts",					  "Subtraction of vectors of flts (param 1 - param 2)"						  ]
[ "-",				  "OPERATOR:  ",  "-(int_vector64, int_vector64) : int_vector64",		  "Subtraction of vectors of ints (param 1 - param 2)"						  ]
[ "-",				  "OPERATOR:  ",  "-(ints, ints) : ints",					  "Subtraction of vectors of ints (param 1 - param 2)"						  ]
[ "/",				  "OPERATOR:  ",  "/(dbl_vector32, dbl) : dbl_vector32",			  "Divide vector of dbls by dbl"								  ]
[ "/",				  "OPERATOR:  ",  "/(dbls, dbl) : dbls",					  "Divide vector of dbls by dbl"								  ]
[ "/",				  "OPERATOR:  ",  "/(flts, flt) : flts",					  "Divide vector of flts by flt"								  ]
[ "/",				  "OPERATOR:  ",  "/(int_vector64, int) : int_vector64",			  "Divide vector of ints by int"								  ]
[ "/",				  "OPERATOR:  ",  "/(ints, int) : ints",					  "Divide vector of ints by int"								  ]
[ "D1distance",			  "COMMAND:   ",  "D1distance(dbl_vector32, dbl_vector32) : dbl",		  "Calculates 'Relative' L1 distance between 2 vectors"						  ]
[ "D1distance",			  "COMMAND:   ",  "D1distance(dbls, dbls) : dbl",				  "Calculates 'Relative' L1 distance between 2 vectors"						  ]
[ "D1distance",			  "COMMAND:   ",  "D1distance(flts, flts) : dbl",				  "Calculates 'Relative' L1 distance between 2 vectors"						  ]
[ "D1distance",			  "COMMAND:   ",  "D1distance(int_vector64, int_vector64) : dbl",		  "Calculates 'Relative' L1 distance between 2 vectors"						  ]
[ "D1distance",			  "COMMAND:   ",  "D1distance(ints, ints) : dbl",				  "Calculates 'Relative' L1 distance between 2 vectors"						  ]
[ "IDdistance",			  "COMMAND:   ",  "IDdistance(dbl_vector32, dbl_vector32) : dbl",		  "Calculates Intersection distance between 2 vectors"						  ]
[ "IDdistance",			  "COMMAND:   ",  "IDdistance(dbls, dbls) : dbl",				  "Calculates Intersection (I) distance (D) between 2 vectors"					  ]
[ "IDdistance",			  "COMMAND:   ",  "IDdistance(flts, flts) : dbl",				  "Calculates Intersection (I) distance (D) between 2 vectors"					  ]
[ "IDdistance",			  "COMMAND:   ",  "IDdistance(int_vector64, int_vector64) : dbl",		  "Calculates Intersection distance between 2 vectors"						  ]
[ "IDdistance",			  "COMMAND:   ",  "IDdistance(ints, ints) : dbl",				  "Calculates Intersection (I) distance (D) between 2 vectors"					  ]
[ "KSdistance",			  "COMMAND:   ",  "KSdistance(dbl_vector32, dbl_vector32) : dbl",		  "Calculates Kolmogorov-Smirnov Coefficient between 2 vectors"					  ]
[ "KSdistance",			  "COMMAND:   ",  "KSdistance(dbls, dbls) : dbl",				  "Calculates Kolmogorov-Smirnov Coefficient between 2 vectors"					  ]
[ "KSdistance",			  "COMMAND:   ",  "KSdistance(flts, flts) : dbl",				  "Calculates Kolmogorov-Smirnov Coefficient between 2 vectors"					  ]
[ "KSdistance",			  "COMMAND:   ",  "KSdistance(int_vector64, int_vector64) : dbl",		  "Calculates Kolmogorov-Smirnov Coefficient between 2 vectors"					  ]
[ "KSdistance",			  "COMMAND:   ",  "KSdistance(ints, ints) : dbl",				  "Calculates Kolmogorov-Smirnov Coefficient between 2 vectors"					  ]
[ "L1distance",			  "COMMAND:   ",  "L1distance(dbl_vector32, dbl_vector32) : dbl",		  "Calculates 'absulte difference' distance between 2 vectors"					  ]
[ "L1distance",			  "COMMAND:   ",  "L1distance(dbls, dbls) : dbl",				  "Calculates 'absulte difference' distance between 2 vectors"					  ]
[ "L1distance",			  "COMMAND:   ",  "L1distance(flts, flts) : dbl",				  "Calculates 'absulte difference' distance between 2 vectors"					  ]
[ "L1distance",			  "COMMAND:   ",  "L1distance(int_vector64, int_vector64) : dbl",		  "Calculates 'absulte difference' distance between 2 vectors"					  ]
[ "L1distance",			  "COMMAND:   ",  "L1distance(ints, ints) : dbl",				  "Calculates 'absulte difference' distance between 2 vectors"					  ]
[ "L2distance",			  "COMMAND:   ",  "L2distance(dbl_vector32, dbl_vector32) : dbl",		  "Calculates Euclidean (L2) distance between 2 vectors"					  ]
[ "L2distance",			  "COMMAND:   ",  "L2distance(dbls, dbls) : dbl",				  "Calculates Euclidean (L2) distance between 2 vectors"					  ]
[ "L2distance",			  "COMMAND:   ",  "L2distance(flts, flts) : dbl",				  "Calculates Euclidean (L2) distance between 2 vectors"					  ]
[ "L2distance",			  "COMMAND:   ",  "L2distance(int_vector64, int_vector64) : dbl",		  "Calculates Euclidean (L2) distance between 2 vectors"					  ]
[ "L2distance",			  "COMMAND:   ",  "L2distance(ints, ints) : dbl",				  "Calculates Euclidean (L2) distance between 2 vectors"					  ]
[ "YLdistance",			  "COMMAND:   ",  "YLdistance(dbl_vector32, dbl_vector32) : dbl",		  "Calculates Yakimovsky Likelihood ratio between 2 vectors"					  ]
[ "YLdistance",			  "COMMAND:   ",  "YLdistance(dbls, dbls) : dbl",				  "Calculates Yakimovsky Likelihood ratio between 2 vectors"					  ]
[ "YLdistance",			  "COMMAND:   ",  "YLdistance(flts, flts) : dbl",				  "Calculates Yakimovsky Likelihood ratio between 2 vectors"					  ]
[ "YLdistance",			  "COMMAND:   ",  "YLdistance(int_vector64, int_vector64) : dbl",		  "Calculates Yakimovsky Likelihood ratio between 2 vectors"					  ]
[ "YLdistance",			  "COMMAND:   ",  "YLdistance(ints, ints) : dbl",				  "Calculates Yakimovsky Likelihood ratio between 2 vectors"					  ]
[ "acos",			  "PROC:      ",  "acos(flt) : flt",						  "not available"										  ]
[ "asin",			  "PROC:      ",  "asin(flt) : flt",						  "not available"										  ]
[ "atan",			  "PROC:      ",  "atan(flt) : flt",						  "not available"										  ]
[ "average",			  "COMMAND:   ",  "average(dbl_vector32) : dbl",				  "Calculates the average value of the vector elements."					  ]
[ "average",			  "COMMAND:   ",  "average(dbls) : dbl",					  "Calculates the average value of the vector elements."					  ]
[ "average",			  "COMMAND:   ",  "average(flts) : dbl",					  "Calculates the average value of the vector elements."					  ]
[ "average",			  "COMMAND:   ",  "average(int_vector64) : dbl",				  "Calculates the average value of the vector elements."					  ]
[ "average",			  "COMMAND:   ",  "average(ints) : dbl",					  "Calculates the average value of the vector elements."					  ]
[ "ceil",			  "PROC:      ",  "ceil(flt) : flt",						  "not available"										  ]
[ "centroid",			  "COMMAND:   ",  "centroid(dbl_vector32) : dbl",				  "Computes the centroid of the given vector"							  ]
[ "centroid",			  "COMMAND:   ",  "centroid(dbls) : dbl",					  "Computes the centroid of the given vector"							  ]
[ "centroid",			  "COMMAND:   ",  "centroid(flts) : dbl",					  "Computes the centroid of the given vector"							  ]
[ "centroid",			  "COMMAND:   ",  "centroid(int_vector64) : dbl",				  "Computes the centroid of the given vector"							  ]
[ "centroid",			  "COMMAND:   ",  "centroid(ints) : dbl",					  "Computes the centroid of the given vector"							  ]
[ "cos",			  "PROC:      ",  "cos(flt) : flt",						  "not available"										  ]
[ "cosh",			  "PROC:      ",  "cosh(flt) : flt",						  "not available"										  ]
[ "dbl_vector32_rancreate",	  "COMMAND:   ",  "dbl_vector32_rancreate() : dbl_vector32",			  "Creates random vector"									  ]
[ "dbls_rancreate",		  "COMMAND:   ",  "dbls_rancreate(int) : dbls",					  "Creates random vector"									  ]
[ "dimension",			  "COMMAND:   ",  "dimension(dbl_vector32) : int",				  "Retrieves the dimension of the vector"							  ]
[ "dimension",			  "COMMAND:   ",  "dimension(dbls) : int",					  "Retrieves the dimension of the vector"							  ]
[ "dimension",			  "COMMAND:   ",  "dimension(flts) : int",					  "Retrieves the dimension of the vector"							  ]
[ "dimension",			  "COMMAND:   ",  "dimension(int_vector64) : int",				  "Retrieves the dimension of the vector"							  ]
[ "dimension",			  "COMMAND:   ",  "dimension(ints) : int",					  "Retrieves the dimension of the vector"							  ]
[ "exp",			  "PROC:      ",  "exp(flt) : flt",						  "not available"										  ]
[ "floor",			  "PROC:      ",  "floor(flt) : flt",						  "not available"										  ]
[ "flts_rancreate",		  "COMMAND:   ",  "flts_rancreate(int) : flts",					  "Creates random vector"									  ]
[ "getval",			  "COMMAND:   ",  "getval(dbl_vector32, int) : dbl",				  "Project the Ith element value out of the vector."						  ]
[ "getval",			  "COMMAND:   ",  "getval(dbls, int) : dbl",					  "Project the Ith element value out of the vector."						  ]
[ "getval",			  "COMMAND:   ",  "getval(flts, int) : flt",					  "Project the Ith element value out of the vector."						  ]
[ "getval",			  "COMMAND:   ",  "getval(int_vector64, int) : int",				  "Project the Ith element value out of the vector."						  ]
[ "getval",			  "COMMAND:   ",  "getval(ints, int) : int",					  "Project the Ith element value out of the vector."						  ]
[ "int_vector64_rancreate",	  "COMMAND:   ",  "int_vector64_rancreate() : int_vector64",			  "Creates random vector"									  ]
[ "ints_rancreate",		  "COMMAND:   ",  "ints_rancreate(int) : ints",					  "Creates random vector"									  ]
[ "length",			  "COMMAND:   ",  "length(dbl_vector32) : dbl",					  "Computes the length of the vector"								  ]
[ "length",			  "COMMAND:   ",  "length(dbls) : dbl",						  "Computes the length of the vector"								  ]
[ "length",			  "COMMAND:   ",  "length(flts) : dbl",						  "Computes the length of the vector"								  ]
[ "length",			  "COMMAND:   ",  "length(int_vector64) : dbl",					  "Computes the length of the vector"								  ]
[ "length",			  "COMMAND:   ",  "length(ints) : dbl",						  "Computes the length of the vector"								  ]
[ "log",			  "PROC:      ",  "log(flt) : flt",						  "not available"										  ]
[ "log10",			  "PROC:      ",  "log10(flt) : flt",						  "not available"										  ]
[ "maxrange",			  "COMMAND:   ",  "maxrange(BAT[any,dbl_vector32]) : dbl_vector32",		  "Determines the 32 values of each dimension in the vectors."					  ]
[ "maxrange",			  "COMMAND:   ",  "maxrange(BAT[any,dbls]) : dbls",				  "Determine the max values of each dimension in the vectors."					  ]
[ "maxrange",			  "COMMAND:   ",  "maxrange(BAT[any,flts]) : flts",				  "Determine the max values of each dimension in the vectors."					  ]
[ "maxrange",			  "COMMAND:   ",  "maxrange(BAT[any,int_vector64]) : int_vector64",		  "Determines the 64 values of each dimension in the vectors."					  ]
[ "maxrange",			  "COMMAND:   ",  "maxrange(BAT[any,ints]) : ints",				  "Determine the max values of each dimension in the vectors."					  ]
[ "meanvector",			  "COMMAND:   ",  "meanvector(BAT[any,dbl_vector32]) : dbl_vector32",		  "Calculates mean vector of given set of vectors"						  ]
[ "meanvector",			  "COMMAND:   ",  "meanvector(BAT[any,dbls], int) : dbls",			  "Calculates mean vector of given set of vectors (Params: bat[vectors], dimension of vectors)"	  ]
[ "meanvector",			  "COMMAND:   ",  "meanvector(BAT[any,flts], int) : flts",			  "Calculates mean vector of given set of vectors (Params: bat[vectors], dimension of vectors)"	  ]
[ "meanvector",			  "COMMAND:   ",  "meanvector(BAT[any,ints], int) : flts",			  "Calculates mean vector of given set of vectors (Params: bat[vectors], dimension of vectors)"	  ]
[ "minrange",			  "COMMAND:   ",  "minrange(BAT[any,dbl_vector32]) : dbl_vector32",		  "Determines the 32 values of each dimension in the vectors."					  ]
[ "minrange",			  "COMMAND:   ",  "minrange(BAT[any,dbls]) : dbls",				  "Determine the min values of each dimension in the vectors."					  ]
[ "minrange",			  "COMMAND:   ",  "minrange(BAT[any,flts]) : flts",				  "Determine the min values of each dimension in the vectors."					  ]
[ "minrange",			  "COMMAND:   ",  "minrange(BAT[any,int_vector64]) : int_vector64",		  "Determines the 64 values of each dimension in the vectors."					  ]
[ "minrange",			  "COMMAND:   ",  "minrange(BAT[any,ints]) : ints",				  "Determine the min values of each dimension in the vectors."					  ]
[ "normalize",			  "COMMAND:   ",  "normalize(dbl_vector32) : dbl_vector32",			  "Normalizes vector"										  ]
[ "normalize",			  "COMMAND:   ",  "normalize(dbls) : dbls",					  "Normalizes vector"										  ]
[ "normalize",			  "COMMAND:   ",  "normalize(flts) : flts",					  "Normalizes vector"										  ]
[ "normalize",			  "COMMAND:   ",  "normalize(ints) : flts",					  "Normalizes vector"										  ]
[ "sin",			  "PROC:      ",  "sin(flt) : flt",						  "not available"										  ]
[ "sinh",			  "PROC:      ",  "sinh(flt) : flt",						  "not available"										  ]
[ "sqrt",			  "PROC:      ",  "sqrt(flt) : flt",						  "not available"										  ]
[ "sum",			  "COMMAND:   ",  "sum(dbl_vector32) : dbl",					  "Calculates the sum of the vector elements."							  ]
[ "sum",			  "COMMAND:   ",  "sum(dbls) : dbl",						  "Calculates the sum of the vector elements."							  ]
[ "sum",			  "COMMAND:   ",  "sum(flts) : flt",						  "Calculates the sum of the vector elements."							  ]
[ "sum",			  "COMMAND:   ",  "sum(int_vector64) : int",					  "Calculates the sum of the vector elements."							  ]
[ "sum",			  "COMMAND:   ",  "sum(ints) : int",						  "Calculates the sum of the vector elements."							  ]
[ "tan",			  "PROC:      ",  "tan(flt) : flt",						  "not available"										  ]
[ "tanh",			  "PROC:      ",  "tanh(flt) : flt",						  "not available"										  ]
[ "test_mmath",			  "PROC:      ",  "test_mmath() : void",					  "not available"										  ]
[ "test_vector",		  "PROC:      ",  "test_vector() : void",					  "not available"										  ]
[ "todbls",			  "COMMAND:   ",  "todbls(flts) : dbls",					  "Converts vectors of flts to vector of dbls"							  ]
[ "todbls",			  "COMMAND:   ",  "todbls(ints) : dbls",					  "Converts vectors of ints to vector of dbls"							  ]
[ "toflts",			  "COMMAND:   ",  "toflts(dbls) : flts",					  "Converts vectors of dbls to vector of flts"							  ]
[ "toflts",			  "COMMAND:   ",  "toflts(ints) : flts",					  "Converts vectors of ints to vector of flts"							  ]
[ "toints",			  "COMMAND:   ",  "toints(dbls) : ints",					  "Converts vectors of dbls to vector of ints"							  ]
[ "toints",			  "COMMAND:   ",  "toints(flts) : ints",					  "Converts vectors of flts to vector of ints"							  ]
[ "twonormdiff",		  "COMMAND:   ",  "twonormdiff(dbl_vector32, dbl_vector32) : dbl_vector32",	  "Calculates 2norm difference between 2 vectors"						  ]
[ "twonormdiff",		  "COMMAND:   ",  "twonormdiff(dbls, dbls) : dbls",				  "Calculates 2norm difference between 2 vectors"						  ]
[ "twonormdiff",		  "COMMAND:   ",  "twonormdiff(flts, flts) : flts",				  "Calculates 2norm difference between 2 vectors"						  ]
[ "twonormdiff",		  "COMMAND:   ",  "twonormdiff(ints, ints) : flts",				  "Calculates 2norm difference between 2 vectors"						  ]
[ "variance",			  "COMMAND:   ",  "variance(dbl_vector32) : dbl",				  "Calculates the variance of the vector elements."						  ]
[ "variance",			  "COMMAND:   ",  "variance(dbls) : dbl",					  "Calculates the variance of the vector elements."						  ]
[ "variance",			  "COMMAND:   ",  "variance(flts) : dbl",					  "Calculates the variance of the vector elements."						  ]
[ "variance",			  "COMMAND:   ",  "variance(int_vector64) : dbl",				  "Calculates the variance of the vector elements."						  ]
[ "variance",			  "COMMAND:   ",  "variance(ints) : dbl",					  "Calculates the variance of the vector elements."						  ]
[ "variance2",			  "COMMAND:   ",  "variance2(dbl_vector32) : dbl",				  "Calculates the squared variance of the vector elements."					  ]
[ "variance2",			  "COMMAND:   ",  "variance2(dbls) : dbl",					  "Calculates the squared variance of the vector elements."					  ]
[ "variance2",			  "COMMAND:   ",  "variance2(flts) : dbl",					  "Calculates the squared variance of the vector elements."					  ]
[ "variance2",			  "COMMAND:   ",  "variance2(int_vector64) : dbl",				  "Calculates the squared variance of the vector elements."					  ]
[ "variance2",			  "COMMAND:   ",  "variance2(ints) : dbl",					  "Calculates the squared variance of the vector elements."					  ]

Module: "wisc"

[ 2 ]
[ 2 ]
#-----------------------------------------------------------------------------------------------------------------#
# function	| type		| signature			| help						  #
#-----------------------------------------------------------------------------------------------------------------#
[ "wisc",	  "COMMAND:   ",  "wisc(str, int) : void",	  "Wisconsin Benchmark Database Generator"	  ]
[ "wiscdestroy",  "COMMAND:   ",  "wiscdestroy(str) : void",	  "WBD destroy table"				  ]

quit;

# 15:30:10 >  
# 15:30:10 >  Done.
# 15:30:10 >  

