@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2004 CWI.
@' All Rights Reserved.

@t An overview of the Monet Database System
@v version 4.3 
@a Peter Boncz, Martin Kersten, Niels Nes, Stefan Manegold
@d 1/10/2002
@* Introduction
@T
This document intends to introduce you to get you up and running with @[<a href="http://monetdb.cwi.nl">Monet</a>@, 
a novel database system under development since 1993 at the 
@[<a href="http://db.cwi.nl/projecten/thema.php4?themanr=5">CWI database research group</a>@.\\ 

When you start reading this, you are supposed to have downloaded Monet from   
@[<a href="http://sourceforge.net/projects/monetdb/">sourceforge</a>@ and succesfully compiled following
the instructions in the file @[<a href="../../../GetGoing/Setup/MonetDB/Unix/index.html">HowToStart</a>@ (for Unix) or 
@[<a href="../../../GetGoing/Setup/MonetDB/Windows/index.html">HowToStart-Win32.txt</a>@ (for Windows). \\

After reading this document,
the next step to take is to study the @[<a href="../../FrontEnds/mil/index.html">MIL Reference Manual</a>@.

@+ Background
@T
Monet builds on previous experiments in database architecture, which go 
back to the early eigthies, when the {\bf Troll} database kernel was developed at the Vrije Universiteit,
Amsterdam by prof. M. L. Kersten, and subsequently commercially distributed.  Troll was a typical first-generation 
relational algebra engine, with an emphasis on algorithms, a simple textual algebraic interface, and 
limited optimizer functionality. \\

A second architecture was developed between 1985 and 1992 
as a co-production between the database research group of CWI and University of Twente
in the context of the @[<a href="http://wwwhome.cs.utwente.nl/~annita/prisma.html">PRISMA</a>@ project. 
This project  researched the consequences of a highly parallel platform (100 cpus) and a 
large main-memory (in the GBs) on the architecture of an SQL-compliant database engine.  A complete 
functional system was delivered early 1990s and subsequently abandoned, primarilly due to 
the limitations imposed upon the portability of the system by its proprietary implementation 
language POOL and refocusing of Philips Research on the core business of Philips.

@- Monet
@T
The Monet project started out as a serious attempt to build a complete database kernel that exploits the 
power of modern hardware to the full on heavy analysis ("query-intensive") applications.
An initial version of Monet was designed and implemented by Kersten and gradually taken over by Boncz as 
part of his Ph.D. research track. Over its eight years of development many other people have contributed to 
its development as implementors of missing functionality or application developers.  \\

The Monet system is used as data management engine by CWI data mining spin-off 
@[<a href="http://www.datadistilleries.com">Data Distilleries B.V.</a>@,  
and as such continues to be deployed at the marketing departments of (mostly) 
large financial institutions (like @[<a href="http://www.abnamro.com">ABN Amro</a>@,
@[<a href="http://www.postbank.nl">ING Postbank</a>@, @[<a href="http://www.aegon.nl">Aegon</a>@,
@[<a href="http://www.vodafone.nl">Vodafone</a>@, @[<a href="http://www.centerparcs.nl">Center Parcs</a>@,
@[<a href="http://www.ohra.nl">OHRA</a>@, @[<a href="http://www.imponline.com">IMP</a>@). 
Its deployment in commercial environments has greatly improved the stability of the Monet code, 
but also meant that in the first years its distribution was restricted. \\

After the restrictions on its distribution were lifted, the Monet source was transferred to 
@[<a href="http://sourceforge.net/projects/monetdb/">sourceforge</a>@, where it is now available for all 
and managed by a small core team of developers at the @[<a href="http://monetdb.cwi.nl/">CWI</a>@. Quality 
control of the source is performed at CWI where a nightly build and testing environment tests the main code 
branches on a farm of different hardware/OS/compiler combinations.

@- Technical Highlights
@T
As for its technical novelty, Monet proposes to use full {\bf vertical fragmentation}
in order to better accomodate {\bf query-intensive access patterns}, both in terms of {\bf I/O optimization}
as well as for improving the access to the {\bf CPU caches}.  \\

Monet also uses a column-wise query-processing algebra that has a zero degree of freedom, which makes it
possible to use a generic but {\bf pre-compiled query engine}, as opposed to the interpretative
techniques used in other DBMSs.  Compile-time fixed query processing primitives are crucial for modern CPUs
like the Pentium 4, which need highly predictable code in order to avoid branch mispredictions,
as well as an ever present pool of independent instructions (in order to fill its parallel units
and obtain a good Instructions-Per-Cycle ratio). Note that compile-time here means {\em DBMS build time},
and not {\em query-compilation-time}, which is a run-time activity. \\

A final Monet design issue was extensibility: by constructing Monet as a {\bf back-end}, on top of
which multiple {\bf front-end} systems can work and interact with the storage/query
on a lower level than, say, SQL allows to re-use the same system in multiple application domains, which
was one of Monet's design goals.  \\

Monet has been applied succesfully to
@[<a href="http://www.cwi.nl/htbin/ins1/publications?request=abstract&key=BoWiKe:ICDE:98">OLAP</a>@,
@[<a href="http://www.cwi.nl/htbin/ins1/publications?request=abstract&key=BoRuKw:VLDB:98">data mining</a>@,
@[<a href="http://www.cwi.nl/htbin/ins1/publications?request=abstract&key=BoQuKe:EDBT:96">GIS</a>@,
@[<a href="http://www.cwi.nl/htbin/ins1/publications/?request=abstract&key=VrMaNeKe:SIGMOD:02">k-NN search</a>@,
@[<a href="http://www.cwi.nl/htbin/ins1/publications?request=abstract&key=ScKeWi:ICDE:01">XML</a>@-,
@[<a href="http://www.cwi.nl/htbin/ins1/publications?request=abstract&key=NeKe:BNCOD:98">image</a>@- and
@[<a href="http://citeseer.nj.nec.com/501825.html">video</a>@-databases.\\

\begin{center}
{\epsfxsize=0.55\textwidth
\epsffile{monet.feps}
\label{fig1}{\em Front-end/Back-end Architecture}}\\
@-
@T
A full reference of the Monet system covering motivation, basic principles, and detailed technical architecture 
can be found in the @[<a href="http://www.cwi.nl/htbin/ins1/publications?request=abstract&key=Bo:DISS:02">Ph.D thesis</a>@.
of Boncz.
@-
@T
The remainder of this document provides a synopsis of the discriminative
features of Monet,  installation information, and a short tutorial to get
a flavour of using it.

@* Monet Features 
@T
Monet is database engine geared at high performance on systems with (complex) queries that have
to analyze large amounts of data (i.e. OLAP, {\bf not} OLTP). The features in which it most
differs from other DBMSs are summarized below:

\begin{itemize} 
\item {\em Independence of SQL:} \\

Monet has a Front-end/Back-end design
allowing one to store more than only relational tables (like object-oriented
or native XML data) and allowing to use querying paradigms other than SQL only
(like OQL or XQuery). 

In this architecture, Monet is the {\bf back-end}, which is accessed by multiple 
{\bf front-ends} such as an SQL-frontend, and XML-frontend or even a Data 
Mining tool).  The intermediate language with which these components talk to each 
other is called the @[<a href="../../FrontEnds/mil/index.html">Monet Interpreter Language</a>@ (MIL).

Currently, the only freely available front-end is the @[<a href="http://monetdb.cwi.nl/TechDocs/FrontEnds/SQL/index.html">SQL frontend</a>@.
Work on a distibution of the XML front-end (so succesfully benchmarked in 
@[<a href="http://monetdb.cwi.nl/xml/">XMark</a>@) is progressing. For the ODMG 
front-end, there are no release plans, as it is owned by 
@[<a href="http://www.datadistilleries.com">Data Distilleries</a>@.
\\

\item {\em Binary Relational Data Storage:}\\

The Monet database system is the first kernel relying fully on binary (i.e. 2-column) relational 
tables the prime storage scheme for relational and object-oriented datamodels. The most common case
of using these binary tables is to put database values in the right column and system
generated object-identifiers (OIDs) in the left. Monet adds special support for densly
ascending OIDs (e.g. 0,1,2,..) in the form of virtual-OIDs (VOIDs), so at the physical level
Monet's binary tables are almost always unary tables, implemented as arrays, such that 
lookup-by-OID is as simple/cheap as indexing an array.

The first benefit of the forced decomposition of data structures in binary tables is that
the resulting physical vertical fragmentation is beneficial to the I/O and CPU cache
access cost for queries that scan through large volumes of data, but do not look at all
columns (at the same time). In other words, vertcal fragmentation avoid touching
data that you do not want to see anyway, which translates into a more optimal use of
both I/O-memory and memory-cache bandwidth. The second advantage of the binary storage
model is that it allows for column-wise query processing, whose benefits are explained below.
\\

\item {\em BAT Algebra: the RISC approach to Query Languages}\\

Monet's query language is called MIL (Monet Interpreter Language) whose main component
is a BAT algebra. The BAT algebra processes queries column-at-a-time where each operator has
a typically simple built-in semantic and is not steered by any complex parameters (such as
expressions).  As each such individual operator processes typically 1 or 2 columns, its
only degree-freedom are the column types, which is handled in Monet by pre-compiling
a separate implementation for each type-combination. Thus, at database compile-time,
operators have full knowledge of their data processing task, thus giving current
compiler technology a chance in generating object code that is efficient on modern 
hardware (i.e. by avoiding the many hard-to-predict branches caused by interpretative 
code and type-checking, and producing inner-loops of algorithms that provide enough
easily to keep the parallell CPU resources busu and reach a high instruction-per-cycle ratio).

Summarizing, by reducing the complexity of its query algebra to the minimum, Monet 
allows for a much more effcieint implementation, which is similar to the RISC-CISC 
argument in CPU architecture.
\\

\item {\em Cache-Conscious Algorithms}\\

While most hardware components have experienced exponential growth in power over the years 
(a.k.a. Moore's law), I/O and especially memory latency have been lagging, creating an 
exponentially growing {\em memory bottleneck}. This means, that in order to achieve efficiency
database query processing algorithms must have either sequential access (in which
case current machines provide high-bandwidth access to DRAM using hardware prefetching)
or if the access pattern is random, then the total volume of cache-lines touched must be 
well smaller than the cache size. Depending on the architecture, the most 
performance-significant cache is either L1 or L2, and even in the latter cache this
yields a randomly accesible memory of maximally some megabytes. This is a much smaller 
size than a "common" DBMS aims for (as these typically only address the I/O bottleneck).  
A second difference with I/O caching is that the CPU-cache is not fully associative and 
cannot be programmed as cache-replacement happens automatically in hardware with (typically)
a LRU algorithm.

In the @[<a href="../Modules/radix/index.html">radix</a>@ module, you find the basic radix-cluster and 
radix-decluster operations for generic cache-conscious query processing in Monet. Coming
with Monet is also a @[<a href="../Modules/calib/index.html">calibrator module</a>@ that automatically extracts all
relevant hardware characterstics, allowing to make cache-conscious query procssing
work on any platform and configuration. 
\\

\item {\em Main-Memory Orientation:}\\

Given the sizeable memories available in current computer platforms, the focus to gain performance 
in a database setting can is shifting to processing in-memory. As discussed above, hardware changes  
are making memory access a mayor battleground for query optimization, justifying why the Monet
database architecture focuses on it. Notice that a focus on main-memory does not mean that Monet
requires all your data to fit into RAM. Monet stores all persistent data on disk and loads only
into memory that which is needed. Due to the column-wise query processing, only a few columns 
of all tables need to be in memory at a given time. Also, by memory-mapping files into virtual
memory, the amount of open data can easily axceed the amount of RAM. It depends on your access
pattern whether you will be able to avoid excessive I/O swapping. Notice that once your algorithms
are optimized to work well in the L2 cache as discussed above, they will certainly run well in
virtual memory, as random access should be localized to a small region and all other access is 
sequential.

Monet can be compiled both on 32-bits and 64-bits systems. The former systems impose a limit on 
all open data of 2GB or 3GB. In 64-bits systems there is no restriction, though the size of each
indiviudal column is currently limited to 2GB. In a future version of Monet, this restriction will 
be lifted.
\\

\item {\em Cooperative Transaction Management:}\\

Transaction processing is not buried deep into the kernel code, where all users of the database 
have to pay the performance price. Instead, Monet assumes a cooperative environment, where the 
compilers/interpreters produce calls to the basic transaction management primitives
provided by MIL. As such, we have the situation that MIL does not guarantee ACID
properties, but it provides the basic building blocks to do so.

The advantage of this design is that query-intensive applications like data mining and OLAP 
that do not have updates or only periodic bulk updates can considerably improve their performance. 
Secondly, the disentanglement of transaction processing and query execution simplifies the code
and makes it possible to use different transaction managers in different situations.

In the case of the SQL-front-end, we use a transaction manager based on write-ahead-logging (WAL)
in conjuction with virtual memory support that minimizes resource overhead using copy-on-write
sharing of relation images.
\\

\item {\em Portability, Extensibility and Documentation:}\\

Monet is a multi-threaded 32/64 bits executable that built on the POSIX standard (a.o. pthreads).
A minimal compatability layer was added to allow it to work on native Windows compilers (though
building on Cygwin is also possible). A 64-bit version on Windows (Itanium) is under development. 
Most of the code is ANSI C, though some modules are C++. 

The code is configured with the standard GNU tools (autoconf, automake, configure) such that
in principle a build on any Posix platform should be as simple as {\tt ./bootstrap; ./configure; make all install}. 
As Microsoft Windows lacks configure, the Monet distribution comes with pre-built Windows
{\tt monetdb\_config.h}, such that making becomes {\tt cd NT; make; make -f Makefile.msc all install}. 
More details and requirements are explained in the file @[<a href="../../../GetGoing/Setup/MonetDB/Unix/index.html">HowToStart</a>@ (for Unix users)
respectively @[<a href="../../../GetGoing/Setup/MonetDB/Windows/index.html">HowToStart-Win32.txt</a>@ (for Windows users).
Both files are located in the root of the source distribution.

Monet is an open database system that can be extended with new {\bf types} (e.g. point,polygons)
new {\bf operators} (e.g. spatial join) and new {\bf search accelerators} (e.g. R-trees)
bundled in {\bf modules}.  An extension module consists of a @[<a href="../mel/index.html">MEL</a>@ 
(Monet Extension Language) specification and a C or C++ implementation, provided by the programmer.
The @[<a href="../mel/mel-tool/index.html">mel</a>@ tool generates code for registering the new MIL atoms, accelerators 
and operators in the database plus some glue code.  The make system is designed to do all necessary 
work automatically for you provided you write your extension module in the 
@[<a href="http://www.cwi.nl/htbin/ins1/publications?request=pdf&key=KeScBeBo:UNPUBLISHED:96">Mx</a>@
format and put it in the right directory (such as the {\tt src/modules/plain/}).

The Monet code is written using the {\tt @[<a href="http://www.cwi.nl/htbin/ins1/publications?request=pdf&key=KeScBeBo:UNPUBLISHED:96">Mx</a>@}
utility, which follows Knuth's suggestion for literate programming. Mx supports integration source code and documentation
in a simple textual style and document extraction in various formats (tex/html) at 
configurable levels of detail (the "hide levels"). It also provides powerful
macro-expansion facilities, which is heavily used to encode query processing algorithms 
regardless of data type, thus providing a more flexible and powerful form of C++-templates in C.
\\

\item {\em Supported APIs:}\\

The @[<a href="../Modules/mapi/index.html">Monet-API</a>@ is the generic textual API for database
applications that use MIL to access Monet directly. It consists of a basic @[<a href="../../APIs/Mapi/C/index.html">C-library</a>@ that can 
be linked with C/C++ programs and comes with wrappers for use in Java, Python, Perl, PHP and 
Haskell programs.

It should be noted that there is an alternative Monet API in the form of the 
@[<a href="../Modules/tcpip/index.html">tcpip</a>@ module that implement a protocol that allows 
to transport binary images of BATs to clients. This module is also a basic building
block for applications that use a shared-nothing architecture where multiple
Monet servers work together on different machines.

Finally, SQL front-end also comes with an ODBC driver implementation. The SQL supported
by the front-end is a (strong) subset of the SQL-2 standard. The ODBC interface complies with 
ODBC3.0 and is available both on Unix and Windows.
\end{itemize}

@* Using Monet 

As stated before, we assume here you have succesfully built and installed Monet according
to the indications in the file @[<a href="../../../GetGoing/Setup/MonetDB/Unix/index.html">HowToStart</a>@ resp. 
@[<a href="../../../GetGoing/Setup/MonetDB/Windows/index.html">HowToStart-Win32.txt</a>@.

@+ System Utilities
@T
The Monet system consists of the following utilities:
\begin{description}
\item[@[<a href="../../Tools/Mserver/index.html">Mserver</a>@]
	to start a Monet server instance.
\item[@[<a href="../../Tools/MapiClient/index.html">MapiClient</a>@]
	to establish a client-session with command-line history.
\item[@[<a href="../mel/mel-tool/index.html">mel</a>@]
	to parse Monet extension module specifications and generate wrapper and header code.
@'\item[@[<a href="">sql</a>@]
@'	to compile SQL programs into MIL.
\end{description}

@- Environment Variables
@T
There are no Monet-specific environmnet variables (any more).  The paths you want to 
set only have to do with being able to conveniently start the Monet server.\\

After succesfull {\tt make install}, the  Monet binaries are located in the {\tt bin/} 
subdirectory of your installation directory. Unless you are system administrator
and installed in the (default) {\tt /usr/local}, you may find it
convenient to add this {\tt bin/} directory to your {\tt PATH} 
environment variable.\\

If you compiled with dynamic libraries (which is default - but static compilation 
is also possible), the @[<a href="../../Tools/Mserver/index.html">Mserver</a>@ Monet server, depends on a number 
of {\small .so} libraries that need to be found. Therefore, you might need to
this {\tt lib/} directory to your {\tt LD\_LIBRARY\_PATH}.\\

However, in (the most common) case that you compiled Monet yourself, you actually do not 
have to set the library path, as during compilation the prefixed path is compiled
into the executables as the first place to check for libraries.\\ 

Notice that some systems would need other environment variables than {\tt LD\_LIBRARY\_PATH}:
\begin{itemize}
\item Windows requires you to put the location of the {\tt .dll} (not {\tt .so}) 
libraries in the {\tt PATH}.
\item AIX uses {\tt LIBPATH} instead of {\tt LD\_LIBRARY\_PATH}
\item the 64-bit environment on IRIX uses {\tt LD\_LIBRARYN64\_PATH}.
\end{itemize}

@+ MonetDB.conf
@T
Monet is configured by a configuration file named {\tt MonetDB.conf}, whose location FILEPATH
can be specified explicitly on the commandline with {\tt -c FILEPATH} or {\tt -$$-config FILEPATH},
or via the enviroment variable \$MONET\_CONFIG.
If this is not done explicitly, Monet looks for a {\tt MonetDB.conf} in the standard system configuration
directory, i.e., {\tt \<prefix\>/etc/MonetDB.conf}.\\

If you are new to using Monet, you may start with the {\tt \<prefix\>/etc/MonetDB.conf} that
is generated by the {\tt make}, and already contains your compilation
and installation paths. In case you need/want to change the default seetings,
copy it to some place in your home directory, edit it there, and use the {\tt -c}/{\tt -$$-config}
option of Mserver the use your personalized copy of {\tt MonetDB.conf} instead of the default one.\\

In the following, we discuss the file format of {\tt MonetDB.conf} in detail.

@- Server Settings
@T
The below displays the most important settings for the Monet server (@[<a href="../../Tools/Mserver/index.html">Mserver</a>@). \\ 

Notice that all settings in the configuration file can be overriden on the command-line
of @[<a href="../../Tools/Mserver/index.html">Mserver</a>@ with the option {\tt -s option=value} or {\tt -$$-set option=value}.
\begin{verbatim}
prefix=/usr/local
exec_prefix=${prefix}
gdk_dbfarm=${prefix}/var/dbfarm	# origin of the database store
gdk_dbname=demo			# default database to open
gdk_mmap=33554432		# memory chucks of size >= 32M will be mmaped
gdk_debug=0			# debug
monet_prompt=>			# prompt 
monet_welcome=yes		# Version and copyright information
monet_mod_path=${exec_prefix}/lib/MonetDB
monet_deamon=no			# if yes, there is no interactive server console
\end{verbatim}

Most commonly, you would adapt {\tt prefix} to you installation directory,
and {\tt gdk\_dbname} to your most commonly used database instance. This will 
basically enable you to start @[<a href="../../Tools/Mserver/index.html">Mserver</a>@ without any command-line parameters.\\

If {\tt prefix} is set correctly, you will in general not need to adapt 
{\tt exec\_prefix} and {\tt monet\_mod\_path} (where Monet looks for {\tt lib/}
directories with extension modules) anymore.\\

The {\tt gdk\_dbfarm} variable holds the directory in which one or more database
instances can have their data. That is, each database is a subdirectory of the
dbfarm. The name of the database is the name of the subdirectory. Creating
and removing a database is as simple as creating/destroying a directory in the
filesystem, with any utility you like. The {\tt -$$-dbfarm PATH} option of @[<a href="../../Tools/Mserver/index.html">Mserver</a>@,
which expects an {\bf absolute} path {\tt PATH} allows to quickly override the 
{\tt gdk\_dbfarm} from the configuration file. \\

One limitation of this setup is that it currently is not possible to use diskspace
in multiple physical disks in one Monet database. The only workarounds to do this is
either to use RAID (be it hardware or software) to unite multiple disks into
one filesystem, or use a filesystem that explicitly allows multiple physical disks
(like the AIX filesystem).\\ 

The {\tt gdk\_debug} and {\tt gdk\_mmap} options are for expert users only.
They allow to give extensive trace output during MIL execution resp. to
control where bulk memory is allocated from (malloc or virtual memory).\\

Finally, if you do not access @[<a href="../../Tools/Mserver/index.html">Mserver</a>@ interactively or only via the
@[<a href="../../Tools/MapiClient/index.html">MapiClient</a>@, you might want to start @[<a href="../../Tools/Mserver/index.html">Mserver</a>@ as a background daemon,
which means that it won't start a MIL interpreter thread that reads
from {\tt stdin} and outputs to {\tt stdout} and {\tt stderr}.

@- MapiClient Settings
@T
\begin{verbatim}
host=localhost			# the host the server runs on
mapi_port=50000			# default port to address a Mserver
mapi_noheaders=no		# show all the mil output
mapi_debug=0			# The mapi debug level		
\end{verbatim}

The MapiClient tool allows you (and multiple concurrent clients) to 
access an Mserver with MIL, as opposed to the default interpreter that 
Mserver starts on {\tt stdin}/{\tt stdout}/{\tt stderr}. 
MapiClient is slightly more
comfortable to work with as it provides command-line history.\\

Notice that you can only MapiClient into an 
Mserver if the server
has loaded the @[<a href="../Modules/mapi/index.html">mapi</a>@ module and issued a {\tt listen()} command. An example
of how this works will be given below in the interactive MIL session.\\

Suffice it to say now that MapiClient needs to know the machine name and 
TCP port where an Mserver is listening. These options can be given to
MapiClient with the {\tt -h HOSTNAME} / {\tt -$$-host HOSTNAME} and 
{\tt -p PORTNO} / {\tt -$$-port PORTNO} command line options. Default values,
though, can be put in your monet configuration file, such that you will
be able to start MapiClient without command-line parameters.

@- SQL Frontend Settings
@T
\begin{verbatim}
sql_port=45123				#default place to sent the SQL query
sql_debug=0				#default place to sent the SQL query
\end{verbatim}
It is urgently needed to document everything that has to do with the SQL frontend.

@+ Usage Scenario 
@T
In this scenario, we use the 'gold' example of data mining/OLAP access to a car
insurance database, which you can find in the {\tt src/gold/} subdirectory of 
the Monet distribution.  Please consult the README file for all the details.\\

Go to the top-level source directory and do the following (where \$PREFIX is the 
directory where you successfully performed a {\tt make install}).

\begin{verbatim}
$ cd scripts/gold
$ mkdir -p $PREFIX/var/dbfarm/gold
$ export TSTTRGDIR=`pwd`
$ Mserver --dbname=gold < load.mil
$ Mserver --dbname=gold < init.mil
\end{verbatim}

The {\tt load.mil} and {\tt init.mil} are MIL scripts that create database tables and fill
them with the @[<a href="../Modules/ascii_io/index.html">bulk loader</a>@.\\

We then proceed to start a Monet server on the newly created 'gold' database:

\begin{verbatim}
$ Mserver --dbname gold  
# Monet Database Server V4.3.15
# Copyright (c) 1993-2002, CWI. All rights reserved.
# compiled for i686-pc-linux-gnu/32bit; dynamically linked.
monet>
\end{verbatim}

Monet answers with a prompt, waiting for MIL commands.\\

We now load the modules {\tt @[<a href="../Modules/mapi/index.html">mapi</a>@} (client MIL access) and {\tt @[<a href="../Modules/xtables/index.html">xtables</a>@}
(for cross-tabulation):

\begin{verbatim}
> module(xtables,mapi); 
> fork(listen(45678));
\end{verbatim}

The {\tt @[<a href="../Modules/mapi/index.html">listen(port)</a>@} command from the {\tt @[<a href="../Modules/mapi/index.html">mapi</a>@} module starts a client
listener. As this command blocks, it is executed as a parameter to {\tt @[<a href="../Modules/kernel/index.html#mod_2_3_1">fork()</a>@}
which forks off a separate MIL client that runs in the background.

We now open a new window and start the @[<a href="../../Tools/MapiClient/index.html">MapiClient</a>@ telling it to connect
to the same port number we passed to {\tt @[<a href="../Modules/mapi/index.html">listen()</a>@} on the local machine. This
will establish a MIL session with the Monet server, so we get a prompt:

@[<a name="ls">@;
\begin{verbatim}
$ MapiClient --host localhost --port 45678
> ls;
#-------------------------------------------------------------------------------------------------------#
# name          | htype | ttype | count | heat  | dirty         | status| kind  | refcnt| lrefcnt       #
#-------------------------------------------------------------------------------------------------------#
[ "car_age",      "oid",  "int",  100000, 0,      "clean",        "disk", "pers", 0,      1,            ]
[ "car_carprice", "oid",  "int",  100000, 0,      "clean",        "disk", "pers", 0,      1,            ]
[ "car_gender",   "oid",  "chr",  100000, 0,      "clean",        "disk", "pers", 0,      1,            ]
[ "car_category", "oid",  "str",  100000, 0,      "clean",        "load", "pers", 0,      1,            ]
[ "car_class",    "oid",  "str",  100000, 0,      "clean",        "load", "pers", 0,      1,            ]
[ "car_town",     "oid",  "str",  100000, 0,      "clean",        "load", "pers", 0,      1,            ]
[ "car_neg",      "oid",  "str",  50000,  0,      "clean",        "disk", "pers", 0,      1,            ]
[ "car_pos",      "oid",  "str",  50000,  0,      "clean",        "disk", "pers", 0,      1,            ]
>
\end{verbatim}
A common command is {\tt @[<a href="../Modules/sys/index.html#mod_2_1_0">ls()</a>@} which lists all persistent BATs. You can pass a 
string parameter that restricts the list to BATs whose names start with that string (so, {\tt ls("car");} would
have given the same result in the example of the car insurance example database). 
There is also a similar command {\tt  @[<a href="../Modules/sys/index.html#mod_2_1_0">dir()</a>@} which lists {\em all} BATs instead 
of only the persistent ones.\\ 

The {\tt ls();} showed that the car insurance table consists of 7 attributes ({\tt age}, {\tt carprice}, {\tt category},
{\tt class}, {\tt gender}, and {\tt town}) that have been vertically fragmented in 7 persistemt ({\tt "pers"}) BATs of 
type {\tt BAT[oid,any]}, which all have 100,000 elements, are clean (have not been updated), and of which the latter 
3 are loaded into memory. Additionally, tjere are sub-bats {\tt car_pos} and {\tt car_neg} that hold materialized results
of selection on the {\tt car_class} BAT those customers that have resp. have nt cause accidents, which is a 50-50 split
in this case.

Now for some querying:
\begin{verbatim}
> car_town.histogram.print;
#-------------------------#
# BAT:            tmp_31  #
# (str)           (int)   #
#-------------------------#
[ "new york",     9990    ]
[ "dallas",       10071   ]
[ "atlanta",      9946    ]
[ "los angeles",  9962    ]
[ "boston",       9965    ]
[ "san diego",    10098   ]
[ "detroit",      9943    ]
[ "washington",   10064   ]
[ "houston",      9951    ]
[ "miami",        10010   ]
>
>help("histogram");
COMMAND:   histogram(BAT[any,any::2]) : BAT[any::2,int]
MODULE:    algebra
COMPILED:  by adm on Mon Oct  7 11:22:49 2002
Produce a BAT containing the histogram of the tail values.
 bat.histogram() ::= {count}(bat.reverse)
>
\end{verbatim}
The above shows a histogram on the town where the car owners live, together with  the on-line
help on the histogram command. 

A more difficult query would ask for the counts of all car owners in Boston grouped by class
and category (in SQL: {\tt select count(*) from car where town = 'boston' group by class, category}):

\begin{verbatim}
> print(car_class,car_category,car_town.uselect("boston").mirror.join(car_class).CTgroup(car_category).reverse.{count});
#---------------------------------------------------------#
# BAT:            car_class     | car_category  | tmp_39  #
# (void)          (str)         | (str)         | (int)   #
#---------------------------------------------------------#
[ 5@0,            "damage",       "nolease",      3875    ]
[ 67@0,           "damage",       "lease",        1114    ]
[ 50003@0,        "no damage",    "lease",        995     ]
[ 50025@0,        "no damage",    "nolease",      3981    ]
>
\end{verbatim}

In order to understand what this does, you are advised to read the 
@[<a href="../../FrontEnds/mil/index.html">MIL Reference Manual</a>@ first, and to study
the following help texts:

\begin{verbatim}
> sigs("xtables");
#------------------------------------------------------#
# signature                                            #
#------------------------------------------------------#
[ ...                                                  ]
[ "CTgroup(BAT[oid,any], BAT[oid,any]) : BAT[oid,oid]" ]
[ ...                                                  ]
>
> help("CTgroup");
COMMAND:   CTgroup(BAT[oid,any], BAT[oid,any]) : BAT[oid,oid]
MODULE:    xtables
COMPILED:  by adm on Mon Oct  7 11:22:50 2002
binary grouping; a synonym for CTderive(ct,attr)
>
> help("mirror");
COMMAND:   mirror(BAT[any::1,any]) : BAT[any::1,any::1]
MODULE:    bat
COMPILED:  by adm on Mon Oct  7 11:22:49 2002
Returns the head-mirror image of a BAT (two head columns).
>
> help("uselect");
COMMAND:   uselect(BAT[any::1,any::2], any::2) : BAT[any::1,void]
MODULE:    algebra
COMPILED:  by adm on Mon Oct  7 11:22:49 2002
Value select, but returning only the head values.
 SEE ALSO: select(bat,val)
>
> help("join");
COMMAND:   join(BAT[any::1,any::2], BAT[any::2,any::3]) : BAT[any::1,any::3]
MODULE:    algebra
COMPILED:  by adm on Mon Oct  7 11:22:49 2002
Returns all BUNs, consisting of a head-value from 'left' and
a tail-value from 'right' for which there are BUNs in 'left'
and 'right' with equal tail- resp. head-value (i.e. the join
columns are projected out).
>
\end{verbatim}

Finally, the MIL session is closed with a {\tt  @[<a href="../Modules/kernel/index.html#mod_2_3_1">quit</a>@}:

\begin{verbatim}
>quit;
\end{verbatim}

This concludes our quick tour of Monet.

@* Memory Management in Monet 
@T
This section documents some of the memory tuning options in the @[<a href="../../Tools/Mserver/index.html">Mserver</a>@. It is intended for 
experienced Monet users, how have studied and worked with @[<a href="../../FrontEnds/mil/index.html">MIL</a>.

@+ The Bat Buffer Pool (BBP)
@T
The BBP is the pool of BATs in existence in a Monet database. The BAT buffer pool may keep a BAT cached in memory 
or cold on disk. BATs may have three modes: 
\begin{description}
\item[{\tt persistent}] may be cached in RAM but always resides on disk permanently.
\item[{\tt transient}] may be cached in RAM or reside on disk until the end of the @[<a href="../../Tools/Mserver/index.html">Mserver</a>@ session. However,
as soon as the BAT ceases to have any references pointing to it, it is freed from RAM and removed from disk.
\item[{\tt session}] like a transient BAT. However, if a session bat does not have any references it may be kept
cached in RAM until the end of the @[<a href="../../Tools/Mserver/index.html">Mserver</a>@ session, if there is room in the BBP cache. The BBP uses 
a LRU algorithm to unload/destroy BATs when space is needed.
\end{description}
The BAT mode is set with the {\tt @[<a href="../Modules/bat/index.html#mod_2_0_5">persists</a>@} command. Session-BATs can 
be released  in the cache with {\tt @[<a href="../Modules/bat/index.html#mod_2_0_5">release(BAT):lng</a>@} that returns an 
identifier that can later be used to speculatively trying to retrieve it again with 
{\tt @[<a href="../Modules/bat/index.html#mod_2_0_5">resurrect(lng):BAT</a>@} command.

The {\tt @[<a target="_self" href="#ls">ls()</a>@} and {\tt @[<a target="_self" href="#ls">dir()</a>@} 
commands list three kinds of references individually for each BAT:

\begin{description}
\item[{\tt refcnt}] 
these are in-memory reference counts. If a MIL algebra command is executing,
it manipulates the BAT as an in-memory data structure. It must be prevented that these BATs are swapped 
out by the BBP while the command is running. Therefore, before entering such an algebra command,
the MIL interpreter increases the reference counts of its BAT parameters, and after leaving it reduces them.

\item[{\tt lrefcnt}] 
logical reference counts may be either MIL variables with a BAT value, or nested BATs (BATs of BATs that contain values).
A logical reference will not prevent a BAT from being unloaded, but will prevent it from being destroyed.
Making a BAT persistent, will increment its lrefcnt by one (and making it transient decreses it by one).
\end{description}

The BBP LRU policy is steerable by applications using the {\tt @[<a href="../Modules/bat/index.html#mod_2_0_5">hot(BAT)</a>@} and
{\tt @[<a href="../Modules/bat/index.html#mod_2_0_5">cold(BAT)</a>@} commands that decrease resp. increase the likelyhood that
a BAT is unloaded when Monet is in need of resources.

@+ Memory Limitations
@T
Modern OSs all implement virtual memory, which means that there is more system memory available than the 
RAM alone: the extra space is provided by a {\em swap-file}. 

Virtual memory space can be used by programs 
either using some malloc library (for small blocks) or using a direct virtual memory interface for 
coarse-grained access. On Windows, the latter is provided by the {\tt VirtualAlloc()} family of calls (short: valloc),
while on Posix this is done by memory mapping on the special file {\tt /dev/zero}. A feature that this
valloc brings over malloc is that it is possible to claim in advance large virtual memory
spaces, without committing the memory yet (i.e. without consuming RAM+swap-file). As such, it allows
to allocate growing contiguous ranges of memory, without risk that an reallocation-in-place fails (until the 
reserved limit is reached).

Additionally, modern OSs implement {\em memory-mapped} files. A memory mapping adds a file to the virtual memory, 
without necessarily consuming RAM nor space swap-file, as it uses the file itself to swap itself onto.\\

On a 32-bit OS, the total amount of addressable memory is between 2 and 4GB. Modern 64-bits OSs implement
a 48-bits virtual memory which has a maximum address space of 240TB. As such, in 2002 it is easy to
construct a system that is limited by the 32-bit address barrier (as you can easily exceed 4GB by buying
some RAM+swap-file), whereas a 64-bits OS is limited only by its physical resources (RAM+swap-file).\\

Summarizing, there are three kinds of memory, that all consume virtual memory address space, but:
\begin{description}
\item[{\tt malloc}]
consumes space in RAM+swap-file. 
\item[{\tt valloc}]
consumes space in RAM+swap-file, and allows reservation of not-yet-committed contiguous ranges.
\item[{\tt mmap}]
does not consume RAM+swap-file. A variant of is {\em privately mapped} files, that is modifyable and only
consume RAM+swapfile space for those pages that have been modified (i.e. it guarantees that the underlying
file is left intact by any modification).
\end{description}

By default BAT heaps are allocated 
from RAM+swapfile. Whether the space is taken from malloced memory or from valloc is determined
by comparing the heap-size to the {\tt gdk_mmap} threshold in the monet configuration file.  

BATs are allocated from memory mapped memory only if that has been requested explicitly with the 
{\tt @[<a href="../Modules/bat/index.html#mod_2_0_6">mmap()</a>@} command. For each of the possibly five heaps,
a {\tt STORE\_MEM} or {\tt STORE\_MMAP} can be specified. Whether Monet uses normal memory
mapped files or {\em privately} mapped files depends on the {\tt @[<a href="../Modules/bat/index.html#mod_2_0_3">access()</a>@}
mode of the BAT (only {\tt BAT\_WRITE} leads to privately mapped files).\\

@+ Memory Tuning
@T
In Monet, which materializes all BATs, it is possible to crash the server by asking too much memory:
\begin{verbatim}
# crash any 32-bits system (or a 64-bits system with available RAM+swap-file < 4GB)
b1 := bat(void,chr,2000000000); 
b2 := bat(void,chr,2000000000); 
\end{verbatim}

In the future, we will fix this behavior by reporting an error instead of a crash. Confronted with
such a problem, however, one should first determine the cause of the lack of memory. On well-equipped 
32-bits systems, the problem tends to be the 2-4GB address space limit, whereas any lack of memory on 
a 64-bits system is due to lack of resources. \\

Most memory resource problems in Monet are easily avoidable by minimizing your open BAT
references (as discussed above) and making you access patterns cache friendly (see the 
@[<a href="../Modules/radix/index.html">radix module</a>@. Additionally, you are able to tune the 
buffer management policy of Monet to the capabilities of your hardware platform
as described in the following.\\

Monet provides two tuning thresholds that steer the beavior of the BBP LRU algorithm:
\begin{description}
\item[mem] the physical resource limit.  The maximum is set with 
{\tt @[<a href="../Modules/sys/index.html#mod_2_0_1">mem_maxsize(lng)</a>@} command, where the default
is 80 percent of the RAM+swap-file size of the system. The current usage of physical resources
can be retrieved with {\tt @[<a href="../Modules/sys/index.html#mod_2_0_1">mem_curize():lng</a>@}.
\item[vm] the virtual memory address space consumption limit.  The maximum is set with 
{\tt @[<a href="../Modules/sys/index.html#mod_2_0_1">vm_maxsize(lng)</a>@} command, where the default
is 80 percent of the RAM+swap-file size of the system. The current usage of virtual address
space can be retrieved with {\tt @[<a href="../Modules/sys/index.html#mod_2_0_1">vm_curize():lng</a>@}.
\end{description}

A particular problem that can occur on 32-bits systems is when it seems that the virtual address
space is not yet exhausted, but an allocation of some large block fails anyway.  This tends 
to be caused by {\em virtual address space fragmentation} and can be monitored with
{\tt @[<a href="../Modules/sys/index.html#mod_2_0_1">mem_printmap():lng</a>@}. Other commands of interest
are {\tt @[<a href="../Modules/sys/index.html#mod_2_0_1">mem_usage(lng minsize) : BAT[str,lng]</a>@} 
and {\tt @[<a href="../Modules/sys/index.html#mod_2_0_1">vm_usage(lng minsize) : BAT[str,lng]</a>@} 
that give detailed overviews of where the various kinds of memory are used.

Debug-mask 4 causes regular printing of memory resource consumption. It can either be set
from the {\tt @[<a href="../../../monet-compiled/etc/MonetDB.conf">MonetDB.conf</a>@} file, the
@[<a href="../../Tools/Mserver/index.html">Mserver</a>@ command line, or while running with
the @[<a href="../Modules/kernel/index.html#mod_2_4_2">debugmask()</a>@ operator. 

@* Copyright Notice
@T
{\small\begin{verbatim}
/*
 * The contents of this file are subject to the MonetDB Public
 * License Version 1.0 (the "License"); you may not use this file
 * except in compliance with the License. You may obtain a copy of
 * the License at
 * http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
 * 
 * Software distributed under the License is distributed on an "AS
 * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
 * implied. See the License for the specific language governing
 * rights and limitations under the License.
 * 
 * The Original Code is the Monet Database System.
 * 
 * The Initial Developer of the Original Code is CWI.
 * Portions created by CWI are Copyright (C) 1997-2004 CWI.
 * All Rights Reserved.
 * 
 * Contributor(s):
 * 		Martin Kersten <Martin.Kersten@cwi.nl>
 * 		Peter Boncz <Peter.Boncz@cwi.nl>
 * 		Niels Nes <Niels.Nes@cwi.nl>
 * 		Stefan Manegold  <Stefan.Manegold@cwi.nl>
 */

\end{verbatim}}
