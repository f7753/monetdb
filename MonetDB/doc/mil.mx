@f mil
@t MIL: Monet Interpreter Language 
@a Peter Boncz
@d 18/11/1997
@T 
@* Introduction
@T
This document is a user manual for MIL. It is intended to be read by 
frontend developers, or application programmers that want to program 
in MIL directly, instead of passing through frontend translation. \\
Beware that MIL's primary function is an {\bf intermediate language},
with only little  syntactic sugar added.

@* Screws and Bolts of the Language
@T
Some general rules:
\begin{itemize}
\item upper- and lower case does matter. 
\item all MIL keywords, however,
are accepted in both total upper case and total lower case (but not in
mixed-case). 
\item white space can be entered between all keywords, punctuation
and atomic values.
\item comments start with the '\#' character and continue till the next 
newline.
\end{itemize}

@+ Value Types
@[<a name="type_doc">@
@T
MIL is a dynamically typed language. That is, variables can change of
value {\em and} type during execution. Operations and procedures may
return different types on different invocations.
@

@- Atomic Types
@T
\begin{itemize}
\item {\tt void}\\
values that are no values. Occupies 0 space.
You will normally never found individual {\tt void} values,
but they can occur inside tables as a zero-width column. 
Their meaning in that context is explained in the section on 
@[<a target="\_self" href="\#mod\_4\_0\_0"><bf>Virtual OIDs<bf></a>.@
\item {\tt bit}\\
boolean values being either {\tt true} or {\tt false}.
\item {\tt chr}\\
character values, denoted like 'c' (standard) or '$\backslash$001' (octal).
\item {\tt sht}\\
short integers; in general represented as 16 bit integers.
Since normal MIL uses standard integer notation for the INT type, 
short constant values must always be formulated as a cast: {\tt sht(42)}. 
\item {\tt int}\\
normal integer values. Use 32-bit representation.
\item {\tt oid}\\
unique numerical identifiers. The next section discusses them in detail.

\item {\tt ptr}\\
integer-sized pointers.
\item {\tt flt}\\
standard floating point numbers. Use 32-bit representation.
\item {\tt dbl}\\
double floats. Like SHT, DBL values have to be cast always 
({\small\tt dbl(12.5)}), since the MIL parser uses floating point
notation already for FLT .
\item {\tt lng}\\
long integers, normally represented on machines as
64-bit integers.  Again, you have to do casts ({\small\tt lng(1200089)}.
\item {\tt str}\\
strings, using standard string notation:
e.g. {\small\tt "hello world"}.
\item {\tt bat}\\
Binary Association Table ({\bf BAT}) values. Contain a collection of two-ary 
tuples, called {\bf BUN}s (Binary UNits). The left value in a BUN
is called the {\bf head}, the right one {\bf tail}. Head-type and Tail-type
determine the extact type of a BAT (its signature). Since the tuples can 
be of any type, recursive types are possible (that is, you can make BATs 
that contain BATs).
\end{itemize}
@
On the syntax level in MIL, we @%always abbreviate BAT types@ as @#bat@,
omitting the signature. For textual signature descriptions, throughout this
document (and in the @[<a href="mel.html">Monet Extension Language</a>@),
we abbreviate BAT signatures at the first level: e.g. @#BAT[OID,BAT]@. This 
is pure pragmatics, in order to preserve simplicity.
@T
Below we display an example BAT. This one has signature {\small\tt BAT[OID,STR]}.
It has OIDs in the heads, and strings in the tail. It contains five BUNs:
{\small\begin{verbatim}
#--------------------------#
# head       | tail        #
#--------------------------#
[ 1788@0,     "Martin"     ]
[ 1639@0,     "Arjan"      ]
[ 4309@0,     "Niels"      ]
[ 8145@0,     "Wilko"      ]
[ 7540@0,     "Sunil"      ]
\end{verbatim}}

More information about BATs is available in the 
@[<a href="WWWROOT/gdk/gdk/5/HEAP\_index\_index.html">technical documentation of GDK</a>@.

@- Type Identifiers 
In MIL, type identifiers {@#void,bit,sht,int,bat,oid,ptr,flt,dbl,lng,str@}
are just synonyms for integer type numbers. Just try @#int.print;@
it will display an integer value. Type numbers may change over time
(see the @[<a href="mel.html">Monet Extension Language</a>@),
and can be looked up from their corresponding strings in the BAT 
@\#monet\_atomtbl@:
@-
@T
{\small\begin{verbatim}
# Monet Database Server V3.05
# Copyright (c) 1993-1996, CWI & UvA.  # All rights reserved.
#
# You are system administrator (adm)!
>monet_atomtbl.print;
#-----------------#
# h       | t     #
#-----------------#
[ "void",  0      ]
[ "bit",   1      ]
[ "chr",   2      ]
[ "sht",   3      ]
[ "bat",   4      ]
[ "int",   5      ]
[ "oid",   6      ]
[ "ptr",   7      ]
[ "flt",   8      ]
[ "dbl",   9      ]
[ "lng",   10     ]
[ "str",   11     ]
>
\end{verbatim}}

@- Type Casts
@T
Values of all numerical types can be cast to each other using 
'TYPE(expression)' notation (e.g. {\small\tt int(13.5)}).
@-
@T
Not all types can sensibly be cast to each other, of course.
Especially casting numerical types to BATs is {\bf strongly disapproved}.

Values of each type can always be created from their {\em string
description}. So a 'TYPE(STR)' cast is guaranteed to exist for any type
(e.g. {\small\tt point("0.345,4.78 : 0.89,1.274")} might convert a string 
to a GIS extension 2D point atom). 
This is especially useful for {\em extension types} (see 'Loading and
Dropping Extension Modules'), which -- since they are user created --
do not have any special syntax support in MIL.

@- NIL values
@T
Each type has one special value called the NIL value. NIL values of
any type can be described by TYPE(nil) (e.g. {\small\tt flt(nil)}).  The
'nil' keyword itself denotes an VOID-typed NIL. Most commands will give
error messages if such a nil-value is passed to them, as a parameter.

@- Unique OIDs
@T
OIDs are special kinds of unsigned integers because the system
guarantees unicity. They have the form   number@stamp. Currently,
OIDs are implemented as 32-bit numbers, where the   stamp part
are the highest two bits, and the   number part occupies the rest
of the OID.

A Monet server stamps each OID it generates with its own database-ID. By 
using Monet servers with different database-IDs, cross-system OID 
unicity can be ensured.

Although OIDs should be generated with the command 
{\tt @[<a href="WWWROOT/modules/kernel/8/newoid\_index.html">newoid(INT range):OID</a>@} to ensure their uniqueness, you 
can also enter OIDs by hand for debugging purposes.

You just type a number closed with an 'at' sign, e.g.  {\small\tt 12345\@},
which specifies the OID {\small\tt 12345\@STAMP}, where {\small\tt STAMP} is the 
current database ID. You can also specify the stamp (e.g. 2) specifically 
yourself by typing {\small\tt 12345\@2}. 

@- Search Accelerator Identifiers 
@T
With {\em search accelarators} we mean:
\begin{itemize}
\item special {\em data structures}, 
\item {\em attached to a column of a table}, i.e. head or tail of a BAT.
\item {\em maintained under table updates} by the database automatically.
\end{itemize}
All decent database systems maintain such structures, often called
{\em indices}. They are used for speeding up database operations, like
select and/or join. Famous examples are {\bf hash-tables, B-trees, R-trees, 
Grid-files}, etc.\\
Whereas these structures are vital to the efficiency of many database
operations, they do not play a big role on the user interface level.
MIL just has, very similar to type identifiers, a set 
of {\em accelerator-identifiers}.

@-
These accelerator identifiers serve to identify a specific 
search accelarator, and are used by the @%search accelerator management@
commands, that can be found in the 
@[<a href="stdlib/bat/index.html">BAT standard module</a>@.

@-
Just like the set of type-identifiers, these identifiers are just synonyms for
integer accelerator numbers (just try typing @#hash.print;@). And just like 
the set of type-identifiers, this set can change over time 
(see the @[<a href="mel.html">Monet Extension Language</a>@),
and their mapping to strings can be looked up in system BAT by the name of 
@\#monet\_acctbl@:
@T
{\small\begin{verbatim}
# Monet Database Server V3.05
# Copyright (c) 1993-1996, CWI & UvA.  # All rights reserved.
#
# You are system administrator (adm)!
>monet_acctbl.print;
#-----------------#
# h       | t     #
#-----------------#
[ "hash",   1     ]
[ "index",  2     ]
\end{verbatim}}
The {\small\tt\bf hash} identifier stands for Monet's built-in bucket-chained 
hash-tables. The {\small\tt\bf index} identifier stands for Monet's built-in 
binary search trees. 


@+ Expressions
@T
Values can be computed with MIL by formulating {\em expressions}:
\begin{itemize}
\item {\tt constant}\\
Constants as described above, are the simplest form of expressions
(examples: {\small\tt true} (bit), {\small\tt 42} (integer), {\small\tt 3.14} (float), 
"foo" (string)).

\item {\tt TYPE(expr)}\\
Expressions can be cast to other types, as described in the previous section
(e.g. {\small\tt sht(42)} (short), {\small\tt lng(42)} (long), {\small\tt dbl(3.14)} (double)).

\item {\tt (expr)}\\
Enclosing parentheses are useful, sometimes even necessary tools, to 
specify unambiguous MIL expressions.

\item {\tt ident}\\
Variables (possibly constant variables) are denoted by identifiers --
consisting of alphanumerical characters or underscores, starting with
a letter. See the next section on how to create variables.
In addition to user-created variables, the names of the set of 
{\bf persistent BATs} in the database are valid 'implicit variables',
having as values the persistent BATs of the database.

\item {\tt ident := expr}\\
Assignment: put a value in a MIL variable (e.g. {\small\tt answer := 42}). If the 
variable did not exist yet, it is created on the fly in the current block 
(see the 'Statements' section on MIL blocks and on how to declare 
variables explicitly);

\item {\tt ..$\backslash$ident}\\
'de-scoping' a variable: if you override a variable name by explictly creating 
a variable with the same name in an nested block (see the 'Statements'
for blocks) e.g. {\small\tt var a:=1; \{ var a:=2; print(a); \}}, giving result: [2],
then you can still reach the underlying variable by doing 
{\small\tt var a:=1; \{ var a:=2; print(..$\backslash$a); \}}, with result: [1].
Concatenated de-scope sequences like {\small\tt ..$\backslash$..$\backslash$..$\backslash$} are possible.

\item {\tt command}\\
MIL accepts a set of {\bf algebraic commands} (for instance: {\small\tt dir}). This 
set of commands may be changed over time (see  'Loading and Dropping Extension Modules'). Simple algebraic commands do not have
parameters, just do something, and return a value (maybe a VOID).

You may also have defined a procedure (see below in the 'Procedures'
section) as a piece of MIL script. There is no syntactical difference 
in using normal commands and MIL procedures.\\

{\small{\bf Name conflicts:} because we allow this parentheses-less notation 
for commands (like {\small\tt dir}), you must take care that you don't try to define 
variables of procedures with the same name as any existing command or MIL 
keyword ({\small\tt dir := "directory"}), because syntax errors will then occur!!}

\item {\tt command(expr, ..expr.. ) }\\
Algebraic commands may also have parameters, which are expressions
themselves, yielding values after execution (e.g. {\small\tt join(a,b)}). 
Values are passed in, execution takes place, a result value comes out. \\

MIL uses command-overloading: it can select different command
implementations, depending on the number of parameters and their actual
types. A command can be either a Builtin Command (discussed at the
end of this document), a command introduced by loading a module 
(see the Standard Modules), or a user-defined PROC (procedure, 
expressed in MIL). Syntactically, there is no difference.\\

{\small{\bf Command resolution:} both commands and procs are 
checked in reverse order of definition (i.e. last defined gets checked 
first), and the first match of formal parameters with actual 
parameters is accepted (return types are not taken into account 
during command resolution, since MIL is a dynamically 
typed language anyway).}

\item {\tt expr.command(expr, ..expr.. )}\\
This 'object-oriented' syntax is supported for algebraic commands
( e.g. {\small\tt a.join(b)}).
The first parameter is like the 'object', and may be placed in front
using dot notation. This is just a synonym for the normal command
invocation notation (see previous point), no special semantics are 
involved.

\item {\tt expr binary-operator expr}\\
Operators are just algebraic commands that can also be used in 
infix notations (you may do both {\small\tt +(1,2)} and {\small\tt 1 + 2}).\\
Note that each binary operator (in our example {\tt +}) is a
command, but not each command is a binary operator!\\
{\small{\bf Operator precedence:} MIL does not have anything like that:
use parentheses in compound operator expressions!!}

\item {\tt unary-operator expr}\\
Not only binary, but also unary prefix operator notation can be allowed
for certain commands ({\small\tt - 3.14} is a command invocation, {\small\tt -3.14} 
isn't).\\ 

\item 
{\tt (* string-expr)(expr, ..expr..)}\\
Invokes a command by means of its name. Command resolution will take place
at execution time. For instance: {\tt\small (* "join")(b1,b2);}.
For multiplexed operatiions and set aggregates (see later), MIL 
has similar using the 
{\small\tt [* string-expr](expr, ..expr..)} notation (multiplex)
and the
{\small\tt \{* string-expr\}(expr)} notation (set aggregate).
\end{itemize}

@+ Statements
@T
Interaction with an {\small\tt\bf Mserver} takes the form of a client
session, that is defined as a sequence of {\em statements}:
\begin{itemize}

\item {\tt expr;}\\
Statements are formed by putting a semicolon after an expression.

\item {\tt \{ statement ..statement.. \}}\\
A {\em sequential block} specifies sequential execution
of a concatenation of statements {\small\tt \{ e := 2.7; pi := 3.14; \}}.\\

\item \begin{verbatim}{| statement ..statement.. |}\end{verbatim}
A {\em parallel block} specifies that a collection of statements
can be executed in parallel. The parallel block terminates execution,
when all statements in it have terminated execution. Example:
\begin{verbatim}{| join(a1,b1); join(a2,b2); join(a3,b3); |}\end{verbatim}
\item {\tt VAR ident, ...ident..;}\\
Variables may be declared (e.g. {\small\tt var pi,e;}). Their lifetime is the 
execution of the nearest block (sequential, parallel) in which they were 
declared. If a variable is declared at the top-level; its lifetime is the MIL
session.

\item {\tt VAR ident := expr, ..ident-declaration..;}\\
Variables may be assigned a value directly in their declaration
(e.g. {\small\tt var pi := 3.14, e := 2.7;}).

\item {\tt CONST ident := expr;}\\
This declares a constant variable. Its type and value cannot
be changed (e.g. {\small\tt const pi := 3.14;}).

\item {\tt IF (BIT-expr) statement  ELSE statement}\\
Standard if-then-else semantics, using C-style (for example:
{\small\tt if (a $<$ 18) print("kid"); else print("adult")});

\item {\tt IF (BIT-expr) statement }\\
The ELSE part may be omitted. 

\item {\tt WHILE(BIT-expr) statement}\\
A simple while-loop construction. The BIT expression is
tested, on FALSE the loop stops, and on TRUE the statement 
is executed and we loop to a new BIT expression evaluation
({\small\tt \{ var i := 0; while((i := i + 1) $\leq$ 10) i.print; \} }).

\item {\tt BAT \@ ITERATOR(expr, ..expr.. ) statement}\\
Iterate over the elements of a BAT. For each element, the statement
is executed. The symbols \$h and \$t (or: \$head and \$tail) can occur 
as variables in the statement, and denote resp. the head- and tail-value 
of the current BUN. \\
We give an example with {\small\tt batloop()} iterator that sequentially loops through all BUNs in 
a BAT[int,int] named 'ints', and prints the sum of all heads and tails: 
{\small\tt ints@batloop() print( \$h + \$t);}.

\item {\tt BAT @ [INT-expr] ITERATOR(expr, ..expr.. ) statement}\\ 
The same as above, except that the statement execution
may now occur {\em in parallel} on multiple 'current elements' at the
same time. The INT-expression denotes the maximum degree of
parallelism (which is desirable, since BATs can contain billions of
elements). \\
We give an example with a recursive BAT[BAT,BAT] containing 
combinations of fragments that have to be joined with each other.
The statement 
{\small\tt fragments@ [16] batloop() join(\$h, \$t);}
will join them in parallel, with a maximum number of 16 jobs in parallel at the same time.\\
\end{itemize}

During program execution, the status of variables can dynamically be 
changed  using the built-in commands 
{\tt @[<a href="WWWROOT/modules/kernel/8/constant\_index.html">constant(..IDENT..)</a>@} 
and
{\tt @[<a href="WWWROOT/modules/kernel/8/freeze\_index.html">freeze(..IDENT..)</a>@}. 

@- Exceptions
@T
Exception-raising commands and how they are caught.
\begin{itemize}
\item {\em any syntax error} will raise an error exception. These 
exceptions cannot be caught by the user. The MIL interpreter will 
stop the interpretation on the active session; and start to wait for
new input.

\item {\tt ERROR(STR format, ANY...);}\\
On demand, we wan also synthetically raise an error exception.
This call produces an error message, much like in C-printf() format, like:
{\small\tt ERROR("you entered \%d foos too many$\backslash$n", foo);}
{\footnotesize (see: CMDERROR())}

\item BREAK;\\
This statement makes MIL quit the nearest enclosing WHILE loop, 
or ITERATOR immediately ({\small\tt while(bool) \{ .. BREAK; .. \}} resp.
{\small\tt b@batloop() \{ .. BREAK; .. \}}).\\
If a command used in {\em Multiplex Operator} form (see below) stops with a 
BREAK, this will cause that the result BAT will have *no* result tuple 
for that execution. Multiplex Operator execution will continue with the next
BUN, however. 
\end{itemize}

@+ Procedures
Users can quickly prototype functionality using the MIL procedure 
mechanism. They follow the same signature overloading mechanism as MIL
applies for its built-in algebraic operators and commands.
@T
\begin{itemize}
\item {\tt PROC ident ( type ident, ..type ident..) := statement}\\
Declare a MIL-procedure. Its definition is a simple MIL statement, in
which the parameter identifiers may appear as variables. The types
from the signature follow the same rules as found in MEL signature
definitions: all atomic MIL types are called by name, BATs are parametrized
(between square brackets: {\tt\small bat[htpe,ttpe]}) with a head-type and a 
tail-type, and the special typename {\tt\small any} indicates a wildcarded type.
Like in MEL, an any-type may have a {\em tag-number} using {\small\tt any::1}
in order to make multiple any-types match (using the same tag-number).
A signature may end with a special sequence {\small\tt ..type..}, 
indicating a variable number of arguments. In case of {\tt\small ..any..}
these arguments may be of any type, but you may be more restrictive.

The parameters may also be omitted in the declaration, in which case
MIL assumes {\tt\small ..any..}; the actual
parameters during execution always still are available with positional
arguments \$1, \$2, \$3,... (unix shell script style).

As of now, you cannot indicate a return type in a PROC signature
(MIL just defaults it to a {\tt\small any} return value).

\item {\tt PROC ident; }\\
If recursion is applied, you need to do a forward declaration of the
procedure, in order for the MIL interpreter to be able to recognize it
correctly.

\item {\tt UNDEF ident; }\\
Undefine a MIL-procedure.
\end{itemize}

PROCs cannot be viewed once they have been parsed. You should store them
yourself in some text-file. Maybe your \$DBDIR/users/\$USER is a good place 
for that, since MIL scripts placed there can easily be read in (see 'source()').
PROCs cannot be made persistent either. You can, however,
put them in your {\small\tt\bf monet.prelude} file, in order to define them
automatically at the start of your Monet sessions.\\
Monet procedures are not typed. You can use them just as another MIL command.
The signature of a procedure hence is that of a command with a variable
number of ANY parameters, returning an ANY value. \\

@- Variable Arguments
@T
For handling variable numbers of arguments in PROCs, the following
special positional arguments are available:
\begin{itemize}
\item {\tt \$0} denotes the number of actual parameters (argument count). 
\item {\tt \$(INT-expr)} references the {\em i-th} actual parameter, where 
{\em i} is given by an integer expression. 
\item {\tt \$(INT-expr..)} can be used as a parameter to another function call,
it actually stands for multiple parameter values. In this way, you can pass 
'the rest' of the received parameters in a procedure to a another
command. For example: \\
{\small\tt proc printf(format) := \{ fprintf(stdout, format, \$(2..)); \} } \\
passes parameter 2-till-the-end of {\small\tt printf} to a call to {\small\tt fprintf}.
If there is only one parameter, the \$(2..) will expand to 0 parameters
without giving an error.\\
Note that in the procedure definition of {\small\tt printf} parameter 2-till-the-end
are not named as formal parameters; still all actual parameters (if any) are 
still available with the positional parameter syntax \$X, \$(X) and \$(X..). 
\end{itemize}

@* Relational Table Support 
@[<a name="special\_doc">@
@T
The relational and Object-orient data-models provide support for 
objects and tables with more than two columns, as provided in Monet.
The way to go about this, is to map the n-ary data model \{ A1,...,An \}
on {\em n} decomposed tables \{ {\small\tt BAT[OID,A1]} .. {\small\tt BAT[OID,An]}\}.

These sets of BATs, and possibly their derivates (sub-sets, used 
during query processing) semantically describe {\em different} parts of the 
{\em same} database objects. Their OID columns make them correspond.\\

@+ Support For Corresponding BATs 
@T
Since this situation is very common, Monet provides special support
for corresponding BATs, typically resulting in the following 
three cases:
\begin{itemize}
\item {\em natural join}. Monet normally must do a natural join
on the OID columns, to find out which attribute values in the BATs 
correspond. Though quick hash-lookups are used, this is relatively 
expensive.\\
\item {\em sorted  BATs}. A common strategy is to keep the different
BATs ordered on the OID column. Cheap merge-algorithms, and binary-search 
lookup, can then be used, even if the one BAT is a subset of the others.\\
\item {\em synced BATs}. For BAT-sets that contain exactly the same sets 
of OIDs, those OID-columns can be marked {\small\tt synced()}. This information 
is then used to use positional lookup (the i-th  element in BAT1 corresponds with the i-th in BAT2) and to turn semijoin- into very cheap copy-operations, etc.
\end{itemize}
This special information (sorted, synced) about BATs is automatically
kept up-to-date by Monet across updates, and propagated to derived BATs, 
where appropriate (a select on a sorted BAT produces a sorted subset BAT).
The special operators in this section (as well as much of the algebraic 
commands in the standard modules) use this information to accelerate
processing.\\

@- Command Signature Notation 
@T
{\em In {\tt command} signature definitions throughout this document, 
we will use @[<a href="mel.html">MEL (Monet Extension Language)</a>@ syntax:
\begin{itemize}
\item {\bf\tiny COMMAND} {\tt command-name}({\small TYPE name, ...VARARGTYPE...}) : {\small RETURNTYPE}
\end{itemize}
If the TYPE is {\small\tt ANY}, this denotes any possible MIL type.}\\


@- Example: value printing
@T
\begin{itemize}
\item {\bf\tiny COMMAND} {\tt print}({\small ANY})
\end{itemize}
The {\small\tt print} command is used to print values. It will put
them on the standard output and enclose them in square brackets.\\
{\em The RETURNTYPE is omitted here; this means that a VOID value is 
returned.}

\begin{itemize}
\item {\bf\tiny COMMAND} {\tt print}({\small BAT[ANY::1, ANY], ..BAT[ANY::1,ANY]..})
\end{itemize}
This second version of {\small\tt print} has a variable number of arguments
of type {\small\tt BAT}.\\
{\em ANY types can be tagged with a number like {\small\tt ANY::2}, in order 
to indicate that certain ANY types correspond with other ANY types.}\\
In this case, the command signature states that the head columns of all its
BAT parameters are of the same type.  The {\small\tt print()} command
prints an N-ary table (where N = \#arguments+1), consisting of the 
equality join of all BATs on the left column (head column), with all 
head columns projected out except the leftmost one. This
produces a [Head,Attr1,Attr2,...AttrN] ASCII table on standard output:

{\small{\begin{verbatim}
print( #----------#  ,  #---------------#  );  ==>  #--------------------# 
       # h  | age #     # h   | name    #           # oid | age | name   #
       #----------#     #---------------#           #--------------------#
       [ 1,   24  ]     [ 1,   "Niels"  ]           [ 1,   24,  "Niels"  ] 
       [ 2,   38  ]     [ 2,   "Martin" ]           [ 2,   38,  "Martin" ]
       [ 3,   27  ]     [ 3,   "Arjan"  ]           [ 3,   27,  "Arjan"  ] 
       [ 4,   27  ]     [ 4,   "Fred"   ]           [ 4,   27,  "Fred"   ]
       [ 5,   27  ]     [ 5,   "Wilko"  ]           [ 5,   27,  "Wilko"  ] 
\end{verbatim}
{\center\em BAT Printing Example, and its result on Standard Output}}

The BAT ordering and syncing interfaces can be found in the 
@[<a href="stdlib/bat.">BAT standard module</a>@. 


@+ Multiplex Operators
@T
Multiplex Operators execute commands for a set of 'objects' (in their 
Monet representation) on their different 'attributes' (i.e. a set of BATs).
For each command or procedure with signature:
\\
{\center\bf\tt COMMAND(type1,...,typeN) : typeR}
\\
there automatically exists its Multiplex Operator equivalent with signature:
\\
{\center\bf\tt [COMMAND](BAT[type0,type1],...,bat[type0,typeN]) 
: BAT[type0,typeR]}
\\
It applies the command operation on all tail values (corresponding by
equal head value), and stores the single return value in the tail of
the return BAT (along with the corresponding head value).
Note that this means that the multiplex operation computes
the {\bf natural join} on equal head values of all its BAT parameters.

{\begin{verbatim}
#----------#   [+]   #----------#   =   #----------# 
# h   | t  #         # h   | t  #       # h   | t  #
#----------#         #----------#       #----------#
[ 1,   2   ]         [ 1,   1   ]       [ 1,   3   ] 
[ 2,   1   ]         [ 2,   1   ]       [ 2,   3   ]
[ 3,   4   ]         [ 3,   1   ]       [ 3,   5   ] 
[ 4,   2   ]         [ 4,   2   ]       [ 4,   4   ]
[ 5,   2   ]         [ 5,   2   ]       [ 5,   4   ] 
\end{verbatim}
{\center\em Multiplex Operator Example: using the numerical '+' operator (arith module)}}

\begin{itemize}
\item All parameter head types should be equal or void
\item The values fed into the command invocations are 
obtained by taking the tail values of the corresponding BUNs.
\end{itemize}

If you want a constant parameter to be given to each command invocation,
instead of a tail-value from some BAT, you can pass a BAT cast (see the 
next section) as a parameter, or just a constant (e.g.  '42'). 
In the case of a constant value of type {\bf BAT}, you must use BAT cast 
notation (e.g. '[A\ ,\ const B]') to avoid confusion.

@- Multiplexing a Dereferenced String
@T
It is possible to use a string dereferencing of a command, operator,
or proc as the function in a multiplex operator:  
{\small\tt [*fcn-expr](..params..)}.

@+ Set Aggregates
@T
Set aggregates are the MIL language construct
        {\small\tt \{Y\}(bat-expr)}
that allow you to to interpret a
        {\small\tt bat[ht,tt]}
as      $S$
a set of collections of {\small\tt tt} values, defined as
        $S = \{ set_{h} | [h,t] \in bat\}$
in which
        $set_{h} = \{ t | [h,t] \in bat\}$
are bags/sets of tail values.
\\
The {\small\tt Y()} is a {\bf read-only} unary BAT command
        {\small\tt Y(bat[tt,any]) : rt}
or
        {\small\tt Y(bat[any,tt]) : rt}
that ignores the contents of the {\em any} column.
\\
The {\bf set-aggregate} version of {\small\tt Y}, denoted in MIL\\
        {\center\small\tt \{Y\}(bat[ht,tt]) : bat[ht,rt]} \\
is defined as\\
        {\center$\{ [h,r] | [h,t] \in bat \wedge r = \mbox{\small\tt Y}(set_{h})\}$ }
@T
The {Y}() language constructor is orthogonal, and works with all
commands, builtins, procs, dereferenced address variables. 
Dereferenced variables (as obtained with {\small\tt fcn = \&sum}) are
called using the syntax {\small\tt \{*fcn\}($bat-expr$)}. 
\\
To clarify it all, we give an example of the use of the
{\small\tt sum()} operator, that normally sums the tails of one BAT,
as a set aggregate {\small\tt \{sum\}()}.
@T
{\begin{verbatim}
{sum} ( #-----------#   )   =   #-----------# 
        # h   | t   #           # h   | t   #
        #-----------#           #-----------# 
        [ 1,   20.0 ]           [ 1,   70.0 ]
        [ 1,   10.0 ]           [ 2,   40.0 ]
        [ 1,   40.0 ]         
        [ 2,   20.0 ]         
        [ 2,   20.0 ]
\end{verbatim}

@- implementation issues
The set-aggregate implementation will not be very efficient in
its generic form, because it implies translating one command into
N calls to some operator that needs a unary BAT. When N is very large,
and the assembled BATs are small, the assembling and call-overhead
will be substantial.
@-
Power users are therefore requested to overload their much-used set-
aggregates Y by {Y}() user-defined commands that have the same semantics.
@-
Optimization is attempted when the BAT is sorted on head. The assembling
ob sub-BATs can then be saved out. Further savings in this branch are made
when we can reach the unpacked implementation of the Y operator. Only in
this case, the set-aggregates will perform to Monet's potential.



@+ BAT Casts [A,B]
The BAT cast operator allows you to enter constant values into
columns:
@T
{\begin{verbatim}
[  #---------------#  ,  "Monet User"  ]  =   #-------------------#
   # h   | t       #                          # h  | t            #
   #---------------#                          #-------------------#
   [ 1,   "Martin" ]                          [ 1,  "Monet User"  ]
   [ 2,   "Fred"   ]                          [ 2,  "Monet User"  ]
   [ 3,   "Niels"  ]                          [ 3,  "Monet User"  ]
   [ 4,   "Arjan"  ]                          [ 4,  "Monet User"  ]
   [ 5,   "Sunil"  ]                          [ 5,  "Monet User"  ]
\end{verbatim}
{\center\em BAT Cast Example: Inserting a constant value in a column}}

\begin{itemize}
\item {\tt [BAT[type0,type1]\ ,\ CONST type2] : BAT[type0,type2]}\\
produces a BAT that is synced with its two parameters, with the same head 
column as the first param, and the same constant value (second parameter) in
the tail.

Similarly, you can put the constant left of the '\ ,\ ', and the BAT to 
its right.

\item {\tt [ \ ,\ BAT[type0,type2] ] : BAT[VOID,type2]}\\
is equal to {\tt [nil \ ,\ BAT[type0,type2] ]}.
\item {\tt [BAT[type0,type1] \ ,\ ] : BAT[type0,VOID]}\\
is equal to {\tt [BAT[type0,type2]\ ,\ nil]}.
\item {\tt [BAT[type0,type1]\ ,\  BAT[type2,type3]] : BAT[type0,type2]}\\
The two parameters must be synced. The result consists of the head column of
the first BAT, and the head column of the second BAT. This is of course
especially useful for reconstructing BATs with a void column to a full 
binary BAT.

\end{itemize}

@+ BAT conditional [A?B:C]
@T
{\begin{verbatim}
[  #----------#  ?  #---------#  :  #---------#  ] =  #--------#
   # h  | t   #     # h  | t  #     # h  | t  #       # h  | t #
   #----------#     #---------#     #---------#       #--------#
   [ 1,  true ]     [ 1,  1   ]     [ 1,  3   ]       [ 1,  1  ]
   [ 2,  true ]     [ 2,  1   ]     [ 2,  3   ]       [ 2,  1  ]
   [ 3,  true ]     [ 3,  1   ]     [ 3,  5   ]       [ 3,  1  ]
   [ 4,  false]     [ 4,  2   ]     [ 4,  4   ]       [ 4,  4  ]
   [ 5,  false]     [ 5,  2   ]     [ 5,  4   ]       [ 5,  4  ]
\end{verbatim}
{\center\em BAT Conditional Example: set-wise if-then-else}}

\begin{itemize}
\item 
Here we have a BAT A with BITs in the tail. The C and B BATs must be 
synced with A, or may be constants with the const keyword. The head-types 
of all BATs must be equal or void. B and C must have the same tail-types.
\item 
The result is a BAT with the head-type of all BATs, and the tail-type of A a
nd B. It contains for each BUN in A, where the tail-value is TRUE, the corresponding A value for each BUN in A where the tail-value is FALSE, the tail 
value of B.
\item
A or B may be omitted, in which case no result BUNs are produced for either
TRUE or FALSE values in A.
\item
A or B may be be constant values; for instance {\small\tt [A?B:const "no damage"]}
will produce B tuples where the A tail is TRUE, and tuples with 
{\small\tt "no damage"} in the tail.
\item
In the case of non-BAT values, the const keyword may be omitted for shortness.
\end{itemize}

@* Virtual OIDs
@T
The {\small\tt VOID} in MIL is like a {\small\tt V-OID}, or {\bf virtual oid}. 
A virtual oid column in a BAT is an OID column, which has the restriction
that it must contain a {\bf dense sequence} of OID numbers. That is,
it contains a sequence of N numbers from base 'base': [base,base+1,base+2..,base+N-1].
Such columns {\bf need zero bytes of memory space}; 
the BAT just contains the base number, and the OID values are then
computed on the fly by adding the BUN position (row-id) to it.

A second restriction is that only one column in a BAT can be a virtual oid
(i.e. not both head and tail can be VOID). 

VOID columns can be created using the {\tt\small{\bf [,B].copy}}
{\em bat projection}. It creates a view on top of B, in which the left 
column seems to be missing; when you print it, all head values are {\tt nil}.
Another way of creating a BAT with a VOID column is to use  
@[<a href="WWWROOT/modules/bat/8/new\_index.html"><tt>new(VOID,T)</tt></a>@.
This willl yield an empty BAT with a VOID head column.
@-
You need to activate the VOID column in a BAT created by hand by specifying a 
base OID of your choice.  This can be done with the command 
@[<a href="WWWROOT/modules/bat/8/seqbase\_index.html"><tt>bat[VOID,T].<bf>seqbase</bf>(oid)</tt></a>@.

@+ Operations on BATs with a VOID column
@T
Any MIL operation that can be executed on a BAT with OIDs can also 
be executed on a BAT with virtual OIDs. The result type will 
automatically be converted to OID, if necessary. Only when from the 
semantics op the MIL command it is known that it will again return a 
BAT with dense OIDs, the return BAT will also have a virtual oid column.

@- Less Storage
@T
The great advantages of virtual oids lie there were tables are very
big. Not having to store the OID for each item in a BAT in means at
least a 50\% reduction in space needs. At least 50\% because alignment
restrictions of the hardware in general make it more (most systems 
enforce OIDs to be stored on 4 byte memory addresses). This means that
a BAT[OID,CHR] containing a 4-byte OID and a 1-byte character takes 
4 + 1 = 8 bytes in storage per tuple. A BAT[VOID,CHR]
takes only one byte of storage; an improvement of a factor 8!

@- Query Optimization
@T
Most MIL commands just don't see the difference between OID and VOID
columns. Only in some specific, but important, cases, Monet makes use
of the specific features of a VOID: lookup on OID number can be very 
efficient, since you need to do nothing more
than subtract the base number in order to know the position of
a BUN. For instance, the 
{\small\tt\bf @[<a href="WWWROOT/modules/algebra/8/find\_index.html">bat[VOID,T].find(oid) : T</a>@}
will use positional lookup. 

Similar optimizations have been made in the 
{\small\tt\bf @[<a href="WWWROOT/modules/algebra/8/semijoin\_index.html">semijoin</a>@}
and 
{\small\tt\bf @[<a href="WWWROOT/modules/algebra/8/join\_index.html">join</a>@}
when one of the join columns is virtual
oid. The same goes for the 
{\small\tt\bf @[<a href="WWWROOT/modules/algebra/8/select\_index.html">select</a>@}
operation when the selection column is a virtual oid.

@- The Update Problem
@T
The only real troubles arise when a BAT with a VOID column is updated: 
\begin{itemize}
\item Insertions do not cause real troubles; they just add a new value at 
the end of a BAT. Note that the  
{\small\tt\bf @[<a href="WWWROOT/modules/bat/8/insert\_index.html">bat[VOID,T].insert(VOID,T)</a>@}
ignores the VOID parameter. It will append the bun {\tt [base+N, T]} to
the BAT no matter which head value you passed. It is ignored.
\item Updates and deletes a BAT with VOID column are forbidden. 
Monet keeps the BATs in memory as a {\em contiguous array} of values.
This means that when e.g. an element in the middle is deleted, its place
must be taken by another one. In the VOID column, this would cause a 
{\em remapping} of OID values (where remapping is actually a synonym for 
'corruption'). 
\end{itemize}

@+ Related Extension Modules 
Two @[<a href="mel.html">MEL</a>@ extension modules are related
to handling BATs with VOID columns:

@- Multi-Attribute Module
@T
The append-only semantics of BATs with void columns would restrict their
use to a very limited number of applications.  
The 
{\bf @[<a href="extlib/multi/index.html">Multi-Attribute Module</a>@} 
introduces special techniques that make updateable void BATs possible in
a context of supporting multi-attribute object storage with vertical 
fragmentation over void BATs. 

This module provides the best of all worlds: query execution
with positional oid-access using void BATs, clustered value-access
using inversion lists, and efficient transactions to manage updates.

The way it works is like this: deletes on void BATs are delayed and only 
sporadically executed (only once in many transactions), so remapping of 
OIDs is tractable. Updates are done by simply overwriting the old value in
the void BAT. This would obstruct transaction management, but by overloading 
the update interface it still is provided, by storing old values out-of-line.
The trick is that inversion-lists that are handy for speeding up 
selections are re-used in the transaction management scheme. 
Inversion-lists are sporadically resorted, and hence retain old
values, that are needed for implementing transaction abort.

The module introduces full update operations, transaction support,
and overloaded versions of select and uselect that use the inversion-list
when beneficial (on high selectivities). 


@- Automatic Enumeration Types
@T
In the past, we refrained from compressing sparse usage of e.g. 4-byte types 
like INT or STR, because alignment restrictions on the OID stored in the
head column would spoil the gains anyway. Now with VOID BATs, the case 
is different.

If you store domains in the tail of void BATs that have less that 65535
or 255 different values, you can reduce storage to 2 or 1 byte per element
by remapping your domain in a specific enumeration type.  
This functionalityis providen by the
{\bf @[<a href="extlib/enum.html">Enumeration Type Module</a>@} 
that can create new data types on the fly, and reduce the storage of your 
columns to CHR- or SHT-sized fields. 
