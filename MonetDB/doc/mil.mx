@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@' 
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@' 
@' The Original Code is the Monet Database System.
@' 
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2003 CWI.
@' All Rights Reserved.
@' 
@' Contributor(s):
@' 		Martin Kersten <Martin.Kersten@cwi.nl>
@' 		Peter Boncz <Peter.Boncz@cwi.nl>
@' 		Niels Nes <Niels.Nes@cwi.nl>
@' 		Stefan Manegold  <Stefan.Manegold@cwi.nl>

@f mil
@t MIL: Monet Interpreter Language
@a Peter Boncz
@d October 1, 2002
@v 1.1
@T
@* Introduction
@T
This document is a user manual for MIL. It is intended to be read by
frontend developers, or application programmers who want to program
in MIL directly instead of passing through frontend translation. \\
Beware that MIL's primary function is an {\bf intermediate language},
with only little  syntactic sugar added.

@* Screws and Bolts of the Language
@T
Some general rules:
\begin{itemize}
\item upper- and lower case matters.
\item all MIL keywords, however,
are accepted in both total upper case and total lower case (but not in
mixed-case).
\item white space can be entered between all keywords, punctuation
and atomic values.
\item comments start with the '\#' character and continue until the
end of the line.
\end{itemize}

@+ Value Types
@[<a name="type_doc">@
@T
MIL is a dynamically typed language. That is, variables can change
value {\em and} type during execution. Operations and procedures may
return different types on different invocations.
@

@- Atomic Types
@T
\begin{itemize}
\item {\tt void}\\
values that are no values. Occupies 0 space.
You will normally never find individual {\tt void} values,
but they can occur inside tables as a zero-width column.
Their meaning in that context is explained in the section on
@[<a target="_self" href="#void"><bf>Virtual OIDs<bf></a>.@
\item {\tt bit}\\
boolean values being either {\tt true} or {\tt false}.
\item {\tt chr}\\
character values, denoted like 'c' (standard) or '$\backslash$001' (octal).
\item {\tt sht}\\
short integers; in general represented as 16 bit integers.
Since normal MIL uses standard integer notation for the INT type,
short constant values must always be formulated as a cast: {\tt sht(42)}.
\item {\tt int}\\
normal integer values. Uses 32-bit representation.
\item {\tt oid}\\
unique numerical identifiers. The next section discusses these in detail.

\item {\tt ptr}\\
pointers. Seldomly used. Some volatile representations (like stream pointers
in the @[<a href=www/modules/streams.html">io</a>@ module) use it as data representation.
This datatype may not be used in persistent BATs.  Its size is that of
{\tt int} on 32-bit platforms and that of {\tt lng} on 64-bit platforms.
\item {\tt flt}\\
standard floating point numbers. Uses a 32-bit representation.
\item {\tt dbl}\\
double floats. Like {\tt sht}, {\tt dbl} values have to be cast always
({\small\tt dbl(12.5)}), since the MIL parser uses floating point
notation already for FLT .
\item {\tt lng}\\
long integers, normally represented on machines as
64-bit integers.  In this case the special {\tt LL} syntax can be used
after integers to denote longs ({\small\tt 1200089LL}.
\item {\tt str}\\
strings, using standard string notation:
e.g. {\small\tt "hello world"}.
\item {\tt bat}\\
Binary Association Table ({\bf BAT}) values. Contain a collection of two-ary
tuples, called {\bf BUN}s (Binary UNits). The left value in a BUN
is called the {\bf head}, the right one {\bf tail}. Head-type and Tail-type
determine the exact type of a BAT (its signature). Since the tuples can
be of any type, recursive types are possible (that is, you can make BATs
that contain BATs).
\end{itemize}
@
On the syntax level in MIL, we @%always abbreviate BAT types@ as @#bat@,
omitting the signature. For textual signature descriptions, throughout this
document (and in the @[<a href="mel.html">Monet Extension Language</a>@),
we abbreviate BAT signatures at the first level: e.g. @#BAT[OID,BAT]@. This
is pure pragmatics, in order to preserve simplicity.
@T
Below we display an example BAT. This one has signature {\small\tt BAT[OID,STR]}.
It has OIDs in the heads, and strings in the tail. It contains five BUNs:
{\small\begin{verbatim}
#--------------------------#
# head       | tail        #
#--------------------------#
[ 1788@0,     "Martin"     ]
[ 1639@0,     "Arjan"      ]
[ 4309@0,     "Niels"      ]
[ 8145@0,     "Wilko"      ]
[ 7540@0,     "Sunil"      ]
\end{verbatim}}

More information about the internal layout of BATs is available in the
@[<a href="www/gdk.html#mod_1_3_0">technical documentation of GDK</a>@.

@- Type Identifiers
In MIL, type identifiers {@#void,bit,sht,int,bat,oid,ptr,flt,dbl,lng,str@}
are just synonyms for integer type numbers. Just try @#int.print;@
it will display an integer value. Type numbers may change over time
(see the @[<a href="mel.html">Monet Extension Language</a>@),
and can be looked up from their corresponding strings in the
BAT @#monet_atomtbl@:
@-
@T
{\small\begin{verbatim}
# Monet Database Server V4.3.15
# Copyright (c) 1993-2003, CWI. All rights reserved.
# compiled for i686-pc-linux-gnu/32bit; dynamically linked.
monet>monet_atomtbl.print;
#-----------------#
# h       | t     #
#-----------------#
[ "void",  0      ]
[ "bit",   1      ]
[ "chr",   2      ]
[ "sht",   3      ]
[ "bat",   4      ]
[ "int",   5      ]
[ "oid",   6      ]
[ "ptr",   7      ]
[ "flt",   8      ]
[ "dbl",   9      ]
[ "lng",   10     ]
[ "str",   11     ]
>
\end{verbatim}}

@- Type Casts
@T
Values of all numerical types can be cast to each other using
'TYPE(expression)' notation (e.g. {\small\tt int(13.5)}).
@-
@T
Not all types can sensibly be cast to each other, of course.
Especially casting numerical types to BATs is {\bf strongly discouraged}.

Values of each type can always be created from their {\em string
description}. So a 'TYPE(STR)' cast is guaranteed to exist for any type
(e.g. {\small\tt point("0.345,4.78 : 0.89,1.274")} might convert a string
to a GIS extension 2D point atom).
This is especially useful for {\em extension types} (see 'Loading and
Dropping Extension Modules'), which -- since they are user-created --
do not have any special syntax support in MIL.

@- NIL values
@T
Each type has one special value called the NIL value. NIL values of
any type can be described by TYPE(nil) (e.g. {\small\tt flt(nil)}).  The
'nil' keyword itself denotes a VOID-typed NIL. Most commands will give
error messages if such a nil-value is passed to them as a parameter.
@-
In sorting, it is convention that the NILs appear first.

@- Unique OIDs
@T
OIDs are special kinds of unsigned integers because the system
guarantees unicity. They have the form   number@stamp. Currently,
OIDs are implemented as 32-bit numbers, where the   stamp part
consists of the highest two bits, and the   number part occupies the rest
of the OID.

A Monet server stamps each OID it generates with its own database-ID. By
using Monet servers with different database-IDs, cross-system OID
unicity can be ensured.

Although OIDs should be generated with the command
{\tt @[<a href="www/modules/kernel.html#mod_2_2_0">newoid(INT range):OID</a>@} to ensure their uniqueness, you
can also enter OIDs by hand for debugging purposes.

You just type a number closed with an 'at' sign, e.g.  {\small\tt 12345\@},
which specifies the OID {\small\tt 12345\@STAMP}, where {\small\tt STAMP} is the
current database ID. You can also specify the stamp (e.g. 2) specifically
yourself by typing {\small\tt 12345\@2}.

@- Search Accelerator Identifiers
@T
With {\em search accelerators} we mean:
\begin{itemize}
\item special {\em data structures},
\item {\em attached to a column of a table}, i.e. head or tail of a BAT.
\item {\em maintained under table updates} by the database automatically.
\end{itemize}
All decent database systems maintain such structures, often called
{\em indices}. They are used for speeding up database operations, like
select and/or join. Famous examples are {\bf hash-tables, B-trees, R-trees,
Grid-files}, etc.\\
Whereas these structures are vital to the efficiency of many database
operations, they do not play a big role on the user interface level.
MIL just has, very similar to type identifiers, a set
of {\em accelerator-identifiers}.

@-
These accelerator identifiers serve to identify a specific
search accelerator, and are used by the @%search accelerator management@
commands, that can be found in the @[<a href="www/modules/bat.html">BAT module</a>@.

@-
Just like the set of type-identifiers, these identifiers are just synonyms for
integer accelerator numbers (just try typing @#hash.print;@). And just like
the set of type-identifiers, this set can change over time
(see the @[<a href="mel.html">Monet Extension Language</a>@),
and their mapping to strings can be looked up in system BAT by the name
of @#monet_acctbl@:
@T
{\small\begin{verbatim}
# Monet Database Server V4.3.15
# Copyright (c) 1993-2003, CWI. All rights reserved.
# compiled for i686-pc-linux-gnu/32bit; dynamically linked.
monet>monet_acctbl.print;
#-----------------#
# h       | t     #
#-----------------#
[ "hash",   1     ]
[ "index",  2     ]
\end{verbatim}}
The {\small\tt\bf hash} identifier stands for Monet's built-in bucket-chained
hash-tables. The {\small\tt\bf index} identifier stands for Monet's built-in
binary search trees.


@+ Expressions
@T
Values can be computed with MIL by formulating {\em expressions}:
\begin{itemize}
\item {\tt constant}\\
Constants as described above, are the simplest form of expressions
(examples: {\small\tt true} (bit), {\small\tt 42} (integer), {\small\tt 3.14} (float),
{\small\tt "foo"} (string)).

\item {\tt TYPE(expr)}\\
Expressions can be cast to other types, as described in the previous section
(e.g. {\small\tt sht(42)} (short), {\small\tt lng(42)} (long), {\small\tt dbl(3.14)} (double)).

\item {\tt (expr)}\\
Enclosing parentheses are useful, sometimes even necessary tools, to
specify unambiguous MIL expressions.

\item {\tt ident}\\
Variables (possibly constant variables) are denoted by identifiers --
consisting of alphanumerical characters or underscores, starting with
a letter. See the next section on how to create variables.
In addition to user-created variables, the names of the set of
{\bf persistent BATs} in the database are valid 'implicit variables',
having as values the persistent BATs of the database.

\item {\tt ident := expr}\\
Assignment: put a value in a MIL variable (e.g. {\small\tt answer := 42}). If the
variable did not exist yet, it is created on the fly in the current block
(see the 'Statements' section on MIL blocks and on how to declare
variables explicitly);

\item {\tt ..$\backslash$ident}\\
'de-scoping' a variable: if you override a variable name by explicitly creating
a variable with the same name in an nested block (see the 'Statements'
for blocks) e.g. {\small\tt var a:=1; \{ var a:=2; print(a); \}}, giving result: [2],
then you can still reach the underlying variable by doing
{\small\tt var a:=1; \{ var a:=2; print(..$\backslash$a); \}}, with result: [1].
Concatenated de-scope sequences like {\small\tt ..$\backslash$..$\backslash$..$\backslash$} are possible.

\item {\tt command}\\
MIL accepts a set of {\bf algebraic commands} (for instance: {\small\tt dir}). This
set of commands may be changed over time (see 'Loading and Dropping Extension Modules').
Simple algebraic commands do not have parameters, just do something, and return a value
(maybe a VOID).

You may also have defined a procedure (see below in the 'Procedures'
section) as a piece of MIL script. There is no syntactical difference
in using normal commands and MIL procedures.\\

{\small{\bf Name conflicts:} because we allow this parentheses-less notation
for commands (like {\small\tt dir}), you must take care that you don't try to define
variables or procedures with the same name as any existing command or MIL
keyword ({\small\tt dir := "directory"}), because syntax errors will then occur!!}

\item {\tt command(expr, ..expr.. ) }\\
Algebraic commands may also have parameters, which are expressions
themselves, yielding values after execution (e.g. {\small\tt join(a,b)}).
Values are passed in, execution takes place, a result value comes out. \\

MIL uses command-overloading: it can select different command
implementations, depending on the number of parameters and their actual
types. A command can be either a Builtin Command (discussed at the
end of this document), a command introduced by loading a module
(see the Extension Modules), or a user-defined PROC (procedure,
expressed in MIL). Syntactically, there is no difference.\\

{\small{\bf Command resolution:} both commands and procs are
checked in reverse order of definition (i.e. last defined gets checked
first), and the first match of formal parameters with actual
parameters is accepted (return types are not taken into account
during command resolution, since MIL is a dynamically
typed language anyway).}

\item {\tt expr.command(expr, ..expr.. )}\\
This 'object-oriented' syntax is supported for algebraic commands
( e.g. {\small\tt a.join(b)}).
The first parameter is like the 'object', and may be placed in front
using dot notation. This is just a synonym for the normal command
invocation notation (see previous point), no special semantics are
involved.

\item {\tt expr binary-operator expr}\\
Operators are just algebraic commands that can also be used in
infix notations (you may do both {\small\tt +(1,2)} and {\small\tt 1 + 2}).\\
Note that each binary operator (in our example {\tt +}) is a
command, but not each command is a binary operator!\\
{\small{\bf Operator precedence:} MIL does not have anything like that:
use parentheses in compound operator expressions!!}

\item {\tt unary-operator expr}\\
Not only binary, but also unary prefix operator notation can be allowed
for certain commands ({\small\tt - 3.14} is a command invocation, {\small\tt -3.14}
isn't).\\

\item
{\tt (* string-expr)(expr, ..expr..)}\\
Invokes a command by means of its name. Command resolution will take place
at execution time. For instance: {\tt\small (* "join")(b1,b2);}.
For multiplexed operations and set aggregates (see later), MIL
has similar syntax using the
{\small\tt [* string-expr](expr, ..expr..)} notation (multiplex)
and the
{\small\tt \{* string-expr\}(expr)} notation (set aggregate).
\end{itemize}

@+ Statements
@T
Interaction with an @[<a href="www/Mserver.html">Mserver</a>@ takes the form of a client
session, that is defined as a sequence of {\em statements}:
\begin{itemize}

\item {\tt expr;}\\
Statements are formed by putting a semicolon after an expression.

\item {\tt \{ statement ..statement.. \}}\\
A {\em sequential block} specifies sequential execution
of a concatenation of statements {\small\tt \{ e := 2.7; pi := 3.14; \}}.\\

\item \begin{verbatim}{| statement ..statement.. |}\end{verbatim}
A {\em parallel block} specifies that a collection of statements
can be executed in parallel. The parallel block terminates execution
when all statements in it have terminated execution. Example:
\begin{verbatim}{| join(a1,b1); join(a2,b2); join(a3,b3); |}\end{verbatim}
\item {\tt VAR ident, ...ident..;}\\
Variables may be declared (e.g. {\small\tt var pi,e;}). Their lifetime is the
execution of the nearest block (sequential, parallel) in which they were
declared. If a variable is declared at the top-level; its lifetime is the MIL
session.

\item {\tt VAR ident := expr, ..ident-declaration..;}\\
Variables may be assigned a value directly in their declaration
(e.g. {\small\tt var pi := 3.14, e := 2.7;}).

\item {\tt CONST ident := expr;}\\
This declares a constant variable. Its type and value cannot
be changed (e.g. {\small\tt const pi := 3.14;}).

\item {\tt IF (BIT-expr) statement  ELSE statement}\\
Standard if-then-else semantics, using C-style (for example:
{\small\tt if (a $<$ 18) print("kid"); else print("adult")});

\item {\tt IF (BIT-expr) statement }\\
The ELSE part may be omitted.

\item {\tt WHILE(BIT-expr) statement}\\
A simple while-loop construction. The BIT expression is
tested, on FALSE the loop stops, and on TRUE the statement
is executed and we loop to a new BIT expression evaluation
({\small\tt \{ var i := 0; while((i := i + 1) $\leq$ 10) i.print; \} }).

\item {\tt BAT \@ ITERATOR(expr, ..expr.. ) statement}\\
Iterate over the elements of a BAT. For each element, the statement
is executed. The symbols \$h and \$t (or: \$head and \$tail) can occur
as variables in the statement, and denote the head- and tail-value
of the current BUN respectively. \\
We give an example with {\small\tt batloop()} iterator that sequentially
loops through all BUNs in
a BAT[int,int] named 'ints', and prints the sum of all heads and tails:
{\small\tt ints@batloop() print( \$h + \$t);}.

\item {\tt BAT @ [INT-expr] ITERATOR(expr, ..expr.. ) statement}\\
The same as above, except that the statement execution
may now occur {\em in parallel} on multiple 'current elements' at the
same time. The INT-expression denotes the maximum degree of
parallelism (which is desirable, since BATs can contain billions of
elements). \\
We give an example with a recursive BAT[BAT,BAT] containing
combinations of fragments that have to be joined with each other.
The statement
{\small\tt fragments@ [16] batloop() join(\$h, \$t);}
will join them in parallel, with a maximum number of 16 jobs in parallel at the same time.\\
\end{itemize}

During program execution, the status of variables can dynamically be
changed  using the built-in commands
{\tt @[<a href="www/modules/kernel.html#mod_2_2_1">constant(..IDENT..)</a>@}
(which fixes value and type) and
{\tt @[<a href="www/modules/kernel.html#mod_2_2_1">freeze(..IDENT..)</a>@}
(which fixes only the type).

Also, the {\tt vars()} command produces a table of all active variables
in the current context:
\begin{verbatim}
> vars;
#-----------------------------------------------------------------------------------------#
# type                  | type  | type_status   | value_status  | value_value             #
#-----------------------------------------------------------------------------------------#
[ "b",                    "BAT",  "liquid",       "variable",     "<tmp_23>"              ]
[ "monet_atomtbl",        "BAT",  "frozen",       "variable",     "<monet_atomtbl>"       ]
[ "BAT_WRITE",            "int",  "frozen",       "constant",     "0"                     ]
[ "BAT_APPEND",           "int",  "frozen",       "constant",     "2"                     ]
[ "BAT_READ",             "int",  "frozen",       "constant",     "1"                     ]
[ "BUF_DONTNEED",         "int",  "frozen",       "constant",     "4"                     ]
[ "BUF_WILLNEED",         "int",  "frozen",       "constant",     "3"                     ]
[ "BUF_SEQUENTIAL",       "int",  "frozen",       "constant",     "2"                     ]
[ "BUF_RANDOM",           "int",  "frozen",       "constant",     "1"                     ]
[ "BUF_NORMAL",           "int",  "frozen",       "constant",     "0"                     ]
[ "STORE_COMPR",          "int",  "frozen",       "constant",     "2"                     ]
[ "STORE_MMAP",           "int",  "frozen",       "constant",     "1"                     ]
[ "STORE_MEM",            "int",  "frozen",       "constant",     "0"                     ]
[ "LNG_MIN",              "lng",  "frozen",       "constant",     "-9223372036854775807"  ]
[ "LNG_MAX",              "lng",  "frozen",       "constant",     "9223372036854775807"   ]
[ "INT_MIN",              "int",  "frozen",       "constant",     "-2147483647"           ]
[ "INT_MAX",              "int",  "frozen",       "constant",     "2147483647"            ]
[ "SHT_MIN",              "sht",  "frozen",       "constant",     "-32767"                ]
[ "SHT_MAX",              "sht",  "frozen",       "constant",     "32767"                 ]
[ "CHR_MIN",              "chr",  "frozen",       "constant",     "'\201'"                ]
[ "CHR_MAX",              "chr",  "frozen",       "constant",     "'\177'"                ]
[ "RAND_MAX",             "int",  "frozen",       "constant",     "2147483647"            ]
[ ...                                                                                     ]
>
\end{verbatim}
The standard collection of variables consists of a number of constants that are needed
by various operators ({\tt @[<a href="www/modules/bat.html#mod_2_0_3">access</a>@(BAT[any,any], int {\bf BAT\_XX})},
{\tt @[<a href="www/modules/bat.html#mod_2_0_6">madvise</a>@(BAT[any,any], int {\bf BUF\_XX})} and
{\tt @[<a href="www/modules/bat.html#mod_2_0_6">mmap</a>@(BAT[any,any], int {\bf STORE\_XX})}). The
{\tt values\_status} tells whether it is a variable or a constant. For variables, the {\tt type\_status}
may either be {\tt liquid} or {\tt frozen}, which indicates whether the variable may be assigned a value
of another type.

@- Exceptions
@T
Exception-raising commands and how they are caught.
\begin{itemize}
\item {\em any syntax error} will raise an error exception. These
exceptions cannot be caught by the user. The MIL interpreter will
stop the interpretation on the active session; and start to wait for
new input.

\item BREAK;\\
This statement makes MIL quit the nearest enclosing WHILE loop,
or ITERATOR immediately ({\small\tt while(bool) \{ .. BREAK; .. \}} or
{\small\tt b@batloop() \{ .. BREAK; .. \}}).\\
If a command used in {\em Multiplex Operator} form (see below) stops with a
BREAK, the result BAT will have *no* result tuple
for that execution. Multiplex Operator execution will continue with the next
BUN, however.

\item {\tt ERROR(STR format, ANY...);}\\
It is also possible to raise an error exception programmatically.
This call produces an error message, much like in C-printf() format:
{\small\tt ERROR("you entered \%d foos too many$\backslash$n", foo);}
{\footnotesize (see: CMDERROR())}

\item {\tt CATCH(expr) : STR}\\
Executes the MIL expression passed as parameter.  If an exception
occurs during execution of the MIL expression, execution is stopped
and the error text is returned by {\tt CATCH}.  If no exception
occurs, {\tt CATCH} returns {\tt str(nil)}.
\end{itemize}

@+ Procedures
Users can quickly prototype functionality using the MIL procedure
mechanism. They follow the same signature overloading mechanism as MIL
applies for its built-in algebraic operators and commands.
@T
\begin{itemize}
\item {\tt PROC ident ( type ident, ..type ident..) : type statement}\\
Declare a MIL-procedure. Its definition is a simple MIL statement, in
which the parameter identifiers may appear as variables. The types
from the signature follow the same rules as found in MEL signature
definitions: all atomic MIL types are called by name, BATs are parametrized
(between square brackets: {\tt\small bat[htpe,ttpe]}) with a head-type and a
tail-type, and the special typename {\tt\small any} indicates a wildcarded type.
Like in MEL, an any-type may have a {\em tag-number} using {\small\tt any::1}
in order to make multiple any-types match (using the same tag-number).
A signature may end with a special sequence {\small\tt ..type..},
indicating a variable number of arguments. In case of {\tt\small ..any..}
these arguments may be of any type, but you may be more restrictive.

The parameters may also be omitted in the declaration, in which case
MIL assumes {\tt\small ..any..}; the actual
parameters during execution are always available with positional
arguments \$1, \$2, \$3,... (Unix shell script style).

As of now, you cannot indicate a return type in a PROC signature
(MIL just defaults it to a {\tt\small any} return value).

\item {\tt PROC ident; }\\
If recursion is applied, you need to do a forward declaration of the
procedure, in order for the MIL interpreter to be able to recognize it
correctly.

\item {\tt UNDEF ident; }\\
Undefine a MIL-procedure.
\end{itemize}

PROCs cannot be viewed once they have been parsed. You should store them
yourself in some text-file. Maybe your \$DBDIR/users/\$USER is a good place
for that, since MIL scripts placed there can easily be read in (see 'source()').
PROCs cannot be made persistent either.  You can, however,
put them in a MIL initialization file passed as startup parameter to
@[<a href="www/Mserver.html">Mserver</a>@.

MIL procedures are not typed; you can use them just as another MIL command.
The signature of a procedure is that of a command with a variable
number of ANY parameters, returning an ANY value. \\

@- Variable Arguments
@T
For handling variable numbers of arguments in PROCs, the following
special positional arguments are available:
\begin{itemize}
\item {\tt \$0} denotes the number of actual parameters (argument count).
\item {\tt \$(INT-expr)} references the {\em i-th} actual parameter, where
{\em i} is given by an integer expression.
\item {\tt \$(INT-expr..)} can be used as a parameter to another function call,
it actually stands for multiple parameter values. In this way, you can pass
'the rest' of the received parameters in a procedure to a another
command. For example: \\
{\small\tt proc printf(format) := \{ fprintf(stdout, format, \$(2..)); \} } \\
passes parameter 2-till-the-end of {\small\tt printf} to a call to {\small\tt fprintf}.
If there is only one parameter, the \$(2..) will expand to 0 parameters
without giving an error.\\
Note that in the procedure definition of {\small\tt printf} parameter 2-till-the-end
are not named as formal parameters; still all actual parameters (if any) are
still available with the positional parameter syntax \$X, \$(X) and \$(X..).
\end{itemize}

@* Relational Table Support
@[<a name="special\_doc">@
@T
The relational and Object-orient data-models provide support for
objects and tables with more than two columns, as provided in Monet.
The way to go about this, is to map the n-ary data model \{ A1,...,An \}
on {\em n} decomposed tables \{ {\small\tt BAT[OID,A1]} .. {\small\tt BAT[OID,An]}\}.

These sets of BATs, and possibly their derivatives (sub-sets, used
during query processing) semantically describe {\em different} parts of the
{\em same} database objects. Their OID columns make them correspond.\\

@+ Support For Corresponding BATs
@T
Since this situation is very common, Monet provides special support
for corresponding BATs, typically resulting in the following
three cases:
\begin{itemize}
\item {\em natural join}. Monet normally must do a natural join
on the OID columns, to find out which attribute values in the BATs
correspond. Though quick hash-lookups are used, this is relatively
expensive.\\
\item {\em sorted  BATs}. A common strategy is to keep the different
BATs ordered on the OID column. Cheap merge-algorithms, and binary-search
lookup, can then be used, even if the one BAT is a subset of the others.\\
\item {\em synced BATs}. For BAT-sets that contain exactly the same sets
of OIDs, those OID-columns can be marked {\small\tt synced()}. This information
is then used to use positional lookup (the i-th  element in BAT1 corresponds
with the i-th in BAT2) and to turn semijoin- into very cheap copy-operations, etc.
\end{itemize}
This special information (sorted, synced) about BATs is automatically
kept up-to-date by Monet across updates, and propagated to derived BATs,
where appropriate (a select on a sorted BAT produces a sorted subset BAT).
The special operators in this section (as well as much of the algebraic
commands in the Extension Modules) use this information to accelerate
processing.\\

@- Command Signature Notation
@T
In {\tt command} signature definitions throughout this document,
we will use @[<a href="mel.html">MEL (Monet Extension Language)</a>@ syntax:
\begin{itemize}
\item {\bf\tiny COMMAND} {\tt command-name}({\small TYPE name, ...VARARGTYPE...}) : {\small RETURNTYPE}
\end{itemize}
If the TYPE is {\small\tt ANY}, this denotes any possible MIL type.\\


@- Example: value printing
@T
\begin{itemize}
\item {\bf\tiny COMMAND} {\tt print}({\small ANY})
\end{itemize}
The {\small\tt print} command is used to print values. It will put
them on the standard output and enclose them in square brackets.\\
{\em The RETURNTYPE is omitted here; this means that a VOID value is
returned.}

\begin{itemize}
\item {\bf\tiny COMMAND} {\tt print}({\small BAT[ANY::1, ANY], ..BAT[ANY::1,ANY]..})
\end{itemize}
This second version of {\small\tt print} has a variable number of arguments
of type {\small\tt BAT}.\\
{\em ANY types can be tagged with a number like {\small\tt ANY::2}, in order
to indicate that certain ANY types correspond with other ANY types.}\\
In this case, the command signature states that the head columns of all its
BAT parameters are of the same type.  The {\small\tt print()} command
prints an N-ary table (where N = \#arguments+1), consisting of the
equality join of all BATs on the left column (head column), with all
head columns projected out except the leftmost one. This
produces a [Head,Attr1,Attr2,...AttrN] ASCII table on standard output:

{\small{\begin{verbatim}
print( #----------#  ,  #---------------#  );  ==>  #--------------------#
       # h  | age #     # h   | name    #           # oid | age | name   #
       #----------#     #---------------#           #--------------------#
       [ 1,   24  ]     [ 1,   "Niels"  ]           [ 1,   24,  "Niels"  ]
       [ 2,   38  ]     [ 2,   "Martin" ]           [ 2,   38,  "Martin" ]
       [ 3,   27  ]     [ 3,   "Arjan"  ]           [ 3,   27,  "Arjan"  ]
       [ 4,   27  ]     [ 4,   "Fred"   ]           [ 4,   27,  "Fred"   ]
       [ 5,   27  ]     [ 5,   "Wilko"  ]           [ 5,   27,  "Wilko"  ]
\end{verbatim}
{\center\em BAT Printing Example, and its result on Standard Output}}


@+ Multiplex Operators
@T
Multiplex Operators execute commands for a set of 'objects' (in their
Monet representation) on their different 'attributes' (i.e. a set of BATs).
For each command or procedure with signature:
\\
{\center\bf\tt COMMAND(type1,...,typeN) : typeR}
\\
there automatically exists its Multiplex Operator equivalent with signature:
\\
{\center\bf\tt [COMMAND](BAT[type0,type1],...,bat[type0,typeN])
: BAT[type0,typeR]}
\\
It applies the command operation on all tail values (corresponding by
equal head value), and stores the single return value in the tail of
the return BAT (along with the corresponding head value).
Note that this means that the multiplex operation computes
the {\bf natural join} on equal head values of all its BAT parameters.

{\begin{verbatim}
#----------#   [+]   #----------#   =   #----------#
# h   | t  #         # h   | t  #       # h   | t  #
#----------#         #----------#       #----------#
[ 1,   2   ]         [ 1,   1   ]       [ 1,   3   ]
[ 2,   1   ]         [ 2,   1   ]       [ 2,   3   ]
[ 3,   4   ]         [ 3,   1   ]       [ 3,   5   ]
[ 4,   2   ]         [ 4,   2   ]       [ 4,   4   ]
[ 5,   2   ]         [ 5,   2   ]       [ 5,   4   ]
\end{verbatim}
{\center\em Multiplex Operator Example: using the numerical '+' operator
(@[<a href="www/modules/arith.html">arith module</a>@)}}

\begin{itemize}
\item All parameter head types should be equal or void
\item The values fed into the command invocations are
obtained by taking the tail values of the corresponding BUNs.
\end{itemize}

If you want a constant parameter to be given to each command invocation,
instead of a tail-value from some BAT, you can pass a BAT cast (see the
next section) as a parameter, or just a constant (e.g.  '42').
In the case of a constant value of type {\bf BAT}, you must use BAT cast
notation (e.g. '[A\ ,\ const B]') to avoid confusion.

@- Multiplexing a Dereferenced String
@T
It is possible to use a string dereferencing of a command, operator,
or proc as the function in a multiplex operator:
{\small\tt [*fcn-expr](..params..)}.

@+ BAT Casts: project(A,B)
The BAT cast operator allows you to enter constant values into
columns:
@T
{\begin{verbatim}
project(  #---------------#  ,  "Monet User"  )  =   #-------------------#
          # h   | t       #                          # h  | t            #
          #---------------#                          #-------------------#
          [ 1,   "Martin" ]                          [ 1,  "Monet User"  ]
          [ 2,   "Fred"   ]                          [ 2,  "Monet User"  ]
          [ 3,   "Niels"  ]                          [ 3,  "Monet User"  ]
          [ 4,   "Arjan"  ]                          [ 4,  "Monet User"  ]
          [ 5,   "Sunil"  ]                          [ 5,  "Monet User"  ]
\end{verbatim}
{\center\em BAT Cast Example: Inserting a constant value in a column}}

@+ BAT conditional [A?B:C]
@T
{\begin{verbatim}
[  #----------#  ?  #---------#  :  #---------#  ] =  #--------#
   # h  | t   #     # h  | t  #     # h  | t  #       # h  | t #
   #----------#     #---------#     #---------#       #--------#
   [ 1,  true ]     [ 1,  1   ]     [ 1,  3   ]       [ 1,  1  ]
   [ 2,  true ]     [ 2,  1   ]     [ 2,  3   ]       [ 2,  1  ]
   [ 3,  true ]     [ 3,  1   ]     [ 3,  5   ]       [ 3,  1  ]
   [ 4,  false]     [ 4,  2   ]     [ 4,  4   ]       [ 4,  4  ]
   [ 5,  false]     [ 5,  2   ]     [ 5,  4   ]       [ 5,  4  ]
\end{verbatim}
{\center\em BAT Conditional Example: set-wise if-then-else}}

\begin{itemize}
\item
Here we have a BAT A with BITs in the tail. The B and C BATs must be
synced with A or may be constants with the const keyword. The head-types
of all BATs must be equal or void. B and C must have the same tail-types.
\item
The result is a BAT with the head-type of all BATs, and the tail-type of B and C.
It contains for each BUN in A where the tail-value is TRUE, the corresponding B value, and
for each BUN in A where the tail-value is FALSE, the tail
value of C.
\item
B or C may be omitted, in which case no result BUNs are produced for either
TRUE or FALSE values in A.
\item
B or C may be be constant values; for instance {\small\tt [A?B:const "no damage"]}
will produce B tuples where the A tail is TRUE, and tuples with
{\small\tt "no damage"} in the tail where the A tail if FALSE.
\item
In the case of non-BAT values, the const keyword may be omitted for brevity.
\end{itemize}

@[<a name="void">@
@+ Virtual OIDs
@T
The {\small\tt VOID} in MIL is like a {\small\tt V-OID}, or {\bf virtual oid}.
A virtual oid column in a BAT is an OID column, which has the restriction
that it must contain a {\bf dense sequence} of OID numbers. That is,
it contains a sequence of N numbers from base 'base': [base,base+1,base+2..,base+N-1].
Such columns {\bf need zero bytes of memory space};
the BAT just contains the base number, and the OID values are then
computed on the fly by adding the BUN position (row-id) to it.

A second restriction is that only one column in a BAT can be a virtual oid
(i.e. not both head and tail can be VOID).

VOID columns can be created using the {\tt\small{\bf [,B].copy}}
{\em bat projection}. It creates a view on top of B, in which the left
column seems to be missing; when you print it, all head values are {\tt nil}.
Another way of creating a BAT with a VOID column is to use
@[<a href="www/modules/bat.html#mod_2_0_1"><tt>new(VOID,T)</tt></a>@
(you can also use the constructor {\small\tt bat(VOID,T)}).
This will yield an empty BAT with a VOID head column.
@-
You need to activate the VOID column in a BAT created by hand by specifying a
base OID of your choice.  This can be done with the command
@[<a href="www/modules/bat.html#mod_2_0_3"><tt>bat[VOID,T].<bf>seqbase</bf>(oid)</tt></a>@.

@+ Operations on BATs with a VOID column
@T
Any MIL operation that can be executed on a BAT with OIDs can also
be executed on a BAT with virtual OIDs. The result type will
automatically be converted to OID, if necessary. Only when from the
semantics op the MIL command it is known that it will again return a
BAT with dense OIDs, the return BAT will also have a virtual oid column.

@- Less Storage
@T
The great advantages of virtual oids lie there where tables are very
large. Not having to store the OID for each item in a BAT means at
least a 50\% reduction in space needs. At least 50\% because alignment
restrictions of the hardware in general make it more (most systems
enforce OIDs to be stored on 4 byte memory addresses). This means that
a BAT[OID,CHR] containing a 4-byte OID and a 1-byte character takes
4 + 1 = 8 bytes in storage per tuple. A BAT[VOID,CHR]
takes only one byte of storage; an improvement of a factor 8!

@- Query Optimization
@T
Most MIL commands just don't see the difference between OID and VOID
columns. Only in some specific, but important, cases, Monet makes use
of the specific features of a VOID: lookup on OID number can be very
efficient, since you need to do nothing more
than subtract the base number in order to know the position of
a BUN. For instance, the
{\small\tt\bf @[<a href="www/modules/algebra.html#mod_2_1_0">bat[VOID,T].find(oid):T</a>@}
will use positional lookup.

Similar optimizations have been made in the
{\small\tt\bf @[<a href="www/modules/algebra.html#mod_2_5_1">semijoin</a>@}
and
{\small\tt\bf @[<a href="www/modules/algebra.html#mod_2_5_4">join</a>@}
when one of the join columns is virtual
oid. The same goes for the
{\small\tt\bf @[<a href="www/modules/algebra.html#mod_2_2_2">select</a>@}
operation when the selection column is a virtual oid.

@+ Pump
@T
Set aggregates are the MIL language {\bf pump} construct\\
        {\center \small\tt \{Y\}(bat-expr, bat-expr)}\\
that allow you to interpret both bats as a
a set of collections of {\small\tt tt} values, defined as\\
        {\center $S = \{ set_{h} | [h,any] \in right\}$}\\
in which\\
        {\center $set_{h} = \{ [t,t] | [h,t] \in left\}$}\\
are bags/sets of tail values.
@-
@T
The {\small\tt Y()} is a {\bf read-only} unary BAT command
        {\small\tt Y(bat[tt,any]) : rt}
or
        {\small\tt Y(bat[any,tt]) : rt}
that ignores the contents of the {\em any} column.
\\
The {\bf pump} version of {\small\tt Y}, denoted in MIL\\
        {\center\small\tt \{Y\}(bat[ht,tt], bat[ht,any]) : bat[ht,rt]} \\
is defined as\\
        {\center$\{ [h,r] | [h,t] \in bat \wedge r = \mbox{\small\tt Y}(set_{h})\}$ }
@-
@T
The {Y}() language constructor is orthogonal, and works with all
commands, builtins, procs, dereferenced address variables.
Dereferenced variables (as obtained with {\small\tt fcn = \&sum}) are
called using the syntax {\small\tt \{*fcn\}($bat-expr$)}.
\\
To clarify it all, we give an example of the use of the
{\small\tt sum()} operator, that normally sums the tails of one BAT,
as a set aggregate {\small\tt \{sum\}()}.
@T
{\begin{verbatim}
{sum} ( #-----------# , #-----------# ) = #-----------#
        # h   | t   #   # h   |  t  #     # h   | t   #
        #-----------#   #-----------#     #-----------#
        [ 1,   20.0 ]   [ 1,    nil ]     [ 1,   70.0 ]
        [ 1,   10.0 ]   [ 2,    nil ]     [ 2,   40.0 ]
        [ 1,   40.0 ]   [ 3,    nil ]     [ 3,    0.0 ]
        [ 2,   20.0 ]
        [ 2,   20.0 ]
\end{verbatim}
In the above we see why the second (right) parameter is necessary: it
makes it possible to work with empty sets/bags as well!

In the new @[<a href="www/modules/aggrX3.html">aggrX3 module</a>@ you find pumps with {\bf three}
parameters. At this moment this, tertiary aggregate is defined only for the most
common aggregate functions, while the binary pump works for all aggregates (including
your own MIL-procs). In the tertiary pump, the first (left) parameter of the binary pump
is split by column into two BATs with a synced void head columns, where the tail of the
first contains the original head column, and the tail of the second the original tail
column. The rationale for this new kind of aggregate is that many applications first
compute these separate void-bats before joining them together, while the fact that both
are synced and void makes this unnecessary (as lookup across both BATs is easy).

@+ GroupBy and OrderBy
@T
As the aggregates expect a single grouping column (be it the head of the left parameter
in the binary pump or the tail in the first parameter of the tertiary pump), we have
to explain how aggregates are computed when the grouping criterion spans multiple columns.

The Monet strategy is to reduce a the multiple grouping BATs to a single {\tt oid} column
first. This is done by  the {\tt CTgroup()} operator:

{\begin{verbatim}
CTgroup( #----------# ) = #----------# . CTgroup( #----------# ) =  #----------#
         # h   | t  #     # h  |  t  #            # h   | t  #      # h   | t  #
         #----------#     #----------#            #----------#      #----------#
         [ 1@0,  2  ]     [ 1@0, 1@0 ]            [ 1@0,  1  ]      [ 1@0, 1@0 ]
         [ 2@0,  1  ]     [ 2@0, 2@0 ]            [ 2@0,  1  ]      [ 2@0, 2@0 ]
         [ 3@0,  4  ]     [ 3@0, 3@0 ]            [ 3@0,  1  ]      [ 3@0, 3@0 ]
         [ 4@0,  2  ]     [ 4@0, 1@0 ]            [ 4@0,  2  ]      [ 4@0, 4@0 ]
         [ 5@0,  2  ]     [ 5@0, 1@0 ]            [ 5@0,  2  ]      [ 5@0, 4@0 ]
\end{verbatim}

The unary {\tt CTgroup(bat[void,any]):bat[void,oid]} replaces each
unique tail value for the first head {\tt oid} where it occurs. The binary
{\tt CTgroup(bat[void,oid], bat[void,any]):bat[void,oid]}
expects in the first parameter the output of the unary {\tt CTgroup()}
and adds a new column to the grouping, while matching tuples from both parameters like a binary multiplex.

Order-by is handled in a similar fashion by the unary {\tt sort} and the binary
{\tt CTrefine()} which much resembles the binary {\tt CTgroup()}.

{\begin{verbatim}
#----------#.reverse.sort.reverse = #----------#.CTrefine( #----------# ) =  #----------#
# h   | t  #                        # h  |  t  #           # h   | t  #      # h   | t  #
#----------#                        #----------#           #----------#      #----------#
[ 1@0,  2  ]                        [ 2@0,  1  ]           [ 1@0,  1  ]      [ 2@0, 0@0 ]
[ 2@0,  1  ]                        [ 4@0,  2  ]           [ 2@0,  1  ]      [ 1@0, 1@0 ]
[ 3@0,  4  ]                        [ 1@0,  2  ]           [ 3@0,  1  ]      [ 4@0, 2@0 ]
[ 4@0,  2  ]                        [ 5@0,  2  ]           [ 4@0,  2  ]      [ 5@0, 2@0 ]
[ 5@0,  2  ]                        [ 3@0,  4  ]           [ 5@0,  2  ]      [ 3@0, 3@0 ]
\end{verbatim}

The {\tt CTrefine(bat[oid,any], bat[void,any]):bat[oid,int]}
refines the order of the first parameter by looking at tail values from the second that match on head.  It
outputs the re-ordered head column (which no longer will be VOID) and renumbers the tail column with a newly
sorted order of integers.

For reasons similar to the pump, a tertiary {\tt CTrefine} will soon be introduced that expects
two void-headed parameters where the tail columns make up the head and tail of the first parameter
in the binary version.

More information on grouping and ordering can be found in the @[<a href="www/modules/xtables.html">xtables module</a>@.

@+ Updates and Transactions
@T
By default, Monet only has support for global database-wide transactions. A successful
{\tt @[<a href="www/modules/trans.html#mod_2_0_1">commit():bit</a>@}
ensures that all {\em persistent} BATs have safely been written to disk. This is an all or nothing
operation, as the {\tt @[<a href="www/modules/trans.html#mod_2_0_1">abort()</a>@} allows one to regress
to the status at the last succeeded commit.

BATs can be appended into with {\tt @[<a href="www/modules/bat.html#mod_2_0_2">insert()</a>@} and deleted from
with {\tt @[<a href="www/modules/bat.html#mod_2_0_2">delete</a>@}.

The default BAT access mode is {\tt BAT\_READ} (an exception are newly created empty BATs,
which have access mode {\tt BAT\_WRITE}). There is also an access mode {\tt BAT\_APPEND} that
only allows inserts.


@* Extension Modules
@T
All MIL primitives are in fact defined by extension modules, which have
a specification in the @[<a href="mel.html">Monet Extension Language</a>@ (MEL).

@+ Inspecting Modules
@T
So we now query for all available modules using the {\tt modules()} operator:

\begin{verbatim}
> modules;
#---------------------------------#
# name          | database        #
#---------------------------------#
[ "algebra",      "any"           ]
[ "arith",        "any"           ]
[ "ascii_io",     "any"           ]
[ "bat",          "any"           ]
[ "kernel",       "any"           ]
[ "str",          "any"           ]
[ "sys",          "any"           ]
[ "trans",        "any"           ]
[ ..                              ]
[ "monettime",    "any",          ]
[ ..                              ]
[ "xtables",      "any"           ]
>
\end{verbatim}

This tells us that Monet has the @[<a href="www/modules/monettime.html">monettime</a>@
module, but it is not loaded yet. This module defines a number of temporal data
types and operations.

The @[<a href="mel.html">MEL</a>@ specification of this module
contains code like this:

\begin{verbatim}
.MODULE monettime;

    .. omitted ...

.ATOM timestamp = lng;
    .FROMSTR = timestamp_fromstr;
    .TOSTR   = timestamp_tostr;
.END

    .. omitted ...

.END monettime;
\end{verbatim}

It contains a new atomic type called 'timestamp' that captures times
in a "Day-Month-Year hour:minute" format.

{\small\begin{verbatim}
>d := timestamp("14-aug-2002 16:14");
!ERROR: interpret: no matching MIL operator to 'timestamp(str)'.
\end{verbatim}}

When you try to use a 'timestamp' without loading
the @[<a href="www/modules/monettime.html">monettime</a>@
module, a runtime error occurs!

\begin{verbatim}
> module(monettime);
> loaded;
#---------------------------------#
# module        | usage_count     #
#---------------------------------#
[ "algebra",      1               ]
[ "arith",        1               ]
[ "bat",          1               ]
[ "kernel",       1               ]
[ "str",          1               ]
[ "sys",          1               ]
[ "trans",        1               ]
[ "mapi",         1               ]
[ "xtables",      1               ]
>
\end{verbatim}

After loading the module, we can ask for all commands contained
in it with {\tt sigs(str modulename)}:

\begin{verbatim}
> sigs("monettime");
[ ...                                             ]
[ "add(timestamp, lng) : timestamp"               ]
[ "date(timestamp) : date"                        ]
[ "date(timestamp, tzone) : date"                 ]
[ "daytime(timestamp) : daytime"                  ]
[ "daytime(timestamp, tzone) : daytime"           ]
[ "diff(timestamp, timestamp) : lng"              ]
[ "dst(timestamp, tzone) : bit"                   ]
[ "timestamp(date, daytime) : timestamp"          ]
[ "timestamp(date, daytime, tzone) : timestamp"   ]
[ ...                                             ]
>
\end{verbatim}

On-line help can be asked for each individual operator:

\begin{verbatim}
> help("diff");
COMMAND:   diff(timestamp, timestamp) : lng
MODULE:    monettime
COMPILED:  by adm on Mon Oct  7 11:22:50 2002
returns the number of milliseconds between 'val1' and 'val2' (!DS2.2).

>
\end{verbatim}

We can now create temporal values, manipulate them, and store them in BATs.

{\small\begin{verbatim}
> d := timestamp("14-aug-2002 16:14");
> d.print;
[ 14-au-1997 16:14 ]
>
> b := bat(oid,timestamp);
> b.insert(0@0, timestamp("13-may-1997 09:10"));
> b.insert(1@0, timestamp("16-aug-1997 10:20"));
> b.insert(2@0, timestamp("15-sep-1997 11:30"));
> b.insert(3@0, timestamp("01-jan-1997 12:40"));
> b.insert(4@0, timestamp("26-feb-1997 13:50"));
> b.insert(5@0, timestamp("15-aug-1997 14:00"));
>
> b.print;
#----------------------------------#
# oid    | timestamp               #
#----------------------------------#
[ 0@0,     13-may-1997 09:10       ]
[ 1@0,     16-aug-1997 10:20       ]
[ 2@0,     15-sep-1997 11:30       ]
[ 3@0,     01-jan-1997 12:40       ]
[ 4@0,     26-feb-1997 13:50       ]
[ 5@0,     15-aug-1997 14:00       ]
>
> drop(monettime);
>
> b.insert(31165626@0, timestamp("15-aug-1997 15:10"));
!ERROR: interpret: no matching MIL operator to 'timestamp(str)'.
!ERROR: insert(param 3): evaluation error.
\end{verbatim}}

After the module is dropped, using temporal primitives
will again produce syntax errors.

MIL has a parser that is based on {\em dynamic lookup tables}.
When a module is loaded, its commands, operators, atoms
and accelerators become accepted keywords for that user.

@* Module Reference
@T
Extension modules are written with the @[<a href="http://www.cwi.nl/htbin/ins1/publications?request=pdf&key=KeScBeBo:UNPUBLISHED:96">Mx</a>@
literate programming tool to integrate code both with the technical and user documentation. Concerning the latter,
the topmost 'hide level' of each module contains a manual page (while the second hide-level
contains the technical documentation).  Below, the manual pages of all modules are grouped
according to their functionality.

@+ Kernel Modules
@T
As of version 4.1 MIL has 7 standard modules, that are always loaded.
\begin{description}
\item[ @[<a href="www/modules/kernel.html">kernel</a>@ ]
	these are the builtin system primitives.  They cannot be overloaded.
\item[ @[<a href="www/modules/bat.html">bat</a>@ ]
	basic commands to create and manipulate BATs.
\item[ @[<a href="www/modules/algebra.html">algebra</a>@ ]
	relational core of BAT commands (select, join, etc).
\item[ @[<a href="www/modules/arith.html">arith</a>@ ]
	simple arithmetic operators on the standard types.
\item[ @[<a href="www/modules/sys.html">sys</a>@ ]
	system information. This module contains helpful procedures for navigating through the system (ls, help).
\item[ @[<a href="www/modules/str.html">str</a>@ ]
	string handling.
\item[ @[<a href="www/modules/trans.html">trans</a>@ ]
	support for global transactions (minimal database consistency).
\end{description}

@+ Query Processing
@T
\begin{description}
\item[@[<a href="www/modules/algebra.html">algebra</a>@]
	Relational core of BAT commands (select, join, etc).
\item[@[<a href="www/modules/aggr.html">aggr</a>@]
	Binary aggregation operations.
\item[@[<a href="www/modules/aggrX3.html">aggrX3</a>@]
	Fast tertiary aggregation operations.
\item[@[<a href="www/modules/xtables.html">xtables</a>@]
	Cross-table operations for data mining.
\item[@[<a href="www/modules/radix.html">radix</a>@]
	Cache-conscious query processing.
\item[@[<a href="www/modules/enum.html">enum</a>@]
	Automatic creation of enumeration types. Used for space compression.
\item[@[<a href="www/modules/mmath.html">mmath</a>@]
	Mathematic operations a la  {\tt math.h}.
\item[@[<a href="www/modules/ascii_io.html">ascii_io</a>@]
	Bulk loading.
\end{description}

@+ Transactions
@T
\begin{description}
\item[@[<a href="www/modules/lock.html">lock</a>@]
	Locks and semaphores.
\end{description}

@+ OS APIs
@T
\begin{description}
\item[@[<a href="www/modules/unix.html">unix</a>@]
	Provides access to some of the C stdlib.h functions.
\item[@[<a href="www/modules/alarm.html">alarm</a>@]
	OS timers and interrupts.
	Standard IO module a la  {\tt stdio.h}.
\item[@[<a href="www/modules/streams.html">streams</a>@]
	Stream IO a la {\tt stdio.h}.
\item[@[<a href="www/modules/tcpip.html">tcpip</a>@]
	TCP/IP asynchronous communication.
\end{description}

@+ Extension Atoms
@T
\begin{description}
\item[@[<a href="www/modules/bitset.html">bitset</a>@]
	Compact bit-set manipulation.
\item[@[<a href="www/modules/bitvector.html">bitvector</a>@]
	Compact bit-set manipulation.
\item[@[<a href="www/modules/blob.html">blob</a>@]
	The generic variable-size atom.
\item[@[<a href="www/modules/decimal.html">decimal</a>@]
	Arbitrary precision arithmetic.
\item[@[<a href="www/modules/monettime.html">monettime</a>@]
	 data types and operations on them.
\item[@[<a href="www/modules/qt.html">qt</a>@]
	Quadtree implementation
\item[@[<a href="www/modules/str.html">str</a>@]
	String manipulation module supporting UTF-8.
\item[@[<a href="www/modules/url.html">url</a>@]
	URL operations
\end{description}

@+ Performance Monitoring
@T
\begin{description}
\item[@[<a href="www/modules/calib.html">calib</a>@]
	Calibrator that automatically extracts relevant hardware parameters from any system.
\item[@[<a href="www/modules/counters.html">counters</a>@]
	System-independent hardware counters.
	(First version, building directly on system-dependent libraries.)
\item[@[<a href="www/modules/pcl.html">pcl</a>@]
	System-independent hardware counters.
	(Second version, building on System-independent @[<a href="http://www.fz-juelich.de/zam/PCL/">PCL</a>@ library
\item[@[<a href="www/modules/mprof.html">mprof</a>@]
	Monet performance profiling.
\end{description}

@+ Benchmark Generators
@T
\begin{description}
\item[@[<a href="www/modules/ddbench.html">ddbench</a>@]
	Drill-down benchmark for data mining.
\item[@[<a href="www/modules/oo7.html">oo7</a>@]
	OO7 benchmark generation and specific operations.
\item[@[<a href="www/modules/tpcd.html">tpcd</a>@]
	Efficient aggregation operations included.
\item[@[<a href="www/modules/wisc.html">wisc</a>@]
	Wisconsin benchmark code.
\end{description}

@* Managing The MIL Interpreter

While we now have explained the basic structure of MIL and given pointers
to the reference manuals of all modules, we pay some attention to some
useful internals of the MIL interpreter of Monet.

@+ Threads
@T
Monet is a multi-threaded server. One ore more MIL interpreter threads
are active handling user requests that are placed in a queue. Parallel
MIL blocks or parallel iterators put many jobs in this queue, that are
then consumed by these multiple MIL interpreter threads, thus creating
parallelism.

At startup of the {\tt @[<a href="www/Mserver.html">Mserver</a>@}, one such interpreter
thread is created.  For each incoming {\tt @[<a href="www/MapiClient.html">MapiClient</a>@}
session, a new thread is created as well.

\begin{verbatim}
> threads;
#-------------------------#
# BAT:    thread          #
# (int)   (str)           #
#-------------------------#
[ 1,      "Interpreter"   ]
>
> threadcnt(2);
#-------------------------#
# BAT:    thread          #
# (int)   (str)           #
#-------------------------#
[ 1,      "Interpreter"   ]
[ 2,      "Interpreter"   ]
[ 3,      "Interpreter"   ]
>
> threadcnt(-1);
#-------------------------#
# BAT:    thread          #
# (int)   (str)           #
#-------------------------#
[ 1,      "Interpreter"   ]
[ 2,      "Interpreter"   ]
>
\end{verbatim}
You can get a listing of all Monet threads with the {\tt @[<a href="www/modules/kernel.html#mod_2_3_2">threads()</a>@} command.
The {\tt @[<a href="www/modules/kernel.html#mod_2_3_2">threadcnt(int delta)</a>@} command allows to increase or decrease the number of
MIL interpreter threads.

@+ Client Sessions
@T
Monet maintains a number of data structures for each client logged in.
By using parallel MIL blocks or parallel iterators, one client can keep
multiple threads busy (threads are thus a lower-level concept than clients).

Clients can:
\begin{itemize}
\item fork other clients with {\tt @[<a href="www/modules/kernel.html#mod_2_3_1">fork(expr):int</a>@},
which returns a client-id.  \item killed with {\tt @[<a href="www/modules/kernel.html#mod_2_3_1">kill(int id)</a>@}.
\item listed with {\tt @[<a href="www/modules/sys.html#mod_2_1_0">clients()</a>@}.
\end{itemize}

A common application of {\tt @[<a href="www/modules/kernel.html#mod_2_3_1">fork()</a>@} is to start a Mapi listener in the background:
\begin{verbatim}
> module(mapi);
> listen(45678).fork;
> clients;
#-------------------------------------------------------------------------#
# BAT:    name  | login                         | mil                     #
# (int)   (str) | (str)                         | (str)                   #
#-------------------------------------------------------------------------#
[ 0,      "adm",  "Mon Oct  7 15:59:18 2002",     "clients()"             ]
[ 1,      "adm",  "Mon Oct  7 15:59:18 2002",     "listen(45678)"         ]
>
> kill(1);
>
> clients;
#-------------------------------------------------------------------------#
# BAT:    name  | login                         | mil                     #
# (int)   (str) | (str)                         | (str)                   #
#-------------------------------------------------------------------------#
[ 0,      "adm",  "Mon Oct  7 15:59:18 2002",     "clients()"             ]
>
\end{verbatim}

The session is ended with a {\tt @[<a href="www/modules/kernel.html#mod_2_3_1">quit()</a>@}. Note that typing this in the
{\tt @[<a href="www/Mserver.html">Mserver</a>@} console with stop the Monet server
immediately, whereas in the {\tt @[<a href="www/MapiClient.html">MapiClient</a>@} it
will only end the current user session. The server can be shutdown from the
{\tt @[<a href="www/MapiClient.html">MapiClient</a>@} (and also from the
{\tt @[<a href="www/Mserver.html">Mserver</a>@} console) with {\tt @[<a href="www/modules/kernel.html#mod_2_3_1">shutdown()</a>@}.

@* Further Reference
@T
We recommend you to study the commands in the following modules:
\begin{description}
\item[system] @[<a href="www/modules/kernel.html">kernel</a>@ (special keywords),
@[<a href="www/modules/sys.html">sys</a>@ (especially look at the @[<a href="www/modules/sys.html#mod_2_1_0">PROCs</a>@).

\item[bats] @[<a href="www/modules/bat.html">bat</a>@ (basic bat management) and
@[<a href="www/modules/algebra.html">algebra</a>@ (the core algebra).

\item[advanced query processing] @[<a href="www/modules/aggr.html">aggr</a>@ and @[<a href="www/modules/aggrX3.html">aggrX3</a>@ (aggregates),
@[<a href="www/modules/xtables.html">xtables</a>@ (groupings) and
@[<a href="www/modules/radix.html">radix</a>@ (cache-conscious join).
\end{description}

The @[<a href="http://www.cwi.nl/htbin/ins1/publications?request=abstract&key=Bo:DISS:02">Ph.D. thesis</a>@
of Peter Boncz is a full reference of Monet and MIL. Among other topics, it discusses in detail
how relational queries (SQL) can be translated into cache and CPU-efficient MIL.
