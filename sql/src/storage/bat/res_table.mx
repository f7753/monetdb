@f res_table

@h
#ifndef RES_TABLE_H
#define RES_TABLE_H

#include "sql_catalog.h"

extern res_table *res_table_create( sql_trans *tr, int res_id, int nr_cols, int querytype, res_table *next );
extern res_col * res_col_create( sql_trans *tr, res_table *t, char *tn, char *name, char *typename, int digits, int scale );

extern void res_table_destroy(res_table *t);
extern void res_tables_destroy(res_table *t);

#endif /* RES_TABLE_H */
@c

#include "res_table.h"
#include "sql_types.h"
#include "bat_bm.h"

res_table *res_table_create( sql_trans *tr, int res_id, int nr_cols, int type, res_table *next )
{
	res_table *t = NEW(res_table);
	(void)tr;
	t->id = res_id;
	t->query_type = type;
	t->nr_cols = nr_cols;
	t->cur_col = 0;
	t->cols = NEW_ARRAY(res_col,nr_cols);
	t->order = 0;
	t->next = next;
	return t;
}

res_col *
res_col_create( sql_trans *tr, res_table *t, char *tn, char *name, char *typename, int digits, int scale )
{
	sql_subtype *tpe = sql_bind_subtype(typename, digits, scale);
	res_col *c = t->cols+t->cur_col;

	if (!tpe)
		tpe = sql_create_subtype(
			sql_trans_bind_type(tr, typename), digits, scale);
	c->tn = _strdup(tn);
	c->name = _strdup(name);
	c->type = tpe;
	c->b = 0;
	c->p = NULL;
	c->mtype = TYPE_bat;
	t->cur_col++;
	return c;
}

void res_table_destroy(res_table *t)
{
	int i;
	for(i=0; i<t->nr_cols; i++){
		res_col *c = t->cols+i;
		if (c->b){
			bat_decref(c->b, TRUE);
		} else {
			_DELETE(c->p);
		}
		_DELETE(c->name);
		sql_subtype_destroy(c->type);
	}
	if (t->order)
		bat_decref(t->order, TRUE);
	_DELETE(t->cols);
	_DELETE(t);
}

void res_tables_destroy(res_table *tab)
{
	if (tab){
		res_table *r = tab, *t;
		for(t=r; t; t=r){ 
			r = t->next;
			res_table_destroy(t);
		}
	}
}
