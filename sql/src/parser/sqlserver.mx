@f sqlserver
@a N.J. Nes
@* 

@m
.MODULE sqlserver;
	.USE streams;

	.BUILTIN sqlserver_start(int port, str cmd) = sqlserver_start;
		"start the sql server, calls cmd on each accepted connection"

	.COMMAND stream_read( stream ) : str = sqlserver_read;
		"read a string of commands"
.END sqlserver;

@h
#ifndef _SQLSERVER_H_
#define _SQLSERVER_H_

#include <streams.h>
#include "monet_context.h"
#include "sqlserver.proto.h"

#endif /*_SQLSERVER_H_*/

@c
#include "sqlserver.h"
#include "mem.h"

#include  <sys/types.h> 
#include  <sys/socket.h> 

@= builtin_operand
{       int _k = interpret(stk, arg(lt, @1), res);
        if (_k < 0) {
                return _k;
        }
        @3 = VALconvert(@2, res, 0);
        if ((@3 == ILLEGALVALUE)  || (@2 == TYPE_bat && !@3)) {
                return handle_paramerror(res,@1,res->vtype,@2);
        }
}
@c

int sqlserver_start(Cntxt stk, YYSTREE lt, ValPtr res){
  int port, *Port, sock, fd = 0, i, server_run = 1;
  char *cmd, *Cmd;
  struct sockaddr_in server, client;

  if (lt->cnt != 2) {
        return handle_argerror(res,lt->cnt,2);
  }
  @:builtin_operand(0,TYPE_int,Port)@
  port = *Port;
  @:builtin_operand(1,TYPE_str,Cmd)@
  cmd = _strdup(Cmd);

  sock = socket (AF_INET, SOCK_STREAM, 0);
  if (sock < 0) {
    perror ("could not create socket");
    exit (1);
  }
   
  server.sin_family = AF_INET;
  server.sin_addr.s_addr = htonl (INADDR_ANY);
  server.sin_port = htons (port);

  if (bind (sock, (struct sockaddr *) &server, sizeof (server)) < 0) {
    perror ("could not bind socket");
    return;
  }

  listen (sock, 5);

  fprintf (stderr, "server listening on port %i\n", port);

  while (server_run) {
    int retval;
    size_t client_len = sizeof (client);
    struct timeval tv;
    fd_set fds;

    /* Watch stdin (fd 0) to see when it has input. */
    FD_ZERO(&fds);
    FD_SET(sock, &fds);
    /* Wait up to five seconds. */
    tv.tv_sec = 5;
    tv.tv_usec = 0;

    retval = select(sock+1, &fds, &fds, &fds, &tv);
    /* Don't rely on the value of tv now! */

    if (retval &&
        (fd = accept(sock, (struct sockaddr *) &client, &client_len))<0 ){
      	perror ("accept () failed");
	break;
    } else if(retval){
	char buf[BUFSIZ];
	
	snprintf( buf, BUFSIZ, "%s(%d);\n", cmd, fd );
	interpret_str( stk, buf, res);
	/*
	int res = 0;
	if ((res = close(fd)) < 0){
		fprintf(stderr, "Error closing socket %d\n", res );
		return;
	}
	*/
    }
  }
}

int sqlserver_read( str *res, stream *S ){
	stream *s = *(stream**)S;
	int len = 0;
	int size = BUFSIZ + 1;
	char *buf = NEW_ARRAY(char, size ), *start = buf;

	while ((len = s->read(s, start, 1, BUFSIZ)) == BUFSIZ){
		size += BUFSIZ;
		buf = RENEW_ARRAY(char, buf, size); 
		start+= BUFSIZ;
		*start = '\0';
	}
	start += len;
	*start = '\0';
	*res = buf;
	return GDK_SUCCEED;
}
