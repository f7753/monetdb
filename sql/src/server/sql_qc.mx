@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2005 CWI.
@' All Rights Reserved.

@f sql_qc
@a N.J. Nes
@* The query cache
An effective scheme to speedup processing of an SQL engine is
to keep a cache of recently executed queries around.
This cache can be inspected by simply searching for an
identical query string, or a simple pattern match against
the sql query tree.  Finding an element saves code generation.

The scheme used here is based on keeping a hash-key around for
the original text and subsequently perform a parse-tree comparison.
This means that only text-identical queries are captured.

The upper layers should consider the cache as an auxiliary
structure. There is no guarantee that elements remain in
the cache forever, nor control features to assure this.

Entries in the cache obtain a unique(?) cache entry number.
It can be used as an external name.

[todo]
The information retain for each cached item is back-end specific.
It should have a hook to update the initialize the cache entry
and a method to destroy it.

The optimization/processing cost should be kept around and the re-use of
a cache entry.
@h
#ifndef _SQL_QC_H_
#define _SQL_QC_H_

#include <sql_mem.h>
#include <sql_list.h>
#include <sql_symbol.h>
#include <sql_backend.h>

typedef struct cq {
	struct cq *next;	/* link them into a queue */
	int type;		/* sql_query_t: Q_PARSE,Q_SCHEMA,.. */
	symbol *s;		/* the SQL parse tree */
	list *params;		/* list of parameter types */
	backend_stack stk;	/* V4 state information */
	backend_code code;	/* V4 state information */
	int id;			/* cache identity */
	int key;		/* the hash key for the query text */
	char *codestring;	/* keep code in string form to aid debugging */
} cq;

typedef struct qc {
	int id;
	cq *q;
} qc;

sql_export qc *qc_create();
sql_export void qc_destroy(qc *cache);
sql_export cq *qc_find(qc *cache, int id);
sql_export cq *qc_match(qc *cache, symbol *s, list *params, int key);
sql_export cq *qc_insert(qc *cache, symbol *s, list *params, int key, int type, char *codedstr);
sql_export void qc_delete(qc *cache, cq *q);
sql_export int qc_size(qc *cache);

#endif /*_SQL_QC_H_*/

@c

#include "sql_qc.h"
#include "sql_scope.h"

qc *
qc_create()
{
	qc *r = NEW(qc);
	r->id = 0;

	r->q = NULL;
	return r;
}

static void
cq_delete(cq *q)
{
	if (q->s)
		symbol_destroy(q->s);

	if (q->params)
		list_destroy(q->params);

	if (q->code)
		backend_freecode(q->code, q->stk, q->id);

	if (q->stk)
		backend_freestack(q->stk);
	_DELETE(q->codestring);
	_DELETE(q);
}

void
qc_delete(qc *cache, cq *q)
{
	cq *n, *p = NULL;

	for (n = cache->q; n; p = n, n = n->next) {
		if (n == q) {
			if (p) {
				p->next = q->next;
			} else {
				cache->q = q->next;
			}
			cq_delete(q);
		}
	}
}

void
qc_destroy(qc *cache)
{
	cq *q, *n;

	for (q = cache->q; q; q = n) {
		n = q->next;

		cq_delete(q);
	}
	_DELETE(cache);
}

int
param_cmp(sql_subtype *t1, sql_subtype *t2)
{
	int res;

	if (t1->scale != t2->scale)
		return -1;
	res = subtype_cmp(t1, t2);
	if (res)
		return -1;
	if ((t1->digits > 0 && t1->scale == 0 && t1->digits < t2->digits) || (t1->scale > 0 && t1->digits > 0 && t1->digits - t1->scale < t2->digits - t2->scale)) {
		return -1;
	}
	return 0;
}

int
param_list_cmp(list *typelist, list *atomlist)
{
	node *n1, *n2;

	if (typelist == atomlist)
		return 0;
	if (!typelist || !atomlist || list_length(typelist) != list_length(atomlist))
		return -1;
	for (n1 = typelist->h, n2 = atomlist->h; n1; n1 = n1->next, n2 = n2->next) {
		sql_subtype *t1 = n1->data;
		atom *a2 = n2->data;

		/* NULL values match any type */
		if (!atom_null(a2) && param_cmp(t1, a2->tpe) != 0)
			return -1;
	}
	return 0;
}

cq *
qc_find(qc *cache, int id)
{
	cq *q;

	for (q = cache->q; q; q = q->next) {
		if (q->id == id)
			return q;
	}
	return NULL;
}

cq *
qc_match(qc *cache, symbol *s, list *params, int key)
{
	cq *q;

	for (q = cache->q; q; q = q->next) {
		if (q->key == key) {
			if (param_list_cmp(q->params, params) == 0 && symbol_cmp(q->s, s) == 0) {
				return q;
			}
		}
	}
	return NULL;
}

cq *
qc_insert(qc *cache, symbol *s, list *params, int key, int type, char *cmd)
{
	node *m;
	cq *n = NEW(cq);
	n->id = cache->id ++;

	n->s = s;

	n->params = list_create((fdestroy) &sql_subtype_destroy);
	if (params)
		for (m = params->h; m; m = m->next) {
			atom *a = m->data;

			list_append(n->params, sql_dup_subtype(a->tpe));
		}
	n->next = cache->q;
	n->stk = 0;
	n->code = NULL;
	n->type = type;
	n->key = key;
	n->codestring = cmd;
	cache->q = n;
	return n;
}

int
qc_size(qc *cache)
{
	return cache->id;
}
