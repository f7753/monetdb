@f mvc
@a N.J. Nes
@* 

@h
/* multi version catalog */

#include <gdk.h>
#include <mem.h>
#include <catalog.h>
#include <stdarg.h>
#include <query.h>

#define ISO_READ_UNCOMMITED 1
#define ISO_READ_COMMITED   2
#define ISO_READ_REPEAT	    3
#define ISO_SERIALIZABLE    4

/* fkey consists of two of these */
typedef struct sql_key { /* pkey, ukey, fkey */
	oid id;
	key_type type; /* pkey, ukey, fkey */
	struct list *columns; 
	struct sql_table *t;
} sql_key;

typedef struct sql_ukey { /* pkey, ukey */
	sql_key k;
	list *keys;
} sql_ukey;

typedef struct sql_fkey { /* fkey */
	sql_key k;
	struct sql_ukey *rkey; /* only set for fkey and rkey */

	bat bid;
} sql_fkey;

typedef struct sql_column {
	oid id;
	char *name;
	char *type; 
	int colnr;

	char *def;
	int null;

	bat bid;
	bat ubid;     /* bat with updates */
	int rtime;
	int wtime;
	int flag;

} sql_column;

typedef struct sql_table {
	oid id;
	char *name;
	int temp;
	char *query;
	int view;
	struct list *columns;
	struct list *dcolumns;
	sql_column *ncolumn;
	sql_ukey *pkey;
	struct list *keys; 	/* all keys (primary,unique and foreign) */
	sql_key *nkey;
	struct list *dkeys;	/* list of dropped keys, not used jet */

	bat obid;     /* bat with oids */
	bat dbid;     /* bat with deletes */
	int rtime;
	int wtime;
	int flag;
} sql_table;

#define oid_column(t) ((sql_column*)t->columns->h->data)

typedef struct sql_schema {
	oid id;
	char *name;
	char *auth;

	int rtime;
	int wtime;
	int flag;

	list *tables;
	list *dtables;
	sql_table *ntable;
} sql_schema;

typedef struct sql_trans {
	char *name;
	int stime; /* transaction time stamp (aka start time) */
	int rtime;
	int wtime;
	int level; 
	int status;
	int type;

	sql_schema *schema;
	list *schemas;
	list *dschemas;
	sql_schema *nschema;

	list *keys; /* need a place to keep keys during the foreing key
		       initialization */

	struct sql_trans *parent; /* multilevel transaction support */
} sql_trans;

typedef struct mvc {
	int debug;

	sql_trans *trans;
} mvc;


extern void mvc_init(int debug, char *dirname);
extern void mvc_exit();

extern mvc *mvc_create( int debug );
extern void mvc_destroy( mvc *c );
extern int mvc_login( mvc *c, char *schema, char *user, char *passwd );

extern int mvc_status( mvc *c );
extern int mvc_type( mvc *c );

/* since Savepoints and transactions related the 
 * statement commit function includes the savepoint creation.
 * And rollbacks can be eigther full or until a given savepoint. 
 * The special statement_release can be used to release savepoints. 
 */
extern int mvc_commit( mvc *c, int chain, char *name );
extern int mvc_rollback( mvc *c, int chain, char *name );
extern int mvc_release( mvc *c, char *name );
extern int mvc_set_iso_level(mvc * m, int level);

extern BAT *mvc_bind( mvc *c, char *tname, char *cname, int access );
extern BAT *mvc_bind_ubat( mvc *c, char *tname, char *cname, int access );
extern BAT *mvc_bind_obat( mvc *c, char *tname, int access );
extern BAT *mvc_bind_dbat( mvc *c, char *tname, int access );

extern sql_schema *mvc_bind_schema( mvc *c, char *sname );
extern sql_table *mvc_bind_table( mvc *c, sql_schema *s, char *tname );
extern sql_column *mvc_bind_column( mvc *c, sql_table *t, char *cname );
extern sql_key *mvc_bind_key( mvc *c, sql_table *t, va_list ap );

extern void mvc_drop_schema( mvc *c, char *name );
extern sql_schema *mvc_create_schema( mvc *c, char *name, char *auth);
extern void mvc_drop_table( mvc *c, sql_schema *s, char *name, bit cascade );
extern sql_table *mvc_create_view( mvc *c, sql_schema *s, char *name, char *sql);
extern sql_table *mvc_create_table(mvc *c, sql_schema *s, char *name, bit temp);
extern void mvc_drop_column( mvc *c, sql_table *t, char *name );
extern sql_column *mvc_create_column( mvc *c, sql_table *t, char *name, char *type, int seqnr );
extern sql_column *mvc_not_null( mvc *c, sql_column *col );
extern sql_column *mvc_default( mvc *c, sql_column *col, char *val );

extern sql_key *mvc_create_key( mvc *m, sql_table *t, int kt, sql_key *fk );
extern sql_key *mvc_key_add_column( mvc *m, sql_key *k, sql_column *c );

extern void mvc_export(stream *s, BAT *order, BAT *bats, char *sep, char *rsep);
extern void mvc_export_schema( mvc *c, stream *s );
extern int mvc_import_table( mvc *c, stream *s, char *tname, char *sep, char *rsep, int nr);
@c

/* multi version catalog */

/* 
 * TODO 
 *
 * insert/delete/update should return ERROR (or success). Client side
 * should handle the result
 *
 * use mmap copy
 *
 * read logs back
 *
 * come up with a multifile log system (so a seperate thread could
 * do the atomic bat commits).
 */

#include <gdk.h>
#include <ascii_io.h>

#include "mvc.h"
#include <statement.h>
#include <types.h>

#define TR_OLD 0
#define TR_NEW 1

static int mvc_debug = 0;

static BAT *sql_schema_id, *sql_schema_name, *sql_schema_auth;
static BAT *sql_table_id, *sql_table_name, *sql_table_schema, 
	*sql_table_query, *sql_table_isview;
static BAT *sql_column_id, *sql_column_name, *sql_column_type,
    *sql_column_table, *sql_column_default, *sql_column_null,
    *sql_column_number;

static BAT *key_id, *key_table, *key_tpe, *key_rkey;
static BAT *kc_id, *kc_col, *kc_nr; 

static sql_trans *gtrans;

static MT_Lock mvc_lock;

/* current time stamps model is simple. Two time stamps per column, 
   one for reads and writes. 
 */

static int stamp = 1;

static int timestamp()
{
	return stamp++;
}

static int ky_id = 1;

static int key_new_id()
{
	return ky_id++;
}

static 
ptr *ADTfromStr( int type, char *s){
        int l = 0;
        ptr *res = NULL;
        if (type == TYPE_str) {
		if (*s == '\1') {
			int len = strlen(s);
			char *r = _strdup( s+1 );
			r[len-2] = '\0';
			res = (ptr*)r;
		} else {
                	res = (ptr*)_strdup(s);
		}
	} else
                BATatoms[type].atomFromStr(s, &l, (ptr)&res);
        return res;
}

static
int ADT_toStr( char **buf, int *len, int type, ptr a){
        return (int)BATatoms[type].atomToStr( buf, len, a);
}

INLINE
ptr bun_find(BAT *b, ptr v){
	BUN p = BUNfnd(b,v);
	if (p)
		return BUNtail(b,p);
	return NULL;
}

static int key_cmp(sql_key *k, oid *id)
{
	if (k && id && k->id == *id)
		return 0;
	return 1;
}

static void key_destroy(sql_key * k)
{
	list_destroy(k->columns);
}

static void column_destroy(sql_column * c)
{
	BBPtransient(c->bid, FALSE);
	BBPtransient(c->ubid, FALSE);
	_DELETE(c->name);
	_DELETE(c->type);
	_DELETE(c->def);
	_DELETE(c);
}

static void table_destroy(sql_table * t)
{
	_DELETE(t->name);
	_DELETE(t->query);

	if (t->dbid) BBPtransient(t->dbid, FALSE);
	if (t->obid) BBPtransient(t->obid, FALSE);
	if (t->keys){
		list_destroy(t->keys);
	}
	if (t->dkeys){
		list_destroy(t->dkeys);
	}
	list_destroy(t->columns);
	if (t->dcolumns){
		list_destroy(t->dcolumns);
	}
	_DELETE(t);
}

static void schema_destroy(sql_schema * s)
{
	_DELETE(s->name);
	_DELETE(s->auth);

	list_destroy(s->tables);
	if (s->dtables){
		list_destroy(s->dtables);
	}
	_DELETE(s);
}

static sql_trans *trans_destroy(sql_trans *t)
{
	sql_trans *res = t->parent;

	if (t->name) _DELETE(t->name); 

	list_destroy(t->schemas);
	if (t->dschemas){
		list_destroy(t->dschemas);
	}
	if (t->keys) list_destroy(t->keys);
	t->schema = NULL;
	_DELETE(t);
	return res;
}

static node *find_column_node(sql_table * t, char *cname)
{
	node *n;
	for (n = t->columns->h; n; n = n->next) {
		sql_column *c = n->data;
		/* check if names match and if its not an internal column */
		if (strcmp(cname, c->name) == 0 && c->colnr >=0) {
			return n;
		}
	}
	return NULL;
}

static sql_column *find_column(sql_table * t, char *cname)
{
	node *n = find_column_node(t, cname );
	if (n) return n->data;
	return NULL;
}

static
node *find_table_node(sql_schema * s, char *tname)
{
	node *n;
	for (n = s->tables->h; n; n = n->next) {
		sql_table *t = n->data;
		if (strcmp(tname, t->name) == 0) {
			return n;
		}
	}
	return NULL;
}
static
sql_table *find_table(sql_schema * s, char *tname)
{
	node *n = find_table_node( s, tname );
	if (n) return n->data;
	return NULL;
}

static
node *find_schema_node(sql_trans *t, char *sname)
{
	node *n;
	for (n = t->schemas->h; n; n = n->next) {
		sql_schema *s = n->data;
		if (strcmp(sname, s->name) == 0) {
			return n;
		}
	}
	return NULL;
}
static
sql_schema *find_schema(sql_trans *t, char *sname)
{
	node *n = find_schema_node( t, sname );
	if (n) return n->data;
	return NULL;
}

static void load_add_column(BAT * columns, BUN j, sql_key *k )
{
	ptr lid = BUNhead(columns, j);
	char *name = bun_find(kc_col, lid);
	sql_column *c = find_column(k->t, name);

	list_append(k->columns,c);
}

static sql_key *load_key(BAT * keys, BUN j, sql_table *t)
{
	sql_trans *tr = gtrans;
	int ccnt;
	BAT *cols, *rcols;
	ptr lid = BUNhead(keys, j);
	int ktype = *(int*) bun_find(key_tpe, lid);
	sql_key *nk = (ktype!=fkey)?(sql_key*)NEW(sql_ukey)
				:(sql_key*)NEW(sql_fkey);
	BUN p,q;

	nk->id = *(oid *) bun_find(key_id, lid);
	nk->type = ktype;
	nk->columns = list_create(NULL);
	nk->t = t;

	if (ktype == ukey || ktype == pkey){
		sql_ukey *uk = (sql_ukey*)nk;
		uk -> keys = NULL;

		if (ktype == pkey)
			t->pkey = uk;
	} else {
		sql_fkey *fk = (sql_fkey*)nk;
		fk -> rkey = NULL;
	}

	cols = BATselect(kc_id, (ptr) & nk->id, (ptr) & nk->id);
	rcols = BATsemijoin(kc_nr, cols);
	BBPunfix(cols->batCacheid);
	cols = BATmirror(rcols);
	rcols = BATsort(cols);
	BBPunfix(cols->batCacheid);
	cols = BATmirror(rcols);

	ccnt = BATcount(cols);
	if (ccnt) {
		BATloop(cols,p,q)
			load_add_column(cols, p, nk);
	}
	BBPunfix(cols->batCacheid);

	if (ktype == fkey){
		sql_fkey *fk = (sql_fkey*)nk;
		oid rkey = *(oid *) bun_find(key_rkey, lid);
		node *n = list_find(tr->keys, &rkey, (fcmp)&key_cmp);
		if (n){
			sql_ukey *uk = n->data;
			fk->rkey = uk;
			if (!uk->keys) uk->keys = list_create(NULL);
			list_append(uk->keys, fk);
		} else {
			list_append(tr->keys, fk);
		}
	} else { /* could be a set of rkeys */
		sql_ukey *uk = (sql_ukey*)nk;
		BAT *keys = BATselect(key_rkey, (ptr) & nk->id, (ptr) & nk->id);
		BATloop(keys,p,q){
			oid fkey = *(oid *) BUNhead(keys, p);
			node *n = list_find(tr->keys, &fkey, (fcmp)&key_cmp);
			if (n){
				sql_fkey *fk = n->data;
				if (!uk->keys) uk->keys = list_create(NULL);
				list_append(uk->keys, fk);
				fk->rkey = uk;
			}
		}
		list_append(tr->keys, nk);
	}
	return nk;
}

static bat mvc_find_bat(char *name)
{
	bat id = BBPindex(name);
	return id;
}

static BAT *mvc_descriptor(bat bid)
{
	BBPfix(bid);
	return BATdescriptor(bid);
}



static sql_column *load_column(sql_table *t, BAT * columns, BUN j)
{
	char name[BUFSIZ];
	sql_column *c = NEW(sql_column);
	ptr lid = BUNhead(columns, j);
	BUN p,q;

	c->id = *(oid *) bun_find(sql_column_id, lid);
	c->name = _strdup((char *) bun_find(sql_column_name, lid));
	c->type = _strdup((char *) bun_find(sql_column_type, lid));
	c->def = _strdup((char *) bun_find(sql_column_default, lid));
	c->null = *(bit *) bun_find(sql_column_null, lid);
	c->colnr = *(int *) bun_find(sql_column_number, lid);

	snprintf(name, BUFSIZ, "%s_%s", t->name, c->name );
	c->bid = mvc_find_bat(name);
	BBPpersistent(c->bid, FALSE);

	snprintf(name, BUFSIZ, "U_%s_%s", t->name, c->name );
	c->ubid = mvc_find_bat(name);
	BBPpersistent(c->ubid, FALSE);

	if (c->bid){
		BAT *b = mvc_descriptor(c->bid);
		BAT *ub = mvc_descriptor(c->ubid);
		BAT *db = mvc_descriptor(t->dbid);

		if (BATcount(ub)){
			void_replace_bat(b, ub);
		}
		if (BATcount(db)){
			void_delete_bat(b, db);
		}
		BBPunfix(b->batCacheid);
		BBPunfix(ub->batCacheid);
		BBPunfix(db->batCacheid);
	}

	c->rtime = 0;
	c->wtime = 0;
	c->flag = TR_OLD;
	return c;
}

static sql_table *load_table(BAT * tables, BUN j)
{
	char name[BUFSIZ];
	sql_table *t = NEW(sql_table);
	ptr lid = BUNhead(tables, j);
	BAT *cols, *rcols, *keys;
	BUN p,q;
	int ccnt;

	t->id = *(oid *) bun_find(sql_table_id, lid);
	t->name = _strdup(bun_find(sql_table_name, lid));
	t->temp = 0;
	t->query = _strdup(bun_find(sql_table_query, lid));
	t->view = *(bit *) bun_find(sql_table_isview, lid);
	t->rtime = 0;
	t->wtime = 0;
	t->flag = TR_OLD;
	t->pkey = NULL;
	t->keys = NULL;
	t->dkeys = NULL;
	t->nkey = NULL;

	snprintf(name, BUFSIZ, "D_%s", t->name );
	t->dbid = mvc_find_bat(name);
	BBPpersistent(t->dbid, FALSE);

	snprintf(name, BUFSIZ, "O_%s", t->name );
	t->obid = mvc_find_bat(name);
	BBPpersistent(t->obid, FALSE);

	t->columns = list_create((fdestroy)&column_destroy);
	t->dcolumns = NULL;
	t->ncolumn = NULL;

	cols = BATselect(sql_column_table, (ptr) & t->id, (ptr) & t->id);
	rcols = BATsemijoin(sql_column_number, cols);
	BBPunfix(cols->batCacheid);
	cols = BATmirror(rcols);
	rcols = BATsort(cols);
	BBPunfix(cols->batCacheid);
	cols = BATmirror(rcols);

	if (!t->view) {
		BATloop (cols,p,q)
			list_append(t->columns, load_column(t, cols, p));
	}
	BBPunfix(cols->batCacheid);

	keys = BATselect(key_table, (ptr) & t->id, (ptr) & t->id);
	ccnt = BATcount(keys);
	if (!t->view && ccnt) {
		t->keys = list_create((fdestroy)&key_destroy);
		BATloop(keys,p,q)
			list_append(t->keys, load_key(keys, p, t));
	}
	BBPunfix(keys->batCacheid);
	return t;
}

static sql_schema *load_schema(BAT * schemas, BUN j)
{
	sql_schema *s = NEW(sql_schema);
	ptr lid = BUNhead(schemas, j);
	BAT *tables;
	BUN p,q;

	s->id = *(oid *) bun_find(sql_schema_id, lid);
	s->name = _strdup(bun_find(sql_schema_name, lid));
	s->auth = _strdup(bun_find(sql_schema_auth, lid));
	s->tables = list_create((fdestroy)&table_destroy);
	s->dtables = NULL;
	s->ntable = NULL;
	s->rtime = 0;
	s->wtime = 0;
	s->flag = TR_OLD;

	tables = BATselect(sql_table_schema, (ptr) & s->id, (ptr) & s->id);
	BATloop(tables,p,q)
		list_append(s->tables, load_table(tables, p));

	BBPunfix(tables->batCacheid);
	return s;
}

static sql_trans *load_trans()
{
	sql_trans *t = NEW(sql_trans);
	BUN p,q;

	gtrans = t; /* need this because gtrans is used when loading keys */
	t->name = NULL;
	t->rtime = 0;
	t->wtime = 0;
	t->stime = timestamp();
	t->level = ISO_SERIALIZABLE;
	t->status = 0;
	t->type = 0;
	t->parent = NULL;

	t->schemas = list_create((fdestroy)&schema_destroy);
	t->dschemas = NULL;
	t->nschema = NULL;
	t->keys = list_create(NULL);

	BATloop(sql_schema_id,p,q)
		list_append(t->schemas, load_schema(sql_schema_id, p));

	list_destroy(t->keys);
	t->keys = list_create(NULL);

	return t;
}

static sql_key *key_dup(sql_trans *tr, sql_key *k, sql_table *t)
{
	sql_key *nk = (k->type!=fkey)?(sql_key*)NEW(sql_ukey)
				:(sql_key*)NEW(sql_fkey);
	node *n;

	nk->id = k->id;
	nk->type = k->type;
	nk->columns = list_create(NULL);
	nk->t = t;

	if (nk->type != fkey){
		sql_ukey *tk = (sql_ukey*)nk;
		tk -> keys = NULL;

		if (nk->type == pkey)
			t->pkey = tk;
	} else {
		sql_fkey *tk = (sql_fkey*)nk;
		tk -> rkey = NULL;
	}

	for(n = k->columns->h; n; n = n->next){
		sql_column *oc = n->data;
		sql_column *c = find_column(t,oc->name); 
		assert(c);
		list_append(nk->columns,c);
	}

	if (nk->type == fkey){
		sql_fkey *fk = (sql_fkey*)nk;
		sql_fkey *ok = (sql_fkey*)k;
		node *n;
		assert( ok->rkey );
		n = list_find(tr->keys, &ok->rkey->k.id, (fcmp)&key_cmp);
		assert(n);
		if (n){
			sql_ukey *uk = n->data;
			fk->rkey = uk;
			if (!uk->keys) uk->keys = list_create(NULL);
			list_append(uk->keys, fk);
		} else {
			list_append(tr->keys, fk);
		}
	} else { /* could be a set of rkeys */
		sql_ukey *uk = (sql_ukey*)nk;
		sql_ukey *ok = (sql_ukey*)k;
		node *m;
		if (ok->keys) for(m=ok->keys->h; m; m = m -> next){
			sql_fkey *ofk = m->data;
			node *n = list_find(tr->keys, &ofk->k.id, (fcmp)&key_cmp);
			if (n){
				sql_fkey *fk = n->data;
				if (!uk->keys) uk->keys = list_create(NULL);
				list_append(uk->keys, fk);
				fk->rkey = uk;
			}
		}
		list_append(tr->keys, nk);
	}
	return nk;
}

static sql_column *column_dup(sql_column * s)
{
	sql_column *c = NEW(sql_column);
	c->id = s->id;
	c->name = _strdup(s->name);
	c->type = _strdup(s->type);
	c->def = _strdup(s->def);
	c->null = s->null;
	c->colnr = s->colnr;
	c->bid = s->bid;
	BBPpersistent(c->bid, FALSE);
	c->ubid = s->ubid;
	BBPpersistent(c->ubid, FALSE);
	c->rtime = 0;
	c->wtime = 0;
	c->flag = TR_OLD;
	return c;
}

static sql_table *table_dup(sql_trans *tr, sql_table * s)
{
	node *n;
	sql_table *t = NEW(sql_table);
	t->id = s->id;
	t->name = _strdup(s->name);
	t->temp = s->temp;
	t->query = _strdup(s->query);
	t->view = s->view;
	t->columns = list_create((fdestroy)&column_destroy);
	t->dcolumns = NULL;
	t->ncolumn = NULL;
	t->rtime = 0;
	t->wtime = 0;
	t->dbid = s->dbid;
	BBPpersistent(t->dbid, FALSE);
	t->obid = s->obid;
	BBPpersistent(t->obid, FALSE);

	t->pkey = NULL;
	t->keys = NULL;
	t->dkeys = NULL;
	t->nkey = NULL;

	t->flag = TR_OLD;

	for (n = s->columns->h; n; n = n->next) {
		sql_column *c = n->data;
		list_append(t->columns, column_dup(c));
	}
	if (s->keys){
		t->keys = list_create((fdestroy)&key_destroy);
	       	for (n = s->keys->h; n; n = n->next) {
			sql_key *k = n->data;
			list_append(t->keys, key_dup(tr,k,t));
		}
	}
	return t;
}

static sql_schema *schema_dup(sql_trans *tr, sql_schema * s)
{
	node *n;
	sql_schema *t = NEW(sql_schema);
	t->id = s->id;
	t->name = _strdup(s->name);
	t->auth = _strdup(s->auth);
	t->tables = list_create((fdestroy)&table_destroy);
	t->dtables = NULL;
	t->ntable = NULL;
	t->rtime = 0;
	t->wtime = 0;
	t->flag = TR_OLD;

	for (n = s->tables->h; n; n = n->next) {
		sql_table *ot = n->data;
		if (!ot->temp)
			list_append(t->tables, table_dup(tr, ot));
	}
	return t;
}


static sql_trans *trans_dup(sql_trans *ot, char *newname ){
	node *n;
	sql_trans *t = NEW(sql_trans);

	t->rtime = 0;
	t->wtime = 0;
	t->stime = timestamp();
	t->level = ot->level;
	t->status = 0;
	t->type = 0;
	t->parent = ot;

	t->schemas = list_create((fdestroy)&schema_destroy);
	t->dschemas = NULL;
	t->nschema = NULL;
	t->keys = list_create(NULL);
	if (newname)
		t->name = _strdup(newname);
	else 
		t->name = NULL;

	for (n = ot->schemas->h; n; n = n->next) {
		list_append(t->schemas, schema_dup(t, n->data));
	}
	return t;
}

static BAT *mvc_bat(char *name, int type)
{
	BAT *b = NULL;
	bat id = mvc_find_bat(name);

	if (mvc_debug)
		printf("mvc_bat %s bid %ld\n", name, id);

	if (id == 0) {
		int cnt = BUFSIZ;
		b = BATnew( TYPE_oid, type, cnt );
		BBPpersistent(b->batCacheid, FALSE);
		BATrename(b, name);
		log_bat_persists(b);
	} else {
		b = mvc_descriptor(id);
	}
	return b;
}

static void new_schema(char *name, char *auth)
{
	int id = BATcount(sql_schema_id);
	int sid = OIDnew(1);

	BUNins(sql_schema_id, (ptr) & id, (ptr) & sid);
	BUNins(sql_schema_name, (ptr) & id, (ptr) name);
	BUNins(sql_schema_auth, (ptr) & id, (ptr) auth);
}

void mvc_init(int debug, char *dirname)
{
	mvc_debug = debug;


	if (mvc_debug)
		printf("mvc_init logdir %s\n", dirname);

	logger_init(mvc_debug, dirname);

	sql_schema_id = mvc_bat("schema_id", TYPE_oid);
	sql_schema_name = mvc_bat("schema_name", TYPE_str);
	sql_schema_auth = mvc_bat("schema_auth", TYPE_str);

	sql_table_id = mvc_bat("table_id", TYPE_oid);
	sql_table_name = mvc_bat("table_name", TYPE_str);
	sql_table_schema = mvc_bat("table_schema", TYPE_oid);
	sql_table_query = mvc_bat("table_query", TYPE_str);
	sql_table_isview = mvc_bat("table_isview", TYPE_bit);

	sql_column_id = mvc_bat("column_id", TYPE_oid);
	sql_column_name = mvc_bat("column_name", TYPE_str);
	sql_column_type = mvc_bat("column_type", TYPE_str);
	sql_column_table = mvc_bat("column_table", TYPE_oid);
	sql_column_default = mvc_bat("column_default", TYPE_str);
	sql_column_null = mvc_bat("column_null", TYPE_bit);
	sql_column_number = mvc_bat("column_number", TYPE_int);

	key_id = mvc_bat("key_id", TYPE_oid);
	key_table = mvc_bat("key_table", TYPE_oid);
	key_tpe = mvc_bat("key_tpe", TYPE_int);
	key_rkey = mvc_bat("key_rkey", TYPE_oid);

	kc_id = mvc_bat("kc_id", TYPE_oid);
	kc_col = mvc_bat("kc_col", TYPE_str);
	kc_nr = mvc_bat("kc_nr", TYPE_int);

	if (BATcount(sql_schema_id) == 0) {
		new_schema("default-schema", "sqladmin");
	}

	mvc_lock = MT_create_lock();

	MT_set_lock(mvc_lock, "mvc_init");

	gtrans = load_trans();

	MT_unset_lock(mvc_lock, "mvc_init");
}

int mvc_login(mvc *m, char *schema, char *user, char *passwd)
{
	/* currently only one schema supported */
	m->trans->schema = find_schema(m->trans, schema);
	if (!m->trans->schema) 
		return -1;
	return 0;
}


void mvc_exit()
{

	if (mvc_debug)
		printf("mvc_exit\n");

	logger_exit(); 
	types_exit();

	BBPunfix(sql_schema_id->batCacheid);
	BBPunfix(sql_schema_name->batCacheid);
	BBPunfix(sql_schema_auth->batCacheid);

	BBPunfix(sql_table_id->batCacheid);
	BBPunfix(sql_table_name->batCacheid);
	BBPunfix(sql_table_schema->batCacheid);
	BBPunfix(sql_table_query->batCacheid);
	BBPunfix(sql_table_isview->batCacheid);

	BBPunfix(sql_column_id->batCacheid);
	BBPunfix(sql_column_name->batCacheid);
	BBPunfix(sql_column_type->batCacheid);
	BBPunfix(sql_column_table->batCacheid);
	BBPunfix(sql_column_default->batCacheid);
	BBPunfix(sql_column_null->batCacheid);
	BBPunfix(sql_column_number->batCacheid);

	BBPunfix(key_id->batCacheid);
	BBPunfix(key_table->batCacheid);
	BBPunfix(key_tpe->batCacheid);
	BBPunfix(key_rkey->batCacheid);

	BBPunfix(kc_id->batCacheid);
	BBPunfix(kc_col->batCacheid);
	BBPunfix(kc_nr->batCacheid);

	trans_destroy(gtrans);
}

mvc *mvc_create(int debug)
{
	mvc *m = NEW(mvc);

	if (debug)
		printf("mvc_create\n");

	MT_set_lock(mvc_lock, "mvc_create");

	m->debug = debug;
	m->trans = NULL;
	m->trans = trans_dup(gtrans,NULL);

	MT_unset_lock(mvc_lock, "mvc_create");
	return m;
}

int mvc_status( mvc *c ){
	sql_trans *t = c->trans;
	int res = t->status;

	t->status = 0;
	return res;
}

int mvc_type( mvc *c ){
	sql_trans *t = c->trans;
	int res = t->type;

	t->type = 0;
	return res;
}


static void bat_log_persists(BAT *ob){
	/* log creation of bat */
	log_bat_persists(ob);
	/*BATmode(ob, PERSISTENT); should be handled by log manager */

}
static void bat_log_transient(BAT *ob){
	/* log destruction of bat */
	log_bat_transient(ob);
	BATmode(ob, TRANSIENT);
}

int void_delete_bat( BAT *b, BAT *u){
	int nr = 0;
	BUN r,s;
	ptr nil = ATOMnilptr(u->ttype);

	BATloop(u, r, s){
		oid *rid = (oid*)BUNtail(u,r);
		BUNreplace(b,  (ptr)rid, nil);
		nr++;
	}
	return nr;
}

int void_replace_bat( BAT *b, BAT *u){
	int nr = 0;
	BUN r,s;

	BATloop(u, r, s){
		oid *rid = (oid*)BUNhead(u,r);
		ptr val = BUNtail(u,r);
		BUNreplace(b,  (ptr)rid, val);
		nr++;
	}
	return nr;
}


int void_insert_bat( BAT *b, BAT *u){
	int nr = 0;
	BUN r,s;
        int sz = BUNsize(u);
	oid nil = oid_nil;

	BATloop(u, r, s){
		oid rid = *(oid*)BUNhead(u,r);
		BUNins(b,  (ptr)&nil, BUNtail(u,r));
		nr++;
	}
	return nr;
}

static void create_key(sql_trans * tr, sql_schema * gs, sql_table *gt, sql_key *gk, int ki )
{
	node *n;
	int kc = BATcount(kc_id);
	int neg = -1;
	int nr = 0;

/*
	gk->id = ki;
*/
	assert (gk->t == gt);

	BUNins(key_id, (ptr) & ki, (ptr) & gk->id);
	BUNins(key_table, (ptr) & ki, (ptr) & gt->id);
	BUNins(key_tpe, (ptr) & ki, (ptr) & gk->type);
	if (gk->type == fkey){
		int rkey;
		assert( ((sql_fkey*)gk)->rkey );
		rkey = ((sql_fkey*)gk)->rkey->k.id;
		BUNins(key_rkey, (ptr) & ki, (ptr) & rkey);
	} else {
		BUNins(key_rkey, (ptr) & ki, (ptr) & neg);
	}
	for (n = gk->columns->h; n; n = n->next, nr++, kc++){
		sql_column *c = n->data;
		BUNins(kc_id, (ptr)&kc, (ptr)&gk->id);
		BUNins(kc_col, (ptr)&kc, (ptr)c->name);
		BUNins(kc_nr, (ptr)&kc, (ptr)&nr);
	}

}

static void create_column(sql_trans * ctr, sql_schema * gs, sql_table *gt, sql_column *gc, int ci )
{
	char name[BUFSIZ];
	BAT *b = mvc_descriptor(gc->bid);
	BAT *u = mvc_descriptor(gc->ubid);

	gc->id = ci;
	gc->rtime = gs->rtime;
	gc->wtime = gs->wtime;

	snprintf(name, BUFSIZ, "%s_%s", gt->name, gc->name );
	BATrename(b, name);
	bat_log_persists(b); 
	BBPunfix(b->batCacheid);

	snprintf(name, BUFSIZ, "U_%s_%s", gt->name, gc->name );
	BATrename(u, name);
	bat_log_persists(u); 
	BBPunfix(u->batCacheid);

	BUNins(sql_column_id, (ptr) & ci, (ptr) & ci);
	BUNins(sql_column_table, (ptr) & ci, (ptr) & gt->id);
	BUNins(sql_column_name, (ptr) & ci, (ptr) gc->name);
	BUNins(sql_column_type, (ptr) & ci, (ptr) gc->type);
	BUNins(sql_column_default, (ptr) & ci, (ptr) gc->def);
	BUNins(sql_column_null, (ptr) & ci, (ptr) & gc->null);
	BUNins(sql_column_number, (ptr) & ci, (ptr) & gc->colnr);
}

static void rollforward_table(sql_trans * ctr, sql_schema * gs, sql_table * ct)
{
	int ci = BATcount(sql_column_id);
	int ki = BATcount(key_id);
	sql_table *gt = find_table(gs, ct->name);
	node *n, *m;

	assert(list_length(gt->columns) == list_length(ct->columns));

	n = ct->columns->h;
	m = gt->columns->h;
	if (n && m) {
		sql_column *cc = n->data;
		sql_column *oc = m->data;

		BAT *cdb = mvc_descriptor(ct->dbid);
		BAT *cob = mvc_descriptor(ct->obid);

		BAT *ds = BATalpha(cdb);
		BAT *os = BATalpha(cob);

		BBPunfix(cdb->batCacheid);
		BBPunfix(cob->batCacheid);

		do {
			sql_column *cc = n->data;
			sql_column *oc = m->data;

			BAT *cb = mvc_descriptor(cc->bid);
			BAT *cub = mvc_descriptor(cc->ubid);
			BAT *ob = mvc_descriptor(oc->bid);

			BAT *ups = BATalpha(cub);
			BAT *ins = BATalpha(cb);

			/* forward inserts */
			if (BATcount(ins)) {
				void_insert_bat(ob, ins);
				log_bat(ob);
			}
			if (BATcount(ds)) {
				void_delete_bat(ob, ds);
			}
			if (BATcount(ups)) {
				BAT *oub = mvc_descriptor(oc->ubid);
				void_insert_bat(oub, ups);
				void_replace_bat(ob, ups);
				log_bat(oub);
				BBPunfix(oub->batCacheid);
			}

			BBPunfix(cb->batCacheid);
			BBPunfix(ob->batCacheid);
			BBPunfix(ins->batCacheid);
			BBPunfix(ups->batCacheid);
			BBPunfix(cub->batCacheid);

			n = n->next;
			m = m->next;
		} while (n && m);

		if (BATcount(ds)) {
			BAT *odb = mvc_descriptor(gt->dbid);
			void_insert_bat(odb, ds);
			log_bat(odb);
			BBPunfix(odb->batCacheid);
		}
		if (BATcount(os)) {
			BAT *oob = mvc_descriptor(gt->obid);
			void_insert_bat(oob, os);
			log_bat(oob);
			BBPunfix(oob->batCacheid);
		}

		gt->rtime = ct->rtime;
		gt->wtime = ct->wtime;
		oc->rtime = cc->rtime;
		oc->wtime = cc->wtime;

		BBPunfix(ds->batCacheid);
		BBPunfix(os->batCacheid);
	}
	for(; n; n = n->next, ci++){
		sql_column *c = n->data;
		create_column( ctr, gs, gt, column_dup(c), ci );
	}
	if (ct->nkey){
		for (n = ct->keys->h; n->data != ct->nkey; n = n->next);

		for (; n; n = n->next, ki++) {
			sql_key *ck = n->data;
			create_key( ctr, gs, gt, key_dup(ctr,ck,gt), ki );
		}
	}
}

static void create_keys(sql_trans * tr, sql_schema * s, sql_table * t)
{
	node *n;
	int ki = BATcount(key_id);

	if (t->keys) for (n = t->keys->h; n; n = n->next, ki++) {
		sql_key *k = n->data;
		create_key( tr, s, t, k, ki);
	}
}

static void create_columns(sql_trans * tr, sql_schema * s, sql_table * t)
{
	node *n;
	int ci = BATcount(sql_column_id);

	for (n = t->columns->h; n; n = n->next) {
		sql_column *c = n->data;
		create_column( tr, s, t, c, ci);
		ci++;
	}
}

void mvc_drop_keys(sql_trans * tr, sql_table * t)
{
	node *n;

	if (t->keys) for (n = t->keys->h; n; n = n->next) {
		sql_key *k = n->data;
		BAT *b = BATselect(kc_id, (ptr) & k->id, (ptr) & k->id );
		BUN p,q;

		BUNdelHead(key_id, (ptr) & k->id);
		BUNdelHead(key_table, (ptr) & k->id);
		BUNdelHead(key_tpe, (ptr) & k->id);
		BUNdelHead(key_rkey, (ptr) & k->id);

		BATloop(b,p,q){
			oid id = *(oid*)BUNhead(kc_id, p);

			BUNdelHead(kc_id, (ptr) & id);
			BUNdelHead(kc_col, (ptr) & id);
			BUNdelHead(kc_nr, (ptr) & id);
		}
		BBPunfix(b->batCacheid);
	}
}

void mvc_drop_columns(sql_trans * tr, sql_table * t)
{
	node *n;

	for (n = t->columns->h; n; n = n->next) {
		sql_column *c = n->data;
		BAT *b,*u;

 		b = mvc_descriptor(c->bid);
		bat_log_transient(b); 
		BBPunfix(b->batCacheid);

		u = mvc_descriptor(c->ubid);
		bat_log_transient(u); 
		BBPunfix(u->batCacheid);

		BUNdelHead(sql_column_id, (ptr) & c->id);
		BUNdelHead(sql_column_table, (ptr) & c->id);
		BUNdelHead(sql_column_name, (ptr) & c->id);
		BUNdelHead(sql_column_type, (ptr) & c->id);
		BUNdelHead(sql_column_default, (ptr) & c->id);
		BUNdelHead(sql_column_null, (ptr) & c->id);
		BUNdelHead(sql_column_number, (ptr) & c->id);
	}
}

static void mvc_forward_create_table(sql_trans * tr, sql_schema * ns,
				     sql_table * nt)
{
	bit view = nt->view;
	nt->id = BATcount(sql_table_id);
	nt->rtime = ns->rtime;
	nt->wtime = ns->wtime;

	BUNins(sql_table_id, (ptr) & nt->id, (ptr) & nt->id);
	BUNins(sql_table_schema, (ptr) & nt->id, (ptr) & ns->id);
	BUNins(sql_table_name, (ptr) & nt->id, (ptr) nt->name);
	BUNins(sql_table_isview, (ptr) & nt->id, (ptr) & view);
	BUNins(sql_table_query, (ptr) & nt->id, (ptr) nt->query);
	if (!nt->view){
		char name[BUFSIZ];
		BAT *o = mvc_descriptor(nt->obid);
		BAT *d = mvc_descriptor(nt->dbid);

		snprintf(name, BUFSIZ, "O_%s", nt->name );
		BATrename(o, name);
		snprintf(name, BUFSIZ, "D_%s", nt->name );
		BATrename(d, name);

		bat_log_persists(o); 
		bat_log_persists(d); 

		BBPunfix(o->batCacheid);
		BBPunfix(d->batCacheid);

		create_columns(tr, ns, nt);
		create_keys(tr, ns, nt);
	}
}

static void rollforward_tables(sql_trans *tr, sql_schema * s)
{
	sql_trans *gtr = tr->parent;
	node *n;
	sql_schema *os = find_schema(gtr, s->name);

	/* delete the dropped tables */
	if (s->dtables) for (n = s->dtables->h; n; n = n->next) {	
		sql_table *t = n->data;
		sql_table *ot = find_table(os, t->name);


		BUNdelHead(sql_table_id, (ptr) & t->id);
		BUNdelHead(sql_table_schema, (ptr) & t->id);
		BUNdelHead(sql_table_name, (ptr) & t->id);
		BUNdelHead(sql_table_isview, (ptr) & t->id);
		BUNdelHead(sql_table_query, (ptr) & t->id);
		if (!t->view){
			BAT *o = mvc_descriptor(t->obid);
			BAT *d = mvc_descriptor(t->dbid);
			bat_log_transient(o); 
			bat_log_transient(d); 
			BBPunfix(o->batCacheid);
			BBPunfix(d->batCacheid);
		} 

		mvc_drop_keys(tr, t);
		mvc_drop_columns(tr, t);

		list_remove_data(os->tables, ot);
		table_destroy(ot);
	}
	/* changes to the existing tables */
	for (n = s->tables->h; n && n->data != s->ntable; n = n->next) {	
		sql_table *t = n->data;
		if (t->flag == TR_OLD)
			rollforward_table(tr, os, t);
	}
	/* add the new tables */
	for (; n; n = n->next) {	
		sql_table *nt, *t = n->data;

		if (!t->temp) {
			mvc_forward_create_table(tr, os, nt = table_dup(gtr,t));
			list_append(os->tables, nt);
		}
	}
}

static void rollforward_schemas(sql_trans *tr)
{
	node *n;

	/* delete the dropped schemas */
	if (tr->dschemas) for (n = tr->dschemas->h; n; n = n->next) {	
		sql_schema *s = n->data;
		sql_schema *os = find_schema(tr->parent, s->name);

		/* TODO move to the removed list if not top trans */
		list_remove_data(tr->parent->schemas, os);
		schema_destroy(os);

		if (tr->parent == gtrans){
			BUNdelHead(sql_schema_id, (ptr) & s->id);
			BUNdelHead(sql_schema_name, (ptr) & s->id);
			BUNdelHead(sql_schema_auth, (ptr) & s->id);
		}
	}
	/* changes to the existing schemas */
	for (n = tr->schemas->h; n && n->data != tr->nschema; n = n->next) {	
		sql_schema *s = n->data;
		if (s->flag == TR_OLD)
			rollforward_tables(tr, s);
	}
	/* add the new schemas */
	for (; n; n = n->next) {	
		sql_schema *ns = schema_dup(tr, n->data);

		if (tr->parent == gtrans){
			ns->id = BATcount(sql_schema_id);

			BUNins(sql_schema_id, (ptr) & ns->id,
			   (ptr) & ns->id);
			BUNins(sql_schema_name, (ptr) & ns->id,
			   (ptr) ns->name);
			BUNins(sql_schema_auth, (ptr) & ns->id,
			   (ptr) ns->auth);

			/* add the new tables */
			for (n = ns->tables->h; n; n = n->next) {
				sql_table *nt = n->data;
				mvc_forward_create_table(tr, ns, nt);
			}
			list_append(tr->parent->schemas, ns);
		}
	}
	if (tr->parent == gtrans){
		log_bat(sql_table_id);
		log_bat(sql_table_schema);
		log_bat(sql_table_name);
		log_bat(sql_table_isview);
		log_bat(sql_table_query);

		log_bat(sql_column_id);
		log_bat(sql_column_table);
		log_bat(sql_column_name);
		log_bat(sql_column_type);
		log_bat(sql_column_default);
		log_bat(sql_column_null);
		log_bat(sql_column_number);

		log_bat(sql_schema_id);
		log_bat(sql_schema_name);
		log_bat(sql_schema_auth);

		log_bat(key_id);
		log_bat(key_table);
		log_bat(key_tpe);
		log_bat(key_rkey);

		log_bat(kc_id);
		log_bat(kc_col);
		log_bat(kc_nr);
		logger_commit();
	}
	list_destroy(tr->keys);
	tr->keys = list_create(NULL);
}


static int validate_tables(sql_schema * s, sql_schema * os)
{
	node *n, *o, *p;

	for (n = s->tables->h; n; n = n->next) {
		sql_table *t = n->data;
		sql_table *ot = find_table(os, t->name);

		if (ot || (t->wtime == 0 && t->rtime == 0)) {
			for (o = t->columns->h, p = ot->columns->h;
			     o && p; o = o->next, p = p->next) {
				sql_column *c = o->data;
				sql_column *oc = p->data;
				/* t wrote, ie. check read and write time */
				/* read or write after t's write */
				if (c->wtime &&
				    (c->wtime < oc->rtime
				     || c->wtime < oc->wtime)) {
					return 0;
				}
				/* commited write before t's read */
				if (c->rtime && c->rtime < oc->wtime) {
					return 0;
				}
			}
		}
	}
	return 1;
}

static int validate(sql_trans *tr)
{
	node *n;
	/* depends on the iso level */

	/* since we protect usage through private copies both the iso levels
	   read uncommited and read commited always succeed.
	 */
	if (tr->level == ISO_READ_UNCOMMITED
	    || tr->level == ISO_READ_COMMITED)
		return 1;

	/* If only 'inserts' occurred on the read bats the repeatable reads
	   iso level can continue */

	/* the hard case */
	for (n = tr->schemas->h; n; n = n->next) {
		sql_schema *s = n->data;
		sql_schema *os = find_schema(tr->parent, s->name);
		if (os || (s->wtime == 0 && s->rtime == 0)) {
			if (!validate_tables(s, os)) return 0;
		}
	}
	return 1;
}

/* 
 * mvc_commit implements the last two phases (out of 3) of 
 * optimistic concurrency control. The first phase, ie. read phase 
 * starts when the transaction is started (aka with any sql statement) 
 * and ends with mvc_commit. The validation phase checks the timestamps 
 * to see if a commit could succeed. Then the write phase makes 
 * the changes global.
 *
 * Commit will first forward the changes to the schema, ie.
 * leaving out the temp tables and adding the new tables directly.
 * 
 * After that the changes to existing tables are forwarded.
 */

int mvc_commit(mvc * m, int chain, char *name)
{
	sql_trans *tr = m->trans;
	int level = (chain)?tr->level:ISO_SERIALIZABLE;
	int res = -1;

	if (m->debug)
		printf("mvc_commit\n");

	/* savepoint then simply make a copy of the current transaction */
	if (name && name[0] != '\0'){
		m->trans = trans_dup(m->trans, name);
		return 0;
	}

	/* if there is nothing to commit reused the transaction */
	if (tr->wtime == 0) {
		tr->stime = timestamp();
		return 0;
	}

	MT_set_lock(mvc_lock, "mvc_commit");

	/* validation phase */
	if (validate(tr)) {
		/* write phase */
		rollforward_schemas(tr);
		res = 0;
	}

	MT_unset_lock(mvc_lock, "mvc_commit");

	tr = m->trans;
	while(tr->parent) 
		tr = trans_destroy(tr);

	m->trans = trans_dup(tr,NULL);
	m->trans->level = level;
	m->trans->status = res;
	return res;
}

int mvc_rollback(mvc * m, int chain, char *name)
{
	int res = 0;
	int level = (chain)?m->trans->level:ISO_SERIALIZABLE;
	sql_trans *tr = m->trans;

	if (m->debug)
		printf("mvc_rollback\n");

	if (name && name[0] != '\0'){
		while(tr->name && strcmp(tr->name,name) != 0)
	       		tr = trans_destroy(tr);
		m->trans = tr; /* restart at savepoint */
	} else {
		while(tr->parent) 
	       		tr = trans_destroy(tr);
		m->trans = trans_dup(tr,NULL);
	}
	m->trans->level = level;
	m->trans->status = 0;
	return res;
}

/* release all savepoints up including the given named savepoint 
 * but keep the current changes.
 * */
int mvc_release(mvc * m, char *name)
{
	int res = 0;
	sql_trans *tr = m->trans;
	sql_trans *p = tr->parent;

	while(p->name && strcmp(p->name, name) != 0)
	   	p = trans_destroy(p);

	tr->parent = p; 
	m->trans = tr; /* restart at savepoint */
	m->trans->status = res;
	return res;
}

int mvc_set_iso_level(mvc * m, int level)
{
	int res = mvc_commit(m,1,NULL);
	m->trans->level = level;
	m->trans->status = res;
	return res;
}

void mvc_destroy(mvc * m)
{
	sql_trans *tr;

	tr = m->trans;
	while(tr->parent) tr = trans_destroy(tr);
	_DELETE(m);
}

static BAT *bind_writable(sql_trans * tr, sql_column * c)
{
	BAT *nb = NULL, *b = mvc_descriptor(c->bid);
	if (c->wtime == 0) {	/* first write ie. need to copy */
		nb = BATcopy(b);
		BBPtransient(b->batCacheid, FALSE);
		BBPunfix(b->batCacheid);
		b = nb;
		c->bid = b->batCacheid;
		BBPpersistent(b->batCacheid, FALSE);
		BATfakeCommit(b);
		c->wtime = tr->wtime = tr->stime;
	}
	return b;
}

BAT *mvc_bind(mvc * m, char *tname, char *cname, int access)
{
	sql_trans *tr = m->trans;
	BAT *b = NULL;
	sql_table *t = find_table(tr->schema, tname);
	sql_column *c;

	if (m->debug)
		printf("mvc_bind %s.%s\n", tname, cname);

	/* TODO check for access */

	assert(t);

	c = find_column(t, cname);
	if (access > 0){
		b = bind_writable(tr, c);
	} else {
		b = mvc_descriptor(c->bid);
	}

	c->rtime = t->rtime = tr->rtime = tr->stime;
	return b;
}

BAT *mvc_bind_ubat(mvc * m, char *tname, char *cname, int access )
{
	sql_trans *tr = m->trans;
	BAT *nb, *b = NULL;
	sql_table *t = find_table(tr->schema, tname);
	sql_column *c;

	if (m->debug)
		printf("mvc_bind_ubat %s.%s\n", tname, cname);

	/* TODO check for access */

	assert(t);

	c = find_column(t, cname);
	b = mvc_descriptor(c->ubid);
	if (c->wtime == 0) {	/* first write ie. need to copy */
		nb = BATcopy(b);
		BBPtransient(b->batCacheid, FALSE);
		BBPunfix(b->batCacheid);
		b = nb;
		c->ubid = b->batCacheid;
		BBPpersistent(b->batCacheid, FALSE);
		BATfakeCommit(b);
		c->wtime = c->rtime = t->rtime = tr->rtime = tr->stime;
	}

	c->rtime = t->rtime = tr->rtime = tr->stime;
	return b;
}

BAT *mvc_bind_obat(mvc * m, char *tname, int access )
{
	sql_trans *tr = m->trans;
	BAT *nb, *b = NULL;
	sql_table *t = find_table(tr->schema, tname);
	sql_column *c;

	if (m->debug)
		printf("mvc_bind_obat %s.oid\n", tname );

	/* TODO check for access */

	assert(t);

	b = mvc_descriptor(t->obid);
	if (t->wtime == 0) {	/* first write ie. need to copy */
		nb = BATcopy(b);
		BBPtransient(b->batCacheid, FALSE);
		BBPunfix(b->batCacheid);
		b = nb;
		t->obid = b->batCacheid;
		BBPpersistent(b->batCacheid, FALSE);
		BATfakeCommit(b);
		t->wtime = t->rtime = tr->rtime = tr->stime;
	}

	t->rtime = tr->rtime = tr->stime;
	return b;
}
BAT *mvc_bind_dbat(mvc * m, char *tname, int access )
{
	sql_trans *tr = m->trans;
	BAT *nb, *b = NULL;
	sql_table *t = find_table(tr->schema, tname);
	sql_column *c;

	if (m->debug)
		printf("mvc_bind_dbat %s.deletes\n", tname );

	/* TODO check for access */

	assert(t);

	b = mvc_descriptor(t->dbid);
	if (t->wtime == 0) {	/* first write ie. need to copy */
		nb = BATcopy(b);
		BBPtransient(b->batCacheid, FALSE);
		BBPunfix(b->batCacheid);
		b = nb;
		t->dbid = b->batCacheid;
		BBPpersistent(b->batCacheid, FALSE);
		BATfakeCommit(b);
		t->wtime = t->rtime = tr->rtime = tr->stime;
	}

	t->rtime = tr->rtime = tr->stime;
	return b;
}

sql_schema *mvc_bind_schema(mvc * m, char *sname )
{
	sql_trans *tr = m->trans;
	sql_schema *s = find_schema(tr, sname);
	if (!s)
		return NULL;
	s->wtime = tr->wtime;

	if (m->debug)
		printf("mvc_bind_schema %s\n", sname );

	return s;
}

sql_table *mvc_bind_table(mvc * m, sql_schema *s, char *tname )
{
	sql_table *t = find_table(s, tname);
	if (!t)
		return NULL;
	t->wtime = s->wtime;

	if (m->debug)
		printf("mvc_bind_table %s.%s\n", s->name, tname );

	return t;
}

sql_column *mvc_bind_column(mvc * m, sql_table * t, char *cname )
{
	sql_column *c = find_column(t, cname);
	if (!c)
		return NULL;
	c->wtime = t->wtime;

	if (m->debug)
		printf("mvc_bind_column %s.%s\n", t->name, cname );

	return c;
}


sql_key *mvc_bind_key(mvc * m, sql_table * t, va_list ap )
{
	sql_key *k = NULL;
	list *l;
	char *p;
	node *kn, *nn;
	int len;

	if (!t->keys)
		return NULL;

 	l = list_create(NULL);
	while(p = va_arg(ap,char*)){
		list_append(l,p);
	}
	len = list_length(l);
	
	for(kn = t->keys->h; !k && kn; kn = kn -> next){
		k = kn->data;
		if (list_length(k->columns) == len){
			node *cc;
			for(cc = k->columns->h, nn = l->h; cc && nn; 
				cc = cc -> next, nn = nn -> next){
				sql_column *c = cc->data;
				if (strcmp(c->name, nn->data) != 0){
					k = NULL;
					break;
				}
			}
		} else {
			k = NULL;
		}
	}
	list_destroy(l);

	if (m->debug)
		printf("mvc_bind_key %s.(%s..)\n", t->name, 
		 	((sql_column*)k->columns->h->data)->name );

	return k;
}


sql_schema *mvc_create_schema(mvc * m, char *name, char *auth)
{
	sql_trans *tr = m->trans;
	sql_schema *s = NEW(sql_schema);

	if (m->debug)
		printf("mvc_create_schema %s %s\n", name, auth);

	s->id = 0;
	s->name = _strdup(name);
	s->auth = _strdup(auth);
	s->flag = TR_NEW;

	if (!tr->nschema) tr->nschema = s;
	list_append(tr->schemas, s);

	s->wtime = tr->wtime = tr->stime;
	return s;
}


void mvc_drop_schema(mvc * m, char *sname)
{
	sql_trans *tr = m->trans;
	node *n = find_schema_node(tr, sname);
	sql_schema *s = n->data; 

	if (m->debug)
		printf("mvc_drop_schema %s\n", sname);

	if (s->flag == TR_NEW) {
		if (tr->nschema == s){
			if (n->next)
				tr->nschema = n->next->data;
			else
				tr->nschema = NULL;
		}
		list_remove_data(tr->schemas, s);
		schema_destroy(s);
	} else {
		if (!tr->dschemas) 
			tr->dschemas = 
				list_create((fdestroy)&schema_destroy);
		list_move_data(tr->schemas, tr->dschemas, s);
	}
	s->wtime = tr->wtime = tr->stime;
}

static sql_table *create_table_intern( mvc *m, char *name, bit temp)
{
	sql_table *t = NEW(sql_table);

	t->id = 0;
	t->name = _strdup(name);
	t->temp = temp;
	t->query = NULL;
	t->view = 0;
	t->flag = TR_NEW;
	t->columns = list_create((fdestroy)&column_destroy);
	t->dcolumns = NULL;
	t->ncolumn = NULL;
	t->pkey = NULL;
	t->keys = NULL;
	t->dkeys = NULL;
	t->nkey = NULL;
	t->obid = 0;
	t->dbid = 0;
	return t;
}

sql_key *mvc_create_key( mvc * m, sql_table *t, int kt, sql_key *rkey )
{ 
	sql_key *nk = (kt!=fkey)?(sql_key*)NEW(sql_ukey)
				:(sql_key*)NEW(sql_fkey);

	if (m->debug)
		printf("mvc_create_key %s %d %d\n", t->name, kt, (int)rkey);

	nk->id = key_new_id();
	nk->type = kt;
	nk->columns = list_create(NULL);
	nk->t = t;

	if (nk->type != fkey){
		sql_ukey *uk = (sql_ukey*)nk;
		uk -> keys = NULL;

		if (nk->type == pkey)
			t->pkey = uk;
	} else {
		sql_fkey *fk = (sql_fkey*)nk;
		sql_ukey *uk = (sql_ukey*)rkey;

		int cnt = BUFSIZ;
		BAT *b = BATnew( TYPE_void, TYPE_oid, cnt );
		BATseqbase(b,0);
		fk->bid = b->batCacheid;
		BBPpersistent(b->batCacheid, FALSE);
		BBPunfix(b->batCacheid);

		fk -> rkey = uk;
		if (!uk->keys) uk->keys = list_create(NULL);
		list_append(uk->keys, fk);

		
	}

	if (!t->nkey) t->nkey = nk;
	if (!t->keys)
		t->keys = list_create((fdestroy)&key_destroy);
	list_append(t->keys, nk);

	return nk;
}

sql_key *mvc_key_add_column( mvc * m, sql_key *k, sql_column *c ){

	if (m->debug)
		printf("mvc_key_add_column %s\n", c->name);
	list_append(k->columns, c);
	return k;
}

sql_table *mvc_create_table(mvc * m, sql_schema *s, char *name, bit temp)
{
	int cnt = BUFSIZ;
	sql_trans *tr = m->trans;
	sql_table *t = create_table_intern(m, name, temp);
	BAT *o = BATnew( TYPE_void, TYPE_oid, cnt );
	BAT *d = BATnew( TYPE_void, TYPE_oid, cnt );

	if (m->debug)
		printf("mvc_create_table %s %s %d\n", s->name, name, temp);

	t->query = _strdup("");
	if (!s->ntable) s->ntable = t;
	list_append(s->tables, t);

	t->obid = o->batCacheid;
	BBPpersistent(o->batCacheid, FALSE);
	BBPunfix(o->batCacheid);
	t->dbid = d->batCacheid;
	BBPpersistent(d->batCacheid, FALSE);
	BBPunfix(d->batCacheid);

	t->wtime = s->wtime = tr->wtime = tr->stime;
	return t;
}

sql_table *mvc_create_view(mvc * m, sql_schema *s, char *name, char *sql)
{
	sql_trans *tr = m->trans;
	sql_table *t = create_table_intern(m, name, 0);

	if (m->debug)
		printf("mvc_create_view %s %s %s\n", s->name, name, sql);

	t->query = _strdup(sql);
	t->view = 1;
	if (!s->ntable) s->ntable = t;
	list_append(s->tables, t);

	t->wtime = s->wtime = tr->wtime = tr->stime;
	return t;
}

void mvc_drop_table(mvc * m, sql_schema *s, char *name, bit cascade)
{
	sql_trans *tr = m->trans;
	node *n = find_table_node(s, name );
	sql_table *t = n->data;

	if (m->debug)
		printf("mvc_drop_table %s %s\n", s->name, name);

	if (t->flag == TR_NEW) {
		if (s->ntable == t){
			if (n->next)
				s->ntable = n->next->data;
			else
				s->ntable = NULL;
		}
		list_remove_data(s->tables, t);
		table_destroy(t);
	} else {
		if (!s->dtables) 
			s->dtables = list_create((fdestroy)&table_destroy);
		list_move_data(s->tables, s->dtables, t);
	}
	/* TODO cascade, ie. remove al references to this table */
	t->wtime = s->wtime = tr->wtime = tr->stime;
}

sql_column *mvc_create_column(mvc * m, sql_table *t, char *name,
		       char *sqltype, int seqnr)
{
	sql_trans *tr = m->trans;
	sql_column *col = NEW(sql_column);

	char *typename = sql_bind_type(sqltype)->name;
	int type = ATOMindex(typename);
	int cnt = BUFSIZ;

	BAT *u = BATnew( TYPE_oid, type, cnt );
	BAT *b = BATnew( TYPE_void, type, cnt );
	BATseqbase(b,0);

	if (m->debug)
		printf("mvc_create_column %s %s %s %d\n", t->name,
		       name, sqltype, seqnr);

	col->id = 0;
	col->name = _strdup(name);
	col->type = _strdup(sqltype);
	col->def = _strdup("");
	col->null = 1;
	col->colnr = seqnr;
	col->rtime = 0;
	col->flag = TR_NEW;

	col->bid = b->batCacheid;
	BBPpersistent(b->batCacheid, FALSE);
	BBPunfix(b->batCacheid);

	col->ubid = u->batCacheid;
	BBPpersistent(u->batCacheid, FALSE);
	BBPunfix(u->batCacheid);

	if (!t->ncolumn) t->ncolumn = col;
	list_append(t->columns, col);

	col->wtime = t->wtime = tr->wtime = tr->stime;

	return col;
}

void mvc_drop_column(mvc * m, sql_table *t, char *name)
{
	sql_trans *tr = m->trans;
	node *n = find_column_node(t, name);
	sql_column *col = n->data;

	if (m->debug)
		printf("mvc_drop_column %s %s\n", t->name, name);

	if (col->flag == TR_NEW) {
		if (t->ncolumn == col){
			if (n->next)
				t->ncolumn = n->next->data;
			else
				t->ncolumn = NULL;
		}
		list_remove_data(t->columns, col);
		column_destroy(col);
	} else {
		if (!t->dcolumns) 
			t->dcolumns = list_create((fdestroy)&column_destroy);
		list_move_data(t->columns, t->dcolumns, col);
	}

	col->wtime = t->wtime = tr->wtime = tr->stime;
}

sql_column * mvc_not_null(mvc * m, sql_column * col)
{
	sql_trans *tr = m->trans;

	if (m->debug)
		printf("mvc_not_null %s\n", col->name);

	col->null = 0;

	col->wtime = tr->wtime = tr->stime;
	return col;
}

sql_column * mvc_default(mvc * m, sql_column * col, char *val)
{
	sql_trans *tr = m->trans;

	if (m->debug)
		printf("mvc_default %s %s\n", col->name, val);

	_DELETE(col->def);
	col->def = _strdup(val);

	col->wtime = tr->wtime = tr->stime;
	return col;
}

void mvc_export_schema(mvc * c, stream * s )
{
	sql_trans *tr = c->trans;
	node *n;
	char buf[BUFSIZ];
	int i;

	i = snprintf(buf, BUFSIZ, "%d\n", list_length(tr->schema->tables));
	s->write(s, buf, i, 1);
	for (n = tr->schema->tables->h; n; n = n->next) {
		node *m;
		sql_table *t = n->data;
		int clen = list_length(t->columns);
		int klen = t->keys?list_length(t->keys):0;
		i = snprintf(buf, BUFSIZ, "%d,%s,%d,%s,%d\n",
				 t->id, t->name, clen, t->query, klen);
		s->write(s, buf, i, 1);

		if (!t->view) {
			for (m = t->columns->h; m; m = m->next) {
				sql_column *col = m->data;
				i = snprintf(buf, BUFSIZ,
					     "%d,%s,%s,%s,%d\n",
					     col->id, col->name,
					     col->type, col->def,
					     col->null);
				s->write(s, buf, i, 1);
			}
			if (t->keys) for (m = t->keys->h; m; m = m->next) {
				node *l;
				sql_key *k = m->data;
				i = snprintf(buf, BUFSIZ, "%d,%d,%d,%d\n",
					     k->id, k->type,
					     list_length(k->columns),
					     (k->type==fkey)?
						((sql_fkey*)k)->rkey->k.id:0);

				s->write(s, buf, i, 1);
				for (l = k->columns->h; l; l = l->next){
					sql_column *col = l->data;
					i = snprintf(buf, BUFSIZ, 
						"%s\n", col->name); 
					s->write(s, buf, i, 1);
				}
			}
		}
	}
	s->flush(s);
}

void mvc_export(stream * s, BAT * order, BAT * bats, char *sep,
		char *rsep)
{
	oid nil = oid_nil;
	char buf[BUFSIZ];
	int i, cnt = BATcount(bats);
	BAT *seps = BATnew( TYPE_void, TYPE_str, cnt );
	BATseqbase(seps,0);

	for (i = 0; i < cnt - 1; i++) {
		BUNins(seps, (ptr) &nil, (ptr) &sep);
	}
	BUNins(seps, (ptr) &nil, (ptr) &rsep);

	i = snprintf(buf, BUFSIZ, "%d\n", BATcount(order));
	s->write(s, buf, i, 1);
	ASCIIoutput(order, seps, bats, s);
	BBPreclaim(seps);
}

int mvc_import_table( mvc *m, stream *s, char *tname, 
		char *sep, char *rsep, int sz)
{
	BUN p,q;
	oid nil = oid_nil;
	int nr = 0, i, cnt; 
	oid newid;
	sql_column *col;
	sql_trans *tr = m->trans;
	node *n;
	sql_table *t = find_table(tr->schema, tname);
	BAT *rbats, *bns, *bats, *nmes, *seps, *tpes, *inss, *b;

	if (!t){
		fprintf(stderr,"ERROR: table %s not found\n", tname );
		tr->status = -1;
		return -1;
	}
	if (!s || s->errnr){
		fprintf(stderr,"ERROR: stream not open %d\n", s->errnr );
		tr->status = -1;
		return  -1;
	}

	bats = BATnew( TYPE_void, TYPE_bat, cnt );
	BATseqbase(bats,0);

	nmes = BATnew( TYPE_void, TYPE_str, cnt );
	BATseqbase(nmes,0);

	seps = BATnew( TYPE_void, TYPE_str, cnt );
	BATseqbase(seps,0);

	tpes = BATnew( TYPE_void, TYPE_str, cnt );
	BATseqbase(tpes,0);

	t->wtime = tr->wtime = tr->stime;
	for (n = t->columns->h; n && n->next; n = n->next, nr++) 
	{
		col = n->data;

		b = bind_writable(tr, col);
		BUNins(bats, (ptr)&nil, (ptr)&(b->batCacheid));
		BUNins(nmes, (ptr)&nil, BBPname(b->batCacheid));
		BUNins(seps, (ptr)&nil, sep);
		BUNins(tpes, (ptr)&nil, ATOMname(b->ttype));
		BBPunfix(b->batCacheid);
	}
	if (n){
		col = n->data;
		b = bind_writable(tr, col);
		BUNins(bats, (ptr)&nil, (ptr)&(b->batCacheid));
		BUNins(nmes, (ptr)&nil, BBPname(b->batCacheid));
		BUNins(seps, (ptr)&nil, rsep);
		BUNins(tpes, (ptr)&nil, ATOMname(b->ttype));
		BBPunfix(b->batCacheid);
	}
	inss = ASCIIinput( nmes, seps, tpes, s, sz);
	if (!inss)
		return -1;
	bns = BATjoin(BATmirror(bats),nmes);
	rbats = BATjoin(bns,inss);

	
	BATloop(rbats,p,q){
		BAT *ba = mvc_descriptor(*(bat*)BUNhead(rbats, p));
		BAT *in = mvc_descriptor(*(bat*)BUNtail(rbats, p));

		cnt = BATcount(in);
		BATins(ba,in);

		BBPunfix(ba->batCacheid);
		BBPunfix(in->batCacheid);
	} 
	col = t->columns->h->data;
	b = mvc_bind_obat(m, t->name, INS);
	newid = OIDnew(cnt);
	nr = cnt;
	for(;cnt;cnt--, newid++)
		BUNins(b, (ptr)&nil, (ptr)&newid );
	BBPunfix(b->batCacheid);

	BBPreclaim(bns);
	BBPreclaim(rbats);
	BBPreclaim(inss);
	BBPreclaim(bats);
	BBPreclaim(nmes);
	BBPreclaim(seps);
	BBPreclaim(tpes);
	tr->status = nr;
	return nr;
}
