@f mvc
@a N.J. Nes
@* 

@h
/* multi version catalog */
#ifndef __MVC_H
#define __MVC_H

#include <gdk.h>
#include <mem.h>
#include <catalog.h>
#include <stdarg.h>
#include <query.h>

#define ISO_READ_UNCOMMITED 1
#define ISO_READ_COMMITED   2
#define ISO_READ_REPEAT	    3
#define ISO_SERIALIZABLE    4

/* todo change the sql_schema/sql_table/sql_column such that it only contains
 * operational data (access rules and times and bids)
 *
 * name bats using schema_table_column etc.
 * 
 * support multiple db's using multiple log managers...
 * requires bat names to be optained through the log manager.
 */

/* fkey consists of two of these */
typedef struct sql_key { /* pkey, ukey, fkey */
	oid id;
	char *name; 	/* constraint name */
	key_type type; /* pkey, ukey, fkey */
	struct list *columns; 
	struct sql_table *t;

	bat bid; /* bid for index(void,oid) or hash (void,int) */
} sql_key;

typedef struct sql_ukey { /* pkey, ukey */
	sql_key k;
	list *keys;
} sql_ukey;

typedef struct sql_fkey { /* fkey */
	sql_key k;
	struct sql_ukey *rkey; /* only set for fkey and rkey */
} sql_fkey;

typedef struct sql_column {
	oid id;
	char *name;
	sql_subtype *type;
	int colnr;

	char *def;
	int null;

	bat bid;
	bat ubid;     /* bat with updates */
	int rtime;
	int wtime;
	int flag;

	struct sql_table *t;

} sql_column;

typedef struct sql_table {
	oid id;
	char *name;
	int type;
	char *query;
	struct list *columns;
	struct list *dcolumns;
	sql_column *ncolumn;
	sql_ukey *pkey;
	struct list *keys; 	/* all keys (primary,unique and foreign) */
	sql_key *nkey;
	struct list *dkeys;	/* list of dropped keys, not used jet */

	bat obid;     /* bat with oids */
	bat dbid;     /* bat with deletes */
	int rtime;
	int wtime;
	int flag;

	struct sql_schema *s;
} sql_table;

typedef struct sql_schema {
	oid id;
	char *name;
	char *auth;

	int rtime;
	int wtime;
	int flag;

	list *tables;
	list *dtables;
	sql_table *ntable;
} sql_schema;

typedef struct sql_trans {
	char *name;
	int stime; /* transaction time stamp (aka start time) */
	int rtime;
	int wtime;
	int level; 
	int status;
	int type;

	sql_schema *schema;
	list *schemas;
	list *dschemas;
	sql_schema *nschema;

	list *keys; /* need a place to keep keys during the foreing key
		       initialization */

	struct sql_trans *parent; /* multilevel transaction support */
} sql_trans;

typedef struct mvc {
	int debug;

	sql_trans *trans;
} mvc;


extern void mvc_init(int debug, char *dirname);
extern void mvc_exit();

extern mvc *mvc_create( int debug );
extern void mvc_destroy( mvc *c );
extern char *mvc_login( mvc *c, char *user, char *passwd );
extern char *mvc_admin_login( mvc *c );
/* later a change_schema and a change_database could be added */

extern int mvc_status( mvc *c );
extern int mvc_type( mvc *c );

/* since Savepoints and transactions related the 
 * statement commit function includes the savepoint creation.
 * And rollbacks can be eigther full or until a given savepoint. 
 * The special statement_release can be used to release savepoints. 
 */
extern int mvc_commit( mvc *c, int chain, char *name );
extern int mvc_rollback( mvc *c, int chain, char *name );
extern int mvc_release( mvc *c, char *name );
extern int mvc_set_iso_level(mvc * m, int level);

extern BAT *mvc_bind( mvc *c, char *sname, char *tname, char *cname, int access );
extern BAT *mvc_bind_ubat( mvc *c, char *sname, char *tname, char *cname, int access );
extern BAT *mvc_bind_obat( mvc *c, char *sname, char *tname, int access );
extern BAT *mvc_bind_dbat( mvc *c, char *sname, char *tname, int access );

extern sql_schema *mvc_bind_schema( mvc *c, char *sname );
extern sql_table *mvc_bind_table( mvc *c, sql_schema *s, char *tname );
extern sql_column *mvc_bind_column( mvc *c, sql_table *t, char *cname );
extern sql_key *mvc_bind_key( mvc *c, sql_table *t, va_list ap );

extern void mvc_drop_schema( mvc *c, char *name );
extern sql_schema *mvc_create_schema( mvc *c, char *name, char *auth);
extern void mvc_drop_table( mvc *c, sql_schema *s, char *name, bit cascade );
extern sql_table *mvc_create_view( mvc *c, sql_schema *s, char *name, char *sql);
extern sql_table *mvc_create_table(mvc *c, sql_schema *s, char *name, int type);
extern void mvc_drop_column( mvc *c, sql_table *t, char *name );
extern sql_column *mvc_create_column( mvc *c, sql_table *t, char *name, char *type, int type_size, int type_digits, int seqnr );
extern sql_column *mvc_not_null( mvc *c, sql_column *col );
extern sql_column *mvc_default( mvc *c, sql_column *col, char *val );

extern sql_key *mvc_create_key( mvc *m, char *sname, 
			char *tname, char *kname, int kt, sql_key *fk );
extern sql_key *mvc_key_add_column( mvc *m, sql_key *k, sql_column *c );

extern void mvc_export(stream *s, BAT *order, BAT *bats, char *sep, char *rsep);
extern void mvc_export_schemas( mvc *c, stream *s );
extern int mvc_import_table( mvc *c, stream *s, char *tname, char *sep, char *rsep, int nr);

#endif /*__MVC_H*/
@c

/* multi version catalog */

/* 
 * TODO 
 *
 * insert/delete/update should return ERROR (or success). Client side
 * should handle the result
 *
 * use mmap copy
 *
 * come up with a multifile log system (so a seperate thread could
 * Do the atomic bat commits).
 */

#include <gdk.h>
#include <ascii_io.h>

#include "mvc.h"
#include "logger.h"
#include <statement.h>
#include <types.h>

#define TR_OLD 0
#define TR_NEW 1

static int mvc_debug = 0;

static struct logger *logger = NULL;
static BAT *sql_schema_id, *sql_schema_name, *sql_schema_auth;
static BAT *U_schema_id, *U_schema_name, *U_schema_auth;
static BAT *D_sql_schema, *O_sql_schema;

static BAT *sql_table_id, *sql_table_name, *sql_table_schema, *sql_table_query, *sql_table_type;
static BAT *U_table_id, *U_table_name, *U_table_schema, *U_table_query, *U_table_type;
static BAT *D_sql_table, *O_sql_table;

static BAT *sql_column_id, *sql_column_name, *sql_column_type, *sql_column_type_size, *sql_column_type_digits, *sql_column_table, *sql_column_default, *sql_column_null, *sql_column_number;
static BAT *U_column_id, *U_column_name, *U_column_type, *U_column_type_size, *U_column_type_digits, *U_column_table, *U_column_default, *U_column_null, *U_column_number;
static BAT *D_sql_column, *O_sql_column;

static BAT *key_id, *key_table, *key_tpe, *key_name, *key_rkey;
static BAT *U_key_id, *U_key_table, *U_key_tpe, *U_key_name, *U_key_rkey;
static BAT *D_key, *O_key;

static BAT *kc_id, *kc_col, *kc_nr; 
static BAT *U_kc_id, *U_kc_col, *U_kc_nr; 
static BAT *D_kc, *O_kc;

static sql_trans *gtrans;

static MT_Lock mvc_lock;

static sql_table *mvc_create_table_bat(mvc * m, sql_schema *s, char *name, 
		int type, BAT *o, BAT *d);
static sql_column *mvc_create_column_bat(mvc * m, sql_table *t, char *name,
		       char *sqltype, int type_size, int type_digits, int seqnr, BAT *b, BAT *u);
/* current time stamps model is simple. Two time stamps per column, 
   one for reads and writes. 
 */

static int transaction_id = 0;

static int stamp = 1;

static int timestamp()
{
	return stamp++;
}

static int ky_id = 1;

static int key_new_id()
{
	return ky_id++;
}

static 
ptr *ADTfromStr( int type, char *s){
        int l = 0;
        ptr *res = NULL;
        if (type == TYPE_str) {
		if (*s == '\1') {
			int len = strlen(s);
			char *r = _strdup( s+1 );
			r[len-2] = '\0';
			res = (ptr*)r;
		} else {
                	res = (ptr*)_strdup(s);
		}
	} else
                BATatoms[type].atomFromStr(s, &l, (ptr)&res);
        return res;
}

static
int ADT_toStr( char **buf, int *len, int type, ptr a){
        return (int)BATatoms[type].atomToStr( buf, len, a);
}

static INLINE
ptr bun_find(BAT *b, ptr v){
	BUN p = BUNfnd(b,v);
	if (p)
		return BUNtail(b,p);
	return NULL;
}

static int key_cmp(sql_key *k, oid *id)
{
	if (k && id && k->id == *id)
		return 0;
	return 1;
}

static void key_destroy(sql_key * k)
{
	if (k->name) _DELETE(k->name);
	list_destroy(k->columns);
}

static void column_destroy(sql_column * c)
{
	BBPtransient(c->bid, FALSE);
	BBPtransient(c->ubid, FALSE);
	_DELETE(c->name);
	_DELETE(c->type);
	_DELETE(c->def);
	_DELETE(c);
}

static void table_destroy(sql_table * t)
{
	_DELETE(t->name);
	_DELETE(t->query);

	if (t->dbid) BBPtransient(t->dbid, FALSE);
	if (t->obid) BBPtransient(t->obid, FALSE);
	if (t->keys){
		list_destroy(t->keys);
	}
	if (t->dkeys){
		list_destroy(t->dkeys);
	}
	list_destroy(t->columns);
	if (t->dcolumns){
		list_destroy(t->dcolumns);
	}
	_DELETE(t);
}

static void schema_destroy(sql_schema * s)
{
	_DELETE(s->name);
	_DELETE(s->auth);

	list_destroy(s->tables);
	if (s->dtables){
		list_destroy(s->dtables);
	}
	_DELETE(s);
}

static sql_trans *trans_destroy(sql_trans *t)
{
	sql_trans *res = t->parent;

	if (t->name) _DELETE(t->name); 

	list_destroy(t->schemas);
	if (t->dschemas){
		list_destroy(t->dschemas);
	}
	if (t->keys) list_destroy(t->keys);
	t->schema = NULL;
	_DELETE(t);
	return res;
}

static node *find_column_node(sql_table * t, char *cname)
{
	node *n;
	for (n = t->columns->h; n; n = n->next) {
		sql_column *c = n->data;
		/* check if names match and if its not an internal column */
		if (strcmp(cname, c->name) == 0 && c->colnr >=0) {
			return n;
		}
	}
	return NULL;
}

static sql_column *find_column(sql_table * t, char *cname)
{
	node *n = find_column_node(t, cname );
	if (n) return n->data;
	return NULL;
}

static
node *find_table_node(sql_schema * s, char *tname)
{
	node *n;
	for (n = s->tables->h; n; n = n->next) {
		sql_table *t = n->data;
		if (strcmp(tname, t->name) == 0) {
			return n;
		}
	}
	return NULL;
}
static
sql_table *find_table(sql_schema * s, char *tname)
{
	node *n = find_table_node( s, tname );
	if (n) return n->data;
	return NULL;
}

static
node *find_schema_node(sql_trans *t, char *sname)
{
	node *n;
	for (n = t->schemas->h; n; n = n->next) {
		sql_schema *s = n->data;
		if (strcmp(sname, s->name) == 0) {
			return n;
		}
	}
	return NULL;
}
static
sql_schema *find_schema(sql_trans *t, char *sname)
{
	node *n = find_schema_node( t, sname );
	if (n) return n->data;
	return NULL;
}

/* todo: add 'truncation` */
static void load_add_column(BAT * columns, BUN j, sql_key *k )
{
	ptr lid = BUNhead(columns, j);
	char *name = bun_find(kc_col, lid);
	sql_column *c = find_column(k->t, name);

	list_append(k->columns,c);
}

static sql_key *load_key(BAT * keys, BUN j, sql_table *t)
{
	sql_trans *tr = gtrans;
	int ccnt;
	BAT *cols, *rcols;
	ptr lid = BUNhead(keys, j);
	int ktype = *(int*) bun_find(key_tpe, lid);
	char *name = (char*) bun_find(key_name, lid);
	sql_key *nk = (ktype!=fkey)?(sql_key*)NEW(sql_ukey)
				:(sql_key*)NEW(sql_fkey);
	BUN p,q;

	nk->id = *(oid *) bun_find(key_id, lid);
	nk->type = ktype;
	nk->name = (name)?_strdup(name):NULL;
	nk->columns = list_create(NULL);
	nk->t = t;

	if (ktype == ukey || ktype == pkey){
		sql_ukey *uk = (sql_ukey*)nk;
		uk -> keys = NULL;

		if (ktype == pkey)
			t->pkey = uk;
	} else {
		sql_fkey *fk = (sql_fkey*)nk;
		fk -> rkey = NULL;
	}

	cols = BATselect(kc_id, (ptr) & nk->id, (ptr) & nk->id);
	rcols = BATsemijoin(kc_nr, cols);
	BBPunfix(cols->batCacheid);
	cols = BATmirror(rcols);
	rcols = BATsort(cols);
	BBPunfix(cols->batCacheid);
	cols = BATmirror(rcols);

	ccnt = BATcount(cols);
	if (ccnt) {
		BATloop(cols,p,q)
			load_add_column(cols, p, nk);
	}
	BBPunfix(cols->batCacheid);

	if (ktype == fkey){
		sql_fkey *fk = (sql_fkey*)nk;
		oid rkey = *(oid *) bun_find(key_rkey, lid);
		node *n = list_find(tr->keys, &rkey, (fcmp)&key_cmp);
		if (n){
			sql_ukey *uk = n->data;
			fk->rkey = uk;
			if (!uk->keys) uk->keys = list_create(NULL);
			list_append(uk->keys, fk);
		} else {
			list_append(tr->keys, fk);
		}
	} else { /* could be a set of rkeys */
		sql_ukey *uk = (sql_ukey*)nk;
		BAT *keys = BATselect(key_rkey, (ptr) & nk->id, (ptr) & nk->id);
		BATloop(keys,p,q){
			oid fkey = *(oid *) BUNhead(keys, p);
			node *n = list_find(tr->keys, &fkey, (fcmp)&key_cmp);
			if (n){
				sql_fkey *fk = n->data;
				if (!uk->keys) uk->keys = list_create(NULL);
				list_append(uk->keys, fk);
				fk->rkey = uk;
			}
		}
		list_append(tr->keys, nk);
	}
	return nk;
}

static BAT *mvc_descriptor(bat bid)
{
	if (bid){
		BBPfix(bid);
		return BATdescriptor(bid);
	}
	return NULL;
}

static void update_table_bat( BAT *b, BAT *ub, BAT *db)
{
	if (BATcount(ub)){
		void_replace_bat(b, ub);
	}
	if (BATcount(db)){
		void_delete_bat(b, db);
	}
}


static sql_column *load_column(sql_table *t, BAT * columns, BUN j)
{
	char name[BUFSIZ], *tpe;
	sql_column *c = NEW(sql_column);
	ptr lid = BUNhead(columns, j);
	BUN p,q;
	int sz,d;

	c->id = *(oid *) bun_find(sql_column_id, lid);
	c->name = _strdup((char *) bun_find(sql_column_name, lid));
	tpe = (char *) bun_find(sql_column_type, lid);
	sz = *(int*)bun_find(sql_column_type_size, lid);
	d =  *(int*)bun_find(sql_column_type_digits, lid);
	c->type = new_subtype(tpe,sz,d);
	c->def = _strdup((char *) bun_find(sql_column_default, lid));
	c->null = *(bit *) bun_find(sql_column_null, lid);
	c->colnr = *(int *) bun_find(sql_column_number, lid);
	c->t = t;

	snprintf(name, BUFSIZ, "%s_%s", t->name, c->name );
	c->bid = log_find_bat(logger, name);
	BBPpersistent(c->bid, FALSE);

	snprintf(name, BUFSIZ, "U_%s_%s", t->name, c->name );
	c->ubid = log_find_bat(logger, name);
	if (c->ubid)
		BBPpersistent(c->ubid, FALSE);

	if (c->bid && c->ubid){
		BAT *b = mvc_descriptor(c->bid);
		BAT *ub = mvc_descriptor(c->ubid);
		BAT *db = mvc_descriptor(t->dbid);

		update_table_bat(b, ub, db);

		BBPunfix(b->batCacheid);
		BBPunfix(ub->batCacheid);
		BBPunfix(db->batCacheid);
	}

	c->rtime = 0;
	c->wtime = 0;
	c->flag = TR_OLD;
	return c;
}

static sql_table *load_table(sql_schema *s, BAT * tables, BUN j)
{
	char name[BUFSIZ];
	sql_table *t = NEW(sql_table);
	ptr lid = BUNhead(tables, j);
	BAT *cols, *rcols, *keys;
	BUN p,q;
	int ccnt;

	t->id = *(oid *) bun_find(sql_table_id, lid);
	t->name = _strdup(bun_find(sql_table_name, lid));
	t->query = _strdup(bun_find(sql_table_query, lid));
	t->type = *(int*) bun_find(sql_table_type, lid);
	t->rtime = 0;
	t->wtime = 0;
	t->flag = TR_OLD;
	t->pkey = NULL;
	t->keys = NULL;
	t->dkeys = NULL;
	t->nkey = NULL;
	t->s = s;

	snprintf(name, BUFSIZ, "D_%s", t->name );
	t->dbid = log_find_bat(logger, name);
	BBPpersistent(t->dbid, FALSE);

	snprintf(name, BUFSIZ, "O_%s", t->name );
	t->obid = log_find_bat(logger, name);
	BBPpersistent(t->obid, FALSE);

	t->columns = list_create((fdestroy)&column_destroy);
	t->dcolumns = NULL;
	t->ncolumn = NULL;

	cols = BATselect(sql_column_table, (ptr) & t->id, (ptr) & t->id);
	rcols = BATsemijoin(sql_column_number, cols);
	BBPunfix(cols->batCacheid);
	cols = BATmirror(rcols);
	rcols = BATsort(cols);
	BBPunfix(cols->batCacheid);
	cols = BATmirror(rcols);

	if (t->type != tt_view) {
		BATloop (cols,p,q)
			list_append(t->columns, load_column(t, cols, p));
	}
	BBPunfix(cols->batCacheid);

	keys = BATselect(key_table, (ptr) & t->id, (ptr) & t->id);
	ccnt = BATcount(keys);
	if (t->type != tt_view && ccnt) {
		t->keys = list_create((fdestroy)&key_destroy);
		BATloop(keys,p,q)
			list_append(t->keys, load_key(keys, p, t));
	}
	BBPunfix(keys->batCacheid);
	return t;
}

static sql_schema *load_schema(BAT * schemas, BUN j)
{
	sql_schema *s = NEW(sql_schema);
	ptr lid = BUNhead(schemas, j);
	BAT *tables;
	BUN p,q;

	s->id = *(oid *) bun_find(sql_schema_id, lid);
	s->name = _strdup(bun_find(sql_schema_name, lid));
	s->auth = _strdup(bun_find(sql_schema_auth, lid));
	s->tables = list_create((fdestroy)&table_destroy);
	s->dtables = NULL;
	s->ntable = NULL;
	s->rtime = 0;
	s->wtime = 0;
	s->flag = TR_OLD;

	tables = BATselect(sql_table_schema, (ptr) & s->id, (ptr) & s->id);
	BATloop(tables,p,q)
		list_append(s->tables, load_table(s, tables, p));

	BBPunfix(tables->batCacheid);
	return s;
}

static sql_trans *load_trans()
{
	sql_trans *t = NEW(sql_trans);
	BUN p,q;

	gtrans = t; /* need this because gtrans is used when loading keys */
	t->name = NULL;
	t->rtime = 0;
	t->wtime = 0;
	t->stime = timestamp();
	t->level = ISO_SERIALIZABLE;
	t->status = 0;
	t->type = 0;
	t->parent = NULL;

	t->schemas = list_create((fdestroy)&schema_destroy);
	t->dschemas = NULL;
	t->nschema = NULL;
	t->keys = list_create(NULL);

	BATloop(sql_schema_id,p,q)
		list_append(t->schemas, load_schema(sql_schema_id, p));

	list_destroy(t->keys);
	t->keys = list_create(NULL);

	return t;
}

static sql_key *key_dup(sql_trans *tr, sql_key *k, sql_table *t)
{
	sql_key *nk = (k->type!=fkey)?(sql_key*)NEW(sql_ukey)
				:(sql_key*)NEW(sql_fkey);
	node *n;

	nk->id = k->id;
	nk->type = k->type;
	nk->name = (k->name)?_strdup(k->name):NULL;
	nk->columns = list_create(NULL);
	nk->t = t;

	if (nk->type != fkey){
		sql_ukey *tk = (sql_ukey*)nk;
		tk -> keys = NULL;

		if (nk->type == pkey)
			t->pkey = tk;
	} else {
		sql_fkey *tk = (sql_fkey*)nk;
		tk -> rkey = NULL;
	}

	for(n = k->columns->h; n; n = n->next){
		sql_column *oc = n->data;
		sql_column *c = find_column(t,oc->name); 
		assert(c);
		list_append(nk->columns,c);
	}

	if (nk->type == fkey){
		sql_fkey *fk = (sql_fkey*)nk;
		sql_fkey *ok = (sql_fkey*)k;
		node *n;
		assert( ok->rkey );
		n = list_find(tr->keys, &ok->rkey->k.id, (fcmp)&key_cmp);
		assert(n);
		if (n){
			sql_ukey *uk = n->data;
			fk->rkey = uk;
			if (!uk->keys) uk->keys = list_create(NULL);
			list_append(uk->keys, fk);
		} else {
			list_append(tr->keys, fk);
		}
	} else { /* could be a set of rkeys */
		sql_ukey *uk = (sql_ukey*)nk;
		sql_ukey *ok = (sql_ukey*)k;
		node *m;
		if (ok->keys) for(m=ok->keys->h; m; m = m -> next){
			sql_fkey *ofk = m->data;
			node *n = list_find(tr->keys, &ofk->k.id, (fcmp)&key_cmp);
			if (n){
				sql_fkey *fk = n->data;
				if (!uk->keys) uk->keys = list_create(NULL);
				list_append(uk->keys, fk);
				fk->rkey = uk;
			}
		}
		list_append(tr->keys, nk);
	}
	return nk;
}

static sql_column *column_dup(sql_table *t, sql_column * s)
{
	sql_column *c = NEW(sql_column);
	c->id = s->id;
	c->name = _strdup(s->name);
	c->type = sql_dup_subtype(s->type);
	c->def = _strdup(s->def);
	c->null = s->null;
	c->colnr = s->colnr;
	c->bid = s->bid;
	BBPpersistent(c->bid, FALSE);
	c->ubid = s->ubid;
	BBPpersistent(c->ubid, FALSE);
	c->rtime = 0;
	c->wtime = 0;
	c->flag = TR_OLD;
	c->t = t;
	return c;
}

static sql_table *table_dup(sql_trans *tr, sql_schema *s, sql_table * ot)
{
	node *n;
	sql_table *t = NEW(sql_table);
	t->id = ot->id;
	t->name = _strdup(ot->name);
	t->type = ot->type;
	t->query = _strdup(ot->query);
	t->columns = list_create((fdestroy)&column_destroy);
	t->dcolumns = NULL;
	t->ncolumn = NULL;
	t->rtime = 0;
	t->wtime = 0;
	t->dbid = ot->dbid;
	BBPpersistent(t->dbid, FALSE);
	t->obid = ot->obid;
	BBPpersistent(t->obid, FALSE);

	t->pkey = NULL;
	t->keys = NULL;
	t->dkeys = NULL;
	t->nkey = NULL;

	t->flag = TR_OLD;
	t->s = s;

	for (n = ot->columns->h; n; n = n->next) {
		sql_column *c = n->data;
		list_append(t->columns, column_dup(t, c));
	}
	if (ot->keys){
		t->keys = list_create((fdestroy)&key_destroy);
	       	for (n = ot->keys->h; n; n = n->next) {
			sql_key *k = n->data;
			list_append(t->keys, key_dup(tr,k,t));
		}
	}
	return t;
}

static sql_schema *schema_dup(sql_trans *tr, sql_schema * os)
{
	node *n;
	sql_schema *s = NEW(sql_schema);
	s->id = os->id;
	s->name = _strdup(os->name);
	s->auth = _strdup(os->auth);
	s->tables = list_create((fdestroy)&table_destroy);
	s->dtables = NULL;
	s->ntable = NULL;
	s->rtime = 0;
	s->wtime = 0;
	s->flag = TR_OLD;

	for (n = os->tables->h; n; n = n->next) {
		sql_table *ot = n->data;
		if (ot->type != tt_temp && ot->type != tt_session)
			list_append(s->tables, table_dup(tr, s, ot));
	}
	return s;
}


static sql_trans *trans_dup(sql_trans *ot, char *newname ){
	node *n;
	sql_trans *t = NEW(sql_trans);

	t->rtime = 0;
	t->wtime = 0;
	t->stime = timestamp();
	t->level = ot->level;
	t->status = 0;
	t->type = 0;
	t->parent = ot;

	t->schemas = list_create((fdestroy)&schema_destroy);
	t->dschemas = NULL;
	t->nschema = NULL;
	t->keys = list_create(NULL);
	if (newname)
		t->name = _strdup(newname);
	else 
		t->name = NULL;

	for (n = ot->schemas->h; n; n = n->next) {
		list_append(t->schemas, schema_dup(t, n->data));
	}
	return t;
}

static BAT *mvc_bat(char *name, int type)
{
	BAT *b = NULL;
	bat id = log_find_bat(logger, name);

	if (mvc_debug)
		printf("mvc_bat %s bid %ld\n", name, id);

	if (id == 0) {
		int cnt = BUFSIZ;
		b = BATnew( TYPE_oid, type, cnt );
		BBPpersistent(b->batCacheid, FALSE);
	} else {
		b = mvc_descriptor(id);
	}
	return b;
}

static void new_schema(char *name, char *auth)
{
	int id = BATcount(sql_schema_id);
	int sid = OIDnew(1);

	BUNins(sql_schema_id, (ptr) & id, (ptr) & sid);
	BUNins(sql_schema_name, (ptr) & id, (ptr) name);
	BUNins(sql_schema_auth, (ptr) & id, (ptr) auth);
}

void mvc_init(int debug, char *dirname)
{
	mvc_debug = debug;

	if (mvc_debug)
		printf("mvc_init logdir %s\n", dirname);

	logger = logger_create(mvc_debug, dirname);

	sql_schema_id = mvc_bat("schemas_id", TYPE_int);
	sql_schema_name = mvc_bat("schemas_name", TYPE_str);
	sql_schema_auth = mvc_bat("schemas_authorization", TYPE_str);
	U_schema_id = mvc_bat("U_schemas_id", TYPE_int);
	U_schema_name = mvc_bat("U_schemas_name", TYPE_str);
	U_schema_auth = mvc_bat("U_schemas_authorization", TYPE_str);
	D_sql_schema = mvc_bat("D_schemas", TYPE_oid);
	O_sql_schema = mvc_bat("O_schemas", TYPE_oid);
	update_table_bat(sql_schema_id, U_schema_id, D_sql_schema);
	update_table_bat(sql_schema_name, U_schema_name, D_sql_schema);
	update_table_bat(sql_schema_auth, U_schema_auth, D_sql_schema);

	sql_table_id = mvc_bat("tables_id", TYPE_int);
	sql_table_name = mvc_bat("tables_name", TYPE_str);
	sql_table_schema = mvc_bat("tables_schema_id", TYPE_int);
	sql_table_query = mvc_bat("tables_query", TYPE_str);
	sql_table_type = mvc_bat("tables_type", TYPE_int);
	U_table_id = mvc_bat("U_tables_id", TYPE_int);
	U_table_name = mvc_bat("U_tables_name", TYPE_str);
	U_table_schema = mvc_bat("U_tables_schema_id", TYPE_int);
	U_table_query = mvc_bat("U_tables_query", TYPE_str);
	U_table_type = mvc_bat("U_tables_type", TYPE_int);
	D_sql_table = mvc_bat("D_tables", TYPE_oid);
	O_sql_table = mvc_bat("O_tables", TYPE_oid);
	update_table_bat(sql_table_id, U_table_id, D_sql_table);
	update_table_bat(sql_table_name, U_table_name, D_sql_table);
	update_table_bat(sql_table_schema, U_table_schema, D_sql_table);
	update_table_bat(sql_table_query, U_table_query, D_sql_table);
	update_table_bat(sql_table_type, U_table_type, D_sql_table);

	sql_column_id = mvc_bat("columns_id", TYPE_int);
	sql_column_name = mvc_bat("columns_name", TYPE_str);
	sql_column_type = mvc_bat("columns_type", TYPE_str);
	sql_column_type_size = mvc_bat("columns_type_size", TYPE_int);
	sql_column_type_digits = mvc_bat("columns_type_digits", TYPE_int);
	sql_column_table = mvc_bat("columns_table_id", TYPE_int);
	sql_column_default = mvc_bat("columns_default", TYPE_str);
	sql_column_null = mvc_bat("columns_null", TYPE_bit);
	sql_column_number = mvc_bat("columns_number", TYPE_int);
	U_column_id = mvc_bat("U_columns_id", TYPE_int);
	U_column_name = mvc_bat("U_columns_name", TYPE_str);
	U_column_type = mvc_bat("U_columns_type", TYPE_str);
	U_column_type_size = mvc_bat("U_columns_type_size", TYPE_int);
	U_column_type_digits = mvc_bat("U_columns_type_digits", TYPE_int);
	U_column_table = mvc_bat("U_columns_table_id", TYPE_int);
	U_column_default = mvc_bat("U_columns_default", TYPE_str);
	U_column_null = mvc_bat("U_columns_null", TYPE_bit);
	U_column_number = mvc_bat("U_columns_number", TYPE_int);
	D_sql_column = mvc_bat("D_columns", TYPE_oid);
	O_sql_column = mvc_bat("O_columns", TYPE_oid);
	update_table_bat(sql_column_id, U_column_id, D_sql_column);
	update_table_bat(sql_column_name, U_column_name, D_sql_column);
	update_table_bat(sql_column_type, U_column_type, D_sql_column);
	update_table_bat(sql_column_type_size, U_column_type_size, D_sql_column);
	update_table_bat(sql_column_type_digits, U_column_type_digits, D_sql_column);
	update_table_bat(sql_column_table, U_column_table, D_sql_column);
	update_table_bat(sql_column_default, U_column_default, D_sql_column);
	update_table_bat(sql_column_null, U_column_null, D_sql_column);
	update_table_bat(sql_column_number, U_column_number, D_sql_column);

	key_id = mvc_bat("keys_id", TYPE_int);
	key_table = mvc_bat("keys_table_id", TYPE_int);
	key_tpe = mvc_bat("keys_type", TYPE_int);
	key_name = mvc_bat("keys_name", TYPE_str);
	key_rkey = mvc_bat("keys_rkey", TYPE_int);
	U_key_id = mvc_bat("U_keys_id", TYPE_int);
	U_key_table = mvc_bat("U_keys_table_id", TYPE_int);
	U_key_tpe = mvc_bat("U_keys_type", TYPE_str);
	U_key_name = mvc_bat("U_keys_name", TYPE_int);
	U_key_rkey = mvc_bat("U_keys_rkey", TYPE_int);
	D_key = mvc_bat("D_keys", TYPE_oid);
	O_key = mvc_bat("O_keys", TYPE_oid);
	update_table_bat(key_id, U_key_id, D_key);
	update_table_bat(key_table, U_key_table, D_key);
	update_table_bat(key_tpe, U_key_tpe, D_key);
	update_table_bat(key_name, U_key_name, D_key);
	update_table_bat(key_rkey, U_key_rkey, D_key);
	/* key_updaterule = mvc_bat("keys_updaterule", TYPE_int); */
	/* key_deleterule = mvc_bat("keys_deleterule", TYPE_int); */
	/* key_deferrability = mvc_bat("keys_deferrability", TYPE_int); */

	kc_id = mvc_bat("keycolumns_id", TYPE_int);
	kc_col = mvc_bat("keycolumns_column", TYPE_str);
	kc_nr = mvc_bat("keycolumns_nr", TYPE_int);
	U_kc_id = mvc_bat("U_keycolumns_id", TYPE_int);
	U_kc_col = mvc_bat("U_keycolumns_column", TYPE_str);
	U_kc_nr = mvc_bat("U_keycolumns_nr", TYPE_int);
	D_kc = mvc_bat("D_keycolumns", TYPE_oid);
	O_kc = mvc_bat("O_keycolumns", TYPE_oid);
	update_table_bat(kc_id, U_kc_id, D_kc);
	update_table_bat(kc_col, U_kc_col, D_kc);
	update_table_bat(kc_nr, U_kc_nr, D_kc);

	mvc_lock = MT_create_lock();

	MT_set_lock(mvc_lock, "mvc_init");

	gtrans = load_trans();

	MT_unset_lock(mvc_lock, "mvc_init");

	if (!find_schema(gtrans, "sys")){
		int cnt = BUFSIZ;
		BAT *od = BATnew( TYPE_void, TYPE_oid, cnt );
		sql_schema *s;
		sql_table *t;
		mvc *m = mvc_create(mvc_debug);

		s = mvc_create_schema(m, "sys", "sqladmin");
		t = mvc_create_table_bat (m, s, "schemas", FALSE, 
				O_sql_schema, D_sql_schema);
		mvc_create_column_bat(m, t, "id", "INTEGER",0,0, 0, sql_schema_id, U_schema_id);
		mvc_create_column_bat(m, t, "name", "VARCHAR",0,0, 1, sql_schema_name, U_schema_name);
		mvc_create_column_bat(m, t, "authorization", "VARCHAR",0,0, 2, sql_schema_auth, U_schema_auth);

		t = mvc_create_table_bat(m, s, "tables", FALSE, 
				O_sql_table, D_sql_table);
		mvc_create_column_bat(m, t, "id", "INTEGER",0,0, 0, sql_table_id, U_table_id);
		mvc_create_column_bat(m, t, "name", "VARCHAR",0,0, 1, sql_table_name, U_table_name);
		mvc_create_column_bat(m, t, "schema_id", "INTEGER",0,0, 2, sql_table_schema, U_table_schema);
		mvc_create_column_bat(m, t, "query", "VARCHAR",0,0, 3, sql_table_query, U_table_query);
		mvc_create_column_bat(m, t, "type", "INTEGER",0,0, 4, sql_table_type, U_table_type);

		t = mvc_create_table_bat(m, s, "columns", FALSE, 
				O_sql_column, D_sql_column);
		mvc_create_column_bat(m, t, "id", "INTEGER",0,0, 0, sql_column_id, U_column_id);
		mvc_create_column_bat(m, t, "name", "VARCHAR",0,0, 1, sql_column_name, U_column_name);
		mvc_create_column_bat(m, t, "type", "VARCHAR",0,0, 2, sql_column_type, U_column_type);
		mvc_create_column_bat(m, t, "type_size", "INTEGER",0,0, 3, sql_column_type_size, U_column_type_size);
		mvc_create_column_bat(m, t, "type_digits", "INTEGER",0,0, 4, sql_column_type_digits, U_column_type_digits);
		mvc_create_column_bat(m, t, "table_id", "INTEGER",0,0, 5, sql_column_table, U_column_table);
		mvc_create_column_bat(m, t, "default", "VARCHAR",0,0, 6, sql_column_default, U_column_default);
		mvc_create_column_bat(m, t, "null", "BOOL",0,0, 7, sql_column_null, U_column_null);
		mvc_create_column_bat(m, t, "number", "INTEGER",0,0, 8, sql_column_number, U_column_number);

		t = mvc_create_table_bat(m, s, "keys", FALSE, O_key, D_key);
		mvc_create_column_bat(m, t, "id", "INTEGER",0,0, 0, key_id, U_key_id);
		mvc_create_column_bat(m, t, "table_id", "INTEGER",0,0, 1, key_table, U_key_table);
		mvc_create_column_bat(m, t, "type", "INTEGER",0,0, 2, key_tpe, U_key_tpe);
		mvc_create_column_bat(m, t, "name", "INTEGER",0,0, 3, key_name, U_key_name);
		mvc_create_column_bat(m, t, "rkey", "INTEGER",0,0, 4, key_rkey, U_key_rkey);

		t = mvc_create_table_bat(m, s, "keycolumns", FALSE, O_kc, D_kc);
		mvc_create_column_bat(m, t, "id", "INTEGER",0,0, 0, kc_id, U_kc_id);
		mvc_create_column_bat(m, t, "column", "VARCHAR",0,0, 1, kc_col, U_kc_col);
		mvc_create_column_bat(m, t, "nr", "INTEGER",0,0, 2, kc_nr, U_kc_nr);

		/* now the authorisation related tables */
		t = mvc_create_table(m, s, "users", FALSE );
		mvc_create_column(m, t, "name", "VARCHAR",0,0, 0 );
		mvc_create_column(m, t, "passwd", "VARCHAR",0,0, 1 );
		mvc_create_column(m, t, "fullname", "VARCHAR",0,0, 2 );
		mvc_create_column(m, t, "default_schema", "INTEGER",0,0, 3 );

		t = mvc_create_table(m, s, "auths", FALSE );
		mvc_create_column(m, t, "id", "INTEGER",0,0, 0 );
		mvc_create_column(m, t, "name", "VARCHAR",0,0, 1 );
		mvc_create_column(m, t, "grantor", "INTEGER",0,0, 2 );
		mvc_create_column(m, t, "privileges", "INTEGER",0,0, 3 );

		t = mvc_create_table(m, s, "user_role", FALSE );
		mvc_create_column(m, t, "login_id", "INTEGER",0,0, 0 );
		mvc_create_column(m, t, "role_id", "INTEGER",0,0, 1 );

		t = mvc_create_table(m, s, "table_privileges", FALSE );
		mvc_create_column(m, t, "table_id", "INTEGER",0,0, 0 );
		mvc_create_column(m, t, "auth_id", "INTEGER",0,0, 1 );
		mvc_create_column(m, t, "privileges", "INTEGER",0,0, 2 );

		t = mvc_create_table(m, s, "column_privileges", FALSE );
		mvc_create_column(m, t, "column_id", "INTEGER",0,0, 0 );
		mvc_create_column(m, t, "auth_id", "INTEGER",0,0, 1 );
		mvc_create_column(m, t, "privileges", "INTEGER",0,0, 2 );

		mvc_create_schema(m, "default-schema", "sqladmin");

		mvc_commit(m, 0, NULL);
		mvc_destroy(m);
	}
}

char *mvc_login(mvc *m, char *user, char *passwd)
{
	char *schema = NULL;
	BAT *name_user = BATmirror(mvc_bind(m, "sys", "users", "name", 0 ));
	BUN p;

	if ((p=BUNfnd(name_user, user)) != NULL){
		BAT *user_pwd = mvc_bind(m, "sys", "users", "passwd", 0 );
		ptr userid = BUNtail(name_user, p);
		char *pwd = BUNtail(user_pwd, BUNfnd(user_pwd, userid));
		
		if (strcmp(passwd, pwd) == 0){
			BAT *user_ds = mvc_bind(m, "sys", "users", "default_schema", 0 );
			BAT *id_schema = BATmirror(mvc_bind(m, "sys", "schemas", "id", 0 ));
			BAT *schema_name = mvc_bind(m, "sys", "schemas", "name", 0 );
			ptr schema_id = BUNtail(user_ds, BUNfnd(user_ds, userid)); 
			ptr lid = BUNtail(id_schema,BUNfnd(id_schema, schema_id));
			schema = BUNtail(schema_name,BUNfnd(schema_name, lid));
			schema = _strdup(schema);
			BBPunfix(id_schema->batCacheid);
			BBPunfix(schema_name->batCacheid);
			BBPunfix(user_ds->batCacheid);
		}
		BBPunfix(user_pwd->batCacheid);
	}
	BBPunfix(name_user->batCacheid);

	if (!schema)
		return NULL;

	m->trans->schema = find_schema(m->trans, schema);
	if (!m->trans->schema) {
		_DELETE(schema);
		return NULL;
	}
	return schema;
}

/* back door ;-) can only used by server todo initial user setup */
char *mvc_admin_login(mvc *m)
{
	char *schema = NULL;
	BAT *name_user = BATmirror(mvc_bind(m, "sys", "users", "name", 0 ));

	if (!BATcount(name_user)){
		m->trans->schema = find_schema(m->trans, "sys");
		schema = _strdup("sys");
	}
	return schema;
}

extern int savebats()
{
	logger_persists(logger);
	return 1;
}

void mvc_exit()
{

	if (mvc_debug)
		printf("mvc_exit\n");

	logger_destroy(logger); 
	types_exit();

	BBPunfix(sql_schema_id->batCacheid);
	BBPunfix(sql_schema_name->batCacheid);
	BBPunfix(sql_schema_auth->batCacheid);
	BBPunfix(U_schema_id->batCacheid);
	BBPunfix(U_schema_name->batCacheid);
	BBPunfix(U_schema_auth->batCacheid);
	BBPunfix(D_sql_schema->batCacheid);
	BBPunfix(O_sql_schema->batCacheid);

	BBPunfix(sql_table_id->batCacheid);
	BBPunfix(sql_table_name->batCacheid);
	BBPunfix(sql_table_schema->batCacheid);
	BBPunfix(sql_table_query->batCacheid);
	BBPunfix(sql_table_type->batCacheid);
	BBPunfix(U_table_id->batCacheid);
	BBPunfix(U_table_name->batCacheid);
	BBPunfix(U_table_schema->batCacheid);
	BBPunfix(U_table_query->batCacheid);
	BBPunfix(U_table_type->batCacheid);
	BBPunfix(D_sql_table->batCacheid);
	BBPunfix(O_sql_table->batCacheid);

	BBPunfix(sql_column_id->batCacheid);
	BBPunfix(sql_column_name->batCacheid);
	BBPunfix(sql_column_type->batCacheid);
	BBPunfix(sql_column_type_size->batCacheid);
	BBPunfix(sql_column_type_digits->batCacheid);
	BBPunfix(sql_column_table->batCacheid);
	BBPunfix(sql_column_default->batCacheid);
	BBPunfix(sql_column_null->batCacheid);
	BBPunfix(sql_column_number->batCacheid);
	BBPunfix(U_column_id->batCacheid);
	BBPunfix(U_column_name->batCacheid);
	BBPunfix(U_column_type->batCacheid);
	BBPunfix(U_column_type_size->batCacheid);
	BBPunfix(U_column_type_digits->batCacheid);
	BBPunfix(U_column_table->batCacheid);
	BBPunfix(U_column_default->batCacheid);
	BBPunfix(U_column_null->batCacheid);
	BBPunfix(U_column_number->batCacheid);
	BBPunfix(D_sql_column->batCacheid);
	BBPunfix(O_sql_column->batCacheid);

	BBPunfix(key_id->batCacheid);
	BBPunfix(key_table->batCacheid);
	BBPunfix(key_tpe->batCacheid);
	BBPunfix(key_name->batCacheid);
	BBPunfix(key_rkey->batCacheid);
	BBPunfix(U_key_id->batCacheid);
	BBPunfix(U_key_table->batCacheid);
	BBPunfix(U_key_tpe->batCacheid);
	BBPunfix(U_key_name->batCacheid);
	BBPunfix(U_key_rkey->batCacheid);
	BBPunfix(D_key->batCacheid);
	BBPunfix(O_key->batCacheid);

	BBPunfix(kc_id->batCacheid);
	BBPunfix(kc_col->batCacheid);
	BBPunfix(kc_nr->batCacheid);
	BBPunfix(U_kc_id->batCacheid);
	BBPunfix(U_kc_col->batCacheid);
	BBPunfix(U_kc_nr->batCacheid);
	BBPunfix(D_kc->batCacheid);
	BBPunfix(O_kc->batCacheid);

	trans_destroy(gtrans);
}

mvc *mvc_create(int debug)
{
	mvc *m = NEW(mvc);

	if (debug)
		printf("mvc_create\n");

	MT_set_lock(mvc_lock, "mvc_create");

	m->debug = debug;
	m->trans = NULL;
	m->trans = trans_dup(gtrans,NULL);

	MT_unset_lock(mvc_lock, "mvc_create");
	return m;
}

int mvc_status( mvc *c ){
	sql_trans *t = c->trans;
	int res = t->status;

	t->status = 0;
	return res;
}

int mvc_type( mvc *c ){
	sql_trans *t = c->trans;
	int res = t->type;

	t->type = 0;
	return res;
}


int void_delete_bat( BAT *b, BAT *u){
	int nr = 0;
	BUN r,s;
	ptr nil = ATOMnilptr(u->ttype);

	BATloop(u, r, s){
		oid *rid = (oid*)BUNtail(u,r);
		BUNreplace(b,  (ptr)rid, nil);
		nr++;
	}
	return nr;
}

int void_replace_bat( BAT *b, BAT *u){
	int nr = 0;
	BUN r,s;

	BATloop(u, r, s){
		oid *rid = (oid*)BUNhead(u,r);
		ptr val = BUNtail(u,r);
		BUNreplace(b,  (ptr)rid, val);
		nr++;
	}
	return nr;
}


int void_insert_bat( BAT *b, BAT *u){
	int nr = 0;
	BUN r,s;
        int sz = BUNsize(u);
	oid nil = oid_nil;

	BATloop(u, r, s){
		oid rid = *(oid*)BUNhead(u,r);
		BUNins(b,  (ptr)&nil, BUNtail(u,r));
		nr++;
	}
	return nr;
}

static void create_key(sql_trans * tr, sql_schema * gs, sql_table *gt, sql_key *gk, int ki )
{
	node *n;
	int kc = BATcount(kc_id);
	int neg = -1;
	int nr = 0;

/*
	gk->id = ki;
*/
	assert (gk->t == gt);

	BUNins(key_id, (ptr) & ki, (ptr) & gk->id);
	BUNins(key_table, (ptr) & ki, (ptr) & gt->id);
	BUNins(key_tpe, (ptr) & ki, (ptr) & gk->type);
	BUNins(key_name, (ptr) & ki, (ptr) gk->name);
	if (gk->type == fkey){
		int rkey;
		assert( ((sql_fkey*)gk)->rkey );
		rkey = ((sql_fkey*)gk)->rkey->k.id;
		BUNins(key_rkey, (ptr) & ki, (ptr) & rkey);
	} else {
		BUNins(key_rkey, (ptr) & ki, (ptr) & neg);
	}
	for (n = gk->columns->h; n; n = n->next, nr++, kc++){
		sql_column *c = n->data;
		BUNins(kc_id, (ptr)&kc, (ptr)&gk->id);
		BUNins(kc_col, (ptr)&kc, (ptr)c->name);
		BUNins(kc_nr, (ptr)&kc, (ptr)&nr);
	}
}

static void create_column(sql_trans * ctr, sql_schema * gs, sql_table *gt, sql_column *gc, int ci )
{
	char name[BUFSIZ];
	BAT *b = mvc_descriptor(gc->bid);
	BAT *u = mvc_descriptor(gc->ubid);

	gc->id = ci;
	gc->rtime = gs->rtime;
	gc->wtime = gs->wtime;

	snprintf(name, BUFSIZ, "%s_%s", gt->name, gc->name );
	log_bat_persists(logger, b, name); 
	BBPunfix(b->batCacheid);

	if (u){
		snprintf(name, BUFSIZ, "U_%s_%s", gt->name, gc->name );
		log_bat_persists(logger, u, name); 
		BBPunfix(u->batCacheid);
	}

	BUNins(sql_column_id, (ptr) & ci, (ptr) & ci);
	BUNins(sql_column_table, (ptr) & ci, (ptr) & gt->id);
	BUNins(sql_column_name, (ptr) & ci, (ptr) gc->name);
	BUNins(sql_column_type, (ptr) & ci, (ptr) gc->type->type->sqlname);
	BUNins(sql_column_type_size, (ptr) & ci, (ptr) &gc->type->size);
	BUNins(sql_column_type_digits, (ptr) & ci, (ptr) &gc->type->digits);
	BUNins(sql_column_default, (ptr) & ci, (ptr) gc->def);
	BUNins(sql_column_null, (ptr) & ci, (ptr) & gc->null);
	BUNins(sql_column_number, (ptr) & ci, (ptr) & gc->colnr);
}

static void rollforward_table(sql_trans * ctr, sql_schema * gs, sql_table * ct)
{
	int ci = BATcount(sql_column_id);
	int ki = BATcount(key_id);
	sql_table *gt = find_table(gs, ct->name);
	node *n, *m;

	assert(list_length(gt->columns) == list_length(ct->columns));

	n = ct->columns->h;
	m = gt->columns->h;
	if (n && m) {
		sql_column *cc = n->data;
		sql_column *oc = m->data;

		BAT *cdb = mvc_descriptor(ct->dbid);
		BAT *cob = mvc_descriptor(ct->obid);

		BAT *ds = BATalpha(cdb);
		BAT *os = BATalpha(cob);

		BBPunfix(cdb->batCacheid);
		BBPunfix(cob->batCacheid);

		do { /* TODO move the logic for keeping intersections
			between I_,U_ and D_ empty into the sql2mil 
			layer */
			sql_column *cc = n->data;
			sql_column *oc = m->data;

			BAT *cb = mvc_descriptor(cc->bid);
			BAT *cub = mvc_descriptor(cc->ubid);
			BAT *ob = mvc_descriptor(oc->bid);

			BAT *ups = BATalpha(cub);
			BAT *ins = BATalpha(cb);

				/* if inserted in this transaction
				   	remove from ins,ups,ds */
/*
			if (BATcount(ds)) {
				BAT *ins_del = BATsemijoin(ins,BATmirror(ds));
				if (BATcount(ins_del)) {
					BAT *nins = BATkdiff(ins,ins_del);
					BAT *nds = BATmirror(BATkdiff(
						BATmirror(ds),ins_del));
					BAT *nups = BATkdiff(ups,ins_del);
					BBPunfix(ins->batCacheid);
					BBPunfix(nds->batCacheid);
					BBPunfix(nups->batCacheid);
					ins = nins;
					ds = nds;
					ups = nups;
				}
				BBPunfix(ins_del->batCacheid);
			}
*/
			/* forward inserts */
			if (BATcount(ins)) {

				if (BATcount(ups)){
					BAT *ups_ins = BATkdiff(ups,ins);
					BBPunfix(ups->batCacheid);
					ups = ups_ins;
				}

				void_insert_bat(ob, ins);
				log_bat(logger, ob);
			}
			if (BATcount(ds)) {
				void_delete_bat(ob, ds);
			}
			if (BATcount(ups)) {
				BAT *oub = mvc_descriptor(oc->ubid);
				void_insert_bat(oub, ups);
				void_replace_bat(ob, ups);
				log_bat(logger, oub);
				BBPunfix(oub->batCacheid);
			}

			BBPunfix(cb->batCacheid);
			BBPunfix(ob->batCacheid);
			BBPunfix(ins->batCacheid);
			BBPunfix(ups->batCacheid);
			BBPunfix(cub->batCacheid);

			n = n->next;
			m = m->next;
		} while (n && m);

		if (BATcount(ds)) {
			BAT *odb = mvc_descriptor(gt->dbid);
			void_insert_bat(odb, ds);
			log_bat(logger, odb);
			BBPunfix(odb->batCacheid);
		}
		if (BATcount(os)) {
			BAT *oob = mvc_descriptor(gt->obid);
			void_insert_bat(oob, os);
			log_bat(logger, oob);
			BBPunfix(oob->batCacheid);
		}

		gt->rtime = ct->rtime;
		gt->wtime = ct->wtime;
		oc->rtime = cc->rtime;
		oc->wtime = cc->wtime;

		BBPunfix(ds->batCacheid);
		BBPunfix(os->batCacheid);
	}
	for(; n; n = n->next, ci++){
		sql_column *c = n->data;
		create_column( ctr, gs, gt, column_dup(gt, c), ci );
	}
	if (ct->nkey){
		for (n = ct->keys->h; n->data != ct->nkey; n = n->next);

		for (; n; n = n->next, ki++) {
			sql_key *ck = n->data;
			create_key( ctr, gs, gt, key_dup(ctr,ck,gt), ki );
		}
	}
}

static void create_keys(sql_trans * tr, sql_schema * s, sql_table * t)
{
	node *n;
	int ki = BATcount(key_id);

	if (t->keys) for (n = t->keys->h; n; n = n->next, ki++) {
		sql_key *k = n->data;
		create_key( tr, s, t, k, ki);
	}
}

static void create_columns(sql_trans * tr, sql_schema * s, sql_table * t)
{
	node *n;
	int ci = BATcount(sql_column_id);

	for (n = t->columns->h; n; n = n->next) {
		sql_column *c = n->data;
		create_column( tr, s, t, c, ci);
		ci++;
	}
}

void mvc_drop_keys(sql_trans * tr, sql_table * t)
{
	node *n;

	if (t->keys) for (n = t->keys->h; n; n = n->next) {
		sql_key *k = n->data;
		BAT *b = BATselect(kc_id, (ptr) & k->id, (ptr) & k->id );
		BUN p,q;

		BUNdelHead(key_id, (ptr) & k->id);
		BUNdelHead(key_table, (ptr) & k->id);
		BUNdelHead(key_tpe, (ptr) & k->id);
		BUNdelHead(key_name, (ptr) & k->id);
		BUNdelHead(key_rkey, (ptr) & k->id);

		BATloop(b,p,q){
			oid id = *(oid*)BUNhead(kc_id, p);

			BUNdelHead(kc_id, (ptr) & id);
			BUNdelHead(kc_col, (ptr) & id);
			BUNdelHead(kc_nr, (ptr) & id);
		}
		BBPunfix(b->batCacheid);
	}
}

void mvc_drop_columns(sql_trans * tr, sql_table * t)
{
	node *n;

	for (n = t->columns->h; n; n = n->next) {
		sql_column *c = n->data;
		BAT *b,*u;

 		b = mvc_descriptor(c->bid);
		log_bat_transient(logger, b); 
		BBPunfix(b->batCacheid);

		u = mvc_descriptor(c->ubid);
		log_bat_transient(logger, u); 
		BBPunfix(u->batCacheid);

		BUNdelHead(sql_column_id, (ptr) & c->id);
		BUNdelHead(sql_column_table, (ptr) & c->id);
		BUNdelHead(sql_column_name, (ptr) & c->id);
		BUNdelHead(sql_column_type, (ptr) & c->id);
		BUNdelHead(sql_column_type_size, (ptr) & c->id);
		BUNdelHead(sql_column_type_digits, (ptr) & c->id);
		BUNdelHead(sql_column_default, (ptr) & c->id);
		BUNdelHead(sql_column_null, (ptr) & c->id);
		BUNdelHead(sql_column_number, (ptr) & c->id);
	}
}

static void mvc_forward_create_table(sql_trans * tr, sql_schema * ns,
				     sql_table * nt)
{
	nt->id = BATcount(sql_table_id);
	nt->rtime = ns->rtime;
	nt->wtime = ns->wtime;

	BUNins(sql_table_id, (ptr) & nt->id, (ptr) & nt->id);
	BUNins(sql_table_schema, (ptr) & nt->id, (ptr) & ns->id);
	BUNins(sql_table_name, (ptr) & nt->id, (ptr) nt->name);
	BUNins(sql_table_type, (ptr) & nt->id, (ptr) & nt->type );
	BUNins(sql_table_query, (ptr) & nt->id, (ptr) nt->query);
	if (nt->type != tt_view){
		char name[BUFSIZ];
		BAT *o = mvc_descriptor(nt->obid);
		BAT *d = mvc_descriptor(nt->dbid);

		snprintf(name, BUFSIZ, "O_%s", nt->name );
		log_bat_persists(logger, o, name); 
		BBPunfix(o->batCacheid);

		snprintf(name, BUFSIZ, "D_%s", nt->name );
		log_bat_persists(logger, d, name); 
		BBPunfix(d->batCacheid);

		create_columns(tr, ns, nt);
		create_keys(tr, ns, nt);
	}
}

static void rollforward_tables(sql_trans *tr, sql_schema * s)
{
	sql_trans *gtr = tr->parent;
	node *n;
	sql_schema *os = find_schema(gtr, s->name);

	/* delete the dropped tables */
	if (s->dtables) for (n = s->dtables->h; n; n = n->next) {	
		sql_table *t = n->data;
		sql_table *ot = find_table(os, t->name);

		BUNdelHead(sql_table_id, (ptr) & t->id);
		BUNdelHead(sql_table_schema, (ptr) & t->id);
		BUNdelHead(sql_table_name, (ptr) & t->id);
		BUNdelHead(sql_table_type, (ptr) & t->id);
		BUNdelHead(sql_table_query, (ptr) & t->id);
		if (t->type != tt_view){
			BAT *o = mvc_descriptor(t->obid);
			BAT *d = mvc_descriptor(t->dbid);
			log_bat_transient(logger, o); 
			log_bat_transient(logger, d); 
			BBPunfix(o->batCacheid);
			BBPunfix(d->batCacheid);
		} 

		mvc_drop_keys(tr, t);
		mvc_drop_columns(tr, t);

		list_remove_data(os->tables, ot);
		table_destroy(ot);
	}
	/* changes to the existing tables */
	for (n = s->tables->h; n && n->data != s->ntable; n = n->next) {	
		sql_table *t = n->data;
		
		if (t->wtime && t->flag == TR_OLD)
			rollforward_table(tr, os, t);
	}
	/* add the new tables */
	for (; n; n = n->next) {	
		sql_table *nt, *ot = n->data;

		if (ot->type != tt_temp && ot->type != tt_session){
			mvc_forward_create_table(tr, os, nt = table_dup(gtr, os, ot));
			list_append(os->tables, nt);
		}
	}
}

static void rollforward_schemas(sql_trans *tr)
{
	node *n;

	/* delete the dropped schemas */
	if (tr->dschemas) for (n = tr->dschemas->h; n; n = n->next) {	
		sql_schema *s = n->data;
		sql_schema *os = find_schema(tr->parent, s->name);

		/* TODO move to the removed list if not top trans */
		list_remove_data(tr->parent->schemas, os);
		schema_destroy(os);

		if (tr->parent == gtrans){
			BUNdelHead(sql_schema_id, (ptr) & s->id);
			BUNdelHead(sql_schema_name, (ptr) & s->id);
			BUNdelHead(sql_schema_auth, (ptr) & s->id);
		}
	}
	/* changes to the existing schemas */
	for (n = tr->schemas->h; n && n->data != tr->nschema; n = n->next) {	
		sql_schema *s = n->data;
		if (s->flag == TR_OLD)
			rollforward_tables(tr, s);
	}
	/* add the new schemas */
	for (; n; n = n->next) {	
		sql_schema *ns = schema_dup(tr, n->data);

		if (tr->parent == gtrans){
			node *m;
			ns->id = BATcount(sql_schema_id);

			BUNins(sql_schema_id, (ptr) & ns->id,
			   (ptr) & ns->id);
			BUNins(sql_schema_name, (ptr) & ns->id,
			   (ptr) ns->name);
			BUNins(sql_schema_auth, (ptr) & ns->id,
			   (ptr) ns->auth);

			/* add the new tables */
			for (m = ns->tables->h; m; m = m->next) {
				sql_table *nt = m->data;
				mvc_forward_create_table(tr, ns, nt);
			}
			list_append(tr->parent->schemas, ns);
		}
	}
	if (tr->parent == gtrans){
		log_bat(logger, sql_table_id);
		log_bat(logger, sql_table_schema);
		log_bat(logger, sql_table_name);
		log_bat(logger, sql_table_type);
		log_bat(logger, sql_table_query);

		log_bat(logger, sql_column_id);
		log_bat(logger, sql_column_table);
		log_bat(logger, sql_column_name);
		log_bat(logger, sql_column_type);
		log_bat(logger, sql_column_type_size);
		log_bat(logger, sql_column_type_digits);
		log_bat(logger, sql_column_default);
		log_bat(logger, sql_column_null);
		log_bat(logger, sql_column_number);

		log_bat(logger, sql_schema_id);
		log_bat(logger, sql_schema_name);
		log_bat(logger, sql_schema_auth);

		log_bat(logger, key_id);
		log_bat(logger, key_table);
		log_bat(logger, key_tpe);
		log_bat(logger, key_name);
		log_bat(logger, key_rkey);

		log_bat(logger, kc_id);
		log_bat(logger, kc_col);
		log_bat(logger, kc_nr);
	}
	list_destroy(tr->keys);
	tr->keys = list_create(NULL);
}


static int validate_tables(sql_schema * s, sql_schema * os)
{
	node *n, *o, *p;

	for (n = s->tables->h; n; n = n->next) {
		sql_table *t = n->data;
		sql_table *ot = find_table(os, t->name);

		if (ot || (t->wtime == 0 && t->rtime == 0)) {
			for (o = t->columns->h, p = ot->columns->h;
			     o && p; o = o->next, p = p->next) {
				sql_column *c = o->data;
				sql_column *oc = p->data;
				/* t wrote, ie. check read and write time */
				/* read or write after t's write */
				if (c->wtime &&
				    (c->wtime < oc->rtime
				     || c->wtime < oc->wtime)) {
					return 0;
				}
				/* commited write before t's read */
				if (c->rtime && c->rtime < oc->wtime) {
					return 0;
				}
			}
		}
	}
	return 1;
}

static int validate(sql_trans *tr)
{
	node *n;
	/* depends on the iso level */

	/* since we protect usage through private copies both the iso levels
	   read uncommited and read commited always succeed.
	 */
	if (tr->level == ISO_READ_UNCOMMITED
	    || tr->level == ISO_READ_COMMITED)
		return 1;

	/* If only 'inserts' occurred on the read bats the repeatable reads
	   iso level can continue */

	/* the hard case */
	for (n = tr->schemas->h; n; n = n->next) {
		sql_schema *s = n->data;
		sql_schema *os = find_schema(tr->parent, s->name);
		if (os || (s->wtime == 0 && s->rtime == 0)) {
			if (!validate_tables(s, os)) return 0;
		}
	}
	return 1;
}

/* 
 * mvc_commit implements the last two phases (out of 3) of 
 * optimistic concurrency control. The first phase, ie. read phase 
 * starts when the transaction is started (aka with any sql statement) 
 * and ends with mvc_commit. The validation phase checks the timestamps 
 * to see if a commit could succeed. Then the write phase makes 
 * the changes global.
 *
 * Commit will first forward the changes to the schema, ie.
 * leaving out the temp tables and adding the new tables directly.
 * 
 * After that the changes to existing tables are forwarded.
 */

int mvc_commit(mvc * m, int chain, char *name)
{
	sql_trans *tr = m->trans;
	int level = (chain)?tr->level:ISO_SERIALIZABLE;
	int res = -1;

	if (m->debug)
		printf("mvc_commit\n");

	/* savepoint then simply make a copy of the current transaction */
	if (name && name[0] != '\0'){
		if (m->debug)
			printf("mvc_savepoint\n");
		m->trans = trans_dup(m->trans, name);
		return 0;
	}

	/* if there is nothing to commit reused the transaction */
	if (tr->wtime == 0) {
		if (m->debug)
			printf("no changes\n");
		tr->stime = timestamp();
		return 0;
	}

	MT_set_lock(mvc_lock, "mvc_commit");

	/* validation phase */
	if (validate(tr)) {
		/* write phase */
		if (m->debug)
			printf("forwarding changes\n");
		log_tstart(logger);
		rollforward_schemas(tr);
		log_tend(logger);
		res = 0;
	}

	MT_unset_lock(mvc_lock, "mvc_commit");

	tr = m->trans;
	while(tr->parent) 
		tr = trans_destroy(tr);

	m->trans = trans_dup(tr,NULL);
	m->trans->level = level;
	m->trans->status = res;
	return res;
}

int mvc_rollback(mvc * m, int chain, char *name)
{
	int res = 0;
	int level = (chain)?m->trans->level:ISO_SERIALIZABLE;
	sql_trans *tr = m->trans;

	if (m->debug)
		printf("mvc_rollback\n");

	if (name && name[0] != '\0'){
		while(tr->name && strcmp(tr->name,name) != 0)
	       		tr = trans_destroy(tr);
		m->trans = tr; /* restart at savepoint */
	} else {
		while(tr->parent) 
	       		tr = trans_destroy(tr);
		m->trans = trans_dup(tr,NULL);
	}
	m->trans->level = level;
	m->trans->status = 0;
	return res;
}

/* release all savepoints up including the given named savepoint 
 * but keep the current changes.
 * */
int mvc_release(mvc * m, char *name)
{
	int res = 0;
	sql_trans *tr = m->trans;
	sql_trans *p = tr->parent;

	while(p->name && strcmp(p->name, name) != 0)
	   	p = trans_destroy(p);

	tr->parent = p; 
	m->trans = tr; /* restart at savepoint */
	m->trans->status = res;
	return res;
}

int mvc_set_iso_level(mvc * m, int level)
{
	int res = mvc_commit(m,1,NULL);
	m->trans->level = level;
	m->trans->status = res;
	return res;
}

void mvc_destroy(mvc * m)
{
	sql_trans *tr;

	tr = m->trans;
	while(tr->parent) tr = trans_destroy(tr);
	_DELETE(m);
}

static BAT *bind_writable(sql_trans * tr, sql_column * c)
{
	BAT *nb = NULL, *b = mvc_descriptor(c->bid);
	if (c->wtime == 0) {	/* first write ie. need to copy */
		nb = BATcopy(b);
		BBPtransient(b->batCacheid, FALSE);
		BBPunfix(b->batCacheid);
		b = nb;
		c->bid = b->batCacheid;
		BBPpersistent(b->batCacheid, FALSE);
		BATfakeCommit(b);
		c->wtime = c->t->wtime = c->t->s->wtime = tr->wtime = tr->stime;
	}
	return b;
}

/* TODO 
	implement late binding here, than only the schema/tables/column 
	bats are always needed the others could be created when needed,
	ie it would be possible to implement CREATE TABLE in a rewriten
	SQL statement(INSERT INTO TABLES) 
		(There is however a problem, we still need to
		update the sql_* structs, could maybe also done using
		late bindings, ie fill structs when needed)
*/
	
BAT *mvc_bind(mvc * m, char *sname, char *tname, char *cname, int access)
{
	sql_trans *tr = m->trans;
	BAT *b = NULL;
	sql_schema *s = find_schema(tr, sname);
	sql_table *t = find_table(s, tname);
	sql_column *c;

	if (m->debug)
		printf("mvc_bind %s.%s(%d)\n", tname, cname, access);

	/* TODO check for access */

	assert(t);

	c = find_column(t, cname);

	if (access > 0){
		b = bind_writable(tr, c);
	} else {
		b = mvc_descriptor(c->bid);
	}

	c->rtime = t->rtime = s->rtime = tr->rtime = tr->stime;
	return b;
}

BAT *mvc_bind_ubat(mvc * m, char *sname, char *tname, char *cname, int access )
{
	sql_trans *tr = m->trans;
	BAT *nb, *b = NULL;
	sql_schema *s = find_schema(tr, sname);
	sql_table *t = find_table(s, tname);
	sql_column *c;

	if (m->debug)
		printf("mvc_bind_ubat %s.%s\n", tname, cname);

	/* TODO check for access */

	assert(t);

	c = find_column(t, cname);
	b = mvc_descriptor(c->ubid);
	if (c->wtime == 0) {	/* first write ie. need to copy */
		nb = BATcopy(b);
		BBPtransient(b->batCacheid, FALSE);
		BBPunfix(b->batCacheid);
		b = nb;
		c->ubid = b->batCacheid;
		BBPpersistent(b->batCacheid, FALSE);
		BATfakeCommit(b);
		c->wtime = c->rtime = t->rtime = tr->rtime = tr->stime;
	}

	c->rtime = t->rtime = tr->rtime = tr->stime;
	return b;
}

BAT *mvc_bind_obat(mvc * m, char *sname, char *tname, int access )
{
	sql_trans *tr = m->trans;
	BAT *nb, *b = NULL;
	sql_schema *s = find_schema(tr, sname);
	sql_table *t = find_table(s, tname);
	sql_column *c;

	if (m->debug)
		printf("mvc_bind_obat %s.oid\n", tname );

	/* TODO check for access */

	assert(t);

	b = mvc_descriptor(t->obid);
	if (t->wtime == 0) {	/* first write ie. need to copy */
		nb = BATcopy(b);
		BBPtransient(b->batCacheid, FALSE);
		BBPunfix(b->batCacheid);
		b = nb;
		t->obid = b->batCacheid;
		BBPpersistent(b->batCacheid, FALSE);
		BATfakeCommit(b);
		t->wtime = t->rtime = tr->rtime = tr->stime;
	}

	t->rtime = tr->rtime = tr->stime;
	return b;
}
BAT *mvc_bind_dbat(mvc * m, char *sname, char *tname, int access )
{
	sql_trans *tr = m->trans;
	BAT *nb, *b = NULL;
	sql_schema *s = find_schema(tr, sname);
	sql_table *t = find_table(s, tname);
	sql_column *c;

	if (m->debug)
		printf("mvc_bind_dbat %s.deletes\n", tname );

	/* TODO check for access */

	assert(t);

	b = mvc_descriptor(t->dbid);
	if (t->wtime == 0) {	/* first write ie. need to copy */
		nb = BATcopy(b);
		BBPtransient(b->batCacheid, FALSE);
		BBPunfix(b->batCacheid);
		b = nb;
		t->dbid = b->batCacheid;
		BBPpersistent(b->batCacheid, FALSE);
		BATfakeCommit(b);
		t->wtime = t->rtime = tr->rtime = tr->stime;
	}

	t->rtime = tr->rtime = tr->stime;
	return b;
}

sql_schema *mvc_bind_schema(mvc * m, char *sname )
{
	sql_trans *tr = m->trans;
	sql_schema *s = find_schema(tr, sname);
	if (!s)
		return NULL;
	s->wtime = tr->wtime;

	if (m->debug)
		printf("mvc_bind_schema %s\n", sname );

	return s;
}

sql_table *mvc_bind_table(mvc * m, sql_schema *s, char *tname )
{
	sql_table *t = find_table(s, tname);
	if (!t)
		return NULL;
	t->wtime = s->wtime;

	if (m->debug)
		printf("mvc_bind_table %s.%s\n", s->name, tname );

	return t;
}

sql_column *mvc_bind_column(mvc * m, sql_table * t, char *cname )
{
	sql_column *c = find_column(t, cname);
	if (!c)
		return NULL;
	c->wtime = t->wtime;

	if (m->debug)
		printf("mvc_bind_column %s.%s\n", t->name, cname );

	return c;
}


sql_key *mvc_bind_key(mvc * m, sql_table * t, va_list ap )
{
	sql_key *k = NULL;
	list *l;
	char *p;
	node *kn, *nn;
	int len;

	if (!t->keys)
		return NULL;

 	l = list_create(NULL);
	while(p = va_arg(ap,char*)){
		list_append(l,p);
	}
	len = list_length(l);
	
	for(kn = t->keys->h; !k && kn; kn = kn -> next){
		k = kn->data;
		if (list_length(k->columns) == len){
			node *cc;
			for(cc = k->columns->h, nn = l->h; cc && nn; 
				cc = cc -> next, nn = nn -> next){
				sql_column *c = cc->data;
				if (strcmp(c->name, nn->data) != 0){
					k = NULL;
					break;
				}
			}
		} else {
			k = NULL;
		}
	}
	list_destroy(l);

	if (m->debug)
		printf("mvc_bind_key %s.(%s..)\n", t->name, 
		 	((sql_column*)k->columns->h->data)->name );

	return k;
}


sql_schema *mvc_create_schema(mvc * m, char *name, char *auth)
{
	sql_trans *tr = m->trans;
	sql_schema *s = NEW(sql_schema);

	if (m->debug)
		printf("mvc_create_schema %s %s\n", name, auth);

	s->id = 0;
	s->name = _strdup(name);
	s->auth = _strdup(auth);
	s->flag = TR_NEW;

	s->tables = list_create((fdestroy)&table_destroy);
	s->dtables = NULL;
	s->ntable = NULL;

	if (!tr->nschema) tr->nschema = s;
	list_append(tr->schemas, s);

	s->wtime = tr->wtime = tr->stime;
	return s;
}


void mvc_drop_schema(mvc * m, char *sname)
{
	sql_trans *tr = m->trans;
	node *n = find_schema_node(tr, sname);
	sql_schema *s = n->data; 

	if (m->debug)
		printf("mvc_drop_schema %s\n", sname);

	if (s->flag == TR_NEW) {
		if (tr->nschema == s){
			if (n->next)
				tr->nschema = n->next->data;
			else
				tr->nschema = NULL;
		}
		list_remove_data(tr->schemas, s);
		schema_destroy(s);
	} else {
		if (!tr->dschemas) 
			tr->dschemas = 
				list_create((fdestroy)&schema_destroy);
		list_move_data(tr->schemas, tr->dschemas, s);
	}
	s->wtime = tr->wtime = tr->stime;
}

static sql_table *create_table_intern( mvc *m, char *name, int type)
{
	sql_table *t = NEW(sql_table);

	t->id = 0;
	t->name = _strdup(name);
	t->type = type;
	t->query = NULL;
	t->flag = TR_NEW;
	t->columns = list_create((fdestroy)&column_destroy);
	t->dcolumns = NULL;
	t->ncolumn = NULL;
	t->pkey = NULL;
	t->keys = NULL;
	t->dkeys = NULL;
	t->nkey = NULL;
	t->obid = 0;
	t->dbid = 0;
	return t;
}

sql_key *mvc_create_key( mvc * m, char *sname, char *tname, char *name, int kt, sql_key *rkey )
{ 
	int cnt = BUFSIZ;
	sql_trans *tr = m->trans;
	sql_schema *s = find_schema(tr, sname);
	sql_table *t = find_table(s, tname);
	sql_key *nk = (kt!=fkey)?(sql_key*)NEW(sql_ukey)
				:(sql_key*)NEW(sql_fkey);

	if (m->debug)
		printf("mvc_create_key %s %d %d\n", t->name, kt, (int)rkey);

	nk->id = key_new_id();
	nk->type = kt;
	nk->name = (name)?_strdup(name):NULL;
	nk->columns = list_create(NULL);
	nk->t = t;

	if (nk->type != fkey){
		/* create void,int bat to keep the hash values */
		BAT *b = BATnew( TYPE_void, TYPE_int, cnt );
		sql_ukey *uk = (sql_ukey*)nk;
		uk -> keys = NULL;

		BATseqbase(b,0);
		nk->bid = b->batCacheid;
		BBPpersistent(b->batCacheid, FALSE);
/*
		snprintf(name, BUFSIZ, "K_%s_%s", nk->t->name, nk->name );
*/
		BBPunfix(b->batCacheid);

		if (nk->type == pkey)
			t->pkey = uk;
	} else {
		BAT *b = BATnew( TYPE_void, TYPE_oid, cnt );
		sql_fkey *fk = (sql_fkey*)nk;
		sql_ukey *uk = (sql_ukey*)rkey;

		BATseqbase(b,0);
		nk->bid = b->batCacheid;
		BBPpersistent(b->batCacheid, FALSE);
/*
		snprintf(name, BUFSIZ, "F_%s_%s", nk->t->name, nk->name );
*/
		BBPunfix(b->batCacheid);

		fk -> rkey = uk;
		if (!uk->keys) uk->keys = list_create(NULL);
		list_append(uk->keys, fk);
	}

	if (!t->nkey) t->nkey = nk;
	if (!t->keys)
		t->keys = list_create((fdestroy)&key_destroy);
	list_append(t->keys, nk);

	return nk;
}

/* todo: add 'truncation` */
sql_key *mvc_key_add_column( mvc * m, sql_key *k, sql_column *c/*, int length */ ){

	if (m->debug)
		printf("mvc_key_add_column %s\n", c->name);
	list_append(k->columns, c);
	return k;
}

static sql_table *mvc_create_table_bat(mvc * m, sql_schema *s, char *name, 
		int type, BAT *o, BAT *d)
{
	sql_trans *tr = m->trans;
	sql_table *t = create_table_intern(m, name, type);

	t->query = _strdup("");
	t->s = s;
	if (!s->ntable) s->ntable = t;
	list_append(s->tables, t);

	t->obid = o->batCacheid;
	BBPpersistent(o->batCacheid, FALSE);
	t->dbid = d->batCacheid;
	BBPpersistent(d->batCacheid, FALSE);

	t->wtime = s->wtime = tr->wtime = tr->stime;
	return t;
}

sql_table *mvc_create_table(mvc * m, sql_schema *s, char *name, int type)
{
	sql_table *res = NULL;
	int cnt = BUFSIZ;
	BAT *o = BATnew( TYPE_void, TYPE_oid, cnt );
	BAT *d = BATnew( TYPE_void, TYPE_oid, cnt );

	if (m->debug)
		printf("mvc_create_table %s %s %d\n", s->name, name, type);

	res = mvc_create_table_bat(m, s, name, type, o, d);
	BBPunfix(o->batCacheid);
	BBPunfix(d->batCacheid);
	return res;
}


sql_table *mvc_create_view(mvc * m, sql_schema *s, char *name, char *sql)
{
	sql_trans *tr = m->trans;
	sql_table *t = create_table_intern(m, name, tt_view);

	if (m->debug)
		printf("mvc_create_view %s %s %s\n", s->name, name, sql);

	t->query = _strdup(sql);
	if (!s->ntable) s->ntable = t;
	list_append(s->tables, t);

	t->wtime = s->wtime = tr->wtime = tr->stime;
	return t;
}

void mvc_drop_table(mvc * m, sql_schema *s, char *name, bit cascade)
{
	sql_trans *tr = m->trans;
	node *n = find_table_node(s, name );
	sql_table *t = n->data;

	if (m->debug)
		printf("mvc_drop_table %s %s\n", s->name, name);

	if (t->flag == TR_NEW) {
		if (s->ntable == t){
			if (n->next)
				s->ntable = n->next->data;
			else
				s->ntable = NULL;
		}
		list_remove_data(s->tables, t);
		table_destroy(t);
	} else {
		if (!s->dtables) 
			s->dtables = list_create((fdestroy)&table_destroy);
		list_move_data(s->tables, s->dtables, t);
	}
	/* TODO cascade, ie. remove al references to this table */
	t->wtime = s->wtime = tr->wtime = tr->stime;
}

static sql_column *mvc_create_column_bat(mvc * m, sql_table *t, char *name,
		       char *sqltype, int type_size, int type_digits, int seqnr, BAT *b, BAT *u)
{
	sql_trans *tr = m->trans;
	sql_column *col = NEW(sql_column);

	col->id = 0;
	col->name = _strdup(name);
	col->type = new_subtype(sqltype, type_size, type_digits);
	col->def = _strdup("");
	col->null = 1;
	col->colnr = seqnr;
	col->rtime = 0;
	col->flag = TR_NEW;
	col->t = t;

	col->bid = b->batCacheid;
	BBPpersistent(b->batCacheid, FALSE);

	col->ubid = 0;
	if (u){
		col->ubid = u->batCacheid;
		BBPpersistent(u->batCacheid, FALSE);
	}

	if (!t->ncolumn) t->ncolumn = col;
	list_append(t->columns, col);

	col->wtime = t->wtime = tr->wtime = tr->stime;

	return col;
}

sql_column *mvc_create_column(mvc * m, sql_table *t, char *name,
		       char *sqltype, int type_size, int type_digits, int seqnr)
{

	sql_column *res = NULL;
	char *typename = sql_bind_type(sqltype)->name;
	int type = ATOMindex(typename), cnt = BUFSIZ;
	BAT *u = BATnew( TYPE_oid, type, cnt );
	BAT *b = BATnew( TYPE_void, type, cnt );

	if (m->debug)
		printf("mvc_create_column %s %s %s %d\n", t->name,
		       name, sqltype, seqnr);

	BATseqbase(b,0);
	res = mvc_create_column_bat(m, t, name, sqltype, type_size, type_digits, seqnr, b, u);
	BBPunfix(b->batCacheid);
	BBPunfix(u->batCacheid);

	return res;
}

void mvc_drop_column(mvc * m, sql_table *t, char *name)
{
	sql_trans *tr = m->trans;
	node *n = find_column_node(t, name);
	sql_column *col = n->data;

	if (m->debug)
		printf("mvc_drop_column %s %s\n", t->name, name);

	if (col->flag == TR_NEW) {
		if (t->ncolumn == col){
			if (n->next)
				t->ncolumn = n->next->data;
			else
				t->ncolumn = NULL;
		}
		list_remove_data(t->columns, col);
		column_destroy(col);
	} else {
		if (!t->dcolumns) 
			t->dcolumns = list_create((fdestroy)&column_destroy);
		list_move_data(t->columns, t->dcolumns, col);
	}

	col->wtime = t->wtime = tr->wtime = tr->stime;
}

sql_column * mvc_not_null(mvc * m, sql_column * col)
{
	sql_trans *tr = m->trans;

	if (m->debug)
		printf("mvc_not_null %s\n", col->name);

	col->null = 0;

	col->wtime = tr->wtime = tr->stime;
	return col;
}

sql_column * mvc_default(mvc * m, sql_column * col, char *val)
{
	sql_trans *tr = m->trans;

	if (m->debug)
		printf("mvc_default %s %s\n", col->name, val);

	_DELETE(col->def);
	col->def = _strdup(val);

	col->wtime = tr->wtime = tr->stime;
	return col;
}

/* roles can be defineed 
 * on the 'top (aka catalog) layer' and on the schema layer 
sql_role *mvc_create_role( mvc *m, sql_schema *s, char *name, int grantor )
{
	sql_trans *tr = m->trans;
	sql_role *role = NEW(sql_role);

	role -> id = 0;
	role -> name = _strdup(name);
	role -> grantor = grantor;
	role -> flag = TR_NEW;

	if (!s->nrole) s->nrole = role;
	list_append(s->roles, role);

	s->wtime = tr->wtime = tr->stime;
	return role;
}

sql_role *mvc_drop_role( mvc *m, sql_schema *s, char *name)
{
	sql_trans *tr = m->trans;
	node *n = find_role_node(s, name );
	sql_role *r = n->data;

	if (m->debug)
		printf("mvc_drop_role %s %s\n", s->name, name);

	if (r->flag == TR_NEW) {
		if (s->nrole == r){
			if (n->next)
				s->nrole = n->next->data;
			else
				s->nrole = NULL;
		}
		list_remove_data(s->roles, r);
		role_destroy(r);
	} else {
		if (!s->droles) 
			s->droles = list_create((fdestroy)&role_destroy);
		list_move_data(s->roles, s->droles, r);
	}
	s->wtime = tr->wtime = tr->stime;
}
*/


void mvc_export_schema(mvc * c, stream * s, sql_schema *schema )
{
	node *n;
	char buf[BUFSIZ];
	int i;

	i = snprintf(buf, BUFSIZ, "%d\n", list_length(schema->tables));
	s->write(s, buf, i, 1);
	for (n = schema->tables->h; n; n = n->next) {
		sql_table *t = n->data;
		int clen = list_length(t->columns);
		int klen = t->keys?list_length(t->keys):0;
		i = snprintf(buf, BUFSIZ, "%d,%s,%d,%d,%s,%d\n",
				 t->id, t->name, clen, t->type, t->query, klen);
		s->write(s, buf, i, 1);

		if (t->type != tt_view ) {
			node *m;
			for (m = t->columns->h; m; m = m->next) {
				sql_column *col = m->data;
				i = snprintf(buf, BUFSIZ,
					     "%d,%s,%s,%d,%d,%s,%d\n",
					     col->id, col->name,
					     col->type->type->sqlname, 
					     col->type->size,
					     col->type->digits,
					     col->def,
					     col->null);
				s->write(s, buf, i, 1);
			}
			if (t->keys) for (m = t->keys->h; m; m = m->next) {
				node *l;
				sql_key *k = m->data;
				i = snprintf(buf, BUFSIZ, "%d,%d,%s,%d,%d\n",
					     k->id, k->type, k->name, 
					     list_length(k->columns),
					     (k->type==fkey)?
						((sql_fkey*)k)->rkey->k.id:0);

				s->write(s, buf, i, 1);
				for (l = k->columns->h; l; l = l->next){
					sql_column *col = l->data;
					i = snprintf(buf, BUFSIZ, 
						"%s\n", col->name); 
					s->write(s, buf, i, 1);
				}
			}
		}
	}
}

void mvc_export_schemas(mvc * c, stream * s )
{
	sql_trans *tr = c->trans;
	node *n;
	int i;
	char buf[BUFSIZ];

	i = snprintf(buf, BUFSIZ, "%d\n", list_length(tr->schemas));
	s->write(s, buf, i, 1);

	for (n = tr->schemas->h; n; n = n->next) {
		sql_schema *schema = n->data;

		i = snprintf(buf, BUFSIZ, "%s\n", schema->name);
		s->write(s, buf, i, 1);
		mvc_export_schema(c, s, schema);
	}

	s->flush(s);
}

void mvc_export(stream * s, BAT * order, BAT * bats, char *sep,
		char *rsep)
{
	oid nil = oid_nil;
	char buf[BUFSIZ];
	int i, cnt = BATcount(bats);
	BAT *seps = BATnew( TYPE_void, TYPE_str, cnt );
	BATseqbase(seps,0);

	for (i = 0; i < cnt - 1; i++) {
		BUNins(seps, (ptr) &nil, (ptr) &sep);
	}
	BUNins(seps, (ptr) &nil, (ptr) &rsep);

	i = snprintf(buf, BUFSIZ, "%d\n", BATcount(order));
	s->write(s, buf, i, 1);
	ASCIIoutput(order, seps, bats, s);
	BBPreclaim(seps);
}

int mvc_import_table( mvc *m, stream *s, char *tname, 
		char *sep, char *rsep, int sz)
{
	BUN p,q;
	oid nil = oid_nil;
	int nr = 0, i, cnt; 
	oid newid;
	sql_column *col;
	sql_trans *tr = m->trans;
	node *n;
	sql_table *t = find_table(tr->schema, tname);
	BAT *rbats, *bns, *bats, *nmes, *seps, *tpes, *inss, *b;

	if (!t){
		fprintf(stderr,"ERROR: table %s not found\n", tname );
		tr->status = -1;
		return -1;
	}
	if (!s || s->errnr){
		fprintf(stderr,"ERROR: stream not open %d\n", s->errnr );
		tr->status = -1;
		return  -1;
	}

	bats = BATnew( TYPE_void, TYPE_bat, cnt );
	BATseqbase(bats,0);

	nmes = BATnew( TYPE_void, TYPE_str, cnt );
	BATseqbase(nmes,0);

	seps = BATnew( TYPE_void, TYPE_str, cnt );
	BATseqbase(seps,0);

	tpes = BATnew( TYPE_void, TYPE_str, cnt );
	BATseqbase(tpes,0);

	t->wtime = tr->wtime = tr->stime;
	for (n = t->columns->h; n && n->next; n = n->next, nr++) 
	{
		col = n->data;

		b = bind_writable(tr, col);
		BUNins(bats, (ptr)&nil, (ptr)&(b->batCacheid));
		BUNins(nmes, (ptr)&nil, BBPname(b->batCacheid));
		BUNins(seps, (ptr)&nil, sep);
		BUNins(tpes, (ptr)&nil, ATOMname(b->ttype));
		BBPunfix(b->batCacheid);
	}
	if (n){
		col = n->data;
		b = bind_writable(tr, col);
		BUNins(bats, (ptr)&nil, (ptr)&(b->batCacheid));
		BUNins(nmes, (ptr)&nil, BBPname(b->batCacheid));
		BUNins(seps, (ptr)&nil, rsep);
		BUNins(tpes, (ptr)&nil, ATOMname(b->ttype));
		BBPunfix(b->batCacheid);
	}
	inss = ASCIIinput( nmes, seps, tpes, s, sz);
	if (!inss)
		return -1;
	bns = BATjoin(BATmirror(bats),nmes);
	rbats = BATjoin(bns,inss);

	
	BATloop(rbats,p,q){
		BAT *ba = mvc_descriptor(*(bat*)BUNhead(rbats, p));
		BAT *in = mvc_descriptor(*(bat*)BUNtail(rbats, p));

		cnt = BATcount(in);
		printf("%s\n", BBPname(ba->batCacheid));
		BATins(ba,in);

		BBPunfix(ba->batCacheid);
		BBPunfix(in->batCacheid);
	} 
	b = mvc_bind_obat(m, t->s->name, t->name, INS);
	newid = OIDnew(cnt);
	nr = cnt;
	for(;cnt;cnt--, newid++)
		BUNins(b, (ptr)&nil, (ptr)&newid );
	BBPunfix(b->batCacheid);

	BBPreclaim(bns);
	BBPreclaim(rbats);
	BBPreclaim(inss);
	BBPreclaim(bats);
	BBPreclaim(nmes);
	BBPreclaim(seps);
	BBPreclaim(tpes);
	tr->status = nr;
	return nr;
}
