@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2004 CWI.
@' All Rights Reserved.

@f sql_parser
@a N.J. Nes
@* 

@h
#ifndef _SQL_PARSER_H_
#define _SQL_PARSER_H_

#include "sql_statement.h"
#include "sql_trans.h"

typedef enum tokens {
	SQL_CREATE_SCHEMA,
	SQL_CREATE_TABLE,
	SQL_CREATE_VIEW,
	SQL_CREATE_INDEX,
	SQL_CREATE_ROLE,
	SQL_CREATE_USER,
	SQL_CREATE_MODULE,
	SQL_CREATE_TYPE,
	SQL_CREATE_FUNC,
	SQL_CREATE_SEQ,
	SQL_DROP_SCHEMA,
	SQL_DROP_TABLE,
	SQL_DROP_VIEW,
	SQL_DROP_INDEX,
	SQL_DROP_ROLE,
	SQL_DROP_USER,
	SQL_DROP_MODULE,
	SQL_DROP_TYPE,
	SQL_DROP_FUNC,
	SQL_DROP_SEQ,
	SQL_ALTER_TABLE,
	SQL_ALTER_USER,
	SQL_DROP_COLUMN,
	SQL_DROP_CONSTRAINT,
	SQL_DROP_DEFAULT,
	SQL_DECLARE,
	SQL_SET,
	SQL_PREP,
	SQL_NAME,
	SQL_USER,
	SQL_PATH,
	SQL_CHARSET,
	SQL_SCHEMA,
	SQL_TABLE,
	SQL_CASE,
	SQL_CAST,
	SQL_COLUMN,
	SQL_COLUMN_OPTIONS,
	SQL_COALESCE,
	SQL_CONSTRAINT,
	SQL_CHECK,
	SQL_DEFAULT,
	SQL_NOT_NULL,
	SQL_NULL,
	SQL_NULLIF,
	SQL_UNIQUE,
	SQL_PRIMARY_KEY,
	SQL_FOREIGN_KEY,
	SQL_BEGIN,
	TR_COMMIT,
	TR_ROLLBACK,
	TR_SAVEPOINT,
	TR_RELEASE,
	TR_START,
	TR_MODE,
	SQL_INSERT,
	SQL_DELETE,
	SQL_UPDATE,
	SQL_CROSS,
	SQL_JOIN,
	SQL_SELECT,
	SQL_WHERE,
	SQL_FROM,
	SQL_UNIONJOIN,
	SQL_UNION,
	SQL_EXCEPT,
	SQL_INTERSECT,
	SQL_VALUES,
	SQL_ASSIGN,
	SQL_ORDERBY,
	SQL_GROUPBY,
	SQL_DESC,
	SQL_AND,
	SQL_OR,
	SQL_NOT,
	SQL_EXISTS,
	SQL_NOT_EXISTS,
	SQL_OP,
	SQL_UNOP,
	SQL_BINOP,
	SQL_NOP,
	SQL_BETWEEN,
	SQL_NOT_BETWEEN,
	SQL_LIKE,
	SQL_NOT_LIKE,
	SQL_IN,
	SQL_NOT_IN,
	SQL_GRANT,
	SQL_GRANT_ROLES,
	SQL_REVOKE,
	SQL_REVOKE_ROLES,
	SQL_EXECUTE,
	SQL_PRIVILEGES,
	SQL_ROLE,
	SQL_PARAMETER,
	SQL_FUNC,
	SQL_AGGR,
	SQL_COMPARE,
	SQL_TEMP_LOCAL,
	SQL_TEMP_GLOBAL,
	SQL_INT_VALUE,
	SQL_ATOM,
	SQL_USING,
	SQL_WHEN,
	SQL_ESCAPE,
	SQL_COPYFROM,
	SQL_COPYTO,
	SQL_EXPORT
} tokens;

typedef enum jt {
	jt_inner = 0,
	jt_left = 1,
	jt_right = 2,
	jt_full = 3,
	jt_union = 4
} jt;

sql_export char *token2string(int token);
sql_export stmt *sql_error( mvc * sql, int error_code, char *format, ... );
sql_export int parse_error( mvc * sql, char *s);
sql_export int sqlparse(void *);

#endif /*_SQL_PARSER_H_*/

@y
%{
#include <sql_mem.h>
#include "sql_parser.h"
#include "sql_symbol.h"
#include "sql_datetime.h"
#include "sql_decimal.h"	/* for decimal_from_str() */
#include "sql_semantic.h"	/* for sql_add_param() & sql_add_arg() */
#include "sql_env.h"

#include <unistd.h>
#include <string.h>
#include <stdlib.h>

#define _symbol_create(t,d)         symbol_create( t, d)
#define _symbol_create_list(t,d)    symbol_create_list( t, d)
#define _symbol_create_int(t,d)     symbol_create_int( t, d)
#define _symbol_create_symbol(t,d)  symbol_create_symbol( t, d)
#define _newAtomNode(d)		    newAtomNode( d)

#define YYPARSE_PARAM parm
#define YYLEX_PARAM parm
#ifdef yyerror
#undef yyerror
#endif
#define yyerror(s) parse_error(YYLEX_PARAM, s)

#define FALSE 0
#define TRUE 1

%}
/* KNOWN NOT DONE OF sql'99
 * 
 * TRIGGERS
 * COLLATION
 * TRANSLATION
 * REF/SCOPE
 * UDT
 */

/* reentrant parser */
%pure_parser
%union {
	int 		ival,operation,bval;
	double 		fval;
	char *		sval;
	symbol*		sym;
	dlist*		l;
	sql_subtype*	type;
}
%{
extern int sqllex( YYSTYPE *yylval, void *m );
%}

	/* symbolic tokens */
%type <sym> 
	alter
	assignment
	create
	drop
	declare
	set
	sql
	sqlstmt
	schema
	opt_schema_default_char_set
	opt_schema_path
	schema_element
	delete_stmt
	copyfrom_stmt
	table_def
	view_def
	view_as
	role_def
	module_def
	type_def
	func_def
	index_def
  	seq_def
	all_or_any_predicate
	atom_exp
	between_predicate
	comparison_predicate
	opt_from_clause
	existence_test
	in_predicate
	insert_stmt
	transaction_stmt
	_transaction_stmt
	like_predicate
	opt_where_clause
	opt_having_clause
	opt_group_by_clause
	predicate
	joined_table
	join_spec
	search_condition
	update_stmt
	select_stmt
	select_with_parens
	select_no_parens
	simple_select
	complex_select
	set_select
	subquery
	target
	test_for_null
	values_or_query_spec
	grant
	revoke
	operation
	table_element
	add_table_element
	alter_table_element
	drop_table_element
	table_constraint
	table_constraint_type
	column_def
	column_options
	column_option
	column_constraint
	column_constraint_type 
	like_table
	domain_constraint_type
	opt_order_by_clause
	default
	default_value
	cast_value
	aggr_ref
	func_ref
	datetime_funcs
	string_funcs
	scalar_exp
	value_exp
	column_exp
	atom
	insert_atom
	literal
	interval_expression
	ordering_spec
	simple_table
	table_ref 
	opt_temp
	case_exp
	cast_exp
	when_value
	when_search
	opt_else
	table_name
	ref_on
	object_name
	prep
	exec
	exec_ref

%type <type>
	data_type
	datetime_type
	interval_type
	func_data_type

%type <sval>
	opt_constraint_name 
	any_all_some
	non_reserved_word
	ident
	func_ident
	column
	authid
	grantee
	opt_alias_name
	opt_to_savepoint
	opt_using
	string
	type_alias
	opt_schema
	opt_passwd

%type <l>
	object_privileges
	privileges
	schema_name
	sqlstmt_list
	assignment_commalist
	opt_column_commalist
	column_commalist_parens
	column_commalist
	opt_corresponding
	column_ref_commalist
	name_commalist 
	column_ref
	atom_commalist
	row_commalist
	qname 
	ordering_spec_commalist
	opt_schema_element_list
	schema_element_list
	operation_commalist
	target_commalist
	opt_into
	authid_list
	grantee_commalist
	column_def_opt_list
	opt_column_def_opt_list
	table_exp
	table_ref_commalist 
	table_element_list
	table_content_source
	column_exp_commalist
	column_option_list
	selection
	start_field
	end_field
	single_datetime_field
	interval_qualifier
	scalar_exp_list
	scalar_exp_list2
	when_value_list
	when_search_list
	opt_seps
	string_commalist
	paramlist
	opt_paramlist
	opt_ref_action

%type <ival>
	drop_action 
	ref_action 
	join_type
	outer_join_type
	time_persision
	non_second_datetime_field
	datetime_field
	opt_bounds
	opt_sign
	opt_index_type
	intval
	nonzero
	opt_nr
	opt_limit
	opt_match
	opt_match_type
	opt_on_commit
	opt_grantor
	opt_from_grantor
	opt_column
	grantor
	transaction_mode
	transaction_mode_list
	_transaction_mode_list
	opt_start
	opt_increment
	opt_min
	opt_max
	opt_cycle

%type <bval>
	opt_brackets

	opt_work
	opt_chain
	opt_distinct
	set_distinct
	opt_with_check_option

	opt_with_grant
	opt_with_admin
	opt_admin_for
	opt_grant_for

	opt_asc_desc
	opt_var
	tz

%right <sval> STRING

/* sql prefixes to avoid name clashes on various architectures */
%token <sval> 
	IDENT aMODULE aTYPE ALIAS AGGR sqlINT INTNUM APPROXNUM USING
	ALL DISTINCT ANY SOME CHECK GLOBAL CAST CONVERT
	CHARACTER VARYING sqlDECIMAL sqlFLOAT 
	TINYINT SMALLINT MEDIUMINT BIGINT
	sqlDOUBLE PRECISION PARTIAL SIMPLE ACTION CASCADE RESTRICT
	BOOL_FALSE BOOL_TRUE 
	CURRENT_ROLE CURRENT_DATE CURRENT_TIMESTAMP CURRENT_TIME
	LEX_ERROR
%token	USER CURRENT_USER sqlSESSION SESSION_USER LOCAL

%token <sval> sqlDELETE UPDATE SELECT INSERT
%token <sval> LEFT RIGHT FULL OUTER NATURAL CROSS JOIN INNER 
%token <sval> COMMIT ROLLBACK SAVEPOINT RELEASE WORK CHAIN NO PRESERVE ROWS
%token  START TRANSACTION READ WRITE ONLY ISOLATION LEVEL
%token  UNCOMMITTED COMMITTED REPEATABLE SERIALIZABLE DIAGNOSTICS sqlSIZE
	
%token <sval> ASYMMETRIC SYMMETRIC ORDER BY
%token <sval> LIKE BETWEEN 
%token <operation> sqlIN EXISTS ESCAPE HAVING GROUP NULLX 
%token <operation> FROM FOR MATCH

/* datetime operations */
%token <operation> EXTRACT
%token SEQUENCE INCREMENT MAXVALUE MINVALUE CYCLE 
%token NEXT VALUE 
%token GENERATED IDENTITY

	/* operators */
%left UNION EXCEPT INTERSECT CORRESPONDING UNIONJOIN
%left JOIN CROSS LEFT FULL RIGHT INNER NATURAL
%left LIKE BETWEEN sqlIN WITH
%left <operation> OR
%left <operation> AND
%left <operation> NOT
%left <operation> '('
%left <sval> COMPARISON /* <> < > <= >= */
%left <operation> '='
%left <operation> '+' '-'
%left <operation> '*' '/' '%'
%left <operation> SUBSTRING CONCATSTRING POSITION
%right UMINUS

	/* literal keyword tokens */
/*
CONTINUE CURRENT CURSOR FOUND GOTO GO LANGUAGE 
SQLCODE SQLERROR UNDER WHENEVER 
*/

%token TEMPORARY 
%token<sval> AS ASC DESC AUTHORIZATION 
%token CHECK CONSTRAINT CREATE 
%token MODULE TYPE PROCEDURE FUNCTION RETURNS EXTERNAL sqlNAME DECLARE
%token PREPARE EXECUTE
%token DEFAULT DISTINCT DROP 
%token FOREIGN 
%token PASSWORD GRANT REVOKE ROLE ADMIN HAVING INTO 
%token IS KEY ON OPTION OPTIONS
%token PATH PRIMARY PRIVILEGES 
%token<sval> PUBLIC REFERENCES SCHEMA SET 

%token ALTER ADD TABLE COLUMN TO UNIQUE VALUES VIEW BATS WHERE WITH 
%token<sval> sqlDATE TIME TIMESTAMP INTERVAL
%token YEAR MONTH DAY HOUR MINUTE SECOND ZONE
%token LIMIT

%token CASE WHEN THEN ELSE END NULLIF COALESCE
%token COPY RECORDS DELIMITERS STDIN
%token INDEX

%%

sqlstmt:
   sql ';' 		{ mvc *m = (mvc*)parm; 
			  m->sym = $$ = $1; YYACCEPT; }
 | prep   		{ mvc *m = (mvc*)parm; 
			  m->sym = $$ = $1; YYACCEPT; }
 | exec ';' 		{ mvc *m = (mvc*)parm; 
			  m->sym = $$ = $1; YYACCEPT; }
 | /*empty*/		{ mvc *m = (mvc*)parm; 
			  m->sym = $$ = NULL; YYACCEPT; }
 | ';'			{ mvc *m = (mvc*)parm; 
			  m->sym = $$ = NULL; YYACCEPT; }
 | error ';'		{ mvc *m = (mvc*)parm;
			  m->sym = $$ = NULL; YYACCEPT; }
 | LEX_ERROR 		{ mvc *m = (mvc*)parm;
			  m->sym = $$ = NULL; YYACCEPT; }
 ;

sqlstmt_list:
    sql 		{ $$ = dlist_append_symbol(dlist_create(), $1); }
 |  sqlstmt_list ';' sql 	
			{ $$ = dlist_append_symbol( $1, $3 ); }
 ;

	/* schema definition language */
sql: 
    schema  	
 |  grant  	
 |  revoke  	
 |  create  
 |  drop   
 |  alter 
 |  declare 
 |  set 
 ;
	
declare:
	DECLARE ident data_type 
			{ dlist *l = dlist_create();
			dlist_append_string(l, $2 );
	  		dlist_append_type(l, $3 );
			$$ = _symbol_create_list( SQL_DECLARE, l); }
	;

set: 
	SET ident '=' scalar_exp	
			{ dlist *l = dlist_create();
			dlist_append_string(l, $2 );
			dlist_append_symbol(l, $4 );
			$$ = _symbol_create_list( SQL_SET, l); }
  |	SET sqlSESSION AUTHORIZATION ident	
			{ dlist *l = dlist_create();
		          sql_subtype *t = sql_bind_subtype("CHAR", strlen($4), 0 ); 
			dlist_append_string(l, _strdup("current_user") );
			dlist_append_symbol(l, 
				_newAtomNode( atom_string(t,sql2str($4))) );
			$$ = _symbol_create_list( SQL_SET, l); }
  |	SET SCHEMA ident	
			{ dlist *l = dlist_create();
		          sql_subtype *t = sql_bind_subtype("CHAR", strlen($3), 0 ); 
			dlist_append_string(l, _strdup("current_schema") );
			dlist_append_symbol(l, 
				_newAtomNode( atom_string(t,sql2str($3))) );
			$$ = _symbol_create_list( SQL_SET, l); }
  |	SET user '=' ident	
			{ dlist *l = dlist_create();
		          sql_subtype *t = sql_bind_subtype("CHAR", strlen($4), 0 ); 
			dlist_append_string(l, _strdup("current_user") );
			dlist_append_symbol(l, 
				_newAtomNode( atom_string(t,sql2str($4))) );
			$$ = _symbol_create_list( SQL_SET, l); }
  |	SET ROLE ident	
			{ dlist *l = dlist_create();
		          sql_subtype *t = sql_bind_subtype("CHAR", strlen($3), 0 ); 
			dlist_append_string(l, _strdup("current_role") );
			dlist_append_symbol(l, 
				_newAtomNode( atom_string(t,sql2str($3))) );
			$$ = _symbol_create_list( SQL_SET, l); }
  | 	SET TIME ZONE LOCAL
			{ dlist *l = dlist_create();
			dlist_append_string(l, _strdup("current_timezone") );
			dlist_append_symbol(l, _symbol_create_list( SQL_OP, 
				dlist_append_string(
					dlist_create(), 
					_strdup("local_timezone"))));
			$$ = _symbol_create_list( SQL_SET, l); }
  | 	SET TIME ZONE interval_expression
			{ dlist *l = dlist_create();
			dlist_append_string(l, _strdup("current_timezone") );
			dlist_append_symbol(l, $4 );
			$$ = _symbol_create_list( SQL_SET, l); }
  ;

schema:
    CREATE SCHEMA schema_name opt_schema_default_char_set
	opt_schema_path	opt_schema_element_list	   

	{ dlist *l = dlist_create();
	  dlist_append_list(l, $3);
	  dlist_append_symbol(l, $4);
	  dlist_append_symbol(l, $5);
	  dlist_append_list(l, $6);
	  $$ = _symbol_create_list( SQL_CREATE_SCHEMA, l); }
 |  DROP SCHEMA qname drop_action 

	{ dlist *l = dlist_create();
	  dlist_append_list(l, $3);
	  dlist_append_int(l, $4);
	  $$ = _symbol_create_list( SQL_DROP_SCHEMA, l); }
 ;

schema_name:
    ident		    	
	{ $$ = dlist_create();
	  dlist_append_string($$, $1 );
	  dlist_append_string($$, NULL ); }
 |  AUTHORIZATION ident  	
	{ $$ = dlist_create();
	  dlist_append_string($$, NULL );
	  dlist_append_string($$, $2 ); }
 |  ident AUTHORIZATION ident 
	{ $$ = dlist_create();
	  dlist_append_string($$, $1 );
	  dlist_append_string($$, $3 ); }
 ;

opt_schema_default_char_set:
    /* empty */		   	{ $$ = NULL; }
 |  DEFAULT CHARACTER SET ident { $$ = _symbol_create( SQL_CHARSET, $4 ); }
 ;

opt_schema_path:
    /* empty */			{ $$ = NULL; }
 |  PATH name_commalist 	{ $$ = _symbol_create_list( SQL_PATH, $2 ); }
 ;

opt_schema_element_list:
    /* empty */			{ $$ = dlist_create(); }
 |  schema_element_list 	
 ;

schema_element_list:
    schema_element	{ $$ = dlist_append_symbol(dlist_create(), $1); }
 |  schema_element_list schema_element 	
			{ $$ = dlist_append_symbol( $1, $2 ); }
 ;

schema_element: grant | revoke | create | drop | alter ;
/* | add */


opt_grantor:
     /* empty */	 { $$ = cur_user; } 
 |   WITH ADMIN grantor  { $$ = $3; }
 ;

grantor:
    CURRENT_USER	{ $$ = cur_user; }
 |  CURRENT_ROLE 	{ $$ = cur_role; }
 ;

grant:
    GRANT privileges TO grantee_commalist opt_with_grant opt_from_grantor
	{ dlist *l = dlist_create();
	  dlist_append_list(l, $2);
	  dlist_append_list(l, $4);
	  dlist_append_int(l, $5);
	  dlist_append_int(l, $6);
	$$ = _symbol_create_list( SQL_GRANT, l); 
	}

 |  GRANT authid_list TO grantee_commalist opt_with_admin 
		opt_from_grantor
	{ dlist *l = dlist_create();
	  dlist_append_list(l, $2);
	  dlist_append_list(l, $4);
	  dlist_append_int(l, $5);
	  dlist_append_int(l, $6);
	$$ = _symbol_create_list( SQL_GRANT_ROLES, l); }
 ;

authid_list:
	authid 		{ $$ = dlist_append_string(dlist_create(), $1); }
 | 	authid_list ',' authid 	
			{ $$ = dlist_append_string($1, $3); }
 ;

opt_with_grant:
    /* empty */				{ $$ = 0; }
 |	WITH GRANT OPTION		{ $$ = 1; }
 ;

opt_with_admin:
 	/* emtpy */		{ $$ = 0; }
 | 	WITH ADMIN OPTION	{ $$ = 1; }
 ;


opt_from_grantor:
 	/* empty */	{ $$ = cur_user; }
 | 	FROM grantor	{ $$ = $2; }
 ;

revoke:
     REVOKE opt_grant_for privileges FROM grantee_commalist opt_from_grantor
	{ dlist *l = dlist_create();
	  dlist_append_list(l, $3);
	  dlist_append_list(l, $5);
	  dlist_append_int(l, $2); /* GRANT OPTION FOR */ 
	  dlist_append_int(l, 0);
	  dlist_append_int(l, $6);
	$$ = _symbol_create_list( SQL_REVOKE, l); }
 |   REVOKE opt_admin_for authid_list FROM grantee_commalist 
	opt_from_grantor
	{ dlist *l = dlist_create();
	  dlist_append_list(l, $3);
	  dlist_append_list(l, $5);
	  dlist_append_int(l, $6);
	  dlist_append_int(l, $2);
	$$ = _symbol_create_list( SQL_REVOKE, l); }
 ;

opt_grant_for:
    	/* empty */			{ $$ = 0; }
 |	GRANT OPTION FOR		{ $$ = 1; }
 ;

opt_admin_for:
    	/* empty */			{ $$ = 0; }
 |	ADMIN OPTION FOR		{ $$ = 1; }
 ;

privileges:
	object_privileges ON object_name 	
	{ $$ = dlist_create();
	  dlist_append_list($$, $1);
	  dlist_append_symbol($$, $3); }
 ;

object_name:
     TABLE ident		{ $$ = _symbol_create(SQL_TABLE, $2); }
 |   ident			{ $$ = _symbol_create(SQL_NAME, $1); }

/* | DOMAIN domain_name
   | CHARACTER SET char_set_name
   | COLLATION collation_name
   | TRANSLATION trans_name 
   | TYPE udt_name 
   | TYPE typed_table_name 
*/
 ; 

object_privileges:
    ALL PRIVILEGES			{ $$ = NULL; }
 |  ALL 				{ $$ = NULL; }
 |  operation_commalist			
 ;

operation_commalist:
    operation		{ $$ = dlist_append_symbol(dlist_create(), $1); }
 |  operation_commalist ',' operation   
			{ $$ = dlist_append_symbol($1, $3); }
 ;

operation:
    INSERT 			    { $$ = _symbol_create(SQL_INSERT,NULL); }
 |  sqlDELETE 			    { $$ = _symbol_create(SQL_DELETE,NULL); }
 |  UPDATE opt_column_commalist     { $$ = _symbol_create_list(SQL_UPDATE,$2); }
 |  SELECT opt_column_commalist	    { $$ = _symbol_create_list(SQL_SELECT,$2); }
 |  REFERENCES opt_column_commalist { $$ = _symbol_create_list(SQL_SELECT,$2); }
 |  EXECUTE			    { $$ = _symbol_create(SQL_EXECUTE,NULL); }
/* | TRIGGER
   | UNDER 
   | USAGE
*/
 ;

grantee_commalist:			
    grantee			{ $$ = dlist_append_string(dlist_create(), $1); }
 |  grantee_commalist ',' grantee	
				{ $$ = dlist_append_string($1, $3); }
 ;

grantee:
    PUBLIC			{ $$ = NULL; }
 |  authid			{ $$ = $1; }
 ;

/* DOMAIN, ASSERTION, CHARACTER SET, TRANSLATION, TRIGGER */ 

alter: 
   ALTER TABLE qname ADD add_table_element 

	{ dlist *l = dlist_create();
	  dlist_append_list(l, $3);
	  dlist_append_symbol(l, $5);
	  $$ = _symbol_create_list( SQL_ALTER_TABLE, l ); }
 | ALTER TABLE qname ALTER alter_table_element 

	{ dlist *l = dlist_create();
	  dlist_append_list(l, $3);
	  dlist_append_symbol(l, $5);
	  $$ = _symbol_create_list( SQL_ALTER_TABLE, l ); }
 | ALTER TABLE qname DROP drop_table_element 
	{ dlist *l = dlist_create();
	  dlist_append_list(l, $3);
	  dlist_append_symbol(l, $5);
	  $$ = _symbol_create_list( SQL_ALTER_TABLE, l ); }
 | ALTER USER ident opt_passwd opt_schema
	{ dlist *l = dlist_create();
	  dlist_append_string(l, $3);
	  dlist_append_string(l, $4);
	  dlist_append_string(l, $5);
	  $$ = _symbol_create_list( SQL_ALTER_USER, l ); }
  ;

opt_passwd:
	/* empty */		{ $$ = NULL; }
  |	WITH PASSWORD string 	{ $$ = $3; }
  ;

opt_schema:
	/* empty */		{ $$ = NULL; }
  |	SCHEMA ident 		{ $$ = $2; }
  ;

alter_table_element:
	opt_column ident SET DEFAULT default_value 
	{ dlist *l = dlist_create();
	  dlist_append_string(l, $2);
	  dlist_append_symbol(l, $5);
	  $$ = _symbol_create_list( SQL_DEFAULT, l); }
 | 	opt_column ident DROP DEFAULT 
	{ $$ = _symbol_create( SQL_DROP_DEFAULT, $2); }
 ;

drop_table_element:
     opt_column ident drop_action
	{ dlist *l = dlist_create();
	  dlist_append_string(l, $2 );
	  dlist_append_int(l, $3 );
	  $$ = _symbol_create_list( SQL_DROP_COLUMN, l ); }
  |  CONSTRAINT ident drop_action
	{ dlist *l = dlist_create();
	  dlist_append_string(l, $2 );
	  dlist_append_int(l, $3 );
	  $$ = _symbol_create_list( SQL_DROP_CONSTRAINT, l ); }
  ;

opt_column:
     COLUMN	 { $$ = 0; }
 |   /* empty */ { $$ = 0; }
 ;

create:	role_def | table_def | view_def | module_def | type_def | func_def | index_def | seq_def;

seq_def:
    CREATE SEQUENCE qname 
    AS data_type 
    opt_start
    opt_increment
    opt_min
    opt_max
    opt_cycle
	{ dlist *l = dlist_create();
	  dlist_append_list(l, $3 );
	  dlist_append_type(l, $5 );
	  dlist_append_int(l, $6 );
	  dlist_append_int(l, $7 );
	  dlist_append_int(l, $8 );
	  dlist_append_int(l, $9 );
	  dlist_append_int(l, $10 );
	  $$ = _symbol_create_list( SQL_CREATE_SEQ, l ); }
  | DROP SEQUENCE qname 
	{ $$ = _symbol_create_list( SQL_DROP_SEQ, $3 ); } 
  ;

opt_start:
     /* empty */ 		{ $$ = 1; }
  |  START WITH intval 		{ $$ = $3; }
  ;

opt_increment:
     /* empty */ 		{ $$ = 1; }
  |  INCREMENT BY intval 	{ $$ = $3; }
  ;

opt_min:
     /* empty */ { $$ = 1; }
  |  NO MINVALUE { $$ = 0; }
  ;

opt_max:
     /* empty */ { $$ = 1; }
  |  NO MAXVALUE { $$ = 0; }
  ;

opt_cycle:
     /* empty */ { $$ = 1; }
  |  NO CYCLE 	 { $$ = 0; }
  ;

index_def:
    CREATE opt_index_type INDEX ident ON qname '(' column_commalist ')' 
	{ dlist *l = dlist_create();
	  dlist_append_string(l, $4);
	  dlist_append_int(l, $2);
	  dlist_append_list(l, $6);
	  dlist_append_list(l, $8);
	  $$ = _symbol_create_list( SQL_CREATE_INDEX, l); }
  ;

opt_index_type:
     UNIQUE		{ $$ = unique; }
 |   /* empty */	{ $$ = unique; }
 ;

/* sql-server def
CREATE [ UNIQUE ] [ CLUSTERED | NONCLUSTERED ] INDEX index_name
    ON { table | view } ( column [ ASC | DESC ] [ ,...n ] )
[ WITH < index_option > [ ,...n] ]
[ ON filegroup ]

< index_option > :: =
    { PAD_INDEX |
        FILLFACTOR = fillfactor |
        IGNORE_DUP_KEY |
        DROP_EXISTING |
    STATISTICS_NORECOMPUTE |
    SORT_IN_TEMPDB 
}
*/

role_def:
    CREATE ROLE qname opt_grantor
	{ dlist *l = dlist_create();
	  dlist_append_list(l, $3);
	  dlist_append_int(l, $4);
	  $$ = _symbol_create_list( SQL_CREATE_ROLE, l ); }
 |  CREATE USER ident WITH PASSWORD string sqlNAME string SCHEMA ident
	{ dlist *l = dlist_create();
	  dlist_append_string(l, $3);
	  dlist_append_string(l, $6);
	  dlist_append_string(l, $8);
	  dlist_append_string(l, $10);
	  $$ = _symbol_create_list( SQL_CREATE_USER, l ); }
 ;

table_def:
    CREATE opt_temp TABLE qname table_content_source opt_on_commit opt_nr

	{ dlist *l = dlist_create();
	  dlist_append_symbol(l, $2);
	  dlist_append_list(l, $4);
	  dlist_append_list(l, $5);
	  dlist_append_int(l, $7);
	  $$ = _symbol_create_list( SQL_CREATE_TABLE, l ); }
 ;

opt_temp:
    /* empty */ 	{ $$ = NULL; }
 |  LOCAL TEMPORARY 	{ $$ = _symbol_create( SQL_TEMP_LOCAL, NULL); }
 |  GLOBAL TEMPORARY	{ $$ = _symbol_create( SQL_TEMP_GLOBAL, NULL); }
 ;

opt_on_commit: /* only for temporary tables */
    /* empty */			 { $$ = 0; } /* default delete rows on commit */
 |  ON COMMIT PRESERVE ROWS  	 { $$ = 1; }
 |  ON COMMIT sqlDELETE ROWS	 { $$ = 0; } 
 ;
	
table_content_source:
    '(' table_element_list ')' 	{ $$ = $2; }
 ;

table_element_list:
    table_element	 
			{ $$ = dlist_append_symbol(dlist_create(), $1); }
 |  table_element_list ',' table_element
			{ $$ = dlist_append_symbol( $1, $3 ); }
 ;

add_table_element: column_def | table_constraint ;
table_element: add_table_element | column_options | like_table ;

column_def:
    column data_type opt_column_def_opt_list
   	{ dlist *l = dlist_create();
	  dlist_append_string(l, $1 );
	  dlist_append_type(l, $2 );
	  dlist_append_list(l, $3 );
	  $$ = _symbol_create_list( SQL_COLUMN, l ); }
 ;

opt_column_def_opt_list:
    /* empty */			{ $$ = NULL; }
 | column_def_opt_list
 ;

column_def_opt_list:
    column_option		
			{ $$ = dlist_append_symbol(dlist_create(), $1 ); }
 |  column_def_opt_list column_option 	
			{ $$ = dlist_append_symbol( $1, $2 ); }
 ;

column_options:
    ident WITH OPTIONS '(' column_option_list ')'  

   	{ dlist *l = dlist_create();
	  dlist_append_string(l, $1 );
	  dlist_append_list(l, $5 );
	  $$ = _symbol_create_list( SQL_COLUMN_OPTIONS, l ); }
 ;

column_option_list:
    column_option		
			{ $$ = dlist_append_symbol(dlist_create(), $1 ); }
 |  column_option_list ',' column_option   
			{ $$ = dlist_append_symbol($1, $3 ); }
 ;

column_option: default | column_constraint ;

default:
    DEFAULT default_value { $$ = $2; }
 ;

/* TODO add auto increment */
default_value:
    literal 

 |  NULLX 	
		{ $$ = _newAtomNode( NULL);  }
 ;
	
column_constraint:
    opt_constraint_name column_constraint_type  /*opt_constraint_attributes*/

   	{ dlist *l = dlist_create();
 	  dlist_append_string(l, $1 );
	  dlist_append_symbol(l, $2 );
	  $$ = _symbol_create_list( SQL_CONSTRAINT, l ); }
 ;

table_constraint:
    opt_constraint_name table_constraint_type  /*opt_constraint_attributes*/

   	{ dlist *l = dlist_create();
	  dlist_append_string(l, $1 );
	  dlist_append_symbol(l, $2 );
	  $$ = _symbol_create_list( SQL_CONSTRAINT, l ); }
 ;

/* opt_constraint_attributes: ; */

opt_constraint_name:
    /* empty */	 		{ $$ = NULL; }
 |  CONSTRAINT ident 		{ $$ = $2; }
 ;

ref_action:
	NO ACTION		{ $$ = 0; }
 | 	CASCADE			{ $$ = 1; }
 | 	RESTRICT		{ $$ = 2; }
 | 	SET NULLX		{ $$ = 3; }
 | 	SET DEFAULT		{ $$ = 4; }
 ;

ref_on:
   ON UPDATE ref_action		{ $$ = _symbol_create_int(SQL_UPDATE, $3); }
 | ON sqlDELETE ref_action	{ $$ = _symbol_create_int(SQL_DELETE, $3); }
 ;

opt_ref_action:
	/* empty */	{ $$ = NULL; }
 | ref_on		{ $$ = dlist_append_symbol(dlist_create(), $1); }
 | ref_on ref_on	{ $$ = dlist_append_symbol(dlist_create(), $1);
 			  dlist_append_symbol($$, $2); 			}
 ;

opt_match_type:
    /* empty */			{ $$ = 0; }
 | FULL				{ $$ = 1; }
 | PARTIAL			{ $$ = 2; }
 | SIMPLE			{ $$ = 0; }
 ;

opt_match:
    /* empty */			{ $$ = 0; }
 | MATCH opt_match_type	 	{ $$ = $2; }
 ;

column_constraint_type:
    NOT NULLX	{ $$ = _symbol_create( SQL_NOT_NULL, NULL); }
 |  NULLX	{ $$ = _symbol_create( SQL_NULL, NULL); }
 |  UNIQUE	{ $$ = _symbol_create( SQL_UNIQUE, NULL ); }
 |  PRIMARY KEY	{ $$ = _symbol_create( SQL_PRIMARY_KEY, NULL ); }
 |  REFERENCES qname '(' column_ref ')' opt_match opt_ref_action

			{ dlist *l = dlist_create();
			  dlist_append_list(l, $2 );
			  dlist_append_list(l, $4 );
			  dlist_append_int(l, $6 );
			  dlist_append_list(l, $7 );
			  $$ = _symbol_create_list( SQL_FOREIGN_KEY, l); }
 | domain_constraint_type
 ;

table_constraint_type:
    UNIQUE column_commalist_parens  
			{ $$ = _symbol_create_list( SQL_UNIQUE, $2); }
 |  PRIMARY KEY column_commalist_parens 
			{ $$ = _symbol_create_list( SQL_PRIMARY_KEY, $3); }
 |  FOREIGN KEY column_commalist_parens 
    REFERENCES qname opt_column_commalist opt_match opt_ref_action

			{ dlist *l = dlist_create();
			  dlist_append_list(l, $5 );
			  dlist_append_list(l, $3 );
			  dlist_append_list(l, $6 );
			  dlist_append_int(l, $7 );
			  dlist_append_list(l, $8 );
			  $$ = _symbol_create_list( SQL_FOREIGN_KEY, l); }

 |  domain_constraint_type
 ;
		
domain_constraint_type:
    CHECK '(' search_condition ')' { $$ = _symbol_create_symbol(SQL_CHECK, $3); }
 ;
		
column_commalist:
    column		     
			{ $$ = dlist_append_string(dlist_create(), $1); }
 |  column_commalist ',' column  
			{ $$ = dlist_append_string( $1, $3 ); }
 ;

like_table:
	LIKE qname 	{ $$ = _symbol_create_list(SQL_LIKE, $2 ); }
 ;

view_def:
    CREATE VIEW qname opt_column_commalist
    AS			{ mvc *m = (mvc*)parm;
			  m->scanner.as = m->scanner.yycur; }
    view_as opt_with_check_option
	{ dlist *l = dlist_create();
	  dlist_append_list(l, $3);
	  dlist_append_list(l, $4);
	  dlist_append_symbol(l, $7);
	  dlist_append_int(l, $8);
	  $$ = _symbol_create_list( SQL_CREATE_VIEW, l ); }
  ;

view_as:
	select_stmt 		
  | 	BATS			{ $$ = NULL; }
  ;
	
opt_with_check_option:
    /* empty */ 		{ $$ = FALSE; }
 |  WITH CHECK OPTION		{ $$ = TRUE; }
 ;

opt_column_commalist:
    /* empty */			{ $$ = NULL; }
 | column_commalist_parens
 ;

column_commalist_parens:
   '(' column_commalist ')' 	{ $$ = $2; } 
 ;

module_def:
    CREATE MODULE qname { $$ = _symbol_create_list( SQL_CREATE_MODULE, $3 ); }
 ;

/*
module_end:
    END ident		
*/

type_def:
    CREATE TYPE qname
    EXTERNAL sqlNAME ident
			{ dlist *f = dlist_create();
	  		  	dlist_append_list(f, $3);
				dlist_append_string(f, $6);
 			  $$ = _symbol_create_list( SQL_CREATE_TYPE, f ); }
 ;

func_def:
    CREATE FUNCTION qname 
	'(' opt_paramlist ')'
    RETURNS data_type
    EXTERNAL sqlNAME ident
			{ dlist *f = dlist_create();
	  		  	dlist_append_list(f, $3);
	  			dlist_append_list(f, $5);
	  			dlist_append_type(f, $8);
				dlist_append_string(f, $11);
				dlist_append_symbol(f, NULL);
 			  $$ = _symbol_create_list( SQL_CREATE_FUNC, f ); }
 |
    CREATE FUNCTION qname 
	'(' opt_paramlist ')'
    RETURNS func_data_type
    AS			{ mvc *m = (mvc*)parm;
			  m->scanner.as = m->scanner.yycur; }
    select_stmt
			{ dlist *f = dlist_create();
	  		  	dlist_append_list(f, $3);
	  			dlist_append_list(f, $5);
	  			dlist_append_type(f, $8);
				dlist_append_string(f, NULL);
				dlist_append_symbol(f, $11);
 			  $$ = _symbol_create_list( SQL_CREATE_FUNC, f ); }
 | /* proc ie no result */
    CREATE PROCEDURE qname 
	'(' opt_paramlist ')'
    AS			{ mvc *m = (mvc*)parm;
			  m->scanner.as = m->scanner.yycur; }
    select_stmt 	/* todo stmt set BEGIN/END */
			{ dlist *f = dlist_create();
	  		  	dlist_append_list(f, $3);
	  			dlist_append_list(f, $5);
	  			dlist_append_type(f, NULL);   /* no result */
				dlist_append_string(f, NULL); /* no mil-impl */
				dlist_append_symbol(f, $9);
 			  $$ = _symbol_create_list( SQL_CREATE_FUNC, f ); }
 ;

func_data_type:
    TABLE		{ $$ = sql_bind_subtype("TABLE", 0, 0); }
 |  data_type
 ;

opt_paramlist:
    paramlist		
 |			{ $$ = NULL; }  
 ;

paramlist:
    paramlist ',' ident data_type	
			{ dlist *p = dlist_create();
	  		  dlist_append_string(p, $3);
	  		  dlist_append_type(p, $4);
			  $$ = dlist_append_list($1, p); }
 |  ident data_type
			{ dlist *l = dlist_create();
			  dlist *p = dlist_create();
	  		  dlist_append_string(p, $1);
	  		  dlist_append_type(p, $2);
			  $$ = dlist_append_list(l, p); }
 ;

drop:
    DROP TABLE qname drop_action
	
	{ dlist *l = dlist_create();
	  dlist_append_list(l, $3 );
	  dlist_append_int(l, $4 );
	  $$ = _symbol_create_list( SQL_DROP_TABLE, l ); }

 |  DROP VIEW qname	  { $$ = _symbol_create_list( SQL_DROP_VIEW, $3 ); }
 |  DROP ROLE qname	  { $$ = _symbol_create_list( SQL_DROP_ROLE, $3 ); }
 |  DROP USER ident	  { $$ = _symbol_create( SQL_DROP_USER, $3 ); }
 |  DROP INDEX qname	  { $$ = _symbol_create_list( SQL_DROP_INDEX, $3 ); }
 |  DROP MODULE qname	  { $$ = _symbol_create_list( SQL_DROP_MODULE, $3 ); }
 ;

drop_action:
    /* empty */ 	{ $$ = 0; }
 |  RESTRICT  		{ $$ = 0; }
 |  CASCADE	  	{ $$ = 1; }
 ;

	/* data manipulative stmts */

sql: 
   transaction_stmt  
 | delete_stmt 	
 | insert_stmt 
 | update_stmt 
 | copyfrom_stmt
 ;

transaction_stmt:
   _transaction_stmt 
	{ mvc *m = (mvc*)parm;
	  $$ = $1;
	  m->type = Q_TRANS; 					}
 ;

_transaction_stmt:
    COMMIT opt_work opt_chain 	
		{ $$ = _symbol_create_int( TR_COMMIT, $3);  }
 |  SAVEPOINT ident 		
		{ $$ = _symbol_create( TR_SAVEPOINT, $2); }
 |  RELEASE SAVEPOINT ident 	
		{ $$ = _symbol_create( TR_RELEASE, $3); }
 |  ROLLBACK opt_work opt_chain opt_to_savepoint
		{ $$ = _symbol_create_list( TR_ROLLBACK, 
		   dlist_append_string(
		   	dlist_append_int(dlist_create(), $3), $4 )); }
 |  START TRANSACTION transaction_mode_list
		{ $$ = _symbol_create_int( TR_START, $3); }
 |  SET local TRANSACTION transaction_mode_list
		{ $$ = _symbol_create_int( TR_MODE, $4); }
 ;

local:
  /* empty */
 | 	LOCAL
 ;

transaction_mode_list:
	/* empty */		{ $$ = tr_none; }
 | 	_transaction_mode_list
 ;

_transaction_mode_list:
   	transaction_mode
    		{ $$ = $1; }
 | 	_transaction_mode_list ',' transaction_mode
		{ $$ = ($1 | $3); } 
 ;


transaction_mode:
	READ ONLY			{ $$ = tr_readonly; }
 |	READ WRITE			{ $$ = tr_writable; }
 | 	ISOLATION LEVEL iso_level	{ $$ = tr_serializable; }
 | 	DIAGNOSTICS sqlSIZE intval	{ $$ = tr_none; /* not supported */ }
 ;

iso_level:
	READ UNCOMMITTED	
 | 	READ COMMITTED	
 | 	REPEATABLE READ	
 | 	SERIALIZABLE	
 ;

opt_work: /* pure syntax sugar */
    WORK		{ $$ = 0; }
 |  /* empty */		{ $$ = 0; }
 ;

opt_chain:
    AND CHAIN		{ $$ = 1; }
 |  AND NO CHAIN	{ $$ = 0; }
 |  /* empty */		{ $$ = 0; }
 ;

opt_to_savepoint:
    /* empty */ 	{ $$ = NULL; }
 |  TO SAVEPOINT ident  { $$ = $3; }
 ;

copyfrom_stmt:
    COPY opt_nr INTO qname FROM string_commalist opt_seps 
	{ dlist *l = dlist_create();
	  dlist_append_list(l, $4);
	  dlist_append_list(l, $6);
	  dlist_append_list(l, $7);
	  dlist_append_int(l, $2);
	  $$ = _symbol_create_list( SQL_COPYFROM, l ); }
  | COPY opt_nr INTO qname FROM STDIN opt_seps 
	{ dlist *l = dlist_create();
	  dlist_append_list(l, $4);
	  dlist_append_list(l, NULL);
	  dlist_append_list(l, $7);
	  dlist_append_int(l, $2);
	  $$ = _symbol_create_list( SQL_COPYFROM, l ); }
  ;

opt_seps:
    /* empty */		
				{ dlist *l = dlist_create(); 
				  dlist_append_string(l, _strdup("|")); 
				  dlist_append_string(l, _strdup("\\n")); 
				  $$ = l; }
 |  opt_using DELIMITERS string 
				{ dlist *l = dlist_create(); 
				  dlist_append_string(l, $3); 
				  dlist_append_string(l, _strdup("\\n")); 
				  $$ = l; }
 |  opt_using DELIMITERS string ',' string 
				{ dlist *l = dlist_create(); 
				  dlist_append_string(l, $3); 
				  dlist_append_string(l, $5);
				  $$ = l; }
 ;

opt_using:
    /* empty */			{ $$ = NULL; }
 |  USING			{ $$ = NULL; }
 ;

opt_nr:
    /* empty */			{ $$ = -1; }
 |  intval RECORDS		{ $$ = $1; }
 ;

string_commalist:
    string		{ $$ = dlist_append_string(dlist_create(), $1); }
 |  string_commalist ',' string  	
			{ $$ = dlist_append_string($1, $3); } 
 ;

delete_stmt:
    sqlDELETE FROM qname opt_where_clause 

	{ dlist *l = dlist_create();
	  dlist_append_list(l, $3);
	  dlist_append_symbol(l, $4);
	  $$ = _symbol_create_list( SQL_DELETE, l ); }
 ;

update_stmt:
    UPDATE qname SET assignment_commalist opt_where_clause

	{ dlist *l = dlist_create();
	  dlist_append_list(l, $2);
	  dlist_append_list(l, $4);
	  dlist_append_symbol(l, $5);
	  $$ = _symbol_create_list( SQL_UPDATE, l ); }
 ;


insert_stmt:
    INSERT INTO qname values_or_query_spec

	{ dlist *l = dlist_create();
	  dlist_append_list(l, $3);
	  dlist_append_list(l, NULL);
	  dlist_append_symbol(l, $4);
	  $$ = _symbol_create_list( SQL_INSERT, l ); }

 |  INSERT INTO qname column_commalist_parens values_or_query_spec

	{ dlist *l = dlist_create();
	  dlist_append_list(l, $3);
	  dlist_append_list(l, $4);
	  dlist_append_symbol(l, $5);
	  $$ = _symbol_create_list( SQL_INSERT, l ); }
 ;

values_or_query_spec:
    VALUES row_commalist
		{ $$ = _symbol_create_list( SQL_VALUES, $2); }
 |  select_stmt
 ;


row_commalist:
    '(' atom_commalist ')'	{ $$ = dlist_append_list(dlist_create(), $2); }
 |  row_commalist ',' '(' atom_commalist ')'
				{ $$ = dlist_append_list($1, $4); }
 ;

atom_commalist:
    insert_atom		{ $$ = dlist_append_symbol(dlist_create(), $1); }
 |  atom_commalist ',' insert_atom  
			{ $$ = dlist_append_symbol($1, $3); }
 ;

insert_atom:
    scalar_exp	
 |  NULLX		
	{ /* replace by argument */
	  mvc *m = (mvc*)parm;
	  int len = (m->args)?list_length(m->args):0;
	  if (len < MAXPARAMS-2 && m->cache){
		atom *a = atom_general( sql_dup_subtype(
				sql_bind_localtype("str")), NULL);

	  	sql_add_arg( m, a);
 	  	$$ = _symbol_create_list( SQL_COLUMN, 
			dlist_append_int(dlist_create(), len)); 
	   } else {
 		$$ = _symbol_create(SQL_NULL, NULL ); 
	   } 
	}
 ;

opt_distinct:
    /* empty */ 	{ $$ = FALSE; }	
 |  ALL			{ $$ = FALSE; }
 |  DISTINCT		{ $$ = TRUE; }
 ;

assignment_commalist:
    assignment		{ $$ = dlist_append_symbol(dlist_create(), $1 ); }
 |  assignment_commalist ',' assignment  
			{ $$ = dlist_append_symbol($1, $3 ); }
 ;

assignment:
    column '=' scalar_exp 	

	{ dlist *l = dlist_create();
	  dlist_append_string(l, $1); 
	  dlist_append_symbol(l, $3); 
	  $$ = _symbol_create_list( SQL_ASSIGN, l); }

 |  column '=' NULLX

	{ dlist *l = dlist_create();
	  dlist_append_string(l, $1); 
	  dlist_append_symbol(l, NULL ); 
	  $$ = _symbol_create_list( SQL_ASSIGN, l); }
 ;

target_commalist:
    target		{ $$ = dlist_append_symbol(dlist_create(), $1); }
 |  target_commalist ',' target  
			{ $$ = dlist_append_symbol($1, $3); }
 ;

target:
   TABLE qname  	{ $$ = _symbol_create_list( SQL_TABLE, $2); }
 ;

opt_where_clause:
    /* empty */ 		{ $$ = NULL; }
 |  WHERE search_condition	{ $$ = $2; }
 ;

	/* query expressions */

joined_table:
   '(' joined_table ')' 	
	{ $$ = $2; }
 |  table_ref CROSS JOIN table_ref

	{ dlist *l = dlist_create();
	  dlist_append_symbol(l, $1);
	  dlist_append_symbol(l, $4);
	  $$ = _symbol_create_list( SQL_CROSS, l); }
 |  table_ref UNIONJOIN table_ref join_spec 
	{ dlist *l = dlist_create();
	  dlist_append_symbol(l, $1);
	  dlist_append_int(l, 0);
	  dlist_append_int(l, 4);
	  dlist_append_symbol(l, $3);
	  dlist_append_symbol(l, $4);
	  $$ = _symbol_create_list( SQL_UNIONJOIN, l); }
 |  table_ref JOIN table_ref join_spec 
	{ dlist *l = dlist_create();
	  dlist_append_symbol(l, $1);
	  dlist_append_int(l, 0);
	  dlist_append_int(l, 0);
	  dlist_append_symbol(l, $3);
	  dlist_append_symbol(l, $4);
	  $$ = _symbol_create_list( SQL_JOIN, l); }
 |  table_ref NATURAL JOIN table_ref 
	{ dlist *l = dlist_create();
	  dlist_append_symbol(l, $1);
	  dlist_append_int(l, 1);
	  dlist_append_int(l, 0);
	  dlist_append_symbol(l, $4);
	  dlist_append_symbol(l, NULL);
	  $$ = _symbol_create_list( SQL_JOIN, l); }
 |  table_ref join_type JOIN table_ref join_spec 
	{ dlist *l = dlist_create();
	  dlist_append_symbol(l, $1);
	  dlist_append_int(l, 0);
	  dlist_append_int(l, $2);
	  dlist_append_symbol(l, $4);
	  dlist_append_symbol(l, $5);
	  $$ = _symbol_create_list( SQL_JOIN, l); }
 |  table_ref NATURAL join_type JOIN table_ref 
	{ dlist *l = dlist_create();
	  dlist_append_symbol(l, $1);
	  dlist_append_int(l, 1);
	  dlist_append_int(l, $3);
	  dlist_append_symbol(l, $5);
	  dlist_append_symbol(l, NULL);
	  $$ = _symbol_create_list( SQL_JOIN, l); }
  ;

join_type:
    INNER			{ $$ = 0; }
  | outer_join_type OUTER 	{ $$ = 1 + $1; }
  | outer_join_type 		{ $$ = 1 + $1; }
  ;

outer_join_type:
    LEFT		{ $$ = 0; }
  | RIGHT		{ $$ = 1; }
  | FULL		{ $$ = 2; }
  ;

join_spec:
    ON search_condition 		{ $$ = $2; }
  | USING column_commalist_parens  	
		{ $$ = _symbol_create_list( SQL_USING, $2); }
  ;

sql: 
    select_stmt
 ;

select_stmt:
    simple_select 			%prec UMINUS
	opt_order_by_clause opt_limit
	{
	  if ($1->token == SQL_SELECT) {
          	SelectNode *sn = (SelectNode*)$1;
	  	sn->orderby = $2;
	  	sn->limit = $3;
	  	$$ = $1;
	   } else {
                $$ = NULL;
		yyerror("order by and limit are not allowed with a select statement");
		YYABORT;
	   }
 	}
 |  set_select                    	%prec UMINUS
 |  select_with_parens                  %prec UMINUS
 ;

select_with_parens:
    '(' select_no_parens ')' 	{ $$ = $2; }
 |  '(' select_with_parens ')'  { $$ = $2; }
 ;

simple_select:
    SELECT opt_distinct selection opt_into table_exp 
	{ $$ = newSelectNode( $2, $3, $4, 
	  	$5->h->data.sym,
	  	$5->h->next->data.sym,
	  	$5->h->next->next->data.sym,
	  	$5->h->next->next->next->data.sym,
	  	NULL, NULL, -1);
	  dlist_destroy_keep_data($5);
	}
    ;

select_no_parens:
    simple_select
 |  set_select
 ;

complex_select:
    select_no_parens
 |  select_with_parens
 ;

set_select:

    complex_select UNION 
	set_distinct opt_corresponding complex_select

	{ dlist *l = dlist_create();
	  dlist_append_symbol(l, $1);
	  dlist_append_int(l, $3);
	  dlist_append_list(l, $4);
	  dlist_append_symbol(l, $5);
	  $$ = _symbol_create_list( SQL_UNION, l); }

 |  complex_select EXCEPT set_distinct opt_corresponding complex_select

	{ dlist *l = dlist_create();
	  dlist_append_symbol(l, $1);
	  dlist_append_int(l, $3);
	  dlist_append_list(l, $4);
	  dlist_append_symbol(l, $5);
	  $$ = _symbol_create_list( SQL_EXCEPT, l); }

 |  complex_select INTERSECT set_distinct opt_corresponding complex_select

	{ dlist *l = dlist_create();
	  dlist_append_symbol(l, $1);
	  dlist_append_int(l, $3);
	  dlist_append_list(l, $4);
	  dlist_append_symbol(l, $5);
	  $$ = _symbol_create_list( SQL_INTERSECT, l); }
 ;

set_distinct:
    /* empty */ 	{ $$ = TRUE; }	
 |  ALL			{ $$ = FALSE; }
 |  DISTINCT		{ $$ = TRUE; }
 ;


opt_corresponding:
	/* empty */	{ $$ = NULL; }
 |  CORRESPONDING				
			{ $$ = dlist_create(); }
 |  CORRESPONDING BY '(' column_ref_commalist ')' 	
			{ $$ = $4; } 
 ;

opt_into:
   INTO target_commalist 	{ $$ = $2; }
 | /* empty */			{ $$ = NULL; }
 ;

selection:
    column_exp_commalist
 |  '*' 			{ $$ = NULL; }
 ;

table_exp:
    opt_from_clause opt_where_clause opt_group_by_clause opt_having_clause

	{ $$ = dlist_create();
	  dlist_append_symbol($$, $1);
	  dlist_append_symbol($$, $2);
	  dlist_append_symbol($$, $3);
	  dlist_append_symbol($$, $4); }
 ;

opt_from_clause: 
    /* empty */			 { $$ = NULL; }
 |  FROM table_ref_commalist 	 { $$ = _symbol_create_list( SQL_FROM, $2); }
 ;

table_ref_commalist:
    table_ref		{ $$ = dlist_append_symbol(dlist_create(), $1); }
 |  table_ref_commalist ',' table_ref  
			{ $$ = dlist_append_symbol($1, $3); }
 ;

simple_table:
   qname 			{ dlist *l = dlist_create();
		  		  dlist_append_list(l, $1);  
		  	  	  dlist_append_symbol(l, NULL);  
		  		  $$ = _symbol_create_list(SQL_NAME, l); }
 | qname table_name 		{ dlist *l = dlist_create();
		  		  dlist_append_list(l, $1);  
		  	  	  dlist_append_symbol(l, $2);  
		  		  $$ = _symbol_create_list(SQL_NAME, l); }
 | func_ref table_name		{ dlist *l = dlist_create();
		  		  dlist_append_symbol(l, $1);  
		  	  	  dlist_append_symbol(l, $2);  
		  		  $$ = _symbol_create_list(SQL_TABLE, l); }
 ;

table_ref:
    simple_table
 |  select_with_parens table_name	
				{
				  $$ = $1; 
				  if ($$->token == SQL_SELECT) {
				  	SelectNode *sn = (SelectNode*)$1;
				  	sn->name = $2; 
				  } else {
				  	dlist_append_symbol($1->data.lval, $2); 
				  }
				}
 |  select_with_parens error	
				{ $$ = NULL;
				  symbol_destroy($1);
				  yyerror("Subquery table reference needs alias");
				  YYABORT;
				}
 |  joined_table 		{ $$ = $1; 
				  dlist_append_symbol($1->data.lval, NULL); }
 |  '(' joined_table ')' table_name	
				{ $$ = $2; 
				  dlist_append_symbol($2->data.lval, $4); }
 ;

table_name:	
    AS ident '(' name_commalist ')'
				{ dlist *l = dlist_create();
		  		  dlist_append_string(l, $2);  
		  	  	  dlist_append_list(l, $4);  
		  		  $$ = _symbol_create_list(SQL_NAME, l); }
 |  AS ident 
				{ dlist *l = dlist_create();
		  		  dlist_append_string(l, $2);  
		  	  	  dlist_append_list(l, NULL);  
		  		  $$ = _symbol_create_list(SQL_NAME, l); }
 |  ident '(' name_commalist ')'
				{ dlist *l = dlist_create();
		  		  dlist_append_string(l, $1);  
		  	  	  dlist_append_list(l, $3);  
		  		  $$ = _symbol_create_list(SQL_NAME, l); }
 |  ident 
				{ dlist *l = dlist_create();
		  		  dlist_append_string(l, $1);  
		  	  	  dlist_append_list(l, NULL);  
		  		  $$ = _symbol_create_list(SQL_NAME, l); }
 ;

opt_group_by_clause:
    /* empty */ 		  { $$ = NULL; }
 |  GROUP BY column_ref_commalist { $$ = _symbol_create_list( SQL_GROUPBY, $3 );}
 ;

column_ref_commalist:
    column_ref		{ $$ = dlist_append_symbol(dlist_create(), 
			       _symbol_create_list(SQL_COLUMN,$1)); }
 |  column_ref_commalist ',' column_ref  
			{ $$ = dlist_append_symbol( $1, 
			       _symbol_create_list(SQL_COLUMN,$3)); }
 ;

opt_having_clause:
    /* empty */ 		 { $$ = NULL; }
 |  HAVING search_condition	 { $$ = $2; }
 ;


search_condition:
    search_condition OR search_condition  	
		{ dlist *l = dlist_create();
		  dlist_append_symbol(l, $1); 
		  dlist_append_symbol(l, $3); 
		  $$ = _symbol_create_list(SQL_OR, l ); }
 |  search_condition AND search_condition
		{ dlist *l = dlist_create();
		  dlist_append_symbol(l, $1); 
		  dlist_append_symbol(l, $3); 
		  $$ = _symbol_create_list(SQL_AND, l ); }
 |  '(' search_condition ')'	{ $$ = $2; }
 | predicate			
/* search conditions 
 |  NOT search_condition    	{ $$ = _symbol_create_symbol(SQL_NOT, $2); }
*/
 ;

opt_order_by_clause:
    /* empty */ 			  { $$ = NULL; }
 |  ORDER BY ordering_spec_commalist  
		{ $$ = _symbol_create_list( SQL_ORDERBY, $3); }
 ;

opt_limit:
    /* empty */ 			{ $$ = -1; }
 |  LIMIT nonzero 			{ $$ = $2; }
 ;

ordering_spec_commalist:
    ordering_spec	 { $$ = dlist_append_symbol(dlist_create(), $1); }
 |  ordering_spec_commalist ',' ordering_spec 
			 { $$ = dlist_append_symbol( $1, $3 ); }
 ;

ordering_spec:
    column_ref opt_asc_desc 
	{ dlist *l = dlist_create();
	  dlist_append_symbol(l, _symbol_create_list(SQL_COLUMN, $1)); 
	  dlist_append_int(l, $2); 
	  $$ = _symbol_create_list(SQL_COLUMN, l ); }
					  
 ;

opt_asc_desc:
    /* empty */ 	{ $$ = TRUE; }
 |  ASC			{ $$ = TRUE; }
 |  DESC		{ $$ = FALSE; }
 ;

predicate: 
    comparison_predicate 
 |  between_predicate 
 |  like_predicate
 |  test_for_null 
 |  in_predicate  
 |  all_or_any_predicate 
 |  existence_test 
 |  BOOL_FALSE  
		{ sql_subtype *t = sql_bind_subtype("BOOLEAN", 0, 0 );
		  $$ = _newAtomNode( atom_general(t, _strdup("false"))); }
 |  BOOL_TRUE  
		{ sql_subtype *t = sql_bind_subtype("BOOLEAN", 0, 0 );
		  $$ = _newAtomNode( atom_general(t, _strdup("true"))); }
 ;

comparison_predicate:
    scalar_exp COMPARISON scalar_exp	 
		{ dlist *l = dlist_create();
		  dlist_append_symbol(l, $1); 
		  dlist_append_string(l, $2); 
		  dlist_append_symbol(l, $3); 
		  $$ = _symbol_create_list(SQL_COMPARE, l ); }
 |  scalar_exp '=' scalar_exp
		{ dlist *l = dlist_create();
		  dlist_append_symbol(l, $1); 
		  dlist_append_string(l, _strdup("=")); 
		  dlist_append_symbol(l, $3); 
		  $$ = _symbol_create_list(SQL_COMPARE, l ); }
 ;

between_predicate:
    scalar_exp NOT BETWEEN opt_bounds scalar_exp AND scalar_exp
		{ dlist *l = dlist_create();
		  dlist_append_symbol(l, $1); 
		  dlist_append_int(l, $4); 
		  dlist_append_symbol(l, $5); 
		  dlist_append_symbol(l, $7); 
		  $$ = _symbol_create_list(SQL_NOT_BETWEEN, l ); }
 |  scalar_exp BETWEEN opt_bounds scalar_exp AND scalar_exp
		{ dlist *l = dlist_create();
		  dlist_append_symbol(l, $1); 
		  dlist_append_int(l, $3); 
		  dlist_append_symbol(l, $4); 
		  dlist_append_symbol(l, $6); 
		  $$ = _symbol_create_list(SQL_BETWEEN, l ); }
 ;

opt_bounds:
   /* empty */ 	{ $$ = 0; }
 | ASYMMETRIC 	{ $$ = 0; }
 | SYMMETRIC 	{ $$ = 1; }
 ;

like_predicate:
    scalar_exp NOT LIKE atom_exp
		{ dlist *l = dlist_create();
		  dlist_append_symbol(l, $1); 
		  dlist_append_symbol(l, $4); 
		  $$ = _symbol_create_list(SQL_NOT_LIKE, l ); }
 |  scalar_exp LIKE atom_exp
		{ dlist *l = dlist_create();
		  dlist_append_symbol(l, $1); 
		  dlist_append_symbol(l, $3); 
		  $$ = _symbol_create_list(SQL_LIKE, l ); }
 ;


atom_exp:
    atom 	{ dlist *l = dlist_create();
		  dlist_append_symbol(l, $1); 
		  $$ = _symbol_create_list(SQL_ESCAPE, l ); }
 |  atom ESCAPE atom 	 
		{ dlist *l = dlist_create();
		  dlist_append_symbol(l, $1); 
		  dlist_append_symbol(l, $3); 
		  $$ = _symbol_create_list(SQL_ESCAPE, l ); }
 ;

test_for_null:
    column_ref IS NOT NULLX  { symbol *s =_symbol_create_list(SQL_COLUMN, $1);
			      $$ = _symbol_create_symbol( SQL_NOT_NULL, s ); }
 |  column_ref IS NULLX	     { symbol *s =_symbol_create_list(SQL_COLUMN, $1);
			       $$ = _symbol_create_symbol( SQL_NULL, s ); }
 ;

in_predicate:
    scalar_exp NOT sqlIN subquery
		{ dlist *l = dlist_create();
		  dlist_append_symbol(l, $1); 
		  dlist_append_symbol(l, $4); 
		  $$ = _symbol_create_list(SQL_NOT_IN, l ); }
 |  scalar_exp sqlIN subquery 
		{ dlist *l = dlist_create();
		  dlist_append_symbol(l, $1); 
		  dlist_append_symbol(l, $3); 
		  $$ = _symbol_create_list(SQL_IN, l ); }
 |  scalar_exp NOT sqlIN '(' atom_commalist ')'
		{ dlist *l = dlist_create();
		  dlist_append_symbol(l, $1); 
		  dlist_append_list(l, $5); 
		  $$ = _symbol_create_list(SQL_NOT_IN, l ); }
 |  scalar_exp sqlIN '(' atom_commalist ')'
		{ dlist *l = dlist_create();
		  dlist_append_symbol(l, $1); 
		  dlist_append_list(l, $4); 
		  $$ = _symbol_create_list(SQL_IN, l ); }
 ;

all_or_any_predicate:
    scalar_exp COMPARISON any_all_some subquery

		{ dlist *l = dlist_create();
		  dlist_append_symbol(l, $1); 
		  dlist_append_string(l, $2); 
		  dlist_append_string(l, $3); 
		  dlist_append_symbol(l, $4); 
		  $$ = _symbol_create_list(SQL_COMPARE, l ); }
 ;
			
any_all_some:
    ANY		{ $$ = $1; }
 |  ALL		{ $$ = $1; }
 |  SOME	{ $$ = $1; }
 ;

existence_test:
    EXISTS subquery 	{ $$ = _symbol_create_symbol( SQL_EXISTS, $2 ); }
 |  NOT EXISTS subquery { $$ = _symbol_create_symbol( SQL_NOT_EXISTS, $3 ); }
 ;

subquery:
    '(' SELECT opt_distinct  selection table_exp ')' 

	{ $$ = newSelectNode( $3, $4, NULL, 
	  	$5->h->data.sym,
	  	$5->h->next->data.sym,
	  	$5->h->next->next->data.sym,
	  	$5->h->next->next->next->data.sym,
	  	NULL, NULL, -1);
	  dlist_destroy_keep_data($5);
	}
 ;

	/* scalar expressions */

scalar_exp:
    value_exp

 |  scalar_exp '+' scalar_exp	
				{ dlist *l = dlist_create();
				  dlist_append_string(l, _strdup("sql_add"));
	  			  dlist_append_symbol(l, $1);
	  			  dlist_append_symbol(l, $3);
	  			  $$ = _symbol_create_list( SQL_BINOP, l ); }
 |  scalar_exp '-' scalar_exp   
				{ dlist *l = dlist_create();
				  dlist_append_string(l, _strdup("sql_sub"));
	  			  dlist_append_symbol(l, $1);
	  			  dlist_append_symbol(l, $3);
	  			  $$ = _symbol_create_list( SQL_BINOP, l ); }
 |  scalar_exp '*' scalar_exp
				{ dlist *l = dlist_create();
				  dlist_append_string(l, _strdup("sql_mul"));
	  			  dlist_append_symbol(l, $1);
	  			  dlist_append_symbol(l, $3);
	  			  $$ = _symbol_create_list( SQL_BINOP, l ); }
 |  scalar_exp '/' scalar_exp
				{ dlist *l = dlist_create();
				  dlist_append_string(l, _strdup("sql_div"));
	  			  dlist_append_symbol(l, $1);
	  			  dlist_append_symbol(l, $3);
	  			  $$ = _symbol_create_list( SQL_BINOP, l ); }
 |  scalar_exp '%' scalar_exp
				{ dlist *l = dlist_create();
				  dlist_append_string(l, _strdup("mod"));
	  			  dlist_append_symbol(l, $1);
	  			  dlist_append_symbol(l, $3);
	  			  $$ = _symbol_create_list( SQL_BINOP, l ); }
 |  '+' scalar_exp %prec UMINUS { $$ = $2; }
 |  '-' scalar_exp %prec UMINUS { dlist *l = dlist_create();
				  dlist_append_string(l, _strdup("sql_neg"));
	  			  dlist_append_symbol(l, $2);
	  			  $$ = _symbol_create_list( SQL_UNOP, l ); }
 |  '(' scalar_exp ')' 		{ $$ = $2; }
 |  subquery			%prec UMINUS
 |  predicate			
 ;

value_exp:
    atom
 |  column_ref 			{ $$ = _symbol_create_list( SQL_COLUMN, $1); }
 |  aggr_ref 
 |  func_ref 
 |  datetime_funcs
 |  string_funcs
 |  case_exp	
 |  cast_exp
 |  '?'				{ $$ = _symbol_create( SQL_PARAMETER, NULL ); }
 ;

func_ref:
    func_ident '(' scalar_exp ')'
	{ dlist *l = dlist_create();
  	  dlist_append_string(l, $1);
  	  dlist_append_symbol(l, $3);
	  $$ = _symbol_create_list( SQL_UNOP, l ); }
|   func_ident '(' scalar_exp ',' scalar_exp ')'
	{ dlist *l = dlist_create();
  	  dlist_append_string(l, $1);
  	  dlist_append_symbol(l, $3);
  	  dlist_append_symbol(l, $5);
	  $$ = _symbol_create_list( SQL_BINOP, l ); }
|   func_ident '(' scalar_exp_list2 ')'
	{ dlist *l = dlist_create();
  	  dlist_append_string(l, $1);
  	  dlist_append_list(l, $3);
	  $$ = _symbol_create_list( SQL_NOP, l ); }
 ;

func_ident:
	IDENT 	{ $$ = $1; }
 |	LEFT	{ $$ = _strdup("left"); }
 |	RIGHT	{ $$ = _strdup("right"); }
 |	INSERT	{ $$ = _strdup("insert"); }
 ;

datetime_funcs:
    EXTRACT '(' datetime_field FROM scalar_exp ')' 
				{ dlist *l = dlist_create();
				  const char *ident = datetime_field((itype)$3);
  		  		  dlist_append_string(l, _strdup(ident));
  		  		  dlist_append_symbol(l, $5);
		  		  $$ = _symbol_create_list( SQL_UNOP, l ); }
 |  CURRENT_DATE opt_brackets 
 			{ dlist *l = dlist_create();
			  dlist_append_string(l, _strdup("current_date"));
	  		  $$ = _symbol_create_list( SQL_OP, l ); }
 |  CURRENT_TIME opt_brackets
 			{ dlist *l = dlist_create();
			  dlist_append_string(l, _strdup("current_time"));
	  		  $$ = _symbol_create_list( SQL_OP, l ); }
 |  CURRENT_TIMESTAMP opt_brackets
 			{ dlist *l = dlist_create();
			  dlist_append_string(l, _strdup("current_timestamp"));
	  		  $$ = _symbol_create_list( SQL_OP, l ); }
 ;

opt_brackets:
   /* empty */	{ $$ = 0; }
 | '(' ')'	{ $$ = 1; }
 ;

string_funcs:
    SUBSTRING '(' scalar_exp FROM scalar_exp FOR scalar_exp ')' 
				{ dlist *l = dlist_create();
				  dlist *ops = dlist_create();
  		  		  dlist_append_string(l, _strdup("substring"));
  		  		  dlist_append_symbol(ops, $3);
  		  		  dlist_append_symbol(ops, $5);
  		  		  dlist_append_symbol(ops, $7);
				  dlist_append_list(l, ops);
		  		  $$ = _symbol_create_list( SQL_NOP, l ); }
  | SUBSTRING '(' scalar_exp ',' scalar_exp ',' scalar_exp ')' 
				{ dlist *l = dlist_create();
				  dlist *ops = dlist_create();
  		  		  dlist_append_string(l, _strdup("substring"));
  		  		  dlist_append_symbol(ops, $3);
  		  		  dlist_append_symbol(ops, $5);
  		  		  dlist_append_symbol(ops, $7);
				  dlist_append_list(l, ops);
		  		  $$ = _symbol_create_list( SQL_NOP, l ); }
  | SUBSTRING '(' scalar_exp FROM scalar_exp ')' 
				{ dlist *l = dlist_create();
  		  		  dlist_append_string(l, _strdup("substring"));
  		  		  dlist_append_symbol(l, $3);
  		  		  dlist_append_symbol(l, $5);
		  		  $$ = _symbol_create_list( SQL_BINOP, l ); }
  | SUBSTRING '(' scalar_exp ',' scalar_exp ')' 
				{ dlist *l = dlist_create();
  		  		  dlist_append_string(l, _strdup("substring"));
  		  		  dlist_append_symbol(l, $3);
  		  		  dlist_append_symbol(l, $5);
		  		  $$ = _symbol_create_list( SQL_BINOP, l ); }
  | POSITION '(' scalar_exp sqlIN scalar_exp ')' 
				{ dlist *l = dlist_create();
  		  		  dlist_append_string(l, _strdup("locate"));
  		  		  dlist_append_symbol(l, $3);
  		  		  dlist_append_symbol(l, $5);
		  		  $$ = _symbol_create_list( SQL_BINOP, l ); }
  | scalar_exp CONCATSTRING scalar_exp  
				{ dlist *l = dlist_create();
  		  		  dlist_append_string(l, _strdup("concat"));
  		  		  dlist_append_symbol(l, $1);
  		  		  dlist_append_symbol(l, $3);
		  		  $$ = _symbol_create_list( SQL_BINOP, l ); }
 ;

column_exp_commalist:
    column_exp 		{ $$ = dlist_append_symbol(dlist_create(), $1 ); }
 |  column_exp_commalist ',' column_exp  
			{ $$ = dlist_append_symbol( $1, $3 ); }
 ;

column_exp:
    ident '.' '*'
		{ dlist *l = dlist_create();
  		  dlist_append_string(l, $1);
  		  dlist_append_string(l, NULL);
  		  $$ = _symbol_create_list( SQL_TABLE, l ); }
 |  scalar_exp opt_alias_name
		{ dlist *l = dlist_create();
  		  dlist_append_symbol(l, $1);
  		  dlist_append_string(l, $2);
  		  $$ = _symbol_create_list( SQL_COLUMN, l ); }
 |  NULLX opt_alias_name	
		{ dlist *l = dlist_create();
  		  dlist_append_symbol(l, _newAtomNode(NULL) );  
  		  dlist_append_string(l, $2);
  		  $$ = _symbol_create_list( SQL_COLUMN, l ); }
 ;

opt_alias_name:
    /* empty */	{ $$ = NULL; }
 |  AS ident	{ $$ = $2; }
 ;

atom:
    literal	
	{ /* replace by argument */
	  mvc *m = (mvc*)parm;
	  int len = (m->args)?list_length(m->args):0;
	  if (len < MAXPARAMS-2 && m->cache){
	  	AtomNode *an = (AtomNode*)$1;

	  	sql_add_arg( m, an->a);
		an->a = NULL;
		symbol_destroy($1);
	  	/* we miss use SQL_COLUMN also for param's, maybe 
	     		change SQL_COLUMN to SQL_IDENT */
 	  	$$ = _symbol_create_list( SQL_COLUMN, 
			dlist_append_int(dlist_create(), len)); 
	   } else {
		$$ = $1;
	   }
	}
 ;


/* change to set function */
aggr_ref:
    AGGR '(' '*' ')' 	
		{ dlist *l = dlist_create();
  		  dlist_append_string(l, $1);
  		  dlist_append_int(l, FALSE);
  		  dlist_append_symbol(l, NULL);
		  $$ = _symbol_create_list( SQL_AGGR, l ); }
 |  AGGR '(' ident '.' '*' ')' 
		{ dlist *l = dlist_create();
		  _DELETE($3);
  		  dlist_append_string(l, $1);
  		  dlist_append_int(l, FALSE);
  		  dlist_append_symbol(l, NULL);
		  $$ = _symbol_create_list( SQL_AGGR, l ); }
 |  AGGR '(' DISTINCT column_ref ')' 
		{ dlist *l = dlist_create();
  		  dlist_append_string(l, $1);
  		  dlist_append_int(l, TRUE);
  		  dlist_append_symbol(l, _symbol_create_list(SQL_COLUMN, $4));
		  $$ = _symbol_create_list( SQL_AGGR, l ); }
 |  AGGR '(' ALL scalar_exp ')'
		{ dlist *l = dlist_create();
  		  dlist_append_string(l, $1);
  		  dlist_append_int(l, FALSE);
  		  dlist_append_symbol(l, $4);
		  $$ = _symbol_create_list( SQL_AGGR, l ); }
 |  AGGR '(' scalar_exp ')' 
		{ dlist *l = dlist_create();
  		  dlist_append_string(l, $1);
  		  dlist_append_int(l, FALSE);
  		  dlist_append_symbol(l, $3);
		  $$ = _symbol_create_list( SQL_AGGR, l ); }
 ;

opt_sign:
   '+'		{ $$ = 1; }
 | '-' 		{ $$ = -1; }
 | /* empty */	{ $$ = 1; }
 ;

tz:
	WITH TIME ZONE	{ $$ = 1; }
 | /* empty */		{ $$ = 0; }
 ;

time_persision:
	'(' intval ')' 	{ $$ = $2; }
 | /* empty */		{ $$ = 0; }
 ;

datetime_type:
    sqlDATE			{ $$ = sql_bind_subtype("DATE", 0, 0); }
 |  TIME time_persision tz 	{ $$ = sql_bind_subtype("TIME", $2, $3); }
 |  TIMESTAMP time_persision tz { $$ = sql_bind_subtype("TIMESTAMP", $2, $3); }
 ;

non_second_datetime_field:
    YEAR		{ $$ = iyear; }
 |  MONTH		{ $$ = imonth; }
 |  DAY			{ $$ = iday; }
 |  HOUR		{ $$ = ihour; }
 |  MINUTE		{ $$ = imin; }
 ;

datetime_field:
    non_second_datetime_field
 |  SECOND		{ $$ = isec; }
 ;

start_field:
    non_second_datetime_field time_persision
		{ $$ = dlist_append_int( 
			 	dlist_append_int( dlist_create(), $1), $2);  }
 ;

end_field:
    non_second_datetime_field 	
		{ $$ = dlist_append_int( 
			 	dlist_append_int( dlist_create(), $1), 0);  }
 |  SECOND time_persision	
		{ $$ = dlist_append_int( 
			 	dlist_append_int( dlist_create(), isec), $2);  }
 ;

single_datetime_field:
    non_second_datetime_field time_persision 
		{ $$ = dlist_append_int( 
			 	dlist_append_int( dlist_create(), $1), $2);  }
 |  SECOND time_persision	
		{ $$ = dlist_append_int( 
			 	dlist_append_int( dlist_create(), isec), $2);  }
 ;

interval_qualifier:
    start_field TO end_field  
	{ $$ =  dlist_append_list(
			dlist_append_list( dlist_create(), $1), $3 ); }
 |  single_datetime_field    
	{ $$ =  dlist_append_list( dlist_create(), $1); }
 ;

interval_type:
    INTERVAL interval_qualifier	{ 
		int sk, ek;
		mvc *m = (mvc*)parm;
	  	int tpe;

		$$ = NULL;
	  	if ( (tpe = parse_interval_qualifier( m, $2, &sk, &ek )) < 0){
			yyerror("incorrect interval");
			YYABORT;
	  	} else {
			if (tpe == 0){
				$$ = sql_bind_subtype("MONTH_INTERVAL", 0, 0);
			} else {
				$$ = sql_bind_subtype("SEC_INTERVAL", 0, 0);
			}
	  	}
	}
 ;

user:
    USER     
 |  SESSION_USER     
 |  CURRENT_USER     
 ;

literal:
    string
		{ char *s = sql2str($1);
		  int len = strlen(s);
		  sql_subtype *t = sql_bind_subtype("CHAR", len, 0 ); 
		  $$ = _newAtomNode( atom_string(t, s)); }
 |  user 
		{ mvc *m = (mvc*)parm;
		  sql_subtype *t = sql_bind_subtype("CHAR", strlen(m->user),0);
		  $$ = _newAtomNode( atom_string(t,sql2str(_strdup(m->user))));
		}

 |  sqlINT   	{ int digits = strlen($1), err = 0, len = sizeof(lng);
		  lng value, *p = &value; 
		  sql_subtype *t = NULL;

		  if (digits <= 19)
		  	t = sql_bind_subtype("INT", digits, 0 );
		  else 
			err = 1;

		  if (err) {
			char buf[BUFSIZ]; 

			snprintf(buf, BUFSIZ, "incorrect integer value (%s)", $1);
			yyerror(buf);
			$$ = NULL;
			YYABORT;
		  } else {
		  	lngFromStr($1, &len, &p);
		  	$$ = _newAtomNode( atom_int(t, value)); 
		  }
		}
 |  INTNUM   
		{ char *s = strip_extra_zeros($1);
		  char *dot = strchr(s, '.');
		  int digits = strlen(s) - 1;
		  int scale = digits - (dot-s);
		  lng value = decimal_from_str(s);
		  sql_subtype *t = NULL;

		  if (*s == '+' || *s == '-')
			digits --;
		  t = sql_bind_subtype("DECIMAL", digits, scale );
		  $$ = _newAtomNode( atom_int(t, value)); }
 |  APPROXNUM
		{ sql_subtype *t = sql_bind_subtype("DOUBLE", 51, 0 );
		  double val = strtod($1,NULL);
		  $$ = _newAtomNode( atom_float(t, val)); }
 |  sqlDATE string 
		{ sql_subtype *t = sql_bind_subtype("DATE", 0, 0 );
		  atom *a = atom_general(t, $2); 
		  if (!a) {
			char buf[BUFSIZ]; 

			snprintf(buf, BUFSIZ, "incorrect date value (%s)", $2);
			yyerror(buf);
			$$ = NULL;
			YYABORT;
		  } else {
		  	$$ = _newAtomNode(a); 
		} }
 |  TIME tz string 
		{ sql_subtype *t = sql_bind_subtype("TIME", 0, $2 );
		  atom *a = atom_general(t, $3); 
		  if (!a) {
			char buf[BUFSIZ]; 

			snprintf(buf, BUFSIZ, "incorrect time value (%s)", $3);
			yyerror(buf);
			$$ = NULL;
			YYABORT;
		  } else {
		  	$$ = _newAtomNode(a); 
		} }
 |  TIMESTAMP tz string 
		{ sql_subtype *t = sql_bind_subtype("TIMESTAMP", 0, $2 );
		  atom *a = atom_general(t, $3); 
		  if (!a) {
			char buf[BUFSIZ]; 

			snprintf(buf, BUFSIZ, "incorrect timestamp value (%s)", $3);
			yyerror(buf);
			$$ = NULL;
			YYABORT;
		  } else {
		  	$$ = _newAtomNode(a); 
		} }
 |  interval_expression
 |  aTYPE string 
		{ sql_subtype *t = sql_bind_subtype($1, 0, 0);
		  atom *a = atom_general(t, $2);
		  $$ = NULL;
	          if (a) 
			$$ = _newAtomNode(a); 
		  if (!$$) {
			char buf[BUFSIZ]; 

			snprintf(buf, BUFSIZ, "incorrect %s %s", $1, $2);
			yyerror(buf);
			if (a) 
				atom_destroy(a);
	  	  	_DELETE($1); 
			YYABORT;
		  }
	  	  _DELETE($1); 
		}
 | type_alias string 
		{ sql_subtype *t = sql_bind_subtype($1, 0, 0);
		  atom *a = atom_general(t, $2);
		  $$ = NULL;
	          if (a) 
			$$ = _newAtomNode(a); 
		  if (!$$) {
			char buf[BUFSIZ]; 

			snprintf(buf, BUFSIZ, "incorrect %s %s", $1, $2);
			yyerror(buf);
			if (a) 
				atom_destroy(a);
			YYABORT;
		  }
		}
 | IDENT string 
		{ mvc *m = (mvc*)parm;
		  sql_type *t = mvc_bind_type(m, $1); 
		  atom *a;

		  $$ = NULL;
		  if (t) { 
			a = atom_general( sql_create_subtype(t, 0, 0), $2);
	          	if (a) 
				$$ = _newAtomNode(a); 
		  }
		  if (!t || !$$) {
			char buf[BUFSIZ]; 

			snprintf(buf, BUFSIZ, "Type (%s) unknown", $1);
			yyerror(buf);
			_DELETE($1); 
			YYABORT;
		  }
		  _DELETE($1); 
		}
 ;

interval_expression:
   INTERVAL opt_sign string interval_qualifier
		{ mvc *m = (mvc*)parm;
	  	  int i,tpe;
	  	  if ( (tpe = parse_interval( m, $2, $3, $4, &i)) < 0 ){
			yyerror("incorrect interval");
			$$ = NULL;
			YYABORT;
	  	  } else {
			sql_subtype *t = NULL; 
			if (tpe == 0){
				t = sql_bind_subtype("MONTH_INTERVAL", 0, 0);
			} else {
				t = sql_bind_subtype("SEC_INTERVAL", 0, 0);
			}
	  		$$ = _newAtomNode( atom_int(t,i));
	  	  }
		}

	/* miscellaneous */
 ;

qname:
    ident		{ $$ = dlist_append_string(dlist_create(), $1); }
 |  ident '.' ident	{ $$ = dlist_append_string(
				dlist_append_string(dlist_create(), $1), $3);}
 ;

column_ref:
    ident		{ $$ = dlist_append_string(
				dlist_create(), $1); }

 |  ident '.' ident	{ $$ = dlist_append_string(
				dlist_append_string(
				 dlist_create(), $1), $3);}

 |  ident '.' ident '.' ident
    			{ $$ = dlist_append_string(
				dlist_append_string(
				 dlist_append_string(
				  dlist_create(), $1), $3), $5);}
 ;

cast_exp:
     CAST '(' cast_value AS data_type ')'
 	{ dlist *l = dlist_create();
	  dlist_append_symbol(l, $3);
	  dlist_append_type(l, $5);
	  $$ = _symbol_create_list( SQL_CAST, l ); }
 |
     CONVERT '(' cast_value ',' data_type ')'
 	{ dlist *l = dlist_create();
	  dlist_append_symbol(l, $3);
	  dlist_append_type(l, $5);
	  $$ = _symbol_create_list( SQL_CAST, l ); }
 ;

cast_value:
	scalar_exp
 | 	NULLX	 { $$ = _newAtomNode(NULL); }
 ;

case_exp: 
     NULLIF '(' scalar_exp ',' scalar_exp ')' 
		{ $$ = _symbol_create_list(SQL_NULLIF,
		   dlist_append_symbol(
		    dlist_append_symbol(
		     dlist_create(), $3), $5)); }
 |   COALESCE '(' scalar_exp ',' scalar_exp ')'
		{ $$ = _symbol_create_list(SQL_COALESCE, 
		   dlist_append_symbol(
		    dlist_append_symbol(
		     dlist_create(), $3), $5)); }
 |   COALESCE '(' scalar_exp_list2 ')'
		{ $$ = _symbol_create_list(SQL_COALESCE, $3); }
 |   CASE scalar_exp when_value_list opt_else END
		{ $$ = _symbol_create_list(SQL_CASE, 
		   dlist_append_symbol(
		    dlist_append_list(
		     dlist_append_symbol(
		      dlist_create(),$2),$3),$4)); }
 |   CASE when_search_list opt_else END
		 { $$ = _symbol_create_list(SQL_CASE, 
		   dlist_append_symbol(
		    dlist_append_list(
		     dlist_create(),$2),$3)); }
 ;

scalar_exp_list2:
    scalar_exp ',' scalar_exp ',' scalar_exp
			{ $$ = dlist_append_symbol( dlist_create(), $1);
			  $$ = dlist_append_symbol( $$, $3); 
			  $$ = dlist_append_symbol( $$, $5);
			}
 |  scalar_exp_list2 ',' scalar_exp
			{ $$ = dlist_append_symbol( $1, $3); }
 ;

when_value:
    WHEN scalar_exp THEN scalar_exp
			{ $$ = _symbol_create_list( SQL_WHEN,
			   dlist_append_symbol(
			    dlist_append_symbol(
			     dlist_create(), $2),$4)); }
 ;

when_value_list:
    when_value
			{ $$ = dlist_append_symbol( dlist_create(), $1);}
 |  when_value_list when_value
			{ $$ = dlist_append_symbol( $1, $2); }
 ;

when_search:
    WHEN search_condition THEN scalar_exp
			{ $$ = _symbol_create_list( SQL_WHEN,
			   dlist_append_symbol(
			    dlist_append_symbol(
			     dlist_create(), $2),$4)); }
 ;

when_search_list:
    when_search
			{ $$ = dlist_append_symbol( dlist_create(), $1); }
 |  when_search_list when_search
			{ $$ = dlist_append_symbol( $1, $2); }
 ;

opt_else:
    /* empty */	        { $$ = NULL; }
 |  ELSE scalar_exp	{ $$ = $2; }
 ;

		/* data types, more types to come */

nonzero:
	intval 	{ $$ = $1;
		  if ($$ == 0) {
			$$ = -1;
			yyerror("Positive value expected");
			YYABORT;
		  }
		}
	;

data_type:
    CHARACTER opt_var	{ $$ = sql_bind_subtype("VARCHAR", 0, 0); }
 |  CHARACTER opt_var '(' nonzero ')'	
			{ if ($2)
				$$ = sql_bind_subtype("VARCHAR", $4, 0); 
			  else
				$$ = sql_bind_subtype("CHAR", $4, 0); 
			}
 |  TINYINT		{ $$ = sql_bind_subtype("INT", 2, 0); }
 |  SMALLINT		{ $$ = sql_bind_subtype("INT", 4, 0); }
 |  MEDIUMINT		{ $$ = sql_bind_subtype("INT", 9, 0); }
 |  BIGINT		{ $$ = sql_bind_subtype("INT", 19, 0); }
 |  sqlDECIMAL		{ $$ = sql_bind_subtype("DECIMAL", 0, 0); }
 |  sqlDECIMAL '(' nonzero ')'	
			{ $$ = sql_bind_subtype("DECIMAL", $3, 0); }
 |  sqlDECIMAL '(' intval ',' intval ')' 
			{ if ($5 >= $3) {
				char buf[BUFSIZ]; 

				snprintf(buf, BUFSIZ, "Presision(%d) should be less than number of digits(%d)", $5, $3);
				yyerror(buf);
				$$ = NULL;
				YYABORT;
			  } else {
				$$ = sql_bind_subtype("DECIMAL", $3, $5); 
			  }
			}
 |  sqlFLOAT		{ $$ = sql_bind_subtype("FLOAT", 0, 0); }
 |  sqlFLOAT '(' nonzero ')'	
			{ $$ = sql_bind_subtype("FLOAT", $3, 0); }
 |  sqlFLOAT '(' intval ',' intval ')'	
			{ if ($5 >= $3) {
				char buf[BUFSIZ]; 

				snprintf(buf, BUFSIZ, "Presision(%d) should be less than number of digits(%d)", $5, $3);
				yyerror(buf);
				$$ = NULL;
				YYABORT;
			  } else {
				$$ = sql_bind_subtype("FLOAT", $3, $5); 
			  }
			}
 |  sqlDOUBLE 		{ $$ = sql_bind_subtype("DOUBLE", 0, 0); }
 |  sqlDOUBLE '(' intval ',' intval ')' 	
			{ if ($5 >= $3) {
				char buf[BUFSIZ]; 

				snprintf(buf, BUFSIZ, "Presision(%d) should be less than number of digits(%d)", $5, $3);
				yyerror(buf);
				$$ = NULL;
				YYABORT;
			  } else {
				$$ = sql_bind_subtype("DOUBLE", $3, $5); 
			  }
			}
 | sqlDOUBLE PRECISION	{ $$ = sql_bind_subtype("DOUBLE", 0, 0); }
 | datetime_type
 | interval_type		
 | aTYPE		{ $$ = sql_bind_subtype($1, 0, 0); _DELETE($1); }
 | aTYPE '(' nonzero ')'{ $$ = sql_bind_subtype($1, $3, 0); _DELETE($1); }
 | type_alias opt_var	{ $$ = sql_bind_subtype($1, 0, 0); }
 | type_alias opt_var '(' nonzero ')'
			{ $$ = sql_bind_subtype($1, $4, 0); }
 | type_alias opt_var '(' intval ',' intval ')'
			{ if ($6 >= $4) {
				char buf[BUFSIZ]; 

				snprintf(buf, BUFSIZ, "Presision(%d) should be less than number of digits(%d)", $6, $4);
				yyerror(buf);
				$$ = NULL;
				YYABORT;
			  } else {
			 	$$ = sql_bind_subtype($1, $4, $6); 
			  }
			}
 | IDENT		{ mvc *m = (mvc*)parm;
			  sql_type *t = mvc_bind_type(m, $1); 
			  if (!t) {
				char buf[BUFSIZ]; 

				snprintf(buf, BUFSIZ, "Type (%s) unknown", $1);
				yyerror(buf);
				_DELETE($1); 
				$$ = NULL;
				YYABORT;
			  } else {
				$$ = sql_create_subtype(t, 0, 0);
			  }
			  _DELETE($1); 
			}
		
 | IDENT '(' nonzero ')'{ mvc *m = (mvc*)parm;
			  sql_type *t = mvc_bind_type(m, $1); 
			  if (!t) {
				char buf[BUFSIZ]; 

				snprintf(buf, BUFSIZ, "Type (%s) unknown", $1);
				yyerror(buf);
				_DELETE($1); 
				$$ = NULL;
				YYABORT;
			  } else {
				$$ = sql_create_subtype(t, $3, 0);
			  }
			  _DELETE($1); 
			}
		
 ;

type_alias:
 ALIAS
	{ 	char *t = sql_bind_alias($1);
	  	if (!t) {
			char buf[BUFSIZ]; 

			snprintf(buf, BUFSIZ, "Type (%s) unknown", $1);
			yyerror(buf);
			_DELETE($1); 
			$$ = NULL;
			YYABORT;
		}
		_DELETE($1); 
		$$ = t; 
	}
 ;

opt_var:
	/* empty */	{ $$ = 0; }
 | VARYING		{ $$ = 1; }
 ;

column:			ident ;

authid: 		ident ;

ident: 
    IDENT	{ $$ = $1; }	
 |  aTYPE	{ $$ = $1; }
 |  ALIAS	{ $$ = $1; }
 |  aMODULE	{ $$ = $1; }
 |  AGGR	{ $$ = $1; } 	/* without '(' */
 |  non_reserved_word		
 ;

non_reserved_word: 
  CHARACTER 	{ $$ = _strdup("character"); }
| sqlDECIMAL 	{ $$ = _strdup("decimal"); }
| sqlFLOAT 	{ $$ = _strdup("float"); }
| sqlDOUBLE 	{ $$ = _strdup("double"); }
| PRECISION 	{ $$ = _strdup("precision"); }
| sqlDATE 	{ $$ = _strdup("date"); }
| TIME 		{ $$ = _strdup("time"); }
| TIMESTAMP	{ $$ = _strdup("timestamp"); }
| PATH		{ $$ = _strdup("path"); }
| ROLE		{ $$ = _strdup("role"); }
| DEFAULT	{ $$ = _strdup("default"); }
| YEAR		{ $$ = _strdup("year"); }
| MONTH		{ $$ = _strdup("month"); }
| DAY		{ $$ = _strdup("day"); }
| HOUR		{ $$ = _strdup("hour"); }
| MINUTE	{ $$ = _strdup("minute"); }
| SECOND	{ $$ = _strdup("second"); }
| ZONE		{ $$ = _strdup("zone"); }
| sqlNAME	{ $$ = _strdup("name"); }
| TYPE		{ $$ = _strdup("type"); }
| MODULE	{ $$ = _strdup("module"); }
| PRIVILEGES	{ $$ = _strdup("privileges"); }
| START		{ $$ = _strdup("start"); }
| VALUE		{ $$ = _strdup("value"); }
;

name_commalist:
    ident		{ $$ = dlist_append_string(dlist_create(), $1); }
 |  name_commalist ',' ident  	
			{ $$ = dlist_append_string($1, $3); } 
 ;

intval:
	sqlINT	{ $$ = strtol($1,&$1,10); }
 |	IDENT	{ mvc *m = (mvc*)parm;
		  char *name = $1; 
		  char *v, *t; 
		  sql_subtype *tpe;

		  if (!(v = sql_get_var(m, name))) {
			char buf[BUFSIZ]; 

			snprintf(buf, BUFSIZ, "Constant (%s) unknown", $1);
			yyerror(buf);
			_DELETE($1); 
			$$ = 0;
			YYABORT;
		  }
		  t = sql_get_type(m, name);
		  tpe = sql_bind_subtype(t, 0, 0);
		  _DELETE($1); 
		  if (tpe->type->localtype == TYPE_lng ||
		      tpe->type->localtype == TYPE_int ||
		      tpe->type->localtype == TYPE_sht ) {
			$$ = strtol(v,&v,10); 
		  } else {
			char buf[BUFSIZ]; 

			snprintf(buf, BUFSIZ, "Constant (%s) has wrong type (number expected)", $1);
			yyerror(buf);
			$$ = 0;
			YYABORT;
		  }
		  sql_subtype_destroy(tpe);
		}
 ;

string:
    STRING
		{ $$ = $1; }
 |  STRING string
		{ $$ = strconcat($1,$2); _DELETE($1); _DELETE($2); }
 ;

prep:
    PREPARE sqlstmt_list ';'
		{ mvc *m = (mvc*)parm; 
		  m->mode = m_prepare; 
		  $$ = _symbol_create_list( SQL_PREP, $2); }
 ;

exec:
     EXECUTE exec_ref
		{ mvc *m = (mvc*)parm; 
		  m->mode = m_execute; 
		  $$ = $2; }
 ;

exec_ref:
    intval '(' ')'
	{ dlist *l = dlist_create();
  	  dlist_append_int(l, $1);
  	  dlist_append_list(l, NULL);
	  $$ = _symbol_create_list( SQL_NOP, l ); }
|   intval '(' scalar_exp_list ')'
	{ dlist *l = dlist_create();
  	  dlist_append_int(l, $1);
  	  dlist_append_list(l, $3);
	  $$ = _symbol_create_list( SQL_NOP, l ); }
 ;

scalar_exp_list:
    scalar_exp 		{ $$ = dlist_append_symbol( dlist_create(), $1); }
 |  scalar_exp_list ',' scalar_exp
			{ $$ = dlist_append_symbol( $1, $3); }
 ;



%%
char *token2string(int token)
{
	switch (token) {
	case SQL_CREATE_SCHEMA:
		return "Create Schema";
	case SQL_CREATE_TABLE:
		return "Create Table";
	case SQL_CREATE_VIEW:
		return "Create View";
	case SQL_CREATE_ROLE:
		return "Create ROLE";
	case SQL_CREATE_USER:
		return "Create USER";
	case SQL_CREATE_MODULE:
		return "Create MODULE";
	case SQL_CREATE_TYPE:
		return "Create TYPE";
	case SQL_CREATE_FUNC:
		return "Create FUNC";
	case SQL_DROP_SCHEMA:
		return "Drop Schema";
	case SQL_DROP_TABLE:
		return "Drop Table";
	case SQL_DROP_VIEW:
		return "Drop View";
	case SQL_DROP_ROLE:
		return "Drop ROLE";
	case SQL_DROP_USER:
		return "Drop USER";
	case SQL_DROP_MODULE:
		return "Drop MODULE";
	case SQL_DROP_TYPE:
		return "Drop TYPE";
	case SQL_DROP_FUNC:
		return "Drop FUNC";
	case SQL_DROP_CONSTRAINT:
		return "Drop CONSTRAINT";
	case SQL_DROP_INDEX:
		return "Drop INDEX";
	case SQL_ALTER_TABLE:
		return "Alter Table";
	case SQL_GRANT_ROLES:
		return "Grant ROLE";
	case SQL_NAME:
		return "Name";
	case SQL_USER:
		return "User";
	case SQL_PATH:
		return "Path";
	case SQL_CHARSET:
		return "Char Set";
	case SQL_SCHEMA:
		return "Schema";
	case SQL_TABLE:
		return "Table";
	case SQL_COLUMN:
		return "Column";
	case SQL_COLUMN_OPTIONS:
		return "Column Options";
	case SQL_CONSTRAINT:
		return "Constraint";
	case SQL_CHECK:
		return "Check";
	case SQL_DEFAULT:
		return "default";
	case SQL_NOT_NULL:
		return "Not Null";
	case SQL_NULL:
		return "Null";
	case SQL_UNIQUE:
		return "Unique";
	case SQL_PRIMARY_KEY:
		return "Primary Key";
	case SQL_FOREIGN_KEY:
		return "Foreign Key";
	case TR_COMMIT:
		return "Commit";
	case TR_ROLLBACK:
		return "Rollback";
	case TR_SAVEPOINT:
		return "Savepoint";
	case TR_RELEASE:
		return "Release";
	case TR_START:
		return "Start";
	case TR_MODE:
		return "Mode";
	case SQL_DECLARE:
		return "Declare";
	case SQL_SET:
		return "Set";
	case SQL_PREP:
		return "Prepare";
	case SQL_SELECT:
		return "Select";
	case SQL_WHERE:
		return "Where";
	case SQL_FROM:
		return "From";
	case SQL_UNIONJOIN:
		return "Union Join";
	case SQL_UNION:
		return "Union";
	case SQL_EXCEPT:
		return "Except";
	case SQL_INTERSECT:
		return "Intersect";
	case SQL_UPDATE:
		return "Update";
	case SQL_INSERT:
		return "Insert";
	case SQL_DELETE:
		return "Delete";
	case SQL_VALUES:
		return "Values";
	case SQL_ASSIGN:
		return "Assignment";
	case SQL_ORDERBY:
		return "Order By";
	case SQL_GROUPBY:
		return "Group By";
	case SQL_DESC:
		return "Desc";
	case SQL_AND:
		return "And";
	case SQL_OR:
		return "Or";
	case SQL_EXISTS:
		return "Exists";
	case SQL_NOT_EXISTS:
		return "Not Exists";
	case SQL_OP:
		return "Op";
	case SQL_UNOP:
		return "Unop";
	case SQL_BINOP:
		return "Binop";
	case SQL_BETWEEN:
		return "Between";
	case SQL_NOT_BETWEEN:
		return "Not Between";
	case SQL_LIKE:
		return "Like";
	case SQL_NOT_LIKE:
		return "Not Like";
	case SQL_IN:
		return "In";
	case SQL_NOT_IN:
		return "Not In";
	case SQL_GRANT:
		return "Grant";
	case SQL_REVOKE:
		return "Revoke";
	case SQL_EXECUTE:
		return "Execute";
	case SQL_PARAMETER:
		return "Parameter";
	case SQL_AGGR:
		return "Aggregates";
	case SQL_COMPARE:
		return "Compare";
	case SQL_TEMP_LOCAL:
		return "Local Temporary";
	case SQL_TEMP_GLOBAL:
		return "Global Temporary";
	case SQL_INT_VALUE:
		return "Integer";
	case SQL_ATOM:
		return "Atom";
	case SQL_ESCAPE:
		return "Escape";
	case SQL_CAST:
		return "Cast";
	case SQL_CASE:
		return "Case";
	case SQL_WHEN:
		return "When";
	case SQL_COALESCE:
		return "Coalesce";
	case SQL_NULLIF:
		return "Nullif";
	case SQL_JOIN:
		return "Join";
	case SQL_CROSS:
		return "Cross";
	case SQL_COPYFROM:
		return "Copy From";
	case SQL_COPYTO:
		return "Copy To";
	default:
		return "unknown";
	}
}

stmt *sql_error( mvc * sql, int error_code, char *format, ... )
{
	va_list	ap; 

	va_start (ap,format); 
	if (sql->errstr[0] == '\0') 
		vsnprintf(sql->errstr, ERRSIZE, _(format), ap); 
	if (!sql->status)
		sql->status = -error_code;
	va_end (ap); 
	return NULL;
}

int parse_error(mvc * c, char *err)
{
	(void)sql_error( c, 4, 
		 "!ERROR %s at token (%d) in statement: %s\n",
		 err, c->scanner.yyval, QUERY(c->scanner));
	return 1;
}
