@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@' 
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@' 
@' The Original Code is the Monet Database System.
@' 
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2004 CWI.
@' All Rights Reserved.
@' 
@' Contributor(s):
@' 		Martin Kersten <Martin.Kersten@cwi.nl>
@' 		Peter Boncz <Peter.Boncz@cwi.nl>
@' 		Niels Nes <Niels.Nes@cwi.nl>
@' 		Stefan Manegold  <Stefan.Manegold@cwi.nl>

@f sql_parser
@a N.J. Nes
@* 

@h
#ifndef _SQL_PARSER_H_
#define _SQL_PARSER_H_

#include "sql_statement.h"

typedef enum tokens {
	SQL_CREATE_SCHEMA,
	SQL_CREATE_TABLE,
	SQL_CREATE_VIEW,
	SQL_CREATE_INDEX,
	SQL_CREATE_ROLE,
	SQL_CREATE_USER,
	SQL_CREATE_MODULE,
	SQL_CREATE_TYPE,
	SQL_CREATE_FUNC,
	SQL_DROP_SCHEMA,
	SQL_DROP_TABLE,
	SQL_DROP_VIEW,
	SQL_DROP_INDEX,
	SQL_DROP_ROLE,
	SQL_DROP_USER,
	SQL_DROP_MODULE,
	SQL_DROP_TYPE,
	SQL_DROP_FUNC,
	SQL_ALTER_TABLE,
	SQL_DROP_COLUMN,
	SQL_DROP_CONSTRAINT,
	SQL_DROP_DEFAULT,
	SQL_SET,
	SQL_NAME,
	SQL_USER,
	SQL_PATH,
	SQL_CHARSET,
	SQL_TABLE,
	SQL_CASE,
	SQL_CAST,
	SQL_COLUMN,
	SQL_COLUMN_OPTIONS,
	SQL_COALESCE,
	SQL_CONSTRAINT,
	SQL_CHECK,
	SQL_DEFAULT,
	SQL_NOT_NULL,
	SQL_NULL,
	SQL_NULLIF,
	SQL_UNIQUE,
	SQL_PRIMARY_KEY,
	SQL_FOREIGN_KEY,
	SQL_BEGIN,
	SQL_COMMIT,
	SQL_ROLLBACK,
	SQL_SAVEPOINT,
	SQL_RELEASE,
	SQL_INSERT,
	SQL_DELETE,
	SQL_UPDATE,
	SQL_CROSS,
	SQL_JOIN,
	SQL_SELECT,
	SQL_WHERE,
	SQL_FROM,
	SQL_UNION,
	SQL_VALUES,
	SQL_ASSIGN,
	SQL_ORDERBY,
	SQL_GROUPBY,
	SQL_DESC,
	SQL_AND,
	SQL_OR,
	SQL_NOT,
	SQL_EXISTS,
	SQL_NOT_EXISTS,
	SQL_OP,
	SQL_UNOP,
	SQL_BINOP,
	SQL_NOP,
	SQL_BETWEEN,
	SQL_NOT_BETWEEN,
	SQL_LIKE,
	SQL_NOT_LIKE,
	SQL_IN,
	SQL_NOT_IN,
	SQL_GRANT,
	SQL_GRANT_ROLES,
	SQL_REVOKE,
	SQL_REVOKE_ROLES,
	SQL_EXECUTE,
	SQL_PRIVILEGES,
	SQL_ROLE,
	SQL_PARAMETER,
	SQL_FUNC,
	SQL_AGGR,
	SQL_COMPARE,
	SQL_TEMP_LOCAL,
	SQL_TEMP_GLOBAL,
	SQL_INT_VALUE,
	SQL_ATOM,
	SQL_USING,
	SQL_WHEN,
	SQL_ESCAPE,
	SQL_COPYFROM,
	SQL_COPYTO,
	SQL_EXPORT
} tokens;

typedef enum jt {
	jt_inner = 0,
	jt_left = 1,
	jt_right = 2,
	jt_full = 3,
	jt_union = 4
} jt;

sql_export char *token2string(int token);
sql_export stmt *sql_error( mvc * sql, int error_code, char *format, ... );
sql_export int parse_error( mvc * sql, char *s);
sql_export int sqlparse(void *);

#endif /*_SQL_PARSER_H_*/

@y
%{
#include <sql_mem.h>
#include "sql_parser.h"
#include "sql_symbol.h"
#include "sql_datetime.h"
#include "sql_decimal.h"	/* for decimal_from_str() */
#include "sql_semantic.h"	/* for sql_add_param() & sql_add_arg() */

#include <unistd.h>
#include <string.h>
#include <stdlib.h>

#define _symbol_create(t,d)         symbol_create( t, d)
#define _symbol_create_list(t,d)    symbol_create_list( t, d)
#define _symbol_create_int(t,d)     symbol_create_int( t, d)
#define _symbol_create_symbol(t,d)  symbol_create_symbol( t, d)
#define _newAtomNode(d)		    newAtomNode( d)

#define YYPARSE_PARAM parm
#define YYLEX_PARAM parm
#ifdef yyerror
#undef yyerror
#endif
#define yyerror(s...) sql_error(YYLEX_PARAM, 4, s)

#define FALSE 0
#define TRUE 1

%}
/* KNOWN NOT DONE OF sql'99
 * 
 * TRIGGERS
 * COLLATION
 * TRANSLATION
 * REF/SCOPE
 * UDT
 */

/* reentrant parser */
%pure_parser
%union {
	int 		ival,operation,bval;
	double 		fval;
	char *		sval;
	symbol*		sym;
	dlist*		l;
	sql_subtype*	type;
}
%{
extern int sqllex( YYSTYPE *yylval, void *lc );
%}

	/* symbolic tokens */
%type <sym> 
	alter
	assignment
	create
	drop
	set
	sql
	sqlstmt
	error
	schema
	opt_schema_default_char_set
	opt_schema_path
	schema_element
	delete_stmt
	copyfrom_stmt
	table_def
	view_def
	role_def
	module_def
	type_def
	func_def
	index_def
	all_or_any_predicate
	atom_exp
	between_predicate
	comparison_predicate
	opt_from_clause
	existence_test
	in_predicate
	insert_stmt
	transaction_stmt
	like_predicate
	opt_where_clause
	opt_having_clause
	opt_group_by_clause
	predicate
	joined_table
	join_spec
	search_condition
	update_stmt
	select_stmt
	select_with_parens
	select_no_parens
	select_clause
	subquery
	target
	test_for_null
	values_or_query_spec
	grant
	revoke
	operation
	table_element
	add_table_element
	alter_table_element
	drop_table_element
	table_constraint
	table_constraint_type
	column_def
	column_options
	column_option
	column_constraint
	column_constraint_type 
	like_table
	domain_constraint_type
	opt_order_by_clause
	default
	default_value
	aggr_ref
	func_ref
	datetime_funcs
	string_funcs
	scalar_exp
	value_exp
	column_exp
	atom
	insert_atom
	literal
	ordering_spec
	simple_table
	table_ref 
	opt_temp
	case_exp
	cast_exp
	when_value
	when_search
	opt_else
	table_name
	ref_on
	object_name

%type <type>
	data_type
	datetime_type
	interval_type
	func_data_type

%type <sval>
	opt_constraint_name 
	any_all_some
	non_reserved_word
	ident
	cident		/* special ident where strings and non-keywords 
			  are excluded, to solve many parser conflicts */
	column
	authid
	grantee
	opt_alias_name
	opt_to_savepoint
	opt_using
	string

%type <l>
	object_privileges
	privileges
	schema_name
	assignment_commalist
	opt_column_commalist
	column_commalist_parens
	column_commalist
	opt_corresponding
	column_ref_commalist
	name_commalist 
	column_ref
	atom_commalist
	qname 
	ordering_spec_commalist
	opt_schema_element_list
	schema_element_list
	operation_commalist
	target_commalist
	opt_into
	authid_list
	grantee_commalist
	column_def_opt_list
	opt_column_def_opt_list
	table_exp
	table_ref_commalist 
	table_element_list
	table_content_source
	column_exp_commalist
	column_option_list
	selection
	insert_atom_commalist
	start_field
	end_field
	single_datetime_field
	interval_qualifier
	scalar_exp_list
	when_value_list
	when_search_list
	opt_seps
	string_commalist
	paramlist
	opt_paramlist
	opt_ref_action

%type <ival>
	drop_action 
	ref_action 
	join_type
	outer_join_type
	time_persision
	non_second_datetime_field
	datetime_field
	opt_bounds
	opt_sign
	opt_index_type
	intval
	nonzero
	opt_nr
	opt_limit
	opt_match
	opt_match_type
	opt_on_commit
	opt_grantor
	opt_from_grantor
	opt_column
	grantor

%type <bval>
	opt_trans
	opt_chain
	opt_distinct
	opt_with_check_option

	opt_with_grant
	opt_with_hierarchy
	opt_with_admin
	opt_admin_for
	opt_grant_for

	opt_asc_desc
	opt_var
	tz

%right <sval> STRING

%token <sval> 
	IDENT TYPE AGGR sqlINT INTNUM APPROXNUM USING
	ALL DISTINCT ANY SOME CHECK GLOBAL LOCAL CAST
	CHARACTER VARYING NUMERIC sqlDECIMAL sqlFLOAT REAL
	sqlDOUBLE PRECISION PARTIAL SIMPLE ACTION CASCADE RESTRICT
	BOOL_FALSE BOOL_TRUE 
	USER SESSION_USER
	CURRENT_USER CURRENT_ROLE CURRENT_DATE CURRENT_TIMESTAMP CURRENT_TIME
	LEX_ERROR

%token <sval> sqlDELETE UPDATE SELECT INSERT
%token <sval> LEFT RIGHT FULL OUTER NATURAL CROSS JOIN INNER 
%token <sval> COMMIT ROLLBACK SAVEPOINT RELEASE WORK CHAIN NO PRESERVE ROWS
	
%token <sval> LIKE BETWEEN ASYMMETRIC SYMMETRIC ORDER BY
%token <operation> sqlIN EXISTS ESCAPE HAVING GROUP NULLX 
%token <operation> FROM FOR MATCH

/* datetime operations */
%token <operation> EXTRACT

	/* operators */
%left UNION EXCEPT INTERSECT CORRESPONDING
%left JOIN CROSS LEFT FULL RIGHT INNER NATURAL
%left <operation> OR
%left <operation> AND
%left <operation> NOT
%left <operation> '('
%left <sval> COMPARISON /* <> < > <= >= */
%left <operation> '='
%left <operation> '+' '-'
%left <operation> '*' '/' '%'
%left <operation> SUBSTRING CONCATSTRING
%right UMINUS

	/* literal keyword tokens */

/*
CONTINUE CURRENT CURSOR DECLARE FOUND GOTO GO LANGUAGE 
SQLCODE SQLERROR UNDER WHENEVER 
*/

%token TEMPORARY 
%token<sval> AS ASC DESC AUTHORIZATION 
%token CHECK CONSTRAINT CREATE 
%token MODULE sqlTYPE PROCEDURE FUNCTION RETURNS EXTERNAL sqlNAME EXECUTE
%token DEFAULT DISTINCT DROP
%token FOREIGN 
%token PASSWORD GRANT REVOKE ROLE ADMIN HAVING INTO 
%token IS KEY ON OPTION OPTIONS
%token PATH PRIMARY PRIVILEGES HIERARCHY
%token<sval> PUBLIC REFERENCES SCHEMA SET 

%token ALTER ADD TABLE COLUMN TO UNION UNIQUE VALUES VIEW WHERE WITH 
%token<sval> sqlDATE TIME TIMESTAMP INTERVAL
%token YEAR MONTH DAY HOUR MINUTE SECOND ZONE
%token LIMIT

%token CASE WHEN THEN ELSE END NULLIF COALESCE
%token COPY RECORDS DELIMITERS STDIN
%token INDEX

%%

sqlstmt:
   sql ';' 		{ mvc *lc = (mvc*)parm; 
			  lc->sym = $$ = $1; YYACCEPT; }
 | /*empty*/		{ mvc *lc = (mvc*)parm; 
			  lc->sym = $$ = NULL; YYACCEPT; }
 | ';'			{ mvc *lc = (mvc*)parm; 
			  lc->sym = $$ = NULL; YYACCEPT; }
 | error ';'		{ mvc *lc = (mvc*)parm;
			  /*
			  if ($1) 
				symbol_destroy($1); 
			  */
			  lc->sym = $$ = NULL; YYACCEPT; }
 | LEX_ERROR 		{ mvc *lc = (mvc*)parm;
			  lc->sym = $$ = NULL; YYACCEPT; }
 ;


	/* schema definition language */
sql: schema | grant | revoke | create | drop | alter | set ;
	
set: 
	SET ident '=' scalar_exp	
				{ dlist *l = dlist_create();
				dlist_append_string(l, $2 );
				dlist_append_symbol(l, $4 );
				$$ = _symbol_create_list( SQL_SET, l); }
	;

schema:
    CREATE SCHEMA schema_name opt_schema_default_char_set
	opt_schema_path	opt_schema_element_list	   

	{ dlist *l = dlist_create();
	  dlist_append_list(l, $3);
	  dlist_append_symbol(l, $4);
	  dlist_append_symbol(l, $5);
	  dlist_append_list(l, $6);
	  $$ = _symbol_create_list( SQL_CREATE_SCHEMA, l); }
 |  DROP SCHEMA qname drop_action 

	{ dlist *l = dlist_create();
	  dlist_append_list(l, $3);
	  dlist_append_int(l, $4);
	  $$ = _symbol_create_list( SQL_DROP_SCHEMA, l); }
 ;

schema_name:
    ident		    	
	{ $$ = dlist_create();
	  dlist_append_string($$, $1 );
	  dlist_append_string($$, NULL ); }
 |  AUTHORIZATION ident  	
	{ $$ = dlist_create();
	  dlist_append_string($$, NULL );
	  dlist_append_string($$, $2 ); }
 |  ident AUTHORIZATION ident 
	{ $$ = dlist_create();
	  dlist_append_string($$, $1 );
	  dlist_append_string($$, $3 ); }
 ;

opt_schema_default_char_set:
    /* empty */		   	{ $$ = NULL; }
 |  DEFAULT CHARACTER SET ident { $$ = _symbol_create( SQL_CHARSET, $4 ); }
 ;

opt_schema_path:
    /* empty */			{ $$ = NULL; }
 |  PATH name_commalist 	{ $$ = _symbol_create_list( SQL_PATH, $2 ); }
 ;

opt_schema_element_list:
    /* empty */			{ $$ = dlist_create(); }
 |  schema_element_list 	
 ;

schema_element_list:
    schema_element	{ $$ = dlist_append_symbol(dlist_create(), $1); }
 |  schema_element_list schema_element 	
			{ $$ = dlist_append_symbol( $1, $2 ); }
 |  schema_element_list error 	
			{ $$ = NULL; dlist_destroy($1); }
 ;

schema_element: grant | revoke | create | drop | alter ;
/* | add */


opt_grantor:
     /* empty */	 { $$ = cur_user; } 
 |   WITH ADMIN grantor  { $$ = $3; }
 ;

grantor:
    CURRENT_USER	{ $$ = cur_user; }
 |  CURRENT_ROLE 	{ $$ = cur_role; }
 ;

grant:
    GRANT privileges TO grantee_commalist opt_with_grant
	 opt_with_hierarchy opt_from_grantor
	{ dlist *l = dlist_create();
	  dlist_append_list(l, $2);
	  dlist_append_list(l, $4);
	  dlist_append_int(l, $5);
	  dlist_append_int(l, $6);
	  dlist_append_int(l, $7);
	$$ = _symbol_create_list( SQL_GRANT, l); 
	}

 |  GRANT authid_list TO grantee_commalist opt_with_admin 
		opt_from_grantor
	{ dlist *l = dlist_create();
	  dlist_append_list(l, $2);
	  dlist_append_list(l, $4);
	  dlist_append_int(l, $5);
	  dlist_append_int(l, $6);
	$$ = _symbol_create_list( SQL_GRANT_ROLES, l); }
 ;

authid_list:
	authid 		{ $$ = dlist_append_string(dlist_create(), $1); }
 | 	authid_list ',' authid 	
			{ $$ = dlist_append_string($1, $3); }
 | 	authid_list error 	
			{ $$ = NULL; dlist_destroy($1); }
 ;

opt_with_grant:
    /* empty */				{ $$ = 0; }
 |	WITH GRANT OPTION		{ $$ = 1; }
 ;

opt_with_hierarchy:
 	/* emtpy */		{ $$ = 0; }
 | 	WITH HIERARCHY OPTION	{ $$ = 1; }
 ;

opt_with_admin:
 	/* emtpy */		{ $$ = 0; }
 | 	WITH ADMIN OPTION	{ $$ = 1; }
 ;


opt_from_grantor:
 	/* empty */	{ $$ = cur_user; }
 | 	FROM grantor	{ $$ = $2; }
 ;

revoke:
     REVOKE opt_grant_for privileges FROM grantee_commalist opt_from_grantor
	{ dlist *l = dlist_create();
	  dlist_append_list(l, $3);
	  dlist_append_list(l, $5);
	  dlist_append_int(l, $2); /* GRANT OPTION FOR */ 
	  dlist_append_int(l, 0);
	  dlist_append_int(l, $6);
	$$ = _symbol_create_list( SQL_REVOKE, l); }
 |   REVOKE HIERARCHY OPTION FOR privileges FROM grantee_commalist 
	opt_from_grantor
	{ dlist *l = dlist_create();
	  dlist_append_list(l, $5);
	  dlist_append_list(l, $7);
	  dlist_append_int(l, 0);
	  dlist_append_int(l, 1); /* HIERARCHY OPTION */
	  dlist_append_int(l, $8);
	$$ = _symbol_create_list( SQL_REVOKE, l); }
 |   REVOKE opt_admin_for authid_list FROM grantee_commalist 
	opt_from_grantor
	{ dlist *l = dlist_create();
	  dlist_append_list(l, $3);
	  dlist_append_list(l, $5);
	  dlist_append_int(l, $6);
	  dlist_append_int(l, $2);
	$$ = _symbol_create_list( SQL_REVOKE, l); }
 ;

opt_grant_for:
    	/* empty */			{ $$ = 0; }
 |	GRANT OPTION FOR		{ $$ = 1; }
 ;

opt_admin_for:
    	/* empty */			{ $$ = 0; }
 |	ADMIN OPTION FOR		{ $$ = 1; }
 ;

privileges:
	object_privileges ON object_name 	
	{ $$ = dlist_create();
	  dlist_append_list($$, $1);
	  dlist_append_symbol($$, $3); }
 ;

object_name:
     TABLE ident		{ $$ = _symbol_create(SQL_TABLE, $2); }
 |   ident			{ $$ = _symbol_create(SQL_NAME, $1); }

/* | DOMAIN domain_name
   | CHARACTER SET char_set_name
   | COLLATION collation_name
   | TRANSLATION trans_name 
   | TYPE udt_name 
   | TYPE typed_table_name 
*/
 ; 

object_privileges:
    ALL PRIVILEGES			{ $$ = NULL; }
 |  ALL 				{ $$ = NULL; }
 |  operation_commalist			
 ;

operation_commalist:
    operation		{ $$ = dlist_append_symbol(dlist_create(), $1); }
 |  operation_commalist ',' operation   
			{ $$ = dlist_append_symbol($1, $3); }
 |  operation_commalist error   
			{ $$ = NULL; dlist_destroy($1); }
 ;

operation:
    INSERT 			    { $$ = _symbol_create(SQL_INSERT,NULL); }
 |  sqlDELETE 			    { $$ = _symbol_create(SQL_DELETE,NULL); }
 |  UPDATE opt_column_commalist     { $$ = _symbol_create_list(SQL_UPDATE,$2); }
 |  SELECT opt_column_commalist	    { $$ = _symbol_create_list(SQL_SELECT,$2); }
 |  REFERENCES opt_column_commalist { $$ = _symbol_create_list(SQL_SELECT,$2); }
 |  EXECUTE			    { $$ = _symbol_create(SQL_EXECUTE,NULL); }
/* | TRIGGER
   | UNDER 
   | USAGE
*/
 ;

grantee_commalist:			
    grantee			{ $$ = dlist_append_string(dlist_create(), $1); }
 |  grantee_commalist ',' grantee	
				{ $$ = dlist_append_string($1, $3); }
 |  grantee_commalist error	{ $$ = NULL; dlist_destroy($1); }
 ;

grantee:
    PUBLIC			{ $$ = NULL; }
 |  authid			{ $$ = $1; }
 ;

/* DOMAIN, ASSERTION, CHARACTER SET, TRANSLATION, TRIGGER */ 

alter: 
   ALTER TABLE qname ADD add_table_element 

	{ dlist *l = dlist_create();
	  dlist_append_list(l, $3);
	  dlist_append_symbol(l, $5);
	  $$ = _symbol_create_list( SQL_ALTER_TABLE, l ); }
 | ALTER TABLE qname ALTER alter_table_element 

	{ dlist *l = dlist_create();
	  dlist_append_list(l, $3);
	  dlist_append_symbol(l, $5);
	  $$ = _symbol_create_list( SQL_ALTER_TABLE, l ); }
 | ALTER TABLE qname DROP drop_table_element 
	{ dlist *l = dlist_create();
	  dlist_append_list(l, $3);
	  dlist_append_symbol(l, $5);
	  $$ = _symbol_create_list( SQL_ALTER_TABLE, l ); }
  ;

alter_table_element:
	opt_column ident SET DEFAULT default_value 
	{ dlist *l = dlist_create();
	  dlist_append_string(l, $2);
	  dlist_append_symbol(l, $5);
	  $$ = _symbol_create_list( SQL_DEFAULT, l); }
 | 	opt_column ident DROP DEFAULT 
	{ $$ = _symbol_create( SQL_DROP_DEFAULT, $2); }
 ;

drop_table_element:
     opt_column ident drop_action
	{ dlist *l = dlist_create();
	  dlist_append_string(l, $2 );
	  dlist_append_int(l, $3 );
	  $$ = _symbol_create_list( SQL_DROP_COLUMN, l ); }
  |  CONSTRAINT ident drop_action
	{ dlist *l = dlist_create();
	  dlist_append_string(l, $2 );
	  dlist_append_int(l, $3 );
	  $$ = _symbol_create_list( SQL_DROP_CONSTRAINT, l ); }
  ;

opt_column:
     COLUMN	 { $$ = 0; }
 |   /* empty */ { $$ = 0; }
 ;

create:	role_def | table_def | view_def | module_def | type_def | func_def | index_def;

index_def:
    CREATE opt_index_type INDEX ident ON qname '(' column_commalist ')' 
	{ dlist *l = dlist_create();
	  dlist_append_string(l, $4);
	  dlist_append_int(l, $2);
	  dlist_append_list(l, $6);
	  dlist_append_list(l, $8);
	  $$ = _symbol_create_list( SQL_CREATE_INDEX, l); }
  ;

opt_index_type:
     UNIQUE		{ $$ = unique; }
 |   /* empty */	{ $$ = unique; }
 ;

/* sql-server def
CREATE [ UNIQUE ] [ CLUSTERED | NONCLUSTERED ] INDEX index_name
    ON { table | view } ( column [ ASC | DESC ] [ ,...n ] )
[ WITH < index_option > [ ,...n] ]
[ ON filegroup ]

< index_option > :: =
    { PAD_INDEX |
        FILLFACTOR = fillfactor |
        IGNORE_DUP_KEY |
        DROP_EXISTING |
    STATISTICS_NORECOMPUTE |
    SORT_IN_TEMPDB 
}
*/

role_def:
    CREATE ROLE qname opt_grantor
	{ dlist *l = dlist_create();
	  dlist_append_list(l, $3);
	  dlist_append_int(l, $4);
	  $$ = _symbol_create_list( SQL_CREATE_ROLE, l ); }
 |  CREATE USER ident WITH PASSWORD ident sqlNAME string SCHEMA ident
	{ dlist *l = dlist_create();
	  dlist_append_string(l, $3);
	  dlist_append_string(l, $6);
	  dlist_append_string(l, $8);
	  dlist_append_string(l, $10);
	  $$ = _symbol_create_list( SQL_CREATE_USER, l ); }
 ;

table_def:
    CREATE opt_temp TABLE qname table_content_source opt_on_commit opt_nr

	{ dlist *l = dlist_create();
	  dlist_append_symbol(l, $2);
	  dlist_append_list(l, $4);
	  dlist_append_list(l, $5);
	  dlist_append_int(l, $7);
	  $$ = _symbol_create_list( SQL_CREATE_TABLE, l ); }
 ;

opt_temp:
    /* empty */ 	{ $$ = NULL; }
 |  LOCAL TEMPORARY 	{ $$ = _symbol_create( SQL_TEMP_LOCAL, NULL); }
 |  GLOBAL TEMPORARY	{ $$ = _symbol_create( SQL_TEMP_GLOBAL, NULL); }
 ;

opt_on_commit: /* only for temporary tables */
    /* empty */			 { $$ = 0; } /* default delete rows on commit */
 |  ON COMMIT PRESERVE ROWS  	 { $$ = 1; }
 |  ON COMMIT sqlDELETE ROWS	 { $$ = 0; } 
 ;
	
table_content_source:
    '(' table_element_list ')' 	{ $$ = $2; }
 ;

table_element_list:
    table_element	 
			{ $$ = dlist_append_symbol(dlist_create(), $1); }
 |  table_element_list ',' table_element
			{ $$ = dlist_append_symbol( $1, $3 ); }
 |  table_element_list error 
			{ $$ = NULL; if ($1) dlist_destroy($1); }
 ;

add_table_element: column_def | table_constraint ;
table_element: add_table_element | column_options | like_table ;

column_def:
    column data_type opt_column_def_opt_list
   	{ dlist *l = dlist_create();
	  dlist_append_string(l, $1 );
	  dlist_append_type(l, $2 );
	  dlist_append_list(l, $3 );
	  $$ = _symbol_create_list( SQL_COLUMN, l ); }
 ;

opt_column_def_opt_list:
    /* empty */			{ $$ = NULL; }
 | column_def_opt_list
 ;

column_def_opt_list:
    column_option		
			{ $$ = dlist_append_symbol(dlist_create(), $1 ); }
 |  column_def_opt_list column_option 	
			{ $$ = dlist_append_symbol( $1, $2 ); }
 |  column_def_opt_list error  	
			{ $$ = NULL; if ($1) dlist_destroy($1); }
 ;

column_options:
    ident WITH OPTIONS '(' column_option_list ')'  

   	{ dlist *l = dlist_create();
	  dlist_append_string(l, $1 );
	  dlist_append_list(l, $5 );
	  $$ = _symbol_create_list( SQL_COLUMN_OPTIONS, l ); }
 ;

column_option_list:
    column_option		
			{ $$ = dlist_append_symbol(dlist_create(), $1 ); }
 |  column_option_list ',' column_option   
			{ $$ = dlist_append_symbol($1, $3 ); }
 |  column_option_list error   
			{ $$ = NULL; if ($1) dlist_destroy($1); }
 ;

column_option: default | column_constraint ;

default:
    DEFAULT default_value { $$ = $2; }
 ;

/* TODO add auto increment */
default_value:
    literal 

 |  NULLX 	
		{ $$ = _newAtomNode( NULL);  }
 ;
	
column_constraint:
    opt_constraint_name column_constraint_type  /*opt_constraint_attributes*/

   	{ dlist *l = dlist_create();
 	  dlist_append_string(l, $1 );
	  dlist_append_symbol(l, $2 );
	  $$ = _symbol_create_list( SQL_CONSTRAINT, l ); }
 ;

table_constraint:
    opt_constraint_name table_constraint_type  /*opt_constraint_attributes*/

   	{ dlist *l = dlist_create();
	  dlist_append_string(l, $1 );
	  dlist_append_symbol(l, $2 );
	  $$ = _symbol_create_list( SQL_CONSTRAINT, l ); }
 ;

/* opt_constraint_attributes: ; */

opt_constraint_name:
    /* empty */	 		{ $$ = NULL; }
 |  CONSTRAINT ident 		{ $$ = $2; }
 ;

ref_action:
	NO ACTION		{ $$ = 0; }
 | 	CASCADE			{ $$ = 1; }
 | 	RESTRICT		{ $$ = 2; }
 | 	SET NULLX		{ $$ = 3; }
 | 	SET DEFAULT		{ $$ = 4; }
 ;

ref_on:
   ON UPDATE ref_action		{ $$ = _symbol_create_int(SQL_UPDATE, $3); }
 | ON sqlDELETE ref_action	{ $$ = _symbol_create_int(SQL_DELETE, $3); }
 ;

opt_ref_action:
	/* empty */	{ $$ = NULL; }
 | ref_on		{ $$ = dlist_append_symbol(dlist_create(), $1); }
 | ref_on ref_on	{ $$ = dlist_append_symbol(dlist_create(), $1);
 			  dlist_append_symbol($$, $2); 			}
 ;

opt_match_type:
    /* empty */			{ $$ = 0; }
 | FULL				{ $$ = 1; }
 | PARTIAL			{ $$ = 2; }
 | SIMPLE			{ $$ = 0; }
 ;

opt_match:
    /* empty */			{ $$ = 0; }
 | MATCH opt_match_type	 	{ $$ = $2; }
 ;

column_constraint_type:
    NOT NULLX	{ $$ = _symbol_create( SQL_NOT_NULL, NULL); }
 |  NULLX	{ $$ = _symbol_create( SQL_NULL, NULL); }
 |  UNIQUE	{ $$ = _symbol_create( SQL_UNIQUE, NULL ); }
 |  PRIMARY KEY	{ $$ = _symbol_create( SQL_PRIMARY_KEY, NULL ); }
 |  REFERENCES qname '(' column_ref ')' opt_match opt_ref_action

			{ dlist *l = dlist_create();
			  dlist_append_list(l, $2 );
			  dlist_append_list(l, $4 );
			  dlist_append_int(l, $6 );
			  dlist_append_list(l, $7 );
			  $$ = _symbol_create_list( SQL_FOREIGN_KEY, l); }
 | domain_constraint_type
 ;

table_constraint_type:
    UNIQUE column_commalist_parens  
			{ $$ = _symbol_create_list( SQL_UNIQUE, $2); }
 |  PRIMARY KEY column_commalist_parens 
			{ $$ = _symbol_create_list( SQL_PRIMARY_KEY, $3); }
 |  FOREIGN KEY column_commalist_parens 
    REFERENCES qname opt_column_commalist opt_match opt_ref_action

			{ dlist *l = dlist_create();
			  dlist_append_list(l, $5 );
			  dlist_append_list(l, $3 );
			  dlist_append_list(l, $6 );
			  dlist_append_int(l, $7 );
			  dlist_append_list(l, $8 );
			  $$ = _symbol_create_list( SQL_FOREIGN_KEY, l); }

 |  domain_constraint_type
 ;
		
domain_constraint_type:
    CHECK '(' search_condition ')' { $$ = _symbol_create_symbol(SQL_CHECK, $3); }
 ;
		
column_commalist:
    column		     
			{ $$ = dlist_append_string(dlist_create(), $1); }
 |  column_commalist ',' column  
			{ $$ = dlist_append_string( $1, $3 ); }
 |  column_commalist error  
			{ $$ = NULL; if ($1) dlist_destroy($1); }
 ;

like_table:
	LIKE qname 	{ $$ = _symbol_create_list(SQL_LIKE, $2 ); }
 ;

view_def:
    CREATE VIEW qname opt_column_commalist
    AS			{ mvc *c = (mvc*)parm;
			  c->scanner.as = c->scanner.yycur; }
	select_stmt opt_with_check_option

	{ dlist *l = dlist_create();
	  dlist_append_list(l, $3);
	  dlist_append_list(l, $4);
	  dlist_append_symbol(l, $7);
	  dlist_append_int(l, $8);
	  $$ = _symbol_create_list( SQL_CREATE_VIEW, l ); }
    ;
	
opt_with_check_option:
    /* empty */ 		{ $$ = FALSE; }
 |  WITH CHECK OPTION		{ $$ = TRUE; }
 ;

opt_column_commalist:
    /* empty */			{ $$ = NULL; }
 | column_commalist_parens
 ;

column_commalist_parens:
   '(' column_commalist ')' 	{ $$ = $2; } 
 ;

module_def:
    CREATE MODULE qname { $$ = _symbol_create_list( SQL_CREATE_MODULE, $3 ); }
 ;

/*
module_end:
    END ident		
*/

type_def:
    CREATE sqlTYPE qname
    EXTERNAL sqlNAME ident
			{ dlist *f = dlist_create();
	  		  	dlist_append_list(f, $3);
				dlist_append_string(f, $6);
 			  $$ = _symbol_create_list( SQL_CREATE_TYPE, f ); }
 ;

func_def:
    CREATE FUNCTION qname 
	'(' opt_paramlist ')'
    RETURNS data_type
    EXTERNAL sqlNAME ident
			{ dlist *f = dlist_create();
	  		  	dlist_append_list(f, $3);
	  			dlist_append_list(f, $5);
	  			dlist_append_type(f, $8);
				dlist_append_string(f, $11);
				dlist_append_symbol(f, NULL);
 			  $$ = _symbol_create_list( SQL_CREATE_FUNC, f ); }
 |
    CREATE FUNCTION qname 
	'(' opt_paramlist ')'
    RETURNS func_data_type
    AS			{ mvc *c = (mvc*)parm;
			  c->scanner.as = c->scanner.yycur; }
    select_stmt
			{ dlist *f = dlist_create();
	  		  	dlist_append_list(f, $3);
	  			dlist_append_list(f, $5);
	  			dlist_append_type(f, $8);
				dlist_append_string(f, NULL);
				dlist_append_symbol(f, $11);
 			  $$ = _symbol_create_list( SQL_CREATE_FUNC, f ); }
 | /* proc ie no result */
    CREATE PROCEDURE qname 
	'(' opt_paramlist ')'
    AS			{ mvc *c = (mvc*)parm;
			  c->scanner.as = c->scanner.yycur; }
    select_stmt 	/* todo stmt set BEGIN/END */
			{ dlist *f = dlist_create();
	  		  	dlist_append_list(f, $3);
	  			dlist_append_list(f, $5);
	  			dlist_append_type(f, NULL);   /* no result */
				dlist_append_string(f, NULL); /* no mil-impl */
				dlist_append_symbol(f, $9);
 			  $$ = _symbol_create_list( SQL_CREATE_FUNC, f ); }
 ;

func_data_type:
    TABLE		{ $$ = sql_bind_subtype("TABLE", 0, 0); }
 |  data_type
 ;

opt_paramlist:
    paramlist		
 |			{ $$ = NULL; }  
 ;

paramlist:
    paramlist ',' ident data_type	
			{ dlist *p = dlist_create();
	  		  dlist_append_string(p, $3);
	  		  dlist_append_type(p, $4);
			  $$ = dlist_append_list($1, p); }
 |  ident data_type
			{ dlist *l = dlist_create();
			  dlist *p = dlist_create();
	  		  dlist_append_string(p, $1);
	  		  dlist_append_type(p, $2);
			  $$ = dlist_append_list(l, p); }
 ;

drop:
    DROP TABLE qname drop_action
	
	{ dlist *l = dlist_create();
	  dlist_append_list(l, $3 );
	  dlist_append_int(l, $4 );
	  $$ = _symbol_create_list( SQL_DROP_TABLE, l ); }

 |  DROP VIEW qname	  { $$ = _symbol_create_list( SQL_DROP_VIEW, $3 ); }
 |  DROP ROLE qname	  { $$ = _symbol_create_list( SQL_DROP_ROLE, $3 ); }
 |  DROP USER ident	  { $$ = _symbol_create( SQL_DROP_USER, $3 ); }
 |  DROP INDEX qname	  { $$ = _symbol_create_list( SQL_DROP_INDEX, $3 ); }
 |  DROP MODULE qname	  { $$ = _symbol_create_list( SQL_DROP_MODULE, $3 ); }
 ;

drop_action:
    /* empty */ 	{ $$ = 0; }
 |  RESTRICT  		{ $$ = 0; }
 |  CASCADE	  	{ $$ = 1; }
 ;

	/* data manipulative stmts */

sql: 
   transaction_stmt 
 | delete_stmt
 | insert_stmt 
 | update_stmt 
 | copyfrom_stmt
 ;

transaction_stmt:
    COMMIT opt_trans opt_chain 	{ $$ = _symbol_create_int( SQL_COMMIT, $3); }
 |  SAVEPOINT ident 		{ $$ = _symbol_create( SQL_SAVEPOINT, $2); }
 |  RELEASE SAVEPOINT ident 	{ $$ = _symbol_create( SQL_RELEASE, $3); }
 |  ROLLBACK opt_trans opt_chain opt_to_savepoint
		{ $$ = _symbol_create_list( SQL_ROLLBACK, 
		   dlist_append_string(
		   	dlist_append_int(dlist_create(), $3), $4 )); }
 ;

opt_trans: /* pure syntax sugar */
    WORK		{ $$ = 0; }
 |  /* empty */		{ $$ = 0; }
 ;

opt_chain:
    AND CHAIN		{ $$ = 1; }
 |  AND NO CHAIN	{ $$ = 0; }
 |  /* empty */		{ $$ = 0; }
 ;

opt_to_savepoint:
    /* empty */ 	{ $$ = NULL; }
 |  TO SAVEPOINT ident  { $$ = $3; }
 ;

copyfrom_stmt:
    COPY opt_nr INTO qname FROM string_commalist opt_seps 
	{ dlist *l = dlist_create();
	  dlist_append_list(l, $4);
	  dlist_append_list(l, $6);
	  dlist_append_list(l, $7);
	  dlist_append_int(l, $2);
	  $$ = _symbol_create_list( SQL_COPYFROM, l ); }
  | COPY opt_nr INTO qname FROM STDIN opt_seps 
	{ dlist *l = dlist_create();
	  dlist_append_list(l, $4);
	  dlist_append_list(l, NULL);
	  dlist_append_list(l, $7);
	  dlist_append_int(l, $2);
	  $$ = _symbol_create_list( SQL_COPYFROM, l ); }
  ;

opt_seps:
    /* empty */		
				{ dlist *l = dlist_create(); 
				  dlist_append_string(l, _strdup("|")); 
				  dlist_append_string(l, _strdup("\\n")); 
				  $$ = l; }
 |  opt_using DELIMITERS string 
				{ dlist *l = dlist_create(); 
				  dlist_append_string(l, $3); 
				  dlist_append_string(l, _strdup("\\n")); 
				  $$ = l; }
 |  opt_using DELIMITERS string ',' string 
				{ dlist *l = dlist_create(); 
				  dlist_append_string(l, $3); 
				  dlist_append_string(l, $5);
				  $$ = l; }
 ;

opt_using:
    /* empty */			{ $$ = NULL; }
 |  USING			{ $$ = NULL; }
 ;

opt_nr:
    /* empty */			{ $$ = -1; }
 |  intval RECORDS		{ $$ = $1; }
 ;

string_commalist:
    string		{ $$ = dlist_append_string(dlist_create(), $1); }
 |  string_commalist ',' string  	
			{ $$ = dlist_append_string($1, $3); } 
 |  string_commalist error  	
			{ $$ = NULL; dlist_destroy($1); } 
 ;

delete_stmt:
    sqlDELETE FROM qname opt_where_clause 

	{ dlist *l = dlist_create();
	  dlist_append_list(l, $3);
	  dlist_append_symbol(l, $4);
	  $$ = _symbol_create_list( SQL_DELETE, l ); }
 ;

update_stmt:
    UPDATE qname SET assignment_commalist opt_where_clause

	{ dlist *l = dlist_create();
	  dlist_append_list(l, $2);
	  dlist_append_list(l, $4);
	  dlist_append_symbol(l, $5);
	  $$ = _symbol_create_list( SQL_UPDATE, l ); }
 ;


insert_stmt:
    INSERT INTO qname values_or_query_spec

	{ dlist *l = dlist_create();
	  dlist_append_list(l, $3);
	  dlist_append_list(l, NULL);
	  dlist_append_symbol(l, $4);
	  $$ = _symbol_create_list( SQL_INSERT, l ); }

 |  INSERT INTO qname column_commalist_parens values_or_query_spec

	{ dlist *l = dlist_create();
	  dlist_append_list(l, $3);
	  dlist_append_list(l, $4);
	  dlist_append_symbol(l, $5);
	  $$ = _symbol_create_list( SQL_INSERT, l ); }
 ;

values_or_query_spec:
    VALUES '(' insert_atom_commalist ')' 
		{ $$ = _symbol_create_list( SQL_VALUES, $3); }
 |  select_stmt
 ;

insert_atom_commalist:
    insert_atom		{ $$ = dlist_append_symbol(dlist_create(), $1); }
 |  insert_atom_commalist ',' insert_atom  
			{ $$ = dlist_append_symbol($1, $3); }
 |  insert_atom_commalist error 
			{ $$ = NULL; dlist_destroy($1); }
 ;

insert_atom:
    scalar_exp	
 ;

opt_distinct:
    /* empty */ 	{ $$ = FALSE; }	
 |  ALL			{ $$ = FALSE; }
 |  DISTINCT		{ $$ = TRUE; }
 ;

assignment_commalist:
    assignment		{ $$ = dlist_append_symbol(dlist_create(), $1 ); }
 |  assignment_commalist ',' assignment  
			{ $$ = dlist_append_symbol($1, $3 ); }
 |  assignment_commalist error
			{ $$ = NULL; dlist_destroy($1); }
 ;

assignment:
    column '=' scalar_exp 	

	{ dlist *l = dlist_create();
	  dlist_append_string(l, $1); 
	  dlist_append_symbol(l, $3); 
	  $$ = _symbol_create_list( SQL_ASSIGN, l); }
 ;

target_commalist:
    target		{ $$ = dlist_append_symbol(dlist_create(), $1); }
 |  target_commalist ',' target  
			{ $$ = dlist_append_symbol($1, $3); }
 |  target_commalist error
			{ $$ = NULL; dlist_destroy($1); }
 ;

target:
   TABLE qname  	{ $$ = _symbol_create_list( SQL_TABLE, $2); }
 ;

opt_where_clause:
    /* empty */ 		{ $$ = NULL; }
 |  WHERE search_condition	{ $$ = $2; }
 ;

	/* query expressions */

joined_table:
   '(' joined_table ')' 	
	{ $$ = $2; }
 |  table_ref CROSS JOIN table_ref

	{ dlist *l = dlist_create();
	  dlist_append_symbol(l, $1);
	  dlist_append_symbol(l, $4);
	  $$ = _symbol_create_list( SQL_CROSS, l); }
 |  table_ref UNION JOIN table_ref join_spec 
	{ dlist *l = dlist_create();
	  dlist_append_symbol(l, $1);
	  dlist_append_int(l, 0);
	  dlist_append_int(l, 4);
	  dlist_append_symbol(l, $4);
	  dlist_append_symbol(l, $5);
	  $$ = _symbol_create_list( SQL_JOIN, l); }
 |  table_ref JOIN table_ref join_spec 
	{ dlist *l = dlist_create();
	  dlist_append_symbol(l, $1);
	  dlist_append_int(l, 0);
	  dlist_append_int(l, 0);
	  dlist_append_symbol(l, $3);
	  dlist_append_symbol(l, $4);
	  $$ = _symbol_create_list( SQL_JOIN, l); }
 |  table_ref NATURAL JOIN table_ref 
	{ dlist *l = dlist_create();
	  dlist_append_symbol(l, $1);
	  dlist_append_int(l, 1);
	  dlist_append_int(l, 0);
	  dlist_append_symbol(l, $4);
	  dlist_append_symbol(l, NULL);
	  $$ = _symbol_create_list( SQL_JOIN, l); }
 |  table_ref join_type JOIN table_ref join_spec 
	{ dlist *l = dlist_create();
	  dlist_append_symbol(l, $1);
	  dlist_append_int(l, 0);
	  dlist_append_int(l, $2);
	  dlist_append_symbol(l, $4);
	  dlist_append_symbol(l, $5);
	  $$ = _symbol_create_list( SQL_JOIN, l); }
 |  table_ref NATURAL join_type JOIN table_ref 
	{ dlist *l = dlist_create();
	  dlist_append_symbol(l, $1);
	  dlist_append_int(l, 1);
	  dlist_append_int(l, $3);
	  dlist_append_symbol(l, $5);
	  dlist_append_symbol(l, NULL);
	  $$ = _symbol_create_list( SQL_JOIN, l); }
  ;

join_type:
    INNER			{ $$ = 0; }
  | outer_join_type OUTER 	{ $$ = 1 + $1; }
  | outer_join_type 		{ $$ = 1 + $1; }
  ;

outer_join_type:
    LEFT		{ $$ = 0; }
  | RIGHT		{ $$ = 1; }
  | FULL		{ $$ = 2; }
  ;

join_spec:
    ON search_condition 		{ $$ = $2; }
  | USING column_commalist_parens  	
		{ $$ = _symbol_create_list( SQL_USING, $2); }
  ;

sql: 
    select_stmt 
 ;

select_stmt:
    select_no_parens                    %prec UMINUS
	opt_order_by_clause opt_limit
	{
          SelectNode *sn = (SelectNode*)$1;
	  sn->orderby = $2;
	  sn->limit = $3;
	  $$ = $1;
 	}
 |  select_with_parens                    %prec UMINUS
 ;

select_with_parens:
    '(' select_no_parens ')' 	{ $$ = $2; }
 |  '(' select_with_parens ')'  { $$ = $2; }
 ;

select_clause:
    select_no_parens
 |  select_with_parens
 ;

select_no_parens:
    SELECT opt_distinct selection opt_into table_exp 
	{ $$ = newSelectNode( $2, $3, $4, 
	  	$5->h->data.sym,
	  	$5->h->next->data.sym,
	  	$5->h->next->next->data.sym,
	  	$5->h->next->next->next->data.sym,
	  	NULL, NULL, -1);
	  dlist_destroy_keep_data($5);
	}

 |  select_clause UNION opt_distinct opt_corresponding select_clause

	{ dlist *l = dlist_create();
	  dlist_append_symbol(l, $1);
	  dlist_append_int(l, $3);
	  dlist_append_list(l, $4);
	  dlist_append_symbol(l, $5);
	  $$ = _symbol_create_list( SQL_UNION, l); }

 |  select_clause EXCEPT opt_distinct opt_corresponding select_clause

	{ dlist *l = dlist_create();
	  dlist_append_symbol(l, $1);
	  dlist_append_int(l, $3);
	  dlist_append_list(l, $4);
	  dlist_append_symbol(l, $5);
	  $$ = _symbol_create_list( SQL_UNION, l); }

 |  select_clause INTERSECT opt_distinct opt_corresponding select_clause

	{ dlist *l = dlist_create();
	  dlist_append_symbol(l, $1);
	  dlist_append_int(l, $3);
	  dlist_append_list(l, $4);
	  dlist_append_symbol(l, $5);
	  $$ = _symbol_create_list( SQL_UNION, l); }
 ;

opt_corresponding:
	/* empty */	{ $$ = NULL; }
 |  CORRESPONDING				
			{ $$ = dlist_create(); }
 |  CORRESPONDING BY '(' column_ref_commalist ')' 	
			{ $$ = $4; } 
 ;

opt_into:
   INTO target_commalist 	{ $$ = $2; }
 | /* empty */			{ $$ = NULL; }
 ;

selection:
    column_exp_commalist
 |  '*' 			{ $$ = NULL; }
 ;

table_exp:
    opt_from_clause opt_where_clause opt_group_by_clause opt_having_clause

	{ $$ = dlist_create();
	  dlist_append_symbol($$, $1);
	  dlist_append_symbol($$, $2);
	  dlist_append_symbol($$, $3);
	  dlist_append_symbol($$, $4); }
 ;

opt_from_clause: 
    /* empty */			 { $$ = NULL; }
 |  FROM table_ref_commalist 	 { $$ = _symbol_create_list( SQL_FROM, $2); }
 ;

table_ref_commalist:
    table_ref		{ $$ = dlist_append_symbol(dlist_create(), $1); }
 |  table_ref_commalist ',' table_ref  
			{ $$ = dlist_append_symbol($1, $3); }
 |  table_ref_commalist error  
			{ $$ = NULL; dlist_destroy($1); }
 ;

simple_table:
   qname 			{ dlist *l = dlist_create();
		  		  dlist_append_list(l, $1);  
		  	  	  dlist_append_symbol(l, NULL);  
		  		  $$ = _symbol_create_list(SQL_NAME, l); }
 | qname table_name 		{ dlist *l = dlist_create();
		  		  dlist_append_list(l, $1);  
		  	  	  dlist_append_symbol(l, $2);  
		  		  $$ = _symbol_create_list(SQL_NAME, l); }
 | func_ref table_name		{ dlist *l = dlist_create();
		  		  dlist_append_symbol(l, $1);  
		  	  	  dlist_append_symbol(l, $2);  
		  		  $$ = _symbol_create_list(SQL_TABLE, l); }
 ;

table_ref:
    simple_table
 |  select_with_parens table_name	
				{ SelectNode *sn = (SelectNode*)$1;
				  $$ = $1; 
				  sn->name = $2; }
 |  select_with_parens error	
				{ $$ = NULL;
				  symbol_destroy($1);
				  yyerror("Subquery table reference needs alias");
				}
 |  joined_table 		{ $$ = $1; 
				  dlist_append_symbol($1->data.lval, NULL); }
 |  '(' joined_table ')' table_name	
				{ $$ = $2; 
				  dlist_append_symbol($2->data.lval, $4); }
 ;

table_name:	
    AS ident '(' name_commalist ')'
				{ dlist *l = dlist_create();
		  		  dlist_append_string(l, $2);  
		  	  	  dlist_append_list(l, $4);  
		  		  $$ = _symbol_create_list(SQL_NAME, l); }
 |  AS ident 
				{ dlist *l = dlist_create();
		  		  dlist_append_string(l, $2);  
		  	  	  dlist_append_list(l, NULL);  
		  		  $$ = _symbol_create_list(SQL_NAME, l); }
 |  ident '(' name_commalist ')'
				{ dlist *l = dlist_create();
		  		  dlist_append_string(l, $1);  
		  	  	  dlist_append_list(l, $3);  
		  		  $$ = _symbol_create_list(SQL_NAME, l); }
 |  ident 
				{ dlist *l = dlist_create();
		  		  dlist_append_string(l, $1);  
		  	  	  dlist_append_list(l, NULL);  
		  		  $$ = _symbol_create_list(SQL_NAME, l); }
 ;

opt_group_by_clause:
    /* empty */ 		  { $$ = NULL; }
 |  GROUP BY column_ref_commalist { $$ = _symbol_create_list( SQL_GROUPBY, $3 );}
 ;

column_ref_commalist:
    column_ref		{ $$ = dlist_append_symbol(dlist_create(), 
			       _symbol_create_list(SQL_COLUMN,$1)); }
 |  column_ref_commalist ',' column_ref  
			{ $$ = dlist_append_symbol( $1, 
			       _symbol_create_list(SQL_COLUMN,$3)); }
 |  column_ref_commalist error 
			{ $$ = NULL; dlist_destroy($1); } 
 ;

opt_having_clause:
    /* empty */ 		 { $$ = NULL; }
 |  HAVING search_condition	 { $$ = $2; }
 ;

	/* search conditions 
 |  NOT search_condition    	{ $$ = _symbol_create_symbol(SQL_NOT, $2); }
*/

search_condition:
    search_condition OR search_condition  	
		{ dlist *l = dlist_create();
		  dlist_append_symbol(l, $1); 
		  dlist_append_symbol(l, $3); 
		  $$ = _symbol_create_list(SQL_OR, l ); }
 |  search_condition AND search_condition
		{ dlist *l = dlist_create();
		  dlist_append_symbol(l, $1); 
		  dlist_append_symbol(l, $3); 
		  $$ = _symbol_create_list(SQL_AND, l ); }
 |  '(' search_condition ')'	{ $$ = $2; }
 | predicate			
 ;

opt_order_by_clause:
    /* empty */ 			  { $$ = NULL; }
 |  ORDER BY ordering_spec_commalist  
		{ $$ = _symbol_create_list( SQL_ORDERBY, $3); }
 ;

opt_limit:
    /* empty */ 			{ $$ = -1; }
 |  LIMIT nonzero 			{ $$ = $2; }
 ;

ordering_spec_commalist:
    ordering_spec	 { $$ = dlist_append_symbol(dlist_create(), $1); }
 |  ordering_spec_commalist ',' ordering_spec 
			 { $$ = dlist_append_symbol( $1, $3 ); }
 |  ordering_spec_commalist error 
			 { $$ = NULL; dlist_destroy($1); }
 ;

ordering_spec:
    intval opt_asc_desc 
	{ dlist *l = dlist_create();
	  dlist_append_symbol(l, _symbol_create_int(SQL_INT_VALUE, (int)$1)); 
	  dlist_append_int(l, $2); 
	  $$ = _symbol_create_list(SQL_COLUMN, l ); }
 |  column_ref opt_asc_desc 
	{ dlist *l = dlist_create();
	  dlist_append_symbol(l, _symbol_create_list(SQL_COLUMN, $1)); 
	  dlist_append_int(l, $2); 
	  $$ = _symbol_create_list(SQL_COLUMN, l ); }
					  
 ;

opt_asc_desc:
    /* empty */ 	{ $$ = TRUE; }
 |  ASC			{ $$ = TRUE; }
 |  DESC		{ $$ = FALSE; }
 ;

predicate: comparison_predicate | between_predicate | like_predicate
 |  test_for_null | in_predicate | all_or_any_predicate | existence_test ;

comparison_predicate:
    scalar_exp COMPARISON scalar_exp	 
		{ dlist *l = dlist_create();
		  dlist_append_symbol(l, $1); 
		  dlist_append_string(l, $2); 
		  dlist_append_symbol(l, $3); 
		  $$ = _symbol_create_list(SQL_COMPARE, l ); }
 |  scalar_exp '=' scalar_exp
		{ dlist *l = dlist_create();
		  dlist_append_symbol(l, $1); 
		  dlist_append_string(l, _strdup("=")); 
		  dlist_append_symbol(l, $3); 
		  $$ = _symbol_create_list(SQL_COMPARE, l ); }
 ;

between_predicate:
    scalar_exp NOT BETWEEN opt_bounds scalar_exp AND scalar_exp
		{ dlist *l = dlist_create();
		  dlist_append_symbol(l, $1); 
		  dlist_append_int(l, $4); 
		  dlist_append_symbol(l, $5); 
		  dlist_append_symbol(l, $7); 
		  $$ = _symbol_create_list(SQL_NOT_BETWEEN, l ); }
 |  scalar_exp BETWEEN opt_bounds scalar_exp AND scalar_exp
		{ dlist *l = dlist_create();
		  dlist_append_symbol(l, $1); 
		  dlist_append_int(l, $3); 
		  dlist_append_symbol(l, $4); 
		  dlist_append_symbol(l, $6); 
		  $$ = _symbol_create_list(SQL_BETWEEN, l ); }
 ;

opt_bounds:
   /* empty */ 	{ $$ = 0; }
 | ASYMMETRIC 	{ $$ = 0; }
 | SYMMETRIC 	{ $$ = 1; }
 ;

like_predicate:
    scalar_exp NOT LIKE atom_exp
		{ dlist *l = dlist_create();
		  dlist_append_symbol(l, $1); 
		  dlist_append_symbol(l, $4); 
		  $$ = _symbol_create_list(SQL_NOT_LIKE, l ); }
 |  scalar_exp LIKE atom_exp
		{ dlist *l = dlist_create();
		  dlist_append_symbol(l, $1); 
		  dlist_append_symbol(l, $3); 
		  $$ = _symbol_create_list(SQL_LIKE, l ); }
 ;


atom_exp:
    atom 	{ dlist *l = dlist_create();
		  dlist_append_symbol(l, $1); 
		  $$ = _symbol_create_list(SQL_ESCAPE, l ); }
 |  atom ESCAPE atom 	 
		{ dlist *l = dlist_create();
		  dlist_append_symbol(l, $1); 
		  dlist_append_symbol(l, $3); 
		  $$ = _symbol_create_list(SQL_ESCAPE, l ); }
 ;

test_for_null:
    column_ref IS NOT NULLX  { symbol *s =_symbol_create_list(SQL_COLUMN, $1);
			      $$ = _symbol_create_symbol( SQL_NOT_NULL, s ); }
 |  column_ref IS NULLX	     { symbol *s =_symbol_create_list(SQL_COLUMN, $1);
			       $$ = _symbol_create_symbol( SQL_NULL, s ); }
 ;

in_predicate:
    scalar_exp NOT sqlIN subquery
		{ dlist *l = dlist_create();
		  dlist_append_symbol(l, $1); 
		  dlist_append_symbol(l, $4); 
		  $$ = _symbol_create_list(SQL_NOT_IN, l ); }
 |  scalar_exp sqlIN subquery 
		{ dlist *l = dlist_create();
		  dlist_append_symbol(l, $1); 
		  dlist_append_symbol(l, $3); 
		  $$ = _symbol_create_list(SQL_IN, l ); }
 |  scalar_exp NOT sqlIN '(' atom_commalist ')'
		{ dlist *l = dlist_create();
		  dlist_append_symbol(l, $1); 
		  dlist_append_list(l, $5); 
		  $$ = _symbol_create_list(SQL_NOT_IN, l ); }
 |  scalar_exp sqlIN '(' atom_commalist ')'
		{ dlist *l = dlist_create();
		  dlist_append_symbol(l, $1); 
		  dlist_append_list(l, $4); 
		  $$ = _symbol_create_list(SQL_IN, l ); }
 ;

atom_commalist:
    atom	{ $$ = dlist_append_symbol(dlist_create(), $1); }
 |  atom_commalist ',' atom 	
		{ $$ = dlist_append_symbol($1, $3); }
 |  atom_commalist error 	
		{ $$ = NULL; dlist_destroy($1); }
 ;

all_or_any_predicate:
    scalar_exp COMPARISON any_all_some subquery

		{ dlist *l = dlist_create();
		  dlist_append_symbol(l, $1); 
		  dlist_append_string(l, $2); 
		  dlist_append_string(l, $3); 
		  dlist_append_symbol(l, $4); 
		  $$ = _symbol_create_list(SQL_COMPARE, l ); }
 ;
			
any_all_some:
    ANY		{ $$ = $1; }
 |  ALL		{ $$ = $1; }
 |  SOME	{ $$ = $1; }
 ;

existence_test:
    EXISTS subquery 	{ $$ = _symbol_create_symbol( SQL_EXISTS, $2 ); }
 |  NOT EXISTS subquery { $$ = _symbol_create_symbol( SQL_NOT_EXISTS, $3 ); }
 ;

subquery:
    '(' SELECT opt_distinct  selection table_exp ')' 

	{ $$ = newSelectNode( $3, $4, NULL, 
	  	$5->h->data.sym,
	  	$5->h->next->data.sym,
	  	$5->h->next->next->data.sym,
	  	$5->h->next->next->next->data.sym,
	  	NULL, NULL, -1);
	  dlist_destroy_keep_data($5);
	}
 ;

	/* scalar expressions */

scalar_exp:
    value_exp

 |  scalar_exp '+' scalar_exp	
				{ dlist *l = dlist_create();
				  dlist_append_string(l, _strdup("sql_add"));
	  			  dlist_append_symbol(l, $1);
	  			  dlist_append_symbol(l, $3);
	  			  $$ = _symbol_create_list( SQL_BINOP, l ); }
 |  scalar_exp '-' scalar_exp   
				{ dlist *l = dlist_create();
				  dlist_append_string(l, _strdup("sql_sub"));
	  			  dlist_append_symbol(l, $1);
	  			  dlist_append_symbol(l, $3);
	  			  $$ = _symbol_create_list( SQL_BINOP, l ); }
 |  scalar_exp '*' scalar_exp
				{ dlist *l = dlist_create();
				  dlist_append_string(l, _strdup("sql_mul"));
	  			  dlist_append_symbol(l, $1);
	  			  dlist_append_symbol(l, $3);
	  			  $$ = _symbol_create_list( SQL_BINOP, l ); }
 |  scalar_exp '/' scalar_exp
				{ dlist *l = dlist_create();
				  dlist_append_string(l, _strdup("sql_div"));
	  			  dlist_append_symbol(l, $1);
	  			  dlist_append_symbol(l, $3);
	  			  $$ = _symbol_create_list( SQL_BINOP, l ); }
 |  scalar_exp '%' scalar_exp
				{ dlist *l = dlist_create();
				  dlist_append_string(l, _strdup("sql_mod"));
	  			  dlist_append_symbol(l, $1);
	  			  dlist_append_symbol(l, $3);
	  			  $$ = _symbol_create_list( SQL_BINOP, l ); }
 |  '+' scalar_exp %prec UMINUS { $$ = $2; }
 |  '-' scalar_exp %prec UMINUS { dlist *l = dlist_create();
				  dlist_append_string(l, _strdup("sql_neg"));
	  			  dlist_append_symbol(l, $2);
	  			  $$ = _symbol_create_list( SQL_UNOP, l ); }
 |  '(' scalar_exp ')' 		{ $$ = $2; }
 |  subquery			%prec UMINUS
 ;

value_exp:
    atom
 |  column_ref 			{ $$ = _symbol_create_list( SQL_COLUMN, $1); }
 |  aggr_ref 
 |  func_ref 
 |  datetime_funcs
 |  string_funcs
 |  case_exp	
 |  cast_exp
 |  NULLX			{ $$ = _symbol_create(SQL_NULL, NULL ); }
 ;

func_ref:
    IDENT '(' scalar_exp ')'
	{ dlist *l = dlist_create();
  	  dlist_append_string(l, $1);
  	  dlist_append_symbol(l, $3);
	  $$ = _symbol_create_list( SQL_UNOP, l ); }
|   IDENT '(' scalar_exp ',' scalar_exp ')'
	{ dlist *l = dlist_create();
  	  dlist_append_string(l, $1);
  	  dlist_append_symbol(l, $3);
  	  dlist_append_symbol(l, $5);
	  $$ = _symbol_create_list( SQL_BINOP, l ); }
|   IDENT '(' scalar_exp_list ')'
	{ dlist *l = dlist_create();
  	  dlist_append_string(l, $1);
  	  dlist_append_list(l, $3);
	  $$ = _symbol_create_list( SQL_NOP, l ); }
 ;

datetime_funcs:
    EXTRACT '(' datetime_field FROM scalar_exp ')' 
				{ dlist *l = dlist_create();
				  const char *ident = datetime_field((itype)$3);
  		  		  dlist_append_string(l, _strdup(ident));
  		  		  dlist_append_symbol(l, $5);
		  		  $$ = _symbol_create_list( SQL_UNOP, l ); }
 |  CURRENT_DATE 
 			{ dlist *l = dlist_create();
			  dlist_append_string(l, _strdup("current_date"));
	  		  $$ = _symbol_create_list( SQL_OP, l ); }
 |  CURRENT_TIME 
 			{ dlist *l = dlist_create();
			  dlist_append_string(l, _strdup("current_time"));
	  		  $$ = _symbol_create_list( SQL_OP, l ); }
 |  CURRENT_TIMESTAMP 
 			{ dlist *l = dlist_create();
			  dlist_append_string(l, _strdup("current_timestamp"));
	  		  $$ = _symbol_create_list( SQL_OP, l ); }
 ;

string_funcs:
    SUBSTRING '(' scalar_exp FROM nonzero FOR intval ')' 
				{ dlist *l = dlist_create();
				  dlist *ops = dlist_create();
				  sql_subtype *t = 
					sql_bind_subtype("MEDIUMINT", 0, 0);

				  dlist_append_symbol(ops, $3);
  		  		  dlist_append_symbol(ops, _newAtomNode(
					atom_int(t, $5 -1 )));
  		  		  dlist_append_symbol(ops, _newAtomNode(
					atom_int(sql_dup_subtype(t), $7 )));

  		  		  dlist_append_string(l, _strdup("substring"));
  		  		  dlist_append_list(l, ops);
		  		  $$ = _symbol_create_list( SQL_NOP, l ); }
 |  scalar_exp CONCATSTRING scalar_exp  
				{ dlist *l = dlist_create();
  		  		  dlist_append_string(l, _strdup("strconcat"));
  		  		  dlist_append_symbol(l, $1);
  		  		  dlist_append_symbol(l, $3);
		  		  $$ = _symbol_create_list( SQL_BINOP, l ); }
 ;

column_exp_commalist:
    column_exp 		{ $$ = dlist_append_symbol(dlist_create(), $1 ); }
 |  column_exp_commalist error  
			{ $$ = NULL; if ($1) dlist_destroy( $1 ); }
 |  column_exp_commalist ',' column_exp  
			{ $$ = dlist_append_symbol( $1, $3 ); }
 ;

column_exp:
    ident '.' '*'
		{ dlist *l = dlist_create();
  		  dlist_append_string(l, $1);
  		  dlist_append_string(l, NULL);
  		  $$ = _symbol_create_list( SQL_TABLE, l ); }
 |  scalar_exp opt_alias_name
		{ dlist *l = dlist_create();
  		  dlist_append_symbol(l, $1);
  		  dlist_append_string(l, $2);
  		  $$ = _symbol_create_list( SQL_COLUMN, l ); }
 ;

opt_alias_name:
    /* empty */	{ $$ = NULL; }
 |  AS ident	{ $$ = $2; }
 ;

atom:
    literal	
	{ /* replace by argument */
	  mvc *c = (mvc*)parm;
	  int len = (c->params)?list_length(c->params):0;
	  if (len < MAXPARAMS-2 && c->cache){
	  	char name[BUFSIZ]; 
	  	AtomNode *an = (AtomNode*)$1;
	  	sql_subtype *t = sql_dup_subtype(atom_type(an->a));

	  	snprintf(name, BUFSIZ, "A%d", len);
	  	sql_add_param( c, _strdup(name), stmt_var(_strdup(name), t) );
	  	sql_add_arg( c, atom_dup(an->a));
	  	/* we miss use SQL_COLUMN also for param's, maybe 
	     	change SQL_COLUMN to SQL_IDENT */
 	  	$$ = _symbol_create_list( SQL_COLUMN, dlist_append_string(dlist_create(), _strdup(name))); 
		c->scanner.key ^= t->type->localtype;

		symbol_destroy($1);
	   } else {
		$$ = $1;
	   }
	}
 ;


/* change to set function */
aggr_ref:
    AGGR '(' '*' ')' 	
		{ dlist *l = dlist_create();
  		  dlist_append_string(l, $1);
  		  dlist_append_int(l, FALSE);
  		  dlist_append_symbol(l, NULL);
		  $$ = _symbol_create_list( SQL_AGGR, l ); }
 |  AGGR '(' ident '.' '*' ')' 
		{ dlist *l = dlist_create();
		  _DELETE($3);
  		  dlist_append_string(l, $1);
  		  dlist_append_int(l, FALSE);
  		  dlist_append_symbol(l, NULL);
		  $$ = _symbol_create_list( SQL_AGGR, l ); }
 |  AGGR '(' DISTINCT column_ref ')' 
		{ dlist *l = dlist_create();
  		  dlist_append_string(l, $1);
  		  dlist_append_int(l, TRUE);
  		  dlist_append_symbol(l, _symbol_create_list(SQL_COLUMN, $4));
		  $$ = _symbol_create_list( SQL_AGGR, l ); }
 |  AGGR '(' ALL scalar_exp ')'
		{ dlist *l = dlist_create();
  		  dlist_append_string(l, $1);
  		  dlist_append_int(l, FALSE);
  		  dlist_append_symbol(l, $4);
		  $$ = _symbol_create_list( SQL_AGGR, l ); }
 |  AGGR '(' scalar_exp ')' 
		{ dlist *l = dlist_create();
  		  dlist_append_string(l, $1);
  		  dlist_append_int(l, FALSE);
  		  dlist_append_symbol(l, $3);
		  $$ = _symbol_create_list( SQL_AGGR, l ); }
 ;

opt_sign:
   '+'		{ $$ = 1; }
 | '-' 		{ $$ = -1; }
 | /* empty */	{ $$ = 1; }
 ;

tz:
	WITH TIME ZONE	{ $$ = 1; }
 | /* empty */		{ $$ = 0; }
 ;

time_persision:
	'(' intval ')' 	{ $$ = $2; }
 | /* empty */		{ $$ = 0; }
 ;

datetime_type:
    sqlDATE			{ $$ = sql_bind_subtype("DATE", 0, 0); }
 |  TIME time_persision tz 	{ $$ = sql_bind_subtype("TIME", $2, $3); }
 |  TIMESTAMP time_persision tz { $$ = sql_bind_subtype("TIMESTAMP", $2, $3); }
 ;

non_second_datetime_field:
    YEAR		{ $$ = iyear; }
 |  MONTH		{ $$ = imonth; }
 |  DAY			{ $$ = iday; }
 |  HOUR		{ $$ = ihour; }
 |  MINUTE		{ $$ = imin; }
 ;

datetime_field:
    non_second_datetime_field
 |  SECOND		{ $$ = isec; }
 ;

start_field:
    non_second_datetime_field time_persision
		{ $$ = dlist_append_int( 
			 	dlist_append_int( dlist_create(), $1), $2);  }
 ;

end_field:
    non_second_datetime_field 	
		{ $$ = dlist_append_int( 
			 	dlist_append_int( dlist_create(), $1), 0);  }
 |  SECOND time_persision	
		{ $$ = dlist_append_int( 
			 	dlist_append_int( dlist_create(), isec), $2);  }
 ;

single_datetime_field:
    non_second_datetime_field time_persision 
		{ $$ = dlist_append_int( 
			 	dlist_append_int( dlist_create(), $1), $2);  }
 |  SECOND time_persision	
		{ $$ = dlist_append_int( 
			 	dlist_append_int( dlist_create(), isec), $2);  }
 ;

interval_qualifier:
    start_field TO end_field  
	{ $$ =  dlist_append_list(
			dlist_append_list( dlist_create(), $1), $3 ); }
 |  single_datetime_field    
	{ $$ =  dlist_append_list( dlist_create(), $1); }
 ;

interval_type:
    INTERVAL interval_qualifier	{ 
		/* TODO: 
		   usual trick is to have a INTERVAL type per range (YEAR-DAY
		 * etc, and store the precisions in digits/scale */
		$$ = sql_bind_subtype("INTERVAL", 0, 0); }
 ;

literal:
    string
		{  sql_subtype *t = sql_bind_subtype("CHAR", strlen($1), 0 ); 
		   $$ = _newAtomNode( atom_string(t, $1)); }
/* TODO need to use user name or id ?? */
 |  USER     
		{  sql_subtype *t = sql_bind_subtype("CHAR", strlen($1), 0);
		   $$ = _newAtomNode( atom_string(t, _strdup($1))); }
 |  SESSION_USER     
		{  sql_subtype *t = sql_bind_subtype("CHAR", strlen($1), 0);
		   $$ = _newAtomNode( atom_string(t, _strdup($1))); }

 |  sqlINT   	{ int digits = strlen($1);
		  long value = strtol($1,&$1,10); 
		  sql_subtype *t = sql_bind_subtype("INT", digits, 0 );
		  $$ = _newAtomNode( atom_int(t, value)); }
 |  INTNUM   
		{ char *s = strip_extra_zeros($1);
		  char *dot = strchr(s, '.');
		  int digits = strlen(s) - 1;
		  int scale = digits - (dot-s);
		  lng value = decimal_from_str(s);
		  sql_subtype *t;

		  if (*s == '+' || *s == '-')
			digits --;
		  t = sql_bind_subtype("DECIMAL", digits, scale );
		  $$ = _newAtomNode( atom_int(t, value)); }
 |  APPROXNUM
		{ sql_subtype *t = sql_bind_subtype("DOUBLE", 51, 0 );
		  double val = strtod($1,NULL);
		  $$ = _newAtomNode( atom_float(t, val)); }
 |  sqlDATE string 
		{ sql_subtype *t = sql_bind_subtype("DATE", 0, 0 );
		  $$ = _newAtomNode( atom_general(t, $2)); }
 |  TIME string 
		{ sql_subtype *t = sql_bind_subtype("TIME", 0, 0 );
		  $$ = _newAtomNode( atom_general(t, $2)); }
 |  TIMESTAMP string 
		{ sql_subtype *t = sql_bind_subtype("TIMESTAMP", 0, 0 );
		  $$ = _newAtomNode( atom_general(t, $2)); }
 |  INTERVAL opt_sign string interval_qualifier
		{ mvc *lc = (mvc*)parm;
	  	  int i,tpe;
	  	  if ( (tpe = parse_interval( lc, $2, $3, $4, &i)) < 0 ){
			yyerror("incorrect interval");
			$$ = NULL;
	  	  } else {
			sql_subtype *t; 
			if (tpe == 0){
				t = sql_bind_subtype("MONTH_INTERVAL", 0, 0);
			} else {
				t = sql_bind_subtype("SEC_INTERVAL", 0, 0);
			}
	  		$$ = _newAtomNode( atom_int(t,i));
	  	  }
		}
 |  TYPE string 
		{ sql_subtype *t = sql_bind_subtype($1, 0, 0);
		  atom *a = atom_general(t, $2);
		  $$ = NULL;
	          if (a) 
			$$ = _newAtomNode(a); 
		  if (!$$) {
			char buf[BUFSIZ]; 

			snprintf(buf, BUFSIZ, "incorrect %s %s", $1, $2);
			yyerror(buf);
			if (a) 
				atom_destroy(a);
	  	  	_DELETE($1); 
			YYABORT;
		  }
	  	  _DELETE($1); 
		}
 |  BOOL_FALSE  
		{ sql_subtype *t = sql_bind_subtype("BOOL", 0, 0 );
		  $$ = _newAtomNode( atom_general(t, _strdup("false"))); }
 |  BOOL_TRUE  
		{ sql_subtype *t = sql_bind_subtype("BOOL", 0, 0 );
		  $$ = _newAtomNode( atom_general(t, _strdup("true"))); }
 ;

	/* miscellaneous */

qname:
    ident		{ $$ = dlist_append_string(dlist_create(), $1); }
 |  ident '.' ident	{ $$ = dlist_append_string(
				dlist_append_string(dlist_create(), $1), $3);}
 ;

column_ref:
    cident		{ $$ = dlist_append_string(
				dlist_create(), $1); }

 |  ident '.' ident	{ $$ = dlist_append_string(
				dlist_append_string(
				 dlist_create(), $1), $3);}

 |  ident '.' ident '.' ident
    			{ $$ = dlist_append_string(
				dlist_append_string(
				 dlist_append_string(
				  dlist_create(), $1), $3), $5);}
 ;

cast_exp:
     CAST '(' scalar_exp AS data_type ')'
 	{ dlist *l = dlist_create();
	  dlist_append_symbol(l, $3);
	  dlist_append_type(l, $5);
	  $$ = _symbol_create_list( SQL_CAST, l ); }
 ;

case_exp: /* could rewrite NULLIF and COALESCE to normal CASE stmts */
     NULLIF '(' scalar_exp ',' scalar_exp ')' 
		{ $$ = _symbol_create_list(SQL_NULLIF,
		   dlist_append_symbol(
		    dlist_append_symbol(
		     dlist_create(), $3), $5)); }
 |   COALESCE '(' scalar_exp_list ')'
		{ $$ = _symbol_create_list(SQL_COALESCE, $3); }
 |   CASE scalar_exp when_value_list opt_else END
		{ $$ = _symbol_create_list(SQL_CASE, 
		   dlist_append_symbol(
		    dlist_append_list(
		     dlist_append_symbol(
		      dlist_create(),$2),$3),$4)); }
 |   CASE when_search_list opt_else END
		 { $$ = _symbol_create_list(SQL_CASE, 
		   dlist_append_symbol(
		    dlist_append_list(
		     dlist_create(),$2),$3)); }
 ;

scalar_exp_list:
    scalar_exp ',' scalar_exp
			{ $$ = dlist_append_symbol( dlist_create(), $1);
			  $$ = dlist_append_symbol( $$, $3); }
 |  scalar_exp_list ',' scalar_exp
			{ $$ = dlist_append_symbol( $1, $3); }
 |  scalar_exp_list error
			{ $$ = NULL; dlist_destroy($1); }
 ;

when_value:
    WHEN scalar_exp THEN scalar_exp
			{ $$ = _symbol_create_list( SQL_WHEN,
			   dlist_append_symbol(
			    dlist_append_symbol(
			     dlist_create(), $2),$4)); }
 ;

when_value_list:
    when_value
			{ $$ = dlist_append_symbol( dlist_create(), $1);}
 |  when_value_list when_value
			{ $$ = dlist_append_symbol( $1, $2); }
 |  when_value_list error
			{ $$ = NULL; dlist_destroy($1); }
 ;

when_search:
    WHEN search_condition THEN scalar_exp
			{ $$ = _symbol_create_list( SQL_WHEN,
			   dlist_append_symbol(
			    dlist_append_symbol(
			     dlist_create(), $2),$4)); }
 ;

when_search_list:
    when_search
			{ $$ = dlist_append_symbol( dlist_create(), $1); }
 |  when_search_list when_search
			{ $$ = dlist_append_symbol( $1, $2); }
 |  when_search_list error
			{ $$ = NULL; dlist_destroy($1); }
 ;

opt_else:
    ELSE scalar_exp	{ $$ = $2; }
 ;

		/* data types, more types to come */

nonzero:
	intval 	{ $$ = $1;
		  if ($$ == 0) {
			$$ = -1;
			yyerror("Positive value expected");
		  }
		}

data_type:
    CHARACTER opt_var	{ $$ = sql_bind_subtype("CHARACTER", 0, 0); }
 |  CHARACTER  opt_var'(' nonzero ')'	
			{ $$ = sql_bind_subtype("CHARACTER", $3, 0); }
 |  NUMERIC		{ $$ = sql_bind_subtype("NUMERIC", 0, 0); }
 |  NUMERIC '(' nonzero ')'	
			{ $$ = sql_bind_subtype("NUMERIC", $3, 0); }
 |  NUMERIC '(' intval ',' intval ')' 
			{ if ($5 >= $3) {
				yyerror("Presision(%d) should be less than number of digits(%d)", $5, $3);
				$$ = NULL;
			  } else {
			        $$ = sql_bind_subtype("NUMERIC", $3, $5); 
			  }
			}
 |  sqlDECIMAL		{ $$ = sql_bind_subtype("DECIMAL", 0, 0); }
 |  sqlDECIMAL '(' nonzero ')'	
			{ $$ = sql_bind_subtype("DECIMAL", $3, 0); }
 |  sqlDECIMAL '(' intval ',' intval ')' 
			{ if ($5 >= $3) {
				yyerror("Presision(%d) should be less than number of digits(%d)", $5, $3);
				$$ = NULL;
			  } else {
				$$ = sql_bind_subtype("DECIMAL", $3, $5); 
			  }
			}
 |  sqlFLOAT		{ $$ = sql_bind_subtype("FLOAT", 0, 0); }
 |  sqlFLOAT '(' nonzero ')'	
			{ $$ = sql_bind_subtype("FLOAT", $3, 0); }
 |  sqlFLOAT '(' intval ',' intval ')'	
			{ if ($5 >= $3) {
				yyerror("Presision(%d) should be less than number of digits(%d)", $5, $3);
				$$ = NULL;
			  } else {
				$$ = sql_bind_subtype("FLOAT", $3, $5); 
			  }
			}
 |  REAL		{ $$ = sql_bind_subtype("REAL", 0, 0); }
 |  sqlDOUBLE 		{ $$ = sql_bind_subtype("DOUBLE", 0, 0); }
 |  sqlDOUBLE '(' intval ',' intval ')' 	
			{ if ($5 >= $3) {
				yyerror("Presision(%d) should be less than number of digits(%d)", $5, $3);
				$$ = NULL;
			  } else {
				$$ = sql_bind_subtype("DOUBLE", $3, $5); 
			  }
			}
 |  sqlDOUBLE PRECISION	{ $$ = sql_bind_subtype("DOUBLE", 0, 0); }
 | datetime_type
 | interval_type		
 | TYPE			{ $$ = sql_bind_subtype($1, 0, 0); _DELETE($1); }
 | TYPE '(' nonzero ')'	{ $$ = sql_bind_subtype($1, $3, 0); _DELETE($1); }
 ;

opt_var:
	/* empty */	{ $$ = 0; }
 | VARYING		{ $$ = 1; }
 ;

column:			ident ;

authid: 		ident ;

ident: 
    IDENT	{ $$ = $1; }	
 |  TYPE	{ $$ = $1; }
 |  AGGR	{ $$ = $1; } 	/* without '(' */
 |  string			
 |  non_reserved_word		
 ;

cident:
     IDENT
 |  TYPE	{ $$ = $1; }
 |  AGGR	{ $$ = $1; } 	/* without '(' */
 |  non_reserved_word		
 ;

non_reserved_word: 
  CHARACTER 	{ $$ = _strdup("character"); }
| NUMERIC 	{ $$ = _strdup("numeric"); }
| sqlDECIMAL 	{ $$ = _strdup("decimal"); }
| sqlFLOAT 	{ $$ = _strdup("float"); }
| REAL 		{ $$ = _strdup("real"); }
| sqlDOUBLE 	{ $$ = _strdup("double"); }
| PRECISION 	{ $$ = _strdup("precision"); }
| sqlDATE 	{ $$ = _strdup("date"); }
| TIME 		{ $$ = _strdup("time"); }
| TIMESTAMP	{ $$ = _strdup("timestamp"); }
| PATH		{ $$ = _strdup("path"); }
| ROLE		{ $$ = _strdup("role"); }
| DEFAULT	{ $$ = _strdup("default"); }
| YEAR		{ $$ = _strdup("year"); }
| MONTH		{ $$ = _strdup("month"); }
| DAY		{ $$ = _strdup("day"); }
| HOUR		{ $$ = _strdup("hour"); }
| MINUTE	{ $$ = _strdup("minute"); }
| SECOND	{ $$ = _strdup("second"); }
| ZONE		{ $$ = _strdup("zone"); }
| sqlNAME	{ $$ = _strdup("name"); }
| sqlTYPE	{ $$ = _strdup("type"); }
;

name_commalist:
    ident		{ $$ = dlist_append_string(dlist_create(), $1); }
 |  name_commalist ',' ident  	
			{ $$ = dlist_append_string($1, $3); } 
 |  name_commalist error  	
			{ $$ = NULL; dlist_destroy($1); } 
 ;

intval:
	sqlINT			{ $$ = strtol($1,&$1,10); }
 ;

string:
    STRING
		{ $$ = $1; }
 |  STRING string
		{ $$ = strconcat($1,$2); _DELETE($1); _DELETE($2); }
 ;



	/* embedded condition things */
/* sql: WHENEVER NOT FOUND when_action |	WHENEVER SQLERROR when_action ;
when_action:	GOTO IDENT |	CONTINUE ; */
%%

char *token2string(int token)
{
	switch (token) {
	case SQL_CREATE_SCHEMA:
		return "Create Schema";
	case SQL_CREATE_TABLE:
		return "Create Table";
	case SQL_CREATE_VIEW:
		return "Create View";
	case SQL_CREATE_ROLE:
		return "Create ROLE";
	case SQL_CREATE_USER:
		return "Create USER";
	case SQL_CREATE_MODULE:
		return "Create MODULE";
	case SQL_CREATE_TYPE:
		return "Create TYPE";
	case SQL_CREATE_FUNC:
		return "Create FUNC";
	case SQL_DROP_SCHEMA:
		return "Drop Schema";
	case SQL_DROP_TABLE:
		return "Drop Table";
	case SQL_DROP_VIEW:
		return "Drop View";
	case SQL_DROP_ROLE:
		return "Drop ROLE";
	case SQL_DROP_USER:
		return "Drop USER";
	case SQL_DROP_MODULE:
		return "Drop MODULE";
	case SQL_DROP_TYPE:
		return "Drop TYPE";
	case SQL_DROP_FUNC:
		return "Drop FUNC";
	case SQL_DROP_CONSTRAINT:
		return "Drop CONSTRAINT";
	case SQL_DROP_INDEX:
		return "Drop INDEX";
	case SQL_ALTER_TABLE:
		return "Alter Table";
	case SQL_GRANT_ROLES:
		return "Grant ROLE";
	case SQL_NAME:
		return "Name";
	case SQL_USER:
		return "User";
	case SQL_PATH:
		return "Path";
	case SQL_CHARSET:
		return "Char Set";
	case SQL_TABLE:
		return "Table";
	case SQL_COLUMN:
		return "Column";
	case SQL_COLUMN_OPTIONS:
		return "Column Options";
	case SQL_CONSTRAINT:
		return "Constraint";
	case SQL_CHECK:
		return "Check";
	case SQL_DEFAULT:
		return "default";
	case SQL_NOT_NULL:
		return "Not Null";
	case SQL_NULL:
		return "Null";
	case SQL_UNIQUE:
		return "Unique";
	case SQL_PRIMARY_KEY:
		return "Primary Key";
	case SQL_FOREIGN_KEY:
		return "Foreign Key";
	case SQL_COMMIT:
		return "Commit";
	case SQL_ROLLBACK:
		return "Rollback";
	case SQL_SET:
		return "Set";
	case SQL_SELECT:
		return "Select";
	case SQL_WHERE:
		return "Where";
	case SQL_FROM:
		return "From";
	case SQL_UNION:
		return "Union";
	case SQL_UPDATE:
		return "Update";
	case SQL_INSERT:
		return "Insert";
	case SQL_DELETE:
		return "Delete";
	case SQL_VALUES:
		return "Values";
	case SQL_ASSIGN:
		return "Assignment";
	case SQL_ORDERBY:
		return "Order By";
	case SQL_GROUPBY:
		return "Group By";
	case SQL_DESC:
		return "Desc";
	case SQL_AND:
		return "And";
	case SQL_OR:
		return "Or";
	case SQL_EXISTS:
		return "Exists";
	case SQL_NOT_EXISTS:
		return "Not Exists";
	case SQL_OP:
		return "Op";
	case SQL_UNOP:
		return "Unop";
	case SQL_BINOP:
		return "Binop";
	case SQL_BETWEEN:
		return "Between";
	case SQL_NOT_BETWEEN:
		return "Not Between";
	case SQL_LIKE:
		return "Like";
	case SQL_NOT_LIKE:
		return "Not Like";
	case SQL_IN:
		return "In";
	case SQL_NOT_IN:
		return "Not In";
	case SQL_GRANT:
		return "Grant";
	case SQL_REVOKE:
		return "Revoke";
	case SQL_EXECUTE:
		return "Execute";
	case SQL_PARAMETER:
		return "Parameter";
	case SQL_AGGR:
		return "Aggregates";
	case SQL_COMPARE:
		return "Compare";
	case SQL_TEMP_LOCAL:
		return "Local Temporary";
	case SQL_TEMP_GLOBAL:
		return "Global Temporary";
	case SQL_INT_VALUE:
		return "Integer";
	case SQL_ATOM:
		return "Atom";
	case SQL_ESCAPE:
		return "Escape";
	case SQL_CAST:
		return "Cast";
	case SQL_CASE:
		return "Case";
	case SQL_WHEN:
		return "When";
	case SQL_COALESCE:
		return "Coalesce";
	case SQL_NULLIF:
		return "Nullif";
	case SQL_JOIN:
		return "Join";
	case SQL_CROSS:
		return "Cross";
	case SQL_COPYFROM:
		return "Copy From";
	case SQL_COPYTO:
		return "Copy To";
	case SQL_EXPORT:
		return "Export";
	default:
		return "unknown";
	}
}

stmt *sql_error( mvc * sql, int error_code, char *format, ... )
{
	va_list	ap; 

	va_start (ap,format); 
	if (sql->errstr[0] == '\0') {
		sql->status = error_code;
		vsnprintf(sql->errstr, ERRSIZE, _(format), ap); 
	}
	va_end (ap); 
	return NULL;
}

int parse_error(mvc * c, char *err)
{
	(void)sql_error( c, 4, 
		 "!ERROR %s at token (%d) in statement: %s\n",
		 err, c->scanner.yyval, QUERY(c->scanner));
	return 1;
}
