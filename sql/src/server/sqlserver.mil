module(sqlserver);
module(sql);
module(ascii_io);
module(str);
module(alarm);
module(unix);
module(ddbench);
module(aggr);
module(mvc);
module(monettime);

proc default_val( myc, cid, val ) := {
	return mvc_default( myc, cid, str(val));
}

proc atom(val):= {
	return val;
}

proc avg(BAT b):= {
	var s := b.sum();
	return s/b.count();
}

proc date_sub_sec_interval( date d, int sec ) := {
	if (sec > 0){
		return d.adddays( -1 * sec/86400);
	}
	return d;
}

proc add(x, y):= return x + y;
proc sub(x, y):= return x - y;
proc mul(x, y):= return x * y;
proc div(x, y):= return x / y;
proc neg(val):= return -1 * val;

proc sep():= {
	return "\t";
}

proc load_seps( BAT[void,BAT] bats, str Sep ) : BAT[void,str] := {
	var seps := new(void,str); seps.seqbase(oid(0));
	var id := 0;
	var cnt := bats.count - 1;
	bats@batloop(){
		if (id != cnt) {
			seps.insert(nil,Sep);
		} else {
			seps.insert(nil,(Sep + "\n"));
		}
		id += 1;
	}
	return seps;
}

proc bat_name(b):= return str(b);
proc bat_type(b):= return monet_atomtbl.reverse.find(b.ttype());

proc bulkload( tab, file, Sep ):= {
	var lid := table_name.reverse().find( tab );
	var tid := table_id.find( lid );
        var columns := column_name.semijoin(column_table.select(tid));
	var bats := column_bat.semijoin(columns);
	bats := column_number.reverse().join(bats).sort();
	bats := bats.reverse().mark(oid(0)).reverse();
	
	var names := [bat_name](bats);
	var types := [bat_type](bats);
	var seps := load_seps(bats,Sep);
	var res := load(names, seps, types, file, -1);
	# merge result
	var x := bats.reverse().join(names.join(res));
	x@batloop(){ $h.insert($t); }
}
Stdout := file_wastream( stdout, "test" );

proc write_output( stream Output, str v ) := {
	var buf := v + "\n";
	stream_write(Output, buf );
}

proc output_count( bat b, stream Output ) := {
	write_output( Output, str(b.count()) );
}

proc ascii_io_output( bat Order, bat bats, stream Output, str Sep ) : int := {
	var Max := bats.reverse.max();
	var seps := [ bats ~ const Sep];
	seps.access(BAT_WRITE);
	seps.replace(Max, "\n");

	seps := seps.reverse.mark(oid(0));
	bats := bats.reverse.mark(oid(0));
	return output( Order, seps.reverse, bats.reverse, Output );
}

proc oidrange( output_stream, nr ) := {
	stream_write( output_stream, ("" + newoid( nr )) + "\n" );
	stream_flush( output_stream );
}

proc server_output( stream Output, bat[oid,any] Order,  ..bat[oid,any]..) : void := {
	var cnt := $0;
	var bats := new(oid,bat);
	var id := 0;
	while((id + 2) < cnt ){
		bats.insert(oid(id), $(id+3));
		id :+= 1;
	}
	ascii_io_output(Order, bats, Output, "\t");
}

proc ascii_export_functions(Output):= {
	output_count( type_sql, Output);
	server_output( Output, type_sql, type_sql, type_db, type_cast );

	output_count( sql_aggr_name, Output);
	server_output( Output, sql_aggr_name, sql_aggr_name, sql_aggr_imp, sql_aggr_type, sql_aggr_result );
		
	output_count( sql_func_name, Output);
	server_output( Output, sql_func_name, sql_func_name, sql_func_imp, sql_func_type1, sql_func_type2, sql_func_result );

	#output_count( schema_name, Output);
	#server_output( Output, schema_id, schema_id, schema_name, schema_auth);
	stream_flush(Output);
}

proc ascii_export_schema(Output, schema):= {
	var sid := oid(-1);
	if (schema_name.reverse().exist(schema)){
		sid := schema_id.find(schema_name.reverse().find(schema));
	}
	write_output ( Output, str(int(sid)) );
	
	var tables := table_name.semijoin(table_schema.select(sid));
	tables := tables.kdiff( table_query );
	output_count( tables, Output);
	var tableids := table_id.semijoin(tables);
	server_output( Output, tableids, tableids, tables, table_temp.semijoin(tables) );

	var table_ids := column_table.join(table_id.reverse().join(tables));
	output_count( table_ids, Output);
	var columnids := column_id.semijoin(table_ids);
	server_output( Output, columnids, columnids, table_ids, column_name, column_type, column_default, column_null, column_number );

	var views := table_name.semijoin(table_query); 
	output_count( views, Output);
	var viewids := table_id.semijoin(views);
	server_output( Output, viewids, viewids, views, table_query );

	stream_flush(Output);
}

proc SQLclient_module( Output, Input, myc, cmd ) := {
	# TODO get schema/user/debug/opt from skipped cmd
	var c := create_context( 0, 1, Output);

	cmd := stream_read( Input );
	while(cmd != ""){
		sql(c, cmd );
		stream_write( Output, "0\n" );
		stream_flush( Output );
		cmd := stream_read( Input );
	}
	destroy_context( c );
	#stream_close( Output );
	stream_close( Input );
}

proc SQLclient_thread( int sock ):= {

	var Output := block_stream(
		socket_wstream( sock, sprintf("SQLserver-%d", sock) ));
	var Input := block_stream(
		socket_rstream( sock, sprintf("SQLserver-%d", sock) ));

	var myc := mvc_create(0);

	var cmd := stream_read( Input );
	if (cmd.startsWith("module")){
		return SQLclient_module( Output, Input, myc, cmd );
	}

	while(cmd != ""){
		if (cmd.startsWith("0")){
			mvc_insert( myc, cmd );
		} else {
			sqlexecute(cmd, Output );
		}
		cmd := stream_read( Input );
	}
	stream_close( Output );
	stream_close( Input );
}

proc hjoin( b1, b2 ) := {
	b1.reverse().accbuild(hash);
	b2.accbuild(hash);
	return b1.join(b2);
}

proc sqlexecute( str cmd, stream Output ):= {
	#print(cmd);
	eval(cmd);
}

proc SQLclient( int sock ) := {
	print(sock);
	SQLclient_thread(sock).fork();
}

proc get_sql_port() := {
	var port := 45123;
	var sqlport := getenv("SQLPORT");
	if (length(sqlport) > 0){
		port := int(sqlport);
	}
	return port;
}

sqlserver_start(get_sql_port(), "SQLclient").fork();

