SQL/MIL FASTPATH HOWTO
======================

door Peter Boncz

Hieronder leg ik uit hoe je de MIL functionaliteit om parsing
functie-resolutie en variable-resolutie te optimaliseren, kunt
gebruiken om vanuit SQL repetitieve statements te versnellen.

onderstaande kun je op 2 plekken gebruiken:
(a) om ODBC prepare/bind/execute mee te implementeren (simpel)
(b) om een adaptieve statement cache te maken in de SQL parser (meer werk)

hash(str sqlstmt) : int
  berekent een hash waarde uit een sql statement waarbij
  constanten in expressies niet worden meegenomen.
match(str sqlstmt1, sqlstmt2)
  checkt equality van statemnets zonder te letten op constanten

als met name hash() efficient kan, kun je dus alle statements
hashen, bijhouden etc. Als je merkt dat een statement voor de
2e keer wordt uitgevoerd (bijv.), dan kun je hem preparen,
met alle constanten als parameters. Als zo'n statment dan nog 
een keer wordt uitgevoerd (3e keer en verder) kun je binden
met de constanten en snel executeren zonder enige SQL vertaling,
SQL optimalisatie, MIL generatie, MIL parsing en MIL functieresolutie.

Kan misschien ook anders, hangt van de impl. van de SQL parser
af. je wel echt parsen, zodat je constanten en hun types kunt
herkennen. maar je moet zo min mogelijk extra doen, om geen tijd
te verliezen. Misschien onmogelijkmakend tegenstrijdig... een uitdaging!

O ja: het aantal constanten mag niet groter zijn dan MAXPARAMS..
      constanten daarna dus letterlijk beschouwen.

als (b) goed genoeg werkt, kun je (a) achterwege laten..


PREPARE + 1e BIND
=================

1) genereer een proc sqlX(a,b,...) met daarin de query als mil block

emit dus aan het begin proc(..type + varnaam voor alle params...) : void {
en een } aan het eind.  voor de rest niets anders doen dan normaal.

2) interpret_str die tekst zoals te doen gebruikelijk (de proc bestaat dan)

3) maak dan zelf een YYSTREE 

YYSTREE milnode(int tok, int tpe, ptr valp) {
	YYSTREE res = yynode(tok);
	VALset(&res->yyval, tpe, valp);
	return res;
}
	
procnode = milnode(TOK_FUNCTION, TYPE_str, "sqlX");

met als yysons alle parameters
for(i=0; i<n; i++)
	yyexpand(procnode, milnode(TOK_CONSTANT, tpe[i], valp[i]))

4) maak ook een stack met reuse aan (stk is je basis stk)

procstk = CNTXTreserve(stk);
CNTXTuse(procstk);
monet_cntxt[procstk].reuse = TRUE;

5) executeer proc voor de eerste keer

interpret(procstk, procnode, ret);


DUS de state die je bijhoudt per prepared statement is: 

	(int procstk, YYSTREE procnode)



volgende BINDs
==============

6) zet de nieuwe waarden in de valrecords 

ValPtr argv = (ValPtr) procnode->yysons[1]->val.pval;
for(i=1; i<=n; i++)
	VALset(argv+i, tpe[i], valp[i]);

(het is waarschijnlijk sneller om hier ATOMfromstr() te gebuiken, 
 en direct de area in argv[i] is te hergebruiken. Dat gaat ook goed
 met val.sval, gezien de herallocatie-semantiek van ATOMfromstr.
 Dan hoef je ook geen VALset meer te doen).

7) executeer de *expansie*

interpret(procstk, procnode->yysons[1]->yysons[0], ret);

cleanup
=======

monet_cntxt[procstk].reuse = FALSE;
CNTXTfree1(procstk);
interpret_str(stk, "undef sqlX;", ret);
