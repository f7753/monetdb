@f sqlserver
@a N.J. Nes
@* 

@m
.MODULE sqlserver;
	.USE ascii_io, streams;

	.PRELUDE = sqlserver_prelude;

	.ATOM mvc = ptr;
	.END;
	.ATOM sql_schema = ptr;
	.END;
	.ATOM sql_table = ptr;
	.END;
	.ATOM sql_column = ptr;
	.END;
	.ATOM sql_key = ptr;
	.END;
	
	.BUILTIN sqlclient( mvc m,  Stream in, Stream out ) = 
		sqlclient;
		"parse the next sql command and convert this to mil code"

	.COMMAND parser_init( int debug ) = parser_init_wrap; 
		"initialize the global structures for the sql parser such as keywords/types/functions/aggrs"

	.COMMAND parser_exit() = parser_exit_wrap; 
		"cleanup the global structures"

	.COMMAND sql_type(str sqlname, int digits, int scale, str name ) = 
		sql_type_wrap; "Add a new sql type"

	.COMMAND sql_aggr(str name, str imp, str atp, str rtp) = 
		sql_aggr_wrap; "Add a new sql aggregate function"

	.COMMAND sql_func(str name, str imp, str tp1, str tp2, str tp3, str rtp)
		= sql_func_wrap; "Add a new sql function"

	.COMMAND mvc_init(int debug, str dir_name) = mvc_init_wrap; 
		"create the global catalog"

	.COMMAND mvc_exit() = mvc_exit_wrap; 
		"cleanup the global catalog"

	.COMMAND mvc_create( int debug ) : mvc = mvc_create_wrap;
		"Create multi version catalog"

	.COMMAND mvc_destroy( mvc m ) = mvc_destroy_wrap;
		"Destroy multi version catalog"

	.COMMAND mvc_login( mvc m, str user, str passwd ) : str 
		= mvc_login_wrap; "database login"

	.COMMAND mvc_admin_login( mvc m ) : str 
		= mvc_admin_login_wrap; "an initial passwordless login by the admin is allowed too setup the initial users (only once)"

	.COMMAND mvc_status( mvc m ) : int 
		= mvc_status_wrap; "return the status of the last mvc operation"

	.COMMAND mvc_type( mvc m ) : int 
		= mvc_type_wrap; "return the type of the last mvc operation"

	.COMMAND mvc_commit( mvc m, int chain, str name ) : int = 
		mvc_commit_wrap; "Commit transaction/savepoint and chain"

	.COMMAND mvc_rollback( mvc m, int chain, str name ) : int = 
		mvc_rollback_wrap; "Rollback transaction/savepoint and chain"

	.COMMAND mvc_release( mvc m, str name ) : int = 
		mvc_release_wrap; "Release the savepoint"

	.COMMAND mvc_set_iso_level( mvc m, int level ) : int = 
		mvc_set_iso_level_wrap; "Change the isolation level"

	.COMMAND mvc_bind( mvc c, str sname, str tname, str cname, int access ) : 
		BAT[any::1,any::2] = 
		mvc_bind_wrap; "Bind the bat, tname.cname"

	.COMMAND mvc_bind_ubat( mvc c, str sname, str tname, str cname, int acess ) : 
		BAT[any::1,any::2] = 
		mvc_bind_ubat_wrap; "Bind bat with the updates to tname.cname"

	.COMMAND mvc_bind_obat( mvc c, str sname, str tname, int access ) : 
		BAT[any::1,any::2] = 
		mvc_bind_obat_wrap; "Bind the oid bat, tname.OID"

	.COMMAND mvc_bind_dbat( mvc c, str sname, str tname, int access ) : 
		BAT[any::1,any::2] = mvc_bind_dbat_wrap; 
		"Bind the table deletes bat, tname.deletes"

	.COMMAND mvc_bind_schema( mvc c, str sname ) : sql_schema = 
		mvc_bind_schema_wrap; "Bind schema, sname"

	.COMMAND mvc_bind_table( mvc c, sql_schema s, str tname ) : sql_table = 
		mvc_bind_table_wrap; "Bind table, s.tname"

	.COMMAND mvc_bind_column( mvc c, sql_table t, str cname ) : sql_column = 
		mvc_bind_column_wrap; "Bind column, t.cname"

	.COMMAND mvc_bind_key( mvc c, sql_table t, str kname ) : sql_key = 
		mvc_bind_key_wrap; "Bind table key with name, kname"

	.COMMAND mvc_drop_schema( mvc c, str name ) = mvc_drop_schema_wrap;
		"Drop schema"

	.COMMAND mvc_create_schema( mvc c, str name, str auth) : sql_schema = 
		mvc_create_schema_wrap; "Create schema"

	.COMMAND mvc_drop_table( mvc c, sql_schema s, str name, bit cascade ) = 
		mvc_drop_table_wrap; "Drop table"

	.COMMAND mvc_create_table( mvc c, sql_schema s, str name, int type) : 
		sql_table = mvc_create_table_wrap; "Create table"

	.COMMAND mvc_create_view( mvc c, sql_schema s, str name, str sql) :
		sql_table = mvc_create_view_wrap; "Create view"

	.COMMAND mvc_drop_column( mvc c, sql_table t, str name ) = 
		mvc_drop_column_wrap; "Drop column"

	.COMMAND mvc_create_column( mvc m, sql_table t, str name, str type, int type_digits, int type_scale, int seqnr ) : sql_column = mvc_create_column_wrap; "Create column"

	.COMMAND mvc_null( mvc m, sql_column col, int flag ) : 
		sql_column = mvc_null_wrap; "Set column null or not"

	.COMMAND mvc_default( mvc m, sql_column col, str val ) :
		sql_column = mvc_default_wrap; "Set column default value"

	.COMMAND mvc_create_key( mvc m, str sname, str tname, str name, int kt, BAT[str,int] columns, sql_key fk ) :
		sql_key = mvc_create_key_wrap; "Create a table key"

	.COMMAND mvc_export(Stream s, BAT order, BAT bats, str sep, str rsep) =
		mvc_export_wrap; "export a table (in order) to stream s with the given tuple and record seperators (sep/rsep)"

	.COMMAND mvc_import_table( mvc c, Stream s, str tname, 
					str sep, str rsep, int nr) : 
		int = mvc_import_table_wrap; 
		"import a table from stream s with the given tuple and record seperators (sep/rsep)"

@+ void bats
To prevent void bats to convert to oid bats we need overloaded insert and
replace commands. 
@m
	.COMMAND renumber( BAT[oid,any::1] b1, oid o ) : BAT[oid,any::1] = bat_renumber;
		"renumber the bat using the offset o"

 	.COMMAND insert( BAT[void,any::1] i, BAT[void,any::1] u ) : BAT[void,any::1] = bat_append_void_bat_wrap; "append the content of u to i"

 	.COMMAND insert( BAT[void,any::1] i, BAT[oid,any::1] u ) : BAT[void,any::1] = bat_append_oid_bat_wrap; "append the content of u to i"

	.COMMAND replace( BAT[void,any::1] o, BAT[oid,any::1] d ) : BAT[void,any::1] = bat_replace_oid_bat_wrap; "inplace replace values on the given locations"

	.LOAD
		# dirty hack for comments ask menzo
		PROC renameFUNC(str OLD,str NEW) : void := {
 			VAR funcs := monet_fcn_nme.select(OLD);
 			funcs := [funcs~NEW];
 			monet_fcn_nme.replace(funcs);
 			monet_fcntbl.reverse.replace(funcs);
		}
	.END;

.END sqlserver;

@h
#ifndef _SQLSERVER_H_
#define _SQLSERVER_H_

#include <streams.h>
#include <monet_context.h>
#include "mvc.h"
#include "sqlserver.proto.h"

#endif /*_SQLSERVER_H_*/

@c
#include "sqlserver.h"
#include <statement.h>
#include <sqlexecute.h>
#include <mem.h>
#include <context.h>
#include <kernel.h>

//#include  <sys/types.h> 

#include <monet_tbl.h>

void sqlserver_prelude(void) {
	int mid = TBL_module_lookup("streams");
	ptr hdl = TBL_module_handle(mid);
	local_TYPE_Stream = (int*)DL_sym(hdl, "TYPE_Stream");

	mid = TBL_module_lookup("ascii_io");
	hdl = TBL_module_handle(mid);
	local_ASCIIoutput = (size_t (*)(BAT*, BAT*, BAT*, stream*))DL_sym(hdl, "ASCIIoutput");

	mid = TBL_module_lookup("ascii_io");
	hdl = TBL_module_handle(mid);
	local_ASCIIinput = (BAT* (*)(BAT*, BAT*, BAT*, bstream*, size_t))DL_sym(hdl, "ASCIIinput");
}

@= builtin_operand
{       int _k = interpret(stk, arg(lt, @1), res);
        if (_k < 0) {
                return _k;
        }
        @3 = VALconvert(@2, res, 0);
        if ((@3 == ILLEGALVALUE)  || (@2 == TYPE_bat && !@3)) {
                return handle_paramerror(res,@1,res->vtype,@2);
        }
}
@c

extern catalog *mvc_catalog_create( mvc *m, context *lc );

int sqlclient(Cntxt stk, YYSTREE lt, ValPtr res){
	buffer *bbuf = buffer_create( BUFSIZ );
	char buf[BUFSIZ];
	int err = 0;
	stmt *s = NULL;
	char *cmd = NULL;
	char *errbuf = GDKmalloc(GDKMAXERRLEN);

	mvc **M, *m;
	stream **In, *in, **Out, *out, *ws;
	context *lc;

  	if (lt->cnt != 3) {
        	return handle_argerror(res, lt->cnt, 3);
  	}
  	@:builtin_operand(0,TYPE_mvc,M)@
	m = *M;
  	@:builtin_operand(1,*local_TYPE_Stream,In)@
	in = *In;
  	@:builtin_operand(2,*local_TYPE_Stream,Out)@
	out = *Out;

	lc = NEW(context);
	ws = buffer_wastream( bbuf, "SQLserver" );
	sql_init_context( lc, ws, m->debug, default_catalog_create() );
	mvc_catalog_create( m, lc );

	GDKsetbuf(errbuf);

	while(lc->cur != EOF ){
		s = sqlnext(lc, in, &err);
		if (err){ /* output error */
			stream_writeInt( out, 0 );
			stream_writeInt( out, 0 );
			stream_writeInt( out, -1 );
			out->write( out, lc->errstr, strlen(lc->errstr), 1 );
			out->flush( out );
		} else if (s){
	    		int nr = 1;
	    		stmt_dump( s, &nr, lc );

			cmd = buffer_get_buf(bbuf);
	    		lc->out->flush( lc->out );

			if (lc->debug&64){
				stream_writeInt( out, 0 );
				stream_writeInt( out, QDEBUG );
				stream_writeInt( out, lc->debug );
				out->write( out, cmd, strlen(cmd), 1 );
				out->flush( out );
			} else {

			    if (s && s->op1.stval->type == st_copyfrom &&
				!stmt_copyfrom_files(s)){
				/*ask_for_data();*/
				stream_writeInt( out, 0 );
				stream_writeInt( out, QDATA );
				stream_writeInt( out, 0 );
				out->flush( out );
			    }
			
			    {
				int i;
				ssize_t status;
				ValRecord res;
				ptr val = &res.val.ival;
        			res.vtype = TYPE_void; 
				i = interpret_str( stk, cmd, &res);
				/*TODO: we need to cleanup val */

				if (i < 0){
					char *errstr = "Mil error";
					char *buf = GDKerrbuf;
					stream_writeInt( out, 0 );
					stream_writeInt( out, mvc_type(m) );
					stream_writeInt( out, i );
					out->write( out, errstr, strlen(errstr), 1 );
					out->write( out, buf, strlen(buf), 1 );
					buf[0] = 0; /* reset error buf */
					out->flush( out );
				} else if ((status=mvc_status(m)) < 0){
					char *errstr = "Error in result";
					stream_writeInt( out, 0 );
					stream_writeInt( out, mvc_type(m) );
					stream_writeInt( out, status );
					out->write( out, errstr, strlen(errstr), 1 );
					out->flush( out );
				} else if (s->type != st_output) {
					stream_writeInt( out, 0 );
					stream_writeInt( out, mvc_type(m) );
					stream_writeInt( out, status );
					out->flush( out );
				}
			    }
			} 
			/* BEWARE to use free instead of _DELETE
 			 * as the stream library is build with out libbat 
 			 * ie. it cannot use GDKmalloc can be used */
			if (cmd) free(cmd);
		}
		if (s) stmt_destroy(s);
	}
	mvc_destroy(m);
	sql_exit_context( lc );
	return GDK_SUCCEED;
}

int mvc_init_wrap( int* debug, str dir_name){
	mvc_init(*debug, dir_name);
	return GDK_SUCCEED;
}
int mvc_exit_wrap( ){
	mvc_exit();
	return GDK_SUCCEED;
}

int parser_init_wrap( int* debug){
	parser_init(*debug );
	return GDK_SUCCEED;
}
int parser_exit_wrap( ){
	parser_exit();
	return GDK_SUCCEED;
}
int sql_type_wrap( str sqlname, int *digits, int *scale, str name ){
	(void)sql_create_type( sqlname, *digits, *scale, name );
	return GDK_SUCCEED;
}
int sql_aggr_wrap( str name, str imp, str atp, str rtp){
	(void)sql_create_aggr( name, imp, atp, rtp );
	return GDK_SUCCEED;
}
int sql_func_wrap( str name, str imp, str tp1, str tp2, str tp3, str rtp){
	(void)sql_create_func( name, imp, tp1, tp2, tp3, rtp );
	return GDK_SUCCEED;
}

int mvc_create_wrap( mvc *res, int *debug ){
	*(mvc**)res = mvc_create( *debug );
	return GDK_SUCCEED;
}

int mvc_destroy_wrap( mvc *c ){
	mvc_destroy( *(mvc**)c );
	return GDK_SUCCEED;
}

int mvc_login_wrap( str *r, mvc *c, str user, str passwd  ){
	*r = mvc_login( *(mvc**)c, user, passwd );
	if (*r == NULL)
		*r = _strdup("");
	return GDK_SUCCEED;
}

int mvc_admin_login_wrap( str *r, mvc *c ){
	*r = mvc_admin_login( *(mvc**)c );
	if (*r == NULL)
		*r = _strdup("");
	return GDK_SUCCEED;
}

int mvc_status_wrap( int* res, mvc* m ){
	*res = mvc_status( *(mvc**)m );
	return GDK_SUCCEED;
}

int mvc_type_wrap( int* res, mvc* m ){
	*res = mvc_type( *(mvc**)m );
	return GDK_SUCCEED;
}


int mvc_commit_wrap( int* res, mvc* m, int* chain, str name){
	*res = mvc_commit( *(mvc**)m, *chain, name );
	return GDK_SUCCEED;
}

int mvc_rollback_wrap( int *res, mvc *m, int *chain, str name ){
	*res = mvc_rollback( *(mvc**)m, *chain, name );
	return GDK_SUCCEED;
}

int mvc_release_wrap( int *res, mvc *m, str name ){
	*res = mvc_release( *(mvc**)m, name );
	return GDK_SUCCEED;
}

int mvc_set_iso_level_wrap( int *res, mvc *m, int *level ){
	*res = mvc_set_iso_level( *(mvc**)m, *level );
	return GDK_SUCCEED;
}

int mvc_bind_wrap( BAT** res, mvc* c, str sname, str tname, str cname, int *access){
	*res = mvc_bind( *(mvc**)c, sname, tname, cname, *access );
	if (*res){
		return GDK_SUCCEED;
	}
	return GDK_FAIL;
}

int mvc_bind_ubat_wrap( BAT** res, mvc* c, str sname, str tname, str cname, int *access ){
	*res = mvc_bind_ubat( *(mvc**)c, sname, tname, cname, *access );
	if (*res){
		return GDK_SUCCEED;
	}
	return GDK_FAIL;
}

int mvc_bind_obat_wrap( BAT** res, mvc* c, str sname, str tname, int *access ){
	*res = mvc_bind_obat( *(mvc**)c, sname, tname, *access );
	if (*res){
		return GDK_SUCCEED;
	}
	return GDK_FAIL;
}

int mvc_bind_dbat_wrap( BAT** res, mvc* c, str sname, str tname, int *access ){
	*res = mvc_bind_dbat( *(mvc**)c, sname, tname, *access );
	if (*res){
		return GDK_SUCCEED;
	}
	return GDK_FAIL;
}


int mvc_bind_schema_wrap( sql_schema* res, mvc* c, str sname){
	*(sql_schema**)res = mvc_bind_schema( *(mvc**)c, sname );
	return GDK_SUCCEED;
}

int mvc_bind_table_wrap( sql_table* res, mvc* c, sql_schema *s, str tname){
	*(sql_table**)res = mvc_bind_table( *(mvc**)c, *(sql_schema**)s, tname);
	return GDK_SUCCEED;
}

int mvc_bind_column_wrap( sql_column* res, mvc* c, sql_table *t, str col){
	*(sql_column**)res = mvc_bind_column( *(mvc**)c, *(sql_table**)t, col);
	return GDK_SUCCEED;
}

int mvc_bind_key_wrap( sql_key* res, mvc* c, sql_table *t, str name ){
	*(sql_key**)res = mvc_bind_key( *(mvc**)c, *(sql_table**)t, name);
	return GDK_SUCCEED;
}


int mvc_create_schema_wrap( sql_schema *s, mvc* c, str name, str auth){
	*(sql_schema**)s = mvc_create_schema( *(mvc**)c, name, auth );
	return GDK_SUCCEED;
}

int mvc_drop_schema_wrap( mvc* c, str name){
	mvc_drop_schema( *(mvc**)c, name );
	return GDK_SUCCEED;
}

int mvc_create_table_wrap( sql_table *res, mvc* c, sql_schema *s, str name, int* type){
	*(sql_table**)res = mvc_create_table( *(mvc**)c, *(sql_schema**)s, name, *type );
	return GDK_SUCCEED;
}

int mvc_create_view_wrap( sql_table *res, mvc* c, sql_schema *s, str name, str sql){
	*(sql_table**)res = mvc_create_view( *(mvc**)c, *(sql_schema**)s, name, sql );
	return GDK_SUCCEED;
}

int mvc_drop_table_wrap( mvc* c, sql_schema *s, str name, bit* cascade){
	mvc_drop_table( *(mvc**)c, *(sql_schema**)s, name, *cascade );
	return GDK_SUCCEED;
}


int mvc_create_column_wrap( sql_column* res, mvc* c, sql_table *t, 
		str name, str type, int *ts, int *td, int* seqnr){
	*(sql_column**)res = 
	  mvc_create_column( *(mvc**)c, *(sql_table**)t, name, type, *ts, *td, *seqnr );
	return GDK_SUCCEED;
}

int mvc_drop_column_wrap( mvc* c, sql_table *t, str name){
	mvc_drop_column( *(mvc**)c, *(sql_table**)t, name );
	return GDK_SUCCEED;
}

int mvc_null_wrap( sql_column* res, mvc* c, sql_column* col, int *flag){
	*(sql_column**)res = mvc_null( *(mvc**)c, *(sql_column**)col, *flag );
	return GDK_SUCCEED;
}

int mvc_default_wrap( sql_column* res, mvc* c, sql_column* col, str val){
	*(sql_column**)res = mvc_default( *(mvc**)c, *(sql_column**)col, val );
	return GDK_SUCCEED;
}

int mvc_create_key_wrap( sql_key* res, mvc* c, str sname, str tname, str name, int *kt, BAT *columns, sql_key *fk){
	if (*(ptr*)fk == ptr_nil){
		*(sql_key**)res = mvc_create_key( *(mvc**)c, sname, tname, name, *kt, columns, NULL);
	} else {
		*(sql_key**)res = mvc_create_key( *(mvc**)c, sname, tname, name, *kt, columns, *(sql_key**)fk);
	}
	return GDK_SUCCEED;
}

int mvc_export_wrap( Stream *s, BAT *order, BAT *bats, str sep, str rsep ){
	mvc_export( *(stream**)s, order, bats, sep, rsep );
	return GDK_SUCCEED;
}

int mvc_import_table_wrap( int *res, mvc *c, Stream *s, str tname , str sep, str rsep, int *sz ){
	*res = mvc_import_table( *(mvc**)c, *(stream**)s, tname, sep, rsep, *sz );
	if (*res < 0)
		return GDK_FAIL;
	return GDK_SUCCEED;
}

int bat_renumber( BAT **r, BAT *in, oid *O )
{
	oid o = *O;
	if (BAThdense(in)){
		BATseqbase(in, in->hseqbase + o);
	} else {
		oid *n = (oid*)BUNhead(in,BUNfirst(in)), *e = n + BATcount(in);
		while(n<e){
			*n += o;
		}
	}
	BBPfix(in->batCacheid);
	*r = in;
	return GDK_SUCCEED;
}

int bat_append_void_bat_wrap( BAT **res, BAT *i, BAT *u )
{
	*res = i;
	void_append_bat( i, u );
	BBPfix(i->batCacheid);
	return GDK_SUCCEED;
}

int bat_append_oid_bat_wrap( BAT **res, BAT *i, BAT *u )
{
	*res = i;
	void_insert_bat( i, u );
	BBPfix(i->batCacheid);
	return GDK_SUCCEED;
}

int bat_replace_oid_bat_wrap( BAT **res, BAT *o, BAT *d )
{
	*res = o;
	void_replace_bat( o, d );
	BBPfix(o->batCacheid);
	return GDK_SUCCEED;
}


@mil

module(str);
module(uchr);
module(alarm);
module(xtables);
module(aggrX3);
module(monettime);
module(sqlserver);
module(mmath);
module(decimal);
module(mapi); # mapi_listen 

var sql_debug := int(monet_environment.find("sql_debug"));
parser_init(sql_debug);

sql_type("OID", 0, 0, 	  	"oid");
sql_type("BOOL", 0, 0,	  	"bit");
sql_type("BOOLEAN", 0, 0,	"bit");

# cannot map char(1) to chr as utf8 may use up to 4 chr's per char(1)
#sql_type("CHAR", 1, 0, 	  	"chr");
sql_type("CHAR", 0, 0,  	"str"); # defined as a fixed length string 
sql_type("CHARACTER", 0, 0, 	"str");
#sql_type("VARCHAR", 1, 0, 	"chr");
sql_type("VARCHAR", 0, 0, 	"str");

sql_type("TEXT", 0, 0, 		"str");
sql_type("TINYTEXT", 0, 0, 	"str");
sql_type("STRING", 0, 0, 	"str");

# *INT(n) n <= 2 -> TINYINT
#	  n <= 5 -> SMALLINT
#	  n <= 9 -> MEDIUMINT
#	  n <= 19 -> BIGINT

sql_type("UBYTE", 2, 0,		"uchr");
sql_type("TINYINT", 2, 0, 	"sht"); # sht as sum(uchr) isn't implemented 
sql_type("SMALLINT", 5, 0,	"sht");
sql_type("MEDIUMINT", 9, 0,	"int");
sql_type("INTEGER", 9, 0,	"int");
sql_type("NUMBER", 9, 0,	"int");
sql_type("BIGINT", 19, 0,	"lng");

#sql_type("INT", 2, 0, 		"uchr"); 
sql_type("INT", 5, 0,		"sht");
sql_type("INT", 9, 0,		"int");
sql_type("INT", 19, 0,		"lng");

# float(n) (n indicates precision of atleast n digits)
# ie n <= 23 -> flt
#    n <= 51 -> dbl
#    n <= 62 -> long long dbl (with -ieee) (not supported)
# this requires a type definition

sql_type("FLOAT", 23, 0, 	"flt");
sql_type("FLOAT", 51, 0, 	"dbl");

sql_type("DOUBLE", 51, 0, 	"dbl");
sql_type("REAL", 51, 0, 	"dbl");

# decimal(n) == int(n)

#sql_type("DECIMAL", 2, 0, 		"uchr"); 
sql_type("DECIMAL", 5, 0,		"sht");
sql_type("DECIMAL", 9, 0,		"int");
sql_type("DECIMAL", 19, 0,		"lng");

# decimal(d,s) (d indicates nr digits, s scale indicates nr of digits after the dot .)
#sql_type("DECIMAL", 51, 50, "decimal");		# (fixed precision) requires decimal module

sql_type("DECIMAL", 23, 22,		"flt");
sql_type("DECIMAL", 51, 50,		"dbl");

#sql_type("NUMERIC", 2, 0, 		"uchr"); 
sql_type("NUMERIC", 5, 0,		"sht");
sql_type("NUMERIC", 9, 0,		"int");
sql_type("NUMERIC", 19, 0,		"lng");

sql_type("NUMERIC", 23, 22,		"flt");
sql_type("NUMERIC", 51, 50,		"dbl");


# Date etc

sql_type("MONTH_INTERVAL", 0, 0, 	"int");
sql_type("SEC_INTERVAL", 0, 0, 		"int");
sql_type("DATE", 0, 0, 			"date");
sql_type("TIME", 0, 0, 			"time");
sql_type("DATETIME", 0, 0, 		"datetime");
sql_type("TIMESTAMP", 0, 0, 		"timestamp");

var strings := new(str,str);
strings.insert("CHAR", 		"chr");
strings.insert("VARCHAR", 	"str");

var numerical := new(str,str); # head is the sum result type 
numerical.insert("int", 	"uchr"); 
numerical.insert("int", 	"sht");
numerical.insert("lng", 	"int");
numerical.insert("lng", 	"lng");
numerical.insert("dbl", 	"dbl");

var floats := new(str,str);	# head is the sum result type
floats.insert("dbl", 		"flt");
floats.insert("dbl", 		"dbl");
numerical.insert(floats);

var dates := new(str,str);
dates.insert("MONTH_INTERVAL", "int");
dates.insert("SEC_INTERVAL", "int");
dates.insert("DATE", "date");
dates.insert("TIME", "time");
dates.insert("TIMESTAMP", "timestamp");

var type_sql := bat(str,str);
type_sql.insert(strings);
type_sql.insert(numerical);
type_sql.insert(dates);

type_sql@batloop(){ sql_aggr( "min", "min", $t, $t ); }
type_sql@batloop(){ sql_aggr( "max", "max", $t, $t ); }
# sum has special output types
numerical@batloop(){ sql_aggr( "sum", "sum", $t, $h ); }
# avg only outputs doubles
numerical@batloop(){ sql_aggr( "avg", "avg", $t, "dbl" ); }
sql_aggr( "count", "count", "", "int" ); 

numerical@batloop(){ sql_func( "sql_sub", "-", $t, $t, "", $t ); }
numerical@batloop(){ sql_func( "sql_add", "+", $t, $t, "", $t ); }
numerical@batloop(){ sql_func( "sql_mul", "*", $t, $t, "", $t ); }
numerical@batloop(){ sql_func( "sql_div", "/", $t, $t, "", $t ); }
numerical@batloop(){ sql_func( "sql_max", "max", $t, $t, "", $t ); }
numerical@batloop(){ sql_func( "sql_min", "min", $t, $t, "", $t ); }
numerical@batloop(){ sql_func( "sql_neg", "-", $t, "", "", $t ); }

numerical@batloop(){ 
	var hd := $t; 
	numerical@batloop(){ 
		if ($t != hd){
		    sql_func( "convert", $t, hd, "", "", $t );
		}
	}
}

strings@batloop(){ 
	var hd := $t; 
	strings@batloop(){ 
		if ($t != hd){
		    sql_func( "convert", $t, hd, "", "", $t );
		}
	}
}

strings@batloop(){ 
	var hd := $t; 
	numerical@batloop(){ 
		sql_func( "convert", $t, hd, "", "", $t );
	}
}

floats@batloop(){ 
	sql_func( "floor", "floor", $t, "", "", $t ); 
	sql_func( "ceil", "ceil", $t, "", "", $t ); 
	sql_func( "sin", "sin", $t, "", "", $t ); 
	sql_func( "cos", "cos", $t, "", "", $t ); 
	sql_func( "tan", "tan", $t, "", "", $t ); 
	sql_func( "asin", "asin", $t, "", "", $t ); 
	sql_func( "acos", "acos", $t, "", "", $t ); 
	sql_func( "atan", "atan", $t, "", "", $t ); 
	sql_func( "sinh", "sinh", $t, "", "", $t ); 
	sql_func( "cosh", "cosh", $t, "", "", $t ); 
	sql_func( "tanh", "tanh", $t, "", "", $t ); 
	sql_func( "sqrt", "sqrt", $t, "", "", $t ); 
	sql_func( "exp", "exp", $t, "", "", $t ); 
	sql_func( "log", "log", $t, "", "", $t ); 
	sql_func( "log10", "log10", $t, "", "", $t ); 
}

sql_func( "current_date", "current_date", "", "", "" , "date" );
sql_func( "current_time", "current_time", "", "", "" , "time" );
sql_func( "current_timestamp", "current_timestamp", "", "", "" , "timestamp" );

sql_func( "sql_sub", "date_sub_sec_interval", "date", "int", "", "date");
sql_func( "sql_sub", "date_sub_month_interval", "date", "int", "", "date");

sql_func( "sql_add", "date_add_sec_interval", "date", "int", "", "date");
sql_func( "sql_add", "addmonths", "date", "int", "", "date");

sql_func( ">", ">", "date", "date", "", "bit");
sql_func( "<", "<", "date", "date", "", "bit");

sql_func( "year", "year", "date", "", "", "int");
sql_func( "month", "month", "date", "", "", "int");

sql_func( "substring", "string", "str", "int", "int", "str");
sql_func( "strconcat", "+", "str", "str", "", "str");

proc sql_add(x, y):= return x + y;
proc sql_sub(x, y):= return x - y;
proc sql_mul(x, y):= return x * y;
proc sql_div(x, y):= return x / y;
proc sql_neg(val):= return -1 * val;

proc floor(flt f):= return flt(floor(dbl(f)));
proc ceil(flt f):= return flt(ceil(dbl(f)));
proc sin(flt f):= return flt(sin(dbl(f)));
proc cos(flt f):= return flt(cos(dbl(f)));
proc tan(flt f):= return flt(tan(dbl(f)));
proc asin(flt f):= return flt(asin(dbl(f)));
proc acos(flt f):= return flt(acos(dbl(f)));
proc atan(flt f):= return flt(atan(dbl(f)));
proc sinh(flt f):= return flt(sinh(dbl(f)));
proc cosh(flt f):= return flt(cosh(dbl(f)));
proc tanh(flt f):= return flt(tanh(dbl(f)));
proc sqrt(flt f):= return flt(sqrt(dbl(f)));
proc exp(flt f):= return flt(exp(dbl(f)));
proc log(flt f):= return flt(log(dbl(f)));
proc log10(flt f):= return flt(log10(dbl(f)));

proc current_timestamp() { return timestamp(epoch()); }
proc current_date() { return date(current_timestamp()); }
proc current_time() { return daytime(current_timestamp()); }

var dbname := monet_environment.find("gdk_dbname");
var dbfarm := monet_environment.find("gdk_dbfarm");
mvc_init(sql_debug,dbfarm + "/" + dbname + "/log");

const QPARSE := 1;
const QTABLE := 2;
const QUPDATE := 3;
const QDATA := 4;
const QHEADER := 5;
const QDEBUG := 6; 

const RDONLY := 0;
const INS := 1;
const DEL := 2;
const UPD := 3;
const UPDATES := 4;
const DELETES := 5;

proc mvc_bind_( m, schema, Table, column, write_access ){
	res := mvc_bind(m, schema,Table, column, write_access);
	if (write_access > 0){
		res := res.access(BAT_WRITE);
	} 
	return res;
}

proc mvc_bind_dbat_( m, schema, Table, write_access ){
	res := mvc_bind_dbat(m, schema, Table, write_access);
	if (write_access > 0){
		res := res.access(BAT_WRITE);
	} 
	return res;
}

proc mvc_create_role( m, auth, grantor ) {
	auth_id := mvc_bind_( m, "sys", "auths", "id", 1);
	auth_name := mvc_bind_( m, "sys", "auths", "name", 1);
	auth_grantor := mvc_bind_( m, "sys", "auths", "grantor", 1);
	auth_priv := mvc_bind_( m, "sys", "auths", "privileges", 1);
	
	if (auth_name.reverse.exist(auth)) {
		return false;
	}
	if (auth_id.count() > 0)
		auth_id.insert(nil, auth_id.max()+1);
	else
		auth_id.insert(nil, 0);
	auth_name.insert(nil, auth);
	auth_grantor.insert(nil, grantor);
	auth_priv.insert(nil,0); # all privileges are off 
	#print(auth_id,auth_name,auth_grantor,auth_priv);
	return true;
} 
proc mvc_drop_role( m, auth ) {
	auth_id := mvc_bind_( m, "sys", "auths", "id", 1);
	auth_name := mvc_bind_( m, "sys", "auths", "name", 1);
	auth_grantor := mvc_bind_( m, "sys", "auths", "grantor", 1);
	auth_priv := mvc_bind_( m, "sys", "auths", "privileges", 1);
	D_auth := mvc_bind_dbat_( m, "sys", "auths", 1);
	
	if (not(auth_name.reverse.exist(auth))) {
		return;
	}
	id := auth_name.reverse.find(auth);
	#print(id);
	auth_id.replace(id, int(nil));
	auth_name.replace(id, str(nil));
	auth_grantor.replace(id, int(nil));
	auth_priv.replace(id, int(nil));
	#print(auth_id,auth_name,auth_grantor,auth_priv);
	D_auth.insert(nil,id);
} 
proc mvc_grant_role( m, grantee, auth ) {
	auth_ids := mvc_bind_( m, "sys", "auths", "id", 1);
	auth_name := mvc_bind_( m, "sys", "auths", "id", 1);
	login_id := mvc_bind_( m, "sys", "user_role", "login_id", 1);
	role_id := mvc_bind_( m, "sys", "user_role", "role_id", 1);

	if (not(auth_name.reverse.exist(grantee)) or
	    not(auth_name.reverse.exist(auth))) {
		return;
	}
	auth_id := auth_ids.find(auth_name.reverse.find(auth));
	grantee_id := auth_ids.find(auth_name.reverse.find(grantee));
	
	login_id.insert(nil,grantee_id);
	role_id.insert(nil,auth_id);
} 

proc mvc_revoke_role( m, grantee, auth ) {
	auth_ids := mvc_bind_( m, "sys", "auths", "id", 1);
	auth_name := mvc_bind_( m, "sys", "auths", "id", 1);
	login_id := mvc_bind_( m, "sys", "user_role", "login_id", 1);
	role_id := mvc_bind_( m, "sys", "user_role", "role_id", 1);
	D_user_role := mvc_bind_dbat_( m, "sys", "user_role", 1);

	if (not(auth_name.reverse.exist(grantee)) or 
	    not(auth_name.reverse.exist(auth))) {
		return;
	}
	auth_id := auth_ids.find(auth_name.reverse.find(auth));
	grantee_id := auth_ids.find(auth_name.reverse.find(grantee));
	
	role := role_id.select(role_id);
	logins := login_id.semijoin(role);
	if (not(logins.reverse.exist(grantee_id)))
		return;
	id := logins.reverse.find(grantee_id);
	#print(id);
	login_id.replace(id,int(nil));
	role_id.replace(id,int(nil));
	D_user_role.insert(nil,id);
} 

proc mvc_create_user( m, user, passwd, fullname, schema_name, grantor ) {
	if (not(mvc_create_role( m, user, grantor )))
		return; 

	user_name := mvc_bind_( m, "sys", "users", "name", 1);
	user_passwd := mvc_bind_( m, "sys", "users", "passwd", 1);
	user_fullname := mvc_bind_( m, "sys", "users", "fullname", 1);
	user_dschema := mvc_bind_( m, "sys", "users", "default_schema", 1);

	schema_ids := mvc_bind_( m, "sys", "schemas", "id", 1);
	schema_names := mvc_bind_( m, "sys", "schemas", "name", 1);
	schema_id := schema_ids.find(schema_names.reverse.find(schema_name));

	user_name.insert(nil, user);
	user_passwd.insert(nil, passwd);
	user_fullname.insert(nil, fullname);
	user_dschema.insert(nil, schema_id);

	#print(user_name,user_passwd,user_fullname,user_dschema);
} 

proc mvc_drop_user( m, user) {
	user_name := mvc_bind_( m, "sys", "users", "name", 1);
	user_passwd := mvc_bind_( m, "sys", "users", "passwd", 1);
	user_fullname := mvc_bind_( m, "sys", "users", "fullname", 1);
	user_dschema := mvc_bind_( m, "sys", "users", "default_schema", 1);
	D_user := mvc_bind_dbat_( m, "sys", "users", 1);

	if (not(user_name.reverse.exist(user))) {
		return;
	}
	mvc_drop_role( m, user );

	id := user_name.reverse.find(user);
	#print(id);
	user_name.replace(id,str(nil));
	user_passwd.replace(id,str(nil));
	user_fullname.replace(id,str(nil));
	user_dschema.replace(id,int(nil));
	D_user.insert(nil,id);
}

proc initialize(int debug) {
	# change to sql statements !!
	var myc := mvc_create(debug);
	var schema := mvc_admin_login(myc);
	
	if (schema != ""){
		user_name := mvc_bind_( myc, schema, "users", "name", 1);
		if (user_name.count() = 0){
			mvc_create_user( myc, "monetdb", "monetdb", "MonetDB Admin", "sys", 0);
			# probably needs priv's too 
			mvc_commit( myc, 0, "");
		}
	}
	mvc_destroy( myc );
}

initialize(sql_debug);

proc {min}(val,grp, extent) := {
	return {min}(grp.reverse.join(val), extent);
}
proc {max}(val,grp,extent) := {
	return {max}(grp.reverse.join(val), extent);
}

proc default_val( myc, cid, val ) := {
	return mvc_default( myc, cid, str(val));
}

proc atom(val):= {
	return val;
}

proc date_sub_sec_interval( date d, int sec ) := {
	if (sec > 0){
		return d.adddays( -1 * sec/86400);
	}
	return d;
}

proc date_add_sec_interval( date d, int sec ) := {
	if (sec > 0){
		return d.adddays(sec/86400);
	}
	return d;
}

proc date_sub_month_interval( date d, int months ) := {
	return d.addmonths(months);
}

proc sep():= {
	return "\t";
}

proc load_seps( BAT[void,BAT] bats, str Sep, str Rsep ) : BAT[void,str] := {
	var seps := new(void,str); seps.seqbase(oid(0));
	var id := 0;
	var cnt := bats.count - 1;
	bats@batloop(){
		if (id != cnt) {
			seps.insert(nil,Sep);
		} else {
			seps.insert(nil,Rsep);
		}
		id += 1;
	}
	return seps;
}

proc oid_insert( b1, b2 ) := {
	var o := b1.reverse.max();
	return b1.insert(renumber(b2,o));
}

proc bat_name(b):= return str(b);
proc bat_type(b):= return monet_atomtbl.reverse.find(b.ttype());

proc input( mvc myc, Stream Input, str tname, BAT fnames, str Sep, str rSep, int sz ):={
	var s := Input;
	if (fnames.count() > 0){
		fnames@batloop(){
			f := iconv($t, "UTF-8", codeset());
			s := open_rastream(f);
			
			mvc_import_table( myc, s, tname, Sep, rSep, sz );
			stream_close(s);
		}
	} else {
		mvc_import_table( myc, s, tname, Sep, rSep, sz );
	}
}

proc ascii_io_output( bat Order, bat bats, Stream Output, str Sep ) : int := {
	var Max := bats.reverse.max();
	var seps := [ bats ~ const Sep];
	seps.access(BAT_WRITE);
	seps.replace(Max, "\n");

	seps := seps.reverse.mark(oid(0));
	bats := bats.reverse.mark(oid(0));
	return output( Order, seps.reverse, bats.reverse, Output );
}

proc output_header( Stream Output, int nrcols ) : void := {
	stream_writeInt( Output, 0 ); # write not done.
	stream_writeInt( Output, QHEADER ); # type TABLE.
	stream_writeInt( Output, nrcols ); # NR columns.
}

proc output_column( Stream Output, str name, str tpe ) : void := {
	var p := name + "," + tpe + "\n";
	stream_write( Output, p);
}

proc server_output( Stream Output, any Order, any val, ..any.. ) : void := {
	stream_writeInt( Output, 0 ); # write not done.
	stream_writeInt( Output, QTABLE ); # type TABLE.
	stream_writeInt( Output, 1 ); # NR records.

	cnt := $0;
	var p := str(val);
	if (type(val) = str)
		p := "\"" + val + "\"";
	var id := 3;
	while(id < cnt ){
		if (type($(id+1)) != str)
 			p := p + "\t" + str($(id+1));
		else
 			p := p + "\t\"" + str($(id+1)) + "\"";
		id :+= 1;
	}
 	p := p + "\n"; 
	stream_write( Output, p);
	stream_flush( Output );
}

proc server_output( Stream Output, bat[oid,any] Order,  ..bat[oid,any]..) : void := {
	var cnt := Order.count();
	stream_writeInt( Output, 0 ); # write not done.
	stream_writeInt( Output, QTABLE ); # type TABLE.
	stream_writeInt( Output, cnt ); # NR records.
	
	cnt := $0;
	var bats := new(oid,bat);
	var id := 0;
	while((id + 2) < cnt ){
		bats.insert(oid(id), $(id+3));
		id :+= 1;
	}
	ascii_io_output(Order, bats, Output, "\t");
	stream_flush( Output );
}

proc SQLclient_thread( int sock ):= {

	var Output := block_stream(
		socket_wstream( sock, sprintf("SQLserver-%d", sock) ));
	var Input := block_stream(
		socket_rstream( sock, sprintf("SQLserver-%d", sock) ));

	var cmd := stream_read( Input ); # api('api',debug);
	#print(cmd);

	if (cmd.startsWith("api") = false ){
		printf("Protocol error: %s\n", cmd);
		return -1;
	}

	cmd := string(cmd,search(cmd, '(') + 1);
	var api := string(cmd,0,search(cmd, ','));

	if ((api.startsWith("sql")) = false){
		printf("Protocol api error: %s\n", api);
		return -1;
	}

	cmd := string(cmd,search(cmd, ',') + 1);
	var debug := string(cmd,0,r_search(cmd, ')'));

	stream_write( Output, "login\n");
	stream_flush( Output );

	cmd := stream_read( Input ); # login(user,passwd);

	if (cmd.startsWith("login") = false ){
		printf("Protocol error: %s\n", cmd);
		return -1;
	}

	cmd := string(cmd,search(cmd, '(') + 1);
	var user := string(cmd,0,search(cmd, ','));
	cmd := string(cmd,search(cmd, ',') + 1);
	var passwd := string(cmd,0,r_search(cmd, ')'));

	var myc := mvc_create(int(debug));
	var schema := mvc_login( myc, user, passwd );
	var db := environment.find("gdk_dbname");

	stream_write( Output, db + "," + schema + "\n");
	stream_flush( Output );

	if (schema != ""){
		sqlclient( myc, Input, Output );
	}
	stream_close( Output );
	stream_close( Input );

	socket_close( sock );
	return 0;
}

proc SQLclient( int sock ) := {
	dsock := socket_dup(sock);
	#printf("# [ %d %d ]\n",sock, dsock);
	fork(SQLclient_thread(dsock));
}

proc new_quit() := {
	mvc_exit();
	eval("old_quit;");
}

proc get_sql_port() := {
	if (monet_environment.exist("sql_port")){
		return int(monet_environment.find("sql_port"));
	}
	var port := 45123;
	var sqlport := getenv("SQLPORT");
	if (length(sqlport) > 0){
		port := int(sqlport);
	}
	return port;
}

renameFUNC("quit", "old_quit");
renameFUNC("new_quit", "quit");

mapi_listen(get_sql_port(), 5, "SQLclient").fork();
