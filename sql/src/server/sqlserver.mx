@f sqlserver
@a N.J. Nes
@* 
The sqlserver module contains the complete wrapper interface for the
SQL client and the corresponding MIL runtime startup.
@m
.MODULE sqlserver;
	.USE ascii_io; 

	.ATOM mvc = ptr;
	.END;
	.ATOM sql_schema = ptr;
	.END;
	.ATOM sql_table = ptr;
	.END;
	.ATOM sql_column = ptr;
	.END;
	.ATOM sql_key = ptr;
	.END;
	
	.BUILTIN sqlclient( int sock ) = 
		sqlclient;
		"parse the next sql command and convert this to mil code"

	.COMMAND mvc_init(int debug) = mvc_init_wrap; 
		"create the global catalog"

	.COMMAND mvc_exit() = mvc_exit_wrap; 
		"cleanup the global catalog"

	.COMMAND mvc_create( int debug ) : mvc = mvc_create_wrap;
		"Create multi version catalog"

	.COMMAND mvc_destroy( mvc m ) = mvc_destroy_wrap;
		"Destroy multi version catalog"

	.COMMAND mvc_login( mvc m, str user, str passwd ) : str 
		= mvc_login_wrap; "database login"

	.COMMAND mvc_status( mvc m ) : int 
		= mvc_status_wrap; "return the status of the last mvc operation"

	.COMMAND mvc_type( mvc m ) : int 
		= mvc_type_wrap; "return the type of the last mvc operation"

	.COMMAND mvc_commit( mvc m, int chain, str name ) : int = 
		mvc_commit_wrap; "Commit transaction/savepoint and chain"

	.COMMAND mvc_rollback( mvc m, int chain, str name ) : int = 
		mvc_rollback_wrap; "Rollback transaction/savepoint and chain"

	.COMMAND mvc_release( mvc m, str name ) : int = 
		mvc_release_wrap; "Release the savepoint"

	.COMMAND mvc_set_iso_level( mvc m, int level ) : int = 
		mvc_set_iso_level_wrap; "Change the isolation level"

	.COMMAND mvc_bind( mvc c, str sname, str tname, str cname, int access ) : 
		BAT[any::1,any::2] = 
		mvc_bind_wrap; "Bind the bat, tname.cname"

	.COMMAND mvc_bind_ubat( mvc c, str sname, str tname, str cname, int acess ) : 
		BAT[any::1,any::2] = 
		mvc_bind_ubat_wrap; "Bind bat with the updates to tname.cname"

	.COMMAND mvc_bind_obat( mvc c, str sname, str tname, int access ) : 
		BAT[any::1,any::2] = 
		mvc_bind_obat_wrap; "Bind the oid bat, tname.OID"

	.COMMAND mvc_bind_dbat( mvc c, str sname, str tname, int access ) : 
		BAT[any::1,any::2] = mvc_bind_dbat_wrap; 
		"Bind the table deletes bat, tname.deletes"

	.COMMAND mvc_bind_kbat( mvc c, str sname, str tname, str kname, int access ) : 
		BAT[any::1,any::2] = mvc_bind_kbat_wrap; 
		"Bind the key constraint table"

	.COMMAND mvc_bind_schema( mvc c, str sname ) : sql_schema = 
		mvc_bind_schema_wrap; "Bind schema, sname"

	.COMMAND mvc_bind_table( mvc c, sql_schema s, str tname ) : sql_table = 
		mvc_bind_table_wrap; "Bind table, s.tname"

	.COMMAND mvc_bind_column( mvc c, sql_table t, str cname ) : sql_column = 
		mvc_bind_column_wrap; "Bind column, t.cname"

	.COMMAND mvc_bind_key( mvc c, sql_table t, str kname ) : sql_key = 
		mvc_bind_key_wrap; "Bind table key with name, kname"

	.COMMAND mvc_drop_schema( mvc c, str name ) = mvc_drop_schema_wrap;
		"Drop schema"

	.COMMAND mvc_create_schema( mvc c, str name, str auth) : sql_schema = 
		mvc_create_schema_wrap; "Create schema"

	.COMMAND mvc_drop_table( mvc c, sql_schema s, str name, bit cascade ) = 
		mvc_drop_table_wrap; "Drop table"

	.COMMAND mvc_create_table( mvc c, sql_schema s, str name, int type) : 
		sql_table = mvc_create_table_wrap; "Create table"

	.COMMAND mvc_create_view( mvc c, sql_schema s, str name, str sql) :
		sql_table = mvc_create_view_wrap; "Create view"

	.COMMAND mvc_drop_column( mvc c, sql_table t, str name ) = 
		mvc_drop_column_wrap; "Drop column"

	.COMMAND mvc_create_column( mvc m, sql_table t, str name, str type, int type_digits, int type_scale, int seqnr ) : sql_column = mvc_create_column_wrap; "Create column"

	.COMMAND mvc_null( mvc m, sql_column col, int flag ) : 
		sql_column = mvc_null_wrap; "Set column null or not"

	.COMMAND mvc_default( mvc m, sql_column col, str val ) :
		sql_column = mvc_default_wrap; "Set column default value"

	.COMMAND mvc_create_key( mvc m, str sname, str tname, str name, int kt, BAT[str,int] columns, sql_key fk ) :
		sql_key = mvc_create_key_wrap; "Create a table key"

	.COMMAND mvc_create_user( mvc m, str user, str pwd, str fullname, str dschema, int id) = mvc_create_user_wrap; "Create a user"

	.COMMAND mvc_result_table( mvc m, int nr_cols, any order ) : int = mvc_result_row_wrap; "Create structure to cache a row query result" 

	.COMMAND mvc_result_table( mvc m, int nr_cols, BAT[oid,any] order ) : int = mvc_result_table_wrap; "Create structure to cache a table query result" 

	.COMMAND mvc_result_column( mvc m, str name, str typename, int digits, int scale, any val) = mvc_result_value_wrap; "Add the value to the row query result"
	.COMMAND mvc_result_column( mvc m, str name, str typename, int digits, int scale, BAT[oid,any] col) = mvc_result_column_wrap; "Add the colunm to the table query result"

	.COMMAND mvc_export_result(mvc m, Stream s, int result_id) =
		mvc_export_result_wrap; "export a result to stream s"

	.COMMAND mvc_export_table(mvc m, Stream s, int result_id, int offset, int nr, str sep, str rsep) =
		mvc_export_table_wrap; "export a result to stream s with the given tuple and record seperators (sep/rsep)"

	.COMMAND mvc_import_table( mvc c, Stream s, str tname, 
					str sep, str rsep, int nr) : 
		BAT[str,BAT] = mvc_import_table_wrap; 
		"import a table from stream s with the given tuple and record seperators (sep/rsep)"

@+ void bats
To prevent void bats to convert to oid bats we need overloaded insert and
replace commands. These operations should at a later stage be moved to the
kernel libraries, e.g. bat.mx
@m
 	.COMMAND append( BAT[oid,any::1] i, BAT[oid,any::1] u ) : BAT[oid,any::1] = oid_bat_append_oid_bat_wrap; "append the content of u to i (renumbers u-oids' to unique numbers)"

 	.COMMAND append( BAT[oid,any::1] i, any::1 u ) : BAT[oid,any::1] = oid_bat_append_val_wrap; "append the value u to i"

 	.COMMAND append( BAT[void,any::1] i, BAT[void,any::1] u ) : BAT[void,any::1] = bat_append_void_bat_wrap; "append the content of u to i"

 	.COMMAND append( BAT[void,any::1] i, BAT[oid,any::1] u ) : BAT[void,any::1] = bat_append_oid_bat_wrap; "append the content of u to i"

 	.COMMAND append( BAT[void,any::1] i, any::1 u ) : BAT[void,any::1] = bat_append_val_wrap; "append the value u to i"

 	.COMMAND append( BAT[oid,void] i, BAT[oid,void] u ) : BAT[oid,void] = bat_append_oidvoid_bat_wrap; "Special case append for empty bats, works around impossible void,void case"

	.COMMAND replace( BAT[void,any::1] o, BAT[oid,any::1] d ) : BAT[void,any::1] = bat_replace_oid_bat_wrap; "inplace replace values on the given locations"

	.COMMAND hash( any::1 ) : int = hash_wrap; "calculate a hash value"

@+
	senddata requests the client to ship data to the server. This is
	needed to be able to handle COPY FROM STDIN.
@m
	.COMMAND senddata( Stream out ) = senddata_wrap; "Request client to senddata"


.END sqlserver;

@h
#ifndef _SQLSERVER_H_
#define _SQLSERVER_H_

#include <streams.h>
#include <monet_context.h>
#include "mvc.h"
#include "sqlserver.proto.h"

#endif /*_SQLSERVER_H_*/

@c
#include "sqlserver.h"
#include "privileges.h"
#include <statement.h>
#include <sqlexecute.h>
#include <mem.h>
#include <context.h>
#include <algebra.h>

int mvc_init_wrap( int* debug ){
	mvc_init(*debug );
	return GDK_SUCCEED;
}
int mvc_exit_wrap( ){
	mvc_exit();
	return GDK_SUCCEED;
}

int mvc_create_wrap( mvc *res, int *debug ){
	*(mvc**)res = mvc_create( *debug );
	return GDK_SUCCEED;
}

int mvc_destroy_wrap( mvc *c ){
	mvc_destroy( *(mvc**)c );
	return GDK_SUCCEED;
}

int mvc_login_wrap( str *r, mvc *c, str user, str passwd  ){
	*r = mvc_login( *(mvc**)c, user, passwd );
	if (*r == NULL)
		*r = _strdup("");
	return GDK_SUCCEED;
}

int mvc_status_wrap( int* res, mvc* m ){
	*res = mvc_status( *(mvc**)m );
	return GDK_SUCCEED;
}

int mvc_type_wrap( int* res, mvc* m ){
	*res = mvc_type( *(mvc**)m );
	return GDK_SUCCEED;
}


int mvc_commit_wrap( int* res, mvc* m, int* chain, str name){
	*res = mvc_commit( *(mvc**)m, *chain, name );
	return GDK_SUCCEED;
}

int mvc_rollback_wrap( int *res, mvc *m, int *chain, str name ){
	*res = mvc_rollback( *(mvc**)m, *chain, name );
	return GDK_SUCCEED;
}

int mvc_release_wrap( int *res, mvc *m, str name ){
	*res = mvc_release( *(mvc**)m, name );
	return GDK_SUCCEED;
}

int mvc_set_iso_level_wrap( int *res, mvc *m, int *level ){
	*res = mvc_set_iso_level( *(mvc**)m, *level );
	return GDK_SUCCEED;
}

int mvc_bind_wrap( BAT** res, mvc* c, str sname, str tname, str cname, int *access){
	*res = mvc_bind( *(mvc**)c, sname, tname, cname, *access );
	if (*res){
		return GDK_SUCCEED;
	}
	return GDK_FAIL;
}

int mvc_bind_ubat_wrap( BAT** res, mvc* c, str sname, str tname, str cname, int *access ){
	*res = mvc_bind_ubat( *(mvc**)c, sname, tname, cname, *access );
	if (*res){
		return GDK_SUCCEED;
	}
	return GDK_FAIL;
}

int mvc_bind_obat_wrap( BAT** res, mvc* c, str sname, str tname, int *access ){
	*res = mvc_bind_obat( *(mvc**)c, sname, tname, *access );
	if (*res){
		return GDK_SUCCEED;
	}
	return GDK_FAIL;
}

int mvc_bind_dbat_wrap( BAT** res, mvc* c, str sname, str tname, int *access ){
	*res = mvc_bind_dbat( *(mvc**)c, sname, tname, *access );
	if (*res){
		return GDK_SUCCEED;
	}
	return GDK_FAIL;
}

int mvc_bind_kbat_wrap( BAT** res, mvc* c, str sname, str tname, str kname, int *access ){
	*res = mvc_bind_kbat( *(mvc**)c, sname, tname, kname, *access );
	if (*res){
		return GDK_SUCCEED;
	}
	return GDK_FAIL;
}


int mvc_bind_schema_wrap( sql_schema* res, mvc* c, str sname){
	*(sql_schema**)res = mvc_bind_schema( *(mvc**)c, sname );
	return GDK_SUCCEED;
}

int mvc_bind_table_wrap( sql_table* res, mvc* c, sql_schema *s, str tname){
	*(sql_table**)res = mvc_bind_table( *(mvc**)c, *(sql_schema**)s, tname);
	return GDK_SUCCEED;
}

int mvc_bind_column_wrap( sql_column* res, mvc* c, sql_table *t, str col){
	*(sql_column**)res = mvc_bind_column( *(mvc**)c, *(sql_table**)t, col);
	return GDK_SUCCEED;
}

int mvc_bind_key_wrap( sql_key* res, mvc* c, sql_table *t, str name ){
	*(sql_key**)res = mvc_bind_key( *(mvc**)c, *(sql_table**)t, name);
	return GDK_SUCCEED;
}


int mvc_create_schema_wrap( sql_schema *s, mvc* c, str name, str auth){
	*(sql_schema**)s = mvc_create_schema( *(mvc**)c, name, auth );
	return GDK_SUCCEED;
}

int mvc_drop_schema_wrap( mvc* c, str name){
	mvc_drop_schema( *(mvc**)c, name );
	return GDK_SUCCEED;
}

int mvc_create_table_wrap( sql_table *res, mvc* c, sql_schema *s, str name, int* type){
	*(sql_table**)res = mvc_create_table( *(mvc**)c, *(sql_schema**)s, name, *type );
	return GDK_SUCCEED;
}

int mvc_create_view_wrap( sql_table *res, mvc* c, sql_schema *s, str name, str sql){
	*(sql_table**)res = mvc_create_view( *(mvc**)c, *(sql_schema**)s, name, sql );
	return GDK_SUCCEED;
}

int mvc_drop_table_wrap( mvc* c, sql_schema *s, str name, bit* cascade){
	mvc_drop_table( *(mvc**)c, *(sql_schema**)s, name, *cascade );
	return GDK_SUCCEED;
}


int mvc_create_column_wrap( sql_column* res, mvc* c, sql_table *t, 
		str name, str type, int *ts, int *td, int* seqnr){
	*(sql_column**)res = 
	  mvc_create_column( *(mvc**)c, *(sql_table**)t, name, type, *ts, *td, *seqnr );
	return GDK_SUCCEED;
}

int mvc_drop_column_wrap( mvc* c, sql_table *t, str name){
	mvc_drop_column( *(mvc**)c, *(sql_table**)t, name );
	return GDK_SUCCEED;
}

int mvc_null_wrap( sql_column* res, mvc* c, sql_column* col, int *flag){
	*(sql_column**)res = mvc_null( *(mvc**)c, *(sql_column**)col, *flag );
	return GDK_SUCCEED;
}

int mvc_default_wrap( sql_column* res, mvc* c, sql_column* col, str val){
	*(sql_column**)res = mvc_default( *(mvc**)c, *(sql_column**)col, val );
	return GDK_SUCCEED;
}

int mvc_create_key_wrap( sql_key* res, mvc* c, str sname, str tname, str name, int *kt, BAT *columns, sql_key *fk){
	if (*(ptr*)fk == ptr_nil){
		*(sql_key**)res = mvc_create_key( *(mvc**)c, sname, tname, name, *kt, columns, NULL);
	} else {
		*(sql_key**)res = mvc_create_key( *(mvc**)c, sname, tname, name, *kt, columns, *(sql_key**)fk);
	}
	return GDK_SUCCEED;
}

int mvc_create_user_wrap( mvc *c, str user, str passwd, str fullname, str dschema, int *grantor)
{
	if (sql_create_user( *(mvc**)c, user, passwd, fullname, dschema, *grantor)){
		return GDK_SUCCEED;
	} else {
		return GDK_FAIL;
	}
}

int mvc_result_table_wrap( int *res_id, mvc *M, int *nr_cols, BAT *order ){
	*res_id = mvc_result_table( *(mvc**)M, *nr_cols, order);
	if (*res_id < 0)
		return GDK_FAIL;
	return GDK_SUCCEED;
}
int mvc_result_row_wrap( int *res_id, mvc *M, int *nr_cols, ptr p, int p_type ){
	*res_id = mvc_result_row( *(mvc**)M, *nr_cols );
	if (*res_id < 0)
		return GDK_FAIL;
	return GDK_SUCCEED;
}
int mvc_result_column_wrap( mvc *M, str name, str type, int *digits, int *scale, BAT *b ){
	if (mvc_result_column( *(mvc**)M, name, type, *digits, *scale, b)) 
		return GDK_FAIL;
	return GDK_SUCCEED;
}
int mvc_result_value_wrap( mvc *M, str name, str type, int *digits, int *scale, ptr p, int mtype ){
	if (mvc_result_value( *(mvc**)M, name, type, *digits, *scale, p, mtype)) 
		return GDK_FAIL;
	return GDK_SUCCEED;
}
int mvc_export_result_wrap( mvc *M, Stream *S, int *res_id){
	if (mvc_export_result( *(mvc**)M, *(stream**)S, *res_id)) 
		return GDK_FAIL;
	
	return GDK_SUCCEED;
}
int mvc_export_table_wrap( mvc *M, Stream *S, int *res_id, int *offset, int *nr, str sep, str rsep){
	if (mvc_export_table( *(mvc**)M, *(stream**)S, *res_id, *offset, *nr, sep, rsep)) 
		return GDK_FAIL;
	
	return GDK_SUCCEED;
}
int mvc_import_table_wrap( BAT **res, mvc *c, Stream *s, str tname , str sep, str rsep, int *sz ){
	*res = mvc_import_table( *(mvc**)c, *(stream**)s, tname, sep, rsep, *sz );
	if (*res == NULL)
		return GDK_FAIL;
	return GDK_SUCCEED;
}

@-
The next collection of operators fill a hole in the Monet kernel libraries.
It provide handy operations on void-BATs. The sole reason not to move it to
the bat.mx module is that overall the kernel does not support bat[void,void]
@c
int bat_append_void_bat_wrap( BAT **res, BAT *i, BAT *u )
{
	*res = i;
	void_append_bat( i, u );
	BBPfix(i->batCacheid);
	return GDK_SUCCEED;
}

int bat_append_oid_bat_wrap( BAT **res, BAT *i, BAT *u )
{
	*res = i;
	void_insert_bat( i, u );
	BBPfix(i->batCacheid);
	return GDK_SUCCEED;
}

int bat_append_oidvoid_bat_wrap( BAT **res, BAT *i, BAT *u )
{
	*res = i;
	assert(BATcount(i)==0 && BATcount(u) == 0);
	BBPfix(i->batCacheid);
	return GDK_SUCCEED;
}

int oid_bat_append_oid_bat_wrap( BAT **res, BAT *i, BAT *u )
{
	BUN r,s;
        oid o;
	
	assert(i->htype == TYPE_oid && u->htype == TYPE_oid);
	BATmax(BATmirror(i),&o);
	o++;
	BATloop(u, r, s){
		oid h = *(oid*)BUNhead(u,r) + o;
		BUNins(i, &h,  BUNtail(u,r));
        }
	*res = i;
	BBPfix(i->batCacheid);
	return GDK_SUCCEED;
}

int oid_bat_append_val_wrap( BAT **res, BAT *i, ptr u )
{
        oid o;

	assert(i->htype == TYPE_oid);
	BATmax(BATmirror(i),&o);
	o++;
	*res = i;
	BUNins( i, (ptr) & o, u );
	BBPfix(i->batCacheid);
	return GDK_SUCCEED;
}


int bat_append_val_wrap( BAT **res, BAT *i, ptr u )
{
	oid h = i->hseqbase + BATcount(i);
	*res = i;
	BUNins( i, (ptr) & h, u );
	BBPfix(i->batCacheid);
	return GDK_SUCCEED;
}

int bat_replace_oid_bat_wrap( BAT **res, BAT *o, BAT *d )
{
	*res = o;
	void_replace_bat( o, d );
	BBPfix(o->batCacheid);
	return GDK_SUCCEED;
}

int hash_wrap( int *res, ptr v, int tpe )
{
	*res = ATOMhash(tpe,v);
	return GDK_SUCCEED;
}

@mil
module(alarm);
module(xtables);
module(aggrX3);
module(monettime);
module(mmath);
module(mapi); # mapi_listen 

# low memory usage for testing unloading
#mem_maxsize(0LL);
#vm_maxsize(0LL);

mvc_init(int(monet_environment.find("sql_debug")));

# dirty hack for comments ask menzo
PROC renameFUNC(str OLD,str NEW) : void := {
 	VAR funcs := monet_fcn_nme.select(OLD);
 	funcs := [funcs~NEW];
 	monet_fcn_nme.replace(funcs);
 	monet_fcntbl.reverse.replace(funcs);
}

proc new_quit() := {
	mvc_exit();
	eval("old_quit;");
}

renameFUNC("quit", "old_quit");
renameFUNC("new_quit", "quit");

proc SQLclient( int sock ) := {
	dsock := socket_dup(sock);
	fork(sqlclient(dsock));
}

mapi_listen(int(monet_environment.find("sql_port")), 5, "SQLclient").fork();
# start a default mapi client for debugging, this should go once
# MonetDB SQL gets stable.
mapi_listen(int(monet_environment.find("mapi_port")), 5, "").fork();
