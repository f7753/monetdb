@f sqlserver
@a N.J. Nes
@* 

@m
.MODULE sqlserver;
	.USE ascii_io,streams;

	.COMMAND isNil( str s ) : bit = isNil_wrap;
		"isNil(s).."

	.BUILTIN sqlserver_start(int port, str cmd) = sqlserver_start;
		"start the sql server, calls cmd on each accepted connection"

	.COMMAND socket_close( int s ) = socket_close_wrap;
		"close a socket"

	.COMMAND socket_dup( int s ) : int = socket_dup_wrap;
		"dup a socket"

    	.ATOM context = ptr;
    	.END;

	.ATOM mvc = ptr;
	.END;
	.ATOM sql_schema = ptr;
	.END;
	.ATOM sql_table = ptr;
	.END;
	.ATOM sql_column = ptr;
	.END;
	.ATOM sql_key = ptr;
	.END;
	
    	.COMMAND sql_create_context( int debug, Stream o, mvc c, str schema, str user ) : context = 
		sql_create_context; "create a context for the sql interpreter"

    	.COMMAND sql_destroy_context( context c ) = 
		sql_destroy_context; "destroy the sql interpreter context"

	.BUILTIN sqlclient( mvc m,  context c, Stream in, Stream out ) = 
		sqlclient;
		"parse the next sql command and convert this to mil code"

	.COMMAND types_init( int debug ) = types_init_wrap; 
		"create the types/functions/aggrs"

	.COMMAND types_exit() = types_exit_wrap; 
		"cleanup the types/funcs/aggrs"

	.COMMAND types_export( Stream s ) = types_export_wrap;
		"export the types/aggrs/functions to the stream s"

	.COMMAND sql_type(str sqlname, str name ) = 
		sql_type_wrap; "Add a new sql type"

	.COMMAND sql_aggr(str name, str imp, str atp, str rtp) = 
		sql_aggr_wrap; "Add a new sql aggregate function"

	.COMMAND sql_func(str name, str imp, str tp1, str tp2, str tp3, str rtp)
		= sql_func_wrap; "Add a new sql function"

	.COMMAND mvc_init(int debug, str dir_name) = mvc_init_wrap; 
		"create the global catalog"

	.COMMAND mvc_exit() = mvc_exit_wrap; "cleanup the global catalog"

	.COMMAND mvc_create( int debug ) : mvc = mvc_create_wrap;
		"Create multi version catalog"

	.COMMAND mvc_destroy( mvc m ) = mvc_destroy_wrap;
		"Destroy multi version catalog"

	.COMMAND mvc_login( mvc m, str user, str passwd ) : str 
		= mvc_login_wrap; "database login"

	.COMMAND mvc_admin_login( mvc m ) : str 
		= mvc_admin_login_wrap; "an initial passwordless login by the admin is allowed too setup the initial users (only once)"

	.COMMAND mvc_status( mvc m ) : int 
		= mvc_status_wrap; "return the status of the last mvc operation"

	.COMMAND mvc_type( mvc m ) : int 
		= mvc_type_wrap; "return the type of the last mvc operation"

	.COMMAND mvc_commit( mvc m, int chain, str name ) : int = 
		mvc_commit_wrap; "Commit transaction/savepoint and chain"

	.COMMAND mvc_rollback( mvc m, int chain, str name ) : int = 
		mvc_rollback_wrap; "Rollback transaction/savepoint and chain"

	.COMMAND mvc_release( mvc m, str name ) : int = 
		mvc_release_wrap; "Release the savepoint"

	.COMMAND mvc_set_iso_level( mvc m, int level ) : int = 
		mvc_set_iso_level_wrap; "Change the isolation level"

	.COMMAND mvc_bind( mvc c, str sname, str tname, str cname, int access ) : 
		BAT[any::1,any::2] = 
		mvc_bind_wrap; "Bind the bat, tname.cname"

	.COMMAND mvc_bind_ubat( mvc c, str sname, str tname, str cname, int acess ) : 
		BAT[any::1,any::2] = 
		mvc_bind_ubat_wrap; "Bind bat with the updates to tname.cname"

	.COMMAND mvc_bind_obat( mvc c, str sname, str tname, int access ) : 
		BAT[any::1,any::2] = 
		mvc_bind_obat_wrap; "Bind the oid bat, tname.OID"

	.COMMAND mvc_bind_dbat( mvc c, str sname, str tname, int access ) : 
		BAT[any::1,any::2] = 
		mvc_bind_dbat_wrap; "Bind the table deletes bat, tname.deletes"


	.COMMAND mvc_bind_schema( mvc c, str sname ) : sql_schema = 
		mvc_bind_schema_wrap; "Bind schema, sname"

	.COMMAND mvc_bind_table( mvc c, sql_schema s, str tname ) : sql_table = 
		mvc_bind_table_wrap; "Bind table, s.tname"

	.COMMAND mvc_bind_column( mvc c, sql_table t, str cname ) : sql_column = 
		mvc_bind_column_wrap; "Bind column, t.cname"

	.COMMAND mvc_bind_key( mvc c, sql_table t, str kname ) : sql_key = 
		mvc_bind_key_wrap; "Bind table key with name, kname"

	.COMMAND mvc_drop_schema( mvc c, str name ) = mvc_drop_schema_wrap;
		"Drop schema"

	.COMMAND mvc_create_schema( mvc c, str name, str auth) : sql_schema = 
		mvc_create_schema_wrap; "Create schema"

	.COMMAND mvc_drop_table( mvc c, sql_schema s, str name, bit cascade ) = 
		mvc_drop_table_wrap; "Drop table"

	.COMMAND mvc_create_table( mvc c, sql_schema s, str name, int type) : 
		sql_table = mvc_create_table_wrap; "Create table"

	.COMMAND mvc_create_view( mvc c, sql_schema s, str name, str sql) :
		sql_table = mvc_create_view_wrap; "Create view"

	.COMMAND mvc_drop_column( mvc c, sql_table t, str name ) = 
		mvc_drop_column_wrap; "Drop column"

	.COMMAND mvc_create_column( mvc m, sql_table t, str name, str type, int type_size, int type_digits, int seqnr ) : sql_column = mvc_create_column_wrap; "Create column"

	.COMMAND mvc_not_null( mvc m, sql_column col ) : 
		sql_column = mvc_not_null_wrap; "Set column not null"

	.COMMAND mvc_default( mvc m, sql_column col, str val ) :
		sql_column = mvc_default_wrap; "Set column default value"

	.COMMAND mvc_create_key( mvc m, str sname, str tname, str name, int kt, BAT[str,int] columns, sql_key fk ) :
		sql_key = mvc_create_key_wrap; "Create a table key"

	.COMMAND mvc_export(Stream s, BAT order, BAT bats, str sep, str rsep) =
		mvc_export_wrap; "export a table (in order) to stream s with the given tuple and record seperators (sep/rsep)"

	.COMMAND mvc_import_table( mvc c, Stream s, str tname, 
					str sep, str rsep, int nr) : 
		int = mvc_import_table_wrap; 
		"import a table from stream s with the given tuple and record seperators (sep/rsep)"

	.COMMAND mvc_export_schemas( mvc c, Stream s ) = mvc_export_schemas_wrap; 
		"Export the schema info of the current transaction"

	.COMMAND renumber( BAT[oid,any::1] b1, oid o ) : BAT[oid,any::1] = bat_renumber;
		"renumber the bat using the offset o"

	.LOAD
		# dirty hack for comments ask menzo
		PROC renameFUNC(str OLD,str NEW) : void := {
 			VAR funcs := monet_fcn_nme.select(OLD);
 			funcs := [funcs~NEW];
 			monet_fcn_nme.replace(funcs);
 			monet_fcntbl.reverse.replace(funcs);
		}
	.END;

.END sqlserver;

@h
#ifndef _SQLSERVER_H_
#define _SQLSERVER_H_

#include <streams.h>
#include "monet_context.h"
#include "context.h"
#include "mvc.h"
#include "sqlserver.proto.h"

#endif /*_SQLSERVER_H_*/

@c
#include "sqlserver.h"
#include <statement.h>
#include <sqlexecute.h>
#include "mem.h"

#include  <sys/types.h> 
#include  <sys/socket.h> 

extern catalog *catalog_create( context *lc, mvc *m);

int isNil_wrap( bit *b, str s)
{
	if (s == NULL){
		*b = FALSE;
	} else {
		*b = TRUE;
	}
	return GDK_SUCCEED;
}


int sql_create_context( context *res, int *debug, Stream *ws, mvc *m, str schema, str user){
	context *lc = NEW(context);

	sql_init_context( lc, *(stream**)ws, *debug, default_catalog_create() );
	catalog_create( lc, *(mvc**)m );
	lc->cat->cc_getschemas( lc->cat, schema, user );
	*(context**)res = lc;
	return GDK_SUCCEED;
}

int sql_destroy_context( context *lc ){
	sql_exit_context( *(context**)lc );
	return GDK_SUCCEED;
}

int sqlclient(Cntxt stk, YYSTREE lt, ValPtr res){
	char buf[BUFSIZ];
	int err = 0;
	stmt *s = NULL;
	char *cmd = NULL;

	mvc **M, *m;
	context **C, *lc;
	stream **In, *in, **Out, *out;

  	if (lt->cnt != 4) {
        	return handle_argerror(res,lt->cnt,4);
  	}
  	@:builtin_operand(0,TYPE_mvc,M)@
	m = *M;
  	@:builtin_operand(1,TYPE_context,C)@
	lc = *C;
  	@:builtin_operand(2,TYPE_Stream,In)@
	in = *In;
  	@:builtin_operand(3,TYPE_Stream,Out)@
	out = *Out;

	while(lc->cur != EOF ){
		s = sqlnext(lc, in, &err);
		if (err){ /* output error */
			stream_writeInt( out, 0 );
			stream_writeInt( out, 0 );
			stream_writeInt( out, -1 );
			out->write( out, lc->errstr, strlen(lc->errstr), 1 );
			out->flush( out );
		} else if (s){
	    		int nr = 1;
	    		stmt_dump( s, &nr, lc );

			cmd = buffer_get_buf(stream_get_buffer( lc->out ));
	    		lc->out->flush( lc->out );

			if (s && s->op1.stval->type == st_copyfrom &&
				!stmt_copyfrom_files(s)){
				/*ask_for_data();*/
				stream_writeInt( out, 0 );
				stream_writeInt( out, QDATA );
				stream_writeInt( out, 0 );
				out->flush( out );
			}
			
			{
				int i, status;
				ValRecord res;
				ptr val = &res.val.ival;
        			res.vtype = TYPE_void; 
				i = interpret_str( stk, cmd, &res);
				/*TODO: we need to cleanup val */

				if (i < 0){
					char *errstr = "Mil error";
					stream_writeInt( out, 0 );
					stream_writeInt( out, mvc_type(m) );
					stream_writeInt( out, i );
					out->write( out, errstr, strlen(errstr), 1 );
					out->flush( out );
				} else if ((status=mvc_status(m)) < 0){
					char *errstr = "Error in result";
					stream_writeInt( out, 0 );
					stream_writeInt( out, mvc_type(m) );
					stream_writeInt( out, status );
					out->write( out, errstr, strlen(errstr), 1 );
					out->flush( out );
				} else if (s->type != st_output) {
					stream_writeInt( out, 0 );
					stream_writeInt( out, mvc_type(m) );
					stream_writeInt( out, status );
					out->flush( out );
				}
			}
			/* BEWARE to use free instead of _DELETE
 			 * as the stream library is build with out libbat 
 			 * ie. it cannot use GDKmalloc can be used */
			if (cmd) free(cmd);
		}
		if (s) stmt_destroy(s);
	}
	return GDK_SUCCEED;
}

int mvc_init_wrap( int* debug, str dir_name){
	mvc_init(*debug, dir_name);
	return GDK_SUCCEED;
}
int mvc_exit_wrap( ){
	mvc_exit();
	return GDK_SUCCEED;
}

int types_init_wrap( int* debug){
	types_init(*debug );
	return GDK_SUCCEED;
}
int types_exit_wrap( ){
	types_exit();
	return GDK_SUCCEED;
}
int types_export_wrap( Stream *s ){
	types_export( *(stream**)s );
	return GDK_SUCCEED;
}
int sql_type_wrap( str sqlname, str name ){
	sql_new_type( sqlname, name );
	return GDK_SUCCEED;
}
int sql_aggr_wrap( str name, str imp, str atp, str rtp){
	sql_new_aggr( name, imp, atp, rtp );
	return GDK_SUCCEED;
}
int sql_func_wrap( str name, str imp, str tp1, str tp2, str tp3, str rtp){
	sql_new_func( name, imp, tp1, tp2, tp3, rtp );
	return GDK_SUCCEED;
}


@= builtin_operand
{       int _k = interpret(stk, arg(lt, @1), res);
        if (_k < 0) {
                return _k;
        }
        @3 = VALconvert(@2, res, 0);
        if ((@3 == ILLEGALVALUE)  || (@2 == TYPE_bat && !@3)) {
                return handle_paramerror(res,@1,res->vtype,@2);
        }
}
@c

int sqlserver_start(Cntxt stk, YYSTREE lt, ValPtr res){
  int port, *Port, sock, fd = 0, server_run = 1;
  char *cmd, *Cmd;
  struct sockaddr_in server, client;

  if (lt->cnt != 2) {
        return handle_argerror(res,lt->cnt,2);
  }
  @:builtin_operand(0,TYPE_int,Port)@
  port = *Port;
  @:builtin_operand(1,TYPE_str,Cmd)@
  cmd = _strdup(Cmd);

  sock = socket (AF_INET, SOCK_STREAM, 0);
  if (sock < 0) {
    perror ("could not create socket");
    exit (1);
  }
   
  server.sin_family = AF_INET;
  server.sin_addr.s_addr = htonl (INADDR_ANY);
  server.sin_port = htons (port);

  if (bind (sock, (struct sockaddr *) &server, sizeof (server)) < 0) {
    perror ("could not bind socket");
    return -1;
  }

  listen (sock, 5);

  fprintf (stderr, "# server listening on port %i\n", port);

  while (monet_running && server_run) {
    int retval;
    int client_len = sizeof (client);
    struct timeval tv;
    fd_set fds;

    FD_ZERO(&fds);
    FD_SET(sock, &fds);
    /* Wait up to five seconds. */
    tv.tv_sec = 0;
    tv.tv_usec = 500;

    retval = select(sock+1, &fds, &fds, &fds, &tv);
    /* Don't rely on the value of tv now! */

    if (retval &&
        (fd = accept(sock, (struct sockaddr *) &client, &client_len))<0 ){
      	perror ("accept () failed");
	break;
    } else if(retval){
	ValRecord res;
	ptr val = &res.val.ival;
	int cres = 0;
	char buf[BUFSIZ];
	
	snprintf( buf, BUFSIZ, "%s(%d);\n", cmd, fd );
        res.vtype = TYPE_void; 
	interpret_str( stk, buf, &res);
	/*TODO: we need to cleanup val */
	if ((cres = close(fd)) < 0){
		fprintf(stderr, "Error closing socket %d\n", cres );
		return;
	}
    }
  }
  if (close(sock) < 0){
	perror("Error closing sock\n");
  }
  return 0;
}

int socket_close_wrap( int *s ){
	close(*s);
	return GDK_SUCCEED;
}

int socket_dup_wrap( int *res, int *s ){
	*res = dup(*s);
	return GDK_SUCCEED;
}

int mvc_create_wrap( mvc *res, int *debug ){
	*(mvc**)res = mvc_create( *debug );
	return GDK_SUCCEED;
}

int mvc_destroy_wrap( mvc *c ){
	mvc_destroy( *(mvc**)c );
	return GDK_SUCCEED;
}

int mvc_login_wrap( str *r, mvc *c, str user, str passwd  ){
	*r = mvc_login( *(mvc**)c, user, passwd );
	if (*r == NULL)
		*r = _strdup("");
	return GDK_SUCCEED;
}

int mvc_admin_login_wrap( str *r, mvc *c ){
	*r = mvc_admin_login( *(mvc**)c );
	if (*r == NULL)
		*r = _strdup("");
	return GDK_SUCCEED;
}

int mvc_status_wrap( int* res, mvc* m ){
	*res = mvc_status( *(mvc**)m );
	return GDK_SUCCEED;
}

int mvc_type_wrap( int* res, mvc* m ){
	*res = mvc_type( *(mvc**)m );
	return GDK_SUCCEED;
}


int mvc_commit_wrap( int* res, mvc* m, int* chain, str name){
	*res = mvc_commit( *(mvc**)m, *chain, name );
	return GDK_SUCCEED;
}

int mvc_rollback_wrap( int *res, mvc *m, int *chain, str name ){
	*res = mvc_rollback( *(mvc**)m, *chain, name );
	return GDK_SUCCEED;
}

int mvc_release_wrap( int *res, mvc *m, str name ){
	*res = mvc_release( *(mvc**)m, name );
	return GDK_SUCCEED;
}

int mvc_set_iso_level_wrap( int *res, mvc *m, int *level ){
	*res = mvc_set_iso_level( *(mvc**)m, *level );
	return GDK_SUCCEED;
}

int mvc_bind_wrap( BAT** res, mvc* c, str sname, str tname, str cname, int *access){
	*res = mvc_bind( *(mvc**)c, sname, tname, cname, *access );
	if (*res){
		return GDK_SUCCEED;
	}
	return GDK_FAIL;
}

int mvc_bind_ubat_wrap( BAT** res, mvc* c, str sname, str tname, str cname, int *access ){
	*res = mvc_bind_ubat( *(mvc**)c, sname, tname, cname, *access );
	if (*res){
		return GDK_SUCCEED;
	}
	return GDK_FAIL;
}

int mvc_bind_obat_wrap( BAT** res, mvc* c, str sname, str tname, int *access ){
	*res = mvc_bind_obat( *(mvc**)c, sname, tname, *access );
	if (*res){
		return GDK_SUCCEED;
	}
	return GDK_FAIL;
}

int mvc_bind_dbat_wrap( BAT** res, mvc* c, str sname, str tname, int *access ){
	*res = mvc_bind_dbat( *(mvc**)c, sname, tname, *access );
	if (*res){
		return GDK_SUCCEED;
	}
	return GDK_FAIL;
}


int mvc_bind_schema_wrap( sql_schema* res, mvc* c, str sname){
	*(sql_schema**)res = mvc_bind_schema( *(mvc**)c, sname );
	return GDK_SUCCEED;
}

int mvc_bind_table_wrap( sql_table* res, mvc* c, sql_schema *s, str tname){
	*(sql_table**)res = mvc_bind_table( *(mvc**)c, *(sql_schema**)s, tname);
	return GDK_SUCCEED;
}

int mvc_bind_column_wrap( sql_column* res, mvc* c, sql_table *t, str col){
	*(sql_column**)res = mvc_bind_column( *(mvc**)c, *(sql_table**)t, col);
	return GDK_SUCCEED;
}

int mvc_bind_key_wrap( sql_key* res, mvc* c, sql_table *t, str name ){
	*(sql_key**)res = mvc_bind_key( *(mvc**)c, *(sql_table**)t, name);
	return GDK_SUCCEED;
}


int mvc_create_schema_wrap( sql_schema *s, mvc* c, str name, str auth){
	*(sql_schema**)s = mvc_create_schema( *(mvc**)c, name, auth );
	return GDK_SUCCEED;
}

int mvc_drop_schema_wrap( mvc* c, str name){
	mvc_drop_schema( *(mvc**)c, name );
	return GDK_SUCCEED;
}

int mvc_create_table_wrap( sql_table *res, mvc* c, sql_schema *s, str name, int* type){
	*(sql_table**)res = mvc_create_table( *(mvc**)c, *(sql_schema**)s, name, *type );
	return GDK_SUCCEED;
}

int mvc_create_view_wrap( sql_table *res, mvc* c, sql_schema *s, str name, str sql){
	*(sql_table**)res = mvc_create_view( *(mvc**)c, *(sql_schema**)s, name, sql );
	return GDK_SUCCEED;
}

int mvc_drop_table_wrap( mvc* c, sql_schema *s, str name, bit* cascade){
	mvc_drop_table( *(mvc**)c, *(sql_schema**)s, name, *cascade );
	return GDK_SUCCEED;
}


int mvc_create_column_wrap( sql_column* res, mvc* c, sql_table *t, 
		str name, str type, int *ts, int *td, int* seqnr){
	*(sql_column**)res = 
	  mvc_create_column( *(mvc**)c, *(sql_table**)t, name, type, *ts, *td, *seqnr );
	return GDK_SUCCEED;
}

int mvc_drop_column_wrap( mvc* c, sql_table *t, str name){
	mvc_drop_column( *(mvc**)c, *(sql_table**)t, name );
	return GDK_SUCCEED;
}

int mvc_not_null_wrap( sql_column* res, mvc* c, sql_column* col){
	*(sql_column**)res = mvc_not_null( *(mvc**)c, *(sql_column**)col );
	return GDK_SUCCEED;
}

int mvc_default_wrap( sql_column* res, mvc* c, sql_column* col, str val){
	*(sql_column**)res = mvc_default( *(mvc**)c, *(sql_column**)col, val );
	return GDK_SUCCEED;
}

int mvc_create_key_wrap( sql_key* res, mvc* c, str sname, str tname, str name, int *kt, BAT *columns, sql_key *fk){
	if (*(ptr*)fk == ptr_nil){
		*(sql_key**)res = mvc_create_key( *(mvc**)c, sname, tname, name, *kt, columns, NULL);
	} else {
		*(sql_key**)res = mvc_create_key( *(mvc**)c, sname, tname, name, *kt, columns, *(sql_key**)fk);
	}
	return GDK_SUCCEED;
}

int mvc_export_wrap( Stream *s, BAT *order, BAT *bats, str sep, str rsep ){
	mvc_export( *(stream**)s, order, bats, sep, rsep );
	return GDK_SUCCEED;
}

int mvc_import_table_wrap( int *res, mvc *c, Stream *s, str tname , str sep, str rsep, int *sz ){
	*res = mvc_import_table( *(mvc**)c, *(stream**)s, tname, sep, rsep, *sz );
	return GDK_SUCCEED;
}

int mvc_export_schemas_wrap( mvc *c, Stream *s ){
	mvc_export_schemas( *(mvc**)c, *(stream**)s );
	return GDK_SUCCEED;
}

int bat_renumber( BAT **r, BAT *in, oid *O )
{
	oid o = *O;
	if (BAThdense(in)){
		BATseqbase(in, in->hseqbase + o);
	} else {
		oid *n = (oid*)BUNhead(in,BUNfirst(in)), *e = n + BATcount(in);
		while(n<e){
			*n += o;
		}
	}
	BBPfix(in->batCacheid);
	*r = in;
	return GDK_SUCCEED;
}

@mil
#module(MILsqueezer);

proc add(x, y):= return x + y;
proc sub(x, y):= return x - y;
proc mul(x, y):= return x * y;
proc div(x, y):= return x / y;
proc neg(val):= return -1 * val;

module(str);
module(uchr);
module(alarm);
#module(unix);
module(ddbench);
module(aggrX3);
module(monettime);
module(sqlserver);
module(mmath);

var sql_debug := int(monet_environment.find("sql_debug"));

types_init(sql_debug);

sql_type("OID", "oid" );
sql_type("BOOL", "bit");
sql_type("UBYTE", "uchr");

sql_type("VARCHAR(1)", "chr");
sql_type("CHARACTER", "str");
sql_type("VARCHAR", "str");
sql_type("TEXT", "str");
sql_type("TINYTEXT", "str");
sql_type("STRING", "str");


sql_type("NUMERIC", "int");
sql_type("DECIMAL", "int");
sql_type("INTEGER", "int");
sql_type("NUMBER", "int");
sql_type("MEDIUMINT", "int");
sql_type("SMALLINT", "sht");
sql_type("TINYINT", "uchr");
sql_type("UBYTE", "uchr");

sql_type("FLOAT", "flt");
sql_type("REAL", "flt");
sql_type("DOUBLE", "dbl");

sql_type("MONTH_INTERVAL", "int");
sql_type("SEC_INTERVAL", "int");
sql_type("DATE", "date");
sql_type("TIME", "str");
sql_type("DATETIME", "str");
sql_type("TIMESTAMP", "str");

var strings := new(str,str);
strings.insert("VARCHAR(1)", "chr");
strings.insert("CHARACTER", "str");
strings.insert("VARCHAR", "str");
strings.insert("STRING", "str");

var numerical := new(str,str);
numerical.insert("UBYTE", "uchr");
numerical.insert("NUMERIC", "int");
numerical.insert("DECIMAL", "int");
numerical.insert("INTEGER", "int");
numerical.insert("NUMBER", "int");
numerical.insert("MEDIUMINT", "int");
numerical.insert("SMALLINT", "sht");
numerical.insert("TINYINT", "uchr");
numerical.insert("UBYTE", "uchr");
numerical.insert("FLOAT", "flt");
numerical.insert("REAL", "flt");
numerical.insert("DOUBLE", "dbl");

var dates := new(str,str);
dates.insert("MONTH_INTERVAL", "int");
dates.insert("SEC_INTERVAL", "int");
dates.insert("DATE", "date");
dates.insert("TIME", "str");
dates.insert("TIMESTAMP", "str");

var type_sql := bat(str,str);
type_sql.insert(strings.reverse());
type_sql.insert(numerical.reverse());
type_sql.insert(dates.reverse());

type_sql@batloop(){ sql_aggr( "min", "min", $t, $t ); }
type_sql@batloop(){ sql_aggr( "max", "max", $t, $t ); }
numerical@batloop(){ sql_aggr( "sum", "sum", $h, $h ); }
numerical@batloop(){ sql_aggr( "avg", "avg", $h, $h ); }
sql_aggr( "count", "count", "", "INTEGER" ); 

numerical@batloop(){ sql_func( "sub", "-", $h, $h, "", $h ); }
numerical@batloop(){ sql_func( "add", "+", $h, $h, "", $h ); }
numerical@batloop(){ sql_func( "mul", "*", $h, $h, "", $h ); }
numerical@batloop(){ sql_func( "div", "/", $h, $h, "", $h ); }
numerical@batloop(){ sql_func( "max", "max", $h, $h, "", $h ); }
numerical@batloop(){ sql_func( "min", "min", $h, $h, "", $h ); }

numerical@batloop(){ sql_func( "neg", "-", $h, "", "", $h ); }
#numerical@batloop(){ sql_func( "pos", "+", $h, "", "", $h ); }

numerical@batloop(){ 
	var hd := $h; 
	numerical@batloop(){ 
		if ($h != hd){
		    sql_func( "convert", $t, hd, "", "", $h );
		}
	}
}

strings@batloop(){ 
	var hd := $h; 
	strings@batloop(){ 
		if ($h != hd){
		    sql_func( "convert", $t, hd, "", "", $h );
		}
	}
}
strings@batloop(){ 
	var hd := $h; 
	numerical@batloop(){ 
		sql_func( "convert", $t, hd, "", "", $h );
	}
}

var floats := numerical.select("dbl").union(numerical.select("flt"));
floats@batloop(){ 
	sql_func( "floor", "floor", $h, "", "", $h ); 
	sql_func( "ceil", "ceil", $h, "", "", $h ); 
	sql_func( "sin", "sin", $h, "", "", $h ); 
	sql_func( "cos", "cos", $h, "", "", $h ); 
	sql_func( "tan", "tan", $h, "", "", $h ); 
	sql_func( "asin", "asin", $h, "", "", $h ); 
	sql_func( "acos", "acos", $h, "", "", $h ); 
	sql_func( "atan", "atan", $h, "", "", $h ); 
	sql_func( "sinh", "sinh", $h, "", "", $h ); 
	sql_func( "cosh", "cosh", $h, "", "", $h ); 
	sql_func( "tanh", "tanh", $h, "", "", $h ); 
	sql_func( "sqrt", "sqrt", $h, "", "", $h ); 
	sql_func( "exp", "exp", $h, "", "", $h ); 
	sql_func( "log", "log", $h, "", "", $h ); 
	sql_func( "log10", "log10", $h, "", "", $h ); 
}
proc floor(flt f):= return flt(floor(dbl(f)));
proc ceil(flt f):= return flt(ceil(dbl(f)));
proc sin(flt f):= return flt(sin(dbl(f)));
proc cos(flt f):= return flt(cos(dbl(f)));
proc tan(flt f):= return flt(tan(dbl(f)));
proc asin(flt f):= return flt(asin(dbl(f)));
proc acos(flt f):= return flt(acos(dbl(f)));
proc atan(flt f):= return flt(atan(dbl(f)));
proc sinh(flt f):= return flt(sinh(dbl(f)));
proc cosh(flt f):= return flt(cosh(dbl(f)));
proc tanh(flt f):= return flt(tanh(dbl(f)));
proc sqrt(flt f):= return flt(sqrt(dbl(f)));
proc exp(flt f):= return flt(exp(dbl(f)));
proc log(flt f):= return flt(log(dbl(f)));
proc log10(flt f):= return flt(log10(dbl(f)));

sql_func( "current_date", "current_date", "", "", "" , "DATE" );
sql_func( "current_time", "current_time", "", "", "" , "TIME" );
sql_func( "current_timestamp", "current_timestamp", "", "", "" , "TIMESTAMP" );

sql_func( "sub", "date_sub_sec_interval", "DATE", "SEC_INTERVAL", "", "DATE");
sql_func( "sub", "date_sub_month_interval", "DATE", "MONTH_INTERVAL", "", "DATE");

sql_func( "add", "date_add_sec_interval", "DATE", "SEC_INTERVAL", "", "DATE");
sql_func( "add", "addmonths", "DATE", "MONTH_INTERVAL", "", "DATE");

sql_func( ">", ">", "DATE", "DATE", "", "BOOL");
sql_func( "<", "<", "DATE", "DATE", "", "BOOL");

sql_func( "year", "year", "DATE", "", "", "INTEGER");
sql_func( "month", "month", "DATE", "", "", "INTEGER");

proc current_timestamp() { return timestamp(epoch()); }
proc current_date() { return date(current_timestamp()); }
proc current_time() { return daytime(current_timestamp()); }

sql_func( "substring", "string", "STRING", "INTEGER", "INTEGER", "STRING");
sql_func( "strconcat", "+", "STRING", "STRING", "", "STRING");
sql_func( "substring", "string", "VARCHAR", "INTEGER", "INTEGER", "VARCHAR");
sql_func( "strconcat", "+", "VARCHAR", "VARCHAR", "", "VARCHAR");

var dbname := monet_environment.find("gdk_dbname");
var dbfarm := monet_environment.find("gdk_dbfarm");
mvc_init(sql_debug,dbfarm + "/" + dbname + "/log");

const QPARSE := 1;
const QTABLE := 2;
const QUPDATE := 3;
const QDATA := 4;
const QHEADER := 5;

const RDONLY := 0;
const INS := 1;
const DEL := 2;
const UPD := 3;
const UPDATES := 4;
const DELETES := 5;

proc mvc_bind_( m, schema, Table, column, write_access ){
	res := mvc_bind(m, schema,Table, column, write_access);
	if (write_access > 0){
		res := res.access(BAT_WRITE);
	} 
	return res;
}

proc mvc_bind_dbat_( m, schema, Table, write_access ){
	res := mvc_bind_dbat(m, schema, Table, write_access);
	if (write_access > 0){
		res := res.access(BAT_WRITE);
	} 
	return res;
}

proc mvc_create_role( m, auth, grantor ) {
	auth_id := mvc_bind_( m, "sys", "auths", "id", 1);
	auth_name := mvc_bind_( m, "sys", "auths", "name", 1);
	auth_grantor := mvc_bind_( m, "sys", "auths", "grantor", 1);
	auth_priv := mvc_bind_( m, "sys", "auths", "privileges", 1);
	
	if (auth_name.reverse.exist(auth)) {
		return false;
	}
	if (auth_id.count() > 0)
		auth_id.insert(nil, auth_id.max()+1);
	else
		auth_id.insert(nil, 0);
	auth_name.insert(nil, auth);
	auth_grantor.insert(nil, grantor);
	auth_priv.insert(nil,0); # all privileges are off 
	#print(auth_id,auth_name,auth_grantor,auth_priv);
	return true;
} 
proc mvc_drop_role( m, auth ) {
	auth_id := mvc_bind_( m, "sys", "auths", "id", 1);
	auth_name := mvc_bind_( m, "sys", "auths", "name", 1);
	auth_grantor := mvc_bind_( m, "sys", "auths", "grantor", 1);
	auth_priv := mvc_bind_( m, "sys", "auths", "privileges", 1);
	D_auth := mvc_bind_dbat_( m, "sys", "auths", 1);
	
	if (not(auth_name.reverse.exist(auth))) {
		return;
	}
	id := auth_name.reverse.find(auth);
	#print(id);
	auth_id.replace(id, int(nil));
	auth_name.replace(id, str(nil));
	auth_grantor.replace(id, int(nil));
	auth_priv.replace(id, int(nil));
	#print(auth_id,auth_name,auth_grantor,auth_priv);
	D_auth.insert(nil,id);
} 
proc mvc_grant_role( m, grantee, auth ) {
	auth_ids := mvc_bind_( m, "sys", "auths", "id", 1);
	auth_name := mvc_bind_( m, "sys", "auths", "id", 1);
	login_id := mvc_bind_( m, "sys", "user_role", "login_id", 1);
	role_id := mvc_bind_( m, "sys", "user_role", "role_id", 1);

	if (not(auth_name.reverse.exist(grantee)) or
	    not(auth_name.reverse.exist(auth))) {
		return;
	}
	auth_id := auth_ids.find(auth_name.reverse.find(auth));
	grantee_id := auth_ids.find(auth_name.reverse.find(grantee));
	
	login_id.insert(nil,grantee_id);
	role_id.insert(nil,auth_id);
} 

proc mvc_revoke_role( m, grantee, auth ) {
	auth_ids := mvc_bind_( m, "sys", "auths", "id", 1);
	auth_name := mvc_bind_( m, "sys", "auths", "id", 1);
	login_id := mvc_bind_( m, "sys", "user_role", "login_id", 1);
	role_id := mvc_bind_( m, "sys", "user_role", "role_id", 1);
	D_user_role := mvc_bind_dbat_( m, "sys", "user_role", 1);

	if (not(auth_name.reverse.exist(grantee)) or 
	    not(auth_name.reverse.exist(auth))) {
		return;
	}
	auth_id := auth_ids.find(auth_name.reverse.find(auth));
	grantee_id := auth_ids.find(auth_name.reverse.find(grantee));
	
	role := role_id.select(role_id);
	logins := login_id.semijoin(role);
	if (not(logins.reverse.exist(grantee_id)))
		return;
	id := logins.reverse.find(grantee_id);
	#print(id);
	login_id.replace(nil,int(nil));
	role_id.replace(nil,int(nil));
	D_user_role.insert(nil,id);
} 

proc mvc_create_user( m, user, passwd, fullname, schema_name, grantor ) {
	if (not(mvc_create_role( m, user, grantor )))
		return; 

	user_name := mvc_bind_( m, "sys", "users", "name", 1);
	user_passwd := mvc_bind_( m, "sys", "users", "passwd", 1);
	user_fullname := mvc_bind_( m, "sys", "users", "fullname", 1);
	user_dschema := mvc_bind_( m, "sys", "users", "default_schema", 1);

	schema_ids := mvc_bind_( m, "sys", "schemas", "id", 1);
	schema_names := mvc_bind_( m, "sys", "schemas", "name", 1);
	schema_id := schema_ids.find(schema_names.reverse.find(schema_name));

	user_name.insert(nil, user);
	user_passwd.insert(nil, passwd);
	user_fullname.insert(nil, fullname);
	user_dschema.insert(nil, schema_id);

	#print(user_name,user_passwd,user_fullname,user_dschema);
} 

proc mvc_drop_user( m, user) {
	user_name := mvc_bind_( m, "sys", "users", "name", 1);
	user_passwd := mvc_bind_( m, "sys", "users", "passwd", 1);
	user_fullname := mvc_bind_( m, "sys", "users", "fullname", 1);
	user_dschema := mvc_bind_( m, "sys", "users", "default_schema", 1);
	D_user := mvc_bind_dbat_( m, "sys", "users", 1);

	if (not(user_name.reverse.exist(user))) {
		return;
	}
	mvc_drop_role( m, user );

	id := user_name.reverse.find(user);
	#print(id);
	user_name.replace(id,str(nil));
	user_passwd.replace(id,str(nil));
	user_fullname.replace(id,str(nil));
	user_dschema.replace(id,int(nil));
	D_user.insert(nil,id);
}

proc initialize(int debug) {
	var myc := mvc_create(debug);
	var schema := mvc_admin_login(myc);
	
	if (schema != ""){
		user_name := mvc_bind_( myc, schema, "users", "name", 1);
		if (user_name.count() = 0){
			mvc_create_user( myc, "monetdb", "monetdb", "MonetDB Admin", "sys", 0);
			# probably needs priv's too 
			mvc_commit( myc, 0, "");
		}
	}
	mvc_destroy( myc );
}

initialize(sql_debug);

proc {min}(val,grp, extent) := {
	return {min}(grp.reverse.join(val), extent);
}
proc {max}(val,grp,extent) := {
	return {max}(grp.reverse.join(val), extent);
}

proc default_val( myc, cid, val ) := {
	return mvc_default( myc, cid, str(val));
}

proc atom(val):= {
	return val;
}

proc avg(BAT b):= {
	var s := b.sum();
	return s/b.count();
}

proc date_sub_sec_interval( date d, int sec ) := {
	if (sec > 0){
		return d.adddays( -1 * sec/86400);
	}
	return d;
}

proc date_add_sec_interval( date d, int sec ) := {
	if (sec > 0){
		return d.adddays(sec/86400);
	}
	return d;
}

proc date_sub_month_interval( date d, int months ) := {
	return d.addmonths(months);
}

proc sep():= {
	return "\t";
}

proc load_seps( BAT[void,BAT] bats, str Sep, str Rsep ) : BAT[void,str] := {
	var seps := new(void,str); seps.seqbase(oid(0));
	var id := 0;
	var cnt := bats.count - 1;
	bats@batloop(){
		if (id != cnt) {
			seps.insert(nil,Sep);
		} else {
			seps.insert(nil,Rsep);
		}
		id += 1;
	}
	return seps;
}

proc oid_insert( b1, b2 ) := {
	var o := b1.reverse.max();
	return b1.insert(renumber(b2,o));
}

proc bat_name(b):= return str(b);
proc bat_type(b):= return monet_atomtbl.reverse.find(b.ttype());

proc input( mvc myc, Stream Input, str tname, BAT fnames, str Sep, str rSep, int sz ):={
	var s := Input;
	if (fnames.count() > 0){
		fnames@batloop(){
			s := open_rastream( $t );
			mvc_import_table( myc, s, tname, Sep, rSep, sz );
			stream_close(s);
		}
	} else {
		mvc_import_table( myc, s, tname, Sep, rSep, sz );
	}
}

proc write_output( Stream Output, str v ) := {
	var buf := v + "\n";
	stream_write(Output, buf );
}

proc result( Stream Output, int Type, int status ) := {
	stream_writeInt( Output, 0 ); # write not done.
	stream_writeInt( Output, Type ); # write not done.
	stream_writeInt( Output, status ); # write not done.
	if (status < 0){
		stream_write( Output, "Error in result" );
	}
	stream_flush( Output );
}

proc ascii_io_output( bat Order, bat bats, Stream Output, str Sep ) : int := {
	var Max := bats.reverse.max();
	var seps := [ bats ~ const Sep];
	seps.access(BAT_WRITE);
	seps.replace(Max, "\n");

	seps := seps.reverse.mark(oid(0));
	bats := bats.reverse.mark(oid(0));
	return output( Order, seps.reverse, bats.reverse, Output );
}

proc output_header( Stream Output, int nrcols ) : void := {
	stream_writeInt( Output, 0 ); # write not done.
	stream_writeInt( Output, QHEADER ); # type TABLE.
	stream_writeInt( Output, nrcols ); # NR columns.
}

proc output_column( Stream Output, str name, str tpe ) : void := {
	var p := name + "," + tpe + "\n";
	stream_write( Output, p);
}


proc server_output( Stream Output, any Order, any val, ..any.. ) : void := {
	stream_writeInt( Output, 0 ); # write not done.
	stream_writeInt( Output, QTABLE ); # type TABLE.
	stream_writeInt( Output, 1 ); # NR records.

	cnt := $0;
	var p := str(val);
	var id := 3;
	while(id < cnt ){
 		p := p + "\t" + str($(id+1));
		id :+= 1;
	}
 	p := p + "\n"; 
	stream_write( Output, p);
	stream_flush( Output );
}

proc server_output( Stream Output, bat[oid,any] Order,  ..bat[oid,any]..) : void := {
	var cnt := Order.count();
	stream_writeInt( Output, 0 ); # write not done.
	stream_writeInt( Output, QTABLE ); # type TABLE.
	stream_writeInt( Output, cnt ); # NR records.
	
	cnt := $0;
	var bats := new(oid,bat);
	var id := 0;
	while((id + 2) < cnt ){
		bats.insert(oid(id), $(id+3));
		id :+= 1;
	}
	ascii_io_output(Order, bats, Output, "\t");
	stream_flush( Output );
}

proc SQLclient_sql( myc, Output, Input, schema, user, debug ) := {
	var buf := buffer_create( 8192 );
	var LOutput := buffer_wastream( buf, sprintf("SQLserver-%d", sock ));
	var c := sql_create_context( debug, LOutput, myc, schema, user );

	sqlclient( myc, c, Input, Output );

	mvc_destroy( myc );
	sql_destroy_context( c );
	stream_close( Output );
	stream_close( Input );
}

proc SQLclient_mil( myc, Output, Input, schema, user, debug ) := {
	var cmd := stream_read( Input );
	while(length(cmd) > 1){
		sqlexecute(cmd, Output );
		cmd := stream_read( Input );
	}
	mvc_destroy( myc );
	stream_close( Output );
	stream_close( Input );
}

proc SQLclient_thread( int sock ):= {

	var Output := block_stream(
		socket_wstream( sock, sprintf("SQLserver-%d", sock) ));
	var Input := block_stream(
		socket_rstream( sock, sprintf("SQLserver-%d", sock) ));

	var cmd := stream_read( Input ); # api('api',debug);
	#print(cmd);

	if (cmd.startsWith("api") = false ){
		printf("Protocol error: %s\n", cmd);
		return -1;
	}

	cmd := string(cmd,search(cmd, '(') + 1);
	var api := string(cmd,0,search(cmd, ','));
	cmd := string(cmd,search(cmd, ',') + 1);
	var debug := string(cmd,0,r_search(cmd, ')'));

	stream_write( Output, "login\n");
	stream_flush( Output );

	cmd := stream_read( Input ); # login(user,passwd);

	if (cmd.startsWith("login") = false ){
		printf("Protocol error: %s\n", cmd);
		return -1;
	}

	cmd := string(cmd,search(cmd, '(') + 1);
	var user := string(cmd,0,search(cmd, ','));
	cmd := string(cmd,search(cmd, ',') + 1);
	var passwd := string(cmd,0,r_search(cmd, ')'));

	var myc := mvc_create(int(debug));
	var schema := mvc_login( myc, user, passwd );
	var db := environment.find("gdk_dbname");

	stream_write( Output, db + "," + schema + "\n");
	stream_flush( Output );

	if (schema != ""){
	    if ((api.startsWith("sql"))){
		SQLclient_sql( myc, Output, Input, schema, user, int(debug) );
	    } else {
		SQLclient_mil( myc, Output, Input, schema, user, int(debug) );
	    }
	}

	socket_close( sock );
	return 0;
}

proc sqlexecute( str cmd, Stream Output ):= {
	#printf("sqlexecute %s\n", cmd);
	#scmd := squeeze(cmd,1);
	#printf("squeezed %s\n", scmd);
	eval(cmd);
}

proc SQLclient( int sock ) := {
	dsock := socket_dup(sock);
	#printf("# [ %d %d ]\n",sock, dsock);
	fork(SQLclient_thread(dsock));
}

proc new_quit() := {
	mvc_exit();
	eval("old_quit;");
}

proc get_sql_port() := {
	if (monet_environment.exist("sql_port")){
		return int(monet_environment.find("sql_port"));
	}
	var port := 45123;
	var sqlport := getenv("SQLPORT");
	if (length(sqlport) > 0){
		port := int(sqlport);
	}
	return port;
}

renameFUNC("quit", "old_quit");
renameFUNC("new_quit", "quit");

sqlserver_start(get_sql_port(), "SQLclient").fork();

