@f sqlserver
@a N.J. Nes
@* 
The sqlserver module contains the complete wrapper interface for the
SQL client and the corresponding MIL runtime startup.
@m
.MODULE sqlserver;
	.USE ascii_io;

	.ATOM mvc = ptr;
	.END;
	.ATOM sql_schema = ptr;
	.END;
	.ATOM sql_table = ptr;
	.END;
	.ATOM sql_column = ptr;
	.END;
	.ATOM sql_key = ptr;
	.END;
	
	.BUILTIN sqlclient( mvc m,  Stream in, Stream out ) = 
		sqlclient;
		"parse the next sql command and convert this to mil code"

	.COMMAND parser_init( int debug ) = parser_init_wrap; 
		"initialize the global structures for the sql parser such as keywords/types/functions/aggrs"

	.COMMAND parser_exit() = parser_exit_wrap; 
		"cleanup the global structures"

	.COMMAND sql_type(str sqlname, int digits, int scale, str name ) = 
		sql_type_wrap; "Add a new sql type"

	.COMMAND sql_aggr(str name, str imp, str atp, str rtp) = 
		sql_aggr_wrap; "Add a new sql aggregate function"

	.COMMAND sql_func(str name, str imp, str tp1, str tp2, str tp3, str rtp)
		= sql_func_wrap; "Add a new sql function"

	.COMMAND mvc_init(int debug, str dir_name) = mvc_init_wrap; 
		"create the global catalog"

	.COMMAND mvc_exit() = mvc_exit_wrap; 
		"cleanup the global catalog"

	.COMMAND mvc_create( int debug ) : mvc = mvc_create_wrap;
		"Create multi version catalog"

	.COMMAND mvc_destroy( mvc m ) = mvc_destroy_wrap;
		"Destroy multi version catalog"

	.COMMAND mvc_login( mvc m, str user, str passwd ) : str 
		= mvc_login_wrap; "database login"

	.COMMAND mvc_admin_login( mvc m ) : str 
		= mvc_admin_login_wrap; "an initial passwordless login by the admin is allowed too setup the initial users (only once)"

	.COMMAND mvc_status( mvc m ) : int 
		= mvc_status_wrap; "return the status of the last mvc operation"

	.COMMAND mvc_type( mvc m ) : int 
		= mvc_type_wrap; "return the type of the last mvc operation"

	.COMMAND mvc_commit( mvc m, int chain, str name ) : int = 
		mvc_commit_wrap; "Commit transaction/savepoint and chain"

	.COMMAND mvc_rollback( mvc m, int chain, str name ) : int = 
		mvc_rollback_wrap; "Rollback transaction/savepoint and chain"

	.COMMAND mvc_release( mvc m, str name ) : int = 
		mvc_release_wrap; "Release the savepoint"

	.COMMAND mvc_set_iso_level( mvc m, int level ) : int = 
		mvc_set_iso_level_wrap; "Change the isolation level"

	.COMMAND mvc_bind( mvc c, str sname, str tname, str cname, int access ) : 
		BAT[any::1,any::2] = 
		mvc_bind_wrap; "Bind the bat, tname.cname"

	.COMMAND mvc_bind_ubat( mvc c, str sname, str tname, str cname, int acess ) : 
		BAT[any::1,any::2] = 
		mvc_bind_ubat_wrap; "Bind bat with the updates to tname.cname"

	.COMMAND mvc_bind_obat( mvc c, str sname, str tname, int access ) : 
		BAT[any::1,any::2] = 
		mvc_bind_obat_wrap; "Bind the oid bat, tname.OID"

	.COMMAND mvc_bind_dbat( mvc c, str sname, str tname, int access ) : 
		BAT[any::1,any::2] = mvc_bind_dbat_wrap; 
		"Bind the table deletes bat, tname.deletes"

	.COMMAND mvc_bind_schema( mvc c, str sname ) : sql_schema = 
		mvc_bind_schema_wrap; "Bind schema, sname"

	.COMMAND mvc_bind_table( mvc c, sql_schema s, str tname ) : sql_table = 
		mvc_bind_table_wrap; "Bind table, s.tname"

	.COMMAND mvc_bind_column( mvc c, sql_table t, str cname ) : sql_column = 
		mvc_bind_column_wrap; "Bind column, t.cname"

	.COMMAND mvc_bind_key( mvc c, sql_table t, str kname ) : sql_key = 
		mvc_bind_key_wrap; "Bind table key with name, kname"

	.COMMAND mvc_drop_schema( mvc c, str name ) = mvc_drop_schema_wrap;
		"Drop schema"

	.COMMAND mvc_create_schema( mvc c, str name, str auth) : sql_schema = 
		mvc_create_schema_wrap; "Create schema"

	.COMMAND mvc_drop_table( mvc c, sql_schema s, str name, bit cascade ) = 
		mvc_drop_table_wrap; "Drop table"

	.COMMAND mvc_create_table( mvc c, sql_schema s, str name, int type) : 
		sql_table = mvc_create_table_wrap; "Create table"

	.COMMAND mvc_create_view( mvc c, sql_schema s, str name, str sql) :
		sql_table = mvc_create_view_wrap; "Create view"

	.COMMAND mvc_drop_column( mvc c, sql_table t, str name ) = 
		mvc_drop_column_wrap; "Drop column"

	.COMMAND mvc_create_column( mvc m, sql_table t, str name, str type, int type_digits, int type_scale, int seqnr ) : sql_column = mvc_create_column_wrap; "Create column"

	.COMMAND mvc_null( mvc m, sql_column col, int flag ) : 
		sql_column = mvc_null_wrap; "Set column null or not"

	.COMMAND mvc_default( mvc m, sql_column col, str val ) :
		sql_column = mvc_default_wrap; "Set column default value"

	.COMMAND mvc_create_key( mvc m, str sname, str tname, str name, int kt, BAT[str,int] columns, sql_key fk ) :
		sql_key = mvc_create_key_wrap; "Create a table key"

	.COMMAND mvc_export(Stream s, BAT order, BAT bats, str sep, str rsep) =
		mvc_export_wrap; "export a table (in order) to stream s with the given tuple and record seperators (sep/rsep)"

	.COMMAND mvc_import_table( mvc c, Stream s, str tname, 
					str sep, str rsep, int nr) : 
		int = mvc_import_table_wrap; 
		"import a table from stream s with the given tuple and record seperators (sep/rsep)"

@+ void bats
To prevent void bats to convert to oid bats we need overloaded insert and
replace commands. 
@m
	.COMMAND renumber( BAT[oid,any::1] b1, oid o ) : BAT[oid,any::1] = bat_renumber;
		"renumber the bat using the offset o"

 	.COMMAND insert( BAT[void,any::1] i, BAT[void,any::1] u ) : BAT[void,any::1] = bat_append_void_bat_wrap; "append the content of u to i"

 	.COMMAND insert( BAT[void,any::1] i, BAT[oid,any::1] u ) : BAT[void,any::1] = bat_append_oid_bat_wrap; "append the content of u to i"

	.COMMAND replace( BAT[void,any::1] o, BAT[oid,any::1] d ) : BAT[void,any::1] = bat_replace_oid_bat_wrap; "inplace replace values on the given locations"

.END sqlserver;

@h
#ifndef _SQLSERVER_H_
#define _SQLSERVER_H_

#include <streams.h>
#include <monet_context.h>
#include "mvc.h"
#include "sqlserver.proto.h"

#endif /*_SQLSERVER_H_*/

@c
#include "sqlserver.h"
#include <statement.h>
#include <sqlexecute.h>
#include <mem.h>
#include <context.h>
#include <kernel.h>

int mvc_init_wrap( int* debug, str dir_name){
	mvc_init(*debug, dir_name);
	return GDK_SUCCEED;
}
int mvc_exit_wrap( ){
	mvc_exit();
	return GDK_SUCCEED;
}

int parser_init_wrap( int* debug){
	parser_init(*debug );
	return GDK_SUCCEED;
}
int parser_exit_wrap( ){
	parser_exit();
	return GDK_SUCCEED;
}
int sql_type_wrap( str sqlname, int *digits, int *scale, str name ){
	(void)sql_create_type( sqlname, *digits, *scale, name );
	return GDK_SUCCEED;
}
int sql_aggr_wrap( str name, str imp, str atp, str rtp){
	(void)sql_create_aggr( name, imp, atp, rtp );
	return GDK_SUCCEED;
}
int sql_func_wrap( str name, str imp, str tp1, str tp2, str tp3, str rtp){
	(void)sql_create_func( name, imp, tp1, tp2, tp3, rtp );
	return GDK_SUCCEED;
}

int mvc_create_wrap( mvc *res, int *debug ){
	*(mvc**)res = mvc_create( *debug );
	return GDK_SUCCEED;
}

int mvc_destroy_wrap( mvc *c ){
	mvc_destroy( *(mvc**)c );
	return GDK_SUCCEED;
}

int mvc_login_wrap( str *r, mvc *c, str user, str passwd  ){
	*r = mvc_login( *(mvc**)c, user, passwd );
	if (*r == NULL)
		*r = _strdup("");
	return GDK_SUCCEED;
}

int mvc_admin_login_wrap( str *r, mvc *c ){
	*r = mvc_admin_login( *(mvc**)c );
	if (*r == NULL)
		*r = _strdup("");
	return GDK_SUCCEED;
}

int mvc_status_wrap( int* res, mvc* m ){
	*res = mvc_status( *(mvc**)m );
	return GDK_SUCCEED;
}

int mvc_type_wrap( int* res, mvc* m ){
	*res = mvc_type( *(mvc**)m );
	return GDK_SUCCEED;
}


int mvc_commit_wrap( int* res, mvc* m, int* chain, str name){
	*res = mvc_commit( *(mvc**)m, *chain, name );
	return GDK_SUCCEED;
}

int mvc_rollback_wrap( int *res, mvc *m, int *chain, str name ){
	*res = mvc_rollback( *(mvc**)m, *chain, name );
	return GDK_SUCCEED;
}

int mvc_release_wrap( int *res, mvc *m, str name ){
	*res = mvc_release( *(mvc**)m, name );
	return GDK_SUCCEED;
}

int mvc_set_iso_level_wrap( int *res, mvc *m, int *level ){
	*res = mvc_set_iso_level( *(mvc**)m, *level );
	return GDK_SUCCEED;
}

int mvc_bind_wrap( BAT** res, mvc* c, str sname, str tname, str cname, int *access){
	*res = mvc_bind( *(mvc**)c, sname, tname, cname, *access );
	if (*res){
		return GDK_SUCCEED;
	}
	return GDK_FAIL;
}

int mvc_bind_ubat_wrap( BAT** res, mvc* c, str sname, str tname, str cname, int *access ){
	*res = mvc_bind_ubat( *(mvc**)c, sname, tname, cname, *access );
	if (*res){
		return GDK_SUCCEED;
	}
	return GDK_FAIL;
}

int mvc_bind_obat_wrap( BAT** res, mvc* c, str sname, str tname, int *access ){
	*res = mvc_bind_obat( *(mvc**)c, sname, tname, *access );
	if (*res){
		return GDK_SUCCEED;
	}
	return GDK_FAIL;
}

int mvc_bind_dbat_wrap( BAT** res, mvc* c, str sname, str tname, int *access ){
	*res = mvc_bind_dbat( *(mvc**)c, sname, tname, *access );
	if (*res){
		return GDK_SUCCEED;
	}
	return GDK_FAIL;
}


int mvc_bind_schema_wrap( sql_schema* res, mvc* c, str sname){
	*(sql_schema**)res = mvc_bind_schema( *(mvc**)c, sname );
	return GDK_SUCCEED;
}

int mvc_bind_table_wrap( sql_table* res, mvc* c, sql_schema *s, str tname){
	*(sql_table**)res = mvc_bind_table( *(mvc**)c, *(sql_schema**)s, tname);
	return GDK_SUCCEED;
}

int mvc_bind_column_wrap( sql_column* res, mvc* c, sql_table *t, str col){
	*(sql_column**)res = mvc_bind_column( *(mvc**)c, *(sql_table**)t, col);
	return GDK_SUCCEED;
}

int mvc_bind_key_wrap( sql_key* res, mvc* c, sql_table *t, str name ){
	*(sql_key**)res = mvc_bind_key( *(mvc**)c, *(sql_table**)t, name);
	return GDK_SUCCEED;
}


int mvc_create_schema_wrap( sql_schema *s, mvc* c, str name, str auth){
	*(sql_schema**)s = mvc_create_schema( *(mvc**)c, name, auth );
	return GDK_SUCCEED;
}

int mvc_drop_schema_wrap( mvc* c, str name){
	mvc_drop_schema( *(mvc**)c, name );
	return GDK_SUCCEED;
}

int mvc_create_table_wrap( sql_table *res, mvc* c, sql_schema *s, str name, int* type){
	*(sql_table**)res = mvc_create_table( *(mvc**)c, *(sql_schema**)s, name, *type );
	return GDK_SUCCEED;
}

int mvc_create_view_wrap( sql_table *res, mvc* c, sql_schema *s, str name, str sql){
	*(sql_table**)res = mvc_create_view( *(mvc**)c, *(sql_schema**)s, name, sql );
	return GDK_SUCCEED;
}

int mvc_drop_table_wrap( mvc* c, sql_schema *s, str name, bit* cascade){
	mvc_drop_table( *(mvc**)c, *(sql_schema**)s, name, *cascade );
	return GDK_SUCCEED;
}


int mvc_create_column_wrap( sql_column* res, mvc* c, sql_table *t, 
		str name, str type, int *ts, int *td, int* seqnr){
	*(sql_column**)res = 
	  mvc_create_column( *(mvc**)c, *(sql_table**)t, name, type, *ts, *td, *seqnr );
	return GDK_SUCCEED;
}

int mvc_drop_column_wrap( mvc* c, sql_table *t, str name){
	mvc_drop_column( *(mvc**)c, *(sql_table**)t, name );
	return GDK_SUCCEED;
}

int mvc_null_wrap( sql_column* res, mvc* c, sql_column* col, int *flag){
	*(sql_column**)res = mvc_null( *(mvc**)c, *(sql_column**)col, *flag );
	return GDK_SUCCEED;
}

int mvc_default_wrap( sql_column* res, mvc* c, sql_column* col, str val){
	*(sql_column**)res = mvc_default( *(mvc**)c, *(sql_column**)col, val );
	return GDK_SUCCEED;
}

int mvc_create_key_wrap( sql_key* res, mvc* c, str sname, str tname, str name, int *kt, BAT *columns, sql_key *fk){
	if (*(ptr*)fk == ptr_nil){
		*(sql_key**)res = mvc_create_key( *(mvc**)c, sname, tname, name, *kt, columns, NULL);
	} else {
		*(sql_key**)res = mvc_create_key( *(mvc**)c, sname, tname, name, *kt, columns, *(sql_key**)fk);
	}
	return GDK_SUCCEED;
}

int mvc_export_wrap( Stream *s, BAT *order, BAT *bats, str sep, str rsep ){
	mvc_export( *(stream**)s, order, bats, sep, rsep );
	return GDK_SUCCEED;
}

int mvc_import_table_wrap( int *res, mvc *c, Stream *s, str tname , str sep, str rsep, int *sz ){
	*res = mvc_import_table( *(mvc**)c, *(stream**)s, tname, sep, rsep, *sz );
	if (*res < 0)
		return GDK_FAIL;
	return GDK_SUCCEED;
}

int bat_renumber( BAT **r, BAT *in, oid *O )
{
	oid o = *O;
	if (BAThdense(in)){
		BATseqbase(in, in->hseqbase + o);
	} else {
		oid *n = (oid*)BUNhead(in,BUNfirst(in)), *e = n + BATcount(in);
		while(n<e){
			*n += o;
		}
	}
	BBPfix(in->batCacheid);
	*r = in;
	return GDK_SUCCEED;
}

int bat_append_void_bat_wrap( BAT **res, BAT *i, BAT *u )
{
	*res = i;
	void_append_bat( i, u );
	BBPfix(i->batCacheid);
	return GDK_SUCCEED;
}

int bat_append_oid_bat_wrap( BAT **res, BAT *i, BAT *u )
{
	*res = i;
	void_insert_bat( i, u );
	BBPfix(i->batCacheid);
	return GDK_SUCCEED;
}

int bat_replace_oid_bat_wrap( BAT **res, BAT *o, BAT *d )
{
	*res = o;
	void_replace_bat( o, d );
	BBPfix(o->batCacheid);
	return GDK_SUCCEED;
}


@mil

module(str);
module(uchr);
module(alarm);
module(xtables);
module(aggrX3);
module(monettime);
module(mmath);
module(decimal);
module(mapi); # mapi_listen 

# dirty hack for comments ask menzo
PROC renameFUNC(str OLD,str NEW) : void := {
 	VAR funcs := monet_fcn_nme.select(OLD);
 	funcs := [funcs~NEW];
 	monet_fcn_nme.replace(funcs);
 	monet_fcntbl.reverse.replace(funcs);
}

var sql_debug := int(monet_environment.find("sql_debug"));
parser_init(sql_debug);

sql_type("OID", 0, 0, 	  	"oid");
sql_type("BOOL", 0, 0,	  	"bit");
sql_type("BOOLEAN", 0, 0,	"bit");

sql_type("CHAR", 0, 0,  	"str"); # defined as a fixed length string 
sql_type("CHARACTER", 0, 0, 	"str");
sql_type("VARCHAR", 0, 0, 	"str");

sql_type("TEXT", 0, 0, 		"str");
sql_type("TINYTEXT", 0, 0, 	"str");
sql_type("STRING", 0, 0, 	"str");

# *INT(n) n <= 2 -> TINYINT
#	  n <= 5 -> SMALLINT
#	  n <= 9 -> MEDIUMINT
#	  n <= 19 -> BIGINT

sql_type("UBYTE", 2, 0,		"uchr");
sql_type("TINYINT", 2, 0, 	"sht"); # sht as sum(uchr) isn't implemented 
sql_type("SMALLINT", 5, 0,	"sht");
sql_type("MEDIUMINT", 9, 0,	"int");
sql_type("INTEGER", 9, 0,	"int");
sql_type("NUMBER", 9, 0,	"int");
sql_type("BIGINT", 19, 0,	"lng");

#sql_type("INT", 2, 0, 		"uchr"); 
sql_type("INT", 5, 0,		"sht");
sql_type("INT", 9, 0,		"int");
sql_type("INT", 19, 0,		"lng");

# float(n) (n indicates precision of atleast n digits)
# ie n <= 23 -> flt
#    n <= 51 -> dbl
#    n <= 62 -> long long dbl (with -ieee) (not supported)
# this requires a type definition

sql_type("FLOAT", 23, 0, 	"flt");
sql_type("FLOAT", 51, 0, 	"dbl");

sql_type("DOUBLE", 51, 0, 	"dbl");
sql_type("REAL", 51, 0, 	"dbl");

# decimal(n) == int(n)

#sql_type("DECIMAL", 2, 0, 		"uchr"); 
sql_type("DECIMAL", 5, 0,		"sht");
sql_type("DECIMAL", 9, 0,		"int");
sql_type("DECIMAL", 19, 0,		"lng");

# decimal(d,s) (d indicates nr digits, s scale indicates nr of digits after the dot .)
#sql_type("DECIMAL", 51, 50, "decimal");		# (fixed precision) requires decimal module

sql_type("DECIMAL", 23, 22,		"flt");
sql_type("DECIMAL", 51, 50,		"dbl");

#sql_type("NUMERIC", 2, 0, 		"uchr"); 
sql_type("NUMERIC", 5, 0,		"sht");
sql_type("NUMERIC", 9, 0,		"int");
sql_type("NUMERIC", 19, 0,		"lng");

sql_type("NUMERIC", 23, 22,		"flt");
sql_type("NUMERIC", 51, 50,		"dbl");


# Date etc

sql_type("MONTH_INTERVAL", 0, 0, 	"int");
sql_type("SEC_INTERVAL", 0, 0, 		"int");
sql_type("DATE", 0, 0, 			"date");
sql_type("TIME", 0, 0, 			"time");
sql_type("DATETIME", 0, 0, 		"datetime");
sql_type("TIMESTAMP", 0, 0, 		"timestamp");

var strings := new(str,str);
strings.insert("CHAR", 		"chr");
strings.insert("VARCHAR", 	"str");

var numerical := new(str,str); # head is the sum result type 
numerical.insert("int", 	"uchr"); 
numerical.insert("int", 	"sht");
numerical.insert("lng", 	"int");
numerical.insert("lng", 	"lng");
numerical.insert("dbl", 	"dbl");

var floats := new(str,str);	# head is the sum result type
floats.insert("dbl", 		"flt");
floats.insert("dbl", 		"dbl");
numerical.insert(floats);

var dates := new(str,str);
dates.insert("MONTH_INTERVAL", "int");
dates.insert("SEC_INTERVAL", "int");
dates.insert("DATE", "date");
dates.insert("TIME", "time");
dates.insert("TIMESTAMP", "timestamp");

var type_sql := bat(str,str);
type_sql.insert(strings);
type_sql.insert(numerical);
type_sql.insert(dates);

type_sql@batloop(){ sql_aggr( "min", "min", $t, $t ); }
type_sql@batloop(){ sql_aggr( "max", "max", $t, $t ); }
# sum has special output types
numerical@batloop(){ sql_aggr( "sum", "sum_" + $h, $t, $h ); }
# avg only outputs doubles
numerical@batloop(){ sql_aggr( "avg", "avg", $t, "dbl" ); }
sql_aggr( "count", "count", "", "int" ); 

numerical@batloop(){ sql_func( "sql_sub", "-", $t, $t, "", $t ); }
numerical@batloop(){ sql_func( "sql_add", "+", $t, $t, "", $t ); }
numerical@batloop(){ sql_func( "sql_mul", "*", $t, $t, "", $t ); }
numerical@batloop(){ sql_func( "sql_div", "/", $t, $t, "", $t ); }
numerical@batloop(){ sql_func( "sql_max", "max", $t, $t, "", $t ); }
numerical@batloop(){ sql_func( "sql_min", "min", $t, $t, "", $t ); }
numerical@batloop(){ sql_func( "sql_neg", "-", $t, "", "", $t ); }

numerical@batloop(){ 
	var hd := $t; 
	numerical@batloop(){ 
		if ($t != hd){
		    sql_func( "convert", $t, hd, "", "", $t );
		}
	}
}

strings@batloop(){ 
	var hd := $t; 
	strings@batloop(){ 
		if ($t != hd){
		    sql_func( "convert", $t, hd, "", "", $t );
		}
	}
}

strings@batloop(){ 
	var hd := $t; 
	numerical@batloop(){ 
		sql_func( "convert", $t, hd, "", "", $t );
	}
}

floats@batloop(){ 
	sql_func( "floor", "floor", $t, "", "", $t ); 
	sql_func( "ceil", "ceil", $t, "", "", $t ); 
	sql_func( "sin", "sin", $t, "", "", $t ); 
	sql_func( "cos", "cos", $t, "", "", $t ); 
	sql_func( "tan", "tan", $t, "", "", $t ); 
	sql_func( "asin", "asin", $t, "", "", $t ); 
	sql_func( "acos", "acos", $t, "", "", $t ); 
	sql_func( "atan", "atan", $t, "", "", $t ); 
	sql_func( "sinh", "sinh", $t, "", "", $t ); 
	sql_func( "cosh", "cosh", $t, "", "", $t ); 
	sql_func( "tanh", "tanh", $t, "", "", $t ); 
	sql_func( "sqrt", "sqrt", $t, "", "", $t ); 
	sql_func( "exp", "exp", $t, "", "", $t ); 
	sql_func( "log", "log", $t, "", "", $t ); 
	sql_func( "log10", "log10", $t, "", "", $t ); 
}

sql_func( "current_date", "current_date", "", "", "" , "date" );
sql_func( "current_time", "current_time", "", "", "" , "time" );
sql_func( "current_timestamp", "current_timestamp", "", "", "" , "timestamp" );

sql_func( "sql_sub", "date_sub_sec_interval", "date", "int", "", "date");
sql_func( "sql_sub", "date_sub_month_interval", "date", "int", "", "date");

sql_func( "sql_add", "date_add_sec_interval", "date", "int", "", "date");
sql_func( "sql_add", "addmonths", "date", "int", "", "date");

sql_func( ">", ">", "date", "date", "", "bit");
sql_func( "<", "<", "date", "date", "", "bit");

sql_func( "year", "year", "date", "", "", "int");
sql_func( "month", "month", "date", "", "", "int");

sql_func( "substring", "string", "str", "int", "int", "str");
sql_func( "strconcat", "+", "str", "str", "", "str");

proc sql_add(x, y):= return x + y;
proc sql_sub(x, y):= return x - y;
proc sql_mul(x, y):= return x * y;
proc sql_div(x, y):= return x / y;
proc sql_neg(val):= return -1 * val;

var dbname := monet_environment.find("gdk_dbname");
var dbfarm := monet_environment.find("gdk_dbfarm");
mvc_init(sql_debug,dbfarm + "/" + dbname + "/log");

proc mvc_bind_( m, schema, Table, column, write_access ){
	res := mvc_bind(m, schema,Table, column, write_access);
	if (write_access > 0){
		res := res.access(BAT_WRITE);
	} 
	return res;
}

proc mvc_bind_dbat_( m, schema, Table, write_access ){
	res := mvc_bind_dbat(m, schema, Table, write_access);
	if (write_access > 0){
		res := res.access(BAT_WRITE);
	} 
	return res;
}

proc initialize(int debug) {
        # change to sql statements !!
        var myc = mvc_create(debug);
        var schema = mvc_admin_login(myc);

        if (schema != ""){
                user_name = mvc_bind_( myc, schema, "users", "name", 1);
                if (user_name.count() = 0){
                        mvc_create_user( myc, "monetdb", "monetdb", "MonetDB Admin", "sys", 0);
                        # probably needs priv's too
                        mvc_commit( myc, 0, "");
                }
        }
        mvc_destroy( myc );
}

initialize(sql_debug);

proc {min}(val,grp, extent) := {
	return {min}(grp.reverse.join(val), extent);
}
proc {max}(val,grp,extent) := {
	return {max}(grp.reverse.join(val), extent);
}

proc default_val( myc, cid, val ) := {
	return mvc_default( myc, cid, str(val));
}

proc atom(val):= {
	return val;
}

proc date_sub_sec_interval( date d, int sec ) := {
	if (sec > 0){
		return d.adddays( -1 * sec/86400);
	}
	return d;
}

proc date_add_sec_interval( date d, int sec ) := {
	if (sec > 0){
		return d.adddays(sec/86400);
	}
	return d;
}

proc date_sub_month_interval( date d, int months ) := {
	return d.addmonths(months);
}

proc sep():= {
	return "\t";
}

proc load_seps( BAT[void,BAT] bats, str Sep, str Rsep ) : BAT[void,str] := {
	var seps := new(void,str); seps.seqbase(oid(0));
	var id := 0;
	var cnt := bats.count - 1;
	bats@batloop(){
		if (id != cnt) {
			seps.insert(nil,Sep);
		} else {
			seps.insert(nil,Rsep);
		}
		id += 1;
	}
	return seps;
}

proc oid_insert( b1, b2 ) := {
	var o := b1.reverse.max();
	return b1.insert(renumber(b2,o));
}

proc bat_name(b):= return str(b);
proc bat_type(b):= return monet_atomtbl.reverse.find(b.ttype());

proc input( mvc myc, Stream Input, str tname, BAT fnames, str Sep, str rSep, int sz ):={
	var s := Input;
	if (fnames.count() > 0){
		fnames@batloop(){
			f := iconv($t, "UTF-8", codeset());
			s := open_rastream(f);
			
			mvc_import_table( myc, s, tname, Sep, rSep, sz );
			stream_close(s);
		}
	} else {
		mvc_import_table( myc, s, tname, Sep, rSep, sz );
	}
}

proc ascii_io_output( bat Order, bat bats, Stream Output, str Sep ) : int := {
	var Max := bats.reverse.max();
	var seps := [ bats ~ const Sep];
	seps.access(BAT_WRITE);
	seps.replace(Max, "\n");

	seps := seps.reverse.mark(oid(0));
	bats := bats.reverse.mark(oid(0));
	return output( Order, seps.reverse, bats.reverse, Output );
}

proc output_header( Stream Output, int nrcols ) : void := {
	stream_writeInt( Output, 0 ); # write not done.
	stream_writeInt( Output, QHEADER ); # type TABLE.
	stream_writeInt( Output, nrcols ); # NR columns.
}

proc output_column( Stream Output, str name, str tpe ) : void := {
	var p := name + "," + tpe + "\n";
	stream_write( Output, p);
}

proc server_output( Stream Output, any Order, any val, ..any.. ) : void := {
	stream_writeInt( Output, 0 ); # write not done.
	stream_writeInt( Output, QTABLE ); # type TABLE.
	stream_writeInt( Output, 1 ); # NR records.

	cnt := $0;
	var p := str(val);
	if (type(val) = str)
		p := "\"" + val + "\"";
	var id := 3;
	while(id < cnt ){
		if (type($(id+1)) != str)
 			p := p + "\t" + str($(id+1));
		else
 			p := p + "\t\"" + str($(id+1)) + "\"";
		id :+= 1;
	}
 	p := p + "\n"; 
	stream_write( Output, p);
	stream_flush( Output );
}

proc server_output( Stream Output, bat[oid,any] Order,  ..bat[oid,any]..) : void := {
	var cnt := Order.count();
	stream_writeInt( Output, 0 ); # write not done.
	stream_writeInt( Output, QTABLE ); # type TABLE.
	stream_writeInt( Output, cnt ); # NR records.
	
	cnt := $0;
	var bats := new(oid,bat);
	var id := 0;
	while((id + 2) < cnt ){
		bats.insert(oid(id), $(id+3));
		id :+= 1;
	}
	ascii_io_output(Order, bats, Output, "\t");
	stream_flush( Output );
}

proc SQLclient_thread( int sock ):= {

	var Output := block_stream(
		socket_wstream( sock, sprintf("SQLserver-%d", sock) ));
	var Input := block_stream(
		socket_rstream( sock, sprintf("SQLserver-%d", sock) ));

	var cmd := stream_read( Input ); # api('api',debug);
	#print(cmd);

	if (cmd.startsWith("api") = false ){
		printf("Protocol error: %s\n", cmd);
		return -1;
	}

	cmd := string(cmd,search(cmd, '(') + 1);
	var api := string(cmd,0,search(cmd, ','));

	if ((api.startsWith("sql")) = false){
		printf("Protocol api error: %s\n", api);
		return -1;
	}

	cmd := string(cmd,search(cmd, ',') + 1);
	var debug := string(cmd,0,r_search(cmd, ')'));

	stream_write( Output, "login\n");
	stream_flush( Output );

	cmd := stream_read( Input ); # login(user,passwd);

	if (cmd.startsWith("login") = false ){
		printf("Protocol error: %s\n", cmd);
		return -1;
	}

	cmd := string(cmd,search(cmd, '(') + 1);
	var user := string(cmd,0,search(cmd, ','));
	cmd := string(cmd,search(cmd, ',') + 1);
	var passwd := string(cmd,0,r_search(cmd, ')'));

	var myc := mvc_create(int(debug));
	var schema := mvc_login( myc, user, passwd );
	var db := environment.find("gdk_dbname");

	stream_write( Output, db + "," + schema + "\n");
	stream_flush( Output );

	if (schema != ""){
		sqlclient( myc, Input, Output );
	}
	stream_close( Output );
	stream_close( Input );

	socket_close( sock );
	return 0;
}

proc SQLclient( int sock ) := {
	dsock := socket_dup(sock);
	#printf("# [ %d %d ]\n",sock, dsock);
	fork(SQLclient_thread(dsock));
}

proc new_quit() := {
	mvc_exit();
	eval("old_quit;");
}

proc get_sql_port() := {
	if (monet_environment.exist("sql_port")){
		return int(monet_environment.find("sql_port"));
	}
	var port := 45123;
	var sqlport := getenv("SQLPORT");
	if (length(sqlport) > 0){
		port := int(sqlport);
	}
	return port;
}

renameFUNC("quit", "old_quit");
renameFUNC("new_quit", "quit");

mapi_listen(get_sql_port(), 5, "SQLclient").fork();
