@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@' 
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@' 
@' The Original Code is the Monet Database System.
@' 
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2004 CWI.
@' All Rights Reserved.
@' 
@' Contributor(s):
@' 		Martin Kersten <Martin.Kersten@cwi.nl>
@' 		Peter Boncz <Peter.Boncz@cwi.nl>
@' 		Niels Nes <Niels.Nes@cwi.nl>
@' 		Stefan Manegold  <Stefan.Manegold@cwi.nl>

@f sql_privileges
@a N.J. Nes
@* Privileges

Sql has a simple access control schema. There are two types of authorization,
users and roles. Each user may be part of several roles.
For each authorization identity a set of privileges is administrated.
These are administrated on multiple levels where lower levels (ie.
table or column level) overwrite privileges on higher levels.

@h
#ifndef _SQL_PRIV_H_
#define _SQL_PRIV_H_

/* privileges */
#include <sql_mvc.h>

#define PRIV_SELECT 1
#define PRIV_UPDATE 2
#define PRIV_INSERT 4
#define PRIV_DELETE 8
#define PRIV_EXECUTE 16
#define PRIV_GRANT 32

#define ROLE_PUBLIC   1
#define ROLE_SYSADMIN 2
#define USER_MONETDB  3

sql_export int mvc_set_role( mvc *m, char *role );
sql_export int mvc_set_schema( mvc *m, char *schema );
sql_export char *mvc_login( mvc *c, char *user, char *passwd );

extern int schema_privs( mvc *m, sql_schema *t, int privs );
extern int table_privs( mvc *m, sql_table *t, int privs );

extern int sql_privilege( mvc *m, int auth_id, int obj_id, int privs, int sub );
extern int sql_grantable( mvc *m, int grantorid, int obj_id, int privs, int sub );
extern int sql_find_auth( mvc *m, str auth );
extern int sql_find_schema( mvc *m, str schema );

sql_export int sql_create_role(mvc *m,  str auth, int grantor ) ;
sql_export int sql_drop_role( mvc *m, str auth );
sql_export int sql_grant_role( mvc *m, str grantee, str auth );
sql_export int sql_revoke_role( mvc *m, str grantee, str auth );
sql_export int sql_create_user( mvc *m, str user, str passwd,str  fullname, str schema_name,int grantor );
sql_export int sql_drop_user(mvc *m,  str user);

#endif /*_SQL_PRIV_H_ */
@c
#include <gdk.h>
/*#include <monet_context.h>*/
#include "sql_privileges.h"
#include "sql_bm.h"
#include "sql_statement.h"
/*#include <algebra.h>*/

@-
The remainder has been taken over from the sql_server mil document.
The code below provides abstractions to manage the priviliges.
@= accessRight
	p = BUNfnd(BATmirror(auth_name), @1);
	if(!p) return FALSE;
@= accessId
	@1 = bun_find(BATmirror(auth_name),@2);
@c
int sql_create_role(mvc *m,  str auth, int grantor ) 
{ BAT *auth_id, *auth_name, *auth_grantor;
  int one = 1;
  oid onil =oid_nil;
  ptr p;
	auth_id = mvc_bind( m, "sys", "auths", "id", UPD); 
	auth_name = mvc_bind( m, "sys", "auths", "name", UPD);
	auth_grantor = mvc_bind( m, "sys", "auths", "grantor", UPD);
	
	p = BUNfnd(BATmirror(auth_name), auth);
	if (p){
		return FALSE;
	}
	if (BATcount(auth_id) > 0) {
		int ma = BATcount(auth_id);
		/*BATmax(auth_id,&ma);*/
		ma++;
		BUNins(auth_id, &onil, &ma);
	} else {
		BUNins(auth_id, &onil, &one);
	}
	BUNins(auth_name, &onil, auth);
	BUNins(auth_grantor, &onil, &grantor);
	bat_destroy(auth_id);
	bat_destroy(auth_name);
	bat_destroy(auth_grantor);
	return TRUE;
} 

int sql_drop_role( mvc *m, str auth )
{ BAT *auth_id, *auth_name, *auth_grantor, *D_auth;
  ptr id, p;
  oid onil =oid_nil;
	auth_id = mvc_bind( m, "sys", "auths", "id", DEL);
	auth_name = mvc_bind( m, "sys", "auths", "name", DEL);
	auth_grantor = mvc_bind( m, "sys", "auths", "grantor", DEL);
	D_auth = mvc_bind_dbat( m, "sys", "auths", INS);
	
	@:accessRight(auth)@
	@:accessId(id,auth)@
	BUNins(auth_id,&id, &int_nil);
	BUNins(auth_name,&id, &str_nil);
	BUNins(auth_grantor,&id, &int_nil);
	BUNins(D_auth,&onil,id);

	bat_destroy(auth_id);
	bat_destroy(auth_name);
	bat_destroy(auth_grantor);
	bat_destroy(D_auth);
	return TRUE;
} 

int sql_grant_role( mvc *m, str grantee, str auth )
{ BAT *auth_ids, *auth_name, *login_id, *role_id;
  ptr auth_id, grantee_id, p;
  oid onil = oid_nil;
	auth_ids = mvc_bind( m, "sys", "auths", "id", UPD);
	auth_name = mvc_bind( m, "sys", "auths", "id", UPD);
	login_id = mvc_bind( m, "sys", "user_role", "login_id", UPD);
	role_id = mvc_bind( m, "sys", "user_role", "role_id", UPD);

	@:accessRight(grantee)@
	@:accessRight(auth)@

	@:accessId(auth_id,auth)@
	@:accessId(grantee_id,grantee)@
	
	BUNins(login_id, &onil,grantee_id);
	BUNins(role_id, &onil,auth_id);

	bat_destroy(auth_ids);
	bat_destroy(auth_name);
	bat_destroy(login_id);
	bat_destroy(role_id);
	return TRUE;
} 

int sql_revoke_role( mvc *m, str grantee, str auth ) 
/* grantee no longer belongs the role (auth) */ 
{ BAT *auth_ids, *auth_name, *login_id, *role_id, *D_user_role;
  BAT *role, *logins;
  ptr id, auth_id, grantee_id, p;
  oid onil =oid_nil;
	auth_ids = mvc_bind( m, "sys", "auths", "id", RDONLY);
	auth_name = mvc_bind( m, "sys", "auths", "id", RDONLY);
	login_id = mvc_bind( m, "sys", "user_role", "login_id", DEL);
	role_id = mvc_bind( m, "sys", "user_role", "role_id", DEL);
	D_user_role = mvc_bind_dbat( m, "sys", "user_role", INS);

	@:accessRight(grantee)@
	@:accessRight(auth)@

	@:accessId(auth_id,auth)@
	@:accessId(grantee_id,grantee)@
	
	role = BATselect(role_id, &auth_id, &auth_id);

	logins = BATsemijoin(login_id,role);
	p = BUNfnd(BATmirror(logins), grantee_id);
	if (!p)
		return FALSE;
	id = bun_find(BATmirror(logins),grantee_id);
	BUNreplace(login_id,id,&int_nil);
	BUNreplace(role_id,id,&int_nil);
	BUNins(D_user_role, &onil,id);
	bat_destroy(auth_ids);
	bat_destroy(auth_name);
	bat_destroy(logins);
	bat_destroy(login_id);
	bat_destroy(role_id);
	bat_destroy(D_user_role);
	return TRUE;
} 

int sql_find_auth( mvc *m, str auth )
{
	int res = -1;
	BAT *auth_name = mvc_bind( m, "sys", "auths", "name", RDONLY);
	BAT *auth_id = mvc_bind( m, "sys", "auths", "id", RDONLY);
	BUN p = BUNfnd(BATmirror(auth_name), auth);
	
	if (p){
		oid id = *(oid*)BUNhead(auth_name, p);
		res = *(int*)BUNtail(auth_id, BUNfnd(auth_id, &id));
	}

	bat_destroy(auth_name);
	bat_destroy(auth_id);
	return res;
}

int sql_find_schema( mvc *m, str schema )
{
	BAT *schema_ids = mvc_bind( m, "sys", "schemas", "id", RDONLY);
	BAT *schema_names = mvc_bind( m, "sys", "schemas", "name", RDONLY);
	BUN p;
	int schema_id = -1;

	p = BUNfnd(BATmirror(schema_names), schema);
	if (p) {
		oid id = *(oid*)BUNhead(schema_names, p);
		schema_id = *(int*)BUNtail(schema_ids, BUNfnd(schema_ids, &id));
	}
	
	bat_destroy(schema_ids);
	bat_destroy(schema_names);
	return schema_id;
}

int sql_create_user( mvc *m, str user, str passwd, str fullname, str schema_name,int grantor )
{ 
	BAT *user_name, *user_passwd, *user_fullname, *user_dschema;
  	BAT *schema_ids, *schema_names;
  	ptr schema_id;
  	oid onil =oid_nil;

	if (!(sql_create_role( m, user, grantor )))
		return FALSE; 

	user_name = mvc_bind( m, "sys", "db_users", "name", UPD);
	user_passwd = mvc_bind( m, "sys", "db_users", "passwd", UPD);
	user_fullname = mvc_bind( m, "sys", "db_users", "fullname", UPD);
	user_dschema = mvc_bind( m, "sys", "db_users", "default_schema", UPD);

	schema_ids = mvc_bind( m, "sys", "schemas", "id", 0);
	schema_names = mvc_bind( m, "sys", "schemas", "name", 0);

	schema_id = bun_find(schema_ids, bun_find(BATmirror(schema_names),schema_name));

	BUNins(user_name, &onil, user);
	BUNins(user_passwd, &onil, passwd);
	BUNins(user_fullname, &onil, fullname);
	BUNins(user_dschema, &onil, schema_id);

	bat_destroy(user_name);
	bat_destroy(user_passwd);
	bat_destroy(user_fullname);
	bat_destroy(user_dschema);
	bat_destroy(schema_ids);
	bat_destroy(schema_names);
	return TRUE;
} 

int sql_drop_user(mvc *m,  str user) 
{ BAT *user_name, *user_passwd, *user_fullname, *user_dschema, *D_user;
  ptr id, p;
  oid onil = oid_nil;
	user_name = mvc_bind( m, "sys", "db_users", "name", DEL);
	user_passwd = mvc_bind( m, "sys", "db_users", "passwd", DEL);
	user_fullname = mvc_bind( m, "sys", "db_users", "fullname", DEL);
	user_dschema = mvc_bind( m, "sys", "db_users", "default_schema", DEL);
	D_user = mvc_bind_dbat( m, "sys", "db_users", INS);

	p = BUNfnd(BATmirror(user_name), user);
	if (!p)
		return FALSE;
	sql_drop_role( m, user );

	id = bun_find(BATmirror(user_name),user);
	BUNreplace(user_name, id, &str_nil);
	BUNreplace(user_passwd,id, &str_nil);
	BUNreplace(user_fullname,id,&str_nil);
	BUNreplace(user_dschema,id,&int_nil);
	BUNins(D_user, &onil,id);
	bat_destroy(user_name);
	bat_destroy(user_passwd);
	bat_destroy(user_fullname);
	bat_destroy(user_dschema);
	bat_destroy(D_user);
	return TRUE;
}

int sql_privilege( mvc *m, int auth_id, int obj_id, int priv, int sub )
{
 	BAT *priv_obj = mvc_bind( m, "sys", "privileges", "obj_id", RDONLY);
 	BAT *priv_auth = mvc_bind( m, "sys", "privileges", "auth_id", RDONLY);
 	BAT *priv_priv = mvc_bind( m, "sys", "privileges", "privileges", RDONLY);
	int res = 0;
	
	BAT *b1,*b2 = BATselect(priv_obj, &obj_id, &obj_id );

	(void)sub;
	b1 = BATsemijoin(priv_auth, b2);
	bat_destroy(b2);
	b2 = BATselect( b1, &auth_id, &auth_id );
	bat_destroy(b1);
	b1 = BATsemijoin(priv_priv, b2);
	bat_destroy(b2);
	b2 = BATselect(b1, &priv, &priv);
	bat_destroy(b1);

	if (BATcount(b2) == 1){
		res = priv;
	}
	bat_destroy(b2);

	bat_destroy(priv_obj);
	bat_destroy(priv_auth);
	bat_destroy(priv_priv);
	return res;
}

int schema_privs( mvc *m, sql_schema *s, int priv )
{
	if (m->user_id == USER_MONETDB || m->role_id == s->auth_id ||
	    sql_privilege( m, m->user_id, s->base.id, priv, 0 ) == priv ||
	    sql_privilege( m, m->role_id, s->base.id, priv, 0 ) == priv ||
	    sql_privilege( m, ROLE_PUBLIC, s->base.id, priv, 0 ) == priv) {
		return 1;
	}
	return 0;
}

int table_privs( mvc *m, sql_table *t, int priv )
{
	if (m->user_id == USER_MONETDB || m->role_id == t->s->auth_id ||
	    sql_privilege( m, m->user_id, t->base.id, priv, 0 ) == priv ||
	    sql_privilege( m, m->role_id, t->base.id, priv, 0 ) == priv ||
	    sql_privilege( m, ROLE_PUBLIC, t->base.id, priv, 0 ) == priv) {
		return 1;
	}
	return 0;
}

int sql_grantable_( mvc *m, int grantorid, int obj_id, int privs, int sub )
{
	BUN p,q;
 	BAT *priv_obj = mvc_bind( m, "sys", "privileges", "obj_id", RDONLY);
 	BAT *priv_auth = mvc_bind( m, "sys", "privileges", "auth_id", RDONLY);
 	BAT *priv_priv = mvc_bind( m, "sys", "privileges", "privileges", RDONLY);
 	BAT *priv_allowed = mvc_bind( m, "sys", "privileges", "grantable", RDONLY);
	BAT *b1,*b2 = BATselect(priv_obj, &obj_id, &obj_id );
	(void)sub;

	b1 = BATsemijoin(priv_auth, b2);
	bat_destroy(b2);
	b2 = BATselect( b1, &grantorid, &grantorid );
	bat_destroy(b1);
	b1 = BATsemijoin(priv_priv, b2);
	bat_destroy(b2);

	BATloop(b1, p, q) {
		oid id = *(oid*)BUNhead(b1,p);
		int priv = *(int*)BUNtail(b1,p);
		int allowed = *(int*)BUNtail(priv_allowed, 
						BUNfnd(priv_allowed, &id));
		/* switch of priv bit */
		if (allowed)
			privs = (privs & ~priv); 
	}
	bat_destroy(b1);

	bat_destroy(priv_obj);
	bat_destroy(priv_auth);
	bat_destroy(priv_priv);
	bat_destroy(priv_allowed);
	if (privs != 0)
		return 0;
	return 1;
}

int sql_grantable( mvc *m, int grantorid, int obj_id, int privs, int sub )
{
	if (m->user_id == USER_MONETDB) 
		return 1;
	return sql_grantable_(m, grantorid, obj_id, privs, sub);
}

static 
int mvc_set_user( mvc *m, char *user )
{
	BUN p;
	int res = 0;
	BAT *auth_name = BATmirror(mvc_bind(m, "sys", "auths", "name", 0 ));

	if (m->debug)
		fprintf(stderr, "mvc_set_user %s\n", user);

	if ((p=BUNfnd(auth_name, user)) != NULL){
		ptr lid = BUNtail(auth_name,p);
		BAT *auth_id = mvc_bind(m, "sys", "auths", "id", 0 );
		int id = *(int*)BUNtail(auth_id, BUNfnd(auth_id, lid));
		m->user_id = m->role_id = id;
		m->user = _strdup(user);
		m->role = _strdup(user);
		res = 1;
		bat_destroy(auth_id);
	}
	bat_destroy(auth_name);
	return res;
}

int mvc_set_role( mvc *m, char *role )
{
	BUN p;
	int res = 0;
	BAT *auth_name = BATmirror(mvc_bind(m, "sys", "auths", "name", 0 ));

	if (m->debug)
		fprintf(stderr, "mvc_set_role %s\n", role);

	if ((p=BUNfnd(auth_name, role)) != NULL){
		ptr lid = BUNtail(auth_name,p);
		BAT *auth_id = mvc_bind(m, "sys", "auths", "id", 0 );
		int id = *(int*)BUNtail(auth_id, BUNfnd(auth_id, lid));
		/* todo check if user is part of this role */
		m->role_id = id;
		m->role = _strdup(role);
		res = 1;
		bat_destroy(auth_id);
	}
	bat_destroy(auth_name);
	return res;
}

int mvc_set_schema( mvc *m, char *schema )
{
	int ret = 0;
	sql_schema *s = find_schema(m->trans, schema);

	if (s) {
		if (m->schema)
			_DELETE(m->schema);
		m->schema = _strdup(schema);
		m->status = 0;
		m->type = Q_TRANS;
		if (m->trans)
			m->trans->schema = s;
		ret = 1;
	}
	return ret;
}

char *mvc_login(mvc *m, char *user, char *passwd)
{
	char *schema = NULL;
	BAT *name_user;
	BUN p;

	if (m->debug)
		fprintf(stderr, "mvc_login %s\n", user);

	mvc_trans(m);
 	name_user = BATmirror(mvc_bind(m, "sys", "db_users", "name", 0 ));
	if ((p=BUNfnd(name_user, user)) != NULL){
		ptr userid = BUNtail(name_user, p);
		BAT *user_pwd = mvc_bind(m, "sys", "db_users", "passwd", 0 );
		char *pwd = BUNtail(user_pwd, BUNfnd(user_pwd, userid));
		
		if (strcmp(passwd, pwd) == 0){
			BAT *user_ds = mvc_bind(m, "sys", "db_users", "default_schema", 0 );
			BAT *id_schema = BATmirror(mvc_bind(m, "sys", "schemas", "id", 0 ));
			BAT *schema_name = mvc_bind(m, "sys", "schemas", "name", 0 );
			ptr schema_id = BUNtail(user_ds, BUNfnd(user_ds, userid)); 
			ptr lid = BUNtail(id_schema,BUNfnd(id_schema, schema_id));
			schema = BUNtail(schema_name,BUNfnd(schema_name, lid));
			if (mvc_set_user(m, user)){ 
				schema = _strdup(schema);
			} else { /* only set schema if user is found */
				schema = NULL;
			}
			bat_destroy(id_schema);
			bat_destroy(schema_name);
			bat_destroy(user_ds);
		}
		bat_destroy(user_pwd);
	}
	bat_destroy(name_user);

	if (!schema)
		return NULL;

	if (!mvc_set_schema( m, schema)) {
		_DELETE(schema);
		return NULL;
	}
	mvc_rollback(m, 0, NULL);
	return schema;
}

