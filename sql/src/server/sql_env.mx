@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@' 
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@' 
@' The Original Code is the Monet Database System.
@' 
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2004 CWI.
@' All Rights Reserved.
@' 
@' Contributor(s):
@' 		Martin Kersten <Martin.Kersten@cwi.nl>
@' 		Peter Boncz <Peter.Boncz@cwi.nl>
@' 		Niels Nes <Niels.Nes@cwi.nl>
@' 		Stefan Manegold  <Stefan.Manegold@cwi.nl>

@f sql_env
@a N.J. Nes
@* Environment variables
The processing setting of the SQL front-end can collect information
for postprocessing and debugging by setting a flag
using the SQL construct: 
SET <variable>=<string> 
SET <variable>=<boolean>
SET <variable>=<int>

The SQL engine comes with a limited set of environment variables
to control its behaviour. 
The 'debug' variable takes an integer and sets the Mserver global
debug flag. (See MonetDB documentation.)
The 'explain' variable currently takes the values 'plan' or
'performance'. The 'plan' qualifier produces a relational table with
the plan derived for execution using the applicable backend and
optimizer schemes. The 'performance' qualifier produces a performance
trace of the SQL queries for post analysis. It is available in
the system table called history. Ommission of either qualifier merely
results in a straight execution of the query.

The 'auto_commit' flag takes a boolean and controls automatic commit
after a successful SQL execution, or conversely an automatic rollback.

The 'reply_size' limits the number of tuples sent to the front end.
[It is unclear how the remainder can be obtained within the SQL language
framework. The reply_size should be replaced by 'limit']
The 'history' variable is a boolean flag which captures execution information
of any SQL query in a table for post-analysis.

By default all remaining variables are stored as strings and 
any type analysis is up to the user. The can be freely used by the
SQL programmer for inclusion in his queries. [TODO]

The limited number of builtin variables defined above are 
strongly typed the hard way.
Moreover, they have a counterpart representation in the 
MVC structure to ease inspection during query processing.

The variables and their type definition are assembled in a system table
called 'sessions'.
@{
@h
#ifndef _SQL_ENV_H_
#define _SQL_ENV_H_

#include "sql_parser.h"
#include "sql_symbol.h"
#include "sql_statement.h"
#include "sql_mvc.h"

sql_export int mvc_debug_on( mvc *m, int flag);

sql_export stmt *sql_set_var(mvc *sql, symbol *s );
sql_export int sql_set_var_value(mvc *sql, char *name, char *value );

sql_export int sql_create_env(mvc *sql, sql_schema *s);
sql_export int sql_create_history(mvc *sql, sql_schema *s);
sql_export int sql_session(mvc *sql);

#endif /* _SQL_ENV_H_ */
@c
#include "sql_env.h"
#include "sql_bm.h"
#include "sql_scope.h"
#include "sql_select.h"
#include "sql_semantic.h"

int mvc_debug_on( mvc *m, int flg)
{
	
	if (m->debug&flg)
		return 1;

	return 0;
}

static char * 
sql_get_var( mvc *sql, char *name )
{
	BAT *n = mvc_bind( sql, "sys", "sessions", "name", 0); 
	BAT *v = mvc_bind( sql, "sys", "sessions", "value", 0); 
	char *val = NULL;
	BUN p;

	if ((p=BUNfnd(BATmirror(n), name))) {
		val = BUNtail(v, BUNfnd(v, BUNhead(n, p)));
	}
	bat_destroy(n);
	bat_destroy(v);
	return val;
}

int 
sql_get_bit_var( mvc *sql, char *name )
{
	char *val = sql_get_var(sql, name);
	if (val && strcmp(val, "true") == 0)
		return TRUE;
	return FALSE;
}

static int 
sql_get_int_var( mvc *sql, char *name ) 
{
	char *val = sql_get_var(sql, name);
	if (val)
		return strtol(val, &val, 10);
	return 0;
}

static char *
sql_get_str_var( mvc *sql, char *name ) 
{
	char *val = sql_get_var(sql, name);
	if (val)
		return (char*)val;
	assert(0);
	return NULL;
}

void
mvc_update_flags( mvc *m )
{
	char *explain;

	m->debug = sql_get_int_var(m, "debug");
	m->auto_commit = sql_get_bit_var(m, "auto_commit");
	m->reply_size = sql_get_int_var(m, "reply_size");
	explain = sql_get_str_var(m, "explain");
	if (m->explain)  
		_DELETE(m->explain);
	if (!explain || strcmp(explain, "") == 0)
		m->explain = NULL;
	else
		m->explain = _strdup(explain);
}


int 
inttype( sql_subtype *itype, sql_subtype *rtype ) 
{
	if (strcmp(rtype->type->base.name, "int") == 0) {
		if (strcmp(itype->type->base.name, "sht") == 0 ||
		    strcmp(itype->type->base.name, "int") == 0 ||
		    strcmp(itype->type->base.name, "lng") == 0) 
		return 1;
	}
	return 0;
}

int simple_type( stmt *s ) 
{
	int type = s->type;
	return type == st_var || type == st_atom || 
		(type == st_unop && simple_type(s->op1.stval) && 
		 strcmp(s->op4.funcval->func->name, "sql_neg") == 0);
}

atom *getatom( mvc *sql, stmt *s ) 
{
	atom *a;
	int type = s->type;
	if (type == st_var)
		return sql->args->h->data;
	if (type == st_atom)
		return s->op1.aval;
	/* unop */
	a = getatom(sql, s->op1.stval);
	if (a->data.vtype == TYPE_sht){
		a->data.val.shval = -a->data.val.shval;
	} else if (a->data.vtype == TYPE_int){
		a->data.val.ival = -a->data.val.ival;
	} else if (a->data.vtype == TYPE_lng){
		a->data.val.lval = -a->data.val.lval;
	}
	return a;
}

stmt *
sql_set_var( mvc *sql, symbol *s )
{
	if (s->token == SQL_SET) {
		BUN p;
		dlist *l = s->data.lval;
		symbol *val = l->h->next->data.sym;
		scope *scp = scope_open(NULL);

		char *name = l->h->data.sval;
		stmt *v = sql_value_exp( sql, scp, val, NULL, NULL, sql_sel);
		sql_subtype *ctype, *valtype;
		str typename;
		BAT *n, *t;
		char *atom;

		scope_close(scp);

		if (!v)
			return NULL;

		if (!simple_type(v)) {
			return sql_error(sql, 02, 
				"Can only set %s=simple_value (%s,%d)\n", 
				name, st_type2string(v->type), v->type);
		}

		n = mvc_bind( sql, "sys", "sessions", "name", 0); 
		t = mvc_bind( sql, "sys", "sessions", "type", 0); 
		if (!(p=BUNfnd(BATmirror(n), name))) {
			bat_destroy(n);
			bat_destroy(t);
@-
Any user defined variable should be added to the table.
They don;t survive session boundaries [?]
@c
			return sql_error(sql, 02, 
				"Unknown session variable, %s\n",
				name);
		}
		typename = BUNtail(t, BUNfnd(t, BUNhead(n,p)));
		ctype = sql_bind_subtype(typename, 0, 0);
		bat_destroy(n);
		bat_destroy(t);

		/* support 3 types 
			bool (bit)
			ints (sht,int,lng)
			str
		 */
 		valtype = tail_type(v);
		if (!ctype || (strcmp(ctype->type->base.name, valtype->type->base.name) != 0 && (inttype(valtype, ctype)) == 0 )) {
			sql_subtype_destroy(ctype);
			stmt_destroy(v);
			return sql_error(sql, 02, "Can only set %s=simple_value where simple_value is of type %s, value is of type %s\n", name, ctype->type->base.name, valtype->type->base.name);
		}
	
		sql_set_var_value(sql, name, atom=atom2string(getatom(sql, v)));
		sql_subtype_destroy(ctype);
		stmt_destroy(v);
		mvc_update_flags(sql);
		_DELETE(atom);
		return stmt_none();
	}
	return NULL;
}

int
sql_set_var_value( mvc *sql, char *name, char *value )
{
	int res = -1;
	BAT *n = mvc_bind( sql, "sys", "sessions", "name", 0); 
	BAT *v = mvc_bind( sql, "sys", "sessions", "value", 1); 
	BUN p;
	
	if ((p=BUNfnd(BATmirror(n), name))) {
		oid id = *(oid*)BUNhead(n,p);
		bun_inplace(v, id, value);
		res = 0;
	}
	bat_destroy(n);
	bat_destroy(v);
	return res;
}
@-
Handling of SQL variables is straigtforward.
@c
int
sql_session( mvc *m ) 
{
	char buf[BUFSIZ];
	BAT *n,*v,*T;

	oid h = 0;

	n = mvc_bind( m, "sys", "sessions", "name", 1 );
	v = mvc_bind( m, "sys", "sessions", "value", 1 );
	T = mvc_bind( m, "sys", "sessions", "type", 1 );

	BUNins(n, (ptr) &h, "debug" );
	snprintf(buf, BUFSIZ, "%d", m->debug );
	BUNins(v, (ptr) &h, buf);
	BUNins(T, (ptr) &h, "MEDIUMINT");
	h++;

	BUNins(n, (ptr) &h, "reply_size" );
	snprintf(buf, BUFSIZ, "%d", m->reply_size );
	BUNins(v, (ptr) &h, buf);
	BUNins(T, (ptr) &h, "MEDIUMINT");
	h++;

	BUNins(n, (ptr) &h, "explain" );
	buf[0] = 0;
	if (m->explain)
		snprintf(buf, BUFSIZ, "%s", m->explain );
	BUNins(v, (ptr) &h, buf);
	BUNins(T, (ptr) &h, "VARCHAR");
	h++;

	BUNins(n, (ptr) &h, "auto_commit" );
	if (m->auto_commit)
		BUNins(v, (ptr) &h, "true");
	else
		BUNins(v, (ptr) &h, "false");
	BUNins(T, (ptr) &h, "BOOLEAN");
	h++;

	bat_destroy(n);
	bat_destroy(v);
	bat_destroy(T);

	return 0;
}

int
sql_create_env( mvc *m, sql_schema *s ) 
{
	BUN p,q;
	BAT *n,*v;

	sql_table *t;

	t = mvc_create_table(m, s, "sessions", 1, 1, 1, -1 );
	mvc_create_column_(m, t, "name", "VARCHAR");
	mvc_create_column_(m, t, "value", "VARCHAR");
	mvc_create_column_(m, t, "type", "VARCHAR");

	t = mvc_create_table(m, s, "env", 1, 1, 0, -1 );
	mvc_create_column_(m, t, "name", "VARCHAR");
	mvc_create_column_(m, t, "value", "VARCHAR");

	n = mvc_bind( m, "sys", "env", "name", 1 );
	v = mvc_bind( m, "sys", "env", "value", 1 );
	BATloop(GDKenv,p,q){
		oid h = n->hseqbase + BATcount(n);
		char *name = BUNhead(GDKenv,p);
		char *val = BUNtail(GDKenv,p);

		BUNins(n, (ptr) &h, name);
		BUNins(v, (ptr) &h, val);
	}

	bat_destroy(n);
	bat_destroy(v);

	return 0;
}
@-
The history table contains information on the parsing, optimization,
and execution time. More detailed information should be obtained using
the MonetDB kernel profier, e.g. using Mknife
@c

int
sql_create_history( mvc *m, sql_schema *s ) 
{
	sql_table *t = mvc_create_table(m, s, "history", 1, 1, 0, -1 );

	mvc_create_column_(m, t, "start", "TIMESTAMP");
	mvc_create_column_(m, t, "query", "VARCHAR");
	mvc_create_column_(m, t, "parse", "MEDIUMINT");
	mvc_create_column_(m, t, "optimize", "MEDIUMINT");
	mvc_create_column_(m, t, "exec", "MEDIUMINT");
	mvc_create_column_(m, t, "total", "MEDIUMINT");
	mvc_create_column_(m, t, "user", "VARCHAR");

	return 0;
}
@}
