@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2005 CWI.
@' All Rights Reserved.

@f rel_select
@a N.J. Nes
@* 

@h
#ifndef _REL_SELECT_H_
#define _REL_SELECT_H_

#include "rel_semantic.h"

#define sql_from 0
#define sql_where 1
/* special search fase which is used within the selection fase */
#define sql_search 2
#define sql_sel   3

extern sql_rel *rel_selects(mvc *sql, symbol *sym);

#endif /*_REL_SELECT_H_*/
@c

#include "rel_select.h"
#include "sql_semantic.h"
#include "rel_dump.h"
#include "sql_privileges.h"

#define new_exp_list() list_create((fdestroy)&exp_destroy)

static void 
rel_destroy(sql_rel *rel)
{
	if (!rel) 
		return;
	if (rel->name) 
		_DELETE(rel->name);
	if (rel->exps)
		list_destroy(rel->exps);
	if (!rel->op == op_basetable) {
		if (rel->l)
			rel_destroy(rel->l);
		if (rel->r)
			rel_destroy(rel->r);
	}
	_DELETE(rel);
}

static void 
exp_destroy(sql_exp *exp)
{
	if (!exp) 
		return;
	if (exp->name) 
		_DELETE(exp->name);
	switch(exp->type){
	case e_atom:
		atom_destroy(exp->l);
		break;
	case e_relation:
		if (exp->l)
			rel_destroy(exp->l);
		break;
	case e_column:
		if (exp->l)
			_DELETE(exp->l);
		_DELETE(exp->r);
		break;
	case e_cmp:
		exp_destroy(exp->l);
		exp_destroy(exp->r);
		break;
	default:
		printf("TODO: exp_destroy %d\n", exp->type);
	}
	_DELETE(exp);
}

static sql_exp *
exp_dup(sql_exp *exp)
{
	/* TODO ref counting */
	return exp;
}

static sql_exp * exp_atom( atom *a) 
{
	sql_exp *e = NEW(sql_exp);
	e->name = NULL;
	e->card = 1;
	e->l = a;
	e->r = NULL;
	e->type = e_atom;
	e->f = NULL;
	return e;
}

static sql_exp *
exp_atom_int(int i) {
	sql_subtype *it = sql_bind_subtype("int", 9, 0);

	return exp_atom(atom_int(sql_dup_subtype(it), i ));
}

static sql_exp * exp_relation( sql_rel *r) 
{
	sql_exp *e = NEW(sql_exp);
	e->name = NULL;
	e->card = r->card;
	e->l = r;
	e->r = NULL;
	e->type = e_relation;
	e->f = NULL;
	return e;
}

static sql_exp * 
exp_column( char *tname, char *cname, sql_subtype *t) 
{
	sql_exp *e = NEW(sql_exp);
	e->name = _strdup(cname);
	e->card = 2;
	e->l = (tname)?_strdup(tname):NULL;
	e->r = _strdup(cname);
	e->type = e_column;
	e->f = t;
	return e;
}

/* TODO change to lists of expressions for expression operators which work
   on more than 2 input expressions (ex like)
 */

static sql_exp * 
exp_exp( sql_exp *l, sql_exp *r ) 
{
	sql_exp *e = NEW(sql_exp);
	e->name = NULL;
	e->card = l->card;
	e->l = l;
	e->r = r;
	e->type = e_exp;
	e->f = NULL;
	return e;
}

static sql_exp * 
exp_like( sql_exp *l, sql_exp *r, sql_exp *esc, int like) 
{
	sql_exp *e = NEW(sql_exp);
	e->name = NULL;
	e->card = l->card;
	e->l = l;
	e->r = r;
	if (esc)
		e->r = exp_exp(r,esc);
	e->type = e_cmp;
	e->flag = like;
	e->f = NULL;
	return e;
}

static sql_exp * 
exp_compare( sql_exp *l, sql_exp *r, int cmptype) 
{
	sql_exp *e = NEW(sql_exp);
	e->name = NULL;
	e->card = l->card;
	e->l = l;
	e->r = r;
	e->type = e_cmp;
	e->flag = cmptype;
	e->f = NULL;
	return e;
}

#define exp_unop(l,f) \
	exp_op(list_append(new_exp_list(),l), f);
#define exp_binop(l,r,f) \
	exp_op(list_append(list_append(new_exp_list(),l),r), f);

static int
exps_card( list *l ) 
{
	node *n;
	int card = 0;

	if (l) for(n = l->h; n; n = n->next) {
		sql_exp *e = n->data;

		if (card < e->card)
			card = e->card;
	}
	return card;
}
	
static sql_exp * 
exp_op( list *l, sql_subfunc *f )
{
	sql_exp *e = NEW(sql_exp);
	e->name = NULL;
	e->card = exps_card(l);
	e->l = l;
	e->r = NULL;
	e->type = e_func;
	e->f = f; 
	return e;
}

static sql_exp * 
exp_convert( sql_exp *exp, sql_subtype *fromtype, sql_subtype *totype )
{
	sql_exp *e = NEW(sql_exp);
	e->name = NULL;
	e->card = exp->card;
	e->l = fromtype;
	e->r = totype;
	e->type = e_convert;
	e->f = NULL; 
	return e;
}

static sql_exp * 
exp_aggr( list *l, sql_subaggr *a )
{
	sql_exp *e = NEW(sql_exp);
	e->name = NULL;
	e->card = exps_card(l);
	e->l = l;
	e->r = NULL;
	e->type = e_aggr;
	e->f = a; 
	return e;
}

static sql_exp * 
exp_unique( sql_exp *l )
{
	sql_exp *e = NEW(sql_exp);
	e->name = NULL;
	e->card = l->card;
	e->l = l;
	e->r = NULL;
	e->type = e_unique;
	e->f = NULL; 
	return e;
}

static sql_subtype *
exp_subtype( sql_exp *e )
{
	switch(e->type) {
	case e_atom: {
		atom *a = e->l;
		return a->tpe;
	}
	case e_exp:
		return exp_subtype(e->l);
	case e_column:
		return e->f;
	case e_aggr: {
		sql_subaggr *a = e->f;
		return a->res;
	}
	case e_func: {
		sql_subfunc *f = e->f;
		return f->res;
	}
	case e_cmp:
		/* return bit */
	case e_relation:
		/* return rel? */
	default:
		return NULL;
	}
}

static void exp_set_name( sql_exp *e, char *name )
{
	if (e->name)
		_DELETE(e->name);
	e->name = _strdup(name);
}

static sql_exp *
exps_bind_column( list *exps, char *cname ) 
{
	node *en;

	for (en = exps->h; en; en = en->next ) {
		sql_exp *e = en->data;
		if (e->name && strcmp(e->name, cname) == 0)
			return e;
	}
	return NULL;
}

static sql_rel *
rel_bind_column_( sql_rel **p, sql_rel *rel, char *cname )
{
	sql_rel *r = NULL;
	switch(rel->op) {
	case op_join:
		*p = rel;
		r = rel_bind_column_( p, rel->l, cname);
		if (r) 
			return r;
		*p = rel;
		return rel_bind_column_( p, rel->r, cname);
	case op_project:
		if (rel->exps && exps_bind_column(rel->exps, cname))
			return rel;
		*p = rel;
		return rel_bind_column_( p, rel->l, cname );
	case op_basetable:
	{
		node *cn;
		sql_table *t = rel->l;

		for (cn = t->columns.set->h; cn; cn = cn->next) {
			sql_column *c = cn->data;
			if (strcmp(c->base.name, cname) == 0)
				return rel;
		}
	} 
	case op_select:
	case op_union:
	case op_groupby:
	case op_orderby:
	case op_topn:
	default:
		return NULL;
	}
	return NULL;
}

static sql_exp *
rel_bind_column( sql_rel *rel, char *cname )
{
	sql_rel *p = NULL;

	rel = rel_bind_column_(&p, rel, cname);
	if (!rel) 
		return NULL;

	if (rel->op == op_project) {
		if (rel->exps)
			return exps_bind_column(rel->exps, cname);
	} else if (rel->op == op_basetable) {
		node *cn;
		sql_table *t = rel->l;

		for (cn = t->columns.set->h; cn; cn = cn->next) {
			sql_column *c = cn->data;
			if (strcmp(c->base.name, cname) == 0)
				return exp_column(rel->name, cname, c->type );
		}
	}
	return NULL;
}


static sql_rel *
rel_bind_table( sql_rel **p, sql_rel *rel, char *tname ) 
{
	sql_rel *r;

	if (rel->name && strcmp(rel->name, tname) == 0) 
		return rel; 
	switch(rel->op) {
	case op_join:
		*p = rel;
		r = rel_bind_table( p,  rel->l, tname);
		if (r) 
			return r;
		*p = rel;
		return rel_bind_table( p, rel->r, tname);
	case op_project:
	case op_select:
	case op_union:
	case op_groupby:
	case op_orderby:
	case op_topn:
		*p = rel;
		return rel_bind_table( p, rel->l, tname);
	default:
		return NULL;
	}
	return NULL;
}

static sql_rel * 
rel_bind_exp(sql_rel **p, sql_rel *rel, sql_exp *e )
{
	switch(e->type) {
	case e_column:
		if (e->l)
			rel = rel_bind_table(p, rel, e->l);
		return rel_bind_column_(p, rel, e->r);
	default:
		return rel;
	}
	return rel;
}


static list *
rel_projections( sql_rel *rel, char *tname )
{
	list *rexps, *exps ;

	if (!tname)
		tname = rel->name;

	switch(rel->op) {
	case op_join:
		exps = rel_projections( rel->l, tname );
		rexps = rel_projections( rel->r, tname );
		exps = list_merge( exps, rexps, (fdup)&exp_dup);
		/*list_destroy(rexps);*/
		return exps;
	case op_project:
	case op_select:
	case op_union:
	case op_groupby:
	case op_orderby:
	case op_topn:
		return rel_projections( rel->l, tname );
	case op_basetable: 
	{
		node *cn;
		sql_table *t = rel->l;

		exps = new_exp_list();
		for (cn = t->columns.set->h; cn; cn = cn->next) {
			sql_column *c = cn->data;
			list_append(exps, exp_column(tname, c->base.name, c->type ));
		}
		return exps;
	} 
	default:
		return NULL;
	}
	return NULL;
}

static sql_rel *
rel_copy( sql_rel *i ) 
{
	sql_rel *rel = NEW(sql_rel);

	rel->name = (i->name)?_strdup(i->name):NULL;
	rel->l = NULL;
	rel->r = NULL;
	switch(i->op) {
	case op_basetable:
		rel->l = i->l;
		break;
	case op_join:
	case op_project:
	case op_select:
	default:
		rel->l = rel_copy(i->l);
		if (i->r)
			rel->r = rel_copy(i->r);
		break;
	}
	rel->op = i->op;
	rel->exps = (i->exps)?list_dup(i->exps, (fdup)&exp_dup):NULL;
	return rel;
}

static sql_rel *
rel_basetable(sql_table *t, char *tname) 
{
	sql_rel *rel = NEW(sql_rel);

	rel->name = (tname)?_strdup(tname):NULL;
	rel->l = t;
	rel->r = NULL;
	rel->op = op_basetable;
	rel->exps = NULL;
	return rel;
}

static sql_rel *
rel_crossproduct(sql_rel *l, sql_rel *r)
{
	sql_rel *rel = NEW(sql_rel);

	rel->name = NULL;
	rel->l = l;
	rel->r = r;
	rel->op = op_join;
	rel->exps = NULL;
	return rel;
}

static sql_rel *
rel_join(sql_rel *rel, sql_exp *e)
{
	if (rel->op != op_join) 
		return rel_join(rel->l, e);
	if (!rel->exps)
		rel->exps = new_exp_list();
	list_append(rel->exps, e);
	return rel;
}

static sql_rel *
rel_project(sql_rel *l, list *e)
{
	sql_rel *rel = NEW(sql_rel);

	rel->name = NULL;
	rel->l = l;
	rel->r = NULL;
	rel->op = op_project;
	rel->exps = e;
	return rel;
}

static sql_rel *
rel_select(sql_rel *l, sql_exp *e)
{
	if (l->op == op_select) {
		list_append(l->exps, e);
		return l;
	} else {
		sql_rel *rel = NEW(sql_rel);
	
		rel->name = NULL;
		rel->l = l;
		rel->r = NULL;
		rel->op = op_select;
		rel->exps = list_append(new_exp_list(), e);
		return rel;
	}
}

static sql_rel *
rel_groupby(sql_rel *l, list *e )
{
	sql_rel *rel = NEW(sql_rel);

	rel->name = NULL;
	rel->l = l;
	rel->r = NULL;
	rel->op = op_groupby;
	rel->exps = e;
	return rel;
}

static sql_rel *
rel_orderby(sql_rel *l, list *e )
{
	sql_rel *r = rel_groupby( l, e);
	r->op = op_orderby;	
	return r;
}

static sql_rel *
rel_topn(sql_rel *l, list *e )
{
	sql_rel *r = rel_groupby( l, e);
	r->op = op_topn;	
	return r;
}

static void rel_set_name( sql_rel *rel, char *name )
{
	if (rel->name)
		_DELETE(rel->name);
	rel->name = _strdup(name);
}

static char * rel_get_name( sql_rel *rel )
{
	if (rel->name)
		return (rel->name);
	switch(rel->op) {
	case op_basetable:
	{
		sql_table *t = rel->l;
		return t->base.name;
	}
	default:
		return rel_get_name(rel->l);
	}
	assert(0);
	return NULL;
}

/* forward refs */
static sql_rel * rel_subquery(mvc *sql, sql_rel *rel, symbol *sq);
static sql_exp * rel_value_exp(mvc *sql, sql_rel *rel, symbol *se, int f);


static sql_rel *
rel_table_optname(mvc *sql, sql_rel *sq, symbol *optname)
{
	(void)sql;
	if (optname && optname->token == SQL_NAME) {
		dlist *columnrefs = NULL;
		char *tname = optname->data.lval->h->data.sval;

		if (tname)
			rel_set_name( sq, tname );
		columnrefs = optname->data.lval->h->next->data.lval;
		if (columnrefs && sq->exps) {
			dnode *d = columnrefs->h;
			node *ne = sq->exps->h;

			for (; d && ne; d = d->next, ne = ne->next) 
				exp_set_name( ne->data, d->data.sval );
		}
	}
	return sq;
}

static sql_rel *
rel_subquery_optname(mvc *sql, symbol *query)
{
	SelectNode *sn = (SelectNode *) query;
	sql_rel *sq = rel_subquery(sql, NULL, query);

	if (!sq)
		return NULL;

	return rel_table_optname(sql, sq, sn->name);
}

static sql_rel *
table_ref(mvc *sql, sql_rel *rel, symbol *tableref)
{
	char *tname = NULL;
	sql_table *t = NULL;

	(void)rel;
	if (tableref->token == SQL_NAME) {
		sql_schema *s = qname_schema(sql, tableref->data.lval->h->data.lval);

		tname = qname_table(tableref->data.lval->h->data.lval);

		if (!s) {
			return sql_error(sql, 02, "Unknown schema");
		}
		t = mvc_bind_table(sql, s, tname);
		if (!t) {
			return sql_error(sql, 02, "Unknown table %s", tname);
		} else if (!table_privs(sql, t, PRIV_SELECT)) {
			return sql_error(sql, 02, "User is not allowed to select from table %s", tname);
		}
		if (tableref->data.lval->h->next->data.sym) {	/* AS */
			tname = tableref->data.lval->h->next->data.sym->data.lval->h->data.sval;
		}
		return rel_basetable(t, tname);
	} else if (tableref->token == SQL_TABLE) {
		/* not sure this is valid SQL, (func_ref table_name)! */
		symbol *ts = tableref->data.lval->h->data.sym;
		sql_exp *e = rel_value_exp(sql, rel, ts, sql_from);
		sql_rel *rel;
		char *tname = tableref->data.lval->h->next->data.sym->data.lval->h->data.sval;

		if (!e)
			return NULL;
		if (e->type != e_relation) {
			exp_destroy(e);
			return sql_error(sql, 02, "No relation returned by table reference %s", tname);
		}
		rel = e->l;
		e->l = NULL;
		rel_set_name(rel, tname); 
		return rel;
	} else if (tableref->token == SQL_SELECT) {
		return rel_subquery_optname(sql, tableref);
	} else {
		/* TODO JOIN/UNIONs ?
		return query_exp_optname(sql, rel, tableref);
		*/
		return NULL;
	}
}

static sql_exp *
rel_column_ref(mvc *sql, sql_rel *rel, symbol *column_r)
{
	sql_exp *exp = NULL;
	dlist *l = column_r->data.lval;

	(void)sql;
	(void)rel;
	assert(column_r->token == SQL_COLUMN && column_r->type == type_list);

	if (dlist_length(l) == 1 && l->h->type == type_int) {
		/* TODO fix args  (cache is temporarily disabled)
		return stmt_varnr(l->h->data.ival, sql_dup_subtype(sql_bind_arg(sql, l->h->data.ival)->tpe));
		*/
		return exp_atom(atom_dup(sql_bind_arg(sql, l->h->data.ival)));
	} else if (dlist_length(l) == 1) {
		char *name = l->h->data.sval;
		
		exp = rel_bind_column(rel, name);
		if (!exp)
			return sql_error(sql, 02, "Column: %s unknown", name);
	} else if (dlist_length(l) == 2) {
		char *tname = l->h->data.sval;
		char *cname = l->h->next->data.sval;
		sql_rel *p, *r = rel_bind_table(&p, rel, tname);

		(void)p;
		if (!r)
			return sql_error(sql, 02, "Column: %s.%s unknown", tname, cname);
		exp = rel_bind_column(r, cname);
		if (!exp)
			return sql_error(sql, 02, "Column: %s.%s unknown", tname, cname);
	} else if (dlist_length(l) >= 3) {
		return sql_error(sql, 02, "TODO: column names of level >= 3");
	}
	return exp;
}

static sql_exp *
exp_sum_scales(sql_subfunc *f, sql_exp *l, sql_exp *r)
{
	(void)f;
	(void)r;
	return l;
}

static sql_exp *
exp_scale_algebra(sql_subfunc *f, sql_exp *l, sql_exp *r)
{
	(void)f;
	(void)r;
	return l;
}

static sql_exp *
exp_fix_scale(mvc *sql, sql_subtype *ct, sql_exp *e, int both, int always)
{
	(void)sql;
	(void)ct;
	(void)both;
	(void)always;
	return e;
}

static sql_exp * 
rel_check_type(mvc *sql, sql_subtype *t, sql_exp *exp, int typecheck)
{
	sql_subtype *fromtype = exp_subtype(exp);
	
	if (fromtype && subtype_cmp(t, fromtype) != 0) {
		fromtype = NULL;
	}
	if (!fromtype) {
		sql_subtype *nt;
		int c = sql_type_convert(fromtype->type->eclass, t->type->eclass);
		if (!c) 
			return NULL;
 		nt = sql_create_subtype(t->type, t->digits, fromtype->scale);
		exp = exp_convert(exp, sql_dup_subtype(fromtype), nt);
	}
	(void)sql;
	(void)typecheck;
	return exp;
}

static int 
rel_convert_types(mvc *sql, sql_exp **ls, sql_exp **rs, int f)
{
	/* TODO convert */
	(void)sql;
	(void)ls;
	(void)rs;
	(void)f;
	return 0;
}

static sql_rel *
rel_compare_exp(mvc *sql, sql_rel *rel, sql_exp *ls, sql_exp *rs, char *compare_op, sql_exp *esc )
{
	sql_exp *e = NULL;
	comp_type type = cmp_equal;

	if (!ls || !rs)
		return NULL;

	if (compare_op[0] == '=') {
		type = cmp_equal;
	} else if (compare_op[0] == '<') {
		type = cmp_lt;
		if (compare_op[1] != '\0') {
			if (compare_op[1] == '>') {
				type = cmp_notequal;
			} else if (compare_op[1] == '=') {
				type = cmp_lte;
			}
		}
	} else if (compare_op[0] == '>') {
		type = cmp_gt;
		if (compare_op[1] != '\0') {
			if (compare_op[1] == '=') {
				type = cmp_gte;
			}
		}
	} else if (compare_op[0] == 'l') {
		type = cmp_like;
	} else if (compare_op[0] == 'n') {
		type = cmp_notlike;
	}
	if (rel_convert_types(sql, &ls, &rs, 1) < 0) {
		if (ls)
			exp_destroy(ls);
		if (rs)
			exp_destroy(rs);
		return NULL;
	}
	if (type != cmp_like && type != cmp_notlike) {
		if (ls->card < rs->card) {
			sql_exp *swap = ls;
	
			ls = rs;
			rs = swap;
		}
		e = exp_compare( ls, rs, type );
	} else {
		e = exp_like( ls, rs, esc, type );
	}

	/* TODO handle subqueries with outer references */
	/* one value or row => select */
	if (rs->card <= 1) {
		sql_rel *r, *p = NULL;

		if (ls->card == rs->card)  /* bin compare op */
			return rel_select(rel, e);

		/* push select into the given relation */
		/* find relation for the column expression */
		r = rel_bind_exp(&p, rel, ls);
		if (p && r->op == op_basetable && p->op == op_select) {
			rel_select(p, e);
		} else {
			sql_rel *n = rel_select(r, e);

			if (p) {
				if (p->l == r)
					p->l = n;
				else
					p->r = n;
			} else {
				rel = n;
			}
			return rel;
		}
		return rel;
	} else { /* join */
		return rel_join(rel, e);
	}
	return rel;
}

static sql_rel *
rel_compare(mvc *sql, sql_rel *rel, symbol *lo, symbol *ro, char *compare_op )
{
	sql_exp *rs, *ls;

	if (lo->token == SQL_SELECT) { /* swap subquery to the right handside */
		symbol *tmp = lo;

		lo = ro;
		ro = tmp;

		if (compare_op[0] == '>')
			compare_op[0] = '<';
		else if (compare_op[0] == '<')
			compare_op[0] = '>';
	}

	ls = rel_value_exp(sql, rel, lo, sql_where);
	if (!ls)
		return NULL;
	if (ro->token != SQL_SELECT) {
		rs = rel_value_exp(sql, rel, ro, sql_where);
	} else {
		sql_rel *r = rel_subquery(sql, rel, ro);

		if (!r) {
			exp_destroy(ls);
			return NULL;
		}
		rs = exp_relation(r);
	}
	if (!rs) {
		exp_destroy(ls);
		return NULL;
	}
	return rel_compare_exp(sql, rel, ls, rs, compare_op, NULL);
}

static sql_rel *
rel_or(mvc *sql, sql_rel *l, sql_rel *r, int f)
{
	(void)sql;
	(void)l;
	(void)r;
	(void)f;
	return NULL;
}

static sql_rel *
rel_logical_exp(mvc *sql, sql_rel *rel, symbol *sc, int f)
{
	if (!sc)
		return NULL;
	switch (sc->token) {
	case SQL_OR:
	{
		symbol *lo = sc->data.lval->h->data.sym;
		symbol *ro = sc->data.lval->h->next->data.sym;
		sql_rel *ls = rel;
		sql_rel *rs = rel_copy(rel);

		ls = rel_logical_exp(sql, ls, lo, f);
		rs = rel_logical_exp(sql, rs, ro, f);

		return rel_or(sql, ls, rs, f);
	}
	case SQL_AND:
	{
		symbol *lo = sc->data.lval->h->data.sym;
		symbol *ro = sc->data.lval->h->next->data.sym;

		rel = rel_logical_exp(sql, rel, lo, f);
		if (!rel)
			return NULL;
		return rel_logical_exp(sql, rel, ro, f);
	}
	case SQL_COMPARE:
	{
		symbol *lo = sc->data.lval->h->data.sym;
		symbol *ro = sc->data.lval->h->next->next->data.sym;
		char *compare_op = sc->data.lval->h->next->data.sval;
		return rel_compare(sql, rel, lo, ro, compare_op);
	}
		break;
	/* Set Member ship */
	case SQL_IN:
	case SQL_NOT_IN:
	{
		dlist *dl = sc->data.lval;
		symbol *lo = dl->h->data.sym;
		sql_exp *l = rel_value_exp(sql, rel, lo, f);
		sql_rel *r = NULL;

		if (!l)
			return NULL;

		/* value list */
		if (dl->h->next->type == type_list) {
			dnode *n = dl->h->next->data.lval->h;
			list *exps = new_exp_list();

			for (; n; n = n->next) {
				symbol *sval = n->data.sym;
				sql_exp *r = rel_value_exp(sql, rel, sval, f);

				list_append(exps, r);
			}
			r = rel_project(NULL, exps );
		} else if (dl->h->next->type == type_symbol) {
			symbol *ro = dl->h->next->data.sym;

			r = rel_subquery(sql, rel, ro);
		}
		if (!r) 
			return r;
		/* create join column expressions */
		/*
		return rel_join(sql, rel, le, re, cmp, ee); 
		*/
		return NULL;
	}
	case SQL_EXISTS:
	case SQL_NOT_EXISTS:
	{
		symbol *lo = sc->data.sym;
		sql_rel *l = rel_subquery(sql, rel, lo);
		char *cmp;

		if (!l)
			return NULL;

		/* change to aggr(count(*)) ==/<> 0 */
		if (sc->token == SQL_EXISTS) {
 			cmp = "<>";
		/* change to aggr(count(*)) == 1 */
		} else {	/* NOT EXISTS */
 			cmp = "=";
		}
		/* 
		rel_groupby( l, exp_aggr(count) as "exists count"); 
		le = exp_column( NULL, "exists count", it ); 
		re = exp_atom_int(1); 
		return rel_compare_exp(sql, rel, le, re, cmp, ee); 
		*/
		(void)cmp;
		return NULL;
	}
	case SQL_LIKE:
	case SQL_NOT_LIKE:
	{
		symbol *lo = sc->data.lval->h->data.sym;
		symbol *ro = sc->data.lval->h->next->data.sym;
		sql_subtype *st = sql_bind_localtype("str");
		sql_exp *le = rel_value_exp(sql, rel, lo, f);
		sql_exp *re, *ee = NULL;

		if (!le)
			return NULL;
		/* Do we need to escape ? */
		if (dlist_length(ro->data.lval) == 2) {
			char *escape = ro->data.lval->h->next->data.sval;
			ee = exp_atom(atom_string(sql_dup_subtype(st), _strdup(escape), 1));
		}
		ro = ro->data.lval->h->data.sym;
		re = rel_value_exp(sql, rel, ro, f);
		if (!re)
			return NULL;
		if ((re = rel_check_type(sql, st, re, type_equal)) == NULL) {
			return sql_error(sql, 02, "Wrong type used with LIKE statement, should be string");
		}
		if (sc->token == SQL_LIKE) 
			return rel_compare_exp(sql, rel, le, re, "l", ee);
		return rel_compare_exp(sql, rel, le, re, "n", ee);
	}
	case SQL_BETWEEN:
	case SQL_NOT_BETWEEN:
	{
		symbol *lo = sc->data.lval->h->data.sym;
		int symmetric = sc->data.lval->h->next->data.ival;
		symbol *ro1 = sc->data.lval->h->next->next->data.sym;
		symbol *ro2 = sc->data.lval->h->next->next->next->data.sym;
		sql_exp *le = rel_value_exp(sql, rel, lo, f);
		sql_exp *re1 = rel_value_exp(sql, rel, ro1, f);
		sql_exp *re2 = rel_value_exp(sql, rel, ro2, f);
		sql_subtype *ct = NULL;

		if (!le || !re1 || !re2) {
			exp_destroy(le);
			exp_destroy(re1);
			exp_destroy(re2);
			return NULL;
		}
		ct = exp_subtype(le);
		re1 = rel_check_type(sql, ct, re1, type_equal);
		re2 = rel_check_type(sql, ct, re2, type_equal);

		if (!re1 || !re2) {
			exp_destroy(le);
			exp_destroy(re1);
			exp_destroy(re2);
			return NULL;
		}

		if (symmetric) {
			sql_exp *tmp = NULL;
			sql_subfunc *min = sql_bind_func(sql->trans->module, "min", exp_subtype(re1), exp_subtype(re2));
			sql_subfunc *max = sql_bind_func(sql->trans->module, "max", exp_subtype(re1), exp_subtype(re2));

			if (!min || !max) {
				return sql_error(sql, 02, "min or max operator on types %s %s missing", exp_subtype(re1)->type->sqlname, exp_subtype(re2)->type->sqlname);
			}
			tmp = exp_binop(re1, re2, min);
			re2 = exp_binop(exp_dup(re1), exp_dup(re2), max);
			re1 = tmp;
		}

		if (sc->token == SQL_NOT_BETWEEN) {
			rel = rel_compare_exp(sql, rel, le, re1, "<", NULL);
			rel = rel_compare_exp(sql, rel, exp_dup(le), re2, ">", NULL);
		} else {
			rel = rel_compare_exp(sql, rel, le, re1, ">=", NULL);
			rel = rel_compare_exp(sql, rel, exp_dup(le), re2, "<=", NULL);
		}
		return rel;
	}
	case SQL_NULL:
	case SQL_NOT_NULL:
	/* is (NOT) NULL */
	{
		sql_exp *re, *le = rel_value_exp(sql, rel, sc->data.sym, f);

		if (!le)
			return NULL;
		re = exp_atom(atom_general(sql_dup_subtype(sql_bind_localtype("str")), NULL, 0));
		if (sc->token == SQL_NULL) 
			return rel_compare_exp(sql, rel, le, re, "=", NULL);
		else
			return rel_compare_exp(sql, rel, le, re, "!=", NULL);
	}
	case SQL_ATOM: {
		/* TRUE or FALSE */
		AtomNode *an = (AtomNode *) sc;
		sql_exp *e = exp_atom(atom_dup(an->a));
		return rel_select(rel, e);
	} 
	default:
		return sql_error(sql, 02, "Predicate %s %d: time to implement some more", token2string(sc->token), sc->token);
	}
	return sql_error(sql, 02, "Predicate: time to implement some more");
}

static sql_exp *
rel_op(mvc *sql, sql_rel *rel, symbol *se )
{
	dnode *l = se->data.lval->h;
	sql_subfunc *f = NULL;

	(void) rel;

	f = sql_bind_func(sql->trans->module, l->data.sval, NULL, NULL);
	if (f) {
		return exp_op(NULL, f);
	} else {
		return sql_error(sql, 02, "operator: %s() unknown", l->data.sval);
	}
	return NULL;
}

static sql_exp *
rel_unop(mvc *sql, sql_rel *rel, symbol *se, int fs)
{
	dnode *l = se->data.lval->h;
	char *fname = l->data.sval;
	sql_subfunc *f = NULL;
	sql_subtype *t = NULL;
	sql_exp *e = rel_value_exp(sql, rel, l->next->data.sym, fs);

	if (!e)
		return NULL;
	t = exp_subtype(e);
	f = sql_bind_func(sql->trans->module, fname, t, NULL);
	/* try to find the function without a type, and convert
	 * the value to the type needed by this function!
	 */
	if (!f && (f = sql_find_func(sql->trans->module, fname, 1)) != NULL) {
		sql_arg *a = f->func->ops->h->data;

		e = rel_check_type(sql, a->type, e, type_equal);
		if (!e) {
			sql_subfunc_destroy(f);
			f = NULL;
		}
	}
	if (f) {
		if (f->func->imp) {
			if (f->func->res->scale == INOUT) {
				f->res->digits = t->digits;
				f->res->scale = t->scale;
			}
			return exp_unop(e, f);
		/*
		} else {
			stmt *res;
			sql_arg *a = f->func->ops->h->data;

			sql_add_param(sql, _strdup(a->name), e);

			res = sqlparse_intern(sql, f->func->imp);
			sql_subfunc_destroy(f);
			return res;
		*/
		}
	} else if (e) {
		char *type = exp_subtype(e)->type->sqlname;

		exp_destroy(e);
		return sql_error(sql, 02, "unary operator %s(%s) unknown", l->data.sval, type);
	}
	return NULL;
}


static sql_exp *
rel_binop_(mvc *sql, sql_exp *l, sql_exp *r, char *fname)
{
	sql_exp *res = NULL;
	sql_subtype *t1, *t2;
	sql_subfunc *f = NULL;

	t1 = exp_subtype(l);
	t2 = exp_subtype(r);

	f = sql_bind_func(sql->trans->module, fname, t1, t2);
	if (f) {
		if (f->func->res->scale == SCALE_FIX) {
			l = exp_fix_scale(sql, t2, l, 0, 0);
			r = exp_fix_scale(sql, t1, r, 0, 0);
		} else if (f->func->res->scale == SCALE_SUB) {
			l = exp_scale_algebra(f, l, r);
		} else if (f->func->res->scale == SCALE_ADD) {
			l = exp_sum_scales(f, l, r);
		} else if (f->func->res->scale == DIGITS_ADD) {
			f->res->digits = t1->digits + t2->digits;
		}
		return exp_binop(l, r, f);
	} else {
		int digits = t1->digits + t2->digits;

		if ((f = sql_bind_member(sql->trans->module, fname, t1, 2)) != NULL) {
			/* try finding function based on first argument */
			node *m = f->func->ops->h;
			sql_arg *a = m->next->data;

			r = rel_check_type(sql, a->type, r, type_equal);
			if (r)
				return exp_binop(l, r, f);
		} else if (rel_convert_types(sql, &l, &r, 0) >= 0) {
			/* try operators */
			t1 = exp_subtype(l);
			t2 = exp_subtype(r);
			f = sql_bind_func(sql->trans->module, fname, t1, t2);
			if (f) {
				if (f->func->res->scale == SCALE_FIX) {
					l = exp_fix_scale(sql, t2, l, 0, 0);
					r = exp_fix_scale(sql, t1, r, 0, 0);
				} else if (f->func->res->scale == SCALE_SUB) {
					l = exp_scale_algebra(f, l, r);
				} else if (f->func->res->scale == SCALE_ADD) {
					l = exp_sum_scales(f, l, r);
				} else if (f->func->res->scale == DIGITS_ADD) {
					f->res->digits = digits;
				}
				return exp_binop(l, r, f);
			}
		}
	}
	if (r && l)
		res = sql_error(sql, 02, "binary operator %s(%s,%s) unknown", fname, exp_subtype(l)->type->sqlname, exp_subtype(r)->type->sqlname);
	if (l)
		exp_destroy(l);
	if (r)
		exp_destroy(r);
	return res;
}

static sql_exp *
rel_binop(mvc *sql, sql_rel *rel, symbol *se, int f)
{
	dnode *dl = se->data.lval->h;
	sql_exp *l = rel_value_exp(sql, rel, dl->next->data.sym, f);
	sql_exp *r = rel_value_exp(sql, rel, dl->next->next->data.sym, f);

	if (!l || !r) {
		if (l)
			exp_destroy(l);
		if (r)
			exp_destroy(r);
		return NULL;
	}

	return rel_binop_(sql, r, l, dl->data.sval);
}

static sql_exp *
rel_nop(mvc *sql, sql_rel *rel, symbol *se, int fs)
{
	dnode *l = se->data.lval->h;
	dnode *ops = l->next->data.lval->h;
	list *exps = new_exp_list();
	list *tl = list_create(NULL);
	sql_subfunc *f = NULL;

	for (; ops; ops = ops->next) {
		sql_exp *e = rel_value_exp(sql, rel, ops->data.sym, fs);

		if (!e) {
			list_destroy(exps);
			return NULL;
		}
		list_append(exps, e);
		list_append(tl, exp_subtype(e));
	}
	f = sql_bind_func_(sql->trans->module, l->data.sval, tl);
	list_destroy(tl);
	if (f) {
		return exp_op(exps, f);
	} else if ((f = sql_bind_member(sql->trans->module, l->data.sval, exp_subtype(exps->h->data), list_length(exps))) != NULL) {
		node *n, *m;
		list *nexps = new_exp_list();

		n = exps->h;
		list_append(nexps, exp_dup(n->data));
		m = f->func->ops->h;
		for (n = n->next, m = m->next; n && m; n = n->next, m = m->next) {
			sql_arg *a = m->data;
			sql_exp *e = exp_dup(n->data);

			e = rel_check_type(sql, a->type, e, type_equal);
			if (!e) {
				list_destroy(nexps);
				nexps = NULL;
				break;
			}
			list_append(nexps, e);
		}
		if (nexps) {
			list_destroy(exps);
			return exp_op(nexps, f);
		}
	}
	list_destroy(exps);
	return sql_error(sql, 02, "operator: %s unknown", l->data.sval);
}

static sql_exp *
rel_aggr(mvc *sql, sql_rel *rel, symbol *se, int f)
{
	dlist *l = se->data.lval;
	sql_subaggr *a = NULL;
	int distinct = l->h->next->data.ival;
	char *aggrstr = l->h->data.sval;
	sql_exp *e = NULL;

	if (f == sql_where) 
		return sql_error(sql, 02, "aggregates not allowed in WHERE clause");
	
	if (!l->h->next->next->data.sym) {	/* count(*) case */

		if (strcmp(aggrstr, "count") != 0) {
			return sql_error(sql, 02, "unable to perform %s(*) aggregate", l->h->data.sval);
		}
		a = sql_bind_aggr(sql->trans->module, aggrstr, NULL);
		return exp_aggr(NULL, a);
	} else {
		/* use cnt as nils shouldn't to be counted */
		if (strcmp(aggrstr, "count") == 0) {
			aggrstr = "count_no_nil";
		}
		e = rel_value_exp(sql, rel, l->h->next->next->data.sym, f);
	}

	if (e && distinct) 
		e = exp_unique(e);
	if (!e)
		return NULL;
	a = sql_bind_aggr(sql->trans->module, aggrstr, exp_subtype(e));
	if (a) {
		/* type may have changed, ie. need to fix_scale */
		sql_subtype *t = exp_subtype(e);
		list *exps = new_exp_list();

		list_append(exps, e);
		return exp_fix_scale(sql, t, exp_aggr(exps, a), 1, (t->type->scale == SCALE_FIX));
	} else {
		char *type = exp_subtype(e)->type->sqlname;

		exp_destroy(e);
		return sql_error(sql, 02, "aggregate: %s(%s) unknown", l->h->data.sval, type);
	}
	return NULL;
}

static sql_exp *
rel_cast(mvc *sql, sql_rel *rel, symbol *se, int f)
{

	dlist *dl = se->data.lval;
	symbol *s = dl->h->data.sym;
	sql_subtype *tpe = dl->h->next->data.typeval;

	sql_exp *e = rel_value_exp(sql, rel, s, f);

	if (e)
		return rel_check_type(sql, tpe, e, type_cast);
	return NULL;
}


static sql_exp *
rel_value_exp(mvc *sql, sql_rel *rel, symbol *se, int f)
{
	(void)sql;
	(void)rel;
	(void)f;
	switch (se->token) {
	case SQL_OP:
		return rel_op(sql, rel, se );
	case SQL_UNOP:
		return rel_unop(sql, rel, se, f);
	case SQL_BINOP:
		return rel_binop(sql, rel, se, f);
	case SQL_NOP:
		return rel_nop(sql, rel, se, f);
	case SQL_AGGR:
		return rel_aggr(sql, rel, se, f);
	case SQL_COLUMN:
		return rel_column_ref(sql, rel, se );
	case SQL_SELECT:{
		sql_rel *r = rel_subquery(sql, rel, se);

		/* convert relation into expression, limit to single columns */
		if (r && r->op == op_project && list_length(r->exps) == 1) {
			return exp_relation(r);
		} else if (r) {
			rel_destroy(r);
		}
		return NULL;
	}
	/*
	case SQL_PARAMETER:{
		char *n = "param";
		stmt *s;

		if (sql->mode != m_prepare) {
			return sql_error(sql, 02, "Cannot have parameters (?) in normal queries, use PREPARE;");
		}
		sql_add_param(sql, _strdup(n), s = stmt_var(_strdup(n), NULL));
		return stmt_dup(s);
	}
	case SQL_NULL:
		return stmt_atom(atom_general(sql_dup_subtype(sql_bind_localtype("str")), NULL, 0));
	*/
	case SQL_ATOM:{
		AtomNode *an = (AtomNode *) se;

		if (!an || !an->a) {
			return exp_atom(atom_general(sql_dup_subtype(sql_bind_localtype("str")), NULL, 0));
		} else {
			return exp_atom(atom_dup(an->a));
		}
	}
	case SQL_CAST:
		return rel_cast(sql, rel, se, f);
	/*
	case SQL_CASE:
		return sql_case_exp(sql, scp, se, grp, subset, f);
	case SQL_COALESCE:
	case SQL_NULLIF:
		return sql_case_exp(sql, scp, se, grp, subset, f);
	*/
	default:
		return exp_relation(rel_logical_exp(sql, rel, se, f));
	}
	return NULL;
}

/* column expression of the form: table.* */
static list *
columns_exp(mvc *sql, sql_rel *rel, symbol *column_e )
{
	char *tname = column_e->data.lval->h->data.sval;
	sql_rel *p, *r = rel_bind_table(&p, rel, tname);

	(void)p;
	if (r) 
		return rel_projections( r, tname );
	return sql_error(sql, 02, "Column expression Table %s unknown", tname);
}

static sql_exp *
column_exp(mvc *sql, sql_rel *rel, symbol *column_e, int f)
{
	dlist *l = column_e->data.lval;
	sql_exp *ve = rel_value_exp(sql, rel, l->h->data.sym, f);

	if (!ve)
		return NULL;
	/* AS name */
	if (ve && l->h->next->data.sval) 
		exp_set_name(ve, l->h->next->data.sval);
	return ve;
}

static list *
rel_table_exp(mvc *sql, sql_rel *rel, symbol *column_e )
{
	if (column_e->token == SQL_TABLE) {
		return columns_exp(sql, rel, column_e);
	}
	return NULL;
}

static sql_exp *
rel_column_exp(mvc *sql, sql_rel *rel, symbol *column_e, int f)
{
	if (column_e->token == SQL_COLUMN) {
		return column_exp(sql, rel, column_e, f);
	}
	return NULL;
}

static sql_rel *
rel_simple_select(mvc *sql, sql_rel *rel, symbol *where, dlist *selection)
{
	list *exps;
	dnode *n = selection->h;

	(void) where;
	if (where) {
		sql_rel *r = rel_logical_exp(sql, rel, where, sql_where);
		if (!r)
			return NULL;
		rel = r;
	}
	exps = new_exp_list();
	for (; n; n = n->next ) {
		/* Here we could get real column expressions (including single
		 * atoms) but also table results. Therefor we try both
		 * rel_column_exp and rel_table_exp.
		 */
		list *te = NULL; 
		sql_exp *ce = rel_column_exp(sql, rel, n->data.sym, sql_sel);

		if (ce) {
			list_append(exps, ce);
			continue;
		} else {
			te = rel_table_exp(sql, rel, n->data.sym );
		}
		if (!ce && !te) {
			list_destroy(exps);
			return NULL;
		}
		/* here we should merge the column expressions we obtained
		 * sofar with the table expression, ie t1.* or a subquery 
		 */
		if (te) {
			exps = list_merge( exps, te, (fdup)&exp_dup);
			/*list_destroy(te);*/
		}
	}
	rel = rel_project(rel, exps);
	return rel;
}

static sql_rel *
rel_group_by(mvc *sql, sql_rel *rel, symbol *groupby )
{
	dnode *o = groupby->data.lval->h;
	list *exps = new_exp_list();

	for (; o; o = o->next) {
		symbol *grp = o->data.sym;
		sql_exp *e = rel_column_ref(sql, rel, grp);

		if (!e) {
			list_destroy(exps);
			return NULL;
		}
		list_append(exps, e);
	}
	return rel_groupby( rel, exps );
}

static sql_rel *
rel_order_by(mvc *sql, sql_rel *rel, symbol *orderby )
{
	list *exps = new_exp_list();
	dnode *o = orderby->data.lval->h;

	for (; o; o = o->next) {
		symbol *order = o->data.sym;

		if (order->token == SQL_COLUMN) {
			symbol *col = order->data.lval->h->data.sym;
			int direction = order->data.lval->h->next->data.ival;
			sql_exp *e = rel_column_ref(sql, rel, col);

			if (!e) {
				list_destroy(exps);
				return NULL;
			}
			e = exp_exp( e, exp_atom_int(direction) );
			list_append(exps, e);
		} else {
			return sql_error(sql, 02, "order not of type SQL_COLUMN\n");
		}
	}
	return rel_orderby( rel, exps);
}

static sql_rel *
rel_select_exp(mvc *sql, sql_rel *rel, SelectNode *sn, int toplevel)
{
	int aggr = 0;

	if (!sn->from)
		return rel_simple_select(sql, rel, sn->where, sn->selection);

	if (sn->where) {
		sql_rel *r = rel_logical_exp(sql, rel, sn->where, sql_where);
		if (!r) 
			return sql_error(sql, 02, "Subquery result missing");
		rel = r;
	}

	if (rel) {
		if (rel && sn->groupby) {
			rel = rel_group_by(sql, rel, sn->groupby );

			if (!rel) 
				return NULL;
			aggr = 1;
		}

		/* TODO ?? outer refs ?? */
	}

	if (sn->having) {
		/* having implies group by, ie if not supplied do a group by */
		if (rel->op != op_groupby) 
			rel = rel_groupby( rel, NULL);

		aggr = 1;
		rel = rel_logical_exp(sql, rel, sn->having, sql_search);

		if (!rel) 
			return NULL;
	}

	if (sn->selection) {
		list *exps = new_exp_list();
		dnode *n = sn->selection->h;

		for (; n; n = n->next) {
			/* Here we could get real column expressions 
			 * (including single atoms) but also table results. 
			 * Therefor we try both rel_column_exp 
			 * and rel_table_exp.
		 	 */
			list *te = NULL; 
			sql_exp *ce = rel_column_exp(sql, rel, n->data.sym, sql_sel);
			if (ce) {
				list_append(exps, ce);
				continue;
			} else {
				te = rel_table_exp(sql, rel, n->data.sym);
			}
			if (!ce && !te) {
				list_destroy(exps);
				return NULL;
			}
			/* here we should merge the column expressions we 
			 * obtained sofar with the table expression, ie 
			 * t1.* or a subquery.
		 	 */
			exps = list_merge( exps, te, (fdup)&exp_dup);
			/*list_destroy(te);*/
		}
		rel = rel_project(rel, exps);
	} else {
		/* select * from tables */

		if (aggr) {
			rel_destroy(rel);
			return sql_error(sql, 02, "Cannot combine select * with group by");
		}

		if (toplevel) {
			rel = rel_project(rel, rel_projections(rel, NULL));
		} else {
			/* 
			 * subquery can only return one column
			 */
		}
	}

	if (rel && sn->orderby) 
		rel = rel_order_by(sql, rel, sn->orderby);

	if (!rel) 
		return NULL;

	if (sn->limit > 0 || sn->offset > 0) {
		list *exps = new_exp_list();

		list_append(exps, exp_atom_int(sn->limit));
		if (sn->offset)
			list_append(exps, exp_atom_int(sn->offset));
		rel = rel_topn(rel, exps);
	}
	return rel;
}


sql_rel *
rel_query(mvc *sql, sql_rel *rel, symbol *sq, int toplevel)
{
	sql_rel *res = NULL;
	SelectNode *sn = (SelectNode *) sq;

	assert(sn->s.token == SQL_SELECT);

	if (!toplevel && sn->limit >= 0)
		return sql_error(sql, 01, "Can only limit outer select ");

	if (!toplevel && sn->orderby)
		return sql_error(sql, 01, "Can only order by outer select ");

	if (sn->from) {		/* keep variable list with tables and names */
		dlist *fl = sn->from->data.lval;
		dnode *n = NULL;
		sql_rel *fnd = NULL;

		for (n = fl->h; n ; n = n->next) {
			fnd = table_ref(sql, rel, n->data.sym);

			if (!fnd)
				break;
			if (res) 
				res = rel_crossproduct(res, fnd);
			else 
				res = fnd;
		}

		if (!fnd) {
			if (res)
				rel_destroy(res);
			return NULL;
		}

	} else if (toplevel) {	/* only on top level query */
		return rel_simple_select(sql, rel, sn->where, sn->selection);
	}
	return rel_select_exp(sql, res, sn, toplevel);
}

static sql_rel *
rel_subquery(mvc *sql, sql_rel *rel, symbol *sq)
{
	int toplevel = (rel) ? 0 : 1;

	return rel_query(sql, rel, sq, toplevel);
}

sql_rel *
rel_selects(mvc *sql, symbol *s)
{
	sql_rel *ret = NULL;

	switch (s->token) {
	case SQL_SELECT:
		ret = rel_subquery(sql, NULL, s);
		sql->type = Q_TABLE;
		break;
	case SQL_JOIN:
		sql->type = Q_TABLE;
		break;
	case SQL_CROSS:
		sql->type = Q_TABLE;
		break;
	case SQL_UNION:
		sql->type = Q_TABLE;
		break;
	case SQL_EXCEPT:
		sql->type = Q_TABLE;
		break;
	case SQL_INTERSECT:
		sql->type = Q_TABLE;
		break;

	default:
		return NULL;
	}
	rel_print(sql, ret, 0);
	printf("\n");
	return ret;
}
