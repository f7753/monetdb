@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at 
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@' 
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@' 
@' The Original Code is the Monet Database System.
@' 
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2002 CWI.  
@' All Rights Reserved.
@' 
@' Contributor(s):
@' 		Martin Kersten <Martin.Kersten@cwi.nl>
@' 		Niels Nes <Niels.Nes@cwi.nl>

@f logger
@t Transactions
@a N. J. Nes
@v 1.0
@T
@* Introduction
[Make it a re-useable piece of code if possible, i.e. a module]
In the philosophy of Monet, transaction management overhead should only
be paid when necessary. Transaction management is for this purpose 
implemented as a separate module and applications are required to
obey the transaction policy, e.g. obtaining/releasing locks. 

This module is designed to support efficient logging of [SQL?] database.
Once loaded, the SQL compiler will insert the proper calls at
transaction commit to include the changes in the log file.

The log format is choosen to simplify reloading it. This means
that the internal (byte) representation is stored in the log file,
prepended with a byte length.

[Niels, it does not necessarily work upon recovery, because the ADT
may require an update of the local access structure, e.g. the
hash table in the string heap.]
[The alternative storage structure is an ascii dump, using a slightly
enhanced Monet dumpfile format.
 +batname[hv,tv]	insert the bun
 -batname[hv,tv]	delete the bun
 *batname[headtype,tailtype]	define a bat
 =bat timestamp		check/update the bat timestamp

possibly use the tag and batname as a mode switcher to reduce the
the storage, i.e.
=mybat[int,int]
+[1,1]
[2,2]
[3,3]
-[2,2]
=yourbat[int,str]
*yourbat 16824
-[3,3]

Alternative, use dbfarm/log/bat-date-version subdirectory
]

The key decision to be made by the user is the location of the log file.
Ideally, it should be stored in fail-safe environment, or at least
the log and databases should be on separate disk volumns.

The current setup assumes that the log directory is a mounted file system. (?)
This file system may reside on the hardware as the database server
and therefor the writes are done to the same disk, but could also 
reside on an other system and then the changes are flushed through the network.  
The default location to store the database log is ....

The logger works under the assumption that it is called to safeguard
updates on the database when it has an exclusive lock on
the latest version. This lock should be guaranteed by calling
the transaction manager first.

Finding the updates applied to a BAT is relatively easy, because each
BAT contains a delta structure. On commit these changes are
writen to the log file and the delta management is reset. Since each 
commit is written to the same log file, the beginning and end are 
marked by a log identifier.

Shouldn;t you dump the BAT version/timestamp? Updates are only
allowed when the BAT timestamp does not prohibit this.

A server restart should only (re)process blocks which are completely 
written to disk. 
Actually, the logger should issue commit statements after each block.

@* Implementation Code 
@h
#ifndef _LOGGER_H_
#define _LOGGER_H_

#include <gdk.h>

extern struct logger *logger_create(int debug, char *dirname );
extern void logger_destroy(struct logger *logger);
/* temporary add statement to make current bats persistent */
extern void logger_persists(struct logger *logger);

extern bat log_find_bat(struct logger* logger, char *name);

extern void log_bat(struct logger* logger, BAT *b);
extern void log_bat_persists(struct logger* logger, BAT *b, char *name );
extern void log_bat_transient(struct logger* logger, BAT *b );

/* for now only one level of transactions is supported */
/* later log_tstart/tend could be replaced by log_begin/log_commit/log_abort */
extern void log_tstart(struct logger *logger);
extern void log_tend(struct logger *logger);


#endif /*_LOGGER_H_*/
@c
#include "logger.h"
#include "stream.h"
#include "mem.h"

@-
The log record encoding is geared at reduced storage space, but
at the expense of readability. A user can not easily inspect the
log a posteriori to check what has happened.

Since the logger uses global variables, you could opt to provide the
exclusive access as part of the logger implementation. 
This means that a client should use the following scheme

... update bat B ...
logger.start()
logger.safe(B)
... other BAT updates to be safed.
logger.commit()
gdk.commit()	# implied by the logger.commit?

[Niels, why not keeping a log per bat, e.g. mybat.log.230102.1 ?
this simplifies parallel 
recovery after a crash. Furthermore, the log time stamp can be
compared with the BAT to see if you need to consult the log file.]
[Martin, this is not done as keeping multiple files open (or opening
multiple files) has a too great performance impact.]
@c
#define LOG_START	1
#define LOG_END		2
#define LOG_INSERT 	3
#define LOG_DELETE	4
#define LOG_CREATE 	5
#define LOG_DESTROY	6

typedef struct logformat_t {
	char flag;
	int nr;
} logformat;

#define LOGFILE "log"

typedef struct logger {
	int 	debug;
	int	id;
	int	tid;
	int	bid;
	char*	dir;
	stream*	log;
	BAT*	bat_version;	/*	[ void, int ] 	*/
	BAT*	bat_name; 	/*	[ void, str ] 	*/
	BAT*	bat_bid;	/*	[ void, oid ] 	*/
	/* Store oids to circumvent trouble with reference counting */
} logger;

static oid logger_name2lbid(logger *logger, char *name)
{
	BAT *r_bat_name = BATmirror(logger->bat_name);
	oid res = 0;
	ptr p = BUNfnd(r_bat_name, name);
	if (p)
		res = *(oid*)BUNtail(r_bat_name, p);
	return res;
}

static char *logger_lbid2name(logger *logger, oid lbid)
{
	return BUNtail(logger->bat_name, BUNfnd(logger->bat_name, &lbid));
}

static oid logger_bat2lbid(logger *logger, bat bid)
{
	BAT *r_bat_bid = BATmirror(logger->bat_bid);
	oid res = 0;
	ptr p = BUNfnd(r_bat_bid, &bid);
	if (p)
		res = *(oid*)BUNtail(r_bat_bid, p);
	return res;
}

static bat logger_lbid2bat(logger *logger, oid lbid)
{
	return *(bat*)BUNtail(logger->bat_bid, BUNfnd(logger->bat_bid, &lbid));
}

static void logger_new_version(logger *logger, oid lbid )
{
	BUNreplace(logger->bat_version, (ptr)&lbid, (ptr)&logger->tid);
}

static void logger_add_bat(logger *logger, BAT *b, char *name)
{
	oid bid = b->batCacheid;
	BUNins(logger->bat_version, &logger->bid, &logger->tid );
	BUNins(logger->bat_name, &logger->bid, name );
	BUNins(logger->bat_bid, &logger->bid, &bid);
	logger->bid++;
}

static void logger_del_bat(logger *logger, oid lbid)
{
	BUNdelHead(logger->bat_version, &lbid);
	BUNdelHead(logger->bat_name, &lbid);
	BUNdelHead(logger->bat_bid, &lbid);
}

static int log_read_format( logger *l, logformat *data )
{
	int res = 1;
	if (l->log->read(l->log, &data->flag, 1, 1) != 1)
		return 0;
	res = stream_readInt(l->log, &data->nr);
	return res;
}

static void log_write_format( logger *l, logformat *data )
{
	l->log->write(l->log, &data->flag, 1, 1);
	stream_writeInt(l->log, data->nr);
}

static char *log_read_string(logger *l)
{
	int len;
	char *buf; 

	stream_readInt(l->log, &len); 
	buf = NEW_ARRAY(char,len);
	l->log->read( l->log, buf, 1, len);
	return  buf;
}

static void log_write_string(logger *l, char *n)
{
	int len = strlen(n)+1; /* log including EOS */
	stream_writeInt( l->log, len);
	l->log->write( l->log, n, 1, len);
}

void log_read_updates(logger *logger, logformat *l, char *name ){
	oid lbid = logger_name2lbid(logger,name);
	BAT *b = BATdescriptor(logger_lbid2bat(logger,lbid));

        if (logger->debug&1)
		fprintf(stderr, "found log_read_updates %s %s %d\n", name, 
				(l->flag==LOG_INSERT)?"insert":"delete",
				l->nr);

        if (b){
		int cnt = BATcount(b);
		void *(*rh)( void *a, stream *s) = BATatoms[b->htype].atomRead;
		void *(*rt)( void *a, stream *s) = BATatoms[b->ttype].atomRead;
		void *hv = ATOMnil(b->htype);
		void *tv = ATOMnil(b->ttype);

		if (b->hseqbase != oid_nil)
			cnt += b->hseqbase;
		if (b->tseqbase != oid_nil)
			cnt += b->tseqbase;

                for(; l->nr>0; l->nr--){
			void *h = rh( hv, logger->log);
			void *t = rt( tv, logger->log);
                        if (l->flag == LOG_INSERT)
                                BUNins( b, h, t );
                        else if (l->flag == LOG_DELETE)
                                BUNdel( b, h, t );
			cnt++;
			if (h != hv) _DELETE(h);
			if (t != tv) _DELETE(t);
                }
		_DELETE(hv);
		_DELETE(tv);
		logger_new_version(logger, lbid);
		BATfakeCommit(b);
	}
}

void log_read_destroy(logger *logger, logformat *l, char *name )
{
	oid lbid = logger_name2lbid(logger, name);
	if (lbid){
		bat bid = logger_lbid2bat(logger, lbid);
		BBPtransient(bid, FALSE);
		BBPunfix(bid);
		logger_del_bat(logger, lbid);
	}
}

void log_read_create(logger *logger, logformat *l, char *name )
{
	int len;
	char *buf = log_read_string(logger);

        if (logger->debug&1)
		fprintf(stderr, "log_read_create %s\n", name );

	if (!buf){
		fprintf(stderr, "could not read create (%s)\n", name);
	} else {
		int ht, tt, hseq = 0, tseq = 0;
		char *ha = buf, *ta = strchr(buf, ',');
		BAT *b;
		if (!ta){
			fprintf(stderr, "types are not , seperated (%s)\n",buf);
			return;
		}
		*ta = 0; ta++; /* skip over , */
		if (strcmp(ha,"vid") == 0){
			ht = TYPE_void;
			hseq = 1;
		} else {
			ht = ATOMindex(ha);
		}
		if (strcmp(ta,"vid") == 0){
			tt = TYPE_void;
			tseq = 1;
		} else {
			tt = ATOMindex(ta);
		}
		b = BATnew( ht, tt, BUFSIZ);

		if (hseq)
			BATseqbase(b,0);
		if (tseq)
			BATseqbase(BATreverse(b),0);

		if (!b){
			fprintf(stderr, "could not create bat (%s,%s,%s,%d,%d)\n"
				,name,ha,ta,ht,tt);
			return;
		}
		BBPpersistent(b->batCacheid, FALSE);
		logger_add_bat(logger, b, name);
		BATfakeCommit(b);
	}
	if (buf) _DELETE(buf);
}

int readlog( logger *logger, char *filename ){
	logformat l;

	logger->log = open_rstream(filename);

	/* if the file doesn't exist, there is nothing to be readback */ 
	if (!logger->log || logger->log->errnr){
		if (logger->log) logger->log->destroy(logger->log);
	       	return 0;
	}
	while( log_read_format(logger, &l) ){
		char *name = NULL;
		int len;

		if (l.flag != LOG_START && l.flag != LOG_END){
			name = log_read_string(logger);

			if (!name){
				fprintf(stderr, 
					"could not read name (%d)\n", l.flag );
				return -1;
			}
		}
		switch(l.flag){
		case LOG_START:
			/* TODO if START not after end, do a rollback of
			 * the just done bats (ie all bats with version == tid)
			 */
		case LOG_END:
			break;
		case LOG_INSERT:
			log_read_updates(logger, &l, name);
			break;
		case LOG_DELETE:
			log_read_updates(logger, &l, name);
			break;
		case LOG_CREATE:
			log_read_create(logger, &l, name );
			break;
		case LOG_DESTROY:
			log_read_destroy(logger, &l, name );
			break;
		default:
			fprintf(stderr, "logger error %d %s\n", l.flag, name);
			return -2;
		}
		if (name) _DELETE(name);
	}
	logger->log->close(logger->log);
	logger->log->destroy(logger->log);
	return 0;
}

@-
The log files are incrementally numbered. They are processed in the
same sequence.
@c
int readlogs( logger *logger, FILE *fp, char *filename ){
	int res = 0;
	char id[BUFSIZ];

        if (logger->debug&1)
		fprintf(stderr, "readlogs %s\n", filename);

	while(fgets(id, BUFSIZ, fp) != NULL){
		char buf[BUFSIZ];

		logger->id = strtol(id,NULL,10);
		snprintf(buf, BUFSIZ, "%s.%d", filename, logger->id );

		if ((res = readlog(logger, buf)) != 0){
			break;
		}
	}
	return res;
}

logger *logger_create(int debug, char *dirname){
	logger *logger = NEW(struct logger);
	FILE *fp;
	char filename[BUFSIZ];

	logger->debug = debug;
	logger->id = 1;
	logger->tid = 1;
	logger->bid = 1;
	logger->dir = _strdup(dirname);
	logger->log = NULL;
	logger->bat_version = BATnew(TYPE_oid,TYPE_int,BUFSIZ); 
		BBPfix(logger->bat_version->batCacheid);
	logger->bat_name = BATnew(TYPE_oid,TYPE_str,BUFSIZ); 
		BBPfix(logger->bat_name->batCacheid);
	logger->bat_bid = BATnew(TYPE_oid,TYPE_oid,BUFSIZ); 
		BBPfix(logger->bat_bid->batCacheid);

	snprintf(filename, BUFSIZ, "%s%c%s", logger->dir, DIR_SEP, LOGFILE);

	if ( (fp = fopen(filename, "r+")) != NULL){
		readlogs(logger, fp, filename);
	} else if ( (fp = fopen(filename, "w")) == NULL){
		fprintf(stderr, "could not create file %s\n", filename);
		exit(1);
	}
	logger->id++;
	fprintf(fp, "%d\n", logger->id);
	fclose(fp);

	snprintf(filename, BUFSIZ, "%s%c%s.%d", logger->dir, DIR_SEP, LOGFILE, logger->id);
	logger->log = open_wstream(filename);
	return logger;
}

void logger_destroy(logger *logger)
{
	stream *log = logger->log;
	_DELETE(logger->dir);
	log->close(log);
	log->destroy(log);

	BBPunfix(logger->bat_version->batCacheid);
	BBPunfix(logger->bat_name->batCacheid);
	BBPunfix(logger->bat_bid->batCacheid);
}

void logger_persists(logger *logger)
{
	int i, cnt = BATcount(logger->bat_version);

	for(i = 1; i<=cnt; i++){
		str name = BUNtail(logger->bat_name,BUNfnd(logger->bat_name,&i));
		bat bid = *(oid*)BUNtail(logger->bat_bid,BUNfnd(logger->bat_bid,&i));
		BATrename(BATdescriptor(bid), name);
		BBPpersistent(bid,TRUE);
	}
}

void logger_restart(logger *logger)
{
	stream *log = logger->log;
	FILE *fp;
	char filename[BUFSIZ];

	log->close(log);
	log->destroy(log);

	snprintf(filename, BUFSIZ, "%s%c%s", logger->dir, DIR_SEP, LOGFILE);

	if ( (fp = fopen(filename, "r+")) != NULL){
		logger->id++;
		fprintf(fp, "%d\n", logger->id);
		fclose(fp);
	}
	logger->log = open_wstream(filename);

}

void logger_remove_files( int start, int end )
{
	int i;
	/* open LOGFILE.NEW (writing)
	 * open LOGFILE	(reading)
	 * output all lines with nr >= end.
	 * close LOGFILE.NEW
	 * move LOGFILE LOGFILE.BAK
	 * move LOGFILE.NEW LOGFILE
	 * remove LOGFILE.BAK
	 */
	for (i = start; i<end; i++){
		/* remove log i; */
	}
}

@-
Changes made to the BAT descriptor should be stored in the log files.
Actually, we need to save the descriptor file, perhaps we should simply
introduce a versioning scheme. 
@c
void log_bat_persists(logger *logger, BAT *b, char *name ){
	char *ha, *ta;
	int len;
	char buf[BUFSIZ];
	logformat l;
	int havevoid = 0;

	logger_add_bat(logger, b, name);
	l.flag = LOG_CREATE;
	l.nr = 0;
	log_write_format( logger, &l );
	log_write_string(logger, name);
	ha = ATOMname(b->htype);
	if (b->htype == TYPE_void && BAThdense(b)){
		ha = "vid";
		havevoid = 1;
	}
	ta = ATOMname(b->ttype);
	if (!havevoid && b->ttype == TYPE_void && BATtdense(b)){
		ta = "vid";
	}
	len = snprintf(buf, BUFSIZ,"%s,%s", ha, ta );
	len++; /* include EOS */
	stream_writeInt( logger->log, len );
	logger->log->write( logger->log, buf, 1, len );
	
        if (logger->debug&1)
		fprintf(stderr, "new bat %s htype %d ttype %d\n", name,
			b->htype, b->ttype );
	log_bat(logger, b);
}

void log_bat_transient(logger *logger, BAT *b ){
	oid lbid = logger_bat2lbid(logger, b->batCacheid);
	char *name = logger_lbid2name(logger, lbid);
	int len;
	char buf[BUFSIZ];
	logformat l;

	l.flag = LOG_DESTROY;
	l.nr = 0;
	log_write_format( logger, &l );
	log_write_string(logger, name);
	
        if (logger->debug&1)
		fprintf(stderr, "destroyed bat %s htype %d ttype %d\n", name,
			b->htype, b->ttype );
	BATfakeCommit(b);
	logger_del_bat(logger, lbid);
}

void log_bat(logger *logger, BAT *b ){
	oid lbid = logger_bat2lbid(logger, b->batCacheid);
	char *name = logger_lbid2name(logger, lbid);
	logformat l;
	int 	status;
	BUN	p; 

	l.nr = BUNindex(b, BUNlast(b)) - BUNindex(b, b->batInserted);
	if (l.nr){
		void (*wh)( ptr a, stream *s) = BATatoms[b->htype].atomWrite;
		void (*wt)( ptr a, stream *s) = BATatoms[b->ttype].atomWrite;
	    	l.flag = LOG_INSERT;
		log_write_format( logger, &l );
		log_write_string(logger, name);
	    	for (p = b->batInserted; p < BUNlast(b); p = BUNnext(b, p)){
			int s1,s2;
			ptr h = BUNhead(b,p);
			ptr t = BUNtail(b,p);
			wh( h, logger->log);
			wt( t, logger->log);
	    	}

		if (logger->debug)
			fprintf(stderr, "Logged %s %d inserts\n", name, l.nr );
	}
	l.nr = BUNindex(b, b->batHole) - BUNindex(b, b->batDeleted);
	if (l.nr){
		void (*wh)( ptr a, stream *s) = BATatoms[b->htype].atomWrite;
		void (*wt)( ptr a, stream *s) = BATatoms[b->ttype].atomWrite;
	    	l.flag = LOG_DELETE;
		log_write_format( logger, &l);
		log_write_string(logger, name);
	    	for (p = b->batDeleted; p < b->batHole; p = BUNnext(b, p)){
			int s1,s2;
			ptr h = BUNhead(b,p);
			ptr t = BUNtail(b,p);
			wh( h, logger->log);
			wt( t, logger->log);
	    	}

	    	if (logger->debug)
			fprintf(stderr, "Logged %s %d deletes\n", name, l.nr );
	}
	BATfakeCommit(b);
	logger_new_version(logger, lbid);
}

static void logger_commit(){
	int *kills = TMfakeCommit();
	TMkill(kills);
}

void log_tstart( logger *logger )
{
	logformat l;
	/* need to change to writing/reading blocks as it may not use
	 * su much memory that the commit fails */

	if (logger->debug)
		fprintf(stderr, "log_tstart %d\n", logger->tid );

	l.flag = LOG_START;
	l.nr = ++logger->tid;
	log_write_format( logger, &l );
}

void log_tend(logger *logger )
{
	logformat l;

	logger_commit();

	if (logger->debug)
		fprintf(stderr, "log_tend\n" );

	l.flag = LOG_END;
	l.nr = logger->tid;
	log_write_format( logger, &l );

	logger->log->flush( logger->log );
}

bat log_find_bat(logger* logger, char *name)
{
	oid lbid = logger_name2lbid(logger, name);
	if (lbid){
		return logger_lbid2bat(logger, lbid); 
	}
	return 0;
}
