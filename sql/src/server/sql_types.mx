@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@' 
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@' 
@' The Original Code is the Monet Database System.
@' 
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2004 CWI.
@' All Rights Reserved.
@' 
@' Contributor(s):
@' 		Martin Kersten <Martin.Kersten@cwi.nl>
@' 		Peter Boncz <Peter.Boncz@cwi.nl>
@' 		Niels Nes <Niels.Nes@cwi.nl>
@' 		Stefan Manegold  <Stefan.Manegold@cwi.nl>

@f sql_types
@a N.J. Nes
@* 

@h
#ifndef SQL_TYPES_H
#define SQL_TYPES_H

#include <sql_mem.h>
#include <sql_list.h>
#include <stream.h>

sql_export list *types;

#define SCALE_NONE	0
#define SCALE_FIX	1
#define SCALE_NOFIX	2
#define SCALE_ADD	3
#define SCALE_SUB	4

#define sql_max(i1,i2) ((i1)<(i2))?(i2):(i1)

typedef struct sql_type {
	sql_ref ref;

	char *sqlname;
	char *name;
	unsigned int digits;
	unsigned int scale; /* indicates how scale is used in functions */
	unsigned int radix; 
	int nr;
	int localtype; 	/* localtype, need for coersions */
} sql_type;

typedef struct sql_subtype {
	sql_ref ref;

	sql_type *type;
	unsigned int digits;
	unsigned int scale;
} sql_subtype;

typedef struct sql_aggr {
	sql_ref ref;

	char *name;
	char *imp;
	sql_subtype *tpe;
	sql_subtype *res;
	int nr;
} sql_aggr;

typedef struct sql_subaggr {
	sql_ref ref;

	sql_aggr *aggr;
	sql_subtype res;
} sql_subaggr;

/* sql_func need type transform rules 
 * types are equal if underlying types are equal +
	scale is equal
 * if types do not mach we try type conversions
 * 	which means for simple 1 arg functions
 *
 *
 */

typedef struct sql_arg {
	char *name;
	sql_subtype *type;
} sql_arg;

typedef struct sql_func {
	sql_ref ref;

	char *name;
	char *imp;
	list *ops; /* param list */
	sql_subtype *res;
		   /* res->scale
		      SCALE_NOFIX/SCALE_NONE => nothing 
		      SCALE_FIX => input scale fixing, 
		      SCALE_ADD => leave inputs as is and do add scales 
		      SCALE_SUB => first input scale, fix with second scale
				   result scale is equal to first input
		    */
	int nr;
	int sql; /* simple sql or native implementation */ 
} sql_func;

typedef struct sql_subfunc {
	sql_ref ref;

	sql_func *func;
	sql_subtype res;
} sql_subfunc;

sql_export sql_subtype *sql_bind_subtype( char *name, unsigned int digits, unsigned int scale );
sql_export sql_subtype *sql_bind_localtype( char *name );
sql_export sql_subtype *sql_create_subtype( sql_type *t, unsigned int s, unsigned int d );
sql_export sql_subtype *sql_dup_subtype( sql_subtype *t );
sql_export void sql_subtype_destroy( sql_subtype *t );

sql_export int type_cmp( sql_type *t1, sql_type *t2);
sql_export int subtype_cmp( sql_subtype *t1, sql_subtype *t2);

sql_export sql_type *sql_create_type(char *sqlname, unsigned int digits, unsigned int scale, unsigned int radix, char *name );

sql_export sql_arg *sql_create_arg( char *name, sql_subtype *t );
sql_export void arg_destroy( sql_arg *a );

sql_export sql_subaggr *sql_bind_aggr( char *name, sql_subtype *type);
sql_export sql_aggr *sql_create_aggr( char *name, char *imp, sql_type *tpe, sql_type *res);
sql_export sql_subaggr *sql_dup_aggr( sql_subaggr *a);
sql_export void sql_subaggr_destroy( sql_subaggr *f);

sql_export sql_subfunc *sql_bind_func( char *name, sql_subtype *tp1, sql_subtype *tp2);
sql_export sql_subfunc *sql_bind_func_result( char *name, sql_subtype *tp1, sql_subtype *tp2, sql_subtype *res);

sql_export sql_subfunc *sql_bind_func_( char *name, list *ops);
sql_export sql_subfunc *sql_bind_func_result_( char *name, list *ops, sql_subtype *res);
sql_export sql_subfunc *sql_dup_func( sql_subfunc *f);
sql_export void sql_subfunc_destroy( sql_subfunc *f);
sql_export sql_subfunc *sql_bind_proc( char *name, list *ops );

sql_export sql_func *sql_create_func(char *name, char *imp, sql_type *tpe1, sql_type *tpe2, sql_type *res, int scale_fixing);

sql_export sql_func *sql_create_func_(char *name, char *imp, list *ops, sql_subtype *res);

sql_export sql_func *sql_create_sqlfunc(char *name, char *imp, list *ops, sql_subtype *res );

sql_export void parser_init(int debug);
sql_export void parser_exit();

#endif /* SQL_TYPES_H */
@c
#include "sql_types.h"
#include "sql_symbol.h"
#include "sql_parser.tab.h"
#include "sql_statement.h"
#include "sql_scan.h"	/* for keyword_exists(), keywords_insert(), init_keywords(), exit_keywords() */
#include <string.h>

#define END_SUBAGGR	1
#define END_AGGR	2
#define END_SUBTYPE	3
#define END_TYPE	4

static int sql_debug = 0;

list *types = NULL;
static list *aggrs = NULL;
static list *funcs = NULL;

static list *localtypes = NULL;
static list *subtypes = NULL;
static list *subaggrs = NULL;
static list *subfuncs = NULL;

static void sqltypeinit();

sql_subtype *sql_create_subtype( sql_type *t, unsigned int digits, unsigned int scale )
{
	sql_subtype *res = NEW(sql_subtype);

	sql_ref_init( &(res->ref) );
	sql_ref_inc( &(t->ref) );
	res->type = t;
	res->digits = digits?digits:t->digits;
	res->scale = scale;
	if (sql_debug){
		sql_ref_inc( &(res->ref) );
		list_append( subtypes,  res);
	}
	return res;
}

sql_subtype *sql_dup_subtype( sql_subtype *res )
{
	sql_ref_inc( &(res->ref) );
	return res;
}

sql_subtype *sql_bind_subtype( char *name, unsigned int digits, unsigned int scale )
	/* todo add approximate info 
	 * if digits/scale == 0 and no approximate with digits/scale == 0
	 * exits we could return the type with largest digits 
	 *
	 * returning the largest when no exact match is found is now the
	 * (wrong?) default
	 */
{
	/* assumes the types are ordered on name,digits,scale where is always
	 * 0 > n
	 */
	node *m, *n;
	for ( n = types->h; n; n = n->next ) {
		sql_type *t = n->data;
		if (strcasecmp(t->sqlname, name) == 0){
			if ((digits && t->digits >= digits) || 
					(digits == t->digits)){
				return sql_create_subtype(t, digits, scale);
			}
			for (m = n->next; m; m = m->next ) {
				t = m->data;
				if (strcasecmp(t->sqlname, name) != 0){
					break;
				}
				n = m;
				if ((digits && t->digits >= digits) || 
					(digits == t->digits)){
					return sql_create_subtype(t, digits, scale);
				}
			}
			t = n->data;
			return sql_create_subtype(t, digits, scale);
		}
	}
	return NULL;
}

static int sql_end = 0;
static void type_destroy(sql_type * t)
{
	int ref = 0;
	if ((ref = sql_ref_dec( &(t->ref) )) == 0){
		_DELETE(t->sqlname);
		_DELETE(t->name);
		_DELETE(t);
	} else if (sql_end == END_TYPE){
		printf("= REFCOUNT of type %s %s is wrong %d\n", t->name, t->sqlname, ref);
	}
}

void sql_subtype_destroy(sql_subtype * t)
{
	int ref = 0;
	if ((ref = sql_ref_dec( &(t->ref)) ) == 0){
		type_destroy(t->type);
		_DELETE(t);
	} else if (sql_end == END_SUBTYPE){
		printf("= REFCOUNT of subtype %s %s is wrong %d\n", t->type->name, t->type->sqlname, ref);
	}
}

sql_subtype *sql_bind_localtype( char *name )
{
	node *n = localtypes->h;
	while (n) {
		sql_subtype *t = n->data;
		if (strcmp(t->type->name, name) == 0){
			return t;
		}
		n = n->next;
	}
	assert(0);
	return NULL;
}

sql_type *sql_bind_type( char *name )
{
	node *n = types->h;
	while (n) {
		sql_type *t = n->data;
		if (strcmp(t->name, name) == 0){
			return t;
		}
		n = n->next;
	}
	assert(0);
	return NULL;
}

int type_cmp( sql_type *t1, sql_type *t2)
{
	int res = 0;
	if (!t1 || !t2)
		return -1;
	/* types are only equal 
		iff they map onto the same systemtype */
	res = (t1->localtype-t2->localtype);
	if (res) return res;
	/* and
		iff they have the same sqlname */
	return (strcmp(t1->sqlname, t2->sqlname));
}

int subtype_cmp( sql_subtype *t1, sql_subtype *t2 )
{
	if (!t1 || !t2)
		return -1; 
	/* subtypes are only equal iff 
			they map onto the same systemtype */
	return (type_cmp( t1->type, t2->type));
}


sql_subaggr *sql_bind_aggr(char *sqlaname, sql_subtype *type)
{
	char *name = toLower(sqlaname);
	node *n = aggrs->h;
	while (n) {
		sql_aggr *a = n->data;
		if (strcmp(a->name, name) == 0 &&
		    (!a->tpe
		     || (type && subtype_cmp(a->tpe, type) == 0))){
			sql_subaggr *ares = NEW(sql_subaggr);
			_DELETE(name);
			sql_ref_init( &(ares->ref) );
			sql_ref_inc( &(a->ref) );
			ares -> aggr = a;
			ares -> res = *a->res;
			/* same scale as the input */
			if (type)
				ares -> res . scale = type->scale; 
			if (sql_debug){
				sql_ref_inc( &(ares->ref) );
				list_append(subaggrs, ares);
			}
			return ares;
		}
		n = n->next;
	}
	_DELETE(name);
	return NULL;
}

static void aggr_destroy(sql_aggr * t)
{
	int ref = 0;
	if ((ref = sql_ref_dec( &(t->ref) )) == 0){
		_DELETE(t->name);
		_DELETE(t->imp);
		if (t->tpe) sql_subtype_destroy(t->tpe);
		sql_subtype_destroy(t->res);
		_DELETE(t);
	} else if (sql_end == END_AGGR){
		printf("= REFCOUNT of aggr %s %s is wrong %d\n", t->name, t->imp, ref);
	}
}

sql_subaggr *sql_dup_aggr(sql_subaggr *a)
{
	sql_ref_inc( &(a->ref) );
	return a;
}

void sql_subaggr_destroy( sql_subaggr *a )
{
	int ref = 0;
	if ((ref = sql_ref_dec( &(a->ref) )) == 0){
		aggr_destroy(a->aggr);
		_DELETE(a);
	} else if (sql_end == END_SUBAGGR){
		printf("= REFCOUNT of subaggr %s %s is wrong %d\n", a->aggr->name, a->aggr->imp, ref);
	} 
}

sql_subfunc *sql_bind_func(char *sqlfname, sql_subtype *tp1, sql_subtype *tp2)
{
	list *l = list_create((fdestroy)&sql_subtype_destroy);
	sql_subfunc *fres;

	if (tp1)
		list_append(l, sql_dup_subtype(tp1));
	if (tp2)
		list_append(l, sql_dup_subtype(tp2));

	fres = sql_bind_func_(sqlfname, l);
	list_destroy(l);
	return fres;
}

int arg_subtype_cmp( sql_arg *a, sql_subtype *t )
{
	return subtype_cmp(a->type, t);
}

sql_subfunc *sql_bind_func_(char *sqlfname, list *ops )
{
	char *name = toLower(sqlfname);
	node *n = funcs->h;
	while (n) {
		sql_func *f = n->data;
		if (!f->res)
			continue;
		if (strcmp(f->name, name) == 0){ 
		   if (list_cmp(f->ops, ops, (fcmp)&arg_subtype_cmp) == 0){
			sql_subfunc *fres = NEW(sql_subfunc);
			_DELETE(name);
			sql_ref_init( &(fres->ref) );
			sql_ref_inc( &(f->ref) );
			fres -> func = f;
			fres -> res = *f->res;
			fres -> res . scale = 0;
			for (n=ops->h; n; n=n->next){
				sql_subtype *a = n->data;
				/* same scale as the input */
				if (a && a->scale > fres->res.scale)
					fres -> res . scale = a->scale; 
			}
			if (sql_debug){
				sql_ref_inc( &(fres->ref) );
				list_append(subfuncs, fres);
			}
			return fres;
                   }
		}
		n = n->next;
	}
	_DELETE(name);
	return NULL;
}

sql_subfunc *sql_bind_func_result(char *sqlfname, sql_subtype *tp1, sql_subtype *tp2, sql_subtype *res)
{
	list *l = list_create((fdestroy)&sql_subtype_destroy);
	sql_subfunc *fres;

	if (tp1)
		list_append(l, sql_dup_subtype(tp1));
	if (tp2)
		list_append(l, sql_dup_subtype(tp2));

	fres = sql_bind_func_result_(sqlfname, l, res);
	list_destroy(l);
	return fres;
}

sql_subfunc *sql_bind_func_result_(char *sqlfname, list *ops, sql_subtype *res )
{
	char *name = toLower(sqlfname);
	node *n = funcs->h;
	while (n) {
		sql_func *f = n->data;
		if (!f->res)
			continue;
		if (strcmp(f->name, name) == 0 &&
		    subtype_cmp(f->res, res) == 0 &&
		    list_cmp(f->ops, ops, (fcmp)&arg_subtype_cmp) == 0){
			sql_subfunc *fres = NEW(sql_subfunc);
			_DELETE(name);
			sql_ref_init( &(fres->ref) );
			sql_ref_inc( &(f->ref) );
			fres -> func = f;
			fres -> res = *f->res;
			fres -> res . scale = 0;
			for (n=ops->h; n; n=n->next){
				sql_subtype *a = n->data;
				/* same scale as the input */
				if (a && a->scale > fres->res.scale)
					fres -> res . scale = a->scale; 
			}
			if (sql_debug){
				sql_ref_inc( &(fres->ref) );
				list_append(subfuncs, fres);
			}
			return fres;
		}
		n = n->next;
	}
	_DELETE(name);
	return NULL;
}

sql_subfunc *sql_bind_proc(char *sqlfname, list *ops )
{
	char *name = toLower(sqlfname);
	node *n = funcs->h;
	while (n) {
		sql_func *f = n->data;
		if (f->res)
			continue;
		if (strcmp(f->name, name) == 0 &&
		    list_cmp(f->ops, ops, (fcmp)&arg_subtype_cmp) == 0){
			sql_subfunc *fres = NEW(sql_subfunc);
			_DELETE(name);
			sql_ref_init( &(fres->ref) );
			sql_ref_inc( &(f->ref) );
			fres -> func = f;
			fres -> res . type = NULL;
			fres -> res . scale = 0;
			if (sql_debug){
				sql_ref_inc( &(fres->ref) );
				list_append(subfuncs, fres);
			}
			return fres;
		}
		n = n->next;
	}
	_DELETE(name);
	return NULL;
}

static void func_destroy(sql_func * t)
{
	int ref = 0;
	if ((ref = sql_ref_dec( &(t->ref) )) == 0){
		_DELETE(t->name);
		if (t->imp) _DELETE(t->imp);
		if (t->ops) list_destroy(t->ops);
		if (t->res) sql_subtype_destroy(t->res);
		_DELETE(t);
	} else if (sql_end == END_AGGR){
		printf("= REFCOUNT of func %s %s is wrong %d\n", t->name, t->imp, ref);
	}
}

sql_subfunc *sql_dup_func(sql_subfunc *f)
{
	sql_ref_inc( &(f->ref) );
	return f;
}

void sql_subfunc_destroy( sql_subfunc *f )
{
	int ref = 0;
	if ((ref = sql_ref_dec( &(f->ref) )) == 0){
		func_destroy(f->func);
		_DELETE(f);
	} else if (sql_end == END_SUBAGGR){
		printf("= REFCOUNT of subfunc %s %s is wrong %d\n", f->func->name, f->func->imp, ref);
	}
}


sql_type *sql_create_type(char *sqlname, unsigned int digits, unsigned int scale, unsigned int radix, char *name)
{
	sql_type *t = NEW(sql_type);

	sql_ref_init( &(t->ref) );
	t->sqlname = toLower(sqlname);
	t->digits = digits;
	t->scale = scale;
	t->radix = radix;
	t->name = _strdup(name);
	t->nr = list_length(types);
	if (t->nr){
		sql_type *pt = types->t->data;
		t->nr = pt->nr;
		if (strcmp(pt->sqlname, t->sqlname) != 0)
			t->nr ++;
	}
	t->localtype = ATOMindex(t->name);
	if (!keyword_exists(t->sqlname))
		keywords_insert(t->sqlname, TYPE);
	list_append(types, t);

	list_append(localtypes, sql_create_subtype(t, 0, 0));

	return t;
}

sql_aggr *sql_create_aggr(char *name, char *imp, sql_type *tpe, sql_type *res )
{
	sql_aggr *t = NEW(sql_aggr);

	sql_ref_init( &(t->ref) );
	t->name = toLower(name);
	t->imp = _strdup(imp);
	if (tpe) {
		t->tpe = sql_create_subtype(tpe, 0, 0);
	} else {
		t->tpe = NULL;
	}
	assert(res);
	t->res = sql_create_subtype(res, 0, 0);
	t->nr = list_length(aggrs);
	list_append(aggrs, t);
	return t;
}

sql_arg *sql_create_arg( char *name, sql_subtype *t )
{
	sql_arg *a = NEW(sql_arg);
	a->name = name;
	a->type = t;
	return a;
}

void arg_destroy( sql_arg *a )
{
	if (a->name) _DELETE(a->name);
	sql_subtype_destroy(a->type);
	_DELETE(a);
}

sql_func *sql_create_func(char *name, char *imp, sql_type *tpe1,
		      sql_type *tpe2, sql_type *res, int scale_fixing )
{
	list *l = list_create((fdestroy)&arg_destroy);
	if (tpe1) 
		list_append(l, sql_create_arg(NULL,sql_create_subtype(tpe1, 0, 0)));
	if (tpe2) 
		list_append(l, sql_create_arg(NULL,sql_create_subtype(tpe2, 0, 0)));

	return sql_create_func_(name, imp, l, 
		sql_create_subtype(res, 0, scale_fixing) );
}

sql_func *sql_create_func_(char *name, char *imp, list *ops, sql_subtype *res )
{
	sql_func *t = NEW(sql_func);

	assert(res && ops);
	sql_ref_init( &(t->ref) );
	t->name = toLower(name);
	t->imp = _strdup(imp);
	t->ops = ops;
	t->res = res;
	t->nr = list_length(funcs);
	t->sql = 0;
	list_append(funcs, t);
	return t;
}

sql_func *sql_create_sqlfunc(char *name, char *imp, list *ops, sql_subtype *res )
{
	sql_func *t = NEW(sql_func);

	assert(res && ops);
	sql_ref_init( &(t->ref) );
	t->name = toLower(name);
	t->imp = _strdup(imp);
	t->ops = ops;
	t->res = res;
	t->nr = list_length(funcs);
	t->sql = 1;
	list_append(funcs, t);
	return t;
}

void parser_init(int debug)
{
	sql_debug = debug;

	init_keywords();
	if (sql_debug){
		subtypes  = list_create((fdestroy)&sql_subtype_destroy);
		subaggrs  = list_create((fdestroy)&sql_subaggr_destroy);
		subfuncs  = list_create((fdestroy)&sql_subfunc_destroy);
	}

	types = list_create((fdestroy)&type_destroy);
	localtypes = list_create((fdestroy)&sql_subtype_destroy);
	aggrs = list_create((fdestroy)&aggr_destroy);
	funcs = list_create((fdestroy)&func_destroy);
	sqltypeinit();
}

/* SQL service initialization
This C-code version initializes the 
parser catalogs with typing information. Although, in principle,
many of the function signatures can be obtained from the underlying
database kernel, we have chosen for this explicit scheme for one
simple reason. The SQL standard dictates the types and we have to
check their availability in the kernel only. The kernel itself could
include manyfunctions for which their is no standard.
lead to unexpected 
*/


typedef struct{
		char * h,  *t;
} pair;

static char *local_result(char *s){
	int i;
	pair type_map [] = {
		{"uchr", "int"},
		{"sht", "int"},
		{"int", "lng"},
		{"lng", "lng"},
		{"flt", "dbl"},
		{"dbl", "dbl"},
		{0, 0}
	};

	for(i = 0; type_map[i].h; i++){
		if (strcmp(s, type_map[i].h) == 0){
			return type_map[i].t;
		}	
	}
	return NULL;
}

void sqltypeinit()
{	
	int i;

	sql_type *ts[100];
	sql_type **misc, **strings, **numerical, **decimals, **floats, **dates;
	sql_type **t, *INT, *OID, *BIT, *DBL;
	sql_type *SECINT, *MONINT, *DTE, *TME, *TMESTAMP;

 	t = ts;
	*t++ = sql_create_type("TABLE", 0, 0, 0, 	 	"bat");

	misc = t;
	BIT = *t++ = sql_create_type("BOOLEAN", 0, 0, 2,	"bit");
	*t++ = sql_create_type("BOOL", 0, 0, 2,	  		"bit");
	*t++ = sql_create_type("UBYTE", 2, 0, 2,		"uchr");

	strings = t;
	*t++ = sql_create_type("CHAR", 0, 0, 0,  	"str"); 
	*t++ = sql_create_type("CHARACTER", 0, 0, 0, 	"str");
	*t++ = sql_create_type("VARCHAR", 0, 0, 0, 	"str");

	*t++ = sql_create_type("TEXT", 0, 0, 0, 		"str");
	*t++ = sql_create_type("TINYTEXT", 0, 0, 0, 	"str");
	*t++ = sql_create_type("STRING", 0, 0, 0, 	"str");

	/* INT(n) n <= 2 -> TINYINT
		  n <= 4 -> SMALLINT
		  n <= 9 -> MEDIUMINT
		  n <= 19 -> BIGINT
	*/

	numerical = t;
	*t++ = sql_create_type("TINYINT", 2, 0, 2, 	"sht"); /* sht as sum(uchr) isn't implemented */
	*t++ = sql_create_type("SMALLINT", 4, 0, 2,	"sht");
	INT = *t++ = sql_create_type("MEDIUMINT", 9, 0, 2,	"int");
	OID = *t++ = sql_create_type("OID", 9, 0, 2, 	  	"oid");
	*t++ = sql_create_type("INTEGER", 9, 0, 2,	"int");
	*t++ = sql_create_type("NUMBER",  9, 0, 2,	"int");
	*t++ = sql_create_type("BIGINT", 19, 0, 2,	"lng");

	/*sql_type("INT", 2, 0, 2, 		"uchr"); */
	*t++ = sql_create_type("INT", 4, 0, 2,		"sht");
	*t++ = sql_create_type("INT", 9, 0, 2,		"int");
	*t++ = sql_create_type("INT", 19, 0, 2,		"lng");

	decimals = t;
	/* decimal(d,s) (d indicates nr digits, 
			s scale indicates nr of digits after the dot .) */
	/*#sql_type("DECIMAL", 2, 1, 10, 		"uchr"); */
	*t++ = sql_create_type("DECIMAL", 4, 1, 10,		"sht");
	*t++ = sql_create_type("DECIMAL", 9, 1, 10,		"int");
	*t++ = sql_create_type("DECIMAL", 19, 1, 10,		"lng");

	/*sql_create_type("NUMERIC", 2, 1, 		"uchr"); */
	*t++ = sql_create_type("NUMERIC", 4, 1, 10,		"sht");
	*t++ = sql_create_type("NUMERIC", 9, 1, 10,		"int");
	*t++ = sql_create_type("NUMERIC", 19, 1, 10,		"lng");

	/* float(n) (n indicates precision of atleast n digits)*/
	/* ie n <= 23 -> flt */
	/*    n <= 51 -> dbl */
	/*    n <= 62 -> long long dbl (with -ieee) (not supported) */
	/* this requires a type definition */

	floats = t;
	*t++ = sql_create_type("FLOAT", 23, 2, 2, 	"flt");
	*t++ = sql_create_type("FLOAT", 51, 2, 2, 	"dbl");

	DBL = *t++ = sql_create_type("DOUBLE", 51, 2, 2, 	"dbl");
	*t++ = sql_create_type("REAL",   51, 2, 2, 	"dbl");

	dates = t;
	MONINT = *t++ = sql_create_type("MONTH_INTERVAL", 0, 0, 10, 	"int");
	SECINT = *t++ = sql_create_type("SEC_INTERVAL", 0, 0, 10, 	"lng");
	DTE = *t++ = sql_create_type("DATE", 0, 0, 0, 		"date");
	TME = *t++ = sql_create_type("TIME", 0, 0, 0, 		"daytime");
	*t++ = sql_create_type("DATETIME", 0, 0, 0, 		"timestamp");
	TMESTAMP = *t++ = sql_create_type("TIMESTAMP", 0, 0,0, 		"timestamp");

	*t++ = sql_create_type("BLOB", 0, 0, 0, "blob");
	*t = NULL;

	for(i=0; ts[i]; i++){
		sql_create_func("hash", "hash", ts[i], INT, INT, SCALE_FIX);
		sql_create_func("=", "=", ts[i], ts[i], BIT, SCALE_FIX);
		sql_create_func("<>", "!=", ts[i], ts[i], BIT, SCALE_FIX);
		sql_create_func("isnull", "isnil", ts[i], NULL, BIT, SCALE_FIX);
	}

	for(i=0; ts[i]; i++){
		sql_create_aggr("min", "min", ts[i], ts[i]);
		sql_create_aggr("max", "max", ts[i], ts[i]);
	}

	for(t=numerical; t < decimals; t++){
		if (*t != OID){
			sql_subtype *r = NULL;
			char buf[50];
			char *lt = local_result((*t)->name);
			snprintf(buf,50,"sum_%s", lt);
			r = sql_bind_localtype(lt);
			sql_create_aggr("sum", buf, *t, r->type);
			sql_create_aggr("avg", "avg", *t, DBL);
		}
	}
	for(t=decimals; t < floats; t+=3){
		char buf[50];
		snprintf(buf,50,"sum_%s", (*(t+1))->name);
		sql_create_aggr("sum", buf, *(t), *(t+1));
		snprintf(buf,50,"sum_%s", (*(t+2))->name);
		sql_create_aggr("sum", buf, *(t+1), *(t+2));
		sql_create_aggr("sum", buf, *(t+2), *(t+2));
		sql_create_aggr("avg", "avg", *(t), DBL);
		sql_create_aggr("avg", "avg", *(t+1), DBL);
		sql_create_aggr("avg", "avg", *(t+2), DBL);
	}
	for(t=floats; t < dates; t++){
		sql_subtype *r = NULL;
		char buf[50];
		char *lt = local_result((*t)->name);
		snprintf(buf,50,"sum_%s", lt);
		r = sql_bind_localtype(lt);
		sql_create_aggr("sum", buf, *t, r->type);
		sql_create_aggr("avg", "avg", *t, DBL);
	}

	sql_create_aggr( "count_no_nil", "count_no_nil", NULL, INT ); 
	sql_create_aggr( "count", "count", NULL, INT ); 

	for(t=misc; t < strings; t++){
		sql_create_func("sql_max","max", *t, *t, *t, SCALE_FIX);
		sql_create_func("sql_min","min", *t, *t, *t, SCALE_FIX);
		sql_create_func("and","and", *t, *t, *t, SCALE_FIX);
		sql_create_func("or","or", *t, *t, *t, SCALE_FIX);
		sql_create_func("xor","xor", *t, *t, *t, SCALE_FIX);
	}

	for(t=numerical; t < dates; t++){
		sql_create_func("sql_sub","-", *t, *t, *t, SCALE_FIX);
		sql_create_func("sql_add","+", *t, *t, *t, SCALE_FIX);
		sql_create_func("sql_mul","*", *t, *t, *t, SCALE_ADD);
		sql_create_func("sql_div","/", *t, *t, *t, SCALE_SUB);
		sql_create_func("sql_max","max", *t, *t, *t, SCALE_FIX);
		sql_create_func("sql_min","min", *t, *t, *t, SCALE_FIX);
		sql_create_func("sql_mod","%", *t, *t, *t, SCALE_FIX);
		sql_create_func("and","and", *t, *t, *t, SCALE_FIX);
		sql_create_func("or","or", *t, *t, *t, SCALE_FIX);
		sql_create_func("xor","xor", *t, *t, *t, SCALE_FIX);
		sql_create_func("sql_neg","-", *t, NULL, *t, SCALE_SUB);
	}

	/* scale fixing for all numbers */
	for(t=numerical; t < dates; t++){
		sql_subtype *lt = sql_bind_localtype( (*t)->name );
	      	sql_create_func("scale_up", "*", *t, lt->type, *t, SCALE_NONE );
	      	sql_create_func("scale_down", "round", *t, lt->type, *t, SCALE_NONE );
	}

	/* convert numericals */
	for(t=numerical; t < dates; t++){
	  sql_type **u;
	  for(u=numerical; u < dates; u++){
	    if (*t != *u)
	      	sql_create_func("convert", (*u)->name, *t, NULL, *u, SCALE_FIX );
	  }
	}


	/* convert strings */
	for(t=strings; t < numerical; t++){
	  sql_type **u;
	  for(u=strings; u < numerical; u++){
	    if (*t != *u)
	      	sql_create_func("convert", (*u)->name, *t, NULL, *u, SCALE_FIX );
	  }
	}

	/* convert string to numerical */
	for(t=strings; t < numerical; t++){
	  sql_type **u;
	  for(u=numerical; u < dates; u++){
		char buf[50];

		snprintf(buf,50,"cast2%s", (*u)->name);
	      	sql_create_func("convert", buf, *t, NULL, *u, SCALE_FIX );
	  }
	}

	/* convert numerical to string */
	for(t=numerical; t < dates; t++){
	  sql_type **u;
	  for(u=strings; u < numerical; u++){
	      	sql_create_func("convert", (*u)->name, *t, NULL, *u, SCALE_FIX);
	  }
	}

	for(t=floats; t < dates; t++){
		sql_create_func( "floor", "floor", *t, NULL, *t, SCALE_FIX ); 
		sql_create_func( "ceil", "ceil", *t, NULL, *t, SCALE_FIX ); 
		sql_create_func( "sin", "sin", *t, NULL, *t, SCALE_FIX ); 
		sql_create_func( "cos", "cos", *t, NULL, *t, SCALE_FIX ); 
		sql_create_func( "tan", "tan", *t, NULL, *t, SCALE_FIX ); 
		sql_create_func( "asin", "asin", *t, NULL, *t, SCALE_FIX ); 
		sql_create_func( "acos", "acos", *t, NULL, *t, SCALE_FIX ); 
		sql_create_func( "atan", "atan", *t, NULL, *t, SCALE_FIX ); 
		sql_create_func( "sinh", "sinh", *t, NULL, *t, SCALE_FIX ); 
		sql_create_func( "cosh", "cosh", *t, NULL, *t, SCALE_FIX ); 
		sql_create_func( "tanh", "tanh", *t, NULL, *t, SCALE_FIX ); 
		sql_create_func( "sqrt", "sqrt", *t, NULL, *t, SCALE_FIX ); 
		sql_create_func( "exp", "exp", *t, NULL, *t, SCALE_FIX ); 
		sql_create_func( "log", "log", *t, NULL, *t, SCALE_FIX ); 
		sql_create_func( "log10", "log10", *t, NULL, *t, SCALE_FIX ); 
	}

	sql_create_func( "current_date", "current_date", NULL, NULL, DTE, SCALE_NONE );
	sql_create_func( "current_time", "current_time", NULL, NULL, TME, SCALE_NONE );
	sql_create_func( "current_timestamp", "current_timestamp", NULL, NULL, TMESTAMP, SCALE_NONE );

	sql_create_func( "sql_sub", "date_sub_sec_interval", DTE, SECINT, DTE, SCALE_FIX);
	sql_create_func( "sql_sub", "date_sub_month_interval", DTE, MONINT, DTE, SCALE_FIX);

	sql_create_func( "sql_add", "date_add_sec_interval", DTE, SECINT, DTE, SCALE_FIX);
	sql_create_func( "sql_add", "addmonths", DTE, MONINT, DTE, SCALE_FIX);

	sql_create_func( ">", ">", DTE, DTE, BIT, SCALE_FIX);
	sql_create_func( "<", "<", DTE, DTE, BIT, SCALE_FIX);

	sql_create_func( "year", "year", DTE, NULL, INT, SCALE_FIX);
	sql_create_func( "month", "month", DTE, NULL, INT, SCALE_FIX);

	for(t=strings; t < numerical; t++){
	  sql_create_func_( "substring", "string", 
		list_append(
	 	  list_append( 
	  	    list_append(list_create((fdestroy)&arg_destroy),
	  	    sql_create_arg(NULL, sql_create_subtype(*t, 0, 0))),
	 	  sql_create_arg(NULL, sql_create_subtype(INT, 0, 0))),
 		sql_create_arg(NULL, sql_create_subtype(INT, 0, 0))), 
	    sql_create_subtype(*t, 0, 0));

	  sql_create_func( "trunc", "trunc", *t, INT, *t, SCALE_SUB);
	  sql_create_func( "strconcat", "+", *t, *t, *t, SCALE_ADD);
	  sql_create_func( "upper", "toUpper", *t, NULL, *t, SCALE_FIX);
	  sql_create_func( "lower", "toLower", *t, NULL, *t, SCALE_FIX);
	}
}

void parser_exit()
{
	sql_end = END_SUBAGGR;

	if (sql_debug){
		list_destroy(subaggrs);
		list_destroy(subfuncs);
	}

	sql_end = END_AGGR;

	list_destroy(aggrs);
	list_destroy(funcs);

	list_destroy(localtypes);

	sql_end = END_SUBTYPE;
	if (sql_debug)
		list_destroy(subtypes);

	sql_end = END_TYPE;
	list_destroy(types);

	exit_keywords();
}
