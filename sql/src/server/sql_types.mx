@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2004 CWI.
@' All Rights Reserved.

@f sql_types
@a N.J. Nes
@*
The typing scheme of SQL is quite elaborate. The standard introduces
several basic types with a plethora of functions.
As long as we haven;t implemented a scheme to accept the
function type signature and relate it to a C-function linked
with the system, we have to patch the code below.

Given the large number of examples, it should be relatively
easy to find something akin you intend to enter.
@h
#ifndef SQL_TYPES_H
#define SQL_TYPES_H

#include <sql_mem.h>
#include <sql_list.h>
#include <stream.h>

sql_export list *types;

#define SCALE_NONE	0
#define SCALE_FIX	1
#define SCALE_NOFIX	2
#define SCALE_ADD	3
#define SCALE_SUB	4
#define DIGITS_ADD	5
#define INOUT		6 	/* output type equals input type */

#define sql_max(i1,i2) ((i1)<(i2))?(i2):(i1)

typedef int sqlid;

typedef struct sql_base {
	int wtime;
	int rtime;
	int flag;
	sqlid id;
	char *name;
} sql_base;

sql_export void base_init( sql_base *b, sqlid id, int flag, char *name );
sql_export void base_set_name( sql_base *b, char *name );
sql_export void base_destroy( sql_base *b );

typedef struct sql_type {
	sql_base base;

	char *sqlname;
	unsigned int digits;
	unsigned int scale; /* indicates how scale is used in functions */
	int localtype; 	/* localtype, need for coersions */
	unsigned char radix;
	unsigned char fixed;
} sql_type;

typedef struct sql_alias {
	char *name;
	char *alias;
} sql_alias;

typedef struct sql_subtype {
	sql_ref ref;

	sql_type *type;
	unsigned int digits;
	unsigned int scale;
	unsigned char fixed;
} sql_subtype;

typedef struct sql_aggr {
	sql_ref ref;

	char *name;
	char *imp;
	sql_subtype *tpe;
	sql_subtype *res;
	int nr;
} sql_aggr;

typedef struct sql_subaggr {
	sql_ref ref;

	sql_aggr *aggr;
	sql_subtype *res;
} sql_subaggr;

/* sql_func need type transform rules
 * types are equal if underlying types are equal +
	scale is equal
 * if types do not mach we try type conversions
 * 	which means for simple 1 arg functions
 *
 *
 */

typedef struct sql_arg {
	char *name;
	sql_subtype *type;
} sql_arg;

typedef struct sql_func {
	sql_ref ref;

	char *name;
	char *imp;
	list *ops; /* param list */
	sql_subtype *res;
		   /* res->scale
		      SCALE_NOFIX/SCALE_NONE => nothing
		      SCALE_FIX => input scale fixing,
		      SCALE_ADD => leave inputs as is and do add scales
					example numerical multiplication
		      SCALE_SUB => first input scale, fix with second scale
				   result scale is equal to first input
					example numerical division
		      DIGITS_ADD => result digits, sum of args
					example string concat
		    */
	int nr;
	int sql; /* simple sql or native implementation */
} sql_func;

typedef struct sql_subfunc {
	sql_ref ref;

	sql_func *func;
	sql_subtype *res;
} sql_subfunc;

sql_export char *sql_bind_alias( char *alias );
sql_export sql_subtype *sql_bind_subtype( char *name, unsigned int digits, unsigned int scale );
sql_export sql_subtype *sql_bind_localtype( char *name );
sql_export sql_subtype *sql_create_subtype( sql_type *t, unsigned int s, unsigned int d );
sql_export sql_subtype *sql_dup_subtype( sql_subtype *t );
sql_export void sql_subtype_destroy( sql_subtype *t );

sql_export int type_cmp( sql_type *t1, sql_type *t2);
sql_export int subtype_cmp( sql_subtype *t1, sql_subtype *t2);

sql_export sql_type *sql_create_type(char *sqlname, unsigned int digits, unsigned int scale, unsigned char radix, unsigned char fixed, char *name );

sql_export sql_arg *sql_create_arg( char *name, sql_subtype *t );
sql_export void arg_destroy( sql_arg *a );

sql_export sql_subaggr *sql_bind_aggr( char *name, sql_subtype *type);
sql_export sql_aggr *sql_create_aggr( char *name, char *imp, sql_type *tpe, sql_type *res);
sql_export sql_subaggr *sql_dup_aggr( sql_subaggr *a);
sql_export void sql_subaggr_destroy( sql_subaggr *f);

sql_export sql_subfunc *sql_find_func( char *name, int nrargs);
sql_export sql_subfunc *sql_bind_member( char *name, sql_subtype *tp, int nrargs);
sql_export sql_subfunc *sql_bind_func( char *name, sql_subtype *tp1, sql_subtype *tp2);
sql_export sql_subfunc *sql_bind_func_result( char *name, sql_subtype *tp1, sql_subtype *tp2, sql_subtype *res);

sql_export sql_subfunc *sql_bind_func_( char *name, list *ops);
sql_export sql_subfunc *sql_bind_func_result_( char *name, list *ops, sql_subtype *res);
sql_export sql_subfunc *sql_dup_func( sql_subfunc *f);
sql_export void sql_subfunc_destroy( sql_subfunc *f);
sql_export sql_subfunc *sql_bind_proc( char *name, list *ops );

sql_export sql_func *sql_create_func(char *name, char *imp, sql_type *tpe1, sql_type *tpe2, sql_type *res, int scale_fixing);
sql_export sql_func *sql_create_func3(char *name, char *imp, sql_type *tpe1, sql_type *tpe2, sql_type *tpe3, sql_type *res, int scale_fixing);
sql_export sql_func *sql_create_func4(char *name, char *imp, sql_type *tpe1, sql_type *tpe2, sql_type *tpe3, sql_type *tpe4, sql_type *res, int scale_fixing);

sql_export sql_func *sql_create_func_(char *name, char *imp, list *ops, sql_subtype *res);

sql_export sql_func *sql_create_sqlfunc(char *name, char *imp, list *ops, sql_subtype *res );

sql_export void parser_init(int debug);
sql_export void parser_exit();

#endif /* SQL_TYPES_H */
@c
#include "sql_types.h"
#include "sql_symbol.h"
#include "sql_parser.tab.h"
#include "sql_statement.h"
#include "sql_scan.h"	/* for keyword_exists(), keywords_insert(), init_keywords(), exit_keywords() */
#include <string.h>

#define END_SUBAGGR	1
#define END_AGGR	2
#define END_SUBTYPE	3
#define END_TYPE	4

static int sql_debug = 0;

list *aliases = NULL;
list *types = NULL;
static list *aggrs = NULL;
static list *funcs = NULL;

static list *localtypes = NULL;
static list *subtypes = NULL;
static list *subaggrs = NULL;
static list *subfuncs = NULL;

static void sqltypeinit();

void
base_init( sql_base *b, sqlid id, int flag, char *name )
{
	b->id = id;
	b->wtime = 0;
	b->rtime = 0;
	b->flag = flag;
	b->name = NULL;
	if (name) b->name = _strdup(name);
}

void
base_set_name( sql_base *b, char *name )
{
	assert(name);
	if (b->name) _DELETE(b->name);
	b->name = _strdup(name);
}

void
base_destroy( sql_base *b )
{
	if (b->name) _DELETE(b->name);
}

sql_subtype *sql_create_subtype( sql_type *t, unsigned int digits, unsigned int scale )
{
	sql_subtype *res = NEW(sql_subtype);

	sql_ref_init( &(res->ref) );
	res->type = t;
	res->digits = digits?digits:t->digits;
	res->scale = scale;
	res->fixed = t->fixed;
	if (sql_debug) {
		sql_ref_inc( &(res->ref) );
		list_append( subtypes,  res);
	}
	return res;
}

sql_subtype *sql_dup_subtype( sql_subtype *res )
{
	sql_ref_inc( &(res->ref) );
	return res;
}

sql_subtype *sql_bind_subtype( char *name, unsigned int digits, unsigned int scale )
	/* todo add approximate info
	 * if digits/scale == 0 and no approximate with digits/scale == 0
	 * exists we could return the type with largest digits
	 *
	 * returning the largest when no exact match is found is now the
	 * (wrong?) default
	 */
{
	/* assumes the types are ordered on name,digits,scale where is always
	 * 0 > n
	 */
	node *m, *n;
	for ( n = types->h; n; n = n->next ) {
		sql_type *t = n->data;
		if (strcasecmp(t->sqlname, name) == 0){
			if ((digits && t->digits >= digits) ||
					(digits == t->digits)){
				return sql_create_subtype(t, digits, scale);
			}
			for (m = n->next; m; m = m->next ) {
				t = m->data;
				if (strcasecmp(t->sqlname, name) != 0){
					break;
				}
				n = m;
				if ((digits && t->digits >= digits) ||
					(digits == t->digits)){
					return sql_create_subtype(t, digits, scale);
				}
			}
			t = n->data;
			return sql_create_subtype(t, digits, scale);
		}
	}
	return NULL;
}

#ifndef NDEBUG
static int sql_end = 0;
#endif

static void type_destroy(sql_type * t)
{
	base_destroy( &t->base );
	_DELETE(t->sqlname);
	_DELETE(t);
}

void sql_subtype_destroy(sql_subtype * t)
{
	int ref = 0;

	if ((ref = sql_ref_dec( &(t->ref)) ) == 0){
		_DELETE(t);
#ifndef NDEBUG
	} else if (sql_end == END_SUBTYPE){
		printf("= REFCOUNT of subtype %s %s is wrong %d\n",
			t->type->base.name, t->type->sqlname, ref);
#else
	(void)ref; /* pacify picky compilers... */
#endif
	}
}

sql_subtype *sql_bind_localtype( char *name )
{
	node *n = localtypes->h;
	while (n) {
		sql_subtype *t = n->data;
		if (strcmp(t->type->base.name, name) == 0){
			return t;
		}
		n = n->next;
	}
	assert(0);
	return NULL;
}

sql_type *sql_bind_type( char *name )
{
	node *n = types->h;
	while (n) {
		sql_type *t = n->data;
		if (strcmp(t->base.name, name) == 0){
			return t;
		}
		n = n->next;
	}
	assert(0);
	return NULL;
}

int type_cmp( sql_type *t1, sql_type *t2)
{
	int res = 0;
	if (!t1 || !t2)
		return -1;
	/* types are only equal
		iff they map onto the same systemtype */
	res = (t1->localtype-t2->localtype);
	if (res) return res;
	/* and
		iff they have the same sqlname */
	return (strcmp(t1->sqlname, t2->sqlname));
}

int subtype_cmp( sql_subtype *t1, sql_subtype *t2 )
{
	if (!t1 || !t2)
		return -1;
	/* subtypes are only equal iff
			they map onto the same systemtype */
	return (type_cmp( t1->type, t2->type));
}


sql_subaggr *sql_bind_aggr(char *sqlaname, sql_subtype *type)
{
	char *name = toLower(sqlaname);
	node *n = aggrs->h;
	while (n) {
		sql_aggr *a = n->data;
		if (strcmp(a->name, name) == 0 &&
		    (!a->tpe
		     || (type && subtype_cmp(a->tpe, type) == 0))){
			int scale = 0;
			sql_subaggr *ares = NEW(sql_subaggr);
			_DELETE(name);
			sql_ref_init( &(ares->ref) );
			sql_ref_inc( &(a->ref) );
			ares -> aggr = a;
			scale = a->res->scale;
			/* same scale as the input */
			if (type)
				scale = type->scale;
			ares -> res = sql_create_subtype(a->res->type,
				a->res->digits, scale);
			if (sql_debug){
				sql_ref_inc( &(ares->ref) );
				list_append(subaggrs, ares);
			}
			return ares;
		}
		n = n->next;
	}
	_DELETE(name);
	return NULL;
}

static void aggr_destroy(sql_aggr * t)
{
	int ref = 0;
	if ((ref = sql_ref_dec( &(t->ref) )) == 0){
		_DELETE(t->name);
		_DELETE(t->imp);
		if (t->tpe) sql_subtype_destroy(t->tpe);
		sql_subtype_destroy(t->res);
		_DELETE(t);
#ifndef NDEBUG
	} else if (sql_end == END_AGGR){
		printf("= REFCOUNT of aggr %s %s is wrong %d\n", t->name, t->imp, ref);
#else
	(void)ref; /* pacify picky compilers... */
#endif
	}
}

sql_subaggr *sql_dup_aggr(sql_subaggr *a)
{
	sql_ref_inc( &(a->ref) );
	return a;
}

void sql_subaggr_destroy( sql_subaggr *a )
{
	int ref = 0;
	if ((ref = sql_ref_dec( &(a->ref) )) == 0){
		aggr_destroy(a->aggr);
		if (a->res) sql_subtype_destroy(a->res);
		_DELETE(a);
#ifndef NDEBUG
	} else if (sql_end == END_SUBAGGR){
		printf("= REFCOUNT of subaggr %s %s is wrong %d\n", a->aggr->name, a->aggr->imp, ref);
#else
	(void)ref; /* pacify picky compilers... */
#endif
	}
}

sql_subfunc *sql_find_func(char *sqlfname, int nrargs )
{
	char *name = toLower(sqlfname);
	node *n = funcs->h;
	assert(nrargs);
	while (n) {
		sql_func *f = n->data;
		if (!f->res)
			continue;
		if (strcmp(f->name, name) == 0){ 
		   if (list_length(f->ops) == nrargs) {
			int scale = 0;
			sql_subfunc *fres = NEW(sql_subfunc);
			_DELETE(name);
			sql_ref_init( &(fres->ref) );
			sql_ref_inc( &(f->ref) );
			fres -> func = f;
			fres -> res = sql_create_subtype(f->res->type, 
					f->res->digits, scale );
			if (sql_debug){
				sql_ref_inc( &(fres->ref) );
				list_append(subfuncs, fres);
			}
			return fres;
                   }
		}
		n = n->next;
	}
	_DELETE(name);
	return NULL;
}
		

/* find function based on first argument */
sql_subfunc *sql_bind_member(char *sqlfname, sql_subtype *tp, int nrargs )
{
	char *name = toLower(sqlfname);
	node *n; 

	assert(nrargs);
	for ( n = funcs->h; n; n = n->next) {
		sql_func *f = n->data;
		if (!f->res)
			continue;
		if (strcmp(f->name, name) == 0){
		   if (list_length(f->ops) == nrargs &&
		       subtype_cmp(tp, ((sql_arg*)f->ops->h->data)->type) == 0){

			int scale = 0;
			sql_subfunc *fres;

			/* member functions should not match binary operators */
			if (nrargs == 2 && subtype_cmp( 
				((sql_arg*)f->ops->h->data)->type,
				((sql_arg*)f->ops->h->next->data)->type) == 0)
				continue;
			fres = NEW(sql_subfunc);
			_DELETE(name);
			sql_ref_init( &(fres->ref) );
			sql_ref_inc( &(f->ref) );
			fres -> func = f;
			/* same scale as the input */
			if (tp && tp->scale > scale)
				scale = tp->scale;
			fres -> res = sql_create_subtype(f->res->type,
					f->res->digits, scale );
			if (sql_debug){
				sql_ref_inc( &(fres->ref) );
				list_append(subfuncs, fres);
			}
			return fres;
                   }
		}
	}
	_DELETE(name);
	return NULL;
}
sql_subfunc *sql_bind_func(char *sqlfname, sql_subtype *tp1, sql_subtype *tp2)
{
	list *l = list_create((fdestroy)&sql_subtype_destroy);
	sql_subfunc *fres;

	if (tp1)
		list_append(l, sql_dup_subtype(tp1));
	if (tp2)
		list_append(l, sql_dup_subtype(tp2));

	fres = sql_bind_func_(sqlfname, l);
	list_destroy(l);
	return fres;
}

int arg_subtype_cmp( sql_arg *a, sql_subtype *t )
{
	return subtype_cmp(a->type, t);
}

sql_subfunc *sql_bind_func_(char *sqlfname, list *ops )
{
	char *name = toLower(sqlfname);
	node *n = funcs->h;
	while (n) {
		sql_func *f = n->data;
		if (!f->res)
			continue;
		if (strcmp(f->name, name) == 0){
		   if (list_cmp(f->ops, ops, (fcmp)&arg_subtype_cmp) == 0){
			unsigned int scale = 0;
			sql_subfunc *fres = NEW(sql_subfunc);
			_DELETE(name);
			sql_ref_init( &(fres->ref) );
			sql_ref_inc( &(f->ref) );
			fres -> func = f;
			for (n=ops->h; n; n=n->next){
				sql_subtype *a = n->data;
				/* same scale as the input */
				if (a && a->scale > scale)
					scale = a->scale;
			}
			fres -> res = sql_create_subtype(f->res->type,
					f->res->digits, scale );
			if (sql_debug){
				sql_ref_inc( &(fres->ref) );
				list_append(subfuncs, fres);
			}
			return fres;
                   }
		}
		n = n->next;
	}
	_DELETE(name);
	return NULL;
}

sql_subfunc *sql_bind_func_result(char *sqlfname, sql_subtype *tp1, sql_subtype *tp2, sql_subtype *res)
{
	list *l = list_create((fdestroy)&sql_subtype_destroy);
	sql_subfunc *fres;

	if (tp1)
		list_append(l, sql_dup_subtype(tp1));
	if (tp2)
		list_append(l, sql_dup_subtype(tp2));

	fres = sql_bind_func_result_(sqlfname, l, res);
	list_destroy(l);
	return fres;
}

sql_subfunc *sql_bind_func_result_(char *sqlfname, list *ops, sql_subtype *res )
{
	char *name = toLower(sqlfname);
	node *n = funcs->h;
	while (n) {
		sql_func *f = n->data;
		if (!f->res)
			continue;
		if (strcmp(f->name, name) == 0 &&
		    subtype_cmp(f->res, res) == 0 &&
		    list_cmp(f->ops, ops, (fcmp)&arg_subtype_cmp) == 0){
			unsigned int scale = 0;
			sql_subfunc *fres = NEW(sql_subfunc);
			_DELETE(name);
			sql_ref_init( &(fres->ref) );
			sql_ref_inc( &(f->ref) );
			fres -> func = f;
			for (n=ops->h; n; n=n->next){
				sql_subtype *a = n->data;
				/* same scale as the input */
				if (a && a->scale > scale)
					scale = a->scale;
			}
			fres -> res = sql_create_subtype(f->res->type,
					f->res->digits, scale );
			if (sql_debug){
				sql_ref_inc( &(fres->ref) );
				list_append(subfuncs, fres);
			}
			return fres;
		}
		n = n->next;
	}
	_DELETE(name);
	return NULL;
}

sql_subfunc *sql_bind_proc(char *sqlfname, list *ops )
{
	char *name = toLower(sqlfname);
	node *n = funcs->h;
	while (n) {
		sql_func *f = n->data;
		if (f->res)
			continue;
		if (strcmp(f->name, name) == 0 &&
		    list_cmp(f->ops, ops, (fcmp)&arg_subtype_cmp) == 0){
			sql_subfunc *fres = NEW(sql_subfunc);
			_DELETE(name);
			sql_ref_init( &(fres->ref) );
			sql_ref_inc( &(f->ref) );
			fres -> func = f;
			fres -> res = NULL;
			if (sql_debug){
				sql_ref_inc( &(fres->ref) );
				list_append(subfuncs, fres);
			}
			return fres;
		}
		n = n->next;
	}
	_DELETE(name);
	return NULL;
}

static void func_destroy(sql_func * t)
{
	int ref = 0;
	if ((ref = sql_ref_dec( &(t->ref) )) == 0){
		_DELETE(t->name);
		if (t->imp) _DELETE(t->imp);
		if (t->ops) list_destroy(t->ops);
		if (t->res) sql_subtype_destroy(t->res);
		_DELETE(t);
#ifndef NDEBUG
	} else if (sql_end == END_AGGR){
		printf("= REFCOUNT of func %s %s is wrong %d\n", t->name, t->imp, ref);
#else
	(void)ref; /* pacify picky compilers... */
#endif
	}
}

sql_subfunc *sql_dup_func(sql_subfunc *f)
{
	sql_ref_inc( &(f->ref) );
	return f;
}

void sql_subfunc_destroy( sql_subfunc *f )
{
	int ref = 0;
	if ((ref = sql_ref_dec( &(f->ref) )) == 0){
		func_destroy(f->func);
		if (f->res) sql_subtype_destroy(f->res);
		_DELETE(f);
#ifndef NDEBUG
	} else if (sql_end == END_SUBAGGR){
		printf("= REFCOUNT of subfunc %s %s is wrong %d\n", f->func->name, f->func->imp, ref);
#else
	(void)ref; /* pacify picky compilers... */
#endif
	}
}


void sql_create_alias( char *name, char *alias )
{
	sql_alias *a = NEW(sql_alias);

	a -> name = _strdup(name);
	a -> alias = _strdup(alias);
	list_append(aliases,a);
	if (!keyword_exists(a->alias))
		keywords_insert(a->alias, ALIAS);
}

void alias_destroy( sql_alias *a )
{
	_DELETE(a->name);
	_DELETE(a->alias);
	_DELETE(a);
}

char *sql_bind_alias( char *alias )
{
	node *n;
	for( n = aliases->h; n; n = n->next) {
		sql_alias *a = n->data;
		if (strcmp(a->alias, alias) == 0) {
			return a->name;
		}
	}
	return NULL;
}


sql_type *sql_create_type(char *sqlname, unsigned int digits, unsigned int scale, unsigned char radix, unsigned char fixed, char *name)
{
	sql_type *t = NEW(sql_type);

	base_init( &t->base, OIDnew(1), TR_OLD, name);
	t->sqlname = toLower(sqlname);
	t->digits = digits;
	t->scale = scale;
	t->localtype = ATOMindex(t->base.name);
	t->radix = radix;
	t->fixed = fixed;
	if (!keyword_exists(t->sqlname))
		keywords_insert(t->sqlname, aTYPE);
	list_append(types, t);

	list_append(localtypes, sql_create_subtype(t, 0, 0));

	return t;
}

sql_aggr *sql_create_aggr(char *name, char *imp, sql_type *tpe, sql_type *res )
{
	sql_aggr *t = NEW(sql_aggr);

	sql_ref_init( &(t->ref) );
	t->name = toLower(name);
	t->imp = _strdup(imp);
	if (tpe) {
		t->tpe = sql_create_subtype(tpe, 0, 0);
	} else {
		t->tpe = NULL;
	}
	assert(res);
	t->res = sql_create_subtype(res, 0, 0);
	t->nr = list_length(aggrs);
	list_append(aggrs, t);
	return t;
}

sql_arg *sql_create_arg( char *name, sql_subtype *t )
{
	sql_arg *a = NEW(sql_arg);
	a->name = name;
	a->type = t;
	return a;
}

void arg_destroy( sql_arg *a )
{
	if (a->name) _DELETE(a->name);
	sql_subtype_destroy(a->type);
	_DELETE(a);
}

sql_func *sql_create_func(char *name, char *imp, sql_type *tpe1,
		      sql_type *tpe2, sql_type *res, int scale_fixing )
{
	list *l = list_create((fdestroy)&arg_destroy);
	if (tpe1)
		list_append(l, sql_create_arg(NULL,sql_create_subtype(tpe1, 0, 0)));
	if (tpe2)
		list_append(l, sql_create_arg(NULL,sql_create_subtype(tpe2, 0, 0)));

	return sql_create_func_(name, imp, l,
		sql_create_subtype(res, 0, scale_fixing) );
}

sql_func *sql_create_func3(char *name, char *imp, sql_type *tpe1,
		      sql_type *tpe2, sql_type *tpe3, sql_type *res, int scale_fixing )
{
	list *l = list_create((fdestroy)&arg_destroy);

	list_append(l, sql_create_arg(NULL,sql_create_subtype(tpe1, 0, 0)));
	list_append(l, sql_create_arg(NULL,sql_create_subtype(tpe2, 0, 0)));
	list_append(l, sql_create_arg(NULL,sql_create_subtype(tpe3, 0, 0)));

	return sql_create_func_(name, imp, l,
		sql_create_subtype(res, 0, scale_fixing) );
}

sql_func *sql_create_func4(char *name, char *imp, sql_type *tpe1,
		      sql_type *tpe2, sql_type *tpe3, sql_type *tpe4, sql_type *res, int scale_fixing )
{
	list *l = list_create((fdestroy)&arg_destroy);

	list_append(l, sql_create_arg(NULL,sql_create_subtype(tpe1, 0, 0)));
	list_append(l, sql_create_arg(NULL,sql_create_subtype(tpe2, 0, 0)));
	list_append(l, sql_create_arg(NULL,sql_create_subtype(tpe3, 0, 0)));
	list_append(l, sql_create_arg(NULL,sql_create_subtype(tpe4, 0, 0)));

	return sql_create_func_(name, imp, l,
		sql_create_subtype(res, 0, scale_fixing) );
}


sql_func *sql_create_func_(char *name, char *imp, list *ops, sql_subtype *res )
{
	sql_func *t = NEW(sql_func);

	assert(res && ops);
	sql_ref_init( &(t->ref) );
	t->name = toLower(name);
	t->imp = _strdup(imp);
	t->ops = ops;
	t->res = res;
	t->nr = list_length(funcs);
	t->sql = 0;
	list_append(funcs, t);
	return t;
}

sql_func *sql_create_sqlfunc(char *name, char *imp, list *ops, sql_subtype *res )
{
	sql_func *t = NEW(sql_func);

	assert(res && ops);
	sql_ref_init( &(t->ref) );
	t->name = toLower(name);
	t->imp = _strdup(imp);
	t->ops = ops;
	t->res = res;
	t->nr = list_length(funcs);
	t->sql = 1;
	list_append(funcs, t);
	return t;
}

void parser_init(int debug)
{
	sql_debug = debug;

	init_keywords();
	if (sql_debug){
		subtypes  = list_create((fdestroy)&sql_subtype_destroy);
		subaggrs  = list_create((fdestroy)&sql_subaggr_destroy);
		subfuncs  = list_create((fdestroy)&sql_subfunc_destroy);
	}

	aliases = list_create((fdestroy)&alias_destroy);
	types = list_create((fdestroy)&type_destroy);
	localtypes = list_create((fdestroy)&sql_subtype_destroy);
	aggrs = list_create((fdestroy)&aggr_destroy);
	funcs = list_create((fdestroy)&func_destroy);
	sqltypeinit();
}

/* SQL service initialization
This C-code version initializes the
parser catalogs with typing information. Although, in principle,
many of the function signatures can be obtained from the underlying
database kernel, we have chosen for this explicit scheme for one
simple reason. The SQL standard dictates the types and we have to
check their availability in the kernel only. The kernel itself could
include manyfunctions for which their is no standard.
lead to unexpected
*/


typedef struct{
		char * h,  *t;
} pair;

static char *local_result(char *s){
	int i;
	pair type_map [] = {
		{"uchr", "int"},
		{"sht", "int"},
		{"int", "lng"},
		{"lng", "lng"},
		{"flt", "dbl"},
		{"dbl", "dbl"},
		{0, 0}
	};

	for(i = 0; type_map[i].h; i++){
		if (strcmp(s, type_map[i].h) == 0){
			return type_map[i].t;
		}
	}
	return NULL;
}
@-
The current implementation uses a hardwired type and function table.
This routine is called once upon restart of the system.
@c
void sqltypeinit()
{
	int i;

	sql_type *ts[100];
	sql_type **misc, **strings, **numerical;
	sql_type **decimals, **floats, **dates, **end, **t;
	sql_type *INT, *LNG, *OID, *BIT, *DBL, *T;
	sql_type *SECINT, *MONINT, *DTE, *TME, *TMESTAMP; 

 	t = ts;
	*t++ = sql_create_type("TABLE", 0, 0, 0, 1, 	 	"bat");

	misc = t;
	BIT = *t++ = sql_create_type("BOOLEAN", 0, 0, 2, 1,	"bit");
	sql_create_alias(BIT->sqlname, "BOOL");
	/**t++ = sql_create_type("UBYTE", 2, 0, 2, 1,		"uchr");*/

	strings = t;
	T = *t++ = sql_create_type("CHAR", 	0, 0, 0, 1, 	"str");
	sql_create_alias(T->sqlname, "CHARACTER");
	T = *t++ = sql_create_type("VARCHAR", 	0, 0, 0, 0, 	"str");
	sql_create_alias(T->sqlname, "TEXT");
	sql_create_alias(T->sqlname, "TINYTEXT");
	sql_create_alias(T->sqlname, "STRING");
	sql_create_alias(T->sqlname, "CLOB");

	/* Following types are translated by the parser
	   INT(n) n <= 2 <- TINYINT
		  n <= 4 <- SMALLINT
		  n <= 9 <- MEDIUMINT
		  n <= 19 <- BIGINT
	*/

	numerical = t;

	OID = *t++ = sql_create_type("OID", 9, 0, 10, 0, 	"oid");
	/*sql_type("INT", 2, SCALE_FIX, 10, 0, 		"uchr"); */
	*t++ = sql_create_type("INT", 4, SCALE_FIX, 10, 0,		"sht");
	INT = *t++ = sql_create_type("INT", 9, SCALE_FIX, 10, 0,	"int");
	LNG = *t++ = sql_create_type("INT", 19, SCALE_FIX, 10, 0,	"lng");
	sql_create_alias(INT->sqlname, "INTEGER");

	decimals = t;
	/* decimal(d,s) (d indicates nr digits,
			s scale indicates nr of digits after the dot .) */
	/*#sql_type("DECIMAL", 2, SCALE_FIX, 10, 		"uchr"); */
	T = *t++ = sql_create_type("DECIMAL", 4, SCALE_FIX, 10, 0,	"sht");
	*t++ = sql_create_type("DECIMAL", 9, SCALE_FIX, 10, 0,		"int");
	*t++ = sql_create_type("DECIMAL", 19, SCALE_FIX, 10, 0,		"lng");

	sql_create_alias(T->sqlname, "NUMERIC");

	/* float(n) (n indicates precision of atleast n digits)*/
	/* ie n <= 23 -> flt */
	/*    n <= 51 -> dbl */
	/*    n <= 62 -> long long dbl (with -ieee) (not supported) */
	/* this requires a type definition */

	floats = t;
	T = *t++ = sql_create_type("FLOAT", 23, SCALE_NOFIX, 2, 1, 	"flt");
	sql_create_alias(T->sqlname, "REAL");
	*t++ = sql_create_type("FLOAT", 51, SCALE_NOFIX, 2, 1, 	"dbl");
	DBL = *t++ = sql_create_type("DOUBLE", 51, SCALE_NOFIX, 2, 1, 	"dbl");

	dates = t;
	MONINT = *t++ = sql_create_type("MONTH_INTERVAL", 0, 0, 10, 1, 	"int");
	SECINT = *t++ = sql_create_type("SEC_INTERVAL", 0, 0, 10, 1, 	"lng");
	DTE = *t++ = sql_create_type("DATE", 0, 0, 0, 1, 	"date");
	TME = *t++ = sql_create_type("TIME", 0, 0, 0, 1, 	"daytime");
	*t++ = sql_create_type("DATETIME", 0, 0, 0, 1, 		"timestamp");
	TMESTAMP = *t++ = sql_create_type("TIMESTAMP", 0, 0, 0, 1,"timestamp");

	*t++ = sql_create_type("BLOB", 0, 0, 0, 0, "blob");
	end = t;
	*t = NULL;

	for(i=0; ts[i]; i++){
		sql_create_func("hash", "hash", ts[i], INT, INT, SCALE_FIX);
		sql_create_func("=", "=", ts[i], ts[i], BIT, SCALE_FIX);
		sql_create_func("<>", "!=", ts[i], ts[i], BIT, SCALE_FIX);
		sql_create_func("isnull", "isnil", ts[i], NULL, BIT, SCALE_FIX);
		sql_create_func( ">", ">", ts[i], ts[i], BIT, SCALE_FIX);
		sql_create_func( ">=", ">=", ts[i], ts[i], BIT, SCALE_FIX);
		sql_create_func( "<", "<", ts[i], ts[i], BIT, SCALE_FIX);
		sql_create_func( "<=", "<=", ts[i], ts[i], BIT, SCALE_FIX);
		sql_create_func( "exist", "exist", ts[i], ts[i], BIT, SCALE_FIX);
		sql_create_func( "not_exist", "not_exist", ts[i], ts[i], BIT, SCALE_FIX);
	}

	for(i=0; ts[i]; i++){
		sql_create_aggr("min", "min", ts[i], ts[i]);
		sql_create_aggr("max", "max", ts[i], ts[i]);
		sql_create_func("sql_min","min", ts[i], ts[i], ts[i],SCALE_FIX);
		sql_create_func("sql_max","max", ts[i], ts[i], ts[i],SCALE_FIX);
	}

	for(t=numerical; t < decimals; t++){
		if (*t != OID){
			sql_subtype *r = NULL;
			char buf[50];
			char *lt = local_result((*t)->base.name);
			snprintf(buf,50,"sum_%s", lt);
			r = sql_bind_localtype(lt);
			sql_create_aggr("sum", buf, *t, r->type);
			sql_create_aggr("avg", "avg", *t, DBL);
		}
	}
	for(t=decimals; t < floats; t+=3){
		char buf[50];
		snprintf(buf,50,"sum_%s", (*(t+1))->base.name);
		sql_create_aggr("sum", buf, *(t), *(t+1));
		snprintf(buf,50,"sum_%s", (*(t+2))->base.name);
		sql_create_aggr("sum", buf, *(t+1), *(t+2));
		sql_create_aggr("sum", buf, *(t+2), *(t+2));
		sql_create_aggr("avg", "avg", *(t), DBL);
		sql_create_aggr("avg", "avg", *(t+1), DBL);
		sql_create_aggr("avg", "avg", *(t+2), DBL);
	}
	for(t=floats; t < dates; t++){
		sql_subtype *r = NULL;
		char buf[50];
		char *lt = local_result((*t)->base.name);
		snprintf(buf,50,"sum_%s", lt);
		r = sql_bind_localtype(lt);
		sql_create_aggr("sum", buf, *t, r->type);
		sql_create_aggr("avg", "avg", *t, DBL);
	}

	sql_create_aggr( "count_no_nil", "count_no_nil", NULL, INT );
	sql_create_aggr( "count", "count", NULL, INT );

	for(t=misc; t < strings; t++){
	  	sql_type **u;

		sql_create_func("and","and", *t, *t, *t, SCALE_FIX);
		sql_create_func("or","or", *t, *t, *t, SCALE_FIX);
		sql_create_func("xor","xor", *t, *t, *t, SCALE_FIX);
		sql_create_func("not","not", *t, NULL, *t, SCALE_FIX);
		/* convert from misc types to strings and numericals and vs */
	  	for(u=strings; u < dates; u++) {
	      		sql_create_func("convert", (*u)->base.name, *t, NULL, *u, SCALE_FIX );
	      		sql_create_func("convert", (*u)->base.name, *t, INT, *u, SCALE_FIX );
	      		sql_create_func("convert", (*t)->base.name, *u, NULL, *t, SCALE_FIX );
	      		sql_create_func("convert", (*t)->base.name, *u, INT, *t, SCALE_FIX );
		}
	}

	for(t=numerical; t < dates; t++){
		sql_subtype *lt = sql_bind_localtype( (*t)->base.name );

		sql_create_func("sql_sub","-", *t, *t, *t, SCALE_FIX);
		sql_create_func("sql_add","+", *t, *t, *t, SCALE_FIX);
		sql_create_func("sql_mul","*", *t, *t, *t, SCALE_ADD);
		sql_create_func("sql_div","/", *t, *t, *t, SCALE_SUB);
		sql_create_func("mod","%", *t, *t, *t, SCALE_FIX);
		sql_create_func("and","and", *t, *t, *t, SCALE_FIX);
		sql_create_func("or","or", *t, *t, *t, SCALE_FIX);
		sql_create_func("xor","xor", *t, *t, *t, SCALE_FIX);
		sql_create_func("sql_neg","-", *t, NULL, *t, INOUT);
		sql_create_func("sql_pos","+", *t, NULL, *t, INOUT);
		sql_create_func("abs", "abs", *t, NULL, *t, SCALE_FIX );
		sql_create_func("sign", "sign", *t, NULL, *t, SCALE_FIX );
		sql_create_func("power", "pow", *t, INT, *t, SCALE_FIX );
	  	sql_create_func("degrees", "deg", *t, NULL, *t, SCALE_NONE);
	  	sql_create_func("radians", "rad", *t, NULL, *t, SCALE_NONE);
		/* scale fixing for all numbers */
	      	sql_create_func("scale_up", "*", *t, lt->type, *t, SCALE_NONE );
	      	sql_create_func("scale_down", "round", *t, lt->type, *t, SCALE_NONE );
	}
	for(t=decimals; t < dates; t++){
	  	sql_create_func("truncate", "trunc", *t, INT, *t, SCALE_NONE);
	  	sql_create_func("round", "round", *t, INT, *t, SCALE_NONE);
	}
	sql_create_func("pi", "pi", NULL, NULL, *t, SCALE_NONE);

	/* convert numericals */
	for(t=numerical; t < dates; t++){
	  sql_type **u;
	  for(u=numerical; u < dates; u++){
	    if (*t != *u) {
	      	sql_create_func("convert", (*u)->base.name, *t, NULL, *u, SCALE_FIX );
	      	sql_create_func("convert", (*u)->base.name, *t, INT, *u, SCALE_FIX );
	    }
	    sql_create_func("scale_up", "*", *u, *t, *t, SCALE_NONE );
	  }
	}

	/* convert strings */
	for(t=strings; t < numerical; t++){
	  sql_type **u;
	  for(u=strings; u < numerical; u++){
	    if (*t != *u) {
	      	sql_create_func("convert", (*u)->base.name, *t, NULL, *u, SCALE_FIX );
	    }
	    sql_create_func("convert", (*u)->base.name, *t, INT, *u, SCALE_FIX );
	  }
	}

	/* convert string to numerical (excluding decimals)  */
	for(t=strings; t < numerical; t++){
	  sql_type **u;
	  for(u=numerical; u < decimals; u++){
		char buf[50];

		snprintf(buf,50,"cast2%s", (*u)->base.name);
	      	sql_create_func("convert", buf, *t, NULL, *u, SCALE_FIX );
	      	sql_create_func("convert", buf, *t, INT, *u, SCALE_FIX );
	  }
	}


	/* convert string to temporal and temporal to string*/
	for(t=strings; t < numerical; t++){
	  sql_type **u;
	  for(u=dates; u < end; u++){
	      	sql_create_func("convert", (*u)->base.name, *t, NULL, *u, SCALE_FIX );
	      	sql_create_func("convert", (*t)->base.name, *u, NULL, *t, SCALE_FIX );
	      	sql_create_func("convert", (*t)->base.name, *u, INT, *t, SCALE_FIX );
	  }
	}

	/* convert string to decimals, these require a more complex conversion
	   as both number of digits and precision should be checked */
	for(t=strings; t < numerical; t++){
	  sql_type **u;
	  for(u=decimals; u < dates; u++){
		char buf[50];

		snprintf(buf,50,"cast2%s", (*u)->base.name);
	  	sql_create_func3( "convert", buf, *t, INT, INT, *u, SCALE_NONE);
	  }
	}

	/* convert numerical to string */
	for(t=numerical; t < dates; t++){
	  sql_type **u;
	  for(u=strings; u < numerical; u++){
	      	sql_create_func("convert", (*u)->base.name, *t, NULL, *u, SCALE_FIX);
	      	sql_create_func("convert", (*u)->base.name, *t, INT, *u, SCALE_FIX);
	  }
	}
	for(t=floats; t < dates; t++){
		sql_create_func( "floor", "floor", *t, NULL, *t, SCALE_FIX );
		sql_create_func( "ceil", "ceil", *t, NULL, *t, SCALE_FIX );
		sql_create_func( "ceiling", "ceil", *t, NULL, *t, SCALE_FIX ); /* JDBC */
		sql_create_func( "sin", "sin", *t, NULL, *t, SCALE_FIX );
		sql_create_func( "cos", "cos", *t, NULL, *t, SCALE_FIX );
		sql_create_func( "tan", "tan", *t, NULL, *t, SCALE_FIX );
		sql_create_func( "asin", "asin", *t, NULL, *t, SCALE_FIX );
		sql_create_func( "acos", "acos", *t, NULL, *t, SCALE_FIX );
		sql_create_func( "atan", "atan", *t, NULL, *t, SCALE_FIX );
		sql_create_func( "atan", "atan2", *t, *t, *t, SCALE_FIX );
		sql_create_func( "sinh", "sinh", *t, NULL, *t, SCALE_FIX );
		sql_create_func( "cot", "cotan", *t, NULL, *t, SCALE_FIX );
		sql_create_func( "cosh", "cosh", *t, NULL, *t, SCALE_FIX );
		sql_create_func( "tanh", "tanh", *t, NULL, *t, SCALE_FIX );
		sql_create_func( "sqrt", "sqrt", *t, NULL, *t, SCALE_FIX );
		sql_create_func( "exp", "exp", *t, NULL, *t, SCALE_FIX );
		sql_create_func( "log", "log", *t, NULL, *t, SCALE_FIX );
		sql_create_func( "log10", "log10", *t, NULL, *t, SCALE_FIX );
	}

	/* Date functions */

	/* Convert timestamp -> time and timestamp -> date */
	sql_create_func("convert", "daytime", TMESTAMP, NULL, TME, SCALE_NONE );
	sql_create_func("convert", "date", TMESTAMP, NULL, DTE, SCALE_NONE );

	sql_create_func( "current_date", "current_date", NULL, NULL, DTE, SCALE_NONE );
/* does not work?!?
	sql_create_func( "curdate", "current_date", NULL, NULL, DTE, SCALE_NONE ); *//* JDBC */
	sql_create_func( "current_time", "current_time", NULL, NULL, TME, SCALE_NONE );
/* does not work?!?
	sql_create_func( "curtime", "current_time", NULL, NULL, TME, SCALE_NONE ); *//* JDBC */
	sql_create_func( "current_timestamp", "current_timestamp", NULL, NULL, TMESTAMP, SCALE_NONE );
/* already there?!?
	sql_create_func( "now", "current_timestamp", NULL, NULL, TMESTAMP, SCALE_NONE );*/

	sql_create_func( "sql_sub", "date_sub_sec_interval", DTE, SECINT, DTE, SCALE_FIX);
	sql_create_func( "sql_sub", "date_sub_month_interval", DTE, MONINT, DTE, SCALE_FIX);

	sql_create_func( "sql_sub", "diff", DTE, DTE, INT, SCALE_FIX);
	sql_create_func( "sql_sub", "diff", TMESTAMP, TMESTAMP, LNG, SCALE_FIX);

	sql_create_func( "sql_add", "date_add_sec_interval", DTE, SECINT, DTE, SCALE_FIX);
	sql_create_func( "sql_add", "addmonths", DTE, MONINT, DTE, SCALE_FIX);
	sql_create_func( "local_timezone", "local_timezone", NULL, NULL, SECINT,  SCALE_FIX);

	sql_create_func( "year", "year", DTE, NULL, INT, SCALE_FIX);
	sql_create_func( "month", "month", DTE, NULL, INT, SCALE_FIX);
	sql_create_func( "day", "day", DTE, NULL, INT, SCALE_FIX);
	sql_create_func( "hour", "hours", TME, NULL, INT, SCALE_FIX);
	sql_create_func( "minute", "minutes", TME, NULL, INT, SCALE_FIX);
	sql_create_func( "second", "seconds", TME, NULL, INT, SCALE_FIX);
	sql_create_func( "year", "year", TMESTAMP, NULL, INT, SCALE_FIX);
	sql_create_func( "month", "month", TMESTAMP, NULL, INT, SCALE_FIX);
	sql_create_func( "day", "day", TMESTAMP, NULL, INT, SCALE_FIX);
	sql_create_func( "hour", "hours", TMESTAMP, NULL, INT, SCALE_FIX);
	sql_create_func( "minute", "minutes", TMESTAMP, NULL, INT, SCALE_FIX);
	sql_create_func( "second", "seconds", TMESTAMP, NULL, INT, SCALE_FIX);

	sql_create_func( "dayofyear", "dayofyear", DTE, NULL, INT, SCALE_FIX);
	sql_create_func( "weekofyear", "weekofyear", DTE, NULL, INT, SCALE_FIX);
	sql_create_func( "dayofweek", "dayofweek", DTE, NULL, INT, SCALE_FIX);
	sql_create_func( "dayofmonth", "day", DTE, NULL, INT, SCALE_FIX); /* JDBC */
	sql_create_func( "week", "weekofyear", DTE, NULL, INT, SCALE_FIX); /* JDBC */


	for(t=strings; t < numerical; t++){
	  sql_create_func(  "locate", "locate", *t, *t, INT, SCALE_NONE);
	  sql_create_func3( "locate", "locate", *t, *t, INT, INT, SCALE_NONE);
	  sql_create_func(  "substring", "substring", *t, INT, *t, SCALE_NONE);
	  sql_create_func3( "substring", "substring", *t, INT, INT, *t, SCALE_NONE);
	  sql_create_func( "like", "like", *t, *t, BIT, SCALE_NONE);
	  sql_create_func( "not_like", "not_like", *t, *t, BIT, SCALE_NONE);
	  sql_create_func( "truncate", "stringleft", *t, INT, *t, SCALE_NONE);
	  sql_create_func( "concat", "+", *t, *t, *t, DIGITS_ADD);
	  sql_create_func( "ascii", "ascii", *t, NULL, INT, SCALE_NONE);
	  sql_create_func( "code", "unicode", INT, NULL, *t, SCALE_NONE);
	  sql_create_func( "length", "stringlength", *t, NULL, INT, SCALE_NONE);
	  sql_create_func( "right", "stringright", *t, INT, *t, SCALE_NONE);
	  sql_create_func( "left", "stringleft", *t, INT, *t, SCALE_NONE);
	  sql_create_func( "upper", "toUpper", *t, NULL, *t, SCALE_NONE);
	  sql_create_func( "ucase", "toUpper", *t, NULL, *t, SCALE_NONE);
	  sql_create_func( "lower", "toLower", *t, NULL, *t, SCALE_NONE);
	  sql_create_func( "lcase", "toLower", *t, NULL, *t, SCALE_NONE);
	  sql_create_func( "trim", "trim", *t, NULL, *t, SCALE_NONE);
	  sql_create_func( "ltrim", "ltrim", *t, NULL, *t, SCALE_NONE);
	  sql_create_func( "rtrim", "rtrim", *t, NULL, *t, SCALE_NONE);
	
	  sql_create_func4( "insert", "stringinsert", *t, INT, INT, *t, *t, SCALE_NONE);
	  sql_create_func3( "replace", "stringreplace", *t, *t, *t, *t, SCALE_NONE);
	  sql_create_func( "repeat", "repeat", *t, INT, *t, SCALE_NONE);
	  sql_create_func( "space", "space", INT, NULL, *t, SCALE_NONE);
	  sql_create_func( "char_length", "length", *t, NULL, INT, SCALE_NONE);
	  sql_create_func( "character_length", "length", *t, NULL, INT, SCALE_NONE);

	  sql_create_func( "soundex", "soundex", *t, NULL, *t, SCALE_NONE);
	  sql_create_func( "difference", "stringdiff", *t, *t, INT, SCALE_NONE);
	  sql_create_func( "editdistance", "editdistance", *t, *t, INT, SCALE_FIX);
	  sql_create_func( "editdistance2", "editdistance2", *t, *t, INT, SCALE_FIX);

	  sql_create_func( "similarity", "similarity", *t, *t, DBL, SCALE_FIX);
	  sql_create_func( "qgramnormalize", "qgramnormalize", *t, NULL, *t, SCALE_NONE);

	  sql_create_func( "levenshtein", "levenshtein", *t, *t, INT, SCALE_FIX);
	  sql_create_func_( "levenshtein", "levenshtein",
		list_append(
	 	  list_append( 
                    list_append(
                      list_append(
                        list_append(
                          list_create((fdestroy)&arg_destroy),
	  	        sql_create_arg(NULL, sql_create_subtype(*t, 0, 0))),
	 	      sql_create_arg(NULL, sql_create_subtype(*t, 0, 0))),
 		    sql_create_arg(NULL, sql_create_subtype(INT, 0, 0))), 
 		  sql_create_arg(NULL, sql_create_subtype(INT, 0, 0))), 
               sql_create_arg(NULL, sql_create_subtype(INT, 0, 0))), 
	    sql_create_subtype(*t, 0, 0));
	}
}

void parser_exit()
{
#ifndef NDEBUG
	sql_end = END_SUBAGGR;
#endif

	if (sql_debug){
		list_destroy(subaggrs);
		list_destroy(subfuncs);
	}

#ifndef NDEBUG
	sql_end = END_AGGR;
#endif

	list_destroy(aggrs);
	list_destroy(funcs);

	list_destroy(localtypes);

#ifndef NDEBUG
	sql_end = END_SUBTYPE;
#endif
	if (sql_debug)
		list_destroy(subtypes);

#ifndef NDEBUG
	sql_end = END_TYPE;
#endif
	list_destroy(aliases);
	list_destroy(types);

	exit_keywords();
}
