@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@' 
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@' 
@' The Original Code is the Monet Database System.
@' 
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2004 CWI.
@' All Rights Reserved.
@' 
@' Contributor(s):
@' 		Martin Kersten <Martin.Kersten@cwi.nl>
@' 		Peter Boncz <Peter.Boncz@cwi.nl>
@' 		Niels Nes <Niels.Nes@cwi.nl>
@' 		Stefan Manegold  <Stefan.Manegold@cwi.nl>

@f sql_statement
@a N.J. Nes
@* 

@h
#ifndef _SQL_STATEMENT_H_
#define _SQL_STATEMENT_H_

#include "sql_sym.h"
#include "sql_atom.h"
#include "sql_string.h"
#include "sql_mvc.h"

#define RDONLY 0
#define INS 1
#define DEL 2
#define UPD 3

#define create_stmt_list() list_create((fdestroy)&stmt_destroy)

typedef enum stmt_type {
	st_none,
	st_sql,		/* sometimes a query rewrite is easier */
	st_var,		/* still needs work */
	st_assign,		/* still needs work */

	st_basetable,
	st_temp,	/* temporal bat */
	st_bat,
	st_ubat,
	st_ibat,	/* intermediate table result */
	st_dbat,
	st_idxbat,
	st_const,
	st_mark,
	st_reverse,
	st_mirror,

	st_limit,
	st_order,
	st_reorder,

	st_ordered,
	st_output,

	st_atom,
	st_filter,
	st_select,
	st_select2,
	st_uselect,
	st_uselect2,
	st_semijoin,

	st_reljoin,
	st_join,
	st_outerjoin,
	st_diff,
	st_intersect,
	st_union,
	st_relselect,

	st_find,
	st_exist,
	st_bulkinsert,
	st_append,
	st_insert,
	st_replace,
	st_exception,
	st_predicate,

	st_group_ext,
	st_group,
	st_derive,
	st_unique,
	st_op,
	st_unop,
	st_binop,
	st_Nop,
	st_aggr,

	st_column_alias,
	st_alias,

	st_set,
	st_sets,
	st_ptable,
	st_pivot,
	st_partial_pivot,
	/* used internally only */
	st_list
} st_type;

typedef enum comp_type {
	cmp_gt = 0,
	cmp_gte = 1,
	cmp_lte = 2,
	cmp_lt = 3,
	cmp_equal = 4,
	cmp_notequal = 5,
	cmp_notlike = 6,
	cmp_like = 7,
	cmp_all = 8
} comp_type;

typedef struct stmt {
	sql_ref ref;

	st_type type;
	symdata op1;
	symdata op2;
	symdata op3;
	symdata op4;		/* only op4 will hold other types */

	fdestroy destroy4;	/* destroy op4 */
	fdup 	 dup4;		/* dup op4 */

	char nrcols;
	char key;		/* key (aka all values are unique) */
	char aggr;		/* aggregated */
	int flag;

	int nr; 		/* variable assignement */

	struct stmt *h;
	struct stmt *t;
	int optimized;
	struct stmt *rewritten;
} stmt;

typedef struct group {
	sql_ref ref;

	stmt *grp;
	stmt *ext;
} group;

sql_export const char * st_type2string(st_type type);

extern stmt *stmt_none();
extern stmt *stmt_sql( char *query );
extern stmt *stmt_assign( char *varname, stmt *val);
extern stmt *stmt_var( char *varname, sql_subtype *t);

extern stmt *stmt_basetable(sql_table *t); 

#define isbasetable(s) (s->type == st_basetable)
#define basetable_table(s) s->op1.tval 

#define ptable_ppivots(s) 	((s)->op1.lval)
#define ptable_pivots(s) 	((s)->op2.lval)
#define ptable_statements(s) 	((s)->op3.stval)

extern stmt *stmt_cbat(sql_column * c, stmt * basetable, int access, st_type type);
extern stmt *stmt_ibat(stmt * i, stmt * basetable );
extern stmt *stmt_tbat(sql_table * t, int access );
extern stmt *stmt_idxbat(sql_idx *i, int access );

extern stmt *stmt_temp(sql_subtype * t );
extern stmt *stmt_atom(atom * op1);
extern stmt *stmt_atom_string( char * s );
extern stmt *stmt_atom_int( int i );
extern stmt *stmt_filter(stmt * sel);
extern stmt *stmt_select(stmt * op1, stmt * op2, comp_type cmptype);
extern stmt *stmt_uselect(stmt * op1, stmt * op2, comp_type cmptype);
/* cmp 
       0 ==   l <  x <  h 	
       1 ==   l <  x <= h 
       2 ==   l <= x <  h
       3 ==   l <= x <= h
       */
extern stmt *stmt_select2(stmt * op1, stmt * op2, stmt * op3, int cmp);
extern stmt *stmt_uselect2(stmt * op1, stmt * op2, stmt * op3, int cmp);
extern stmt *stmt_semijoin(stmt * op1, stmt * op2);

/* TODO: project single value 
extern stmt *stmt_project(stmt *table, stmt *col ); 
*/

/* TODO: project table 
extern stmt *stmt_relproject(stmt *table, list *collist ); 
*/

extern stmt *stmt_relselect_init();
extern void stmt_relselect_fill(stmt *relselect, stmt *select);
extern stmt *stmt_relselect(list * sels);

extern stmt *stmt_reljoin_init();
extern void stmt_reljoin_fill(stmt *reljoin, stmt *lc, stmt *rc);
extern stmt *stmt_reljoin1(list * joins);
extern stmt *stmt_reljoin2(list * l1, list * l2);
extern stmt *stmt_join(stmt * op1, stmt * op2, comp_type cmptype);
extern stmt *stmt_outerjoin(stmt * op1, stmt * op2, comp_type cmptype);

extern stmt *stmt_diff(stmt * op1, stmt * op2);
extern stmt *stmt_intersect(stmt * op1, stmt * op2);
extern stmt *stmt_union(stmt * op1, stmt * op2);
extern stmt *stmt_list(list * l);
extern stmt *stmt_set(stmt * s1);
extern stmt *stmt_sets(list * s1);
extern stmt *stmt_ptable();
extern stmt *stmt_pivot(stmt *s, stmt *ptable);
extern stmt *stmt_partial_pivot(stmt *s, stmt *ptable);

extern stmt *stmt_find(stmt *b, stmt *v );
extern stmt *stmt_exist(stmt *b, stmt *v );
extern stmt *stmt_bulkinsert(stmt *t, char *sep, char *rsep, stmt *file, int nr);

extern stmt *stmt_append(stmt *c, stmt * values);
extern stmt *stmt_insert(stmt *c, stmt * values);
extern stmt *stmt_replace(stmt * c, stmt * values);

/* raise exception incase the condition (cond) holds */
extern stmt *stmt_exception(stmt *cond, char *errstr, int errcode);
extern stmt *stmt_predicate(stmt *cond, stmt *def/*allways done*/, stmt *s /* done if cond is true */);

extern stmt *stmt_const(stmt * s, stmt * val);
extern stmt *stmt_mark(stmt * s, int id);
extern stmt *stmt_reverse(stmt * s);
extern stmt *stmt_mirror(stmt * s);

extern stmt *stmt_limit(stmt * s, int limit);
extern stmt *stmt_order(stmt * s, int direction);
extern stmt *stmt_reorder(stmt * s, stmt * t, int direction);

extern stmt *stmt_op(sql_subfunc * op);
extern stmt *stmt_unop(stmt * op1, sql_subfunc * op);
extern stmt *stmt_binop(stmt * op1, stmt * op2, sql_subfunc * op);
extern stmt *stmt_Nop(stmt * ops, sql_subfunc * op);
extern stmt *stmt_aggr(stmt * op1, group * grp, sql_subaggr * op );
extern stmt *stmt_unique(stmt * s, group * grp);

extern stmt *stmt_alias(stmt * op1, char *name);
extern stmt *stmt_column(stmt * op1, stmt *t, char *tname, char *cname);

extern stmt *stmt_ordered(stmt * order, stmt * res);
extern stmt *stmt_output(stmt * l);

extern sql_subtype *head_type(stmt * st);
sql_export sql_subtype *tail_type(stmt * st);

sql_export char *column_name(stmt * st);
extern char *table_name(stmt * st);
sql_export sql_column *basecolumn(stmt *st);

sql_export void stmt_destroy(stmt *s );
extern stmt *stmt_dup( stmt *s );

extern group *grp_create(stmt * s, group *og );
extern group *grp_semijoin(group *og, stmt *s );
extern void grp_destroy(group * g);
extern group *grp_dup(group * g);

#endif	/* _SQL_STATEMENT_H_ */

@c
#include "sql_mem.h"
#include "sql_statement.h"
#include <string.h>

const char * st_type2string(st_type type) {
	switch (type) {
	case st_none:	return "st_none";
	case st_sql:	return "st_sql";

	case st_basetable:	return "st_basetable";

	case st_temp:	return "st_temp";
	case st_bat:	return "st_bat";
	case st_ubat:	return "st_ubat";
	case st_ibat:	return "st_ibat";
	case st_dbat:	return "st_dbat";
	case st_idxbat:	return "st_idxbat";

	case st_const:	return "st_const";
	case st_mark:	return "st_mark";
	case st_reverse:return "st_reverse";
	case st_mirror:	return "st_mirror";
	case st_limit:	return "st_limit";
	case st_order:	return "st_order";
	case st_reorder:	return "st_reorder";
	case st_ordered:	return "st_ordered";
	case st_output:	return "st_output";

	case st_atom:	return "st_atom";

	case st_reljoin:	return "st_reljoin";
	case st_join:	return "st_join";
	case st_semijoin:	return "st_semijoin";
	case st_outerjoin:	return "st_outerjoin";
	case st_diff:	return "st_diff";
	case st_intersect:	return "st_intersect";
	case st_union:	return "st_union";
	case st_filter:	return "st_filter";
	case st_relselect:	return "st_relselect";
	case st_select:	return "st_select";
	case st_select2:	return "st_select2";
	case st_uselect:	return "st_uselect";
	case st_uselect2:	return "st_uselect2";
	case st_bulkinsert:	return "st_bulkinsert";
	case st_append:	return "st_append";
	case st_insert:	return "st_insert";
	case st_replace:	return "st_replace";
	case st_exception:	return "st_exception";
	case st_predicate:	return "st_predicate";
	case st_group_ext:	return "st_group_ext";
	case st_group:	return "st_group";
	case st_derive:	return "st_derive";
	case st_unique:	return "st_unique";
	case st_op:	return "st_op";
	case st_unop:	return "st_unop";
	case st_binop:	return "st_binop";
	case st_Nop:	return "st_Nop";
	case st_aggr:	return "st_aggr";
	case st_column_alias:	return "st_column_alias";
	case st_alias:	return "st_alias";
	case st_set:	return "st_set";
	case st_sets:	return "st_sets";
	case st_ptable:	return "st_ptable";
	case st_partial_pivot:	return "st_partial_pivot";
	case st_pivot:	return "st_pivot";
	case st_list:	return "st_list";
	default:	return "st_?";
	}
	return "unknown"; /* just needed for broken compilers ! */
}

/* #TODO make proper traversal operations */
stmt *stmt_atom_string( char * s )
{
	sql_subtype *t = sql_bind_subtype("CHAR", strlen(s), 0);
	return stmt_atom( atom_string(t, _strdup(s)) );
}

stmt *stmt_atom_int( int i )
{
	sql_subtype *t = sql_bind_subtype("MEDIUMINT", 0, 0);
	return stmt_atom( atom_int(t, i) );
}

static stmt *stmt_atom_oid( int i )
{
	sql_subtype *t = sql_bind_subtype("OID", 0, 0);
	return stmt_atom( atom_int(t, i) );
}

static stmt *stmt_create(st_type type)
{
	stmt *s = NEW(stmt);

	sql_ref_init(&s->ref);
	s->type = type;
	s->op1.sval = NULL;
	s->op2.sval = NULL;
	s->op3.sval = NULL;
	s->op4.sval = NULL;
	s->flag = 0;
	s->nrcols = 0;
	s->key = 0;
	s->aggr = 0;
	s->nr = 0;
	s->h = NULL;
	s->t = NULL;
	s->optimized = 0;
	s->rewritten = NULL;
	return s;
}

static stmt *stmt_ext( stmt *grp )
{
	stmt *ns = stmt_create(st_group_ext);

	ns->op1.stval = grp;
	ns->nrcols = grp->nrcols;
	ns->key = 1;
	ns->h = stmt_dup(grp->h);
	ns->t = stmt_dup(grp->t);
	return ns;
}

static stmt *stmt_group(stmt * s)
{
	stmt *ns = stmt_create(st_group);

	ns->op1.stval = s;
	ns->nrcols = s->nrcols;
	ns->key = 0;
	ns->h = stmt_dup(s->h);
	ns->t = stmt_dup(s->t);
	return ns;
}

static stmt *stmt_derive(stmt * s, stmt * t)
{
	stmt *ns = stmt_create(st_derive);
	ns->op1.stval = s;
	ns->op2.stval = t;
	ns->nrcols = s->nrcols;
	ns->key = 0;
	ns->h = stmt_dup(s->h);
	ns->t = stmt_dup(s->t);
	return ns;
}

void grp_destroy( group * g)
{
	if (sql_ref_dec(&g->ref) == 0) {
		stmt_destroy(g->grp);
		stmt_destroy(g->ext);
		_DELETE(g);
	}
}

group *grp_dup( group * g) 
{
	if (g) 
		sql_ref_inc(&g->ref);
	return g;
}

group *grp_create( stmt *s, group *og )
{
	group *g = NEW(group);
	sql_ref_init(&g->ref);
	if (og){
		g->grp = stmt_derive(stmt_dup(og->grp), s);
		grp_destroy(og);
	} else {
		g->grp = stmt_group(s);
	}
	g->ext = stmt_ext(stmt_dup(g->grp));
	return g;
}

static stmt *stmt_semijoin_tail( stmt *op1, stmt *op2 )
{
	return stmt_reverse(stmt_semijoin(stmt_reverse(op1), op2));
}

group *grp_semijoin( group *og, stmt *s )
{
	group *g = NEW(group);
	sql_ref_init(&g->ref);
	g->grp = stmt_semijoin_tail(stmt_dup(og->grp),s);
	g->ext = stmt_semijoin(stmt_dup(og->ext),stmt_dup(s));
	grp_destroy(og);
	return g;
}

void stmt_destroy(stmt * s)
{
	if (sql_ref_dec(&s->ref) == 0) {
		switch (s->type) {
			/* stmt_destroy  op1 */
		case st_relselect:
			list_destroy(s->op1.lval);
			break;
		case st_reljoin:
			list_destroy(s->op1.lval);
			list_destroy(s->op2.lval);
			break;

		case st_diff: case st_intersect: case st_union:
		case st_join: case st_outerjoin:
		case st_derive:
		case st_unique:
		case st_alias: case st_column_alias:
		case st_append: case st_insert: case st_replace:
		case st_exception: case st_predicate:
		case st_partial_pivot: case st_pivot:
	  	case st_find:
	  	case st_exist:
		case st_sql:

			if (s->op1.stval) stmt_destroy(s->op1.stval);
			if (s->op2.stval) stmt_destroy(s->op2.stval);
			if (s->op3.stval) stmt_destroy(s->op3.stval);
			break;

		case st_set: case st_sets: case st_list:
		case st_ptable:
			list_destroy(s->op1.lval);
			if (s->op2.lval) list_destroy(s->op2.lval);
			if (s->op3.stval) stmt_destroy(s->op3.stval);
			if (s->op4.stval) stmt_destroy(s->op4.stval);
			break;

		case st_assign:
			if (s->op1.stval) stmt_destroy(s->op1.stval);
			_DELETE(s->op4.sval);
			break;
		case st_var:
			_DELETE(s->op1.sval);
			sql_subtype_destroy(s->op2.typeval);
			break;

		/* reference only independently managed resources */
		case st_basetable: 
		case st_bat: case st_ubat:
		case st_dbat: case st_idxbat:
		case st_none:
			break;

		/* special cases */
		case st_temp:
			if (s->op1.stval) stmt_destroy(s->op1.stval);
			if (s->op2.stval) stmt_destroy(s->op2.stval);
			if (s->op3.stval) stmt_destroy(s->op3.stval);
			sql_subtype_destroy(s->op4.typeval);
			break;
		case st_aggr:
			if (s->op1.stval) stmt_destroy(s->op1.stval);
			if (s->op2.stval) stmt_destroy(s->op2.stval);
			if (s->op3.stval) stmt_destroy(s->op3.stval);
			sql_subaggr_destroy(s->op4.aggrval);
			break;
		case st_op: case st_unop: case st_binop: case st_Nop:
			if (s->op1.stval) stmt_destroy(s->op1.stval);
			if (s->op2.stval) stmt_destroy(s->op2.stval);
			if (s->op3.stval) stmt_destroy(s->op3.stval);
			sql_subfunc_destroy(s->op4.funcval);
			break;
		case st_atom:
			atom_destroy(s->op1.aval);
			break;

		/* simple case of statements of only statements */
		case st_const: case st_mark:
		case st_reverse: case st_mirror:
		case st_limit: case st_order: case st_reorder:
		case st_ordered: case st_output:

		case st_ibat:
		case st_group: case st_group_ext:

		case st_filter:
		case st_select: case st_select2:
		case st_uselect: case st_uselect2:
		case st_semijoin:

		case st_bulkinsert:
			if (s->op1.stval) stmt_destroy(s->op1.stval);
			if (s->op2.stval) stmt_destroy(s->op2.stval);
			if (s->op3.stval) stmt_destroy(s->op3.stval);
			if (s->op4.stval) stmt_destroy(s->op4.stval);
			break;

		default:
			printf("! TODO: stmt_destroy(%d=%s) !\n",s->type,st_type2string(s->type));
		}
		if (s->h) 
			stmt_destroy(s->h);
		if (s->t) 
			stmt_destroy(s->t);
		if (s->rewritten) 
			stmt_destroy(s->rewritten);
		_DELETE(s);
	}
}

stmt *stmt_none(){
	return stmt_create(st_none);
}

stmt *stmt_sql(char *query ){
	stmt *s = stmt_create(st_sql);
	s->op1.stval = stmt_atom_string(query );
	return s;
}

stmt *stmt_assign(char *varname, stmt *val){
	stmt *s = stmt_create(st_assign);
	s->op1.stval = val;
	s->op4.sval = varname;
	return s;
}

/* todo use sql_arg */
stmt *stmt_var(char *varname, sql_subtype *t){
	stmt *s = stmt_create(st_var);
	s->op1.sval = varname;
	s->op2.typeval = t;
	s->key = 1;
	return s;
}

stmt *stmt_basetable( sql_table *t )
{
	stmt *s = stmt_create(st_basetable);
	s->op1.tval = t;
	return s;
}

stmt *stmt_temp(sql_subtype * t)
{
	stmt *s = stmt_create(st_temp);
	s->op4.typeval = t;
	s->nrcols = 1;
	return s;
}

stmt *stmt_ibat(stmt * op1, stmt * basetable )
{
	stmt *s = stmt_create(st_ibat);
	s->op1.stval = op1;
	s->nrcols = 1;
	s->key = op1->key;
	s->h = basetable; /* oid's used from this basetable */
	return s;
}

stmt *stmt_cbat(sql_column * c, stmt * basetable, int access, st_type type)
{
	stmt *s = stmt_create(type);
	s->op1.cval = c;
	s->nrcols = 1;
	s->flag = access;
	s->h = basetable; /* oid's used from this basetable */
	return s;
}

stmt *stmt_tbat(sql_table * t, int access )
{
	stmt *s = stmt_create(st_dbat);
	s->nrcols = 0;
	s->flag = access;
	s->op1.tval = t;
	return s;
}

stmt *stmt_idxbat(sql_idx * i, int access)
{
	stmt *s = stmt_create(st_idxbat);
	s->op1.idxval = i;
	s->nrcols = 1;
	s->flag = access;
	return s;
}

stmt *stmt_const(stmt * s, stmt * val)
{
	stmt *ns = stmt_create(st_const);
	ns->op1.stval = s;
	ns->op2.stval = val;
	ns->nrcols = s->nrcols;
	ns->key = s->key;
	ns->h = stmt_dup(s->h);
	return ns;
}

/* BEWARE stmt_mark marks the head, this while the mil mark is a mark tail 
 * Current implementation adds the reverses in stmt_mark nolonger in
 * statement_exec.
*/
stmt *stmt_mark(stmt * s, int id)
{
	stmt *ns = stmt_create(st_mark);
	ns->op1.stval = stmt_reverse(s);
	ns->op2.stval = stmt_atom_oid(id);
	ns->nrcols = s->nrcols;
	ns->key = s->key;
	ns->h = stmt_dup(s->t);
	return stmt_reverse(ns);
}

stmt *stmt_reverse(stmt * s)
{
	stmt *ns = stmt_create(st_reverse);
	ns->op1.stval = s;
	ns->nrcols = s->nrcols;
	ns->key = s->key;
	ns->h = stmt_dup(s->t);
	ns->t = stmt_dup(s->h);
	return ns;
}

stmt *stmt_mirror(stmt * s)
{
	stmt *ns = stmt_create(st_mirror);
	ns->op1.stval = s;
	ns->nrcols = 2;
	ns->key = s->key;
	ns->h = stmt_dup(s->h);
	ns->t = stmt_dup(s->h);
	return ns;
}

stmt *stmt_limit(stmt * s, int limit)
{
	stmt *ns = stmt_create(st_limit);
	ns->op1.stval = s;
	ns->op2.stval = stmt_atom_int(limit);
	ns->nrcols = s->nrcols;
	ns->key = s->key;
	ns->t = stmt_dup(s->t);
	return ns;
}

stmt *stmt_order(stmt * s, int direction)
{
	stmt *ns = stmt_create(st_order);
	ns->op1.stval = s;
	ns->flag = direction;
	ns->nrcols = s->nrcols;
	ns->key = s->key;
	ns->t = stmt_dup(s->t);
	return ns;
}

stmt *stmt_reorder(stmt * s, stmt * t, int direction)
{
	stmt *ns = stmt_create(st_reorder);
	ns->op1.stval = s;
	ns->op2.stval = t;
	ns->flag = direction;
	ns->nrcols = s->nrcols;
	ns->key = s->key;
	ns->t = stmt_dup(s->t);
	return ns;
}

stmt *stmt_unique(stmt * s, group * g)
{
	stmt *ns = stmt_create(st_unique);
	ns->op1.stval = s;
	if (g) {
		ns->op2.stval = stmt_dup(g->grp);
		grp_destroy(g);
	}
	ns->nrcols = s->nrcols;
	ns->key = 1; /* ?? maybe change key to unique ? */
	ns->t = stmt_dup(s->t);
	return ns;
}

stmt *stmt_atom(atom * op1)
{
	stmt *s = stmt_create(st_atom);
	s->op1.aval = op1;
	s->key = 1; /* values are also unique */
	return s;
}

stmt *stmt_filter(stmt * sel )
{
	stmt *s = stmt_create(st_filter);
	s->op1.stval = sel;
	s->nrcols = 1;
	s->h = stmt_dup(s->op1.stval->h);
	return s;
}

stmt *stmt_relselect_init()
{
	stmt *s = stmt_create(st_relselect);
	s->op1.lval = list_create((fdestroy)&stmt_destroy);
	s->nrcols = 1;
	return s;
}

void stmt_relselect_fill(stmt *rs, stmt *sel)
{
	list_append(rs->op1.lval, sel);
	if (!rs->h) rs->h = stmt_dup(((stmt*)(rs->op1.lval->h->data))->h);
}

stmt *stmt_relselect(list * sels)
{
	stmt *s = stmt_create(st_relselect);
	s->op1.lval = sels;
	s->nrcols = 1;
	s->h = stmt_dup(((stmt*)(s->op1.lval->h->data))->h);
	return s;
}

stmt *stmt_select(stmt * op1, stmt * op2, comp_type cmptype)
{
	stmt *s = stmt_create(st_select);
	s->op1.stval = op1;
	s->op2.stval = op2;
	s->flag = cmptype;
	s->nrcols = 1;
	s->h = stmt_dup(s->op1.stval->h);
	s->t = stmt_dup(s->op1.stval->t);
	return s;
}

stmt *stmt_select2(stmt * op1, stmt * op2, stmt * op3, int cmp)
{
	stmt *s = stmt_create(st_select2);
	s->op1.stval = op1;
	s->op2.stval = op2;
	s->op3.stval = op3;
	s->flag = cmp;
	s->nrcols = 1;
	s->h = stmt_dup(s->op1.stval->h);
	s->t = stmt_dup(s->op1.stval->t);
	return s;
}

stmt *stmt_uselect(stmt * op1, stmt * op2, comp_type cmptype)
{
	stmt *s = stmt_create(st_uselect);
	assert(cmptype != cmp_like && cmptype != cmp_notlike);
	s->op1.stval = op1;
	s->op2.stval = op2;
	s->flag = cmptype;
	s->nrcols = 1;
	s->h = stmt_dup(s->op1.stval->h);
	return s;
}

stmt *stmt_uselect2(stmt * op1, stmt * op2, stmt * op3, int cmp)
{
	stmt *s = stmt_create(st_uselect2);
	s->op1.stval = op1;
	s->op2.stval = op2;
	s->op3.stval = op3;
	s->flag = cmp;
	s->nrcols = 1;
	s->h = stmt_dup(s->op1.stval->h);
	return s;
}

stmt *stmt_semijoin(stmt * op1, stmt * op2)
{
	stmt *s = stmt_create(st_semijoin);
	s->op1.stval = op1;
	s->op2.stval = op2;
	/* assert( op1->h == op2->h ); */
	s->nrcols = op1->nrcols;
	s->key = op1->key;
	s->h = stmt_dup(op1->h);
	s->t = stmt_dup(op1->t);
	return s;
}


stmt *stmt_reljoin_init()
{
	stmt *s = stmt_create(st_reljoin);
	s->op1.lval = list_create((fdestroy)&stmt_destroy);
	s->op2.lval = list_create((fdestroy)&stmt_destroy);
	s->nrcols = 2;
	return s;
}

void stmt_reljoin_fill(stmt *rj, stmt *lc, stmt *rc)
{
	list_append(rj->op1.lval, lc);
	list_append(rj->op2.lval, rc);
	if (!rj->h) rj->h = stmt_dup(((stmt*)(rj->op1.lval->h->data))->h);
	if (!rj->t) rj->t = stmt_dup(((stmt*)(rj->op2.lval->h->data))->h);
}

stmt *stmt_reljoin2(list * l1, list * l2)
{
	stmt *s = stmt_create(st_reljoin);
	s->op1.lval = l1;
	s->op2.lval = l2;
	s->nrcols = 2;
	s->h = stmt_dup(((stmt*)(s->op1.lval->h->data))->h);
	s->t = stmt_dup(((stmt*)(s->op2.lval->h->data))->h);
	return s;
}

stmt *stmt_reljoin1(list * joins)
{
	list *l1 = list_create((fdestroy)&stmt_destroy);
	list *l2 = list_create((fdestroy)&stmt_destroy);
	stmt *L = NULL;
	node *n = NULL;
	for (n = joins->h; n; n = n->next){
		stmt *l = stmt_dup(((stmt*)(n->data))->op1.stval);
		stmt *r = stmt_dup(((stmt*)(n->data))->op2.stval);
		while(l->type == st_reverse){
			stmt *t = l;
			l = stmt_dup(l->op1.stval);
			stmt_destroy(t);
		}
		while(r->type == st_reverse){
			stmt *t = r;
			r = stmt_dup(r->op1.stval);
			stmt_destroy(t);
		}
		if (l->t != r->t){
			r = stmt_reverse(r);
		}
		if (L == NULL) {
			L = stmt_dup(l);
		} else if (L->h != l->h) {
			stmt *t = l;
			l = r;
			r = t;
		}
		l1 = list_append(l1, l);
		l2 = list_append(l2, r);
	}
	if (L != NULL) stmt_destroy(L);
	return stmt_reljoin2(l1, l2);
}

stmt *stmt_join(stmt * op1, stmt * op2, comp_type cmptype)
{
	stmt *s = stmt_create(st_join);
	s->op1.stval = op1;
	s->op2.stval = op2;
	s->flag = cmptype;
	s->nrcols = 2;
	s->h = stmt_dup(op1->h);
	s->t = stmt_dup(op2->t);
	return s;
}

stmt *stmt_outerjoin(stmt * op1, stmt * op2, comp_type cmptype)
{
	stmt *s = stmt_create(st_outerjoin);
	s->op1.stval = op1;
	s->op2.stval = op2;
	s->flag = cmptype;
	s->nrcols = 2;
	s->h = stmt_dup(op1->h);
	s->t = stmt_dup(op2->t);
	return s;
}

stmt *stmt_diff(stmt * op1, stmt * op2)
{
	stmt *s = stmt_create(st_diff);
	s->op1.stval = op1;
	s->op2.stval = op2;
	s->nrcols = op1->nrcols;
	s->key = op1->key;
	s->h = stmt_dup(op1->h);
	s->t = stmt_dup(op1->t);
	return s;
}

stmt *stmt_intersect(stmt * op1, stmt * op2)
{
	stmt *res = NULL;
	int reverse = 0;

	while(op1->type == st_reverse){
		stmt *r = op1;
		op1 = stmt_dup(op1->op1.stval);
		stmt_destroy(r);
	}
	while(op2->type == st_reverse){
		stmt *r = op2;
		op2 = stmt_dup(op2->op1.stval);
		stmt_destroy(r);
	}
	if (op1->h != op2->h){
		reverse = 1;
	}
	assert ((op1->type == st_join || op1->type == st_reljoin) && (op2->type == st_join || op2->type == st_reljoin));
	if (op1->type == st_join && op1->flag == cmp_all){
		stmt_destroy(op1);
		return op2;
	} else if (op2->type == st_join && op2->flag == cmp_all){
		stmt_destroy(op2);
		return op1;
	}

	/* this case should have been transformed into a proper multi-att join ("st_reljoin") by push_selects_down() */
	assert (!(op1->flag == cmp_equal && op2->flag == cmp_equal));
	
	if (op1->type == st_reljoin || op2->type == st_reljoin) {
printf("= TODO stmt_intersect (1)\n");
		/* 
		 * could/should we do a similar rewrite here as we do below?
		 */
		res = stmt_create(st_intersect);
		res->op1.stval = op1;
		if (reverse){
			res->op2.stval = stmt_reverse(op2);
		} else {
			res->op2.stval = op2;
		}
		res->nrcols = op1->nrcols;
		res->key = op1->key;
		res->h = stmt_dup(op1->h);
		res->t = stmt_dup(op1->t);
	} else {
printf("= TODO stmt_intersect (2)\n");
		/*
	         * need to add the mark trick as [].select(true) on tables 
		 * without unique head identifiers + semijoin is wrong
		 */
		if (!reverse){
			stmt *ml = stmt_mark(stmt_reverse(stmt_dup(op1)), 50);
			stmt *mr = stmt_mark(stmt_dup(op1), 50);
			stmt *l = stmt_join(stmt_dup(ml), 
				stmt_dup(op2->op1.stval), cmp_equal ); 
			stmt *r = stmt_join(stmt_dup(mr), 
				stmt_reverse(stmt_dup(op2->op2.stval)), cmp_equal);
			stmt *v = stmt_uselect( l, r, (comp_type)op2->flag);
			res = stmt_join(stmt_reverse(stmt_semijoin(ml,v)), mr, cmp_equal);
		} else { /* reverse */
			stmt *ml = stmt_mark(stmt_reverse(stmt_dup(op1)), 50);
			stmt *mr = stmt_mark(stmt_dup(op1), 50);
			stmt *l = stmt_join(stmt_dup(mr), 
				stmt_dup(op2->op1.stval), cmp_equal ); 
			stmt *r = stmt_join(stmt_dup(ml), 
				stmt_reverse(stmt_dup(op2->op2.stval)), cmp_equal);
			stmt *v = stmt_uselect( l, r, (comp_type)op2->flag);
			res = stmt_join(stmt_reverse(stmt_semijoin(ml,v)), mr, cmp_equal);
		}

/*
		if (!reverse){
	 		res = stmt_semijoin( stmt_dup(op1), stmt_uselect( stmt_join(op1, stmt_reverse(stmt_dup(op2->op2.stval)), cmp_equal ), stmt_dup(op2->op1.stval), (comp_type)op2->flag));
		} else {
	 		res = stmt_semijoin( stmt_dup(op1), stmt_uselect( stmt_join(op1, stmt_dup(op2->op1.stval), cmp_equal ), stmt_reverse(stmt_dup(op2->op2.stval)), (comp_type)op2->flag));
		}
		stmt_destroy(op2);
*/
		stmt_destroy(op1);
		stmt_destroy(op2);
	}
	return res;
}

stmt *stmt_union(stmt * op1, stmt * op2)
{
	stmt *s = stmt_create(st_union);
	s->op1.stval = op1;
	s->op2.stval = op2;
	s->nrcols = op1->nrcols;
	s->h = stmt_dup(op1->h);
	s->t = stmt_dup(op1->t);
	return s;
}

stmt *stmt_find(stmt * b, stmt * v)
{
	stmt *s = stmt_create(st_find);
	s->op1.stval = b;
	s->op2.stval = v;
	s->nrcols = 1;
	s->key = 0;
	s->h = stmt_dup(b->h);
	s->t = stmt_dup(b->t);
	return s;
}

stmt *stmt_exist(stmt * b, stmt * v)
{
	stmt *s = stmt_create(st_exist);
	s->op1.stval = b;
	s->op2.stval = v;
	s->nrcols = 0;
	s->key = 1;
	s->h = stmt_dup(b->h);
	s->t = stmt_dup(b->t);
	return s;
}

stmt *stmt_bulkinsert(stmt *t, char *sep, char *rsep, stmt *file, int nr )
{
	stmt *s = stmt_create(st_bulkinsert);
	s->op1.stval = t;
	s->op2.stval = stmt_atom_string(sep);
	s->op3.stval = stmt_atom_string(rsep);
	s->op4.stval = file;
	s->flag = nr; 
	return s;
}

stmt *stmt_list(list * l)
{
	stmt *s = stmt_create(st_list);
	s->op1.lval = l;
	if (list_length(l) > 0) {
		stmt *f = l->h->data;
		s->nrcols = f->nrcols;
	}
	return s;
}

stmt *stmt_ordered(stmt * order, stmt * res)
{
	stmt *ns = stmt_create(st_ordered);
	ns->type = st_ordered;
	ns->op1.stval = order;
	ns->op2.stval = res;
	ns->nrcols = res->nrcols;
	ns->key = res->key;
	ns->t = stmt_dup(res->t);
	return ns;
}

stmt *stmt_output(stmt * l)
{
	stmt *s = stmt_create(st_output);
	s->op1.stval = l;
	return s;
}

stmt *stmt_set(stmt * s1)
{
	stmt *s = stmt_create(st_set);
	s->op1.lval = list_append(list_create((fdestroy)&stmt_destroy),s1);
	return s;
}

stmt *stmt_sets(list * l1)
{
	stmt *s = stmt_create(st_sets);
	s->op1.lval = l1;
	return s;
}

/* ptable 
		list of ppivots
		list of pivots
		statements	
 */

stmt *stmt_ptable()
{
	stmt *s = stmt_create(st_ptable);
/*
	s->op1.lval = list_create( (fdestroy)&stmt_destroy );
	s->op2.lval = list_create( (fdestroy)&stmt_destroy );
*/
	s->op1.lval = list_create( (fdestroy)NULL );
	s->op2.lval = list_create( (fdestroy)NULL );
	s->op3.stval = NULL;
	s->op4.stval = NULL;
	return s;
}

static void stmt_ptable_add_ppivot( stmt *ptable, stmt *piv )
{
	/*list_append(ptable->op1.lval, stmt_dup(piv));*/
	list_append(ptable->op1.lval, piv);
}

static void stmt_ptable_add_pivot( stmt *ptable, stmt *piv )
{
	/*list_append(ptable->op2.lval, stmt_dup(piv));*/
	list_append(ptable->op2.lval, piv);
}

stmt *stmt_partial_pivot(stmt * base, stmt *ptable)
{
	stmt *s = stmt_create(st_partial_pivot);

	s->op1.stval = base;
	s->op2.stval = ptable;
	stmt_ptable_add_ppivot(ptable, s);
	s->nrcols = 2;
	s->h = stmt_dup(ptable); /* the ptable is the new base table */
	s->t = stmt_dup(base); 	 /* pivots have oid's in the tail */
	return s;
}

stmt *stmt_pivot(stmt * base, stmt *ptable)
{
	stmt *s = stmt_create(st_pivot);

	s->op1.stval = base;
	s->op2.stval = ptable;
	stmt_ptable_add_pivot(ptable, s);
	s->nrcols = 2;
	s->h = stmt_dup(ptable); /* the ptable is the new base table */
	s->t = stmt_dup(base); 	 /* pivots have oid's in the tail */
	return s;
}

stmt *stmt_append(stmt * c, stmt * a )
{
	stmt *s = stmt_create(st_append);
	s->op1.stval = c;
	s->op2.stval = a;
	s->h = stmt_dup(c->h);
	s->t = stmt_dup(c->t);
	return s;
}

stmt *stmt_insert(stmt * c, stmt * a )
{
	stmt *s = stmt_create(st_insert);
	s->op1.stval = c;
	s->op2.stval = a;
	s->h = stmt_dup(c->h);
	s->t = stmt_dup(c->t);
	return s;
}

stmt *stmt_replace(stmt * c, stmt * b)
{
	stmt *s = stmt_create(st_replace);
	s->op1.stval = c;
	s->op2.stval = b;
	s->nrcols = 1;
	return s;
}

stmt *stmt_exception(stmt * cond, char *errstr, int errcode )
{
	stmt *s = stmt_create(st_exception);
	s->op1.stval = cond;
	s->op2.stval = stmt_atom_string(errstr);
	s->op3.stval = stmt_atom_int(errcode);
	s->nrcols = 0;
	return s;
}

stmt *stmt_predicate(stmt *cond, stmt *def/*allways done*/, stmt *ss /* done if cond is true */)
{
	stmt *s = stmt_create(st_predicate);
	s->op1.stval = cond;
	s->op2.stval = def;
	s->op3.stval = ss;
	s->key = ss->key;
	s->nrcols = ss->nrcols;
	s->h = stmt_dup(ss->h);
	s->t = stmt_dup(ss->t);
	return s;
}


stmt *stmt_op(sql_subfunc * op)
{
	stmt *s = stmt_create(st_op);
	assert(op);
	
	s->op4.funcval = op;
	s->nrcols = 0; /* function without arguments returns single value */
	s->key = 1;
	return s;
}

stmt *stmt_unop(stmt * op1, sql_subfunc * op)
{
	stmt *s = stmt_create(st_unop);
	s->op1.stval = op1;
	assert(op);
	s->op4.funcval = op;
	s->h = stmt_dup(op1->h);
	s->nrcols = op1->nrcols;
	s->key = op1->key;
	return s;
}

stmt *stmt_binop(stmt * op1, stmt * op2, sql_subfunc * op)
{
	stmt *s = stmt_create(st_binop);
	s->op1.stval = op1;
	s->op2.stval = op2;
	assert(op);
	s->op4.funcval = op;
	if (op1->nrcols > op2->nrcols){
		s->h = stmt_dup(op1->h);
		s->nrcols = op1->nrcols;
		s->key = op1->key;
	} else {
		s->h = stmt_dup(op2->h);
		s->nrcols = op2->nrcols;
		s->key = op2->key;
	}
	return s;
}

stmt *stmt_Nop(stmt * ops, sql_subfunc * op)
{
	node *n;
	stmt *o, *s = stmt_create(st_Nop);

	s->op1.stval = ops; 
	assert(op);
	s->op4.funcval = op;
	for(n = ops->op1.lval->h, o = n->data; n; n = n->next){
		stmt *c = n->data;
		if (o->nrcols < c->nrcols)
			o = c;
	}

	s->h = stmt_dup(o->h);
	s->nrcols = o->nrcols;
	s->key = o->key;

	return s;
}

stmt *stmt_aggr(stmt * op1, group * grp, sql_subaggr * op )
{
	stmt *s = stmt_create(st_aggr);
	s->op1.stval = op1;
	if (grp) {
		s->op2.stval = stmt_dup(grp->grp);
		s->op3.stval = stmt_dup(grp->ext);
		s->nrcols = 1;
		s->h = stmt_dup(grp->grp->h);
		grp_destroy(grp);
	} else {
		s->nrcols = 0;
		s->h = stmt_dup(op1->h);
	}
	s->key = 1;
	s->aggr = 1;
	s->op4.aggrval = op;
	return s;
}

stmt *stmt_alias(stmt * op1, char *alias)
{
	stmt *s = stmt_create(st_alias);
	s->op1.stval = op1;
	s->op2.stval = stmt_atom_string(alias);
	s->h = stmt_dup(op1->h);
	s->t = stmt_dup(op1->t);
	s->nrcols = op1->nrcols;
	s->key = op1->key;
	return s;
}

stmt *stmt_column(stmt * op1, stmt *t, char *tname, char *cname)
{
	stmt *s = stmt_create(st_column_alias);
	s->op1.stval = op1;
	s->op2.stval = (tname)? stmt_atom_string(tname):NULL;
	s->op3.stval = (cname)? stmt_atom_string(cname):NULL;
	s->h = t;
	s->nrcols = 1; 
	s->key = op1->key;
	return s;
}

stmt *stmt_dup( stmt * s)
{
	if (s) 
		sql_ref_inc(&s->ref);
	return s;
}


sql_subtype *tail_type(stmt * st) 
{
	switch (st->type) {
	case st_const:
	case st_join:
	case st_outerjoin:
		return tail_type(st->op2.stval);
	case st_reljoin:
		return tail_type(st->op2.lval->h->data);

	case st_diff:
	case st_filter:
	case st_select:
	case st_select2:
	case st_uselect:
	case st_uselect2:
	case st_semijoin:
	case st_unique:
	case st_union:
	case st_append:
	case st_replace:
	case st_alias:
	case st_column_alias:
	case st_ibat:
	case st_partial_pivot: case st_pivot:
	case st_group:
	case st_group_ext:
	case st_mark:
		return tail_type(st->op1.stval);

	case st_list:
		return tail_type(st->op1.lval->h->data);

	case st_bat:
		return st->op1.cval->type;
	case st_idxbat:
		if (st->op1.idxval->type == unique){	
			return sql_bind_localtype( "int" );
		} else if (st->op1.idxval->type == join_idx){	
			return sql_bind_localtype( "oid" );
		}
	case st_mirror:
	case st_reverse:
		return head_type(st->op1.stval);

	case st_aggr:
		return &st->op4.aggrval->res;
	case st_op:
	case st_unop:
	case st_binop:
	case st_Nop:
		return &st->op4.funcval->res;
	case st_atom:
		return atom_type(st->op1.aval);
	case st_temp:
		return st->op4.typeval;
	case st_var:
		return st->op2.typeval;
	case st_exist:
		return sql_bind_localtype( "bit" );

	case st_relselect:
	default:
		fprintf(stderr, "missing tail type %d: %s\n", st->type, st_type2string(st->type) );
		return NULL;
	}
}

sql_subtype *head_type(stmt * st)
{
	switch (st->type) {
	case st_aggr:
	case st_unop:
	case st_binop:
	case st_Nop:
	case st_unique:
	case st_union:
	case st_alias:
	case st_column_alias:
	case st_diff:
	case st_join:
	case st_outerjoin:
	case st_semijoin:
	case st_mirror:
	case st_filter:
	case st_select:
	case st_select2:
	case st_uselect:
	case st_uselect2:
	case st_ibat:
	case st_append:
	case st_insert:
	case st_replace:
	case st_partial_pivot: case st_pivot:
	case st_mark:
	case st_group:
	case st_group_ext:
		return head_type(st->op1.stval);
	case st_relselect:
	case st_reljoin:
		return head_type(st->op1.lval->h->data);

	case st_list:
		return head_type(st->op1.lval->h->data);

	case st_temp:
	case st_bat:
		return sql_bind_localtype("oid");
		/* return NULL;	oid */

	case st_reverse:
		return tail_type(st->op1.stval);
	case st_atom:
		return atom_type(st->op1.aval);

	default:
		fprintf(stderr, "missing head type %d: %s\n", st->type, st_type2string(st->type) );
		return NULL;
	}
}

static stmt *head_column(stmt * st);

static stmt *tail_column(stmt * st)
{
	switch (st->type) {
	case st_join:
	case st_outerjoin:
	case st_derive:
	case st_intersect:
		return tail_column(st->op2.stval);
	case st_reljoin:
		return tail_column(st->op2.lval->h->data);

	case st_const:
	case st_unop:
	case st_binop:
	case st_Nop:
	case st_aggr:
	case st_diff:
	case st_filter:
	case st_select:
	case st_select2:
	case st_uselect:
	case st_uselect2:
	case st_semijoin:
	case st_atom:
	case st_alias:
	case st_union:
	case st_append:
	case st_unique:
	case st_partial_pivot: case st_pivot:
		return tail_column(st->op1.stval);

	case st_var:
	case st_column_alias:
	case st_ibat:
	case st_bat:
		return st;

	case st_mirror:
	case st_reverse:
		return head_column(st->op1.stval);
	case st_list:
		return tail_column(st->op1.lval->h->data);

	/* required for shrink_select_ranges() in sql_rel2bin.mx */
	case st_idxbat: 

	/* required for eliminate_semijoin() in sql_rel2bin.mx */
	case st_relselect: 

		printf("= TODO: tail_column(%d=%s) -> NULL !?\n",
			st->type, st_type2string(st->type) );
	/* some statements have no column comming from any basetable */
	case st_mark:
	case st_group:	
	case st_group_ext:
		return NULL;

	default:
		fprintf(stderr, "missing tail column %d: %s\n", st->type, st_type2string(st->type) );
		assert(0);
		return NULL;
	}
}

stmt *head_column(stmt * st)
{
	switch (st->type) {
	case st_atom:
	case st_const:
	case st_mark:
	case st_alias:
	case st_union:
	case st_unique:
	case st_aggr:
	case st_unop:
	case st_binop:
	case st_Nop:
	case st_diff:
	case st_join:
	case st_outerjoin:
	case st_intersect:
	case st_semijoin:
	case st_filter:
	case st_select:
	case st_select2:
	case st_uselect:
	case st_uselect2:
	case st_append:
	case st_insert:
	case st_replace:
	case st_partial_pivot: case st_pivot:
	case st_mirror:
	case st_group:
	case st_group_ext:
		return head_column(st->op1.stval);
	case st_relselect:
	case st_reljoin:
		return head_column(st->op1.lval->h->data);

	case st_column_alias:
	case st_ibat:
	case st_bat:
	case st_var:
		return st;

	case st_reverse:
		return tail_column(st->op1.stval);

	case st_derive:
		return tail_column(st->op2.stval);
	case st_list:
		return head_column(st->op1.lval->h->data);

	/* required for eliminate_semijoin() in sql_rel2bin.mx */
	/* st_temp has no head column coming from any basetable */
	case st_temp: 
		return NULL;

	default:
		fprintf(stderr, "missing head column %d: %s\n", st->type, st_type2string(st->type) );
		assert(0);
		return NULL;
	}
}

static char *func_name(char *n1, char *n2)
{
	int l1 = strlen(n1);
	int l2 = strlen(n2);
	if (l2 > 16) { /* only support short names */
		char *ns = NEW_ARRAY(char, l2 + 1);
		strncpy(ns, n2, l2);
		ns[l2] = 0;
		return ns;
	} else {
		char *ns = NEW_ARRAY(char, l1 + l2 + 2), *s = ns;
		strncpy(ns, n1, l1);
		ns += l1;
		*ns++ = '_';
		strncpy(ns, n2, l2);
		ns += l2;
		*ns = '\0';
		return s;
	}
}

char *column_name(stmt * st)
{
	switch (st->type) {
	case st_reverse:
		return column_name(st->op1.stval);
	case st_const:
	case st_join:
	case st_outerjoin:
	case st_derive:
	case st_exist:
		return column_name(st->op2.stval);

	case st_mirror:
	case st_group:
	case st_group_ext:
	case st_ibat:
	case st_union:
	case st_append:
	case st_mark:
	case st_filter:
	case st_select:
	case st_select2:
	case st_uselect:
	case st_uselect2:
	case st_semijoin:
	case st_diff:
	case st_unique:
	case st_partial_pivot: case st_pivot:
	case st_replace:
		return column_name(st->op1.stval);

	case st_op:
		return _strdup(st->op4.funcval->func->name);
	case st_unop:
	case st_binop:
	case st_Nop: 
	{
		char *cn = column_name(st->op1.stval);
		char *r = func_name(st->op4.funcval->func->name, cn);
		_DELETE(cn);
		return r;
	}
	case st_aggr: 
	{
		char *cn = column_name(st->op1.stval);
		char *r = func_name(st->op4.aggrval->aggr->name, cn);
		_DELETE(cn);
		return r;
	}
	case st_alias:
		return column_name(st->op2.stval);
	case st_column_alias:
		return column_name(st->op3.stval);
	case st_bat:
		return _strdup(st->op1.cval->base.name);
	case st_atom:
		if (st->op1.aval->data.vtype == TYPE_str)
			return atom2string(st->op1.aval);
	case st_var:
	case st_temp:
		return _strdup("single_value");

	case st_relselect:
	case st_reljoin:
	case st_list:
		if (list_length(st->op1.lval))
			return column_name(st->op1.lval->h->data);
		/* whats the name of an empty list ? */
		assert(0);
	default:
		fprintf(stderr, "missing column name %d: %s\n", st->type, st_type2string(st->type) );
		return NULL;
	}
}

char *table_name(stmt * st)
{
	switch (st->type) {
	case st_reverse:
		return table_name(st->op1.stval);
	case st_const:
	case st_join:
	case st_outerjoin:
	case st_derive:
		return table_name(st->op2.stval);
	case st_mirror:
	case st_group:
	case st_group_ext:
	case st_ibat:
	case st_union:
	case st_append:
	case st_mark:
	case st_filter:
	case st_select:
	case st_select2:
	case st_uselect:
	case st_uselect2:
	case st_semijoin:
	case st_diff:
	case st_aggr:
	case st_unique:
	case st_partial_pivot: case st_pivot:
		return table_name(st->op1.stval);

	case st_bat:
		return _strdup(st->op1.cval->t->base.name);
	case st_alias:
		return _strdup("unknown");
	case st_column_alias:
		return table_name(st->op2.stval);

	case st_atom:
		if (st->op1.aval->data.vtype == TYPE_str)
			return atom2string(st->op1.aval);
		assert(0);

	case st_relselect:
	case st_reljoin:
	default:
		fprintf(stderr, "missing table name %d: %s\n", st->type, st_type2string(st->type) );
		return NULL;
	}
}

sql_column *basecolumn(stmt * st)
{
	if (!st) return NULL; /* required for shrink_select_ranges() and eliminate_semijoin() in sql_rel2bin.mx */
	switch (st->type) {
	case st_reverse:
		return basecolumn(head_column(st->op1.stval));

	case st_partial_pivot: case st_pivot:
		return basecolumn(st->op1.stval);
	case st_bat:
		return st->op1.cval;

	case st_column_alias: /* required to avoid cyclic calls */
	case st_ibat:
		printf("= TODO: basecolumn(%d=%s) -> NULL !?\n",
			st->type, st_type2string(st->type) );
		return NULL;

	default:
		return basecolumn(tail_column(st));
	}
}

