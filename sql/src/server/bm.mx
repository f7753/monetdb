@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at 
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@' 
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@' 
@' The Original Code is the Monet Database System.
@' 
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2002 CWI.  
@' All Rights Reserved.
@' 
@' Contributor(s):
@' 		Martin Kersten <Martin.Kersten@cwi.nl>
@' 		Niels Nes <Niels.Nes@cwi.nl>

@f bm
@t Bat Manager
@a N. J. Nes
@v 1.0
@T
@* Introduction
Manages a collection of bats. This gives an abstraction on top of the monet
bat ids.

@* Implementation Code 
@h
#ifndef _BM_H_
#define _BM_H_

#include <gdk.h>

/* TODO move void_* functions into bm */
extern void bat_destroy(BAT *b);

extern struct bm *bm_create();
extern void bm_destroy(struct bm *bm);
extern struct bm *bm_dup(struct bm *bm);

/* The current state of the bat manager can be saved using
 * the bm_save function. It makes the managed bats persistent. 
 * For each persistent bat the name,version pairs are writen 
 * to the given file. 
 *
 * The previous persistent versions should be removed (after the
 * file writen by bm_save saved), using the bm_cleanup.
 */
extern void bm_save( struct bm *bm, FILE *fp );
extern void bm_cleanup( struct bm *bm );
extern void bm_load( struct bm *bm, FILE *fp );

/* fake commits as real commits are handled by a log manager */
extern void bm_commit( struct bm *bm, int tid );
extern void bm_abort( struct bm *bm, int tid );
extern int bm_version( struct bm *bm);

extern oid bm_add_bat(struct bm *bm, oid bid, char *name, int version);
extern void bm_del_bat(struct bm *bm, oid lbid);
extern void bm_new_version(struct bm *bm, oid lbid, int version );
extern void bm_new_bat(struct bm *bm, oid lbid, oid bid );

extern oid bm_find_bat(struct bm *bm, char *name);
extern BAT *bm_lbid2bat(struct bm *bm, oid lbid);
extern char *bm_lbid2name(struct bm *bm, oid lbid);
extern int bm_lbid2version(struct bm *bm, oid lbid);

#endif /*_BM_H_*/
@c
#include "bm.h"
#include "stream.h"
#include "mem.h"

typedef struct bm {
	/* Store oids to circumvent trouble with reference counting */
	oid	vid;
	oid	lbid;
	int 	version;
	BAT*	bat_version;	/*	[ void, int ] 	*/
	BAT*	bat_name; 	/*	[ void, str ] 	*/
	BAT*	bat_bid;	/*	[ void, oid ] 	*/
	BAT*	bat_lbid;	/*	[ void, oid ] 	*/
	BAT*	bat_oversion;	/* 	[ void, int ]   */
} bm;

static BAT *bat_descriptor(bat bid)
{
	if (bid){
		BBPfix(bid);
		return BATdescriptor(bid);
	}
	return NULL;
}

void bat_destroy(BAT *b)
{
	if (b){
		BBPunfix(b->batCacheid);
	}
}

static BAT *bm_create_bat( int ht, int tt, size_t size ){
	BAT *b = BATnew(ht, tt, size);
	BBPfix(b->batCacheid);
	/* Make persistent as only persistent bats keep delta information */
	BBPpersistent(b->batCacheid, FALSE);
	return b;
}

static void bm_add_bat_intern(bm *bm, oid lbid, oid bid, char *name, int version)
{
	BUNins(bm->bat_version, &bm->vid, &version );
	BUNins(bm->bat_name, &bm->vid, name );
	BUNins(bm->bat_bid, &bm->vid, &bid);
	BUNins(bm->bat_lbid, &bm->vid, &lbid);
	BBPpersistent(bid, FALSE);
	bm->vid++;
	if (version > bm->version)
		bm->version = version;
}

bm *bm_create( )
{
	bm *bm = NEW(struct bm);
	bm->vid = 1;
	bm->lbid = 1;
	bm->version = 0;

	bm->bat_name = bm_create_bat(TYPE_oid,TYPE_str,BUFSIZ); 
	bm->bat_bid = bm_create_bat(TYPE_oid,TYPE_oid,BUFSIZ); 
	bm->bat_lbid = bm_create_bat(TYPE_oid,TYPE_oid,BUFSIZ); 
	bm->bat_version = bm_create_bat(TYPE_oid,TYPE_int,BUFSIZ); 
	bm->bat_oversion = NULL;
	return bm;
}

void bm_destroy( bm *bm )
{
	BUN p,q;
	BAT *b = bm->bat_bid;

	BATloop(b, p, q){
		bat bid = *(oid*)BUNtail(b,p);
		BBPtransient(bid,FALSE);
	}

	BBPtransient(bm->bat_name->batCacheid, FALSE);
	BBPtransient(bm->bat_bid->batCacheid, FALSE);
	BBPtransient(bm->bat_lbid->batCacheid, FALSE);
	BBPtransient(bm->bat_version->batCacheid, FALSE);
	BBPunfix(bm->bat_name->batCacheid);
	BBPunfix(bm->bat_bid->batCacheid);
	BBPunfix(bm->bat_lbid->batCacheid);
	BBPunfix(bm->bat_version->batCacheid);
	if (bm->bat_oversion) 
		BBPunfix(bm->bat_oversion->batCacheid);

	_DELETE(bm);
}

bm *bm_dup( bm *obm )
{
	BUN p,q;
	BAT *b = obm->bat_version;
	bm *nbm = bm_create();

	nbm->version = obm->version;

	BATloop(b, p, q){
	    	int version = *(int*)BUNtail(b,p);
	    	oid id = *(oid*)BUNhead(b,p);
		str name = BUNtail(obm->bat_name, BUNfnd(obm->bat_name,&id));
		bat bid = *(oid*)BUNtail(obm->bat_bid, 
				BUNfnd(obm->bat_bid,&id));
		oid lbid = *(oid*)BUNtail(obm->bat_lbid, 
				BUNfnd(obm->bat_lbid,&id));
		BBPpersistent(bid, FALSE);
		if (lbid > nbm->lbid) 
			nbm->lbid = lbid+1;
		bm_add_bat_intern(nbm, lbid, bid, name, version);
	}
	return nbm;
}

void bm_save( bm *bm, FILE *fp )
{
	BUN p,q;
	BAT *b;

	b = bm->bat_version;
	BATloop(b, p, q){
		BUN z;
	    	/*
	     	 * Save all bats using name_version 
   	     	 */
	    	oid id = *(oid*)BUNhead(b,p);
	    	int version = *(int*)BUNtail(b,p);
	    	int oversion = 0;
	    	str name = BUNtail(bm->bat_name, BUNfnd(bm->bat_name,&id));
	    	bat bid = *(oid*)BUNtail(bm->bat_bid, BUNfnd(bm->bat_bid,&id));
	    	if (bm->bat_oversion && (z = BUNfnd(bm->bat_oversion, &id)) ){
			oversion = *(int*)BUNtail(bm->bat_oversion, z);
	    	}
	    	if (version > oversion) {	
/*
	    	if (!(BBP_status(bid)&BBPPERSISTENT)){
*/
	    		char name_version[BUFSIZ];
			BAT *o = bat_descriptor(bid);
	    		BAT *b = BATcopy(o);

	    		snprintf( name_version, BUFSIZ, "%s_%d", name, version); 
	    		BATrename(b, name_version);
	    		BATmode(b, PERSISTENT);
			BBPunfix(b->batCacheid);
			BBPunfix(o->batCacheid);
	    	}
	    	fprintf(fp, "%s,%d\n", name, version); 
	}
}

void bm_cleanup( bm *bm )
{
	BUN p,q;

	if (bm->bat_oversion){
		BAT *b = bm->bat_oversion;
		BATloop(b, p, q){
	   	 	oid id = *(oid*)BUNhead(b,p);
	    		int oversion = *(int*)BUNtail(b,p);
	    		str name = BUNtail(bm->bat_name, 
					BUNfnd(bm->bat_name,&id));
	    		int version = *(int*)BUNtail(bm->bat_version, 
					BUNfnd(bm->bat_version,&id));
	    		if (version > oversion) {	
	    			char name_version[BUFSIZ];
				BAT *ob = NULL;

	    			snprintf( name_version, BUFSIZ, "%s_%d", name, oversion); 
				ob = bat_descriptor(BBPindex(name_version));
	    			BATmode(ob, TRANSIENT);
				BBPunfix(ob->batCacheid);
			}
	    	}
		BBPunfix(bm->bat_oversion->batCacheid);
		bm->bat_oversion = BATcopy(bm->bat_version);
	}
}

void bm_load( bm *bm, FILE *fp )
{
	char line[BUFSIZ];
	while(fgets(line, BUFSIZ, fp) != NULL && line[0] != '\n'){
		char *s = strchr(line, ',');
		if (s){
			char nme[BUFSIZ];
			oid bid = 0;
			int version = 0;

			*s++ = 0;
			version = strtol(s,NULL,10);
			snprintf(nme, BUFSIZ, "%s_%d", line, version );
			bid = BBPindex(nme);
			assert(bid);
			bm_add_bat_intern(bm, bm->lbid++, bid, line, version);
		}
	}
	if (!bm->bat_oversion)
		bm->bat_oversion = BATcopy(bm->bat_version);
}

void bm_commit( bm *bm, int tid ) 
{
	BUN p,q;
	BAT *b = bm->bat_version;

	BATloop(b, p, q){
	    	int version = *(int*)BUNtail(b,p);
	    	if (tid == version){
	    		oid id = *(oid*)BUNhead(b,p);
			bat bid = *(oid*)BUNtail(bm->bat_bid,
				BUNfnd(bm->bat_bid,&id));
			BAT *b = bat_descriptor(bid);
			BATfakeCommit(b);
			BBPunfix(b->batCacheid);
	    	}
	}
	/* remove the destroyed bats */
 	b = bm->bat_bid;
	for (p = b->batDeleted; p < b->batHole; p = BUNnext(b, p)){
		bat bid = *(oid*)BUNtail(b,p);
		BBPtransient(bid, FALSE);
	}
	BATfakeCommit(bm->bat_version);
	BATfakeCommit(bm->bat_name);
	BATfakeCommit(bm->bat_bid);
	BATfakeCommit(bm->bat_lbid);
}

void bm_abort( bm * bm, int tid )
{
	BUN p,q;
	BAT *b;

	/* remove the created bats */
 	b = bm->bat_bid;
	for (p = b->batInserted; p < BUNlast(b); p = BUNnext(b, p)){
		bat bid = *(oid*)BUNtail(b,p);
		BBPtransient(bid, FALSE);
	}
	b = bm->bat_version;
	BATloop(b, p, q){
	    	int version = *(int*)BUNtail(b,p);
	    	if (tid == version){
	    		oid id = *(oid*)BUNhead(b,p);
			bat bid = *(oid*)BUNtail(bm->bat_bid,
					BUNfnd(bm->bat_bid,&id));
			BAT *b = bat_descriptor(bid);
			BATundo(b);
			BATfakeCommit(b);
			BBPunfix(b->batCacheid);
	    	}
	}
	BATundo(bm->bat_version);
	BATundo(bm->bat_name);
	BATundo(bm->bat_bid);
	BATundo(bm->bat_lbid);
}
 
oid bm_name2lbid(bm *bm, char *name)
{
	BAT *r_bat_name = BATmirror(bm->bat_name);
	oid res = 0;
	ptr p = BUNfnd(r_bat_name, name);
	if (p){
		ptr q = BUNfnd(bm->bat_lbid, BUNtail(r_bat_name, p));
		res = *(oid*)BUNtail(bm->bat_lbid, q);
	}
	return res;
}

oid bm_lbid2vid(bm *bm, oid lbid)
{
	BAT *r_bat_lbid = BATmirror(bm->bat_lbid);
	oid res = 0;
	ptr p = BUNfnd(r_bat_lbid, &lbid);

	if (p) {
		res = *(oid*)BUNtail(r_bat_lbid, p);
	}
	return res;
}

char *bm_lbid2name(bm *bm, oid lbid)
{
	oid vid = bm_lbid2vid(bm, lbid);
	return BUNtail(bm->bat_name, BUNfnd(bm->bat_name, &vid));
}

void bm_new_version(bm *bm, oid lbid, int version )
{
	oid vid = bm_lbid2vid(bm, lbid);
	BUNreplace(bm->bat_version, (ptr)&vid, &version);

	if (version > bm->version)
		bm->version = version;
}

void bm_new_bat(bm *bm, oid lbid, oid bid )
{
	oid vid = bm_lbid2vid(bm, lbid);
	bat obid = *(oid*)BUNtail(bm->bat_bid, BUNfnd(bm->bat_bid, &vid));
	BBPtransient(obid, FALSE);
	BBPpersistent(bid, FALSE);
	BUNreplace(bm->bat_bid, (ptr)&vid, &bid);
}

oid bm_add_bat(bm *bm, oid bid, char *name, int version)
{
	oid lbid = bm_find_bat(bm, name);
	if (!lbid){
		lbid = bm->lbid++;
		bm_add_bat_intern(bm, lbid, bid, name, version);
	} else if (lbid > bm->lbid){
		bm->lbid = lbid+1;
	}
	if (version > bm->version)
		bm->version = version;
	return lbid;
}

void bm_del_bat(bm *bm, oid lbid)
{
	oid vid = bm_lbid2vid(bm, lbid);
	BUNdelHead(bm->bat_version, &vid);
	BUNdelHead(bm->bat_name, &vid);
	BUNdelHead(bm->bat_bid, &vid);
	BUNdelHead(bm->bat_lbid, &vid);
	if (bm->bat_oversion)
		BUNdelHead(bm->bat_oversion, &vid);
	/* no BBPtransient(bid, FALSE); here as this is needs to be done 
	 *  by the bm_{commit,abort} */
}

oid bm_find_bat(bm* bm, char *name)
{
	return bm_name2lbid(bm, name);
}

BAT* bm_lbid2bat(bm *bm, oid lbid)
{
	BAT *b;
	bat bid;
	oid vid;

	vid = bm_lbid2vid(bm, lbid);
	
	bid = *(oid*)BUNtail(bm->bat_bid, BUNfnd(bm->bat_bid, &vid)); 
	b = bat_descriptor(bid);
	return b;
}

int bm_lbid2version(bm *bm, oid lbid)
{
	oid vid = bm_lbid2vid(bm, lbid);
	return *(int*)BUNtail(bm->bat_version, BUNfnd(bm->bat_version, &vid));
}

int bm_version(bm *bm){
	return bm->version;
}
