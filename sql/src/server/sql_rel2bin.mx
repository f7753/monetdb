@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@' 
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@' 
@' The Original Code is the Monet Database System.
@' 
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2004 CWI.
@' All Rights Reserved.
@' 
@' Contributor(s):
@' 		Martin Kersten <Martin.Kersten@cwi.nl>
@' 		Peter Boncz <Peter.Boncz@cwi.nl>
@' 		Niels Nes <Niels.Nes@cwi.nl>
@' 		Stefan Manegold  <Stefan.Manegold@cwi.nl>

@f sql_rel2bin
@a S. Manegold
@* 

@h

#ifndef _SQL_REL2BIN_H
#define _SQL_REL2BIN_H

#include "sql_statement.h"
#include "sql_types.h"

sql_export stmt *rel2bin( mvc *c, stmt *s );

#endif /* _SQL_REL2BIN_H */

@c

#include "sql_rel2bin.h"
#include "sql_env.h"
#include <stdio.h>

static stmt *head_column(stmt * st);

static stmt *tail_column(stmt * st)
{
	switch (st->type) {
	case st_join:
	case st_outerjoin:
	case st_intersect:
	case st_find:
		return tail_column(st->op2.stval);

	case st_reljoin:
		return tail_column(st->op2.lval->h->data);

	case st_const:

	case st_filter:
	case st_select:
	case st_select2:
	case st_uselect:
	case st_uselect2:
	case st_semijoin:

	case st_diff:
	case st_union:

	case st_append:
	case st_insert:
	case st_replace:

	case st_unique:
	case st_unop:
	case st_binop:
	case st_Nop:
	case st_aggr:

	case st_alias:

	case st_pivot:

		return tail_column(st->op1.stval);

	case st_column_alias:
	case st_ibat:
	case st_bat:
		return st;

	case st_mirror:
	case st_reverse:
		return head_column(st->op1.stval);
	case st_list:
		return tail_column(st->op1.lval->h->data);

	/* required for shrink_select_ranges() in sql_rel2bin.mx */
	case st_idxbat: 

	/* required for eliminate_semijoin() in sql_rel2bin.mx */
	case st_relselect: 

	/* some statements have no column coming from any basetable */
	case st_atom:
	case st_var:
	case st_mark:
	case st_derive:
	case st_group_ext:
	case st_group:	
	case st_predicate:	/* 1 = 1 is not a column */
	case st_basetable: 	/* a table is not a column */
	case st_ptable:
		return NULL;

	default:
		fprintf(stderr, "missing tail column %d: %s\n", st->type, st_type2string(st->type) );
		assert(0);
		return NULL;
	}
}

static stmt *head_column(stmt * st)
{
	switch (st->type) {
	case st_const:
	case st_mark:
	case st_mirror:

	case st_filter:
	case st_select:
	case st_select2:
	case st_uselect:
	case st_uselect2:
	case st_semijoin:

	case st_join:
	case st_outerjoin:
	case st_diff:
	case st_intersect:
	case st_union:

	case st_append:
	case st_insert:
	case st_replace:

	case st_group_ext:
	case st_group:
	case st_unique:
	case st_unop:
	case st_binop:
	case st_Nop:
	case st_aggr:

	case st_alias:

	case st_pivot:

		return head_column(st->op1.stval);

	case st_relselect:
	case st_reljoin:
		return head_column(st->op1.lval->h->data);

	case st_column_alias:
	case st_ibat:
	case st_bat:
		return st;

	case st_reverse:
		return tail_column(st->op1.stval);

	case st_derive:
		return tail_column(st->op2.stval);

	case st_list:
		return head_column(st->op1.lval->h->data);

	/* required for eliminate_semijoin() in sql_rel2bin.mx */
	/* st_temp has no head column coming from any basetable */
	case st_atom:
	case st_var:
	case st_basetable:
	case st_temp: 
	case st_predicate:
	case st_op:
	case st_ptable:
	case st_groupby:
		return NULL;

	/* stmts without head column which also are not expected */
	case st_none:
	case st_sql:

	case st_ubat:
	case st_dbat:
	case st_idxbat:

	case st_limit:
	case st_order:
	case st_reorder:

	case st_ordered:
	case st_output:

	case st_find:
	case st_bulkinsert:

	case st_exception:

	case st_set:
	case st_sets:
		fprintf(stderr, "missing head column %d: %s\n", st->type, st_type2string(st->type) );
		assert(0);
		return NULL;
	}
	return NULL;
}

static sql_column *basecolumn(stmt * st)
{
	if (!st) return NULL; /* required for shrink_select_ranges() and eliminate_semijoin() in sql_rel2bin.mx */
	switch (st->type) {
	case st_reverse:
		return basecolumn(head_column(st->op1.stval));

	case st_pivot:
		return basecolumn(st->op1.stval);
	case st_bat:
		return st->op1.cval;

	case st_column_alias: /* required to avoid cyclic calls */
		printf("= TODO: basecolumn(%d=%s) -> NULL !?\n",
			st->type, st_type2string(st->type) );
	/* intermediate bat (result of view etc) has no direct base column */
	case st_ibat:
		return NULL;

	default:
		return basecolumn(tail_column(st));
	}
}


static int cmp_sel2( stmt *sel, st_type *tpe )
{
	(void) tpe; /* Stefan: unsed, but required for list_select() / type fcmp() */
	if (sel->type == st_select2 || sel->type == st_uselect2){
		return 0;
	}
	return -1;
}

static int cmp_sel_oneCol( stmt *sel )
{
	int rtrn = -1;
	if (sel->type >= st_select && sel->type <= st_uselect2) {
		if (sel->op2.stval->nrcols == 0){
			rtrn = 0;
		}
	} else {
		if (sel->type == st_reverse) {
			printf("= TODO: sql_rel2bin: shrink_select_ranges: handle %s(%s)!\n", st_type2string(sel->type), st_type2string(sel->op1.stval->type));
		} else {
			printf("= TODO: sql_rel2bin: shrink_select_ranges: handle %s!\n", st_type2string(sel->type));
		}
	}
	return rtrn;
}

static int cmp_sel_twoCol( stmt *sel )
{
	return !cmp_sel_oneCol(sel);
}

static int cmp_sel_hasNoBasecol( stmt *sel )
{
	int rtrn = -1;
	if (basecolumn(sel) == NULL){
		rtrn = 0;
	}
	return rtrn;
}

static int cmp_sel_hasBasecol( stmt *sel )
{
	int rtrn = -1;
	if (basecolumn(sel) != NULL){
		rtrn = 0;
	}
	return rtrn;
}

static int cmp_sel_basecol( stmt *sel, stmt *key )
{
	if (basecolumn(key) == basecolumn(sel)){
		return 0;
	}
	return -1;
}

static int cmp_sel_val( stmt *sel, stmt *key )
{
	if (sel->op2.stval == key->op2.stval){
		return 0;
	}
	return -1;
}

static int cmp_sel_comp_type( stmt *sel, comp_type *flg )
{
	if ((sel->type == st_select || sel->type == st_uselect) && (comp_type)sel->flag == *flg){
		return 0;
	}
	return -1;
}

static stmt* stmt_min(stmt *x, stmt *y)
{
	sql_subtype *t;
	sql_subfunc *f;
	assert(x->nrcols == 0);
	assert(y->nrcols == 0);
	t = tail_type(x);
	assert(t);
/*	assert(t == tail_type(y));	*/
	f = sql_bind_func_result("sql_min", t, t, t);
	assert(f);
	return stmt_binop( x, y, f );
}

static stmt* stmt_max(stmt *x, stmt *y)
{
	sql_subtype *t;
	sql_subfunc *f;
	assert(x->nrcols == 0);
	assert(y->nrcols == 0);
	t = tail_type(x);
	assert(t);
/*	assert(t == tail_type(y));	*/
	f = sql_bind_func_result("sql_max", t, t, t);
	assert(f);
	return stmt_binop( x, y, f );
}

stmt *stmt_uselect_select(stmt * s)
{
	assert(s->type == st_uselect2 || 
	       (s->type == st_uselect && !s->op2.stval->nrcols));
	if (s->type == st_uselect2)
		s->type = st_select2;
	else
		s->type = st_select;
	assert(!s->t);
	s->t = stmt_dup(s->op1.stval->t);
	return s;
}


list *shrink_select_ranges(list *oldsels)
{
	/* find minimal ranges for selects per column on one table */

	list *newsels, *haveNoBasecol, *haveBasecol, *basecols, *oneColSels, *twoColSels;
	node *bc;
	
	newsels  = list_create((fdestroy)&stmt_destroy);

	/* we skip selects that involve two columns, e.g., R.a < R.b, here */
	twoColSels = list_select( oldsels, (void*)1L, (fcmp)&cmp_sel_twoCol, (fdup)&stmt_dup );
	oneColSels = list_select( oldsels, (void*)1L, (fcmp)&cmp_sel_oneCol, (fdup)&stmt_dup );
	assert(list_length(twoColSels)+list_length(oneColSels)==list_length(oldsels));
        list_destroy(oldsels);

	/* some statments (e.g., st_idxbat when checking key constraints during inserts)
	   don't seem to have a basecolumn, hence, we skip them, here */
	haveNoBasecol = list_select( oneColSels, (void*)1L, (fcmp)&cmp_sel_hasNoBasecol, (fdup)&stmt_dup );
	haveBasecol   = list_select( oneColSels, (void*)1L, (fcmp)&cmp_sel_hasBasecol,   (fdup)&stmt_dup );  
	assert(list_length(haveNoBasecol)+list_length(haveBasecol)==list_length(oneColSels));
	list_destroy(oneColSels);

	basecols = list_distinct( haveBasecol, (fcmp)&cmp_sel_basecol, (fdup)&stmt_dup );
	for ( bc = basecols->h; bc; bc = bc->next ){
		list *colsels = list_select( haveBasecol, bc->data, (fcmp)&cmp_sel_basecol, (fdup)&stmt_dup );
		sql_subtype *tt = tail_type(((stmt*)(colsels->h->data))->op2.stval);
		assert(tt);
		if ( list_length(colsels) == 1 ){
			/* only one select on this column; simply keep it. */
			list_append( newsels, stmt_dup(colsels->h->data) );
		} else if ( !sql_bind_func_result("sql_min", tt, tt, tt) || !sql_bind_func_result("sql_max", tt, tt, tt) ) {
			/* no "min" and/or "max" available on this data type, hence, we cannot apply the following "tricks" */
			list_merge( newsels, colsels, (fdup)&stmt_dup );
		} else {
			list *sels2, *sels1[cmp_all];
			stmt *bound[4] = {NULL, NULL, NULL, NULL};
			stmt *col[4] = {NULL, NULL, NULL, NULL};
			comp_type ct;
			node *n;
			int flg, len = 0;
			
			/* separate all single-range, equal, notequal, notlike, & like selects and eliminate duplicates
			 * (notequal, notlike, & like selects are saved and re-added at the end) */
			for ( ct = cmp_gt; ct < cmp_all; ct++ ){
				list *l = list_select( colsels, (void*)&ct, (fcmp)&cmp_sel_comp_type, (fdup)&stmt_dup );
				len += list_length(l);
				sels1[ct] = list_distinct( l, (fcmp)&cmp_sel_val, (fdup)&stmt_dup );
				list_destroy(l);
			}
			/* separate all double-sided range selects */
			sels2 = list_select( colsels, (void*)1L, (fcmp)&cmp_sel2, (fdup)&stmt_dup );
			len += list_length(sels2);

			/* make sure we didn't miss anything */
			assert(len == list_length(colsels));

			/* split-up each double-sided range select in two single-sided ones
			 * (x<[=]a<[=]y  =>  a>[=]x && a<[=]y) to find the minimal ranges below */
			for ( n = sels2->h; n; n = n->next ){
				stmt *sl, *sr, *s = n->data;
				comp_type cl=cmp_all, cr=cmp_all; /* invalid values; just to pacify compilers */

				switch(s->flag){
				case 0: cl=cmp_gt;  cr=cmp_lt;  break;
				case 1: cl=cmp_gt;  cr=cmp_lte; break;
				case 2: cl=cmp_gte; cr=cmp_lt;  break;
				case 3: cl=cmp_gte; cr=cmp_lte; break;
				default: assert(0);
				}
				sl = stmt_uselect(stmt_dup(s->op1.stval), stmt_dup(s->op2.stval), cl);
				sr = stmt_uselect(stmt_dup(s->op1.stval), stmt_dup(s->op3.stval), cr);
				list_append( sels1[cl], sl );
				list_append( sels1[cr], sr );
			}
			list_destroy(sels2);

			/* split-up each equal (point) select in two single-sided ones
			 * (a=x  =>  a>=x && a<=x) to find the minimal ranges below */
			/*
			 * in the "worst case", this gets later re-combined to
			 * 	x<=a<=x   which is identical to   a=x
			 *
			 * in case there are other equal (point) or range selects,
			 * this improves optimization, especially empty selections
			 * are detected instantly, e.g.:
			 *	a=x && a=y
			 *  =>	a>=x && a<=x && a>=y && a<=y
			 *  =>	a>=max(x,y) && a<=min(x,y)
			 *  =>  max(x,y)<=a<=min(x,y)
			 * or
			 *	a=x && a<=y
			 *  =>	a>=x && a<=x && a<=y
			 *  =>	a>=x && a<=min(x,y)
			 *  =>	x<=a<=min(x,y)
			 *
			 * in both cases we end up with just a single select
			 * instead of two selects plus a semijoin
			 */
			for ( n = sels1[cmp_equal]->h; n; n = n->next ){
				stmt *sl, *sr, *s = n->data;

				sl = stmt_uselect(stmt_dup(s->op1.stval), stmt_dup(s->op2.stval), cmp_gte);
				sr = stmt_uselect(stmt_dup(s->op1.stval), stmt_dup(s->op2.stval), cmp_lte);
				list_append( sels1[cmp_gte], sl );
				list_append( sels1[cmp_lte], sr );
			}
			list_destroy(sels1[cmp_equal]);

			/* minimize all single-sided range selects */
			/*
			 * while
			 *	1) a< x && a< y  =>  a <  min(x,y)
			 *	2) a<=x && a<=y  =>  a <= min(x,y)
			 *	3) a> x && a> y  =>  a >  max(x,y)
			 *	4) a>=x && a>=y  =>  a >= max(x,y)
			 * we cannot do similar simple stuff for
			 *	5) a < x && a <= y
			 * and
			 * 	6) a > x && a >= y
			 * TODO:
			 * for the latter two cases, produce code like
			 * 	5: if (x<=y) { a < x } else { a <= y }
			 * 	6: if (x>=y) { a > x } else { a >= y }
			 */
			for ( ct = cmp_gt; ct <= cmp_lt; ct++ ){
				if ( list_length(sels1[ct]) > 0 ){
					col[ct] = stmt_dup( ((stmt*)(sels1[ct]->h->data))->op1.stval );
				}
				if ( list_length(sels1[ct]) == 1 ){
					bound[ct] = stmt_dup( ((stmt*)(sels1[ct]->h->data))->op2.stval );
				}
				if ( list_length(sels1[ct]) > 1 ){
					list *bnds = list_create((fdestroy)&stmt_destroy);
					for ( n = sels1[ct]->h; n; n = n->next ){
						list_append( bnds, stmt_dup( ((stmt*)(n->data))->op2.stval ) );
					}
					if (ct <= cmp_gte)
						bound[ct] = (stmt*)list_reduce( bnds, (freduce)&stmt_max, (fdup)&stmt_dup );
					else
						bound[ct] = (stmt*)list_reduce( bnds, (freduce)&stmt_min, (fdup)&stmt_dup );
					list_destroy(bnds);
				}
				list_destroy(sels1[ct]);
			}
			
			/* pairwise (re-)combine single-sided range selects to double-sided range selects */
			/*
			 * 	0) a> x && a< y  =>  x< a< y
			 * 	1) a> x && a<=y  =>  x< a<=y
			 * 	2) a>=x && a< y  =>  x<=a< y
			 * 	3) a>=x && a<=y  =>  x<=a<=y
			 */
			for ( flg = 0; flg <= 3; flg++ ){
				comp_type cl=cmp_all, cr=cmp_all; /* invalid values; just to pacify compilers */
				
				switch(flg){
				case 0: cl=cmp_gt;  cr=cmp_lt;  break;
				case 1: cl=cmp_gt;  cr=cmp_lte; break;
				case 2: cl=cmp_gte; cr=cmp_lt;  break;
				case 3: cl=cmp_gte; cr=cmp_lte; break;
                                default: assert(0);
				}
				if (bound[cl] && bound[cr]) {
					list_append( newsels, stmt_uselect2( stmt_dup(col[cl]), bound[cl], bound[cr], flg ) );
					bound[cl] = bound[cr] = NULL;
				}
			}
			
			/* collect remaining single-sided range selects that haven't found a partner */
			for ( ct = cmp_gt; ct <= cmp_lt; ct++ ){
				if (bound[ct]) {
					list_append( newsels, stmt_uselect( stmt_dup(col[ct]), bound[ct], ct ) );
				}
				if (col[ct]) {
					stmt_destroy(col[ct]);
				}
			}	

			/* finally collect all saved like, notlike, and notequal selects */
			for ( ct = cmp_like; ct >= cmp_notequal; ct-- ) {
				list_merge( newsels, sels1[ct], (fdup)&stmt_dup );
				list_destroy(sels1[ct]);
			}
		}
		list_destroy(colsels);
	}
	/* re-add the skipped statements without basecolumn */
	list_merge( newsels, haveNoBasecol, (fdup)&stmt_dup );
	/* re-add the skipped two-column selects */
	list_merge( newsels, twoColSels, (fdup)&stmt_dup );

	list_destroy(twoColSels);
	list_destroy(haveNoBasecol);
	list_destroy(haveBasecol);
	list_destroy(basecols);

	return newsels;
}

#define PSEL(s) ((s->type == st_select || s->type == st_uselect) && !s->op2.stval->nrcols)
#define RSEL(s) (s->type == st_select2 || s->type == st_uselect2)
#define USEL(s) (s->type == st_uselect || s->type == st_uselect2)

stmt *eliminate_semijoin(stmt *s)
{
	stmt *s1, *s2;
	sql_column *bc1, *bc2;

	assert(s->type == st_semijoin);
	s1 = s->op1.stval;
	s2 = s->op2.stval;
	bc1 = basecolumn(s1);
	bc2 = basecolumn(s2);
	if (bc1 && bc1 == bc2) {
		int match1 = (PSEL(s1) || RSEL(s1));
		int match2 = (PSEL(s2) || RSEL(s2));
		if (match1 && match2) {
			/* semijoin( select(x,..), select(x,..) ) */
			int swap = 0;
			if (PSEL(s1) && s1->flag == cmp_equal) {
				/* do point select first */
				swap = 0;
			} else if (PSEL(s2) && s2->flag == cmp_equal) {
				/* do point select first */
				swap = 1;
			} else if (PSEL(s2) && s2->flag == cmp_notequal) {
				/* do notequal select last */
				swap = 0;
			} else if (PSEL(s1) && s1->flag == cmp_notequal) {
				/* do notequal select last */
				swap = 1;
			} else if (PSEL(s2) && s2->flag == cmp_notlike) {
				/* do notequal select last */
				swap = 0;
			} else if (PSEL(s1) && s1->flag == cmp_notlike) {
				/* do notequal select last */
				swap = 1;
			} else if (PSEL(s2) && s2->flag == cmp_like) {
				/* do like select last */
				swap = 0;
			} else if (PSEL(s1) && s1->flag == cmp_like) {
				/* do like select last */
				swap = 1;
			} else if (PSEL(s1)) {
				/* single-sided range before double-sided range */
				swap = 0;
			} else if (PSEL(s2)) {
				/* single-sided range before double-sided range */
				swap = 1;
			}
			if (swap) {
				stmt *os;
				os = s1; s1 = s2; s2 = os;
			}
			if (USEL(s1)) {
				/* uselect => select  to keep tail for s2 */
				s1 = stmt_uselect_select(s1);
			}
		} else if (match1) {
			/* semijoin( select(x,..), f(x) )  =>  semijoin( f(x), select(x,..) ) */
			stmt *os;
			int m;
			m = match1; match1 = match2; match2 = m;
			os = s1; s1 = s2; s2 = os;
		}
		if (match2) {
			/* semijoin( f(x), select(x,..) )  =>  select( f(x), .. ) */
			stmt *ns = NULL;
			switch(s2->type){
			case st_select:
			case st_uselect:
				/* uselect => select  as semijoin also propagates the left input's tail */
				ns = stmt_select(stmt_dup(s1), stmt_dup(s2->op2.stval), (comp_type)s2->flag);
				break;
			case st_select2:
			case st_uselect2:
				/* uselect => select  as semijoin also propagates the left input's tail */
				ns = stmt_select2(stmt_dup(s1), stmt_dup(s2->op2.stval), stmt_dup(s2->op3.stval), s2->flag);
				break;
			default:
				/* pacify compiler; should never be reached. */
				assert(0);
			}
			return ns;
		}
	}
	return stmt_dup(s);
}
 
stmt *eliminate_reverse(stmt *s)
{
	stmt *os = s->op1.stval, *ns;

	assert(s->type == st_reverse);
	switch (os->type){
	case st_reverse:
		/* reverse(reverse(x)) => x */
		ns = os->op1.stval; break;
	case st_mirror:
		/* reverse(mirror(x)) => mirror(x) */
		ns = os; break;
	default:
		ns = s;
	}
	return stmt_dup(ns);
}


stmt *rel2bin( mvc *c, stmt *s )
{
	assert(!(s->optimized < 2 && s->rewritten));
	if (s->optimized >= 2) {
		if (s->rewritten) 
			return stmt_dup(s->rewritten);
		else
			return stmt_dup(s);
	}

	switch(s->type){
	/* first just return those statements which we cannot optimize,
	 * such as schema manipulation, transaction managment, 
	 * and user authentication.
	 */
	case st_none: 
	case st_sql: 
	case st_dbat: case st_basetable: case st_idxbat:

	case st_atom: 
	case st_find: 
	case st_bulkinsert: 
	case st_var:

		s->optimized = 2;
		return stmt_dup(s);

	case st_reljoin: {

		list *l1 = create_stmt_list();
		list *l2 = create_stmt_list();
		node *n1, *n2;
		stmt *res;

		for(n1 = s->op1.lval->h, n2 = s->op2.lval->h; n1 && n2; n1 = n1->next, n2 = n2->next ){
			list_append(l1, rel2bin(c, n1->data));
			list_append(l2, rel2bin(c, n2->data));
		}
		res = stmt_reljoin2(l1, l2);
		s->optimized = res->optimized = 2;
		if (res != s) {
			s->rewritten = stmt_dup(res);
		}
		return res;
	}

	case st_relselect: {

		stmt *res;
		node *n;
		list * l = create_stmt_list();

		for(n = s->op1.lval->h; n; n = n->next ){
			list_append(l, rel2bin(c, n->data));
		}
		if (list_length(l) == 1){
			res = stmt_dup(l->h->data);
		} else {
			if (!mvc_debug_on(c,4096)) {
				l = shrink_select_ranges(l);
			}
			res = (stmt*)list_reduce(l, (freduce)&stmt_semijoin, (fdup)&stmt_dup );
		}
		list_destroy(l);
		s->optimized = res->optimized = 2;
		if (res != s) {
			s->rewritten = stmt_dup(res);
		}
		return res;
	}

	case st_semijoin: {
	
		stmt *os, *ns;

		os = stmt_semijoin(
			rel2bin(c, s->op1.stval),
			rel2bin(c, s->op2.stval));
		if (!mvc_debug_on(c,4096) && os->nrcols) {
			ns = eliminate_semijoin(os);
		} else {
			ns = stmt_dup(os);
		}
		stmt_destroy(os);
		s->optimized = ns->optimized = 2;
		if (ns != s) {
			s->rewritten = stmt_dup(ns);
		}
		return ns;
	}

	case st_reverse: {
	
		stmt *os, *ns;

		os = stmt_reverse(rel2bin(c, s->op1.stval));
		if (!mvc_debug_on(c,4096)) {
			ns = eliminate_reverse(os);
		} else {
			ns = stmt_dup(os);
		}
		stmt_destroy(os);
		s->optimized = ns->optimized = 2;
		if (ns != s) {
			s->rewritten = stmt_dup(ns);
		}
		return ns;
	}

	case st_temp:
	case st_filter: 
	case st_select: case st_select2: 
	case st_uselect: case st_uselect2: 
	case st_diff: case st_intersect: case st_union: case st_outerjoin:
	case st_join: 
	case st_mirror: case st_const: case st_mark: 
	case st_group: case st_group_ext: case st_derive: case st_unique: 
	case st_limit: case st_order: case st_reorder: case st_ordered: 

	case st_alias: case st_column_alias: 
	case st_ibat: 
	case st_output: 
	case st_append: case st_insert: case st_replace: 
	case st_exception: case st_predicate:

	case st_aggr: 
	case st_op: case st_unop: case st_binop: case st_Nop:

		if (s->op1.stval){
			stmt *os, *ns;
			os = s->op1.stval;
		       	ns = rel2bin(c, os);
			assert(ns != s);
			stmt_destroy(os);
			s->op1.stval = ns;
		}
		if (s->op2.stval){
			stmt *os = s->op2.stval;
		       	stmt *ns = rel2bin(c, os);
			assert(ns != s);
			stmt_destroy(os);
			s->op2.stval = ns;
		}
		if (s->op3.stval){
			stmt *os = s->op3.stval;
		       	stmt *ns = rel2bin(c, os);
			assert(ns != s);
			stmt_destroy(os);
			s->op3.stval = ns;
		}
		s->optimized = 2;
		return stmt_dup(s);

	case st_list: {

		stmt *res = NULL;
		node *n;
		list *l = s->op1.lval;
		list *nl = NULL;

		nl = create_stmt_list();
		for(n = l->h; n; n = n->next ){
			stmt *ns = rel2bin(c, n->data);
			list_append(nl, ns);
		}
		res = stmt_list(nl);
		s->optimized = res->optimized = 2;
		if (res != s) {
			s->rewritten = stmt_dup(res);
		}
		return res;
	} 

	case st_bat: case st_ubat: 

		s->optimized = 2;
		return stmt_dup(s);

	case st_pivot: 
	case st_ptable:
	case st_set: case st_sets: 
	default:
		assert(0); 	/* these should have been rewriten by now */
	}
	return stmt_dup(s);
}

