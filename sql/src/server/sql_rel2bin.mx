@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at 
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@' 
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@' 
@' The Original Code is the Monet Database System.
@' 
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2002 CWI.  
@' All Rights Reserved.
@' 
@' Contributor(s):
@' 		Martin Kersten <Martin.Kersten@cwi.nl>
@' 		Niels Nes <Niels.Nes@cwi.nl>
@' 		Stefan Manegold <Stefan.Manegold@cwi.nl>
@' 		Peter Boncz <Peter.Boncz@cwi.nl>

@f sql_rel2bin
@a S. Manegold
@* 

@h

#ifndef _SQL_REL2BIN_H
#define _SQL_REL2BIN_H

#include "sql_context.h"
#include "sql_statement.h"
#include "sql_types.h"

extern stmt *rel2bin( context *c, stmt *s );

#endif /* _SQL_REL2BIN_H */

@c

#include "sql_rel2bin.h"
#include <stdio.h>

static int cmp_sel_st_type( stmt *sel, st_type *tpe )
{
	if (sel->type == *tpe){
		return 0;
	}
	return -1;
}

static int cmp_sel_hasNoBasecol( stmt *sel )
{
	int rtrn = -1;
	if (basecolumn(sel) == NULL){
		rtrn = 0;
	}
	return rtrn;
}

static int cmp_sel_hasBasecol( stmt *sel )
{
	int rtrn = -1;
	if (basecolumn(sel) != NULL){
		rtrn = 0;
	}
	return rtrn;
}

static int cmp_sel_basecol( stmt *sel, stmt *key )
{
	if (basecolumn(key) == basecolumn(sel)){
		return 0;
	}
	return -1;
}

static int cmp_sel_val( stmt *sel, stmt *key )
{
	if (sel->op2.stval == key->op2.stval){
		return 0;
	}
	return -1;
}

static int cmp_sel_comp_type( stmt *sel, comp_type *flg )
{
	if (sel->type == st_select && sel->flag == *flg){
		return 0;
	}
	return -1;
}

static stmt* stmt_min(stmt *x, stmt *y)
{
	sql_subtype *t;
	sql_subfunc *f;
	assert(x->nrcols == 0);
	assert(y->nrcols == 0);
	t = tail_type(x);
	assert(t);
/*	assert(t == tail_type(y));	*/
	f = sql_bind_func_result("sql_min", t, t, t);
	assert(f);
	return stmt_binop( x, y, f );
}

static stmt* stmt_max(stmt *x, stmt *y)
{
	sql_subtype *t;
	sql_subfunc *f;
	assert(x->nrcols == 0);
	assert(y->nrcols == 0);
	t = tail_type(x);
	assert(t);
/*	assert(t == tail_type(y));	*/
	f = sql_bind_func_result("sql_max", t, t, t);
	assert(f);
	return stmt_binop( x, y, f );
}


@(
@' replaced by "shrink_select_ranges()"

stmt *range_select( stmt *s1, stmt *s2 )
{
	sql_column *c1, *c2;

	if (s1->type != s2->type || s1->type != st_select){
		return stmt_semijoin(stmt_dup(s1),stmt_dup(s2));
	}

	/* check if range optimization is possible */
	if (s1->flag >= cmp_equal || s2->flag >= cmp_equal)
		return stmt_semijoin(stmt_dup(s1),stmt_dup(s2));

	if (s1->flag > s2->flag) /* comp_type order is >,>=,<=,< */
		return range_select(s2, s1);

	if (s1->flag >= cmp_lte || s2->flag <= cmp_gte ) /* comp_type order is >,>=,<=,< */
		return stmt_semijoin(stmt_dup(s1),stmt_dup(s2));

	c1 = basecolumn(s1);
	c2 = basecolumn(s2);
	if (c1 == c2){
		int cmp1 = s1->flag;
		int cmp2 = s2->flag;
		int cmpX = -1;

		if (cmp1 == cmp_gt && cmp2 == cmp_lt){
			cmpX = 0;
		} else if (cmp1 == cmp_gt && cmp2 == cmp_lte){
			cmpX = 1;
		} else if (cmp1 == cmp_gte && cmp2 == cmp_lt){
			cmpX = 2;
		} else if (cmp1 == cmp_gte && cmp2 == cmp_lte){
			cmpX = 3;
		}
		return stmt_select2(
			stmt_dup(s1->op1.stval),
			stmt_dup(s1->op2.stval),
			stmt_dup(s2->op2.stval),
			cmpX);
	}
	return stmt_semijoin(stmt_dup(s1),stmt_dup(s2));
}

list *distill_range_selects(list *sels)
{
	node *n1, *n2;
	for ( n1 = sels->h; n1; n1 = n1->next){
		stmt *s1 = n1->data;
		if (s1->type == st_select && s1->flag < cmp_equal){
			for ( n2 = n1->next; n2; n2 = n2->next){
				stmt *s2 = n2->data;
				if (s2->type == st_select && s2->flag < cmp_equal
				     && basecolumn(s1) == basecolumn(s2)         ){
					stmt *rs = range_select(s1,s2);
					sels = list_prepend(sels,rs);
					n1 = list_remove_node(sels,n1);
					n2 = list_remove_node(sels,n2);
					break;
				}
			}
		}
	}
	return sels;
}
@)

list *shrink_select_ranges(list *oldsels)
{
	/* find minimal ranges for selects per column on one table */

	list *newsels, *haveNoBasecol, *haveBasecol, *basecols;
	node *bc;
	
	newsels  = list_create((fdestroy)&stmt_destroy);

	/* some statments (e.g., st_kbat when checking key constraints during inserts)
	   don't seem to have a basecolumn, hence, we skip them, here */
	haveNoBasecol = list_select( oldsels, (void*)1, (fcmp)&cmp_sel_hasNoBasecol, (fdup)&stmt_dup );
	haveBasecol   = list_select( oldsels, (void*)1, (fcmp)&cmp_sel_hasBasecol,   (fdup)&stmt_dup );  
	list_destroy(oldsels);

	basecols = list_distinct( haveBasecol, (fcmp)&cmp_sel_basecol, (fdup)&stmt_dup );
	for ( bc = basecols->h; bc; bc = bc->next ){
		list *colsels = list_select( haveBasecol, bc->data, (fcmp)&cmp_sel_basecol, (fdup)&stmt_dup );
		if ( list_length(colsels) == 1 ){
			/* only one select on this column; simply keep it. */
			list_append( newsels, stmt_dup(colsels->h->data) );
		} else {
			list *l1, *l2, *sels2, *sels1[cmp_all];
			stmt *bound[4] = {NULL, NULL, NULL, NULL};
			stmt *col[4] = {NULL, NULL, NULL, NULL};
			st_type ST_select2 = st_select2;
			comp_type ct;
			node *n;
			int flg, len = 0;
			
			/* separate all single-range, equal, not-equal, & like selects and eliminate duplicates
			 * (not-equal & like selects are saved and re-added at the end) */
			for ( ct = cmp_gt; ct < cmp_all; ct++ ){
				l1 = list_select( colsels, (void*)&ct, (fcmp)&cmp_sel_comp_type, (fdup)&stmt_dup );
				len += list_length(l1);
				sels1[ct] = list_distinct( l1, (fcmp)&cmp_sel_val, (fdup)&stmt_dup );
				list_destroy(l1);
			}
			/* separate all double-sided range selects */
			sels2 = list_select( colsels, (void*)&ST_select2, (fcmp)&cmp_sel_st_type, (fdup)&stmt_dup );
			len += list_length(sels2);

			/* make sure we didn't miss anything */
			assert(len == list_length(colsels));

			/* split-up each double-sided range select in two single-sided ones
			 * (x<[=]a<[=]y  =>  a>[=]x && a<[=]y) to find the minimal ranges below */
			for ( n = sels2->h; n; n = n->next ){
				stmt *sl, *sr, *s = n->data;
				comp_type cl, cr;

				switch(s->flag){
				case 0: cl=cmp_gt;  cr=cmp_lt;  break;
				case 1: cl=cmp_gt;  cr=cmp_lte; break;
				case 2: cl=cmp_gte; cr=cmp_lt;  break;
				case 3: cl=cmp_gte; cr=cmp_lte; break;
				}
				sl = stmt_select(stmt_dup(s->op1.stval), stmt_dup(s->op2.stval), cl);
				sr = stmt_select(stmt_dup(s->op1.stval), stmt_dup(s->op3.stval), cr);
				list_append( sels1[cl], sl );
				list_append( sels1[cr], sr );
			}
			list_destroy(sels2);

			/* split-up each equal (point) select in two single-sided ones
			 * (a=x  =>  a>=x && a<=x) to find the minimal ranges below */
			/*
			 * in the "worst case", this gets later re-combined to
			 * 	x<=a<=x   which is identical to   a=x
			 *
			 * in case there are other equal (point) or range selects,
			 * this improves optimization, especially empty selections
			 * are detected instantly, e.g.:
			 *	a=x && a=y
			 *  =>	a>=x && a<=x && a>=y && a<=y
			 *  =>	a>=max(x,y) && a<=min(x,y)
			 *  =>  max(x,y)<=a<=min(x,y)
			 * or
			 *	a=x && a<=y
			 *  =>	a>=x && a<=x && a<=y
			 *  =>	a>=x && a<=min(x,y)
			 *  =>	x<=a<=min(x,y)
			 *
			 * in both cases we end up with just a single select
			 * instead of two selects plus a semijoin
			 */
			for ( n = sels1[cmp_equal]->h; n; n = n->next ){
				stmt *sl, *sr, *s = n->data;

				sl = stmt_select(stmt_dup(s->op1.stval), stmt_dup(s->op2.stval), cmp_gte);
				sr = stmt_select(stmt_dup(s->op1.stval), stmt_dup(s->op2.stval), cmp_lte);
				list_append( sels1[cmp_gte], sl );
				list_append( sels1[cmp_lte], sr );
			}
			list_destroy(sels1[cmp_equal]);

			/* minimize all single-sided range selects */
			/*
			 * while
			 *	1) a< x && a< y  =>  a <  min(x,y)
			 *	2) a<=x && a<=y  =>  a <= min(x,y)
			 *	3) a> x && a> y  =>  a >  max(x,y)
			 *	4) a>=x && a>=y  =>  a >= max(x,y)
			 * we cannot do similar simple stuff for
			 *	5) a < x && a <= y
			 * and
			 * 	6) a > x && a >= y
			 * TODO:
			 * for the latter two cases, produce code like
			 * 	5: if (x<=y) { a < x } else { a <= y }
			 * 	6: if (x>=y) { a > x } else { a >= y }
			 */
			for ( ct = cmp_gt; ct <= cmp_lt; ct++ ){
				if ( list_length(sels1[ct]) > 0 ){
					col[ct] = stmt_dup( ((stmt*)(sels1[ct]->h->data))->op1.stval );
				}
				if ( list_length(sels1[ct]) == 1 ){
					bound[ct] = stmt_dup( ((stmt*)(sels1[ct]->h->data))->op2.stval );
				}
				if ( list_length(sels1[ct]) > 1 ){
					list *bnds = list_create((fdestroy)&stmt_destroy);
					for ( n = sels1[ct]->h; n; n = n->next ){
						list_append( bnds, stmt_dup( ((stmt*)(n->data))->op2.stval ) );
					}
					if (ct <= cmp_gte)
						bound[ct] = (stmt*)list_reduce( bnds, (freduce)&stmt_max, (fdup)&stmt_dup );
					else
						bound[ct] = (stmt*)list_reduce( bnds, (freduce)&stmt_min, (fdup)&stmt_dup );
					list_destroy(bnds);
				}
				list_destroy(sels1[ct]);
			}
			
			/* pairwise (re-)combine single-sided range selects to double-sided range selects */
			/*
			 * 	0) a> x && a< y  =>  x< a< y
			 * 	1) a> x && a<=y  =>  x< a<=y
			 * 	2) a>=x && a< y  =>  x<=a< y
			 * 	3) a>=x && a<=y  =>  x<=a<=y
			 */
			for ( flg = 0; flg <= 3; flg++ ){
				comp_type cl, cr;
				
				switch(flg){
				case 0: cl=cmp_gt;  cr=cmp_lt;  break;
				case 1: cl=cmp_gt;  cr=cmp_lte; break;
				case 2: cl=cmp_gte; cr=cmp_lt;  break;
				case 3: cl=cmp_gte; cr=cmp_lte; break;
				}
				if (bound[cl] && bound[cr]) {
					list_append( newsels, stmt_select2( stmt_dup(col[cl]), bound[cl], bound[cr], flg ) );
					bound[cl] = bound[cr] = NULL;
				}
			}
			
			/* collect remaining single-sided range selects that haven't found a partner */
			for ( ct = cmp_gt; ct <= cmp_lt; ct++ ){
				if (bound[ct]) {
					list_append( newsels, stmt_select( stmt_dup(col[ct]), bound[ct], ct ) );
				}
			}	

			/* finally collect all saved not-equal and like selects */
			list_merge( newsels, sels1[cmp_like], (fdup)&stmt_dup );
			list_merge( newsels, sels1[cmp_notequal], (fdup)&stmt_dup );

			list_destroy(sels1[cmp_notequal]);
			list_destroy(sels1[cmp_like]);
		}
		list_destroy(colsels);
	}
	/* re-add the skipped statements without basecolumn */
	list_merge( newsels, haveNoBasecol, (fdup)&stmt_dup );

	list_destroy(haveNoBasecol);
	list_destroy(haveBasecol);
	list_destroy(basecols);

	return newsels;
}


stmt *rel2bin( context *c, stmt *s )
{
	switch(s->type){
	/* first just return those statements which we cannot optimize,
	 * such as schema manipulation, transaction managment, 
	 * and user authentication.
	 */
	case st_none:
	case st_release: case st_commit: case st_rollback: 
	case st_schema: case st_table: case st_column: case st_key: 
	case st_create_schema: case st_drop_schema: 
	case st_create_view: case st_create_table: case st_drop_table: 
	case st_create_column: case st_null: case st_default: 
	case st_create_key: case st_create_kc:
	case st_create_role: case st_drop_role: 
	case st_grant_role: case st_revoke_role: 
	case st_grant: case st_revoke:

	case st_dbat: case st_obat: case st_basetable: case st_kbat:

	case st_atom: 
	case st_find: 
	case st_bulkinsert: case st_senddata: case st_export:
	case st_assign: case st_var:

		s->optimized = 2;
		return stmt_dup(s);

	case st_reljoin: {
		if (s->optimized > 1) 
			return stmt_dup(s);

	{	node *n1, *n2;

		for(n1 = s->op1.lval->h, n2 = s->op2.lval->h; n1 && n2; n1 = n1->next, n2 = n2->next ){
			stmt *nn1 = rel2bin(c, n1->data);
			stmt *nn2 = rel2bin(c, n2->data);

			stmt_destroy(n1->data);
			stmt_destroy(n2->data);
			n1->data = nn1;
			n2->data = nn2;
		}
		s->optimized = 2;
		return stmt_dup(s);
	}}

	case st_relselect: {
		if (s->optimized > 1) 
			return stmt_dup(s);

	{	stmt *res;
		node *n;
		list * l = create_stmt_list();

		for(n = s->op1.lval->h; n; n = n->next ){
			list_append(l, rel2bin(c, n->data));
		}
		if (list_length(l) == 1){
			res = stmt_dup(l->h->data);
@(
@' replaced by "shrink_select_ranges()"
		} else if (list_length(l) == 2){
			res = range_select(l->h->data, l->h->next->data);
@)
		} else {
@(
@' replaced by "shrink_select_ranges()"
			l = distill_range_selects(l);
@)
			if (!(c->debug&4096)) {
				l = shrink_select_ranges(l);
			}
			res = (stmt*)list_reduce(l, (freduce)&stmt_semijoin, (fdup)&stmt_dup );
		}
		list_destroy(l);

		res->optimized = 2;
		return res;
	}}

	case st_temp:
	case st_filter: 
	case st_select: case st_select2: case st_semijoin:
	case st_diff: case st_intersect: case st_union: case st_outerjoin:
	case st_join: 
	case st_mirror: case st_reverse: case st_const: case st_mark: 
	case st_group: case st_group_ext: case st_derive: case st_unique: 
	case st_limit: case st_order: case st_reorder: case st_ordered: 

	case st_alias: case st_column_alias: 
	case st_ibat: 
	case st_output: 
	case st_append: case st_insert: case st_replace: 
	case st_exception:

	case st_aggr: 
	case st_op: case st_unop: case st_binop: case st_Nop:

		if (s->optimized > 1) 
			return stmt_dup(s);

		if (s->op1.stval){
			stmt *os = s->op1.stval;
		       	stmt *ns = rel2bin(c, os);
			s->op1.stval = ns;
			stmt_destroy(os);
		}
		if (s->op2.stval){
			stmt *os = s->op2.stval;
		       	stmt *ns = rel2bin(c, os);
			s->op2.stval = ns;
			stmt_destroy(os);
		}
		if (s->op3.stval){
			stmt *os = s->op3.stval;
		       	stmt *ns = rel2bin(c, os);
			s->op3.stval = ns;
			stmt_destroy(os);
		}
		s->optimized = 2;
		return stmt_dup(s);

	case st_list: {
		stmt *res = NULL;
		node *n;
		list *l = s->op1.lval;
		list *nl = NULL;

		if (s->optimized > 1) 
			return stmt_dup(s);

		nl = create_stmt_list();
		for(n = l->h; n; n = n->next ){
			stmt *ns = rel2bin(c, n->data);
			list_append(nl, ns);
		}
		res = stmt_list(nl);
		res->optimized = 2;
		return res;
	} 

	case st_bat: case st_ubat: 
		s->optimized = 2;
		return stmt_dup(s);

	case st_pivot: 
	case st_partial_pivot:
	case st_ptable:
	case st_set: case st_sets: 
	default:
		assert(0); 	/* these should have been rewriten by now */
	}
	return stmt_dup(s);
}

