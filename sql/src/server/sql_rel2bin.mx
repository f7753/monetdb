@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at 
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@' 
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@' 
@' The Original Code is the Monet Database System.
@' 
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2002 CWI.  
@' All Rights Reserved.
@' 
@' Contributor(s):
@' 		Martin Kersten <Martin.Kersten@cwi.nl>
@' 		Niels Nes <Niels.Nes@cwi.nl>
@' 		Stefan Manegold <Stefan.Manegold@cwi.nl>
@' 		Peter Boncz <Peter.Boncz@cwi.nl>

@f sql_rel2bin
@a S. Manegold
@* 

@h

#ifndef _SQL_REL2BIN_H
#define _SQL_REL2BIN_H

#include "sql_context.h"
#include "sql_statement.h"

extern stmt *rel2bin( context *c, stmt *s );

#endif /* _SQL_REL2BIN_H */

@c

#include "sql_rel2bin.h"
#include <stdio.h>

stmt *range_select( stmt *s1, stmt *s2 )
{
	sql_column *c1, *c2;

	if (s1->type != s2->type || s1->type != st_select){
		return stmt_semijoin(stmt_dup(s1),stmt_dup(s2));
	}

	/* check if range optimization is possible */
	if (s1->flag >= cmp_equal || s2->flag >= cmp_equal)
		return stmt_semijoin(stmt_dup(s1),stmt_dup(s2));

	if (s1->flag > s2->flag) /* comp_type order is >,>=,<=,< */
		return range_select(s2, s1);

	c1 = basecolumn(s1);
	c2 = basecolumn(s2);
	if (c1 == c2){
		int cmp1 = s1->flag;
		int cmp2 = s2->flag;
		int cmpX = 0;

		if (cmp1 == cmp_gt && cmp2 == cmp_lt){
			cmpX = 0;
		} else if (cmp1 == cmp_gt && cmp2 == cmp_lte){
			cmpX = 1;
		} else if (cmp1 == cmp_gte && cmp2 == cmp_lt){
			cmpX = 2;
		} else if (cmp1 == cmp_gte && cmp2 == cmp_lte){
			cmpX = 3;
		}
		return stmt_select2(
			stmt_dup(s1->op1.stval),
			stmt_dup(s1->op2.stval),
			stmt_dup(s2->op2.stval),
			cmpX);
	}
	return stmt_semijoin(stmt_dup(s1),stmt_dup(s2));
}

list *distill_range_selects(list *l){
	node *n1, *n2;
	for ( n1 = l->h; n1; n1 = n1->next){
		stmt *s1 = n1->data;
		if (s1->type == st_select && s1->flag < cmp_equal){
			for ( n2 = n1->next; n2; n2 = n2->next){
				stmt *s2 = n2->data;
				if (s2->type == st_select && s2->flag < cmp_equal
				     && basecolumn(s1) == basecolumn(s2)         ){
					stmt *rs = range_select(s1,s2);
					l  = list_prepend(l,rs);
					n1 = list_remove_node(l,n1);
					n2 = list_remove_node(l,n2);
					break;
				}
			}
		}
	}
	return l;
}

stmt *rel2bin( context *c, stmt *s ){
	stmt *res = s;

	switch(s->type){
	/* first just return those statements which we cannot optimize,
	 * such as schema manipulation, transaction managment, 
	 * and user authentication.
	 */
	case st_none:
	case st_release: case st_commit: case st_rollback: 
	case st_schema: case st_table: case st_column: case st_key: 
	case st_create_schema: case st_drop_schema: 
	case st_create_view: case st_create_table: case st_drop_table: 
	case st_create_column: case st_null: case st_default: 
	case st_create_key: case st_create_kc:
	case st_create_role: case st_drop_role: 
	case st_grant_role: case st_revoke_role: 
	case st_grant: case st_revoke:

	case st_dbat: case st_obat: case st_basetable: case st_kbat:

	case st_atom: 
	case st_find: 
	case st_bulkinsert: case st_senddata: case st_export:
	case st_assign: case st_var:

		s->optimized = 2;
		return stmt_dup(s);

	case st_reljoin: {
		if (s->optimized > 1) 
			return stmt_dup(s);

	{	node *n1, *n2;

		for(n1 = s->op1.lval->h, n2 = s->op2.lval->h; n1 && n2; n1 = n1->next, n2 = n2->next ){
			stmt *nn1 = rel2bin(c, n1->data);
			stmt *nn2 = rel2bin(c, n2->data);

			stmt_destroy(n1->data);
			stmt_destroy(n2->data);
			n1->data = nn1;
			n2->data = nn2;
		}
		s->optimized = 2;
		return stmt_dup(s);
	}}

	case st_relselect: {
		if (s->optimized > 1) 
			return stmt_dup(s);

	{	stmt *res;
		node *n;
		list * l = create_stmt_list();

		for(n = s->op1.lval->h; n; n = n->next ){
			list_append(l, rel2bin(c, n->data));
		}
		if (list_length(l) == 1){
			res = stmt_dup(l->h->data);
		} else if (list_length(l) == 2){
			res = range_select(l->h->data, l->h->next->data);
		} else {
			l = distill_range_selects(l);
			res = (stmt*)list_reduce(l, (freduce)&stmt_semijoin, (fdup)&stmt_dup );
		}
		list_destroy(l);

		res->optimized = 2;
		return res;
	}}

	case st_temp:
	case st_filter: 
	case st_select: case st_select2: case st_like: case st_semijoin: 
	case st_diff: case st_intersect: case st_union: case st_outerjoin:
	case st_join: 
	case st_mirror: case st_reverse: case st_const: case st_mark: 
	case st_group: case st_group_ext: case st_derive: case st_unique: 
	case st_limit: case st_order: case st_reorder: case st_ordered: 

	case st_alias: case st_column_alias: 
	case st_ibat: 
	case st_output: 
	case st_append: case st_insert: case st_replace: 
	case st_exception:

	case st_aggr: 
	case st_op: case st_unop: case st_binop: case st_Nop:

		if (s->optimized > 1) 
			return stmt_dup(s);

		if (s->op1.stval){
			stmt *os = s->op1.stval;
		       	stmt *ns = rel2bin(c, os);
			s->op1.stval = ns;
			stmt_destroy(os);
		}
		if (s->op2.stval){
			stmt *os = s->op2.stval;
		       	stmt *ns = rel2bin(c, os);
			s->op2.stval = ns;
			stmt_destroy(os);
		}
		if (s->op3.stval){
			stmt *os = s->op3.stval;
		       	stmt *ns = rel2bin(c, os);
			s->op3.stval = ns;
			stmt_destroy(os);
		}
		s->optimized = 2;
		return stmt_dup(s);

	case st_list: {
		stmt *res = NULL;
		node *n;
		list *l = s->op1.lval;
		list *nl = NULL;

		if (s->optimized > 1) 
			return stmt_dup(s);

		nl = create_stmt_list();
		for(n = l->h; n; n = n->next ){
			stmt *ns = rel2bin(c, n->data);
			list_append(nl, ns);
		}
		res = stmt_list(nl);
		res->optimized = 2;
		return res;
	} 

	case st_bat: case st_ubat: 
		s->optimized = 2;
		return stmt_dup(s);

	case st_pivot: 
	case st_partial_pivot:
	case st_ptable:
	case st_set: case st_sets: 
		assert(0); 	/* these should have been rewriten by now */
	}
	return res;
}
