@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2005 CWI.
@' All Rights Reserved.

@f sql_atom
@a N.J. Nes
@* 

@h
#ifndef _SQL_ATOM_H_
#define _SQL_ATOM_H_

#include <sql_mem.h>
#include <sql_types.h>

typedef struct atom {
	int isnull;
	sql_subtype *tpe;
	ValRecord data;
} atom;

#define atom_null(a) a->isnull

extern atom *atom_int(sql_subtype * tpe, lng val);
extern atom *atom_string(sql_subtype * tpe, char *val);
extern atom *atom_float(sql_subtype * tpe, double val);
extern atom *atom_general(sql_subtype * tpe, char *val);

/* duplicate atom */
extern atom *atom_dup(atom * a);

extern char *atom2string(atom * a);
sql_export sql_subtype *atom_type(atom * a);

extern void atom_destroy(atom * a);

sql_export void atom_dump(atom *a, stream *s);
#endif	/* _SQL_ATOM_H_ */

@c
#include "sql_atom.h"
#include <sql_string.h>
#include <monettime.h>

static int atom_debug = 0;

atom *atom_create()
{
	atom *a = NEW(atom);
	memset(&a->data, 0, sizeof(a->data));
	return a;
}

atom *atom_int(sql_subtype * tpe, lng val)
{
	if (tpe->type->localtype == TYPE_dbl || tpe->type->localtype == TYPE_flt){
		return atom_float( tpe, (double)val);
	} else {
		atom *a = atom_create();
		a->isnull = 0;
		a->tpe = tpe;
		a->data.vtype = tpe->type->localtype;
		switch(ATOMstorage(a->data.vtype)){
		case TYPE_sht:
			a->data.val.shval = (sht)val;
			break;
		case TYPE_int:
			a->data.val.ival = (int)val;
			break;
		case TYPE_lng:
			a->data.val.lval = val;
			break;
		default:
			printf ("atom_int %d\n", a->data.vtype);
			assert(0);
		}
		a->data.len = 0;
		if (atom_debug)
			fprintf(stderr, "atom_int(%s,%lld)\n", tpe->type->sqlname, val);
		return a;
	}
	return NULL;
}

atom *atom_string(sql_subtype * tpe, char *val)
{
	atom *a = atom_create();
	a->isnull = 1;
	a->tpe = tpe;
	a->data.val.sval = NULL;
	a->data.vtype = TYPE_str;
	a->data.len = 0;
	if (val){
		a->isnull = 0;
		a->data.val.sval = val;
		a->data.len = strlen(a->data.val.sval); 
	}

	if (atom_debug) 
		fprintf(stderr, "atom_string(%s,%s)\n", tpe->type->sqlname,val);
	return a;
}

atom *atom_float(sql_subtype * tpe, double val)
{
	atom *a = atom_create();
	a->isnull = 0;
	a->tpe = tpe;
	a->data.val.dval = val;
	a->data.vtype = TYPE_dbl;
	a->data.len = 0;
	if (atom_debug)
		fprintf(stderr, "atom_float(%s,%f)\n", tpe->type->sqlname,val);
	return a;
}

atom *atom_general(sql_subtype * tpe, char *val)
{
	atom *a;
	ptr p = NULL;

	if (atom_debug)
		fprintf(stderr, "atom_general(%s,%s)\n", tpe->type->sqlname, val);

	if (tpe->type->localtype == TYPE_str)
		return atom_string(tpe, val);
	a = atom_create();
	a->isnull = 1;
	a->tpe = tpe;
	a->data.val.pval = NULL; 
	a->data.vtype = tpe->type->localtype;
	a->data.len = 0;

	assert(a->data.vtype >= 0);

	if (val) {
		int type = a->data.vtype;
		a->isnull = 0;
		if (ATOMstorage(type) == TYPE_str){
			a->isnull = 0;
			a->data.val.sval = sql2str(val);
			a->data.len = strlen(a->data.val.sval); 
		} else {
			int res = ATOMfromstr(type, &p, &a->data.len, val);
			/* no result or nil means error (SQL has NULL not nil)*/
			if (res <= 0 || !p ||
			    ATOMcmp(type, p, ATOMnilptr(type)) == 0) {
				_DELETE(val);
				_DELETE(a);
				if (p)
					GDKfree(p);
				return NULL;
			}
			VALset(&a->data, a->data.vtype, p);

			if (p && ATOMstorage(a->data.vtype) < TYPE_str) 
				GDKfree(p);
			_DELETE(val);
		}
	} else if (ATOMstorage(a->data.vtype) < TYPE_str){
		p = ATOMnilptr(a->data.vtype);
		VALset(&a->data, a->data.vtype, p);
	}
	return a;
}

void atom_destroy(atom * a)
{
	VALclear(&a->data);
	if (a->tpe) 
		sql_subtype_destroy(a->tpe);
	_DELETE(a);
}

char *atom2string(atom * a)
{
	char buf[1024];
	switch (a->data.vtype) {
	case TYPE_lng:
		sprintf(buf, "%lld", a->data.val.lval);
		break;
	case TYPE_int:
		sprintf(buf, "%d", a->data.val.ival);
		break;
	case TYPE_sht:
		sprintf(buf, "%d", a->data.val.shval);
		break;
	case TYPE_bit:
		if (a->data.val.cval[0])
			return _strdup("true");
		return _strdup("false");
	case TYPE_dbl:
		sprintf(buf, "%f", a->data.val.dval);
		break;
	case TYPE_str:
		if (a->data.val.sval)
			return _strdup(a->data.val.sval);
		else
			sprintf(buf, "NULL");
		break;
	}
	return _strdup(buf);
}

sql_subtype *atom_type(atom * a)
{
	return a->tpe;
}

atom *atom_dup(atom * a)
{
	atom *r = atom_create();
	*r = *a;
	r->tpe = sql_dup_subtype(a->tpe);
	if (!a->isnull)
		VALcopy(&r->data, &a->data);
	return r;
}

void atom_dump( atom *a, stream *s){
	if (!a->isnull && a->data.vtype == TYPE_str){
		ATOMprint(a->data.vtype, VALget(&a->data), s);
	} else if (!a->isnull && ATOMstorage(a->data.vtype) == TYPE_str){
		stream_write(s, a->tpe->type->base.name, strlen(a->tpe->type->base.name), 1);
		stream_write(s, "(", 1, 1);
		ATOMprint(a->data.vtype, VALget(&a->data), s);
		stream_write(s, ")", 1, 1);
	} else if (!a->isnull){
		stream_write(s, a->tpe->type->base.name, strlen(a->tpe->type->base.name), 1);
		stream_write(s, "(\"", 2, 1);
		ATOMprint(a->data.vtype, VALget(&a->data), s);
		stream_write(s, "\")", 2, 1);
	} else {
		stream_write(s, a->tpe->type->base.name, strlen(a->tpe->type->base.name), 1);
		stream_write(s, "(nil)", 5, 1);
	}
}

