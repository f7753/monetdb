@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@' 
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@' 
@' The Original Code is the Monet Database System.
@' 
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2004 CWI.
@' All Rights Reserved.
@' 
@' Contributor(s):
@' 		Martin Kersten <Martin.Kersten@cwi.nl>
@' 		Peter Boncz <Peter.Boncz@cwi.nl>
@' 		Niels Nes <Niels.Nes@cwi.nl>
@' 		Stefan Manegold  <Stefan.Manegold@cwi.nl>

@f sql_context
@a N.J. Nes
@* 

@* Context code

@h
#ifndef _SQL_CONTEXT_H_
#define _SQL_CONTEXT_H_

#include <sql_mem.h>
#include <stream.h>
#include "sql_statement.h"
#include "sql_qc.h"
#include "sql_mvc.h"

sql_export void cmd_init(mvc * c);
sql_export void cmd_add_token(mvc * c, char *token);
sql_export void cmd_add_string(mvc * c, char *str);

sql_export struct stmt *sql_symbol2stmt( mvc *c );

sql_export int sqlcleanup( mvc *c, char *cmd, int err);


#endif	/* _SQL_CONTEXT_H_ */

@c
#include "sql_context.h"
#include "sql_symbol.h"
#include "sql_scan.h"
#include "sql_semantic.h"
#include "sql_optimize.h"
#include "sql_rel2bin.h"
#include "sql_scope.h"
#include "sql_qc.h"
#include "sql_backend.h"

stmt *sql_symbol2stmt( mvc *c ){
	stmt *s = semantic(c, c->sym);
	if (s){
		stmt *opt = optimize(c, s);
		stmt_destroy(s);
		s = rel2bin(c, opt);
		stmt_destroy(opt);
	}
	return s;
}

int sqlcleanup( mvc *c, char *cmd, int err)
{
	sql_destroy_params(c);
	sql_destroy_args(c);
	if (cmd){
		/* beware to use free instead of _DELETE
 	 	 * as the stream library is build without 
	 	 * libbat ie. it cannot use gdkmalloc 
	 	 * can be used */
	        free(cmd);
	}
	if (c->sym) {
		symbol_destroy(c->sym);
		c->sym = NULL;
	}
	return err;
}

void cmd_init(mvc * m)
{
	struct scanner *c = &m->scanner;

	if (c->sql && m->debug & D__SQL)
		fprintf(stderr, "%s\n", c->sql);
	c->sql[0] = '\0';
	c->sqllen = 1;

	m->errstr[0] = '\0';
	c->key = 0;
}

/* add token + widthspace */
void cmd_add_token(mvc * m, char *token)
{
	struct scanner *c = &m->scanner;
	int len = strlen(token);

	if ((c->sqllen + len + 1) > c->sqlsize) {
		while( (c->sqllen + len + 1) > c->sqlsize)
			c->sqlsize *= 2;
		c->sql = RENEW_ARRAY(char, c->sql, c->sqlsize);
	}
	strncpy(c->sql + c->sqllen - 1, token, len);
	c->sqllen += len + 1;
	c->sql[c->sqllen - 2] = ' ';
	c->sql[c->sqllen - 1] = '\0';
}

/* add quoted string + widthspace */
void cmd_add_string(mvc * m, char *str)
{
	struct scanner *c = &m->scanner;
	int len = strlen(str);
	if ((c->sqllen + len + 3) > c->sqlsize) {
		while( (c->sqllen + len + 3) > c->sqlsize)
			c->sqlsize *= 2;
		c->sql = RENEW_ARRAY(char, c->sql, c->sqlsize);
	}
	c->sql[c->sqllen - 1] = '\'';
	strncpy(c->sql + c->sqllen, str, len);
	c->sqllen += len + 3;
	c->sql[c->sqllen - 3] = '\'';
	c->sql[c->sqllen - 2] = ' ';
	c->sql[c->sqllen - 1] = '\0';
}
