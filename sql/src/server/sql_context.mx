@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at 
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@' 
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@' 
@' The Original Code is the Monet Database System.
@' 
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2002 CWI.  
@' All Rights Reserved.
@' 
@' Contributor(s):
@' 		Martin Kersten <Martin.Kersten@cwi.nl>
@' 		Niels Nes <Niels.Nes@cwi.nl>
@' 		Stefan Manegold <Stefan.Manegold@cwi.nl>
@' 		Peter Boncz <Peter.Boncz@cwi.nl>

@f sql_context
@a N.J. Nes
@* 

@* Context code

This small module contains the code to instantiate an SQL client.
This code strongly depends on the front-end/back-end setup.

@h
#ifndef _SQL_CONTEXT_H_
#define _SQL_CONTEXT_H_

#include <mem.h>
#include <stream.h>
#include "sql_statement.h"
#include "sql_mvc.h"

#define ERRSIZE 1024

typedef struct context {
	int cur;
	int prev;	/* previous token lr(1) is to restrictive for SQL */

	int yyval;
	char *yytext;
	int yylen;
	int yysize;
	int debug;

	char *sql;
	int sqllen;
	int sqlsize;

	int lineno;
	char *filename;
	char *buf;
	stream *in;
	stream *out;

	int status; 	/* sql error code */
	char errstr[ERRSIZE];
	struct  mvc *mvc;

	char 	auth;	/* authorization */
	int 	authid; /* authorization id */

	list 	*params;
	struct symbol *sym;
} context;

sql_export void sql_init_context(context * c, stream * out, int debug, mvc *m);
sql_export void sql_exit_context(context * c);

sql_export stmt *sqlnext(context * c, stream * in, int *err);
sql_export stmt *sqlexecute(context * c, char *inbuf, int *err);

sql_export void cmd_init(context * c);
sql_export void cmd_add_token(context * c, char *token);
sql_export void cmd_add_string(context * c, char *str);


#endif	/* _SQL_CONTEXT_H_ */

@c

#include "sql_context.h"
#include "sql_symbol.h"
#include "sql_scan.h"
#include "sql_semantic.h"
#include "sql_optimize.h"
#include "sql_rel2bin.h"
#include "sql_server.h"

#include <monet_context.h>
#include <kernel.h>

@= builtin_operand
{       int _k = interpret(stk, arg(lt, @1), res);
        if (_k < 0) {
                return _k;
        }
        @3 = VALconvert(@2, res);
        if ((@3 == ILLEGALVALUE)  || (@2 == TYPE_bat && !@3)) {
                return handle_paramerror(res,@1,res->vtype,@2);
        }
}
@c

int connect_error(stream *in, stream *out, int sock)
{
	close_stream(in);
	close_stream(out);
	close(sock);
	return GDK_FAIL;
}


int senddata_wrap( Stream *Out ){
	stream *out = *(stream**)Out;
	stream_writeInt( out, QDATA );
	stream_writeInt( out, 0 );
	out->flush( out );
	return GDK_SUCCEED;
}

int sqlclient(Cntxt stk, YYSTREE lt, ValPtr res){
	buffer *bbuf;
	int debug = 0, l = 0, i, sock, *Sock;
	char buf[BUFSIZ+1], *errbuf;
	char *user, *passwd, *schema, *dbname;
	Variable v;

	mvc *m;
	stream *in, *out, *ws;
	context *lc;

  	if (lt->cnt != 1) {
        	return handle_argerror(res, lt->cnt, 1);
  	}
  	@:builtin_operand(0,TYPE_int,Sock)@
	sock = *Sock;

	out = block_stream( socket_wstream( sock, "SQLSERVER" ));
	in  = block_stream( socket_rstream( sock, "SQLSERVER" ));

	if ((i = in->read(in, buf, 1, BUFSIZ)) >= BUFSIZ)
		return connect_error(in, out, sock);
	buf[i] = 0;
	/* expect api(sql,debug); */
	l = strlen("api(sql,");
	if (i > l+1 )
		debug = strtol(buf+l,NULL,10);

	i=snprintf(buf, BUFSIZ, "login\n" );
	out->write(out, buf, 1, i);
	out->flush(out);

	if ((i = in->read(in, buf, 1, BUFSIZ)) >= BUFSIZ)
		return connect_error(in, out, sock);
	buf[i] = 0;
	/* expect login(user,passwd); */
	l = strlen("login(");
	if (i > l+1 ){
		char *s, *e = strchr(buf+l,',');
		if (!e) return connect_error(in, out, sock);
		*e = 0;
		s = e+1; /* skip comma */
		e = strrchr(s, ')');
		if (!e) return connect_error(in, out, sock);
		*e = 0;
		user = GDKstrdup(buf+l);
		passwd = GDKstrdup(s);
	} else {
		return connect_error(in, out, sock);
	}

	m = mvc_create(debug);
	schema = mvc_login( m, user, passwd );
	dbname = GDKgetenv("gdk_dbname");

	i = snprintf(buf, BUFSIZ, "%s,%s\n", dbname, schema?schema:"" );
	out->write(out, buf, 1, i);
	out->flush(out);

	if (!schema){ 
		GDKfree(user);
		GDKfree(passwd);
		mvc_destroy(m);
		return connect_error(in, out, sock);
	}

	lc = NEW(context);
 	bbuf = buffer_create( BUFSIZ );
	ws = buffer_wastream( bbuf, "SQLserver" );
	sql_init_context( lc, ws, debug, m );

	/* add myc and Output, Input to the stack */
	v = VARnew(stk, "myc");
	v->binding.vtype = TYPE_mvc;
	v->binding.val.pval = m;

	v = VARnew(stk, "Output");
	v->binding.vtype = TYPE_Stream;
	v->binding.val.pval = out;

	v = VARnew(stk, "Input");
	v->binding.vtype = TYPE_Stream;
	v->binding.val.pval = in;

 	errbuf = GDKmalloc(GDKMAXERRLEN);
	GDKsetbuf(errbuf);

	while(TRUE){
		stmt *s = NULL;
		int size = BUFSIZ + 1, err = 0;
		char *cmd = NULL, *inbuf = NEW_ARRAY(char, size );
		int inlen = 0;
		while ((inlen = in->read(in, inbuf, 1, BUFSIZ)) == BUFSIZ){
			err = 1;
		}
		inbuf[inlen] = '\0';

		if (!inlen || inbuf[0] == EOT)
			break;
		if (!err){
			if (strncmp(inbuf,"mvc_export", 10) != 0){
				s = sqlexecute(lc, inbuf, &err);
			} else {
				cmd = inbuf;
			} 
		}
		if (cmd != inbuf)
			_DELETE(inbuf);

		if (err){ /* output error */
			stream_writeInt( out, -1 );
			stream_writeInt( out, err );
			out->write( out, lc->errstr, strlen(lc->errstr), 1 );
			out->flush( out );
		} else if (s && s->type == st_none){
			stream_writeInt( out, QUPDATE );
			stream_writeInt( out, 0 );
			out->flush( out );
		} else if (s){
	    		int nr = 1;
	    		stmt_dump( s, &nr, lc );

			cmd = buffer_get_buf(bbuf);
	    		lc->out->flush( lc->out );
		}

		if (cmd){

/*
			if (lc->debug&4096) {
				char *sqzd_cmd = NULL;
				int misq_x = 0;
				CMDsqueezeStr2Str(&sqzd_cmd, cmd, &misq_x);
				if (sqzd_cmd && (sqzd_cmd != str_nil)) {
					if (cmd == inbuf)
						_DELETE(cmd);
					else if (cmd)
						free(cmd);
					cmd = sqzd_cmd;
				}
			}
*/

			if (lc->debug&64){
				stream_writeInt( out, QDEBUG );
				stream_writeInt( out, lc->debug );
				out->write( out, cmd, strlen(cmd), 1 );
				out->flush( out );
			} else {
				ssize_t status;
        			res->vtype = TYPE_void; 
				status = interpret_str( stk, cmd, res);

				if (status < 0){
					char *errstr = "Mil error";
					char *buf = GDKerrbuf;
					stream_writeInt( out, mvc_type(m) );
					stream_writeInt( out, status );
					out->write( out, errstr, strlen(errstr), 1 );
					out->write( out, buf, strlen(buf), 1 );
					buf[0] = 0; /* reset error buf */
					out->flush( out );
				} else if ((status=mvc_status(m)) < 0){
					char *errstr = "Error in result";
					stream_writeInt( out, mvc_type(m) );
					stream_writeInt( out, status );
					out->write( out, errstr, strlen(errstr), 1 );
					out->flush( out );
				} else if (s && s->type != st_output) {
					stream_writeInt( out, mvc_type(m) );
					stream_writeInt( out, status );
					out->flush( out );
				}
			}
			/* BEWARE to use free instead of _DELETE
 			 * as the stream library is build with out libbat 
 			 * ie. it cannot use GDKmalloc can be used */
			if (cmd == inbuf)
				_DELETE(cmd);
			else if (cmd) 
				free(cmd);
		}
		if (s) stmt_destroy(s);
	}
	mvc_destroy(m);
	sql_exit_context( lc );
	close_stream(in);
	close_stream(out);
	close(sock);
	return GDK_SUCCEED;
}

void sql_init_context(context * c, stream * out, int debug, mvc * mvc)
{
	memset(c, 0, sizeof(context));
	c->cur = ' ';
	c->filename = NULL;
	c->buf = NULL;
	c->in = NULL;
	c->out = out;
	c->debug = debug;
	c->lineno = 1;
	c->sym = NULL;
	c->mvc = mvc;
	c->status = 0;
	c->errstr[0] = '\0';

	c->yyval = 0;
	c->yytext = NEW_ARRAY(char, BUFSIZ);
	c->yytext[0] = 0;
	c->yylen = 0;
	c->yysize = BUFSIZ;

	if (c->sql)
		_DELETE(c->sql);
	c->sql = NEW_ARRAY(char, BUFSIZ);
	c->sqlsize = BUFSIZ;
	c->sql[0] = '\0';

	cmd_init(c);
}

void sql_exit_context(context * c)
{
	if (c->out){
		c->out->close(c->out);
		c->out->destroy(c->out);
	}
	c->mvc = NULL;

	if (c->sql != NULL)
		_DELETE(c->sql);
	c->sql = NULL;
	_DELETE(c->yytext);
}

stmt *sqlnext(context * c, stream * in, int *err)
{
	stmt *res = NULL;

	c->filename = in->name;
	c->in = in;

	cmd_init(c);

	if (c->cur != EOF && !(*err = sqlparse(c))) {
		res = semantic(c, c->sym);
		if (res){
			stmt *opt = optimize(c, res);
			stmt_destroy(res);
			res = rel2bin(c, opt);
			stmt_destroy(opt);
			/* optimizer or rel2bin bug */
			if (!res)
				*err = 1;
		}
		if (!res && c->status){
			*err = 1;
		}
	}
	if (c->sym) {
		symbol_destroy(c->sym);
		c->sym = NULL;
	}
	return res;
}

stmt *sqlexecute(context * c, char *buf, int *err)
{
	stmt *res = NULL;

	c->filename = "";
	c->buf = buf;
	c->cur = ' ';

	cmd_init(c);

	if (!(*err = sqlparse(c))) {
		res = semantic(c, c->sym);
		if (res){
			stmt *opt = optimize(c, res);
			stmt_destroy(res);
			res = opt;
			res = rel2bin(c, opt);
			stmt_destroy(opt);
			/* optimizer or rel2bin bug */
			if (!res)
				*err = 1;
		}
		if (!res && c->status){
			*err = 1;
		}
	}
	if (c->sym) {
		symbol_destroy(c->sym);
		c->sym = NULL;
	}
	return res;
}

void cmd_init(context * c)
{
	if (c->sql && c->debug & D__SQL)
		fprintf(stderr, "%s\n", c->sql);
	c->sql[0] = '\0';
	c->sqllen = 1;

	c->errstr[0] = '\0';
}

/* add token + widthspace */
void cmd_add_token(context * c, char *token)
{
	int len = strlen(token);
	if ((c->sqllen + len + 1) > c->sqlsize) {
		while( (c->sqllen + len + 1) > c->sqlsize)
			c->sqlsize *= 2;
		c->sql = RENEW_ARRAY(char, c->sql, c->sqlsize);
	}
	strncpy(c->sql + c->sqllen - 1, token, len);
	c->sqllen += len + 1;
	c->sql[c->sqllen - 2] = ' ';
	c->sql[c->sqllen - 1] = '\0';
}

/* add quoted string + widthspace */
void cmd_add_string(context * c, char *str)
{
	int len = strlen(str);
	if ((c->sqllen + len + 3) > c->sqlsize) {
		while( (c->sqllen + len + 3) > c->sqlsize)
			c->sqlsize *= 2;
		c->sql = RENEW_ARRAY(char, c->sql, c->sqlsize);
	}
	c->sql[c->sqllen - 1] = '\'';
	strncpy(c->sql + c->sqllen, str, len);
	c->sqllen += len + 3;
	c->sql[c->sqllen - 3] = '\'';
	c->sql[c->sqllen - 2] = ' ';
	c->sql[c->sqllen - 1] = '\0';
}
