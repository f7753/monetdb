@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@' 
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@' 
@' The Original Code is the Monet Database System.
@' 
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2004 CWI.
@' All Rights Reserved.
@' 
@' Contributor(s):
@' 		Martin Kersten <Martin.Kersten@cwi.nl>
@' 		Peter Boncz <Peter.Boncz@cwi.nl>
@' 		Niels Nes <Niels.Nes@cwi.nl>
@' 		Stefan Manegold  <Stefan.Manegold@cwi.nl>

@f sql_select
@a N.J. Nes
@* 

@h
#ifndef _SQL_SELECT_H_
#define _SQL_SELECT_H_

#include <stdio.h>
#include <stdarg.h>
#include <sql_list.h>
#include "sql_symbol.h"
#include "sql_scope.h"
#include "sql_statement.h"

#define sql_from 0
#define sql_where 1
#define sql_sel   2

sql_export stmt *selects( mvc * sql, symbol * sym);

sql_export stmt *sql_subquery(mvc * sql, scope * scp, symbol * sq, int toplevel);
sql_export stmt *scope_subquery(mvc * sql, scope * scp, symbol * sq );

sql_export stmt *sql_value_exp(mvc * sql, scope * scp, symbol * se, group * grp, stmt * subset, int f);
sql_export stmt *sql_logical_exp(mvc * sql, scope * scp, symbol * sc, group * grp, stmt * subset, int f);
sql_export stmt *stmt2pivot(scope * scp, stmt * s);

#endif /*_SQL_SELECT_H_*/
@c

#include "sql_config.h"
#include "sql_select.h"
#include "sql_parser.h"
#include "sql_scope.h"
#include "sql_semantic.h"
#include "sql_privileges.h"

static stmt *sql_select(mvc * sql, scope * scp, SelectNode *sn, int toplevel );
static stmt *sql_simple_select(mvc * sql, scope * scp, symbol *where, dlist * selection);
static stmt *sql_compare(mvc * sql, stmt * ls,
			 stmt * rs, char *compare_op, int f);
static stmt *sql_compare_exp( mvc *sql, scope *scp, group *grp, stmt *subset, symbol *lo, symbol *ro, char *compare_op, int f );

static tvar *query_exp_optname(mvc * sql, scope * scp, symbol * q);
static tvar *sql_subquery_optname(mvc * sql, scope * scp, symbol * query);

static void sql_select_cleanup( mvc * sql, stmt *s, stmt *subset, group *grp )
{
	(void) sql; /* Stefan: unused!? */

	if (grp)
		grp_destroy(grp);
	if (subset)
		stmt_destroy(subset);
	if (s)
		stmt_destroy(s);
}

static tvar *table_ref(mvc * sql, scope * scp, symbol * tableref)
{
	char *tname = NULL;
	sql_table *t = NULL;

	/* todo handle opt_table_ref 
	   (ie tableref->data.lval->h->next->data.sym */

	if (tableref->token == SQL_NAME) {
		sql_schema *s = qname_schema(sql, tableref->data.lval->h->data.lval);
		tname = qname_table(tableref->data.lval->h->data.lval);
				
		if (!s){
			(void) sql_error( sql, 02, "Unknown schema");
			return NULL;
		}
		t = mvc_bind_table(sql, s, tname);
		if (!t) {
			(void) sql_error( sql, 02, "Unknown table %s", tname);
			return NULL;
		}
		if (tableref->data.lval->h->next->data.sym) {	/* AS */
			tname = tableref->data.lval->h->next->data.sym->data.lval->h->data.sval;
		}
		return scope_add_table_columns(sql, scp, t, tname);
	} else if (tableref->token == SQL_TABLE) {
		stmt *s = sql_value_exp(sql, scp, tableref->data.lval->h->data.sym, NULL, NULL, sql_from);
		char *tname = tableref->data.lval->h->next->data.sym->data.lval->h->data.sval;

		if (!s) 
			return NULL;
		return scope_add_table(scp, s, tname, NULL);
	} else if (tableref->token == SQL_SELECT) {
		return sql_subquery_optname(sql, scp, tableref);
	} else {
		return query_exp_optname(sql, scp, tableref);
	}
}

stmt *sql_subquery(mvc * sql, scope * scp, symbol * sq, int toplevel)
{
	SelectNode *sn = (SelectNode*)sq;
	assert(sn->s.token == SQL_SELECT);

	if (!toplevel && sn->limit >= 0)
		return sql_error( sql, 01, "Can only limit outer select " );

	if (!toplevel && sn->orderby)
		return sql_error( sql, 01, "Can only order by outer select " );

	if (sn->from) {		/* keep variable list with tables and names */
		dlist *fl = sn->from->data.lval;
		dnode *n = NULL;
		tvar *fnd = (tvar *) 1L; /* 1L to keep 64-bit compilers from complaining *
		                          * about different sizes of int and pointer     */

		for (n = fl->h; (n && fnd); n = n->next)
			fnd = table_ref(sql, scp, n->data.sym);

		if (!fnd)
			return NULL;

	} else if (toplevel) {	/* only on top level query */
		return sql_simple_select(sql, scp, sn->where, sn->selection);
	}
	return sql_select(sql, scp, sn, toplevel );
}

stmt *scope_subquery(mvc * sql, scope * scp, symbol * sq)
{
	stmt *s;
	int toplevel = (scp)?0:1;

	scp = scope_open(scp);
	s = sql_subquery(sql, scp, sq, toplevel);
	scp = scope_close(scp);
	return s;
}


/* 
 * Column references, can be done using simple names or aliases and
 * using a combination of table name and column name (or alias).
 * The sql_column_ref finds the column based on the specification from
 * symbol column_r.
 * A special column reference is 'rowid'.
 */

static stmt *sql_column_ref(mvc * sql, scope * scp, symbol * column_r)
{
	stmt *cs = NULL;
	dlist *l = column_r->data.lval;

	assert(column_r->token == SQL_COLUMN
	       && column_r->type == type_list);

	if (dlist_length(l) == 1) {
		char *name = l->h->data.sval;

		if (strcasecmp(name, "rowid") == 0){
			cvar *cv = scope_first_column(scp);
			return stmt_mirror(stmt_dup(cv->s));
		} else if (!(cs = scope_bind(scp, NULL, name))) {
			/* maybe simple param */
			cs = sql_bind_param(sql, name);
			if (!cs)
				return sql_error( sql, 02, 
					"Identifier: %s unknown or ambigious", name);
		}
	} else if (dlist_length(l) == 2) {
		char *tname = l->h->data.sval;
		char *cname = l->h->next->data.sval;

		if (strcasecmp(cname, "rowid") == 0){
			tvar *tv = scope_bind_table(scp, tname);
			cvar *cv;
			if (!tv){
				return sql_error( sql, 02, 
					"Identifier: %s unknown", tname);
			}
			cv = tv->columns->h->data;
			return stmt_mirror(stmt_dup(cv->s));
		} else if (!(cs = scope_bind(scp, tname, cname))) {
			return sql_error( sql, 02, "Column: %s.%s unknown", tname, cname);
		}
	} else if (dlist_length(l) >= 3) {
		return sql_error( sql, 02, "TODO: column names of level >= 3" );
	}
	return cs;
}

static char *tmp_table_name()
{
	oid id = OIDnew(1);
	static char buf[BUFSIZ];
	snprintf(buf, BUFSIZ, "c%ld", id );
	return buf;
}

static sql_table *create_table_intern(mvc * sql, sql_schema * schema,
				  char *name, char *query, stmt * sq, table_type type)
{
	node *m;
	sql_table *table = mvc_create_table(sql, schema, name, type, -1);
	(void) query; /* Stefan: unused!? */

       	for ( m = sq->op1.lval->h; m; m = m->next ) {
		stmt *st = m->data;
		sql_subtype *tp = sql_dup_subtype(tail_type(st));
		char *cname = column_name(st);

		(void)mvc_create_column(sql, table, cname, tp );
		_DELETE(cname);
	}
	return table;
}

static tvar *table_optname(mvc * sql, scope * scp, stmt * sq,
			   char *query, symbol * optname)
{
	node *m;
	char *tmpname = NULL;
	char *tname = NULL;
	dlist *columnrefs = NULL;
	tvar *tv;
	sql_schema *schema = cur_schema(sql);

	if (optname && optname->token == SQL_NAME) {
		tmpname = tname = optname->data.lval->h->data.sval;
		columnrefs = optname->data.lval->h->next->data.lval;
	} else {	
		tmpname = tmp_table_name();
	}
	(void)create_table_intern(sql, schema, tmpname, query, sq, tt_temp);
	tv = scope_add_table(scp, sq, tname, NULL);
	if (columnrefs) {
		dnode *d;

		for (m = sq->op1.lval->h, d = columnrefs->h; 
		     d && m; 
		     d = d->next, m = m->next) {
			stmt *st = m->data;
			stmt *sc = stmt_ibat(stmt_alias(stmt_dup(st), d->data.sval), stmt_dup(sq));

			table_add_column(tv, sc, tname, d->data.sval);
		}
	} else if (tname) {
		/* foreach column add column name */
		for ( m = sq->op1.lval->h; m; m = m->next) {
			stmt *st = m->data;
			char *cname = column_name(st);
			stmt *sc = stmt_ibat(stmt_dup(st), stmt_dup(sq));

			table_add_column(tv, sc, tname, cname);
			_DELETE(cname);
		}
	} else {
		/* foreach column add full basetable,column name */
		for ( m = sq->op1.lval->h; m; m = m->next) {
			stmt *st = m->data;
			char *cname = column_name(st);
			char *tname = table_name(st);
			stmt *sc = stmt_ibat(stmt_dup(st), stmt_dup(sq));

			table_add_column(tv, sc, tname, cname);
			_DELETE(tname);
			_DELETE(cname);
		}
	}
	return tv;
}

static tvar *sql_subquery_optname(mvc * sql, scope * scp,
				  symbol * query)
{
	SelectNode *sn = (SelectNode*)query;
	stmt *sq = scope_subquery(sql, NULL, query);

	if (!sq)
		return NULL;

	return table_optname(sql, scp, sq, QUERY(sql->scanner), sn->name);
}

static stmt *find_pivot(stmt * subset, stmt * t)
{
	assert(subset->type == st_ptable);

	if (t){
		node *n;
		for (n = ptable_pivots(subset)->h; n; n = n->next) { 
			stmt *s = n->data;
			if (s->t == t) 
				return stmt_dup(s);
		}
	}
	assert(0);
	return NULL;
}

/* before the pivot table is created we need to check on both head and
 * tail for the subset.
 * */
static stmt *complex_find_subset(stmt * subset, stmt * t)
{

	if (t) {
		node *n;
		for (n = subset->op1.lval->h; n; n = n->next) {
			stmt *s = n->data;
			if (s->t == t) 
				return stmt_dup(s);
		}
		for (n = subset->op1.lval->h; n; n = n->next) {
			stmt *s = n->data;
			if (s->h == t) 
				return stmt_dup(s);
		}
	}
	return NULL;
}

/* The case/when construction in the selection works on the resulting
   table (ie. on the marked columns). We just need to know which oid list
   is involved (ie. find one subset).
   We need to check if for all results the types are the same. 

 TODO case in where part!!
 */
static stmt *sql_case(mvc * sql, scope * scp, int token, symbol *opt_cond, dlist * when_search_list, symbol * opt_else, group * grp, stmt * subset, int f)
{
	list *conds = create_stmt_list();
	list *results = create_stmt_list();
	dnode *dn = when_search_list->h;
	sql_subtype *restype = NULL;
	stmt *res = NULL, *else_stmt = NULL;
	node *n, *m;

	if (dn) {
		stmt *cond = NULL, *result = NULL;

		/* NULLIF(e1,e2) == CASE WHEN e1=e2 THEN NULL ELSE e1 END */
		if (token == SQL_NULLIF) {
			stmt *e1, *e2;
		
 			e1 = sql_value_exp(sql, scp,
				dn->data.sym, grp, subset, f);
			e2 = sql_value_exp(sql, scp,
				dn->next->data.sym, grp, subset, f);
			if (e1 && subset->nrcols && e1->nrcols == 0) 
				e1 =stmt_const(first_subset(subset),e1);
			if (e1 && e2) {
				cond = sql_compare(sql, stmt_dup(e1), e2,
					"=", sql_where);
				result = stmt_atom( atom_general( sql_dup_subtype(tail_type(e1)), NULL));
				else_stmt = e1; /* ELSE case */
			} else {
				if (e1) stmt_destroy(e1);
				if (e2) stmt_destroy(e2);
			}
		/* COALESCE(e1,e2) == CASE WHEN e1 
			IS NOT NULL THEN e1 ELSE e2 END */
		} else if (token == SQL_COALESCE) {
			cond = sql_value_exp(sql, scp,
				dn->data.sym, grp, subset, f);

			if (cond && subset->nrcols && cond->nrcols == 0) 
				cond = stmt_const(first_subset(subset),cond);
			if (cond) {
				result = stmt_dup(cond);
				cond = sql_compare(sql, cond, 
					stmt_atom( atom_general( 
					  sql_dup_subtype(tail_type(cond)), 
					  NULL)), "<>", sql_where);
			}
		} else {
			dlist *when = dn->data.sym->data.lval;
			if (opt_cond){
				cond = sql_compare_exp( sql, scp, grp, subset, 
					opt_cond, when->h->data.sym, "=", sql_where);
			} else {
				cond = sql_logical_exp(sql, scp, 
					when->h->data.sym, grp, subset, sql_where);
			}
			result = sql_value_exp(sql, scp, 
					when->h->next->data.sym, grp, subset, f);
		}
		if (!cond || !result) {
			list_destroy(conds);
			list_destroy(results);
			return NULL;
		}
		list_prepend(conds, cond);
		list_prepend(results, result);

		restype = sql_dup_subtype(tail_type(result));

		if (token == SQL_NULLIF)
			dn = NULL;
		else
			dn = dn->next;
	}
	if (!restype) {
		list_destroy(conds);
		list_destroy(results);
		return sql_error(sql, 02, "Error: result type missing");
	}
	for (; dn; dn = dn->next) {
		sql_subtype *tpe = NULL;
		stmt *cond = NULL, *result = NULL;

		if (token == SQL_COALESCE){
			cond = sql_value_exp(sql, scp,
				dn->data.sym, grp, subset, f);

			if (cond && subset->nrcols && cond->nrcols == 0) 
				cond = stmt_const(first_subset(subset),cond);
			if (cond) {
				result = stmt_dup(cond);
				cond = sql_compare(sql, cond, 
					stmt_atom( atom_general( 
					  sql_dup_subtype(tail_type(cond)), 
					  NULL)), "<>", sql_where);
			}
		} else {
			dlist *when = dn->data.sym->data.lval;

			if (opt_cond){
				cond = sql_compare_exp( sql, scp, grp, subset, 
					opt_cond, when->h->data.sym, "=", sql_where);
			} else {
				cond = sql_logical_exp(sql, scp, 
					when->h->data.sym, grp, subset, sql_where);
			}
			result = sql_value_exp(sql, scp, 
				when->h->next->data.sym, grp, subset, sql_where);
		}
		if (!cond || !result) {
			list_destroy(conds);
			list_destroy(results);
			return NULL;
		}
		list_prepend(conds, cond);
		list_prepend(results, result);

		tpe = tail_type(result);
		if (!tpe) {
			list_destroy(conds);
			list_destroy(results);
			return sql_error(sql, 02, "Error: result type missing");
		}
		tpe = supertype(restype, tpe);
		sql_subtype_destroy( restype );
		if (!tpe) {
			list_destroy(conds);
			list_destroy(results);
			return sql_error(sql, 02, "Error: result types %s,%s of case are not compatible", restype->type->sqlname, tpe->type->sqlname);
		}
		restype = tpe;
	}
	if (subset) {
		res = first_subset(subset);
		if (!res) {
			list_destroy(conds);
			list_destroy(results);
			return sql_error(sql, 02, "Subset not found for case stmt");
		}
	} else {
		return sql_error(sql, 02, "Case in query currently not supported");
	}
	if (opt_else || else_stmt) {
		stmt *result = else_stmt;

		if (!result)
		 	result = sql_value_exp(sql, scp, opt_else, grp, subset, f);

		if (!result || !(result = check_types(sql, restype, result))) {
			list_destroy(conds);
			list_destroy(results);
			return NULL;
		}
		if (result->nrcols <= 0) {
			res = stmt_const(res, result);
		} else {
			if (res) stmt_destroy(res);
			res = result;
		}
	} else {
		res = stmt_const(res, stmt_atom( atom_general( sql_dup_subtype(restype), NULL)));
	}
	if (restype) 
		sql_subtype_destroy(restype);
	restype = tail_type(res);
	for (n = conds->h, m = results->h; n && m;
	     n = n->next, m = m->next) {
		stmt *cond = stmt_dup(n->data);
		stmt *result = stmt_dup(m->data);

		/* need more semantic tests here */
		if (cond->type == st_sets) {
			node *k = cond->op1.lval->h;
			stmt *cur = NULL;

			if (k) {
				list *l1 = k->data;
				cur = stmt_dup(l1->h->data);
				k = k->next;
				for (; k; k = k->next) {
					list *l2 = k->data;
					stmt *st = stmt_dup(l2->h->data);
					cur = stmt_union(cur, st);
				}
				if (cond) stmt_destroy(cond);
				cond = cur;
			}
		}
		if (cond->type == st_set) {
			stmt *nc = (stmt*)list_reduce(cond->op1.lval, (freduce)&stmt_semijoin, (fdup)&stmt_dup );
			stmt_destroy(cond);
			cond = nc;
		}
		if (result->nrcols <= 0)
			result = stmt_const(cond, result);
		else 
			result = stmt_semijoin(result, cond);
		
		if (! (result = check_types(sql, restype, result)) ) {
			list_destroy(conds);
			list_destroy(results);
			stmt_destroy(res);
			return NULL;
		}
		res = stmt_replace(res, result);
	}
	list_destroy(conds);
	list_destroy(results);
	return res;
}

static stmt *sql_case_exp(mvc * sql, scope * scp, symbol * se, group * grp, stmt * subset, int f)
{
	dlist *l = se->data.lval;
	if (se->token == SQL_COALESCE) {
		symbol *opt_else = l->t->data.sym;
		dlist_remove_node(l, l->t);
		return sql_case(sql, scp, se->token, NULL,  l, opt_else, grp, subset, f);
	} else if (se->token == SQL_NULLIF) {
		return sql_case(sql, scp, se->token, NULL,  l, NULL, grp, subset, f);
	} else if (l->h->type == type_list) {
		dlist *when_search_list = l->h->data.lval;
		symbol *opt_else = l->h->next->data.sym;
		return sql_case(sql, scp, SQL_CASE, NULL,  when_search_list, opt_else, grp, subset, f);
	} else {
		symbol *scalar_exp = l->h->data.sym;
		dlist *when_value_list = l->h->next->data.lval;
		symbol *opt_else = l->h->next->next->data.sym;
		return sql_case(sql, scp, SQL_CASE, scalar_exp, when_value_list, opt_else, grp, subset, f);
	}
}

static stmt *sql_cast(mvc * sql, scope * scp, symbol * se, group * grp, stmt * subset, int f)
{

	dlist *dl = se->data.lval;
	symbol *s = dl->h->data.sym;
	sql_subtype *tpe = dl->h->next->data.typeval;

	stmt *l = sql_value_exp(sql, scp, s, grp, subset, f);

	if (l) 
		return check_types(sql, tpe, l);
	return NULL;
}

static stmt *sql_Nop(mvc * sql, scope * scp, symbol * se, group * grp, stmt * subset, int fs)
{
	dnode *l = se->data.lval->h;
	dnode *ops = l->next->data.lval->h;
	list *sl = create_stmt_list();
	list *tl = list_create(NULL);
	sql_subfunc *f = NULL;

	for(; ops; ops = ops->next){
		stmt *op = sql_value_exp(sql, scp, ops->data.sym, grp, subset, fs);
		if (!op){
			list_destroy(sl);
			return NULL;
		}
		list_append( sl, op);
		list_append( tl, tail_type(op));
	}
	f = sql_bind_func_(l->data.sval, tl);
	list_destroy(tl);
	if (f) {
		return stmt_Nop(stmt_list(sl), f);
	} else {
		if ( (f = sql_bind_member(l->data.sval, tail_type(sl->h->data), list_length(sl))) != NULL) {
			node *n, *m;
			list *nsl = create_stmt_list();
			
			n = sl->h;
			list_append( nsl, stmt_dup(n->data));
			m = f->func->ops->h;
			for(n = n->next, m = m->next; n && m; 
			    n = n->next, m = m->next){
				sql_arg *a = m->data;
				stmt *op = stmt_dup(n->data);

				op = check_types(sql, a->type, op);
				if (!op) {
					list_destroy(nsl);
					nsl = NULL;
					break;
				}
				list_append( nsl, op);
			}
			if (nsl) {
				list_destroy(sl);
				return stmt_Nop(stmt_list(nsl), f);
			}
		} 
		list_destroy(sl);
		return sql_error(sql, 02, "operator: %s unknown", l->data.sval);
	}
	return NULL;
}

static stmt *
sql_binop_(mvc * sql, scope *scp, char *fname, stmt * ls, stmt *rs)
{
	stmt *res = NULL;
	sql_subtype *t1, *t2;
	sql_subfunc *f = NULL;

 	t1 = tail_type(ls);
	t2 = tail_type(rs);

	/* input from different tables requires an extra cross-product! */
	if (ls->nrcols > 0 && rs->nrcols > 0 && ls->h != rs->h) {
		ls = stmt_join(scope_find_pivot(scp, ls->h), ls, cmp_equal);
		rs = stmt_join(scope_find_pivot(scp, rs->h), rs, cmp_equal);
	}
	f = sql_bind_func(fname, t1, t2 );
	if (f) {
		if (f->func->res->scale == SCALE_FIX){
			ls = fix_scale( sql, t2, ls, 0, 0);
			rs = fix_scale( sql, t1, rs, 0, 0);
		}
		if (f->func->res->scale == SCALE_SUB)
			ls = scale_algebra( f, ls, rs );
		if (f->func->res->scale == SCALE_ADD)
			sum_scales(f, ls, rs);
		return stmt_binop(ls, rs, f);
	} else {
		if (convert_types( sql, &ls, &rs, 0) >= 0){
 			t1 = tail_type(ls);
			t2 = tail_type(rs);
			f = sql_bind_func(fname, t1, t2 );
			if (f){
				if (f->func->res->scale == SCALE_FIX){
					ls = fix_scale( sql, t2, ls, 0, 0);
					rs = fix_scale( sql, t1, rs, 0, 0);
				}
				if (f->func->res->scale == SCALE_SUB)
					ls = scale_algebra( f, ls, rs );
				if (f->func->res->scale == SCALE_ADD)
					sum_scales(f, ls, rs);
				return stmt_binop(ls, rs, f);
			}
		}
	}
	res = sql_error(sql, 02, "Binary operator: %s(%s,%s) unknown", fname, tail_type(ls)->type->sqlname, tail_type(rs)->type->sqlname);
	if (ls) 
		stmt_destroy(ls);
	if (rs) 
		stmt_destroy(rs);
	return res;
}

static stmt *sql_binop(mvc * sql, scope * scp, symbol * se, group * grp, stmt * subset, int f)
{
	dnode *l = se->data.lval->h;
	stmt *ls = sql_value_exp(sql, scp, l->next->data.sym, grp, subset, f);
	stmt *rs = sql_value_exp(sql, scp, l->next->next->data.sym, grp, subset, f);
	if (!ls || !rs){
		if (ls) stmt_destroy(ls);
		if (rs) stmt_destroy(rs);
		return NULL;
	}

	/* also need to add semantic checks here */
	if (ls->type == st_list){
		stmt *o = ls;
		assert(list_length(ls->op1.lval) == 1);
		ls = stmt_dup(ls->op1.lval->h->data);
		stmt_destroy(o); 
	}
	if (rs->type == st_list){
		stmt *o = rs;
		assert(list_length(rs->op1.lval) == 1);
		rs = stmt_dup(rs->op1.lval->h->data);
		stmt_destroy(o); 
	}

	return sql_binop_(sql, scp, l->data.sval, ls, rs ); 
}

static stmt *sql_op(mvc * sql, scope * scp, symbol * se, group * grp, stmt * subset)
{
	dnode *l = se->data.lval->h;
	sql_subfunc *f = NULL;
	(void) scp; (void) grp; (void) subset; /* Stefan: unused!? */

	f = sql_bind_func(l->data.sval, NULL, NULL);
	if (f) {
		return stmt_op(f);
	} else {
		return sql_error(sql, 02, "operator: %s() unknown", l->data.sval);
	}
	return NULL;
}

static stmt *sql_unop(mvc * sql, scope * scp, symbol * se, group * grp, stmt * subset, int fs)
{
	dnode *l = se->data.lval->h;
	sql_subfunc *f = NULL;
	sql_subtype *rt = NULL;
	stmt *rs = sql_value_exp(sql, scp, l->next->data.sym, grp, subset, fs);

	if (!rs)
		return NULL;
	rt = tail_type(rs);
	f = sql_bind_func(l->data.sval, rt, NULL );
	if (f) {
		if (f->func->imp) {
			/* HACK ALERT: output same type as input */
			if (f->func->res->scale == SCALE_SUB) {
				f->res->digits = rt->digits;
				f->res->scale = rt->scale;
			}
			return stmt_unop(rs, f);
		} else {
			stmt *res;
			sql_arg *a = f->func->ops->h->data;
			sql_add_param(sql, _strdup(a->name), rs );

			res = sqlparse_intern(sql, f->func->imp);
			sql_subfunc_destroy(f);
			return res;
		}
	} else {
		char *type = tail_type(rs)->type->sqlname;

		stmt_destroy(rs);
		return sql_error(sql, 02, "Unary operator: %s(%s) unknown", l->data.sval, type);
	}
	return NULL;
}


static stmt *sql_aggrop(mvc * sql, scope * scp, symbol * se, group * grp, stmt * subset, int f)
{
	dlist *l = se->data.lval;
	sql_subaggr *a = NULL;
	int distinct = l->h->next->data.ival;
	stmt *s = NULL;
	char *aggrstr = l->h->data.sval;

	if (!l->h->next->next->data.sym) {	/* count(*) case */
		cvar *cv;
		if (strcmp(aggrstr, "count") != 0) {
			return sql_error(sql, 02, "Aggregate: Cannot do a %s(*)", l->h->data.sval);
		}
		if (grp) {
			a = sql_bind_aggr(aggrstr, NULL); 
			return stmt_aggr(stmt_dup(grp->grp), grp_dup(grp), a);
		}
		cv = scope_first_column(scp);
		if (cv && subset) {
			stmt *foundsubset = find_pivot(subset, cv->s->h);

				assert(foundsubset);
			if (!foundsubset) {
				return sql_error(sql, 02, "Aggregate: Cannot find subset for column %s\n", cv->cname) ;
			}
			s = stmt_join(foundsubset, stmt_dup(cv->s), cmp_equal);
		}
	} else {
		/* use cnt as nils shouldn't to be counted */
		if (strcmp(aggrstr, "count") == 0) {
			aggrstr = "count_no_nil";
		}
		/* the values which are aggregated together, no grp should
		 * be given there to optain the values */
		s = sql_value_exp(sql, scp, l->h->next->next->data.sym, /*grp*/ NULL, subset, f);
	}

	if (s && distinct) {
		s = stmt_unique(s,grp_dup(grp));
	}
	if (!s)
		return NULL;
	a = sql_bind_aggr(aggrstr, tail_type(s));
	if (a) {
		/* type may have changed, ie. need to fix_scale */
		sql_subtype *t = tail_type(s);
		return fix_scale(sql, t, stmt_aggr(s, grp_dup(grp), a), 1, (t->type->scale == SCALE_FIX));
	} else {
		char *type = tail_type(s)->type->sqlname;
		stmt_destroy(s);
		return sql_error(sql, 02, "Aggregate: %s(%s) unknown", l->h->data.sval, type);
	}
	return NULL;
}

static stmt *sql_column_value(mvc * sql, scope * scp, symbol * se, group * grp, stmt * subset, int f)
{
	stmt *s = sql_column_ref(sql, scp, se);

	if (s && s->h && subset && f) {
		stmt *col = s;
		stmt *foundsubset = find_pivot(subset, s->h);

		if (!foundsubset) 
			return sql_error(sql, 02, 
				"Subset not found for value expression");

		s = stmt_join(foundsubset, s, cmp_equal);
		if (s && grp && f && s->type != st_aggr && grp->cols) {
			if (grp_find_groupby_col(grp, col)) {
				s = stmt_join(stmt_dup(grp->ext), s, cmp_equal);
			} else {
				char *name = column_name(col);
				stmt_destroy(s);
				if (name)
					return sql_error(sql, 02, "Cannot use non group by column (%s) in query result without aggregation", name);
				else
					return sql_error(sql, 02, "Cannot use non group by column in query result without aggregation" );
			}
		}
	} 
	return s;
}

stmt *sql_value_exp(mvc * sql, scope * scp, symbol * se, group * grp, stmt * subset, int f)
{

	switch (se->token) {
	case SQL_NOP:
		return sql_Nop(sql, scp, se, grp, subset, f);
	case SQL_BINOP:
		return sql_binop(sql, scp, se, grp, subset, f);
	case SQL_OP:
		return sql_op(sql, scp, se, grp, subset);
	case SQL_UNOP:
		return sql_unop(sql, scp, se, grp, subset, f);
	case SQL_AGGR:
		return sql_aggrop(sql, scp, se, grp, subset, f);
	case SQL_COLUMN:
		return sql_column_value(sql, scp, se, grp, subset, f);
	case SQL_SELECT:
		return scope_subquery(sql, scp, se);
	case SQL_PARAMETER:
		return sql_error(sql, 02, "Currently no support for '?' parameters\n");
	case SQL_NULL: 
		return stmt_atom(atom_general(sql_dup_subtype(
				sql_bind_localtype("str")),NULL));
	case SQL_ATOM: {
		AtomNode *an = (AtomNode*)se;
		if (!an || !an->a){
			return stmt_atom(atom_general(sql_dup_subtype(
				sql_bind_localtype("str")),NULL));
		} else {
			return stmt_atom(atom_dup(an->a));
		}
	}
	case SQL_CAST:
		return sql_cast(sql, scp, se, grp, subset, f);
	case SQL_CASE:
		return sql_case_exp(sql, scp, se, grp, subset, f);
	case SQL_COALESCE:
	case SQL_NULLIF:
		return sql_case_exp(sql, scp, se, grp, subset, f);
	default:
		return sql_logical_exp(sql, scp, se, grp, subset, f);
	}
	return NULL;
}

/* turns a stmt set (or a set of stmt_sets) into a pivot table 
 * ie a table with a oid column for each base table.
 * A row of this pivot table expresses how the rows of the base tables
 * relate.
 */

stmt *stmt2pivot(scope * scp, stmt * s)
{
	stmt *ptable = stmt_dup(scp->ptable);
	ptable_statements(ptable) = s;
	ptable ->nrcols = s->nrcols;
	return ptable;
}

static stmt *find_on_column_name(mvc * sql, scope * scp, tvar * t, char *name)
{
	node *m;
	(void) sql; (void) scp; /* Stefan: unused!? */

	for (m = t->columns->h; m; m = m->next) {
		cvar *rc = m->data;
		if (strcmp(name, rc->cname) == 0) {
			return stmt_dup(rc->s);
		}
	}
	return NULL;
}

static list *join_on_column_name(mvc * sql, scope * scp, tvar * tv,
				 tvar * r, int all)
{
	list *res = create_stmt_list();
	node *n;
	for (n = tv->columns->h; n; n = n->next) {
		cvar *lc = n->data;
		stmt *rs = find_on_column_name(sql, scp, r, lc->cname);
		if (rs) {
			list_append(res, stmt_dup(lc->s));
			list_append(res, rs);
		} else if (all) {
			list_destroy(res);
			return NULL;
		}
	}
	return res;
}


static stmt *
sql_join_ (mvc * sql, scope * scp, symbol * tab1, int natural, 
	   jt jointype, symbol * tab2, symbol * js) 
{
	stmt *s = NULL, *subset = NULL;
	tvar *tv1, *tv2;

	tv1 = table_ref(sql, scp, tab1);
	tv2 = table_ref(sql, scp, tab2);

	if (!tv1 || !tv2)
		return NULL;

	if (js && natural) {
		return sql_error(sql, 02, "Cannot have a NATURAL JOIN with a join specification (ON or USING);");
	}
	if (!js && !natural) {
		return sql_error(sql, 02, "Must have NATURAL JOIN or a JOIN with a specification (ON or USING);");
	}

	if (js && js->token != SQL_USING) {	/* On sql_logical_exp */
		s = sql_logical_exp(sql, scp, js, NULL, NULL, sql_where);
	} else if (js) {	/* using */
		dnode *n = js->data.lval->h;

		s = stmt_reljoin_init();
		for (; n; n = n->next) {
			char *nm = n->data.sval;

			stmt *ls = find_on_column_name(sql, scp, tv1, nm);
			stmt *rs = find_on_column_name(sql, scp, tv2, nm);
			if (!ls || !rs) {
				if (ls) stmt_destroy(ls);
				if (rs) stmt_destroy(rs);
				if (s) stmt_destroy(s);
				return sql_error(sql, 02, "Tables %s and %s do have a matching column %s\n", tv1->tname, tv2->tname, nm);
			}
			if ((convert_types(sql, &ls, &rs, 1) < 0)) 
			{
				if (ls) stmt_destroy(ls);
				if (rs) stmt_destroy(rs);
				if (s) stmt_destroy(s);
				return NULL;
			}
			stmt_reljoin_fill(s, ls, rs);
		}
	} else {		/* ! js -> natural join */
		list *matching_columns;
		node *m;

		matching_columns = join_on_column_name(sql, scp, tv1, tv2, 0);

		if (!matching_columns || list_length(matching_columns) == 0) {
			if (matching_columns) list_destroy(matching_columns);
			return sql_error(sql, 02, "No attributes of tables %s and %s match\n", tv1->tname, tv2->tname);
		}

		s = stmt_reljoin_init();
		for (m = matching_columns->h; m; m = m->next->next) {
			stmt *ls = stmt_dup(m->data);
			stmt *rs = stmt_dup(m->next->data);

			if ((!rs) || (!ls) ||
				(convert_types(sql, &ls, &rs, 1) < 0)) 
			{
				if (ls) stmt_destroy(ls);
				if (rs) stmt_destroy(rs);
				if (s) stmt_destroy(s);
				return NULL;
			}
			stmt_reljoin_fill(s, ls, rs);
		}
		list_destroy(matching_columns);
	}

	if (s) {
		s = stmt2pivot(scp, s);
	}
	subset = s;
	if (subset) {
		list *l1;
		tvar *t = NULL;
		node *n;
		stmt *fs1 = find_pivot(subset, tv1->s);
		stmt *fs2 = find_pivot(subset, tv2->s);
		stmt *ld = NULL, *rd = NULL;

		if (!fs1 || !fs2) {
			if (fs1) stmt_destroy(fs1);
			if (fs2) stmt_destroy(fs2);
			if (!fs1) {
		     		return sql_error(sql, 02, "Subset %s not found in join expression", tv1->tname);
			} else if (!fs2) {
		     		return sql_error(sql, 02, "Subset %s not found in join expression", tv2->tname);
			} else {
		     		return sql_error(sql, 02, "Subsets %s,%s not found in join expression", tv1->tname, tv2->tname);
			}

		}

		t = tv1;
		if (jointype == jt_left || jointype == jt_full) {
			cvar *cs = t->columns->h->data;
			/* we need to add the missing oid's */
			ld = stmt_diff(stmt_dup(cs->s), stmt_reverse(stmt_dup(fs1)));
			ld = stmt_mark(stmt_reverse(ld), 0);
		}
		t = tv2;
		if (jointype == jt_right || jointype == jt_full) {
			cvar *cs = t->columns->h->data;
			/* we need to add the missing oid's */
			rd = stmt_diff(stmt_dup(cs->s), stmt_reverse(stmt_dup(fs2)));
			rd = stmt_mark(stmt_reverse(rd), 0);
		}
		l1 = create_stmt_list();
		t = tv1;
		for (n = t->columns->h; n; n = n->next) {
			cvar *cs = n->data;

			list_append(l1, stmt_join(stmt_dup(fs1), stmt_dup(cs->s), cmp_equal));
		}
		t = tv2;
		for (n = t->columns->h; n; n = n->next) {
			cvar *cs = n->data;

			list_append(l1, stmt_join(stmt_dup(fs2), stmt_dup(cs->s), cmp_equal));
		}
		if (fs1) stmt_destroy(fs1);
		if (fs2) stmt_destroy(fs2);
		if (jointype == jt_left || jointype == jt_full) {
			list *l2 = create_stmt_list();
			node *m = l1->h;
			t = tv1;
			for (n = t->columns->h; n;
			     n = n->next, m = m->next) {
				cvar *cs = n->data;

				list_append(l2, stmt_append(stmt_dup(m->data), stmt_join (stmt_dup(ld), stmt_dup(cs->s), cmp_equal)));
			}
			t = tv2;
			for (n = t->columns->h; n;
			     n = n->next, m = m->next) {
				cvar *cs = n->data;

				list_append(l2, stmt_append(stmt_dup(m->data), stmt_const (stmt_dup(ld), stmt_atom (atom_general (sql_dup_subtype(tail_type(cs->s)), NULL)))));
			}
			list_destroy(l1);
			l1 = l2;
		}
		if (jointype == jt_right || jointype == jt_full) {
			list *l2 = create_stmt_list();
			node *m = l1->h;
			t = tv1;
			for (n = t->columns->h; n;
			     n = n->next, m = m->next) {
				cvar *cs = n->data;

				list_append(l2, stmt_append(stmt_dup(m->data), stmt_const (stmt_dup(rd), stmt_atom (atom_general (sql_dup_subtype(tail_type(cs->s)), NULL)))));
			}
			t = tv2;
			for (n = t->columns->h; n;
			     n = n->next, m = m->next) {
				cvar *cs = n->data;

				list_append(l2, stmt_append(stmt_dup(m->data), stmt_join (stmt_dup(rd), stmt_dup(cs->s), cmp_equal)));
			}
			list_destroy(l1);
			l1 = l2;
		}
		if (ld) stmt_destroy(ld);
		if (rd) stmt_destroy(rd);
		s = stmt_list(l1);
	}
	if (subset) stmt_destroy(subset);
	return s;
}

static stmt *sql_join(mvc * sql, scope * scp, symbol * q)
{

	dnode *n = q->data.lval->h;
	symbol *tab_ref1 = n->data.sym;
	int natural = n->next->data.ival;
	jt jointype = (jt) n->next->next->data.ival;
	symbol *tab_ref2 = n->next->next->next->data.sym;
	symbol *joinspec = n->next->next->next->next->data.sym;

	return sql_join_(sql, scp, tab_ref1, natural, jointype, tab_ref2, joinspec);
}

stmt *distinct( stmt * s) 
{
	node *n;
	group *grp = NULL;
	list *rl = create_stmt_list();

 	for (n = s->op1.lval->h; n; n = n->next) {
		stmt *t = n->data;
		grp = grp_create(stmt_dup(t), grp, NULL);
	}

 	for (n = s->op1.lval->h; n; n = n->next) {
		stmt *t = n->data;
		list_append(rl, stmt_join(stmt_dup(grp->ext), 
				          stmt_dup(t), cmp_equal));
	}

	if (grp)
		grp_destroy(grp);
	stmt_destroy(s);
	s = stmt_list(rl);
	return s;
}

static stmt *sql_union_(mvc *sql, scope *scp, symbol *t1, int dist, dlist *cols, symbol *t2)
{
	stmt *res;
	node *n, *m;

	tvar *tv1 = table_ref(sql, scp, t1);
	tvar *tv2 = table_ref(sql, scp, t2);
	list *unions = NULL;

	if (!tv1 || !tv2) {
		return NULL;
	}

	if (list_length(tv1->columns) != list_length(tv2->columns)) {
		return sql_error(sql, 02, "Cannot union different ordinality queryes");
	}
	unions = create_stmt_list();
	if (!cols) {
		for (n = tv1->columns->h, m = tv2->columns->h;
			n && m; 
			n = n->next, m = m->next) {
				cvar *lc = n->data;
				cvar *rc = m->data;
				stmt *ls = stmt_dup(lc->s);
	
				/* insert single value into table */
				if (lc->s->key) {
					stmt *temp = stmt_temp(
						sql_dup_subtype(
							tail_type(lc->s)));
					ls = stmt_append(temp, ls);
				}
				ls = stmt_append(ls, stmt_dup(rc->s));
				/* the alias keeps the column name around */
				ls = stmt_alias(ls, lc->cname);
				list_append(unions, ls );
		}
	/* TODO cols length 0 see natural join
	        cols length > 0 see union join, join on name */
	}
	res = stmt_list(unions);
	if (dist) {
		res = distinct(res);
	}
	return res;
}

static stmt *sql_union(mvc * sql, scope * scp, symbol * q)
{

	dnode *n = q->data.lval->h;
	symbol *tab_ref1 = n->data.sym;
	int dist = n->next->data.ival;
	dlist *corresponding = n->next->next->data.lval;
	symbol *tab_ref2 = n->next->next->next->data.sym;
	return sql_union_(sql, scp, tab_ref1, dist, corresponding, tab_ref2 );
}

static stmt *sql_cross(mvc * sql, scope * scp, symbol * q)
{

	dnode *n = q->data.lval->h;
	symbol *tab_ref1 = n->data.sym;
	symbol *tab_ref2 = n->next->data.sym;

	tvar *tv1 = table_ref(sql, scp, tab_ref1);
	tvar *tv2 = table_ref(sql, scp, tab_ref2);
	cvar *cv1;
	cvar *cv2;
	stmt *ct;

	if (!tv1 || !tv2)
		return NULL;

	cv1 = tv1->columns->h->data;
	cv2 = tv2->columns->h->data;

	/* cross product */
	ct = stmt_join(stmt_dup(cv1->s), stmt_reverse(stmt_dup(cv2->s)), cmp_all);

	if (ct) {
		/* add the columns */
		list *rl = create_stmt_list();
		node *nv;

		ct = stmt2pivot(scp, ct);

		for (nv = scp->tables->h; nv; nv = nv->next) {
			node *n;
			tvar *tv = nv->data;
			stmt *foundsubset = find_pivot(ct, tv->s);

			for (n = tv->columns->h; n; n = n->next) {
				cvar *cs = n->data;
				list_append(rl, 
					stmt_join (
						stmt_dup(foundsubset), 
						stmt_dup(cs->s), cmp_equal));
			}
			stmt_destroy(foundsubset);
		}
		stmt_destroy(ct);
		return stmt_list(rl);
	}
	return NULL;
}

static tvar *query_exp_optname(mvc * sql, scope * scp, symbol * q)
{
	tvar *res = NULL;

	switch (q->token) {
	case SQL_UNION:
		{
			scope *nscp = scope_open(scp);
			stmt *tq = sql_union(sql, nscp, q);
			if (!tq) 
				return NULL;
			res = table_optname(sql, scp, tq, QUERY(sql->scanner), q->data.lval->t->data.sym);
			scp = scope_close(nscp);
			return res;
		}
	case SQL_JOIN:
		{
			scope *nscp = scope_open(scp);
			stmt *tq = sql_join(sql, nscp, q);
			if (!tq) 
				return NULL;
			res = table_optname(sql, scp, tq, QUERY(sql->scanner), q->data.lval->t->data.sym);
			scp = scope_close(nscp);
			return res;
		}
	case SQL_CROSS:
		{
			scope *nscp = scope_open(scp);
			stmt *tq = sql_cross(sql, nscp, q);
			if (!tq) 
				return NULL;
			res = table_optname(sql, scp, tq, QUERY(sql->scanner), q->data.lval->t->data.sym);
			scp = scope_close(nscp);
			return res;
		}
	case SQL_UNIONJOIN:
		{
			scope *nscp = scope_open(scp);
			node *m;
			dnode *n = q->data.lval->h;
			/*int all = n->next->data.ival;*/
			tvar *lv = table_ref(sql, nscp, n->data.sym);
			tvar *rv = table_ref(sql, nscp, n->next->next->data.sym);
			list *unions, *matching_columns;

			if (!lv || !rv)
				return NULL;

			/* find the matching columns (all should match?)
			 * union these 
			 * if !all do a distinct operation at the end 
			 */
			/* join all result columns ie join(lh,rh) on column_name */

			matching_columns = join_on_column_name(sql, nscp, lv, rv, 1);

			if (!matching_columns)
				return NULL;

			unions = create_stmt_list();
			for (m = matching_columns->h; m; m = m->next->next) {
				stmt *l = stmt_dup(m->data);
				stmt *r = stmt_dup(m->next->data);
				list_append(unions, stmt_union(l, r));
			}
			res = table_optname(sql, scp, stmt_list(unions), QUERY(sql->scanner), q->data.lval->t->data.sym);
			list_destroy(matching_columns);
			scp = scope_close(nscp);
			return res;
		}
	default:
		printf("case %d %s\n", q->token, token2string(q->token));
	}
	return NULL;
}

/* column expression of the form: table.* */
static stmt *columns_exp(mvc * sql, scope * scp, symbol * column_e, group * grp, stmt * subset, int f)
{
	char *tname = column_e->data.lval->h->data.sval;
	tvar *tv = scope_bind_table(scp, tname);
	(void) sql; /* Stefan: unused!? */
	(void) f;
	
	if (tv) {
		stmt *foundsubset = find_pivot(subset, tv->s);
		list *columns = create_stmt_list();
		node *n = tv->columns->h;
		if (grp)
			foundsubset = stmt_join(stmt_dup(grp->ext), foundsubset, cmp_equal);
		while (n) {
			cvar *cv = n->data;
			list_append(columns, stmt_join(stmt_dup(foundsubset), stmt_dup(cv->s), cmp_equal));
			n = n->next;
		}
		stmt_destroy(foundsubset);
		return stmt_list(columns);
	}
	return NULL;
}


static stmt *
column_exp( mvc * sql, scope * scp, symbol * column_e, group * grp, 
		stmt * subset, int f) 
{
	dlist *l = column_e->data.lval;
	stmt *s = sql_value_exp(sql, scp, l->h->data.sym, grp, subset, f);

	if (!s)
		return NULL;
	/* AS name */
	if (s && l->h->next->data.sval) {
		s = stmt_alias(s, l->h->next->data.sval);
		scope_add_alias(scp, stmt_dup(s), l->h->next->data.sval);
	}
	return s;
}

static stmt *sql_column_exp(mvc * sql, scope * scp, symbol * column_e, group * grp, stmt * subset, int f)
{
	stmt *res = NULL;
	if (column_e->token == SQL_TABLE) {
		res = columns_exp(sql, scp, column_e, grp, subset, f);
	} else if (column_e->token == SQL_COLUMN) {
		res = column_exp(sql, scp, column_e, grp, subset, f);
	}
	if (!res) {
		return sql_error(sql, 02, "Column expression Symbol(%d)->token = %s no output", (int) column_e->token, token2string(column_e->token));
	}
	return res;
}

static list *list_map_merge(list * l2, list * l1)
{
	list *res = list_dup(l1, (fdup)&stmt_dup);
	res = list_merge(res, l2, (fdup)&stmt_dup);
	return res;
}

static list *list_map_append_list(list * l2, list * l1)
{
	return list_append(l1, list_dup(l2, (fdup)&stmt_dup));
}

static stmt *sql_compare(mvc * sql, stmt * ls,
			 stmt * rs, char *compare_op, int f)
{
	int join = 0;
	comp_type type = cmp_equal;

	if (!ls || !rs)
		return NULL;

	/* predicate case ? */
	if (f == sql_sel || (ls->nrcols <= 0 && rs->nrcols <= 0)) {
		return sql_binop_(sql, NULL, compare_op, ls, rs);
	} else if (ls->nrcols > 0 && rs->nrcols > 0) {
		join = 1;
	}
	if (compare_op[0] == '=') {
		type = cmp_equal;
	} else if (compare_op[0] == '<') {
		type = cmp_lt;
		if (compare_op[1] != '\0') {
			if (compare_op[1] == '>') {
				type = cmp_notequal;
			} else if (compare_op[1] == '=') {
				type = cmp_lte;
			}
		}
	} else if (compare_op[0] == '>') {
		type = cmp_gt;
		if (compare_op[1] != '\0') {
			if (compare_op[1] == '=') {
				type = cmp_gte;
			}
		}
	}
	if (join) {
		if (convert_types(sql, &ls, &rs, 1) < 0){
			if (ls) stmt_destroy(ls);
			if (rs) stmt_destroy(rs);
			return NULL;
		}
		if (ls->h && rs->h && ls->h == rs->h) {
			return stmt_uselect(ls, rs, type);
		}
		rs = stmt_reverse(rs);
		return stmt_join(ls, rs, type);
	} else {
		stmt *res;
		if (ls->nrcols == 0) {
			stmt *t = ls;
			ls = rs;
			rs = t;
		}
		if (convert_types(sql, &ls, &rs, 1) < 0){
			if (ls) stmt_destroy(ls);
			if (rs) stmt_destroy(rs);
			return NULL;
		}
		res = stmt_uselect(ls, rs, type);
		if (ls->nrcols == 2 || rs->nrcols == 2)
			res = stmt_filter(res);
		return res;
	}
}

static stmt *sql_compare_exp( mvc *sql, scope *scp, group *grp, stmt *subset, symbol *lo, symbol *ro, char *compare_op, int f )
{
	stmt *rs, *ls = sql_value_exp(sql, scp, lo, grp, subset, f);
	if (!ls)
		return NULL;
	if (ro->token != SQL_SELECT) {
		rs = sql_value_exp(sql, scp, ro, grp, subset, f);
		if (!rs) {
			stmt_destroy(ls);
			return NULL;
		}
		if (grp && (!rs->key || !ls->key)) {
			stmt_destroy(rs);
			stmt_destroy(ls);
			return sql_error(sql, 02, "Cannot compare sets with values, probably a aggregate function missing");
		}
		return sql_compare(sql, ls, rs, compare_op, f);
	} else {
		node *o;
		rs = scope_subquery(sql, scp, ro);

		if (!rs) {
			stmt_destroy(ls);
			return NULL;
		}
		if (rs->type != st_list || list_length(rs->op1.lval) == 0) {
			stmt_destroy(ls);
			stmt_destroy(rs);
			return sql_error(sql, 02, "Subquery result wrong");
		}
		o = rs->op1.lval->h;
		/* no outer references */
		if (list_length(rs->op1.lval) == 1) {
			stmt *sqa = stmt_dup(o->data);
			stmt_destroy(rs);
			return sql_compare(sql, ls, sqa, compare_op, f);
		} else {
			/* for now assume single outer ref ! */
			stmt *oref = stmt_dup(o->next->data);
			stmt *sqa  = stmt_dup(o->data);
			stmt *cmp = NULL;
			stmt *h;

			if( list_length(rs->op1.lval) > 2 || !oref->t) {
				stmt_destroy(oref);
				stmt_destroy(sqa);
				stmt_destroy(rs);
				return sql_error(sql, 02, "comparision between incompatible types");
			}

			cmp = stmt_join(stmt_reverse(oref), sqa, cmp_equal);
			/* need to fix the oref head */
			h = stmt_dup(cmp->h->h);
			stmt_destroy(cmp->h);
			cmp->h = h;

			if (subset){ /* filter subset */
				ls = stmt_join(find_pivot(subset, ls->h), ls, cmp_equal);
			} else {
				ls = stmt_join(scope_find_pivot(scp, ls->h), ls, cmp_equal);
			}
			cmp = sql_compare(sql, ls, cmp, compare_op, f);
			stmt_destroy(rs);
			if (!cmp)
				return NULL;
			return stmt_filter(cmp);
		}
	}
	return NULL;
}

static stmt *sql_and(mvc * sql, stmt * ls, stmt * rs)
{
	stmt *res = NULL;
	(void) sql; /* Stefan: unused!? */

	if (!ls || !rs)
		return NULL;
	if (ls->type != st_set && ls->type != st_sets) {
		ls = stmt_set(ls);
	}
	if (rs->type != st_set && rs->type != st_sets) {
		rs = stmt_set(rs);
	}
	if (ls->type == st_set && rs->type == st_set) {
		list_merge( ls->op1.lval, rs->op1.lval,(fdup)&stmt_dup);
		ls->nrcols = stmt_list_nrcols( ls->op1.lval );
		stmt_destroy(rs);
		res = ls;
	} else if (ls->type == st_sets && rs->type == st_set) {
		res = stmt_sets(list_map(ls->op1.lval, rs->op1.sval,
					(fmap) & list_map_merge));
		stmt_destroy(rs);
		stmt_destroy(ls);
	} else if (ls->type == st_set && rs->type == st_sets) {
		res = stmt_sets(list_map(rs->op1.lval, ls->op1.sval,
					(fmap) & list_map_merge));
		stmt_destroy(rs);
		stmt_destroy(ls);
	} else if (ls->type == st_sets && rs->type == st_sets) {
		res = stmt_sets(list_map(ls->op1.lval, rs->op1.sval,
					(fmap) & list_map_merge));
		stmt_destroy(rs);
		stmt_destroy(ls);
	}
	return res;
}

static stmt *sql_or(mvc * sql, stmt * ls, stmt * rs)
{
	stmt *res = NULL;
	(void) sql; /* Stefan: unused!? */

	if (!ls || !rs)
		return NULL;
	if (ls->type != st_set && ls->type != st_sets) {
		ls = stmt_set(ls);
	}
	if (rs->type != st_set && rs->type != st_sets) {
		rs = stmt_set(rs);
	}
	if (ls->type == st_set && rs->type == st_set) {
		res = stmt_sets(
			list_append( 
			    list_append(
				list_create((fdestroy)&list_destroy),
				  list_dup(ls->op1.lval, (fdup)&stmt_dup)),
				    list_dup(rs->op1.lval, (fdup)&stmt_dup)));
		stmt_destroy(ls);
		stmt_destroy(rs);
	} else if (ls->type == st_sets
		   && rs->type == st_set) {
		list_append(ls->op1.lval, 
				list_dup(rs->op1.lval, (fdup)&stmt_dup));
		res = ls;
		stmt_destroy(rs);
	} else if (ls->type == st_set
		   && rs->type == st_sets) {
		list_append(rs->op1.lval, 
				list_dup(ls->op1.lval, (fdup)&stmt_dup));
		res = rs;
		stmt_destroy(ls);
	} else if (ls->type == st_sets
		   && rs->type == st_sets) {
		(void) list_map(ls->op1.lval, rs->op1.sval,
			(fmap) & list_map_append_list);
		res = ls;
		stmt_destroy(rs);
	}
	return res;
}

stmt *
sql_logical_exp(mvc * sql, scope * scp, symbol * sc, group * grp, stmt * subset, int f)
{
	if (!sc)
		return NULL;
	switch (sc->token) {
	case SQL_OR:
		{
			symbol *lo = sc->data.lval->h->data.sym;
			symbol *ro = sc->data.lval->h->next->data.sym;
			stmt *ls = sql_logical_exp(sql, scp, lo, grp, subset, f);
			stmt *rs = sql_logical_exp(sql, scp, ro, grp, subset, f);
			return sql_or(sql, ls, rs);
		}
		break;
	case SQL_AND:
		{
			symbol *lo = sc->data.lval->h->data.sym;
			symbol *ro = sc->data.lval->h->next->data.sym;
			stmt *ls = sql_logical_exp(sql, scp, lo, grp, subset, f);
			stmt *rs = sql_logical_exp(sql, scp, ro, grp, subset, f);
			return sql_and(sql, ls, rs);
		}
		break;
	case SQL_COMPARE:
		{
			symbol *lo = sc->data.lval->h->data.sym;
			symbol *ro = sc->data.lval->h->next->next->data.sym;
			char *compare_op = sc->data.lval->h->next->data.sval;
			return sql_compare_exp(
				 sql, scp, grp, subset, lo, ro, compare_op, f);
		}
		break;
	case SQL_BETWEEN:
	case SQL_NOT_BETWEEN:
		{
			stmt *res = NULL;
			symbol *lo = sc->data.lval->h->data.sym;
			int symmetric = sc->data.lval->h->next->data.ival;
			symbol *ro1 =
			    sc->data.lval->h->next->next->data.sym;
			symbol *ro2 =
			    sc->data.lval->h->next->next->next->data.sym;
			stmt *ls = sql_value_exp(sql, scp, lo, grp, subset, f);
			stmt *rs1 = sql_value_exp(sql, scp, ro1, grp, subset, f);
			stmt *rs2 = sql_value_exp(sql, scp, ro2, grp, subset, f);
			sql_subtype *ct = NULL;
			if (!ls || !rs1 || !rs2)
				return NULL;
			if (rs1->nr > 0 || rs2->nr > 0) {
				return sql_error(sql, 02, "Between requires an atom on the right handside");
			}
			ct = tail_type(ls);
			rs1 = check_types(sql, ct, rs1);
			rs2 = check_types(sql, ct, rs2);
			if (symmetric) {
				stmt *tmp = NULL;
				sql_subfunc *min = sql_bind_func("min", tail_type(rs1), tail_type(rs2));
				sql_subfunc *max = sql_bind_func("max", tail_type(rs1), tail_type(rs2));
				if (!min || !max) {
					return sql_error(sql, 02, "min or max operator on types %s %s missing",
						 tail_type(rs1)->type->sqlname,
						 tail_type(rs2)->type->sqlname);
				}
				tmp = stmt_binop(rs1, rs2, min);
				rs2 = stmt_binop(rs1, rs2, max);
				rs1 = tmp;
			}
			res = stmt_uselect2(ls, rs1, rs2, 3 
					/* aka rs1 <= ls <= rs2*/);
			if (sc->token == SQL_NOT_BETWEEN)
				res = stmt_diff(ls, res);
			return res;
		}
	case SQL_LIKE:
	case SQL_NOT_LIKE:
	{
		stmt *res = NULL;
		symbol *lo = sc->data.lval->h->data.sym;
		symbol *ro = sc->data.lval->h->next->data.sym;
		stmt *ls = sql_value_exp(sql, scp, lo, grp, subset, f);
		stmt *a = NULL, *e = NULL;
		sql_subtype *st = sql_bind_localtype("str");

		if (!ls)
			return NULL;

		lo = ro->data.lval->h->data.sym;
		a = sql_value_exp(sql, scp, lo, grp, subset, f);
	
		if (!a){
			stmt_destroy(ls);
			return NULL;
		}
		if (dlist_length(ro->data.lval) == 2) {
			symbol *es = ro->data.lval->h->next->data.sym;
			e = sql_value_exp(sql, scp, es, grp, subset, f );
			if (!check_types(sql, st, e) ){
				return sql_error(sql, 02, 
					"Wrong type used with LIKE ESCAPE statment, should be string" );
			}
		}
		if (e) {
			return sql_error(sql, 02, 
			    "LIKE with escapes, is currently not supported");
		}
		if (!check_types(sql, st, a) ){
			return sql_error(sql, 02, 
			    "Wrong type used with LIKE stmt, should be string");
		}
		/* predicate case ? */
		if (ls->nrcols == 0 || f == sql_sel) {
			sql_subtype *bt = sql_bind_localtype( "bit" );
			sql_subtype *s = sql_bind_localtype( "str" );
			char *l = (sc->token == SQL_LIKE ? 
					"like" : "not_like");
			sql_subfunc *like = sql_bind_func_result( l, s, s, bt);

			res = stmt_binop(ls, a, like);
		} else {
			comp_type cmp = (sc->token == SQL_LIKE ? 
					cmp_like : cmp_notlike);
			res = stmt_select(ls, a, cmp);
		}
		return res;
	}
	case SQL_IN:
	case SQL_NOT_IN:
		/*
         <in predicate> ::=
              <row value constructor>
                [ NOT ] IN <in predicate value>

         <in predicate value> ::=
                <table subquery>
              | <left paren> <in value list> <right paren>

         <in value list> ::=
              <value expression> { <comma> <value expression> }...
		*/
		{
			dlist *l = sc->data.lval;
			symbol *lo = l->h->data.sym;
			stmt *ls = sql_value_exp(sql, scp, lo, grp, subset, f);
			if (!ls)
				return NULL;
			if (l->h->next->type == type_list) {
				dnode *n = l->h->next->data.lval->h;
				sql_subtype *ct = tail_type(ls);
				stmt *temp = stmt_temp(sql_dup_subtype(ct));

				for (; n; n = n->next) {
					symbol *sval = n->data.sym;
					stmt *v = sql_value_exp(sql, scp, sval, NULL, NULL, f); 
					temp = stmt_append(temp, 
						check_types(sql, ct, v) );
				}
				if (sc->token == SQL_IN){
					/* predicate case ? */
					if (ls->nrcols == 0 || f == sql_sel) {
						sql_subtype *bt = 
						    sql_bind_localtype( "bit" );
						sql_subtype *tp = tail_type(ls);
						sql_subfunc *exist;

						/* [exist](temp,ls) */
						exist = sql_bind_func_result(
							"exist", tp, tp, bt);
						temp = stmt_reverse(temp);
						return stmt_binop(temp,ls,exist);
					} else { /* normal subquery */
						return stmt_reverse(
							stmt_semijoin(
						 	stmt_reverse(ls), 
						 	stmt_reverse(temp)));
					}
				} else { /* SQL_NOT_IN */
					/* predicate case ? */
					if (ls->nrcols == 0 || f == sql_sel) {
						sql_subtype *bt = 
						    sql_bind_localtype( "bit" );
						sql_subtype *tp = tail_type(ls);
						sql_subfunc *nexist; 
						
						/* [not_exist](temp,ls) */
						/* not_exit needed to handle
						   null correctly */
						nexist = sql_bind_func_result(
						       "not_exist", tp, tp, bt);
						temp = stmt_reverse(temp);
						return stmt_binop(temp,ls,nexist);
					} else { /* normal subquery */
						return stmt_diff(
							stmt_dup(ls), 
							stmt_join(ls, 
					       	  	    stmt_reverse(temp), 
							    cmp_equal));
					}
				}
			} else if (l->h->next->type == type_symbol) {
				symbol *ro = l->h->next->data.sym;
				stmt *sq = scope_subquery(sql, scp, ro);

				if (!sq)
					return NULL;

				if (sq->type != st_list
				    || list_length(sq->op1.lval) == 0) {
					stmt_destroy(sq);
					return sql_error(sql, 02, "Subquery result wrong");
				}
				if (list_length(sq->op1.lval) == 1) {
					stmt *rs = stmt_dup(sq->op1.lval->h->data);
					stmt_destroy(sq);
					if (sc->token == SQL_IN){
					  return
					    stmt_reverse
					    (stmt_semijoin
					     (stmt_reverse(ls),
					      stmt_reverse(rs)));
					} else { /* SQL_NOT_IN */
					  return
					    stmt_reverse
					    (stmt_diff
					     (stmt_reverse(ls),
					      stmt_reverse(rs)));
					}
				} else {	
					/* TODO fix this broken impl ! */
					return sql_error(sql, 03, "time to implement (NOT) IN with outer refs\n");
				}
				return NULL;
			} else {
				return sql_error(sql, 02, "In missing inner query");
			}
		}
		break;
	case SQL_EXISTS:
	case SQL_NOT_EXISTS:
		{
			symbol *lo = sc->data.sym;
			stmt *ls = scope_subquery(sql, scp, lo);

			if (!ls)
				return NULL;

			if (ls->type != st_list) {
				stmt_destroy(ls);
				return sql_error(sql, 02, "Subquery result wrong");
			}
			if (list_length(ls->op1.lval) == 1 || f == sql_sel) {
				/* predicate case */
				/* EXIST non empty result means AND TRUE */
				/* NOT EXIST non empty result means AND FALSE */
				stmt *res, *s = ls->op1.lval->h->data; 
				sql_subaggr *cnt;
				sql_subtype *bt = sql_bind_localtype( "bit" );
				sql_subtype *it = sql_bind_localtype( "int" );

				if (s->nrcols == 0) {
					s = stmt_append(
						stmt_temp(tail_type(s)),
						stmt_dup(s));
				}
 				cnt = sql_bind_aggr("count", NULL);
				res = stmt_dup(s);
				res = stmt_aggr(res, NULL, cnt);
				if (sc->token == SQL_EXISTS){
	    				sql_subfunc *ne = sql_bind_func_result(
						"<>", it, it, bt);
					res = stmt_binop(res, 
						stmt_atom_int(0), ne);
				} else { /* NOT EXISTS */
	    				sql_subfunc *e = sql_bind_func_result(
						"=", it, it, bt);
					res = stmt_binop(res, 
						stmt_atom_int(0), e);
				}
				stmt_destroy(ls);
				return res;
			} else {
				/* for now assume single outer ref ! */
				node *o = ls->op1.lval->h;
				stmt *t, *oref = stmt_dup(o->next->data);

				/* need to fix the oref tail */
				t = stmt_dup(oref->t->t);
				stmt_destroy(oref->t);
				oref->t = t;

				t = stmt_reverse(oref);
				if (sc->token == SQL_NOT_EXISTS) 
					t = stmt_diff(scope_first_pivot(scp),t);
				stmt_destroy(ls);
				return stmt_filter(t);
			}
		}
		break;
	case SQL_NULL:
	case SQL_NOT_NULL:
		{
			symbol *cr = sc->data.sym;
			stmt *res =
			    sql_value_exp(sql, scp, cr, grp, subset, f);

			/* TODO predicate!! */
			if (res) {
				sql_subtype *tpe = sql_dup_subtype(tail_type(res));
				stmt *a = stmt_atom(atom_general(tpe, NULL));

				if (sc->token == SQL_NULL) {
					res = stmt_uselect(res, a, cmp_equal);
				} else {
					res = stmt_uselect(res, a,
							cmp_notequal);
				}
			}
			return res;
		}
		break;
	case SQL_ATOM: {
			AtomNode *an = (AtomNode*)sc;
			/* TRUE or FALSE */
			return stmt_atom(atom_dup(an->a));
		} break;
	default:
		return sql_error(sql, 02, 
			 "Predicate %s %d: time to implement some more",
			 token2string(sc->token), sc->token);
	}
	return sql_error(sql, 02, "Predicate: time to implement some more");
}

static group *query_groupby_inner(mvc * sql, scope * scp, stmt * c, stmt * subset, group * cur)
{
	stmt *s = find_pivot(subset, c->h);
	(void) scp; /* Stefan: unused!? */

	if (s) {
		stmt *j = stmt_join(s, c, cmp_equal);
		cur = grp_create(j, cur, c);
	}

	if (!cur) {
		char *cn = column_name(c);
		assert(cur);
		(void) sql_error(sql, 02, 
			 "subset not found for groupby column %s\n", cn);
		_DELETE(cn);
		return NULL;
	}
	return cur;
}

static group *query_groupby(mvc * sql, scope * scp, symbol * groupby, stmt * subset)
{
	group *cur = NULL;
	dnode *o = groupby->data.lval->h;
	while (o) {
		symbol *grp = o->data.sym;
		stmt *c = sql_column_ref(sql, scp, grp);
		if (!c) {
			if (cur) grp_destroy(cur);
			return NULL;
		}
		cur = query_groupby_inner(sql, scp, c, subset, cur);
		o = o->next;
	}
	return cur;
}

static group *query_groupby_outers(mvc * sql, scope * scp, stmt * subset)
{
	group *cur = NULL;
	node *o = scp->outers->h;
	(void) sql; /* Stefan: unused!? */

	for ( ; o; o = o->next) {
		stmt *outer = o->data;
		stmt *s = find_pivot(subset, outer);
		if (s) 
			cur = grp_create(s, cur, NULL);
	}
	return cur;
}

/*
   select column_1, column_2 from x order by column_1, column_2;

   As SQL-3 drop support for order by number (column position in result table)
   so we also do not support it. Unfortunately SQL-3 added new crap,
   order by 'expression', where expression should match a result column 
   expression. We also do not support this (just use as bla and order by bla!).
   SQL-3 supports ordering on columns not in the result table, but again we
   don't.
 */
static stmt *
orderby_column_ref(mvc * sql, symbol * column_r, stmt *s)
{
	dlist *l = column_r->data.lval;

	assert(column_r->token == SQL_COLUMN
	       && column_r->type == type_list);

	if (dlist_length(l) == 1) {
		char *name = l->h->data.sval;
		node *n;

 		for (n = s->op1.lval->h; n; n = n->next) {
			stmt *t = n->data;
			char *cn = column_name(t);

			if (strcmp(cn, name) == 0){
				_DELETE(cn);
				return stmt_dup(t);
			}
			_DELETE(cn);
		}
		return sql_error( sql, 02, "Unknown column name (%s) in order by", name );
	}
	return sql_error( sql, 02, "Only single column names supported in order by" );
}

static stmt *query_orderby(mvc * sql, symbol * orderby, stmt * s )
{
	stmt *cur = NULL;
	dnode *o = orderby->data.lval->h;

	while (o) {
		symbol *order = o->data.sym;
		if (order->token == SQL_COLUMN) {
			symbol *col = order->data.lval->h->data.sym;
			int direction = order->data.lval->h->next->data.ival;
			stmt *sc = orderby_column_ref(sql, col, s);

			if (sc) {
				if (cur)
					cur = stmt_reorder(cur, sc, direction);
				else
					cur = stmt_order(sc, direction);
			} else {
				return NULL;
			}
		} else {
			return sql_error(sql, 02, "order not of type SQL_COLUMN\n");
		}
		o = o->next;
	}
	return cur;
}

static stmt *sql_simple_select(mvc * sql, scope * scp, symbol *where, dlist * selection)
{
	stmt *s = NULL;
	list *rl;
	dnode *n = selection->h;

	if (where) {
		s = sql_logical_exp(sql, scp, where, NULL, NULL, sql_where);
		if (!s) 
			return NULL;
		if (s->type != st_set && s->type != st_sets) {
			s = stmt_set(s);
		}
		s = stmt2pivot(scp, s);
	}	
 	rl = create_stmt_list();
	while (n) {
		stmt *cs = sql_column_exp(sql, scp, n->data.sym, NULL, NULL, sql_sel);

		if (!cs) {
			list_destroy(rl);
			return NULL;
		}

		/* t1.* */
		if (cs->type == st_list && n->data.sym->token == SQL_TABLE) {
			list_merge(rl, cs->op1.lval, (fdup)&stmt_dup);
			stmt_destroy(cs);
		} else if (cs->type == st_list) {	/* subquery */
			if (list_length(cs->op1.lval) == 1){ 
				list_append(rl, stmt_dup(cs->op1.lval->h->data));
			} else {
				stmt_destroy(cs);
				return sql_error( sql, 02, "Subquery should return a single value");
			}
		/*
		} else if (cs->nrcols == 0){
			list_append(rl, cs);
		*/
		} else {
			list_append(rl, cs);
		}
		n = n->next;
	}
	if (s) {
		list *nl = create_stmt_list();
		node *n;

		for( n = rl->h; n; n = n->next ) {
			stmt *v = n->data;
			stmt *t = stmt_temp(sql_dup_subtype(tail_type(v)));

			t = stmt_predicate( stmt_dup(s), t, stmt_dup(v));
			list_append(nl, t);
		}
		stmt_destroy(s);
		list_destroy(rl);
		rl = nl;
	}
	s = stmt_list(rl);

	if (!s)
		return sql_error(sql, 02, "Subquery result missing");
	return s;
}

static stmt *sql_select(mvc * sql, scope * scp, SelectNode *sn, int toplevel )
{
	list *rl = NULL;
	stmt *s = NULL;

	stmt *order = NULL, *subset = NULL;
	group *grp = NULL;

	if (!sn->from)
		return sql_simple_select(sql, scp, sn->where, sn->selection);

	if (sn->where) {
		node *n;
		stmt *cur = NULL;

		s = sql_logical_exp(sql, scp, sn->where, NULL, NULL, sql_where);
		if (!s) {
			sql_select_cleanup(sql, s, subset, grp);
			return sql_error( sql, 02, "Subquery result missing");
		}
		if (s->type != st_set && s->type != st_sets) {
			s = stmt_set(s);
		}
		/* check for tables not used in the where part */
		if (s->type == st_set){ /* TODO: handle st_sets!! */
		    for (n = scp->tables->h; n; n = n->next) {
			tvar *v = n->data;
			stmt *tmp = complex_find_subset(s, v->s);
			if (!tmp) {
				cvar *cv = v->columns->h->data;
				tmp = stmt_dup(cv -> s);
				/* just add a select whole column */
				if (!cur) {
					cur = stmt_dup(tmp);
				/* add join to an already used column */
				} else {	
					tmp = stmt_join(stmt_dup(cur),
						stmt_reverse(tmp), cmp_all);
				}
				s = sql_and(sql, s, tmp);
			} else if (!cur) {
				cur = tmp;
			} else {
				stmt_destroy(tmp);
			}
		    }
		}
		if (cur) 
			stmt_destroy(cur);
		
	} else if (sn->from) {
		node *n;
		stmt *cur = NULL;
		for (n = scp->tables->h; n; n = n->next) {
			tvar *tv = n->data;
			cvar *cv = tv->columns->h->data;
			stmt *tmp = stmt_dup(cv -> s);
			if (!cur) {
				if (isbasetable(tv->s)){
					cur = stmt_diff(tmp, stmt_reverse(
					   stmt_tbat(basetable_table(tv->s), RDONLY )));
				} else {
					cur = tmp;
				}
			} else {
				tmp = stmt_join(stmt_dup(cur), 
						stmt_reverse(tmp), cmp_all);
				if (s) {
					list_append(s->op1.lval, tmp);
				} else {
					s = stmt_set(tmp);
				}
			}
		}
		if (!cur) {
			sql_select_cleanup(sql, s, subset, grp);
			return sql_error(sql, 02, "Subquery has no columns");
		}
		if (!s)
			s = cur;
		else
			stmt_destroy(cur);
	}

	if (s) {
		s = stmt2pivot(scp, s);
		if (s && sn->groupby) {
			grp = query_groupby(sql, scp, sn->groupby, s);
			if (!grp)  {
				sql_select_cleanup(sql, s, subset, grp);
				return sql_error( sql, 02, "Subquery result missing");
			}
		}

		if (s && list_length(scp->outers) > 0) {
			assert(!grp);
			grp = query_groupby_outers(sql, scp, s);
			if (!grp) {
				assert(0);
				sql_select_cleanup(sql, s, subset, grp);
				return sql_error( sql, 02, "Subquery outer ref groupby result missing");
			}
		}
	}

	subset = stmt_dup(s);
	if (sn->having) {
		if (s) stmt_destroy(s);
		s = sql_logical_exp(sql, scp, sn->having, 
					grp, subset, sql_where);

		if (!s){
			sql_select_cleanup(sql, s, subset, grp);
			return sql_error( sql, 02, "Subquery result missing");
		}

		if (!grp) {
			sql_subtype *it = sql_bind_localtype( "int" );

			/* implicit single group of whole result */
			grp = grp_create(stmt_const(stmt_dup(subset),
				stmt_atom(atom_int(sql_dup_subtype(it), 0))), 
			      NULL, NULL);
		}
		grp = grp_semijoin(grp, stmt_dup(s));
	}

	if (!subset){
		sql_select_cleanup(sql, s, subset, grp);
		return sql_error( sql, 02, "Subquery result missing");
	}

	rl = create_stmt_list();
	if (sn->selection) {
		list *sl = create_stmt_list();
		dnode *n;
		node *m;
		int nrcols = 0;

		for (n = sn->selection->h; n; n = n->next ){
			stmt *cs = sql_column_exp(sql, scp, n->data.sym, grp, subset, sql_sel);
			if (!cs){
				list_destroy(sl);
				list_destroy(rl);
				sql_select_cleanup(sql, s, subset, grp);
				return sql_error( sql, 02, "Subquery result missing");
			}

			list_append(sl, cs);
			if (nrcols < cs->nrcols)
				nrcols = cs->nrcols;
		}

		for (m = sl->h, n = sn->selection->h; 
		     m && n; 
		     m = m->next, n = n->next){
			stmt *cs = m->data; 
			/* t1.* */
			if (cs->type == st_list && n->data.sym->token == SQL_TABLE){
				list_merge(rl, cs->op1.lval, (fdup)&stmt_dup);
			} else if (cs->type == st_list) {	/* subquery */
				if (list_length(cs->op1.lval) == 1) {	/* single value */
					stmt *ss = ptable_pivots(subset)->h->data;
					stmt *cs1 = cs->op1.lval->h->data;
					ss = stmt_dup(ss);
					cs1 = stmt_dup(cs1);
					list_append(rl, stmt_join (ss, cs1, cmp_all));
				} else {	/* referenced variable(s) (can only be 2) */
					stmt *sqa = cs->op1.lval->h->data;
					stmt *ids = cs->op1.lval->h->next->data;
					stmt *s = stmt_join( 
						stmt_reverse(stmt_dup(ids)),
						stmt_dup(sqa), cmp_equal);
					s = stmt_outerjoin(
						stmt_mirror(
						    first_subset(subset)), 
						s, cmp_equal);
					list_append(rl, s);
				}
			} else if (cs->nrcols == 0) {
				/* select name,count(*) should give an error */
				if (cs->aggr && nrcols > 0){
					list_destroy(sl);
					list_destroy(rl);
					sql_select_cleanup(sql, s, subset, grp);
					return sql_error( sql, 02, "single value in column expression");
				} else if (!cs->aggr && nrcols != 0) {
					stmt *ss = first_subset(subset);
					cs = stmt_const(ss,stmt_dup(cs));
					list_append(rl, cs);
				} else {
					cs = stmt_dup(cs);
					list_append(rl, cs);
				}
			} else {
				cs = stmt_dup(cs);
				list_append(rl, cs);
			}
		}
		list_destroy(sl);
	} else {
		/* select * from tables */
		if (grp && list_length(scp->outers) <= 0) {
			list_destroy(rl);
			sql_select_cleanup(sql, s, subset, grp);
			return sql_error( sql, 02, "Cannot combine select * with group by");
		}
		if (toplevel) {
			node *nv;
			for (nv = scp->tables->h; nv; nv = nv->next) {
				node *n;
				tvar *tv = nv->data;
				stmt *foundsubset = find_pivot(subset, tv->s);

				for (n = tv->columns->h; n; n = n->next) {
					stmt *s;
					cvar *cs = n->data;
					stmt *cbat = stmt_dup(cs->s);
					/* selected only a single row ?? */
					if (subset->nrcols == 0) {
						s = cbat;
					} else {
						s = stmt_join(stmt_dup(foundsubset), cbat, cmp_equal);
					}
					list_append(rl, s);
				}
				stmt_destroy(foundsubset);
			}
		} else {
			/* 
			 * subquery can only return one column
			 */
			tvar *tv = scope_first_table(scp);
			stmt *foundsubset = find_pivot(subset, tv->s);

			if (!foundsubset){
				list_destroy(rl);
				sql_select_cleanup(sql, s, subset, grp);
				return sql_error( sql, 02, "Subquery result missing");
			}
			list_append(rl, foundsubset);
		}
	}
	/* the inner query should output a table where the first bat
	 * contains the queried column values. 
	 * If variables from the outer query are correlated 
	 * the oids from the base tables of these variables are returned
	 * in the next columns.
	 */
	if (list_length(scp->outers) > 0) {
		node *n = scp->outers->h;
		for (; n; n = n->next) {
			stmt *oref = n->data;
			stmt *foundsubset = find_pivot(subset, oref);

			if (!foundsubset){
				list_destroy(rl);
				sql_select_cleanup(sql, s, subset, grp);
				return sql_error( sql, 02, "Subquery result missing");
			}
			list_append(rl, stmt_join( stmt_dup(grp->ext), 
					   foundsubset, cmp_equal));
		}
	}
	stmt_destroy(s);
	s = stmt_list(rl);

	if (s && subset && sn->distinct){
		s = distinct(s);
	}

	if (s && subset && sn->orderby) {
		order = query_orderby(sql, sn->orderby, s);
		if (!order) {
			sql_select_cleanup(sql, s, subset, grp);
			return sql_error( sql, 02, "Subquery result missing");
		}
	}

	if (!s) {
		sql_select_cleanup(sql, s, subset, grp);
		return sql_error( sql, 02, "Subquery result missing");
	}

	sql_select_cleanup(sql, NULL, subset, grp);

	if (sn->limit >= 0){
		if (order) 
			order = stmt_limit(order, sn->limit);
		else 
			order = stmt_limit(stmt_dup(s->op1.lval->h->data), sn->limit);
	}

	if (s && order)
		return stmt_ordered(order, s);
	return s;
}


stmt *
selects(mvc * sql, symbol * s) 
{
	stmt *ret = NULL;

	switch (s->token) {
	case SQL_SELECT:
		ret = scope_subquery(sql, NULL, s);
		/* add output stmt */
		if (ret) 
			ret = stmt_output(ret);
		sql->type = Q_TABLE;
		break;
	case SQL_JOIN:
		ret = sql_join(sql, NULL, s);
		/* add output stmt */
		if (ret) 
			ret = stmt_output(ret);
		sql->type = Q_TABLE;
		break;
	case SQL_CROSS:
		ret = sql_cross(sql, NULL, s);
		/* add output stmt */
		if (ret) 
			ret = stmt_output(ret);
		sql->type = Q_TABLE;
		break;
	case SQL_UNION:
		ret = sql_union(sql, NULL, s);
		/* add output stmt */
		if (ret) 
			ret = stmt_output(ret);
		sql->type = Q_TABLE;
		break;
	case SQL_EXCEPT:
		ret = sql_union(sql, NULL, s);
		/* add output stmt */
		if (ret) 
			ret = stmt_output(ret);
		sql->type = Q_TABLE;
		break;
	case SQL_INTERSECT:
		ret = sql_union(sql, NULL, s);
		/* add output stmt */
		if (ret) 
			ret = stmt_output(ret);
		sql->type = Q_TABLE;
		break;
	default:
		return sql_error(sql, 01, 
			 "Select statement unknown Symbol(%ld)->token = %s",
			 (long) s, token2string(s->token));
	}
	return ret;
}
