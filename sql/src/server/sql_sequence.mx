@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2005 CWI.
@' All Rights Reserved.

@f sql_sequence
@a N.J. Nes
@* 

@h
#ifndef _SQL_SEQUENCE_H_
#define _SQL_SEQUENCE_H_

#include "sql_symbol.h"
#include <sql_statement.h>

sql_export int sql_create_sequences(mvc *sql, sql_schema *s);
sql_export stmt *sequences(mvc * sql, symbol * s);

#endif /*_SQL_SEQUENCE_H_*/
@c

#include "sql_sequence.h"
#include "sql_semantic.h"
#include "sql_privileges.h"

int
sql_create_sequences( mvc *m, sql_schema *s ) 
{
	sql_table *t;

	t = mvc_create_table(m, s, "sequences", 1, 1, 0, -1 );
	mvc_create_column_(m, t, "name", "varchar", 0);
	mvc_create_column_(m, t, "curvalue", "int", 18);
	mvc_create_column_(m, t, "increment", "int", 4);
	mvc_create_column_(m, t, "minvalue", "int", 18);
	mvc_create_column_(m, t, "maxvalue", "int", 18);
	mvc_create_column_(m, t, "cycle", "boolean", 0);
	return 0;
}

static int 
find_seq( mvc *m, str seq )
{
	int res = 0;
	sql_schema *sys = find_schema( m->trans, "sys" );
	sql_table *seqs = find_table( sys, "sequences" );
	sql_column *seqname = find_column( seqs, "name" );
	ssize_t rid = column_find_row( m->trans, seqname, seq, NULL );
	
	if (rid >= 0)
		res = 1;
	return res;
}


static stmt *
sql_create_seq(mvc * sql, sql_schema *ss, dlist *qname, sql_subtype *tpe, 
		     int start, int inc, int min, int max, int cycle) 
{
	char buf[BUFSIZ];
	char *name = qname_table(qname);

	(void)tpe;
	if (find_seq( sql, name)) {
		return sql_error(sql, 02, 
		    	"CREATE SEQUENCE failed: " 
			"name %s already in use", 
			name);
	} else if (!schema_privs(sql->role_id, ss)){
		return sql_error(sql, 02, 
		    "User/Role is not allowed to create sequences in schema %s", 
		    ss->base.name);
	}
	snprintf(buf, BUFSIZ,
			"insert into sys.sequences values " 
			"('%s', %d, %d, %d, %d, %s);",
			name, start, inc, min, max, cycle?"true":"false");
	return stmt_sql(_strdup(buf));
}

static stmt *
sql_drop_seq(mvc * sql, sql_schema *ss, dlist *qname) 
{
	char buf[BUFSIZ];
	char *name = qname_table(qname);

	if (!find_seq( sql, name)) {
		return sql_error(sql, 02, 
			"DROP SEQUENCE failed: no such sequence %s", 
			name);
	} else if (!schema_privs(sql->role_id, ss)){
		return sql_error(sql, 02, 
		    "User/Role is not allowed to drop sequences in schema %s", 
		    ss->base.name);
	}
	snprintf(buf, BUFSIZ, 
		"delete from sys.sequences where name = '%s';", name);
	return stmt_sql(_strdup(buf));
}

stmt *sequences(mvc * sql, symbol * s)
{
	stmt *res = NULL;
	
	switch (s->token) {
	case SQL_CREATE_SEQ: {
		dlist *l = s->data.lval;
		res = sql_create_seq( 
			sql, 
			cur_schema(sql),
			l->h->data.lval,
			l->h->next->data.typeval,
			l->h->next->next->data.ival,
			l->h->next->next->next->data.ival,
			l->h->next->next->next->next->data.ival,
			l->h->next->next->next->next->next->data.ival,
			l->h->next->next->next->next->next->next->data.ival);
	}	break;
	case SQL_DROP_SEQ: {
		dlist *l = s->data.lval;
		res = sql_drop_seq( 
			sql, 
			cur_schema(sql),
			l->h->data.lval );
	}	break;
	default:
		return sql_error(sql, 01, 
			 "sql_stmt Symbol(%ld)->token = %s",
			 (long) s, token2string(s->token));
	}
	return res;
}
