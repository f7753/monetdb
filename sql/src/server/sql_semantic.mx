@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@' 
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@' 
@' The Original Code is the Monet Database System.
@' 
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2004 CWI.
@' All Rights Reserved.
@' 
@' Contributor(s):
@' 		Martin Kersten <Martin.Kersten@cwi.nl>
@' 		Peter Boncz <Peter.Boncz@cwi.nl>
@' 		Niels Nes <Niels.Nes@cwi.nl>
@' 		Stefan Manegold  <Stefan.Manegold@cwi.nl>

@f sql_semantic
@a N.J. Nes
@* 

@h
#ifndef _SQL_SEMANTIC_H_
#define _SQL_SEMANTIC_H_

#include <stdio.h>
#include <stdarg.h>
#include <sql_list.h>
#include "sql_symbol.h"
#include "sql_parser.h"
#include "sql_scope.h"

sql_export stmt *semantic( mvc * sql, symbol * sym);

sql_export sql_schema *cur_schema( mvc *sql );
sql_export sql_schema *qname_schema(mvc *sql, dlist * qname);
sql_export char *qname_table(dlist * qname);
sql_export tvar *scope_add_table_columns(mvc * sql, scope * scp, sql_table * t, char *tname);

sql_export void cleanup_stmts(stmt **stmts, int cnt);
sql_export stmt *sql_insert(mvc * sql, sql_table *t, stmt **inserts, int len);
sql_export stmt *sql_delete( mvc *sql, tvar *tv, sql_table *t, stmt *s );
sql_export stmt *sql_subquery(mvc * sql, scope * scp, symbol * sq);

sql_export void sql_add_arg( mvc *sql, atom *v );		/* used in src/server/sql_parser.y */
sql_export void sql_add_param( mvc *sql, char *name, stmt *s );	/* used in src/server/sql_parser.y */
sql_export void sql_destroy_params( mvc *sql );			/* used in backend */
sql_export void sql_destroy_args( mvc *sql );			/* used in backend */

#endif /*_SQL_SEMANTIC_H_*/

@c

#include "sql_parser.h"
#include "sql_symbol.h"
#include "sql_statement.h"
#include "sql_semantic.h"
#include "sql_trans.h"
#include "sql_schema.h"
#include "sql_privileges.h"

#include <unistd.h>
#include <stdio.h>
#include <string.h>
#include <ctype.h>

#define create_string_list() list_create((fdestroy)&GDKfree)

/* 
 * For debugging purposes we need to be able to convert sql-tokens to 
 * a string representation.
 *
 *
 * !SQL ERROR <sqlerrno> : <details>
 * !SQL DEBUG  <details>
 * !SQL WARNING <details>
 * !SQL  <informative message, reserved for ...rows affected>
 *
 * Todo add insert bats used for inserts (ie should change the 
 * 	query code to use the global bats (mvc_bat) in read only mode).
 */

void sql_add_arg( mvc *sql, atom *v )
{
	if (!sql->args)
		sql->args = list_create((fdestroy)&atom_destroy);
	list_append(sql->args, v);
}

void sql_add_param( mvc *sql, char *name, stmt *s )
{
	var_ *v = NEW(var_);

	v->name = name;
	v->s = s;
	sql_ref_init( &(v->ref) );

	if (!sql->params)
		sql->params = list_create((fdestroy)&var_destroy);
	list_append(sql->params, v);
}

stmt *sql_bind_param( mvc *sql, char *name )
{
	node *n;
	if (sql->params){
		for(n = sql->params->h; n; n = n->next)
		{
			var_ *v = n->data;
			if (strcmp(v->name, name) == 0){
				return stmt_dup(v->s);
			}
		}
	}
	return NULL;
}

void sql_destroy_params( mvc *sql )
{
	if (sql->params)
		list_destroy(sql->params);
	sql->params = NULL;
}

void sql_destroy_args( mvc *sql )
{
	if (sql->args)
		list_destroy(sql->args);
	sql->args = NULL;
}


static stmt *sql_select(mvc * sql, scope * scp, SelectNode *sn, int toplevel );
static stmt *sql_simple_select(mvc * sql, scope * scp, dlist * selection);
static stmt *sql_logical_exp(mvc * sql, scope * scp, symbol * sc, group * grp, stmt * subset);
static stmt *sql_value_exp(mvc * sql, scope * scp, symbol * se, group * grp, stmt * subset);
static stmt *sql_compare_exp( mvc *sql, scope *scp, group *grp, stmt *subset, symbol *lo, symbol *ro, char *compare_op );

static tvar *query_exp_optname(mvc * sql, scope * scp, symbol * q);
static tvar *sql_subquery_optname(mvc * sql, scope * scp, symbol * query);

sql_schema *cur_schema( mvc *sql )
{
	return sql->trans->schema;
}

static void sql_select_cleanup( mvc * sql, stmt *s, stmt *subset, group *grp )
{
	(void) sql; /* Stefan: unused!? */

	if (grp)
		grp_destroy(grp);
	if (subset)
		stmt_destroy(subset);
	if (s)
		stmt_destroy(s);
}

sql_schema *qname_schema(mvc *sql, dlist * qname)
{
	sql_schema *s = cur_schema(sql);
	assert(qname && qname->h);

	if (dlist_length(qname) == 2) {
		char *name = qname->h->data.sval;
		s = mvc_bind_schema(sql, name);
	}
	return s;
}

char *qname_table(dlist * qname)
{
	assert(qname && qname->h);

	if (dlist_length(qname) == 1) {
		return qname->h->data.sval;
	} else if (dlist_length(qname) == 2) {
		return qname->h->next->data.sval;
	}
	return "Unknown";
}

static stmt *
sqlparse_intern(mvc *m, char *query) 
{
	mvc o = *m;
	stmt *sq;

	m->qc = NULL;
	m->cache = 0;

	scanner_reset(&m->scanner, query);

	m->params = NULL;
	m->args = NULL;
	m->sym = NULL;

	(void)sqlparse(m); /* blindly ignore errors */
	sq = sql_subquery(m, NULL, m->sym);

	symbol_destroy(m->sym);
	*m = o;
	return sq;
}

tvar *scope_add_table_columns(mvc * sql, scope * scp, sql_table * t, char *tname)
{
	node *n, *m;
	tvar *tv = NULL;

	if (t->type == tt_view){

		if (!t->st){
			stmt *sq = sqlparse_intern(sql, t->query);

			t -> st = sq;
			for ( n = t->columns.set->h, m = sq->op1.lval->h;
					n && m; n = n->next, m = m->next) {
				sql_column *c = n->data;
				stmt *sc = stmt_dup(m->data);

				sc = stmt_alias(sc, c->base.name);
				c->st = stmt_ibat(sc, stmt_dup(sq));
			}
		}
		tv = scope_add_table(scp, stmt_dup(t->st), tname);
		for ( n = t->columns.set->h; n; n = n->next) {
			sql_column *c = n->data;
			stmt *sc = stmt_dup(c->st);
			table_add_column(tv, sc, NULL, c->base.name);
		}
	} else {
		stmt *ts;

		tv = scope_add_table(scp, ts = stmt_basetable(t), tname);
		for ( n = t->columns.set->h; n; n = n->next) {
			sql_column *c = n->data;
			stmt *sc = stmt_cbat(c, stmt_dup(ts), RDONLY, st_bat);
			table_add_column(tv, sc, NULL, c->base.name);
		}
	}
	return tv;
}

static tvar *table_ref(mvc * sql, scope * scp, symbol * tableref)
{
	char *tname = NULL;
	sql_table *t = NULL;

	/* todo handle opt_table_ref 
	   (ie tableref->data.lval->h->next->data.sym */

	if (tableref->token == SQL_NAME) {
		sql_schema *s = qname_schema(sql, tableref->data.lval->h->data.lval);
		tname = qname_table(tableref->data.lval->h->data.lval);
				
		if (!s){
			(void) sql_error( sql, 02, "Unknown schema");
			return NULL;
		}
		t = mvc_bind_table(sql, s, tname);
		if (!t) {
			(void) sql_error( sql, 02, "Unknown table %s", tname);
			return NULL;
		}
		if (tableref->data.lval->h->next->data.sym) {	/* AS */
			tname = tableref->data.lval->h->next->data.sym->data.lval->h->data.sval;
		}
		return scope_add_table_columns(sql, scp, t, tname);
	} else if (tableref->token == SQL_TABLE) {
		stmt *s = sql_value_exp(sql, scp, tableref->data.lval->h->data.sym, NULL, NULL);
		char *tname = tableref->data.lval->h->next->data.sym->data.lval->h->data.sval;

		if (!s) 
			return NULL;
		return scope_add_table(scp, s, tname);
	} else if (tableref->token == SQL_SELECT) {
		return sql_subquery_optname(sql, scp, tableref);
	} else {
		return query_exp_optname(sql, scp, tableref);
	}
}

stmt *sql_subquery(mvc * sql, scope * scp, symbol * sq)
{
	int toplevel = (!scp) ? 1 : 0;
	stmt *res = NULL;
	SelectNode *sn = (SelectNode*)sq;
	assert(sn->s.token == SQL_SELECT);

	if (!toplevel && sn->limit >= 0){
		(void) sql_error( sql, 01, "Can only limit outer select " );
		return NULL;
	}
	if (!toplevel && sn->orderby){
		(void) sql_error( sql, 01, "Can only order by outer select " );
		return NULL;
	}

	if (sn->from) {		/* keep variable list with tables and names */
		dlist *fl = sn->from->data.lval;
		dnode *n = NULL;
		tvar *fnd = (tvar *) 1L; /* 1L to keep 64-bit compilers from complaining *
		                          * about different sizes of int and pointer     */

		if (toplevel)
			scp = scope_open(scp);

		for (n = fl->h; (n && fnd); n = n->next)
			fnd = table_ref(sql, scp, n->data.sym);

		if (!fnd){
			if (toplevel && scp)
				scp = scope_close(scp);
			return NULL;
		}

	} else if (toplevel) {	/* only on top level query */
		scp = scope_open(scp);
		res = sql_simple_select(sql, scp, sn->selection);
		scp = scope_close(scp);
		return res;
	}

	res = sql_select(sql, scp, sn, toplevel );

	if (toplevel && scp)
		scp = scope_close(scp);

	return res;
}

static stmt *scope_subquery(mvc * sql, scope * scp, symbol * sq)
{
	scope *nscp = scope_open(scp);
	stmt *s = sql_subquery(sql, nscp, sq);
	scp = scope_close(nscp);
	return s;
}


/* 
 * Column references, can be done using simple names or aliases and
 * using a combination of table name and column name (or alias).
 * The sql_column_ref finds the column based on the specification from
 * symbol column_r.
 * A special column reference is 'rowid'.
 */

static stmt *sql_column_ref(mvc * sql, scope * scp, symbol * column_r)
{
	stmt *cs = NULL;
	dlist *l = column_r->data.lval;

	assert(column_r->token == SQL_COLUMN
	       && column_r->type == type_list);

	if (dlist_length(l) == 1) {
		char *name = l->h->data.sval;

		if (strcasecmp(name, "rowid") == 0){
			cvar *cv = scope_first_column(scp);
			return stmt_mirror(stmt_dup(cv->s));
		} else if (!(cs = scope_bind(scp, NULL, name))) {
			/* maybe simple param */
			cs = sql_bind_param(sql, name);
			if (!cs)
				return sql_error( sql, 02, 
					"Identifier: %s unknown or ambigious", name);
		}
	} else if (dlist_length(l) == 2) {
		char *tname = l->h->data.sval;
		char *cname = l->h->next->data.sval;

		if (strcasecmp(cname, "rowid") == 0){
			tvar *tv = scope_bind_table(scp, tname);
			cvar *cv;
			if (!tv){
				return sql_error( sql, 02, 
					"Identifier: %s unknown", tname);
			}
			cv = tv->columns->h->data;
			return stmt_mirror(stmt_dup(cv->s));
		} else if (!(cs = scope_bind(scp, tname, cname))) {
			return sql_error( sql, 02, "Column: %s.%s unknown", tname, cname);
		}
	} else if (dlist_length(l) >= 3) {
		return sql_error( sql, 02, "TODO: column names of level >= 3" );
	}
	return cs;
}

static char *tmp_table_name()
{
	oid id = OIDnew(1);
	static char buf[BUFSIZ];
	snprintf(buf, BUFSIZ, "c%ld", id );
	return buf;
}

static sql_table *create_table_intern(mvc * sql, sql_schema * schema,
				  char *name, char *query, stmt * sq, table_type type)
{
	node *m;
	sql_table *table = mvc_create_table(sql, schema, name, type, -1);
	(void) query; /* Stefan: unused!? */

       	for ( m = sq->op1.lval->h; m; m = m->next ) {
		stmt *st = m->data;
		sql_subtype *tp = tail_type(st);
		char *cname = column_name(st);

		(void)mvc_create_column(sql, table, cname, 
			tp->type->sqlname, tp->digits, tp->scale);
		_DELETE(cname);
	}
	return table;
}

static tvar *table_optname(mvc * sql, scope * scp, stmt * sq,
			   char *query, symbol * optname)
{
	node *m;
	char *tmpname = NULL;
	char *tname = NULL;
	dlist *columnrefs = NULL;
	tvar *tv;
	sql_schema *schema = cur_schema(sql);

	if (optname && optname->token == SQL_NAME) {
		tmpname = tname = optname->data.lval->h->data.sval;
		columnrefs = optname->data.lval->h->next->data.lval;
	} else {	
		tmpname = tmp_table_name();
	}
	(void)create_table_intern(sql, schema, tmpname, query, sq, tt_temp);
	tv = scope_add_table(scp, sq, tname);
	if (columnrefs) {
		dnode *d;

		for (m = sq->op1.lval->h, d = columnrefs->h; 
		     d && m; 
		     d = d->next, m = m->next) {
			stmt *st = m->data;
			stmt *sc = stmt_ibat(stmt_alias(stmt_dup(st), d->data.sval), stmt_dup(sq));

			table_add_column(tv, sc, tname, d->data.sval);
		}
	} else if (tname) {
		/* foreach column add column name */
		for ( m = sq->op1.lval->h; m; m = m->next) {
			stmt *st = m->data;
			char *cname = column_name(st);
			stmt *sc = stmt_ibat(stmt_dup(st), stmt_dup(sq));

			table_add_column(tv, sc, tname, cname);
			_DELETE(cname);
		}
	} else {
		/* foreach column add full basetable,column name */
		for ( m = sq->op1.lval->h; m; m = m->next) {
			stmt *st = m->data;
			char *cname = column_name(st);
			char *tname = table_name(st);
			stmt *sc = stmt_ibat(stmt_dup(st), stmt_dup(sq));

			table_add_column(tv, sc, tname, cname);
			_DELETE(tname);
			_DELETE(cname);
		}
	}
	return tv;
}

static tvar *sql_subquery_optname(mvc * sql, scope * scp,
				  symbol * query)
{
	SelectNode *sn = (SelectNode*)query;
	stmt *sq = sql_subquery(sql, NULL, query);

	if (!sq)
		return NULL;

	return table_optname(sql, scp, sq, QUERY(sql->scanner), sn->name);
}

static stmt *find_pivot(stmt * subset, stmt * t)
{
	assert(subset->type == st_ptable);

	if (t){
		node *n;
		for (n = ptable_pivots(subset)->h; n; n = n->next) { 
			stmt *s = n->data;
			if (s->t == t) 
				return stmt_dup(s);
		}
	}
	assert(0);
	return NULL;
}

static stmt *first_subset(stmt * subset)
{
	node *n;

	assert(subset->type == st_ptable);

       	n = ptable_pivots(subset)->h;
	if (n) 
		return stmt_dup(n->data);
	return NULL;
}


/* before the pivot table is created we need to check on both head and
 * tail for the subset.
 * */
static stmt *complex_find_subset(stmt * subset, stmt * t)
{

	if (t) {
		node *n;
		for (n = subset->op1.lval->h; n; n = n->next) {
			stmt *s = n->data;
			if (s->t == t) 
				return stmt_dup(s);
		}
		for (n = subset->op1.lval->h; n; n = n->next) {
			stmt *s = n->data;
			if (s->h == t) 
				return stmt_dup(s);
		}
	}
	return NULL;
}


static lng scale2value(int scale){
	lng val = 1;

	if (scale < 0) scale = -scale;
	for(;scale; scale--){
		val = val * 10;
	}
	return val;
}

static void sum_scales( sql_subfunc *f, stmt *ls, stmt *rs ){
	if (strcmp(f->func->imp, "*") == 0 && 
			f->func->res->type->scale == SCALE_FIX){
		f->res.scale = tail_type(ls)->scale + 
					tail_type(rs)->scale;
	}
}

static stmt *scale_algebra( sql_subfunc *f, stmt *ls, stmt *rs ){
	sql_subtype *lt = tail_type(ls);
	sql_subtype *rt = tail_type(rs);

	if (lt->type->scale == SCALE_FIX && rt->scale){ 
		sql_subtype *it = sql_bind_localtype( lt->type->base.name );
		sql_subfunc *c = NULL;

		if (strcmp(f->func->imp, "/") == 0){
			c = sql_bind_func("scale_up",lt,it);
		}
		if (c){
			lng val = scale2value(rt->scale);
			atom *a = atom_int(sql_dup_subtype(it), val);
			ls = stmt_binop(ls, stmt_atom(a), c);
		}
	}
	return ls;
}

static stmt *fix_scale( mvc * sql, sql_subtype * ct, stmt * s, int both, int always)
{
	sql_subtype *st = tail_type(s);
	(void) sql; /* Stefan: unused!? */

	if (ct->type->scale == SCALE_FIX && st->type->scale == SCALE_FIX){ 
		int scale_diff = ((int) ct->scale - (int) st->scale);

		if (scale_diff){
			sql_subtype *it = sql_bind_localtype( st->type->base.name );
			sql_subfunc *c = NULL;

			if (scale_diff < 0){
				if (!both) 
					return s;
				c = sql_bind_func("scale_down",st,it);
			} else {
				c = sql_bind_func("scale_up",st,it);
			}
			if (c) {
				lng val = scale2value(scale_diff);
				atom *a = atom_int(sql_dup_subtype(it), val);
				c->res.scale = (st->scale + scale_diff);
				return stmt_binop(s, stmt_atom(a), c);
			}
		}
	} else if (always && st->scale){ /* scale down */
		int scale_diff =  - (int) st->scale;
		sql_subtype *it = sql_bind_localtype( st->type->base.name );
		sql_subfunc *c = sql_bind_func("scale_down",st,it);

		if (c) {
			lng val = scale2value(scale_diff);
			atom *a = atom_int(sql_dup_subtype(it), val);
			c->res.scale = 0;
			return stmt_binop(s, stmt_atom(a), c);
		} else {
			printf("scale_down mising (%s)\n", st->type->base.name);
		}
	}
	return s;
}

/* check_types tries to match the ct type with the type of s if they don't
 * match s is converted. Returns NULL on failure.
 */
static stmt *check_types(mvc * sql, sql_subtype * ct, stmt * s )
{
	sql_subtype *st = tail_type(s);

	if (st) {
		sql_subtype *t = st;

		/* check if the types are the same */
		if (t && subtype_cmp(t, ct) != 0) {
			t = NULL;
		}
		if (!t) {	/* try to convert if needed */
			sql_subfunc *c = 
				sql_bind_func_result("convert",st,NULL,ct);
			if (c){ 
				if ((ct->digits > 0 && ct->scale == 0 && 
					ct->digits < st->digits) ||
		    		    (ct->scale > 0 && ct->digits > 0 && 
					ct->digits-ct->scale < 
						st->digits-st->scale) 
				) {
					sql_subfunc_destroy(c);
					return sql_error(sql, 03, "Types %s(%d,%d) (%s) and %s(%d,%d) (%s) are not equal", st->type->sqlname, st->digits, st->scale, st->type->base.name, ct->type->sqlname, ct->digits, ct->scale, ct->type->base.name);
				}
				return fix_scale(sql, ct, stmt_unop(s, c), 1,
					(st->type->scale == SCALE_FIX));
			}
			/* here we need to check if we could convert using
			   the more complex conversion functions 
			   (convert(x,int,int) -> y)
			 */
			if (st->scale == 0) {
				sql_subtype *it = sql_bind_localtype( "int" );
				list *ops = list_create((fdestroy)&
					sql_subtype_destroy);
				list_append(ops, sql_dup_subtype(st));
				list_append(ops, sql_dup_subtype(it));
				list_append(ops, sql_dup_subtype(it));
				c = sql_bind_func_result_( "convert", ops, ct);
				list_destroy(ops);
				if (c){ 
					ops = create_stmt_list();
					list_append(ops, s);
					list_append(ops, stmt_atom(
						atom_int(sql_dup_subtype(it), 
						ct->digits)));
					list_append(ops, stmt_atom(
						atom_int(sql_dup_subtype(it), 
						ct->scale)));
					return stmt_Nop(stmt_list(ops), c);
				}
			}
		}
		if (!t || subtype_cmp(t, ct) != 0) {
			return sql_error(sql, 02, "Types %s(%d,%d) (%s) and %s(%d,%d) (%s) are not equal", st->type->sqlname, st->digits, st->scale, st->type->base.name, ct->type->sqlname, ct->digits, ct->scale, ct->type->base.name);
		}
	} else {
		assert(0);
		return sql_error(sql, 02, "Statement has no type information");
	}
	if (st) {
		if ((ct->digits > 0 && ct->scale == 0 
			&& ct->digits < st->digits) ||
		    (ct->scale > 0 && ct->digits > 0 
			&& ct->digits-ct->scale < st->digits-st->scale) 
		){
			return sql_error(sql, 03, "Types %s(%d,%d) (%s) and %s(%d,%d) (%s) are not equal", st->type->sqlname, st->digits, st->scale, st->type->base.name, ct->type->sqlname, ct->digits, ct->scale, ct->type->base.name);
		}
	}
	return fix_scale(sql, ct, s, 1, 0);
}


static sql_subtype *supertype( sql_subtype *r, sql_subtype *i ) 
{
	/* first find super type */
	char *tpe = r->type->sqlname;
	int digits = 0;
	unsigned int scale = sql_max(i->scale,r->scale);

	if (i->type->nr > r->type->nr)
		tpe = i->type->sqlname;
	if (i->digits && r->digits) {
		if (i->digits > r->digits) {
			digits = i->digits;
			if (i->scale < scale)
				digits += scale-i->scale;	
		} else if (i->digits < r->digits) {
			digits = r->digits;
			if (r->scale < scale)
				digits += scale-r->scale;	
		} else {
			/* same number of digits */
			digits = i->digits;
			if (i->scale < r->scale) 
				digits += r->scale - i->scale;	
			else 
				digits += i->scale - r->scale;	
		}
	}

	return sql_bind_subtype(tpe,digits,scale);
}

/* convert_types convert both the stmt's L and R such that they get
 * matching types. On failure <0 is returned;
 */
static int convert_types(mvc * sql, stmt ** L, stmt ** R, int scale_fixing )
{
	stmt *ls = *L;
	stmt *rs = *R;
	sql_subtype *lt = tail_type(ls);
	sql_subtype *rt = tail_type(rs);

	if (rt && lt){
		sql_subtype *i = lt;
		sql_subtype *r = rt;

		if (subtype_cmp(lt,rt) != 0){
			sql_subtype *super = supertype(r, i);
			if (scale_fixing){
				/* convert ls to super type */
				ls = check_types(sql, super, ls);
				/* convert rs to super type */
				rs = check_types(sql, super, rs);
			} else {
				/* convert ls to super type */
				super->scale = lt->scale;
				ls = check_types(sql, super, ls);
				/* convert rs to super type */
				super->scale = rt->scale;
				rs = check_types(sql, super, rs);
			}
			sql_subtype_destroy(super);
		} else if (scale_fixing) {
			ls = fix_scale( sql, r, ls, 0, 0);
			rs = fix_scale( sql, i, rs, 0, 0);
		}
		if (!ls || !rs) {
			if (ls)
				*L = ls;
			if (rs)
				*R = rs;
			return -1;
		}
		*L = ls;
		*R = rs;
		return 0;
	}
	return -1;
}

/* The case/when construction in the selection works on the resulting
   table (ie. on the marked columns). We just need to know which oid list
   is involved (ie. find one subset).
   We need to check if for all results the types are the same. 
 */
static stmt *sql_case(mvc * sql, scope * scp, symbol *opt_cond, dlist * when_search_list, symbol * opt_else, group * grp, stmt * subset)
{
	list *conds = create_stmt_list();
	list *results = create_stmt_list();
	dnode *dn = when_search_list->h;
	sql_subtype *restype = NULL;
	stmt *res = NULL;
	node *n, *m;


	if (dn) {
		dlist *when = dn->data.sym->data.lval;
		stmt *cond, *result;

		if (opt_cond){
			cond = sql_compare_exp( sql, scp, grp, subset, 
					opt_cond, when->h->data.sym, "=");
		} else {
			cond = sql_logical_exp(sql, scp, 
					when->h->data.sym, grp, subset);
		}
		result = sql_value_exp(sql, scp, 
					when->h->next->data.sym, grp, subset);
		if (!cond || !result) {
			list_destroy(conds);
			list_destroy(results);
			return NULL;
		}
		list_prepend(conds, cond);
		list_prepend(results, result);

		restype = sql_dup_subtype(tail_type(result));
	}
	if (!restype) {
		list_destroy(conds);
		list_destroy(results);
		return sql_error(sql, 02, "Error: result type missing");
	}
	for (dn = dn->next; dn; dn = dn->next) {
		sql_subtype *tpe = NULL;
		dlist *when = dn->data.sym->data.lval;
		stmt *cond, *result;

		if (opt_cond){
			cond = sql_compare_exp( sql, scp, grp, subset, 
					opt_cond, when->h->data.sym, "=");
		} else {
			cond = sql_logical_exp(sql, scp, 
					when->h->data.sym, grp, subset);
		}
		result = sql_value_exp(sql, scp, 
					when->h->next->data.sym, grp, subset);
		if (!cond || !result) {
			list_destroy(conds);
			list_destroy(results);
			return NULL;
		}
		list_prepend(conds, cond);
		list_prepend(results, result);

		tpe = tail_type(result);
		if (!tpe) {
			list_destroy(conds);
			list_destroy(results);
			return sql_error(sql, 02, "Error: result type missing");
		}
		tpe = supertype(restype, tpe);
		if (!tpe) {
			list_destroy(conds);
			list_destroy(results);
			return sql_error(sql, 02, "Error: result types %s,%s of case are not compatible", restype->type->sqlname, tpe->type->sqlname);
		}
		sql_subtype_destroy( restype );
		restype = tpe;
	}
	if (subset) {
		res = first_subset(subset);
		if (!res) {
			list_destroy(conds);
			list_destroy(results);
			return sql_error(sql, 02, "Subset not found for case stmt");
		}
	} else {
		printf("Case in query not handled jet\n");
	}
	if (opt_else) {
		stmt *result = sql_value_exp(sql, scp, opt_else, grp, subset);

		if (!result || !(result = check_types(sql, restype, result))) {
			list_destroy(conds);
			list_destroy(results);
			return NULL;
		}
		if (result->nrcols <= 0) {
			res = stmt_const(res, result);
		} else {
			if (res) stmt_destroy(res);
			res = result;
		}
	} else {
		res = stmt_const(res, stmt_atom( atom_general( sql_dup_subtype(restype), NULL)));
	}
	if (restype) 
		sql_subtype_destroy(restype);
	restype = tail_type(res);
	for (n = conds->h, m = results->h; n && m;
	     n = n->next, m = m->next) {
		stmt *cond = stmt_dup(n->data);
		stmt *result = stmt_dup(m->data);

		/* need more semantic tests here */
		if (cond->type == st_sets) {
			node *k = cond->op1.lval->h;
			stmt *cur = NULL;

			if (k) {
				list *l1 = k->data;
				cur = stmt_dup(l1->h->data);
				k = k->next;
				for (; k; k = k->next) {
					list *l2 = k->data;
					stmt *st = stmt_dup(l2->h->data);
					cur = stmt_union(cur, st);
				}
				if (cond) stmt_destroy(cond);
				cond = cur;
			}
		}
		if (cond->type == st_set) {
			stmt *nc = (stmt*)list_reduce(cond->op1.lval, (freduce)&stmt_semijoin, (fdup)&stmt_dup );
			stmt_destroy(cond);
			cond = nc;
		}
		if (result->nrcols <= 0)
			result = stmt_const(cond, result);
		else 
			result = stmt_semijoin(result, cond);
		
		if (! (result = check_types(sql, restype, result)) ) {
			list_destroy(conds);
			list_destroy(results);
			stmt_destroy(res);
			return NULL;
		}
		res = stmt_replace(res, result);
	}
	list_destroy(conds);
	list_destroy(results);
	return res;
}

static stmt *sql_case_exp(mvc * sql, scope * scp, symbol * se, group * grp, stmt * subset)
{
	dlist *l = se->data.lval;
	if (l->h->type == type_list) {
		dlist *when_search_list = l->h->data.lval;
		symbol *opt_else = l->h->next->data.sym;
		return sql_case(sql, scp, NULL,  when_search_list, opt_else, grp, subset);
	} else {
		symbol *scalar_exp = l->h->data.sym;
		dlist *when_value_list = l->h->next->data.lval;
		symbol *opt_else = l->h->next->next->data.sym;
		return sql_case(sql, scp, scalar_exp, when_value_list, opt_else, grp, subset);
	}
}

static stmt *sql_cast(mvc * sql, scope * scp, symbol * se, group * grp, stmt * subset)
{

	dlist *dl = se->data.lval;
	symbol *s = dl->h->data.sym;
	sql_subtype *tpe = dl->h->next->data.typeval;

	stmt *l = sql_value_exp(sql, scp, s, grp, subset);

	if (l) 
		return check_types(sql, tpe, l);
	return NULL;
}

static stmt *sql_Nop(mvc * sql, scope * scp, symbol * se, group * grp, stmt * subset)
{
	dnode *l = se->data.lval->h;
	dnode *ops = l->next->data.lval->h;
	list *sl = create_stmt_list();
	list *tl = list_create(NULL);
	sql_subfunc *f = NULL;

	for(; ops; ops = ops->next){
		stmt *op = sql_value_exp(sql, scp, ops->data.sym, grp, subset);
		if (!op){
			list_destroy(sl);
			return NULL;
		}
		list_append( sl, op);
		list_append( tl, tail_type(op));
	}
	f = sql_bind_func_(l->data.sval, tl);
	list_destroy(tl);
	if (f) {
		return stmt_Nop(stmt_list(sl), f);
	} else {
		list_destroy(sl);
		return sql_error(sql, 02, "operator: %s unknown", l->data.sval);
	}
	return NULL;
}

static stmt *
sql_binop_(mvc * sql, char *fname, stmt * ls, stmt *rs)
{
	stmt *res = NULL;
	sql_subtype *t1, *t2;
	sql_subfunc *f = NULL;

 	t1 = tail_type(ls);
	t2 = tail_type(rs);

	f = sql_bind_func(fname, t1, t2 );
	if (f) {
		if (f->func->res->scale == SCALE_FIX){
			ls = fix_scale( sql, t2, ls, 0, 0);
			rs = fix_scale( sql, t1, rs, 0, 0);
		}
		if (f->func->res->scale == SCALE_SUB)
			ls = scale_algebra( f, ls, rs );
		if (f->func->res->scale == SCALE_ADD)
			sum_scales(f, ls, rs);
		return stmt_binop(ls, rs, f);
	} else {
		if (convert_types( sql, &ls, &rs, 0) >= 0){
 			t1 = tail_type(ls);
			t2 = tail_type(rs);
			f = sql_bind_func(fname, t1, t2 );
			if (f){
				if (f->func->res->scale == SCALE_FIX){
					ls = fix_scale( sql, t2, ls, 0, 0);
					rs = fix_scale( sql, t1, rs, 0, 0);
				}
				if (f->func->res->scale == SCALE_SUB)
					ls = scale_algebra( f, ls, rs );
				if (f->func->res->scale == SCALE_ADD)
					sum_scales(f, ls, rs);
				ls = stmt_binop(ls, rs, f);
				return ls;
			}
		}
	}
	res = sql_error(sql, 02, "Binary operator: %s(%s,%s) unknown", fname, tail_type(ls)->type->sqlname, tail_type(rs)->type->sqlname);
	if (ls) 
		stmt_destroy(ls);
	if (rs) 
		stmt_destroy(rs);
	return res;
}

static stmt *sql_binop(mvc * sql, scope * scp, symbol * se, group * grp, stmt * subset)
{
	dnode *l = se->data.lval->h;
	stmt *ls = sql_value_exp(sql, scp, l->next->data.sym, grp, subset);
	stmt *rs = sql_value_exp(sql, scp, l->next->next->data.sym, grp, subset);
	if (!ls || !rs){
		if (ls) stmt_destroy(ls);
		if (rs) stmt_destroy(rs);
		return NULL;
	}

	/* also need to add semantic checks here */
	if (ls->type == st_list){
		stmt *o = ls;
		assert(list_length(ls->op1.lval) == 1);
		ls = stmt_dup(ls->op1.lval->h->data);
		stmt_destroy(o); 
	}
	if (rs->type == st_list){
		stmt *o = rs;
		assert(list_length(rs->op1.lval) == 1);
		rs = stmt_dup(rs->op1.lval->h->data);
		stmt_destroy(o); 
	}

	return sql_binop_(sql, l->data.sval, ls, rs ); 
}

static stmt *sql_op(mvc * sql, scope * scp, symbol * se, group * grp, stmt * subset)
{
	dnode *l = se->data.lval->h;
	sql_subfunc *f = NULL;
	(void) scp; (void) grp; (void) subset; /* Stefan: unused!? */

	f = sql_bind_func(l->data.sval, NULL, NULL);
	if (f) {
		return stmt_op(f);
	} else {
		return sql_error(sql, 02, "operator: %s() unknown", l->data.sval);
	}
	return NULL;
}

static stmt *sql_unop(mvc * sql, scope * scp, symbol * se, group * grp, stmt * subset)
{
	dnode *l = se->data.lval->h;
	sql_subfunc *f = NULL;
	sql_subtype *rt = NULL;
	stmt *rs = sql_value_exp(sql, scp, l->next->data.sym, grp, subset);
	if (!rs)
		return NULL;
	rt = tail_type(rs);
	f = sql_bind_func(l->data.sval, rt, NULL );
	if (f) {
		if (f->func->imp) {
			/* output same type as input */
			if (f->func->res->scale == SCALE_SUB) {
				f->res.digits = rt->digits;
				f->res.scale = rt->scale;
			}
			return stmt_unop(rs, f);
		} else {
			sql_arg *a = f->func->ops->h->data;
			sql_add_param(sql, _strdup(a->name), rs );

			return sqlparse_intern(sql, f->func->imp);
		}
	} else {
		char *type = tail_type(rs)->type->sqlname;

		stmt_destroy(rs);
		return sql_error(sql, 02, "Unary operator: %s(%s) unknown", l->data.sval, type);
	}
	return NULL;
}


static stmt *sql_aggrop(mvc * sql, scope * scp, symbol * se, group * grp, stmt * subset)
{
	dlist *l = se->data.lval;
	sql_subaggr *a = NULL;
	int distinct = l->h->next->data.ival;
	stmt *s = NULL;
	char *aggrstr = l->h->data.sval;
	if (!l->h->next->next->data.sym) {	/* count(*) case */
		cvar *cv;
		if (strcmp(aggrstr, "count") != 0) {
			return sql_error(sql, 02, "Aggregate: Cannot do a %s(*)", l->h->data.sval);
		}
		if (grp) {
			a = sql_bind_aggr(aggrstr, NULL); 
			return stmt_aggr(stmt_dup(grp->grp), grp_dup(grp), a);
		}
		cv = scope_first_column(scp);
		if (cv && subset) {
			stmt *foundsubset = find_pivot(subset, cv->s->h);

				assert(foundsubset);
			if (!foundsubset) {
				return sql_error(sql, 02, "Aggregate: Cannot find subset for column %s\n", cv->cname) ;
			}
			s = stmt_join(foundsubset, stmt_dup(cv->s), cmp_equal);
		}
	} else {
		/* use cnt as nils shouldn't to be counted */
		if (strcmp(aggrstr, "count") == 0) {
			aggrstr = "count_no_nil";
		}
		/* the values which are aggregated together, no grp should
		 * be given there to optain the values */
		s = sql_value_exp(sql, scp, l->h->next->next->data.sym, /*grp*/ NULL, subset);
	}

	if (s && distinct) {
		s = stmt_unique(s,grp_dup(grp));
	}
	if (!s)
		return NULL;
	a = sql_bind_aggr(aggrstr, tail_type(s));
	if (a) {
		/* type may have changed, ie. need to fix_scale */
		sql_subtype *t = tail_type(s);
		return fix_scale(sql, t, stmt_aggr(s, grp_dup(grp), a), 1, (t->type->scale == SCALE_FIX));
	} else {
		char *type = tail_type(s)->type->sqlname;
		stmt_destroy(s);
		return sql_error(sql, 02, "Aggregate: %s(%s) unknown", l->h->data.sval, type);
	}
	return NULL;
}

static stmt *sql_column_value(mvc * sql, scope * scp, symbol * se, group * grp, stmt * subset)
{
	stmt *res = sql_column_ref(sql, scp, se);
	(void) grp; /* Stefan: unused!? */

	if (res && res->h && subset) {
		stmt *foundsubset = find_pivot(subset, res->h);

		if (!foundsubset) {
			return sql_error(sql, 02, "Subset not found for value expression");
		}
		res = stmt_join(foundsubset, res, cmp_equal);
	} 
	return res;
}

static stmt *sql_value_exp(mvc * sql, scope * scp, symbol * se, group * grp, stmt * subset)
{

	switch (se->token) {
	case SQL_NOP:
		return sql_Nop(sql, scp, se, grp, subset);
	case SQL_BINOP:
		return sql_binop(sql, scp, se, grp, subset);
	case SQL_OP:
		return sql_op(sql, scp, se, grp, subset);
	case SQL_UNOP:
		return sql_unop(sql, scp, se, grp, subset);
	case SQL_AGGR:
		return sql_aggrop(sql, scp, se, grp, subset);
	case SQL_COLUMN:
		return sql_column_value(sql, scp, se, grp, subset);
	case SQL_SELECT:
		return scope_subquery(sql, scp, se);
	case SQL_PARAMETER:
		printf("parameter not used\n");
		break;
	case SQL_ATOM: {
		AtomNode *an = (AtomNode*)se;
		if (!an || !an->a){
			return stmt_atom(atom_general(sql_dup_subtype(
				sql_bind_localtype("str")),NULL));
		} else {
			return stmt_atom(atom_dup(an->a));
		}
	}
	case SQL_CAST:
		return sql_cast(sql, scp, se, grp, subset);
	case SQL_CASE:
		return sql_case_exp(sql, scp, se, grp, subset);
	case SQL_NULLIF:
	case SQL_COALESCE:
		printf("case %d %s\n", se->token, token2string(se->token));
		return NULL;
		break;
	default:
		return sql_logical_exp(sql, scp, se, grp, subset);
	}
	return NULL;
}

/* turns a stmt set (or a set of stmt_sets) into a pivot table 
 * ie a table with a oid column for each base table.
 * A row of this pivot table expresses how the rows of the base tables
 * relate.
 */

static stmt *stmt2pivot(scope * scp, stmt * s)
{
	stmt *ptable = stmt_dup(scp->ptable);
	ptable_statements(ptable) = s;
	return ptable;
}

static stmt *find_on_column_name(mvc * sql, scope * scp, tvar * t, char *name)
{
	node *m;
	(void) sql; (void) scp; /* Stefan: unused!? */

	for (m = t->columns->h; m; m = m->next) {
		cvar *rc = m->data;
		if (strcmp(name, rc->cname) == 0) {
			return stmt_dup(rc->s);
		}
	}
	return NULL;
}

static list *join_on_column_name(mvc * sql, scope * scp, tvar * tv,
				 tvar * r, int all)
{
	list *res = create_stmt_list();
	node *n;
	for (n = tv->columns->h; n; n = n->next) {
		cvar *lc = n->data;
		stmt *rs = find_on_column_name(sql, scp, r, lc->cname);
		if (rs) {
			list_append(res, stmt_dup(lc->s));
			list_append(res, rs);
		} else if (all) {
			list_destroy(res);
			return NULL;
		}
	}
	return res;
}


static stmt *sql_join_
    (mvc * sql,
     scope * scp,
     symbol * tab1, int natural, jt jointype, symbol * tab2, symbol * js) {
	stmt *s = NULL, *subset = NULL;
	tvar *tv1, *tv2;

	tv1 = table_ref(sql, scp, tab1);
	tv2 = table_ref(sql, scp, tab2);

	if (!tv1 || !tv2)
		return NULL;

	if (js && natural) {
		return sql_error(sql, 02, "Cannot have a NATURAL JOIN with a join specification (ON or USING);");
	}
	if (!js && !natural) {
		return sql_error(sql, 02, "Must have NATURAL JOIN or a JOIN with a specification (ON or USING);");
	}

	if (js && js->token != SQL_USING) {	/* On sql_logical_exp */
		s = sql_logical_exp(sql, scp, js, NULL, NULL);
	} else if (js) {	/* using */
		dnode *n = js->data.lval->h;

		s = stmt_reljoin_init();
		for (; n; n = n->next) {
			char *nm = n->data.sval;

			stmt *ls = find_on_column_name(sql, scp, tv1, nm);
			stmt *rs = find_on_column_name(sql, scp, tv2, nm);
			if (!ls || !rs) {
				if (ls) stmt_destroy(ls);
				if (rs) stmt_destroy(rs);
				if (s) stmt_destroy(s);
				return sql_error(sql, 02, "Tables %s and %s do have a matching column %s\n", tv1->tname, tv2->tname, nm);
			}
			if ((convert_types(sql, &ls, &rs, 1) < 0)) 
			{
				if (ls) stmt_destroy(ls);
				if (rs) stmt_destroy(rs);
				if (s) stmt_destroy(s);
				return NULL;
			}
			stmt_reljoin_fill(s, ls, rs);
		}
	} else {		/* ! js -> natural join */
		list *matching_columns;
		node *m;

		matching_columns = join_on_column_name(sql, scp, tv1, tv2, 0);

		if (!matching_columns || list_length(matching_columns) == 0) {
			if (matching_columns) list_destroy(matching_columns);
			return sql_error(sql, 02, "No attributes of tables %s and %s match\n", tv1->tname, tv2->tname);
		}

		s = stmt_reljoin_init();
		for (m = matching_columns->h; m; m = m->next->next) {
			stmt *ls = stmt_dup(m->data);
			stmt *rs = stmt_dup(m->next->data);

			if ((!rs) || (!ls) ||
				(convert_types(sql, &ls, &rs, 1) < 0)) 
			{
				if (ls) stmt_destroy(ls);
				if (rs) stmt_destroy(rs);
				if (s) stmt_destroy(s);
				return NULL;
			}
			stmt_reljoin_fill(s, ls, rs);
		}
		list_destroy(matching_columns);
	}

	if (s) {
		s = stmt2pivot(scp, s);
	}
	subset = s;
	if (subset) {
		list *l1;
		tvar *t = NULL;
		node *n;
		stmt *fs1 = find_pivot(subset, tv1->s);
		stmt *fs2 = find_pivot(subset, tv2->s);
		stmt *ld = NULL, *rd = NULL;

		if (!fs1 || !fs2) {
			if (fs1) stmt_destroy(fs1);
			if (fs2) stmt_destroy(fs2);
			if (!fs1) {
		     		return sql_error(sql, 02, "Subset %s not found in join expression", tv1->tname);
			} else if (!fs2) {
		     		return sql_error(sql, 02, "Subset %s not found in join expression", tv2->tname);
			} else {
		     		return sql_error(sql, 02, "Subsets %s,%s not found in join expression", tv1->tname, tv2->tname);
			}

		}

		t = tv1;
		if (jointype == jt_left || jointype == jt_full) {
			cvar *cs = t->columns->h->data;
			/* we need to add the missing oid's */
			ld = stmt_diff(stmt_dup(cs->s), stmt_reverse(stmt_dup(fs1)));
			ld = stmt_mark(stmt_reverse(ld), 0);
		}
		t = tv2;
		if (jointype == jt_right || jointype == jt_full) {
			cvar *cs = t->columns->h->data;
			/* we need to add the missing oid's */
			rd = stmt_diff(stmt_dup(cs->s), stmt_reverse(stmt_dup(fs2)));
			rd = stmt_mark(stmt_reverse(rd), 0);
		}
		l1 = create_stmt_list();
		t = tv1;
		for (n = t->columns->h; n; n = n->next) {
			cvar *cs = n->data;

			list_append(l1, stmt_join(stmt_dup(fs1), stmt_dup(cs->s), cmp_equal));
		}
		t = tv2;
		for (n = t->columns->h; n; n = n->next) {
			cvar *cs = n->data;

			list_append(l1, stmt_join(stmt_dup(fs2), stmt_dup(cs->s), cmp_equal));
		}
		if (fs1) stmt_destroy(fs1);
		if (fs2) stmt_destroy(fs2);
		if (jointype == jt_left || jointype == jt_full) {
			list *l2 = create_stmt_list();
			node *m = l1->h;
			t = tv1;
			for (n = t->columns->h; n;
			     n = n->next, m = m->next) {
				cvar *cs = n->data;

				list_append(l2, stmt_append(stmt_dup(m->data), stmt_join (stmt_dup(ld), stmt_dup(cs->s), cmp_equal)));
			}
			t = tv2;
			for (n = t->columns->h; n;
			     n = n->next, m = m->next) {
				cvar *cs = n->data;

				list_append(l2, stmt_append(stmt_dup(m->data), stmt_const (stmt_dup(ld), stmt_atom (atom_general (sql_dup_subtype(tail_type(cs->s)), NULL)))));
			}
			list_destroy(l1);
			l1 = l2;
		}
		if (jointype == jt_right || jointype == jt_full) {
			list *l2 = create_stmt_list();
			node *m = l1->h;
			t = tv1;
			for (n = t->columns->h; n;
			     n = n->next, m = m->next) {
				cvar *cs = n->data;

				list_append(l2, stmt_append(stmt_dup(m->data), stmt_const (stmt_dup(rd), stmt_atom (atom_general (sql_dup_subtype(tail_type(cs->s)), NULL)))));
			}
			t = tv2;
			for (n = t->columns->h; n;
			     n = n->next, m = m->next) {
				cvar *cs = n->data;

				list_append(l2, stmt_append(stmt_dup(m->data), stmt_join (stmt_dup(rd), stmt_dup(cs->s), cmp_equal)));
			}
			list_destroy(l1);
			l1 = l2;
		}
		if (ld) stmt_destroy(ld);
		if (rd) stmt_destroy(rd);
		s = stmt_list(l1);
	}
	if (subset) stmt_destroy(subset);
	return s;
}

static stmt *sql_join(mvc * sql, scope * scp, symbol * q)
{

	dnode *n = q->data.lval->h;
	symbol *tab_ref1 = n->data.sym;
	int natural = n->next->data.ival;
	jt jointype = (jt) n->next->next->data.ival;
	symbol *tab_ref2 = n->next->next->next->data.sym;
	symbol *joinspec = n->next->next->next->next->data.sym;

	return sql_join_(sql, scp, tab_ref1, natural, jointype, tab_ref2, joinspec);
}

stmt *distinct( stmt * s) 
{
	node *n;
	group *grp = NULL;
	list *rl = create_stmt_list();

 	for (n = s->op1.lval->h; n; n = n->next) {
		stmt *t = n->data;
		grp = grp_create(stmt_dup(t), grp);
	}

 	for (n = s->op1.lval->h; n; n = n->next) {
		stmt *t = n->data;
		list_append(rl, stmt_join(stmt_dup(grp->ext), 
				          stmt_dup(t), cmp_equal));
	}

	if (grp)
		grp_destroy(grp);
	stmt_destroy(s);
	s = stmt_list(rl);
	return s;
}

static stmt *sql_union_(mvc *sql, scope *scp, symbol *t1, int all, dlist *cols, symbol *t2)
{
	stmt *res;
	node *n, *m;

	scope *nscp = scope_open(scp);
	tvar *tv1 = table_ref(sql, nscp, t1);
	tvar *tv2 = table_ref(sql, nscp, t2);
	list *unions = NULL;

	if (!tv1 || !tv2) {
		return NULL;
	}

	if (list_length(tv1->columns) != list_length(tv2->columns)) {
		return sql_error(sql, 02, "Cannot union different ordinality queryes");
	}
	unions = create_stmt_list();
	if (!cols) {
		for (n = tv1->columns->h, m = tv2->columns->h;
			n && m; 
			n = n->next, m = m->next) {
				cvar *lc = n->data;
				cvar *rc = m->data;
				stmt *ls = stmt_dup(lc->s);
	
				/* insert single value into table */
				if (lc->s->key) {
					stmt *temp = stmt_temp(
						sql_dup_subtype(
							tail_type(lc->s)));
					ls = stmt_append(temp, ls);
				}
				list_append(unions, stmt_append(ls, 
					stmt_dup(rc->s)));
		}
	/* TODO cols length 0 see natural join
	        cols length > 0 see union join, join on name */
	}
	res = stmt_list(unions);
	if (!all) {
		res = distinct(res);
	}
	scp = scope_close(nscp);
	return res;
}

static stmt *sql_union(mvc * sql, scope * scp, symbol * q)
{

	dnode *n = q->data.lval->h;
	symbol *tab_ref1 = n->data.sym;
	int all = n->next->data.ival;
	dlist *corresponding = n->next->next->data.lval;
	symbol *tab_ref2 = n->next->next->next->data.sym;
	return sql_union_(sql, scp, tab_ref1, all, corresponding, tab_ref2 );
}

static stmt *sql_cross(mvc * sql, scope * scp, symbol * q)
{

	dnode *n = q->data.lval->h;
	symbol *tab_ref1 = n->data.sym;
	symbol *tab_ref2 = n->next->data.sym;

	tvar *tv1 = table_ref(sql, scp, tab_ref1);
	tvar *tv2 = table_ref(sql, scp, tab_ref2);
	cvar *cv1;
	cvar *cv2;
	stmt *ct;

	if (!tv1 || !tv2)
		return NULL;

	cv1 = tv1->columns->h->data;
	cv2 = tv2->columns->h->data;

	/* cross product */
	ct = stmt_join(stmt_dup(cv1->s), stmt_reverse(stmt_dup(cv2->s)), cmp_all);

	if (ct) {
		/* add the columns */
		list *rl = create_stmt_list();
		node *nv;

		ct = stmt2pivot(scp, ct);

		for (nv = scp->tables->h; nv; nv = nv->next) {
			node *n;
			tvar *tv = nv->data;
			stmt *foundsubset = find_pivot(ct, tv->s);

			for (n = tv->columns->h; n; n = n->next) {
				cvar *cs = n->data;
				list_append(rl, 
					stmt_join (
						stmt_dup(foundsubset), 
						stmt_dup(cs->s), cmp_equal));
			}
			stmt_destroy(foundsubset);
		}
		stmt_destroy(ct);
		return stmt_list(rl);
	}
	return NULL;
}

static tvar *query_exp_optname(mvc * sql, scope * scp, symbol * q)
{
	tvar *res = NULL;

	switch (q->token) {
	case SQL_UNION:
		{
			scope *nscp = scope_open(scp);
			stmt *tq = sql_union(sql, nscp, q);
			if (!tq) {
				printf("empty union result\n");
				return NULL;
			}
			res = table_optname(sql, scp, tq, QUERY(sql->scanner), q->data.lval->t->data.sym);
			scp = scope_close(nscp);
			return res;
		}
	case SQL_JOIN:
		{
			scope *nscp = scope_open(scp);
			stmt *tq = sql_join(sql, nscp, q);
			if (!tq) {
				printf("empty join result\n");
				return NULL;
			}
			res = table_optname(sql, scp, tq, QUERY(sql->scanner), q->data.lval->t->data.sym);
			scp = scope_close(nscp);
			return res;
		}
	case SQL_CROSS:
		{
			scope *nscp = scope_open(scp);
			stmt *tq = sql_cross(sql, nscp, q);
			if (!tq) {
				printf("empty join result\n");
				return NULL;
			}
			res = table_optname(sql, scp, tq, QUERY(sql->scanner), q->data.lval->t->data.sym);
			scp = scope_close(nscp);
			return res;
		}
	case SQL_UNIONJOIN:
		{
			scope *nscp = scope_open(scp);
			node *m;
			dnode *n = q->data.lval->h;
			/*int all = n->next->data.ival;*/
			tvar *lv = table_ref(sql, nscp, n->data.sym);
			tvar *rv = table_ref(sql, nscp, n->next->next->data.sym);
			list *unions, *matching_columns;

			if (!lv || !rv)
				return NULL;

			/* find the matching columns (all should match?)
			 * union these 
			 * if !all do a distinct operation at the end 
			 */
			/* join all result columns ie join(lh,rh) on column_name */

			matching_columns = join_on_column_name(sql, nscp, lv, rv, 1);

			if (!matching_columns)
				return NULL;

			unions = create_stmt_list();
			for (m = matching_columns->h; m; m = m->next->next) {
				stmt *l = stmt_dup(m->data);
				stmt *r = stmt_dup(m->next->data);
				list_append(unions, stmt_union(l, r));
			}
			res = table_optname(sql, scp, stmt_list(unions), QUERY(sql->scanner), q->data.lval->t->data.sym);
			list_destroy(matching_columns);
			scp = scope_close(nscp);
			return res;
		}
	default:
		printf("case %d %s\n", q->token, token2string(q->token));
	}
	return NULL;
}

/* column expression of the form: table.* */
static stmt *columns_exp(mvc * sql, scope * scp, symbol * column_e, group * grp, stmt * subset)
{
	char *tname = column_e->data.lval->h->data.sval;
	tvar *tv = scope_bind_table(scp, tname);
	(void) sql; /* Stefan: unused!? */

	if (tv) {
		stmt *foundsubset = find_pivot(subset, tv->s);
		list *columns = create_stmt_list();
		node *n = tv->columns->h;
		if (grp)
			foundsubset = stmt_join(stmt_dup(grp->ext), foundsubset, cmp_equal);
		while (n) {
			cvar *cv = n->data;
			list_append(columns, stmt_join(stmt_dup(foundsubset), stmt_dup(cv->s), cmp_equal));
			n = n->next;
		}
		stmt_destroy(foundsubset);
		return stmt_list(columns);
	}
	return NULL;
}


static stmt *column_exp(mvc * sql, scope * scp, symbol * column_e, group * grp, stmt * subset) {
	dlist *l = column_e->data.lval;
	stmt *s = sql_value_exp(sql, scp, l->h->data.sym, grp, subset);
	if (!s)
		return NULL;

	if (grp && s->type != st_aggr) {
		s = stmt_join(stmt_dup(grp->ext), s, cmp_equal);
	}

	/* AS name */
	if (s && l->h->next->data.sval) {
		s = stmt_alias(s, l->h->next->data.sval);
		scope_add_alias(scp, stmt_dup(s), l->h->next->data.sval);
	}
	return s;
}

static stmt *sql_column_exp(mvc * sql, scope * scp, symbol * column_e, group * grp, stmt * subset)
{
	stmt *res = NULL;
	if (column_e->token == SQL_TABLE) {
		res = columns_exp(sql, scp, column_e, grp, subset);
	} else if (column_e->token == SQL_COLUMN) {
		res = column_exp(sql, scp, column_e, grp, subset);
	}
	if (!res) {
		return sql_error(sql, 02, "Column expression Symbol(%d)->token = %s no output", (int) column_e->token, token2string(column_e->token));
	}
	return res;
}

static list *list_map_merge(list * l2, list * l1)
{
	list *res = list_dup(l1, (fdup)&stmt_dup);
	res = list_merge(res, l2, (fdup)&stmt_dup);
	return res;
}

static list *list_map_append_list(list * l2, list * l1)
{
	return list_append(l1, list_dup(l2, (fdup)&stmt_dup));
}

static stmt *sql_compare(mvc * sql, stmt * ls,
			 stmt * rs, char *compare_op)
{
	int join = 0;
	comp_type type = cmp_equal;

	if (!ls || !rs)
		return NULL;

	if (ls->nrcols <= 0 && rs->nrcols <= 0) {
		return sql_binop_(sql, compare_op, ls, rs);
	} else if (ls->nrcols > 0 && rs->nrcols > 0) {
		join = 1;
	}
	if (compare_op[0] == '=') {
		type = cmp_equal;
	} else if (compare_op[0] == '<') {
		type = cmp_lt;
		if (compare_op[1] != '\0') {
			if (compare_op[1] == '>') {
				type = cmp_notequal;
			} else if (compare_op[1] == '=') {
				type = cmp_lte;
			}
		}
	} else if (compare_op[0] == '>') {
		type = cmp_gt;
		if (compare_op[1] != '\0') {
			if (compare_op[1] == '=') {
				type = cmp_gte;
			}
		}
	}
	if (join) {
		if (convert_types(sql, &ls, &rs, 1) < 0){
			if (ls) stmt_destroy(ls);
			if (rs) stmt_destroy(rs);
			return NULL;
		}
		if (ls->h && rs->h && ls->h == rs->h) {
			return stmt_uselect(ls, rs, type);
		}
		rs = stmt_reverse(rs);
		return stmt_join(ls, rs, type);
	} else {
		if (ls->nrcols == 0) {
			stmt *t = ls;
			ls = rs;
			rs = t;
		}
		if (convert_types(sql, &ls, &rs, 1) < 0){
			if (ls) stmt_destroy(ls);
			if (rs) stmt_destroy(rs);
			return NULL;
		}
		return stmt_uselect(ls, rs, type);
	}
}

static stmt *sql_compare_exp( mvc *sql, scope *scp, group *grp, stmt *subset, symbol *lo, symbol *ro, char *compare_op )
{
	stmt *rs, *ls = sql_value_exp(sql, scp, lo, grp, subset);
	if (!ls)
		return NULL;
	if (ro->token != SQL_SELECT) {
		rs = sql_value_exp(sql, scp, ro, grp, subset);
		if (!rs) {
			stmt_destroy(ls);
			return NULL;
		}
		if (grp && (!rs->key || !ls->key)) {
			stmt_destroy(rs);
			stmt_destroy(ls);
			return sql_error(sql, 02, "Cannot compare sets with values, probably a aggregate function missing");
		}
		return sql_compare(sql, ls, rs, compare_op);
	} else {
		node *o;
		rs = scope_subquery(sql, scp, ro);

		if (!rs) {
			stmt_destroy(ls);
			return NULL;
		}
		if (rs->type != st_list || list_length(rs->op1.lval) == 0) {
			stmt_destroy(ls);
			stmt_destroy(rs);
			return sql_error(sql, 02, "Subquery result wrong");
		}
		o = rs->op1.lval->h;
		/* no outer references */
		if (list_length(rs->op1.lval) == 1) {
			stmt *sqa = stmt_dup(o->data);
			stmt_destroy(rs);
			return sql_compare(sql, ls, sqa, compare_op);
		} else {
			/* for now assume single outer ref ! */
			stmt *oref = stmt_dup(o->next->data);
			stmt *sqa  = stmt_dup(o->data);
			stmt *cmp = NULL;
			stmt *h;

			assert( list_length(rs->op1.lval) == 2);

			cmp = stmt_join(stmt_reverse(oref), sqa, cmp_equal);
			/* need to fix the oref head */
			h = stmt_dup(cmp->h->h);
			stmt_destroy(cmp->h);
			cmp->h = h;

			if (subset){ /* filter subset */
				ls = stmt_join(find_pivot(subset, ls->h), ls, cmp_equal);
			} else {
				ls = stmt_join(scope_find_pivot(scp, ls->h), ls, cmp_equal);
			}
			cmp = sql_compare(sql, ls, cmp, compare_op);
			stmt_destroy(rs);
			if (!cmp)
				return NULL;
			return stmt_filter(cmp);
		}
	}
	return NULL;
}

static stmt *sql_and(mvc * sql, stmt * ls, stmt * rs)
{
	stmt *res = NULL;
	(void) sql; /* Stefan: unused!? */

	if (!ls || !rs)
		return NULL;
	if (ls->type != st_set && ls->type != st_sets) {
		ls = stmt_set(ls);
	}
	if (rs->type != st_set && rs->type != st_sets) {
		rs = stmt_set(rs);
	}
	if (ls->type == st_set && rs->type == st_set) {
		list_merge( ls->op1.lval, rs->op1.lval,(fdup)&stmt_dup);
		stmt_destroy(rs);
		res = ls;
	} else if (ls->type == st_sets && rs->type == st_set) {
		res = stmt_sets(list_map(ls->op1.lval, rs->op1.sval,
					(fmap) & list_map_merge));
		stmt_destroy(rs);
		stmt_destroy(ls);
	} else if (ls->type == st_set && rs->type == st_sets) {
		res = stmt_sets(list_map(rs->op1.lval, ls->op1.sval,
					(fmap) & list_map_merge));
		stmt_destroy(rs);
		stmt_destroy(ls);
	} else if (ls->type == st_sets && rs->type == st_sets) {
		res = stmt_sets(list_map(ls->op1.lval, rs->op1.sval,
					(fmap) & list_map_merge));
		stmt_destroy(rs);
		stmt_destroy(ls);
	}
	return res;
}

static stmt *sql_or(mvc * sql, stmt * ls, stmt * rs)
{
	stmt *res = NULL;
	(void) sql; /* Stefan: unused!? */

	if (!ls || !rs)
		return NULL;
	if (ls->type != st_set && ls->type != st_sets) {
		ls = stmt_set(ls);
	}
	if (rs->type != st_set && rs->type != st_sets) {
		rs = stmt_set(rs);
	}
	if (ls->type == st_set && rs->type == st_set) {
		res = stmt_sets(
			list_append( 
			    list_append(
				list_create((fdestroy)&list_destroy),
				  list_dup(ls->op1.lval, (fdup)&stmt_dup)),
				    list_dup(rs->op1.lval, (fdup)&stmt_dup)));
		stmt_destroy(ls);
		stmt_destroy(rs);
	} else if (ls->type == st_sets
		   && rs->type == st_set) {
		list_append(ls->op1.lval, 
				list_dup(rs->op1.lval, (fdup)&stmt_dup));
		res = ls;
		stmt_destroy(rs);
	} else if (ls->type == st_set
		   && rs->type == st_sets) {
		list_append(rs->op1.lval, 
				list_dup(ls->op1.lval, (fdup)&stmt_dup));
		res = rs;
		stmt_destroy(ls);
	} else if (ls->type == st_sets
		   && rs->type == st_sets) {
		(void) list_map(ls->op1.lval, rs->op1.sval,
			(fmap) & list_map_append_list);
		res = ls;
		stmt_destroy(rs);
	}
	return res;
}

static stmt *sql_logical_exp(mvc * sql, scope * scp, symbol * sc, group * grp, stmt * subset)
{
	if (!sc)
		return NULL;
	switch (sc->token) {
	case SQL_OR:
		{
			symbol *lo = sc->data.lval->h->data.sym;
			symbol *ro = sc->data.lval->h->next->data.sym;
			stmt *ls = sql_logical_exp(sql, scp, lo, grp, subset);
			stmt *rs = sql_logical_exp(sql, scp, ro, grp, subset);
			return sql_or(sql, ls, rs);
		}
		break;
	case SQL_AND:
		{
			symbol *lo = sc->data.lval->h->data.sym;
			symbol *ro = sc->data.lval->h->next->data.sym;
			stmt *ls = sql_logical_exp(sql, scp, lo, grp, subset);
			stmt *rs = sql_logical_exp(sql, scp, ro, grp, subset);
			return sql_and(sql, ls, rs);
		}
		break;
	case SQL_COMPARE:
		{
			symbol *lo = sc->data.lval->h->data.sym;
			symbol *ro = sc->data.lval->h->next->next->data.sym;
			char *compare_op = sc->data.lval->h->next->data.sval;
			return sql_compare_exp(
				 sql, scp, grp, subset, lo, ro, compare_op);
		}
		break;
	case SQL_BETWEEN:
	case SQL_NOT_BETWEEN:
		{
			stmt *res = NULL;
			symbol *lo = sc->data.lval->h->data.sym;
			int symmetric = sc->data.lval->h->next->data.ival;
			symbol *ro1 =
			    sc->data.lval->h->next->next->data.sym;
			symbol *ro2 =
			    sc->data.lval->h->next->next->next->data.sym;
			stmt *ls = sql_value_exp(sql, scp, lo, grp, subset);
			stmt *rs1 = sql_value_exp(sql, scp, ro1, grp, subset);
			stmt *rs2 = sql_value_exp(sql, scp, ro2, grp, subset);
			sql_subtype *ct = NULL;
			if (!ls || !rs1 || !rs2)
				return NULL;
			if (rs1->nr > 0 || rs2->nr > 0) {
				return sql_error(sql, 02, "Between requires an atom on the right handside");
			}
			ct = tail_type(ls);
			rs1 = check_types(sql, ct, rs1);
			rs2 = check_types(sql, ct, rs2);
			if (symmetric) {
				stmt *tmp = NULL;
				sql_subfunc *min = sql_bind_func("min", tail_type(rs1), tail_type(rs2));
				sql_subfunc *max = sql_bind_func("max", tail_type(rs1), tail_type(rs2));
				if (!min || !max) {
					return sql_error(sql, 02, "min or max operator on types %s %s missing",
						 tail_type(rs1)->type->sqlname,
						 tail_type(rs2)->type->sqlname);
				}
				tmp = stmt_binop(rs1, rs2, min);
				rs2 = stmt_binop(rs1, rs2, max);
				rs1 = tmp;
			}
			res = stmt_uselect2(ls, rs1, rs2, 3 
					/* aka rs1 <= ls <= rs2*/);
			if (sc->token == SQL_NOT_BETWEEN)
				res = stmt_diff(ls, res);
			return res;
		}
	case SQL_LIKE:
	case SQL_NOT_LIKE:
		{
			stmt *res = NULL;
			symbol *lo = sc->data.lval->h->data.sym;
			symbol *ro = sc->data.lval->h->next->data.sym;
			stmt *ls = sql_value_exp(sql, scp, lo, grp, subset);
			stmt *a = NULL, *e = NULL;
			sql_subtype *st = sql_bind_localtype("str");
			comp_type cmp = (sc->token == SQL_LIKE ? cmp_like : cmp_notlike);

			if (!ls)
				return NULL;

			lo = ro->data.lval->h->data.sym;
			a = sql_value_exp(sql, scp, lo, grp, subset);
	
			if (!a){
				stmt_destroy(ls);
				return NULL;
			}
			if (dlist_length(ro->data.lval) == 2) {
				symbol *es = ro->data.lval->h->next->data.sym;
				e = sql_value_exp(sql, scp, es, grp, subset );
				if (!check_types(sql, st, e) ){
					return sql_error(sql, 02, "Wrong type used with LIKE ESCAPE statment, should be string" );
				}
			}
			if (e) {
				return sql_error(sql, 02, "Time to implement LIKE escapes");
			}
			if (!check_types(sql, st, a) ){
				return sql_error(sql, 02, "Wrong type used with LIKE stmt, should be string" );
			}
			res = stmt_select(ls, a, cmp);
			return res;
		}
	case SQL_IN:
	case SQL_NOT_IN:
		/*
         <in predicate> ::=
              <row value constructor>
                [ NOT ] IN <in predicate value>

         <in predicate value> ::=
                <table subquery>
              | <left paren> <in value list> <right paren>

         <in value list> ::=
              <value expression> { <comma> <value expression> }...
		*/
		{
			dlist *l = sc->data.lval;
			symbol *lo = l->h->data.sym;
			stmt *ls = sql_value_exp(sql, scp, lo, grp, subset);
			if (!ls)
				return NULL;
			if (l->h->next->type == type_list) {
				dnode *n = l->h->next->data.lval->h;
				sql_subtype *ct = tail_type(ls);
				stmt *temp = stmt_temp(sql_dup_subtype(ct));

				for (; n; n = n->next) {
					symbol *sval = n->data.sym;
					stmt *v = sql_value_exp(sql, scp, sval, NULL, NULL); 
					temp = stmt_append(temp, 
						check_types(sql, ct, v) );
				}
				if (sc->token == SQL_IN){
					/* normal subquery */
					if (ls->nrcols) {
						return stmt_reverse(
							stmt_semijoin(
						 	stmt_reverse(ls), 
						 	stmt_reverse(temp)));
					} else { /* boolean expression */
						return stmt_exist(
							stmt_reverse(temp),ls);
					}
				} else { /* SQL_NOT_IN */
					return stmt_diff(
						stmt_dup(ls), stmt_join(
						 ls, 
					         stmt_reverse(temp), 
						 cmp_equal));
				}
			} else if (l->h->next->type == type_symbol) {
				symbol *ro = l->h->next->data.sym;
				stmt *sq = scope_subquery(sql, scp, ro);

				if (!sq)
					return NULL;

				if (sq->type != st_list
				    || list_length(sq->op1.lval) == 0) {
					stmt_destroy(sq);
					return sql_error(sql, 02, "Subquery result wrong");
				}
				if (list_length(sq->op1.lval) == 1) {
					stmt *rs = stmt_dup(sq->op1.lval->h->data);
					stmt_destroy(sq);
					if (sc->token == SQL_IN){
					  return
					    stmt_reverse
					    (stmt_semijoin
					     (stmt_reverse(ls),
					      stmt_reverse(rs)));
					} else { /* SQL_NOT_IN */
					  return
					    stmt_reverse
					    (stmt_diff
					     (stmt_reverse(ls),
					      stmt_reverse(rs)));
					}
				} else {	
					/* TODO fix this broken impl ! */
					return sql_error(sql, 03, "time to implement (NOT) IN with outer refs\n");
				}
				return NULL;
			} else {
				return sql_error(sql, 02, "In missing inner query");
			}
		}
		break;
	case SQL_EXISTS:
	case SQL_NOT_EXISTS:
		{
			symbol *lo = sc->data.sym;
			scope *nscp = scope_open(scp);
			stmt *ls = sql_subquery(sql, nscp, lo);

			scp = scope_close(nscp);

			if (!ls)
				return NULL;
			if (ls->type != st_list) {
				stmt_destroy(ls);
				return sql_error(sql, 02, "Subquery result wrong");
			}
			if (list_length(ls->op1.lval) == 1) {
				/* EXIST non empty result means AND TRUE */
				/* NOT EXIST non empty result means AND FALSE */
				/* EXISTS pivot.semijoin(pivot.outerjoin(result));
				 * NOT EXISTS pivot.diff(pivot.outerjoin(result));
				 */
				stmt *res, *s = ls->op1.lval->h->data; 
				printf("stupid exists not implemented\n");
				res = stmt_reverse(stmt_dup(s));
				stmt_destroy(ls);
				return res;
			} else {
				/* for now assume single outer ref ! */
				node *o = ls->op1.lval->h;
				stmt *t, *oref = stmt_dup(o->next->data);

				/* need to fix the oref tail */
				t = stmt_dup(oref->t->t);
				stmt_destroy(oref->t);
				oref->t = t;

				t = stmt_reverse(oref);
				if (sc->token == SQL_NOT_EXISTS) 
					t = stmt_diff(scope_first_pivot(scp),t);
				stmt_destroy(ls);
				return stmt_filter(t);
			}
		}
		break;
	case SQL_NULL:
	case SQL_NOT_NULL:
		{
			symbol *cr = sc->data.sym;
			stmt *res =
			    sql_value_exp(sql, scp, cr, grp, subset);

			if (res) {
				sql_subtype *tpe = sql_dup_subtype(tail_type(res));
				stmt *a = stmt_atom(atom_general(tpe, NULL));

				if (sc->token == SQL_NULL) {
					res = stmt_uselect(res, a, cmp_equal);
				} else {
					res = stmt_uselect(res, a,
							cmp_notequal);
				}
			}
			return res;
		}
		break;
	case SQL_ATOM: {
			AtomNode *an = (AtomNode*)sc;
			/* TRUE or FALSE */
			return stmt_atom(atom_dup(an->a));
		} break;
	default:
		return sql_error(sql, 02, 
			 "Predicate %s %d: time to implement some more",
			 token2string(sc->token), sc->token);
	}
	return sql_error(sql, 02, "Predicate: time to implement some more");
}

static stmt *having_condition(mvc * sql, scope * scp, symbol * sc, group * grp, stmt * subset)
{
	if (!sc)
		return NULL;
	switch (sc->token) {
	case SQL_OR:
		{
			symbol *lo = sc->data.lval->h->data.sym;
			symbol *ro = sc->data.lval->h->next->data.sym;
			stmt *ls = having_condition(sql, scp, lo, grp, subset);
			stmt *rs = having_condition(sql, scp, ro, grp, subset);
			if (!ls || !rs)
				return NULL;

			return stmt_union(ls, rs);
		}
		break;
	case SQL_AND:
		{
			symbol *lo = sc->data.lval->h->data.sym;
			symbol *ro = sc->data.lval->h->next->data.sym;
			stmt *ls = having_condition(sql, scp, lo, grp, subset);
			stmt *rs = having_condition(sql, scp, ro, grp, subset);
			if (!ls || !rs)
				return NULL;

			return stmt_semijoin(ls, rs);
		}
		break;
	case SQL_COMPARE:
	case SQL_BETWEEN:
	case SQL_NOT_BETWEEN:
	case SQL_LIKE:
	case SQL_NOT_LIKE:
	case SQL_IN:
	case SQL_NOT_IN:
	case SQL_EXISTS:
	case SQL_NOT_EXISTS:
			return sql_logical_exp(sql, scp, sc, grp, subset);
	default:
		return sql_error(sql, 02, 
			 "Predicate %s %d: time to implement some more",
			 token2string(sc->token), sc->token);
	}
	return sql_error(sql, 02, "Predicate: time to implement some more");
}


static group *query_groupby_inner(mvc * sql, scope * scp, stmt * c, stmt * subset, group * cur)
{
	stmt *s = find_pivot(subset, c->h);
	(void) scp; /* Stefan: unused!? */

	if (s) {
		stmt *j = stmt_join(s, c, cmp_equal);
		cur = grp_create(j, cur);
	}

	if (!cur) {
		char *cn = column_name(c);
		assert(cur);
		(void) sql_error(sql, 02, 
			 "subset not found for groupby column %s\n", cn);
		_DELETE(cn);
		return NULL;
	}
	return cur;
}

static group *query_groupby(mvc * sql, scope * scp, symbol * groupby, stmt * subset)
{
	group *cur = NULL;
	dnode *o = groupby->data.lval->h;
	while (o) {
		symbol *grp = o->data.sym;
		stmt *c = sql_column_ref(sql, scp, grp);
		if (!c) {
			if (cur) grp_destroy(cur);
			return NULL;
		}
		cur = query_groupby_inner(sql, scp, c, subset, cur);
		o = o->next;
	}
	return cur;
}

static group *query_groupby_outers(mvc * sql, scope * scp, stmt * subset)
{
	group *cur = NULL;
	node *o = scp->outers->h;
	(void) sql; /* Stefan: unused!? */

	for ( ; o; o = o->next) {
		stmt *outer = o->data;
		stmt *s = find_pivot(subset, outer);
		if (s) 
			cur = grp_create(s, cur);
	}
	return cur;
}

/*
   select column_1, column_2 from x order by column_1, column_2;

   As SQL-3 drop support for order by number (column position in result table)
   so we also do not support it. Unfortunately SQL-3 added new crap,
   order by 'expression', where expression should match a result column 
   expression. We also do not support this (just use as bla and order by bla!).
   SQL-3 supports ordering on columns not in the result table, but again we
   don't.
 */
static stmt *
orderby_column_ref(mvc * sql, symbol * column_r, stmt *s)
{
	dlist *l = column_r->data.lval;

	assert(column_r->token == SQL_COLUMN
	       && column_r->type == type_list);

	if (dlist_length(l) == 1) {
		char *name = l->h->data.sval;
		node *n;

 		for (n = s->op1.lval->h; n; n = n->next) {
			stmt *t = n->data;
			char *cn = column_name(t);

			if (strcmp(cn, name) == 0){
				_DELETE(cn);
				return stmt_dup(t);
			}
			_DELETE(cn);
		}
		return sql_error( sql, 02, "Unknown column name (%s) in order by", name );
	}
	return sql_error( sql, 02, "Only single column names supported in order by" );
}

static stmt *query_orderby(mvc * sql, symbol * orderby, stmt * s )
{
	stmt *cur = NULL;
	dnode *o = orderby->data.lval->h;

	while (o) {
		symbol *order = o->data.sym;
		if (order->token == SQL_COLUMN) {
			symbol *col = order->data.lval->h->data.sym;
			int direction = order->data.lval->h->next->data.ival;
			stmt *sc = orderby_column_ref(sql, col, s);

			if (sc) {
				if (cur)
					cur = stmt_reorder(cur, sc, direction);
				else
					cur = stmt_order(sc, direction);
			} else {
				return NULL;
			}
		} else {
			return sql_error(sql, 02, "order not of type SQL_COLUMN\n");
		}
		o = o->next;
	}
	return cur;
}

static stmt *sql_simple_select(mvc * sql, scope * scp, dlist * selection)
{
	stmt *s = NULL;
	list *rl = create_stmt_list();

	if (selection) {
		dnode *n = selection->h;
		while (n) {
			stmt *cs = sql_column_exp(sql, scp, n->data.sym, NULL, NULL);

			if (!cs) {
				list_destroy(rl);
				return NULL;
			}

			/* t1.* */
			if (cs->type == st_list && n->data.sym->token == SQL_TABLE) {
				list_merge(rl, cs->op1.lval, (fdup)&stmt_dup);
				stmt_destroy(cs);
			} else if (cs->type == st_list) {	/* subquery */
				if (list_length(cs->op1.lval) == 1){ 
					list_append(rl, stmt_dup(cs->op1.lval->h->data));
				} else {
					stmt_destroy(cs);
					return sql_error( sql, 02, "Subquery should return a single value");
				}
			/*
			} else if (cs->nrcols == 0){
				list_append(rl, cs);
			*/
			} else {
				list_append(rl, cs);
			}
			n = n->next;
		}
	}
	s = stmt_list(rl);

	if (!s)
		return sql_error(sql, 02, "Subquery result missing");
	return s;
}

static stmt *sql_select(mvc * sql, scope * scp, SelectNode *sn, int toplevel )
{
	list *rl = NULL;
	stmt *s = NULL;

	stmt *order = NULL, *subset = NULL;
	group *grp = NULL;

	if (!sn->from && !sn->where)
		return sql_simple_select(sql, scp, sn->selection);

	if (sn->where) {
		node *n;
		stmt *cur = NULL;

		s = sql_logical_exp(sql, scp, sn->where, NULL, NULL);
		if (!s) {
			sql_select_cleanup(sql, s, subset, grp);
			return sql_error( sql, 02, "Subquery result missing");
		}
		if (s->type != st_set && s->type != st_sets) {
			s = stmt_set(s);
		}
		/* check for tables not used in the where part */
		if (s->type == st_set){ /* TODO: handle st_sets!! */
		    for (n = scp->tables->h; n; n = n->next) {
			tvar *v = n->data;
			stmt *tmp = complex_find_subset(s, v->s);
			if (!tmp) {
				cvar *cv = v->columns->h->data;
				tmp = stmt_dup(cv -> s);
				/* just add a select whole column */
				if (!cur) {
					cur = stmt_dup(tmp);
				/* add join to an already used column */
				} else {	
					tmp = stmt_join(stmt_dup(cur),
						stmt_reverse(tmp), cmp_all);
				}
				s = sql_and(sql, s, tmp);
			} else if (!cur) {
				cur = tmp;
			} else {
				stmt_destroy(tmp);
			}
		    }
		}
		if (cur) 
			stmt_destroy(cur);
		
	} else if (sn->from) {
		node *n;
		stmt *cur = NULL;
		for (n = scp->tables->h; n; n = n->next) {
			tvar *tv = n->data;
			cvar *cv = tv->columns->h->data;
			stmt *tmp = stmt_dup(cv -> s);
			if (!cur) {
				if (isbasetable(tv->s)){
					cur = stmt_diff(tmp, stmt_reverse(
					   stmt_tbat(basetable_table(tv->s), RDONLY )));
				} else {
					cur = tmp;
				}
			} else {
				tmp = stmt_join(stmt_dup(cur), 
						stmt_reverse(tmp), cmp_all);
				if (s) {
					list_append(s->op1.lval, tmp);
				} else {
					s = stmt_set(tmp);
				}
			}
		}
		if (!cur) {
			sql_select_cleanup(sql, s, subset, grp);
			return sql_error(sql, 02, "Subquery has no columns");
		}
		if (!s)
			s = cur;
		else
			stmt_destroy(cur);
	}

	if (s) {
		s = stmt2pivot(scp, s);
		if (s && sn->groupby) {
			grp = query_groupby(sql, scp, sn->groupby, s);
			if (!grp)  {
				sql_select_cleanup(sql, s, subset, grp);
				return sql_error( sql, 02, "Subquery result missing");
			}
		}

		if (s && list_length(scp->outers) > 0) {
			assert(!grp);
			grp = query_groupby_outers(sql, scp, s);
			if (!grp) {
				assert(0);
				sql_select_cleanup(sql, s, subset, grp);
				return sql_error( sql, 02, "Subquery outer ref groupby result missing");
			}
		}
	}

	subset = stmt_dup(s);
	if (sn->having) {
		if (s) stmt_destroy(s);
		s = having_condition(sql, scp, sn->having, grp, subset);

		if (!s){
			sql_select_cleanup(sql, s, subset, grp);
			return sql_error( sql, 02, "Subquery result missing");
		}

		if (!grp) {
			sql_subtype *it = sql_bind_localtype( "int" );

			/* implicit single group of whole result */
			grp = grp_create(stmt_const(stmt_dup(subset),
				stmt_atom(atom_int(sql_dup_subtype(it), 0))), 
			      NULL);
		}
		grp = grp_semijoin(grp, stmt_dup(s));
	}

	if (!subset){
		sql_select_cleanup(sql, s, subset, grp);
		return sql_error( sql, 02, "Subquery result missing");
	}

	rl = create_stmt_list();
	if (sn->selection) {
		list *sl = create_stmt_list();
		dnode *n;
		node *m;
		int nrcols = 0;

		for (n = sn->selection->h; n; n = n->next ){
			stmt *cs = sql_column_exp(sql, scp, n->data.sym, grp, subset);
			if (!cs){
				list_destroy(sl);
				list_destroy(rl);
				sql_select_cleanup(sql, s, subset, grp);
				return sql_error( sql, 02, "Subquery result missing");
			}

			list_append(sl, cs);
			if (nrcols < cs->nrcols)
				nrcols = cs->nrcols;
		}

		for (m = sl->h, n = sn->selection->h; 
		     m && n; 
		     m = m->next, n = n->next){
			stmt *cs = m->data; 
			/* t1.* */
			if (cs->type == st_list && n->data.sym->token == SQL_TABLE){
				list_merge(rl, cs->op1.lval, (fdup)&stmt_dup);
			} else if (cs->type == st_list) {	/* subquery */
				if (list_length(cs->op1.lval) == 1) {	/* single value */
					stmt *ss = ptable_pivots(subset)->h->data;
					stmt *cs1 = cs->op1.lval->h->data;
					ss = stmt_dup(ss);
					cs1 = stmt_dup(cs1);
					list_append(rl, stmt_join (ss, cs1, cmp_all));
				} else {	/* referenced variable(s) (can only be 2) */
					stmt *sqa = cs->op1.lval->h->data;
					stmt *ids = cs->op1.lval->h->next->data;
					stmt *s = stmt_join( 
						stmt_reverse(stmt_dup(ids)),
						stmt_dup(sqa), cmp_equal);
					s = stmt_outerjoin(
						stmt_mirror(
						    first_subset(subset)), 
						s, cmp_equal);
					list_append(rl, s);
				}
			} else if (cs->nrcols == 0 && nrcols > 0){
				/* select name,count(*) should give an error */
				if (!cs->aggr){
					stmt *ss = first_subset(subset);
					cs = stmt_const(ss,stmt_dup(cs));
					list_append(rl, cs);
				} else {
					list_destroy(sl);
					list_destroy(rl);
					sql_select_cleanup(sql, s, subset, grp);
					return sql_error( sql, 02, "single value in column expression");
				}
			} else {
				cs = stmt_dup(cs);
				list_append(rl, cs);
			}
		}
		list_destroy(sl);
	} else {
		/* select * from tables */
		if (grp && list_length(scp->outers) <= 0) {
			list_destroy(rl);
			sql_select_cleanup(sql, s, subset, grp);
			return sql_error( sql, 02, "Cannot combine select * with group by");
		}
		if (toplevel) {
			node *nv;
			for (nv = scp->tables->h; nv; nv = nv->next) {
				node *n;
				tvar *tv = nv->data;
				stmt *foundsubset = find_pivot(subset, tv->s);

				for (n = tv->columns->h; n; n = n->next) {
					cvar *cs = n->data;
					stmt *cbat = stmt_dup(cs->s);
					list_append(rl, stmt_join(stmt_dup(foundsubset), cbat, cmp_equal));
				}
				stmt_destroy(foundsubset);
			}
		} else {
			/* 
			 * subquery can only return one column
			 */
			tvar *tv = scope_first_table(scp);
			stmt *foundsubset = find_pivot(subset, tv->s);

			if (!foundsubset){
				list_destroy(rl);
				sql_select_cleanup(sql, s, subset, grp);
				return sql_error( sql, 02, "Subquery result missing");
			}
			list_append(rl, foundsubset);
		}
	}
	/* the inner query should output a table where the first bat
	 * contains the queried column values. 
	 * If variables from the outer query are correlated 
	 * the oids from the base tables of these variables are returned
	 * in the next columns.
	 */
	if (list_length(scp->outers) > 0) {
		node *n = scp->outers->h;
		for (; n; n = n->next) {
			stmt *oref = n->data;
			stmt *foundsubset = find_pivot(subset, oref);
			stmt *t;

			if (!foundsubset){
				list_destroy(rl);
				sql_select_cleanup(sql, s, subset, grp);
				return sql_error( sql, 02, "Subquery result missing");
			}
			list_append(rl,
				t=stmt_join( stmt_dup(grp->ext), 
					   foundsubset, cmp_equal));
			/* needed for subquery johan (select * from select *) */
			t->nrcols = 1;
		}
	}
	stmt_destroy(s);
	s = stmt_list(rl);

	if (s && subset && sn->distinct){
		s = distinct(s);
	}

	if (s && subset && sn->orderby) {
		order = query_orderby(sql, sn->orderby, s);
		if (!order) {
			sql_select_cleanup(sql, s, subset, grp);
			return sql_error( sql, 02, "Subquery result missing");
		}
	}

	if (!s) {
		sql_select_cleanup(sql, s, subset, grp);
		return sql_error( sql, 02, "Subquery result missing");
	}

	sql_select_cleanup(sql, NULL, subset, grp);

	if (sn->limit >= 0){
		if (order) 
			order = stmt_limit(order, sn->limit);
		else 
			order = stmt_limit(stmt_dup(s->op1.lval->h->data), sn->limit);
	}

	if (s && order)
		return stmt_ordered(order, s);
	return s;
}

static char *strfnd( char *s, char *sep )
{
	int l = strlen(sep);
	while( *s && (*s != *sep || strncmp(s, sep, l) != 0) ){
		s++;
	}
	if (*s)
		return s + l;
	return NULL;
}

static stmt *insert_value(mvc * sql, scope * scp, sql_column * c, symbol * s)
{
	if (s->token == SQL_NULL) {
		return stmt_atom(atom_general(sql_dup_subtype(c->type), NULL));
	} else {
		stmt *n = NULL;
		stmt *a = sql_value_exp(sql, scp, s, NULL, NULL);
		if (!a || !(n = check_types(sql, c->type, a))) {
			if (a) stmt_destroy(a);
			return NULL;
		}
		return n;
	}
	return NULL;
}

void cleanup_stmts(stmt **stmts, int cnt){
	int i;
	for (i=0; i<cnt; i++){
		if (stmts[i])
			stmt_destroy(stmts[i]);
	}
	_DELETE(stmts);
}


static stmt *
insert_check_ukey( mvc * sql, stmt **inserts, sql_key *k, stmt *idx_inserts )
{
	char buf[BUFSIZ];
	stmt *res;

	sql_subtype *it = sql_bind_localtype( "int" );
	sql_subtype *lt = sql_bind_localtype( "lng" );
	sql_subaggr *cnt = sql_bind_aggr("count", NULL);
	sql_subtype *bt = sql_bind_localtype( "bit" );

	if (list_length(k->columns) > 1){
		node *m;
		stmt *s; 
		sql_subaggr *sum;
		stmt *count_sum = NULL;
	    	sql_subfunc *ne = sql_bind_func_result("<>", it, it, bt);

		/* 1st stage: find out if original contains same values */
		if (inserts[0]->op2.stval->key){
			s = stmt_relselect_init();
			stmt_relselect_fill( s, stmt_uselect(
				stmt_idxbat(k->idx,0), stmt_dup(idx_inserts), cmp_equal)); 
			for(m = k->columns->h; m; m = m->next) {
				sql_kc *c = m->data;
				stmt_relselect_fill( s, stmt_uselect(
					stmt_dup(inserts[c->c->colnr]->op1.stval), 
					stmt_dup(inserts[c->c->colnr]->op2.stval),
					cmp_equal));
			}
		} else {
			s = stmt_reljoin_init();
			stmt_reljoin_fill( s, 
				 	stmt_idxbat(k->idx,0), 
					stmt_dup(idx_inserts)); 
			for(m = k->columns->h; m; m = m->next) {
				sql_kc *c = m->data;
				stmt_reljoin_fill( s,
					stmt_dup(inserts[c->c->colnr]->op1.stval), 
					stmt_dup(inserts[c->c->colnr]->op2.stval));
			}
		}
		s = stmt_binop(stmt_aggr(s, NULL, cnt),
			stmt_atom(atom_int(sql_dup_subtype(it), 0)), ne);

		/* 2e stage: find out if inserted are unique */
		if (idx_inserts->nrcols){ /* insert columns not atoms */
			group *g = NULL;
		    	stmt *ss;
			sql_subfunc *or = sql_bind_func_result("or", bt, bt, bt);
		    	for(m = k->columns->h; m; m = m->next){
				sql_kc *c = m->data;
				g = grp_create(
					stmt_dup(inserts[c->c->colnr]->op2.stval),g);
			}
			ss = stmt_aggr(stmt_dup(g->grp), grp_dup(g), sql_dup_aggr(cnt));
			grp_destroy(g);
			/* (count(ss) <> sum(ss)) */
			sum = sql_bind_aggr("sum", tail_type(ss));
			count_sum = stmt_binop( 
				check_types(sql, lt, stmt_aggr(stmt_dup(ss), NULL, sql_dup_aggr(cnt))),
				check_types(sql, lt, stmt_aggr(ss, NULL, sum)), 
				sql_dup_func(ne));

			/* combine results */
			s = stmt_binop(s, count_sum, or);
		}

		snprintf(buf, BUFSIZ, 
			"key constraint %s.%s failed", k->t->base.name, k->base.name ); 
		res = stmt_exception( s, buf, 00001 );
	} else { /* single column key */
		sql_kc *c = k->columns->h->data;
		stmt *h = stmt_dup(inserts[c->c->colnr]->op2.stval);	
		stmt *s = stmt_uselect( 
			stmt_dup(inserts[c->c->colnr]->op1.stval), h, cmp_equal);
		/* s should be empty */
		snprintf(buf, BUFSIZ, 
			"key constraint %s.%s failed", k->t->base.name, k->base.name ); 
		res = stmt_exception( stmt_aggr(s, NULL, cnt), buf, 00001); 
	}
	return res;
}

static stmt *
insert_check_fkey( mvc * sql, stmt **inserts, sql_key *k, stmt *idx_inserts )
{
	char buf[BUFSIZ];
	stmt *s;
	sql_subtype *it = sql_bind_localtype( "int" );
	sql_subaggr *cnt = sql_bind_aggr("count", NULL);
	sql_subtype *bt = sql_bind_localtype( "bit" );
	sql_subfunc *ne = sql_bind_func_result("<>", it, it, bt);

	(void)sql; /* unused! */

	if (inserts[0]->op2.stval->key){
		s = stmt_binop( 
			stmt_aggr(stmt_dup(idx_inserts), NULL, cnt), 
			stmt_atom(atom_int(sql_dup_subtype(it),1)), ne);
	} else {
		/* reljoin.count <> inserts[col1].count */
		s = stmt_binop( 
			stmt_aggr(stmt_dup(idx_inserts), NULL, cnt), 
			stmt_aggr(stmt_dup(inserts[0]->op2.stval), NULL, 
				sql_dup_aggr(cnt)) , ne);
	}

	/* s should be empty */
	snprintf(buf, BUFSIZ, 
		"key constraint %s.%s failed", k->t->base.name, k->base.name ); 
	return stmt_exception( s, buf, 00001 );
}

static stmt *
sql_insert_key(mvc * sql, stmt **inserts, sql_key *k, stmt *idx_inserts )
{
	/* int insert = 1;
	 * while insert and has u/pkey and not defered then
	 * 	if u/pkey values exist then
	 * 		insert = 0
	 * while insert and has fkey and not defered then
	 *	find id of corresponding u/pkey  
	 *	if (!found)
	 *		insert = 0
	 * if insert
	 * 	insert values
	 * 	insert fkey/pkey index
	 */
	if (k->type == pkey || k->type == ukey){
		return insert_check_ukey( sql, inserts, k, idx_inserts);
	} else { /* foreign keys */
		return insert_check_fkey( sql, inserts, k, idx_inserts);
	}
}

static stmt *
hash_insert( sql_idx *i, stmt **inserts )
{
	node *m;
	sql_subtype *it; 
	int bits = 0;
	stmt *h = NULL;

	if (list_length(i->columns) <= 1)
		return NULL;

	it = sql_bind_localtype( "int" );
	for(m = i->columns->h; m; m = m->next, bits += 8){
		sql_kc *c = m->data;
		sql_subfunc *hf = 
			sql_bind_func_result("hash", c->c->type, it, it);

		if (h){
			sql_subfunc *xor = 
				sql_bind_func_result("xor", it, it, it);
			h = stmt_binop(h, stmt_binop(
				stmt_dup(inserts[c->c->colnr]->op2.stval), 
				stmt_atom(atom_int(sql_dup_subtype(it), bits)), 
				hf), xor);
		} else {
			h = stmt_binop(
				stmt_dup(inserts[c->c->colnr]->op2.stval), 
				stmt_atom(atom_int(sql_dup_subtype(it), bits)), 
				hf);
		}
	}
	return h;
}

static stmt *
join_idx_insert( sql_idx *i, stmt **inserts )
{
	node *m, *o;
	sql_idx *ri = ((sql_fkey*)i->key)->rkey->k.idx;
	stmt *s = NULL, *rts = stmt_basetable(ri->t);

	if (inserts[0]->op2.stval->key){
		s = stmt_relselect_init();
	    	for(m = i->columns->h, o = ri->columns->h; m && o; 
			m = m->next, o = o->next) {
			sql_kc *c = m->data;
			sql_kc *rc = o->data;
			stmt_relselect_fill( s, stmt_uselect(
				stmt_dup(stmt_cbat(rc->c, stmt_dup(rts), 0, st_bat)), 
				stmt_dup(inserts[c->c->colnr]->op2.stval),
				cmp_equal));
		}
		/* append to the pre-computed join-index */
		s = stmt_mark(stmt_reverse(stmt_dup(s)), 0);
	} else {
		s = stmt_reljoin_init();
	    	for(m = i->columns->h, o = ri->columns->h; m && o; 
			m = m->next, o = o->next) {
			sql_kc *c = m->data;
			sql_kc *rc = o->data;
			stmt_reljoin_fill( s,
				stmt_dup(inserts[c->c->colnr]->op2.stval),
				stmt_dup(stmt_cbat(rc->c, stmt_dup(rts), 0, st_bat)));
		}
		/* append to the pre-computed join-index */
	}
	stmt_destroy(rts);
	return s;
}

static int
sql_insert_idxs(mvc * sql, sql_table *t, stmt **inserts, list *l)
{
	node *n;
	int res = 1;

	(void)sql; /* unused!? */
	
	if (!t->idxs.set)
		return res;

 	for(n = t->idxs.set->h; n; n = n->next){
	    	sql_idx *i = n->data;
		stmt *is = NULL;

		if (i->type == unique){
			is = hash_insert( i, inserts); 
		} else if (i->type == join_idx){
			is = join_idx_insert( i, inserts);
		}
		if (i->key){
			stmt *ckeys = sql_insert_key(sql, inserts, i->key, is);
			list_prepend(l, ckeys);
		}
		if (is) 
			list_append(l, stmt_append(stmt_idxbat(i,1), is));
	}
	return res;
}

static int 
is_idx_updated(sql_idx *i, stmt **updates )
{
	int update = 0;
	node *m;

	for(m = i->columns->h; m; m = m->next ){
		sql_kc *ic = m->data;
		
		if (!updates[ic->c->colnr]){
			update = ic->c->colnr;
			break;
		}
	}
	return update;
}

static int 
first_updated_col(stmt **updates, int cnt )
{
	int i;

	for(i = 0; i < cnt; i++) {
		if (updates[i])
			return i;
	}
	return -1;
}

static stmt *
update_check_ukey( mvc * sql, stmt **updates, sql_key *k, stmt *idx_updates, int updcol )
{
	char buf[BUFSIZ];
	stmt *res;

	sql_subtype *it = sql_bind_localtype( "int" );
	sql_subaggr *cnt = sql_bind_aggr("count", NULL);
	sql_subtype *bt = sql_bind_localtype( "bit" );

	if (list_length(k->columns) > 1){
		stmt *ts = stmt_basetable(k->t);
		node *m;
		stmt *s; 
		sql_subaggr *sum;
		stmt *count_sum = NULL;
	    	sql_subfunc *ne = sql_bind_func_result("<>", it, it, bt);

		/* 1st stage: find out if original contains same values */
		s = stmt_reljoin_init();
		stmt_reljoin_fill( s, 
			stmt_diff( stmt_idxbat(k->idx,0), stmt_dup(idx_updates)),
			stmt_dup(idx_updates)); 
		for(m = k->columns->h; m; m = m->next) {
			sql_kc *c = m->data;
			stmt *upd;
			if (updates[c->c->colnr]){
				upd = stmt_dup(updates[c->c->colnr]->op2.stval);
			} else {
				upd = stmt_dup(updates[updcol]->op2.stval);
				upd = stmt_semijoin(
					stmt_cbat(c->c, stmt_dup(ts), RDONLY, st_bat), 
					upd);
			}

			stmt_reljoin_fill( s,
				stmt_diff(
					stmt_dup(updates[c->c->colnr]->op1.stval), 
					stmt_dup(idx_updates)),
				upd);
		}
		s = stmt_binop(stmt_aggr(s, NULL, cnt),
			stmt_atom(atom_int(sql_dup_subtype(it), 0)), ne);

		/* 2e stage: find out if updated are unique */
		if (idx_updates->nrcols){ /* update columns not atoms */
			group *g = NULL;
		    	stmt *ss;
			sql_subfunc *or = sql_bind_func_result("or", bt, bt, bt);
		    	for(m = k->columns->h; m; m = m->next){
				sql_kc *c = m->data;
				stmt *upd;
				if (updates[c->c->colnr]){
					upd = stmt_dup(updates[c->c->colnr]->op2.stval);
				} else {
					upd = stmt_dup(updates[updcol]->op2.stval);
					upd = stmt_semijoin(
						stmt_cbat(c->c, 
							stmt_dup(ts), 
							RDONLY, 
							st_bat), 
						upd);
				}
				g = grp_create(upd,g);
			}
			ss = stmt_aggr(stmt_dup(g->grp), grp_dup(g), sql_dup_aggr(cnt));
			grp_destroy(g);
			/* (count(ss) <> sum(ss)) */
			sum = sql_bind_aggr("sum", tail_type(ss));
			count_sum = stmt_binop( 
				stmt_aggr(stmt_dup(ss), NULL, sql_dup_aggr(cnt)), 
				check_types(sql, it, stmt_aggr(ss, NULL, sum)) , 
				sql_dup_func(ne));

			/* combine results */
			s = stmt_binop(s, count_sum, or);
		}

		snprintf(buf, BUFSIZ, 
			"key constraint %s.%s failed", k->t->base.name, k->base.name ); 
		res = stmt_exception( s, buf, 00001);
	} else { /* single column key */
		sql_kc *c = k->columns->h->data;
		stmt *h = stmt_dup( updates[c->c->colnr]->op2.stval ); 
		stmt *o = stmt_diff( 
				stmt_dup(updates[c->c->colnr]->op1.stval), 
				stmt_dup(updates[c->c->colnr]->op2.stval));	
		stmt *s = stmt_uselect( o, h, cmp_equal);
		/* s should be empty */
		snprintf(buf, BUFSIZ, 
			"key constraint %s.%s failed", k->t->base.name, k->base.name ); 
		res = stmt_exception( stmt_aggr(s, NULL, cnt), buf, 00001); 
	}
	return res;
}

static stmt *
update_check_fkey( mvc * sql, stmt **updates, sql_key *k, stmt *idx_updates, int updcol )
{
	char buf[BUFSIZ];
	stmt *s;
	sql_subtype *it = sql_bind_localtype( "int" );
	sql_subaggr *cnt = sql_bind_aggr("count", NULL);
	sql_subtype *bt = sql_bind_localtype( "bit" );
	sql_subfunc *ne = sql_bind_func_result("<>", it, it, bt);

	(void)sql; /* unused! */
	/* reljoin.count <> updates[updcol].count */
	s = stmt_binop( 
		stmt_aggr(stmt_dup(idx_updates), NULL, cnt), 
		stmt_aggr(stmt_dup(updates[updcol]->op2.stval), NULL, sql_dup_aggr(cnt)), 
		ne);

	/* s should be empty */
	snprintf(buf, BUFSIZ, 
		"key constraint %s.%s failed", k->t->base.name, k->base.name ); 
	return stmt_exception( s, buf, 00001 );
}

static stmt *
sql_update_key(mvc * sql, stmt **updates, sql_key *k, stmt *idx_updates, int updcol )
{
	if (k->type == pkey || k->type == ukey){
		return update_check_ukey( sql, updates, k, idx_updates, updcol);
	} else { /* foreign keys */
		return update_check_fkey( sql, updates, k, idx_updates, updcol);
	}
}

static stmt *
hash_update( sql_idx *i, stmt **updates, int updcol )
{
	/* calculate new value */
	node *m;
	sql_subtype *it;
	int bits = 0;
	stmt *h = NULL, *ts;

	if (list_length(i->columns) <= 1)
		return NULL;

	ts = stmt_basetable(i->t);
 	it = sql_bind_localtype( "int" );
	for(m = i->columns->h; m; m = m->next, bits += 8){
		sql_kc *c = m->data;
		sql_subfunc *hf = sql_bind_func_result("hash", c->c->type, it, it);
		stmt *upd;

		if (updates[c->c->colnr]){
			upd = stmt_dup(updates[c->c->colnr]->op2.stval);
		} else {
			upd = stmt_dup(updates[updcol]->op2.stval);
			upd = stmt_semijoin(
				stmt_cbat(c->c, stmt_dup(ts), RDONLY, st_bat), 
				upd);
		}
	
		if (h){
			sql_subfunc *xor = sql_bind_func_result("xor", it, it, it);
			h = stmt_binop(h, stmt_binop(upd, 
				stmt_atom(atom_int(sql_dup_subtype(it), bits)), hf), xor);
		} else {
			h = stmt_binop(upd, stmt_atom(
				atom_int(sql_dup_subtype(it), bits)), hf);
		}
	}
	stmt_destroy(ts);
	return h;
}

static stmt *
join_idx_update( sql_idx *i, stmt **updates, int updcol )
{
	node *m, *o;
	sql_idx *ri = ((sql_fkey*)i->key)->rkey->k.idx;
	stmt *s = NULL, *rts = stmt_basetable(i->t), *ts;

	ts = stmt_basetable(i->t);
	s = stmt_reljoin_init();
	for(m = i->columns->h, o = ri->columns->h; m && o; 
		m = m->next, o = o->next) {
		sql_kc *c = m->data;
		sql_kc *rc = o->data;
		stmt *upd;

		if (updates[c->c->colnr]){
			upd = stmt_dup(updates[c->c->colnr]->op2.stval);
		} else {
			upd = stmt_dup(updates[updcol]->op2.stval);
			upd = stmt_semijoin(
				stmt_cbat(c->c, stmt_dup(ts), RDONLY, st_bat), 
				upd);
		}
		stmt_reljoin_fill( s, upd,
			stmt_dup(stmt_cbat(rc->c, stmt_dup(rts), 0, st_bat)));
	}
	stmt_destroy(ts);
	stmt_destroy(rts);
	return s;
}

static int 
sql_update_idxs(mvc * sql, sql_table *t, stmt **updates, list *l)
{
	int res = 1;
	node *n;
	int updcol;

	(void)sql; 

	if (!t->idxs.set)
		return res;

	updcol = first_updated_col(updates, list_length(t->columns.set));
 	for(n = t->idxs.set->h; n; n = n->next){
	    	sql_idx *i = n->data;
	    	stmt *is = NULL;

		/* check if update is needed, 
		 * ie atleast on of the idx columns is updated 
		 */
		if ( is_idx_updated(i, updates) == 0)
			continue;

		if (i->type == unique){
			is = hash_update( i, updates, updcol); 
		} else if (i->type == join_idx){
			is = join_idx_update( i, updates, updcol);
		}
		if (is && i->key){
			stmt *ckeys = sql_update_key(sql, updates, i->key, is, updcol);
			list_prepend(l, ckeys);
		}
		if (is) 
			list_append( l, stmt_replace(stmt_idxbat(i,1), is));
	}
	return res;
}

stmt *sql_insert(mvc * sql, sql_table *t, stmt **inserts, int len)
{
	char buf[BUFSIZ];
	int i;
	list *l = create_stmt_list();
	node *n;
	sql_subaggr *cnt = sql_bind_aggr("count", NULL);

	if (!sql_insert_idxs(sql, t, inserts, l)){
		return sql_error(sql, 02, 
			"Inserting into indexes failed for table %s",
			t->base.name);
	}

	for(n = t->columns.set->h; n; n = n->next){
		sql_column *c = n->data;

		if (!inserts[c->colnr]) {
			list_destroy(l);
			sql_subaggr_destroy( cnt );
			return NULL;
		}
		if (!c->null) {
			stmt *s = NULL;
			if (!inserts[c->colnr]->op2.stval->key){
				s = stmt_atom( atom_general(
					sql_dup_subtype(c->type), NULL));
				s = stmt_uselect( 
					stmt_dup(inserts[c->colnr]->op2.stval), 
					s, cmp_equal);
				s = stmt_aggr(s, NULL, sql_dup_aggr(cnt)); 
			} else {
				sql_subfunc *isnil = 
					sql_bind_func("isnull", c->type, NULL );
				s = stmt_unop(
					stmt_dup(inserts[c->colnr]->op2.stval), 
 					isnil);
			}
			snprintf(buf, BUFSIZ, 
				"null constraint %s.%s failed", 
				c->t->base.name, c->base.name ); 
			s = stmt_exception( s, buf, 00001); 
			
			list_prepend(l, s);
		}
	}

	sql_subaggr_destroy( cnt );
	for (i = 0; i < len; i++) 
		list_append(l, stmt_dup(inserts[i]));
	return stmt_list(l);
}

static stmt *insert_into(mvc * sql, dlist * qname,
			 dlist * columns, symbol * val_or_q)
{
	scope *scp;
	tvar *tv = NULL;

	sql_schema *s = qname_schema(sql, qname);
	char *tname = qname_table(qname);
	sql_table *t;
	list *collist = NULL;
	int i, len = 0;
	stmt **inserts, *res = NULL;

	if (!s || (t = mvc_bind_table(sql, s, tname)) == NULL) {
		return sql_error(sql, 02, 
			"Inserting into non existing table %s", tname);
	}
	if (!table_privs(sql, t, PRIV_INSERT)){
		return sql_error(sql, 02, 
			"User is not allowed to insert into table %s", tname);
	}
	if (columns) {
		dnode *n;

		collist = list_create((fdestroy)NULL);
		for (n = columns->h; n; n = n->next ) {
			sql_column *c = mvc_bind_column(sql, t, n->data.sval);
			if (c) {
				list_append(collist, c);
			} else {
				return sql_error(sql, 02, "Inserting into non existing column %s.%s", tname, n->data.sval);
			}
		}
	} else {
		collist = t->columns.set;
	}

	len = list_length(t->columns.set);
	inserts = NEW_ARRAY(stmt *, len);
	for (i = 0; i < len; i++)
		inserts[i] = NULL;

	scp = scope_open(NULL);
	tv = scope_add_table_columns(sql, scp, t, t->base.name);

	if (val_or_q->token == SQL_VALUES) {
		dlist *values = val_or_q->data.lval;
		if (dlist_length(values) != list_length(collist)) {
			scp = scope_close(scp);
			return sql_error(sql, 02, 
				 "Inserting into table %s, number of values doesn't match number of columns", tname);
		} else {
			dnode *n;
			node *m;

			for (n = values->h, m = collist->h;
			     n && m; n = n->next, m = m->next) {
				sql_column *c = m->data;
				stmt *ins = insert_value(sql, NULL, c, n->data.sym);
				if (!ins){
					cleanup_stmts(inserts, len);
					return NULL;
				}
					
				inserts[c->colnr] = stmt_append( stmt_cbat(c, stmt_dup(tv->s), INS, st_bat), ins );
			}

		}
		for(i=0; i<len; i++){
			if (!inserts[i]){
				node *m;
				for(m = t->columns.set->h; m; m = m->next){
					sql_column *c = m->data;
					if (c->colnr == i) {
						atom *a = atom_general(
						    sql_dup_subtype(c->type), 
						    _strdup(c->def) );
						/* no valid default ! */
						if (!a) {
							scp = scope_close(scp);
		
							cleanup_stmts(inserts, len);
							return sql_error(sql, 02, 
				 				"column %s has no valid default value", c->base.name);
						}
						inserts[i] = stmt_append( stmt_cbat(c, stmt_dup(tv->s), INS, st_bat), stmt_atom(a));
					}
				}
			}
		}
	} else {
		stmt *s = sql_subquery(sql, NULL, val_or_q);

		if (!s){
			scp = scope_close(scp);
			cleanup_stmts(inserts, len);
			return NULL;
		}
		if (list_length(s->op1.lval) != list_length(collist)) {
			if (s) 
				stmt_destroy(s);
			scp = scope_close(scp);
			cleanup_stmts(inserts, len);
			return sql_error(sql, 02, 
				 "Inserting into table %s, query result doesn't match number of columns", tname);
		} else {
			node *m, *n;

			for (n = s->op1.lval->h, m = collist->h;
			     n && m; n = n->next, m = m->next) {
				sql_column *c = m->data;
				stmt *ins = check_types(sql, c->type, 	
					stmt_dup(n->data));
				if (!ins){
					scp = scope_close(scp);
					cleanup_stmts(inserts, len);
					return NULL;
				}
				inserts[c->colnr] = stmt_append( stmt_cbat(c, stmt_dup(tv->s), INS, st_bat), ins);
			}
		}
		if (s) 
			stmt_destroy(s);
	}
	if (collist != t->columns.set)
		list_destroy(collist);
	res = sql_insert(sql, t, inserts, len);
	scp = scope_close(scp);
	cleanup_stmts(inserts, len);
	return res;
}

static stmt *sql_bulkinsert(mvc * sql, sql_table *t, char *tsep, char *rsep, char *filename, int nr )
{
	sql_subtype *strtype = sql_bind_localtype( "str" );
	stmt *bats = NULL;
	stmt *fname = (filename)?stmt_atom(atom_string(
			sql_dup_subtype(strtype), _strdup(filename))):NULL;
	node *n;
	int i, len = 0;
	stmt **inserts, *res = NULL;
	
	scope *scp = scope_open(NULL);
	tvar *tv  = scope_add_table_columns(sql, scp, t, t->base.name);

	bats = stmt_bulkinsert(stmt_basetable(t), tsep, rsep, fname, nr);
	len = list_length(t->columns.set);
	inserts = NEW_ARRAY(stmt *, len);
	for(n=t->columns.set->h, i = 0; n; n = n->next, i++){
		sql_column *c = n->data;
		inserts[i] = stmt_append( 
		  stmt_cbat(c, stmt_dup(tv->s), INS, st_bat), 
		    stmt_find(stmt_dup(bats), stmt_atom(atom_string(
				sql_dup_subtype(strtype), 
				_strdup(c->base.name)))));
	}
	stmt_destroy(bats);
	res = sql_insert(sql, t, inserts, len);
	scp = scope_close(scp);
	cleanup_stmts(inserts, len);
	return res;
}

static stmt *copyfrom(mvc * sql, dlist * qname, dlist *files, dlist *seps, int nr)
{
	char *tname = qname_table(qname);
	sql_table *t = mvc_bind_table(sql, cur_schema(sql), tname);
	char *tsep = seps->h->data.sval;
	char *rsep = seps->h->next->data.sval;
	list *slist;

	if (!t) {
		return sql_error(sql, 02, 
				"Copy into non existing table %s", tname);
	} else if (files){
		dnode *n = files->h;
		for (slist = create_stmt_list(); n; n = n->next){
			char *fname = n->data.sval;
			list_append(slist, 
				sql_bulkinsert( sql, t, tsep, rsep, fname, nr));
		}
		return stmt_list(slist);
	}
 	slist = create_stmt_list();
	list_append(slist, sql_bulkinsert( sql, t, tsep, rsep, NULL, nr ));
	return stmt_list(slist);
}


static stmt *sql_update(mvc * sql, sql_table *t, stmt **updates, list *l )
{
	char buf[BUFSIZ];
	node *n;
	sql_subaggr *cnt = sql_bind_aggr("count", NULL);

	if (!sql_update_idxs(sql, t, updates, l)){
		return sql_error(sql, 02, 
			"Updating indexes failed for table %s",
			t->base.name);
	}

	for(n = t->columns.set->h; n; n = n->next){
		sql_column *c = n->data;

		if (updates[c->colnr] && !c->null) {
			stmt *s = NULL;
			if (!updates[c->colnr]->op2.stval->key){
				s = stmt_atom( atom_general(
					sql_dup_subtype(c->type), NULL));
				s = stmt_uselect( 
					stmt_dup(updates[c->colnr]->op2.stval), 
					s, cmp_equal);
				s = stmt_aggr(s, NULL, sql_dup_aggr(cnt)); 
			} else {
				sql_subfunc *isnil = 
					sql_bind_func("isnull", c->type, NULL );
				s = stmt_unop(
					stmt_dup(updates[c->colnr]->op2.stval), 
 					isnil);
			}
			snprintf(buf, BUFSIZ, 
				"null constraint %s.%s failed", 
				c->t->base.name, c->base.name ); 
			s = stmt_exception( s, buf, 00001); 
			
			list_prepend(l, s);
		}
	}
	sql_subaggr_destroy( cnt );
	return stmt_list(l);
}

static stmt *update_table(mvc * sql, dlist * qname,
			dlist * assignmentlist, symbol * opt_where)
{
	stmt *s = NULL;
	char *tname = qname_table(qname);
	sql_table *t = mvc_bind_table(sql, cur_schema(sql), tname);

	if (!t) {
		return sql_error(sql, 02, "Updating non existing table %s", tname);
	} else {
		int len = 0, i = 0;
		tvar *tv = NULL;
		dnode *n;
		list *l;
		scope *scp;
		stmt **updates;

		scp = scope_open(NULL);
		tv = scope_add_table_columns(sql, scp, t, t->base.name);

		if (opt_where){
			s = sql_logical_exp(sql, scp, opt_where, NULL, NULL);
			if (s) 
				s = stmt2pivot(scp,s);
			if (!s){
				scope_close(scp);
			       	return NULL;
			}
		} else { /* update all */
			cvar *c = tv->columns->h->data;
			s = stmt2pivot(scp,stmt_dup(c->s));
		}
	       	l = create_stmt_list();

		len = list_length(t->columns.set);
		updates = NEW_ARRAY(stmt *, len);
		for (i = 0; i < len; i++)
			updates[i] = NULL;

		for( n = assignmentlist->h, i=0; n; n = n->next, i++ ){
			symbol *a = NULL;
			stmt *v = NULL;
			dlist *assignment = n->data.sym->data.lval;
			char *cname = assignment->h->data.sval;
			cvar *cl = scope_bind_column(scp, NULL, cname);
			sql_column *c = NULL;

			if (!cl) {
				stmt_destroy(s);
				list_destroy(l);
				cleanup_stmts(updates, len);
				return sql_error(sql, 02, 
				  "Updating non existing column %s.%s",
					 tname, assignment->h->data.sval);
			}
			a = assignment->h->next->data.sym;
			if (a)
				v = sql_value_exp(sql, scp, a, NULL, s);
			else 
				v = stmt_atom(atom_general(
					sql_dup_subtype(tail_type(cl->s)), 
					NULL));

			if (!v || 
		           (v = check_types(sql, tail_type(cl->s), v)) == NULL){
				stmt_destroy(s);
				list_destroy(l);
				cleanup_stmts(updates, len);
				return NULL;
			}

			if (v->nrcols <= 0){
				v = stmt_const(
				  stmt_reverse(s ? first_subset(s) : stmt_dup(cl->s)), v);
			}

			c = basecolumn(cl->s);
			updates[c->colnr] = stmt_replace( stmt_cbat(c, stmt_dup(tv->s), UPD, st_bat), v);
			list_append(l, stmt_dup(updates[c->colnr]) );
			if (t->base.flag != TR_NEW) {
				list_append(l, stmt_insert( 
					stmt_cbat(c, 
					          stmt_dup(tv->s), 
						  UPD, st_ubat), stmt_dup(v)));
			}
			/* TODO rows = count(stmt_dup(v)) */
		}
		if (s) stmt_destroy(s);
	
		if ((s = sql_update( sql, t, updates, l)) == NULL){
			list_destroy(l);
			cleanup_stmts(updates, len);
			return NULL;
		}
		scp = scope_close(scp);
		cleanup_stmts(updates, len);
		return s;
	}
	return NULL;
}

static int
sql_delete_idxs(mvc * sql, sql_table *t, stmt *vals, list *l)
{
	node *n;
	int res = 1;

	(void)sql; /* unused!? */

	for(n = t->idxs.set->h; n; n = n->next){
		sql_idx *i = n->data;
		sql_subtype *it = NULL;
		stmt *v = NULL;

		if (i->type == unique && list_length(i->columns) <= 1)
			continue;
		
		if (i->type == unique) {
			it = sql_bind_localtype( "int" );
		} else if (i->type == join_idx){
			it = sql_bind_localtype( "oid" );
		}

		assert(it);
		v = stmt_const( stmt_reverse( first_subset(vals)), 
			stmt_atom(atom_general(sql_dup_subtype(it), NULL)));
		list_append(l, stmt_replace( stmt_idxbat(i, 1), v));
	}
	return res;
}


stmt *
sql_delete( mvc *sql, tvar *tv, sql_table *t, stmt *s )
{
	node *n;
	list *l = create_stmt_list();
	sql_subtype *to	= sql_bind_subtype("OID", 0, 0);
	stmt *v = stmt_const( stmt_reverse(first_subset(s)), 
				stmt_atom(atom_general(to, NULL)));

	list_append(l, stmt_append(
			stmt_tbat(basetable_table(tv->s), INS ),
			stmt_reverse(v)));
	for(n = t->columns.set->h; n; n = n->next){
		sql_column *c = n->data;
		stmt *v = stmt_const( stmt_reverse( first_subset(s)), 
			stmt_atom(atom_general(sql_dup_subtype(c->type), NULL)));
		list_append(l, stmt_replace( stmt_cbat(c, stmt_dup(tv->s), DEL, st_bat), v));
	}
	/* TODO rows = count(stmt_dup(v)) */

	if (t->idxs.set && !sql_delete_idxs(sql, t, s, l )){
		list_destroy(l);
		return sql_error(sql, 02, 
			"Deleting from indexes failed for table %s",
			t->base.name);
	}
	stmt_destroy(s);
	return stmt_list(l);
}

static stmt *delete_table(mvc * sql, dlist * qname, symbol * opt_where)
{
	char *tname = qname_table(qname);
	sql_table *t = mvc_bind_table(sql, cur_schema(sql), tname);

	if (!t) {
		return sql_error(sql, 02, 
			 "Deleting from non existing table %s", tname);
	}
	if (!table_privs(sql, t, PRIV_DELETE)){
		return sql_error(sql, 02, 
			"User is not allowed to delete from table %s", tname);
	} else {
		tvar *tv = NULL;
		stmt  *s = NULL;
		scope *scp = scope_open(NULL);

		tv = scope_add_table_columns(sql, scp, t, t->base.name);

		if (opt_where){
			s = sql_logical_exp(sql, scp, opt_where, NULL, NULL);
			if (s) 
				s = stmt2pivot(scp,s);
			if (!s){
				scope_close(scp);
			       	return NULL;
			}
		} else { /* delete all */
			cvar *c = tv->columns->h->data;
			s = stmt2pivot(scp,stmt_dup(c->s));
		}

		assert (isbasetable(tv->s));
		s = sql_delete(sql, tv, t, s);

		scp = scope_close(scp);
		return s;
	}
	return NULL;
}


static stmt *sql_stmt(mvc * sql, symbol * s)
{
	stmt *ret = NULL;
	switch (s->token) {

	case TR_COMMIT: case TR_SAVEPOINT: 
	case TR_RELEASE: case TR_ROLLBACK:
	case TR_START: case TR_MODE:
		return transaction(sql, s);

	case SQL_CREATE_SCHEMA: case SQL_DROP_SCHEMA:
	case SQL_CREATE_TABLE: case SQL_DROP_TABLE: 
	case SQL_ALTER_TABLE:
	case SQL_CREATE_VIEW: case SQL_DROP_VIEW:
	case SQL_CREATE_INDEX: case SQL_DROP_INDEX:
	case SQL_CREATE_USER: case SQL_DROP_USER:
	case SQL_CREATE_ROLE: case SQL_DROP_ROLE:
	case SQL_GRANT_ROLES:
	case SQL_GRANT: case SQL_REVOKE:
	case SQL_CREATE_MODULE: case SQL_DROP_MODULE:
	case SQL_CREATE_TYPE:
	case SQL_CREATE_FUNC:
		return schema(sql, s);
	
	case SQL_COPYFROM:
		{
			dlist *l = s->data.lval;
			ret = copyfrom(sql, l->h->data.lval,
				       l->h->next->data.lval,
				       l->h->next->next->data.lval,
				       l->h->next->next->next->data.ival);
			sql->type = Q_UPDATE;
		}
		break;
	case SQL_INSERT:
		{
			dlist *l = s->data.lval;
			ret = insert_into(sql,
					  l->h->data.lval,
					  l->h->next->data.lval,
					  l->h->next->next->data.sym);
			sql->type = Q_UPDATE;
		}
		break;
	case SQL_UPDATE:
		{
			dlist *l = s->data.lval;
			ret = update_table(sql,
					 l->h->data.lval,
					 l->h->next->data.lval,
					 l->h->next->next->data.sym);
			sql->type = Q_UPDATE;
		}
		break;
	case SQL_DELETE:
		{
			dlist *l = s->data.lval;
			ret = delete_table(sql, 
					 l->h->data.lval,
					 l->h->next->data.sym);
			sql->type = Q_UPDATE;
		}
		break;
	case SQL_SELECT:
		ret = sql_subquery(sql, NULL, s);
		/* add output stmt */
		if (ret) 
			ret = stmt_output(ret);
		sql->type = Q_TABLE;
		break;
	case SQL_JOIN:
		ret = sql_join(sql, NULL, s);
		/* add output stmt */
		if (ret) 
			ret = stmt_output(ret);
		sql->type = Q_TABLE;
		break;
	case SQL_CROSS:
		ret = sql_cross(sql, NULL, s);
		/* add output stmt */
		if (ret) 
			ret = stmt_output(ret);
		sql->type = Q_TABLE;
		break;
	case SQL_UNION:
		ret = sql_union(sql, NULL, s);
		/* add output stmt */
		if (ret) 
			ret = stmt_output(ret);
		sql->type = Q_TABLE;
		break;
	case SQL_EXCEPT:
		ret = sql_union(sql, NULL, s);
		/* add output stmt */
		if (ret) 
			ret = stmt_output(ret);
		sql->type = Q_TABLE;
		break;
	case SQL_INTERSECT:
		ret = sql_union(sql, NULL, s);
		/* add output stmt */
		if (ret) 
			ret = stmt_output(ret);
		sql->type = Q_TABLE;
		break;
	case SQL_SET:
		{
			dlist *l = s->data.lval;
			symbol *val = l->h->next->data.sym;
			scope *scp = scope_open(NULL);
			stmt *v = sql_value_exp( sql, scp, val, NULL, NULL);
			scope_close(scp);
			if (v)
				ret = stmt_assign(_strdup(l->h->data.sval), v);
		}
		break;
	default:
		return sql_error(sql, 01, 
			 "sql_stmt Symbol(%ld)->token = %s",
			 (long) s, token2string(s->token));
	}
	return ret;
}


stmt *semantic(mvc * s, symbol * sym)
{
	stmt *res = NULL;

	if (sym){
		res = sql_stmt(s, sym);
	}
	return res;
}
