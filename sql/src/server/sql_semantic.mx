@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2005 CWI.
@' All Rights Reserved.

@f sql_semantic
@a N.J. Nes
@* 

@h
#ifndef _SQL_SEMANTIC_H_
#define _SQL_SEMANTIC_H_

#include <stdio.h>
#include <stdarg.h>
#include <sql_list.h>
#include "sql_symbol.h"
#include "sql_parser.h"
#include "sql_scope.h"

#define create_string_list() list_create((fdestroy)&GDKfree)

sql_export stmt *semantic(mvc *sql, symbol *sym);

sql_export sql_schema *cur_schema(mvc *sql);
sql_export sql_schema *qname_schema(mvc *sql, dlist *qname);
sql_export char *qname_table(dlist *qname);
sql_export tvar *scope_add_table_columns(mvc *sql, scope *scp, sql_table *t, char *tname);

sql_export sql_subtype *supertype(sql_subtype *r, sql_subtype *i);
sql_export int convert_types(mvc *sql, stmt **L, stmt **R, int scale_fixing);

typedef enum {
	type_equal,
	type_cast,		/* also truncate */
	type_dyncheck		/* if types are equal, check 
				   the digits/scale/overflow dynamicaly */
} check_type;

sql_export stmt *check_types(mvc *sql, sql_subtype *ct, stmt *s, check_type tpe);
sql_export stmt *fix_scale(mvc *sql, sql_subtype *ct, stmt *s, int both, int always);
sql_export stmt *sum_scales(sql_subfunc *f, stmt *ls, stmt *rs);
sql_export stmt *scale_algebra(sql_subfunc *f, stmt *ls, stmt *rs);
sql_export stmt *sqlparse_intern(mvc *m, char *query);
sql_export stmt *scope_sqlparse(mvc *m, scope *scp, char *query);

sql_export stmt *first_subset(stmt *subset);

sql_export void sql_add_arg(mvc *sql, atom *v);	/* used in src/server/sql_parser.y */
sql_export void sql_add_param(mvc *sql, char *name, stmt *s);	/* used in src/server/sql_parser.y */
sql_export stmt *sql_bind_param(mvc *sql, char *name);
sql_export atom *sql_bind_arg(mvc *sql, int nr);

sql_export void sql_destroy_params(mvc *sql);	/* used in backend */
sql_export void sql_destroy_args(mvc *sql);	/* used in backend */

#endif /*_SQL_SEMANTIC_H_*/

@c

#include "sql_parser.h"
#include "sql_symbol.h"
#include "sql_statement.h"
#include "sql_semantic.h"
#include "sql_trans.h"
#include "sql_schema.h"
#include "sql_updates.h"
#include "sql_select.h"
#include "sql_env.h"
#include "sql_sequence.h"
#include "sql_privileges.h"

#include <unistd.h>
#include <stdio.h>
#include <string.h>
#include <ctype.h>

/* 
 * For debugging purposes we need to be able to convert sql-tokens to 
 * a string representation.
 *
 *
 * !SQL ERROR <sqlerrno> : <details>
 * !SQL DEBUG  <details>
 * !SQL WARNING <details>
 * !SQL  <informative message, reserved for ...rows affected>
 *
 * Todo add insert bats used for inserts (ie should change the 
 * 	query code to use the global bats (mvc_bat) in read only mode).
 */

void
sql_add_arg(mvc *sql, atom *v)
{
	if (!sql->args)
		sql->args = list_create((fdestroy) &atom_destroy);
	list_append(sql->args, v);
}

void
sql_add_param(mvc *sql, char *name, stmt *s)
{
	var_ *v = NEW(var_);

	v->name = name;
	v->s = s;
	sql_ref_init(&(v->ref));

	if (!sql->params)
		sql->params = list_create((fdestroy) &var_destroy);
	list_append(sql->params, v);
}

stmt *
sql_bind_param(mvc *sql, char *name)
{
	node *n;

	if (sql->params) {
		for (n = sql->params->h; n; n = n->next) {
			var_ *v = n->data;

			if (strcmp(v->name, name) == 0) {
				return stmt_dup(v->s);
			}
		}
	}
	return NULL;
}

atom *
sql_bind_arg(mvc *sql, int nr)
{
	node *n;

	if (sql->args) {
		for (n = sql->args->h; n && nr; nr--)
			n = n->next;
		if (n)
			return n->data;
	}
	return NULL;
}

void
sql_convert_arg(mvc *sql, int nr, sql_subtype *rt)
{
	atom *a = sql_bind_arg(sql, nr);

	if (atom_null(a)) {
		if (a->data.vtype != rt->type->localtype) {
			a->data.vtype = rt->type->localtype;
			if (ATOMstorage(a->data.vtype) < TYPE_str) {
				ptr p = ATOMnilptr(a->data.vtype);

				VALset(&a->data, a->data.vtype, p);
			} else {
				a->data.val.pval = NULL;
			}
		}
	}
	sql_subtype_destroy(a->tpe);
	a->tpe = sql_dup_subtype(rt);
}

void
sql_destroy_params(mvc *sql)
{
	if (sql->params)
		list_destroy(sql->params);
	sql->params = NULL;
}

void
sql_destroy_args(mvc *sql)
{
	if (sql->args)
		list_destroy(sql->args);
	sql->args = NULL;
}


sql_schema *
cur_schema(mvc *sql)
{
	return sql->trans->schema;
}

sql_schema *
qname_schema(mvc *sql, dlist *qname)
{
	sql_schema *s = cur_schema(sql);

	assert(qname && qname->h);

	if (dlist_length(qname) == 2) {
		char *name = qname->h->data.sval;

		s = mvc_bind_schema(sql, name);
	}
	return s;
}

char *
qname_table(dlist *qname)
{
	assert(qname && qname->h);

	if (dlist_length(qname) == 1) {
		return qname->h->data.sval;
	} else if (dlist_length(qname) == 2) {
		return qname->h->next->data.sval;
	}
	return "Unknown";
}

stmt *
scope_sqlparse(mvc *m, scope *scp, char *query)
{
	mvc o = *m;
	stmt *sq;

	m->qc = NULL;

	m->cache = 0;

	scanner_reset(&m->scanner, query);

	m->params = NULL;
	m->args = NULL;
	m->sym = NULL;
	m->errstr[0] = '\0';
	m->status = 0;

	(void) sqlparse(m);	/* blindly ignore errors */
	sq = sql_subquery(m, scp, m->sym, 1);

	symbol_destroy(m->sym);
	if (m->status || m->errstr[0]) {
		int status = m->status;
		char errstr[ERRSIZE];

		strcpy(errstr, m->errstr);
		*m = o;
		m->status = status;
		strcpy(m->errstr, errstr);
	} else {
		*m = o;
	}
	return sq;
}

stmt *
sqlparse_intern(mvc *m, char *query)
{
	mvc o = *m;
	stmt *sq;

	m->qc = NULL;

	m->cache = 0;

	scanner_reset(&m->scanner, query);

	m->params = NULL;
	m->args = NULL;
	m->sym = NULL;
	m->errstr[0] = '\0';
	m->status = 0;
	/* via views we give access to protected objects */
	m->user_id = USER_MONETDB;

	(void) sqlparse(m);	/* blindly ignore errors */
	sq = scope_subquery(m, NULL, m->sym);

	symbol_destroy(m->sym);
	if (m->status || m->errstr[0]) {
		int status = m->status;
		char errstr[ERRSIZE];

		strcpy(errstr, m->errstr);
		*m = o;
		m->status = status;
		strcpy(m->errstr, errstr);
	} else {
		*m = o;
	}
	return sq;
}

tvar *
scope_add_table_columns(mvc *sql, scope *scp, sql_table *t, char *tname)
{
	node *n, *m;
	tvar *tv = NULL;

	if (!t->table && t->query) {

		stmt *sq = sqlparse_intern(sql, t->query);

		if (!sq)
			return NULL;
		tv = scope_add_table(scp, sq, tname, NULL);
		for (n = t->columns.set->h, m = sq->op1.lval->h; n && m; n = n->next, m = m->next) {
			sql_column *c = n->data;
			stmt *sc = stmt_dup(m->data);

			sc = stmt_alias(sc, _strdup(tname), _strdup(c->base.name));
			sc = stmt_column(sc, stmt_dup(sq));
			table_add_column(tv, sc, NULL, c->base.name);
		}
	} else {
		stmt *ts;

		tv = scope_add_table(scp, ts = stmt_basetable(t, tname), tname, t);
		for (n = t->columns.set->h; n; n = n->next) {
			sql_column *c = n->data;
			stmt *sc = stmt_cbat(c, stmt_dup(ts), RDONLY, st_bat);

			table_add_column(tv, sc, NULL, c->base.name);
		}
	}
	return tv;
}

static lng
scale2value(int scale)
{
	lng val = 1;

	if (scale < 0)
		scale = -scale;
	for (; scale; scale--) {
		val = val * 10;
	}
	return val;
}

stmt *
sum_scales(sql_subfunc *f, stmt *ls, stmt *rs)
{
	if (strcmp(f->func->imp, "*") == 0 && f->func->res->type->scale == SCALE_FIX) {
		sql_subtype fres = *f->res;

		f->res->scale = tail_type(ls)->scale + tail_type(rs)->scale;
		f->res->digits = tail_type(ls)->digits + tail_type(rs)->digits;
		/* HACK alert: digits should be less then max */
		if (f->res->type->radix == 10 && f->res->digits > 19)
			f->res->digits = 19;
		if (f->res->type->radix == 2 && f->res->digits > 53)
			f->res->digits = 53;
		/* sum of digits may mean we need a bigger result type 
		 * as the function don't support this we need to
		 * make bigger input types!
		 */
		if (f) {
			sql_subtype *t = NULL;

			/* numeric types are fixed length */
			if (f->res->type->fixed) {
				t = sql_bind_numeric(f->res->type->localtype, f->res->digits);
			} else {
				t = sql_bind_subtype(f->res->type->sqlname, f->res->digits, f->res->scale);
			}
			if (subtype_cmp(t, &fres) != 0) {
				sql_subtype *fr = f->res;
				sql_subfunc *c = NULL;

				f->res = t;
				c = sql_bind_func_result("convert", f->res, NULL, t);
				if (c)
					ls = stmt_unop(ls, c);
				t = fr;
			}
			sql_subtype_destroy(t);
		}
	}
	return ls;
}

stmt *
scale_algebra(sql_subfunc *f, stmt *ls, stmt *rs)
{
	sql_subtype *lt = tail_type(ls);
	sql_subtype *rt = tail_type(rs);

	/*
	 * Decimals are mapped on plain integers. This has impact on the
	 * implemantion of division. First the 'dividend' should be large 
	 * enough to prevent rounding errors. This is solved by a 
	 * multiplication with the 'scale' of the divisor.
	 * Second the result type of the division should be equal to the 
	 * 'dividend', with the maximum scale of the dividend and divisor.
	 *
	 * Example      1.0/0.1 mapped (int 1 dec(1,0) and int 1 dec(2,1))
	 *                              1 * 10 = 10 (scale of divisor)
	 *                              10/1 = 1 dec(1)
	 */

	if (lt->type->scale == SCALE_FIX && rt->scale) {
		sql_subfunc *c = NULL;
		int digits = rt->scale + lt->digits;
		int scale = MAX(lt->scale, rt->scale);
		int d = 0;

		/* scale fixing may require a larger type ! */
		sql_subtype *it = sql_bind_subtype(lt->type->sqlname, digits, scale);

		if (scale > lt->scale)
			d = (scale - lt->scale);
		f->res->digits = lt->digits;
		f->res->scale = scale;

		if (strcmp(f->func->imp, "/") == 0) {
			c = sql_bind_func("scale_up", lt, it);
			if (!c) {
				c = sql_bind_func_result("convert", lt, NULL, it);
				if (c) {
					ls = stmt_unop(ls, c);
					lt = tail_type(ls);
					c = sql_bind_func("scale_up", lt, it);
				}
			}
		}
		if (c) {
			lng val = scale2value(rt->scale + d);
			atom *a = atom_int(sql_dup_subtype(it), val);

			ls = stmt_binop(ls, stmt_atom(a), c);
		}
		sql_subtype_destroy(it);
	}
	return ls;
}

stmt *
fix_scale(mvc *sql, sql_subtype *ct, stmt *s, int both, int always)
{
	sql_subtype *st = tail_type(s);

	(void) sql;		/* Stefan: unused!? */

	if (ct->type->scale == SCALE_FIX && st->type->scale == SCALE_FIX) {
		int scale_diff = ((int) ct->scale - (int) st->scale);

		if (scale_diff) {
			sql_subtype *it = sql_bind_localtype(st->type->base.name);
			sql_subfunc *c = NULL;

			if (scale_diff < 0) {
				if (!both)
					return s;
				c = sql_bind_func("scale_down", st, it);
			} else {
				c = sql_bind_func("scale_up", st, it);
			}
			if (c) {
				lng val = scale2value(scale_diff);
				atom *a = atom_int(sql_dup_subtype(it), val);

				c->res->scale = (st->scale + scale_diff);
				return stmt_binop(s, stmt_atom(a), c);
			}
		}
	} else if (always && st->scale) {	/* scale down */
		int scale_diff = -(int) st->scale;
		sql_subtype *it = sql_bind_localtype(st->type->base.name);
		sql_subfunc *c = sql_bind_func("scale_down", st, it);

		if (c) {
			lng val = scale2value(scale_diff);
			atom *a = atom_int(sql_dup_subtype(it), val);

			c->res->scale = 0;
			return stmt_binop(s, stmt_atom(a), c);
		} else {
			printf("scale_down mising (%s)\n", st->type->base.name);
		}
	}
	return s;
}

/* try to do an inplace convertion 
 * 
 * inplace conversion is only possible if the s 
 */
stmt *
inplace_convert(mvc *sql, sql_subtype *ct, stmt *s)
{
	sql_subtype *st = tail_type(s);

	if (s->type != st_var || s->ref.refcnt > 1 || ct->scale)
		return s;

	if (ct->digits == 0 || (ct->digits > 0 && st->digits < ct->digits)) {
		stmt *r = s;

		if (ct->type->localtype == st->type->localtype) {
			if (ct->type->localtype == TYPE_lng || ct->type->localtype == TYPE_int || ct->type->localtype == TYPE_sht) {
				r = stmt_varnr(s->flag, sql_dup_subtype(ct));
				sql_convert_arg(sql, s->flag, ct);
			} else if (ct->type->localtype == TYPE_str) {
				sql_subtype *nt = sql_create_subtype(st->type, ct->digits, ct->scale);

				r = stmt_varnr(s->flag, nt);
				sql_convert_arg(sql, s->flag, nt);
			}
		} else if (st->type->localtype == TYPE_str) {
			atom *a = sql_bind_arg(sql, s->flag);

			if (atom_null(a)) {
				r = stmt_varnr(s->flag, sql_dup_subtype(ct));
				sql_convert_arg(sql, s->flag, ct);
			}
		}
		if (r != s)
			stmt_destroy(s);
		return r;
	}
	return s;
}

static stmt *
sql_truncate(sql_subtype *ct, stmt *s)
{
	sql_subtype *st = tail_type(s);
	sql_subtype *it = sql_bind_localtype("lng");
	sql_subfunc *c = NULL;

	/* atleast we need equal base types */
	if (type_cmp(st->type, ct->type) != 0) {
		stmt_destroy(s);
		return NULL;
	}
	c = sql_bind_func("truncate", st, it);
	if (!c)			/* no truncate function, ie no need to truncate */
		return s;
	return stmt_binop(s, stmt_atom_int(ct->digits), c);
}

stmt *
dyncheck_types(mvc *sql, sql_subtype *ct, stmt *s)
{
	sql_subtype *t = NULL, *st = tail_type(s);

	/* check if the types are the same */
	t = st;
	if (t && subtype_cmp(t, ct) != 0) {
		t = NULL;
	}

	if (!t) {		/* try to convert if needed */
		sql_subtype *it = sql_bind_localtype("lng");
		sql_subfunc *c;

		c = sql_bind_func_result("convert", st, it, ct);
		if (c)
			return fix_scale(sql, ct, stmt_binop(s, stmt_atom_int(ct->digits), c), 1, (st->type->scale == SCALE_FIX));
	}
	if (!t || subtype_cmp(t, ct) != 0) {
		stmt *res = sql_error(sql, 02, "Types %s(%d,%d) (%s) and %s(%d,%d) (%s) are not equal", st->type->sqlname, st->digits, st->scale, st->type->base.name, ct->type->sqlname, ct->digits, ct->scale, ct->type->base.name);

		if (s)
			stmt_destroy(s);
		return res;
	}
	if (st) {
		if ((ct->digits > 0 && ct->scale == 0 && ct->digits < st->digits) || (ct->scale > 0 && ct->digits > 0 && ct->digits - ct->scale < st->digits - st->scale)
		    ) {
			stmt *res = NULL;
			sql_subtype *it = sql_bind_localtype("lng");
			sql_subfunc *c;

			c = sql_bind_func_result("convert", st, it, ct);
			if (c)
				return fix_scale(sql, ct, stmt_binop(s, stmt_atom_int(ct->digits), c), 1, 0);

			res = sql_error(sql, 03, "Dynamic types %s(%d,%d) (%s) and %s(%d,%d) (%s) are not equal", st->type->sqlname, st->digits, st->scale, st->type->base.name, ct->type->sqlname, ct->digits, ct->scale, ct->type->base.name);
			if (s)
				stmt_destroy(s);
			return res;
		}
	}
	return fix_scale(sql, ct, s, 1, 0);
}

/* check_types tries to match the ct type with the type of s if they don't
 * match s is converted. Returns NULL on failure.
 */
stmt *
check_types(mvc *sql, sql_subtype *ct, stmt *s, check_type tpe)
{
	sql_subtype *t = NULL, *st = tail_type(s);

	if (!st) {
		assert(0);
		stmt_destroy(s);
		return sql_error(sql, 02, "Statement has no type information");
	}

	/* first try cheap internal (inplace) convertions ! */
	s = inplace_convert(sql, ct, s);
	t = st = tail_type(s);

	/* check if the types are the same */
	if (t && subtype_cmp(t, ct) != 0) {
		t = NULL;
	}

	if (!t) {		/* try to convert if needed */
		sql_subfunc *c = sql_bind_func_result("convert", st, NULL, ct);

		if (c)
			s = stmt_unop(s, c);

		/* here we need to check if we could convert using
		   the more complex conversion functions 
		   (convert(x,int) -> y)
		 */
		if (!c && ct->scale == 0 && st->scale == 0) {
			sql_subtype *it = sql_bind_localtype("int");
			sql_subfunc *c = sql_bind_func_result("convert", st, it, ct);

			if (c)
				s = stmt_binop(s, stmt_atom_int(ct->digits), c);
		}

		/* here we need to check if we could convert using
		   the more complex conversion functions 
		   (convert(x,int,int) -> y)
		 */
		if (!c && st->scale == 0) {
			sql_subtype *it = sql_bind_localtype("int");
			list *ops = list_create((fdestroy) NULL);

			list_append(ops, st);
			list_append(ops, it);
			list_append(ops, it);
			c = sql_bind_func_result_("convert", ops, ct);
			list_destroy(ops);
			if (c) {
				ops = create_stmt_list();
				list_append(ops, s);
				list_append(ops, stmt_atom_int(ct->digits));
				list_append(ops, stmt_atom_int(ct->scale));
				return stmt_Nop(stmt_list(ops), c);
			}
		}

		t = tail_type(s);
	}
	if (!t || subtype_cmp(t, ct) != 0) {
		stmt *res = sql_error(sql, 02, "Types %s(%d,%d) (%s) and %s(%d,%d) (%s) are not equal", st->type->sqlname, st->digits, st->scale, st->type->base.name, ct->type->sqlname, ct->digits, ct->scale, ct->type->base.name);

		stmt_destroy(s);
		return res;
	}
	if (st) {
		/* types are equal, but the digits and scale 
		   still need to be checked 
		 */
		int sc = (ct->type->scale == SCALE_FIX);

		if ((ct->digits > 0 && ct->scale == 0 && ct->digits < st->digits) || (sc && ct->scale > 0 && ct->digits > 0 && ct->digits - ct->scale < st->digits - st->scale)
		    ) {
			stmt *res = NULL;

			if (tpe == type_dyncheck) {
				s = dyncheck_types(sql, ct, s);
				if (s)
					return fix_scale(sql, ct, s, 1, (st->type->scale == SCALE_FIX));
			}
			if (tpe == type_cast) {
				s = sql_truncate(ct, s);
				if (s)
					return fix_scale(sql, ct, s, 1, (st->type->scale == SCALE_FIX));
			}
			if (s) {
				res = sql_error(sql, 03, "Types %s(%d,%d) (%s) and %s(%d,%d) (%s) are not equal", st->type->sqlname, st->digits, st->scale, st->type->base.name, ct->type->sqlname, ct->digits, ct->scale, ct->type->base.name);
				stmt_destroy(s);
			}
			return res;
		}
	}
	if (!s)
		return NULL;
	return fix_scale(sql, ct, s, 1, (st->type->scale == SCALE_FIX));
}


sql_subtype *
supertype(sql_subtype *r, sql_subtype *i)
{
	/* first find super type */
	char *tpe = r->type->sqlname;
	int digits = 0;
	unsigned int scale = sql_max(i->scale, r->scale);

	if (i->type->base.id >r->type->base.id)
		tpe = i->type->sqlname;
	if (i->digits && r->digits) {
		if (i->digits > r->digits) {
			digits = i->digits;
			if (i->scale < scale)
				digits += scale - i->scale;
		} else if (i->digits < r->digits) {
			digits = r->digits;
			if (r->scale < scale)
				digits += scale - r->scale;
		} else {
			/* same number of digits */
			digits = i->digits;
			if (i->scale < r->scale)
				digits += r->scale - i->scale;
			else
				digits += i->scale - r->scale;
		}
	}

	return sql_bind_subtype(tpe, digits, scale);
}

int
set_type_param(stmt *s, stmt *param)
{
	sql_subtype *type = tail_type(s);

	if (!s || !param || param->type != st_var)
		return -1;

	param->op2.typeval = sql_dup_subtype(type);
	return 0;
}

/* convert_types convert both the stmt's L and R such that they get
 * matching types. On failure <0 is returned;
 */
int
convert_types(mvc *sql, stmt **L, stmt **R, int scale_fixing)
{
	stmt *ls = *L;
	stmt *rs = *R;
	sql_subtype *lt = tail_type(ls);
	sql_subtype *rt = tail_type(rs);

	if (rt && !lt)
		return set_type_param(rs, ls);

	if (!rt && lt)
		return set_type_param(ls, rs);

	if (rt && lt) {
		sql_subtype *i = lt;
		sql_subtype *r = rt;

		if (subtype_cmp(lt, rt) != 0) {
			sql_subtype *super = supertype(r, i);

			if (scale_fixing) {
				/* convert ls to super type */
				ls = check_types(sql, super, ls, type_equal);
				/* convert rs to super type */
				rs = check_types(sql, super, rs, type_equal);
			} else {
				/* convert ls to super type */
				super->scale = lt->scale;
				ls = check_types(sql, super, ls, type_equal);
				/* convert rs to super type */
				super->scale = rt->scale;
				rs = check_types(sql, super, rs, type_equal);
			}
			sql_subtype_destroy(super);
		} else if (scale_fixing) {
			ls = fix_scale(sql, r, ls, 0, 0);
			rs = fix_scale(sql, i, rs, 0, 0);
		}
		*L = ls;
		*R = rs;
		if (!ls || !rs) {
			return -1;
		}
		return 0;
	}
	return -1;
}

stmt *
first_subset(stmt *subset)
{
	node *n;

	assert(subset->type == st_ptable);

	n = ptable_pivots(subset)->h;
	if (n)
		return stmt_dup(n->data);
	return NULL;
}



stmt *
semantic(mvc *sql, symbol *s)
{
	stmt *res = NULL;

	if (!s)
		return NULL;

	switch (s->token) {

	case TR_COMMIT:
	case TR_SAVEPOINT:
	case TR_RELEASE:
	case TR_ROLLBACK:
	case TR_START:
	case TR_MODE:
		return transactions(sql, s);

	case SQL_CREATE_SCHEMA:
	case SQL_DROP_SCHEMA:
	case SQL_CREATE_TABLE:
	case SQL_DROP_TABLE:
	case SQL_ALTER_TABLE:
	case SQL_CREATE_VIEW:
	case SQL_DROP_VIEW:
	case SQL_CREATE_INDEX:
	case SQL_DROP_INDEX:
	case SQL_CREATE_USER:
	case SQL_DROP_USER:
	case SQL_ALTER_USER:
	case SQL_CREATE_ROLE:
	case SQL_DROP_ROLE:
	case SQL_GRANT_ROLES:
	case SQL_GRANT:
	case SQL_REVOKE:
	case SQL_CREATE_MODULE:
	case SQL_DROP_MODULE:
	case SQL_CREATE_TYPE:
	case SQL_CREATE_FUNC:
		return schemas(sql, s);

	case SQL_CREATE_SEQ:
	case SQL_DROP_SEQ:
		return sequences(sql, s);

	case SQL_COPYFROM:
	case SQL_INSERT:
	case SQL_UPDATE:
	case SQL_DELETE:
		return updates(sql, s);

	case SQL_DECLARE:
	case SQL_SET:
		return env(sql, s);

	case SQL_SELECT:
	case SQL_JOIN:
	case SQL_CROSS:
	case SQL_UNION:
	case SQL_EXCEPT:
	case SQL_INTERSECT:
		return selects(sql, s);

	case SQL_PREP:
	{
		dnode *d;
		list *l = create_stmt_list();

		for (d = s->data.lval->h; d; d = d->next) {
			symbol *sym = d->data.sym;
			stmt *st = semantic(sql, sym);

			if (!st) {
				list_destroy(l);
				return NULL;
			}
			list_append(l, st);
		}
		return stmt_list(l);
	}

	default:
		return sql_error(sql, 01, "sql_stmt Symbol(%ld)->token = %s", (long) s, token2string(s->token));
	}
	return res;
}
