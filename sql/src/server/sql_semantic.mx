@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@' 
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@' 
@' The Original Code is the Monet Database System.
@' 
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2004 CWI.
@' All Rights Reserved.
@' 
@' Contributor(s):
@' 		Martin Kersten <Martin.Kersten@cwi.nl>
@' 		Peter Boncz <Peter.Boncz@cwi.nl>
@' 		Niels Nes <Niels.Nes@cwi.nl>
@' 		Stefan Manegold  <Stefan.Manegold@cwi.nl>

@f sql_semantic
@a N.J. Nes
@* 

@h
#ifndef _SQL_SEMANTIC_H_
#define _SQL_SEMANTIC_H_

#include <stdio.h>
#include <stdarg.h>
#include <sql_list.h>
#include "sql_symbol.h"
#include "sql_context.h"
#include "sql_parser.h"

sql_export stmt *semantic( mvc * sql, symbol * sym);
sql_export void sql_add_arg( mvc *sql, atom *v );		/* used in src/server/sql_parser.y */
sql_export void sql_add_param( mvc *sql, char *name, stmt *s );	/* used in src/server/sql_parser.y */
sql_export void sql_destroy_params( mvc *sql );			/* used in src/server/sql_context.c */
sql_export void sql_destroy_args( mvc *sql );			/* used in src/server/sql_context.c */

#endif /*_SQL_SEMANTIC_H_*/

@c

#include "sql_parser.h"
#include "sql_symbol.h"
#include "sql_statement.h"
#include "sql_scope.h"
#include "sql_semantic.h"
#include "sql_privileges.h"

#include <unistd.h>
#include <stdio.h>
#include <string.h>
#include <ctype.h>

#define create_string_list() list_create((fdestroy)&GDKfree)

/* 
 * For debugging purposes we need to be able to convert sql-tokens to 
 * a string representation.
 *
 *
 * !SQL ERROR <sqlerrno> : <details>
 * !SQL DEBUG  <details>
 * !SQL WARNING <details>
 * !SQL  <informative message, reserved for ...rows affected>
 *
 * Todo add insert bats used for inserts (ie should change the 
 * 	query code to use the global bats (mvc_bat) in read only mode).
 */

void sql_add_arg( mvc *sql, atom *v )
{
	if (!sql->args)
		sql->args = list_create((fdestroy)&atom_destroy);
	list_append(sql->args, v);
}

void sql_add_param( mvc *sql, char *name, stmt *s )
{
	var_ *v = NEW(var_);

	v->name = name;
	v->s = s;
	sql_ref_init( &(v->ref) );

	if (!sql->params)
		sql->params = list_create((fdestroy)&var_destroy);
	list_append(sql->params, v);
}

stmt *sql_bind_param( mvc *sql, char *name )
{
	node *n;
	if (sql->params){
		for(n = sql->params->h; n; n = n->next)
		{
			var_ *v = n->data;
			if (strcmp(v->name, name) == 0){
				return stmt_dup(v->s);
			}
		}
	}
	return NULL;
}

void sql_destroy_params( mvc *sql )
{
	if (sql->params)
		list_destroy(sql->params);
	sql->params = NULL;
}

void sql_destroy_args( mvc *sql )
{
	if (sql->args)
		list_destroy(sql->args);
	sql->args = NULL;
}


static stmt *sql_select(mvc * sql, scope * scp, SelectNode *sn, int toplevel );
static stmt *sql_simple_select(mvc * sql, scope * scp, dlist * selection);
static stmt *sql_logical_exp(mvc * sql, scope * scp, symbol * sc, group * grp, stmt * subset);
static stmt *sql_value_exp(mvc * sql, scope * scp, symbol * se, group * grp, stmt * subset);
static stmt *sql_compare_exp( mvc *sql, scope *scp, group *grp, stmt *subset, symbol *lo, symbol *ro, char *compare_op );

static tvar *query_exp_optname(mvc * sql, scope * scp, symbol * q);
static tvar *sql_subquery_optname(mvc * sql, scope * scp, symbol * query);
static stmt *sql_subquery(mvc * sql, scope * scp, symbol * sq);

static sql_schema *cur_schema( mvc *sql )
{
	return sql->trans->schema;
}

static void sql_select_cleanup( mvc * sql, stmt *s, stmt *subset, group *grp )
{
	(void) sql; /* Stefan: unused!? */

	if (grp)
		grp_destroy(grp);
	if (subset)
		stmt_destroy(subset);
	if (s)
		stmt_destroy(s);
}

static sql_schema *qname_schema(mvc *sql, dlist * qname)
{
	sql_schema *s = cur_schema(sql);
	assert(qname && qname->h);

	if (dlist_length(qname) == 2) {
		char *name = qname->h->data.sval;
		s = mvc_bind_schema(sql, name);
	}
	return s;
}

static char *qname_table(dlist * qname)
{
	assert(qname && qname->h);

	if (dlist_length(qname) == 1) {
		return qname->h->data.sval;
	} else if (dlist_length(qname) == 2) {
		return qname->h->next->data.sval;
	}
	return "Unknown";
}

static stmt *
sqlparse_intern(mvc *m, char *query) 
{
	mvc o = *m;
	stmt *sq;

	m->qc = NULL;
	m->cache = 0;
	m->scanner.buf = query;
	m->scanner.cur = ' ';
	m->scanner.key = 0;
	m->scanner.sql = NEW_ARRAY(char, BUFSIZ);
	m->scanner.sqlsize = BUFSIZ;
	m->scanner.sql[0] = '\0';

	m->params = NULL;
	m->args = NULL;
	m->sym = NULL;

	(void)sqlparse(m); /* blindly ignore errors */
	sq = sql_subquery(m, NULL, m->sym);

	symbol_destroy(m->sym);
	_DELETE(m->scanner.sql);
	*m = o;
	return sq;
}

static tvar *scope_add_table_columns(mvc * sql, scope * scp, sql_table * t, char *tname)
{
	node *n, *m;
	tvar *tv = NULL;

	if (t->type == tt_view){

		if (!t->st){
			stmt *sq = sqlparse_intern(sql, t->query);

			t -> st = sq;
			for ( n = t->columns.set->h, m = sq->op1.lval->h;
					n && m; n = n->next, m = m->next) {
				sql_column *c = n->data;
				stmt *sc = stmt_dup(m->data);

				sc = stmt_alias(sc, c->base.name);
				c->st = stmt_ibat(sc, stmt_dup(sq));
			}
		}
		tv = scope_add_table(scp, stmt_dup(t->st), tname);
		for ( n = t->columns.set->h; n; n = n->next) {
			sql_column *c = n->data;
			stmt *sc = stmt_dup(c->st);
			table_add_column(tv, sc, NULL, c->base.name);
		}
	} else {
		stmt *ts;

		tv = scope_add_table(scp, ts = stmt_basetable(t), tname);
		for ( n = t->columns.set->h; n; n = n->next) {
			sql_column *c = n->data;
			stmt *sc = stmt_cbat(c, stmt_dup(ts), RDONLY, st_bat);
			table_add_column(tv, sc, NULL, c->base.name);
		}
	}
	return tv;
}

static tvar *table_ref(mvc * sql, scope * scp, symbol * tableref)
{
	char *tname = NULL;
	sql_table *t = NULL;

	/* todo handle opt_table_ref 
	   (ie tableref->data.lval->h->next->data.sym */

	if (tableref->token == SQL_NAME) {
		sql_schema *s = qname_schema(sql, tableref->data.lval->h->data.lval);
		tname = qname_table(tableref->data.lval->h->data.lval);
				
		if (!s){
			(void) sql_error( sql, 02, "Unknown schema");
			return NULL;
		}
		t = mvc_bind_table(sql, s, tname);
		if (!t) {
			(void) sql_error( sql, 02, "Unknown table %s", tname);
			return NULL;
		}
		if (tableref->data.lval->h->next->data.sym) {	/* AS */
			tname = tableref->data.lval->h->next->data.sym->data.lval->h->data.sval;
		}
		return scope_add_table_columns(sql, scp, t, tname);
	} else if (tableref->token == SQL_TABLE) {
		stmt *s = sql_value_exp(sql, scp, tableref->data.lval->h->data.sym, NULL, NULL);
		char *tname = tableref->data.lval->h->next->data.sym->data.lval->h->data.sval;

		if (!s) 
			return NULL;
		return scope_add_table(scp, s, tname);
	} else if (tableref->token == SQL_SELECT) {
		return sql_subquery_optname(sql, scp, tableref);
	} else {
		return query_exp_optname(sql, scp, tableref);
	}
}

static stmt *sql_subquery(mvc * sql, scope * scp, symbol * sq)
{
	int toplevel = (!scp) ? 1 : 0;
	stmt *res = NULL;
	SelectNode *sn = (SelectNode*)sq;
	assert(sn->s.token == SQL_SELECT);

	if (!toplevel && sn->limit >= 0){
		(void) sql_error( sql, 01, "Can only limit outer select " );
		return NULL;
	}


	if (sn->from) {		/* keep variable list with tables and names */
		dlist *fl = sn->from->data.lval;
		dnode *n = NULL;
		tvar *fnd = (tvar *) 1L; /* 1L to keep 64-bit compilers from complaining *
		                          * about different sizes of int and pointer     */

		if (toplevel)
			scp = scope_open(scp);

		for (n = fl->h; (n && fnd); n = n->next)
			fnd = table_ref(sql, scp, n->data.sym);

		if (!fnd){
			if (toplevel && scp)
				scp = scope_close(scp);
			return NULL;
		}

	} else if (toplevel) {	/* only on top level query */
		scp = scope_open(scp);
		res = sql_simple_select(sql, scp, sn->selection);
		scp = scope_close(scp);
		return res;
	}

	res = sql_select(sql, scp, sn, toplevel );

	if (toplevel && scp)
		scp = scope_close(scp);

	return res;
}

static stmt *scope_subquery(mvc * sql, scope * scp, symbol * sq)
{
	scope *nscp = scope_open(scp);
	stmt *s = sql_subquery(sql, nscp, sq);
	scp = scope_close(nscp);
	return s;
}


/* 
 * Column references, can be done using simple names or aliases and
 * using a combination of table name and column name (or alias).
 * The sql_column_ref finds the column based on the specification from
 * symbol column_r.
 * A special column reference is 'rowid'.
 */

static stmt *sql_column_ref(mvc * sql, scope * scp, symbol * column_r)
{
	stmt *cs = NULL;
	dlist *l = column_r->data.lval;

	assert(column_r->token == SQL_COLUMN
	       && column_r->type == type_list);

	if (dlist_length(l) == 1) {
		char *name = l->h->data.sval;

		if (strcasecmp(name, "rowid") == 0){
			cvar *cv = scope_first_column(scp);
			return stmt_mirror(stmt_dup(cv->s));
		} else if (!(cs = scope_bind(scp, NULL, name))) {
			/* maybe simple param */
			cs = sql_bind_param(sql, name);
			if (!cs)
				return sql_error( sql, 02, 
					"Identifier: %s unknown or ambigious", name);
		}
	} else if (dlist_length(l) == 2) {
		char *tname = l->h->data.sval;
		char *cname = l->h->next->data.sval;

		if (strcasecmp(cname, "rowid") == 0){
			tvar *tv = scope_bind_table(scp, tname);
			cvar *cv;
			if (!tv){
				return sql_error( sql, 02, 
					"Identifier: %s unknown", tname);
			}
			cv = tv->columns->h->data;
			return stmt_mirror(stmt_dup(cv->s));
		} else if (!(cs = scope_bind(scp, tname, cname))) {
			return sql_error( sql, 02, "Column: %s.%s unknown", tname, cname);
		}
	} else if (dlist_length(l) >= 3) {
		return sql_error( sql, 02, "TODO: column names of level >= 3" );
	}
	return cs;
}

static char *tmp_table_name()
{
	oid id = OIDnew(1);
	static char buf[BUFSIZ];
	snprintf(buf, BUFSIZ, "c%ld", id );
	return buf;
}

static sql_table *create_table_intern(mvc * sql, sql_schema * schema,
				  char *name, char *query, stmt * sq, table_type type)
{
	node *m;
	sql_table *table = mvc_create_table(sql, schema, name, type);
	(void) query; /* Stefan: unused!? */

       	for ( m = sq->op1.lval->h; m; m = m->next ) {
		stmt *st = m->data;
		sql_subtype *tp = tail_type(st);
		char *cname = column_name(st);

		(void)mvc_create_column(sql, table, cname, 
			tp->type->sqlname, tp->digits, tp->scale);
		_DELETE(cname);
	}
	return table;
}

static tvar *table_optname(mvc * sql, scope * scp, stmt * sq,
			   char *query, symbol * optname)
{
	node *m;
	char *tmpname = NULL;
	char *tname = NULL;
	dlist *columnrefs = NULL;
	tvar *tv;
	sql_schema *schema = cur_schema(sql);

	if (optname && optname->token == SQL_NAME) {
		tmpname = tname = optname->data.lval->h->data.sval;
		columnrefs = optname->data.lval->h->next->data.lval;
	} else {	
		tmpname = tmp_table_name();
	}
	(void)create_table_intern(sql, schema, tmpname, query, sq, tt_temp);
	tv = scope_add_table(scp, sq, tname);
	if (columnrefs) {
		dnode *d;

		for (m = sq->op1.lval->h, d = columnrefs->h; 
		     d && m; 
		     d = d->next, m = m->next) {
			stmt *st = m->data;
			stmt *sc = stmt_ibat(stmt_dup(st), stmt_dup(sq));

			table_add_column(tv, sc, tname, d->data.sval);
		}
	} else if (tname) {
		/* foreach column add column name */
		for ( m = sq->op1.lval->h; m; m = m->next) {
			stmt *st = m->data;
			char *cname = column_name(st);
			stmt *sc = stmt_ibat(stmt_dup(st), stmt_dup(sq));

			table_add_column(tv, sc, tname, cname);
			_DELETE(cname);
		}
	} else {
		/* foreach column add full basetable,column name */
		for ( m = sq->op1.lval->h; m; m = m->next) {
			stmt *st = m->data;
			char *cname = column_name(st);
			char *tname = table_name(st);
			stmt *sc = stmt_ibat(stmt_dup(st), stmt_dup(sq));

			table_add_column(tv, sc, tname, cname);
			_DELETE(tname);
			_DELETE(cname);
		}
	}
	return tv;
}

static tvar *sql_subquery_optname(mvc * sql, scope * scp,
				  symbol * query)
{
	SelectNode *sn = (SelectNode*)query;
	stmt *sq = sql_subquery(sql, NULL, query);

	if (!sq)
		return NULL;

	return table_optname(sql, scp, sq, sql->scanner.sql, sn->name);
}

static char *schema_name(dlist * name_auth)
{
	assert(name_auth && name_auth->h);

	return name_auth->h->data.sval;
}

static char *schema_auth(dlist * name_auth)
{
	assert(name_auth && name_auth->h && dlist_length(name_auth) == 2);

	return name_auth->h->next->data.sval;
}

static stmt *find_pivot(stmt * subset, stmt * t)
{
	assert(subset->type == st_ptable);

	if (t){
		node *n;
		for (n = ptable_pivots(subset)->h; n; n = n->next) { 
			stmt *s = n->data;
			if (s->t == t) 
				return stmt_dup(s);
		}
	}
	assert(0);
	return NULL;
}

static stmt *first_subset(stmt * subset)
{
	node *n;

	assert(subset->type == st_ptable);

       	n = ptable_pivots(subset)->h;
	if (n) 
		return stmt_dup(n->data);
	return NULL;
}


/* before the pivot table is created we need to check on both head and
 * tail for the subset.
 * */
static stmt *complex_find_subset(stmt * subset, stmt * t)
{

	if (t) {
		node *n;
		for (n = subset->op1.lval->h; n; n = n->next) {
			stmt *s = n->data;
			if (s->t == t) 
				return stmt_dup(s);
		}
		for (n = subset->op1.lval->h; n; n = n->next) {
			stmt *s = n->data;
			if (s->h == t) 
				return stmt_dup(s);
		}
	}
	return NULL;
}


static lng scale2value(int scale){
	lng val = 1;

	if (scale < 0) scale = -scale;
	for(;scale; scale--){
		val = val * 10;
	}
	return val;
}

static void sum_scales( sql_subfunc *f, stmt *ls, stmt *rs ){
	if (strcmp(f->func->imp, "*") == 0 && 
			f->func->res->type->scale == SCALE_FIX){
		f->res.scale = tail_type(ls)->scale + 
					tail_type(rs)->scale;
	}
}

static stmt *scale_algebra( sql_subfunc *f, stmt *ls, stmt *rs ){
	sql_subtype *lt = tail_type(ls);
	sql_subtype *rt = tail_type(rs);

	if (lt->type->scale == SCALE_FIX && rt->scale){ 
		sql_subtype *it = sql_bind_localtype( lt->type->name );
		sql_subfunc *c = NULL;

		if (strcmp(f->func->imp, "/") == 0){
			c = sql_bind_func("scale_up",lt,it);
		}
		if (c){
			lng val = scale2value(rt->scale);
			atom *a = atom_int(sql_dup_subtype(it), val);
			ls = stmt_binop(ls, stmt_atom(a), c);
		}
	}
	return ls;
}

static stmt *fix_scale( mvc * sql, sql_subtype * ct, stmt * s, int both, int always)
{
	sql_subtype *st = tail_type(s);
	(void) sql; /* Stefan: unused!? */

	if (ct->type->scale == SCALE_FIX && st->type->scale == SCALE_FIX){ 
		int scale_diff = (ct->scale - st->scale);

		if (scale_diff){
			sql_subtype *it = sql_bind_localtype( st->type->name );
			sql_subfunc *c = NULL;

			if (scale_diff < 0){
				if (!both) 
					return s;
				c = sql_bind_func("scale_down",st,it);
			} else {
				c = sql_bind_func("scale_up",st,it);
			}
			if (c) {
				lng val = scale2value(scale_diff);
				atom *a = atom_int(sql_dup_subtype(it), val);
				c->res.scale = (st->scale + scale_diff);
				return stmt_binop(s, stmt_atom(a), c);
			}
		}
	} else if (always && st->scale){ /* scale down */
		int scale_diff =  - st->scale;
		sql_subtype *it = sql_bind_localtype( st->type->name );
		sql_subfunc *c = sql_bind_func("scale_down",st,it);

		if (c) {
			lng val = scale2value(scale_diff);
			atom *a = atom_int(sql_dup_subtype(it), val);
			c->res.scale = 0;
			return stmt_binop(s, stmt_atom(a), c);
		} else {
			printf("scale_down mising (%s)\n", st->type->name);
		}
	}
	return s;
}

/* check_types tries to match the ct type with the type of s if they don't
 * match s is converted. Returns NULL on failure.
 */
static stmt *check_types(mvc * sql, sql_subtype * ct, stmt * s )
{
	sql_subtype *st = tail_type(s);

	if (st) {
		sql_subtype *t = st;

		/* check if the types are the same */
		if (t && subtype_cmp(t, ct) != 0) {
			t = NULL;
		}
		if (!t) {	/* try to convert if needed */
			sql_subfunc *c = 
				sql_bind_func_result("convert",st,NULL,ct);
			if (c){ 
				if (ct->digits > 0){
					if (ct->digits < st->digits){
						sql_subfunc_destroy(c);
						return sql_error(sql, 03, "Types %s(%d,%d) (%s) and %s(%d,%d) (%s) are not equal", st->type->sqlname, st->digits, st->scale, st->type->name, ct->type->sqlname, ct->digits, ct->scale, ct->type->name);
					}
				}
				return fix_scale(sql, ct, stmt_unop(s, c), 1,
					(st->type->scale == SCALE_FIX));
			}
		}
		if (!t || subtype_cmp(t, ct) != 0) {
			return sql_error(sql, 02, "Types %s(%d,%d) (%s) and %s(%d,%d) (%s) are not equal", st->type->sqlname, st->digits, st->scale, st->type->name, ct->type->sqlname, ct->digits, ct->scale, ct->type->name);
		}
	} else {
		assert(0);
		return sql_error(sql, 02, "Statement has no type information");
	}
	return fix_scale(sql, ct, s, 1, 0);
}


/* convert_types convert both the stmt's L and R such that they get
 * matching types. On failure <0 is returned;
 */
static int convert_types(mvc * sql, stmt ** L, stmt ** R, int scale_fixing )
{
	stmt *ls = *L;
	stmt *rs = *R;
	sql_subtype *lt = tail_type(ls);
	sql_subtype *rt = tail_type(rs);

	if (rt && lt){
		sql_subtype *i = lt;
		sql_subtype *r = rt;

		if (subtype_cmp(lt,rt) != 0){
			/* first find super type */
			char *tpe = r->type->sqlname;
			int digits = 0;
			int scale = sql_max(i->scale,r->scale);
			sql_subtype *super;
			if (lt->type->nr > rt->type->nr)
				tpe = i->type->sqlname;
			if (i->digits && r->digits)
				digits = sql_max(i->digits,r->digits);

			super = sql_bind_subtype(tpe,digits,scale);
			if (scale_fixing){
				/* convert ls to super type */
				ls = check_types(sql, super, ls);
				/* convert rs to super type */
				rs = check_types(sql, super, rs);
			} else {
				/* convert ls to super type */
				super->scale = lt->scale;
				ls = check_types(sql, super, ls);
				/* convert rs to super type */
				super->scale = rt->scale;
				rs = check_types(sql, super, rs);
			}
			sql_subtype_destroy(super);
		} else if (scale_fixing) {
			ls = fix_scale( sql, r, ls, 0, 0);
			rs = fix_scale( sql, i, rs, 0, 0);
		}
		assert(ls && rs);
		*L = ls;
		*R = rs;
		return 0;
	}
	return -1;
}

/* The case/when construction in the selection works on the resulting
   table (ie. on the marked columns). We just need to know which oid list
   is involved (ie. find one subset).
   We need to check if for all results the types are the same. 
 */
static stmt *sql_case(mvc * sql, scope * scp, symbol *opt_cond, dlist * when_search_list, symbol * opt_else, group * grp, stmt * subset)
{
	list *conds = create_stmt_list();
	list *results = create_stmt_list();
	dnode *dn = when_search_list->h;
	sql_subtype *restype = NULL;
	stmt *res = NULL;
	node *n, *m;


	if (dn) {
		dlist *when = dn->data.sym->data.lval;
		stmt *cond, *result;

		if (opt_cond){
			cond = sql_compare_exp( sql, scp, grp, subset, 
					opt_cond, when->h->data.sym, "=");
		} else {
			cond = sql_logical_exp(sql, scp, 
					when->h->data.sym, grp, subset);
		}
		result = sql_value_exp(sql, scp, 
					when->h->next->data.sym, grp, subset);
		if (!cond || !result) {
			list_destroy(conds);
			list_destroy(results);
			return NULL;
		}
		list_prepend(conds, cond);
		list_prepend(results, result);

		restype = tail_type(result);
	}
	if (!restype) {
		list_destroy(conds);
		list_destroy(results);
		return sql_error(sql, 02, "Error: result type missing");
	}
	for (dn = dn->next; dn; dn = dn->next) {
		sql_subtype *tpe = NULL;
		dlist *when = dn->data.sym->data.lval;
		stmt *cond, *result;

		if (opt_cond){
			cond = sql_compare_exp( sql, scp, grp, subset, 
					opt_cond, when->h->data.sym, "=");
		} else {
			cond = sql_logical_exp(sql, scp, 
					when->h->data.sym, grp, subset);
		}
		result = sql_value_exp(sql, scp, 
					when->h->next->data.sym, grp, subset);
		if (!cond || !result) {
			list_destroy(conds);
			list_destroy(results);
			return NULL;
		}
		list_prepend(conds, cond);
		list_prepend(results, result);

		tpe = tail_type(result);
		if (!tpe) {
			list_destroy(conds);
			list_destroy(results);
			return sql_error(sql, 02, "Error: result type missing");
		}
		if (subtype_cmp(restype, tpe) != 0) {
			list_destroy(conds);
			list_destroy(results);
			return sql_error(sql, 02, "Error: result types %s,%s of case are not compatible", restype->type->sqlname, tpe->type->sqlname);
		}
	}
	if (subset) {
		res = first_subset(subset);
		if (!res) {
			list_destroy(conds);
			list_destroy(results);
			return sql_error(sql, 02, "Subset not found for case stmt");
		}
	} else {
		printf("Case in query not handled jet\n");
	}
	if (opt_else) {
		stmt *result = sql_value_exp(sql, scp, opt_else, grp, subset);

		if (!result) {
			list_destroy(conds);
			list_destroy(results);
			return NULL;
		}
		result = check_types(sql, restype, result);
		if (result->nrcols <= 0) {
			res = stmt_const(res, result);
		} else {
			if (res) stmt_destroy(res);
			res = result;
		}
	} else {
		res = stmt_const(res, NULL);
	}
	for (n = conds->h, m = results->h; n && m;
	     n = n->next, m = m->next) {
		stmt *cond = stmt_dup(n->data);
		stmt *result = stmt_dup(m->data);

		/* need more semantic tests here */
		if (cond->type == st_sets) {
			node *k = cond->op1.lval->h;
			stmt *cur = NULL;

			if (k) {
				list *l1 = k->data;
				cur = stmt_dup(l1->h->data);
				k = k->next;
				for (; k; k = k->next) {
					list *l2 = k->data;
					stmt *st = stmt_dup(l2->h->data);
					cur = stmt_union(cur, st);
				}
				if (cond) stmt_destroy(cond);
				cond = cur;
			}
		}
		if (cond->type == st_set) {
			stmt *nc = (stmt*)list_reduce(cond->op1.lval, (freduce)&stmt_semijoin, (fdup)&stmt_dup );
			stmt_destroy(cond);
			cond = nc;
		}
		if (result->nrcols <= 0)
			result = stmt_const(cond, result);
		else 
			result = stmt_semijoin(result, cond);
		res = stmt_replace(res, result);
	}
	list_destroy(conds);
	list_destroy(results);
	return res;
}

static stmt *sql_case_exp(mvc * sql, scope * scp, symbol * se, group * grp, stmt * subset)
{
	dlist *l = se->data.lval;
	if (l->h->type == type_list) {
		dlist *when_search_list = l->h->data.lval;
		symbol *opt_else = l->h->next->data.sym;
		return sql_case(sql, scp, NULL,  when_search_list, opt_else, grp, subset);
	} else {
		symbol *scalar_exp = l->h->data.sym;
		dlist *when_value_list = l->h->next->data.lval;
		symbol *opt_else = l->h->next->next->data.sym;
		return sql_case(sql, scp, scalar_exp, when_value_list, opt_else, grp, subset);
	}
}

static stmt *sql_cast(mvc * sql, scope * scp, symbol * se, group * grp, stmt * subset)
{

	dlist *dl = se->data.lval;
	symbol *s = dl->h->data.sym;
	sql_subtype *tpe = dl->h->next->data.typeval;

	stmt *l = sql_value_exp(sql, scp, s, grp, subset);

	if (l) 
		return check_types(sql, tpe, l);
	return NULL;
}

static stmt *sql_Nop(mvc * sql, scope * scp, symbol * se, group * grp, stmt * subset)
{
	dnode *l = se->data.lval->h;
	dnode *ops = l->next->data.lval->h;
	list *sl = create_stmt_list();
	list *tl = list_create(NULL);
	sql_subfunc *f = NULL;

	for(; ops; ops = ops->next){
		stmt *op = sql_value_exp(sql, scp, ops->data.sym, grp, subset);
		if (!op){
			list_destroy(sl);
			return NULL;
		}
		list_append( sl, op);
		list_append( tl, tail_type(op));
	}
	f = sql_bind_func_(l->data.sval, tl);
	list_destroy(tl);
	if (f) {
		return stmt_Nop(stmt_list(sl), f);
	} else {
		list_destroy(sl);
		return sql_error(sql, 02, "operator: %s unknown", l->data.sval);
	}
	return NULL;
}

static stmt *sql_binop(mvc * sql, scope * scp, symbol * se, group * grp, stmt * subset)
{
	stmt * res = NULL;
	dnode *l = se->data.lval->h;
	stmt *ls = sql_value_exp(sql, scp, l->next->data.sym, grp, subset);
	stmt *rs = sql_value_exp(sql, scp, l->next->next->data.sym, grp, subset);
	sql_subtype *t1, *t2;
	sql_subfunc *f = NULL;

	if (!ls || !rs){
		if (ls) stmt_destroy(ls);
		if (rs) stmt_destroy(rs);
		return NULL;
	}

	/* also need to add semantic checks here */
	if (ls->type == st_list){
		stmt *o = ls;
		assert(list_length(ls->op1.lval) == 1);
		ls = stmt_dup(ls->op1.lval->h->data);
		stmt_destroy(o); 
	}
	if (rs->type == st_list){
		stmt *o = rs;
		assert(list_length(rs->op1.lval) == 1);
		rs = stmt_dup(rs->op1.lval->h->data);
		stmt_destroy(o); 
	}

 	t1 = tail_type(ls);
	t2 = tail_type(rs);

	f = sql_bind_func(l->data.sval, t1, t2 );
	if (f) {
		if (f->func->res->scale == SCALE_FIX){
			ls = fix_scale( sql, t2, ls, 0, 0);
			rs = fix_scale( sql, t1, rs, 0, 0);
		}
		if (f->func->res->scale == SCALE_SUB)
			ls = scale_algebra( f, ls, rs );
		if (f->func->res->scale == SCALE_ADD)
			sum_scales(f, ls, rs);
		return stmt_binop(ls, rs, f);
	} else {
		if (convert_types( sql, &ls, &rs, 0) >= 0){
 			t1 = tail_type(ls);
			t2 = tail_type(rs);
			f = sql_bind_func(l->data.sval, t1, t2 );
			if (f){
				if (f->func->res->scale == SCALE_FIX){
					ls = fix_scale( sql, t2, ls, 0, 0);
					rs = fix_scale( sql, t1, rs, 0, 0);
				}
				if (f->func->res->scale == SCALE_SUB)
					ls = scale_algebra( f, ls, rs );
				if (f->func->res->scale == SCALE_ADD)
					sum_scales(f, ls, rs);
				ls = stmt_binop(ls, rs, f);
				return ls;
			}
		}
	}
	res = sql_error(sql, 02, "Binary operator: %s(%s,%s) unknown", l->data.sval, tail_type(ls)->type->sqlname, tail_type(rs)->type->sqlname);
	if (ls) stmt_destroy(ls);
	if (rs) stmt_destroy(rs);

	return res;
}

static stmt *sql_op(mvc * sql, scope * scp, symbol * se, group * grp, stmt * subset)
{
	dnode *l = se->data.lval->h;
	sql_subfunc *f = NULL;
	(void) scp; (void) grp; (void) subset; /* Stefan: unused!? */

	f = sql_bind_func(l->data.sval, NULL, NULL);
	if (f) {
		return stmt_op(f);
	} else {
		return sql_error(sql, 02, "operator: %s() unknown", l->data.sval);
	}
	return NULL;
}

static stmt *sql_unop(mvc * sql, scope * scp, symbol * se, group * grp, stmt * subset)
{
	dnode *l = se->data.lval->h;
	sql_subfunc *f = NULL;
	stmt *rs = sql_value_exp(sql, scp, l->next->data.sym, grp, subset);
	if (!rs)
		return NULL;
	f = sql_bind_func(l->data.sval, tail_type(rs), NULL );
	if (f) {
		if (f->func->imp) {
			return stmt_unop(rs, f);
		} else {
			sql_arg *a = f->func->ops->h->data;
			sql_add_param(sql, _strdup(a->name), rs );

			return sqlparse_intern(sql, f->func->imp);
		}
	} else {
		char *type = tail_type(rs)->type->sqlname;
		stmt_destroy(rs);
		return sql_error(sql, 02, "Unary operator: %s(%s) unknown", l->data.sval, type);
	}
	return NULL;
}


static stmt *sql_aggrop(mvc * sql, scope * scp, symbol * se, group * grp, stmt * subset)
{
	dlist *l = se->data.lval;
	sql_subaggr *a = NULL;
	int distinct = l->h->next->data.ival;
	stmt *s = NULL;
	char *aggrstr = l->h->data.sval;
	if (!l->h->next->next->data.sym) {	/* count(*) case */
		cvar *cv;
		if (strcmp(aggrstr, "count") != 0) {
			return sql_error(sql, 02, "Aggregate: Cannot do a %s(*)", l->h->data.sval);
		}
		if (grp) {
			a = sql_bind_aggr(aggrstr, NULL); 
			return stmt_aggr(stmt_dup(grp->grp), grp_dup(grp), a);
		}
		cv = scope_first_column(scp);
		if (cv && subset) {
			stmt *foundsubset = find_pivot(subset, cv->s->h);

				assert(foundsubset);
			if (!foundsubset) {
				return sql_error(sql, 02, "Aggregate: Cannot find subset for column %s\n", cv->cname) ;
			}
			s = stmt_join(foundsubset, stmt_dup(cv->s), cmp_equal);
		}
	} else {
		/* use cnt as nils shouldn't to be counted */
		if (strcmp(aggrstr, "count") == 0) {
			aggrstr = "count_no_nil";
		}
		/* the values which are aggregated together, no grp should
		 * be given there to optain the values */
		s = sql_value_exp(sql, scp, l->h->next->next->data.sym, /*grp*/ NULL, subset);
	}

	if (s && distinct) {
		s = stmt_unique(s,grp_dup(grp));
	}
	if (!s)
		return NULL;
	a = sql_bind_aggr(aggrstr, tail_type(s));
	if (a) {
		/* type may have changed, ie. need to fix_scale */
		sql_subtype *t = tail_type(s);
		return fix_scale(sql, t, stmt_aggr(s, grp_dup(grp), a), 1, (t->type->scale == SCALE_FIX));
	} else {
		char *type = tail_type(s)->type->sqlname;
		stmt_destroy(s);
		return sql_error(sql, 02, "Aggregate: %s(%s) unknown", l->h->data.sval, type);
	}
	return NULL;
}

static stmt *sql_column_value(mvc * sql, scope * scp, symbol * se, group * grp, stmt * subset)
{
	stmt *res = sql_column_ref(sql, scp, se);
	(void) grp; /* Stefan: unused!? */

	if (res && res->h && subset) {
		stmt *foundsubset = find_pivot(subset, res->h);

		if (!foundsubset) {
			return sql_error(sql, 02, "Subset not found for value expression");
		}
		res = stmt_join(foundsubset, res, cmp_equal);
	} 
	return res;
}

static stmt *sql_value_exp(mvc * sql, scope * scp, symbol * se, group * grp, stmt * subset)
{

	switch (se->token) {
	case SQL_NOP:
		return sql_Nop(sql, scp, se, grp, subset);
	case SQL_BINOP:
		return sql_binop(sql, scp, se, grp, subset);
	case SQL_OP:
		return sql_op(sql, scp, se, grp, subset);
	case SQL_UNOP:
		return sql_unop(sql, scp, se, grp, subset);
	case SQL_AGGR:
		return sql_aggrop(sql, scp, se, grp, subset);
	case SQL_COLUMN:
		return sql_column_value(sql, scp, se, grp, subset);
	case SQL_SELECT:
		return scope_subquery(sql, scp, se);
	case SQL_PARAMETER:
		printf("parameter not used\n");
		break;
	case SQL_ATOM: {
		AtomNode *an = (AtomNode*)se;
		return stmt_atom(atom_dup(an->a));
	}
	case SQL_CAST:
		return sql_cast(sql, scp, se, grp, subset);
	case SQL_CASE:
		return sql_case_exp(sql, scp, se, grp, subset);
	case SQL_NULLIF:
	case SQL_COALESCE:
		printf("case %d %s\n", se->token, token2string(se->token));
		return NULL;
		break;
	default:
		printf("unknown %d %s\n", se->token,
		       token2string(se->token));
	}
	return NULL;
}

/* turns a stmt set (or a set of stmt_sets) into a pivot table 
 * ie a table with a oid column for each base table.
 * A row of this pivot table expresses how the rows of the base tables
 * relate.
 */

static stmt *stmt2pivot(scope * scp, stmt * s)
{
	stmt *ptable = stmt_dup(scp->ptable);
	ptable_statements(ptable) = s;
	return ptable;
}

static stmt *find_on_column_name(mvc * sql, scope * scp, tvar * t, char *name)
{
	node *m;
	(void) sql; (void) scp; /* Stefan: unused!? */

	for (m = t->columns->h; m; m = m->next) {
		cvar *rc = m->data;
		if (strcmp(name, rc->cname) == 0) {
			return stmt_dup(rc->s);
		}
	}
	return NULL;
}

static list *join_on_column_name(mvc * sql, scope * scp, tvar * tv,
				 tvar * r, int all)
{
	list *res = create_stmt_list();
	node *n;
	for (n = tv->columns->h; n; n = n->next) {
		cvar *lc = n->data;
		stmt *rs = find_on_column_name(sql, scp, r, lc->cname);
		if (rs) {
			list_append(res, stmt_dup(lc->s));
			list_append(res, rs);
		} else if (all) {
			list_destroy(res);
			return NULL;
		}
	}
	return res;
}


static stmt *sql_join_
    (mvc * sql,
     scope * scp,
     symbol * tab1, int natural, jt jointype, symbol * tab2, symbol * js) {
	stmt *s = NULL, *subset = NULL;
	tvar *tv1, *tv2;

	tv1 = table_ref(sql, scp, tab1);
	tv2 = table_ref(sql, scp, tab2);

	if (!tv1 || !tv2)
		return NULL;

	if (js && natural) {
		return sql_error(sql, 02, "Cannot have a NATURAL JOIN with a join specification (ON or USING);");
	}
	if (!js && !natural) {
		return sql_error(sql, 02, "Must have NATURAL JOIN or a JOIN with a specification (ON or USING);");
	}

	if (js && js->token != SQL_USING) {	/* On sql_logical_exp */
		s = sql_logical_exp(sql, scp, js, NULL, NULL);
	} else if (js) {	/* using */
		dnode *n = js->data.lval->h;

		s = stmt_reljoin_init();
		for (; n; n = n->next) {
			char *nm = n->data.sval;

			stmt *ls = find_on_column_name(sql, scp, tv1, nm);
			stmt *rs = find_on_column_name(sql, scp, tv2, nm);
			if (!ls || !rs) {
				if (ls) stmt_destroy(ls);
				if (rs) stmt_destroy(rs);
				if (s) stmt_destroy(s);
				return sql_error(sql, 02, "Tables %s and %s do have a matching column %s\n", tv1->tname, tv2->tname, nm);
			}
			if ((convert_types(sql, &ls, &rs, 1) < 0)) 
			{
				if (ls) stmt_destroy(ls);
				if (rs) stmt_destroy(rs);
				if (s) stmt_destroy(s);
				return NULL;
			}
			stmt_reljoin_fill(s, ls, rs);
		}
	} else {		/* ! js -> natural join */
		list *matching_columns;
		node *m;

		matching_columns = join_on_column_name(sql, scp, tv1, tv2, 0);

		if (!matching_columns || list_length(matching_columns) == 0) {
			if (matching_columns) list_destroy(matching_columns);
			return sql_error(sql, 02, "No attributes of tables %s and %s match\n", tv1->tname, tv2->tname);
		}

		s = stmt_reljoin_init();
		for (m = matching_columns->h; m; m = m->next->next) {
			stmt *ls = stmt_dup(m->data);
			stmt *rs = stmt_dup(m->next->data);

			if ((!rs) || (!ls) ||
				(convert_types(sql, &ls, &rs, 1) < 0)) 
			{
				if (ls) stmt_destroy(ls);
				if (rs) stmt_destroy(rs);
				if (s) stmt_destroy(s);
				return NULL;
			}
			stmt_reljoin_fill(s, ls, rs);
		}
		list_destroy(matching_columns);
	}

	if (s) {
		s = stmt2pivot(scp, s);
	}
	subset = s;
	if (subset) {
		list *l1;
		tvar *t = NULL;
		node *n;
		stmt *fs1 = find_pivot(subset, tv1->s);
		stmt *fs2 = find_pivot(subset, tv2->s);
		stmt *ld = NULL, *rd = NULL;

		if (!fs1 || !fs2) {
			if (fs1) stmt_destroy(fs1);
			if (fs2) stmt_destroy(fs2);
			if (!fs1) {
		     		return sql_error(sql, 02, "Subset %s not found in join expression", tv1->tname);
			} else if (!fs2) {
		     		return sql_error(sql, 02, "Subset %s not found in join expression", tv2->tname);
			} else {
		     		return sql_error(sql, 02, "Subsets %s,%s not found in join expression", tv1->tname, tv2->tname);
			}

		}

		t = tv1;
		if (jointype == jt_left || jointype == jt_full) {
			cvar *cs = t->columns->h->data;
			/* we need to add the missing oid's */
			ld = stmt_diff(stmt_dup(cs->s), stmt_reverse(stmt_dup(fs1)));
			ld = stmt_mark(stmt_reverse(ld), 0);
		}
		t = tv2;
		if (jointype == jt_right || jointype == jt_full) {
			cvar *cs = t->columns->h->data;
			/* we need to add the missing oid's */
			rd = stmt_diff(stmt_dup(cs->s), stmt_reverse(stmt_dup(fs2)));
			rd = stmt_mark(stmt_reverse(rd), 0);
		}
		l1 = create_stmt_list();
		t = tv1;
		for (n = t->columns->h; n; n = n->next) {
			cvar *cs = n->data;

			list_append(l1, stmt_join(stmt_dup(fs1), stmt_dup(cs->s), cmp_equal));
		}
		t = tv2;
		for (n = t->columns->h; n; n = n->next) {
			cvar *cs = n->data;

			list_append(l1, stmt_join(stmt_dup(fs2), stmt_dup(cs->s), cmp_equal));
		}
		if (fs1) stmt_destroy(fs1);
		if (fs2) stmt_destroy(fs2);
		if (jointype == jt_left || jointype == jt_full) {
			list *l2 = create_stmt_list();
			node *m = l1->h;
			t = tv1;
			for (n = t->columns->h; n;
			     n = n->next, m = m->next) {
				cvar *cs = n->data;

				list_append(l2, stmt_append(stmt_dup(m->data), stmt_join (stmt_dup(ld), stmt_dup(cs->s), cmp_equal)));
			}
			t = tv2;
			for (n = t->columns->h; n;
			     n = n->next, m = m->next) {
				cvar *cs = n->data;

				list_append(l2, stmt_append(stmt_dup(m->data), stmt_const (stmt_dup(ld), stmt_atom (atom_general (sql_dup_subtype(tail_type(cs->s)), NULL)))));
			}
			list_destroy(l1);
			l1 = l2;
		}
		if (jointype == jt_right || jointype == jt_full) {
			list *l2 = create_stmt_list();
			node *m = l1->h;
			t = tv1;
			for (n = t->columns->h; n;
			     n = n->next, m = m->next) {
				cvar *cs = n->data;

				list_append(l2, stmt_append(stmt_dup(m->data), stmt_const (stmt_dup(rd), stmt_atom (atom_general (sql_dup_subtype(tail_type(cs->s)), NULL)))));
			}
			t = tv2;
			for (n = t->columns->h; n;
			     n = n->next, m = m->next) {
				cvar *cs = n->data;

				list_append(l2, stmt_append(stmt_dup(m->data), stmt_join (stmt_dup(rd), stmt_dup(cs->s), cmp_equal)));
			}
			list_destroy(l1);
			l1 = l2;
		}
		if (ld) stmt_destroy(ld);
		if (rd) stmt_destroy(rd);
		s = stmt_list(l1);
	}
	if (subset) stmt_destroy(subset);
	return s;
}

static stmt *sql_join(mvc * sql, scope * scp, symbol * q)
{

	dnode *n = q->data.lval->h;
	symbol *tab_ref1 = n->data.sym;
	int natural = n->next->data.ival;
	jt jointype = (jt) n->next->next->data.ival;
	symbol *tab_ref2 = n->next->next->next->data.sym;
	symbol *joinspec = n->next->next->next->next->data.sym;

	return sql_join_(sql, scp, tab_ref1, natural, jointype, tab_ref2, joinspec);
}

static stmt *sql_cross(mvc * sql, scope * scp, symbol * q)
{

	dnode *n = q->data.lval->h;
	symbol *tab_ref1 = n->data.sym;
	symbol *tab_ref2 = n->next->data.sym;

	tvar *tv1 = table_ref(sql, scp, tab_ref1);
	tvar *tv2 = table_ref(sql, scp, tab_ref2);
	cvar *cv1;
	cvar *cv2;
	stmt *ct;

	if (!tv1 || !tv2)
		return NULL;

	cv1 = tv1->columns->h->data;
	cv2 = tv2->columns->h->data;

	ct = stmt_join(stmt_dup(cv1->s), stmt_reverse(stmt_dup(cv2->s)), cmp_all);

	if (ct) {
		list *rl = create_stmt_list();
		node *nv;

		ct = stmt2pivot(scp, ct);

		for (nv = scp->tables->h; nv; nv = nv->next) {
			node *n;
			tvar *tv = nv->data;
			stmt *foundsubset = find_pivot(ct, tv->s);

			for (n = tv->columns->h; n; n = n->next) {
				cvar *cs = n->data;
				list_append(rl, stmt_join (foundsubset, stmt_dup(cs->s), cmp_equal));
			}
		}
		return stmt_list(rl);
	}
	return NULL;
}

static tvar *query_exp_optname(mvc * sql, scope * scp, symbol * q)
{
	tvar *res = NULL;

	switch (q->token) {
	case SQL_JOIN:
		{
			scope *nscp = scope_open(scp);
			stmt *tq = sql_join(sql, nscp, q);
			if (!tq) {
				printf("empty join result\n");
				return NULL;
			}
			res = table_optname(sql, scp, tq, sql->scanner.sql, q->data.lval->t->data.sym);
			scp = scope_close(nscp);
			return res;
		}
	case SQL_CROSS:
		{
			scope *nscp = scope_open(scp);
			stmt *tq = sql_cross(sql, nscp, q);
			if (!tq) {
				printf("empty join result\n");
				return NULL;
			}
			res = table_optname(sql, scp, tq, sql->scanner.sql, q->data.lval->t->data.sym);
			scp = scope_close(nscp);
			return res;
		}
	case SQL_UNION:
		{
			scope *nscp = scope_open(scp);
			node *m;
			dnode *n = q->data.lval->h;
			/*int all = n->next->data.ival;*/
			tvar *lv = table_ref(sql, nscp, n->data.sym);
			tvar *rv = table_ref(sql, nscp, n->next->next->data.sym);
			list *unions, *matching_columns;

			if (!lv || !rv)
				return NULL;

			/* find the matching columns (all should match?)
			 * union these 
			 * if !all do a distinct operation at the end 
			 */
			/* join all result columns ie join(lh,rh) on column_name */

			matching_columns = join_on_column_name(sql, nscp, lv, rv, 1);

			if (!matching_columns)
				return NULL;

			unions = create_stmt_list();
			for (m = matching_columns->h; m; m = m->next->next) {
				stmt *l = stmt_dup(m->data);
				stmt *r = stmt_dup(m->next->data);
				list_append(unions, stmt_union(l, r));
			}
			res = table_optname(sql, scp, stmt_list(unions), sql->scanner.sql, q->data.lval->t->data.sym);
			list_destroy(matching_columns);
			scp = scope_close(nscp);
			return res;
		}
	default:
		printf("case %d %s\n", q->token, token2string(q->token));
	}
	return NULL;
}

/* column expresion of the form: table.* */
static stmt *columns_exp(mvc * sql, scope * scp, symbol * column_e, group * grp, stmt * subset)
{
	char *tname = column_e->data.lval->h->data.sval;
	tvar *tv = scope_bind_table(scp, tname);
	(void) sql; /* Stefan: unused!? */

	if (tv) {
		stmt *foundsubset = find_pivot(subset, tv->s);
		list *columns = create_stmt_list();
		node *n = tv->columns->h;
		if (grp)
			foundsubset = stmt_join(stmt_dup(grp->ext), foundsubset, cmp_equal);
		while (n) {
			cvar *cv = n->data;
			list_append(columns, stmt_join(stmt_dup(foundsubset), stmt_dup(cv->s), cmp_equal));
			n = n->next;
		}
		stmt_destroy(foundsubset);
		return stmt_list(columns);
	}
	return NULL;
}


static stmt *column_exp(mvc * sql, scope * scp, symbol * column_e, group * grp, stmt * subset) {
	dlist *l = column_e->data.lval;
	stmt *s = sql_value_exp(sql, scp, l->h->data.sym, grp, subset);
	if (!s)
		return NULL;

	if (grp && s->type != st_aggr) {
		s = stmt_join(stmt_dup(grp->ext), s, cmp_equal);
	}

	/* AS name */
	if (s && l->h->next->data.sval) {
		s = stmt_alias(s, l->h->next->data.sval);
		scope_add_alias(scp, stmt_dup(s), l->h->next->data.sval);
	}
	return s;
}

static stmt *sql_column_exp(mvc * sql, scope * scp, symbol * column_e, group * grp, stmt * subset)
{
	stmt *res = NULL;
	if (column_e->token == SQL_TABLE) {
		res = columns_exp(sql, scp, column_e, grp, subset);
	} else if (column_e->token == SQL_COLUMN) {
		res = column_exp(sql, scp, column_e, grp, subset);
	}
	if (!res) {
		return sql_error(sql, 02, "Column expression Symbol(%d)->token = %s no output", (int) column_e->token, token2string(column_e->token));
	}
	return res;
}

static list *list_map_merge(list * l2, list * l1)
{
	list *res = list_dup(l1, (fdup)&stmt_dup);
	res = list_merge(res, l2, (fdup)&stmt_dup);
	return res;
}

static list *list_map_append_list(list * l2, list * l1)
{
	return list_append(l1, list_dup(l2, (fdup)&stmt_dup));
}

static stmt *sql_compare(mvc * sql, stmt * ls,
			 stmt * rs, char *compare_op)
{
	int join = 0;
	comp_type type = cmp_equal;

	if (!ls || !rs)
		return NULL;

	if (ls->nrcols <= 0 && rs->nrcols <= 0) {
		stmt_destroy(ls);
		stmt_destroy(rs);
		return sql_error(sql, 02, "Compare(%s) between two atoms is not possible", compare_op);
	} else if (ls->nrcols > 0 && rs->nrcols > 0) {
		join = 1;
	}
	if (compare_op[0] == '=') {
		type = cmp_equal;
	} else if (compare_op[0] == '<') {
		type = cmp_lt;
		if (compare_op[1] != '\0') {
			if (compare_op[1] == '>') {
				type = cmp_notequal;
			} else if (compare_op[1] == '=') {
				type = cmp_lte;
			}
		}
	} else if (compare_op[0] == '>') {
		type = cmp_gt;
		if (compare_op[1] != '\0') {
			if (compare_op[1] == '=') {
				type = cmp_gte;
			}
		}
	}
	if (join) {
		if (convert_types(sql, &ls, &rs, 1) < 0){
			if (ls) stmt_destroy(ls);
			if (rs) stmt_destroy(rs);
			return NULL;
		}
		if (ls->h && rs->h && ls->h == rs->h) {
			return stmt_uselect(ls, rs, type);
		}
		rs = stmt_reverse(rs);
		return stmt_join(ls, rs, type);
	} else {
		if (ls->nrcols == 0) {
			stmt *t = ls;
			ls = rs;
			rs = t;
		}
		if (convert_types(sql, &ls, &rs, 1) < 0){
			if (ls) stmt_destroy(ls);
			if (rs) stmt_destroy(rs);
			return NULL;
		}
		return stmt_uselect(ls, rs, type);
	}
}

static stmt *sql_compare_exp( mvc *sql, scope *scp, group *grp, stmt *subset, symbol *lo, symbol *ro, char *compare_op )
{
	stmt *rs, *ls = sql_value_exp(sql, scp, lo, grp, subset);
	if (!ls)
		return NULL;
	if (ro->token != SQL_SELECT) {
		rs = sql_value_exp(sql, scp, ro, grp, subset);
		if (!rs) {
			stmt_destroy(ls);
			return NULL;
		}
		if (grp && (!rs->key || !ls->key)) {
			stmt_destroy(rs);
			stmt_destroy(ls);
			return sql_error(sql, 02, "Cannot compare sets with values, probably a aggregate function missing");
		}
		return sql_compare(sql, ls, rs, compare_op);
	} else {
		node *o;
		rs = scope_subquery(sql, scp, ro);

		if (!rs) {
			stmt_destroy(ls);
			return NULL;
		}
		if (rs->type != st_list || list_length(rs->op1.lval) == 0) {
			stmt_destroy(ls);
			stmt_destroy(rs);
			return sql_error(sql, 02, "Subquery result wrong");
		}
		o = rs->op1.lval->h;
		/* no outer references */
		if (list_length(rs->op1.lval) == 1) {
			stmt *sqa = stmt_dup(o->data);
			stmt_destroy(rs);
			return sql_compare(sql, ls, sqa, compare_op);
		} else {
			/* for now assume single outer ref ! */
			stmt *oref = stmt_dup(o->next->data);
			stmt *sqa  = stmt_dup(o->data);
			stmt *cmp = NULL;
			stmt *h;

			assert( list_length(rs->op1.lval) == 2);

			cmp = stmt_join(stmt_reverse(oref), sqa, cmp_equal);
			/* need to fix the oref head */
			h = stmt_dup(cmp->h->h);
			stmt_destroy(cmp->h);
			cmp->h = h;

			if (subset){ /* filter subset */
				ls = stmt_join(find_pivot(subset, ls->h), ls, cmp_equal);
			} else {
				ls = stmt_join(scope_find_pivot(scp, ls->h), ls, cmp_equal);
			}
			cmp = sql_compare(sql, ls, cmp, compare_op);
			stmt_destroy(rs);
			return stmt_filter(cmp);
		}
	}
	return NULL;
}

static stmt *sql_and(mvc * sql, stmt * ls, stmt * rs)
{
	stmt *res = NULL;
	(void) sql; /* Stefan: unused!? */

	if (!ls || !rs)
		return NULL;
	if (ls->type != st_set && ls->type != st_sets) {
		ls = stmt_set(ls);
	}
	if (rs->type != st_set && rs->type != st_sets) {
		rs = stmt_set(rs);
	}
	if (ls->type == st_set && rs->type == st_set) {
		list_merge( ls->op1.lval, rs->op1.lval,(fdup)&stmt_dup);
		stmt_destroy(rs);
		res = ls;
	} else if (ls->type == st_sets && rs->type == st_set) {
		res = stmt_sets(list_map(ls->op1.lval, rs->op1.sval,
					(fmap) & list_map_merge));
		stmt_destroy(rs);
		stmt_destroy(ls);
	} else if (ls->type == st_set && rs->type == st_sets) {
		res = stmt_sets(list_map(rs->op1.lval, ls->op1.sval,
					(fmap) & list_map_merge));
		stmt_destroy(rs);
		stmt_destroy(ls);
	} else if (ls->type == st_sets && rs->type == st_sets) {
		res = stmt_sets(list_map(ls->op1.lval, rs->op1.sval,
					(fmap) & list_map_merge));
		stmt_destroy(rs);
		stmt_destroy(ls);
	}
	return res;
}

static stmt *sql_or(mvc * sql, stmt * ls, stmt * rs)
{
	stmt *res = NULL;
	(void) sql; /* Stefan: unused!? */

	if (!ls || !rs)
		return NULL;
	if (ls->type != st_set && ls->type != st_sets) {
		ls = stmt_set(ls);
	}
	if (rs->type != st_set && rs->type != st_sets) {
		rs = stmt_set(rs);
	}
	if (ls->type == st_set && rs->type == st_set) {
		res = stmt_sets(
			list_append( 
			    list_append(
				list_create((fdestroy)&list_destroy),
				  list_dup(ls->op1.lval, (fdup)&stmt_dup)),
				    list_dup(rs->op1.lval, (fdup)&stmt_dup)));
		stmt_destroy(ls);
		stmt_destroy(rs);
	} else if (ls->type == st_sets
		   && rs->type == st_set) {
		list_append(ls->op1.lval, 
				list_dup(rs->op1.lval, (fdup)&stmt_dup));
		res = ls;
		stmt_destroy(rs);
	} else if (ls->type == st_set
		   && rs->type == st_sets) {
		list_append(rs->op1.lval, 
				list_dup(ls->op1.lval, (fdup)&stmt_dup));
		res = rs;
		stmt_destroy(ls);
	} else if (ls->type == st_sets
		   && rs->type == st_sets) {
		(void) list_map(ls->op1.lval, rs->op1.sval,
			(fmap) & list_map_append_list);
		res = ls;
		stmt_destroy(rs);
	}
	return res;
}

static stmt *sql_logical_exp(mvc * sql, scope * scp, symbol * sc, group * grp, stmt * subset)
{
	if (!sc)
		return NULL;
	switch (sc->token) {
	case SQL_OR:
		{
			symbol *lo = sc->data.lval->h->data.sym;
			symbol *ro = sc->data.lval->h->next->data.sym;
			stmt *ls = sql_logical_exp(sql, scp, lo, grp, subset);
			stmt *rs = sql_logical_exp(sql, scp, ro, grp, subset);
			return sql_or(sql, ls, rs);
		}
		break;
	case SQL_AND:
		{
			symbol *lo = sc->data.lval->h->data.sym;
			symbol *ro = sc->data.lval->h->next->data.sym;
			stmt *ls = sql_logical_exp(sql, scp, lo, grp, subset);
			stmt *rs = sql_logical_exp(sql, scp, ro, grp, subset);
			return sql_and(sql, ls, rs);
		}
		break;
	case SQL_COMPARE:
		{
			symbol *lo = sc->data.lval->h->data.sym;
			symbol *ro = sc->data.lval->h->next->next->data.sym;
			char *compare_op = sc->data.lval->h->next->data.sval;
			return sql_compare_exp(
				 sql, scp, grp, subset, lo, ro, compare_op);
		}
		break;
	case SQL_BETWEEN:
	case SQL_NOT_BETWEEN:
		{
			stmt *res = NULL;
			symbol *lo = sc->data.lval->h->data.sym;
			int symmetric = sc->data.lval->h->next->data.ival;
			symbol *ro1 =
			    sc->data.lval->h->next->next->data.sym;
			symbol *ro2 =
			    sc->data.lval->h->next->next->next->data.sym;
			stmt *ls = sql_value_exp(sql, scp, lo, grp, subset);
			stmt *rs1 = sql_value_exp(sql, scp, ro1, grp, subset);
			stmt *rs2 = sql_value_exp(sql, scp, ro2, grp, subset);
			sql_subtype *ct = NULL;
			if (!ls || !rs1 || !rs2)
				return NULL;
			if (rs1->nr > 0 || rs2->nr > 0) {
				return sql_error(sql, 02, "Between requires an atom on the right handside");
			}
			ct = tail_type(ls);
			rs1 = check_types(sql, ct, rs1);
			rs2 = check_types(sql, ct, rs2);
			if (symmetric) {
				stmt *tmp = NULL;
				sql_subfunc *min = sql_bind_func("min", tail_type(rs1), tail_type(rs2));
				sql_subfunc *max = sql_bind_func("max", tail_type(rs1), tail_type(rs2));
				if (!min || !max) {
					return sql_error(sql, 02, "min or max operator on types %s %s missing",
						 tail_type(rs1)->type->sqlname,
						 tail_type(rs2)->type->sqlname);
				}
				tmp = stmt_binop(rs1, rs2, min);
				rs2 = stmt_binop(rs1, rs2, max);
				rs1 = tmp;
			}
			res = stmt_uselect2(ls, rs1, rs2, 3 
					/* aka rs1 <= ls <= rs2*/);
			if (sc->token == SQL_NOT_BETWEEN)
				res = stmt_diff(ls, res);
			return res;
		}
	case SQL_LIKE:
	case SQL_NOT_LIKE:
		{
			stmt *res = NULL;
			symbol *lo = sc->data.lval->h->data.sym;
			symbol *ro = sc->data.lval->h->next->data.sym;
			stmt *ls = sql_value_exp(sql, scp, lo, grp, subset);
			stmt *a = NULL, *e = NULL;
			sql_subtype *st = sql_bind_localtype("str");
			int cmp = (sc->token == SQL_LIKE ? cmp_like : cmp_notlike);

			if (!ls)
				return NULL;

			lo = ro->data.lval->h->data.sym;
			a = sql_value_exp(sql, scp, lo, grp, subset);
	
			if (!a){
				stmt_destroy(ls);
				return NULL;
			}
			if (dlist_length(ro->data.lval) == 2) {
				symbol *es = ro->data.lval->h->next->data.sym;
				e = sql_value_exp(sql, scp, es, grp, subset );
				if (!check_types(sql, st, e) ){
					return sql_error(sql, 02, "Wrong type used with LIKE ESCAPE statment, should be string" );
				}
			}
			if (e) {
				return sql_error(sql, 02, "Time to implement LIKE escapes");
			}
			if (!check_types(sql, st, a) ){
				return sql_error(sql, 02, "Wrong type used with LIKE stmt, should be string" );
			}
			res = stmt_select(ls, a, cmp);
			return res;
		}
	case SQL_IN:
	case SQL_NOT_IN:
		/*
         <in predicate> ::=
              <row value constructor>
                [ NOT ] IN <in predicate value>

         <in predicate value> ::=
                <table subquery>
              | <left paren> <in value list> <right paren>

         <in value list> ::=
              <value expression> { <comma> <value expression> }...
		*/
		{
			dlist *l = sc->data.lval;
			symbol *lo = l->h->data.sym;
			stmt *ls = sql_value_exp(sql, scp, lo, grp, subset);
			if (!ls)
				return NULL;
			if (l->h->next->type == type_list) {
				dnode *n = l->h->next->data.lval->h;
				sql_subtype *ct = tail_type(ls);
				stmt *temp = stmt_temp(sql_dup_subtype(ct));

				for (; n; n = n->next) {
					symbol *sval = n->data.sym;
					stmt *v = sql_value_exp(sql, scp, sval, NULL, NULL); 
					temp = stmt_append(temp, 
						check_types(sql, ct, v) );
				}
				if (sc->token == SQL_IN){
					return stmt_reverse(
						stmt_semijoin(
						 stmt_reverse(ls), 
						 stmt_reverse(temp)));
				} else { /* SQL_NOT_IN */
					return stmt_diff(
						stmt_dup(ls), stmt_join(
						 ls, 
					         stmt_reverse(temp), 
						 cmp_equal));
				}
			} else if (l->h->next->type == type_symbol) {
				symbol *ro = l->h->next->data.sym;
				stmt *sq = scope_subquery(sql, scp, ro);

				if (!sq)
					return NULL;

				if (sq->type != st_list
				    || list_length(sq->op1.lval) == 0) {
					stmt_destroy(sq);
					return sql_error(sql, 02, "Subquery result wrong");
				}
				if (list_length(sq->op1.lval) == 1) {
					stmt *rs = stmt_dup(sq->op1.lval->h->data);
					stmt_destroy(sq);
					if (sc->token == SQL_IN){
					  return
					    stmt_reverse
					    (stmt_semijoin
					     (stmt_reverse(ls),
					      stmt_reverse(rs)));
					} else { /* SQL_NOT_IN */
					  return
					    stmt_reverse
					    (stmt_diff
					     (stmt_reverse(ls),
					      stmt_reverse(rs)));
					}
				} else {	
					/* TODO fix this broken impl ! */
					return sql_error(sql, 03, "time to implement (NOT) IN with outer refs\n");
				}
				return NULL;
			} else {
				return sql_error(sql, 02, "In missing inner query");
			}
		}
		break;
	case SQL_EXISTS:
	case SQL_NOT_EXISTS:
		{
			symbol *lo = sc->data.sym;
			scope *nscp = scope_open(scp);
			stmt *ls = sql_subquery(sql, nscp, lo);

			scp = scope_close(nscp);

			if (!ls)
				return NULL;
			if (ls->type != st_list) {
				stmt_destroy(ls);
				return sql_error(sql, 02, "Subquery result wrong");
			}
			if (list_length(ls->op1.lval) == 1) {
				/* EXIST non empty result means AND TRUE */
				/* NOT EXIST non empty result means AND FALSE */
				/* EXISTS pivot.semijoin(pivot.outerjoin(result));
				 * NOT EXISTS pivot.diff(pivot.outerjoin(result));
				 */
				stmt *res, *s = ls->op1.lval->h->data; 
				printf("stupid exists not implemented\n");
				res = stmt_reverse(stmt_dup(s));
				stmt_destroy(ls);
				return res;
			} else {
				/* for now assume single outer ref ! */
				node *o = ls->op1.lval->h;
				stmt *t, *oref = stmt_dup(o->next->data);

				/* need to fix the oref tail */
				t = stmt_dup(oref->t->t);
				stmt_destroy(oref->t);
				oref->t = t;

				t = stmt_reverse(oref);
				if (sc->token == SQL_NOT_EXISTS) 
					t = stmt_diff(scope_first_pivot(scp),t);
				stmt_destroy(ls);
				return stmt_filter(t);
			}
		}
		break;
	case SQL_NULL:
	case SQL_NOT_NULL:
		{
			symbol *cr = sc->data.sym;
			stmt *res =
			    sql_value_exp(sql, scp, cr, grp, subset);

			if (res) {
				sql_subtype *tpe = sql_dup_subtype(tail_type(res));
				stmt *a = stmt_atom(atom_general(tpe, NULL));

				if (sc->token == SQL_NULL) {
					res = stmt_uselect(res, a, cmp_equal);
				} else {
					res = stmt_uselect(res, a,
							cmp_notequal);
				}
			}
			return res;
		}
		break;
	default:
		return sql_error(sql, 02, 
			 "Predicate %s %d: time to implement some more",
			 token2string(sc->token), sc->token);
	}
	return sql_error(sql, 02, "Predicate: time to implement some more");
}

static stmt *having_condition(mvc * sql, scope * scp, symbol * sc, group * grp, stmt * subset)
{
	if (!sc)
		return NULL;
	switch (sc->token) {
	case SQL_OR:
		{
			symbol *lo = sc->data.lval->h->data.sym;
			symbol *ro = sc->data.lval->h->next->data.sym;
			stmt *ls = having_condition(sql, scp, lo, grp, subset);
			stmt *rs = having_condition(sql, scp, ro, grp, subset);
			if (!ls || !rs)
				return NULL;

			return stmt_union(ls, rs);
		}
		break;
	case SQL_AND:
		{
			symbol *lo = sc->data.lval->h->data.sym;
			symbol *ro = sc->data.lval->h->next->data.sym;
			stmt *ls = having_condition(sql, scp, lo, grp, subset);
			stmt *rs = having_condition(sql, scp, ro, grp, subset);
			if (!ls || !rs)
				return NULL;

			return stmt_semijoin(ls, rs);
		}
		break;
	case SQL_COMPARE:
	case SQL_BETWEEN:
	case SQL_NOT_BETWEEN:
	case SQL_LIKE:
	case SQL_NOT_LIKE:
	case SQL_IN:
	case SQL_NOT_IN:
	case SQL_EXISTS:
	case SQL_NOT_EXISTS:
			return sql_logical_exp(sql, scp, sc, grp, subset);
	default:
		return sql_error(sql, 02, 
			 "Predicate %s %d: time to implement some more",
			 token2string(sc->token), sc->token);
	}
	return sql_error(sql, 02, "Predicate: time to implement some more");
}


static group *query_groupby_inner(mvc * sql, scope * scp, stmt * c, stmt * subset, group * cur)
{
	stmt *s = find_pivot(subset, c->h);
	(void) scp; /* Stefan: unused!? */

	if (s) {
		stmt *j = stmt_join(s, c, cmp_equal);
		cur = grp_create(j, cur);
	}

	if (!cur) {
		char *cn = column_name(c);
		assert(cur);
		(void) sql_error(sql, 02, 
			 "subset not found for groupby column %s\n", cn);
		_DELETE(cn);
		return NULL;
	}
	return cur;
}

static group *query_groupby(mvc * sql, scope * scp, symbol * groupby, stmt * subset)
{
	group *cur = NULL;
	dnode *o = groupby->data.lval->h;
	while (o) {
		symbol *grp = o->data.sym;
		stmt *c = sql_column_ref(sql, scp, grp);
		cur = query_groupby_inner(sql, scp, c, subset, cur);
		o = o->next;
	}
	return cur;
}

static group *query_groupby_outers(mvc * sql, scope * scp, stmt * subset)
{
	group *cur = NULL;
	node *o = scp->outers->h;
	(void) sql; /* Stefan: unused!? */

	for ( ; o; o = o->next) {
		stmt *outer = o->data;
		stmt *s = find_pivot(subset, outer);
		if (s) 
			cur = grp_create(s, cur);
	}
	return cur;
}

static stmt *query_orderby(mvc * sql, scope * scp, symbol * orderby, stmt * st, stmt * subset, group * grp)
{
	stmt *cur = NULL;
	dnode *o = orderby->data.lval->h;
	(void) st; /* Stefan: unused!? */

	while (o) {
		symbol *order = o->data.sym;
		if (order->token == SQL_COLUMN) {
			symbol *col = order->data.lval->h->data.sym;
			int direction =
			    order->data.lval->h->next->data.ival;
			stmt *sc = sql_column_ref(sql, scp, col);
			if (sc) {
				stmt *j = NULL;
				if (sc->type == st_bat || sc->type == st_ibat) {
					j = find_pivot(subset, sc->h);
					if (!j) {
						return sql_error(sql, 02, "subset not found for orderby column\n");
					}
					if (grp)
						j = stmt_join(stmt_dup(grp->ext), j, cmp_equal);
					j = stmt_join(j, sc, cmp_equal);
				} else {
					j = sc;
				}
				if (cur)
					cur = stmt_reorder(cur, j, direction);
				else
					cur = stmt_order(j, direction);
			} else {
				return NULL;
			}
		} else {
			return sql_error(sql, 02, "order not of type SQL_COLUMN\n");
		}
		o = o->next;
	}
	return cur;
}

static stmt *sql_simple_select(mvc * sql, scope * scp, dlist * selection)
{
	stmt *s = NULL;
	list *rl = create_stmt_list();

	if (selection) {
		dnode *n = selection->h;
		while (n) {
			stmt *cs = sql_column_exp(sql, scp, n->data.sym, NULL, NULL);

			if (!cs) {
				list_destroy(rl);
				return NULL;
			}

			/* t1.* */
			if (cs->type == st_list && n->data.sym->token == SQL_TABLE) {
				list_merge(rl, cs->op1.lval, (fdup)&stmt_dup);
				stmt_destroy(cs);
			} else if (cs->type == st_list) {	/* subquery */
				if (list_length(cs->op1.lval) == 1){ 
					list_append(rl, stmt_dup(cs->op1.lval->h->data));
				} else {
					stmt_destroy(cs);
					return sql_error( sql, 02, "Subquery should return a single value");
				}
			/*
			} else if (cs->nrcols == 0){
				list_append(rl, cs);
			*/
			} else {
				list_append(rl, cs);
			}
			n = n->next;
		}
	}
	s = stmt_list(rl);

	if (!s)
		return sql_error(sql, 02, "Subquery result missing");
	return s;
}

static stmt *sql_select(mvc * sql, scope * scp, SelectNode *sn, int toplevel )
{
	list *rl = NULL;
	stmt *s = NULL;

	stmt *order = NULL, *subset = NULL;
	group *grp = NULL;

	if (!sn->from && !sn->where)
		return sql_simple_select(sql, scp, sn->selection);

	if (sn->where) {
		node *n;
		stmt *cur = NULL;

		s = sql_logical_exp(sql, scp, sn->where, NULL, NULL);
		if (!s) {
			sql_select_cleanup(sql, s, subset, grp);
			return sql_error( sql, 02, "Subquery result missing");
		}
		if (s->type != st_set && s->type != st_sets) {
			s = stmt_set(s);
		}
		/* check for tables not used in the where part */
		if (s->type == st_set){ /* TODO: handle st_sets!! */
		    for (n = scp->tables->h; n; n = n->next) {
			tvar *v = n->data;
			stmt *tmp = complex_find_subset(s, v->s);
			if (!tmp) {
				cvar *cv = v->columns->h->data;
				tmp = stmt_dup(cv -> s);
				/* just add a select whole column */
				if (!cur) {
					cur = stmt_dup(tmp);
				/* add join to an allready used column */
				} else {	
					tmp = stmt_join(stmt_dup(cur),
						stmt_reverse(tmp), cmp_all);
				}
				s = sql_and(sql, s, tmp);
			} else if (!cur) {
				cur = tmp;
			} else {
				stmt_destroy(tmp);
			}
		    }
		}
		if (cur) 
			stmt_destroy(cur);
		
	} else if (sn->from) {
		node *n;
		stmt *cur = NULL;
		for (n = scp->tables->h; n; n = n->next) {
			tvar *tv = n->data;
			cvar *cv = tv->columns->h->data;
			stmt *tmp = stmt_dup(cv -> s);
			if (!cur) {
				if (isbasetable(tv->s)){
					cur = stmt_diff(tmp, stmt_reverse(
					   stmt_tbat(basetable_table(tv->s), RDONLY )));
				} else {
					cur = tmp;
				}
			} else {
				tmp = stmt_join(stmt_dup(cur), 
						stmt_reverse(tmp), cmp_all);
				if (s) {
					list_append(s->op1.lval, tmp);
				} else {
					s = stmt_set(tmp);
				}
			}
		}
		if (!cur) {
			sql_select_cleanup(sql, s, subset, grp);
			return sql_error(sql, 02, "Subquery has no columns");
		}
		if (!s)
			s = cur;
		else
			stmt_destroy(cur);
	}

	if (s) {
		s = stmt2pivot(scp, s);
		if (s && sn->groupby) {
			grp = query_groupby(sql, scp, sn->groupby, s);
			if (!grp)  {
				sql_select_cleanup(sql, s, subset, grp);
				return sql_error( sql, 02, "Subquery result missing");
			}
		}

		if (s && list_length(scp->outers) > 0) {
			grp = query_groupby_outers(sql, scp, s);
			if (!grp) {
				assert(0);
				sql_select_cleanup(sql, s, subset, grp);
				return sql_error( sql, 02, "Subquery outer ref groupby result missing");
			}
		}
	}

	subset = stmt_dup(s);
	if (sn->having) {
		if (s) stmt_destroy(s);
		s = having_condition(sql, scp, sn->having, grp, subset);

		if (!s){
			sql_select_cleanup(sql, s, subset, grp);
			return sql_error( sql, 02, "Subquery result missing");
		}

		if (grp) {
			grp = grp_semijoin(grp, stmt_dup(s));
		} else {
			node *n = NULL;
			list *sl = create_stmt_list();
			assert (subset->type == st_ptable);
			for (n = ptable_pivots(subset)->h; n; n = n->next) {
				stmt *cs = n->data;

				list_append(sl, stmt_semijoin(stmt_dup(cs), stmt_dup(s)));
			}
			stmt_destroy(subset);
			subset = stmt_list(sl);
		}
	}

	if (!subset){
		sql_select_cleanup(sql, s, subset, grp);
		return sql_error( sql, 02, "Subquery result missing");
	}

	rl = create_stmt_list();
	if (sn->selection) {
		list *sl = create_stmt_list();
		dnode *n;
		node *m;
		int nrcols = 0;

		for (n = sn->selection->h; n; n = n->next ){
			stmt *cs = sql_column_exp(sql, scp, n->data.sym, grp, subset);
			if (!cs){
				list_destroy(sl);
				list_destroy(rl);
				sql_select_cleanup(sql, s, subset, grp);
				return sql_error( sql, 02, "Subquery result missing");
			}

			list_append(sl, cs);
			if (nrcols < cs->nrcols)
				nrcols = cs->nrcols;
		}

		for (m = sl->h, n = sn->selection->h; 
		     m && n; 
		     m = m->next, n = n->next){
			stmt *cs = m->data; 
			/* t1.* */
			if (cs->type == st_list && n->data.sym->token == SQL_TABLE){
				list_merge(rl, cs->op1.lval, (fdup)&stmt_dup);
			} else if (cs->type == st_list) {	/* subquery */
				if (list_length(cs->op1.lval) == 1) {	/* single value */
					stmt *ss = ptable_pivots(subset)->h->data;
					stmt *cs1 = cs->op1.lval->h->data;
					ss = stmt_dup(ss);
					cs1 = stmt_dup(cs1);
					list_append(rl, stmt_join (ss, cs1, cmp_all));
				} else {	/* referenced variable(s) (can only be 2) */
					stmt *sqa = cs->op1.lval->h->data;
					stmt *ids = cs->op1.lval->h->next->data;
					stmt *s = stmt_join( 
						stmt_reverse(stmt_dup(ids)),
						stmt_dup(sqa), cmp_equal);
					s = stmt_outerjoin(
						stmt_mirror(
						    first_subset(subset)), 
						s, cmp_equal);
					list_append(rl, s);
				}
			} else if (cs->nrcols == 0 && nrcols > 0){
				/* select name,count(*) should give an error */
				if (!cs->aggr){
					stmt *ss = first_subset(subset);
					cs = stmt_const(ss,stmt_dup(cs));
					list_append(rl, cs);
				} else {
					list_destroy(sl);
					list_destroy(rl);
					sql_select_cleanup(sql, s, subset, grp);
					return sql_error( sql, 02, "single value in column expression");
				}
			} else {
				cs = stmt_dup(cs);
				list_append(rl, cs);
			}
		}
		list_destroy(sl);
	} else {
		/* select * from tables */
		if (toplevel) {
			node *nv;
			for (nv = scp->tables->h; nv; nv = nv->next) {
				node *n;
				tvar *tv = nv->data;
				stmt *foundsubset = find_pivot(subset, tv->s);

				for (n = tv->columns->h; n; n = n->next) {
					cvar *cs = n->data;
					stmt *cbat = stmt_dup(cs->s);
					list_append(rl, stmt_join(stmt_dup(foundsubset), cbat, cmp_equal));
				}
				stmt_destroy(foundsubset);
			}
		} else {
			/* 
			 * subquery can only return one column
			 */
			tvar *tv = scope_first_table(scp);
			stmt *foundsubset = find_pivot(subset, tv->s);

			if (!foundsubset){
				list_destroy(rl);
				sql_select_cleanup(sql, s, subset, grp);
				return sql_error( sql, 02, "Subquery result missing");
			}
			list_append(rl, foundsubset);
		}
	}
	/* the inner query should output a table where the first bat
	 * contains the queried column values. 
	 * If variables from the outer query are correlated 
	 * the oids from the base tables of these variables are returned
	 * in the next columns.
	 */
	if (list_length(scp->outers) > 0) {
		node *n = scp->outers->h;
		for (; n; n = n->next) {
			stmt *oref = n->data;
			stmt *foundsubset = find_pivot(subset, oref);
			stmt *t;

			if (!foundsubset){
				list_destroy(rl);
				sql_select_cleanup(sql, s, subset, grp);
				return sql_error( sql, 02, "Subquery result missing");
			}
			list_append(rl,
				t=stmt_join( stmt_dup(grp->ext), 
					   foundsubset, cmp_equal));
			/* needed for subquery johan (select * from select *) */
			t->nrcols = 1;
		}
	}
	stmt_destroy(s);
	s = stmt_list(rl);

	if (s && subset && sn->distinct){
		node *n;
		group *grp = NULL;
		rl = create_stmt_list();
 		for (n = s->op1.lval->h; n; n = n->next) {
			stmt *t = n->data;
			grp = grp_create(stmt_dup(t), grp);
		}
 		for (n = s->op1.lval->h; n; n = n->next) {
			stmt *t = n->data;
			list_append(rl, stmt_join(stmt_dup(grp->ext), 
					          stmt_dup(t), cmp_equal));
		}
		grp_destroy(grp);

		stmt_destroy(s);
		s = stmt_list(rl);
	}


	if (s && subset && sn->orderby) {
		order = query_orderby(sql, scp, sn->orderby, s, subset, grp);
		if (!order) {
			sql_select_cleanup(sql, s, subset, grp);
			return sql_error( sql, 02, "Subquery result missing");
		}
	}

	if (!s) {
		sql_select_cleanup(sql, s, subset, grp);
		return sql_error( sql, 02, "Subquery result missing");
	}

	sql_select_cleanup(sql, NULL, subset, grp);

	if (sn->limit >= 0){
		if (order) 
			order = stmt_limit(order, sn->limit);
		else 
			order = stmt_limit(stmt_dup(s->op1.lval->h->data), sn->limit);
	}

	if (s && order)
		return stmt_ordered(order, s);
	return s;
}

static char *strfnd( char *s, char *sep )
{
	int l = strlen(sep);
	while( *s && (*s != *sep || strncmp(s, sep, l) != 0) ){
		s++;
	}
	if (*s)
		return s + l;
	return NULL;
}

static stmt *create_view(mvc * sql, stmt * ss,
			 dlist * qname, dlist * column_spec,
			 symbol * query, int check)
{

	char *name = qname_table(qname);
	(void) check; /* Stefan: unused!? */

	if (mvc_bind_table(sql, cur_schema(sql), name)) {
		stmt_destroy(ss);
		return sql_error(sql, 02, "Create View name %s allready in use", name);
	} else {
		char buf[BUFSIZ];

		stmt *stct = NULL;
		stmt *sq = sql_subquery(sql, NULL, query);
		char *subquery = strfnd(sql->scanner.sql, " as ");
		list *l;

		if (!sq)
			return NULL;

 		l = create_stmt_list();
		if (column_spec) {
			dnode *n = column_spec->h;
			node *m = sq->op1.lval->h;
			stmt *ts = stmt_create_view( ss, name, subquery);

			list_append(l, ts);
			for (; n; n = n->next, m = m->next) {
				char *cname = n->data.sval;
				stmt *cs, *st = m->data;
				sql_subtype *tp = tail_type(st);
				cs = stmt_create_column(stmt_dup(ts), cname, 
					tp->type->sqlname, 
					tp->digits, tp->scale);
				list_append(l, cs);
			}
		} else {
			node *m;
			stmt *ts = stmt_create_view( ss, name, subquery);

			list_append(l, ts);
       			for ( m = sq->op1.lval->h; m; m = m->next) {
				stmt *cs, *st = m->data;
				char *cname = column_name(st);
				sql_subtype *tp = tail_type(st);

				cs = stmt_create_column(stmt_dup(ts), cname, 
					tp->type->sqlname, 
					tp->digits, tp->scale);
				_DELETE(cname);
				list_append(l, cs);
			}
		}
		snprintf(buf, BUFSIZ, "grant select on '%s' to '%s' with grant option with hierarchy option;", name, sql->user);
		list_append( l, stmt_sql(buf));
		stct = stmt_list(l);
		stmt_destroy(sq);
		return stct;
	}
	return NULL;
}

static stmt *drop_view(mvc * sql, dlist * qname )
{
	stmt *res = NULL;
	char *tname = qname_table(qname);
	sql_table *t = mvc_bind_table(sql, cur_schema(sql), tname);

	if (!t) {
		return sql_error(sql, 02, 
			 "Drop View, view %s unknown", tname);
	} else if (t->type == tt_view){
		stmt *ss = stmt_bind_schema( cur_schema(sql)->base.name );
		res = stmt_drop_table(ss, t->base.name, 0);
	} else {
		return sql_error(sql, 02, 
			 "Drop View, cannot drop view %s", tname);
	}
	return res;
}

static stmt *
create_index(mvc * sql, stmt *ss, char * iname, int itype, 
	     dlist * qname, dlist * column_list) 
{

	char *name = qname_table(qname);

	sql_table *t = mvc_bind_table(sql, cur_schema(sql), name); 
	if (!t){
		stmt_destroy(ss);
		return sql_error(sql, 02, 
			"Create Index could not find table name %s", name);
	} else {
		dnode *n = column_list->h;
		list *l = create_stmt_list();
		stmt *ts = stmt_bind_table( ss, name );
		stmt *cis = stmt_create_index( ts, iname, itype);

		list_append(l, cis);
		for (; n; n = n->next) {
			char *cname = n->data.sval;
			sql_column *c = mvc_bind_column(sql, t, cname);
			if (!c){
				list_destroy(l);
				return sql_error(sql, 02, 
				  "Create Index unknown column %s", cname);
			} else {
				list_append(l, 
					stmt_create_ic( stmt_dup(cis), cname));
			}
		}
		return stmt_list(l);
	}
	return NULL;
}

static stmt *drop_index(mvc * sql, dlist * qname )
{
	stmt *res = NULL;
	char *iname = qname_table(qname);

	sql_idx *i = mvc_bind_idx(sql, cur_schema(sql), iname);

	if (!i) {
		return sql_error(sql, 02, 
			 "Drop Index, index %s unknown", iname);
	} else {
		stmt *ss = stmt_bind_schema( cur_schema(sql)->base.name );
		res = stmt_drop_index(ss, i->base.name);
	}
	return res;
}

static stmt *
create_user(mvc * sql, char * user, char * passwd, char *fullname, char *schema)
{
	int schema_id = 0;
	list *l;
	char buf[BUFSIZ];

	if (sql_find_auth( sql, user) >= 0) {
		return sql_error(sql, 02, 
			 "User %s allready exists", user);
	}
	if ((schema_id = sql_find_schema( sql, schema)) < 0) {
		return sql_error(sql, 02, 
			 "Schema %s doesn't exist", schema);
	}
	l = create_stmt_list();
	snprintf(buf, BUFSIZ, "insert into users values('%s','%s','%s',%d);", user, passwd, fullname, schema_id );
	list_append(l, stmt_sql(buf));
	snprintf(buf, BUFSIZ, "insert into auths values(%d, '%s', %d);", OIDnew(1), user, sql->user_id);
	list_append(l, stmt_sql(buf));
	return stmt_list(l);
}

static stmt *drop_user(mvc * sql, char * user )
{
	(void) sql; /* Stefan: unused!? */
	/* TODO check if user exists */

	return stmt_drop_user(user);
}

static stmt *
create_role(mvc * sql, dlist * qname, int grantor)
{
	char *role_name = qname->t->data.sval;

	if (dlist_length(qname) > 2){
		return sql_error(sql, 02, 
			"qualified role can only have a schema and a role\n");
	} 
	return stmt_create_role(role_name, grantor);
}

static stmt *drop_role(mvc * sql, dlist * qname )
{
	char *role_name = qname->t->data.sval;

	if (dlist_length(qname) > 2){
		return sql_error(sql, 02, "qualified role can only have a schema and a role\n");
	} 
	return stmt_drop_role(role_name);
}

static stmt *column_constraint_type(mvc * sql, char *name, symbol * s, stmt * ss, stmt * ts, stmt * cs, char *cname)
{
	stmt *res = NULL;

	switch (s->token) {
	case SQL_UNIQUE: 
	case SQL_PRIMARY_KEY: 
	{
		key_type kt = (s->token == SQL_UNIQUE)?ukey:pkey;
		res = stmt_create_key(ts, name, kt, NULL);
		res = stmt_create_kc( res, cname );
		stmt_destroy(ss);
		stmt_destroy(cs);
	} break;
	case SQL_FOREIGN_KEY:
	{
		dnode *n = s->data.lval->h;
		char *rtname = qname_table(n->data.lval);
		char *rcname = n->data.lval->h->data.sval;
		list *cols = list_append(list_create(NULL),rcname);
		sql_table *rt = mvc_bind_table( sql, cur_schema(sql), rtname );
		sql_key *rk = mvc_bind_ukey( rt, cols);
		stmt *rks;

		list_destroy(cols);
		if (!rt) 
			return sql_error(sql, 02, "table %s unknown\n", rtname);

		rks = stmt_bind_key(ss, rk->base.name);
		if (!rks) {
			return sql_error(sql, 02, "Could not find referenced unique key in table %s\n", rk->base.name );
		}
		res = stmt_create_key(ts, name, fkey, rks);
		res = stmt_create_kc( res, cname );
		stmt_destroy(cs);
	} break;
	case SQL_NOT_NULL:
	case SQL_NULL: {
		int null = (s->token == SQL_NOT_NULL)?0:1;
		res = stmt_null(cs, null);
		stmt_destroy(ss);
		stmt_destroy(ts);
	} 	break;
	}

	if (!res) {
		return sql_error(sql, 02, 
			 "Unknown constraint (%ld)->token = %s\n",
			 (long) s, token2string(s->token));
	}
	return res;
}

/* 
column_option: default | column_constraint ;
*/

static char *table_constraint_name()
{
	oid id = OIDnew(1);
	static char buf[BUFSIZ];
	snprintf(buf, BUFSIZ, "c%ld", id );
	return buf;
}


static stmt *column_option(mvc * sql, symbol * s, stmt * ss, stmt * ts, stmt * cs, char *cname, sql_subtype *ctype)
{
	stmt *res = NULL;
	assert(cs);
	switch (s->token) {
	case SQL_CONSTRAINT:
		{
			dlist *l = s->data.lval;
			char *opt_name = l->h->data.sval;  
			symbol *sym = l->h->next->data.sym;
			if (!opt_name) 
				opt_name = table_constraint_name();
			res = column_constraint_type(sql, opt_name, sym, ss, ts, cs, cname);
		}
		break;
	case SQL_ATOM: {
			AtomNode *an = (AtomNode*)s;
			if (!an || !an->a){
				res = stmt_default(cs, stmt_atom(atom_general(sql_dup_subtype(ctype),NULL)));
			} else {
				res = stmt_default(cs, stmt_atom(atom_dup(an->a)));
			}
			stmt_destroy(ss);
			stmt_destroy(ts);
		} break;
	}
	if (!res) {
		return sql_error(sql, 02, 
			 "Unknown column option (%ld)->token = %s\n",
			 (long) s, token2string(s->token));
	}
	return res;
}

static void column_options(mvc * sql, dlist * opt_list, list *stmt_list, stmt *ss, stmt * ts, stmt * cs, char *cname, sql_subtype *ctype )
{
	stmt *res = cs;

	assert(cs);
	if (opt_list) {
		dnode *n = NULL;
		for (n = opt_list->h; n && res; n = n->next) {
			res = column_option(sql, n->data.sym, stmt_dup(ss), stmt_dup(ts), stmt_dup(cs), cname, ctype);
			list_append( stmt_list, res);
		}
	}
	stmt_destroy(ss);
	stmt_destroy(ts);
	stmt_destroy(cs);
}

typedef struct tmp_column {
	char *name;
	stmt *s;
	sql_subtype *type;
} tmp_column;

tmp_column *create_tmp_col( char *name, stmt *cs, sql_subtype *type )
{
	tmp_column * tc = NEW(tmp_column);
	tc -> name = name;
	tc -> s = cs;
	tc -> type = type;
	return tc;
}

void destroy_tmp_col( tmp_column *c) 
{
	_DELETE(c);
}

stmt *find_column_stmt( list *columns, char *name)
{
	node *n;
	for (n=columns->h; n; n = n->next ){
		tmp_column *c = n->data;
		if (strcmp(c->name, name) == 0)
			return stmt_dup(c->s);
	}
	return NULL;
}

sql_subtype *find_column_type( list *columns, char *name)
{
	node *n;
	for (n=columns->h; n; n = n->next ){
		tmp_column *c = n->data;
		if (strcmp(c->name, name) == 0)
			return c->type;
	}
	return NULL;
}

static stmt *create_column(mvc * sql, symbol * s, stmt * ss, stmt * ts, list *columns )
{
	dlist *l = s->data.lval;
	char *cname = l->h->data.sval;
	sql_subtype *ctype = l->h->next->data.typeval;
	dlist *opt_list = l->h->next->next->data.lval;
	stmt *res = NULL;

	if (cname && ctype) {
		list *l = create_stmt_list();
		stmt *cs = stmt_create_column(ts, cname, ctype->type->sqlname,
			ctype->digits, ctype->scale);

		l = list_append( l, cs );
		list_append(columns, create_tmp_col(cname, cs, ctype) );
		column_options(sql, opt_list, l, ss, stmt_dup(ts), stmt_dup(cs), cname, ctype);
		res = stmt_list(l);
	}

	if (!res) {
		return sql_error(sql, 02, "Create Column: type or name");
	}
	return res;
}

static stmt *table_foreign_key( mvc * sql, char *name, symbol * s, stmt * ss, stmt * ts, char *tname, list * columns )
{
	stmt *res = NULL;
	dnode *n = s->data.lval->h;
	char *rtname = qname_table(n->data.lval);
	sql_table *ft = mvc_bind_table( sql, cur_schema(sql), rtname );

	if (!ft){
		return sql_error(sql, 02, "Table %s unknown\n", rtname );
	} else {
		sql_key *rk = NULL;
		dnode *nms = n->next->data.lval->h;
		node *fnms;
		stmt *srk;

		if (n->next->next->data.lval){ /* find unique referenced key */
			dnode *rnms = n->next->next->data.lval->h;
			list *cols = list_create(NULL);

			for( ;rnms; rnms = rnms->next)
				list_append(cols, rnms->data.sval);

			/* find key in ft->keys*/
			rk = mvc_bind_ukey(ft, cols);
			list_destroy(cols);
		} else { /* no list of columns to find referenced unique key ie
			    use ft.pkey */
			rk = &ft->pkey->k;
		}
		if (!rk){
			return sql_error(sql, 02, "Could not find referenced unique key in table %s\n", ft->base.name );
		}
		srk = stmt_bind_key( ss, rk->base.name );
		res = stmt_create_key(ts, name, fkey, srk);

		for(fnms = rk->columns->h; nms && fnms; nms = nms->next, fnms = fnms->next){
			char *nm = nms->data.sval;
			stmt *c = find_column_stmt(columns, nm );

			if (!c){
				if (res) stmt_destroy(res);
				return sql_error(sql, 02, "Table %s has no column %s\n", tname, nm);
			}
			res = stmt_create_kc( res, nm );
			stmt_destroy(c);
		}
		if (nms || fnms){
			if (res) stmt_destroy(res);
			return sql_error(sql, 02, "Not all colunms are handeled in the foreign key\n");
		}
	}
	return res;
}

static stmt *table_constraint_type( mvc * sql, char *name, symbol * s, stmt * ss, stmt *ts, char *tname, list* columns )
{
	stmt *res = NULL;
	switch(s->token){
		case SQL_UNIQUE: 
		case SQL_PRIMARY_KEY:
		{
			key_type kt = (s->token==SQL_PRIMARY_KEY?pkey:ukey);
			stmt *ks = stmt_create_key(ts, name, kt, NULL);
			dnode *nms = s->data.lval->h;

			for(;nms; nms = nms->next){
				char *nm = nms->data.sval;
				stmt *c = find_column_stmt(columns, nm);

				if (!c){
					return sql_error(sql, 02, "Table %s has no column %s\n", tname, nm);
				}
				ks = stmt_create_kc( ks, nm );
				stmt_destroy(c);
			}
			res = ks;
			stmt_destroy(ss);
		} break;
		case SQL_FOREIGN_KEY:
			res = table_foreign_key( sql, name, s, ss, ts, tname, columns );
		 	break;
	}
	if (!res) {
		return sql_error(sql, 02, 
			 "Table Constraint Type: wrong token (%ld) = %s\n",
			 (long) s, token2string(s->token));
	}
	return res;
}

static stmt *table_constraint( mvc * sql, symbol * s, stmt *ss, stmt * ts, char *tname, list *columns) 
{
	stmt *res = NULL;

	if (s->token == SQL_CONSTRAINT){
		dlist *l = s->data.lval;
		char *opt_name = l->h->data.sval; 
		symbol *sym = l->h->next->data.sym;
		if (!opt_name) 
			opt_name = table_constraint_name();
		res = table_constraint_type(sql, opt_name, sym, ss, ts, tname, columns );
	}

	if (!res) {
		return sql_error(sql, 02, 
			 "Table Constraint: wrong token (%ld) = %s\n",
			 (long) s, token2string(s->token));
	}
	return res;
}

static stmt *table_element(mvc * sql, symbol * s, stmt *ss, stmt * ts, char *tname, list *columns /* list of (name,ctype,stmt) */  )
{
	stmt *res = NULL;

	switch (s->token) {
	case SQL_COLUMN:
		res = create_column(sql, s, ss, ts, columns);
		break;
	case SQL_CONSTRAINT:
		res = table_constraint(sql, s, ss, ts, tname,columns);
		break;
	case SQL_COLUMN_OPTIONS:
		{
			dnode *n = s->data.lval->h;
			char *cname = n->data.sval;
			stmt *cs = find_column_stmt(columns, cname);
			sql_subtype *ctype = find_column_type(columns, cname);
			dlist *olist = n->next->data.lval;

			if (!cs || !ctype){
				return sql_error(sql, 02, "Column %s not found\n", cname);
			} else {
				list *l = list_create((fdestroy)&stmt_destroy);
				column_options(sql, olist, l, ss, ts, cs, cname, ctype);
				res = stmt_list(l);
			}
		} break;
	case SQL_LIKE:
		{
			list *newcolumns = create_stmt_list();
			char *name = qname_table(s->data.lval);
			sql_table *t = mvc_bind_table( sql, cur_schema(sql), name );
			node *n;

			for (n = t->columns.set->h; n; n = n->next ){ 
				sql_column *oc = n->data;
				stmt *sc = stmt_create_column(stmt_dup(ts), oc->base.name, oc->type->type->sqlname, oc->type->digits, oc->type->scale);
				list_append(newcolumns, sc);
			}
			res = stmt_list(newcolumns);
			stmt_destroy(ss);
			stmt_destroy(ts);
		} break;
	}
	if (!res) {
		return sql_error(sql, 02, 
			 "Unknown table element (%ld)->token = %s\n",
			 (long) s, token2string(s->token));
	}
	return res;
}

static stmt *create_table(mvc * sql, stmt * ss,
			int temp, dlist * qname, dlist * columns)
{
	char *name = qname_table(qname);

	if (mvc_bind_table(sql, cur_schema(sql), name)) {
		stmt_destroy(ss);
		return sql_error(sql, 02, 
			 "Create Table name %s allready in use", name);
	} else {
		char buf[BUFSIZ];

		table_type type = (temp)?tt_session:tt_base; 
		stmt *ts = stmt_create_table(ss, name, type);
		list *new_columns = list_append(create_stmt_list(), ts);
		list *tmp_columns = list_create((fdestroy)&destroy_tmp_col);
		dnode *n;

		for (n = columns->h; n; n = n->next) {
			stmt *te = table_element(sql, n->data.sym, 
				stmt_dup(ss), stmt_dup(ts), name, tmp_columns);
			if (!te){
				list_destroy(new_columns);
				return NULL;
			}
			list_append(new_columns, te );
		}
		list_destroy(tmp_columns);
		snprintf(buf, BUFSIZ, "grant all on '%s' to '%s' with grant option with hierarchy option;", name, sql->user);
		list_append( new_columns, stmt_sql(buf));
		return stmt_list(new_columns);
	}
}

static stmt *drop_table(mvc * sql, dlist * qname, int drop_action)
{
	stmt *res = NULL;
	char *tname = qname_table(qname);
	sql_table *t = mvc_bind_table(sql, cur_schema(sql), tname);

	if (!t) {
		return sql_error(sql, 02, 
			 "Drop Table, table %s unknown", tname);
	} else if (t->type != tt_view){
		stmt *ss = stmt_bind_schema( cur_schema(sql)->base.name );
		res = stmt_drop_table(ss, t->base.name, drop_action);
	} else {
		return sql_error(sql, 02, 
			 "Drop Table, cannot drop view %s ", tname);
	}
	return res;
}

static stmt *alter_table(mvc * sql, stmt *ss, dlist * qname, symbol * te)
{
	char *name = qname_table(qname);
	sql_table *table = NULL;

	if ((table = mvc_bind_table(sql, cur_schema(sql), name)) == NULL) {
		stmt_destroy(ss);
		return sql_error(sql, 02, 
			 "Alter Table name %s doesn't exist", name);
	} else {
		stmt *ts = stmt_bind_table(ss, table->base.name);
		list *tmp_columns = list_create((fdestroy)&destroy_tmp_col);
		stmt *c = create_column(sql, te, ss, ts, tmp_columns );
		list_destroy(tmp_columns);
		return c;
	}
}

static stmt *create_schema(mvc * sql, dlist * auth_name, dlist * schema_elements)
{
	char *name = schema_name(auth_name);
	char *auth = schema_auth(auth_name);

	if (auth == NULL) {
		auth = cur_schema(sql)->auth;
	}
	if (mvc_bind_schema(sql, name)) {
		return sql_error(sql, 02, 
			"Create Schema name %s allready in use", name);
	} else {
		stmt *st = stmt_create_schema(name, auth);
		list *schema_objects = list_append(create_stmt_list(), st);

		dnode *n = schema_elements->h;

		while (n) {
			if (n->data.sym->token == SQL_CREATE_TABLE) {
				dlist *l = n->data.sym->data.lval;
				st = create_table(sql, stmt_dup(st),
						  l->h->data.ival,
						  l->h->next->data.lval,
						  l->h->next->next->data.
						  lval);
			} else if (n->data.sym->token == SQL_CREATE_VIEW) {
				dlist *l = n->data.sym->data.lval;
				st = create_view(sql, stmt_dup(st),
						 l->h->data.lval,
						 l->h->next->data.lval,
						 l->h->next->next->data.
						 sym,
						 l->h->next->next->next->
						 data.ival);
			}
			list_append(schema_objects, st);
			n = n->next;
		}
		return stmt_list(schema_objects);
	}
}

static stmt *drop_schema(mvc * sql, dlist * qname, int dropaction)
{
	char *name = schema_name(qname);
	sql_schema *s = mvc_bind_schema( sql, name );

	if (!s) {
		return sql_error(sql, 02, 
			 "Drop Schema name %s does not exist", name);
	} else {
		return stmt_drop_schema(name, dropaction);
	}
}


static stmt *insert_value(mvc * sql, scope * scp, sql_column * c, symbol * s)
{
	if (s->token == SQL_NULL) {
		return stmt_atom(atom_general(sql_dup_subtype(c->type), NULL));
	} else {
		stmt *n = NULL;
		stmt *a = sql_value_exp(sql, scp, s, NULL, NULL);
		if (!a || !(n = check_types(sql, c->type, a)))
			return NULL;
		return n;
	}
	return NULL;
}

static void cleanup_stmts(stmt **stmts, int cnt){
	int i;
	for (i=0; i<cnt; i++){
		if (stmts[i])
			stmt_destroy(stmts[i]);
	}
	_DELETE(stmts);
}


static stmt *
insert_check_ukey( mvc * sql, stmt **inserts, sql_key *k, stmt *idx_inserts )
{
	char buf[BUFSIZ];
	stmt *res;
	group *g = NULL;

	sql_subtype *it = sql_bind_localtype( "int" );
	sql_subtype *lt = sql_bind_localtype( "lng" );
	sql_subaggr *cnt = sql_bind_aggr("count", NULL);
	sql_subtype *bt = sql_bind_localtype( "bit" );

	if (list_length(k->columns) > 1){
		node *m;
		stmt *s; 
		sql_subaggr *sum;
		stmt *count_sum = NULL;
	    	sql_subfunc *ne = sql_bind_func_result("<>", it, it, bt);

		/* 1st stage: find out if original contains same values */
		if (inserts[0]->op2.stval->key){
			s = stmt_relselect_init();
			stmt_relselect_fill( s, stmt_uselect(
				stmt_idxbat(k->idx,0), stmt_dup(idx_inserts), cmp_equal)); 
			for(m = k->columns->h; m; m = m->next) {
				sql_kc *c = m->data;
				stmt_relselect_fill( s, stmt_uselect(
					stmt_dup(inserts[c->c->colnr]->op1.stval), 
					stmt_dup(inserts[c->c->colnr]->op2.stval),
					cmp_equal));
			}
		} else {
			s = stmt_reljoin_init();
			stmt_reljoin_fill( s, 
				 	stmt_idxbat(k->idx,0), 
					stmt_dup(idx_inserts)); 
			for(m = k->columns->h; m; m = m->next) {
				sql_kc *c = m->data;
				stmt_reljoin_fill( s,
					stmt_dup(inserts[c->c->colnr]->op1.stval), 
					stmt_dup(inserts[c->c->colnr]->op2.stval));
			}
		}
		s = stmt_binop(stmt_aggr(s, NULL, cnt),
			stmt_atom(atom_int(sql_dup_subtype(it), 0)), ne);

		/* 2e stage: find out if inserted are unique */
		if (idx_inserts->nrcols){ /* insert columns not atoms */
		    	stmt *ss;
			sql_subfunc *or = sql_bind_func_result("or", bt, bt, bt);
		    	for(m = k->columns->h; m; m = m->next){
				sql_kc *c = m->data;
				g = grp_create(
					stmt_dup(inserts[c->c->colnr]->op2.stval),g);
			}
			ss = stmt_aggr(stmt_dup(g->grp), grp_dup(g), sql_dup_aggr(cnt));
			/* (count(ss) <> sum(ss)) */
			sum = sql_bind_aggr("sum", tail_type(ss));
			count_sum = stmt_binop( 
				check_types(sql, lt, stmt_aggr(stmt_dup(ss), NULL, sql_dup_aggr(cnt))),
				check_types(sql, lt, stmt_aggr(ss, NULL, sum)), 
				sql_dup_func(ne));

			/* combine results */
			s = stmt_binop(s, count_sum, or);
		}

		snprintf(buf, BUFSIZ, 
			"key constraint %s.%s failed", k->t->base.name, k->base.name ); 
		res = stmt_exception( s, buf, 00001 );
	} else { /* single column key */
		sql_kc *c = k->columns->h->data;
		stmt *h = stmt_dup(inserts[c->c->colnr]->op2.stval);	
		stmt *s = stmt_uselect( 
			stmt_dup(inserts[c->c->colnr]->op1.stval), h, cmp_equal);
		/* s should be empty */
		snprintf(buf, BUFSIZ, 
			"key constraint %s.%s failed", k->t->base.name, k->base.name ); 
		res = stmt_exception( stmt_aggr(s, NULL, cnt), buf, 00001); 
	}
	return res;
}

static stmt *
insert_check_fkey( mvc * sql, stmt **inserts, sql_key *k, stmt *idx_inserts )
{
	char buf[BUFSIZ];
	stmt *s;
	sql_subtype *it = sql_bind_localtype( "int" );
	sql_subaggr *cnt = sql_bind_aggr("count", NULL);
	sql_subtype *bt = sql_bind_localtype( "bit" );
	sql_subfunc *ne = sql_bind_func_result("<>", it, it, bt);

	(void)sql; /* unused! */

	if (inserts[0]->op2.stval->key){
		s = stmt_binop( 
			stmt_aggr(stmt_dup(idx_inserts), NULL, cnt), 
			stmt_atom(atom_int(sql_dup_subtype(it),1)), ne);
	} else {
		/* reljoin.count <> inserts[col1].count */
		s = stmt_binop( 
			stmt_aggr(stmt_dup(idx_inserts), NULL, cnt), 
			stmt_aggr(stmt_dup(inserts[0]->op2.stval), NULL, 
				sql_dup_aggr(cnt)) , ne);
	}

	/* s should be empty */
	snprintf(buf, BUFSIZ, 
		"key constraint %s.%s failed", k->t->base.name, k->base.name ); 
	return stmt_exception( s, buf, 00001 );
}

static stmt *
sql_insert_key(mvc * sql, stmt **inserts, sql_key *k, stmt *idx_inserts )
{
	/* int insert = 1;
	 * while insert and has u/pkey and not defered then
	 * 	if u/pkey values exist then
	 * 		insert = 0
	 * while insert and has fkey and not defered then
	 *	find id of corresponding u/pkey  
	 *	if (!found)
	 *		insert = 0
	 * if insert
	 * 	insert values
	 * 	insert fkey/pkey index
	 */
	if (k->type == pkey || k->type == ukey){
		return insert_check_ukey( sql, inserts, k, idx_inserts);
	} else { /* foreign keys */
		return insert_check_fkey( sql, inserts, k, idx_inserts);
	}
}

static stmt *
hash_insert( sql_idx *i, stmt **inserts )
{
	node *m;
	sql_subtype *it; 
	int bits = 0;
	stmt *h = NULL;

	if (list_length(i->columns) <= 1)
		return NULL;

	it = sql_bind_localtype( "int" );
	for(m = i->columns->h; m; m = m->next, bits += 8){
		sql_kc *c = m->data;
		sql_subfunc *hf = 
			sql_bind_func_result("hash", c->c->type, it, it);

		if (h){
			sql_subfunc *xor = 
				sql_bind_func_result("xor", it, it, it);
			h = stmt_binop(h, stmt_binop(
				stmt_dup(inserts[c->c->colnr]->op2.stval), 
				stmt_atom(atom_int(sql_dup_subtype(it), bits)), 
				hf), xor);
		} else {
			h = stmt_binop(
				stmt_dup(inserts[c->c->colnr]->op2.stval), 
				stmt_atom(atom_int(sql_dup_subtype(it), bits)), 
				hf);
		}
	}
	return h;
}

static stmt *
join_idx_insert( sql_idx *i, stmt **inserts )
{
	node *m, *o;
	sql_idx *ri = ((sql_fkey*)i->key)->rkey->k.idx;
	stmt *s = NULL, *rts = stmt_basetable(ri->t);

	if (inserts[0]->op2.stval->key){
		s = stmt_relselect_init();
	    	for(m = i->columns->h, o = ri->columns->h; m && o; 
			m = m->next, o = o->next) {
			sql_kc *c = m->data;
			sql_kc *rc = o->data;
			stmt_relselect_fill( s, stmt_uselect(
				stmt_dup(stmt_cbat(rc->c, stmt_dup(rts), 0, st_bat)), 
				stmt_dup(inserts[c->c->colnr]->op2.stval),
				cmp_equal));
		}
		/* append to the pre-computed join-index */
		s = stmt_mark(stmt_reverse(stmt_dup(s)), 0);
	} else {
		s = stmt_reljoin_init();
	    	for(m = i->columns->h, o = ri->columns->h; m && o; 
			m = m->next, o = o->next) {
			sql_kc *c = m->data;
			sql_kc *rc = o->data;
			stmt_reljoin_fill( s,
				stmt_dup(inserts[c->c->colnr]->op2.stval),
				stmt_dup(stmt_cbat(rc->c, stmt_dup(rts), 0, st_bat)));
		}
		/* append to the pre-computed join-index */
	}
	stmt_destroy(rts);
	return s;
}

static int
sql_insert_idxs(mvc * sql, sql_table *t, stmt **inserts, list *l)
{
	node *n;
	int res = 1;

	(void)sql; /* unused!? */
	
	if (!t->idxs.set)
		return res;

 	for(n = t->idxs.set->h; n; n = n->next){
	    	sql_idx *i = n->data;
		stmt *is = NULL;

		if (i->type == unique){
			is = hash_insert( i, inserts); 
		} else if (i->type == join_idx){
			is = join_idx_insert( i, inserts);
		}
		if (i->key){
			stmt *ckeys = sql_insert_key(sql, inserts, i->key, is);
			list_prepend(l, ckeys);
		}
		if (is) 
			list_append(l, stmt_append(stmt_idxbat(i,1), is));
	}
	return res;
}

static int 
is_idx_updated(sql_idx *i, stmt **updates )
{
	int update = 0;
	node *m;

	for(m = i->columns->h; m; m = m->next ){
		sql_kc *ic = m->data;
		
		if (!updates[ic->c->colnr]){
			update = ic->c->colnr;
			break;
		}
	}
	return update;
}

static int 
first_updated_col(stmt **updates, int cnt )
{
	int i;

	for(i = 0; i < cnt; i++) {
		if (updates[i])
			return i;
	}
	return -1;
}

static stmt *
update_check_ukey( mvc * sql, stmt **updates, sql_key *k, stmt *idx_updates, int updcol )
{
	char buf[BUFSIZ];
	stmt *res;
	group *g = NULL;

	sql_subtype *it = sql_bind_localtype( "int" );
	sql_subaggr *cnt = sql_bind_aggr("count", NULL);
	sql_subtype *bt = sql_bind_localtype( "bit" );

	if (list_length(k->columns) > 1){
		stmt *ts = stmt_basetable(k->t);
		node *m;
		stmt *s; 
		sql_subaggr *sum;
		stmt *count_sum = NULL;
	    	sql_subfunc *ne = sql_bind_func_result("<>", it, it, bt);

		/* 1st stage: find out if original contains same values */
		s = stmt_reljoin_init();
		stmt_reljoin_fill( s, 
			stmt_diff( stmt_idxbat(k->idx,0), stmt_dup(idx_updates)),
			stmt_dup(idx_updates)); 
		for(m = k->columns->h; m; m = m->next) {
			sql_kc *c = m->data;
			stmt *upd;
			if (updates[c->c->colnr]){
				upd = stmt_dup(updates[c->c->colnr]->op2.stval);
			} else {
				upd = stmt_dup(updates[updcol]->op2.stval);
				upd = stmt_semijoin(
					stmt_cbat(c->c, stmt_dup(ts), RDONLY, st_bat), 
					upd);
			}

			stmt_reljoin_fill( s,
				stmt_diff(
					stmt_dup(updates[c->c->colnr]->op1.stval), 
					stmt_dup(idx_updates)),
				upd);
		}
		s = stmt_binop(stmt_aggr(s, NULL, cnt),
			stmt_atom(atom_int(sql_dup_subtype(it), 0)), ne);

		/* 2e stage: find out if updated are unique */
		if (idx_updates->nrcols){ /* update columns not atoms */
		    	stmt *ss;
			sql_subfunc *or = sql_bind_func_result("or", bt, bt, bt);
		    	for(m = k->columns->h; m; m = m->next){
				sql_kc *c = m->data;
				stmt *upd;
				if (updates[c->c->colnr]){
					upd = stmt_dup(updates[c->c->colnr]->op2.stval);
				} else {
					upd = stmt_dup(updates[updcol]->op2.stval);
					upd = stmt_semijoin(
						stmt_cbat(c->c, 
							stmt_dup(ts), 
							RDONLY, 
							st_bat), 
						upd);
				}
				g = grp_create(upd,g);
			}
			ss = stmt_aggr(stmt_dup(g->grp), grp_dup(g), sql_dup_aggr(cnt));
			/* (count(ss) <> sum(ss)) */
			sum = sql_bind_aggr("sum", tail_type(ss));
			count_sum = stmt_binop( 
				stmt_aggr(stmt_dup(ss), NULL, sql_dup_aggr(cnt)), 
				check_types(sql, it, stmt_aggr(ss, NULL, sum)) , 
				sql_dup_func(ne));

			/* combine results */
			s = stmt_binop(s, count_sum, or);
		}

		snprintf(buf, BUFSIZ, 
			"key constraint %s.%s failed", k->t->base.name, k->base.name ); 
		res = stmt_exception( s, buf, 00001);
	} else { /* single column key */
		sql_kc *c = k->columns->h->data;
		stmt *h = stmt_dup( updates[c->c->colnr]->op2.stval ); 
		stmt *o = stmt_diff( 
				stmt_dup(updates[c->c->colnr]->op1.stval), 
				stmt_dup(updates[c->c->colnr]->op2.stval));	
		stmt *s = stmt_uselect( o, h, cmp_equal);
		/* s should be empty */
		snprintf(buf, BUFSIZ, 
			"key constraint %s.%s failed", k->t->base.name, k->base.name ); 
		res = stmt_exception( stmt_aggr(s, NULL, cnt), buf, 00001); 
	}
	return res;
}

static stmt *
update_check_fkey( mvc * sql, stmt **updates, sql_key *k, stmt *idx_updates, int updcol )
{
	char buf[BUFSIZ];
	stmt *s;
	sql_subtype *it = sql_bind_localtype( "int" );
	sql_subaggr *cnt = sql_bind_aggr("count", NULL);
	sql_subtype *bt = sql_bind_localtype( "bit" );
	sql_subfunc *ne = sql_bind_func_result("<>", it, it, bt);

	(void)sql; /* unused! */
	/* reljoin.count <> updates[updcol].count */
	s = stmt_binop( 
		stmt_aggr(stmt_dup(idx_updates), NULL, cnt), 
		stmt_aggr(stmt_dup(updates[updcol]->op2.stval), NULL, sql_dup_aggr(cnt)), 
		ne);

	/* s should be empty */
	snprintf(buf, BUFSIZ, 
		"key constraint %s.%s failed", k->t->base.name, k->base.name ); 
	return stmt_exception( s, buf, 00001 );
}

static stmt *
sql_update_key(mvc * sql, stmt **updates, sql_key *k, stmt *idx_updates, int updcol )
{
	if (k->type == pkey || k->type == ukey){
		return update_check_ukey( sql, updates, k, idx_updates, updcol);
	} else { /* foreign keys */
		return update_check_fkey( sql, updates, k, idx_updates, updcol);
	}
}

static stmt *
hash_update( sql_idx *i, stmt **updates, int updcol )
{
	/* calculate new value */
	node *m;
	sql_subtype *it;
	int bits = 0;
	stmt *h = NULL, *ts;

	if (list_length(i->columns) <= 1)
		return NULL;

	ts = stmt_basetable(i->t);
 	it = sql_bind_localtype( "int" );
	for(m = i->columns->h; m; m = m->next, bits += 8){
		sql_kc *c = m->data;
		sql_subfunc *hf = sql_bind_func_result("hash", c->c->type, it, it);
		stmt *upd;

		if (updates[c->c->colnr]){
			upd = stmt_dup(updates[c->c->colnr]->op2.stval);
		} else {
			upd = stmt_dup(updates[updcol]->op2.stval);
			upd = stmt_semijoin(
				stmt_cbat(c->c, stmt_dup(ts), RDONLY, st_bat), 
				upd);
		}
	
		if (h){
			sql_subfunc *xor = sql_bind_func_result("xor", it, it, it);
			h = stmt_binop(h, stmt_binop(upd, 
				stmt_atom(atom_int(sql_dup_subtype(it), bits)), hf), xor);
		} else {
			h = stmt_binop(upd, stmt_atom(
				atom_int(sql_dup_subtype(it), bits)), hf);
		}
	}
	stmt_destroy(ts);
	return h;
}

static stmt *
join_idx_update( sql_idx *i, stmt **updates, int updcol )
{
	node *m, *o;
	sql_idx *ri = ((sql_fkey*)i->key)->rkey->k.idx;
	stmt *s = NULL, *rts = stmt_basetable(i->t), *ts;

	ts = stmt_basetable(i->t);
	s = stmt_reljoin_init();
	for(m = i->columns->h, o = ri->columns->h; m && o; 
		m = m->next, o = o->next) {
		sql_kc *c = m->data;
		sql_kc *rc = o->data;
		stmt *upd;

		if (updates[c->c->colnr]){
			upd = stmt_dup(updates[c->c->colnr]->op2.stval);
		} else {
			upd = stmt_dup(updates[updcol]->op2.stval);
			upd = stmt_semijoin(
				stmt_cbat(c->c, stmt_dup(ts), RDONLY, st_bat), 
				upd);
		}
		stmt_reljoin_fill( s, upd,
			stmt_dup(stmt_cbat(rc->c, stmt_dup(rts), 0, st_bat)));
	}
	stmt_destroy(ts);
	stmt_destroy(rts);
	return s;
}

static int 
sql_update_idxs(mvc * sql, sql_table *t, stmt **updates, list *l)
{
	int res = 1;
	node *n;
	int updcol;

	(void)sql; 

	if (!t->idxs.set)
		return res;

	updcol = first_updated_col(updates, list_length(t->columns.set));
 	for(n = t->idxs.set->h; n; n = n->next){
	    	sql_idx *i = n->data;
	    	stmt *is = NULL;

		/* check if update is needed, 
		 * ie atleast on of the idx columns is updated 
		 */
		if ( is_idx_updated(i, updates) == 0)
			continue;

		if (i->type == unique){
			is = hash_update( i, updates, updcol); 
		} else if (i->type == join_idx){
			is = join_idx_update( i, updates, updcol);
		}
		if (is && i->key){
			stmt *ckeys = sql_update_key(sql, updates, i->key, is, updcol);
			list_prepend(l, ckeys);
		}
		if (is) 
			list_append( l, stmt_replace(stmt_idxbat(i,1), is));
	}
	return res;
}

static stmt *sql_insert(mvc * sql, sql_table *t, stmt **inserts, int len)
{
	char buf[BUFSIZ];
	int i;
	list *l = create_stmt_list();
	node *n;
	sql_subaggr *cnt = sql_bind_aggr("count", NULL);

	if (!sql_insert_idxs(sql, t, inserts, l)){
		return sql_error(sql, 02, 
			"Inserting into indexes failed for table %s",
			t->base.name);
	}

	for(n = t->columns.set->h; n; n = n->next){
		sql_column *c = n->data;

		if (!inserts[c->colnr]) {
			list_destroy(l);
			for (i = 0; i < len; i++) 
				stmt_destroy(inserts[i]);
			sql_subaggr_destroy( cnt );
			return NULL;
		}
		if (!c->null) {
			stmt *s = NULL;
			if (!inserts[c->colnr]->op2.stval->key){
				s = stmt_atom( atom_general(
					sql_dup_subtype(c->type), NULL));
				s = stmt_uselect( 
					stmt_dup(inserts[c->colnr]->op2.stval), 
					s, cmp_equal);
				s = stmt_aggr(s, NULL, sql_dup_aggr(cnt)); 
			} else {
				sql_subfunc *isnil = 
					sql_bind_func("isnull", c->type, NULL );
				s = stmt_unop(
					stmt_dup(inserts[c->colnr]->op2.stval), 
 					isnil);
			}
			snprintf(buf, BUFSIZ, 
				"null constraint %s.%s failed", 
				c->t->base.name, c->base.name ); 
			s = stmt_exception( s, buf, 00001); 
			
			list_prepend(l, s);
		}
	}

	sql_subaggr_destroy( cnt );
	for (i = 0; i < len; i++) 
		list_append(l, inserts[i]);
	/* TODO rows = stmt_dup(inserts[0]) */
	return stmt_list(l);
}

static stmt *insert_into(mvc * sql, dlist * qname,
			 dlist * columns, symbol * val_or_q)
{
	scope *scp;
	tvar *tv = NULL;

	sql_schema *s = qname_schema(sql, qname);
	char *tname = qname_table(qname);
	sql_table *t;
	list *collist = NULL;
	int i, len = 0;
	stmt **inserts, *res = NULL;

	if (!s || (t = mvc_bind_table(sql, s, tname)) == NULL) {
		return sql_error(sql, 02, 
			"Inserting into non existing table %s", tname);
	}
	if (!table_privs(sql, t, PRIV_INSERT)){
		return sql_error(sql, 02, 
			"User is not allowed to insert into table %s", tname);
	}
	if (columns) {
		dnode *n;

		collist = list_create((fdestroy)NULL);
		for (n = columns->h; n; n = n->next ) {
			sql_column *c = mvc_bind_column(sql, t, n->data.sval);
			if (c) {
				list_append(collist, c);
			} else {
				return sql_error(sql, 02, "Inserting into non existing column %s.%s", tname, n->data.sval);
			}
		}
	} else {
		collist = t->columns.set;
	}

	len = list_length(t->columns.set);
	inserts = NEW_ARRAY(stmt *, len);
	for (i = 0; i < len; i++)
		inserts[i] = NULL;

	scp = scope_open(NULL);
	tv = scope_add_table_columns(sql, scp, t, t->base.name);

	if (val_or_q->token == SQL_VALUES) {
		dlist *values = val_or_q->data.lval;
		if (dlist_length(values) != list_length(collist)) {
			scp = scope_close(scp);
			return sql_error(sql, 02, 
				 "Inserting into table %s, number of values doesn't match number of columns", tname);
		} else {
			dnode *n;
			node *m;

			for (n = values->h, m = collist->h;
			     n && m; n = n->next, m = m->next) {
				sql_column *c = m->data;
				stmt *ins = insert_value(sql, NULL, c, n->data.sym);
				if (!ins){
					cleanup_stmts(inserts, len);
					return NULL;
				}
					
				inserts[c->colnr] = stmt_append( stmt_cbat(c, stmt_dup(tv->s), INS, st_bat), ins );
			}

		}
		for(i=0; i<len; i++){
			if (!inserts[i]){
				node *m;
				for(m = t->columns.set->h; m; m = m->next){
					sql_column *c = m->data;
					if (c->colnr == i)
						inserts[i] = stmt_append( stmt_cbat(c, stmt_dup(tv->s), INS, st_bat), stmt_atom(atom_general(sql_dup_subtype(c->type), _strdup(c->def))) );
				}
			}
		}
	} else {
		stmt *s = sql_subquery(sql, NULL, val_or_q);

		if (!s){
			scp = scope_close(scp);
			cleanup_stmts(inserts, len);
			return NULL;
		}
		if (list_length(s->op1.lval) != list_length(collist)) {
			if (s) 
				stmt_destroy(s);
			scp = scope_close(scp);
			cleanup_stmts(inserts, len);
			return sql_error(sql, 02, 
				 "Inserting into table %s, query result doesn't match number of columns", tname);
		} else {
			node *m, *n;

			for (n = s->op1.lval->h, m = collist->h;
			     n && m; n = n->next, m = m->next) {
				sql_column *c = m->data;
				inserts[c->colnr] = stmt_append( stmt_cbat(c, stmt_dup(tv->s), INS, st_bat), stmt_dup(n->data));
			}
		}
		if (s) 
			stmt_destroy(s);
	}
	if (collist != t->columns.set)
		list_destroy(collist);
	res = sql_insert(sql, t, inserts, len);
	scp = scope_close(scp);
	_DELETE(inserts);
	return res;
}

static stmt *sql_bulkinsert(mvc * sql, sql_table *t, char *tsep, char *rsep, char *filename, int nr )
{
	sql_subtype *strtype = sql_bind_localtype( "str" );
	stmt *bats = NULL;
	stmt *fname = (filename)?stmt_atom(atom_string(
			sql_dup_subtype(strtype), _strdup(filename))):NULL;
	node *n;
	int i, len = 0;
	stmt **inserts, *res = NULL;
	
	scope *scp = scope_open(NULL);
	tvar *tv  = scope_add_table_columns(sql, scp, t, t->base.name);

	bats = stmt_bulkinsert(stmt_basetable(t), tsep, rsep, fname, nr);
	len = list_length(t->columns.set);
	inserts = NEW_ARRAY(stmt *, len);
	for(n=t->columns.set->h, i = 0; n; n = n->next, i++){
		sql_column *c = n->data;
		inserts[i] = stmt_append( 
		  stmt_cbat(c, stmt_dup(tv->s), INS, st_bat), 
		    stmt_find(stmt_dup(bats), stmt_atom(atom_string(
				sql_dup_subtype(strtype), 
				_strdup(c->base.name)))));
	}
	stmt_destroy(bats);
	res = sql_insert(sql, t, inserts, len);
	scp = scope_close(scp);
	_DELETE(inserts);
	return res;
}

static stmt *copyfrom(mvc * sql, dlist * qname, dlist *files, dlist *seps, int nr)
{
	char *tname = qname_table(qname);
	sql_table *t = mvc_bind_table(sql, cur_schema(sql), tname);
	char *tsep = seps->h->data.sval;
	char *rsep = seps->h->next->data.sval;
	list *slist;

	if (!t) {
		return sql_error(sql, 02, 
				"Copy into non existing table %s", tname);
	} else if (files){
		dnode *n = files->h;
		for (slist = create_stmt_list(); n; n = n->next){
			char *fname = n->data.sval;
			list_append(slist, 
				sql_bulkinsert( sql, t, tsep, rsep, fname, nr));
		}
		return stmt_list(slist);
	}
 	slist = create_stmt_list();
	list_append(slist, stmt_senddata());
	list_append(slist, sql_bulkinsert( sql, t, tsep, rsep, NULL, nr ));
	return stmt_list(slist);
}


static stmt *sql_update(mvc * sql, sql_table *t, stmt **updates, list *l )
{
	char buf[BUFSIZ];
	node *n;
	sql_subaggr *cnt = sql_bind_aggr("count", NULL);

	if (!sql_update_idxs(sql, t, updates, l)){
		return sql_error(sql, 02, 
			"Updating indexes failed for table %s",
			t->base.name);
	}

	for(n = t->columns.set->h; n; n = n->next){
		sql_column *c = n->data;

		if (updates[c->colnr] && !c->null) {
			stmt *s = NULL;
			if (!updates[c->colnr]->op2.stval->key){
				s = stmt_atom( atom_general(
					sql_dup_subtype(c->type), NULL));
				s = stmt_uselect( 
					stmt_dup(updates[c->colnr]->op2.stval), 
					s, cmp_equal);
				s = stmt_aggr(s, NULL, sql_dup_aggr(cnt)); 
			} else {
				sql_subfunc *isnil = 
					sql_bind_func("isnull", c->type, NULL );
				s = stmt_unop(
					stmt_dup(updates[c->colnr]->op2.stval), 
 					isnil);
			}
			snprintf(buf, BUFSIZ, 
				"null constraint %s.%s failed", 
				c->t->base.name, c->base.name ); 
			s = stmt_exception( s, buf, 00001); 
			
			list_prepend(l, s);
		}
	}
	sql_subaggr_destroy( cnt );
	return stmt_list(l);
}

static stmt *update_table(mvc * sql, dlist * qname,
			dlist * assignmentlist, symbol * opt_where)
{
	stmt *s = NULL;
	char *tname = qname_table(qname);
	sql_table *t = mvc_bind_table(sql, cur_schema(sql), tname);

	if (!t) {
		return sql_error(sql, 02, "Updating non existing table %s", tname);
	} else {
		int len = 0, i = 0;
		tvar *tv = NULL;
		dnode *n;
		list *l;
		scope *scp;
		stmt **updates;

		scp = scope_open(NULL);
		tv = scope_add_table_columns(sql, scp, t, t->base.name);

		if (opt_where){
			s = sql_logical_exp(sql, scp, opt_where, NULL, NULL);
			if (s) 
				s = stmt2pivot(scp,s);
			if (!s){
				scope_close(scp);
			       	return NULL;
			}
		} else { /* update all */
			cvar *c = tv->columns->h->data;
			s = stmt2pivot(scp,stmt_dup(c->s));
		}
	       	l = create_stmt_list();

		len = list_length(t->columns.set);
		updates = NEW_ARRAY(stmt *, len);
		for (i = 0; i < len; i++)
			updates[i] = NULL;

		for( n = assignmentlist->h, i=0; n; n = n->next, i++ ){
			symbol *a = NULL;
			stmt *v = NULL;
			dlist *assignment = n->data.sym->data.lval;
			char *cname = assignment->h->data.sval;
			cvar *cl = scope_bind_column(scp, NULL, cname);
			sql_column *c = NULL;

			if (!cl) {
				stmt_destroy(s);
				list_destroy(l);
				return sql_error(sql, 02, 
				  "Updating non existing column %s.%s",
					 tname, assignment->h->data.sval);
			}
			a = assignment->h->next->data.sym;
			if (a)
				v = sql_value_exp(sql, scp, a, NULL, s);
			else 
				v = stmt_atom(atom_general(
					sql_dup_subtype(tail_type(cl->s)), 
					NULL));

			if (!v) {
				stmt_destroy(s);
				list_destroy(l);
				cleanup_stmts(updates, len);
				return NULL;
			}

			v = check_types(sql, tail_type(cl->s), v);

			if (v->nrcols <= 0){
				v = stmt_const(
				  stmt_reverse(s ? first_subset(s) : stmt_dup(cl->s)), v);
			}

			c = basecolumn(cl->s);
			updates[c->colnr] = stmt_replace( stmt_cbat(c, stmt_dup(tv->s), UPD, st_bat), v);
			list_append(l, updates[c->colnr] );
			list_append(l, stmt_insert( stmt_cbat(c, stmt_dup(tv->s), UPD, st_ubat), stmt_dup(v)));
			/* TODO rows = count(stmt_dup(v)) */
		}
		if (s) stmt_destroy(s);
	
		if ((s = sql_update( sql, t, updates, l)) == NULL){
			_DELETE(updates);
			list_destroy(l);
			return NULL;
		}
		_DELETE(updates);
		scp = scope_close(scp);
		return s;
	}
	return NULL;
}

static int
sql_delete_idxs(mvc * sql, sql_table *t, stmt *vals, list *l)
{
	node *n;
	int res = 1;

	(void)sql; /* unused!? */

	for(n = t->idxs.set->h; n; n = n->next){
		sql_idx *i = n->data;
		sql_subtype *it = NULL;
		stmt *v = NULL;

		if (i->type == unique && list_length(i->columns) <= 1)
			continue;
		
		if (i->type == unique) {
			it = sql_bind_localtype( "int" );
		} else if (i->type == join_idx){
			it = sql_bind_localtype( "oid" );
		}

		assert(it);
		v = stmt_const( stmt_reverse( first_subset(vals)), 
			stmt_atom(atom_general(sql_dup_subtype(it), NULL)));
		list_append(l, stmt_replace( stmt_idxbat(i, 1), v));
	}
	return res;
}


static stmt *
sql_delete( mvc *sql, tvar *tv, sql_table *t, stmt *s )
{
	node *n;
	list *l = create_stmt_list();
	sql_subtype *to	= sql_bind_subtype("OID", 0, 0);
	stmt *v = stmt_const( stmt_reverse(first_subset(s)), 
				stmt_atom(atom_general(to, NULL)));

	list_append(l, stmt_append(
			stmt_tbat(basetable_table(tv->s), INS ),
			stmt_reverse(v)));
	for(n = t->columns.set->h; n; n = n->next){
		sql_column *c = n->data;
		stmt *v = stmt_const( stmt_reverse( first_subset(s)), 
			stmt_atom(atom_general(sql_dup_subtype(c->type), NULL)));
		list_append(l, stmt_replace( stmt_cbat(c, stmt_dup(tv->s), DEL, st_bat), v));
	}
	/* TODO rows = count(stmt_dup(v)) */

	if (t->idxs.set && !sql_delete_idxs(sql, t, s, l )){
		list_destroy(l);
		return sql_error(sql, 02, 
			"Deleting from indexes failed for table %s",
			t->base.name);
	}
	stmt_destroy(s);
	return stmt_list(l);
}

static stmt *delete_table(mvc * sql, dlist * qname, symbol * opt_where)
{
	char *tname = qname_table(qname);
	sql_table *t = mvc_bind_table(sql, cur_schema(sql), tname);

	if (!t) {
		return sql_error(sql, 02, 
			 "Deleting from non existing table %s", tname);
	}
	if (!table_privs(sql, t, PRIV_DELETE)){
		return sql_error(sql, 02, 
			"User is not allowed to delete from table %s", tname);
	} else {
		tvar *tv = NULL;
		stmt  *s = NULL;
		scope *scp = scope_open(NULL);

		tv = scope_add_table_columns(sql, scp, t, t->base.name);

		if (opt_where){
			s = sql_logical_exp(sql, scp, opt_where, NULL, NULL);
			if (s) 
				s = stmt2pivot(scp,s);
			if (!s){
				scope_close(scp);
			       	return NULL;
			}
		} else { /* delete all */
			cvar *c = tv->columns->h->data;
			s = stmt2pivot(scp,stmt_dup(c->s));
		}

		assert (isbasetable(tv->s));
		s = sql_delete(sql, tv, t, s);

		scp = scope_close(scp);
		return s;
	}
	return NULL;
}

static stmt *grant_roles(mvc * sql, sql_schema *schema,
		dlist * roles, dlist * grantees, int grant, int grantor)
{
	/* grant roles to the grantees */
	dnode *r, *g;
	list *l = create_stmt_list();
	(void) sql; (void) schema; (void) grant; (void) grantor; /* Stefan: unused!? */
	
	for( r = roles->h; r; r = r->next ){
		char *role = r->data.sval;

		/*
		role_id = relproject(relselect(auths, role),id);
		exception(count(role_id) == 0), "Role %s not found !", role;
		*/
		for( g = grantees->h; g; g = g->next ){
			char *grantee = g->data.sval;

			/* 
			   grantee_id = relproject(relselect(auths,grantee),id);
			   exception (count(grantee_id) == 0), "User/role %s not found !", grantee;
			   r = relselect(role_user,role_id,grantee_id)
			   exception(count(r) > 0), "Role (%s,%s) allready granted", role, grantee;
			   relinsert(role_user,role_id,grantee_id,grantor,grant);
			 */ 
			list_append(l, stmt_grant_role(grantee, role) );
		}
	}
	return stmt_list(l);
}

static stmt *revoke_roles(mvc * sql, sql_schema *schema,
		dlist * roles, dlist * grantees, int admin, int grantor)
{
	/* revoke roles from the grantees */
	dnode *r, *g;
	list *l = create_stmt_list();
	(void) sql; (void) schema; (void) admin; (void) grantor; /* Stefan: unused!? */
	
	for( r = roles->h; r; r = r->next ){
		char *role = r->data.sval;
		for( g = grantees->h; g; g = g->next ){
			char *grantee = g->data.sval;
			list_append(l, stmt_revoke_role(grantee, role) );
		}
	}
	return stmt_list(l);
}

static stmt *
sql_insert_priv( mvc *sql, int auth_id, int obj_id, 
	int privilege, int grantor, int grantable, int hierarchy)
{
	sql_schema *ss = mvc_bind_schema( sql, "sys");
	sql_table *pt = mvc_bind_table( sql, ss, "privileges" );
	node *n = pt->columns.set->h;
	stmt *inserts[6];
	stmt *pts = stmt_bind_table( stmt_bind_schema( "sys" ), "privileges" );

	inserts[0] = stmt_append(stmt_cbat(n->data, stmt_dup(pts), INS, st_bat),
 			stmt_atom_int(obj_id));
	n = n->next;
	inserts[1] = stmt_append(stmt_cbat(n->data, stmt_dup(pts), INS, st_bat),
 			stmt_atom_int(auth_id));
	n = n->next;
	inserts[2] = stmt_append(stmt_cbat(n->data, stmt_dup(pts), INS, st_bat),
 			stmt_atom_int(privilege));
	n = n->next;
	inserts[3] = stmt_append(stmt_cbat(n->data, stmt_dup(pts), INS, st_bat),
 			stmt_atom_int(grantor));
	n = n->next;
	inserts[4] = stmt_append(stmt_cbat(n->data, stmt_dup(pts), INS, st_bat),
 			stmt_atom_int(grantable));
	n = n->next;
	inserts[5] = stmt_append(stmt_cbat(n->data, stmt_dup(pts), INS, st_bat),
 			stmt_atom_int(hierarchy));
	stmt_destroy(pts);
	return sql_insert(sql, pt, inserts, 6);
}

void
sql_insert_all_privs( mvc *sql, int auth_id, int obj_id, 
			int grantor, int grantable, int hierarchy, list *l) 
{
	list_append(l, sql_insert_priv( sql, auth_id, obj_id, PRIV_SELECT, 
		grantor, grantable, hierarchy ));
	list_append(l, sql_insert_priv( sql, auth_id, obj_id, PRIV_UPDATE, 
		grantor, grantable, hierarchy ));
	list_append(l, sql_insert_priv( sql, auth_id, obj_id, PRIV_INSERT, 
		grantor, grantable, hierarchy ));
	list_append(l, sql_insert_priv( sql, auth_id, obj_id, PRIV_DELETE, 
		grantor, grantable, hierarchy ));
}

const char *
priv2string( int priv )
{
	switch(priv) {
	case PRIV_SELECT: return "SELECT";
	case PRIV_UPDATE: return "UPDATE";
	case PRIV_INSERT: return "INSERT";
	case PRIV_DELETE: return "DELETE";
	case PRIV_EXECUTE: return "EXECUTE";
	}
	return "UNKNOWN PRIV";
}

static stmt *
grant_table( mvc *sql, sql_schema *cur, dlist *privs, char *tname,  
	dlist *grantees, int grant, int hierarchy, int grantor )
{
	dnode *gn;
	sql_table *t = mvc_bind_table( sql, cur, tname );
	list *l;

	if (!t) {
		return sql_error(sql, 02, 
			 "GRANT Table name %s doesn't exist", tname);
	}
		
 	l = create_stmt_list();
	if (privs == NULL){ /* ALL [ PRIVILEGES ] */
		int all = PRIV_SELECT|PRIV_UPDATE|PRIV_INSERT|PRIV_DELETE;
		int allowed = sql_grantable( sql, grantor, t->s->base.id, all, 1);

		if (!allowed)
			allowed = sql_grantable( sql, grantor, t->base.id, all,0);
		if (!allowed){
			list_destroy(l);
			return sql_error(sql, 02, 
				 "GRANTOR %s is not allowed to grant ALL privileges for table %s", sql->user, tname);
		}

		for ( gn = grantees->h; gn; gn = gn->next ) {
			char *grantee = gn->data.sval;
			int grantee_id = sql_find_auth(sql, grantee);

			if (grantee_id < 0){
				list_destroy(l);
				return sql_error(sql, 02,
					"User/Role %s unknown", grantee);
			}
			sql_insert_all_privs(sql, grantee_id, t->base.id, grantor, grant, hierarchy, l);
		}
		return stmt_list(l);
	}
	for ( gn = grantees->h; gn; gn = gn->next ) {
		dnode *opn;
		char *grantee = gn->data.sval;
		int grantee_id = sql_find_auth(sql, grantee);

		if (grantee_id < 0){
			list_destroy(l);
			return sql_error(sql, 02, 
				"User/Role %s unknown", grantee);
		}

		for ( opn = privs->h; opn; opn = opn->next ){
			symbol *op = opn->data.sym;
			int priv = PRIV_SELECT;

			switch(op->token) {
			case SQL_SELECT: priv = PRIV_SELECT; break;
			case SQL_UPDATE: priv = PRIV_UPDATE; break;

			case SQL_INSERT: priv = PRIV_INSERT; break;
			case SQL_DELETE: priv = PRIV_DELETE; break;

			case SQL_EXECUTE:
			default:
				list_destroy(l);
				return sql_error(sql, 02, 
			 		"Cannot GRANT EXECUTE on table name %s",
					tname);
			}

			if ((op->token == SQL_SELECT || 
			     op->token == SQL_UPDATE) && op->data.lval){
				dnode *cn;

				for(cn = op->data.lval->h; cn; cn = cn->next) {
					char *cname = cn->data.sval;
					sql_column *c=0;

					int allowed = sql_grantable( sql, 
						grantor, t->s->base.id, 
						priv, 1);

					if (!allowed)
						allowed = sql_grantable( sql, 
							grantor, 
							t->base.id, priv, 1);
					if (!allowed)
						allowed = sql_grantable( sql, 
							grantor, 
							c->base.id, priv, 0);
					if (!allowed) {
						list_destroy(l);
						return sql_error(sql, 02, 
				 			"GRANTOR %s is not allowed to grant privilege %s for table %s", sql->user, priv2string(priv), tname);
					}

					c = mvc_bind_column( sql, t, cname );
					if (!c) {
						list_destroy(l);
						return sql_error(sql, 02, 
			 				"Grant: table %s has no column %s", tname, cname);
					}
		     			list_append(l, sql_insert_priv( 
						sql, grantee_id, 
						c->base.id, priv, 
						grantor, grant, hierarchy ));
				}
			} else {
				int allowed = sql_grantable( sql, grantor, 
					t->s->base.id, priv, 1);

				if (!allowed)
					allowed = sql_grantable( sql, grantor, 
						t->base.id, priv, 0);
				if (!allowed) {
					list_destroy(l);
					return sql_error(sql, 02, 
				 		"GRANTOR %s is not allowed to grant privilege %s for table %s", sql->user, priv2string(priv), tname);
				}

				list_append(l, sql_insert_priv( sql, 
					grantee_id, t->base.id, priv, 
					grantor, grant, hierarchy ));
			}
		}
	}
	return stmt_list(l);
}

static stmt *
grant_func( mvc *sql, sql_schema *cur, dlist *privs, char *fname,  
	dlist *grantees, int grant, int hierarchy, int grantor )
{
/* todo */
	(void)sql;
	(void)cur;
	(void)privs;
	(void)fname;
	(void)grantees;
	(void)grant;
	(void)hierarchy;
	(void)grantor;
	return NULL;
}


static stmt *grant_privs(mvc *sql, sql_schema *cur, 
	dlist *privs, dlist *grantees, 
	int grant, int hierarchy, int grantor )
{
	dlist *obj_privs = privs->h->data.lval;
	symbol *obj      = privs->h->next->data.sym;
	int token = obj->token;
	
	if (token == SQL_NAME)
		if (mvc_bind_table(sql, cur, obj->data.sval) != NULL)	
			token = SQL_TABLE;

	switch(token){
	case SQL_TABLE:
		return
		grant_table( sql, cur, obj_privs, obj->data.sval, grantees,
				grant, hierarchy, grantor );
	case SQL_NAME:
		return
		grant_func( sql, cur, obj_privs, obj->data.sval, grantees,
				grant, hierarchy, grantor );
	default: 
		return sql_error(sql, 02, "Grant: unknown token %d", token );
	}
	return NULL;
}
	
static stmt *
sql_delete_priv( mvc *sql, int auth_id, int obj_id, 
	int privilege, int grantor, int grantable, int hierarchy)
{
	sql_schema *ss = mvc_bind_schema( sql, "sys");
	sql_table *pt = mvc_bind_table( sql, ss, "privileges" );
	node *n = pt->columns.set->h;

	stmt *pts = stmt_bind_table( stmt_bind_schema( "sys" ), "privileges" );
	stmt *s = stmt_relselect_init();
	scope *scp = scope_open(NULL);
	tvar *ptv = scope_add_table_columns(sql, scp, pt, pt->base.name);

	(void)grantor;
	(void)grantable;
	(void)hierarchy;

	stmt_relselect_fill( s, stmt_uselect(
		stmt_cbat(n->data, stmt_dup(pts), RDONLY, st_bat),
 			stmt_atom_int(auth_id), cmp_equal));
	n = n->next;
	stmt_relselect_fill( s, stmt_uselect(
		stmt_cbat(n->data, stmt_dup(pts), RDONLY, st_bat),
 			stmt_atom_int(privilege), cmp_equal));
	n = n->next;
	stmt_relselect_fill( s, stmt_uselect(
		stmt_cbat(n->data, stmt_dup(pts), RDONLY, st_bat),
 			stmt_atom_int(obj_id), cmp_equal));
	
	s = sql_delete(sql, ptv, pt, s);
	scope_close(scp);
	return s;
}

static stmt *
revoke_table( mvc *sql, sql_schema *cur, dlist *privs, char *tname,  
	dlist *grantees, int grant, int hierarchy, int grantor )
{
	dnode *gn;
	sql_table *t = mvc_bind_table( sql, cur, tname );
	list *l;

	if (!t) {
		return sql_error(sql, 02, 
			 "REVOKE Table name %s doesn't exist", tname);
	}
		
	/* TODO 
	if (grant)
		do update !
	if (hierarchy)
		do update !
	if (grant || hierarchy)
		return
	 */
 	l = create_stmt_list();
	if (privs == NULL){ /* ALL [ PRIVILEGES ] */
		for ( gn = grantees->h; gn; gn = gn->next ) {
			char *grantee = gn->data.sval;
			int grantee_id = sql_find_auth(sql, grantee);

			if (grantee_id < 0){
				list_destroy(l);
				return sql_error(sql, 02,
					"User/Role %s unknown", grantee);
			}

		     	list_append(l, sql_delete_priv( sql, grantee_id, 
				t->base.id, PRIV_SELECT, grantor, grant, 
				hierarchy ));
		     	list_append(l, sql_delete_priv( sql, grantee_id, 
				t->base.id, PRIV_UPDATE, grantor, grant, 
				hierarchy ));
		     	list_append(l, sql_delete_priv( sql, grantee_id, 
				t->base.id, PRIV_INSERT, grantor, grant, 
				hierarchy ));
		     	list_append(l, sql_delete_priv( sql, grantee_id, 
				t->base.id, PRIV_DELETE, grantor, grant,
				hierarchy ));
			/* TODO if hierarchy also delete all sub objects 
				(ie columns) with these privs */
		}
		return stmt_list(l);
	}
	for ( gn = grantees->h; gn; gn = gn->next ) {
		char *grantee = gn->data.sval;
		int grantee_id = sql_find_auth(sql, grantee);
		dnode *opn;

		if (grantee_id < 0){
			list_destroy(l);
			return sql_error(sql, 02, 
				"User/Role %s unknown", grantee);
		}

		for ( opn = privs->h; opn; opn = opn->next ){
			symbol *op = opn->data.sym;
			int priv = PRIV_SELECT;

			switch(op->token) {
			case SQL_SELECT: priv = PRIV_SELECT; break;
			case SQL_UPDATE: priv = PRIV_UPDATE; break;

			case SQL_INSERT: priv = PRIV_INSERT; break;
			case SQL_DELETE: priv = PRIV_DELETE; break;

			case SQL_EXECUTE:
			default:
				list_destroy(l);
				return sql_error(sql, 02, 
			 		"Cannot GRANT EXECUTE on table name %s",
					tname);
			}

			if ((op->token == SQL_SELECT || 
			     op->token == SQL_UPDATE) && op->data.lval){
				dnode *cn;

				for(cn = op->data.lval->h; cn; cn = cn->next) {
					char *cname = cn->data.sval;
					sql_column *c;

					c = mvc_bind_column( sql, t, cname );
					if (!c) {
						list_destroy(l);
						return sql_error(sql, 02, 
			 				"Grant: table %s has no column %s", tname, cname);
					}
		     			list_append(l, sql_delete_priv( 
						sql, grantee_id, 
						c->base.id, priv, 
						grantor, grant, hierarchy ));
				}
			} else {
				list_append(l, sql_delete_priv( sql, 
					grantee_id, t->base.id, priv, 
					grantor, grant, hierarchy ));
			}
		}
	}
	return stmt_list(l);
}

static stmt *
revoke_func( mvc *sql, sql_schema *cur, dlist *privs, char *fname,  
	dlist *grantees, int grant, int hierarchy, int grantor )
{
/* todo */
	(void)sql;
	(void)cur;
	(void)privs;
	(void)fname;
	(void)grantees;
	(void)grant;
	(void)hierarchy;
	(void)grantor;
	return NULL;
}

static stmt *revoke_privs(mvc *sql, sql_schema *cur, 
	dlist *privs, dlist *grantees, 
	int grant, int hierarchy, int grantor )
{
	dlist *obj_privs = privs->h->data.lval;
	symbol *obj      = privs->h->next->data.sym;
	int token = obj->token;
	
	if (token == SQL_NAME)
		if (mvc_bind_table(sql, cur, obj->data.sval) != NULL)	
			token = SQL_TABLE;

	switch(token){
	case SQL_TABLE:
		return
		revoke_table( sql, cur, obj_privs, obj->data.sval, grantees,
				grant, hierarchy, grantor );
	case SQL_NAME:
		return
		revoke_func( sql, cur, obj_privs, obj->data.sval, grantees,
				grant, hierarchy, grantor );
	default: 
		return sql_error(sql, 02, "Grant: unknown token %d", token );
	}
	return NULL;
}


static stmt *create_module(mvc * sql, dlist *qname ){
	char *mname = qname_table(qname);
	(void)sql;
	return stmt_create_module(mname);
}

static stmt *drop_module(mvc * sql, dlist *qname ){
	char *mname = qname_table(qname);
	(void)sql;
	return stmt_drop_module(mname);
}

static stmt *create_type(mvc * sql, dlist * qname, char *impl ){
	char *tname = qname_table(qname);
	(void)sql;

	sql_create_type(tname, 0, 0, 0, impl);
	return stmt_none();
}

static stmt *create_func(mvc * sql, dlist * qname, dlist *params, sql_subtype *res, char *impl, symbol *body ){
	char *fname = qname_table(qname);
	dnode *n;
	list *l = list_create((fdestroy)&arg_destroy);

	for(n=params->h; n; n = n->next){ 
		dnode *an = n->data.lval->h;
		list_append(l, 
			sql_create_arg( 
				_strdup(an->data.sval),
				sql_dup_subtype(an->next->data.typeval)));
	}
	if (body){ /* sql func */
		char *subquery = strfnd(sql->scanner.sql, " as ");
		stmt *b = NULL;
		
		for(n=params->h; n; n = n->next){ 
			dnode *m = n->data.lval->h;
			char *name = _strdup(m->data.sval);
			sql_subtype *t = sql_dup_subtype(m->next->data.typeval);
			sql_add_param(sql, name, stmt_var(_strdup(name), t ) );
		}
		if (!(b = sql_subquery(sql, NULL, body))){
			sql_destroy_params(sql);
 			return NULL;
		}
		sql_destroy_params(sql);
		stmt_destroy(b);
		
		sql_create_sqlfunc(fname, subquery, l, sql_dup_subtype(res));
	} else {
		sql_create_func_(fname, impl, l, sql_dup_subtype(res));
	}
	return stmt_none();
}

static stmt *sql_stmt(mvc * sql, symbol * s)
{
	sql_schema *cur = cur_schema(sql);
	stmt *ret = NULL;
	switch (s->token) {

	case SQL_RELEASE:{
			ret = stmt_release(s->data.sval);
		}
		break;
	case SQL_COMMIT:{
			ret = stmt_commit(s->data.ival, NULL);
		}
		break;
	case SQL_SAVEPOINT:{
			ret = stmt_commit(0, s->data.sval);
		}
		break;
	case SQL_ROLLBACK:{
			dlist *l = s->data.lval;
			ret = stmt_rollback(l->h->data.ival,
					    l->h->next->data.sval);
		}
		break;

	case SQL_CREATE_SCHEMA:
		{
			dlist *l = s->data.lval;
			ret = create_schema(sql, 
				l->h->data.lval, /* qname (name.authid) */
				l->h->next->next->next->data.lval /* schema_elements */);
			sql->type = Q_SCHEMA;
		}
		break;
	case SQL_DROP_SCHEMA:
		{
			dlist *l = s->data.lval;
			ret = drop_schema(sql, 
				l->h->data.lval, /* qname */
				l->h->next->next->data.ival); /* drop_action */
			sql->type = Q_SCHEMA;
		}
		break;
	case SQL_DROP_TABLE:
		{
			dlist *l = s->data.lval;
			ret = drop_table(sql, l->h->data.lval,
				         l->h->next->data.ival);
			sql->type = Q_SCHEMA;
		}
		break;
	case SQL_DROP_VIEW:
		{
			dlist *l = s->data.lval;
			ret = drop_view(sql, l);
			sql->type = Q_SCHEMA;
		}
		break;
	case SQL_CREATE_TABLE:
		{
			
			stmt *ss = stmt_bind_schema(cur->base.name);
			dlist *l = s->data.lval;
			ret = create_table(sql, ss,
					   l->h->data.ival,
					   l->h->next->data.lval,
					   l->h->next->next->data.lval);
			sql->type = Q_SCHEMA;
		}
		break;
	case SQL_CREATE_VIEW:
		{
			stmt *ss = stmt_bind_schema(cur->base.name);
			dlist *l = s->data.lval;
			ret = create_view(sql, ss,
					  l->h->data.lval,
					  l->h->next->data.lval,
					  l->h->next->next->data.sym,
					  l->h->next->next->next->data.
					  ival);
			sql->type = Q_SCHEMA;
		}
		break;
	case SQL_CREATE_INDEX:
		{
			stmt *ss = stmt_bind_schema(cur->base.name);
			dlist *l = s->data.lval;
			ret = create_index(sql, ss,
					  l->h->data.sval,
					  l->h->next->data.ival,
					  l->h->next->next->data.lval,
					  l->h->next->next->next->data.lval);
			sql->type = Q_SCHEMA;
		}
		break;
	case SQL_DROP_INDEX:
		{
			dlist *l = s->data.lval;
			ret = drop_index(sql, l); /* index name */
			sql->type = Q_SCHEMA;
		}
		break;
	case SQL_CREATE_USER:
		{
			dlist *l = s->data.lval;
			ret = create_user(sql, 
				  l->h->data.sval, /* user name */
				  l->h->next->data.sval, /* password */
				  l->h->next->next->data.sval, /* fullname */
				  l->h->next->next->next->data.sval); /* dschema */
			sql->type = Q_SCHEMA;
		}
		break;
	case SQL_DROP_USER:
			ret = drop_user(sql, s->data.sval); /* user name */
			sql->type = Q_SCHEMA;
		break;
	case SQL_CREATE_ROLE:
		{
			dlist *l = s->data.lval;
			ret = create_role(sql, 
				  l->h->data.lval, /* role name */
				  l->h->next->data.ival); /* role grantor */
			sql->type = Q_SCHEMA;
		}
		break;
	case SQL_DROP_ROLE:
		{
			dlist *l = s->data.lval;
			ret = drop_role(sql, l); /* role name */
			sql->type = Q_SCHEMA;
		}
		break;
	case SQL_ALTER_TABLE:
		{
			stmt *ss = stmt_bind_schema(cur->base.name);
			dlist *l = s->data.lval;
			ret = alter_table(sql, ss,
					l->h->data.lval,	/* table name */
					l->h->next->data.sym);	/* table element */
			sql->type = Q_SCHEMA;
		}
		break;
	case SQL_GRANT_ROLES:
		{
			dlist *l = s->data.lval;
			ret = grant_roles(sql, cur, 
			    l->h->data.lval,	/* authids */
			    l->h->next->data.lval,	/* grantees */
			    l->h->next->next->data.ival, /* admin? */
			    l->h->next->next->next->data.ival?
				sql->user_id:sql->role_id); 
				/* grantor ? */
			sql->type = Q_SCHEMA;
		} break;
	case SQL_GRANT:
		{
			dlist *l = s->data.lval;
			ret = grant_privs( sql, cur,
			    l->h->data.lval,		/* privileges */
			    l->h->next->data.lval,	/* grantees */
			    l->h->next->next->data.ival, /* grant ? */
			    l->h->next->next->next->data.ival, /* hierarchy ? */
			    l->h->next->next->next->next->data.ival?
				sql->user_id:sql->role_id); 
				/* grantor ? */
			sql->type = Q_SCHEMA;
		} break;
	case SQL_REVOKE:
		{
			dlist *l = s->data.lval;
			ret = revoke_privs( sql, cur,
			    l->h->data.lval,		/* privileges */
			    l->h->next->data.lval,	/* grantees */
			    l->h->next->next->data.ival, /* grant ? */
			    l->h->next->next->next->data.ival, /* hierarchy ? */
			    l->h->next->next->next->next->data.ival?
				sql->user_id:sql->role_id); 
				/* grantor ? */
			sql->type = Q_SCHEMA;
		} break;

	case SQL_CREATE_MODULE:
		{
			dlist *l = s->data.lval;
			ret = create_module( sql, l);
			sql->type = Q_SCHEMA;
		}
		break;

	case SQL_DROP_MODULE:
		{
			dlist *l = s->data.lval;
			ret = drop_module( sql, l );
			sql->type = Q_SCHEMA;
		}
		break;

	case SQL_CREATE_TYPE:
		{
			dlist *l = s->data.lval;
			ret = create_type( sql, l->h->data.lval,
					  l->h->next->data.sval );
			sql->type = Q_SCHEMA;
		}
		break;

	case SQL_CREATE_FUNC:
		{
			dlist *l = s->data.lval;
			ret = create_func( sql, l->h->data.lval,
					  l->h->next->data.lval,
					  l->h->next->next->data.typeval,
					  l->h->next->next->next->data.sval,
					  l->h->next->next->next->next->data.sym
					);
			sql->type = Q_SCHEMA;
		}
		break;

	case SQL_COPYFROM:
		{
			dlist *l = s->data.lval;
			ret = copyfrom(sql, l->h->data.lval,
				       l->h->next->data.lval,
				       l->h->next->next->data.lval,
				       l->h->next->next->next->data.ival);
			sql->type = Q_UPDATE;
		}
		break;
	case SQL_INSERT:
		{
			dlist *l = s->data.lval;
			ret = insert_into(sql,
					  l->h->data.lval,
					  l->h->next->data.lval,
					  l->h->next->next->data.sym);
			sql->type = Q_UPDATE;
		}
		break;
	case SQL_UPDATE:
		{
			dlist *l = s->data.lval;
			ret = update_table(sql,
					 l->h->data.lval,
					 l->h->next->data.lval,
					 l->h->next->next->data.sym);
			sql->type = Q_UPDATE;
		}
		break;
	case SQL_DELETE:
		{
			dlist *l = s->data.lval;
			ret = delete_table(sql, 
					 l->h->data.lval,
					 l->h->next->data.sym);
			sql->type = Q_UPDATE;
		}
		break;
	case SQL_SELECT:
		ret = sql_subquery(sql, NULL, s);
		/* add output stmt */
		if (ret) 
			ret = stmt_output(ret);
		sql->type = Q_TABLE;
		break;
	case SQL_JOIN:
		ret = sql_join(sql, NULL, s);
		/* add output stmt */
		if (ret) 
			ret = stmt_output(ret);
		sql->type = Q_TABLE;
		break;
	case SQL_CROSS:
		ret = sql_cross(sql, NULL, s);
		/* add output stmt */
		if (ret) 
			ret = stmt_output(ret);
		sql->type = Q_TABLE;
		break;
	case SQL_SET:
		{
			dlist *l = s->data.lval;
			symbol *val = l->h->next->data.sym;
			scope *scp = scope_open(NULL);
			stmt *v = sql_value_exp( sql, scp, val, NULL, NULL);
			scope_close(scp);
			if (v)
				ret = stmt_assign(_strdup(l->h->data.sval), v);
		}
		break;
	case SQL_EXPORT:
		{
			dlist *l = s->data.lval;
			ret = stmt_export( l->h->data.ival,
					   l->h->next->data.ival,
					   l->h->next->next->data.ival);
			sql->type = Q_RESULT;
		}
		break;
	default:
		return sql_error(sql, 01, 
			 "sql_stmt Symbol(%ld)->token = %s",
			 (long) s, token2string(s->token));
	}
	return ret;
}


stmt *semantic(mvc * s, symbol * sym)
{
	stmt *res = NULL;

	if (sym){
		res = sql_stmt(s, sym);
	}
	return res;
}
