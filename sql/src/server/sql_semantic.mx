@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@' 
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@' 
@' The Original Code is the Monet Database System.
@' 
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2004 CWI.
@' All Rights Reserved.
@' 
@' Contributor(s):
@' 		Martin Kersten <Martin.Kersten@cwi.nl>
@' 		Peter Boncz <Peter.Boncz@cwi.nl>
@' 		Niels Nes <Niels.Nes@cwi.nl>
@' 		Stefan Manegold  <Stefan.Manegold@cwi.nl>

@f sql_semantic
@a N.J. Nes
@* 

@h
#ifndef _SQL_SEMANTIC_H_
#define _SQL_SEMANTIC_H_

#include <stdio.h>
#include <stdarg.h>
#include <sql_list.h>
#include "sql_symbol.h"
#include "sql_parser.h"
#include "sql_scope.h"

#define create_string_list() list_create((fdestroy)&GDKfree)

sql_export stmt *semantic( mvc * sql, symbol * sym);

sql_export sql_schema *cur_schema( mvc *sql );
sql_export sql_schema *qname_schema(mvc *sql, dlist * qname);
sql_export char *qname_table(dlist * qname);
sql_export tvar *scope_add_table_columns(mvc * sql, scope * scp, sql_table * t, char *tname);

sql_export sql_subtype *supertype( sql_subtype *r, sql_subtype *i );
sql_export int convert_types(mvc * sql, stmt ** L, stmt ** R, int scale_fixing);
sql_export stmt *check_types(mvc * sql, sql_subtype * ct, stmt * s );
sql_export stmt *fix_scale( mvc * sql, sql_subtype * ct, stmt * s, int both, int always);
sql_export void sum_scales( sql_subfunc *f, stmt *ls, stmt *rs );
sql_export stmt *scale_algebra( sql_subfunc *f, stmt *ls, stmt *rs );
sql_export stmt * sqlparse_intern(mvc *m, char *query);
sql_export stmt * scope_sqlparse(mvc *m, scope *scp, char *query);

sql_export stmt *first_subset(stmt * subset);

sql_export void sql_add_arg( mvc *sql, atom *v );		/* used in src/server/sql_parser.y */
sql_export void sql_add_param( mvc *sql, char *name, stmt *s );	/* used in src/server/sql_parser.y */
sql_export stmt *sql_bind_param( mvc *sql, char *name );

sql_export void sql_destroy_params( mvc *sql );			/* used in backend */
sql_export void sql_destroy_args( mvc *sql );			/* used in backend */

#endif /*_SQL_SEMANTIC_H_*/

@c

#include "sql_parser.h"
#include "sql_symbol.h"
#include "sql_statement.h"
#include "sql_semantic.h"
#include "sql_trans.h"
#include "sql_schema.h"
#include "sql_updates.h"
#include "sql_select.h"
#include "sql_env.h"
#include "sql_privileges.h"

#include <unistd.h>
#include <stdio.h>
#include <string.h>
#include <ctype.h>

/* 
 * For debugging purposes we need to be able to convert sql-tokens to 
 * a string representation.
 *
 *
 * !SQL ERROR <sqlerrno> : <details>
 * !SQL DEBUG  <details>
 * !SQL WARNING <details>
 * !SQL  <informative message, reserved for ...rows affected>
 *
 * Todo add insert bats used for inserts (ie should change the 
 * 	query code to use the global bats (mvc_bat) in read only mode).
 */

void sql_add_arg( mvc *sql, atom *v )
{
	if (!sql->args)
		sql->args = list_create((fdestroy)&atom_destroy);
	list_append(sql->args, v);
}

void sql_add_param( mvc *sql, char *name, stmt *s )
{
	var_ *v = NEW(var_);

	v->name = name;
	v->s = s;
	sql_ref_init( &(v->ref) );

	if (!sql->params)
		sql->params = list_create((fdestroy)&var_destroy);
	list_append(sql->params, v);
}

stmt *sql_bind_param( mvc *sql, char *name )
{
	node *n;
	if (sql->params){
		for(n = sql->params->h; n; n = n->next)
		{
			var_ *v = n->data;
			if (strcmp(v->name, name) == 0){
				return stmt_dup(v->s);
			}
		}
	}
	return NULL;
}

void sql_destroy_params( mvc *sql )
{
	if (sql->params)
		list_destroy(sql->params);
	sql->params = NULL;
}

void sql_destroy_args( mvc *sql )
{
	if (sql->args)
		list_destroy(sql->args);
	sql->args = NULL;
}


sql_schema *cur_schema( mvc *sql )
{
	return sql->trans->schema;
}

sql_schema *qname_schema(mvc *sql, dlist * qname)
{
	sql_schema *s = cur_schema(sql);
	assert(qname && qname->h);

	if (dlist_length(qname) == 2) {
		char *name = qname->h->data.sval;
		s = mvc_bind_schema(sql, name);
	}
	return s;
}

char *qname_table(dlist * qname)
{
	assert(qname && qname->h);

	if (dlist_length(qname) == 1) {
		return qname->h->data.sval;
	} else if (dlist_length(qname) == 2) {
		return qname->h->next->data.sval;
	}
	return "Unknown";
}

stmt *
scope_sqlparse(mvc *m, scope *scp, char *query) 
{
	mvc o = *m;
	stmt *sq;

	m->qc = NULL;
	m->cache = 0;

	scanner_reset(&m->scanner, query);

	m->params = NULL;
	m->args = NULL;
	m->sym = NULL;

	(void)sqlparse(m); /* blindly ignore errors */
	sq = sql_subquery(m, scp, m->sym, 1);

	symbol_destroy(m->sym);
	*m = o;
	return sq;
}

stmt *
sqlparse_intern(mvc *m, char *query) 
{
	mvc o = *m;
	stmt *sq;

	m->qc = NULL;
	m->cache = 0;

	scanner_reset(&m->scanner, query);

	m->params = NULL;
	m->args = NULL;
	m->sym = NULL;

	(void)sqlparse(m); /* blindly ignore errors */
	sq = scope_subquery(m, NULL, m->sym);

	symbol_destroy(m->sym);
	*m = o;
	return sq;
}

tvar *scope_add_table_columns(mvc * sql, scope * scp, sql_table * t, char *tname)
{
	node *n, *m;
	tvar *tv = NULL;

	if (t->type == tt_view){

		stmt *sq = sqlparse_intern(sql, t->query);

		for ( n = t->columns.set->h, m = sq->op1.lval->h;
				n && m; n = n->next, m = m->next) {
			sql_column *c = n->data;
			stmt *sc = stmt_dup(m->data);

			sc = stmt_alias(sc, c->base.name);
			c->st = stmt_ibat(sc, stmt_dup(sq));
		}

		tv = scope_add_table(scp, sq, tname, NULL);
		for ( n = t->columns.set->h; n; n = n->next) {
			sql_column *c = n->data;
			stmt *sc = stmt_dup(c->st);
			table_add_column(tv, sc, NULL, c->base.name);
		}
	} else {
		stmt *ts;

		tv = scope_add_table(scp, ts = stmt_basetable(t), tname, t);
		for ( n = t->columns.set->h; n; n = n->next) {
			sql_column *c = n->data;
			stmt *sc = stmt_cbat(c, stmt_dup(ts), RDONLY, st_bat);
			table_add_column(tv, sc, NULL, c->base.name);
		}
	}
	return tv;
}

static lng scale2value(int scale){
	lng val = 1;

	if (scale < 0) scale = -scale;
	for(;scale; scale--){
		val = val * 10;
	}
	return val;
}

void sum_scales( sql_subfunc *f, stmt *ls, stmt *rs ){
	if (strcmp(f->func->imp, "*") == 0 && 
			f->func->res->type->scale == SCALE_FIX){
		f->res.scale = tail_type(ls)->scale + 
					tail_type(rs)->scale;
	}
}

stmt *scale_algebra( sql_subfunc *f, stmt *ls, stmt *rs ){
	sql_subtype *lt = tail_type(ls);
	sql_subtype *rt = tail_type(rs);

	if (lt->type->scale == SCALE_FIX && rt->scale){ 
		sql_subtype *it = sql_bind_localtype( lt->type->base.name );
		sql_subfunc *c = NULL;

		if (strcmp(f->func->imp, "/") == 0){
			c = sql_bind_func("scale_up",lt,it);
		}
		if (c){
			lng val = scale2value(rt->scale);
			atom *a = atom_int(sql_dup_subtype(it), val);
			ls = stmt_binop(ls, stmt_atom(a), c);
		}
	}
	return ls;
}

stmt *fix_scale( mvc * sql, sql_subtype * ct, stmt * s, int both, int always)
{
	sql_subtype *st = tail_type(s);
	(void) sql; /* Stefan: unused!? */

	if (ct->type->scale == SCALE_FIX && st->type->scale == SCALE_FIX){ 
		int scale_diff = ((int) ct->scale - (int) st->scale);

		if (scale_diff){
			sql_subtype *it = sql_bind_localtype( st->type->base.name );
			sql_subfunc *c = NULL;

			if (scale_diff < 0){
				if (!both) 
					return s;
				c = sql_bind_func("scale_down",st,it);
			} else {
				c = sql_bind_func("scale_up",st,it);
			}
			if (c) {
				lng val = scale2value(scale_diff);
				atom *a = atom_int(sql_dup_subtype(it), val);
				c->res.scale = (st->scale + scale_diff);
				return stmt_binop(s, stmt_atom(a), c);
			}
		}
	} else if (always && st->scale){ /* scale down */
		int scale_diff =  - (int) st->scale;
		sql_subtype *it = sql_bind_localtype( st->type->base.name );
		sql_subfunc *c = sql_bind_func("scale_down",st,it);

		if (c) {
			lng val = scale2value(scale_diff);
			atom *a = atom_int(sql_dup_subtype(it), val);
			c->res.scale = 0;
			return stmt_binop(s, stmt_atom(a), c);
		} else {
			printf("scale_down mising (%s)\n", st->type->base.name);
		}
	}
	return s;
}

/* check_types tries to match the ct type with the type of s if they don't
 * match s is converted. Returns NULL on failure.
 */
stmt *check_types(mvc * sql, sql_subtype * ct, stmt * s )
{
	sql_subtype *st = tail_type(s);

	if (st) {
		sql_subtype *t = st;

		/* check if the types are the same */
		if (t && subtype_cmp(t, ct) != 0) {
			t = NULL;
		}
		if (!t) {	/* try to convert if needed */
			sql_subfunc *c = 
				sql_bind_func_result("convert",st,NULL,ct);
			if (c){ 
				if ((ct->digits > 0 && ct->scale == 0 && 
					ct->digits < st->digits) ||
		    		    (ct->scale > 0 && ct->digits > 0 && 
					ct->digits-ct->scale < 
						st->digits-st->scale) 
				) {
					sql_subfunc_destroy(c);
					return sql_error(sql, 03, "Types %s(%d,%d) (%s) and %s(%d,%d) (%s) are not equal", st->type->sqlname, st->digits, st->scale, st->type->base.name, ct->type->sqlname, ct->digits, ct->scale, ct->type->base.name);
				}
				return fix_scale(sql, ct, stmt_unop(s, c), 1,
					(st->type->scale == SCALE_FIX));
			} 
			/* here we need to check if we could convert using
			   the more complex conversion functions 
			   (convert(x,int,int) -> y)
			 */
			if (st->scale == 0) {
				sql_subtype *it = sql_bind_localtype( "int" );
				list *ops = list_create((fdestroy)NULL);
				list_append(ops, st);
				list_append(ops, it);
				list_append(ops, it);
				c = sql_bind_func_result_( "convert", ops, ct);
				list_destroy(ops);
				if (c){ 
					ops = create_stmt_list();
					list_append(ops, s);
					list_append(ops, stmt_atom(
						atom_int(sql_dup_subtype(it), 
						ct->digits)));
					list_append(ops, stmt_atom(
						atom_int(sql_dup_subtype(it), 
						ct->scale)));
					return stmt_Nop(stmt_list(ops), c);
				}
			}
		}
		if (!t || subtype_cmp(t, ct) != 0) {
			return sql_error(sql, 02, "Types %s(%d,%d) (%s) and %s(%d,%d) (%s) are not equal", st->type->sqlname, st->digits, st->scale, st->type->base.name, ct->type->sqlname, ct->digits, ct->scale, ct->type->base.name);
		}
	} else {
		assert(0);
		return sql_error(sql, 02, "Statement has no type information");
	}
	if (st) {
		if ((ct->digits > 0 && ct->scale == 0 
			&& ct->digits < st->digits) ||
		    (ct->scale > 0 && ct->digits > 0 
			&& ct->digits-ct->scale < st->digits-st->scale) 
		){
			return sql_error(sql, 03, "Types %s(%d,%d) (%s) and %s(%d,%d) (%s) are not equal", st->type->sqlname, st->digits, st->scale, st->type->base.name, ct->type->sqlname, ct->digits, ct->scale, ct->type->base.name);
		}
	}
	return fix_scale(sql, ct, s, 1, 0);
}


sql_subtype *supertype( sql_subtype *r, sql_subtype *i ) 
{
	/* first find super type */
	char *tpe = r->type->sqlname;
	int digits = 0;
	unsigned int scale = sql_max(i->scale,r->scale);

	if (i->type->nr > r->type->nr)
		tpe = i->type->sqlname;
	if (i->digits && r->digits) {
		if (i->digits > r->digits) {
			digits = i->digits;
			if (i->scale < scale)
				digits += scale-i->scale;	
		} else if (i->digits < r->digits) {
			digits = r->digits;
			if (r->scale < scale)
				digits += scale-r->scale;	
		} else {
			/* same number of digits */
			digits = i->digits;
			if (i->scale < r->scale) 
				digits += r->scale - i->scale;	
			else 
				digits += i->scale - r->scale;	
		}
	}

	return sql_bind_subtype(tpe,digits,scale);
}

/* convert_types convert both the stmt's L and R such that they get
 * matching types. On failure <0 is returned;
 */
int convert_types(mvc * sql, stmt ** L, stmt ** R, int scale_fixing )
{
	stmt *ls = *L;
	stmt *rs = *R;
	sql_subtype *lt = tail_type(ls);
	sql_subtype *rt = tail_type(rs);

	if (rt && lt){
		sql_subtype *i = lt;
		sql_subtype *r = rt;

		if (subtype_cmp(lt,rt) != 0){
			sql_subtype *super = supertype(r, i);
			if (scale_fixing){
				/* convert ls to super type */
				ls = check_types(sql, super, ls);
				/* convert rs to super type */
				rs = check_types(sql, super, rs);
			} else {
				/* convert ls to super type */
				super->scale = lt->scale;
				ls = check_types(sql, super, ls);
				/* convert rs to super type */
				super->scale = rt->scale;
				rs = check_types(sql, super, rs);
			}
			sql_subtype_destroy(super);
		} else if (scale_fixing) {
			ls = fix_scale( sql, r, ls, 0, 0);
			rs = fix_scale( sql, i, rs, 0, 0);
		}
		if (!ls || !rs) {
			if (ls)
				*L = ls;
			if (rs)
				*R = rs;
			return -1;
		}
		*L = ls;
		*R = rs;
		return 0;
	}
	return -1;
}

stmt *first_subset(stmt * subset)
{
	node *n;

	assert(subset->type == st_ptable);

       	n = ptable_pivots(subset)->h;
	if (n) 
		return stmt_dup(n->data);
	return NULL;
}



stmt *semantic(mvc * sql, symbol * s)
{
	stmt *res = NULL;

	if (!s)
		return NULL;

	switch (s->token) {

	case TR_COMMIT: case TR_SAVEPOINT: 
	case TR_RELEASE: case TR_ROLLBACK:
	case TR_START: case TR_MODE:
		return transactions(sql, s);

	case SQL_CREATE_SCHEMA: case SQL_DROP_SCHEMA:
	case SQL_CREATE_TABLE: case SQL_DROP_TABLE: 
	case SQL_ALTER_TABLE:
	case SQL_CREATE_VIEW: case SQL_DROP_VIEW:
	case SQL_CREATE_INDEX: case SQL_DROP_INDEX:
	case SQL_CREATE_USER: case SQL_DROP_USER:
	case SQL_CREATE_ROLE: case SQL_DROP_ROLE:
	case SQL_GRANT_ROLES:
	case SQL_GRANT: case SQL_REVOKE:
	case SQL_CREATE_MODULE: case SQL_DROP_MODULE:
	case SQL_CREATE_TYPE:
	case SQL_CREATE_FUNC:
		return schemas(sql, s);

	case SQL_COPYFROM:
	case SQL_INSERT:
	case SQL_UPDATE:
	case SQL_DELETE:
		return updates(sql, s);

	case SQL_SET:
		return sql_set_var(sql, s);

	case SQL_SELECT:
	case SQL_JOIN:
	case SQL_CROSS:
	case SQL_UNION:
	case SQL_EXCEPT:
	case SQL_INTERSECT:
		return selects(sql, s);
	
	default:
		return sql_error(sql, 01, 
			 "sql_stmt Symbol(%ld)->token = %s",
			 (long) s, token2string(s->token));
	}
	return res;
}
