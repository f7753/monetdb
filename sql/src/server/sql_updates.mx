@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@' 
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@' 
@' The Original Code is the Monet Database System.
@' 
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2004 CWI.
@' All Rights Reserved.
@' 
@' Contributor(s):
@' 		Martin Kersten <Martin.Kersten@cwi.nl>
@' 		Peter Boncz <Peter.Boncz@cwi.nl>
@' 		Niels Nes <Niels.Nes@cwi.nl>
@' 		Stefan Manegold  <Stefan.Manegold@cwi.nl>

@f sql_updates
@a N.J. Nes
@* 

@h
#ifndef _SQL_UPDATES_H_
#define _SQL_UPDATES_H_

#include <stdio.h>
#include <stdarg.h>
#include <sql_list.h>
#include "sql_symbol.h"
#include "sql_scope.h"
#include "sql_statement.h"
#include "sql_bm.h"

sql_export stmt *updates( mvc * sql, symbol * sym);

sql_export void cleanup_stmts(stmt **stmts, int cnt);
sql_export stmt *sql_insert(mvc * sql, sql_table *t, stmt **inserts, int len);
sql_export stmt *sql_delete( mvc *sql, tvar *tv, sql_table *t, stmt *s, int all );

#endif /*_SQL_UPDATES_H_*/
@c

#include "sql_config.h"
#include "sql_updates.h"
#include "sql_parser.h"
#include "sql_scope.h"
#include "sql_semantic.h"
#include "sql_select.h"
#include "sql_privileges.h"

static stmt *insert_value(mvc * sql, scope * scp, sql_column * c, symbol * s)
{
	if (s->token == SQL_NULL) {
		return stmt_atom(atom_general(sql_dup_subtype(c->type), NULL));
	} else {
		stmt *n = NULL;
		stmt *a = sql_value_exp(sql, scp, s, NULL, NULL, sql_sel);
		if (!a || !(n = check_types(sql, c->type, a))) {
			return NULL;
		}
		return n;
	}
	return NULL;
}

void cleanup_stmts(stmt **stmts, int cnt){
	int i;
	for (i=0; i<cnt; i++){
		if (stmts[i])
			stmt_destroy(stmts[i]);
	}
	_DELETE(stmts);
}


static stmt *
insert_check_ukey( mvc * sql, stmt **inserts, sql_key *k, stmt *idx_inserts )
{
/* pkey's cannot have NULLs, ukeys however can
   current implementation switches on 'NOT NULL' on primary key columns */

	char buf[BUFSIZ];
	stmt *res;

	sql_subtype *it = sql_bind_localtype( "int" );
	sql_subtype *lt = sql_bind_localtype( "lng" );
	sql_subaggr *cnt = sql_bind_aggr("count", NULL);
	sql_subtype *bt = sql_bind_localtype( "bit" );

	if (list_length(k->columns) > 1){
		node *m;
		stmt *s = inserts[0]->op2.stval;
		sql_subaggr *sum;
		stmt *count_sum = NULL;
	    	sql_subfunc *ne = sql_bind_func_result("<>", it, it, bt);

		/* 1st stage: find out if original contains same values */
		if (s->key && s->nrcols == 0){
			s = stmt_relselect_init();
			stmt_relselect_fill( s, stmt_uselect(
				stmt_idxbat(k->idx,0), stmt_dup(idx_inserts), cmp_equal)); 
			for(m = k->columns->h; m; m = m->next) {
				sql_kc *c = m->data;
				stmt_relselect_fill( s, stmt_uselect(
					stmt_dup(inserts[c->c->colnr]->op1.stval), 
					stmt_dup(inserts[c->c->colnr]->op2.stval),
					cmp_equal));
			}
		} else {
			s = stmt_reljoin_init();
			stmt_reljoin_fill( s, 
				 	stmt_idxbat(k->idx,0), 
					stmt_dup(idx_inserts)); 
			for(m = k->columns->h; m; m = m->next) {
				sql_kc *c = m->data;
				stmt_reljoin_fill( s,
					stmt_dup(inserts[c->c->colnr]->op1.stval), 
					stmt_dup(inserts[c->c->colnr]->op2.stval));
			}
		}
		s = stmt_binop(stmt_aggr(s, NULL, cnt),
			stmt_atom_int(0), ne);

		/* 2e stage: find out if inserted are unique */
		if (idx_inserts->nrcols){ /* insert columns not atoms */
			group *g = NULL;
		    	stmt *ss;
			sql_subfunc *or = sql_bind_func_result("or", bt, bt, bt);
		    	for(m = k->columns->h; m; m = m->next){
				sql_kc *c = m->data;
				g = grp_create(
					stmt_dup(inserts[c->c->colnr]->op2.stval),g, NULL);
			}
			ss = stmt_aggr(stmt_dup(g->grp), grp_dup(g), sql_dup_aggr(cnt));
			grp_destroy(g);
			/* (count(ss) <> sum(ss)) */
			sum = sql_bind_aggr("sum", tail_type(ss));
			count_sum = stmt_binop( 
				check_types(sql, lt, stmt_aggr(stmt_dup(ss), NULL, sql_dup_aggr(cnt))),
				check_types(sql, lt, stmt_aggr(ss, NULL, sum)), 
				sql_dup_func(ne));

			/* combine results */
			s = stmt_binop(s, count_sum, or);
		}

		snprintf(buf, BUFSIZ, 
			"key constraint %s.%s failed", k->t->base.name, k->base.name ); 
		res = stmt_exception( s, buf, 00001 );
	} else { /* single column key */
		sql_kc *c = k->columns->h->data;
		stmt *h = stmt_dup(inserts[c->c->colnr]->op2.stval);	
		stmt *s = stmt_uselect( 
			stmt_dup(inserts[c->c->colnr]->op1.stval), h, cmp_equal);
		/* s should be empty */
		snprintf(buf, BUFSIZ, 
			"key constraint %s.%s failed", k->t->base.name, k->base.name ); 
		res = stmt_exception( stmt_aggr(s, NULL, cnt), buf, 00001); 
	}
	return res;
}

static stmt *
insert_check_fkey( mvc * sql, stmt **inserts, sql_key *k, stmt *idx_inserts )
{
	char buf[BUFSIZ];
	stmt *s = inserts[0]->op2.stval;
	sql_subtype *it = sql_bind_localtype( "int" );
	sql_subaggr *cnt = sql_bind_aggr("count", NULL);
	sql_subtype *bt = sql_bind_localtype( "bit" );
	sql_subfunc *ne = sql_bind_func_result("<>", it, it, bt);

	(void)sql; /* unused! */

	if (s->key && s->nrcols == 0){
		s = stmt_binop(
			stmt_aggr(stmt_dup(idx_inserts), NULL, cnt), 
			stmt_atom_int(1), ne);
	} else {
		/* reljoin.count <> inserts[col1].count */
		stmt *ins = stmt_dup(inserts[0]->op2.stval);

		s = stmt_binop( 
			stmt_aggr(stmt_dup(idx_inserts), NULL, cnt), 
			stmt_aggr(ins, NULL, sql_dup_aggr(cnt)) , ne);
	}

	/* s should be empty */
	snprintf(buf, BUFSIZ, 
	 "foreign key constraint %s.%s failed", k->t->base.name, k->base.name );
	return stmt_exception( s, buf, 00001 );
}

static stmt *
sql_insert_key(mvc * sql, stmt **inserts, sql_key *k, stmt *idx_inserts )
{
	/* int insert = 1;
	 * while insert and has u/pkey and not defered then
	 * 	if u/pkey values exist then
	 * 		insert = 0
	 * while insert and has fkey and not defered then
	 *	find id of corresponding u/pkey  
	 *	if (!found)
	 *		insert = 0
	 * if insert
	 * 	insert values
	 * 	insert fkey/pkey index
	 */
	if (k->type == pkey || k->type == ukey){
		return insert_check_ukey( sql, inserts, k, idx_inserts);
	} else { /* foreign keys */
		return insert_check_fkey( sql, inserts, k, idx_inserts);
	}
}

static stmt *
hash_insert( sql_idx *i, stmt **inserts )
{
	node *m;
	sql_subtype *it; 
	int bits = 0;
	stmt *h = NULL;

	if (list_length(i->columns) <= 1)
		return NULL;

	it = sql_bind_localtype( "int" );
	for(m = i->columns->h; m; m = m->next, bits += 8){
		sql_kc *c = m->data;
		sql_subfunc *hf = 
			sql_bind_func_result("hash", c->c->type, it, it);

		if (h){
			sql_subfunc *xor = 
				sql_bind_func_result("xor", it, it, it);
			h = stmt_binop(h, stmt_binop(
				stmt_dup(inserts[c->c->colnr]->op2.stval), 
				stmt_atom_int(bits), hf), xor);
		} else {
			h = stmt_binop(
				stmt_dup(inserts[c->c->colnr]->op2.stval), 
				stmt_atom_int(bits), hf);
		}
	}
	return h;
}

static stmt *
join_idx_insert( sql_idx *i, stmt **inserts )
{
	node *m, *o;
	sql_idx *ri = ((sql_fkey*)i->key)->rkey->k.idx;
	stmt *rts = stmt_basetable(ri->t, ri->t->base.name);
	stmt *s = inserts[0]->op2.stval;

	if (s->key && s->nrcols == 0){
		sql_subtype *bt = sql_bind_localtype( "bit" );
		sql_subfunc *or = sql_bind_func_result("or", bt, bt, bt);
		int nulls = 0;
		stmt *cond = NULL;

		s = stmt_relselect_init();
	    	for(m = i->columns->h, o = ri->columns->h; m && o; 
			m = m->next, o = o->next) {
			sql_kc *c = m->data;
			sql_kc *rc = o->data;
			stmt_relselect_fill( s, stmt_uselect(
				stmt_dup(stmt_cbat(rc->c, stmt_dup(rts), 0, st_bat)), 
				stmt_dup(inserts[c->c->colnr]->op2.stval),
				cmp_equal));

			if (c->c->null) {
				sql_subfunc *isnil = sql_bind_func(
					"isnull", c->c->type, NULL );
				stmt *ins = stmt_dup(inserts[c->c->colnr]->op2.stval);
				ins = stmt_unop(ins, isnil);
				if (!cond) {
					cond = ins;
				} else {
					cond = stmt_binop(cond, ins, sql_dup_func(or));
				}

				nulls = 1;
			}
		}
		sql_subfunc_destroy(or);

		s = stmt_mark(stmt_reverse(s), 0);
		/* add missing nulls (and NULLs only (SIMPLE MATCH)) */
		if (nulls) {
			s = stmt_predicate( cond, s, 
				stmt_append(stmt_temp(
					sql_dup_subtype(tail_type(s))), 
					stmt_atom(atom_general( 
						sql_dup_subtype(tail_type(s)), 
						NULL ))));
		}
	} else {
		int nulls = 0;
		s = stmt_reljoin_init();
	    	for(m = i->columns->h, o = ri->columns->h; m && o; 
			m = m->next, o = o->next) {
			sql_kc *c = m->data;
			sql_kc *rc = o->data;
			stmt_reljoin_fill( s,
				stmt_dup(inserts[c->c->colnr]->op2.stval),
				stmt_dup(stmt_cbat(rc->c, stmt_dup(rts), 0, st_bat)));
			if (c->c->null)
				nulls = 1;
		}
		/* add missing nulls (and NULLs only (SIMPLE MATCH)) */
		if (nulls) {
			stmt *cur = NULL, *missing = stmt_diff(
				stmt_dup( inserts[0]->op2.stval ),
				stmt_dup(s));
	    		for(m = i->columns->h; m; m = m->next) {
				
				sql_kc *c = m->data;
				sql_subfunc *isnil = 
					sql_bind_func("isnull", 	
					c->c->type, NULL );
					
				stmt *n;
				n = stmt_dup(inserts[c->c->colnr]->op2.stval);
				n = stmt_semijoin( n, stmt_dup(missing));
				n = stmt_unop( n, isnil );
				n = stmt_uselect( n, stmt_bool(1), cmp_equal );
				if (cur)
					cur = stmt_semijoin( cur, n);
				else 
					cur = n;
			}
			stmt_destroy(missing);
			s = stmt_union(s, stmt_const(cur, stmt_atom( 
				atom_general( sql_dup_subtype(
				sql_bind_localtype("oid")), NULL ))));
		}
		s = stmt_reverse(stmt_order(stmt_reverse(s), 1));
		
	}
	stmt_destroy(rts);
	return s;
}

static int
sql_insert_idxs(mvc * sql, sql_table *t, stmt **inserts, list *l)
{
	node *n;
	int res = 1;

	(void)sql; /* unused!? */
	
	if (!t->idxs.set)
		return res;

 	for(n = t->idxs.set->h; n; n = n->next){
	    	sql_idx *i = n->data;
		stmt *is = NULL;

		if (i->type == unique){
			is = hash_insert( i, inserts); 
		} else if (i->type == join_idx){
			is = join_idx_insert( i, inserts);
		}
		if (i->key){
			stmt *ckeys = sql_insert_key(sql, inserts, i->key, is);
			list_prepend(l, ckeys);
		}
		/* append to the pre-computed join-index */
		if (is) 
			list_append(l, stmt_append(stmt_idxbat(i,1), is));
	}
	return res;
}

static int 
is_idx_updated(sql_idx *i, stmt **updates )
{
	int update = 0;
	node *m;

	for(m = i->columns->h; m; m = m->next ){
		sql_kc *ic = m->data;
		
		if (updates[ic->c->colnr]){
			update = ic->c->colnr;
			break;
		}
	}
	return update;
}

static int 
first_updated_col(stmt **updates, int cnt )
{
	int i;

	for(i = 0; i < cnt; i++) {
		if (updates[i])
			return i;
	}
	return -1;
}

static stmt *
update_check_ukey( mvc * sql, stmt **updates, sql_key *k, stmt *idx_updates, int updcol )
{
	char buf[BUFSIZ];
	stmt *res;

	sql_subtype *it = sql_bind_localtype( "int" );
	sql_subaggr *cnt = sql_bind_aggr("count", NULL);
	sql_subtype *bt = sql_bind_localtype( "bit" );

	if (list_length(k->columns) > 1){
		stmt *ts = stmt_basetable(k->t, k->t->base.name);
		node *m;
		stmt *s; 
		sql_subaggr *sum;
		stmt *count_sum = NULL;
	    	sql_subfunc *ne = sql_bind_func_result("<>", it, it, bt);

		/* 1st stage: find out if original contains same values */
		s = stmt_reljoin_init();
		stmt_reljoin_fill( s, 
			stmt_diff( stmt_idxbat(k->idx,0), stmt_dup(idx_updates)),
			stmt_dup(idx_updates)); 
		for(m = k->columns->h; m; m = m->next) {
			sql_kc *c = m->data;
			stmt *upd, *l;
			if (updates[c->c->colnr]){
				upd = stmt_dup(updates[c->c->colnr]->op2.stval);
				l = stmt_dup(updates[c->c->colnr]->op1.stval); 
			} else {
				upd = stmt_dup(updates[updcol]->op2.stval);
				upd = stmt_semijoin( stmt_cbat(c->c, 
					stmt_dup(ts), RDONLY, st_bat), upd);
				l = stmt_dup(upd);
			}
			stmt_reljoin_fill( s, l, upd);

		}
		s = stmt_binop(stmt_aggr(s, NULL, cnt),
			stmt_atom_int(0), ne);

		/* 2e stage: find out if updated are unique */
		if (idx_updates->nrcols){ /* update columns not atoms */
			group *g = NULL;
		    	stmt *ss;
			sql_subfunc *or = sql_bind_func_result("or", bt, bt, bt);
		    	for(m = k->columns->h; m; m = m->next){
				sql_kc *c = m->data;
				stmt *upd;
				if (updates[c->c->colnr]){
					upd = stmt_dup(updates[c->c->colnr]->op2.stval);
				} else {
					upd = stmt_dup(updates[updcol]->op2.stval);
					upd = stmt_semijoin(
						stmt_cbat(c->c, 
							stmt_dup(ts), 
							RDONLY, 
							st_bat), 
						upd);
				}
				g = grp_create(upd,g, NULL);
			}
			ss = stmt_aggr(stmt_dup(g->grp), grp_dup(g), sql_dup_aggr(cnt));
			grp_destroy(g);
			/* (count(ss) <> sum(ss)) */
			sum = sql_bind_aggr("sum", tail_type(ss));
			count_sum = stmt_binop( 
				stmt_aggr(stmt_dup(ss), NULL, sql_dup_aggr(cnt)), 
				check_types(sql, it, stmt_aggr(ss, NULL, sum)) , 
				sql_dup_func(ne));

			/* combine results */
			s = stmt_binop(s, count_sum, or);
		}

		snprintf(buf, BUFSIZ, 
			"key constraint %s.%s failed", k->t->base.name, k->base.name ); 
		res = stmt_exception( s, buf, 00001);
	} else { /* single column key */
		sql_kc *c = k->columns->h->data;
		stmt *h = stmt_dup( updates[c->c->colnr]->op2.stval ); 
		stmt *o = stmt_diff( 
				stmt_dup(updates[c->c->colnr]->op1.stval), 
				stmt_dup(updates[c->c->colnr]->op2.stval));	
		stmt *s = stmt_uselect( o, h, cmp_equal);
		/* s should be empty */
		snprintf(buf, BUFSIZ, 
			"key constraint %s.%s failed", k->t->base.name, k->base.name ); 
		res = stmt_exception( stmt_aggr(s, NULL, cnt), buf, 00001); 
	}
	return res;
}

static stmt *
update_check_fkey( mvc * sql, stmt **updates, sql_key *k, stmt *idx_updates, int updcol )
{
	char buf[BUFSIZ];
	stmt *s;
	sql_subtype *it = sql_bind_localtype( "int" );
	sql_subaggr *cnt = sql_bind_aggr("count", NULL);
	sql_subtype *bt = sql_bind_localtype( "bit" );
	sql_subfunc *ne = sql_bind_func_result("<>", it, it, bt);
	stmt *cur;

	(void)sql; /* unused! */
	/* reljoin.count <> updates[updcol].count */
	cur = stmt_dup(updates[updcol]->op2.stval);
	s = stmt_binop( 
		stmt_aggr(stmt_dup(idx_updates), NULL, cnt), 
		stmt_aggr(cur, NULL, sql_dup_aggr(cnt)), ne);

	/* s should be empty */
	snprintf(buf, BUFSIZ, 
	 "foreign key constraint %s.%s failed", k->t->base.name, k->base.name );
	return stmt_exception( s, buf, 00001 );
}

static stmt *
sql_update_key(mvc * sql, stmt **updates, sql_key *k, stmt *idx_updates, int updcol )
{
	if (k->type == pkey || k->type == ukey){
		return update_check_ukey( sql, updates, k, idx_updates, updcol);
	} else { /* foreign keys */
		return update_check_fkey( sql, updates, k, idx_updates, updcol);
	}
}

static stmt *
hash_update( sql_idx *i, stmt **updates, int updcol )
{
	/* calculate new value */
	node *m;
	sql_subtype *it;
	int bits = 0;
	stmt *h = NULL, *ts;

	if (list_length(i->columns) <= 1)
		return NULL;

	ts = stmt_basetable(i->t, i->t->base.name);
 	it = sql_bind_localtype( "int" );
	for(m = i->columns->h; m; m = m->next, bits += 8){
		sql_kc *c = m->data;
		sql_subfunc *hf = sql_bind_func_result("hash", c->c->type, it, it);
		stmt *upd;

		if (updates[c->c->colnr]){
			upd = stmt_dup(updates[c->c->colnr]->op2.stval);
		} else {
			upd = stmt_dup(updates[updcol]->op2.stval);
			upd = stmt_semijoin(
				stmt_cbat(c->c, stmt_dup(ts), RDONLY, st_bat), 
				upd);
		}
	
		if (h){
			sql_subfunc *xor = sql_bind_func_result("xor", it, it, it);
			h = stmt_binop(h, stmt_binop(upd, 
				stmt_atom_int(bits), hf), xor);
		} else {
			h = stmt_binop(upd, stmt_atom_int(bits), hf);
		}
	}
	stmt_destroy(ts);
	return h;
}

static stmt *
join_idx_update( sql_idx *i, stmt **updates, int updcol )
{
	int nulls = 0;
	node *m, *o;
	sql_idx *ri = ((sql_fkey*)i->key)->rkey->k.idx;
	stmt *s = NULL, *rts = stmt_basetable(ri->t, ri->t->base.name), *ts;
	stmt *null = NULL;

	ts = stmt_basetable(i->t, i->t->base.name);
	s = stmt_reljoin_init();
	for(m = i->columns->h, o = ri->columns->h; m && o; 
		m = m->next, o = o->next) {
		sql_kc *c = m->data;
		sql_kc *rc = o->data;
		stmt *upd;

		if (updates[c->c->colnr]){
			upd = stmt_dup(updates[c->c->colnr]->op2.stval);
		} else {
			upd = stmt_dup(updates[updcol]->op2.stval);
			upd = stmt_semijoin(
				stmt_cbat(c->c, stmt_dup(ts), RDONLY, st_bat), 
				upd);
		}
		if (c->c->null) { /* new nulls (MATCH SIMPLE) */
			stmt *nn = stmt_dup( upd );
			nn = stmt_uselect(nn, stmt_atom(atom_general(
				sql_dup_subtype(c->c->type), NULL)), 
				cmp_equal);
			if (null)
				null = stmt_semijoin(null,nn);
			else
				null = nn;
			nulls = 1;
		}
		stmt_reljoin_fill( s, upd,
			stmt_dup(stmt_cbat(rc->c, stmt_dup(rts), 0, st_bat)));

	}
	/* add missing nulls */
	if (nulls) 
		s = stmt_union(s, stmt_const(null, 
			stmt_atom(atom_general( sql_dup_subtype(
				sql_bind_localtype("oid")), NULL ))));

	stmt_destroy(ts);
	stmt_destroy(rts);
	return s;
}

static int 
sql_update_idxs(mvc * sql, sql_table *t, stmt **updates, list *l)
{
	int res = 1;
	node *n;
	int updcol;

	(void)sql; 

	if (!t->idxs.set)
		return res;

	updcol = first_updated_col(updates, list_length(t->columns.set));
 	for(n = t->idxs.set->h; n; n = n->next){
	    	sql_idx *i = n->data;
	    	stmt *is = NULL;

		/* check if update is needed, 
		 * ie atleast on of the idx columns is updated 
		 */
		if ( is_idx_updated(i, updates) == 0)
			continue;

		if (i->type == unique){
			is = hash_update( i, updates, updcol); 
		} else if (i->type == join_idx){
			is = join_idx_update( i, updates, updcol);
		}
		if (is && i->key){
			stmt *ckeys = sql_update_key(sql, updates, i->key, is, updcol);
			list_prepend(l, ckeys);
		}
		if (is) 
			list_append( l, stmt_replace(stmt_idxbat(i,1), is));
	}
	return res;
}

stmt *sql_insert(mvc * sql, sql_table *t, stmt **inserts, int len)
{
	char buf[BUFSIZ];
	int i;
	list *l = create_stmt_list();
	node *n;
	sql_subaggr *cnt = sql_bind_aggr("count", NULL);

	if (!sql_insert_idxs(sql, t, inserts, l)){
		return sql_error(sql, 02, 
			"Inserting into indexes failed for table %s",
			t->base.name);
	}

	for(n = t->columns.set->h; n; n = n->next){
		sql_column *c = n->data;

		if (!inserts[c->colnr]) {
			list_destroy(l);
			sql_subaggr_destroy( cnt );
			return NULL;
		}
		if (!c->null) {
			stmt *s = inserts[c->colnr]->op2.stval;
			if (!(s->key && s->nrcols == 0)){
				s = stmt_atom( atom_general(
					sql_dup_subtype(c->type), NULL));
				s = stmt_uselect( 
					stmt_dup(inserts[c->colnr]->op2.stval), 
					s, cmp_equal);
				s = stmt_aggr(s, NULL, sql_dup_aggr(cnt)); 
			} else {
				sql_subfunc *isnil = 
					sql_bind_func("isnull", c->type, NULL );
				s = stmt_unop(
					stmt_dup(inserts[c->colnr]->op2.stval), 
 					isnil);
			}
			snprintf(buf, BUFSIZ, 
				"null constraint %s.%s failed", 
				c->t->base.name, c->base.name ); 
			s = stmt_exception( s, buf, 00001); 
			
			list_prepend(l, s);
		}
	}

	sql_subaggr_destroy( cnt );
	for (i = 0; i < len; i++) 
		list_append(l, stmt_dup(inserts[i]));
	return stmt_list(l);
}

static stmt *insert_into(mvc * sql, dlist * qname,
			 dlist * columns, symbol * val_or_q)
{
	scope *scp;
	tvar *tv = NULL;

	sql_schema *s = qname_schema(sql, qname);
	char *tname = qname_table(qname);
	sql_table *t;
	list *collist = NULL;
	int i, len = 0;
	stmt **inserts, *res = NULL;

	if (!s || (t = mvc_bind_table(sql, s, tname)) == NULL) {
		return sql_error(sql, 02, 
			"Inserting into non existing table %s", tname);
	}
	if (!table_privs(sql, t, PRIV_INSERT)){
		return sql_error(sql, 02, 
			"User is not allowed to insert into table %s", tname);
	}
	if (columns) {
		dnode *n;

		collist = list_create((fdestroy)NULL);
		for (n = columns->h; n; n = n->next ) {
			sql_column *c = mvc_bind_column(sql, t, n->data.sval);
			if (c) {
				list_append(collist, c);
			} else {
				return sql_error(sql, 02, "Inserting into non existing column %s.%s", tname, n->data.sval);
			}
		}
	} else {
		collist = t->columns.set;
	}

	len = list_length(t->columns.set);
	inserts = NEW_ARRAY(stmt *, len);
	for (i = 0; i < len; i++)
		inserts[i] = NULL;

	scp = scope_open(NULL);
	tv = scope_add_table_columns(sql, scp, t, t->base.name);

	if (val_or_q->token == SQL_VALUES) {
		dlist *values = val_or_q->data.lval;
		if (dlist_length(values) != list_length(collist)) {
			scp = scope_close(scp);
			return sql_error(sql, 02, 
				 "Inserting into table %s, number of values doesn't match number of columns", tname);
		} else {
			dnode *n;
			node *m;

			for (n = values->h, m = collist->h;
			     n && m; n = n->next, m = m->next) {
				sql_column *c = m->data;
				stmt *ins = insert_value(sql, NULL, c, n->data.sym);
				if (!ins){
					cleanup_stmts(inserts, len);
					return NULL;
				}
					
				inserts[c->colnr] = stmt_append( stmt_cbat(c, stmt_dup(tv->s), INS, st_bat), ins );
			}

		}
		for(i=0; i<len; i++){
			if (!inserts[i]){
				node *m;
				for(m = t->columns.set->h; m; m = m->next){
					sql_column *c = m->data;
					if (c->colnr == i) {
						atom *a = NULL;
						if (c->def)
						    a = atom_general(
						    sql_dup_subtype(c->type), 
						    _strdup(c->def) );
						else
						    a = atom_general(
						    sql_dup_subtype(c->type), 
						    NULL );
						/* no valid default ! */
						if (!a) {
							scp = scope_close(scp);
		
							cleanup_stmts(inserts, len);
							return sql_error(sql, 02, 
				 				"column %s has no valid default value", c->base.name);
						}
						inserts[i] = stmt_append( stmt_cbat(c, stmt_dup(tv->s), INS, st_bat), stmt_atom(a));
					}
				}
			}
		}
	} else {
		stmt *s = scope_subquery(sql, NULL, val_or_q);

		if (!s){
			scp = scope_close(scp);
			cleanup_stmts(inserts, len);
			return NULL;
		}
		if (list_length(s->op1.lval) != list_length(collist)) {
			if (s) 
				stmt_destroy(s);
			scp = scope_close(scp);
			cleanup_stmts(inserts, len);
			return sql_error(sql, 02, 
				 "Inserting into table %s, query result doesn't match number of columns", tname);
		} else {
			node *m, *n;

			for (n = s->op1.lval->h, m = collist->h;
			     n && m; n = n->next, m = m->next) {
				sql_column *c = m->data;
				stmt *ins = check_types(sql, c->type, 	
					stmt_dup(n->data));
				if (!ins){
					scp = scope_close(scp);
					cleanup_stmts(inserts, len);
					return NULL;
				}
				inserts[c->colnr] = stmt_append( stmt_cbat(c, stmt_dup(tv->s), INS, st_bat), ins);
			}
		}
		if (s) 
			stmt_destroy(s);
	}
	if (collist != t->columns.set)
		list_destroy(collist);
	res = sql_insert(sql, t, inserts, len);
	scp = scope_close(scp);
	cleanup_stmts(inserts, len);
	return res;
}

static stmt *sql_bulkinsert(mvc * sql, sql_table *t, char *tsep, char *rsep, char *filename, int nr )
{
	sql_subtype *strtype = sql_bind_localtype( "str" );
	stmt *bats = NULL;
	stmt *fname = (filename)?stmt_atom(atom_string(
			sql_dup_subtype(strtype), _strdup(filename))):NULL;
	node *n;
	int i, len = 0;
	stmt **inserts, *res = NULL;
	
	scope *scp = scope_open(NULL);
	tvar *tv  = scope_add_table_columns(sql, scp, t, t->base.name);

	bats = stmt_bulkinsert(stmt_basetable(t, t->base.name), 
				tsep, rsep, fname, nr);
	len = list_length(t->columns.set);
	inserts = NEW_ARRAY(stmt *, len);
	for(n=t->columns.set->h, i = 0; n; n = n->next, i++){
		sql_column *c = n->data;
		inserts[i] = stmt_append( 
		  stmt_cbat(c, stmt_dup(tv->s), INS, st_bat), 
		    stmt_find(stmt_dup(bats), stmt_atom(atom_string(
				sql_dup_subtype(strtype), 
				_strdup(c->base.name)))));
	}
	stmt_destroy(bats);
	res = sql_insert(sql, t, inserts, len);
	scp = scope_close(scp);
	cleanup_stmts(inserts, len);
	return res;
}

static stmt *copyfrom(mvc * sql, dlist * qname, dlist *files, dlist *seps, int nr)
{
	char *tname = qname_table(qname);
	sql_table *t = mvc_bind_table(sql, cur_schema(sql), tname);
	char *tsep = seps->h->data.sval;
	char *rsep = seps->h->next->data.sval;
	list *slist;

	if (!t) {
		return sql_error(sql, 02, 
				"Copy into non existing table %s", tname);
	} else if (files){
		dnode *n = files->h;
		for (slist = create_stmt_list(); n; n = n->next){
			char *fname = n->data.sval;
			list_append(slist, 
				sql_bulkinsert( sql, t, tsep, rsep, fname, nr));
		}
		return stmt_list(slist);
	}
 	slist = create_stmt_list();
	list_append(slist, sql_bulkinsert( sql, t, tsep, rsep, NULL, nr ));
	return stmt_list(slist);
}


static stmt *sql_update(mvc * sql, sql_table *t, stmt **updates, list *l )
{
	char buf[BUFSIZ];
	node *n;
	sql_subaggr *cnt = sql_bind_aggr("count", NULL);

	if (!sql_update_idxs(sql, t, updates, l)){
		sql_subaggr_destroy( cnt );
		return sql_error(sql, 02, 
			"Updating indexes failed for table %s",
			t->base.name);
	}

	for(n = t->columns.set->h; n; n = n->next){
		sql_column *c = n->data;

		if (updates[c->colnr] && !c->null) {
			stmt *s = updates[c->colnr]->op2.stval;
			if (!(s->key && s->nrcols == 0)){
				s = stmt_atom( atom_general(
					sql_dup_subtype(c->type), NULL));
				s = stmt_uselect( 
					stmt_dup(updates[c->colnr]->op2.stval), 
					s, cmp_equal);
				s = stmt_aggr(s, NULL, sql_dup_aggr(cnt)); 
			} else {
				sql_subfunc *isnil = 
					sql_bind_func("isnull", c->type, NULL );
				s = stmt_unop(
					stmt_dup(updates[c->colnr]->op2.stval), 
 					isnil);
			}
			snprintf(buf, BUFSIZ, 
				"null constraint %s.%s failed", 
				c->t->base.name, c->base.name ); 
			s = stmt_exception( s, buf, 00001); 
			
			list_prepend(l, s);
		}
	}
	sql_subaggr_destroy( cnt );
	return stmt_list(l);
}

static stmt *update_table(mvc * sql, dlist * qname,
			dlist * assignmentlist, symbol * opt_where)
{
	stmt *s = NULL;
	char *tname = qname_table(qname);
	sql_table *t = mvc_bind_table(sql, cur_schema(sql), tname);

	if (!t) {
		return sql_error(sql, 02, "Updating non existing table %s", tname);
	} else {
		int len = 0, i = 0;
		tvar *tv = NULL;
		dnode *n;
		list *l;
		scope *scp;
		stmt **updates;

		scp = scope_open(NULL);
		tv = scope_add_table_columns(sql, scp, t, t->base.name);

		if (opt_where){
			s = sql_logical_exp(sql, scp, opt_where, NULL, NULL, sql_where);
			if (s) 
				s = stmt2pivot(scp,s);
			if (!s){
				scope_close(scp);
			       	return NULL;
			}
		} else { /* update all */
			cvar *c = tv->columns->h->data;
			s = stmt2pivot(scp,stmt_dup(c->s));
		}
	       	l = create_stmt_list();

		len = list_length(t->columns.set);
		updates = NEW_ARRAY(stmt *, len);
		for (i = 0; i < len; i++)
			updates[i] = NULL;

		for( n = assignmentlist->h, i=0; n; n = n->next, i++ ){
			symbol *a = NULL;
			stmt *v = NULL;
			dlist *assignment = n->data.sym->data.lval;
			char *cname = assignment->h->data.sval;
			sql_column *c = mvc_bind_column(sql, t, cname);

			if (!c) {
				stmt_destroy(s);
				list_destroy(l);
				cleanup_stmts(updates, len);
				return sql_error(sql, 02, 
				  "Updating non existing column %s.%s",
					 tname, assignment->h->data.sval);
			}
			a = assignment->h->next->data.sym;
			if (a)
				v = sql_value_exp(sql, scp, a, NULL, s, sql_sel);
			else 
				v = stmt_atom(atom_general(
					sql_dup_subtype(c->type), NULL));

			if (!v || 
		           (v = check_types(sql, c->type, v)) == NULL){
				stmt_destroy(s);
				list_destroy(l);
				cleanup_stmts(updates, len);
				return NULL;
			}

			if (v->nrcols <= 0){
				v = stmt_const(
				  stmt_reverse(s ? 
					first_subset(s) : 
				  	stmt_cbat(c, stmt_dup(tv->s), RDONLY, st_bat)), v);
			}

			updates[c->colnr] = stmt_replace( stmt_cbat(c, stmt_dup(tv->s), UPD, st_bat), v);
			list_append(l, stmt_dup(updates[c->colnr]) );
			if (t->base.flag != TR_NEW) {
				list_append(l, stmt_insert( 
					stmt_cbat(c, 
					          stmt_dup(tv->s), 
						  UPD, st_ubat), stmt_dup(v)));
			}
			/* TODO rows = count(stmt_dup(v)) */
		}
		if (s) stmt_destroy(s);
	
		if ((s = sql_update( sql, t, updates, l)) == NULL){
			list_destroy(l);
			cleanup_stmts(updates, len);
			return NULL;
		}
		scp = scope_close(scp);
		cleanup_stmts(updates, len);
		return s;
	}
	return NULL;
}

static int
sql_delete_idxs(mvc * sql, sql_table *t, stmt *vals, list *l)
{
	node *n;
	int res = 1;

	(void)sql; /* unused!? */

	for(n = t->idxs.set->h; n; n = n->next){
		sql_idx *i = n->data;
		sql_subtype *it = NULL;
		stmt *v = NULL;

		if (i->type == unique && list_length(i->columns) <= 1)
			continue;
		
		if (i->type == unique) {
			it = sql_bind_localtype( "int" );
		} else if (i->type == join_idx){
			it = sql_bind_localtype( "oid" );
		}

		assert(it);
		v = stmt_const( stmt_reverse( first_subset(vals)), 
			stmt_atom(atom_general(sql_dup_subtype(it), NULL)));
		list_append(l, stmt_replace( stmt_idxbat(i, 1), v));
	}
	return res;
}


stmt *
sql_delete( mvc *sql, tvar *tv, sql_table *t, stmt *s, int all )
{
	node *n;
	list *l = create_stmt_list();
	sql_subtype *to;
	stmt *v;

	if (all && !t->idxs.set && (t->base.flag == TR_NEW || 
	    t->type == tt_temp || t->type == tt_session) ){
		BAT *d;
		for(n = t->columns.set->h; n; n = n->next){
			sql_column *c = n->data;
			BAT *b = mvc_bind(sql, c->t->s->base.name,
					       c->t->base.name,
					       c->base.name, 1);
			BAT *u = mvc_bind_ubat(sql, c->t->s->base.name,
					       c->t->base.name,
					       c->base.name, 1);
			if (b){ 	
				BATclear(b);
				bat_destroy(b);
			}
		
			if (u){
				BATclear(u);
				bat_destroy(u);
			}	
		}
		d = mvc_bind_dbat( sql, t->s->base.name, t->base.name, 1);
		BATclear(d);
		bat_destroy(d);
	}

	to = sql_bind_subtype("OID", 0, 0);
 	v = stmt_const( stmt_reverse(first_subset(s)), 
				stmt_atom(atom_general(to, NULL)));
	list_append(l, stmt_append(
			stmt_tbat(basetable_table(tv->s), INS ),
			stmt_reverse(v)));
	for(n = t->columns.set->h; n; n = n->next){
		sql_column *c = n->data;
		stmt *v = stmt_const( stmt_reverse( first_subset(s)), 
			stmt_atom(atom_general(sql_dup_subtype(c->type), NULL)));
		list_append(l, stmt_replace( stmt_cbat(c, stmt_dup(tv->s), DEL, st_bat), v));
	}
	/* TODO rows = count(stmt_dup(v)) */

	if (t->idxs.set && !sql_delete_idxs(sql, t, s, l )){
		list_destroy(l);
		return sql_error(sql, 02, 
			"Deleting from indexes failed for table %s",
			t->base.name);
	}
	stmt_destroy(s);
	return stmt_list(l);
}

static stmt *delete_table(mvc * sql, dlist * qname, symbol * opt_where)
{
	char *tname = qname_table(qname);
	sql_table *t = mvc_bind_table(sql, cur_schema(sql), tname);

	if (!t) {
		return sql_error(sql, 02, 
			 "Deleting from non existing table %s", tname);
	}
	if (!table_privs(sql, t, PRIV_DELETE)){
		return sql_error(sql, 02, 
			"User is not allowed to delete from table %s", tname);
	} else {
		int all = 0;
		tvar *tv = NULL;
		stmt  *s = NULL;
		scope *scp = scope_open(NULL);

		tv = scope_add_table_columns(sql, scp, t, t->base.name);

		if (opt_where){
			s = sql_logical_exp(sql, scp, opt_where, NULL, NULL, sql_where);
			if (s) 
				s = stmt2pivot(scp,s);
			if (!s){
				scope_close(scp);
			       	return NULL;
			}
		} else { /* delete all */
			cvar *c = tv->columns->h->data;
			s = stmt2pivot(scp,stmt_dup(c->s));
			all = 1;
		}

		assert (isbasetable(tv->s));
		s = sql_delete(sql, tv, t, s, all);

		scp = scope_close(scp);
		return s;
	}
	return NULL;
}

stmt *
updates(mvc * sql, symbol * s) 
{
	stmt *ret = NULL;

	switch (s->token) {
	case SQL_COPYFROM:
		{
			dlist *l = s->data.lval;
			ret = copyfrom(sql, l->h->data.lval,
				       l->h->next->data.lval,
				       l->h->next->next->data.lval,
				       l->h->next->next->next->data.ival);
			sql->type = Q_UPDATE;
		}
		break;
	case SQL_INSERT:
		{
			dlist *l = s->data.lval;
			ret = insert_into(sql,
					  l->h->data.lval,
					  l->h->next->data.lval,
					  l->h->next->next->data.sym);
			sql->type = Q_UPDATE;
		}
		break;
	case SQL_UPDATE:
		{
			dlist *l = s->data.lval;
			ret = update_table(sql,
					 l->h->data.lval,
					 l->h->next->data.lval,
					 l->h->next->next->data.sym);
			sql->type = Q_UPDATE;
		}
		break;
	case SQL_DELETE:
		{
			dlist *l = s->data.lval;
			ret = delete_table(sql, 
					 l->h->data.lval,
					 l->h->next->data.sym);
			sql->type = Q_UPDATE;
		}
		break;
	default:
		return sql_error(sql, 01, 
			 "Updates statement unknown Symbol(%ld)->token = %s",
			 (long) s, token2string(s->token));
	}
	return ret;
}
