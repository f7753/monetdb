@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2004 CWI.
@' All Rights Reserved.

@f sql_scan
@a N.J. Nes
@* 

@h

#ifndef _SQL_SCAN_H_
#define _SQL_SCAN_H_

#include "sql_mem.h"
#include "sql_list.h"
#include <stream.h>
#include <stdio.h>

typedef enum { LINE_1,	LINE_N,	BLOCKED	 } prot;

struct scanner {
	char 	*buf;
	bstream *rs;
	stream 	*ws;

	int yynext;	/* next token, lr(1) isn't powerfull enough for sql */
	int yysval;	/* start of current token */
	int yyval;	/* current token */
	int yycur;	/* next char in the queue */
	char yybak;	/* sometimes its needed to write an EOS marker */
	int as;		/* start of query part of view's etc */
	int key;
	prot mode; 	/* which mode (line (1,N), blocked) */
};

#define QUERY(scanner) ((scanner.rs)?(scanner.rs->buf+scanner.rs->pos):scanner.buf)

sql_export void scanner_init( struct scanner *s, bstream *rs, stream *ws );
sql_export void scanner_reset( struct scanner *s, char *buf );
sql_export void scanner_query_processed( struct scanner *s );

extern void init_keywords();
extern void exit_keywords();
extern void keywords_insert(char *k, int token);
extern int  keyword_exists(char *text);

#endif	/* _SQL_SCAN_H_ */

@c

#include <sql_mem.h>
#include "sql_scan.h"
#include "sql_types.h"
#include "sql_symbol.h"
#include "sql_parser.tab.h"
#include "sql_statement.h"
#include "sql_mvc.h"
#include "sql_parser.h"	/* for sql_error() */

#include <stream.h>
#include <unistd.h>
#include <string.h>
#include <ctype.h>
#include <stdlib.h>

#define HASH_SIZE 512
#define HASH_MASK (HASH_SIZE-1)

typedef struct keyword {
	char *keyword;
	int len;
	int token;
	struct keyword *next;
} keyword;

static int keywords_init_done = 0;
static keyword *keywords[HASH_SIZE];

static int 
keyword_key(char *k, int *l)
{
	char *s = k;
	int h = 1;
	while (*k) {
		h *= (*k - 'a');
		k++;
	}
	*l = k - s;
	return (h < 0) ? -h : h;
}

void 
keywords_insert(char *k, int token)
{
	keyword *kw = NEW(keyword);
	int len = 0;
	int bucket = keyword_key(k=toLower(k), &len) & HASH_MASK;

	kw->keyword = k;
	kw->len = len;
	kw->token = token;
	kw->next = keywords[bucket];
	keywords[bucket] = kw;
}

void 
init_keywords()
{
	int i;

	if (keywords_init_done)
		return;
	keywords_init_done = 1;

	for (i = 0; i < HASH_SIZE; i++)
		keywords[i] = NULL;

	keywords_insert("false", BOOL_FALSE);
	keywords_insert("true", BOOL_TRUE);

	keywords_insert("ALTER", ALTER);
	keywords_insert("ADD", ADD);
	keywords_insert("AND", AND);
	keywords_insert("AVG", AGGR);
	keywords_insert("MIN", AGGR);
	keywords_insert("MAX", AGGR);
	keywords_insert("SUM", AGGR);
	keywords_insert("COUNT", AGGR);
	keywords_insert("AS", AS);
	keywords_insert("ASC", ASC);
	keywords_insert("AUTHORIZATION", AUTHORIZATION);
	keywords_insert("BATS", BATS);
	keywords_insert("BETWEEN", BETWEEN);
	keywords_insert("SYMMETRIC", SYMMETRIC);
	keywords_insert("ASYMMETRIC", ASYMMETRIC);
	keywords_insert("BY", BY);
	keywords_insert("CAST", CAST);
	keywords_insert("CONVERT", CONVERT);
	keywords_insert("CHARACTER", CHARACTER);
	keywords_insert("VARYING", VARYING);
	keywords_insert("CHECK", CHECK);
	keywords_insert("CONSTRAINT", CONSTRAINT);
	keywords_insert("CREATE", CREATE);
	keywords_insert("CROSS", CROSS);
	keywords_insert("COPY", COPY );
	keywords_insert("RECORDS", RECORDS );
	keywords_insert("DELIMITERS", DELIMITERS );
	keywords_insert("STDIN", STDIN );

	keywords_insert("TINYINT", TINYINT);
	keywords_insert("SMALLINT", SMALLINT);
	keywords_insert("MEDIUMINT", MEDIUMINT);
	keywords_insert("BIGINT", BIGINT);
	keywords_insert("DEC", sqlDECIMAL);
	keywords_insert("DECIMAL", sqlDECIMAL);
	keywords_insert("DECLARE", DECLARE);
	keywords_insert("DEFAULT", DEFAULT);
	keywords_insert("DESC", DESC);
	keywords_insert("DISTINCT", DISTINCT);
	keywords_insert("DOUBLE", sqlDOUBLE);
	keywords_insert("DROP", DROP);
	keywords_insert("ESCAPE", ESCAPE);
	keywords_insert("EXISTS", EXISTS);
	keywords_insert("EXTRACT", EXTRACT);
	keywords_insert("FLOAT", sqlFLOAT);
	keywords_insert("FOR", FOR);
	keywords_insert("FOREIGN", FOREIGN);
	keywords_insert("FROM", FROM);
	keywords_insert("REFERENCES", REFERENCES);

	keywords_insert("MATCH", MATCH);
	keywords_insert("FULL", FULL);
	keywords_insert("PARTIAL", PARTIAL);
	keywords_insert("SIMPLE", SIMPLE);

	keywords_insert("INSERT", INSERT);
	keywords_insert("UPDATE", UPDATE);
	keywords_insert("DELETE", sqlDELETE);

	keywords_insert("ACTION", ACTION);
	keywords_insert("CASCADE", CASCADE);
	keywords_insert("RESTRICT", RESTRICT);
	keywords_insert("GLOBAL", GLOBAL);
	keywords_insert("GROUP", GROUP);
	keywords_insert("HAVING", HAVING);
	keywords_insert("IN", sqlIN);
	keywords_insert("INNER", INNER);
	keywords_insert("INTO", INTO);
	keywords_insert("IS", IS);
	keywords_insert("JOIN", JOIN);
	keywords_insert("KEY", KEY);
	keywords_insert("LEFT", LEFT);
	keywords_insert("LIKE", LIKE);
	keywords_insert("LIMIT", LIMIT);
	keywords_insert("LOCAL", LOCAL);
	keywords_insert("NATURAL", NATURAL);
	keywords_insert("NOT", NOT);
	keywords_insert("NULL", NULLX);
	keywords_insert("OFFSET", OFFSET);
	keywords_insert("ON", ON);
	keywords_insert("OPTIONS", OPTIONS);
	keywords_insert("OPTION", OPTION);
	keywords_insert("OR", OR);
	keywords_insert("ORDER", ORDER);
	keywords_insert("OUTER", OUTER);
	keywords_insert("PATH", PATH);
	keywords_insert("PRECISION", PRECISION);
	keywords_insert("PRIMARY", PRIMARY);

	keywords_insert("USER", USER);
	keywords_insert("PASSWORD", PASSWORD);
	keywords_insert("GRANT", GRANT);
	keywords_insert("REVOKE", REVOKE);
	keywords_insert("ROLE", ROLE);
	keywords_insert("ADMIN", ADMIN);
	keywords_insert("PRIVILEGES", PRIVILEGES);
	keywords_insert("PUBLIC", PUBLIC);
	keywords_insert("CURRENT_USER", CURRENT_USER);
	keywords_insert("CURRENT_ROLE", CURRENT_ROLE);
	keywords_insert("SESSION_USER", SESSION_USER);
	keywords_insert("SESSION", sqlSESSION);

	keywords_insert("RIGHT", RIGHT);
	keywords_insert("SCHEMA", SCHEMA);
	keywords_insert("SELECT", SELECT);
	keywords_insert("SET", SET);
	keywords_insert("AUTO_COMMIT", AUTO_COMMIT);

	keywords_insert("ALL", ALL);
	keywords_insert("ANY", ANY);
	keywords_insert("SOME", SOME);
	keywords_insert("EVERY", ANY);
	/*
	   keywords_insert("SQLCODE", SQLCODE );
	 */
	keywords_insert("COLUMN", COLUMN);
	keywords_insert("TABLE", TABLE);
	keywords_insert("TEMPORARY", TEMPORARY);
	keywords_insert("TEMP", TEMPORARY);
	keywords_insert("TO", TO);
	keywords_insert("UNION", UNION);
	keywords_insert("EXCEPT", EXCEPT);
	keywords_insert("INTERSECT", INTERSECT);
	keywords_insert("CORRESPONDING", CORRESPONDING);
	keywords_insert("UNIQUE", UNIQUE);
	keywords_insert("USING", USING);
	keywords_insert("VALUES", VALUES);
	keywords_insert("VIEW", VIEW);
	keywords_insert("WHERE", WHERE);
	keywords_insert("WITH", WITH);

	keywords_insert("DATE", sqlDATE);
	keywords_insert("TIME", TIME);
	keywords_insert("TIMESTAMP", TIMESTAMP);
	keywords_insert("INTERVAL", INTERVAL);
	keywords_insert("CURRENT_DATE", CURRENT_DATE);
	keywords_insert("CURRENT_TIME", CURRENT_TIME);
	keywords_insert("CURRENT_TIMESTAMP", CURRENT_TIMESTAMP);
	keywords_insert("NOW", CURRENT_TIMESTAMP);
	keywords_insert("ZONE", ZONE);

	keywords_insert("YEAR", YEAR);
	keywords_insert("MONTH", MONTH);
	keywords_insert("DAY", DAY);
	keywords_insert("HOUR", HOUR);
	keywords_insert("MINUTE", MINUTE);
	keywords_insert("SECOND", SECOND);

	keywords_insert("POSITION", POSITION);
	keywords_insert("SUBSTRING", SUBSTRING);

	keywords_insert("CASE", CASE);
	keywords_insert("WHEN", WHEN);
	keywords_insert("THEN", THEN);
	keywords_insert("ELSE", ELSE);
	keywords_insert("END", END);
	keywords_insert("NULLIF", NULLIF);
	keywords_insert("COALESCE", COALESCE);

	keywords_insert("COMMIT", COMMIT);
	keywords_insert("ROLLBACK", ROLLBACK);
	keywords_insert("SAVEPOINT", SAVEPOINT);
	keywords_insert("RELEASE", RELEASE);
	keywords_insert("WORK", WORK);
	keywords_insert("CHAIN", CHAIN);
	keywords_insert("PRESERVE", PRESERVE);
	keywords_insert("ROWS", ROWS);
	keywords_insert("NO", NO);
	keywords_insert("START", START);
	keywords_insert("TRANSACTION", TRANSACTION);
	keywords_insert("READ", READ);
	keywords_insert("WRITE", WRITE);
	keywords_insert("ONLY", ONLY);
	keywords_insert("ISOLATION", ISOLATION);
	keywords_insert("LEVEL", LEVEL);
	keywords_insert("UNCOMMITTED", UNCOMMITTED);
	keywords_insert("COMMITTED", COMMITTED);
	keywords_insert("REPEATABLE", REPEATABLE);
	keywords_insert("SERIALIZABLE", SERIALIZABLE);
	keywords_insert("DIAGNOSTICS", DIAGNOSTICS);
	keywords_insert("SIZE", sqlSIZE);

	keywords_insert("MODULE", MODULE );
	keywords_insert("TYPE", TYPE );
	keywords_insert("PROCEDURE", PROCEDURE );
	keywords_insert("FUNCTION", FUNCTION );
	keywords_insert("RETURNS", RETURNS );
	keywords_insert("EXTERNAL", EXTERNAL );
	keywords_insert("NAME", sqlNAME );

	keywords_insert("PREPARE", PREPARE );
	keywords_insert("PREP",    PREPARE );
	keywords_insert("EXECUTE", EXECUTE );
	keywords_insert("EXEC",    EXECUTE );

	keywords_insert("INDEX", INDEX );

	keywords_insert("SEQUENCE", SEQUENCE );
	keywords_insert("INCREMENT", INCREMENT );
	keywords_insert("MAXVALUE", MAXVALUE );
	keywords_insert("MINVALUE", MINVALUE );
	keywords_insert("CYCLE", CYCLE );
	keywords_insert("NEXT", NEXT );
	keywords_insert("VALUE", VALUE );
	keywords_insert("GENERATED", GENERATED );
	keywords_insert("IDENTITY", IDENTITY );
}

void 
exit_keywords()
{
	int i;

	if (keywords_init_done == 0)
		return;
	keywords_init_done = 0;

	for (i = 0; i < HASH_SIZE; i++) {
		keyword *k = keywords[i];
		while (k) {
			keyword *l = k;
			k = k->next;
			_DELETE(l->keyword);
			_DELETE(l);
		}
	}
}

static keyword *
find_keyword(char *text)
{
	int len = 0;
	int bucket = keyword_key(mkLower(text), &len) & HASH_MASK;
	keyword *k = keywords[bucket];
	while (k) {
		if (len == k->len && strcmp(k->keyword, text) == 0)
			return k;
		k = k->next;
	}
	return NULL;
}

int 
keyword_exists(char *text)
{
	if (find_keyword(text)){
		return 1;
	}
	return 0;
}

#define find_keyword_bs(lc, s) find_keyword(lc->rs->buf+lc->rs->pos+s)
#define find_keyword_s(lc, s) find_keyword(lc->buf+s)

void
scanner_init( struct scanner *s, bstream *rs, stream *ws )
{
	s->buf = NULL;
	s->rs = rs;
	s->ws = ws;

	s->yynext = 0;
	s->yyval = 0;
	s->yybak = 0; /* keep backup of char replaced by EOS */
	s->yycur = 0;

	s->key = 0;	/* keep a hash key of the query */

	s->mode = LINE_N;
}

void
scanner_reset( struct scanner *s, char *query )
{
	if (s->buf) 
		_DELETE(s->buf);
	s->buf = query;
	s->rs = NULL;

	s->yynext = 0;
	s->yyval = 0;
	s->yybak = 0; 	/* keep backup of char replaced by EOS */
	s->yycur = 0;

	s->key = 0;	/* keep a hash key of the query */
}

void
scanner_query_processed( struct scanner *s )
{
	if (s->yybak) {
		if (s->rs) {
			s->rs->buf [ s->rs->pos + s->yycur ] = s->yybak;
		} else {
			s->buf [ s->yycur ] = s->yybak;
		}
		s->yybak = 0;
	}
	if (s->rs) {
		int cur;
		s->rs->pos += s->yycur;
		/* completely eat the query including white space after the ; */
		cur = s->rs->buf[s->rs->pos];
		while(isspace(cur)) { 
			s->rs->pos++;
			cur = s->rs->buf[s->rs->pos];
		}
		assert( s->rs->pos <= s->rs->len);
		s->yycur = 0;
	}
	s->key = 0;	/* keep a hash key of the query */
}

static int 
scanner_error(mvc * lc, int cur)
{
	switch (cur) {
	case EOF:
		(void)sql_error( lc, 1, "Unexpected end of input");
		return -1; /* EOF needs -1 result */
	default:
		(void)sql_error( lc, 1, "Unexpected control character");
	}
	return LEX_ERROR;
}


/*
   UTF-8 encoding is as follows:
U-00000000 - U-0000007F: 0xxxxxxx
U-00000080 - U-000007FF: 110xxxxx 10xxxxxx
U-00000800 - U-0000FFFF: 1110xxxx 10xxxxxx 10xxxxxx
U-00010000 - U-001FFFFF: 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
U-00200000 - U-03FFFFFF: 111110xx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx
U-04000000 - U-7FFFFFFF: 1111110x 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx
*/
/* To be correctly coded UTF-8, the sequence should be the shortest
   possible encoding of the value being encoded.  This means that for
   an encoding of length n+1 (1 <= n <= 5), at least one of the bits in
   utf8chkmsk[n] should be non-zero (else the encoding could be
   shorter).
*/
static int utf8chkmsk[] = {
	0x0000007f,
	0x00000780,
	0x0000f800,
	0x001f0000,
	0x03e00000,
	0x7c000000
};

static void
utf8_putchar(struct scanner *lc, int ch )
{
        if ((ch) < 0x80) {
		lc->yycur--;
        } else if ((ch) < 0x800) {
		lc->yycur-=2;
        } else if ((ch) < 0x10000) {
		lc->yycur-=3;
        } else {
		lc->yycur-=4;
        }
}

static int
scanner_getc_s(struct scanner * lc)
{
	unsigned char *s = (unsigned char*)lc->buf;
	int c;
	int n, m, mask;

	if (((c = s[lc->yycur++]) & 0x80) == 0) {
		/* 7-bit char */
		return c;
	}
	for (n = 0, m = 0x40; c & m; n++, m >>= 1)
		;
	/* n now is number of 10xxxxxx bytes that should follow */
	if (n == 0 || n >= 6) {
		/* incorrect UTF-8 sequence */
		/* n==0: c == 10xxxxxx */
		/* n>=6: c == 1111111x */
		return EOF;
	}

	mask = utf8chkmsk[n];
	c &= ~(0xFFC0 >> n);	/* remove non-x bits */
	while (--n >= 0) {
		c <<= 6;
		if (((m = s[lc->yycur++]) & 0xC0) != 0x80) {
			/* incorrect UTF-8 sequence: byte is not 10xxxxxx */
			/* this includes end-of-string (m == 0) */
			return EOF;
		}
		c |= m & 0x3F;
	}
	if ((c & mask) == 0) {
		/* incorrect UTF-8 sequence: not shortest possible */
		return EOF;
	}
	return c;
}

static INLINE int
scanner_read_more(struct scanner * lc, int n)
{
	bstream *b = lc->rs;
	int more = 0;


	while (b->len < b->pos+lc->yycur+n) {

		if (lc->mode == LINE_1) 
			return EOF;

		/* query is not finished ask for more */
		if (b->eof || !isa_block_stream(b->s) ) { 
			if (stream_write(lc->ws,PROMPT2,sizeof(PROMPT2)-1,1) == 1)
				stream_flush(lc->ws);
			b->eof = 0;
			more = 1;
		}
		/* we need more query text */
		if (bstream_next( b ) < 0 || 
	    	   /* we asked for more data but didn't get any */
	    	   (more && b->eof && b->len < b->pos+lc->yycur+n))
			return EOF;
	}
	return 1;
}

static INLINE int
scanner_getc_bs(struct scanner * lc)
{
	bstream *b = lc->rs;
	unsigned char *s = NULL;
	int c;
	int n, m, mask;

	if (scanner_read_more(lc, 1) == EOF)
		return EOF;

	s = (unsigned char*) b->buf + b->pos + lc->yycur++;
	if (((c = *s) & 0x80) == 0) {
		/* 7-bit char */
		return c;
	}
	for (n = 0, m = 0x40; c & m; n++, m >>= 1)
		;
	/* n now is number of 10xxxxxx bytes that should follow */
	if (n == 0 || n >= 6 || (b->pos + n) > b->len) {
		/* incorrect UTF-8 sequence */
		/* n==0: c == 10xxxxxx */
		/* n>=6: c == 1111111x */
		goto error;
	}

	if (scanner_read_more(lc, n) == EOF)
		return EOF;
	s = (unsigned char*) b->buf + b->pos + lc->yycur;

	mask = utf8chkmsk[n];
	c &= ~(0xFFC0 >> n);	/* remove non-x bits */
	while (--n >= 0) {
		c <<= 6;
		lc->yycur ++;
		if (((m = *s++) & 0xC0) != 0x80) {
			/* incorrect UTF-8 sequence: byte is not 10xxxxxx */
			/* this includes end-of-string (m == 0) */
			goto error;
		}
		c |= m & 0x3F;
	}
	if ((c & mask) == 0) {
		/* incorrect UTF-8 sequence: not shortest possible */
		goto error;
	}
	return c;

  error:
	if (b->pos+lc->yycur < b->len) 	/* skip bogus char */
		lc->yycur++;
	return EOF;
}

static int 
scanner_token_bs(struct scanner * lc, int token)
{
	lc->yybak = lc->rs->buf [ lc->rs->pos + lc->yycur ];
	lc->rs->buf[ lc->rs->pos + lc->yycur ] = 0;
	lc->yyval = token;
	return lc->yyval;
}

static int 
scanner_token_s(struct scanner * lc, int token)
{
	lc->yybak = lc->buf [ lc->yycur ];
	lc->buf[ lc->yycur ] = 0;
	lc->yyval = token;
	return lc->yyval;
}

static int 
scanner_string_bs(mvc * c, int quote)
{
	struct scanner *lc = &c->scanner;
	bstream *rs = lc->rs;
	int cur = quote;
	int escape = 0;

	while (cur != EOF) {
		unsigned int pos = rs->pos + lc->yycur;

		while ((((cur = rs->buf[pos++]) & 0x80) == 0) && cur &&
		       (cur != quote || escape)) 
		{
			if (cur != '\\')
				escape = 0;
			else 
				escape = !escape;
		}
		lc->yycur = pos - rs->pos;
		/* check for quote escaped quote: Obsuce SQL Rule */
		if (cur == quote && rs->buf[pos] == quote) { 
			rs->buf[pos-1] = '\\';
			lc->yycur++;
			continue;
		}
		assert(pos <= rs->len+1);
		if (cur == quote && !escape) {
			return scanner_token_bs(lc, STRING);
		}
		lc->yycur--; /* go back to current (possibly invalid) char */
		/* long utf8, if correct isn't the quote */
		if (!cur) {
			cur = scanner_read_more(lc, 1);
		} else {
			cur = scanner_getc_bs(lc);
		}
	}
	(void)sql_error( c, 2, "Unexpected end of input" );
	return LEX_ERROR;
}

static int 
scanner_string_s(mvc * c, int quote)
{
	struct scanner *lc = &c->scanner;
	int cur = quote;
	int escape = 0;

	while(cur != EOF) {
		while ((cur = scanner_getc_s(lc)) != EOF && 
			(cur != quote || escape)) {
			if (cur == '\\' && !escape)
				escape = 1;
			else
				escape = 0;
		}
		/* check for quote escaped quote: Obsuce SQL Rule */
		if (cur == quote && lc->buf[lc->yycur] == quote) { 
			lc->yycur++;
			continue;
		} 
		if (cur == quote)
			return scanner_token_s(lc, STRING);
	}
	if (cur == EOF) {
		(void)sql_error( c, 2, "Unexpected end of input" );
	}
	return LEX_ERROR;
}

@= scanner
static int 
keyword_or_ident@1(struct scanner * lc, int cur)
{
	keyword *k = NULL;
	int s;

	utf8_putchar(lc, cur);
	s = lc->yycur;
	lc->yyval = IDENT;
	while ((cur = scanner_getc@1(lc)) != EOF) {
		if ((isascii(cur) && !isalnum(cur)) && cur != '_') {
			utf8_putchar(lc, cur);
			(void)scanner_token@1(lc, IDENT);
			k = find_keyword@1(lc,s);
			if (k) 
				lc->yyval = k->token;
			return lc->yyval;
		}
	}
	(void)scanner_token@1(lc, IDENT);
	k = find_keyword@1(lc,s);
	if (k) 
		lc->yyval = k->token;
	return lc->yyval;
}

static int 
skip_white_space@1(struct scanner * lc)
{
	int cur;

	lc->yysval = lc->yycur;
	while ((cur = scanner_getc@1(lc)) != EOF && isspace(cur))
		lc->yysval = lc->yycur;
	return cur;
}

static int 
skip_c_comment@1(struct scanner * lc)
{
	int cur;
	int prev = 0;

	while ((cur = scanner_getc@1(lc)) != EOF && 
	       !(cur == '/' && prev == '*')) 
		prev = cur;
	lc->yysval = lc->yycur;
	if (cur == '/')
		cur = scanner_getc@1(lc);
	return cur;
}

static int 
skip_sql_comment@1(struct scanner * lc)
{
	int cur;
	while ((cur = scanner_getc@1(lc)) != EOF && (cur != '\n'))
		;
	lc->yysval = lc->yycur;
	if (cur == '\n')
		cur = scanner_getc@1(lc);
	return cur;
}

static int tokenize@1(mvc * lc, int cur);

static int 
number@1(mvc * c, int cur)
{
	struct scanner *lc = &c->scanner;
	int token = sqlINT;

	/* TODO start with . */
	while ((cur = scanner_getc@1(lc)) != EOF && isdigit(cur)) 
		;
	if (cur == '.') {
		token = INTNUM;

		while ((cur = scanner_getc@1(lc)) != EOF && isdigit(cur)) 
			;
	}
	if (cur == 'e' || cur == 'E') {
		token = APPROXNUM;
		cur = scanner_getc@1(lc);
		if (cur == '-' || cur == '+') 
			token = 0;
		while ((cur = scanner_getc@1(lc)) != EOF && 
		       isdigit(cur)) 
			token = APPROXNUM;
	}
	if (token) {
		if (cur != EOF)
			utf8_putchar(lc, cur);
		return scanner_token@1(lc, token);
	} else {
		(void)sql_error( c, 2, "Unexpected symbol %c", cur);
		return LEX_ERROR;
	}
}

static
int scanner_symbol@1(mvc * c, int cur)
{
	struct scanner *lc = &c->scanner;
	int next = 0;

	if (cur == '/') {
		next = scanner_getc@1(lc);
		if (next == '*') {
			cur = skip_c_comment@1(lc);
			return tokenize@1(c, cur);
		} else {
			utf8_putchar(lc, next); 
			return scanner_token@1(lc, cur);
		}
	} else if (isdigit(cur)) {
		return number@1(c, cur);
	} else if (cur == '#') {
		if ((cur = skip_sql_comment@1(lc)) == EOF)
			return cur;
		return tokenize@1(c, cur);
	} else if (cur == '\'' || cur == '"') {
		return scanner_string@1(c, cur);
	}
	switch (cur) {
	case '-':
		next = scanner_getc@1(lc);
		if (next == '-') {
			if ((cur = skip_sql_comment@1(lc)) == EOF)
				return cur;
			return tokenize@1(c, cur);
		}
		utf8_putchar(lc, next); 
		return scanner_token@1(lc, cur);
	case '?':
	case '%':
	case '+':
	case '*':
	case '/':
	case '(':
	case ')':
	case ',':
	case '.':
	case ';':
	case '=':
		return scanner_token@1(lc, cur);
	case '<':
		cur = scanner_getc@1(lc);
		if (cur == '=') {
			return scanner_token@1( lc, COMPARISON);
		} else if (cur == '>') {
			return scanner_token@1( lc, COMPARISON);
		} else {
			utf8_putchar(lc, cur); 
			return scanner_token@1( lc, COMPARISON);
		}
	case '>':
		cur = scanner_getc@1(lc);
		if (cur != '=') {
			utf8_putchar(lc, cur); 
			return scanner_token@1( lc, COMPARISON);
		} else {
			return scanner_token@1( lc, COMPARISON);
		}
	case '|':
		cur = scanner_getc@1(lc);
		if (cur == '|') {
			return scanner_token@1(lc, CONCATSTRING);
		}
	}
	(void)sql_error( c, 3, "Unexpected symbol (%c)", cur);
	return LEX_ERROR;
}

static int 
tokenize@1(mvc * c, int cur)
{
	struct scanner *lc = &c->scanner;
	while (1) {
		if (isspace(cur)) {
			if ((cur = skip_white_space@1(lc)) == EOF)
				return cur;
		} else if (isdigit(cur)) {
			return number@1(c, cur);
		} else if (isalpha(cur) || cur == '_') {
			return keyword_or_ident@1(lc, cur);
		} else if (ispunct(cur)) {
			return scanner_symbol@1(c, cur);
		}
		if (cur == EOF || iscntrl(cur))
			return scanner_error(c, cur);
	}
}
@c
@:scanner(_bs)@
@:scanner(_s)@

int valid_ident(const char *s)
{
	if (*s != '_' && !isalpha((int)*s))
		return 0;
	s++;
	while(*s != '"'){
		if (*s != '_' && !isalnum((int)*s))
			return 0;
		s++;
	}
	return 1;
}

int 
sqllex(YYSTYPE * yylval, void *parm)
{
	int token;
	mvc *c = (mvc *) parm;
	struct scanner *lc = &c->scanner;

	if (lc->yynext) {
		int next = lc->yynext;
		lc->yynext = 0;
		return next;
	}

	if (lc->yybak) {
		if (lc->rs) {
			lc->rs->buf [ lc->rs->pos + lc->yycur ] = lc->yybak;
		} else {
			lc->buf [ lc->yycur ] = lc->yybak;
		}
		lc->yybak = 0;
	}

	lc->yysval = lc->yycur;
	if (lc->rs)
		token = tokenize_bs(c, scanner_getc_bs(lc));
	else
		token = tokenize_s(c, scanner_getc_s(lc));

	if (lc->rs) 
		yylval->sval = (lc->rs->buf + lc->rs->pos + lc->yysval);
	else 
		yylval->sval = (lc->buf + lc->yysval);

	if (token == IDENT || token == COMPARISON || token == AGGR || 
	    token == aTYPE || token == ALIAS || token == aMODULE )
		yylval->sval = _strdup(yylval->sval);
	if (token == STRING) {
		if (*yylval -> sval == '"' && valid_ident(yylval->sval+1))
			token = IDENT;
		yylval->sval = sql_strdup(yylval->sval);
	}

	if (token == UNION) {
		int next = sqllex(yylval, parm);
		if (token == JOIN)
			token = UNIONJOIN; 
		else
			lc->yynext = next;
	}

	/* Don't include literals in the calculation of the key */
	if (token != STRING && token != sqlINT &&
	    token != INTNUM && token != APPROXNUM && token != NULLX)
		lc->key ^= token;

	return token;
}
