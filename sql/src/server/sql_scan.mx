@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@' 
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@' 
@' The Original Code is the Monet Database System.
@' 
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2004 CWI.
@' All Rights Reserved.
@' 
@' Contributor(s):
@' 		Martin Kersten <Martin.Kersten@cwi.nl>
@' 		Peter Boncz <Peter.Boncz@cwi.nl>
@' 		Niels Nes <Niels.Nes@cwi.nl>
@' 		Stefan Manegold  <Stefan.Manegold@cwi.nl>

@f sql_scan
@a N.J. Nes
@* 

@h

#ifndef _SQL_SCAN_H_
#define _SQL_SCAN_H_

#include "sql_list.h"
#include "sql_context.h"
#include <stdio.h>

extern void init_keywords();
extern void exit_keywords();
extern void keywords_insert(char *k, int token);
extern int  keyword_exists(char *yytext);

#endif	/* _SQL_SCAN_H_ */

@c

#include <sql_mem.h>
#include "sql_scan.h"
#include "sql_types.h"
#include "sql_symbol.h"
#include "sql_parser.tab.h"
#include "sql_statement.h"
#include "sql_parser.h"	/* for sql_error() */

#include <stream.h>
#include <unistd.h>
#include <string.h>
#include <ctype.h>
#include <stdlib.h>

#define HASH_SIZE 128
#define HASH_MASK (HASH_SIZE-1)

typedef struct keyword {
	char *keyword;
	int len;
	int token;
	struct keyword *next;
} keyword;

static int keywords_init_done = 0;
static keyword *keywords[HASH_SIZE];

static int keyword_key(char *k, int *l)
{
	char *s = k;
	int h = 0;
	while (*k) {
		h += tolower(*k) - 'a';
		k++;
	}
	*l = k - s;
	return (h < 0) ? -h : h;
}

void keywords_insert(char *k, int token)
{
	keyword *kw = NEW(keyword);
	int len = 0;
	int bucket = keyword_key(k, &len) & HASH_MASK;

	kw->keyword = toLower(k);
	kw->len = len;
	kw->token = token;
	kw->next = keywords[bucket];
	keywords[bucket] = kw;
}

void init_keywords()
{
	int i;

	if (keywords_init_done)
		return;
	keywords_init_done = 1;

	for (i = 0; i < HASH_SIZE; i++)
		keywords[i] = NULL;

	keywords_insert("false", BOOL_FALSE);
	keywords_insert("true", BOOL_TRUE);

	keywords_insert("ALL", ALL);
	keywords_insert("ALTER", ALTER);
	keywords_insert("ADD", ADD);
	keywords_insert("AND", AND);
	keywords_insert("AVG", AGGR);
	keywords_insert("MIN", AGGR);
	keywords_insert("MAX", AGGR);
	keywords_insert("SUM", AGGR);
	keywords_insert("COUNT", AGGR);
	keywords_insert("ANY", ANY);
	keywords_insert("AS", AS);
	keywords_insert("ASC", ASC);
	keywords_insert("AUTHORIZATION", AUTHORIZATION);
	keywords_insert("BETWEEN", BETWEEN);
	keywords_insert("SYMMETRIC", SYMMETRIC);
	keywords_insert("ASYMMETRIC", ASYMMETRIC);
	keywords_insert("BY", BY);
	keywords_insert("CAST", CAST);
	keywords_insert("CHARACTER", CHARACTER);
	keywords_insert("VARYING", VARYING);
	keywords_insert("CHECK", CHECK);
	/*
	   keywords_insert("CLOSE", CLOSE );
	 */
	keywords_insert("CONSTRAINT", CONSTRAINT);
	/*
	   keywords_insert("CONTINUE", CONTINUE );
	 */
	keywords_insert("CREATE", CREATE);
	keywords_insert("CROSS", CROSS);
	/*
	   keywords_insert("CURRENT", CURRENT );
	   keywords_insert("CURSOR", CURSOR );
	 */
	keywords_insert("COPY", COPY );
	keywords_insert("RECORDS", RECORDS );
	keywords_insert("DELIMITERS", DELIMITERS );
	keywords_insert("STDIN", STDIN );

	keywords_insert("DEC", sqlDECIMAL);
	keywords_insert("DECIMAL", sqlDECIMAL);
	/*
	   keywords_insert("DECLARE", DECLARE );
	 */
	keywords_insert("DEFAULT", DEFAULT);
	keywords_insert("DESC", DESC);
	keywords_insert("DISTINCT", DISTINCT);
	keywords_insert("DOUBLE", sqlDOUBLE);
	keywords_insert("DROP", DROP);
	keywords_insert("ESCAPE", ESCAPE);
	keywords_insert("EXISTS", EXISTS);
	keywords_insert("EXTRACT", EXTRACT);
	/*
	   keywords_insert("FETCH", FETCH );
	 */
	keywords_insert("FLOAT", sqlFLOAT);
	keywords_insert("FOR", FOR);
	keywords_insert("FOREIGN", FOREIGN);
	/*
	   keywords_insert("FOUND", FOUND );
	 */
	keywords_insert("FROM", FROM);
	keywords_insert("REFERENCES", REFERENCES);

	keywords_insert("MATCH", MATCH);
	keywords_insert("FULL", FULL);
	keywords_insert("PARTIAL", PARTIAL);
	keywords_insert("SIMPLE", SIMPLE);

	keywords_insert("INSERT", INSERT);
	keywords_insert("UPDATE", UPDATE);
	keywords_insert("DELETE", sqlDELETE);

	keywords_insert("ACTION", ACTION);
	keywords_insert("CASCADE", CASCADE);
	keywords_insert("RESTRICT", RESTRICT);
	/*
	   keywords_insert("GO", GO );
	 */
	keywords_insert("GLOBAL", GLOBAL);
	keywords_insert("GROUP", GROUP);
	keywords_insert("HAVING", HAVING);
	keywords_insert("IN", sqlIN);
	keywords_insert("INNER", INNER);
	keywords_insert("INTO", INTO);
	keywords_insert("IS", IS);
	keywords_insert("JOIN", JOIN);
	keywords_insert("KEY", KEY);
	/*
	   keywords_insert("LANGUAGE", LANGUAGE );
	 */
	keywords_insert("LEFT", LEFT);
	keywords_insert("LIKE", LIKE);
	keywords_insert("LIMIT", LIMIT);
	keywords_insert("LOCAL", LOCAL);
	keywords_insert("NATURAL", NATURAL);
	keywords_insert("NOT", NOT);
	keywords_insert("NULL", NULLX);
	keywords_insert("NUMERIC", NUMERIC);
	/*
	   keywords_insert("OF", OF );
	 */
	keywords_insert("ON", ON);
	/*
	   keywords_insert("OPEN", OPEN );
	 */
	keywords_insert("OPTIONS", OPTIONS);
	keywords_insert("OPTION", OPTION);
	keywords_insert("OR", OR);
	keywords_insert("ORDER", ORDER);
	keywords_insert("OUTER", OUTER);
	keywords_insert("PATH", PATH);
	keywords_insert("PRECISION", PRECISION);
	keywords_insert("PRIMARY", PRIMARY);

	keywords_insert("USER", USER);
	keywords_insert("PASSWORD", PASSWORD);
	keywords_insert("GRANT", GRANT);
	keywords_insert("REVOKE", REVOKE);
	keywords_insert("ROLE", ROLE);
	keywords_insert("ADMIN", ADMIN);
	keywords_insert("PRIVILEGES", PRIVILEGES);
	keywords_insert("HIERARCHY", HIERARCHY);
	keywords_insert("PUBLIC", PUBLIC);
	keywords_insert("CURRENT_USER", CURRENT_USER);
	keywords_insert("CURRENT_ROLE", CURRENT_ROLE);
	keywords_insert("SESSION_USER", SESSION_USER);

	keywords_insert("REAL", REAL);
	keywords_insert("RIGHT", RIGHT);
	keywords_insert("SCHEMA", SCHEMA);
	keywords_insert("SELECT", SELECT);
	keywords_insert("SET", SET);
	keywords_insert("SOME", SOME);
	/*
	   keywords_insert("SQLCODE", SQLCODE );
	 */
	keywords_insert("COLUMN", COLUMN);
	keywords_insert("TABLE", TABLE);
	keywords_insert("TEMPORARY", TEMPORARY);
	keywords_insert("TEMP", TEMPORARY);
	keywords_insert("TO", TO);
	/*
	   keywords_insert("UNDER", UNDER );
	 */
	keywords_insert("UNION", UNION);
	keywords_insert("UNIQUE", UNIQUE);
	keywords_insert("USING", USING);
	keywords_insert("VALUES", VALUES);
	keywords_insert("VIEW", VIEW);
	/*
	   keywords_insert("WHENEVER", WHENEVER );
	 */
	keywords_insert("WHERE", WHERE);
	keywords_insert("WITH", WITH);

	keywords_insert("DATE", sqlDATE);
	keywords_insert("TIME", TIME);
	keywords_insert("TIMESTAMP", TIMESTAMP);
	keywords_insert("INTERVAL", INTERVAL);
	keywords_insert("CURRENT_DATE", CURRENT_DATE);
	keywords_insert("CURRENT_TIME", CURRENT_TIME);
	keywords_insert("CURRENT_TIMESTAMP", CURRENT_TIMESTAMP);
	keywords_insert("NOW", CURRENT_TIMESTAMP);

	keywords_insert("YEAR", YEAR);
	keywords_insert("MONTH", MONTH);
	keywords_insert("DAY", DAY);
	keywords_insert("HOUR", HOUR);
	keywords_insert("MINUTE", MINUTE);
	keywords_insert("SECOND", SECOND);

	keywords_insert("SUBSTRING", SUBSTRING);

	keywords_insert("CASE", CASE);
	keywords_insert("WHEN", WHEN);
	keywords_insert("THEN", THEN);
	keywords_insert("ELSE", ELSE);
	keywords_insert("END", END);
	keywords_insert("NULLIF", NULLIF);
	keywords_insert("COALESCE", COALESCE);

	keywords_insert("COMMIT", COMMIT);
	keywords_insert("ROLLBACK", ROLLBACK);
	keywords_insert("SAVEPOINT", SAVEPOINT);
	keywords_insert("RELEASE", RELEASE);
	keywords_insert("WORK", WORK);
	keywords_insert("CHAIN", CHAIN);
	keywords_insert("PRESERVE", PRESERVE);
	keywords_insert("ROWS", ROWS);
	keywords_insert("NO", NO);

	keywords_insert("MODULE", MODULE );
	keywords_insert("TYPE", sqlTYPE );
	keywords_insert("PROCEDURE", PROCEDURE );
	keywords_insert("FUNCTION", FUNCTION );
	keywords_insert("RETURNS", RETURNS );
	keywords_insert("EXTERNAL", EXTERNAL );
	keywords_insert("NAME", sqlNAME );
	keywords_insert("EXPORT", EXPORT );
	keywords_insert("EXECUTE", EXECUTE );

	keywords_insert("INDEX", INDEX );
}

void exit_keywords()
{
	int i;

	if (keywords_init_done == 0)
		return;
	keywords_init_done = 0;

	for (i = 0; i < HASH_SIZE; i++) {
		keyword *k = keywords[i];
		while (k) {
			keyword *l = k;
			k = k->next;
			_DELETE(l->keyword);
			_DELETE(l);
		}
	}
}

static keyword *find_keyword(char *yytext)
{
	int len = 0;
	int bucket = keyword_key(mkLower(yytext), &len) & HASH_MASK;
	keyword *k = keywords[bucket];
	while (k) {
		if (len == k->len) {
			if (len < 4) {
				if (*(short *) k->keyword ==
				    *(short *) yytext
				    && strcmp(k->keyword, yytext) == 0)
					return k;
			} else {
				if (*(int *) k->keyword == *(int *) yytext
				    && strcmp(k->keyword, yytext) == 0)
					return k;
			}
		}
		k = k->next;
	}
	return NULL;
}

int keyword_exists(char *yytext)
{
	if (find_keyword(yytext)){
		return 1;
	}
	return 0;
}

/*
   UTF-8 encoding is as follows:
U-00000000 - U-0000007F: 0xxxxxxx
U-00000080 - U-000007FF: 110xxxxx 10xxxxxx
U-00000800 - U-0000FFFF: 1110xxxx 10xxxxxx 10xxxxxx
U-00010000 - U-001FFFFF: 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
U-00200000 - U-03FFFFFF: 111110xx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx
U-04000000 - U-7FFFFFFF: 1111110x 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx
*/
/* To be correctly coded UTF-8, the sequence should be the shortest
   possible encoding of the value being encoded.  This means that for
   an encoding of length n+1 (1 <= n <= 5), at least one of the bits in
   utf8chkmsk[n] should be non-zero (else the encoding could be
   shorter).
*/
static int utf8chkmsk[] = {
	0x0000007f,
	0x00000780,
	0x0000f800,
	0x001f0000,
	0x03e00000,
	0x7c000000,
};

static int
utf8_getchar(unsigned char **sp)
{
	unsigned char *s = *sp;
	int c;
	int n, m, mask;

	if (((c = *s++) & 0x80) == 0) {
		/* 7-bit char */
		*sp = s;
		return c;
	}
	for (n = 0, m = 0x40; c & m; n++, m >>= 1)
		;
	/* n now is number of 10xxxxxx bytes that should follow */
	if (n == 0 || n >= 6) {
		/* incorrect UTF-8 sequence */
		/* n==0: c == 10xxxxxx */
		/* n>=6: c == 1111111x */
		goto error;
	}

	mask = utf8chkmsk[n];
	c &= ~(0xFFC0 >> n);	/* remove non-x bits */
	while (--n >= 0) {
		c <<= 6;
		if (((m = *s++) & 0xC0) != 0x80) {
			/* incorrect UTF-8 sequence: byte is not 10xxxxxx */
			/* this includes end-of-string (m == 0) */
			goto error;
		}
		c |= m & 0x3F;
	}
	if ((c & mask) == 0) {
		/* incorrect UTF-8 sequence: not shortest possible */
		goto error;
	}
	*sp = s;		/* this is how far we got */
	return c;

  error:
	if (**sp)
		(*sp)++;
	return EOF;
}

static int
utf8_getchar_bstream(bstream *b)
{
	unsigned char *s = NULL;
	int c;
	int n, m, mask;

	if (b->pos >= b->len)
		if (bstream_next( b ) == 0)
			return EOF;

	s = b->buf + b->pos++;
	if (((c = *s) & 0x80) == 0) {
		/* 7-bit char */
		return c;
	}
	for (n = 0, m = 0x40; c & m; n++, m >>= 1)
		;
	/* n now is number of 10xxxxxx bytes that should follow */
	if (n == 0 || n >= 6 || (b->pos + n) > b->len) {
		/* incorrect UTF-8 sequence */
		/* n==0: c == 10xxxxxx */
		/* n>=6: c == 1111111x */
		goto error;
	}

	mask = utf8chkmsk[n];
	c &= ~(0xFFC0 >> n);	/* remove non-x bits */
	while (--n >= 0) {
		c <<= 6;
		b->pos ++;
		if (((m = *s++) & 0xC0) != 0x80) {
			/* incorrect UTF-8 sequence: byte is not 10xxxxxx */
			/* this includes end-of-string (m == 0) */
			goto error;
		}
		c |= m & 0x3F;
	}
	if ((c & mask) == 0) {
		/* incorrect UTF-8 sequence: not shortest possible */
		goto error;
	}
	return c;

  error:
	if (b->pos < b->len) 	/* skip bogus char */
		b->pos++;
	return EOF;
}

static int lex_getc(struct scanner * lc)
{
	int c = EOF;

	if (lc->rs) {
		c = utf8_getchar_bstream(lc->rs);
		if (c == EOF) {
			/* error: Incorrect UTF-8 sequence */
		}
	} else if (*lc->buf) {
		c = utf8_getchar((unsigned char**)&lc->buf);
		if (c == EOF) {
			/* error: Incorrect UTF-8 sequence */
		}
	}
	if (c == '\n')
		lc->lineno++;
	if (c == EOT)
		c = EOF;
	return c;
}

static void lex_append(struct scanner *lc, int ch)
{
	if (lc->yylen+4 >= lc->yysize) { /* keep space for EOS */
		lc->yysize *= 4;
		lc->yytext = RENEW_ARRAY(char, lc->yytext, lc->yysize);
		assert (lc->yytext);
	}
        if ((ch) < 0x80) {
		lc->yytext[lc->yylen++] = (ch);
        } else if ((ch) < 0x800) {
		lc->yytext[lc->yylen++] = 0xC0 | ((ch) >> 6);
		lc->yytext[lc->yylen++] = 0x80 | ((ch) & 0x3F);
        } else if ((ch) < 0x10000) {
		lc->yytext[lc->yylen++] = 0xE0 | ((ch) >> 12);
		lc->yytext[lc->yylen++] = 0x80 | (((ch) >> 6) & 0x3F);
		lc->yytext[lc->yylen++] = 0x80 | ((ch) & 0x3F);
        } else {
		lc->yytext[lc->yylen++] = 0xF0 | ((ch) >> 18);
		lc->yytext[lc->yylen++] = 0x80 | (((ch) >> 12) & 0x3F);
		lc->yytext[lc->yylen++] = 0x80 | (((ch) >> 6) & 0x3F);
		lc->yytext[lc->yylen++] = 0x80 | ((ch) & 0x3F);
        }
	lc->yytext[lc->yylen] = 0;
}

int keyword_or_ident(struct scanner * lc)
{
	keyword *k = NULL;
	int cur = 0;
	
	assert(lc->yylen == 0);

	lex_append(lc, lc->cur);
	while ((cur = lex_getc(lc)) != EOF) {
		if ((isascii(cur) && !isalnum(cur)) && cur != '_') {
			k = find_keyword(lc->yytext);
			if (k) {
				lc->yyval = k->token;
			} else {
				lc->yyval = IDENT;
			}
			lc->cur = cur;
			return lc->yyval;
		}
		lex_append(lc, cur);
	}
	k = find_keyword(lc->yytext);
	if (k) {
		lc->yyval = k->token;
	} else {
		lc->yyval = IDENT;
	}
	lc->cur = cur;
	return lc->yyval;
}

void skip_white_space(struct scanner * lc)
{
	int cur;
	while ((cur = lex_getc(lc)) != EOF && isspace(cur));
	lc->cur = cur;
}


int handle_error(mvc * lc)
{
	switch (lc->scanner.cur) {
	case EOF:
		(void)sql_error( lc, 1, "Unexpected end of input");
		return -1; /* EOF needs -1 result */
	default:
		(void)sql_error( lc, 1, "Unexpected control character");
	}
	return LEX_ERROR;
}

int skip_c_comment(struct scanner * lc)
{
	int cur;
	int prev = 0;
	while ((cur = lex_getc(lc)) != EOF && !(cur == '/' && prev == '*')) {
		prev = cur;
	}
	if (cur == '/')
		lc->cur = lex_getc(lc);
	return lc->cur;
}

int skip_sql_comment(struct scanner * lc)
{
	int cur;
	while ((cur = lex_getc(lc)) != EOF && (cur != '\n'));
	if (cur == '\n')
		lc->cur = lex_getc(lc);
	return lc->cur;
}

int context_yychar(struct scanner * lc, int yychar)
{
	lc->yytext[0] = (char) yychar;
	lc->yytext[1] = 0;
	lc->yyval = yychar;
	lc->yylen = 1;
	return lc->yyval;
}

int context_yy2char(struct scanner * lc, int yychar, int yyval)
{
	lc->yytext[0] = (char) yychar;
	lc->yytext[1] = (char) yychar;
	lc->yytext[2] = 0;
	lc->yyval = yyval;
	lc->yylen = 2;
	return lc->yyval;
}

int context_comparison(struct scanner * lc, char *yychar)
{
	int len = strlen(yychar);
	strncpy(lc->yytext, yychar, len);
	lc->yytext[len] = '\0';
	lc->yyval = COMPARISON;
	lc->yylen = len;
	return lc->yyval;
}

int lex_string(mvc * c, int quote)
{
	struct scanner *lc = &c->scanner;
	int cur = 0;
	int escape = 0;

	assert(lc->yylen == 0);

	lc->yytext[0] = 0;
	while ((cur = lex_getc(lc)) != EOF && (cur != quote || escape)) {
		if (cur == '\\' && !escape)
			escape = 1;
		else
			escape = 0;
		lex_append(lc, cur);
	}
	if (cur == EOF) {
		(void)sql_error( c, 2, "Unexpected end of input" );
		return LEX_ERROR;
	}
	lc->yyval = STRING;
	lc->cur = lex_getc(lc);
	return lc->yyval;
}

static int tokenize(mvc * lc);

int number(mvc * c, int len)
{
	struct scanner *lc = &c->scanner;
	char *yytext = lc->yytext;
	int token = sqlINT;
	int cur = 0;
	int yylen = len;
	int yysz = lc->yysize;
	/* todo start with . */

	yytext[len - 1] = lc->cur;

	while ((cur = lex_getc(lc)) != EOF && isdigit(cur)) {
		if (yylen == yysz) {
			yytext = RENEW_ARRAY(char, yytext, yysz << 1);
			yysz = yysz << 1;
		}
		yytext[yylen++] = (char) cur;
	}
	if (cur == '.') {
		token = INTNUM;
		if (yylen == yysz) {
			yytext = RENEW_ARRAY(char, yytext, yysz << 1);
			yysz = yysz << 1;
		}
		yytext[yylen++] = (char) cur;
		while ((cur = lex_getc(lc)) != EOF && isdigit(cur)) {
			if (yylen == yysz) {
				yytext = RENEW_ARRAY(char, yytext, yysz << 1);
				yysz = yysz << 1;
			}
			yytext[yylen++] = (char) cur;
		}
		if (cur == 'e' || cur == 'E') {
			token = APPROXNUM;
			if (yylen == yysz) {
				yytext = RENEW_ARRAY(char, yytext, yysz << 1);
				yysz = yysz << 1;
			}
			yytext[yylen++] = 'E';
			cur = lex_getc(lc);
			if (cur == '-' || cur == '+') {
				token = 0;
				if (yylen == yysz) {
					yytext =
					    RENEW_ARRAY(char, yytext, yysz<<1);
					yysz = yysz << 1;
				}
				yytext[yylen++] = (char) cur;
			}
			while ((cur = lex_getc(lc)) != EOF && isdigit(cur)) {
				token = APPROXNUM;
				if (yylen == yysz) {
					yytext =
					    RENEW_ARRAY(char, yytext, yysz<<1);
					yysz = yysz << 1;
				}
				yytext[yylen++] = (char) cur;
			}
		}
	}
	yytext[yylen] = 0;
	lc->yytext = yytext;
	lc->yylen = yylen;
	lc->yysize = yysz;
	if (token) {
		lc->yyval = token;
	} else if (yylen == 1) {
		if (yytext[0] == '-') {
			if (cur == '-') {
				if (skip_sql_comment(lc) == EOF)
					return lc->cur;
				return tokenize(c);
			} else {
				lc->cur = cur;
				return context_yychar(lc, yytext[0]);
			}
		} else if (yytext[0] == '+') {
			lc->cur = cur;
			return context_yychar(lc, yytext[0]);
		}
	} else {
		(void)sql_error( c, 2, "Unexpected symbol %c", lc->cur);
		return LEX_ERROR;
	}

	lc->cur = cur;
	return lc->yyval;
}


int lex_symbol(mvc * c)
{
	struct scanner *lc = &c->scanner;
	int cur = lc->cur;
	int next = 0;

	if (cur == '/') {
		next = lex_getc(lc);
		if (next == '*') {
			skip_c_comment(lc);
			return tokenize(c);
		} else {
			lc->cur = next;
			return context_yychar(lc, cur);
		}
	} else if (isdigit(cur)) {
		lc->cur = cur;
		return number(c, 1);
	} else if (cur == '#') {
		if (skip_sql_comment(lc) == EOF)
			return lc->cur;
		return tokenize(c);
	} else if (cur == '\'' || cur == '"') {
		return lex_string(c, cur);
	}
	switch (cur) {
	case '-':
		next = lex_getc(lc);
		if (next == '-') {
			if (skip_sql_comment(lc) == EOF)
				return lc->cur;
			return tokenize(c);
		}
		lc->cur = next;
		return context_yychar(lc, cur);
	case '%':
	case '+':
	case '*':
	case '/':
	case '(':
	case ')':
	case ',':
	case '.':
	case ';':
	case '=':
		lc->cur = lex_getc(lc);
		return context_yychar(lc, cur);
	case '<':
		lc->cur = lex_getc(lc);
		if (lc->cur == '=') {
			lc->cur = lex_getc(lc);
			return context_comparison(lc, "<=");
		} else if (lc->cur == '>') {
			lc->cur = lex_getc(lc);
			return context_comparison(lc, "<>");
		} else {
			return context_comparison(lc, "<");
		}
	case '>':
		lc->cur = lex_getc(lc);
		if (lc->cur != '=') {
			return context_comparison(lc, ">");
		} else {
			lc->cur = lex_getc(lc);
			return context_comparison(lc, ">=");
		}
	case '|':
		lc->cur = lex_getc(lc);
		if (lc->cur == '|') {
			lc->cur = ' ';
			return context_yy2char(lc, '|', CONCATSTRING);
		}
	}
	(void)sql_error( c, 3, "Unexpected symbol (%c)", lc->cur);
	lc->cur = ' ';
	return LEX_ERROR;
}

int tokenize(mvc * c)
{
	struct scanner *lc = &c->scanner;
	while (1) {
		if (isspace(lc->cur)) {
			skip_white_space(lc);
			if (lc->cur == EOF)
				return lc->cur;
		} else if (isdigit(lc->cur)) {
			return number(c, 1);
		} else if (isalpha(lc->cur) || lc->cur == '_') {
			return keyword_or_ident(lc);
		} else if (ispunct(lc->cur)) {
			return lex_symbol(c);
		}
		if (lc->cur == EOF || iscntrl(lc->cur))
			return handle_error(c);
	}
}

int sqllex(YYSTYPE * yylval, void *parm)
{
	mvc *c = (mvc *) parm;
	struct scanner *lc = &c->scanner;
	int token = lc->prev;

	lc->prev = 0;

	if (!token) {
		lc->yylen = 0;

		token = tokenize(c);
		yylval->sval = lc->yytext;

		if (token == UNION) {
			lc->yylen = 0;
			token = tokenize(c);
			yylval->sval = lc->yytext;
			if (token == JOIN) {
				cmd_add_token(c, "UNION JOIN");
				return UNIONJOIN;
			} else {
				lc->prev = token;
				yylval->sval = "UNION";
				cmd_add_token(c, "UNION");
				cmd_add_token(c, lc->yytext);
				return UNION;
			}
		} else {
			if (token == IDENT || token == COMPARISON ||
			    token == AGGR || token == TYPE ||
			    token == STRING)
				yylval->sval = _strdup(lc->yytext);

			if ( token == STRING )
				cmd_add_string(c, lc->yytext);
			else
				cmd_add_token(c, lc->yytext);
			lc->key ^= token;
		}
	}
	return token;
}
