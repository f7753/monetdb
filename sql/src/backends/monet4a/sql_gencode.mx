@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at 
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@' 
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@' 
@' The Original Code is the Monet Database System.
@' 
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2002 CWI.  
@' All Rights Reserved.
@' 
@' Contributor(s):
@' 		Martin Kersten <Martin.Kersten@cwi.nl>
@' 		Niels Nes <Niels.Nes@cwi.nl>
@' 		Stefan Manegold <Stefan.Manegold@cwi.nl>
@' 		Peter Boncz <Peter.Boncz@cwi.nl>

@f sql_gencode
@a N.J. Nes
@* 

@h
#ifndef _SQL_GENCODE_H_
#define _SQL_GENCODE_H_

#include "sql_server2.h"
#include "sql_session.h"
#include "sql_statement.h"
#include "sql_context.h"
#include "sql_scope.h"

sql_server_export int backend_dumpstmt( stmt *s, int *nr, backend *sql );
sql_server_export void backend_dumpproc( backend *be, int id, stmt *s );

#endif /*_SQL_GENCODE_H_*/

@c
#include <sql_gencode.h>
#include <string.h>

@(
		if (c->debug&8192) {
			char *sqzd_cmd = NULL;
			int misq_x = 0;
			CMDsqueezeStr2Str(&sqzd_cmd, cmd, &misq_x);
			if (sqzd_cmd && (sqzd_cmd != str_nil)) {
				/*_DELETE?*/free(cmd);
				cmd = sqzd_cmd;
			}
		}
@)


static void write_head( backend *sql, int nr )
{
        (void) nr; /* Stefan: unused!? */

	if (sql->debug&2){
		char *t0 = "t0 := time();\n";
		int l = strlen(t0);
		stream_write( sql->out, t0, 1, l );
	}
}

static void write_tail( backend *sql, int nr)
{
	if (sql->debug&2){
		char dbg[BUFSIZ];
		int l = snprintf( dbg, BUFSIZ,
		"t1 := time(); printf(\"%d %%d\\n\", t1 - t0);\n", nr);
		stream_write( sql->out, dbg, 1, l );
	}
}

static void write_part( backend *sql, char *buf, int len )
{
	buf[len] = '\0';
	stream_write( sql->out, buf, 1, len );

	if (sql->debug&8)
		fwrite( buf, 1, len, stderr);
}

static void write_command( backend *sql, char *buf )
{
	if (sql->debug&(1024+2048)) {
		int l;
		char v[BUFSIZ];
		char *s = _strdup(buf), *c = s;
		while ((c = strchr(c,'"')))	*c = '`';
		c = s;
		while ((c = strchr(c,'\n')))	*c = '\t';
		l = snprintf( v, BUFSIZ, "printf(\"< %s >\\n\");\n", s );
		stream_write( sql->out, v, 1, l );
		_DELETE(s);
	}
}

static void write_result( backend *sql, char *buf )
{
	if (sql->debug&(1024+2048)) {
		int l;
		char v[BUFSIZ], *a = buf, *b, *y, z;
		while (a && (y = strstr(a," := "))) {
			z = *y;
			*y = '\0';
			if ( (b = strrchr(a,' ' )))	a = b;
			if (!(b = strrchr(a,'\n')))	b = a;
			l = snprintf( v, BUFSIZ, 
				"if (type(%s) != 4) {"
				"	print(%s);"
				"} else {"
				"	var x := count(%s);"
				"	printf(\"| %%d * { %%s , %%s } |\\n\",x,head(%s),tail(%s));",
				b, b, b, b, b );
			if (sql->debug&2048) {
			    l += snprintf( v+l, BUFSIZ-l,
				"	if (x < 40) {"
				"		print(%s);"
				"	} else {"
				"		print(slice(%s,0,9));"
				"		print(\"...\");"
				"		print(sample(slice(%s,10,x - 11),10));"
				"		print(\"...\");"
				"		print(slice(%s,x - 10,x - 1));"
				"	}",
				b, b, b, b );
			}
			l += snprintf( v+l, BUFSIZ-l,
				"}\n") ;
			stream_write( sql->out, v, 1, l );
			*y = z;
			a = strchr(y,';');
		}
	}
}

static void dump( backend *sql, char *buf, int len, int nr )
{
	write_head(sql,nr);
	write_command(sql,buf);
	write_part(sql,buf,len);
	write_result(sql,buf);
	write_tail(sql,nr);
}

void mvc_dump_1( backend *sql, stmt *s, char *name, int *nr )
{
	char buf[BUFSIZ];
	int o1 = backend_dumpstmt(s->op1.stval, nr, sql);
	int len = snprintf( buf, BUFSIZ, 
		"s%d := mvc_%s(myc, s%d);\n", 
		-s->nr, name, o1);
	dump(sql,buf,len,-s->nr);
}

void mvc_dump_2( backend *sql, stmt *s, char *name, int *nr )
{
	char buf[BUFSIZ];
	int o1 = backend_dumpstmt(s->op1.stval, nr, sql);
	int o2 = backend_dumpstmt(s->op2.stval, nr, sql);
	int len = snprintf( buf, BUFSIZ, 
		"s%d := mvc_%s(myc, s%d, s%d);\n", 
		-s->nr, name, o1, o2);
	dump(sql,buf,len,-s->nr);
}

void mvc_dump_3( backend *sql, stmt *s, char *name, int *nr )
{
	char buf[BUFSIZ];
	int o1 = backend_dumpstmt(s->op1.stval, nr, sql);
	int o2 = backend_dumpstmt(s->op2.stval, nr, sql);
	int o3 = backend_dumpstmt(s->op3.stval, nr, sql);
	int len = snprintf( buf, BUFSIZ, 
		"s%d := mvc_%s(myc, s%d, s%d, s%d);\n", 
		-s->nr, name, o1, o2, o3);
	dump(sql,buf,len,-s->nr);
}

void mvc_dump_4( backend *sql, stmt *s, char *name, int *nr )
{
	char buf[BUFSIZ];
	int o1 = backend_dumpstmt(s->op1.stval, nr, sql);
	int o2 = backend_dumpstmt(s->op2.stval, nr, sql);
	int o3 = backend_dumpstmt(s->op3.stval, nr, sql);
	int o4 = backend_dumpstmt(s->op4.stval, nr, sql);
	int len = snprintf( buf, BUFSIZ, 
		"s%d := mvc_%s(myc, s%d, s%d, s%d, s%d);\n", 
		-s->nr, name, o1, o2, o3, o4);
	dump(sql,buf,len,-s->nr);
}

void mvc_dump_n( backend *sql, stmt *s, char *name, int *nr )
{
	char buf[BUFSIZ];
	node *n;

	int len = snprintf( buf, BUFSIZ, "s%d := mvc_%s(myc", -s->nr, name);
	for(n = s->op1.stval->op1.lval->h; n; n = n->next){
		int o = backend_dumpstmt(n->data, nr, sql);
		len += snprintf( buf+len, BUFSIZ-len, ", s%d", o);
	}
	len += snprintf( buf+len, BUFSIZ-len, ");\n");
	dump(sql,buf,len,-s->nr);
}

void dump_1( backend *sql, stmt *s, char *name, int *nr )
{
	char buf[BUFSIZ];
	int o1 = backend_dumpstmt(s->op1.stval, nr, sql);
	int len = snprintf( buf, BUFSIZ, 
		"s%d := s%d.%s;\n", 
		-s->nr, o1, name);
	dump(sql,buf,len,-s->nr);
}

void dump_2( backend *sql, stmt *s, char *name, int *nr )
{
	char buf[BUFSIZ];
	int o1 = backend_dumpstmt(s->op1.stval, nr, sql);
	int o2 = backend_dumpstmt(s->op2.stval, nr, sql);
	int len = snprintf( buf, BUFSIZ, 
		"s%d := %s(s%d, s%d);\n", 
		-s->nr, name, o1, o2);
	dump(sql,buf,len,-s->nr);
}

void dump_3( backend *sql, stmt *s, char *name, int *nr )
{
	char buf[BUFSIZ];
	int o1 = backend_dumpstmt(s->op1.stval, nr, sql);
	int o2 = backend_dumpstmt(s->op2.stval, nr, sql);
	int o3 = backend_dumpstmt(s->op3.stval, nr, sql);
	int len = snprintf( buf, BUFSIZ, 
		"s%d := %s(s%d, s%d, s%d);\n", 
		-s->nr, name, o1, o2, o3);
	dump(sql,buf,len,-s->nr);
}

int backend_dumpstmt( stmt *s, int *nr, backend *sql ){
    char buf[BUFSIZ+1];
    int len = 0;
    node *n;

    assert (*nr);

    buf[0] = '\0';
    if (s){
    	if (s->nr > 0) return s->nr;

	if (s->nr == 0)
		s->nr = -(*nr)++;

	switch(s->type){
	case st_none: 
		len = snprintf( buf, BUFSIZ, "none := \"none\";\n");
		dump(sql,buf,len,-s->nr);
		break;
	case st_load_module: 
		len = snprintf( buf, BUFSIZ, "module(\"%s\");\n", s->op4.sval);
		dump(sql,buf,len,-s->nr);
		break;
	case st_assign: {
		int val = backend_dumpstmt( s->op1.stval, nr, sql );
		len = snprintf( buf, BUFSIZ, "%s := s%d;\n",
			s->op4.sval, val);
		dump(sql,buf,len,-s->nr);
	}	break;
	case st_var: {
		len = snprintf( buf, BUFSIZ, "s%d := %s;\n",
			-s->nr, s->op1.sval);
		dump(sql,buf,len,-s->nr);
	}	break;
	case st_release: 
		mvc_dump_1( sql, s, "release", nr  ); 
		break;
	case st_commit: 
		mvc_dump_2( sql, s, "commit", nr  ); 
		break;
	case st_rollback: 
		mvc_dump_2( sql, s, "rollback", nr  ); 
		break;
	case st_schema: 
		mvc_dump_1( sql, s, "bind_schema", nr );
	 	break;
	case st_table: 
		mvc_dump_2( sql, s, "bind_table", nr );
	 	break;
	case st_column: 
		mvc_dump_2( sql, s, "bind_column", nr );
	 	break;
	case st_key: 
		mvc_dump_2( sql, s, "bind_key", nr );
	 	break;
	case st_create_schema: 
		mvc_dump_2( sql, s, "create_schema", nr );
		break;
	case st_drop_schema: 
		mvc_dump_2( sql, s, "drop_schema", nr );
		break;
	case st_create_view: 
		mvc_dump_3( sql, s, "create_view", nr );
		break;
	case st_create_table: 
		mvc_dump_3( sql, s, "create_table", nr );
		break;
	case st_drop_table: 
		mvc_dump_3( sql, s, "drop_table", nr );
		break;
	case st_create_column: 
		mvc_dump_n( sql, s, "create_column", nr );
		break;
	case st_null: 
		mvc_dump_2( sql, s, "null", nr );
	 	break;
	case st_default: 
		mvc_dump_2( sql, s, "default", nr );
		break;
	case st_create_key: 
		if (!s->op4.stval){
			mvc_dump_3( sql, s, "create_key", nr );
		} else {
			mvc_dump_4( sql, s, "create_key", nr );
		}
		break;
	case st_create_kc:
		mvc_dump_2( sql, s, "create_kc", nr );
		break;
	case st_drop_key:
		mvc_dump_2( sql, s, "drop_key", nr );
		break;
	case st_create_idx: 
		mvc_dump_3( sql, s, "create_idx", nr );
		break;
	case st_create_ic:
		mvc_dump_2( sql, s, "create_ic", nr );
		break;
	case st_drop_idx:
		mvc_dump_2( sql, s, "drop_idx", nr );
		break;
	case st_create_role: 
		mvc_dump_2( sql, s, "create_role", nr );
		break;
	case st_drop_role: 
		mvc_dump_1( sql, s, "drop_role", nr );
		break;
	case st_grant_role: 
		mvc_dump_2( sql, s, "grant_role", nr );
		break;
	case st_revoke_role: 
		mvc_dump_2( sql, s, "revoke_role", nr );
		break;
	case st_temp: 
		len = snprintf( buf, BUFSIZ, 
			"s%d := new(void,%s).seqbase(oid(0));\n", 
			-s->nr, s->op4.typeval->type->name );
		dump(sql,buf,len,-s->nr);
		break;
	case st_ibat: 
		s->nr = -backend_dumpstmt( s->op1.stval, nr, sql );
		break;
	case st_bat:
	case st_ubat: {
		char *type = (s->type==st_bat)?"":"_ubat";
		char *hname = NULL;
		if (s->h->type == st_basetable){
			hname = s->h->op1.tval->base.name;
		}
		len = snprintf( buf, BUFSIZ, 
			   "s%d := mvc_bind%s(myc, \"%s\", \"%s\", \"%s\", %d)",
			  -s->nr, type, 
			  s->op1.cval->t->s->base.name, 
			  s->op1.cval->t->base.name, 
			  s->op1.cval->base.name, s->flag);

		if (s->flag > RDONLY){
			len += snprintf( buf+len, BUFSIZ-len, 
			  		".access(BAT_WRITE)"); 
		}
		len += snprintf( buf+len, BUFSIZ-len, "; #%s\n", hname);
		if (sql->debug&4){
			len += snprintf( buf+len, BUFSIZ-len, 
				"s%d.info.print();", -s->nr);
		}
		/*dump(sql,buf,len,-s->nr);*/
		write_head(sql,-s->nr);
		write_command(sql,buf);
		write_part(sql,buf,len);
		write_result(sql,buf);
		write_tail(sql,-s->nr);
	} break;
	case st_dbat: {
		len = snprintf( buf, BUFSIZ, 
		  	"s%d := mvc_bind_dbat(myc, \"%s\", \"%s\", %d)",
			  -s->nr,  
			  s->op1.tval->s->base.name, 
			  s->op1.tval->base.name, 
			  s->flag);

		if (s->flag > RDONLY){
			len += snprintf( buf+len, BUFSIZ-len, 
		  		".access(BAT_WRITE)"); 
		}
		len += snprintf( buf+len, BUFSIZ-len, ";\n" ); 
		if (sql->debug&4){
			len += snprintf( buf+len, BUFSIZ-len, 
			"s%d.info.print();\n", -s->nr);
		}
		dump(sql,buf,len,-s->nr);
	} break;
	case st_idxbat: {
		len = snprintf( buf, BUFSIZ, 
		  	"s%d := mvc_bind_ibat(myc, \"%s\", \"%s\", \"%s\", %d)",
			  -s->nr, 
			  s->op1.idxval->t->s->base.name, 
			  s->op1.idxval->t->base.name, 
			  s->op1.idxval->base.name,
			  s->flag);

		if (s->flag > RDONLY){
			len += snprintf( buf+len, BUFSIZ-len, 
		  		".access(BAT_WRITE)"); 
		}
		len += snprintf( buf+len, BUFSIZ-len, ";\n" ); 
		if (sql->debug&4){
			len += snprintf( buf+len, BUFSIZ-len, 
			"s%d.info.print();\n", -s->nr);
		}
		dump(sql,buf,len,-s->nr);
	} break;
	case st_const: 
		dump_2( sql, s, "project", nr );
	 	break;
	case st_mark: 
		dump_2( sql, s, "mark", nr );
	 	break;
	case st_reverse: 
		dump_1( sql, s, "reverse", nr );
	 	break;
	case st_mirror: 
		dump_1( sql, s, "mirror", nr );
	 	break;
	case st_limit: {
		int l = backend_dumpstmt( s->op1.stval, nr, sql );
		int r = backend_dumpstmt( s->op2.stval, nr, sql );
		len = snprintf( buf, BUFSIZ, 
			"s%d := s%d.slice(0, s%d - 1);\n", -s->nr, l, r );
		dump(sql,buf,len,-s->nr);
	} 	break;
	case st_order: {
		int l = backend_dumpstmt( s->op1.stval, nr, sql );
		if (s->flag)
			len = snprintf( buf, BUFSIZ,
			"s%d := s%d.reverse().sort()", -s->nr, l );
		else 
			len = snprintf( buf, BUFSIZ,
			"s%d := s%d.reverse().sort_rev()", -s->nr, l );
		len += snprintf( buf+len, BUFSIZ-len, ".reverse();\n" );
		dump(sql,buf,len,-s->nr);
	} 	break;
	case st_reorder: {
		int l = backend_dumpstmt( s->op1.stval, nr, sql );
		int r = backend_dumpstmt( s->op2.stval, nr, sql );
		if (s->flag)
			len = snprintf( buf, BUFSIZ,
				"s%d := s%d.CTrefine(s%d)", -s->nr, l, r);
		else 
			len = snprintf( buf, BUFSIZ,
				"s%d := s%d.CTrefine_rev(s%d)", -s->nr, l, r);
		len += snprintf( buf+len, BUFSIZ-len, ";\n" );
		dump(sql,buf,len,-s->nr);
	} 	break;

	case st_select: 
	case st_uselect: {
		int l = backend_dumpstmt( s->op1.stval, nr, sql );
		int r = backend_dumpstmt( s->op2.stval, nr, sql );
		if (s->op2.stval->nrcols >= 1){
			char *op = "=";
			switch(s->flag){
			case cmp_equal: op = "="; break;
			case cmp_notequal: op = "!="; break;
			case cmp_lt: op = "<"; break;
			case cmp_lte: op = "<="; break;
			case cmp_gt: op = ">"; break;
			case cmp_gte: op = ">="; break;
			default:
				len = snprintf( buf, BUFSIZ, 
					"error impossible\n");
	  		} 
			len = snprintf( buf, BUFSIZ, 
				"s%d := [%s](s%d,s%d).uselect(TRUE);\n", 
				-s->nr, op, l, r ); 
		} else {
		char *cmd;
		if (s->type == st_select)
			cmd="select";
		else
			cmd="uselect";
		switch(s->flag){
		case cmp_like:
			len = snprintf( buf, BUFSIZ, 
				"s%d := s%d.likeselect(s%d);\n", -s->nr, l, r ); 
			break;
		case cmp_notlike:
			(void)(*nr)++; 
			len = snprintf( buf, BUFSIZ, 
				"s%d := s%d.likeselect(s%d);\n", *nr, l, r ); 
			len += snprintf( buf+len, BUFSIZ, 
				"s%d := s%d.kdiff(s%d);\n", -s->nr, l, *nr );
			break;
		case cmp_equal:
			len = snprintf( buf, BUFSIZ, 
				"s%d := s%d.%s(s%d);\n", -s->nr, l, cmd, r ); 
			break;
		case cmp_notequal:
			(void)(*nr)++; 
			len = snprintf( buf, BUFSIZ, 
				"s%d := s%d.uselect(s%d);\n", *nr, l, r ); 
			len += snprintf( buf+len, BUFSIZ, 
				"s%d := s%d.kdiff(s%d);\n", -s->nr, l, *nr );
			break;
		case cmp_lt:
			len = snprintf( buf, BUFSIZ, 
			  "s%d := s%d.%s(%s(nil), s%d, FALSE, FALSE);\n", 
			  -s->nr, l, cmd, tail_type(s)->type->name, r ); 
			break;
		case cmp_lte:
			len = snprintf( buf, BUFSIZ, 
			  "s%d := s%d.%s(%s(nil), s%d);\n", 
			  -s->nr, l, cmd, tail_type(s)->type->name, r ); 
			break;
		case cmp_gt:
			len = snprintf( buf, BUFSIZ, 
			  "s%d := s%d.%s(s%d, %s(nil), FALSE, FALSE);\n", 
			  -s->nr, l, cmd, r, tail_type(s)->type->name ); 
			break;
		case cmp_gte: 
			len = snprintf( buf, BUFSIZ, 
			  "s%d := s%d.%s(s%d, %s(nil));\n", 
			  -s->nr, l, cmd, r, tail_type(s)->type->name ); 
			break;
		default:
			len = snprintf( buf, BUFSIZ, 
					"error impossible\n");
	  	} 
		}
		dump(sql,buf,len,-s->nr);
	} break;
	case st_select2: 
	case st_uselect2: {
		int l = backend_dumpstmt( s->op1.stval, nr, sql );
		int r1 = backend_dumpstmt( s->op2.stval, nr, sql );
		int r2 = backend_dumpstmt( s->op3.stval, nr, sql );
		char *bits = NULL;
		char *cmd;
		if (s->type == st_select2)
			cmd="select";
		else
			cmd="uselect";
		switch(s->flag){
		case 0: 
			bits = ", FALSE, FALSE";
			break;
		case 1: 
			bits = ", FALSE, TRUE";
			break;
		case 2: 
			bits = ", TRUE, FALSE";
			break;
		case 3: 
			bits = ", TRUE, TRUE";
			break;
		}
		len = snprintf( buf, BUFSIZ, 
		  "s%d := s%d.%s(s%d, s%d%s);\n", 
		  -s->nr, l, cmd, r1, r2, bits ); 
		dump(sql,buf,len,-s->nr);
	} break;
	case st_semijoin: 
		dump_2( sql, s, "semijoin", nr );
		break;
	case st_diff: 
		dump_2( sql, s, "kdiff", nr );
		break;
	case st_union: 
		dump_2( sql, s, "kunion", nr );
		break;
	case st_reljoin: {
		if (list_length(s->op1.lval) == 1) {
			int l = backend_dumpstmt( s->op1.lval->h->data, nr, sql );
			int r = backend_dumpstmt( s->op2.lval->h->data, nr, sql );
			len = snprintf( buf, BUFSIZ,
			  "s%d := join(s%d,reverse(s%d));\n", -s->nr, l, r);
		} else {
			node *ln = NULL, *rn = NULL;
			char x = '(';
			len = snprintf( buf, BUFSIZ,
			  "s%d := ds_link", -s->nr );
			for (ln = s->op1.lval->h, rn = s->op2.lval->h; ln && rn; ln = ln->next, rn = rn->next) {
				int l = backend_dumpstmt( ln->data, nr, sql );
				int r = backend_dumpstmt( rn->data, nr, sql );
				len += snprintf(buf +len, BUFSIZ-len,
				  "%c s%d, s%d", x, l, r );
				x = ',';
			}
			len += snprintf(buf +len, BUFSIZ-len, 
			  " );\n");
		}
		dump(sql,buf,len,-s->nr);
	} break;
	case st_outerjoin:
	case st_join: {
		int l = backend_dumpstmt( s->op1.stval, nr, sql );
		int r = backend_dumpstmt( s->op2.stval, nr, sql );
		char *jt = "join";
		if (s->type == st_outerjoin)
			jt = "outerjoin";
		switch(s->flag){
		case cmp_equal:
			len = snprintf( buf, BUFSIZ, 
			  "s%d := s%d.%s(s%d);\n", -s->nr, l, jt, r ); 
			break;
		case cmp_notequal:
			len = snprintf( buf, BUFSIZ, 
			  "s%d := s%d.%s(s%d, \"!=\");\n", -s->nr, l, jt, r ); 
			break;
		case cmp_lt:
			len = snprintf( buf, BUFSIZ, 
			  "s%d := s%d.%s(s%d, \"<\");\n", -s->nr, l, jt, r ); 
			break;
		case cmp_lte: 
			len = snprintf( buf, BUFSIZ, 
			  "s%d := s%d.%s(s%d, \"<=\");\n", -s->nr, l, jt, r );
			break;
		case cmp_gt: 
			len = snprintf( buf, BUFSIZ, 
			  "s%d := s%d.%s(s%d, \">\" );\n", -s->nr, l, jt, r); 
			break;
		case cmp_gte: 
			len = snprintf( buf, BUFSIZ, 
			  "s%d := s%d.%s(s%d, \">=\" );\n", -s->nr, l, jt, r);
			break;
		case cmp_all: /* aka cross table */
			len = snprintf( buf, BUFSIZ, 
			"s%d := s%d.project(0).join(s%d.reverse().project(0).reverse());\n", -s->nr, l, r ); 
			break;
		default:
			len = snprintf( buf, BUFSIZ, 
					"error impossible\n");
	  	} 
		if (sql->debug&4){
			len += snprintf(buf +len, BUFSIZ-len, 
				"s%d.info.print;\n", -s->nr);
		}
		dump(sql,buf,len,-s->nr);
	} break;
	case st_group: 
		dump_1( sql, s, "CTgroup", nr );
		break;
	case st_group_ext: 
		dump_1( sql, s, "tunique.mirror", nr );
		break;
	case st_derive: 
		dump_2( sql, s, "CTgroup", nr );
		break;
	case st_unique: {
		int l = backend_dumpstmt( s->op1.stval, nr, sql );
		if (s->op2.stval){
			int g = backend_dumpstmt( s->op2.stval, nr, sql );

		  	len += snprintf( buf+len, BUFSIZ-len, 
			/*"s%dg := s%d.CTunique(s%d);\n", -s->nr, g, l);*/
			"s%dg := s%d.CTgroup(s%d);\n", -s->nr, g, l);
		  	len += snprintf( buf+len, BUFSIZ-len, 
			"s%de := s%dg.tunique().mirror();\n", -s->nr, -s->nr);
			/*"s%de := s%dg.reverse.kunique.mirror;\n", -s->nr, -s->nr);*/
		  	len += snprintf( buf+len, BUFSIZ-len, 
			"s%d := s%d.semijoin(s%de);\n", -s->nr, l, -s->nr );
		} else {
		  	len += snprintf( buf+len, BUFSIZ-len, 
			"s%d := s%d.reverse().kunique().reverse();\n", 
			-s->nr, l);
		}
		dump(sql,buf,len,-s->nr);
	} 	break;
	case st_op: {
		len = snprintf( buf, BUFSIZ, 
		   "s%d := %s();\n", -s->nr, s->op4.funcval->func->imp);
		dump(sql,buf,len,-s->nr);
	} 	break;
	case st_unop: {
		int l = backend_dumpstmt( s->op1.stval, nr, sql );

		if (s->op1.stval->nrcols){
		  sql_subtype *v, *a;
		  a = tail_type(s);
		  v = tail_type(s->op1.stval);
		  if (  a->type->localtype == v->type->localtype &&
			strcmp(s->op4.funcval->func->name, "convert") == 0 )
		   len = snprintf( buf, BUFSIZ, "s%d := s%d;\n", -s->nr, l);
		  else
		   len = snprintf( buf, BUFSIZ, 
		   "s%d := [%s](s%d);\n", -s->nr, s->op4.funcval->func->imp, l);
		} else 
		  len = snprintf( buf, BUFSIZ, 
		   "s%d := %s(s%d);\n", -s->nr, s->op4.funcval->func->imp, l);
		 dump(sql,buf,len,-s->nr);
	} 	break;
	case st_binop: {
		int l = backend_dumpstmt( s->op1.stval, nr, sql );
		int r = backend_dumpstmt( s->op2.stval, nr, sql );
		if (s->op1.stval->nrcols || s->op2.stval->nrcols ){
/*
		  	if (!s->op1.stval->nrcols){
				int n = (*nr)++; 
		  		len += snprintf( buf+len, BUFSIZ-len, 
		    		"s%d := [s%d ~ s%d];\n", n, r, l ); 
				l = n;
		  	}
		  	if (!s->op2.stval->nrcols){
				int n = (*nr)++; 
		  		len += snprintf( buf+len, BUFSIZ-len, 
		    		"s%d := [s%d ~ s%d];\n", n, l, r ); 
				r = n;
		  	}
*/
		  	len += snprintf( buf+len, BUFSIZ-len, 
		    	"s%d := [%s](s%d,s%d);\n", 
			-s->nr, s->op4.funcval->func->imp, l, r );
		} else  {
		  	len += snprintf( buf+len, BUFSIZ-len, 
		    	"s%d := %s(s%d,s%d);\n", 
			-s->nr, s->op4.funcval->func->imp, l,r );
		}
		dump(sql,buf,len,-s->nr);
	} 	break;
	case st_Nop: {
		int opslen = 0;
		char ops[BUFSIZ];
		node *n;

		backend_dumpstmt(s->op1.stval, nr, sql); /* dump operants */
		write_head(sql,-s->nr);
		if (s->nrcols){
		    stmt *h;
		    for (n=s->op1.stval->op1.lval->h, h=n->data; n; n=n->next){
			stmt *op = n->data;
			if (op->nrcols > h->nrcols)
				h = op;
		    }
		
		    for (n = s->op1.stval->op1.lval->h; n; n=n->next){
			stmt *op = n->data;
			int n = op->nr;
/*
		  	if (!op->nrcols){
				n = (*nr)++; 
		  		len = snprintf( buf, BUFSIZ, 
		    		"s%d := [ s%d ~ s%d];\n", n, h->nr, op->nr); 
				write_part(sql,buf,len);
		  	}
*/
			opslen += snprintf(ops+opslen, BUFSIZ-opslen, 
			 "%cs%d", (opslen)?',':' ', n);
		    }
		    len = snprintf( buf, BUFSIZ, 
		    	"s%d := [%s](%s);\n", 
			-s->nr, s->op4.funcval->func->imp, ops );
		} else {
		    for (n = s->op1.stval->op1.lval->h; n; n=n->next){
			stmt *op = n->data;
			int n = op->nr;

			opslen += snprintf(ops+opslen, BUFSIZ-opslen, 
			 "%cs%d", (opslen)?',':' ', n);
		    }
		    len = snprintf( buf, BUFSIZ, 
		      	"s%d := %s(%s);\n", 
			-s->nr, s->op4.funcval->func->imp, ops);
		}
		write_part(sql,buf,len);
		write_command(sql,buf);
		write_result(sql,buf);
		write_tail(sql,-s->nr);
	} 	break;
	case st_aggr: {
		int l = backend_dumpstmt( s->op1.stval, nr, sql );
		if (s->op3.gval){
			int g = backend_dumpstmt( s->op2.stval, nr, sql );
			int e = backend_dumpstmt( s->op3.stval, nr, sql );
			len += snprintf( buf+len, BUFSIZ-len, 
			"s%d := {%s}(s%d, s%d, s%d);\n", 
				-s->nr, s->op4.aggrval->aggr->imp, l, g, e);
		} else {
			len += snprintf( buf+len, BUFSIZ-len, 
				"s%d := s%d.%s();\n", 
				-s->nr, l, s->op4.aggrval->aggr->imp );
		}
		dump(sql,buf,len,-s->nr);
	} 	break;
	case st_atom: {
		write_head(sql,-s->nr);
		len = snprintf( buf, BUFSIZ, "s%d := ", -s->nr);
		write_command(sql,buf);
		write_part(sql,buf,len);
		atom_dump(s->op1.aval, sql->out);
		len = snprintf( buf, BUFSIZ, ";\n");
		write_part(sql,buf,len);
		len = snprintf( buf, BUFSIZ, "s%d := ", -s->nr);
		write_result(sql,buf);
		write_tail(sql,-s->nr);
	} break;
	case st_insert: {
		int l = backend_dumpstmt( s->op1.stval, nr, sql );
		int r = backend_dumpstmt( s->op2.stval, nr, sql );
		if (s->op2.stval->nrcols){
			len = snprintf( buf, BUFSIZ, 
		  	"s%d := insert(s%d.access(BAT_WRITE),s%d);\n", -s->nr, l, r);
		} else {
			len = snprintf( buf, BUFSIZ, 
		  	"s%d := insert(s%d,s%d);\n", -s->nr, l, r);
		}
		dump(sql,buf,len,-s->nr);
	} break;
	case st_append: {
		int l = backend_dumpstmt( s->op1.stval, nr, sql );
		int r = backend_dumpstmt( s->op2.stval, nr, sql );
		/*
		if (s->op2.stval->nrcols){
		*/
			len = snprintf( buf, BUFSIZ, 
		  	"s%d := append(s%d.access(BAT_WRITE),s%d);\n", -s->nr, l, r);
		/*
		} else {
			len = snprintf( buf, BUFSIZ, 
		  	"s%d := append(s%d,s%d);\n", -s->nr, l, r);
		}
		*/
		dump(sql,buf,len,-s->nr);
	} break;
	case st_replace: {
		int l = backend_dumpstmt( s->op1.stval, nr, sql );
		int r = backend_dumpstmt( s->op2.stval, nr, sql );
		len += snprintf( buf+len, BUFSIZ-len, 
		  "s%d := replace(s%d.access(BAT_WRITE),s%d);\n", -s->nr, l, r);
		dump(sql,buf,len,-s->nr);
	} break;
	case st_exception: {
		int l = backend_dumpstmt( s->op1.stval, nr, sql );
		int r = backend_dumpstmt( s->op2.stval, nr, sql );
		len += snprintf( buf+len, BUFSIZ-len, 
		  "if (bit(s%d)){ ERROR(s%d); }\n", l, r);
		dump(sql,buf,len,-s->nr);
	}
	case st_alias: 
	case st_column_alias: 
		s->nr = - backend_dumpstmt( s->op1.stval, nr, sql );
		break;
	case st_set: 
	case st_list: {
		for (n = s->op1.lval->h; n; n = n->next ){
			(void)backend_dumpstmt( n->data, nr, sql );
		}
	} break;
	case st_sets: {
		for(n = s->op1.lval->h; n; n = n->next ){
			list *l = n->data;
			node *m = l->h;
			while(m){
				(void)backend_dumpstmt( m->data, nr, sql );
				m = m->next;
			}
		}
	} break;
	case st_find: 
		dump_2( sql, s, "find", nr );
		break;
	case st_bulkinsert: {
		char *tname = s->op1.stval->op1.tval->base.name;
		int sep =  backend_dumpstmt( s->op2.stval, nr, sql );
		int rsep =  backend_dumpstmt( s->op3.stval, nr, sql );

		if (s->op4.stval){
			int file =  backend_dumpstmt( s->op4.stval, nr, sql );
			len += snprintf( buf+len, BUFSIZ-len, 
			"f%d := open_rastream(iconv(s%d, \"UTF-8\", codeset()));\n", file, file);
			len += snprintf( buf+len, BUFSIZ-len, 
		    	"s%d := mvc_import_table( myc, f%d, \"%s\", s%d, s%d, %d);\n",
			-s->nr, file, tname, sep, rsep, s->flag );
			len += snprintf( buf+len, BUFSIZ-len, 
			"stream_close(f%d);\n", file );
		} else {
			len += snprintf( buf+len, BUFSIZ-len, 
		        "s%d := mvc_import_table( myc, Input, \"%s\", s%d, s%d, %d);\n",
			-s->nr, tname, sep, rsep, s->flag );
		}
		dump(sql,buf,len,-s->nr);
	} break;
	case st_senddata: {
		len += snprintf( buf+len, BUFSIZ-len, "senddata(Output);\n");
		dump(sql,buf,len,-s->nr);
	} break;
	case st_export: {
		int o1 = backend_dumpstmt(s->op1.stval, nr, sql);
		int o2 = backend_dumpstmt(s->op2.stval, nr, sql);
		int o3 = backend_dumpstmt(s->op3.stval, nr, sql);
		int len = snprintf( buf, BUFSIZ, 
		    "s%d := mvc_export_table(myc, Output, s%d, s%d, s%d);\n", 
			-s->nr, o1, o2, o3);
		dump(sql,buf,len,-s->nr);
	}
	case st_filter:
		s->nr = -backend_dumpstmt( s->op1.stval, nr, sql );
		break;
	case st_ordered: {
		int l =  backend_dumpstmt( s->op1.stval, nr, sql );
		(void)backend_dumpstmt( s->op2.stval, nr, sql );
		s->nr = -l;
	} break;
	case st_output: {
		stmt *order = NULL;
		stmt *lst = s->op1.stval;
		backend_dumpstmt( lst, nr, sql );

		write_head(sql,-s->nr);
		if (sql->debug&1){
			if (lst->type == st_list){
				list *l = lst->op1.lval;

				n = l->h;
				while(n){
					stmt *r = n->data;
					len += snprintf( buf+len, BUFSIZ-len,
						"print(s%d);\n", r->nr);
					n = n->next;
				}
			}
		}
		if (sql->debug&32){
			len += snprintf( buf+len, BUFSIZ-len,
			"stream_write(Output,\"0\\n\");stream_flush(Output);\n");
			if (lst->type == st_list){
				list *l = lst->op1.lval;

				n = l->h;
				len += snprintf( buf+len, BUFSIZ-len, 
						"table(\n");
				if (n){
					stmt *r = n->data;
					len += snprintf( buf+len, BUFSIZ-len,
						"s%d", r->nr);
					n = n->next;
				}
				while(n){
					stmt *r = n->data;
					len += snprintf( buf+len, BUFSIZ-len,
						", s%d", r->nr);
					n = n->next;
				}
				len += snprintf( buf+len, BUFSIZ-len, ");\n");
			}
			break;
		}
		if (len) {
			write_command(sql,buf);
			write_part(sql,buf,len);
		}
		len = 0;
		if (lst->type == st_ordered){
			order = lst->op1.stval; 
			lst = lst->op2.stval; 
		}
		if (lst->type == st_list){
			list *l = lst->op1.lval;
			int cnt = list_length(l);

			n = l->h;
			if (n){
			  if (!order){
			    order = n->data;
			  }
			}
			len = snprintf( buf, BUFSIZ,
				"s%d := mvc_result_table(myc, %d, s%d);\n", 
					-s->nr, cnt, order->nr);
			write_command(sql,buf);
			write_part(sql,buf,len);
			len = 0;
			for(; n; n = n->next){
				stmt *r = n->data;
				len = snprintf( buf, BUFSIZ,
					"mvc_result_column(myc, \"%s\", \"%s\", %d, %d, s%d);\n", 
					column_name(r),
					tail_type(r)->type->sqlname,
					tail_type(r)->digits,
					tail_type(r)->scale,
				        r->nr
				);
				write_command(sql,buf);
				write_part(sql,buf,len);
				len = 0;
			}
			len = snprintf( buf, BUFSIZ,
				"mvc_export_result(myc, Output, s%d);\n", 
					-s->nr );
			/* send first part (or all) */
			len += snprintf( buf+len, BUFSIZ-len,
				"mvc_export_table(myc, Output, s%d, 0, int(reply_size));\n", 
					-s->nr );
			write_command(sql,buf);
			write_part(sql,buf,len);
			len = 0;
		} else {
			fprintf(stderr, "not a valid output list %d %d %d\n",
					lst->type, st_list, st_ordered);
		}
		write_tail(sql,-s->nr);
	} break;

	/* should not appear here */
	case st_relselect:
	case st_intersect: 
	/* todo */
	case st_grant:
	case st_revoke:

	case st_basetable: /* relation(table) */
	case st_ptable:
	case st_pivot:
	case st_partial_pivot:
	case st_idx:
		printf("backend_dumpstmt: not implemented stmt %s\n", st_type2string(s->type));
		assert(0);
	}

    	if (s->nr > 0) 
		assert(s->nr <= 0);
	else
		s->nr = -s->nr;

    	return s->nr;
    }
    return 0;
}

void backend_dumpproc( backend *be, int id, stmt *s )
{
	int nr = 1;
	int i = 0;
	char buf[BUFSIZ];
	node *n;

	i = snprintf( buf, BUFSIZ, "proc sql%d (", id);
	if (be->context->params){
		for (n = be->context->params->h; n; n = n->next){
			var_ *v = n->data;

			i += snprintf(buf+i, BUFSIZ-i, "%s %s%c", 
				v->s->op2.typeval->type->name,
				v->name, (n->next)?',':' '
				);
		}
	}
	i += snprintf(buf+i, BUFSIZ-i, ") : void {\n");
	stream_write(be->out, buf, i, 1); 

    	backend_dumpstmt( s, &nr, be );

	stream_write(be->out, "}\n", 2, 1);
}
	

