@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at 
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@' 
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@' 
@' The Original Code is the Monet Database System.
@' 
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2002 CWI.  
@' All Rights Reserved.
@' 
@' Contributor(s):
@' 		Martin Kersten <Martin.Kersten@cwi.nl>
@' 		Niels Nes <Niels.Nes@cwi.nl>
@' 		Stefan Manegold <Stefan.Manegold@cwi.nl>
@' 		Peter Boncz <Peter.Boncz@cwi.nl>

@f sql_session
@a N.J. Nes
@* 

@* Session code

This small module contains the code to instantiate an SQL client.
This code strongly depends on the front-end/back-end setup.

@h
#ifndef _SQL_SESSION_H_
#define _SQL_SESSION_H_

#include "sql_server.h"
#include <sql_backend.h>
#include <monet_context.h>
#include <kernel.h>

extern int mvc_export_result( mvc *c, stream *s, int res_id );
extern int mvc_export_table( mvc *c, stream *s, int res_id, int offset, int nr);
extern BAT *mvc_import_table( mvc *c, stream *s, char *tname, char *sep, char *rsep, int nr);

extern int debug_cmd( context *c, char *cmd, stream *out, int part );
extern void monet4_freestack( backend_stack stk );
extern void monet4_freecode( backend_code code );
#endif /*_SQL_SESSION_H_*/
@c
#include "sql_session.h"
#include "sql_server.h"
#include "sql_gencode.h"	/* for stmt_dump() */
#include <sql_context.h>
#include <sql_scope.h>
#include <sql_qc.h>
#include <sql_parser.h>		/* for sqlparse() */

@= builtin_operand
{       int _k = interpret(stk, arg(lt, @1), res);
        if (_k < 0) {
                return _k;
        }
        @3 = VALconvert(@2, res);
        if ((@3 == ILLEGALVALUE)  || (@2 == TYPE_bat && !@3)) {
                return handle_paramerror(res,@1,res->vtype,@2);
        }
}
@c

static YYSTREE milnode(int tok, int tpe, ptr valp) 
{
        YYSTREE res = yynode(tok, tpe);
        VALset(&res->yyval, tpe, valp);
        return res;
}

static YYSTREE milnode2(int tok, ValPtr valp) 
{
        YYSTREE res = yynode(tok, valp->vtype);
	res->yyval = *valp;
        return res;
}

void backend_dumpproc( context *c, int id, stream *cout, stmt *s )
{
	int nr = 1;
	int i = 0;
	char buf[BUFSIZ];
	node *n;

	i = snprintf( buf, BUFSIZ, "proc sql%d (", id);
	if (c->params){
		for (n = c->params->h; n; n = n->next){
			var_ *v = n->data;

			i += snprintf(buf+i, BUFSIZ-i, "%s %s%c", 
				v->s->op2.typeval->type->name,
				v->name, (n->next)?',':' '
				);
		}
	}
	i += snprintf(buf+i, BUFSIZ-i, ") : void {\n");
	stream_write(cout, buf, i, 1); 

    	stmt_dump( s, &nr, c );

	stream_write(cout, "}\n", 2, 1);
}
	
int backend_parse( context *c, char *cmd, Cntxt stack )
{
	int err = 0;
	(void) c; /* Stefan: unused!? */

	if (cmd){
		ValRecord v;

		v.vtype = TYPE_void;

		err = interpret_str( stack, cmd, &v);
	}
	return err;
}

Cntxt backend_newstack( Cntxt stk )
{
	Cntxt procstk;

	procstk = CNTXTnew(stk);
	CNTXTuse(procstk);
	monet_cntxt[procstk].reuse = TRUE;

	return procstk;
}

void monet4_freestack( backend_stack stk )
{
	Cntxt procstk = (Cntxt)(ptrdiff_t)stk;

	monet_cntxt[procstk].reuse = FALSE;
	CNTXTfree1(procstk);
}

void monet4_freecode( backend_code code )
{
	YYSTREE procnode = (YYSTREE)code;
	if (code){
		/* clear arguments */
		int i;
		int l = procnode->yysons[1]->cnt;
		ValPtr argv = (ValPtr) procnode->yysons[1]->yyval.val.pval;

		for (i=1; i<l; i++){
			argv[i].vtype = TYPE_void; 
			argv[i].len = 0; 
		}
	}
}

YYSTREE backend_interpret( Cntxt procstk, char *name, list *args )
{
	YYSTREE procnode;
	YYSTREE argtree;
	node *n;
	int err = 0;
	ValRecord v;

	v.vtype = TYPE_void;
	procnode = milnode(TOK_FUNCTION, TYPE_str, _strdup(name)); 
 	argtree = yynode(0,0); 
	if (args){
  		for (n=args->h; n; n = n->next){
			atom *a = n->data;
			YYSTREE arg = milnode2(TOK_CONSTANT, &a->data );
				/* todo cleanup should first remove
				   these nodes, without cleaning the
				   shared values!! */

       			argtree = yyexpand(argtree, arg);
		}
	}
	yyexpand(procnode, argtree);
	yyexpand(procnode, yynode(0,TYPE_int));
	err = interpret( procstk, procnode, &v);

	(void) err;	/* Stefan: unused!? */

	return procnode;
}

int backend_fastpath( Cntxt procstk, YYSTREE procnode, list *args )
{
	int err = 0;
	ValRecord v;
	node *n;

	v.vtype = TYPE_void;
	if (args){
		int i;

		ValPtr argv = (ValPtr) procnode->yysons[1]->yyval.val.pval;
	  	for (i=1, n=args->h; n; i++, n = n->next){
			atom *a = n->data;
			argv[i] = a->data;
		}
	}
	err = interpret( procstk, procnode->yysons[1]->yysons[0], &v);
	return err;
}


int connect_error(stream *in, stream *out, int sock)
{
	close_stream(in);
	close_stream(out);
	close(sock);
	return GDK_FAIL;
}

int sqlexecute(context * c, stream *out, Cntxt stk )
{
	stream *cout = c->out;
	char *cmd = NULL, *s;
	int i, err = 0;
	cq *q = NULL;

	cmd_init(c);

	s = c->buf;

	c->mvc->type = Q_PARSE;
	c->mvc->status = 0;

	if ((err = sqlparse(c)) || c->mvc->status || !c->sym) {
		if (!err)
			err = c->mvc->status;
		return sqlcleanup(c, cmd, err);
	}
	
	if (c->trace){
		char *buf = s;

		char old = *c->buf;

		*c->buf = '\0';
		*c->buf = old;

		if (!stream_writeInt( out, Q_DEBUGP ) ||
		    !stream_writeInt( out, 1 ))
			return -1;

		while( buf < c->buf) {
			int i;
			char b[BUFSIZ];

		  	while( *buf != '\n' && buf < c->buf) 
				buf++;
			i = snprintf(b, BUFSIZ, "# %5d: ", c->cnt);
		  	if (stream_write(out, b, 1, i) != i ||
		  	    stream_write(out, s, 1, buf - s) != (buf-s) ||
			    stream_write(out, "\n", 1, 1) != 1)
				return -1;

			s = ++buf;
		}
		c->cnt++;
		stream_flush(out);
	}
	if ( !(q = qc_find(c->qc, c->sym, c->params, c->key)) ){
		stmt *s = sql_symbol2stmt(c);

		if (!s && c->mvc->status){
			err = c->mvc->status;
			return sqlcleanup(c, cmd, err);
		}

		backend_dumpproc( c, c->qc->id, cout, s );
		cmd = buffer_get_buf(c->outbuf);
    		stream_flush( cout );
		stmt_destroy(s);
	
		if (c->debug&64){
			err = debug_cmd(c, cmd, out, 1);
		} else {
			err = backend_parse( c, cmd, stk );
		} 
		q = qc_insert(c->qc, c->sym, c->params, c->key, c->mvc->type );

		c->sym = NULL;
		c->params = NULL;

		/* beware to use free instead of _DELETE
 	 	 * as the stream library is build with out 
	 	 * libbat ie. it cannot use gdkmalloc 
	 	 * can be used */
	        free(cmd); 
		cmd = NULL;

		if (err)
			return sqlcleanup(c, cmd, err);
	}
	if (c->debug){
		char buf[BUFSIZ];
		node *n;

		i = snprintf(buf, BUFSIZ, "sql%d (", q->id );
		stream_write(cout, buf, i, 1 );
		if (c->args){
	  		for (n=c->args->h; n; n = n->next){
				atom *a = n->data;
				atom_dump(a, cout);
				if (n->next)
					stream_write(cout, ",", 1, 1); 
			}
		}
		stream_write(cout, ");\n", 3, 1);

		cmd = buffer_get_buf(c->outbuf);
    		stream_flush( cout );
		if (c->debug&64){
			err = debug_cmd(c, cmd, out, 0);
		} else {
			err = backend_parse( c, cmd, stk );
		} 
	} else if (!q->code){
		char buf[BUFSIZ];
		Cntxt procstk = backend_newstack(stk);
		YYSTREE procnode;

		snprintf( buf, BUFSIZ, "sql%d", q->id);

		c->mvc->type = q->type;
		procnode = backend_interpret( procstk, buf, c->args);

		if (!err){
			q->code = (backend_code)procnode;
			q->stk = (backend_stack)(ptrdiff_t)procstk;
		} else {
			backend_freestack( (backend_stack)(ptrdiff_t)procstk );
		}
	} else {
		c->mvc->type = q->type;
		err = backend_fastpath( (Cntxt)(ptrdiff_t)q->stk, (YYSTREE)q->code, c->args);
	}
	if (c->mvc->type == Q_TRANS){
		if (c->qc) qc_destroy(c->qc); 
		c->qc = qc_create();
	}

	if (!err && !(c->debug&64)){
		ssize_t status, type;

		if ((status = mvc_status(c->mvc)) < 0){
			char *errstr = "Error in result";
			if (!stream_writeInt( out, mvc_type(c->mvc) ) ||
			    !stream_writeInt( out, status ) ||
			    stream_write( out, errstr, strlen(errstr), 1 ) != 1)
				return -1;
			stream_flush( out );
  		} else if ( (type = mvc_type(c->mvc)) != Q_RESULT ) {
			if (!stream_writeInt( out, type ) ||
			    !stream_writeInt( out, status ))
				return -1;
			stream_flush( out );
  		}
	}
	return sqlcleanup(c, cmd, err);
}


int sqlclient(Cntxt stk, YYSTREE lt, ValPtr res){
	int debug = 0, trace = 0, reply_size = 100, l = 0, i, sock, *Sock, go = TRUE;
	char buf[BUFSIZ+1], *errbuf;
	char *user, *passwd, *schema, *dbname;
	Variable v;

	mvc *m;
	stream *in, *out;
	context *sql;

  	if (lt->cnt != 1) {
        	return handle_argerror(res, lt->cnt, 1);
  	}
  	@:builtin_operand(0,TYPE_int,Sock)@
	sock = *Sock;

	out = block_stream( socket_wstream( sock, "SQLSERVER" ));
	in  = block_stream( socket_rstream( sock, "SQLSERVER" ));

	if ((i = stream_read(in, buf, 1, BUFSIZ)) >= BUFSIZ)
		return connect_error(in, out, sock);
	buf[i] = 0;
	/* expect api(sql,debug); */
	l = strlen("api(sql,");
	if (i > l+1 ){
		char *s = NULL;
		debug = strtol(buf+l,&s,10);
		if (s){
			s++; /* skip , */
			trace = strtol(s, &s, 10);
			if (s){
				s++; /* skip , */
				reply_size = strtol(s, NULL, 10);
			}
		}
	}

	i=snprintf(buf, BUFSIZ, "login\n" );
	stream_write(out, buf, 1, i);
	stream_flush(out);

	if ((i = stream_read(in, buf, 1, BUFSIZ)) >= BUFSIZ)
		return connect_error(in, out, sock);
	buf[i] = 0;
	/* expect login(user,passwd); */
	l = strlen("login(");
	if (i > l+1 ){
		char *s, *e = strchr(buf+l,',');
		if (!e) return connect_error(in, out, sock);
		*e = 0;
		s = e+1; /* skip comma */
		e = strrchr(s, ')');
		if (!e) return connect_error(in, out, sock);
		*e = 0;
		user = GDKstrdup(buf+l);
		passwd = GDKstrdup(s);
	} else {
		return connect_error(in, out, sock);
	}

	m = mvc_create(debug);
	schema = mvc_login( m, user, passwd );
	dbname = GDKgetenv("gdk_dbname");

	i = snprintf(buf, BUFSIZ, "%s,%s\n", dbname, schema?schema:"" );
	stream_write(out, buf, 1, i);
	stream_flush(out);

	if (!schema){ 
		GDKfree(user);
		GDKfree(passwd);
		mvc_destroy(m);
		return connect_error(in, out, sock);
	}

	sql = NEW(context);
	sql_init_context( sql, debug, trace, reply_size, m );
	sql->qc = qc_create();

	/* add myc and Output, Input to the stack */
	v = VARnew(stk, "myc");
	v->binding.vtype = TYPE_mvc;
	v->binding.val.pval = m;

	v = VARnew(stk, "Output");
	v->binding.vtype = TYPE_Stream;
	v->binding.val.pval = out;

	v = VARnew(stk, "Input");
	v->binding.vtype = TYPE_Stream;
	v->binding.val.pval = in;

 	errbuf = GDKmalloc(GDKMAXERRLEN);
	errbuf[0] = '\0';
	GDKsetbuf(errbuf);

	while(go){
		int size = BUFSIZ + 1, err = 0;
		char *inbuf = NEW_ARRAY(char, size ), *start = inbuf;
		int inlen = 0, len;

		while ((len = stream_read(in, start, 1, BUFSIZ)) == BUFSIZ){
			inlen += BUFSIZ;
			size += BUFSIZ;
			inbuf = RENEW_ARRAY(char, inbuf, size); 
			start = inbuf + size - BUFSIZ - 1;
			*start = '\0';
		}
		if (len < 0){
			go = !go;
 			break;
		}
		inlen += len;
		inbuf[inlen] = '\0';

		if (!inlen || inbuf[0] == EOT)
			break;

		sql->buf = inbuf;
		sql->cur = ' ';

		while( sql->buf && *sql->buf && *sql->buf != EOT ){
			char *ibuf = sql->buf;

			err = sqlexecute(sql, out, stk);
			if (err){ /* output error */
				char *buf = GDKerrbuf;

				if (!stream_writeInt( out, -1 ) ||
				    !stream_writeInt( out, err ) ||
				    stream_write( out, sql->errstr, 
						strlen(sql->errstr), 1 ) != 1 ||
				    (buf && stream_write( out, buf, strlen(buf), 1 ) != 1)){
					go = !go;
					break;
				}
				buf[0] = 0; /* reset error buf */
	
				/* show the buggy query */
				if ( stream_write( out, " in:\n", 5, 1) != 1){
					go = !go;
					break;
				}
				while (ibuf[0] == '\n') ibuf++;
				if ( stream_write( out, ibuf, strlen(ibuf), 1) != 1){
					go = !go;
					break;
				}
				stream_flush( out );
			}
		}
		if (inbuf) _DELETE(inbuf);
	}
	mvc_destroy(m);

	if (sql->qc) qc_destroy(sql->qc); 
	sql->qc = NULL;

	sql_exit_context( sql );
	close_stream(in);
	close_stream(out);
	close(sock);
	return GDK_SUCCEED;
}

@= dec_tostr
	char buf[32];
	@1 v = *(@1*)a;
	int scale = (int)(ptrdiff_t)extra, cur = 31, neg = (v<0)?1:0, i, done = 0;
	int l;

	if (v<0) v = -v;

	buf[cur--] = 0;
	if (scale){
		for(i=0; i<scale; i++){
			buf[cur--] = (v%10) + '0';
			v /= 10;
		}
		buf[cur--] = '.';
	}
	while(v){
		buf[cur--] = (v%10) + '0';
		v /= 10;
		done = 1;
	}
	if (!done)
		buf[cur--] = '0';
	if (neg)
		buf[cur--] = '-';
	l = (32-cur-1);
	if (*len < l){
		if (*Buf) GDKfree(*Buf);
		*len = l+1;
		*Buf = GDKmalloc(*len);
	}
	strcpy(*Buf, buf+cur+1);
	return l-1;
@c

int dec_tostr( void *extra, char **Buf, int *len, int type, ptr a){
	/* support dec map to sht, int and lng */
	if (type == TYPE_sht){
		@:dec_tostr(sht)@
	} else if (type == TYPE_int){
		@:dec_tostr(int)@
	} else if (type == TYPE_lng){
		@:dec_tostr(lng)@
	} else {
		GDKwarning("Decimal cannot be mapped to %s\n", ATOMname(type));
	}
	return 0;
}

@= dec_frstr
	sql_subtype *t = (sql_subtype*)extra;

	int i, neg = 0;
	char *p = s;
	@1 *r;
	@1 res = 0;
	if (*s == '-'){
		neg = 1;
		s++;
	} else if (*s == '+'){ 
		neg = 0;
		s++;
	}
	for( i = 0; i < (t->digits-t->scale) && *s != '.'; i++, s++){
		if (!*s || *s < '0' || *s > '9' ){
			GDKerror("decimal wrong format (%s)", p);
			return NULL;
		}
		res *= 10;
		res += (*s-'0');
	}
	if (*s){
		if (*s != '.'){
			GDKerror("decimal wrong format (%s)", p);
			return NULL;
		}
		s++;
		for( i = 0; *s && i < t->scale; i++, s++){
			if (*s < '0' || *s > '9' ){
				GDKerror("decimal wrong format (%s)", p);
				return NULL;
			}
			res *= 10;
			res += (*s-'0');
		}
	}
	if (*s){
		GDKerror("decimal wrong format (%s)", p);
		return NULL;
	}
 	r = (@1*)GDKmalloc(sizeof(@1));
	if (neg)
		*r = -res;
	else
		*r = res;
	return (ptr*)r;
@c

ptr *dec_frstr( void *extra, int type, char *s){
	/* support dec map to sht, int and lng */
	if (type == TYPE_sht){
		@:dec_frstr(sht)@
	} else if (type == TYPE_int){
		@:dec_frstr(int)@
	} else if (type == TYPE_lng){
		@:dec_frstr(lng)@
	} else {
		GDKwarning("Decimal cannot be mapped to %s\n", ATOMname(type));
	}
	return NULL;
}

BAT *mvc_import_table( mvc *m, stream *s, char *tname, 
		char *sep, char *rsep, int sz)
{
	int i = 0, cnt = -1;
	sql_trans *tr = m->trans;
	sql_table *t = mvc_bind_table(m, tr->schema, tname);
	node *n;
	BAT *bats = NULL;
	bstream *bs = bstream_create(s, 1<<10);
	ascii as;
        ascii_io *fmt;

	if (!t){
		GDKerror("table %s not found\n", tname );
		m->type = -1;
		return NULL;
	}
	if (!s || stream_errnr(s)){
		GDKerror("stream not open %d\n", stream_errnr(s));
		m->type = -1;
		return  NULL;
	}

	if (t->columns.set){
		as.nr_attrs = list_length(t->columns.set);
		as.nr = sz;
		fmt = as.format =
                    (ascii_io*)GDKmalloc(sizeof(ascii_io) * (as.nr_attrs + 1) );

		for (n = t->columns.set->h, i=0; n; n = n->next, i++) 
		{
			sql_column *col = n->data;

			fmt[i].name = _strdup(col->base.name);
                	fmt[i].sep = (n->next)?_strdup(sep):_strdup(rsep);
                	fmt[i].seplen = (int) strlen( fmt[i].sep );
                	fmt[i].type = _strdup(col->type->type->name);
                	fmt[i].adt = ATOMindex( fmt[i].type );
                	fmt[i].tostr = &ASCIIadt_toStr;
                	fmt[i].frstr = &ASCIIadt_frStr;
                	fmt[i].extra = NULL;
			if (strcmp(col->type->type->sqlname, "decimal")==0){
				fmt[i].tostr = &dec_tostr;
				fmt[i].frstr = &dec_frstr;
				fmt[i].extra = col->type;
			}
		}
        	if (ASCIIcreate_bats( &as ) >= 0){
                	if ((cnt = ASCIIload_file( &as, bs ))>=0)
                        	bats = ASCIIcollect_bats( &as );
        	}
        	ASCIIdestroy_format( &as );
	}
	bstream_destroy(bs);

	m->type = Q_UPDATE;
	m->status = cnt;
	return bats;
}

static res_table *find_export_table( mvc *m, int res_id ){
	res_table *r = m->results;
	for( ; r; r = r->next){
		if (r->id == res_id)
			return r;
	}
	return NULL;
}

int mvc_export_result( mvc *m, stream *s, int res_id )
{
	int i;
	res_table *t = find_export_table(m, res_id);
	
	m->type = Q_RESULT;
	stream_writeInt( s, Q_RESULT );
	stream_writeInt( s, t->nr_cols );
	stream_writeInt( s, t->id );
	
	for (i = 0; i < t->nr_cols; i++) 
	{
		res_col *c = t->cols+i;
		stream_write(s, c->name, strlen(c->name), 1);
		stream_write(s, ",", 1, 1);
		stream_write(s, c->type->type->sqlname, 
				strlen(c->type->type->sqlname), 1);
		stream_write(s, "\n", 1, 1);
	}
	stream_flush(s);
	return 0;
}

static int mvc_export_row( mvc *m, stream *s, res_table *t ) 
{
	char *sep = "\t";
	char *rsep = "\n";

	int i;

	m->type = Q_RESULT;
	stream_writeInt( s, Q_TABLE );
	stream_writeInt( s, 1 );

	for (i = 0; i < t->nr_cols; i++) 
	{
		res_col *c = t->cols+i;
		if (i != 0)
			stream_write(s, sep, strlen(sep), 1);

		if (c->type->type->scale == SCALE_FIX){
			char *buf = NULL;
			int len = 0;
			int l = dec_tostr((void*)(ptrdiff_t)c->type->scale, &buf, &len,
					c->mtype, c->p);
			stream_write(s, buf, l, 1);
			_DELETE(buf);
		} else { 
			char *buf = NULL;
			int len = 0;
			int l = (*BATatoms[c->mtype].atomToStr)(&buf, &len, c->p);
			stream_write(s, buf, l, 1);
			_DELETE(buf);
		}
	}
	mvc_clean_result(m, t);
	stream_write(s, rsep, strlen(rsep), 1);
	stream_flush(s);
	return 0;
}

int mvc_export_table( mvc *m, stream *s, int res_id, int offset, int nr )
{
	char *sep = "\t";
	char *rsep = "\n";

	ascii as;
        ascii_io *fmt;
	res_table *t = find_export_table(m, res_id);
	size_t i;
	ssize_t cnt;
	int clean = 0;
	BAT *order = NULL;

	if (!t) 
		return -1;

	if (!t->order)
		return mvc_export_row(m, s, t );

	m->type = Q_RESULT;
	order = BATdescriptor(t->order);
	cnt = nr;
	if (cnt < 0){
 		cnt = BATcount(order);
		clean = 1;
	}
	if (offset >= BATcount(order))
		cnt = 0;
	if (offset + cnt > BATcount(order)){
		cnt = BATcount(order)-offset;
		clean = 1;
	}

	stream_writeInt( s, Q_TABLE );
	stream_writeInt( s, cnt );
	
	if (cnt <= 0){
		stream_flush(s);
		return 0;
	}
	as.nr_attrs = t->nr_cols;
	as.nr = cnt;
	as.offset = offset;
	fmt = as.format =
                (ascii_io*)GDKmalloc(sizeof(ascii_io) * (as.nr_attrs + 1) );

	memset(fmt, 0, (as.nr_attrs+1)*sizeof(ascii_io));

	for (i = 0; i < t->nr_cols; i++) 
	{
		res_col *c = t->cols+i;
		if (!c->b) 
			break;

		fmt[i].c = BATdescriptor(c->b);
		fmt[i].name = NULL;
                fmt[i].sep = (i<(t->nr_cols-1))?_strdup(sep):_strdup(rsep);
                fmt[i].seplen = (int) strlen( fmt[i].sep );
		fmt[i].type = ATOMname(fmt[i].c->ttype);
		fmt[i].adt = fmt[i].c->ttype;
                fmt[i].tostr = &ASCIIadt_toStr;
                fmt[i].frstr = &ASCIIadt_frStr;
                fmt[i].extra = NULL;
		if (c->type->type->scale == SCALE_FIX){
			fmt[i].tostr = &dec_tostr;
			fmt[i].frstr = &dec_frstr;
			fmt[i].extra = (void*)(ptrdiff_t)c->type->scale;
		}
	}
	if (i == t->nr_cols){
		ASCIIoutput_file(&as, order, s);
	}
	BBPunfix(order->batCacheid);
	ASCIIdestroy_format( &as );
	stream_flush( s );
	if (clean)
		mvc_clean_result(m, t);
	return 0;
}
int debug_cmd( context *c, char *cmd, stream *out, int part )
{
	stream_writeInt( out, (part)?Q_DEBUGP:Q_DEBUG );
	stream_writeInt( out, c->debug );
	stream_write( out, cmd, strlen(cmd), 1 );
	stream_flush( out );
	return 0;
}
