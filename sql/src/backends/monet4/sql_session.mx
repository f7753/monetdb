@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at 
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@' 
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@' 
@' The Original Code is the Monet Database System.
@' 
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2002 CWI.  
@' All Rights Reserved.
@' 
@' Contributor(s):
@' 		Martin Kersten <Martin.Kersten@cwi.nl>
@' 		Niels Nes <Niels.Nes@cwi.nl>
@' 		Stefan Manegold <Stefan.Manegold@cwi.nl>
@' 		Peter Boncz <Peter.Boncz@cwi.nl>

@f sql_session
@a N.J. Nes
@* 

@* Session code

This small module contains the code to instantiate an SQL client.
This code strongly depends on the front-end/back-end setup.

@h
#ifndef _SQL_SESSION_H_
#define _SQL_SESSION_H_

#include <sql_backend.h>
#include <monet_context.h>
#include <kernel.h>

extern int sqlclient(Cntxt stk, YYSTREE lt, ValPtr res);

#endif /*_SQL_SESSION_H_*/
@c
#include "sql_session.h"
#include "sql_server.h"
#include "sql_gencode.h"	/* for stmt_dump() */
#include <sql_context.h>
#include <sql_scope.h>
#include <sql_qc.h>
#include <sql_parser.h>		/* for sqlparse() */

@= builtin_operand
{       int _k = interpret(stk, arg(lt, @1), res);
        if (_k < 0) {
                return _k;
        }
        @3 = VALconvert(@2, res);
        if ((@3 == ILLEGALVALUE)  || (@2 == TYPE_bat && !@3)) {
                return handle_paramerror(res,@1,res->vtype,@2);
        }
}
@c

static YYSTREE milnode(int tok, int tpe, ptr valp) 
{
        YYSTREE res = yynode(tok, tpe);
        VALset(&res->yyval, tpe, valp);
        return res;
}

static YYSTREE milnode2(int tok, ValPtr valp) 
{
        YYSTREE res = yynode(tok, valp->vtype);
	res->yyval = *valp;
        return res;
}

void backend_dumpproc( context *c, int id, stream *cout, stmt *s )
{
	int nr = 1;
	int i = 0;
	char buf[BUFSIZ];
	node *n;

	i = snprintf( buf, BUFSIZ, "proc sql%d (", id);
	if (c->params){
		for (n = c->params->h; n; n = n->next){
			var *v = n->data;

			i += snprintf(buf+i, BUFSIZ-i, "%s %s%c", 
				v->s->op2.typeval->type->name,
				v->name, (n->next)?',':' '
				);
		}
	}
	i += snprintf(buf+i, BUFSIZ-i, ") : void {\n");
	cout->write(cout, buf, i, 1); 

    	stmt_dump( s, &nr, c );

	cout->write(cout, "}\n", 2, 1);
}
	
int backend_parse( context *c, char *cmd, Cntxt stack )
{
	int err = 0;
	(void) c; /* Stefan: unused!? */

	if (cmd){
		ValRecord v;

		v.vtype = TYPE_void;

		err = interpret_str( stack, cmd, &v);
	}
	return err;
}

Cntxt backend_newstack( Cntxt stk )
{
	Cntxt procstk;

	procstk = CNTXTnew(stk);
	CNTXTuse(procstk);
	monet_cntxt[procstk].reuse = TRUE;

	return procstk;
}

void backend_freestack( backend_stack stk )
{
	Cntxt procstk = (Cntxt)(ptrdiff_t)stk;

	monet_cntxt[procstk].reuse = FALSE;
	CNTXTfree1(procstk);
}

void backend_freecode( backend_code code )
{
	YYSTREE procnode = (YYSTREE)code;
	if (code){
		/* clear arguments */
		int i;
		int l = procnode->yysons[1]->cnt;
		ValPtr argv = (ValPtr) procnode->yysons[1]->yyval.val.pval;

		for (i=1; i<l; i++){
			argv[i].vtype = TYPE_void; 
			argv[i].len = 0; 
		}
	}
}

YYSTREE backend_interpret( Cntxt procstk, char *name, list *args )
{
	YYSTREE procnode;
	YYSTREE argtree;
	node *n;
	int err = 0;
	ValRecord v;

	v.vtype = TYPE_void;
	procnode = milnode(TOK_FUNCTION, TYPE_str, _strdup(name)); 
 	argtree = yynode(0,0); 
	if (args){
  		for (n=args->h; n; n = n->next){
			atom *a = n->data;
			YYSTREE arg = milnode2(TOK_CONSTANT, &a->data );
				/* todo cleanup should first remove
				   these nodes, without cleaning the
				   shared values!! */

       			argtree = yyexpand(argtree, arg);
		}
	}
	yyexpand(procnode, argtree);
	yyexpand(procnode, yynode(0,TYPE_int));
	err = interpret( procstk, procnode, &v);

	(void) err;	/* Stefan: unused!? */

	return procnode;
}

int backend_fastpath( Cntxt procstk, YYSTREE procnode, list *args )
{
	int err = 0;
	ValRecord v;
	node *n;

	v.vtype = TYPE_void;
	if (args){
		int i;

		ValPtr argv = (ValPtr) procnode->yysons[1]->yyval.val.pval;
	  	for (i=1, n=args->h; n; i++, n = n->next){
			atom *a = n->data;
			argv[i] = a->data;
		}
	}
	err = interpret( procstk, procnode->yysons[1]->yysons[0], &v);
	return err;
}


int connect_error(stream *in, stream *out, int sock)
{
	close_stream(in);
	close_stream(out);
	close(sock);
	return GDK_FAIL;
}

int sqlexecute(context * c, stream *out, Cntxt stk )
{
	stream *cout = c->out;
	char *cmd = NULL, *s;
	int i, err = 0;
	cq *q = NULL;

	cmd_init(c);

	s = c->buf;

	c->mvc->type = Q_PARSE;
	c->mvc->status = 0;

	if ((err = sqlparse(c)) || c->mvc->status || !c->sym) {
		if (!err)
			err = c->mvc->status;
		return sqlcleanup(c, cmd, err);
	}
	
	if (c->trace){
		char *buf = s;

		char old = *c->buf;

		*c->buf = '\0';
		*c->buf = old;

		stream_writeInt( out, Q_DEBUGP );
		stream_writeInt( out, 1 );
		while( buf < c->buf) {
			int i;
			char b[BUFSIZ];

		  	while( *buf != '\n' && buf < c->buf) buf++;
			i = snprintf(b, BUFSIZ, "# %5d: ", c->cnt);
		  	out->write(out, b, 1, i);
		  	out->write(out, s, 1, buf - s);
			out->write(out, "\n", 1, 1);
			s = ++buf;
		}
		c->cnt++;
		out->flush(out);
	}
	if ( !(q = qc_find(c->qc, c->sym, c->params, c->key)) ){
		stmt *s = sql_symbol2stmt(c);

		if (!s && c->mvc->status){
			err = c->mvc->status;
			return sqlcleanup(c, cmd, err);
		}

		backend_dumpproc( c, c->qc->id, cout, s );
		cmd = buffer_get_buf(c->outbuf);
    		cout->flush( cout );
		stmt_destroy(s);
	
		if (c->debug&64){
			err = debug_cmd(c, cmd, out, 1);
		} else {
			err = backend_parse( c, cmd, stk );
		} 
		q = qc_insert(c->qc, c->sym, c->params, c->key, c->mvc->type );

		c->sym = NULL;
		c->params = NULL;

		/* beware to use free instead of _DELETE
 	 	 * as the stream library is build with out 
	 	 * libbat ie. it cannot use gdkmalloc 
	 	 * can be used */
	        free(cmd); 
		cmd = NULL;

		if (err)
			return sqlcleanup(c, cmd, err);
	}
	if (c->debug){
		char buf[BUFSIZ];
		node *n;

		i = snprintf(buf, BUFSIZ, "sql%d (", q->id );
		cout->write(cout, buf, i, 1 );
		if (c->args){
	  		for (n=c->args->h; n; n = n->next){
				atom *a = n->data;
				atom_dump(a, cout);
				if (n->next)
					cout->write(cout, ",", 1, 1); 
			}
		}
		cout->write(cout, ");\n", 3, 1);

		cmd = buffer_get_buf(c->outbuf);
    		cout->flush( cout );
		if (c->debug&64){
			err = debug_cmd(c, cmd, out, 0);
		} else {
			err = backend_parse( c, cmd, stk );
		} 
	} else if (!q->code){
		char buf[BUFSIZ];
		Cntxt procstk = backend_newstack(stk);
		YYSTREE procnode;

		snprintf( buf, BUFSIZ, "sql%d", q->id);

		c->mvc->type = q->type;
		procnode = backend_interpret( procstk, buf, c->args);

		if (!err){
			q->code = (backend_code)procnode;
			q->stk = (backend_stack)(ptrdiff_t)procstk;
		} else {
			backend_freestack( (backend_stack)(ptrdiff_t)procstk );
		}
	} else {
		c->mvc->type = q->type;
		err = backend_fastpath( (Cntxt)(ptrdiff_t)q->stk, (YYSTREE)q->code, c->args);
	}
	if (c->mvc->type == Q_TRANS){
		if (c->qc) qc_destroy(c->qc); 
		c->qc = qc_create();
	}

	if (!err && !(c->debug&64)){
		ssize_t status, type;

		if ((status = mvc_status(c->mvc)) < 0){
			char *errstr = "Error in result";
			stream_writeInt( out, mvc_type(c->mvc) );
			stream_writeInt( out, status );
			out->write( out, errstr, strlen(errstr), 1 );
			out->flush( out );
  		} else if ( (type = mvc_type(c->mvc)) != Q_RESULT ) {
			stream_writeInt( out, type );
			stream_writeInt( out, status );
			out->flush( out );
  		}
	}
	return sqlcleanup(c, cmd, err);
}


int sqlclient(Cntxt stk, YYSTREE lt, ValPtr res){
	int debug = 0, trace = 0, reply_size = 100, l = 0, i, sock, *Sock;
	char buf[BUFSIZ+1], *errbuf;
	char *user, *passwd, *schema, *dbname;
	Variable v;

	mvc *m;
	stream *in, *out;
	context *sql;

  	if (lt->cnt != 1) {
        	return handle_argerror(res, lt->cnt, 1);
  	}
  	@:builtin_operand(0,TYPE_int,Sock)@
	sock = *Sock;

	out = block_stream( socket_wstream( sock, "SQLSERVER" ));
	in  = block_stream( socket_rstream( sock, "SQLSERVER" ));

	if ((i = in->read(in, buf, 1, BUFSIZ)) >= BUFSIZ)
		return connect_error(in, out, sock);
	buf[i] = 0;
	/* expect api(sql,debug); */
	l = strlen("api(sql,");
	if (i > l+1 ){
		char *s = NULL;
		debug = strtol(buf+l,&s,10);
		if (s){
			s++; /* skip , */
			trace = strtol(s, &s, 10);
			if (s){
				s++; /* skip , */
				reply_size = strtol(s, NULL, 10);
			}
		}
	}

	i=snprintf(buf, BUFSIZ, "login\n" );
	out->write(out, buf, 1, i);
	out->flush(out);

	if ((i = in->read(in, buf, 1, BUFSIZ)) >= BUFSIZ)
		return connect_error(in, out, sock);
	buf[i] = 0;
	/* expect login(user,passwd); */
	l = strlen("login(");
	if (i > l+1 ){
		char *s, *e = strchr(buf+l,',');
		if (!e) return connect_error(in, out, sock);
		*e = 0;
		s = e+1; /* skip comma */
		e = strrchr(s, ')');
		if (!e) return connect_error(in, out, sock);
		*e = 0;
		user = GDKstrdup(buf+l);
		passwd = GDKstrdup(s);
	} else {
		return connect_error(in, out, sock);
	}

	m = mvc_create(debug);
	schema = mvc_login( m, user, passwd );
	dbname = GDKgetenv("gdk_dbname");

	i = snprintf(buf, BUFSIZ, "%s,%s\n", dbname, schema?schema:"" );
	out->write(out, buf, 1, i);
	out->flush(out);

	if (!schema){ 
		GDKfree(user);
		GDKfree(passwd);
		mvc_destroy(m);
		return connect_error(in, out, sock);
	}

	sql = NEW(context);
	sql_init_context( sql, debug, trace, reply_size, m );
	sql->qc = qc_create();

	/* add myc and Output, Input to the stack */
	v = VARnew(stk, "myc");
	v->binding.vtype = TYPE_mvc;
	v->binding.val.pval = m;

	v = VARnew(stk, "Output");
	v->binding.vtype = TYPE_Stream;
	v->binding.val.pval = out;

	v = VARnew(stk, "Input");
	v->binding.vtype = TYPE_Stream;
	v->binding.val.pval = in;

 	errbuf = GDKmalloc(GDKMAXERRLEN);
	errbuf[0] = '\0';
	GDKsetbuf(errbuf);

	while(TRUE){
		int size = BUFSIZ + 1, err = 0;
		char *inbuf = NEW_ARRAY(char, size ), *start = inbuf;
		int inlen = 0, len;

		while ((len = in->read(in, start, 1, BUFSIZ)) == BUFSIZ){
			inlen += BUFSIZ;
			size += BUFSIZ;
			inbuf = RENEW_ARRAY(char, inbuf, size); 
			start = inbuf + size - BUFSIZ - 1;
			*start = '\0';
		}
		inlen += len;
		inbuf[inlen] = '\0';

		if (!inlen || inbuf[0] == EOT)
			break;

		sql->buf = inbuf;
		sql->cur = ' ';

		while( sql->buf && *sql->buf && *sql->buf != EOT ){
			char *ibuf = sql->buf;

			err = sqlexecute(sql, out, stk);
			if (err){ /* output error */
				char *buf = GDKerrbuf;
				stream_writeInt( out, -1 );
				stream_writeInt( out, err );
				out->write( out, sql->errstr, strlen(sql->errstr), 1 );
				if (buf)
				out->write( out, buf, strlen(buf), 1 );
				buf[0] = 0; /* reset error buf */
	
				/* show the buggy query */
				out->write( out, " in:\n", 5, 1);
				while (ibuf[0] == '\n') ibuf++;
				out->write( out, ibuf, strlen(ibuf), 1);
				out->flush( out );
			}
		}
		if (inbuf) _DELETE(inbuf);
	}
	mvc_destroy(m);

	if (sql->qc) qc_destroy(sql->qc); 
	sql->qc = NULL;

	sql_exit_context( sql );
	close_stream(in);
	close_stream(out);
	close(sock);
	return GDK_SUCCEED;
}

