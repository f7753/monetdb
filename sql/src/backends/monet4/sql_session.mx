@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2005 CWI.
@' All Rights Reserved.

@f sql_session
@a N.J. Nes
@*

@* Session code

This small module contains the code to instantiate an SQL client.
This code strongly depends on the front-end/back-end setup.

@h
#ifndef _SQL_SESSION_H_
#define _SQL_SESSION_H_

#include "sql_server.h"
#include <sql_backend.h>
#include <monet_context.h>
#include <kernel.h>
#include <str.h>

typedef struct backend {
	int 	console;
	int 	trace;
	mvc 	*mvc;

	buffer *outbuf;
	stream *out;
} backend;

extern int sqlclient(Cntxt stk, YYSTREE lt, ValPtr res);
extern int mvc_export_default( mvc *m, stream *s ); 
extern int mvc_export_result( mvc *c, stream *s, int res_id );
extern int mvc_export_table( mvc *c, stream *s, int res_id, unsigned int offset, unsigned int nr);
extern BAT *mvc_import_table( mvc *c, bstream *s, char *tname, char *sep, char *rsep, int nr);
extern int mvc_sql( mvc *c, str query );

extern void monet4_freestack( backend_stack stk );
extern void monet4_freecode( backend_code code, backend_stack stk, int nr );
extern void monet4_parse( backend_stack stk, char *code );

extern int sqlstatement(char *cmd, Cntxt stk );

#endif /*_SQL_SESSION_H_*/
@c
#include "sql_session.h"
#include "sql_server.h"
#include "sql_gencode.h"	/* for backend_dumpproc() */
#include <sql_semantic.h>
#include <sql_optimize.h>
#include <sql_privileges.h>
#include <sql_rel2bin.h>
#include <sql_scope.h>
#include <sql_qc.h>
#include <sql_parser.h>		/* for sqlparse() */
#include <sql_env.h>		/* explain,debug,reply_size,auto_commit etc */
#include <monettime.h>
#include <bat/bat_store.h>
#include <bat/res_table.h>

static res_table *find_export_table( mvc *m, int res_id );

@= builtin_operand
{       int _k = interpret(stk, arg(lt, @1), res);
        if (_k < 0) {
                return _k;
        }
        @3 = VALconvert(@2, res);
        if ((@3 == ILLEGALVALUE)  || (@2 == TYPE_bat && !@3)) {
                return handle_paramerror(res,@1,res->vtype,@2);
        }
}
@c

static backend *backend_create( int trace, mvc *c, int console )
{
	backend *b = NEW(backend);

	b->mvc = c;

 	b->outbuf = buffer_create( BUFSIZ );
	b->out = buffer_wastream( b->outbuf, "SQLserver" );
	b->trace = trace;
	b->console = console;
	return b;
}

static void backend_destroy( backend *b )
{
	if (b->out){
		buffer_destroy( b->outbuf );
		stream_close( b->out );
		stream_destroy( b->out );
	}
	_DELETE(b);
}

static YYSTREE milnode(int tok, int tpe, ptr valp)
{
        YYSTREE res = Myynode(tok, tpe);
        VALset(&res->yyval, tpe, valp);
        return res;
}

static YYSTREE milnode2(int tok, ValPtr valp)
{
        YYSTREE res = Myynode(tok, valp->vtype);
	res->yyval = *valp;
	res->dealloc = 0;
        return res;
}

static int backend_parse( Cntxt stack, char *cmd )
{
	int err = 0;

	if (cmd){
		ValRecord v;

		v.vtype = TYPE_void;

		err = interpret_str( stack, cmd, &v);
	}
	return err;
}

void monet4_parse( backend_stack stack, char *cmd )
{
	backend_parse( (Cntxt)stack, cmd );
}


Cntxt backend_newstack( Cntxt stk )
{
	Cntxt procstk;

	procstk = CNTXTnew(stk);
	CNTXTuse(procstk);
	monet_cntxt[procstk].reuse = TRUE;

	return procstk;
}

void monet4_freestack( backend_stack stk )
{
	Cntxt procstk = (Cntxt)(ptrdiff_t)stk;

	monet_cntxt[procstk].reuse = FALSE;
	CNTXTclear(procstk);
	CNTXTfree1(procstk);
	CNTXTdelete(procstk);
}

static void
reset_arg_tree( YYSTREE args )
{
	while(args){
		unsigned i;
		for (i=0; i< args->cnt; i++){
			if (args->yysons[i])
				reset_arg_tree(args->yysons[i]);

		}
		args->yyval.vtype = TYPE_void;
		args->yyval.len = 0;

		args = args->overflow;
	}
}

void monet4_freecode( backend_code code, backend_stack stk, int nr)
{
	YYSTREE callnode = (YYSTREE)code;

	if (code){
		Client client;
		char name[BUFSIZ];
		int i;
		int l = callnode->yysons[1]->cnt;
		ValPtr argv;

		/* clear default arguments */
		reset_arg_tree( callnode->yysons[0] );

		/* clear fastpath arguments */
		if (callnode->yysons[1]) {
 			argv = (ValPtr) callnode->yysons[1]->yyval.val.pval;
			for (i=1; i<l; i++){
				argv[i].vtype = TYPE_void;
				argv[i].len = 0;
			}
		}

		/* cleanup proc */
		Myyfree(callnode);

		snprintf(name, BUFSIZ, "sql%d", nr);
		CNTXTclient( (Cntxt)(ptrdiff_t)stk, &client);
		TBL_delproc(client, name);
	}
}

YYSTREE monet4_interpret( Cntxt procstk, char *name, list *args, int *err )
{
	YYSTREE callnode;
	YYSTREE argtree;
	ValRecord v;

	v.vtype = TYPE_void;
	callnode = milnode(TOK_FUNCTION, TYPE_str, _strdup(name));
 	argtree = Myynode(0,0);
	if (args){
		node *n;
  		for (n=args->h; n; n = n->next){
			atom *a = n->data;
			YYSTREE arg;

			if (atom_null(a)) {
				if (a->data.vtype == TYPE_str && 
				    a->data.val.sval == NULL) {
					a->data.val.sval = GDKstrdup(str_nil);
				}
			}
			arg = milnode2(TOK_CONSTANT, &a->data );
       			argtree = Myyexpand(argtree, arg);
		}
	}
	Myyexpand(callnode, argtree);
	Myyexpand(callnode, Myynode(0,TYPE_int));
	*err = interpret( procstk, callnode, &v);

	return callnode;
}

int backend_fastpath( Cntxt procstk, YYSTREE callnode, list *args )
{
	ValRecord v;
	node *n;

	v.vtype = TYPE_void;
	if (args){
		int i;

		ValPtr argv = (ValPtr) callnode->yysons[1]->yyval.val.pval;
	  	for (i=1, n=args->h; n; i++, n = n->next){
			atom *a = n->data;

			if (atom_null(a)) {
				int t = argv[i].vtype;
				if (a->data.vtype != t) {
					a->data.vtype = t;
					if (ATOMstorage(t) < TYPE_str){
						ptr p = ATOMnilptr(t);
						VALset(&a->data, t, p);
					} else {
						a->data.val.pval = NULL; 
					}
				}
			}
			argv[i] = a->data;
		}
	}
	return interpret( procstk, callnode->yysons[1]->yysons[0], &v);
}

@-
A connection error means that not only the channels to the database should
be reset, but also this client should be terminated immediately.
@c
int connect_error(stream *in, stream *out)
{
	/* Make sure that the write- (out-) stream is closed first,
	 * as the related read- (in-) stream closes the shared
	 * socket; see also MonetDB/src/common/stream.mx:socket_close .
	 */
	if (out) {
		stream_close(out);
		stream_destroy(out);
	}
	if (in) {
		stream_close(in);
		stream_destroy(in);
	}
	return GDK_FAIL;
}

static int
error(stream *out, char *str)
{
	char *p;

	if (!out)
		out = GDKerr;

	if (stream_errnr(out))
		return -1;
	while ((p = strchr(str, '\n')) != NULL) {
		p++;		/* include newline */
		if (*str != '!' && stream_write(out, "!", 1, 1) != 1)
			return -1;
		if (stream_write(out, str, p - str, 1) != 1)
			return -1;
		str = p;
	}
	if (str && *str) {
		if (*str != '!' && stream_write(out, "!", 1, 1) != 1)
			return -1;
		if (stream_write(out, str, strlen(str), 1) != 1 ||
		    stream_write(out, "\n", 1, 1) != 1)
			return -1;
	}
	return 0;
}

int explain_cmd( mvc *c, char *cmd, stream *out )
{
	int t_id;
	BAT *b;

	if (!out)
		return 0;
	strSplit(&b, cmd, "\n");
	BATseqbase(b, 0);
 	t_id = mvc_result_table( c, 1, b);
	mvc_result_column( c, "", "statement", "varchar", -1,-1, b);
	BBPunfix(b->batCacheid);
	return mvc_export_result( c, out, t_id ) ||
		mvc_export_table( c, out, t_id, 0, -1 );
}

stmt *sql_symbol2stmt( mvc *c ){
	stmt *s = semantic(c, c->sym);
	if (s){
		stmt *opt = optimize(c, s);
		stmt_destroy(s);
		s = rel2bin(c, opt);
		stmt_destroy(opt);
	}
	return s;
}

int sqlcleanup( mvc *c, int err )
{
	sql_destroy_params(c);
	sql_destroy_args(c);

	/* some statements dynamically disable caching */
	if (c->sym) {
		symbol_destroy(c->sym);
		c->sym = NULL;
	}
	scanner_query_processed(&(c->scanner));
	return err;
}

static int 
output_prepare( stream *out, cq *q )
{
	int i;
	node *n;
	char buf[BUFSIZ];

	if (!out)
		return 0;
	/* indicate to client that a new SQL command starts here */
	if (stream_write(out, "#-\n", 3, 1) != 1) {
		return -1;
	}

	i = snprintf( buf, BUFSIZ, "%d\n%d\n", q->id, q->params?list_length(q->params):0);
	if (stream_write(out, buf, i, 1) != 1) {
		return -1;
	}
	if (q->params) for (n = q->params->h; n; n = n->next) {
		sql_subtype *t = n->data;
		if (t) {
			i = snprintf( buf, BUFSIZ, "%s(%d,%d)\n", 
				t->type->sqlname, t->digits, t->scale);
			if (stream_write(out, buf, i, 1) != 1) {
				return -1;
			}
		}
	}
	return 0;
}

enum ex_t {
	ex_none,
	ex_plan,
	ex_performance
};

static void mvc_clean_result( mvc *m, res_table *t)
{
	res_table *r = m->results;

	if (r == t){
		m->results = t->next;
	} else {
		for( ; r; r = r->next){
			if (r->next == t){
				r->next = t->next;
				break;
			}
		}
	}
	res_table_destroy(t);
}

int sqlexecute(backend * be, stream *out )
{
	char *query = NULL;
	lng T0 = 0, Tparse = 0, Tmil = 0, Texec = 0, T1 = 0;
	mvc *c = be->mvc;
	int err = 0;
	enum ex_t explain = ex_none;
	cq *q = NULL;

	c->type = Q_PARSE;

	if (!c->trans)
		mvc_trans(c);

	if (c->explain)
	{
	    	if (strcmp(c->explain, "plan") == 0)
			explain = ex_plan;
	    	else if (strcmp(c->explain, "performance") == 0)
			explain = ex_performance;
	}

	if (explain == ex_performance)
		T0 = GDKusec();

	if ((err = sqlparse(c)) ||
	    /* Only forget old errors on transaction boundaries */
	    (mvc_status(c) && c->type != Q_TRANS) || !c->sym) {
		if (!err)
			err = mvc_status(c);
		return sqlcleanup(c, err);
	}

	if (explain == ex_performance)
		Tparse = GDKusec();

	if (explain == ex_plan && c->sym->token == SQL_SET)
		explain = ex_none;

	if (c->mode == m_execute) {
		node *a, *p;
		int id = c->sym->data.lval->h->data.ival;
		q = qc_find( c->qc, id);

		if (!q) {
			error(out, "Error: no prepared statement with the given query id\n");
			err = -1;
		} else if ((c->args != q->params && (!c->args || !q->params)) 
		       || (c->args && q->params && 
			  list_length(q->params) != list_length(c->args))) {
			error(out, "Error: wrong number of arguments for prepared statement\n");
			err = -1;
			q = NULL;
		} else {
			if (c->args) for ( a = c->args->h, p = q->params->h; 
			      a && p; 
			      a = a->next, p = p->next){
				atom *arg = a->data;
				sql_subtype *pt = p->data;
	
				if (subtype_cmp(pt, arg->tpe) != 0) {
					char buf[BUFSIZ];

					snprintf( buf, BUFSIZ, "Error: wrong argument for prepared statement (%s,%s)\n", pt->type->sqlname, arg->tpe->type->sqlname);
					error(out, buf);
					err = -1;
					q = NULL;
				}
			}
		}
	} else if (explain == ex_plan || !c->cache ||
	    !(q = qc_match(c->qc, c->sym, c->args, c->scanner.key))) {
		char *cmd = NULL;
		stmt *s = sql_symbol2stmt(c);

		if (!s && (err = mvc_status(c)) )
			return sqlcleanup(c, err);
		assert(s);

		if (explain == ex_plan) {
			/* insert mil statements into a bat */
			if (c->args){
				int i = 0;
				node *n;

	  			for (n=c->args->h; n; n = n->next, i++){
					int len;
					atom *a = n->data;
					char buf[BUFSIZ];

					stream_write(be->out, "var ", 4, 1);
					len=snprintf(buf,BUFSIZ,"A%d", i);
					stream_write(be->out, buf, len, 1);
					stream_write(be->out, " := ", 4, 1);
					atom_dump(a, be->out);
					stream_write(be->out, ";\n", 2, 1);
				}
			}
		}

		if (explain == ex_plan || !c->cache) {
			int nr = 1;

			backend_dumpstmt( s, &nr, be );
		} else {
			backend_dumpproc( be, c->qc->id, s );
		}
		cmd = buffer_get_buf(be->outbuf);
    		stream_flush( be->out );
		stmt_destroy(s);

		if (explain == ex_plan) {
			err = explain_cmd( c, cmd, out);
		} else {
			err = backend_parse( c->stk, cmd );
			if (c->cache) {
				q = qc_insert(c->qc, c->sym, c->args,
						c->scanner.key, c->type, 
						GDKstrdup(cmd) );
				c->sym = NULL;
			}
		}

		/* beware to use free instead of _DELETE
 	 	 * as the stream library is built without
	 	 * libbat i.e. it cannot use gdkmalloc */
	        free(cmd);

		if (err) 
			return sqlcleanup(c, err);
	}

	if (explain == ex_performance) {
		query = sql_escape(QUERY(c->scanner));
		Tmil = GDKusec();
	}

	scanner_query_processed(&(c->scanner));

	if (q && c->mode == m_prepare) {
		if ( (err = output_prepare( out, q )) ) {
			return sqlcleanup(c, err);
		}
	} else if (q && !q->code) {
		/* TODO change to backend_call(c, name, c->args, &err); */
		char buf[BUFSIZ];
		Cntxt procstk = backend_newstack(c->stk);
		YYSTREE callnode;

		snprintf( buf, BUFSIZ, "sql%d", q->id);

		c->type = q->type;
		callnode = monet4_interpret( procstk, buf, c->args, &err);

		if (!err){
			q->code = (backend_code)callnode;
			q->stk = (backend_stack)(ptrdiff_t)procstk;
		} else {
			c->status = err;
			monet4_freecode( callnode, (backend_stack)(ptrdiff_t)procstk, q->id);
			backend_freestack( (backend_stack)(ptrdiff_t)procstk );
			qc_delete(c->qc, q);
		}
	} else if (q) {
		c->type = q->type;
		err = backend_fastpath( (Cntxt)(ptrdiff_t)q->stk, (YYSTREE)q->code, c->args);
	}
	if (explain == ex_performance)
		Texec = GDKusec();

	/*
 	 * clear query cache after Transaction boundaries (commit/rollback)
	 * and on schema changes
	 */
	if (c->cache &&
	   ( c->type == Q_TRANS || c->type == Q_SCHEMA || c->qc->id > 100)) {
		if (c->qc) qc_destroy(c->qc);
		c->qc = qc_create();
	}

	if (explain == ex_performance) {
		char *e = c->explain;
		char buf[BUFSIZ];

		T1 = GDKusec();
		/* TODO use sql_prepare/execute */
		snprintf(buf, BUFSIZ, 
			"insert into sys.history "
			"values(now,'%s',%lld,%lld,%lld,%lld,USER);\n", 
			query, Tparse-T0, Tmil-Tparse, Texec-Tmil, T1-T0);
		_DELETE(query);
		/* switch of explain to prevent recursion */
		c->explain = NULL;
		(void)mvc_sql( c, buf);
		c->explain = e;
	}

	if (!err && explain != ex_plan) {
		if (mvc_status(c) < 0) {
			error(out, "Error in result");
		} else if (c->cache && 
			   c->type != Q_RESULT && 
			   c->type != Q_UPDATE) {
			err = mvc_export_default( c, out ); 
		}
	}
	return sqlcleanup(c, err);
}

@-
Sidestepping SQL to directly executed a single MIL statement
in the same context.
@c
void sidestepMil(Cntxt stk, char *cmd){
	ValRecord res;
	res.vtype= TYPE_void;
	interpret_str(stk, cmd, &res);
}

#define TRANS_ABORTED "!current transaction is aborted (please ROLLBACK)\n"

int handle_error(mvc *m, stream *out, int pstatus) 
{
	int go = 1;
	char *buf = GDKerrbuf;

	/* transaction already broken */
	if (m->type != Q_TRANS && pstatus < 0) { 
		if (stream_write( out, TRANS_ABORTED, sizeof(TRANS_ABORTED)-1, 1 ) != 1 ){
			go = !go;
		}
	} else {
		if (error(out, m->errstr) < 0 || 
		    (buf && buf[0] && error( out, buf) < 0)) {
			go = !go;
		}
	}
	/* reset error buffers */
	m->errstr[0] = 0;
	buf[0] = 0;
	return go;
}

@c
int
sqlclient2(mvc *m, Cntxt stk, bstream *in, stream *out, int trace, int console )
{
	int go = TRUE;
	char *errbuf;
	backend *sql;
	Variable v;

	int err;
	int language = 'S';
	prot oldmode;

	sql = backend_create( trace, m, console );

	/* add myc and Output, Input to the stack */
	v = VARnew(stk, "myc");
	v->binding.vtype = TYPE_mvc;
	v->binding.val.pval = m;

	v = VARnew(stk, "Output");
	v->binding.vtype = TYPE_Stream;
	v->binding.val.pval = out;

	v = VARnew(stk, "Input");
	v->binding.vtype = TYPE_Bstream;
	v->binding.val.pval = in;

 	errbuf = GDKmalloc(GDKMAXERRLEN);
	errbuf[0] = '\0';
	GDKsetbuf(errbuf);

	in->eof = 1;		/* force prompt on first iteration */
	while(go){
		int pstatus = 0;
		while (in->pos < in->len &&
                       (isspace((int)(in->buf[in->pos])) ||
		        in->buf[in->pos] == ';' ))
			in->pos++;

		if (in->pos >= in->len) {
			ssize_t rd;
			assert(in->pos == in->len);

			if (in->eof || !isa_block_stream(in->s)) {
				language = (sql->console)?'S':0;

				/* auto_commit on end of statement */
				if (m->auto_commit && m->trans) {
	   				if (m->cache && 
					   (m->type == Q_TRANS || 
					    m->type == Q_SCHEMA || 
					    m->qc->id > 100)) {
						if (m->qc) qc_destroy(m->qc);
						m->qc = qc_create();
					}
					if (mvc_commit(m, 0, NULL) < 0) {
						go = handle_error(m, out, pstatus);
						if (!go) 
							break;
					}
				}

				if (stream_write(out,PROMPT1,sizeof(PROMPT1)-1,1) != 1 ||
				    stream_flush(out)) {
					go = FALSE;
					break;
				}
				in->eof = 0;
			}
			if ((rd = bstream_next(in)) <= 0) {
				if (rd == 0 && language != 0 && in->eof) {
					/* we hadn't seen the EOF
					   before, so just try again
					   (this time with prompt) */
					continue;
				}
				go= FALSE;
				break;
			}
			if (go && !sql->console && language == 0)
				language = in->buf[in->pos++];
		}
		if (sql->console && strncmp(in->buf+in->pos,"quit",4) == 0) {
			in->pos = in->len; /* HACK: should use parsed lenght */
			go=FALSE;
			break;
		}
@-
To enable tracing of SQL execution using its MIL code
requires the same client context. This means that we should
have an escape from the sql parser and directly address the
MIL interpreter. This is accomplished with a prepend of the
query string with "M".
		if (mil && language == 'M') {
			sidestepMil(stk, in->buf+in->pos);
			in->pos = in->len; /* HACK: should use parsed lenght */
			continue;
		}
@c
		oldmode = m->scanner.mode;
		if (language == 's') {
			language = 'S';
			m->scanner.mode = LINE_1;
		}
		if (language != 'S' && language != 'X') {
			error(out, "!ERROR:Unrecognized language prefix");
			break;
		}
		if (language == 'X') {
			int n, id, off, len;

			n = sscanf(in->buf+in->pos, "export %d %d %d", &id, &off, &len);
			if (n == 2 || n == 3) {
				mvc_export_table(m, out, id, off, n == 3 ? len : m->reply_size);
				in->pos = in->len; /* HACK: should use parsed lenght */
				continue;
			}
			if (sscanf(in->buf+in->pos, "close %d", &id) == 1) {
				res_table *t = find_export_table(m, id);
				if (t) mvc_clean_result(m, t);
				in->pos = in->len; /* HACK: should use parsed lenght */
				continue;
			}
			error(out, "!ERROR:Unrecognized X command");
			break;
		}

		if (m->trans) 
			pstatus = m->status;

		/* no transaction, reset status */
		if (!m->trans)
			m->status = 0;

		m->mode = m_normal;

		err = sqlexecute(sql, out);
		m->scanner.mode = oldmode;

		if (err){ /* output error */
			if (m->auto_commit && m->trans) {
				/* rollback and skip rest */
				mvc_rollback(m, 0, NULL);
				in->pos = in->len;
				if (m->qc) qc_destroy(m->qc);
				m->qc = qc_create();
			}
			go = handle_error(m, out, pstatus);
		}
	}

	_DELETE(errbuf);
	GDKsetbuf(NULL);
	backend_destroy( sql );
	return GDK_SUCCEED;
}

int
sqlstatement(char *cmd, Cntxt stk )
{
	int err = 0;
	mvc *m;
	backend *sql;
	Variable v;

	m = mvc_create(0, (backend_stack)stk, NULL, GDKout );
	mvc_trans(m); /* start transaction */
	m->user_id = m->role_id = USER_MONETDB;
	m->user = _strdup("monetdb");
	m->trans->schema = mvc_bind_schema(m, "sys");
	sql = backend_create( 0, m, 1 );

	/* add myc and Output, Input to the stack */
	v = VARnew(stk, "myc");
	v->binding.vtype = TYPE_mvc;
	v->binding.val.pval = m;

	scanner_reset(&m->scanner, cmd = _strdup(cmd) );

	err = sqlexecute(sql, GDKout);
	if (err) 
		GDKerror(m->errstr);
	backend_destroy( sql );
	GDKfree(cmd);
	mvc_commit(m, 0, NULL);
	res_tables_destroy(m->results);
	mvc_destroy(m);
	VARdel(stk, v);
	if (err)
		return GDK_FAIL;
	else
		return GDK_SUCCEED;
}

int
mvc_sql(mvc *m, char *cmd )
{
	Cntxt stk = (Cntxt)m->stk;
	mvc o = *m;

	int err = 0;
	backend *sql;
	Variable v;

	sql = backend_create( 0, m, 1 );

	/* add myc and Output */
	v = VARnew(stk, "myc");
	v->binding.vtype = TYPE_mvc;
	v->binding.val.pval = m;

	v = VARnew(stk, "Output");
	v->binding.vtype = TYPE_Stream;
	v->binding.val.pval = NULL;

	m->qc = NULL;
	m->cache = 0;
	scanner_reset(&m->scanner, cmd );

	m->params = NULL;
	m->args = NULL;
	m->sym = NULL;
	m->auto_commit = 0;

	err = sqlexecute(sql, NULL );
	backend_destroy( sql );
	assert (m->qc == NULL);
	*m = o;
	VARdel(stk, v);
	if (err)
		return GDK_FAIL;
	else
		return GDK_SUCCEED;
}

@-
The new SQL client server works with a Mapi compliant front-end.
The routine below is called when someone knocks on the door for
an SQL connection.

To simplify the implementation, we will patch MAPIlisten to
recognize the call for SQLmapiclient and adhere to the Mapi protocol
to read an authentication line, i.e.
<username>:<password>:blocked
We assume that a new user-context has been set using a proper fork()
command. This means that the SQL client runs under the authentication of
the DBA.
@c
static int
sendProperty(stream *out, char *name, char *value)
{
	if (stream_write(out, "[ \"", 1, 3) != 3)
		return 0;
	while (*name) {
		switch (*name) {
		case '"':
			if (stream_write(out, "\\\"", 1, 2) != 2)
				return 0;
			break;
		case '\\':
			if (stream_write(out, "\\\\", 1, 2) != 2)
				return 0;
			break;
		default:
			if (stream_write(out, name, 1, 1) != 1)
				return 0;
			break;
		}
		name++;
	}
	if (stream_write(out, "\", \"", 1, 4) != 4)
		return 0;
	while (*value) {
		switch (*value) {
		case '"':
			if (stream_write(out, "\\\"", 1, 2) != 2)
				return 0;
			break;
		case '\\':
			if (stream_write(out, "\\\\", 1, 2) != 2)
				return 0;
			break;
		default:
			if (stream_write(out, value, 1, 1) != 1)
				return 0;
			break;
		}
		value++;
	}
	if (stream_write(out, "\" ]\n", 1, 4) != 4)
		return 0;
	return 1;
}

int sqlclient(Cntxt stk, YYSTREE lt, ValPtr res)
{
	int trace = 0, ret = GDK_SUCCEED;
	ssize_t i=0;
	char buf[BUFSIZ+1];
	char *user, *passwd, *schema;
	int blocked=0;

	mvc *m;
	stream **In, **Out;
	stream *in, *out;
	bstream *rs;
	stream *bkin, *bkout;

	Thread sqlthread = THRget(THRgettid());
	Client client;

	CNTXTclient( (Cntxt)(ptrdiff_t)stk, &client);

  	if (lt->cnt != 2) {
        	return handle_argerror(res, lt->cnt, 2);
  	}
  	@:builtin_operand(0,TYPE_Stream,In)@
	in = *In;
  	@:builtin_operand(1,TYPE_Stream,Out)@
	out = *Out;

	/* Time to adjust the thread IO channels */
	bkin = client -> fdin;
	bkout = client -> fdout;
	monetSetChannel(sqlthread,in,out);
@-
Start analysis using the mapi-client protocol.
Use default setting for trace.
@c
	if (in == 0){
		GDKsyserror("mapisqlclient:stream-r problems\n");
		return connect_error(in, out);
	}
	if (out == 0){
		GDKsyserror("mapisqlclient:stream-w problems\n");
		return connect_error(in, out);
	}
	/* get user name */
	memset(buf,0,BUFSIZ);
	user= buf;
	if( stream_read(in, user, 1, 1) <0)
		return connect_error(in, out);
	for(i=0; i<BUFSIZ && *user != '\n'; i++){
		user++;
		if( stream_read(in, user, 1, 1) <0)
			return connect_error(in, out);
	}
	*user=0;
	user= buf;
	passwd= strrchr(user,':');
	if(passwd && strncmp(passwd,":blocked",8)==0){
		blocked = 1;
		*passwd=0;
	}
	passwd= strrchr(user,':');
	if(passwd && strncasecmp(passwd,":sql",4)==0){
		/* skip :sql only used for M5 */
		*passwd=0;
	}

	passwd= strchr(user,':');
	if( passwd){
		*passwd= 0;
		passwd++;
		user= _strdup(buf);
		passwd= _strdup(passwd);
	} else {
		return connect_error(in, out);
	}

	if (blocked){
		in= block_stream(stream_rstream(in));
		out= block_stream(stream_wstream(out));

		monetSetChannel(sqlthread,in,out);
	}

	if (out == 0){
		GDKsyserror("mapisqlclient:stream-w problems\n");
		GDKfree(user);
		GDKfree(passwd);
		return connect_error(in, out);
	}
@-
The server should emit an identity message, e.g. the Mserver version
These lines should be eaten away into the prompt is encountered.
@c

	rs = bstream_create(in, isa_block_stream(in) ? (128 * BLOCK) : 0);
	m = mvc_create(1, (backend_stack)stk, rs, out );
	if (blocked)
		m->scanner.mode = BLOCKED;
	schema = mvc_login( m, user, passwd );
	GDKfree(user);
	GDKfree(passwd);

	if (!schema){
		/* close the connection to the Monet server */
		if( error(out, "!ERROR:Schema authorization error") == 0 &&
		    stream_write(out,PROMPT1,sizeof(PROMPT1)-1,1) >=0 )
			stream_flush(out);
		res_tables_destroy(m->results);
		mvc_destroy(m);
		return connect_error(in, out);
	}
	/* Send the profile to the client for inspection*/
	if (!sendProperty(out, "version", "4.3") ||
	    !sendProperty(out, "language", "sql") ||
	    !sendProperty(out, "schema", schema) ||
	    stream_flush(out) < 0) {
		res_tables_destroy(m->results);
		mvc_destroy(m);
		return connect_error(in, out);
	}
		
	ret = sqlclient2(m, stk, rs, out, trace, 0 );
	res_tables_destroy(m->results);
	mvc_destroy(m);
	/* Make sure that the write- (out-) stream is closed first,
	 * as the related read- (in-) stream closes the shared
	 * socket; see also MonetDB/src/common/stream.mx:socket_close .
	 */
	bstream_destroy(rs);
	close_stream(out);
	close_stream(in);
	monetSetChannel(sqlthread,bkin,bkout);
	return ret;
}

int sqlconsole(Cntxt stk, YYSTREE lt, ValPtr res)
{
	int ret = GDK_SUCCEED;
	char *schema;

	stream *in = GDKin, *out = GDKout;
	bstream *rs;
	mvc *m;

  	if (lt->cnt != 0)
        	return handle_argerror(res, lt->cnt, 0);

	rs = bstream_create(in, 0);
	m = mvc_create(1, (backend_stack)stk, rs, out );
	if (!m) {
		GDKerror("Couldn't start sqlconsole");
		return GDK_FAIL;
	}
	schema = mvc_login( m, "monetdb", "monetdb" );

	if (!schema){
		stream_printf(out, "!ERROR:Schema authorization error");
		stream_flush(out);
		res_tables_destroy(m->results);
		mvc_destroy(m);
		return GDK_FAIL;
	}
	sendProperty(out, "version", "4.3");
	sendProperty(out, "language", "sql");
	sendProperty(out, "schema", schema);
	stream_flush(out);

	ret = sqlclient2(m, stk, rs, out, 0, 1 );
	res_tables_destroy(m->results);
	mvc_destroy(m);
	bstream_destroy(rs);
	return ret;
}

int mvc_new(Cntxt stk, YYSTREE lt, ValPtr res)
{
	stream *in = GDKin, *out = GDKout;
	bstream *rs;
	mvc *m;

  	if (lt->cnt != 0)
        	return handle_argerror(res, lt->cnt, 0);

	rs = bstream_create(in, 0);
	m = mvc_create(1, (backend_stack)stk, rs, out );

	mvc_trans(m); /* start transaction */
	m->user_id = m->role_id = USER_MONETDB;
	m->user = _strdup("monetdb");
	m->trans->schema = mvc_bind_schema(m, "sys");

	res->vtype = TYPE_mvc;
	res->val.pval = (ptr)m;
	return GDK_SUCCEED;
}

int mvc_destroy_wrap(mvc *m, int *commit )
{
	if (*commit)
		mvc_commit(*(mvc**)m, 0, NULL);
	else
		mvc_rollback(*(mvc**)m, 0, NULL);
	res_tables_destroy(m->results);
	mvc_destroy(*(mvc**)m);
	return GDK_SUCCEED;
}


@= dec_tostr
	char buf[32];
	@1 v = *(@1*)a;
	int scale = (int)(ptrdiff_t)extra, cur = 31, neg = (v<0)?1:0, i, done = 0;
	int l;

	if (v == @1_nil) {
		if (*len < 4){
			if (*Buf) GDKfree(*Buf);
			*len = 4;
			*Buf = GDKmalloc(*len);
		}
		strcpy(*Buf, "nil");
		return 3;
	}
		
	if (v<0) v = -v;

	buf[cur--] = 0;
	if (scale){
		for(i=0; i<scale; i++){
			buf[cur--] = (char) (v%10 + '0');
			v /= 10;
		}
		buf[cur--] = '.';
	}
	while(v){
		buf[cur--] = (char ) (v%10 + '0');
		v /= 10;
		done = 1;
	}
	if (!done)
		buf[cur--] = '0';
	if (neg)
		buf[cur--] = '-';
	l = (32-cur-1);
	if (*len < l){
		if (*Buf) GDKfree(*Buf);
		*len = l+1;
		*Buf = GDKmalloc(*len);
	}
	strcpy(*Buf, buf+cur+1);
	return l-1;
@c

int dec_tostr( void *extra, char **Buf, int *len, int type, ptr a)
{
	/* support dec map to sht, int and lng */
	if (type == TYPE_sht){
		@:dec_tostr(sht)@
	} else if (type == TYPE_int){
		@:dec_tostr(int)@
	} else if (type == TYPE_lng){
		@:dec_tostr(lng)@
	} else {
		GDKwarning("Decimal cannot be mapped to %s\n", ATOMname(type));
	}
	return 0;
}

int sql_time_tostr( void *M, char **buf, int *len, int type, ptr A)
{
	mvc *m = M;
	int len1, big=128;
	char buf1[128], *s1 = buf1, *s;
	lng val, timezone = m->timezone * 60*1000;
	daytime tmp, *a = A;
        daytime mtime = 24*60*60*1000;

	(void)type;
	if (*(int*)a == int_nil) {
		if( *len <5){
			if (*buf) GDKfree(*buf);
			*buf = (str) GDKmalloc(*len = 16);
		} s= *buf;
		strcpy(s, "nil");
		return 3;
	}

	val = *a + timezone;
	if (val < 0)
                val = mtime + val;
        if (val > mtime)
                val = val - mtime;
	tmp = (daytime)val;

	len1 = daytime_tostr(&s1, &big, &tmp);

	if (*len < len1+ 8) {
		if (*buf) GDKfree(*buf);
		*buf = (str) GDKmalloc(*len = len1+8);
	} s = *buf;
	strcpy(s, buf1); s += len1;

	*s++ = (m->timezone>=0)?'+':'-';
	sprintf(s, "%02d:%02d", ABS(m->timezone)/60, ABS(m->timezone)%60); 
	s += 5;
	return (int) (s - *buf);
}

int sql_timestamp_tostr( void *M, char **buf, int *len, int type, ptr A)
{
	mvc *m = M;
	int len1, len2, big=128;
	char buf1[128], buf2[128], *s, *s1=buf1, *s2=buf2;
	timestamp tmp, *a = A;
	lng timezone = m->timezone * 60*1000;

	(void)type;
	if (*(lng*)a == lng_nil) {
		if( *len <5){
			if (*buf) GDKfree(*buf);
			*buf = (str) GDKmalloc(*len = 16);
		} s= *buf;
		strcpy(s, "nil");
		return 3;
	}

	timestamp_add(&tmp, a, &timezone);
	len1 = date_tostr(&s1, &big, &tmp.days);
	len2 = daytime_tostr(&s2, &big, &tmp.msecs);

	if (*len < len1+len2 + 8) {
		if (*buf) GDKfree(*buf);
		*buf = (str) GDKmalloc(*len = len1+len2+8);
	} s = *buf;
	strcpy(s, buf1); s += len1;
	*s++ = ' '; 
	strcpy(s, buf2); s += len2;

	*s++ = (m->timezone>=0)?'+':'-';
	sprintf(s, "%02d:%02d", ABS(m->timezone)/60, ABS(m->timezone)%60); 
	s += 5;
	return (int) (s - *buf);
}

static int bat_max_length( BAT *b ) 
{
	BUN p, q;
	int max = 0;

	BATloop(b, p, q){
		char *s = BUNtail(b,p);
		int l = strlen(s);
		if (l > max)
			max = l;
	}
	return max;
}

@= dec_frstr
	sql_subtype *t = (sql_subtype*)extra;

	unsigned int i, neg = 0;
	char *p = s;
	@1 *r;
	@1 res = 0;
	if (*s == '-'){
		neg = 1;
		s++;
	} else if (*s == '+'){
		neg = 0;
		s++;
	}
	for( i = 0; i < (t->digits-t->scale) && *s != '.' && *s; i++, s++){
		if (!*s || *s < '0' || *s > '9' ){
			GDKerror("decimal wrong format (%s)", p);
			return NULL;
		}
		res *= 10;
		res += (*s-'0');
	}
	if (!*s && t->scale) {
		GDKerror("decimal wrong format (%s)", p);
		return NULL;
	}
	if (*s){
		if (*s != '.'){
			GDKerror("decimal wrong format (%s)", p);
			return NULL;
		}
		s++;
		for( i = 0; *s && i < t->scale; i++, s++){
			if (*s < '0' || *s > '9' ){
				GDKerror("decimal wrong format (%s)", p);
				return NULL;
			}
			res *= 10;
			res += (*s-'0');
		}
	}
	if (*s){
		GDKerror("decimal wrong format (%s)", p);
		return NULL;
	}
 	r = (@1*)GDKmalloc(sizeof(@1));
	if (neg)
		*r = -res;
	else
		*r = res;
	return (ptr*)r;
@c

ptr *dec_frstr( void *extra, int type, char *s, char *e, char quote)
{
	/* support dec map to sht, int and lng */
	(void)e;
	(void)quote;
	if (type == TYPE_sht){
		@:dec_frstr(sht)@
	} else if (type == TYPE_int){
		@:dec_frstr(int)@
	} else if (type == TYPE_lng){
		@:dec_frstr(lng)@
	} else {
		GDKwarning("Decimal cannot be parsed from %s\n", ATOMname(type));
	}
	return NULL;
}

ptr *_ASCIIadt_frStr( void *extra, int type, char *s, char *e, char quote){
        int l = 0;
        ptr *res = NULL;
	(void) extra;
	if (!(type == TYPE_str && quote) && strcasecmp(s, "NULL") == 0) {
		res = (ptr*)ATOMnil(type);
	} else if (type == TYPE_str) {
		return ASCIIstrFrStr( s, e );
	} else {
                (void) (*BATatoms[type].atomFromStr)(s, &l, (ptr)&res);
	}
        return res;
}


static int _ASCIIadt_toStr( void *extra, char **buf, int *len, int type, ptr a){

	(void) extra;
	if (!a || ATOMcmp(type, ATOMnilptr(type),a) == 0){
		char *dst;
		const char src[] = "NULL";
		int l = sizeof(src) - 1;

		if (l+1 > *len) {
			GDKfree(buf);
			*len = l+1;
			*buf = GDKmalloc( *len );
		}
		dst = *buf;
		strncpy(dst, src, l);
		dst[l] = 0;
		return l;
	} else {
        	return (*BATatoms[type].atomToStr)(buf, len, a);
	}
}


BAT *mvc_import_table( mvc *m, bstream *bs, char *tname,
		char *sep, char *rsep, int sz)
{
	int i = 0;
	sql_trans *tr = m->trans;
	sql_table *t = mvc_bind_table(m, tr->schema, tname);
	node *n;
	BAT *bats = NULL;
	ascii as;
        ascii_io *fmt;

	if (!t){
		GDKerror("table %s not found\n", tname );
		m->type = -1;
		return NULL;
	}
	if (!bs || stream_errnr(bs->s)){
		GDKerror("stream not open %d\n", stream_errnr(bs->s));
		m->type = -1;
		return  NULL;
	}

	if (t->columns.set){
		stream *out = m->scanner.ws;
		as.nr_attrs = list_length(t->columns.set);
		as.nr = sz;
		fmt = as.format =
                    (ascii_io*)GDKmalloc(sizeof(ascii_io) * (as.nr_attrs + 1) );

		if (!isa_block_stream(bs->s))
			out = NULL;

		for (n = t->columns.set->h, i=0; n; n = n->next, i++)
		{
			sql_column *col = n->data;

			fmt[i].name = _strdup(col->base.name);
                	fmt[i].sep = (n->next)?_strdup(sep):_strdup(rsep);
                	fmt[i].seplen = (int) strlen( fmt[i].sep );
                	fmt[i].type = _strdup(col->type->type->base.name);
                	fmt[i].adt = ATOMindex( fmt[i].type );
                	fmt[i].tostr = &_ASCIIadt_toStr;
                	fmt[i].frstr = &_ASCIIadt_frStr;
                	fmt[i].extra = NULL;
			if (strcmp(col->type->type->sqlname, "decimal")==0){
				fmt[i].tostr = &dec_tostr;
				fmt[i].frstr = &dec_frstr;
				fmt[i].extra = col->type;
			}
		}
        	if (ASCIIcreate_bats( &as ) >= 0){
                	if (ASCIIload_file( &as, bs, out )>=0)
                        	bats = ASCIIcollect_bats( &as );
        	}
        	ASCIIdestroy_format( &as );
	}

	m->type = Q_UPDATE;
	return bats;
}

static res_table *find_export_table( mvc *m, int res_id )
{
	res_table *r = m->results;
	for( ; r; r = r->next){
		if (r->id == res_id)
			return r;
	}
	return NULL;
}
@-
mvc_export_result dumps the sql header information
It should be produced in Monet format to enable mapi
to work with it.
@c
int mvc_export_default( mvc *m, stream *s ) 
{
	int ok = 1;
	if (s) {
		/* indicate to client that a new SQL command starts here */
		ok = (stream_write(s, "#-\n", 3, 1) == 1); 

		if (ok) ok = (stream_printf(s, "# " SZFMT, m->type) >= 0);
		if (ok) ok = (stream_write(s, " # querytype\n", 13, 1) == 1);
	}
	return (ok)?0:-1;
}

int mvc_export_result( mvc *m, stream *s, int res_id )
{
	int i, ok = 1, count;
	res_table *t = find_export_table(m, res_id);

	if (!s)
		return 0;
	/* indicate to client that a new SQL command starts here */
	ok = (stream_write(s, "#-\n", 3, 1) == 1); 

	if (ok) ok = (stream_printf(s, "# " SZFMT, t->query_type) >= 0);
	if (ok) ok = (stream_write(s, " # querytype\n", 13, 1) == 1);

	if (ok && t->query_type == Q_UPDATE) return 0;
	
	if (!ok)
		return -1;
	m->type = Q_RESULT;

	ok = (stream_write(s, "# ", 2, 1) == 1);
	for (i = 0; i < t->nr_cols && ok; i++) {
		res_col *c = t->cols+i;
		int len = strlen(c->tn);
		if (len)
			ok = (stream_write(s, c->tn, len, 1) == 1);
		if(i+1< t->nr_cols && ok)
			ok = (stream_write(s, ",\t", 2, 1) == 1);
	}
	if (ok) ok = (stream_write(s, " # table_name\n", 14, 1) == 1);

	if (ok) ok = (stream_write(s, "# ", 2, 1) == 1);
	for (i = 0; i < t->nr_cols && ok; i++) {
		res_col *c = t->cols+i;
		ok = (stream_write(s, c->name, strlen(c->name), 1) == 1);
		if(i+1< t->nr_cols && ok)
			ok = (stream_write(s, ",\t", 2, 1) == 1);
	}
	if (ok) ok = (stream_write(s, " # name\n", 8, 1) == 1);

	if (ok) ok = (stream_write(s, "# ", 2, 1) == 1);
	for (i = 0; i < t->nr_cols && ok; i++) {
		res_col *c = t->cols+i;
		ok = (stream_write(s, c->type->type->sqlname,
				strlen(c->type->type->sqlname), 1) == 1);
		if(i+1< t->nr_cols && ok)
			ok = (stream_write(s, ",\t", 2, 1) == 1);
	}
	if (ok) ok = (stream_write(s, " # type\n", 8, 1) == 1);

	if (ok) ok = (stream_write(s, "# ", 2, 1) == 1);
	for (i = 0; i < t->nr_cols && ok; i++) {
		res_col *c = t->cols+i;

		if (c->type->type->localtype == TYPE_str) {
			if (strcmp(c->type->type->sqlname, "char") == 0) {
				ok = (stream_printf(s, SZFMT, c->type->digits) >= 0);
			} else {
				count = 0;
				if (c->b) {
					BAT *b = BATdescriptor(c->b);
				
					count = bat_max_length(b);
					BBPunfix(b->batCacheid);
				} else {
					count = strlen((char*)c->p);
				}
				ok = (stream_printf(s, SZFMT, count) >= 0);
			}
		/* the following three could be done once by taking the
		   max value and calculating the number of digits from that
		   value, instead of the maximum values taken now, which
		   include the optional sign */
		} else if (strcmp(c->type->type->sqlname, "smallint") == 0) {
			count = 1;
			count += c->type->digits ? c->type->digits : 5;
			ok = (stream_printf(s, SZFMT, count) >= 0);
		} else if (strcmp(c->type->type->sqlname, "int") == 0) {
			count = 1;
			count += c->type->digits ? c->type->digits : 10;
			ok = (stream_printf(s, SZFMT, count) >= 0);
		} else if (strcmp(c->type->type->sqlname, "bigint") == 0) {
			count = 1;
			count += c->type->digits ? c->type->digits : 19;
			ok = (stream_printf(s, SZFMT, count) >= 0);
		} else if (strcmp(c->type->type->sqlname, "real") == 0) {
			/* [sign]+digit+period+[max 6 digits]+E+[sign]+[max 2 digits] */
			ok = (stream_printf(s, SZFMT, 13) >= 0);
		} else if (strcmp(c->type->type->sqlname, "double") == 0) {
			/* [sign]+digit+period+[max 14 digits]+E+[sign]+[max 3 digits] */
			ok = (stream_printf(s, SZFMT, 22) >= 0);
		} else if (strcmp(c->type->type->sqlname, "decimal") == 0) {
			count = 1 + c->type->digits;
			if (c->type->scale > 0) count += 1;
			ok = (stream_printf(s, SZFMT, count) >= 0);
		} else if (strcmp(c->type->type->sqlname, "date") == 0) {
			ok = (stream_write(s, "10", 2, 1) == 1);
		} else if (strcmp(c->type->type->sqlname, "time") == 0) {
			count = 8;
			if (c->type->scale) /* time zone */
				count += 6; /* +03:30 */
			if (c->type->digits) /* fractional seconds precision */
				count += 1 + c->type->digits;
			ok = (stream_printf(s, SZFMT, count) >= 0);
		} else if (strcmp(c->type->type->sqlname, "timestamp") == 0) {
			count = 10 + 1 + 8;
			if (c->type->scale) /* time zone */
				count += 6; /* +03:30 */
			if (c->type->digits) /* fractional seconds precision */
				count += 1 + c->type->digits;
			ok = (stream_printf(s, SZFMT, count) >= 0);
		} else {
			ok = (stream_write(s, "0", 1, 1) == 1);
		}
		if(i+1< t->nr_cols && ok)
			ok = (stream_write(s, ",\t", 2, 1) == 1);
	}
	if (ok) ok = (stream_write(s, " # length\n", 10, 1) == 1);

	{
		size_t count;
		if (t->order) {
			BAT *order = BATdescriptor(t->order);
			count = BATcount(order);
			BBPunfix(order->batCacheid);
		} else
			count = 1;
		if (ok) ok = (stream_printf(s, "# " SZFMT, count) >= 0);
		for (i = 1; i < t->nr_cols && ok; i++)
			ok = (stream_write(s, ",\t", 2, 1) == 1);
		if (ok) ok = (stream_write(s, " # tuplecount\n", 14, 1) == 1);
	}

	if (ok) ok = (stream_printf(s, "# %d", t->id) >= 0);
	for (i = 1; i < t->nr_cols && ok; i++)
		ok = (stream_write(s, ",\t", 2, 1) == 1);
	if (ok) ok = (stream_write(s, " # id\n", 6, 1) == 1);

	return (ok)?0:-1;
}

static int mvc_export_row( mvc *m, stream *s, res_table *t )
{
	char *sep = ",\t";
	char *rsep = "\t]\n";

	int i, ok = 1;

	m->type = Q_RESULT;
	if (!s)
		return 0;

	ok = (stream_write(s, "[ ", strlen("[ "), 1) == 1);
	for (i = 0; i < t->nr_cols && ok; i++)
	{
		res_col *c = t->cols+i;
		if (i != 0) {
			ok = (stream_write(s, sep, strlen(sep), 1) == 1);
			if (!ok) 
				break;
		}

		if (c->type->type->scale == SCALE_FIX &&
	            strcmp(c->type->type->sqlname, "decimal")==0){
			char *buf = NULL;
			int len = 0;
			int l = dec_tostr((void*)(ptrdiff_t)c->type->scale, &buf, &len,
					c->mtype, c->p);
			ok = (stream_write(s, buf, l, 1) == 1);
			_DELETE(buf);
		} else if (c->type->scale == SCALE_FIX &&
	            strcmp(c->type->type->sqlname, "time")==0){
			char *buf = NULL;
			int len = 0;
			int l = sql_time_tostr((void*)m, &buf, &len,
					c->mtype, c->p);
			ok = (stream_write(s, buf, l, 1) == 1);
			_DELETE(buf);
		} else if (c->type->scale == SCALE_FIX &&
	            strcmp(c->type->type->sqlname, "timestamp")==0){
			char *buf = NULL;
			int len = 0;
			int l = sql_timestamp_tostr((void*)m, &buf, &len,
					c->mtype, c->p);
			ok = (stream_write(s, buf, l, 1) == 1);
			_DELETE(buf);
		} else if (!c->p ||
			ATOMcmp(c->mtype, ATOMnilptr(c->mtype),c->p) == 0){
			ok = (stream_write(s, "NULL", sizeof("NULL")-1, 1) ==1);
		} else {
			char *buf = NULL;
			int len = 0;
			int l = (*BATatoms[c->mtype].atomToStr)(&buf, &len, c->p);
			ok = (stream_write(s, buf, l, 1) == 1);
			_DELETE(buf);
		}
	}
	mvc_clean_result(m, t);
	if (ok) ok = (stream_write(s, rsep, strlen(rsep), 1) == 1);
	return (ok)?0:-1;
}

int mvc_export_table( mvc *m, stream *s, int res_id, unsigned int offset, unsigned int nr )
{
	char *sep = ",\t";
	char *rsep = "\t]\n";

	ascii as;
        ascii_io *fmt;
	res_table *t = find_export_table(m, res_id);
	ssize_t i;
	size_t cnt;
	int clean = 0;
	BAT *order = NULL;

	if (!t)
		return -1;
	if (!s)
		return 0;

	if (!t->order)
		return mvc_export_row(m, s, t );

	m->type = Q_RESULT;
	order = BATdescriptor(t->order);
	cnt = nr;
	if (cnt == 0){
 		cnt = BATcount(order);
		clean = 1;
	}
	if (offset >= BATcount(order))
		cnt = 0;
	if (offset + cnt > BATcount(order)){
		cnt = BATcount(order)-offset;
		clean = 1;
	}

	if (cnt == 0){
		if (clean || !BATcount(order)) {
			BBPunfix(order->batCacheid);
			mvc_clean_result(m, t);
		}
		if (stream_errnr(s))
			return -1;
		return 0;
	}
	as.nr_attrs = t->nr_cols +1; /* for the leader */
	as.nr = cnt;
	as.offset = offset;
	fmt = as.format =
                (ascii_io*)GDKmalloc(sizeof(ascii_io) * (as.nr_attrs+1));

	memset(fmt, 0, (as.nr_attrs+1)*sizeof(ascii_io));

        fmt[0].c= NULL;
        fmt[0].sep = _strdup("[ ");
        fmt[0].seplen = (int) strlen( fmt[0].sep );

	for (i = 1; i <= t->nr_cols; i++)
	{
		res_col *c = t->cols+(i-1);
		if (!c->b)
			break;

		fmt[i].c = BATdescriptor(c->b);
		fmt[i].name = NULL;
                fmt[i].sep = ((i-1)<(t->nr_cols-1))?_strdup(sep):_strdup(rsep);
                fmt[i].seplen = (int) strlen( fmt[i].sep );
		fmt[i].type = ATOMname(fmt[i].c->ttype);
		fmt[i].adt = fmt[i].c->ttype;
                fmt[i].tostr = &_ASCIIadt_toStr;
                fmt[i].frstr = &_ASCIIadt_frStr;
                fmt[i].extra = NULL;
		if (c->type->type->scale == SCALE_FIX && 
		    strcmp(c->type->type->sqlname, "decimal") == 0){
			fmt[i].tostr = &dec_tostr;
			fmt[i].frstr = &dec_frstr;
			fmt[i].extra = (void*)(ptrdiff_t)c->type->scale;
		} else 
		if (c->type->scale == SCALE_FIX && 
	            strcmp(c->type->type->sqlname, "timestamp")==0){
			fmt[i].tostr = &sql_timestamp_tostr;
			fmt[i].frstr = NULL;
			fmt[i].extra = m;
		} else 
		if (c->type->scale == SCALE_FIX && 
	            strcmp(c->type->type->sqlname, "time")==0){
			fmt[i].tostr = &sql_time_tostr;
			fmt[i].frstr = NULL;
			fmt[i].extra = m;
		}
	}
	if (i == t->nr_cols+1){
		ASCIIoutput_file(&as, order, s);
	}
	BBPunfix(order->batCacheid);
	ASCIIdestroy_format( &as );
	if (clean)
		mvc_clean_result(m, t);
	if (stream_errnr(s)) 
		return -1;
	return 0;
}
