@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at 
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@' 
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@' 
@' The Original Code is the Monet Database System.
@' 
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2002 CWI.  
@' All Rights Reserved.
@' 
@' Contributor(s):
@' 		Martin Kersten <Martin.Kersten@cwi.nl>
@' 		Niels Nes <Niels.Nes@cwi.nl>
@' 		Stefan Manegold <Stefan.Manegold@cwi.nl>
@' 		Peter Boncz <Peter.Boncz@cwi.nl>

@f sql_session
@a N.J. Nes
@* 

@* Session code

This small module contains the code to instantiate an SQL client.
This code strongly depends on the front-end/back-end setup.

@h
#ifndef _SQL_SESSION_H_
#define _SQL_SESSION_H_

#include "sql_server.h"
#include <sql_backend.h>
#include <sql_context.h>
#include <sql_semantic.h>
#include <monet_context.h>
#include <kernel.h>
#include <str.h>

typedef struct backend {
	int 	debug;
	int 	trace;
	mvc 	*mvc;

	buffer *outbuf;
	stream *out;
} backend;

extern int mvc_export_result( mvc *c, stream *s, int res_id );
extern int mvc_export_table( mvc *c, stream *s, int res_id, int offset, int nr);
extern BAT *mvc_import_table( mvc *c, stream *s, char *tname, char *sep, char *rsep, int nr);

extern void monet4_freestack( backend_stack stk );
extern void monet4_freecode( backend_code code, backend_stack stk, int nr );
extern void monet4_parse( backend_stack stk, char *code );

extern int sqlstatement(char *cmd, Cntxt stk );
extern int mvc_sql(mvc *m, char *cmd );

#endif /*_SQL_SESSION_H_*/
@c
#include "sql_session.h"
#include "sql_server.h"
#include "sql_gencode.h"	/* for backend_dumpproc() */
#include <sql_context.h>
#include <sql_scope.h>
#include <sql_qc.h>
#include <sql_parser.h>		/* for sqlparse() */

@= builtin_operand
{       int _k = interpret(stk, arg(lt, @1), res);
        if (_k < 0) {
                return _k;
        }
        @3 = VALconvert(@2, res);
        if ((@3 == ILLEGALVALUE)  || (@2 == TYPE_bat && !@3)) {
                return handle_paramerror(res,@1,res->vtype,@2);
        }
}
@c

static backend *backend_create( int trace, mvc *c )
{
	backend *b = NEW(backend);

	b->debug = c->debug;
	b->mvc = c;
	
 	b->outbuf = buffer_create( BUFSIZ );
	b->out = buffer_wastream( b->outbuf, "SQLserver" );
	b->trace = trace;
	return b;
}

static void backend_destroy( backend *b )
{
	if (b->out){
		buffer_destroy( b->outbuf );
		stream_close( b->out );
		stream_destroy( b->out );
	}
	_DELETE(b);
}
	
static YYSTREE milnode(int tok, int tpe, ptr valp) 
{
        YYSTREE res = yynode(tok, tpe);
        VALset(&res->yyval, tpe, valp);
        return res;
}

static YYSTREE milnode2(int tok, ValPtr valp) 
{
        YYSTREE res = yynode(tok, valp->vtype);
	res->yyval = *valp;
	res->dealloc = 0;
        return res;
}

static int backend_parse( Cntxt stack, char *cmd )
{
	int err = 0;

	if (cmd){
		ValRecord v;

		v.vtype = TYPE_void;

		err = interpret_str( stack, cmd, &v);
	}
	return err;
}

void monet4_parse( backend_stack stack, char *cmd )
{
	backend_parse( (Cntxt)stack, cmd );
}

Cntxt backend_newstack( Cntxt stk )
{
	Cntxt procstk;

	procstk = CNTXTnew(stk);
	CNTXTuse(procstk);
	monet_cntxt[procstk].reuse = TRUE;

	return procstk;
}

void monet4_freestack( backend_stack stk )
{
	Cntxt procstk = (Cntxt)(ptrdiff_t)stk;

	monet_cntxt[procstk].reuse = FALSE;
	CNTXTclear(procstk);
	CNTXTfree1(procstk);
	CNTXTdelete(procstk);
}

static void 
reset_arg_tree( YYSTREE args )
{
	while(args){
		int i;
		for (i=0; i< args->cnt; i++){
			if (args->yysons[i])
				reset_arg_tree(args->yysons[i]);

		}
		args->yyval.vtype = TYPE_void; 
		args->yyval.len = 0; 

		args = args->overflow;
	}
}

void monet4_freecode( backend_code code, backend_stack stk, int nr)
{
	YYSTREE callnode = (YYSTREE)code;
	if (code){
		Client client;
		char name[BUFSIZ]; 
		int i;
		int l = callnode->yysons[1]->cnt;
		ValPtr argv;

		/* clear default arguments */
		reset_arg_tree( callnode->yysons[0] );

		/* clear fastpath arguments */
 		argv = (ValPtr) callnode->yysons[1]->yyval.val.pval;
		for (i=1; i<l; i++){
			argv[i].vtype = TYPE_void; 
			argv[i].len = 0; 
		}

		/* cleanup proc */
		yyfree(callnode);

		snprintf(name, BUFSIZ, "sql%d", nr);
		CNTXTclient( (Cntxt)(ptrdiff_t)stk, &client);
		TBL_delproc(client, name);
	}
}

YYSTREE monet4_interpret( Cntxt procstk, char *name, list *args )
{
	YYSTREE callnode;
	YYSTREE argtree;
	node *n;
	int err = 0;
	ValRecord v;

	v.vtype = TYPE_void;
	callnode = milnode(TOK_FUNCTION, TYPE_str, _strdup(name)); 
 	argtree = yynode(0,0);
	if (args){
  		for (n=args->h; n; n = n->next){
			atom *a = n->data;
			YYSTREE arg = milnode2(TOK_CONSTANT, &a->data );
       			argtree = yyexpand(argtree, arg);
		}
	}
	yyexpand(callnode, argtree);
	yyexpand(callnode, yynode(0,TYPE_int));
	err = interpret( procstk, callnode, &v);

	(void) err;	/* Stefan: unused!? */

	return callnode;
}

int backend_fastpath( Cntxt procstk, YYSTREE callnode, list *args )
{
	int err = 0;
	ValRecord v;
	node *n;

	v.vtype = TYPE_void;
	if (args){
		int i;

		ValPtr argv = (ValPtr) callnode->yysons[1]->yyval.val.pval;
	  	for (i=1, n=args->h; n; i++, n = n->next){
			atom *a = n->data;
			argv[i] = a->data;
		}
	}
	err = interpret( procstk, callnode->yysons[1]->yysons[0], &v);
	return err;
}


int connect_error(stream *in, stream *out)
{
	close_stream(in);
	close_stream(out);
	return GDK_FAIL;
}

int explain_cmd( mvc *c, char *cmd, stream *out )
{
	int t_id;
	BAT *b;

	strSplit(&b, cmd, "\n");
	BATseqbase(b, 0);
 	t_id = mvc_result_table( c, 1, b);
	mvc_result_column( c, "statement", "STRING", -1,-1, b);	
	BBPunfix(b->batCacheid);
	return mvc_export_result( c, out, t_id ) ||
		mvc_export_table( c, out, t_id, 0, -1 );
}

int sqlexecute(backend * be, stream *out, int output )
{
	mvc *c = be->mvc;
	char *cmd = NULL, *s;
	int err = 0, explain = 0;
	cq *q = NULL;

	cmd_init(c);

	s = c->scanner.buf;

	c->type = Q_PARSE;
	c->status = 0;

	if ((err = sqlparse(c)) || c->status || !c->sym) {
		if (!err)
			err = c->status;
		return sqlcleanup(c, cmd, err);
	}
	
	if (be->trace && output){
		char *buf = s;

		char old = *c->scanner.buf;

		*c->scanner.buf = '\0';
		*c->scanner.buf = old;

		if (!stream_writeInt( out, Q_DEBUGP ) ||
		    !stream_writeInt( out, 1 ))
			return -1;

		while( buf < c->scanner.buf) {
			int i;
			char b[BUFSIZ];

		  	while( *buf != '\n' && buf < c->scanner.buf) 
				buf++;
			i = snprintf(b, BUFSIZ, "# %5d: ", c->scanner.cnt);
		  	if (stream_write(out, b, 1, i) != i ||
		  	    stream_write(out, s, 1, buf - s) != (buf-s) ||
			    stream_write(out, "\n", 1, 1) != 1)
				return -1;

			s = ++buf;
		}
		c->scanner.cnt++;
		if (stream_flush(out) < 0)
			return -1;
	}

	if (c->explain && 
	    c->explain->vtype == TYPE_str && c->explain->val.sval &&
	    strcmp(c->explain->val.sval, "mil") == 0) {
		explain = 1;
	}
	if (explain || !c->cache || 
            !(q = qc_find(c->qc, c->sym, c->params, c->scanner.key))) {
		stmt *s = sql_symbol2stmt(c);

		if (!s && c->status){
			err = c->status;
			return sqlcleanup(c, cmd, err);
		}
		if (s->type == st_assign)
			explain = 0;

		if (explain) {
			/* insert mil statements into a bat */
			if (c->args && c->params){
				node *n, *m;

	  			for (n=c->args->h, m=c->params->h; 
					n && m; 
					n = n->next, m = m->next){
					atom *a = n->data;
					var_ *v = m->data;

					stream_write(be->out, v->name, 
						strlen(v->name), 1); 
					stream_write(be->out, " := ", 
						4, 1); 
					atom_dump(a, be->out);
					stream_write(be->out, ";\n", 
						2, 1); 
				}
			}
		}

		if (explain || !c->cache) {
			int nr = 1;

			backend_dumpstmt( s, &nr, be );
		} else {
			backend_dumpproc( be, c->qc->id, s );
		}
		cmd = buffer_get_buf(be->outbuf);
    		stream_flush( be->out );
		stmt_destroy(s);
	
		if (explain) {
			err = explain_cmd( c, cmd, out );
		} else {
			err = backend_parse( c->stk, cmd );
			if (c->cache){
				q = qc_insert(c->qc, c->sym, c->params, 
						c->scanner.key, c->type );
				c->sym = NULL;
				c->params = NULL;
			}
		} 

		/* beware to use free instead of _DELETE
 	 	 * as the stream library is build with out 
	 	 * libbat ie. it cannot use gdkmalloc 
	 	 * can be used */
	        free(cmd); 
		cmd = NULL;

		if (err)
			return sqlcleanup(c, cmd, err);
	}
	if (q && !q->code) {
		char buf[BUFSIZ];
		Cntxt procstk = backend_newstack(c->stk);
		YYSTREE callnode;

		snprintf( buf, BUFSIZ, "sql%d", q->id);

		c->type = q->type;
		callnode = monet4_interpret( procstk, buf, c->args);

		if (callnode){
			q->code = (backend_code)callnode;
			q->stk = (backend_stack)(ptrdiff_t)procstk;
		} else {
			backend_freestack( (backend_stack)(ptrdiff_t)procstk );
		}
	} else if (q) {
		c->type = q->type;
		err = backend_fastpath( (Cntxt)(ptrdiff_t)q->stk, (YYSTREE)q->code, c->args);
	}
	/* 
 	 * clear query cache after Transaction boundaries (commit/rollback)
	 * and on schema changes 
	 */
	if (c->type == Q_TRANS || c->type == Q_SCHEMA || 
	    (c->cache && c->qc->id > 10)) {
		if (c->qc) qc_destroy(c->qc);
		c->qc = qc_create();
	}
	sql_destroy_args(c);
	sql_destroy_params(c);

	if (!err && !explain && output) {
		ssize_t status, type;

		if ((status = mvc_status(c)) < 0){
			char *errstr = "Error in result";
			if (!stream_writeInt( out, mvc_type(c) ) ||
			    !stream_writeInt( out, status ) ||
			    stream_write( out, errstr, 
					strlen(errstr), 1 ) != 1 ||
			    stream_flush( out ) < 0)
				return -1;
  		} else if ( (type = mvc_type(c)) != Q_RESULT ) {
			if (!stream_writeInt( out, type ) ||
			    !stream_writeInt( out, status ) ||
			    stream_flush( out ) < 0)
				return -1;
  		}
	}
	return sqlcleanup(c, cmd, err);
}


int 
sqlclient2(mvc *m, Cntxt stk, stream *in, stream *out, 
	int trace, int reply_size)
{
	int go = TRUE;
	char *errbuf;
	backend *sql;
	Variable v;

	sql = backend_create( trace, m );

	/* add myc and Output, Input to the stack */
	v = VARnew(stk, "myc");
	v->binding.vtype = TYPE_mvc;
	v->binding.val.pval = m;

	v = VARnew(stk, "Output");
	v->binding.vtype = TYPE_Stream;
	v->binding.val.pval = out;

	v = VARnew(stk, "Input");
	v->binding.vtype = TYPE_Stream;
	v->binding.val.pval = in;

	v = VARnew(stk, "explain");
	v->binding.vtype = TYPE_str;
	v->binding.val.sval = NULL;
	m->explain = &v->binding;

	v = VARnew(stk, "reply_size");
	v->binding.vtype = TYPE_int;
	v->binding.val.ival = reply_size;

 	errbuf = GDKmalloc(GDKMAXERRLEN);
	errbuf[0] = '\0';
	GDKsetbuf(errbuf);

	while(go){
		int nsize = BUFSIZ;
		int size = BUFSIZ + 1, err = 0;
		char *inbuf = NEW_ARRAY(char, size ), *start = inbuf;
		ssize_t inlen = 0, len;

		while ((len = stream_read(in, start, 1, nsize)) == nsize){
			inlen += nsize;
			nsize *= 4;
			size += nsize;
			inbuf = RENEW_ARRAY(char, inbuf, size); 
			start = inbuf + size - nsize - 1;
			*start = '\0';
		}
		if (len < 0){
			_DELETE(inbuf);
			go = !go;
 			break;
		}
		inlen += len;
		inbuf[inlen] = '\0';

		if (!inlen || inbuf[0] == EOT) {
			_DELETE(inbuf);
			break;
		}

		m->scanner.buf = inbuf;
		m->scanner.cur = ' ';

		while( m->scanner.buf && *m->scanner.buf && 
		       *m->scanner.buf != EOT ){
			char *ibuf = m->scanner.buf;

			err = sqlexecute(sql, out, 1 );
			if (err){ /* output error */
				char *buf = GDKerrbuf;

				if (stream_errnr(out) != 0 ||
				    !stream_writeInt( out, -1 ) ||
				    !stream_writeInt( out, err ) ||
				    stream_write( out, m->errstr, 
						strlen(m->errstr), 1 ) != 1 ||
				    (buf && stream_write( out, buf, strlen(buf), 1 ) != 1)){
					go = !go;
					break;
				}
				buf[0] = 0; /* reset error buf */
	
				/* show the buggy query */
				if ( stream_write( out, " in:\n", 5, 1) != 1){
					go = !go;
					break;
				}
				if (ibuf != m->scanner.buf)
					m->scanner.buf[-1] = '\0';
				while (ibuf[0] == '\n') ibuf++;
				if ( stream_write( out, ibuf, strlen(ibuf), 1) != 1 ||
				     stream_flush( out ) < 0 ){
					go = !go;
					break;
				}
			}
		}
		if (inbuf) _DELETE(inbuf);
	}

	_DELETE(errbuf);
	GDKsetbuf(NULL);
	backend_destroy( sql );
	return GDK_SUCCEED;
}


int 
sqlserver(Cntxt stk, YYSTREE lt, ValPtr res)
{
	int ret = 0;
	mvc *m;

	(void)lt; (void)res;
	m = mvc_create(0, 0, (backend_stack)stk );
	m->user_id = m->role_id = 0;
	m->user = _strdup("monetdb");
	m->trans->schema = mvc_bind_schema(m, "sys");

	ret = sqlclient2(m, stk, GDKin, GDKout, 0, -1);
	mvc_destroy(m);
	return ret;
}

int 
sqlstatement(char *cmd, Cntxt stk )
{
	int err = 0;
	mvc *m;
	backend *sql;
	Variable v;

	m = mvc_create(0, 0, (backend_stack)stk );
	m->user_id = m->role_id = 0;
	m->user = _strdup("monetdb");
	m->trans->schema = mvc_bind_schema(m, "sys");
        sql = backend_create( 0, m );

	/* add myc and Output, Input to the stack */
	v = VARnew(stk, "myc");
	v->binding.vtype = TYPE_mvc;
	v->binding.val.pval = m;

	m->scanner.buf = cmd;
	m->scanner.cur = ' ';
	err = sqlexecute(sql, GDKout, 0 );
	backend_destroy( sql );
	mvc_commit(m, 0, NULL);
	mvc_destroy(m);
	if (err)
		return GDK_FAIL;
	else
		return GDK_SUCCEED;
}

int 
mvc_sql(mvc *c, char *cmd )
{
	mvc *m = *(mvc**)c;
	Cntxt stk = (Cntxt)m->stk;
	mvc o = *m;

	int err = 0;
	backend *sql;
	Variable v;

        sql = backend_create( 0, m );

	/* add myc and Output, Input to the stack */
	v = VARnew(stk, "myc");
	v->binding.vtype = TYPE_mvc;
	v->binding.val.pval = m;

	m->qc = NULL;
	m->cache = 0;
	m->scanner.buf = cmd;
	m->scanner.cur = ' ';
	m->scanner.key = 0;
	m->scanner.sql = NEW_ARRAY(char, BUFSIZ);
	m->scanner.sqlsize = BUFSIZ;
	m->scanner.sql[0] = '\0';

	m->params = NULL;
	m->args = NULL;
	m->sym = NULL;

	err = sqlexecute(sql, GDKout, 0 );
	backend_destroy( sql );
	_DELETE(m->scanner.sql);
	*m = o;
	if (err)
		return GDK_FAIL;
	else
		return GDK_SUCCEED;
}

int 
sqlclient(Cntxt stk, YYSTREE lt, ValPtr res)
{
	int debug = 0, trace = 0, reply_size = 100, l = 0, ret = GDK_SUCCEED;
	ssize_t i = 0;
	char buf[BUFSIZ+1];
	char *user, *passwd, *schema, *dbname;

	mvc *m;
	stream **In, **Out;
	stream *in, *out;

  	if (lt->cnt != 2) {
        	return handle_argerror(res, lt->cnt, 2);
  	}
  	@:builtin_operand(0,TYPE_Stream,In)@
	in = *In;
  	@:builtin_operand(1,TYPE_Stream,Out)@
	out = *Out;

	out = block_stream( stream_wstream( out ));
	in  = block_stream( stream_rstream( in ));

	if ((i = stream_read(in, buf, 1, BUFSIZ)) < 0)
		return connect_error(in, out);
	buf[i] = 0;
	/* expect api(sql,debug); */
	l = strlen("api(sql,");
	if (i > l+1) {
		char *s = NULL;
		debug = strtol(buf+l,&s,10);
		if (s) {
			s++; /* skip , */
			trace = strtol(s, &s, 10);
			if (s) {
				s++; /* skip , */
				reply_size = strtol(s, NULL, 10);
			}
		}
	}

	i=snprintf(buf, BUFSIZ, "login\n" );
	if (stream_write(out, buf, 1, i) != i || stream_flush(out) < 0)
		return connect_error(in, out);

	if ((i = stream_read(in, buf, 1, BUFSIZ)) < 0)
		return connect_error(in, out);
	buf[i] = 0;
	/* expect login(user,passwd); */
	l = strlen("login(");
	if (i > l+1 ){
		char *s, *e = strchr(buf+l,',');
		if (!e) return connect_error(in, out);
		*e = 0;
		s = e+1; /* skip comma */
		e = strrchr(s, ')');
		if (!e) return connect_error(in, out);
		*e = 0;
		user = GDKstrdup(buf+l);
		passwd = GDKstrdup(s);
	} else {
		return connect_error(in, out);
	}
	m = mvc_create(debug, 1, (backend_stack)stk );
	schema = mvc_login( m, user, passwd );
	GDKfree(user);
	GDKfree(passwd);
	dbname = GDKgetenv("gdk_dbname");

	i = snprintf(buf, BUFSIZ, "%s,%s\n", dbname, schema?schema:"" );
	if (stream_write(out, buf, 1, i) != i || stream_flush(out) < 0) 
		return connect_error(in, out);

	if (!schema){ 
		mvc_destroy(m);
		return connect_error(in, out);
	} else {
		GDKfree(schema);
	}

	ret = sqlclient2(m, stk, in, out, trace, reply_size);
	mvc_destroy(m);
	close_stream(in);
	close_stream(out);
	return ret;
}

@= dec_tostr
	char buf[32];
	@1 v = *(@1*)a;
	int scale = (int)(ptrdiff_t)extra, cur = 31, neg = (v<0)?1:0, i, done = 0;
	int l;

	if (v<0) v = -v;

	buf[cur--] = 0;
	if (scale){
		for(i=0; i<scale; i++){
			buf[cur--] = (v%10) + '0';
			v /= 10;
		}
		buf[cur--] = '.';
	}
	while(v){
		buf[cur--] = (v%10) + '0';
		v /= 10;
		done = 1;
	}
	if (!done)
		buf[cur--] = '0';
	if (neg)
		buf[cur--] = '-';
	l = (32-cur-1);
	if (*len < l){
		if (*Buf) GDKfree(*Buf);
		*len = l+1;
		*Buf = GDKmalloc(*len);
	}
	strcpy(*Buf, buf+cur+1);
	return l-1;
@c

int dec_tostr( void *extra, char **Buf, int *len, int type, ptr a){
	/* support dec map to sht, int and lng */
	if (type == TYPE_sht){
		@:dec_tostr(sht)@
	} else if (type == TYPE_int){
		@:dec_tostr(int)@
	} else if (type == TYPE_lng){
		@:dec_tostr(lng)@
	} else {
		GDKwarning("Decimal cannot be mapped to %s\n", ATOMname(type));
	}
	return 0;
}

@= dec_frstr
	sql_subtype *t = (sql_subtype*)extra;

	int i, neg = 0;
	char *p = s;
	@1 *r;
	@1 res = 0;
	if (*s == '-'){
		neg = 1;
		s++;
	} else if (*s == '+'){ 
		neg = 0;
		s++;
	}
	for( i = 0; i < (t->digits-t->scale) && *s != '.'; i++, s++){
		if (!*s || *s < '0' || *s > '9' ){
			GDKerror("decimal wrong format (%s)", p);
			return NULL;
		}
		res *= 10;
		res += (*s-'0');
	}
	if (*s){
		if (*s != '.'){
			GDKerror("decimal wrong format (%s)", p);
			return NULL;
		}
		s++;
		for( i = 0; *s && i < t->scale; i++, s++){
			if (*s < '0' || *s > '9' ){
				GDKerror("decimal wrong format (%s)", p);
				return NULL;
			}
			res *= 10;
			res += (*s-'0');
		}
	}
	if (*s){
		GDKerror("decimal wrong format (%s)", p);
		return NULL;
	}
 	r = (@1*)GDKmalloc(sizeof(@1));
	if (neg)
		*r = -res;
	else
		*r = res;
	return (ptr*)r;
@c

ptr *dec_frstr( void *extra, int type, char *s){
	/* support dec map to sht, int and lng */
	if (type == TYPE_sht){
		@:dec_frstr(sht)@
	} else if (type == TYPE_int){
		@:dec_frstr(int)@
	} else if (type == TYPE_lng){
		@:dec_frstr(lng)@
	} else {
		GDKwarning("Decimal cannot be mapped to %s\n", ATOMname(type));
	}
	return NULL;
}

BAT *mvc_import_table( mvc *m, stream *s, char *tname, 
		char *sep, char *rsep, int sz)
{
	int i = 0, cnt = -1;
	sql_trans *tr = m->trans;
	sql_table *t = mvc_bind_table(m, tr->schema, tname);
	node *n;
	BAT *bats = NULL;
	bstream *bs = bstream_create(s, 1<<10);
	ascii as;
        ascii_io *fmt;

	if (!t){
		GDKerror("table %s not found\n", tname );
		m->type = -1;
		return NULL;
	}
	if (!s || stream_errnr(s)){
		GDKerror("stream not open %d\n", stream_errnr(s));
		m->type = -1;
		return  NULL;
	}

	if (t->columns.set){
		as.nr_attrs = list_length(t->columns.set);
		as.nr = sz;
		fmt = as.format =
                    (ascii_io*)GDKmalloc(sizeof(ascii_io) * (as.nr_attrs + 1) );

		for (n = t->columns.set->h, i=0; n; n = n->next, i++) 
		{
			sql_column *col = n->data;

			fmt[i].name = _strdup(col->base.name);
                	fmt[i].sep = (n->next)?_strdup(sep):_strdup(rsep);
                	fmt[i].seplen = (int) strlen( fmt[i].sep );
                	fmt[i].type = _strdup(col->type->type->name);
                	fmt[i].adt = ATOMindex( fmt[i].type );
                	fmt[i].tostr = &ASCIIadt_toStr;
                	fmt[i].frstr = &ASCIIadt_frStr;
                	fmt[i].extra = NULL;
			if (strcmp(col->type->type->sqlname, "decimal")==0){
				fmt[i].tostr = &dec_tostr;
				fmt[i].frstr = &dec_frstr;
				fmt[i].extra = col->type;
			}
		}
        	if (ASCIIcreate_bats( &as ) >= 0){
                	if ((cnt = ASCIIload_file( &as, bs ))>=0)
                        	bats = ASCIIcollect_bats( &as );
        	}
        	ASCIIdestroy_format( &as );
	}
	bstream_destroy(bs);

	m->type = Q_UPDATE;
	m->status = cnt;
	return bats;
}

static res_table *find_export_table( mvc *m, int res_id ){
	res_table *r = m->results;
	for( ; r; r = r->next){
		if (r->id == res_id)
			return r;
	}
	return NULL;
}

int mvc_export_result( mvc *m, stream *s, int res_id )
{
	int i;
	res_table *t = find_export_table(m, res_id);
	
	m->type = Q_RESULT;
	if (!stream_writeInt( s, Q_RESULT ) ||
	    !stream_writeInt( s, t->nr_cols ) ||
	    !stream_writeInt( s, t->id ))
		return -1;
	
	for (i = 0; i < t->nr_cols; i++) 
	{
		res_col *c = t->cols+i;

		if ((stream_write(s, c->name, strlen(c->name), 1) != 1) ||
		     stream_write(s, ",", 1, 1) != 1 ||
		     stream_write(s, c->type->type->sqlname, 
				strlen(c->type->type->sqlname), 1) != 1 ||
		     stream_write(s, "\n", 1, 1) != 1)
			return -1;
	}
	return stream_flush(s);
}

static int mvc_export_row( mvc *m, stream *s, res_table *t ) 
{
	char *sep = ",\t";
	char *rsep = "\t]\n";

	int i, res = 0;

	m->type = Q_RESULT;
	if (!stream_writeInt( s, Q_TABLE ) ||
	    !stream_writeInt( s, 1 ))
		res = -1;

	stream_write(s, "[ ", strlen("[ "), 1);
	for (i = 0; res == 0 && i < t->nr_cols; i++) 
	{
		res_col *c = t->cols+i;

		if (i != 0 && (res = stream_write(s, sep, strlen(sep), 1) != 1))
			break;

		if (c->type->type->scale == SCALE_FIX){
			char *buf = NULL;
			int len = 0;
			int l = dec_tostr((void*)(ptrdiff_t)c->type->scale, &buf, &len,
					c->mtype, c->p);
			res = (stream_write(s, buf, l, 1) != 1);
			_DELETE(buf);
		} else { 
			char *buf = NULL;
			int len = 0;
			int l = (*BATatoms[c->mtype].atomToStr)(&buf, &len, c->p);
			res = (stream_write(s, buf, l, 1) != 1);
			_DELETE(buf);
		}
	}
	mvc_clean_result(m, t);
	if (res != 0 || 
	    stream_write(s, rsep, strlen(rsep), 1) != 1)
		return -1;
	return stream_flush(s);
}

int mvc_export_table( mvc *m, stream *s, int res_id, int offset, int nr )
{
	char *sep = ",\t";
	char *rsep = "\t]\n";

	ascii as;
        ascii_io *fmt;
	res_table *t = find_export_table(m, res_id);
	size_t i;
	ssize_t cnt;
	int clean = 0, res = 0;
	BAT *order = NULL;

	if (!t) 
		return -1;

	if (!t->order)
		return mvc_export_row(m, s, t );

	m->type = Q_RESULT;
	order = BATdescriptor(t->order);
	cnt = nr;
	if (cnt < 0){
 		cnt = BATcount(order);
		clean = 1;
	}
	if (offset >= BATcount(order))
		cnt = 0;
	if (offset + cnt > BATcount(order)){
		cnt = BATcount(order)-offset;
		clean = 1;
	}

	if (!stream_writeInt( s, Q_TABLE ) ||
	    !stream_writeInt( s, cnt ))
		return -1;
	
	if (cnt <= 0)
		return stream_flush(s);
	as.nr_attrs = t->nr_cols +1; /* for the leader */
	as.nr = cnt;
	as.offset = offset;
	fmt = as.format =
                (ascii_io*)GDKmalloc(sizeof(ascii_io) * (as.nr_attrs + 1) );

	memset(fmt, 0, (as.nr_attrs+1)*sizeof(ascii_io));

        fmt[0].c= NULL;
        fmt[0].sep = _strdup("[ ");
        fmt[0].seplen = (int) strlen( fmt[0].sep );

	for (i = 0; i < t->nr_cols; i++) 
	{
		int ii = i + 1;
		res_col *c = t->cols+i;
		if (!c->b) 
			break;

		fmt[ii].c = BATdescriptor(c->b);
		fmt[ii].name = NULL;
                fmt[ii].sep = (i<(t->nr_cols-1))?_strdup(sep):_strdup(rsep);
                fmt[ii].seplen = (int) strlen( fmt[ii].sep );
		fmt[ii].type = ATOMname(fmt[ii].c->ttype);
		fmt[ii].adt = fmt[ii].c->ttype;
                fmt[ii].tostr = &ASCIIadt_toStr;
                fmt[ii].frstr = &ASCIIadt_frStr;
                fmt[ii].extra = NULL;
		if (c->type->type->scale == SCALE_FIX){
			fmt[ii].tostr = &dec_tostr;
			fmt[ii].frstr = &dec_frstr;
			fmt[ii].extra = (void*)(ptrdiff_t)c->type->scale;
		}
	}
	if (i == t->nr_cols)
		res = ASCIIoutput_file(&as, order, s);
	BBPunfix(order->batCacheid);
	ASCIIdestroy_format( &as );
	if (res >= 0 && stream_flush( s ) < 0)
		res = -1;
	if (clean)
		mvc_clean_result(m, t);
	return res;
}
