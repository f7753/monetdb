@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2005 CWI.
@' All Rights Reserved.

@f sql_server
@a N.J. Nes, M.L. Kersten
@* 
The sql_server module contains the complete wrapper interface for the
SQL client and the corresponding MIL runtime startup.

The implementation described here is focused on using the Mapi library
for interaction. This provides a simple textual interface to the server
based on ASCII text.

It is intended to work directly with any of the MapiClient implementations.
To avoid clashes with the default port settings, we have hardwired a number
for the time being.
@m
.MODULE sql_server;
	.USE ascii_io, monettime; 

	.ATOM mvc = ptr;
	.END;

@+ extra low level interface 
@m
	.BUILTIN mvc_new() : mvc = mvc_new;
	"create a sql contect"

	.command mvc_destroy(mvc m, int commit) = mvc_destroy_wrap;
	"commit/abort and destroy sql contect"
@+ 
@m

	.BUILTIN sqlclient( Stream s_in, Stream s_out ) = sqlclient;
	"Read sql statements from s_in and output results on s_out"

	.BUILTIN sqlconsole( ) = sqlconsole;
	"Read sql statements from stdin and output results on stdout"

	.COMMAND sqllogmanager() = sqllogmanager;
		"The log manager takes care of keeping the logs small, ie. it merges the changes into bats and abandons the logs"

@-
The session is interpreted in the context of a globally
known catalog. It is commonly represented by a variable
in the user context and should be provided to all commands.
No sanity check is performed on its validity and authorized
access after being logged in.
@m
	.BUILTIN mvc_init(int debug) = mvc_init_wrap; 
		"create the global catalog"

	.BUILTIN quit() = mvc_exit_wrap; 
		"cleanup the global catalog and quit server"

	.COMMAND mvc_sql( mvc m, str cmd ) = mvc_sql_wrap;
		"execute a sql query"

	.COMMAND mvc_update_var( mvc m, str varname ) = mvc_update_var_wrap;
		"update a session variable in the mvc structure"
@-
The updates against the relational tables are collected in separate
BATs until transaction commit. 
The code produced by the SQL->MIL compiler uses it to propagate
the updates to the persistent versions.
??What is the idx table??
@m
	.COMMAND mvc_bind( mvc c, str sname, str tname, str cname, int access ) : 
		BAT[any::1,any::2] = 
		mvc_bind_wrap; "Bind the bat, tname.cname"

	.COMMAND mvc_bind_ubat( mvc c, str sname, str tname, str cname, int access ) : 
		BAT[any::1,any::2] = 
		mvc_bind_ubat_wrap; "Bind bat with the updates to tname.cname"

	.COMMAND mvc_bind_dbat( mvc c, str sname, str tname, int access ) : 
		BAT[any::1,any::2] = mvc_bind_dbat_wrap; 
		"Bind the table deletes bat, tname.deletes"

	.COMMAND mvc_bind_idxbat( mvc c, str sname, str tname, str iname, int access ) : 
		BAT[any::1,any::2] = mvc_bind_idxbat_wrap; 
		"Bind the idx table"
@-
A special clear table function is required for an efficient DELETE ALL implementation. A table clear requires global table knowledge. 
@m
	.COMMAND mvc_clear_table( mvc c, str sname, str tname ) :
		lng = mvc_clear_table_wrap;
		"Clear table" 
@-
The results of the SQL queries are assembled in result sets, which
can be shipped to the front-end for display or exported over a
stream.
@m
	.COMMAND mvc_result_table( mvc m, int nr_cols, any order ) : int = mvc_result_row_wrap; "Create structure to cache a row query result" 

	.COMMAND mvc_result_table( mvc m, int nr_cols, BAT[oid,any] order ) : int = mvc_result_table_wrap; "Create structure to cache a table query result" 

	.COMMAND mvc_result_column( mvc m, str tname, str name, str typename, int digits, int scale, any val) = mvc_result_value_wrap; "Add the value to the row query result"
	.COMMAND mvc_result_column( mvc m, str tname, str name, str typename, int digits, int scale, BAT[oid,any] col) = mvc_result_column_wrap; "Add the colunm to the table query result"

	.COMMAND mvc_export_result(mvc m, Stream s, int result_id) =
		mvc_export_result_wrap; "export a result to stream s"

	.COMMAND mvc_export_table(mvc m, Stream s, int result_id, int offset, int nr ) =
		mvc_export_table_wrap; "export a result to stream s"

	.COMMAND mvc_import_table( mvc c, Bstream s, str tname, 
					str sep, str rsep, int nr) : 
		BAT[str,BAT] = mvc_import_table_wrap; 
		"import a table from stream s with the given tuple and record seperators (sep/rsep)"

	.COMMAND sql_mark( BAT[any::1,any] b , oid base) :
				BAT[any::1,OID] = sql_mark;
		"Produces a new BAT with fresh unique dense sequence of OIDs in the tail that starts at base (i.e. [base,base+1,..base+b.count()-1] )."

	.COMMAND hash( any::1 v, int sh ) : int = hash_wrap; "calculate a hash value and shift left"

@= mel_round
	.COMMAND round( @1 v, @1 r ) : @1 = @1_round_wrap; "round off the value v to nearests multiple of r"
@m

@:mel_round(sht)@
@:mel_round(int)@
@:mel_round(lng)@

@m
	.COMMAND round( flt v, flt r ) : flt = flt_round_wrap; "round off the value v to nearests multiple of r"

	.COMMAND round( dbl v, dbl r ) : dbl = dbl_round_wrap; "round off the value v to nearests multiple of r"

	.COMMAND cast2sht( str v ) : sht = cast2sht; "cast to sht"
	.COMMAND cast2int( str v ) : int = cast2int; "cast to int"
	.COMMAND cast2lng( str v ) : lng = cast2lng; "cast to lng"
	.COMMAND cast2flt( str v ) : flt = cast2flt; "cast to flt"
	.COMMAND cast2dbl( str v ) : dbl = cast2dbl; "cast to dbl"
	.COMMAND cast2sht( str v, int digits, int scale ) : sht = trunc2sht; 
		"cast to sht"
	.COMMAND cast2int( str v, int digits, int scale ) : int = trunc2int; 
		"cast to int"
	.COMMAND cast2lng( str v, int digits, int scale ) : lng = trunc2lng; 
		"cast to lng"
	.COMMAND cast2flt( str v, int digits, int scale ) : flt = ftrunc2flt; 
		"cast to flt"
	.COMMAND cast2dbl( str v, int digits, int scale ) : dbl = ftrunc2dbl; 
		"cast to dbl"

	.COMMAND "str"( any v, int digits ) : str = str_cast;
		"cast to string and check for overflow"
	.COMMAND "sht"( str v, int digits ) : sht = str2sht;
		"cast to short and check for overflow"
	.COMMAND "int"( str v, int digits ) : int = str2int;
		"cast to short and check for overflow"
	.COMMAND "lng"( str v, int digits ) : lng = str2lng;
		"cast to short and check for overflow"

	.COMMAND "sht"( sht v, int digits ) : sht = sht_2_sht;
		"cast to short and check for overflow"
	.COMMAND "sht"( int v, int digits ) : sht = int_2_sht;
		"cast to short and check for overflow"
	.COMMAND "sht"( lng v, int digits ) : sht = lng_2_sht;
		"cast to short and check for overflow"
	.COMMAND "sht"( dbl v, int digits ) : sht = dbl_2_sht;
		"cast to short and check for overflow"
	.COMMAND "int"( sht v, int digits ) : int = sht_2_int;
		"cast to int and check for overflow"
	.COMMAND "int"( int v, int digits ) : int = int_2_int;
		"cast to int and check for overflow"
	.COMMAND "int"( lng v, int digits ) : int = lng_2_int;
		"cast to int and check for overflow"
	.COMMAND "int"( dbl v, int digits ) : int = dbl_2_int;
		"cast to int and check for overflow"
	.COMMAND "lng"( sht v, int digits ) : lng = sht_2_lng;
		"cast to int and check for overflow"
	.COMMAND "lng"( int v, int digits ) : lng = int_2_lng;
		"cast to int and check for overflow"
	.COMMAND "lng"( lng v, int digits ) : lng = lng_2_lng;
		"cast to int and check for overflow"
	.COMMAND "lng"( dbl v, int digits ) : lng = dbl_2_lng;
		"cast to int and check for overflow"
.END sql_server;

@-
The implementation below mostly wraps around the primitives
provided in the SQL server code base. The wrapper handles
conversion from the MIL interpretation context to direct
handles and returns proper error messages upon failure.
@h
#ifndef _SQL_SERVER_H_
#define _SQL_SERVER_H_

#include <sql_mem.h>

#ifdef _MSC_VER
#ifndef LIBSQL_SERVER
#define sql_server_export extern __declspec(dllimport)
#else
#define sql_server_export extern __declspec(dllexport)
#endif
#else
#define sql_server_export extern
#endif

#include <streams.h>
#include <ascii_io.h>
#include <monettime.h>
#include <monet_context.h>
#include "sql_mvc.h"
#include "sql_server.proto.h"

#endif /*_SQL_SERVER_H_*/

@c
#include "sql_server.h"
#include "sql_result.h"
#include "sql_privileges.h"
#include "sql_session.h"
#include <sql_decimal.h>
#include <sql_string.h>
#include <sql_env.h>
#include <algebra.h>
#include <bat/bat_store.h>
#include <bat/res_table.h>
#include <bat/bat_bm.h>

@-
The code heavily depends on the (complex) data structures for
both program representation (YYSTREE), runtime stack (Cntxt),
and the MIL interpreter. Details can be found in the src/monet
directory.
@c
static int
builtin_operand(Cntxt stk, YYSTREE lt, int arg_nr, ptr *Res, int type, ValPtr res)
{
	int k = interpret(stk, arg(lt, arg_nr), res);

	if (k < 0)
		return k;
	*Res = VALconvert(type, res);
	if ((res == ILLEGALVALUE) || (type == TYPE_bat && res)) {
		return handle_paramerror(res, arg_nr, res->vtype, type);
	}
	return 0;
}

@-
The bootstrap method for accessing an SQL database is hardwired.
An alternative scheme is to collect these statements in an SQL boot file.

??Where and how is the catalog defined??
?? Why not make the grants part of it??
@c
int
mvc_init_wrap(Cntxt stk, YYSTREE lt, ValPtr res)
{
	int *Debug = NULL, **D = &Debug;

	if (lt->cnt != 1) {
		return handle_argerror(res, lt->cnt, 1);
	}
	builtin_operand(stk, lt, 0, (ptr *) D, TYPE_int, res);
	backend_init(&monet4_freestack, &monet4_freecode, &monet4_parse);
	if (mvc_init(*Debug, (backend_stack) stk) < 0) {
		return GDK_FAIL;
	}
	return GDK_SUCCEED;
}

int
sqllogmanager()
{
	/* try log cleanup every 5 minute */
	while (1) {
		MT_sleep_ms(300000);
		mvc_logmanager();
	}
	return GDK_SUCCEED;	/* or GDK_FAIL since it is not supposed to end/return? */
}

int
mvc_exit_wrap(Cntxt stk, YYSTREE lt, ValPtr res)
{
	Client c;

	CNTXTclient(stk, &c);
	while (c->father >= 0) {
		c = monet_clients + c->father;
	}
	/* only exit sql on a global quit */
	if (c == monet_clients) {
		mvc_exit();
	}
	return CMDquit(stk, lt, res);
}

int
mvc_sql_wrap(mvc *c, str cmd)
{
	return mvc_sql(*(mvc **) c, cmd);
}

int
mvc_update_var_wrap(mvc *c, str varname)
{
	return sql_update_var(*(mvc **) c, varname);
}

static BAT *
mvc_bind(mvc *m, char *sname, char *tname, char *cname, int access)
{
	sql_trans *tr = m->trans;
	BAT *b = NULL;
	sql_schema *s = mvc_bind_schema(m, sname);
	sql_table *t = mvc_bind_table(m, s, tname);
	sql_column *c = mvc_bind_column(m, t, cname);

	b = bind_bat(tr, c, access);
	return b;
}


static BAT *
mvc_bind_ubat(mvc *m, char *sname, char *tname, char *cname, int access)
{
	sql_trans *tr = m->trans;
	BAT *b = NULL;
	sql_schema *s = mvc_bind_schema(m, sname);
	sql_table *t = mvc_bind_table(m, s, tname);
	sql_column *c = mvc_bind_column(m, t, cname);

	b = bind_ubat(tr, c, access);
	return b;
}

static BAT *
mvc_bind_dbat(mvc *m, char *sname, char *tname, int access)
{
	sql_trans *tr = m->trans;
	BAT *b = NULL;
	sql_schema *s = mvc_bind_schema(m, sname);
	sql_table *t = mvc_bind_table(m, s, tname);

	b = bind_dbat(tr, t, access);
	return b;
}

static BAT *
mvc_bind_idxbat(mvc *m, char *sname, char *tname, char *iname, int access)
{
	sql_trans *tr = m->trans;
	BAT *b = NULL;
	sql_schema *s = mvc_bind_schema(m, sname);
	sql_idx *i = mvc_bind_idx(m, s, iname);

	(void) tname;
	b = bind_idx(tr, i, access);
	return b;
}


int
mvc_bind_wrap(BAT **res, mvc *c, str sname, str tname, str cname, int *access)
{
	*res = mvc_bind(*(mvc **) c, sname, tname, cname, *access);
	if (*res) {
		return GDK_SUCCEED;
	}
	return GDK_FAIL;
}

int
mvc_bind_ubat_wrap(BAT **res, mvc *c, str sname, str tname, str cname, int *access)
{
	*res = mvc_bind_ubat(*(mvc **) c, sname, tname, cname, *access);
	if (*res) {
		return GDK_SUCCEED;
	}
	return GDK_FAIL;
}

int
mvc_bind_dbat_wrap(BAT **res, mvc *c, str sname, str tname, int *access)
{
	*res = mvc_bind_dbat(*(mvc **) c, sname, tname, *access);
	if (*res) {
		return GDK_SUCCEED;
	}
	return GDK_FAIL;
}

int
mvc_bind_idxbat_wrap(BAT **res, mvc *c, str sname, str tname, str iname, int *access)
{
	*res = mvc_bind_idxbat(*(mvc **) c, sname, tname, iname, *access);
	if (*res) {
		return GDK_SUCCEED;
	}
	return GDK_FAIL;
}

int
mvc_clear_table_wrap(lng *res, mvc *c, str sname, str tname)
{
	mvc *m = *(mvc **) c;
	sql_schema *s = mvc_bind_schema(m, sname);
	sql_table *t = mvc_bind_table(m, s, tname);

	*res = mvc_clear_table(m, t);
	return GDK_SUCCEED;
}

static int
mvc_result_row(mvc *m, int nr_cols)
{
	m->results = res_table_create(m->trans, m->result_id++, nr_cols, m->type, m->results);
	return m->results->id;
}


int
mvc_result_table_wrap(int *res_id, mvc *M, int *nr_cols, BAT *order)
{
	*res_id = mvc_result_table(*(mvc **) M, *nr_cols, order);
	if (*res_id < 0)
		return GDK_FAIL;
	return GDK_SUCCEED;
}

int
mvc_result_row_wrap(int *res_id, mvc *M, int *nr_cols, ptr p, int p_type)
{
	(void) p;
	(void) p_type;		/* Stefan: unused!? */

	*res_id = mvc_result_row(*(mvc **) M, *nr_cols);
	if (*res_id < 0)
		return GDK_FAIL;
	return GDK_SUCCEED;
}

int
mvc_result_column_wrap(mvc *M, str tn, str name, str type, int *digits, int *scale, BAT *b)
{
	if (mvc_result_column(*(mvc **) M, tn, name, type, *digits, *scale, b))
		return GDK_FAIL;
	return GDK_SUCCEED;
}

int
mvc_result_value_wrap(mvc *M, str tn, str name, str type, int *digits, int *scale, ptr p, int mtype)
{
	if (mvc_result_value(*(mvc **) M, tn, name, type, *digits, *scale, p, mtype))
		return GDK_FAIL;
	return GDK_SUCCEED;
}

int
mvc_export_result_wrap(mvc *M, Stream *S, int *res_id)
{
	if (mvc_export_result(*(mvc **) M, *(stream **) S, *res_id))
		return GDK_FAIL;

	return GDK_SUCCEED;
}

int
mvc_export_table_wrap(mvc *M, Stream *S, int *res_id, int *offset, int *nr)
{
	if (mvc_export_table(*(mvc **) M, *(stream **) S, *res_id, *offset, *nr))
		return GDK_FAIL;

	return GDK_SUCCEED;
}

int
mvc_import_table_wrap(BAT **res, mvc *c, Bstream *s, str tname, str sep, str rsep, int *sz)
{
	*res = mvc_import_table(*(mvc **) c, *(bstream **) s, tname, sep, rsep, *sz);
	if (*res == NULL)
		return GDK_FAIL;
	return GDK_SUCCEED;
}

int
sql_mark(BAT **res, BAT *b, oid *base)
{
	BAT *bn = VIEWhead(b);
	BATseqbase(BATmirror(bn), *base);
	return (*res = bn) ? GDK_SUCCEED : GDK_FAIL;
}

int
hash_wrap(int *res, ptr v, int tpe, int *sh)
{
	*res = (ATOMhash(tpe, v) << (*sh)) & 0xEFFFFFFF;
	return GDK_SUCCEED;
}

@-
The core modules of Monet provide just a limited set of
mathematical operators. The extensions required to support
SQL-99 are shown below. At some point they also should be
moved to module code base.
@= round
int @1_round_wrap( @1 *res, @1 *v, @1 *r )
{
	@1 val = *v;
	@1 add = *r;

	add >>=1;
	if (val < 0) 
		add = -add;
	val += add; 
	val /= *r;
	*res = val;
	return GDK_SUCCEED;
}

int trunc2@1( @1 *res, str val, int *d, int *sc )
{
	char *s = strip_extra_zeros(val);
	char *dot = strchr(s, '.');
	int digits = strlen(s) - 1;
	int scale = digits - (dot-s);
	lng value = 0;

	if (!dot) {
		GDKerror("\"%s\" is no decimal value (doesn't contain a '.')", val);
		return GDK_FAIL;
	}
		
	value = decimal_from_str(s);
	if (*s == '+' || *s == '-')
		digits --;
	if (scale < *sc) {
		/* the current scale is too small, increase it by adding 0's */
		int d = *sc - scale;	/* CANNOT be 0! */
		value *= d * 10;
		scale += d;
		digits += d;
	} else if (scale > *sc) {
		/* the current scale is too big, decrease it by correctly rounding */
		int d = scale - *sc;	/* CANNOT be 0 */
		value /= (d - 1) * 10;
		if (value % 10 >= 5) value += 10;
		value /= 10;
		scale -= d;
		digits -= d;
	}
	if (digits > *d) {
		GDKerror("decimal (%s) doesn't have format (%d,%d)", val, *d, *sc);
		return GDK_FAIL;
	}
	*res = (@1) value;
	return GDK_SUCCEED;
}
@c

@:round(sht)@
@:round(int)@
@:round(lng)@

@= fround
int @1_round_wrap( @1 *res, @1 *v, @1 *r )
{
	@1 val = *v;
/* assume float does correct rounding 
	@1 add = *r;

	add /= 2;
	if (val < 0) 
		add = -add;
	val += add;
*/
	val /= *r;
	*res = val;
	return GDK_SUCCEED;
}

int ftrunc2@1( @1 *res, str val, int *d, int *s )
{
	ptr p = NULL;
	int len = 0;
	int e;
	int digits = *d - *s;
	dbl value = 1;
	
	e = ATOMfromstr(TYPE_@1, &p, &len, val);
	if (e < 0 || !p || 
	   (ATOMcmp(TYPE_@1, p, ATOMnilptr(TYPE_@1)) == 0 &&
	    ATOMcmp(TYPE_str, val, ATOMnilptr(TYPE_str)) != 0) ) {
		if (p)
			GDKfree(p);
		return GDK_FAIL;
	}
	while (digits > 0) {
		digits--;
		value *= 10;
	}
	if (*(@1*)p > value) {
		GDKerror("double (%s) doesn't have format (%d,%d)", val, *d, *s);
		return GDK_FAIL;
	}
	*res = *(@1*)p;
	if (p)
		GDKfree(p);
	return GDK_SUCCEED;
}
@c

@:fround(flt)@
@:fround(dbl)@

@= cast
int
cast2@1( @1 *res, str val )
{
	ptr p = NULL;
	int len = 0;
	int e; 
	
	e = ATOMfromstr(TYPE_@1, &p, &len, val);
	if (e < 0 || !p || 
	   (ATOMcmp(TYPE_@1, p, ATOMnilptr(TYPE_@1)) == 0 &&
	    ATOMcmp(TYPE_str, val, ATOMnilptr(TYPE_str)) != 0) ) {
		if (p)
			GDKfree(p);
		return GDK_FAIL;
	}
	*res = *(@1*)p;
	if (p)
		GDKfree(p);
	return GDK_SUCCEED;
}

@c

@:cast(sht)@
@:cast(int)@
@:cast(lng)@
@:cast(flt)@
@:cast(dbl)@

int
str_cast(str *res, ptr v, int tpe, int *len)
{
	int sz = *len + 1;
	char *r = GDKmalloc(sz);

	if (tpe != TYPE_str) {
		sz = BATatoms[tpe].atomToStr(&r, &sz, v);
	} else {
		sz = strlen(v);
		if (sz <= *len) {
			strncpy(r, v, sz);
			r[sz] = 0;
		}
	}
	if (sz > *len) {
		GDKfree(r);
		if (ATOMcmp(TYPE_str, ATOMnilptr(TYPE_str), v) != 0) {
			GDKerror("str_cast: value too long for type (var)char(%d)\n", *len);
			return GDK_FAIL;
		} else {
			*res = GDKstrdup(str_nil);
			return GDK_SUCCEED;
		}
	}
	*res = r;
	return GDK_SUCCEED;
}

@= str_cast
int
str2@1( @1 *res, str v, int *len )
{
	int slen = strlen(v); 

	if (slen > *len || slen > 5) {
		if (ATOMcmp(TYPE_str, ATOMnilptr(TYPE_str), v) != 0) {
			GDKerror("str2@1: value too long for type int(%d)\n",*len);
			return GDK_FAIL;
		} else {
			*res = @1_nil;
			return GDK_SUCCEED;
		}
	}
	if (ATOMfromstr(TYPE_@1, (ptr)res, &slen, v) <=0 || *res == @1_nil) {
		GDKerror("str2@1: incorrect int(%d) value\n", *len);
		return GDK_FAIL;
	}
	return GDK_SUCCEED;
}

@c
@:str_cast(sht)@
@:str_cast(int)@
@:str_cast(lng)@

@= numcastup
int @2_2_@1( @1 *res, @2 *v, int *len )
{
	int p = *len, inlen = 1;
	@2 cpyval = *v;

	/* shortcut nil */
	if (*v == @2_nil) {
		*res = @1_nil;
		return(GDK_SUCCEED);
	}
	
	/* count the number of digits in the input */
	while (cpyval /= 10)
		inlen++;
	if (p && inlen > p) {
		GDKerror("@2_2_@1: too many digits (%d > %d)\n", inlen, p);
		return(GDK_FAIL);
	}

	/* since the @1 type is bigger than or equal to the @2 type, it will
	   always fit */
	*res = (@1)*v;
	return GDK_SUCCEED;
}
@c
@:numcastup(sht,sht)@
@:numcastup(int,sht)@
@:numcastup(int,int)@
@:numcastup(lng,sht)@
@:numcastup(lng,int)@
@:numcastup(lng,lng)@

@= numcastdown
int @2_2_@1( @1 *res, @2 *v, int *len )
{
	int p = *len, inlen = 1;
	lng val = *v, cpyval = val;

	/* shortcut nil */
	if (*v == @2_nil) {
		*res = @1_nil;
		return(GDK_SUCCEED);
	}
	
	/* count the number of digits in the input */
	while (cpyval /= 10)
		inlen++;
	if (p && inlen > p) {
		GDKerror("@2_2_@1: too many digits (%d > %d)\n", inlen, p);
		return(GDK_FAIL);
	}

	/* see if the number fits in the data type */
	if (val >= GDK_@1_min && val <= GDK_@1_max)	{
		*res = (@1)*v;
		return GDK_SUCCEED;
	} else {
		GDKerror("@2_2_@1: value (%d) exceeds limits of type @1\n",val);
		return GDK_FAIL;
	}
}
@c
@:numcastdown(sht,int)@
@:numcastdown(sht,lng)@
@:numcastdown(sht,dbl)@
@:numcastdown(int,lng)@
@:numcastdown(int,dbl)@
@:numcastdown(lng,dbl)@

@-
An SQL session needs a minimal set of modules, shown below.
The MIL procs should also be moved to the kernel, despite the
fact that they are rather SQL specific.
@mil
module(alarm);
module(xtables);
module(aggrX3);
module(monettime);
module(blob);
module(txtsim);
module(mmath);
module(mkey);
module(bat_arith);
module(pcre); # likeselect_pcre
module(pqueue); # pqueue_topn
module(mapi); # mapi_listen 

# low memory usage for testing unloading
#mem_maxsize(0LL);
#vm_maxsize(0LL);

proc SQLclient( Stream s_in, Stream s_out ) : void {
	fork(sqlclient(s_in, s_out));
}

proc sql_diff (bat[any::1,any::2] b1, bat[any::1,any::3] b2) : bat[any::1,any::2] {
	if (count(b2) > 0)
		return kdiff(b1,b2);
	return b1;
}

proc sql_server_start() : void {
	var err := CATCH( mvc_init(int(monet_environment.find("sql_debug"))) );

	tzone_local(TIMEZONE("GMT"));

	if (isnil(err)){
		fork(sqllogmanager());

		mapi_listen(int(monet_environment.find("sql_port")), 5, "SQLclient").fork();
		# start a default mapi client for debugging, this should go once
		# MonetDB SQL gets stable.
		mapi_listen(int(monet_environment.find("mapi_port")), 5, "").fork();
	} else {
		printf(err);
		drop(sql_server);
	}
}

if (mod() = "main") {
	sql_server_start();
}
