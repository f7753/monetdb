@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2004 CWI.
@' All Rights Reserved.

@f sql_server
@a N.J. Nes, M.L. Kersten
@* 
The sql_server module contains the complete wrapper interface for the
SQL client and the corresponding MIL runtime startup.

The implementation described here is focused on using the Mapi library
for interaction. This provides a simple textual interface to the server
based on ascii text.

It is intended to work directly with any of the MapiClient implementations.
To avoid clashes with the default port settings, we have hardwired a number
for the time being.
@m
.MODULE sql_server;
	.USE ascii_io, monettime; 

	.ATOM mvc = ptr;
	.END;

	.BUILTIN sqlclient( Stream s_in, Stream s_out ) = sqlclient;
	"Read sql statements from s_in and output results on s_out"

	.BUILTIN sqlconsole( ) = sqlconsole;
	"Read sql statements from stdin and output results on stdout"

	.COMMAND sqllogmanager() = sqllogmanager;
		"The log manager takes care of keeping the logs small, ie. it merges the changes into bats and abandons the logs"

@-
The session is interpreted in the context of a globally
known catalog. It is commonly represented by a variable
in the user context and should be provided to all commands.
No sanity check is performed on its validity and authorized
access after being logged in.
@m
	.BUILTIN mvc_init(int debug) = mvc_init_wrap; 
		"create the global catalog"

	.BUILTIN quit() = mvc_exit_wrap; 
		"cleanup the global catalog and quit server"

	.COMMAND mvc_sql( mvc m, str cmd ) = mvc_sql_wrap;
		"execute a sql query"

	.COMMAND mvc_update_var( mvc m, str varname ) = mvc_update_var_wrap;
		"update a session variable in the mvc structure"

	.COMMAND mvc_login( mvc m, str user, str passwd ) : str 
		= mvc_login_wrap; "database login"

@-
The updates against the relational tables are collected in separate
BATs until transaction commit. 
The code produced by the SQL->MIL compiler uses it to propagate
the updates to the persistent versions.
??What is the idx table??
@m
	.COMMAND mvc_bind( mvc c, str sname, str tname, str cname, int access ) : 
		BAT[any::1,any::2] = 
		mvc_bind_wrap; "Bind the bat, tname.cname"

	.COMMAND mvc_bind_ubat( mvc c, str sname, str tname, str cname, int access ) : 
		BAT[any::1,any::2] = 
		mvc_bind_ubat_wrap; "Bind bat with the updates to tname.cname"

	.COMMAND mvc_bind_dbat( mvc c, str sname, str tname, int access ) : 
		BAT[any::1,any::2] = mvc_bind_dbat_wrap; 
		"Bind the table deletes bat, tname.deletes"

	.COMMAND mvc_bind_ibat( mvc c, str sname, str tname, str iname, int access ) : 
		BAT[any::1,any::2] = mvc_bind_ibat_wrap; 
		"Bind the idx table"
@-
The results of the SQL queries are assembled in result sets, which
can be shipped to the front-end for display or exported over a
stream.
@m
	.COMMAND mvc_result_table( mvc m, int nr_cols, any order ) : int = mvc_result_row_wrap; "Create structure to cache a row query result" 

	.COMMAND mvc_result_table( mvc m, int nr_cols, BAT[oid,any] order ) : int = mvc_result_table_wrap; "Create structure to cache a table query result" 

	.COMMAND mvc_result_column( mvc m, str tname, str name, str typename, int digits, int scale, any val) = mvc_result_value_wrap; "Add the value to the row query result"
	.COMMAND mvc_result_column( mvc m, str tname, str name, str typename, int digits, int scale, BAT[oid,any] col) = mvc_result_column_wrap; "Add the colunm to the table query result"

	.COMMAND mvc_export_result(mvc m, Stream s, int result_id) =
		mvc_export_result_wrap; "export a result to stream s"

	.COMMAND mvc_export_table(mvc m, Stream s, int result_id, int offset, int nr ) =
		mvc_export_table_wrap; "export a result to stream s"

	.COMMAND mvc_import_table( mvc c, Bstream s, str tname, 
					str sep, str rsep, int nr) : 
		BAT[str,BAT] = mvc_import_table_wrap; 
		"import a table from stream s with the given tuple and record seperators (sep/rsep)"

	.COMMAND hash( any::1 v, int sh ) : int = hash_wrap; "calculate a hash value and shift left"

	.COMMAND round( sht v, sht r ) : sht = sht_round_wrap; "round off the value v to nearests multiple of r"

	.COMMAND round( int v, int r ) : int = int_round_wrap; "round off the value v to nearests multiple of r"

	.COMMAND round( lng v, lng r ) : lng = lng_round_wrap; "round off the value v to nearests multiple of r"

	.COMMAND round( flt v, flt r ) : flt = flt_round_wrap; "round off the value v to nearests multiple of r"

	.COMMAND round( dbl v, dbl r ) : dbl = dbl_round_wrap; "round off the value v to nearests multiple of r"

	.COMMAND cast2sht( str v ) : sht = cast2sht; "cast to sht"
	.COMMAND cast2int( str v ) : int = cast2int; "cast to int"
	.COMMAND cast2lng( str v ) : lng = cast2lng; "cast to lng"
	.COMMAND cast2flt( str v ) : flt = cast2flt; "cast to flt"
	.COMMAND cast2dbl( str v ) : dbl = cast2dbl; "cast to dbl"
	.COMMAND cast2sht( str v, int digits, int scale ) : sht = trunc2sht; 
		"cast to sht"
	.COMMAND cast2int( str v, int digits, int scale ) : int = trunc2int; 
		"cast to int"
	.COMMAND cast2lng( str v, int digits, int scale ) : lng = trunc2lng; 
		"cast to lng"
	.COMMAND cast2flt( str v, int digits, int scale ) : flt = trunc2flt; 
		"cast to flt"
	.COMMAND cast2dbl( str v, int digits, int scale ) : dbl = trunc2dbl; 
		"cast to dbl"

	.COMMAND "str"( any v, int digits ) : str = str_cast;
		"cast to string and check for overflow"
	.COMMAND "sht"( str v, int digits ) : sht = str2sht;
		"cast to short and check for overflow"
	.COMMAND "int"( str v, int digits ) : int = str2int;
		"cast to short and check for overflow"
	.COMMAND "lng"( str v, int digits ) : lng = str2lng;
		"cast to short and check for overflow"
	.COMMAND "sht"( sht v, int digits ) : sht = sht_2_sht;
		"cast to short and check for overflow"
	.COMMAND "sht"( int v, int digits ) : sht = int_2_sht;
		"cast to short and check for overflow"
	.COMMAND "sht"( lng v, int digits ) : sht = lng_2_sht;
		"cast to short and check for overflow"
	.COMMAND "int"( sht v, int digits ) : int = sht_2_int;
		"cast to int and check for overflow"
	.COMMAND "int"( int v, int digits ) : int = int_2_int;
		"cast to int and check for overflow"
	.COMMAND "int"( lng v, int digits ) : int = lng_2_int;
		"cast to int and check for overflow"
	.COMMAND "lng"( sht v, int digits ) : lng = sht_2_lng;
		"cast to int and check for overflow"
	.COMMAND "lng"( int v, int digits ) : lng = int_2_lng;
		"cast to int and check for overflow"
	.COMMAND "lng"( lng v, int digits ) : lng = lng_2_lng;
		"cast to int and check for overflow"
.END sql_server;

@-
The implementation below mostly wraps around the primitives
provided in the SQL server code base. The wrapper handles
conversion from the MIL interpretation context to direct
handles and returns proper error messages upon failure.
@h
#ifndef _SQL_SERVER_H_
#define _SQL_SERVER_H_

#include <sql_mem.h>

#ifdef _MSC_VER
#ifndef LIBSQL_SERVER
#define sql_server_export extern __declspec(dllimport)
#else
#define sql_server_export extern __declspec(dllexport)
#endif
#else
#define sql_server_export extern
#endif

#include <streams.h>
#include <ascii_io.h>
#include <monettime.h>
#include <monet_context.h>
#include "sql_mvc.h"
#include "sql_server.proto.h"

#endif /*_SQL_SERVER_H_*/

@c
#include "sql_server.h"
#include "sql_privileges.h"
#include "sql_session.h"
#include <sql_decimal.h>
#include <sql_string.h>
#include <sql_env.h>
#include <algebra.h>

@-
The code heavily depends on the (complex) data structures for
both program representation (YYSTREE), runtime stack (Cntxt),
and the MIL interpreter. Details can be found in the src/monet
directory.
@c
static int builtin_operand( Cntxt stk, YYSTREE lt, int arg_nr, ptr *Res, int type, ValPtr res)
{ 
	int k = interpret( stk, arg(lt, arg_nr), res);
	if (k < 0) return k;
        *Res = VALconvert(type, res);
        if ((res == ILLEGALVALUE)  || (type == TYPE_bat && res)) {
                return handle_paramerror(res,arg_nr, res->vtype, type);
        }
	return 0;
}
@-
The bootstrap method for accessing an SQL database is hardwired.
An alternative scheme is to collect these statements in an SQL boot file.

??Where and how is the catalog defined??
?? Why not make the grants part of it??
@c
int mvc_init_wrap(Cntxt stk, YYSTREE lt, ValPtr res)
{ 
	int ret, *Debug = NULL;
  	if (lt->cnt != 1) {
        	return handle_argerror(res, lt->cnt, 1);
  	}
	builtin_operand( stk, lt, 0, (ptr*)&Debug, TYPE_int, res);
	backend_init( &monet4_freestack, &monet4_freecode, &monet4_parse );
	if ( (ret = mvc_init(*Debug, (backend_stack)stk )) > 0 ){
		#define S(q) sqlstatement(q,stk)
		S("GRANT ALL on modules to PUBLIC with grant option;" );
		S("GRANT ALL on schemas to PUBLIC with grant option;" );
		S("GRANT ALL on tables to PUBLIC with grant option;" );
		S("GRANT ALL on columns to PUBLIC with grant option;" );
		S("GRANT ALL on keys to PUBLIC with grant option;" );
		S("GRANT ALL on idxs to PUBLIC with grant option;" );
		S("GRANT ALL on keycolumns to PUBLIC with grant option;" );
		S("GRANT ALL on types to PUBLIC with grant option;" );
		S("GRANT ALL on user_role to PUBLIC with grant option;" );
		S("GRANT ALL on auths to PUBLIC with grant option;" );
		S("GRANT ALL on privileges to PUBLIC with grant option;" );
		S("GRANT ALL on users to PUBLIC with grant option;" );
		S("GRANT ALL on sessions to PUBLIC with grant option;" );
		S("GRANT ALL on history to PUBLIC with grant option;" );
		S("GRANT ALL on env to PUBLIC with grant option;" );
	} else if (ret < 0) {
		return GDK_FAIL;
	}
	return GDK_SUCCEED;
}

int sqllogmanager() {
	/* try log cleanup every minute */
	while(1) {
		MT_sleep_ms(60000); 
		mvc_logmanager();
	}
	return GDK_SUCCEED;	/* or GDK_FAIL since it is not supposed to end/return? */
}

int mvc_exit_wrap(Cntxt stk, YYSTREE lt, ValPtr res){ 
	Client c;

        CNTXTclient(stk, &c);
	while (c->father >= 0) {
		c = monet_clients + c->father;
	}
	/* only exit sql on a global quit */
	if (c == monet_clients) {
		mvc_exit();
	}
	return CMDquit(stk, lt, res);
}

int mvc_sql_wrap( mvc *c, str cmd ){
	return mvc_sql( *(mvc**)c, cmd );
}

int mvc_update_var_wrap( mvc *c, str varname ){
	return sql_update_var( *(mvc**)c, varname );
}


int mvc_login_wrap( str *r, mvc *c, str user, str passwd  ){
	*r = mvc_login( *(mvc**)c, user, passwd );
	if (*r == NULL)
		*r = _strdup("");
	return GDK_SUCCEED;
}

int mvc_bind_wrap( BAT** res, mvc* c, str sname, str tname, str cname, int *access){
	*res = mvc_bind( *(mvc**)c, sname, tname, cname, *access );
	if (*res){
		return GDK_SUCCEED;
	}
	return GDK_FAIL;
}

int mvc_bind_ubat_wrap( BAT** res, mvc* c, str sname, str tname, str cname, int *access ){
	*res = mvc_bind_ubat( *(mvc**)c, sname, tname, cname, *access );
	if (*res){
		return GDK_SUCCEED;
	}
	return GDK_FAIL;
}

int mvc_bind_dbat_wrap( BAT** res, mvc* c, str sname, str tname, int *access ){
	*res = mvc_bind_dbat( *(mvc**)c, sname, tname, *access );
	if (*res){
		return GDK_SUCCEED;
	}
	return GDK_FAIL;
}

int mvc_bind_ibat_wrap( BAT** res, mvc* c, str sname, str tname, str iname, int *access ){
	*res = mvc_bind_ibat( *(mvc**)c, sname, tname, iname, *access );
	if (*res){
		return GDK_SUCCEED;
	}
	return GDK_FAIL;
}

int mvc_result_table_wrap( int *res_id, mvc *M, int *nr_cols, BAT *order ){
	*res_id = mvc_result_table( *(mvc**)M, *nr_cols, order);
	if (*res_id < 0)
		return GDK_FAIL;
	return GDK_SUCCEED;
}
int mvc_result_row_wrap( int *res_id, mvc *M, int *nr_cols, ptr p, int p_type ){
	(void) p; (void) p_type; /* Stefan: unused!? */

	*res_id = mvc_result_row( *(mvc**)M, *nr_cols );
	if (*res_id < 0)
		return GDK_FAIL;
	return GDK_SUCCEED;
}
int mvc_result_column_wrap( mvc *M, str tn, str name, str type, int *digits, int *scale, BAT *b ){
	if (mvc_result_column( *(mvc**)M, tn, name, type, *digits, *scale, b)) 
		return GDK_FAIL;
	return GDK_SUCCEED;
}
int mvc_result_value_wrap( mvc *M, str tn, str name, str type, int *digits, int *scale, ptr p, int mtype ){
	if (mvc_result_value( *(mvc**)M, tn, name, type, *digits, *scale, p, mtype)) 
		return GDK_FAIL;
	return GDK_SUCCEED;
}
int mvc_export_result_wrap( mvc *M, Stream *S, int *res_id){
	if (mvc_export_result( *(mvc**)M, *(stream**)S, *res_id)) 
		return GDK_FAIL;
	
	return GDK_SUCCEED;
}
int mvc_export_table_wrap( mvc *M, Stream *S, int *res_id, int *offset, int *nr){
	if (mvc_export_table( *(mvc**)M, *(stream**)S, *res_id, *offset, *nr)) 
		return GDK_FAIL;
	
	return GDK_SUCCEED;
}
int mvc_import_table_wrap( BAT **res, mvc *c, Bstream *s, str tname , str sep, str rsep, int *sz ){
	*res = mvc_import_table( *(mvc**)c, *(bstream**)s, tname, sep, rsep, *sz );
	if (*res == NULL)
		return GDK_FAIL;
	return GDK_SUCCEED;
}

int hash_wrap( int *res, ptr v, int tpe, int *sh )
{
	*res = (ATOMhash(tpe,v)<<(*sh))&0xEFFFFFFF;
	return GDK_SUCCEED;
}
@-
The core modules of Monet provide just a limited set of
mathematical operators. The extensions required to support
SQL-99 are shown below. At some point they also should be
moved to module code base.
@= round
int @1_round_wrap( @1 *res, @1 *v, @1 *r )
{
	@1 val = *v;
	@1 add = *r;

	add >>=1;
	if (val < 0) 
		add = -add;
	val += add; 
	val /= *r;
	*res = val;
	return GDK_SUCCEED;
}

int trunc2@1( @1 *res, str val, int *d, int *sc )
{
	char *s = strip_extra_zeros(val);
	char *dot = strchr(s, '.');
	int digits = strlen(s) - 1;
	int scale = digits - (dot-s);
	lng value = 0;

	if (!dot) {
		GDKerror("decimal (%s) doesn't have format (%d,%d)", val, *d, *sc);
		return GDK_FAIL;
	}
		
	value = decimal_from_str(s);
	if (*s == '+' || *s == '-')
		digits --;
	if (scale < *sc){
		while(scale < *sc) {
			value *= 10;
			scale ++;
			digits ++;
		}
	} else if (scale > *sc){
		while(scale > *sc) {
			value /= 10;
			scale --;
			digits --;
		}
	}
	if (digits > *d) {
		GDKerror("decimal (%s) doesn't have format (%d,%d)", val, *d, *sc);
		return GDK_FAIL;
	}
	*res = (@1) value;
	return GDK_SUCCEED;
}
@c

@:round(sht)@
@:round(int)@
@:round(lng)@

@= fround
int @1_round_wrap( @1 *res, @1 *v, @1 *r )
{
	@1 val = *v;
/* assume float does correct rounding 
	@1 add = *r;

	add /= 2;
	if (val < 0) 
		add = -add;
	val += add;
*/
	val /= *r;
	*res = val;
	return GDK_SUCCEED;
}

int trunc2@1( @1 *res, str val, int *d, int *s )
{
	ptr p = NULL;
	int len = 0;
	int e;
	int digits = *d - *s;
	lng value = 1;
	
 	e = ATOMfromstr(TYPE_@1, &p, &len, val);
	if (e < 0 || !p || 
	   (ATOMcmp(TYPE_@1, p, ATOMnilptr(TYPE_@1)) == 0 &&
	    ATOMcmp(TYPE_str, val, ATOMnilptr(TYPE_str)) != 0) ) {
		if (p)
			GDKfree(p);
		return GDK_FAIL;
	}
	while(digits > 0) {
		digits--;
		value *= 10;
	}
	if (*(@1*)p > value) {
		GDKerror("double (%s) doesn't have format (%d,%d)", val, *d, *s);
		return GDK_FAIL;
		
	}
	*res = *(@1*)p;
	if (p)
		GDKfree(p);
	return GDK_SUCCEED;
}
@c

@:fround(flt)@
@:fround(dbl)@

@= cast
int cast2@1( @1 *res, str val )
{
	ptr p = NULL;
	int len = 0;
	int e; 
	
	e = ATOMfromstr(TYPE_@1, &p, &len, val);
	if (e < 0 || !p || 
	   (ATOMcmp(TYPE_@1, p, ATOMnilptr(TYPE_@1)) == 0 &&
	    ATOMcmp(TYPE_str, val, ATOMnilptr(TYPE_str)) != 0) ) {
		if (p)
			GDKfree(p);
		return GDK_FAIL;
	}
	*res = *(@1*)p;
	if (p)
		GDKfree(p);
	return GDK_SUCCEED;
}

@c

@:cast(sht)@
@:cast(int)@
@:cast(lng)@
@:cast(flt)@
@:cast(dbl)@

int str_cast( str *res, ptr v, int tpe, int *len ){
	int sz = *len + 1;
	char *r = GDKmalloc(sz);

	if (tpe != TYPE_str) {
		sz = BATatoms[tpe].atomToStr(&r, &sz, v); 
	} else {
		sz = strlen(v);
		if (sz <= *len) {
			strncpy(r, v, sz);
			r[sz] = 0;
		}
	}
	if (sz > *len){
		GDKfree(r);
		if (ATOMcmp(TYPE_str, ATOMnilptr(TYPE_str), v) != 0) {
			GDKerror("str_cast: value to long for type (var)char(%d)\n",*len);
			return GDK_FAIL;
		} else {
			*res = GDKstrdup(str_nil);
			return GDK_SUCCEED;
		}
	}
	*res = r;
	return GDK_SUCCEED;
}

@= str_cast
int str2@1( @1 *res, str v, int *len ){
	int slen = strlen(v); 

	if (slen > *len || slen > 5) {
		if (ATOMcmp(TYPE_str, ATOMnilptr(TYPE_str), v) != 0) {
			GDKerror("str2@1: value to long for type int(%d)\n",*len);
			return GDK_FAIL;
		} else {
			*res = @1_nil;
			return GDK_SUCCEED;
		}
	}
	if (ATOMfromstr(TYPE_@1, (ptr)res, &slen, v) <=0 || *res == @1_nil) {
		GDKerror("str2@1: incorrect int(%d) value\n", *len);
		return GDK_FAIL;
	}
	return GDK_SUCCEED;
}

@c
@:str_cast(sht)@
@:str_cast(int)@
@:str_cast(lng)@

static lng max_values[20] =
{
	LL_CONSTANT(0),
	LL_CONSTANT(1),
	LL_CONSTANT(10),
	LL_CONSTANT(100),
	LL_CONSTANT(1000),
	LL_CONSTANT(10000),
	LL_CONSTANT(100000),
	LL_CONSTANT(1000000),
	LL_CONSTANT(10000000),
	LL_CONSTANT(100000000),
	LL_CONSTANT(1000000000),
	LL_CONSTANT(10000000000),
	LL_CONSTANT(100000000000),
	LL_CONSTANT(1000000000000),
	LL_CONSTANT(10000000000000),
	LL_CONSTANT(100000000000000),
	LL_CONSTANT(1000000000000000),
	LL_CONSTANT(10000000000000000),
	LL_CONSTANT(100000000000000000)
};

@= numcast
int @2_2_@1( @1 *res, @2 *v, int *len ){
	int p = *len;

	if (p > 19)
		p = 19;
	if (*v > max_values[p]){
		if (*v != @2_nil) {
			GDKerror("@2_2_@1: value to long for type int(%d)\n",p);
			return GDK_FAIL;
		} else {
			*res = @1_nil;
			return GDK_SUCCEED;
		}
	}
	*res = *v;
	return GDK_SUCCEED;
}
@c
@:numcast(sht,sht)@
@:numcast(sht,int)@
@:numcast(sht,lng)@
@:numcast(int,sht)@
@:numcast(int,int)@
@:numcast(int,lng)@
@:numcast(lng,sht)@
@:numcast(lng,int)@
@:numcast(lng,lng)@

@-
An SQL session needs a minimal set of modules, shown below.
The MIL procs should also be moved to the kernel, despite the
fact that they are rather SQL specific.
@mil
module(alarm);
module(xtables);
module(aggrX3);
module(monettime);
module(blob);
module(txtsim);
module(mmath);
module(mkey);
module(bat_arith);
module(mapi); # mapi_listen 

# low memory usage for testing unloading
#mem_maxsize(0LL);
#vm_maxsize(0LL);
var err := CATCH( mvc_init(int(monet_environment.find("sql_debug"))) );

tzone_local(TIMEZONE("GMT"));
proc SQLclient( Stream s_in, Stream s_out ) : void {
	fork(sqlclient(s_in, s_out));
}

if (isnil(err)){
	fork(sqllogmanager);

	mapi_listen(int(monet_environment.find("sql_port")), 5, "SQLclient").fork();
	# start a default mapi client for debugging, this should go once
	# MonetDB SQL gets stable.
	mapi_listen(int(monet_environment.find("mapi_port")), 5, "").fork();
} else {
	printf(err);
	drop(sql_server);
}
