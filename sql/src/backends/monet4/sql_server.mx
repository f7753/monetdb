@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@' 
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@' 
@' The Original Code is the Monet Database System.
@' 
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2004 CWI.
@' All Rights Reserved.
@' 
@' Contributor(s):
@' 		Martin Kersten <Martin.Kersten@cwi.nl>
@' 		Peter Boncz <Peter.Boncz@cwi.nl>
@' 		Niels Nes <Niels.Nes@cwi.nl>
@' 		Stefan Manegold  <Stefan.Manegold@cwi.nl>

@f sql_server
@a N.J. Nes, M.L. Kersten
@* 
The sql_server module contains the complete wrapper interface for the
SQL client and the corresponding MIL runtime startup.

The implementation described here is focused on using the Mapi library
for interaction. This provides a simple textual interface to the server
based on ascii text.

It is intended to work directly with any of the MapiClient implementations.
To avoid clashes with the default port settings, we have hardwired a number
for the time being.
@m
.MODULE sql_server;
	.USE ascii_io; 

	.ATOM mvc = ptr;
	.END;

	.BUILTIN sqlclient( Stream s_in, Stream s_out ) = sqlclient;
	"Read sql statements from s_in and output results on s_out"

	.BUILTIN sqlconsole( ) = sqlconsole;
	"Read sql statements from stdin and output results on stdout"

	.COMMAND logmanager() = logmanager;
		"The log manager takes care off keeping the logs small, ie. it merges the changs into bats and abands the logs"

	.BUILTIN mvc_init(int debug) = mvc_init_wrap; 
		"create the global catalog"

	.BUILTIN quit() = mvc_exit_wrap; 
		"cleanup the global catalog and quit server"

	.COMMAND mvc_sql( mvc m, str cmd ) = mvc_sql_wrap;
		"execute a sql query"

	.COMMAND mvc_login( mvc m, str user, str passwd ) : str 
		= mvc_login_wrap; "database login"

	.COMMAND mvc_status( mvc m ) : int 
		= mvc_status_wrap; "return the status of the last mvc operation"

	.COMMAND mvc_type( mvc m ) : int 
		= mvc_type_wrap; "return the type of the last mvc operation"

	.COMMAND mvc_bind( mvc c, str sname, str tname, str cname, int access ) : 
		BAT[any::1,any::2] = 
		mvc_bind_wrap; "Bind the bat, tname.cname"

	.COMMAND mvc_bind_ubat( mvc c, str sname, str tname, str cname, int access ) : 
		BAT[any::1,any::2] = 
		mvc_bind_ubat_wrap; "Bind bat with the updates to tname.cname"

	.COMMAND mvc_bind_dbat( mvc c, str sname, str tname, int access ) : 
		BAT[any::1,any::2] = mvc_bind_dbat_wrap; 
		"Bind the table deletes bat, tname.deletes"

	.COMMAND mvc_bind_ibat( mvc c, str sname, str tname, str iname, int access ) : 
		BAT[any::1,any::2] = mvc_bind_ibat_wrap; 
		"Bind the idx table"

	.COMMAND mvc_result_table( mvc m, int nr_cols, any order ) : int = mvc_result_row_wrap; "Create structure to cache a row query result" 

	.COMMAND mvc_result_table( mvc m, int nr_cols, BAT[oid,any] order ) : int = mvc_result_table_wrap; "Create structure to cache a table query result" 

	.COMMAND mvc_result_column( mvc m, str name, str typename, int digits, int scale, any val) = mvc_result_value_wrap; "Add the value to the row query result"
	.COMMAND mvc_result_column( mvc m, str name, str typename, int digits, int scale, BAT[oid,any] col) = mvc_result_column_wrap; "Add the colunm to the table query result"

	.COMMAND mvc_export_result(mvc m, Stream s, int result_id) =
		mvc_export_result_wrap; "export a result to stream s"

	.COMMAND mvc_export_table(mvc m, Stream s, int result_id, int offset, int nr ) =
		mvc_export_table_wrap; "export a result to stream s"

	.COMMAND mvc_import_table( mvc c, Bstream s, str tname, 
					str sep, str rsep, int nr) : 
		BAT[str,BAT] = mvc_import_table_wrap; 
		"import a table from stream s with the given tuple and record seperators (sep/rsep)"

@+ void bats
To prevent void bats to convert to oid bats we need overloaded insert and
replace commands. These operations should at a later stage be moved to the
kernel libraries, e.g. bat.mx
@m
 	.COMMAND append( BAT[oid,any::1] i, BAT[oid,any::1] u ) : BAT[oid,any::1] = oid_bat_append_oid_bat_wrap; "append the content of u to i (renumbers u-oids' to unique numbers)"

 	.COMMAND append( BAT[oid,any::1] i, any::1 u ) : BAT[oid,any::1] = oid_bat_append_val_wrap; "append the value u to i"

 	.COMMAND append( BAT[void,any::1] i, BAT[void,any::1] u ) : BAT[void,any::1] = bat_append_void_bat_wrap; "append the content of u to i"

 	.COMMAND append( BAT[void,any::1] i, BAT[oid,any::1] u ) : BAT[void,any::1] = bat_append_oid_bat_wrap; "append the content of u to i"

 	.COMMAND append( BAT[void,any::1] i, any::1 u ) : BAT[void,any::1] = bat_append_val_wrap; "append the value u to i"

 	.COMMAND append( BAT[oid,void] i, BAT[oid,void] u ) : BAT[oid,void] = bat_append_oidvoid_bat_wrap; "Special case append for empty bats, works around impossible void,void case"

	.COMMAND replace( BAT[void,any::1] o, BAT[oid,any::1] d ) : BAT[void,any::1] = bat_replace_oid_bat_wrap; "inplace replace values on the given locations"

	.COMMAND hash( any::1 v, int sh ) : int = hash_wrap; "calculate a hash value and shift left"

	.COMMAND round( sht v, sht r ) : sht = sht_round_wrap; "round off the value v to nearests multiple of r"

	.COMMAND round( int v, int r ) : int = int_round_wrap; "round off the value v to nearests multiple of r"

	.COMMAND round( lng v, lng r ) : lng = lng_round_wrap; "round off the value v to nearests multiple of r"

	.COMMAND round( flt v, flt r ) : flt = flt_round_wrap; "round off the value v to nearests multiple of r"

	.COMMAND round( dbl v, dbl r ) : dbl = dbl_round_wrap; "round off the value v to nearests multiple of r"

	.COMMAND cast2sht( str v ) : sht = cast2sht; "cast to sht"
	.COMMAND cast2int( str v ) : int = cast2int; "cast to int"
	.COMMAND cast2lng( str v ) : lng = cast2lng; "cast to lng"
	.COMMAND cast2flt( str v ) : flt = cast2flt; "cast to flt"
	.COMMAND cast2dbl( str v ) : dbl = cast2dbl; "cast to dbl"
	.COMMAND cast2sht( str v, int digits, int scale ) : sht = trunc2sht; 
		"cast to sht"
	.COMMAND cast2int( str v, int digits, int scale ) : int = trunc2int; 
		"cast to int"
	.COMMAND cast2lng( str v, int digits, int scale ) : lng = trunc2lng; 
		"cast to lng"
	.COMMAND cast2flt( str v, int digits, int scale ) : flt = trunc2flt; 
		"cast to flt"
	.COMMAND cast2dbl( str v, int digits, int scale ) : dbl = trunc2dbl; 
		"cast to dbl"

.END sql_server;

@h
#ifndef _SQL_SERVER_H_
#define _SQL_SERVER_H_

#include <sql_mem.h>

#ifdef _MSC_VER
#ifndef LIBSQL_SERVER
#define sql_server_export extern __declspec(dllimport)
#else
#define sql_server_export extern __declspec(dllexport)
#endif
#else
#define sql_server_export extern
#endif

#include <streams.h>
#include <ascii_io.h>
#include <monet_context.h>
#include "sql_mvc.h"
#include "sql_server.proto.h"

#endif /*_SQL_SERVER_H_*/

@c
#include "sql_server.h"
#include "sql_privileges.h"
#include "sql_session.h"
#include <sql_decimal.h>
#include <sql_string.h>
#include <algebra.h>

static int builtin_operand( Cntxt stk, YYSTREE lt, int arg_nr, ptr *Res, int type, ValPtr res)
{ 
	int k = interpret( stk, arg(lt, arg_nr), res);
	if (k < 0) return k;
        *Res = VALconvert(type, res);
        if ((res == ILLEGALVALUE)  || (type == TYPE_bat && res)) {
                return handle_paramerror(res,arg_nr, res->vtype, type);
        }
	return 0;
}

int mvc_init_wrap(Cntxt stk, YYSTREE lt, ValPtr res)
{ 
	int ret, *Debug = NULL;
  	if (lt->cnt != 1) {
        	return handle_argerror(res, lt->cnt, 1);
  	}
	builtin_operand( stk, lt, 0, (ptr*)&Debug, TYPE_int, res);
	backend_init( &monet4_freestack, &monet4_freecode, &monet4_parse );
	if ( (ret = mvc_init(*Debug, (backend_stack)stk )) > 0 ){
		sqlstatement("GRANT ALL on modules to monetdb with grant option with hierarchy option;", stk);
		sqlstatement("GRANT ALL on schemas to monetdb with grant option with hierarchy option;", stk);
		sqlstatement("GRANT ALL on tables to monetdb with grant option with hierarchy option;", stk);
		sqlstatement("GRANT ALL on columns to monetdb with grant option with hierarchy option;", stk);
		sqlstatement("GRANT ALL on keys to monetdb with grant option with hierarchy option;", stk);
		sqlstatement("GRANT ALL on idxs to monetdb with grant option with hierarchy option;", stk);
		sqlstatement("GRANT ALL on keycolumns to monetdb with grant option with hierarchy option;", stk);
		sqlstatement("GRANT ALL on types to monetdb with grant option with hierarchy option;", stk);
		sqlstatement("GRANT ALL on users to monetdb with grant option with hierarchy option;", stk);
		sqlstatement("GRANT ALL on user_role to monetdb with grant option with hierarchy option;", stk);
		sqlstatement("GRANT ALL on auths to monetdb with grant option with hierarchy option;", stk);
		sqlstatement("GRANT ALL on privileges to monetdb with grant option with hierarchy option;", stk);
		sqlstatement("CREATE TABLE history (start TIMESTAMP, query VARCHAR, parse MEDIUMINT, mil MEDIUMINT, exec MEDIUMINT, total MEDIUMINT, \"user\" VARCHAR);", stk);
	} else if (ret < 0) {
		return GDK_FAIL;
	}
	return GDK_SUCCEED;
}

int logmanager() {
	/* try log cleanup every minute */
	while(1) {
		MT_sleep_ms(60000); 
		mvc_logmanager();
	}
	return GDK_SUCCEED;	/* or GDK_FAIL since it is not supposed to end/return? */
}

int mvc_exit_wrap(Cntxt stk, YYSTREE lt, ValPtr res){ 
	Client c;

        CNTXTclient(stk, &c);
	while (c->father >= 0) {
		c = monet_clients + c->father;
	}
	/* only exit sql on a global quit */
	if (c == monet_clients) {
		mvc_exit();
	}
	return CMDquit(stk, lt, res);
}

int mvc_sql_wrap( mvc *c, str cmd ){
	return mvc_sql( *(mvc**)c, cmd );
}


int mvc_login_wrap( str *r, mvc *c, str user, str passwd  ){
	*r = mvc_login( *(mvc**)c, user, passwd );
	if (*r == NULL)
		*r = _strdup("");
	return GDK_SUCCEED;
}

int mvc_status_wrap( int* res, mvc* m ){
	*res = mvc_status( *(mvc**)m );
	return GDK_SUCCEED;
}

int mvc_type_wrap( int* res, mvc* m ){
	*res = mvc_type( *(mvc**)m );
	return GDK_SUCCEED;
}

int mvc_bind_wrap( BAT** res, mvc* c, str sname, str tname, str cname, int *access){
	*res = mvc_bind( *(mvc**)c, sname, tname, cname, *access );
	if (*res){
		return GDK_SUCCEED;
	}
	return GDK_FAIL;
}

int mvc_bind_ubat_wrap( BAT** res, mvc* c, str sname, str tname, str cname, int *access ){
	*res = mvc_bind_ubat( *(mvc**)c, sname, tname, cname, *access );
	if (*res){
		return GDK_SUCCEED;
	}
	return GDK_FAIL;
}

int mvc_bind_dbat_wrap( BAT** res, mvc* c, str sname, str tname, int *access ){
	*res = mvc_bind_dbat( *(mvc**)c, sname, tname, *access );
	if (*res){
		return GDK_SUCCEED;
	}
	return GDK_FAIL;
}

int mvc_bind_ibat_wrap( BAT** res, mvc* c, str sname, str tname, str iname, int *access ){
	*res = mvc_bind_ibat( *(mvc**)c, sname, tname, iname, *access );
	if (*res){
		return GDK_SUCCEED;
	}
	return GDK_FAIL;
}

int mvc_result_table_wrap( int *res_id, mvc *M, int *nr_cols, BAT *order ){
	*res_id = mvc_result_table( *(mvc**)M, *nr_cols, order);
	if (*res_id < 0)
		return GDK_FAIL;
	return GDK_SUCCEED;
}
int mvc_result_row_wrap( int *res_id, mvc *M, int *nr_cols, ptr p, int p_type ){
	(void) p; (void) p_type; /* Stefan: unused!? */

	*res_id = mvc_result_row( *(mvc**)M, *nr_cols );
	if (*res_id < 0)
		return GDK_FAIL;
	return GDK_SUCCEED;
}
int mvc_result_column_wrap( mvc *M, str name, str type, int *digits, int *scale, BAT *b ){
	if (mvc_result_column( *(mvc**)M, name, type, *digits, *scale, b)) 
		return GDK_FAIL;
	return GDK_SUCCEED;
}
int mvc_result_value_wrap( mvc *M, str name, str type, int *digits, int *scale, ptr p, int mtype ){
	if (mvc_result_value( *(mvc**)M, name, type, *digits, *scale, p, mtype)) 
		return GDK_FAIL;
	return GDK_SUCCEED;
}
int mvc_export_result_wrap( mvc *M, Stream *S, int *res_id){
	if (mvc_export_result( *(mvc**)M, *(stream**)S, *res_id)) 
		return GDK_FAIL;
	
	return GDK_SUCCEED;
}
int mvc_export_table_wrap( mvc *M, Stream *S, int *res_id, int *offset, int *nr){
	if (mvc_export_table( *(mvc**)M, *(stream**)S, *res_id, *offset, *nr)) 
		return GDK_FAIL;
	
	return GDK_SUCCEED;
}
int mvc_import_table_wrap( BAT **res, mvc *c, Bstream *s, str tname , str sep, str rsep, int *sz ){
	*res = mvc_import_table( *(mvc**)c, *(bstream**)s, tname, sep, rsep, *sz );
	if (*res == NULL)
		return GDK_FAIL;
	return GDK_SUCCEED;
}

@-
The next collection of operators fill a hole in the Monet kernel libraries.
It provide handy operations on void-BATs. The sole reason not to move it to
the bat.mx module is that overall the kernel does not support bat[void,void]
@c
int bat_append_void_bat_wrap( BAT **res, BAT *i, BAT *u )
{
	*res = i;
	void_append_bat( i, u );
	BBPfix(i->batCacheid);
	return GDK_SUCCEED;
}

int bat_append_oid_bat_wrap( BAT **res, BAT *i, BAT *u )
{
	*res = i;
	void_insert_bat( i, u );
	BBPfix(i->batCacheid);
	return GDK_SUCCEED;
}

int bat_append_oidvoid_bat_wrap( BAT **res, BAT *i, BAT *u )
{
	(void)u; /* fake usage to fool compilers in case assertions are disabled */
	*res = i;
	assert(BATcount(i)==0 && BATcount(u) == 0);
	BBPfix(i->batCacheid);
	return GDK_SUCCEED;
}

int oid_bat_append_oid_bat_wrap( BAT **res, BAT *i, BAT *u )
{
	BUN r,s;
        oid o;
	
	assert(i->htype == TYPE_oid && u->htype == TYPE_oid);
	BATmax(BATmirror(i),&o);
	o++;
	BATloop(u, r, s){
		oid h = *(oid*)BUNhead(u,r) + o;
		BUNins(i, &h,  BUNtail(u,r));
        }
	*res = i;
	BBPfix(i->batCacheid);
	return GDK_SUCCEED;
}

int oid_bat_append_val_wrap( BAT **res, BAT *i, ptr u )
{
        oid o;

	assert(i->htype == TYPE_oid);
	BATmax(BATmirror(i),&o);
	o++;
	*res = i;
	BUNins( i, (ptr) & o, u );
	BBPfix(i->batCacheid);
	return GDK_SUCCEED;
}


int bat_append_val_wrap( BAT **res, BAT *i, ptr u )
{
	oid h = i->hseqbase + BATcount(i);
	*res = i;
	BUNins( i, (ptr) & h, u );
	BBPfix(i->batCacheid);
	return GDK_SUCCEED;
}

int bat_replace_oid_bat_wrap( BAT **res, BAT *o, BAT *d )
{
	*res = o;
	void_replace_bat( o, d );
	BBPfix(o->batCacheid);
	return GDK_SUCCEED;
}

int hash_wrap( int *res, ptr v, int tpe, int *sh )
{
	*res = (ATOMhash(tpe,v)<<(*sh))&0xEFFFFFFF;
	return GDK_SUCCEED;
}

@= round
int @1_round_wrap( @1 *res, @1 *v, @1 *r )
{
	@1 val = *v;
	@1 add = *r;

	add >>=1;
	if (val < 0) 
		add = -add;
	val += add; 
	val /= *r;
	*res = val;
	return GDK_SUCCEED;
}

int trunc2@1( @1 *res, str val, int *d, int *sc )
{
	char *s = strip_extra_zeros(val);
	char *dot = strchr(s, '.');
	int digits = strlen(s) - 1;
	int scale = digits - (dot-s);
	lng value = 0;

	if (!dot) {
		GDKerror("decimal (%s) doesn't have format (%d,%d)", val, *d, *sc);
		return GDK_FAIL;
	}
		
	value = decimal_from_str(s);
	if (*s == '+' || *s == '-')
		digits --;
	if (scale < *sc){
		while(scale < *sc) {
			value *= 10;
			scale ++;
			digits ++;
		}
	} else if (scale > *sc){
		while(scale > *sc) {
			value /= 10;
			scale --;
			digits --;
		}
	}
	if (digits > *d) {
		GDKerror("decimal (%s) doesn't have format (%d,%d)", val, *d, *sc);
		return GDK_FAIL;
	}
	*res = value;
	return GDK_SUCCEED;
}
@c

@:round(sht)@
@:round(int)@
@:round(lng)@

@= fround
int @1_round_wrap( @1 *res, @1 *v, @1 *r )
{
	@1 val = *v;
/* assume float does correct rounding 
	@1 add = *r;

	add /= 2;
	if (val < 0) 
		add = -add;
	val += add;
*/
	val /= *r;
	*res = val;
	return GDK_SUCCEED;
}

int trunc2@1( @1 *res, str val, int *d, int *s )
{
	ptr p = NULL;
	int len = 0;
	int e = ATOMfromstr(TYPE_@1, &p, &len, val);
	int digits = *d - *s;
	lng value = 1;
	
	if (e <= 0 || !p || ATOMcmp(TYPE_@1, p, ATOMnilptr(TYPE_@1)) == 0) {
		if (p)
			GDKfree(p);
		return GDK_FAIL;
	}
	while(digits > 0) {
		digits--;
		value *= 10;
	}
	if (*(@1*)p > value) {
		GDKerror("double (%s) doesn't have format (%d,%d)", val, *d, *s);
		return GDK_FAIL;
		
	}
	*res = *(@1*)p;
	if (p)
		GDKfree(p);
	return GDK_SUCCEED;
}
@c

@:fround(flt)@
@:fround(dbl)@

@= cast
int cast2@1( @1 *res, str val )
{
	ptr p = NULL;
	int len = 0;
	int e = ATOMfromstr(TYPE_@1, &p, &len, val);
	
	if (e <= 0 || !p || ATOMcmp(TYPE_@1, p, ATOMnilptr(TYPE_@1)) == 0) {
		if (p)
			GDKfree(p);
		return GDK_FAIL;
	}
	*res = *(@1*)p;
	if (p)
		GDKfree(p);
	return GDK_SUCCEED;
}

@c

@:cast(sht)@
@:cast(int)@
@:cast(lng)@
@:cast(flt)@
@:cast(dbl)@

@mil
module(alarm);
module(xtables);
module(aggrX3);
module(monettime);
module(blob);
module(mmath);
module(mkey);
module(mapi); # mapi_listen 

# low memory usage for testing unloading
#mem_maxsize(0LL);
#vm_maxsize(0LL);
err := CATCH( mvc_init(int(monet_environment.find("sql_debug"))) );

proc SQLclient( Stream s_in, Stream s_out ) := {
	fork(sqlclient(s_in, s_out));
}

if (isnil(err)){
	fork(logmanager);

	mapi_listen(int(monet_environment.find("sql_port")), 5, "SQLclient").fork();
	# start a default mapi client for debugging, this should go once
	# MonetDB SQL gets stable.
	mapi_listen(int(monet_environment.find("mapi_port")), 5, "").fork();
} else {
	printf(err);
	drop(sql_server);
}
