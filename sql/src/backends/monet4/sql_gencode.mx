@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@' 
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@' 
@' The Original Code is the Monet Database System.
@' 
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2004 CWI.
@' All Rights Reserved.
@' 
@' Contributor(s):
@' 		Martin Kersten <Martin.Kersten@cwi.nl>
@' 		Peter Boncz <Peter.Boncz@cwi.nl>
@' 		Niels Nes <Niels.Nes@cwi.nl>
@' 		Stefan Manegold  <Stefan.Manegold@cwi.nl>

@f sql_gencode
@a N.J. Nes
@* 

@h
#ifndef _SQL_GENCODE_H_
#define _SQL_GENCODE_H_

#include "sql_server.h"
#include "sql_session.h"
#include "sql_statement.h"
#include "sql_backend.h"
#include "sql_scope.h"

sql_server_export int backend_dumpstmt( stmt *s, int *nr, backend *sql );
sql_server_export void backend_dumpproc( backend *be, int id, stmt *s );

#endif /*_SQL_GENCODE_H_*/

@c
#include <sql_gencode.h>
#include <string.h>

void stmt_reset( stmt *s )
{
	s->nr = 0;
	switch (s->type) {
		case st_diff: case st_intersect: case st_union:
		case st_join: case st_outerjoin:
		case st_derive:
		case st_unique:
		case st_alias: case st_column_alias:
		case st_append: case st_insert: case st_replace:
		case st_exception: case st_predicate:
		case st_partial_pivot: case st_pivot:
	  	case st_find:
	  	case st_exist:
		case st_sql:
		case st_temp:
		case st_aggr:
		case st_op: case st_unop: case st_binop: case st_Nop:

		case st_release: case st_commit: case st_rollback:
		case st_schema: case st_table: case st_column: case st_key:
		case st_idx:
		case st_create_module: case st_drop_module:
		case st_create_type: case st_drop_type:
		case st_create_func: case st_drop_func:
		case st_create_schema: case st_drop_schema:
		case st_create_view: case st_create_table: case st_drop_table:
		case st_create_column: case st_null: case st_default:
		case st_create_key: case st_create_kc:
		case st_drop_key: case st_drop_idx: 
		case st_create_idx: case st_create_ic:
		case st_create_user: case st_drop_user:
		case st_create_role: case st_drop_role:
		case st_grant_role: case st_revoke_role:

		case st_const: case st_mark:
		case st_reverse: case st_mirror:
		case st_limit: case st_order: case st_reorder:
		case st_ordered: case st_output:

		case st_ibat:
		case st_group: case st_group_ext:

		case st_filter:
		case st_select: case st_select2:
		case st_uselect: case st_uselect2:
		case st_semijoin:

		case st_bulkinsert:

		if (s->op1.stval) stmt_reset(s->op1.stval);
		if (s->op2.stval) stmt_reset(s->op2.stval);
		if (s->op3.stval) stmt_reset(s->op3.stval);
		default:
			break;
	}
}

sql_server_export int backend_dumpstmt_( stmt *s, int *nr, backend *sql );
@(
		if (mvc_debug_on(c->mvc,8192)) {
			char *sqzd_cmd = NULL;
			int misq_x = 0;
			CMDsqueezeStr2Str(&sqzd_cmd, cmd, &misq_x);
			if (sqzd_cmd && (sqzd_cmd != str_nil)) {
				/*_DELETE?*/free(cmd);
				cmd = sqzd_cmd;
			}
		}
@)


static void write_head( backend *sql, int nr )
{
        (void) nr; /* Stefan: unused!? */

	if (mvc_debug_on(sql->mvc,2)) {
		char *t0 = "var t0 := time();\n";
		int l = strlen(t0);
		stream_write( sql->out, t0, 1, l );
	}
}

static void write_tail( backend *sql, int nr)
{
	if (mvc_debug_on(sql->mvc,2)) {
		char dbg[BUFSIZ];
		int l = snprintf( dbg, BUFSIZ,
		"var t1 := time(); printf(\"%d %%d\\n\", t1 - t0);\n", nr);
		assert(l < BUFSIZ);
		stream_write( sql->out, dbg, 1, l );
	}
}

static void write_part( backend *sql, char *buf, int len )
{
	buf[len] = '\0';
	stream_write( sql->out, buf, 1, len );

	if (mvc_debug_on(sql->mvc,8)) 
		fwrite( buf, 1, len, stderr);
}

static void write_command( backend *sql, char *buf )
{
	if (mvc_debug_on(sql->mvc,1024+2048)) {
		char *s = _strdup(buf), *c = s;
		int l = strlen(s) + 32;
		char *v = NEW_ARRAY(char, l);
		while ((c = strchr(c,'"')))	*c = '`';
		c = s;
		while ((c = strchr(c,'\n')))	*c = '\t';
		l = snprintf( v, l, "printf(\"< %s >\\n\");\n", s );
		_DELETE(s);
		stream_write( sql->out, v, 1, l );
		_DELETE(v);
	}
}

static void write_result( backend *sql, char *buf )
{
	if (mvc_debug_on(sql->mvc,1024+2048)) {
		size_t l;
		size_t buflen = BUFSIZ;
		char *v = NEW_ARRAY(char, buflen), *a = buf, *b, *y, z;
		while (a && (y = strstr(a," := "))) {
			z = *y;
			*y = '\0';
			if ( (b = strrchr(a,' ' )))	a = b;
			if (!(b = strrchr(a,'\n')))	b = a;
			if (9 * strlen(b) + 512 > buflen) {
				buflen = 9 * strlen(b) + 512;
				v = RENEW_ARRAY(char,v,buflen);
			}
			l = snprintf( v, buflen, 
				"if (type(%s) != 4) {"
				"	print(%s);"
				"} else {"
				"	var x := count(%s);"
				"	printf(\"| %%d * { %%s , %%s } |\\n\",x,head(%s),tail(%s));",
				b, b, b, b, b );
			assert(l <= buflen);
			if (mvc_debug_on(sql->mvc,2048)) {
			    l += snprintf( v+l, buflen-l,
				"	if (x < 40) {"
				"		print(%s);"
				"	} else {"
				"		print(slice(%s,0,9));"
				"		print(\"...\");"
				"		print(sample(slice(%s,10,x - 11),10));"
				"		print(\"...\");"
				"		print(slice(%s,x - 10,x - 1));"
				"	}",
				b, b, b, b );
			    assert(l <= buflen);
			}
			l += snprintf( v+l, buflen-l,
				"}\n") ;
			assert(l <= buflen);
			stream_write( sql->out, v, 1, l );
			*y = z;
			a = strchr(y,';');
		}
		_DELETE(v);
	}
}

static void dump( backend *sql, char *buf, int len, int nr )
{
	if (len == -1)
		len = strlen(buf);
	write_head(sql,nr);
	write_command(sql,buf);
	write_part(sql,buf,len);
	write_result(sql,buf);
	write_tail(sql,nr);
}

void mvc_dump_1( backend *sql, stmt *s, char *name, int *nr )
{
	int o1 = backend_dumpstmt_(s->op1.stval, nr, sql);
	size_t buflen = strlen(name) + 64;
	char *buf = NEW_ARRAY(char, buflen);
	size_t len = snprintf( buf, buflen, 
		"var s%d := mvc_%s(myc, s%d);\n", 
		-s->nr, name, o1);
	assert(len <= buflen);
	dump(sql,buf,len,-s->nr);
	_DELETE(buf);
}

void mvc_dump_2( backend *sql, stmt *s, char *name, int *nr )
{
	int o1 = backend_dumpstmt_(s->op1.stval, nr, sql);
	int o2 = backend_dumpstmt_(s->op2.stval, nr, sql);
	size_t buflen = strlen(name) + 64;
	char *buf = NEW_ARRAY(char, buflen);
	size_t len = snprintf( buf, buflen, 
		"var s%d := mvc_%s(myc, s%d, s%d);\n", 
		-s->nr, name, o1, o2);
	assert(len <= buflen);
	dump(sql,buf,len,-s->nr);
	_DELETE(buf);
}

void mvc_dump_3( backend *sql, stmt *s, char *name, int *nr )
{
	int o1 = backend_dumpstmt_(s->op1.stval, nr, sql);
	int o2 = backend_dumpstmt_(s->op2.stval, nr, sql);
	int o3 = backend_dumpstmt_(s->op3.stval, nr, sql);
	size_t buflen = strlen(name) + 128;
	char *buf = NEW_ARRAY(char, buflen);
	size_t len = snprintf( buf, buflen, 
		"var s%d := mvc_%s(myc, s%d, s%d, s%d);\n", 
		-s->nr, name, o1, o2, o3);
	assert(len <= buflen);
	dump(sql,buf,len,-s->nr);
	_DELETE(buf);
}

void mvc_dump_4( backend *sql, stmt *s, char *name, int *nr )
{
	int o1 = backend_dumpstmt_(s->op1.stval, nr, sql);
	int o2 = backend_dumpstmt_(s->op2.stval, nr, sql);
	int o3 = backend_dumpstmt_(s->op3.stval, nr, sql);
	int o4 = backend_dumpstmt_(s->op4.stval, nr, sql);
	size_t buflen = strlen(name) + 128;
	char *buf = NEW_ARRAY(char, buflen);
	size_t len = snprintf( buf, buflen, 
		"var s%d := mvc_%s(myc, s%d, s%d, s%d, s%d);\n", 
		-s->nr, name, o1, o2, o3, o4);
	assert(len <= buflen);
	dump(sql,buf,len,-s->nr);
	_DELETE(buf);
}

void mvc_dump_5( backend *sql, stmt *s, char *name, int *nr )
{
	int o1 = backend_dumpstmt_(s->op1.stval, nr, sql);
	int o2 = backend_dumpstmt_(s->op2.stval, nr, sql);
	int o3 = backend_dumpstmt_(s->op3.stval, nr, sql);
	int o4 = backend_dumpstmt_(s->op4.stval, nr, sql);
	size_t buflen = strlen(name) + 128;
	char *buf = NEW_ARRAY(char, buflen);
	size_t len = snprintf( buf, buflen, 
		"var s%d := mvc_%s(myc, s%d, s%d, s%d, s%d, %d);\n", 
		-s->nr, name, o1, o2, o3, o4, s->flag);
	assert(len <= buflen);
	dump(sql,buf,len,-s->nr);
	_DELETE(buf);
}

void mvc_dump_n( backend *sql, stmt *s, char *name, int *nr )
{
	size_t buflen = strlen(name) + BUFSIZ;
	char *buf = NEW_ARRAY(char, buflen);
	node *n;

	size_t len = snprintf( buf, buflen, 
		"var s%d := mvc_%s(myc", -s->nr, name);
	assert(len <= buflen);
	for(n = s->op1.stval->op1.lval->h; n; n = n->next){
		int o = backend_dumpstmt_(n->data, nr, sql);
		if (len + 20 > buflen) {
			buflen += BUFSIZ;
			buf = RENEW_ARRAY(char,buf,buflen);
		}
		len += snprintf( buf+len, buflen-len, ", s%d", o);
		assert(len <= buflen);
	}
	len += snprintf( buf+len, buflen-len, ");\n");
	assert(len <= buflen);
	dump(sql,buf,len,-s->nr);
	_DELETE(buf);
}

void dump_1( backend *sql, stmt *s, char *name, int *nr )
{
	int o1 = backend_dumpstmt_(s->op1.stval, nr, sql);
	size_t buflen = strlen(name) + 64;
	char *buf = NEW_ARRAY(char, buflen);
	size_t len = snprintf( buf, buflen, 
		"var s%d := s%d.%s;\n", 
		-s->nr, o1, name);
	assert(len <= buflen);
	dump(sql,buf,len,-s->nr);
	_DELETE(buf);
}

void dump_2( backend *sql, stmt *s, char *name, int *nr )
{
	int o1 = backend_dumpstmt_(s->op1.stval, nr, sql);
	int o2 = backend_dumpstmt_(s->op2.stval, nr, sql);
	size_t buflen = strlen(name) + 64;
	char *buf = NEW_ARRAY(char, buflen);
	size_t len = snprintf( buf, buflen, 
		"var s%d := %s(s%d, s%d);\n", 
		-s->nr, name, o1, o2);
	assert(len <= buflen);
	dump(sql,buf,len,-s->nr);
	_DELETE(buf);
}

void dump_3( backend *sql, stmt *s, char *name, int *nr )
{
	int o1 = backend_dumpstmt_(s->op1.stval, nr, sql);
	int o2 = backend_dumpstmt_(s->op2.stval, nr, sql);
	int o3 = backend_dumpstmt_(s->op3.stval, nr, sql);
	size_t buflen = strlen(name) + 64;
	char *buf = NEW_ARRAY(char, buflen);
	size_t len = snprintf( buf, buflen, 
		"var s%d := %s(s%d, s%d, s%d);\n", 
		-s->nr, name, o1, o2, o3);
	assert(len <= buflen);
	dump(sql,buf,len,-s->nr);
	_DELETE(buf);
}

int backend_dumpstmt_( stmt *s, int *nr, backend *sql ){
    char *buf = NULL;
    size_t len = 0;
    node *n;

    assert (*nr);

    if (s){
    	if (s->nr > 0) return s->nr;

	if (s->nr == 0)
		s->nr = -(*nr)++;

	switch(s->type){
	case st_none: 
		dump(sql,"var none := \"none\";\n",-1,-s->nr);
		break;
	case st_sql: 
		mvc_dump_1( sql, s, "sql", nr  ); 
		break;
	case st_create_module: 
		mvc_dump_1( sql, s, "create_module", nr  ); 
		break;
	case st_drop_module: 
		mvc_dump_1( sql, s, "drop_module", nr  ); 
		break;
	case st_create_type: 
		mvc_dump_1( sql, s, "create_type", nr  ); 
		break;
	case st_drop_type: 
		mvc_dump_1( sql, s, "drop_type", nr  ); 
		break;
	case st_create_func: 
		mvc_dump_1( sql, s, "create_func", nr  ); 
		break;
	case st_drop_func: 
		mvc_dump_1( sql, s, "drop_func", nr  ); 
		break;
	case st_assign: {
		int val = backend_dumpstmt_( s->op1.stval, nr, sql );
		size_t buflen = strlen(s->op4.sval) + 32;
		buf = NEW_ARRAY(char, buflen+1);
		len = snprintf( buf, buflen, "%s := s%d;\n",
			s->op4.sval, val);
		assert(len <= buflen);
		dump(sql,buf,len,-s->nr);
		_DELETE(buf);
		break;
	}
	case st_var: {
		size_t buflen = strlen(s->op1.sval) + 32;
		buf = NEW_ARRAY(char, buflen+1);
		len = snprintf( buf, buflen, "var s%d := %s;\n",
			-s->nr, s->op1.sval);
		assert(len <= buflen);
		dump(sql,buf,len,-s->nr);
		_DELETE(buf);
		break;
	}
	case st_release: 
		mvc_dump_1( sql, s, "release", nr  ); 
		break;
	case st_commit: 
		mvc_dump_2( sql, s, "commit", nr  ); 
		break;
	case st_rollback: 
		mvc_dump_2( sql, s, "rollback", nr  ); 
		break;
	case st_schema: 
		mvc_dump_1( sql, s, "bind_schema", nr );
	 	break;
	case st_table: 
		mvc_dump_2( sql, s, "bind_table", nr );
	 	break;
	case st_column: 
		mvc_dump_2( sql, s, "bind_column", nr );
	 	break;
	case st_key: 
		mvc_dump_2( sql, s, "bind_key", nr );
	 	break;
	case st_create_schema: 
		mvc_dump_2( sql, s, "create_schema", nr );
		break;
	case st_drop_schema: 
		mvc_dump_2( sql, s, "drop_schema", nr );
		break;
	case st_create_view: 
		mvc_dump_3( sql, s, "create_view", nr );
		break;
	case st_create_table: 
		mvc_dump_4( sql, s, "create_table", nr );
		break;
	case st_drop_table: 
		mvc_dump_3( sql, s, "drop_table", nr );
		break;
	case st_create_column: 
		mvc_dump_n( sql, s, "create_column", nr );
		break;
	case st_null: 
		mvc_dump_2( sql, s, "null", nr );
	 	break;
	case st_default: 
		mvc_dump_2( sql, s, "default", nr );
		break;
	case st_create_key: 
		if (!s->op4.stval){
			mvc_dump_3( sql, s, "create_key", nr );
		} else {
			mvc_dump_4( sql, s, "create_key", nr );
		}
		break;
	case st_create_kc:
		mvc_dump_2( sql, s, "create_kc", nr );
		break;
	case st_drop_key:
		mvc_dump_2( sql, s, "drop_key", nr );
		break;
	case st_create_idx: 
		mvc_dump_3( sql, s, "create_idx", nr );
		break;
	case st_create_ic:
		mvc_dump_2( sql, s, "create_ic", nr );
		break;
	case st_drop_idx:
		mvc_dump_2( sql, s, "drop_idx", nr );
		break;
	case st_create_user: 
		mvc_dump_5( sql, s, "create_user", nr );
		break;
	case st_drop_user: 
		mvc_dump_1( sql, s, "drop_user", nr );
		break;
	case st_create_role: 
		mvc_dump_2( sql, s, "create_role", nr );
		break;
	case st_drop_role: 
		mvc_dump_1( sql, s, "drop_role", nr );
		break;
	case st_grant_role: 
		mvc_dump_2( sql, s, "grant_role", nr );
		break;
	case st_revoke_role: 
		mvc_dump_2( sql, s, "revoke_role", nr );
		break;
	case st_temp: {
		size_t buflen = strlen(s->op4.typeval->type->name) + 64;
		buf = NEW_ARRAY(char, buflen+1);
		len = snprintf( buf, buflen, 
			"var s%d := new(void,%s).seqbase(oid(0));\n", 
			-s->nr, s->op4.typeval->type->name );
		assert(len <= buflen);
		dump(sql,buf,len,-s->nr);
		_DELETE(buf);
		break;
	}
	case st_ibat: 
		s->nr = -backend_dumpstmt_( s->op1.stval, nr, sql );
		break;
	case st_bat:
	case st_ubat: {
		char *type = (s->type==st_bat)?"":"_ubat";
		char *hname = NULL;
		size_t buflen = 128 + strlen(type) +
			strlen(s->op1.cval->t->s->base.name) +
			strlen(s->op1.cval->t->base.name) +
			strlen(s->op1.cval->base.name);
		if (s->h->type == st_basetable){
			hname = s->h->op1.tval->base.name;
			len += strlen(hname);
		}
		buf = NEW_ARRAY(char, buflen+1);
		len = snprintf( buf, buflen, 
		     "var s%d := mvc_bind%s(myc, \"%s\", \"%s\", \"%s\", %d)",
			  -s->nr, type, 
			  s->op1.cval->t->s->base.name, 
			  s->op1.cval->t->base.name, 
			  s->op1.cval->base.name, s->flag);
		assert(len <= buflen);

		if (s->flag > RDONLY){
			len += snprintf( buf+len, buflen-len, 
			  		".access(BAT_WRITE)"); 
			assert(len <= buflen);
		}
		len += snprintf( buf+len, buflen-len, "; #%s\n", hname?hname:"");
		assert(len <= buflen);
		if (mvc_debug_on(sql->mvc,4)) {
			len += snprintf( buf+len, buflen-len, 
				"s%d.info.print();", -s->nr);
			assert(len <= buflen);
		}
		/*dump(sql,buf,len,-s->nr);*/
		write_head(sql,-s->nr);
		write_command(sql,buf);
		write_part(sql,buf,len);
		write_result(sql,buf);
		write_tail(sql,-s->nr);
		_DELETE(buf);
		break;
	}
	case st_dbat: {
		size_t buflen = 128 + strlen(s->op1.tval->s->base.name) +
			strlen(s->op1.tval->base.name);
		buf = NEW_ARRAY(char, buflen+1);
		len = snprintf( buf, buflen, 
		  	"var s%d := mvc_bind_dbat(myc, \"%s\", \"%s\", %d)",
			  -s->nr,  
			  s->op1.tval->s->base.name, 
			  s->op1.tval->base.name, 
			  s->flag);
		assert(len <= buflen);

		if (s->flag > RDONLY){
			len += snprintf( buf+len, buflen-len, 
		  		".access(BAT_WRITE)"); 
			assert(len <= buflen);
		}
		len += snprintf( buf+len, buflen-len, ";\n" ); 
		assert(len <= buflen);
		if (mvc_debug_on(sql->mvc,4)) {
			len += snprintf( buf+len, buflen-len, 
					 "s%d.info.print();\n", -s->nr);
			assert(len <= buflen);
		}
		dump(sql,buf,len,-s->nr);
		_DELETE(buf);
		break;
	}
	case st_idxbat: {
		size_t buflen = 128 + strlen(s->op1.idxval->t->s->base.name) +
			strlen(s->op1.idxval->t->base.name) +
			strlen(s->op1.idxval->base.name);
		buf = NEW_ARRAY(char, buflen+1);
		len = snprintf( buf, buflen, 
		  "var s%d := mvc_bind_ibat(myc, \"%s\", \"%s\", \"%s\", %d)",
			  -s->nr, 
			  s->op1.idxval->t->s->base.name, 
			  s->op1.idxval->t->base.name, 
			  s->op1.idxval->base.name,
			  s->flag);
		assert(len <= buflen);

		if (s->flag > RDONLY){
			len += snprintf( buf+len, buflen-len, 
					 ".access(BAT_WRITE)"); 
			assert(len <= buflen);
		}
		len += snprintf( buf+len, buflen-len, ";\n" ); 
		assert(len <= buflen);
		if (mvc_debug_on(sql->mvc,4)) {
			len += snprintf( buf+len, buflen-len, 
					 "s%d.info.print();\n", -s->nr);
			assert(len <= buflen);
		}
		dump(sql,buf,len,-s->nr);
		_DELETE(buf);
		break;
	}
	case st_const: 
		dump_2( sql, s, "project", nr );
	 	break;
	case st_mark: 
		dump_2( sql, s, "mark", nr );
	 	break;
	case st_reverse: 
		dump_1( sql, s, "reverse", nr );
	 	break;
	case st_mirror: 
		dump_1( sql, s, "mirror", nr );
	 	break;
	case st_limit: {
		int l = backend_dumpstmt_( s->op1.stval, nr, sql );
		int r = backend_dumpstmt_( s->op2.stval, nr, sql );
		buf = NEW_ARRAY(char, BUFSIZ+1);
		len = snprintf( buf, BUFSIZ, 
			"var s%d := s%d.slice(0, s%d - 1);\n", -s->nr, l, r );
		dump(sql,buf,len,-s->nr);
		_DELETE(buf);
		break;
	}
	case st_order: {
		int l = backend_dumpstmt_( s->op1.stval, nr, sql );
		buf = NEW_ARRAY(char, BUFSIZ+1);
		if (s->flag)
			len = snprintf( buf, BUFSIZ,
			"var s%d := s%d.reverse().sort()", -s->nr, l );
		else 
			len = snprintf( buf, BUFSIZ,
			"var s%d := s%d.reverse().sort_rev()", -s->nr, l );
		len += snprintf( buf+len, BUFSIZ-len, ".reverse();\n" );
		dump(sql,buf,len,-s->nr);
		_DELETE(buf);
		break;
	}
	case st_reorder: {
		int l = backend_dumpstmt_( s->op1.stval, nr, sql );
		int r = backend_dumpstmt_( s->op2.stval, nr, sql );
		buf = NEW_ARRAY(char, BUFSIZ+1);
		if (s->flag)
			len = snprintf( buf, BUFSIZ,
				"var s%d := s%d.CTrefine(s%d)", -s->nr, l, r);
		else 
			len = snprintf( buf, BUFSIZ,
				"var s%d := s%d.CTrefine_rev(s%d)", -s->nr, l, r);
		len += snprintf( buf+len, BUFSIZ-len, ";\n" );
		dump(sql,buf,len,-s->nr);
		_DELETE(buf);
		break;
	}

	case st_select: 
	case st_uselect: {
		int l = backend_dumpstmt_( s->op1.stval, nr, sql );
		int r = backend_dumpstmt_( s->op2.stval, nr, sql );
		buf = NEW_ARRAY(char, BUFSIZ+1);
		if (s->op2.stval->nrcols >= 1){
			char *op = "=";
			switch(s->flag){
			case cmp_equal: op = "="; break;
			case cmp_notequal: op = "!="; break;
			case cmp_lt: op = "<"; break;
			case cmp_lte: op = "<="; break;
			case cmp_gt: op = ">"; break;
			case cmp_gte: op = ">="; break;
			default:
				len = snprintf( buf, BUFSIZ, 
					"error impossible\n");
	  		} 
			len = snprintf( buf, BUFSIZ, 
				"var s%d := [%s](s%d,s%d).uselect(TRUE);\n", 
				-s->nr, op, l, r ); 
		} else {
		char *cmd;
		if (s->type == st_select)
			cmd="select";
		else
			cmd="uselect";
		switch(s->flag){
		case cmp_like:
			len = snprintf( buf, BUFSIZ, 
				"var s%d := s%d.likeselect(s%d);\n", -s->nr, l, r ); 
			break;
		case cmp_notlike:
			(void)(*nr)++; 
			len = snprintf( buf, BUFSIZ, 
				"var s%d := s%d.likeselect(s%d);\n", *nr, l, r ); 
			len += snprintf( buf+len, BUFSIZ, 
				"var s%d := s%d.kdiff(s%d);\n", -s->nr, l, *nr );
			break;
		case cmp_equal:
			len = snprintf( buf, BUFSIZ, 
				"var s%d := s%d.%s(s%d);\n", -s->nr, l, cmd, r ); 
			break;
		case cmp_notequal:
			(void)(*nr)++; 
			len = snprintf( buf, BUFSIZ, 
				"var s%d := s%d.uselect(s%d);\n", *nr, l, r ); 
			len += snprintf( buf+len, BUFSIZ, 
				"var s%d := s%d.kdiff(s%d);\n", -s->nr, l, *nr );
			break;
		case cmp_lt:
			len = snprintf( buf, BUFSIZ, 
			  "var s%d := s%d.%s(%s(nil), s%d, FALSE, FALSE);\n", 
			  -s->nr, l, cmd, tail_type(s)->type->name, r ); 
			break;
		case cmp_lte:
			len = snprintf( buf, BUFSIZ, 
			  "var s%d := s%d.%s(%s(nil), s%d);\n", 
			  -s->nr, l, cmd, tail_type(s)->type->name, r ); 
			break;
		case cmp_gt:
			len = snprintf( buf, BUFSIZ, 
			  "var s%d := s%d.%s(s%d, %s(nil), FALSE, FALSE);\n", 
			  -s->nr, l, cmd, r, tail_type(s)->type->name ); 
			break;
		case cmp_gte: 
			len = snprintf( buf, BUFSIZ, 
			  "var s%d := s%d.%s(s%d, %s(nil));\n", 
			  -s->nr, l, cmd, r, tail_type(s)->type->name ); 
			break;
		default:
			len = snprintf( buf, BUFSIZ, 
					"error impossible\n");
	  	} 
		}
		dump(sql,buf,len,-s->nr);
		_DELETE(buf);
		break;
	}
	case st_select2: 
	case st_uselect2: {
		int l = backend_dumpstmt_( s->op1.stval, nr, sql );
		int r1 = backend_dumpstmt_( s->op2.stval, nr, sql );
		int r2 = backend_dumpstmt_( s->op3.stval, nr, sql );
		char *bits = NULL;
		char *cmd;
		if (s->type == st_select2)
			cmd="select";
		else
			cmd="uselect";
		switch(s->flag){
		case 0: 
			bits = ", FALSE, FALSE";
			break;
		case 1: 
			bits = ", FALSE, TRUE";
			break;
		case 2: 
			bits = ", TRUE, FALSE";
			break;
		case 3: 
			bits = ", TRUE, TRUE";
			break;
		}
		buf = NEW_ARRAY(char, BUFSIZ+1);
		len = snprintf( buf, BUFSIZ, 
		  "var s%d := s%d.%s(s%d, s%d%s);\n", 
		  -s->nr, l, cmd, r1, r2, bits ); 
		dump(sql,buf,len,-s->nr);
		_DELETE(buf);
		break;
	}
	case st_semijoin: 
		dump_2( sql, s, "semijoin", nr );
		break;
	case st_diff: 
		dump_2( sql, s, "kdiff", nr );
		break;
	case st_union: 
		dump_2( sql, s, "kunion", nr );
		break;
	case st_reljoin: {
		buf = NEW_ARRAY(char, BUFSIZ+1);
		if (list_length(s->op1.lval) == 1) {
			int l = backend_dumpstmt_( s->op1.lval->h->data, nr, sql );
			int r = backend_dumpstmt_( s->op2.lval->h->data, nr, sql );
			len = snprintf( buf, BUFSIZ,
			  "var s%d := join(s%d,reverse(s%d));\n", -s->nr, l, r);
		} else {
			node *ln = NULL, *rn = NULL;
			char x = '(';
			len = snprintf( buf, BUFSIZ,
			  "var s%d := ds_link", -s->nr );
			for (ln = s->op1.lval->h, rn = s->op2.lval->h; ln && rn; ln = ln->next, rn = rn->next) {
				int l = backend_dumpstmt_( ln->data, nr, sql );
				int r = backend_dumpstmt_( rn->data, nr, sql );
				len += snprintf(buf +len, BUFSIZ-len,
				  "%c s%d, s%d", x, l, r );
				x = ',';
			}
			len += snprintf(buf +len, BUFSIZ-len, 
			  " );\n");
		}
		dump(sql,buf,len,-s->nr);
		_DELETE(buf);
		break;
	}
	case st_outerjoin:
	case st_join: {
		int l = backend_dumpstmt_( s->op1.stval, nr, sql );
		int r = backend_dumpstmt_( s->op2.stval, nr, sql );
		char *jt = "join";
		if (s->type == st_outerjoin)
			jt = "outerjoin";
		buf = NEW_ARRAY(char, BUFSIZ+1);
		switch(s->flag){
		case cmp_equal:
			len = snprintf( buf, BUFSIZ, 
			  "var s%d := s%d.%s(s%d);\n", -s->nr, l, jt, r ); 
			break;
		case cmp_notequal:
			len = snprintf( buf, BUFSIZ, 
			  "var s%d := s%d.%s(s%d, \"!=\");\n", -s->nr, l, jt, r ); 
			break;
		case cmp_lt:
			len = snprintf( buf, BUFSIZ, 
			  "var s%d := s%d.%s(s%d, \"<\");\n", -s->nr, l, jt, r ); 
			break;
		case cmp_lte: 
			len = snprintf( buf, BUFSIZ, 
			  "var s%d := s%d.%s(s%d, \"<=\");\n", -s->nr, l, jt, r );
			break;
		case cmp_gt: 
			len = snprintf( buf, BUFSIZ, 
			  "var s%d := s%d.%s(s%d, \">\" );\n", -s->nr, l, jt, r); 
			break;
		case cmp_gte: 
			len = snprintf( buf, BUFSIZ, 
			  "var s%d := s%d.%s(s%d, \">=\" );\n", -s->nr, l, jt, r);
			break;
		case cmp_all: /* aka cross table */
			len = snprintf( buf, BUFSIZ, 
			"var s%d := s%d.project(0).join(s%d.reverse().project(0).reverse());\n", -s->nr, l, r ); 
			break;
		default:
			len = snprintf( buf, BUFSIZ, 
					"error impossible\n");
	  	} 
		if (mvc_debug_on(sql->mvc,4)) {
			len += snprintf(buf +len, BUFSIZ-len, 
				"s%d.info.print;\n", -s->nr);
		}
		dump(sql,buf,len,-s->nr);
		_DELETE(buf);
		break;
	}
	case st_group: 
		dump_1( sql, s, "CTgroup", nr );
		break;
	case st_group_ext: 
		dump_1( sql, s, "tunique.mirror", nr );
		break;
	case st_derive: 
		dump_2( sql, s, "CTgroup", nr );
		break;
	case st_unique: {
		int l = backend_dumpstmt_( s->op1.stval, nr, sql );
		buf = NEW_ARRAY(char, BUFSIZ+1);
		buf[0] = 0;
		if (s->op2.stval){
			int g = backend_dumpstmt_( s->op2.stval, nr, sql );

		  	len += snprintf( buf+len, BUFSIZ-len, 
			/*"var s%dg := s%d.CTunique(s%d);\n", -s->nr, g, l);*/
			"var s%dg := s%d.CTgroup(s%d);\n", -s->nr, g, l);
		  	len += snprintf( buf+len, BUFSIZ-len, 
			"var s%de := s%dg.tunique().mirror();\n", -s->nr, -s->nr);
			/*"var s%de := s%dg.reverse.kunique.mirror;\n", -s->nr, -s->nr);*/
		  	len += snprintf( buf+len, BUFSIZ-len, 
			"var s%d := s%d.semijoin(s%de);\n", -s->nr, l, -s->nr );
		} else {
		  	len += snprintf( buf+len, BUFSIZ-len, 
			"var s%d := s%d.reverse().kunique().reverse();\n", 
			-s->nr, l);
		}
		dump(sql,buf,len,-s->nr);
		_DELETE(buf);
		break;
	}
	case st_op: {
		size_t buflen = strlen(s->op4.funcval->func->imp) + 32;
		buf = NEW_ARRAY(char, buflen+1);
		len = snprintf( buf, buflen, 
		   "var s%d := %s();\n", -s->nr, s->op4.funcval->func->imp);
		assert(len <= buflen);
		dump(sql,buf,len,-s->nr);
		_DELETE(buf);
		break;
	}
	case st_unop: {
		int l = backend_dumpstmt_( s->op1.stval, nr, sql );
		size_t buflen;

		if (s->op1.stval->nrcols){
		  sql_subtype *v, *a;
		  a = tail_type(s);
		  v = tail_type(s->op1.stval);
		  if (  a->type->localtype == v->type->localtype &&
			strcmp(s->op4.funcval->func->name, "convert") == 0 ) {
		   buflen = BUFSIZ;
		   buf = NEW_ARRAY(char, buflen+1);
		   len = snprintf( buf, buflen, "var s%d := s%d;\n", -s->nr, l);
		   assert(len <= buflen);
		  } else {
		   buflen = strlen(s->op4.funcval->func->imp) + 64;
		   buf = NEW_ARRAY(char, buflen+1);
		   len = snprintf( buf, buflen, 
		   "var s%d := [%s](s%d);\n", -s->nr, s->op4.funcval->func->imp, l);
		   assert(len <= buflen);
		  }
		} else {
		  buflen = strlen(s->op4.funcval->func->imp) + 64;
		  buf = NEW_ARRAY(char, buflen+1);
		  len = snprintf( buf, buflen, 
		   "var s%d := %s(s%d);\n", -s->nr, s->op4.funcval->func->imp, l);
		  assert(len <= buflen);
		}
		dump(sql,buf,len,-s->nr);
		_DELETE(buf);
		break;
	}
	case st_binop: {
		int l = backend_dumpstmt_( s->op1.stval, nr, sql );
		int r = backend_dumpstmt_( s->op2.stval, nr, sql );
		size_t buflen = strlen(s->op4.funcval->func->imp) + 64;
		buf = NEW_ARRAY(char, buflen+1);
		if (s->op1.stval->nrcols || s->op2.stval->nrcols ){
		  	len += snprintf( buf, buflen, 
		    	"var s%d := [%s](s%d,s%d);\n", 
			-s->nr, s->op4.funcval->func->imp, l, r );
			assert(len <= buflen);
		} else  {
		  	len += snprintf( buf, buflen, 
		    	"var s%d := %s(s%d,s%d);\n", 
			-s->nr, s->op4.funcval->func->imp, l,r );
			assert(len <= buflen);
		}
		dump(sql,buf,len,-s->nr);
		_DELETE(buf);
		break;
	}
	case st_Nop: {
		int opslen = 0;
		char *ops;
		node *n;
		size_t buflen;

		backend_dumpstmt_(s->op1.stval, nr, sql); /* dump operands */
		write_head(sql,-s->nr);
		if (s->nrcols){
		    stmt *h;
		    buflen = 0;
		    for (n=s->op1.stval->op1.lval->h, h=n->data; n; n=n->next){
			stmt *op = n->data;
			if (op->nrcols > h->nrcols)
				h = op;
			buflen += 20;
		    }

		    ops = NEW_ARRAY(char, buflen);
		    for (n = s->op1.stval->op1.lval->h; n; n=n->next){
			stmt *op = n->data;
			int n = op->nr;
			opslen += snprintf(ops+opslen, buflen-opslen, 
			 "%cs%d", (opslen)?',':' ', n);
		    }
		    buflen = strlen(s->op4.funcval->func->imp) + opslen + 64;
		    buf = NEW_ARRAY(char, buflen+1);
		    len = snprintf( buf, buflen, 
		    	"var s%d := [%s](%s);\n", 
			-s->nr, s->op4.funcval->func->imp, ops );
		    assert(len <= buflen);
		} else {
		    buflen = 0;
		    for (n = s->op1.stval->op1.lval->h; n; n=n->next)
			buflen += 20;
		    ops = NEW_ARRAY(char, buflen);
		    for (n = s->op1.stval->op1.lval->h; n; n=n->next){
			stmt *op = n->data;
			int n = op->nr;

			opslen += snprintf(ops+opslen, buflen-opslen, 
			 "%cs%d", (opslen)?',':' ', n);
		    }
		    buflen = strlen(s->op4.funcval->func->imp) + opslen + 64;
		    buf = NEW_ARRAY(char, buflen+1);
		    len = snprintf( buf, BUFSIZ, 
		      	"var s%d := %s(%s);\n", 
			-s->nr, s->op4.funcval->func->imp, ops);
		    assert(len <= buflen);
		}
		_DELETE(ops);
		write_part(sql,buf,len);
		write_command(sql,buf);
		write_result(sql,buf);
		write_tail(sql,-s->nr);
		_DELETE(buf);
		break;
	}
	case st_aggr: {
		int l = backend_dumpstmt_( s->op1.stval, nr, sql );
		size_t buflen = strlen(s->op4.aggrval->aggr->imp) + 64;
		buf = NEW_ARRAY(char, buflen+1);
		if (s->op3.gval){
			int g = backend_dumpstmt_( s->op2.stval, nr, sql );
			int e = backend_dumpstmt_( s->op3.stval, nr, sql );
			len += snprintf( buf+len, buflen-len, 
			"var s%d := {%s}(s%d, s%d, s%d);\n", 
				-s->nr, s->op4.aggrval->aggr->imp, l, g, e);
			assert(len <= buflen);
		} else {
			len += snprintf( buf+len, buflen-len, 
				"var s%d := s%d.%s();\n", 
				-s->nr, l, s->op4.aggrval->aggr->imp );
			assert(len <= buflen);
		}
		dump(sql,buf,len,-s->nr);
		_DELETE(buf);
		break;
	}
	case st_atom: {
		write_head(sql,-s->nr);
		buf = NEW_ARRAY(char, BUFSIZ+1);
		len = snprintf( buf, BUFSIZ, "var s%d := ", -s->nr);
		write_command(sql,buf);
		write_part(sql,buf,len);
		atom_dump(s->op1.aval, sql->out);
		len = snprintf( buf, BUFSIZ, ";\n");
		write_part(sql,buf,len);
		len = snprintf( buf, BUFSIZ, "var s%d := ", -s->nr);
		write_result(sql,buf);
		write_tail(sql,-s->nr);
		_DELETE(buf);
		break;
	}
	case st_insert: {
		int l = backend_dumpstmt_( s->op1.stval, nr, sql );
		int r = backend_dumpstmt_( s->op2.stval, nr, sql );
		buf = NEW_ARRAY(char, BUFSIZ+1);
		if (s->op2.stval->nrcols){
			len = snprintf( buf, BUFSIZ, 
		  	"var s%d := insert(s%d.access(BAT_WRITE),s%d);\n", -s->nr, l, r);
		} else {
			len = snprintf( buf, BUFSIZ, 
		  	"var s%d := insert(s%d,s%d);\n", -s->nr, l, r);
		}
		dump(sql,buf,len,-s->nr);
		_DELETE(buf);
		break;
	}
	case st_append: {
		int l = backend_dumpstmt_( s->op1.stval, nr, sql );
		int r = backend_dumpstmt_( s->op2.stval, nr, sql );
		buf = NEW_ARRAY(char, BUFSIZ+1);
		len = snprintf( buf, BUFSIZ, 
		   	"var s%d := append(s%d.access(BAT_WRITE),s%d);\n", 
			-s->nr, l, r);
		dump(sql,buf,len,-s->nr);
		_DELETE(buf);
		break;
	}
	case st_replace: {
		int l = backend_dumpstmt_( s->op1.stval, nr, sql );
		int r = backend_dumpstmt_( s->op2.stval, nr, sql );
		buf = NEW_ARRAY(char, BUFSIZ+1);
		len += snprintf( buf, BUFSIZ, 
		  "var s%d := replace(s%d.access(BAT_WRITE),s%d);\n", -s->nr, l, r);
		dump(sql,buf,len,-s->nr);
		_DELETE(buf);
		break;
	}
	case st_exception: {
		int l = backend_dumpstmt_( s->op1.stval, nr, sql );
		int r = backend_dumpstmt_( s->op2.stval, nr, sql );
		buf = NEW_ARRAY(char, BUFSIZ+1);
		len += snprintf( buf, BUFSIZ, 
		  "if (bit(s%d)){ ERROR(s%d); }\n", l, r);
		dump(sql,buf,len,-s->nr);
		_DELETE(buf);
		break;
	}
	case st_predicate: {
		int pred = backend_dumpstmt_( s->op1.stval, nr, sql );
		int e, def = backend_dumpstmt_( s->op2.stval, nr, sql );
		buf = NEW_ARRAY(char, BUFSIZ+1);
		len = snprintf( buf, BUFSIZ, "if (s%d){\n", pred);
		write_part(sql,buf,len);
		e = backend_dumpstmt_( s->op3.stval, nr, sql );
		stmt_reset(s->op3.stval);
		len = snprintf( buf, BUFSIZ, "s%d := s%d;\n}\n", def, e);
		write_part(sql,buf,len);
		/* make sure right variable is used later */
		len = snprintf( buf, BUFSIZ, "s%d := s%d;\n", -s->nr, def);
		write_part(sql,buf,len);
		_DELETE(buf);
		break;
	}
	case st_alias: 
	case st_column_alias: 
		s->nr = - backend_dumpstmt_( s->op1.stval, nr, sql );
		break;
	case st_set: 
	case st_list: {
		for (n = s->op1.lval->h; n; n = n->next ){
			(void)backend_dumpstmt_( n->data, nr, sql );
		}
		break;
	}
	case st_sets: {
		for(n = s->op1.lval->h; n; n = n->next ){
			list *l = n->data;
			node *m = l->h;
			while(m){
				(void)backend_dumpstmt_( m->data, nr, sql );
				m = m->next;
			}
		}
		break;
	}
	case st_find: 
		dump_2( sql, s, "find", nr );
		break;
	case st_exist: 
		dump_2( sql, s, "exist", nr );
		break;
	case st_bulkinsert: {
		char *tname = s->op1.stval->op1.tval->base.name;
		int sep =  backend_dumpstmt_( s->op2.stval, nr, sql );
		int rsep =  backend_dumpstmt_( s->op3.stval, nr, sql );
		size_t buflen = strlen(tname) + 512;

		buf = NEW_ARRAY(char, buflen+1);
		if (s->op4.stval){
			int file =  backend_dumpstmt_( s->op4.stval, nr, sql );
			len += snprintf( buf+len, buflen-len, 
			"var f%ds := open_rastream(iconv(s%d, \"UTF-8\", codeset()));\n", file, file);
			assert(len <= buflen);
			len += snprintf( buf+len, buflen-len, 
			"var f%d := bstream_create(f%ds, 1024*1024);\n", file, file);
			assert(len <= buflen);
			len += snprintf( buf+len, buflen-len, 
		    	"var s%d := mvc_import_table( myc, f%d, \"%s\", s%d, s%d, %d);\n",
			-s->nr, file, tname, sep, rsep, s->flag );
			assert(len <= buflen);
			len += snprintf( buf+len, buflen-len, 
			"bstream_destroy(f%d);\n", file );
			assert(len <= buflen);
			len += snprintf( buf+len, buflen-len, 
			"stream_close(f%ds);\n", file );
			assert(len <= buflen);
		} else {
			len += snprintf( buf+len, buflen-len, 
		        "var s%d := mvc_import_table( myc, Input, \"%s\", s%d, s%d, %d);\n",
			-s->nr, tname, sep, rsep, s->flag );
			assert(len <= buflen);
		}
		dump(sql,buf,len,-s->nr);
		_DELETE(buf);
		break;
	}
	case st_filter:
		s->nr = -backend_dumpstmt_( s->op1.stval, nr, sql );
		break;
	case st_ordered: {
		int l =  backend_dumpstmt_( s->op1.stval, nr, sql );
		(void)backend_dumpstmt_( s->op2.stval, nr, sql );
		s->nr = -l;
		break;
	}
	case st_output: {
		stmt *order = NULL;
		stmt *lst = s->op1.stval;
		size_t buflen = BUFSIZ;
		backend_dumpstmt_( lst, nr, sql );

		write_head(sql,-s->nr);
		buf = NEW_ARRAY(char, buflen+1);
		buf[0] = 0;
		if (mvc_debug_on(sql->mvc,1)) {
			if (lst->type == st_list){
				list *l = lst->op1.lval;

				n = l->h;
				while(n){
					stmt *r = n->data;
					if (buflen - len < 32) {
						buflen += BUFSIZ;
						buf = RENEW_ARRAY(char,buf,buflen);
					}
					len += snprintf( buf+len, buflen-len,
						"print(s%d);\n", r->nr);
					assert(len <= buflen);
					n = n->next;
				}
			}
		}
		if (mvc_debug_on(sql->mvc,32)) {
			if (buflen - len < 128) {
				buflen += BUFSIZ;
				buf = RENEW_ARRAY(char,buf,buflen);
			}
			len += snprintf( buf+len, buflen-len,
			"stream_write(Output,\"0\\n\");stream_flush(Output);\n");
			assert(len <= buflen);
			if (lst->type == st_list){
				list *l = lst->op1.lval;

				n = l->h;
				len += snprintf( buf+len, buflen-len, 
						"table(\n");
				assert(len <= buflen);
				if (n){
					stmt *r = n->data;
					len += snprintf( buf+len, buflen-len,
						"s%d", r->nr);
					assert(len <= buflen);
					n = n->next;
				}
				while(n){
					stmt *r = n->data;
					if (buflen - len < 32) {
						buflen += BUFSIZ;
						buf = RENEW_ARRAY(char,buf,buflen);
					}
					len += snprintf( buf+len, buflen-len,
						", s%d", r->nr);
					assert(len <= buflen);
					n = n->next;
				}
				len += snprintf( buf+len, buflen-len, ");\n");
				assert(len <= buflen);
			}
			_DELETE(buf);
			break;
		}
		if (len) {
			write_command(sql,buf);
			write_part(sql,buf,len);
		}
		len = 0;
		if (lst->type == st_ordered){
			order = lst->op1.stval; 
			lst = lst->op2.stval; 
		}
		if (lst->type == st_list){
			list *l = lst->op1.lval;
			int cnt = list_length(l);

			n = l->h;
			if (n){
			  if (!order){
			    order = n->data;
			  }
			}
			if (buflen - len < 128) {
				buflen += BUFSIZ;
				buf = RENEW_ARRAY(char,buf,buflen);
			}
			len = snprintf( buf, buflen,
				"var s%d := mvc_result_table(myc, %d, s%d);\n", 
					-s->nr, cnt, order->nr);
			assert(len <= buflen);
			write_command(sql,buf);
			write_part(sql,buf,len);
			len = 0;
			for(; n; n = n->next){
				stmt *r = n->data;
				char *cn = column_name(r);
				size_t sl = strlen(cn) + strlen(tail_type(r)->type->sqlname);
				if (buflen - len < 128 + sl) {
					buflen += BUFSIZ + sl;
					buf = RENEW_ARRAY(char,buf,buflen);
				}
				len = snprintf( buf, buflen,
					"mvc_result_column(myc, \"%s\", \"%s\", %d, %d, s%d);\n", 
					cn,
					tail_type(r)->type->sqlname,
					tail_type(r)->digits,
					tail_type(r)->scale,
				        r->nr
				);
				assert(len <= buflen);
				_DELETE(cn);
				write_command(sql,buf);
				write_part(sql,buf,len);
				len = 0;
			}
			if (buflen - len < 256) {
				buflen += BUFSIZ;
				buf = RENEW_ARRAY(char,buf,buflen);
			}
			len = snprintf( buf, buflen,
				"mvc_export_result(myc, Output, s%d);\n", 
					-s->nr );
			assert(len <= buflen);
			/* send first part (or all) */
			len += snprintf( buf+len, buflen-len,
				"mvc_export_table(myc, Output, s%d, 0, int(reply_size));\n", -s->nr );
			assert(len <= buflen);
			write_command(sql,buf);
			write_part(sql,buf,len);
			len = 0;
		} else {
			fprintf(stderr, "not a valid output list %d %d %d\n",
					lst->type, st_list, st_ordered);
		}
		write_tail(sql,-s->nr);
		_DELETE(buf);
		break;
	}

	/* should not appear here */
	case st_relselect:
	case st_intersect: 
	/* todo */

	case st_basetable: /* relation(table) */
	case st_ptable:
	case st_pivot:
	case st_partial_pivot:
	case st_idx:
		printf("backend_dumpstmt_: not implemented stmt %s\n", st_type2string(s->type));
		assert(0);
	}

    	if (s->nr > 0) 
		assert(s->nr <= 0);
	else
		s->nr = -s->nr;

    	return s->nr;
    }
    return 0;
}

int backend_dumpstmt( stmt *s, int *nr, backend *sql )
{
	int ret = 0;

	stream_write(sql->out, "{\n", 2, 1); 
    	ret = backend_dumpstmt_( s, nr, sql );
	stream_write(sql->out, "}\n", 2, 1); 
	return ret;
}

void backend_dumpproc( backend *be, int id, stmt *s )
{
	int nr = 1;
	int i = 0;
	char buf[BUFSIZ];
	node *n;

	i = snprintf( buf, BUFSIZ, "proc sql%d (", id);
	if (be->mvc->params){
		for (n = be->mvc->params->h; n; n = n->next){
			var_ *v = n->data;

			i += snprintf(buf+i, BUFSIZ-i, "%s %s%c", 
				v->s->op2.typeval->type->name,
				v->name, (n->next)?',':' '
				);
		}
	}
	i += snprintf(buf+i, BUFSIZ-i, ") : void \n");
	stream_write(be->out, buf, i, 1); 

    	backend_dumpstmt( s, &nr, be );
}
	

