@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2004 CWI.
@' All Rights Reserved.

@f sql_gencode
@t SQL to MAL code generation.
@a N. Nes, M. Kersten
@+ MAL Code generation
[TODO, check code generation, in particular the assignment of
the result to the proper variable]

This module contains the actions to construct a MAL program, ready for
optimization and execution by the Monet V5 kernel.

The code base is modeled directly after its MIL variant, replacing
each IO request by instructions to initialize the corresponding MAL data
structure.
To speed up the compilation, we may consider keeping a cache of pre-compiled
statements.

MAL extensions needed. A temporary variable used as an argument
should be printed (done). Consider replacing modname/fcnname by
an integer constant and a global lookup table. This should
reduce the cost to prepare MAL statements significantly.

A dummy module is needed to load properly.
@-
@h
#ifndef _SQL2MAL_H
#define _SQL2MAL_H

#include <sql.h>
#include <sql_atom.h>
#include <sql_statement.h>
#include <sql_mvc.h>
#include <mal_function.h>

sql_export int backend_dumpstmt(backend *be, MalBlkPtr mb, stmt *s);
sql_export void backend_dumpproc( backend *be, MalBlkPtr mb, int id, stmt *s );

#define _SQL_GENCODE_DEBUG
#endif /* _SQL2MAL_H */
@c
#include "sql_gencode.h"
#include "sql_scope.h"

@+ MAL code support
To simplify construction of the MAL program use the following
macros

@c

static InstrPtr 
newStmt( MalBlkPtr mb, char *module, char *name ) 
{ 
	InstrPtr q= newInstruction(ASSIGNsymbol);
	moduleId(q)= (module)? GDKstrdup(module): 0;
	functionId(q)= (name)? GDKstrdup(name): 0;
	getDestVar(q)= newTmpVariable(mb,TYPE_any);
	setVarInitialized(mb,getDestVar(q));
	pushInstruction(mb,q);
	return q;
}

static InstrPtr 
newStmtId( MalBlkPtr mb, char *id, char *module, char *name ) 
{
	InstrPtr q= newInstruction(ASSIGNsymbol);
	moduleId(q)= (module)? GDKstrdup(module): 0;
	functionId(q)= (name)? GDKstrdup(name): 0;
	getDestVar(q)= newVariable(mb,id,TYPE_any);
	setVarInitialized(mb,getDestVar(q));
	pushInstruction(mb,q);
	return q;
}

static InstrPtr
newAssignment( MalBlkPtr mb )
{
	InstrPtr q= newInstruction(ASSIGNsymbol);
	pushInstruction(mb,q);
	return q;
}

static InstrPtr 
pushInt(MalBlkPtr mb, InstrPtr q, int val) 
{	
	int _t; 
	char bufi[BUFSIZ];

	snprintf(bufi,BUFSIZ,"%d",val);
	_t= newConstant(mb,TYPE_int,GDKstrdup(bufi),TRUE); 
	return pushArgument(mb,q,_t);
}

static InstrPtr 
pushStr(MalBlkPtr mb, InstrPtr q, const char *val) 
{
	int _t = newConstant(mb,TYPE_str,GDKstrdup(val),TRUE); 
	return pushArgument(mb,q,_t);
}

static InstrPtr 
pushBit(MalBlkPtr mb, InstrPtr q, const char *val) 
{
	int _t = newConstant(mb,TYPE_bit,GDKstrdup(val),TRUE); 
	return pushArgument(mb,q,_t);
}

static InstrPtr 
pushNilType(MalBlkPtr mb, InstrPtr q, char *tpe ) 
{	
	int _t = newConstant(mb,
		getTypeIndex(tpe,strlen(tpe)),GDKstrdup("nil"),TRUE); 
	return pushArgument(mb,q,_t);
}

@+ MAL initialization
Many instructions have a more or less fixed structure, therefore
they can be assembled in a pre-compiled block. Each time we need it,
a copy can be extracted and included in the MAL block

The catalog relations should be maintained in a MAL box, which
provides the handle for transaction management.
@-
The atoms produced by the parser should be converted back into
MAL constants. Ideally, this should not be necessary when the
SQL parser keeps the string representation around.
This involves regeneration of their string as well and
trimming the enclosing string quotes.
@c
static
int constantAtom(backend *sql, MalBlkPtr mb, atom *a){
	int idx;
	ValPtr vr=  (ValPtr) &a->data;
	char * val;
	(void) sql;

	VALformat(&val,vr);
	if( vr->vtype == TYPE_str ){
		val[strlen(val)-1]=0;
		idx= newConstant(mb,vr->vtype,GDKstrdup(val+1),1);
		GDKfree(val);
	} else	idx= newConstant(mb,vr->vtype,val,1);
	return idx;
}
@-
Instructions are encapsulated with time code.
@= SQLprelude
        if (sql->debug&2){
		/* t0:= time(); printf(" %d ",t0); */
		q= newStmtId(mb, "t0","alarm","usec");
		q= newStmt(mb,"io","printf");
		q= pushStr(mb,q," %d ");
		q= pushArgumentId(mb,q,"t0");
        }

@= SQLpostlude
        if (sql->debug&2){
		/* t1 := time();t1:= t1-t0; 
		   printf(" %d ",t1);printf("%d\n",nr);*/
		q= newStmtId(mb,"t1","alarm","usec");
		q= newStmtId(mb,"t1","calc","-");
		q= pushArgumentId(mb,q,"t1");
		q= pushArgumentId(mb,q,"t0");
		q= newStmt(mb,"io","printf");
		q= pushStr(mb,q," %d ");
		q= pushArgumentId(mb,q,"t1");
		q= newStmt(mb,"io","printf");
		q= pushStr(mb,q," %d \n");
		q= pushArgumentId(mb,q,"nr");
        }
@-
The dump_header produces a sequence of instructions for
the front-end to prepare presentation of a result table.
@c
void dump_header(MalBlkPtr mb, stmt *s, list *l ){
        node *n;
	InstrPtr q;
	int old;


        for (n=l->h; n; n = n->next){
                char *name ;
                s = n->data;
		old= s->nr;	/* s is mis-used in next macro */
		name= column_name(s);

		q= newStmt(mb,"sql","column");
		q= pushArgument(mb,q,old);
		q= pushStr(mb,q,name);
		q= pushStr(mb,q,tail_type(s)->type->sqlname);
		q= pushInt(mb,q,tail_type(s)->digits);
		q= pushInt(mb,q,tail_type(s)->scale);
		s->nr= old;
        }
}
@-
Some utility routines to generate code
@c
void dump_1(backend *sql, MalBlkPtr mb, stmt *s, char *mod, char *name){
	InstrPtr q;
	int o1 = backend_dumpstmt(sql,mb, s->op1.stval);
	@:SQLprelude@
	q= newStmt(mb,mod,name);
	q= pushArgument(mb,q,o1);
	s->nr = getDestVar(q);
	@:SQLpostlude@
}
void dump_2(backend *sql, MalBlkPtr mb, stmt *s, char *mod, char *name){
	InstrPtr q;
	int o1 = backend_dumpstmt(sql,mb, s->op1.stval);
	int o2 = backend_dumpstmt(sql,mb, s->op2.stval);
	@:SQLprelude@
	q= newStmt(mb,mod,name);
	q= pushArgument(mb,q,o1);
	q= pushArgument(mb,q,o2);
	s->nr = getDestVar(q);
	@:SQLpostlude@
}
@-
The big code generation switch. The sections are aligned to the
Monet version4 code generation block for ease of comparison.
@c
int backend_dumpstmt(backend *sql, MalBlkPtr mb, stmt *s){
    InstrPtr q = NULL;
    node *n;

    if (s){
    	if (s->nr > 0) 
		return s->nr;	/* stmt already handled */

	switch(s->type){
	case st_none: 
		q= newAssignment(mb);
		q= pushStr(mb,q,"none");
		q= pushStr(mb,q,"none");
		s->nr = getDestVar(q);
		break;
	case st_sql:{
		int o1 = backend_dumpstmt(sql,mb,s->op1.stval);
		q= newStmt(mb,"sql","eval");
		s->nr = getDestVar(q);
		q= pushArgument(mb,q,o1);
		} break;
        case st_var: {
                int val = backend_dumpstmt(sql,mb, s->op2.stval);
		q= newAssignment(mb);
		q= pushArgumentId(mb,q,s->op1.sval);
		q= pushArgument(mb,q,val);
		s->nr = getDestVar(q);
        }       break;
	case st_update_var:{
		dump_1(sql,mb,s,"sql","update_var");
		} break;
	case st_temp: {
		int l,r;
		q= newStmt(mb,"bat","new");
		q= pushArgumentId(mb,q,"void");
		q= pushArgumentId(mb,q,s->op4.typeval->type->base.name);
		l= getDestVar(q);
		q= newStmt(mb,"calc","oid");
		q= pushInt(mb,q,0);
		r= getDestVar(q);
		q= newStmt(mb,"bat","seqbase");
		q= pushArgument(mb,q,l);
		q= pushArgument(mb,q,r);
		s->nr = getDestVar(q);
	} break;
	case st_ibat: 
		s->nr = backend_dumpstmt(sql,mb, s->op1.stval);
		break;
	case st_bat:
	case st_ubat: {
		char *type = (s->type==st_bat)?"":"_ubat";
		char buf[256];
		int k;

		@:SQLprelude@
		snprintf(buf,256,"bind%s",type);
		q= newStmt(mb,"sql",buf);
		q= pushStr(mb,q,s->op1.cval->t->s->base.name);
		q= pushStr(mb,q,s->op1.cval->t->base.name);
		q= pushStr(mb,q,s->op1.cval->base.name);
		q= pushInt(mb,q,s->flag);
		k= getDestVar(q);
		s->nr= k;

		if( s->flag >RDONLY) {
			q= newStmt(mb,"bat","setWriteMode");
			q= pushArgument(mb,q,k);
		} 
		@:SQLpostlude@
	} break;
	case st_dbat: {
		int k;
		@:SQLprelude@
		q= newStmt(mb,"sql","bind_dbat");
		q= pushStr(mb,q,s->op1.tval->s->base.name);
		q= pushStr(mb,q,s->op1.tval->base.name);
		q= pushInt(mb,q,s->flag);
		k= getDestVar(q);
		s->nr= k;

		if( s->flag >RDONLY) {
			q= newStmt(mb,"bat","setWriteMode");
			q= pushArgument(mb,q,k);
		}
		@:SQLpostlude@
	} break;
	case st_idxbat:{
		int k;

		@:SQLprelude@
		q= newStmt(mb,"sql","bind_ibat");
		q= pushStr(mb,q,s->op1.idxval->t->s->base.name);
		q= pushStr(mb,q,s->op1.idxval->t->base.name);
		q= pushStr(mb,q,s->op1.idxval->base.name);
		q= pushInt(mb,q,s->flag);
		k= getDestVar(q);
		s->nr= k;

		if( s->flag >RDONLY) {
			q= newStmt(mb,"bat","setWriteMode");
			q= pushArgument(mb,q,k);
		} 
		@:SQLpostlude@
		} break;
	case st_const: {
		dump_2(sql,mb,s,"bbp","project");
		} break;
	case st_mark: {
		dump_2(sql,mb,s,"algebra","mark");
		} break;
	case st_reverse: {
		dump_1(sql,mb,s,"bat","reverse");
		} break;
        case st_mirror: {
		dump_1(sql,mb,s,"bat","mirror");
		} break;
	case st_limit: {
		int l = backend_dumpstmt(sql,mb, s->op1.stval);
		int k;

		@:SQLprelude@
		q= newStmt(mb,"calc","-");
		q= pushArgument(mb,q,l);
		q= pushInt(mb,q,1);
		k= getDestVar(q);

		q= newStmt(mb,"bat","slice");
		q= pushInt(mb,q,0);
		q= pushArgument(mb,q,k);
		s->nr= getDestVar(q);
		@:SQLpostlude@
		break;
	}
	case st_order: {
		int l = backend_dumpstmt(sql,mb, s->op1.stval);
		int k;
		@:SQLprelude@
		q= newStmt(mb,"bat","reverse");
		q= pushArgument(mb,q,l);
		k= getDestVar(q);

		if( s->flag) {
			q= newStmt(mb,"algebra","sort");
		} else {
			q= newStmt(mb,"algebra","sort_reverse");
		}
		q= pushArgument(mb,q,k);
		k= getDestVar(q);

		q= newStmt(mb,"bat","reverse");
		s->nr= getDestVar(q);
		q= pushArgument(mb,q,k);
		@:SQLpostlude@
	} 	break;
	case st_reorder: {
		int l = backend_dumpstmt(sql,mb, s->op1.stval);
		int r = backend_dumpstmt(sql,mb, s->op2.stval);
		@:SQLprelude@
		if( s->flag){
			q= newStmt(mb,"group","refine");
		} else {
			q= newStmt(mb,"group","refine_reverse");
		}
		q= pushArgument(mb,q,l);
		q= pushArgument(mb,q,r);
		@:SQLpostlude@
	} 	break;

	case st_uselect:
	case st_select: {
		int l = backend_dumpstmt(sql,mb, s->op1.stval);
		int r = backend_dumpstmt(sql,mb, s->op2.stval);
		int k;

		char *cmd = s->type == st_select? "select":"uselect";

		@:SQLprelude@
		if (s->op2.stval->nrcols >= 1){
			char *op = "=";
			int k;

			switch(s->flag){
			case cmp_equal: op = "="; break;
			case cmp_notequal: op = "!="; break;
			case cmp_lt: op = "<"; break;
			case cmp_lte: op = "<="; break;
			case cmp_gt: op = ">"; break;
			case cmp_gte: op = ">="; break;
			default:
				GDKerror("Unknown operator");
	  		} 
			q= newStmt(mb,"multiplex","tactics");
			q= pushStr(mb,q,op);
			q= pushArgument(mb,q,l);
			q= pushArgument(mb,q,r);
			k= getDestVar(q);
			q= newStmt(mb,"algebra","uselect");
			q= pushArgument(mb,q,k);
			q= pushBit(mb,q,"true");
		} else {
		switch(s->flag){
		case cmp_like:{
			q= newStmt(mb,"algebra","likeselect");
			q= pushArgument(mb,q,l);
			q= pushArgument(mb,q,r);
			@:SQLpostlude@
			break;
			}
		case cmp_notlike:{
			int k;
			q= newStmt(mb,"algebra","likeselect");
			q= pushArgument(mb,q,l);
			q= pushArgument(mb,q,r);
			k= getDestVar(q);
			q= newStmt(mb,"algebra"," kdiff");
			q= pushArgument(mb,q,l);
			q= pushArgument(mb,q,k);
			@:SQLpostlude@
			break;
			}
		case cmp_equal:{
			q= newStmt(mb,"algebra",cmd);
			q= pushArgument(mb,q,l);
			q= pushArgument(mb,q,r);
			@:SQLpostlude@
			break;
			}
		case cmp_notequal:{
			q= newStmt(mb,"algebra","uselect");
			q= pushArgument(mb,q,l);
			q= pushArgument(mb,q,r);
			k= getDestVar(q);
			q= newStmt(mb,"algebra","kdiff");
			q= pushArgument(mb,q,l);
			q= pushArgument(mb,q,k);
			break;
		}
		case cmp_lt:
			q= newStmt(mb,"calc",tail_type(s)->type->base.name);
			q= pushNilType(mb,q,tail_type(s)->type->base.name);
			k= getDestVar(q);

			q= newStmt(mb,"algebra",cmd);
			q= pushArgument(mb,q,l);
			q= pushArgument(mb,q,k);
			q= pushArgument(mb,q,r);
			q= pushBit(mb,q,"false");
			q= pushBit(mb,q,"false");
			break;
		case cmp_lte:
			q= newStmt(mb,"calc",tail_type(s)->type->base.name);
			q= pushNilType(mb,q,tail_type(s)->type->base.name);
			k= getDestVar(q);

			q= newStmt(mb,"algebra",cmd);
			q= pushArgument(mb,q,l);
			q= pushArgument(mb,q,k);
			q= pushArgument(mb,q,r);
			@:SQLpostlude@
			break;
		case cmp_gt:
			q= newStmt(mb,"calc",tail_type(s)->type->base.name);
			q= pushNilType(mb,q,tail_type(s)->type->base.name);
			k= getDestVar(q);

			q= newStmt(mb,"algebra",cmd);
			q= pushArgument(mb,q,l);
			q= pushArgument(mb,q,r);
			q= pushArgument(mb,q,k);
			q= pushBit(mb,q,"false");
			q= pushBit(mb,q,"false");
			break;
		case cmp_gte: 
			q= newStmt(mb,"calc",tail_type(s)->type->base.name);
			q= pushNilType(mb,q,tail_type(s)->type->base.name);
			k= getDestVar(q);

			q= newStmt(mb,"algebra",cmd);
			q= pushArgument(mb,q,l);
			q= pushArgument(mb,q,r);
			q= pushArgument(mb,q,k);
			break;
		default:
			GDKerror("SQL2MAL: error impossible\n");
	  	} 
		}
		@:SQLpostlude@
	} break;
	case st_uselect2: 
	case st_select2: {
		int l = backend_dumpstmt(sql,mb, s->op1.stval);
		int r1 = backend_dumpstmt(sql,mb, s->op2.stval);
		int r2 = backend_dumpstmt(sql,mb, s->op3.stval);
		char *cmd= st_uselect2== s->type? "uselect":"select";

		@:SQLprelude@
		q= newStmt(mb,"algebra",cmd);
		q= pushArgument(mb,q,l);
		q= pushArgument(mb,q,r1);
		q= pushArgument(mb,q,r2);

		switch(s->flag){
		case 0:
			q= pushBit(mb,q,"false");
			q= pushBit(mb,q,"false");
			break;
		case 1:
			q= pushBit(mb,q,"false");
			q= pushBit(mb,q,"true");
			break;
		case 2:
			q= pushBit(mb,q,"true");
			q= pushBit(mb,q,"false");
			break;
		case 3:
			q= pushBit(mb,q,"true");
			q= pushBit(mb,q,"true");
			break;
		}
		s->nr= getDestVar(q);
		@:SQLpostlude@
	} break;
	case st_semijoin: {
		dump_2(sql,mb,s,"algebra","semijoin");
	} break;
	case st_diff: {
		dump_2(sql,mb,s,"algebra","kdiff");
	} break;
	case st_union: {
		dump_2(sql,mb,s,"algebra","kunion");
	} break;
        case st_reljoin: {
                node *ln = NULL, *rn = NULL;
		@:SQLprelude@
		if( list_length(s->op1.lval)== 1){
			int l = backend_dumpstmt(sql,mb, s->op1.lval->h->data);
			int r = backend_dumpstmt(sql,mb, s->op2.lval->h->data);
			int k;
	
			q= newStmt(mb,"bat","reverse");
			q= pushArgument(mb,q,r);
			k= getDestVar(q);
			q= newStmt(mb,"algebra","join");
			q= pushArgument(mb,q,l);
			q= pushArgument(mb,q,k);
		} else {
			q= newStmt(mb,"algebra","ds_link");
			for (ln = s->op1.lval->h, rn = s->op2.lval->h; 
				ln && rn; ln = ln->next, rn = rn->next) {
				int l = backend_dumpstmt(sql,mb, ln->data);
				int r = backend_dumpstmt(sql,mb, rn->data);
				q= pushArgument(mb,q,l);
				q= pushArgument(mb,q,r);
			}
		}
		s->nr= getDestVar(q);
		@:SQLpostlude@
        } break;
	case st_outerjoin:
	case st_join: {
		int l = backend_dumpstmt(sql,mb, s->op1.stval);
		int r = backend_dumpstmt(sql,mb, s->op2.stval);
		char *jt = "join";
		@:SQLprelude@
		if (s->type == st_outerjoin)
			jt = "outerjoin";
		switch(s->flag){
		case cmp_equal:
			q= newStmt(mb,"algebra",jt);
			q= pushArgument(mb,q,l);
			q= pushArgument(mb,q,r);
			@:SQLpostlude@
			break;
		case cmp_notequal:
			q= newStmt(mb,"algebra",jt);
			q= pushArgument(mb,q,l);
			q= pushArgument(mb,q,r);
			q= pushStr(mb,q,"!=");
			@:SQLpostlude@
			break;
		case cmp_lt:
			q= newStmt(mb,"algebra",jt);
			q= pushArgument(mb,q,l);
			q= pushArgument(mb,q,r);
			q= pushStr(mb,q,"<");
			@:SQLpostlude@
			break;
		case cmp_lte: 
			q= newStmt(mb,"algebra",jt);
			q= pushArgument(mb,q,l);
			q= pushArgument(mb,q,r);
			q= pushStr(mb,q,"<=");
			@:SQLpostlude@
			break;
		case cmp_gt: 
			q= newStmt(mb,"algebra",jt);
			q= pushArgument(mb,q,l);
			q= pushArgument(mb,q,r);
			q= pushStr(mb,q,">");
			@:SQLpostlude@
			break;
		case cmp_gte: 
			q= newStmt(mb,"algebra",jt);
			q= pushArgument(mb,q,l);
			q= pushArgument(mb,q,r);
			q= pushStr(mb,q,">=");
			@:SQLpostlude@
			break;
		case cmp_all: /* aka cross table */
			{ int z;

			q= newStmt(mb,"bat","reverse");
			q= pushArgument(mb,q,r);
			r= getDestVar(q);

			q= newStmt(mb,"calc","int");
			q= pushInt(mb,q,0);
			z= getDestVar(q);

			q= newStmt(mb,"bbp","project");
			q= pushArgument(mb,q,r);
			q= pushInt(mb,q,z);
			r= getDestVar(q);

			q= newStmt(mb,"bat","reverse");
			q= pushArgument(mb,q,r);
			r= getDestVar(q);

			q= newStmt(mb,"bbp","project");
			q= pushArgument(mb,q,l);
			q= pushInt(mb,q,z);
			l= getDestVar(q);

			q= newStmt(mb,"algebra","join");
			q= pushArgument(mb,q,l);
			q= pushArgument(mb,q,r);
			@:SQLpostlude@
			break;
			}
		default:
			GDKerror("SQL2MAL: error impossible\n");
	  	} 
		s->nr= getDestVar(q);
	break;
	}
	case st_group: {
		dump_1(sql,mb,s,"group","group");
	} 	break;
	case st_group_ext: {
		int k, l = backend_dumpstmt(sql,mb, s->op1.stval);
		@:SQLprelude@
		q= newStmt(mb,"algebra","tunique");
		q= pushArgument(mb,q,l);
		k= getDestVar(q);
		q= newStmt(mb,"bat","mirror");
		q= pushArgument(mb,q,k);
		s->nr= getDestVar(q);
		@:SQLpostlude@
	} 	break;
	case st_derive: {
		dump_1(sql,mb,s,"group","derive");
	} 	break;
	case st_unique: {
		int k, l = backend_dumpstmt(sql,mb, s->op1.stval);
		@:SQLprelude@
		if (s->op2.stval){
			int k2, g = backend_dumpstmt(sql,mb, s->op2.gval->grp);

			q= newStmt(mb,"group","group");
			q= pushArgument(mb,q,g);
			q= pushArgument(mb,q,l);
			k= getDestVar(q);

			q= newStmt(mb,"algebra","tunique");
			q= pushArgument(mb,q,k);
			k2= getDestVar(q);

			q= newStmt(mb,"algebra","mirror");
			q= pushArgument(mb,q,k2);
			k2= getDestVar(q);

			q= newStmt(mb,"algebra","semijoin");
			q= pushArgument(mb,q,l);
			q= pushArgument(mb,q,k2);
		} else {
			q= newStmt(mb,"bat","reverse");
			q= pushArgument(mb,q,l);
			k= getDestVar(q);
			q= newStmt(mb,"algebra","kunique");
			q= pushArgument(mb,q,k);
			k= getDestVar(q);
			q= newStmt(mb,"bat","reverse");
			q= pushArgument(mb,q,k);
		}
		s->nr= getDestVar(q);
		@:SQLpostlude@
	} 	break;
	case st_op: {
		@:SQLprelude@
		q= newStmt(mb,NULL,s->op4.funcval->func->imp);
		s->nr= getDestVar(q);
		@:SQLpostlude@
		break;
	}
	case st_unop: {
		int l = backend_dumpstmt(sql,mb, s->op1.stval);
		@:SQLprelude@
		if (s->op1.stval->nrcols){
			sql_subtype *v,*a;
			a = tail_type(s);
			v= tail_type(s->op1.stval);
			if( a->type->localtype == v->type->localtype &&
			    strcmp(s->op4.funcval->func->name,"convert")==0){
				q= newAssignment(mb);
				s->nr = getDestVar(q);
				q= pushArgument(mb,q,l);
			} else {
				q= newStmt(mb,NULL,s->op4.funcval->func->imp);
				q= pushArgument(mb,q,l);
			}
		} else {
			q= newStmt(mb,NULL, s->op4.funcval->func->imp);
			q= pushArgument(mb,q,l);
		}
		s->nr= getDestVar(q);
		@:SQLpostlude@
	} 	break;
	case st_binop: {
		int l = backend_dumpstmt(sql,mb, s->op1.stval);
		int r = backend_dumpstmt(sql,mb, s->op2.stval);
		@:SQLprelude@
		if (s->op1.stval->nrcols || s->op2.stval->nrcols ){
			q= newStmt(mb,"multiplex","tactics");
			q= pushStr(mb,q,s->op4.funcval->func->imp);
			q= pushArgument(mb,q,l);
			q= pushArgument(mb,q,r);
		} else  {
			q= newStmt(mb,"multiplex", s->op4.funcval->func->imp);
			q= pushArgument(mb,q,l);
			q= pushArgument(mb,q,r);
		}
		s->nr= getDestVar(q);
		@:SQLpostlude@
	} 	break;
	case st_Nop: {
		int opslen=0,i;
		int ops[MAXARG];
		node *n;

		stmt *op1 = s->op1.lval->h->data;
		int l = backend_dumpstmt(sql,mb, op1);
		@:SQLprelude@
		if (s->nrcols ){
			stmt *h;
			for (n=s->op1.stval->op1.lval->h, h=n->data; n; n=n->next){
				stmt *op = n->data;
				if (op->nrcols > h->nrcols)
					h = op;
			}

                        for (n = s->op1.stval->op1.lval->h; n; n=n->next){
                            stmt *op = n->data;
                            int n = op->nr;
                            if (!op->nrcols){
				q= newStmt(mb,"batcalc","zipper");
				q= pushArgument(mb,q,l);
				q= pushArgument(mb,q,n);
				ops[opslen++]= getDestVar(q);
                            }
                        }

			q= newStmt(mb,"multiplex","tactics");
			q= pushStr(mb,q,s->op4.funcval->func->imp);
			for(i=0;i<opslen;i++){
				q= pushArgument(mb,q,ops[i]);
			}
		} else {
			q= newStmt(mb,NULL,s->op4.funcval->func->imp);
			for (n = s->op1.stval->op1.lval->h; n; n=n->next){
				stmt *op = n->data;
				int n = op->nr;
				q= pushArgument(mb,q,n);
			}
		}
		s->nr= getDestVar(q);
		@:SQLpostlude@
	} 	break;
	case st_aggr: {
		int l = backend_dumpstmt(sql,mb, s->op1.stval);

		@:SQLprelude@
		if (s->op3.gval){
			int g = backend_dumpstmt(sql,mb, s->op2.stval);
			int e = backend_dumpstmt(sql,mb, s->op3.stval);
			q= newStmt(mb,"multiplex","group");
			q= pushStr(mb,q,s->op4.aggrval->aggr->imp);
			q= pushArgument(mb,q,l);
			q= pushArgument(mb,q,g);
			q= pushArgument(mb,q,e);
		} else {
			q= newStmt(mb,NULL,s->op4.aggrval->aggr->imp);
			q= pushArgument(mb,q,l);
		}
		s->nr= getDestVar(q);
		@:SQLpostlude@
	} 	break;
	case st_atom: {
		if( s->op1.aval->isnull){
			q= newStmt(mb,"calc",s->op1.aval->tpe->type->base.name);
			q= pushNilType(mb,q,s->op1.aval->tpe->type->base.name);
			s->nr= getDestVar(q);
		} else {
			s->nr= constantAtom(sql,mb,s->op1.aval);
		}
	} break;
	case st_insert: {
		int l = backend_dumpstmt(sql,mb, s->op1.stval);
		int r = backend_dumpstmt(sql,mb, s->op2.stval);
		@:SQLprelude@
		if (s->op2.stval->nrcols){
			q= newStmt(mb,"bat","setWriteMode");
			q= pushArgument(mb,q,l);
			q= newStmt(mb,"bat","insert");
			q= pushArgument(mb,q,l);
			q= pushArgument(mb,q,r);
			s->nr= l;
		} else {
			q= newStmt(mb,"bat","insert");
			q= pushArgument(mb,q,l);
			q= pushArgument(mb,q,r);
			s->nr= l;
		}
		@:SQLpostlude@
	} break;
	case st_append:{
                int l = backend_dumpstmt(sql, mb, s->op1.stval);
                int r = backend_dumpstmt(sql, mb, s->op2.stval );
		q= newStmt(mb,"bat","setWriteMode");
		q= pushArgument(mb,q,l);
		q= newStmt(mb,"bat","append");
		q= pushArgument(mb,q,l);
		q= pushArgument(mb,q,r);
		s->nr= getDestVar(q);
		@:SQLpostlude@
	} break;
	case st_replace: {
		int l = backend_dumpstmt(sql,mb, s->op1.stval);
		int r = backend_dumpstmt(sql,mb, s->op2.stval);
		@:SQLprelude@
		q= newStmt(mb,"bat","setWriteMode");
		q= pushArgument(mb,q,l);
		q= newStmt(mb,"bat","replace");
		q= pushArgument(mb,q,l);
		q= pushArgument(mb,q,r);
		s->nr= getDestVar(q);
		@:SQLpostlude@
	} break;
	case st_exception:{
		int l = backend_dumpstmt(sql,mb, s->op1.stval);
		int r = backend_dumpstmt(sql,mb, s->op2.stval);
		@:SQLprelude@
		/* if(bit(l)) { error(r);}  ==raising an exception*/
		q= newStmt(mb,"sql","assert");
		q= pushArgument(mb,q,l);
		q= pushArgument(mb,q,r);
		s->nr= getDestVar(q);
		@:SQLpostlude@
		break;
	}
	case st_intersect: {
		int l = backend_dumpstmt(sql,mb, s->op1.stval);
		int r = backend_dumpstmt(sql,mb, s->op2.stval);
		@:SQLprelude@
		q= newStmt(mb,"algebra","sintersect");
		q= pushArgument(mb,q,l);
		q= pushArgument(mb,q,r);
		s->nr= getDestVar(q);
		@:SQLpostlude@
	} break;
	case st_alias: 
		s->nr = backend_dumpstmt(sql,mb, s->op1.stval);
		break;
	case st_set: 
	case st_list: {
		for (n = s->op1.lval->h; n; n = n->next ){
			backend_dumpstmt(sql,mb, n->data);
		}
	} break;
	case st_sets: {
		for(n = s->op1.lval->h; n; n = n->next ){
			list *l = n->data;
			node *ml = l->h;
			while(ml){
				backend_dumpstmt(sql,mb, ml->data);
				ml = ml->next;
			}
		}
	} break;
        case st_find: {
		dump_2(sql,mb,s,"algebra","find");
	} break;
       case st_bulkinsert: {
                char *tname = s->op1.stval->op1.tval->base.name;
                int sep =  backend_dumpstmt(sql,mb, s->op2.stval);
                int rsep = backend_dumpstmt(sql,mb, s->op3.stval);

                if (s->op4.stval){
			int file = backend_dumpstmt(sql,mb, s->op4.stval);
			int codeset;
			
			q= newStmt(mb,"str","codeset");
			codeset= getDestVar(q);

			q= newStmt(mb,"str","iconv");
			q= pushArgument(mb,q,file);
			q= pushStr(mb,q,"UTF-8");
			q= pushArgument(mb,q,codeset);
			file= getDestVar(q);

			/* TODO use a bstream */
			q= newStmt(mb,"io","open_rastream");
			q= pushArgument(mb,q,file);
			file= getDestVar(q);

			q= newStmt(mb,"sql","importTable");
			q= pushArgument(mb,q,file);
			q= pushStr(mb,q,tname);
			q= pushArgument(mb,q,sep);
			q= pushArgument(mb,q,rsep);
			q= pushArgument(mb,q,s->flag);

			q= newStmt(mb,"io","stream_close");
			q= pushArgument(mb,q,file);
                } else {
			q= newStmt(mb,"sql","importTable");
			q= pushStr(mb,q,"Input");
			q= pushStr(mb,q,tname);
			q= pushArgument(mb,q,sep);
			q= pushArgument(mb,q,rsep);
			q= pushArgument(mb,q,s->flag);
                }
		s->nr= getDestVar(q);
        } break;
        case st_filter:
                s->nr = backend_dumpstmt(sql,mb, s->op1.stval);
                break;
	case st_ordered: {
		int l =  backend_dumpstmt(sql,mb, s->op1.stval);
		backend_dumpstmt(sql,mb, s->op2.stval);
		s->nr = l;
	} break;
	case st_output: {
		stmt *order = NULL; int flg=0;
		stmt *lst = s->op1.stval;
		backend_dumpstmt(sql, mb, lst);

		if (lst->type == st_ordered){
			order = lst->op1.stval; 
			lst = lst->op2.stval; 
			flg=1;
		}
		if (lst->type == st_list){
			list *l = lst->op1.lval;

			n = l->h;
			if (n){
			  if (!order){
			    order = n->data;
			  }
			}
			/* first rename the columns for better output*/
			dump_header(mb,s,l);
			q= newStmt(mb,"sql","output");
			if( flg){ 
				q= pushArgument(mb,q,order->nr);
			}

			for(; n; n = n->next){
				stmt *r = n->data;
				q= pushArgument(mb,q,r->nr);
			}
		} else {
			q= newStmt(mb,"sql","print");
			q= pushStr(mb,q,"not a valid output list\n");
		}
	} break;

        /* todo */
        case st_basetable:
        case st_ptable:
        case st_pivot:
	case st_relselect:
	case st_groupby:
                printf("not implemented stmt\n");
                assert(0);


	}
/*	if (s->nr == 0) s->nr = mb->stop;*/
#ifdef _SQL_GENCODE_DEBUG	
    } else {
	printf("called with zero statement nr\n");
#endif
    }
    return s->nr;
}

void backend_dumpproc( backend *be, MalBlkPtr mb, int id, stmt *s )
{
	int i = 0;
	char buf[BUFSIZ];
	node *n;
	
	(void)id;
	/* TODO change mal procs */ 
	if (be->mvc->params){
		for (n = be->mvc->params->h; n; n = n->next){
			var_ *v = n->data;

			i += snprintf(buf+i, BUFSIZ-i, "%s %s%c", 
				v->s->op2.typeval->type->base.name,
				v->name, (n->next)?',':' '
				);
		}
	}
    	backend_dumpstmt( be, mb, s);
}
