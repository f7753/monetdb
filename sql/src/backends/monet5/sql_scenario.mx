@f sql_scenario
@t SQL catalog management
@a N. Nes, M.L. Kersten
@+ SQL scenario
The SQL scenario imlementation is a derivative of the MAL session scenario.

It is also the first version that uses state records attached to
the client record. They are initialized as part of the initialization 
phase of the scenario.

@h
#ifndef _SQL_SCENARIO_H_
#define _SQL_SCENARIO_H_
#include "sql.h"

/* #define _SQL_SCENARIO_DEBUG */
/* #define _SQL_READER_DEBUG */
/* #define _SQL_PARSER_DEBUG  */

sql_export str SQLexitClient(Client c);
sql_export str SQLinitClient(Client c);
sql_export str SQLexit(Client c);
sql_export str SQLinit(Client c);

sql_export str SQLparser(Client c);
sql_export str SQLengine(Client c);

#endif /* _SQL_SCENARIO_H_ */

@+ Scenario routines
Before we are can process SQL statements the global catalogue
should be initialized. Thereafter, each time a client enters
we update its context descriptor to denote an SQL scenario.
@c
#include "sql_scenario.h"
#include "sql_gencode.h"

static int SQLinitialized;

str SQLinit(Client c){
#ifdef _SQL_SCENARIO_DEBUG
	stream_printf(GDKout,"SQLinit Monet 5\n");
#endif
	if( SQLinitialized ){
		return throwMessage("SQLinit",
			"Catalogue already available\n");
	}
	SQLinitialized= FALSE;
	(void)c; /* not used */
	if( mvc_init(FALSE,0) <0) {
		return throwMessage("SQLinit",
			"Catalogue initialization failed\n");
	}
	SQLinitialized= TRUE;
	return MAL_SUCCEED;
}
str SQLexit(Client c){
#ifdef _SQL_SCENARIO_DEBUG
	stream_printf(GDKout,"SQLexit\n");
#endif
	(void)c; /* not used */
	if( SQLinitialized == FALSE){
		return throwMessage("SQLexit",
			"Catalogue not available\n");
	}
	mvc_exit();
	SQLinitialized= FALSE;
	return MAL_SUCCEED;
}
str SQLinitClient(Client c){
	mvc *m;
	str schema;

#ifdef _SQL_SCENARIO_DEBUG
	stream_printf(GDKout,"SQLinitClient\n");
#endif
	if( SQLinitialized == FALSE){
		return throwMessage("SQLinitClient",
			"Catalogue not available\n");
	}
	if( (backend*) c->state[PARSER] == 0){
		m = mvc_create(0, 0, NULL, c->fdout);
		/* replace user name with client record setting later on */
		schema = mvc_login(m, "monetdb", "monetdb");
		if( !schema){
			return throwMessage("SQLparser","No schema defined\n");
		} else {
			_DELETE(schema);
		}
		c->state[PARSER] = (void*) backend_create(0/*debug*/, m);
		c->state[OPTIMIZE] = m;
	} else {
		m = c->state[OPTIMIZE];
	}
	
	return MAL_SUCCEED;
}
str SQLexitClient(Client c){
#ifdef _SQL_SCENARIO_DEBUG
	stream_printf(GDKout,"SQLexitClient\n");
#endif
	if( SQLinitialized == FALSE){
		return throwMessage("SQLinitClient",
			"Catalogue not available\n");
	}
	if((backend*) c->state[PARSER] && (mvc *) c->state[OPTIMIZE]){
		mvc_destroy((mvc *) c->state[OPTIMIZE]);
		backend_destroy((backend*) c->state[PARSER]);
		/* files are already closed */
		c->state[OPTIMIZE]= NULL;
		c->state[PARSER]= NULL;
	}
	return MAL_SUCCEED;
}
str SQLlanguage(str *ret){
        str msg= MAL_SUCCEED;
        stream_printf(GDKout,"#Continue as SQL session\n");
        msg= setScenario(getClient(),"sql");
        *ret = 0;
        return msg;
}
@-
A statement received internally is simply appended for
execution
@c
str SQLstatement(int *ret, str *cmd){
	Client c;

#ifdef _SQL_READER_DEBUG
	stream_printf(GDKout,"SQLstatement:%s\n",*cmd);
#endif
	c = getClient();
	appendInput(c,*cmd);
	*ret= 0;
	return MAL_SUCCEED;
}
@-
The SQL reader collects a (sequence) of statements from the input
stream, but only when no unresolved 'nxt' character is visible.
In combination with SQLparser this ensures that all statements
are handled one by one.
@c
str SQLreader(Client c){
	int cnt, oldcnt,eof=0;
	lng T0;
	backend *be = ((backend*)c->state[PARSER]);
#ifdef _SQL_READER_DEBUG
	stream_printf(GDKout,"SQLparser: start reading SQL block\n");
#endif
	if( c->mode <= FINISHING)
		return throwMessage("SQLreader","end of SQL input\n");
@- 
Continue processing any left-over input from the previous round.
@c
	while(c->nxt && *c->nxt && isspace((int)*c->nxt)) c->nxt++;
	if( c->nxt && *c->nxt) return 0;

	T0= GDKusec();
	c->prompt= GDKstrdup("sql>");
	c->promptlength= strlen(c->prompt);
	c->nxt=c->input;
	oldcnt= cnt=0;
	while( c->mode > FINISHING && (eof=readClient(c,c->prompt))){
		cnt +=strlen(c->input+oldcnt);
		if( cnt==oldcnt ) break;
		if( c->input[cnt-1]==';') break;
		/* add the newline before reading the next part */
		c->input[cnt]= '\n';
		c->input[cnt+1]= 0;
		c->nxt= c->input+cnt;
		oldcnt=cnt;
	}
	c->input[cnt]= '\n';
	c->input[cnt+1]= 0;
	c->nxt=c->input;

#ifdef _SQL_READER_DEBUG
	stream_printf(GDKout,"SQL blk:%s\n",c->input);
#endif
	if(eof==0 || strncmp(c->nxt,"quit",4)==0) {
		c->mode= FINISHING;
		return throwMessage("SQLreader","end of SQL input\n");
	}
	be->Tread= GDKusec()-T0;
	return 0;
}
@-
The SQL block is stored in the client input buffer, from which it
can be parsed by the SQL parser. The client structure contains
a small table of bounded tables. This should be reset before we
parse a new statement sequence.
@-
Before we parse the sql statement, we look for any variable settings
for specific commands.
The most important one is to prepare code to be handled by the debugger.
The current analysis is simple and fulfills our short-term needs.
A future version may analyse the parameter settings in more detail.
@c

#define skip() while(*c->nxt && isspace(*c->nxt) ) c->nxt++;
#define tst(X) (strncmp(c->nxt,(X),strlen(X))==0 && isspace(c->nxt[strlen(X)]))

enum ex_t {
        ex_none,
        ex_mil,
        ex_sql
};

void SQLsetDebugger(Client c)
{
	InstrPtr q;
	q= newInstruction(ASSIGNsymbol);
	functionId(q)= GDKstrdup("showFunction");
	pushInstruction(c->curprg->def,q);
	q= newInstruction(ASSIGNsymbol);
	functionId(q)= GDKstrdup("mdb");
	q= pushArgument(c->curprg->def,q,
		     newConstant(c->curprg->def,TYPE_bit,
			       GDKstrdup("true"),0));
	pushInstruction(c->curprg->def,q);
}
void SQLsetTrace(Client c, int on){
	if(on)
		c->listing = (c->listing & LIST_INPUT) | LIST_MAL_INSTR;
	else	c->listing &= LIST_INPUT;
}
void SQLsetExplain(Client c){
	c->listing = (c->listing & LIST_INPUT) | LIST_MAL_ALL;
}
@-
Analyse the flags and prepare the execution context
@c
int SQLsetEnvironment(Client c){
        (void) c;
        /* test flags and react accordingly */
        return 0;
}
@-
The core part of the SQL interface, parse the query and
prepare the intermediate code.
@c
#define explainMAL() (be->mvc->explain && \
	strcmp(be->mvc->explain, "mal") == 0)
#define explainSQL() (be->mvc->explain && \
	strcmp(be->mvc->explain, "sql") == 0)

str SQLparser(Client c) {
	str msg=0;
	int debug=0, err=0,cache= 0,len;
	backend *be;
	MalBlkRecord oldstate;
	lng T0;
	InstrPtr q;

	oldstate= *c->curprg->def;
#ifdef _SQL_PARSER_DEBUG
	stream_printf(GDKout,"SQL compilation %s\n",c->nxt);
#endif
	debug= SQLsetEnvironment(c);
	be = ((backend*)c->state[PARSER]);
	/* input string is copied to the SQL structure for parsing */
	scanner_reset(&be->mvc->scanner, _strdup(c->nxt));

        be->mvc->type = Q_PARSE;

        cache = be->mvc->cache;

        if (!be->mvc->trans)
                mvc_trans(be->mvc);

	T0 = GDKusec();

        if ((err = sqlparse(be->mvc)) ||
            /* Only forget old errors on transaction boundaries */
            (mvc_status(be->mvc) && be->mvc->type != Q_TRANS) || 
	    !be->mvc->sym) {
                if (!err)
                        err = mvc_status(be->mvc);
		stream_printf(c->fdout,"#%s\n", be->mvc->errstr);
		*be->mvc->errstr=0;
		msg= throwMessage("SQLparser","Parser errors\n");
                sqlcleanup(be->mvc, err, cache);
        }
	len= strlen(be->mvc->scanner.buf);
	c->nxt +=len;
@-
We have dealt with the first parsing step and advanced the input reader
to the next statement (if any).
Now is the time to also perform the semantic analysis, optimize and produce code.
@c
	if( err == 0){
                stmt *s = sql_symbol2stmt(be->mvc);

                if (!s && mvc_status(be->mvc)){
                        err = mvc_status(be->mvc);
			stream_printf(c->fdout,"#%s\n", be->mvc->errstr);
			*be->mvc->errstr=0;
                        sqlcleanup(be->mvc, err, cache);
			msg= throwMessage("SQLparser","Semantic errors\n");
			goto finalize;
                }
                assert(s);
		/* generate MAL code */
		if (!be->mvc->cache) {
			backend_dumpstmt( be, c->curprg->def,s );
		} else {
			backend_dumpproc( be, c->curprg->def, 
					  be->mvc->qc->id, s );
		}
	} 
#ifdef _SQL_PARSER_DEBUG
	else stream_printf(GDKout,"parse result %d\n",err);
#endif
@-
In the final phase we add any debugging control
@c
	/* turn off debugger */
	if(debug){
		q= newInstruction(ASSIGNsymbol);
		functionId(q)= GDKstrdup("mdb");
		q= pushArgument(c->curprg->def,q,
			     newConstant(c->curprg->def,TYPE_bit,
				       GDKstrdup("false"),0));
		pushInstruction(c->curprg->def,q);
	}
@-
During the execution of the query exceptions can be raised.
The default action is to print them out at the end of the
query block.
@c
	if( err ==0 ){
		pushCatchDefault(c->curprg->def,"sqlerror");
		pushEndInstruction(c->curprg->def);
		chkProgram(c->nspace, c->curprg->def);
		if( c->curprg->def->errors){
			showErrors(c);
			/* restore the state */
			if( c->listing || explainMAL())
				printFunction(c->fdout,c->curprg->def, c->listing);
			resetInstructions(c->curprg->def,oldstate.stop);
			resetVariables(c->curprg->def, c->glb, oldstate.vtop);
			c->curprg->def->errors=0;
			msg= throwMessage("SQLparser","Semantic errors\n");
			stream_flush(c->fdout);
			return msg;
		}
	}
finalize:
	if( explainMAL()){
		printFunction(c->fdout,c->curprg->def, c->listing);
	} 
#ifdef _SQL_PARSER_DEBUG
	else {
	printf("SQL finished:%s\n",msg);
	printFunction(c->fdout,c->curprg->def, c->listing);
	}
#endif
	stream_flush(c->fdout);
@-
Gather the statistics for post analysis. It should preferrable
be stored in an SQL table
@c
        if (explainSQL()){
		char safe = *c->nxt;
		*c->nxt=0;
		be->qry= GDKstrdup(c->nxt-len);
		be->Tparse= GDKusec()-T0;
		*c->nxt=safe;
	}
		
	return msg;
}
@-
Execution of the SQL program is delegated to the MALengine.
@c
str SQLengine(Client c) {
	str msg =MAL_SUCCEED;
	MalStkPtr oldglb= c->glb;
	backend *be= ((backend*)c->state[PARSER]);
	lng T0;

	if( c->curprg->def->errors)
		return throwMessage("SQLengine","Program contains errors\n");
#ifdef SQL_SCENARIO_DEBUG
	stream_printf(GDKout,"Ready to execute SQL statement\n");
#endif
	T0= GDKusec();
	c->glb= 0;
	msg= MALengine(c);
	c->glb= oldglb;
	if( explainSQL()){
		lng tot= be->Tparse;
		int ret;
		char buf[BUFSIZ], *stmt= buf, *qs, *t, *lim=buf+BUFSIZ;

		tot+= be->Texec = GDKusec()-T0;
		snprintf(buf, BUFSIZ, "%s","set explain='none';insert into history values(now,'");
		qs= be->qry;
		for(t= buf+strlen(buf);*qs &&  t<lim-4; t++){
			if( *qs== '\n') {qs++; continue;}
			if( *qs=='\'') { *t++= '\\'; *t++= '\\'; *t++= '\\';}
			*t= *qs++;
		}
		*t=0;
		ret= strlen(buf);
		snprintf(buf+ret, BUFSIZ-ret, "',%ld,0,%ld,%ld,USER);set explain='sql';\n", 
			be->Tparse, be->Texec, tot);
@-
This code causes a recursion, because the reset of the explain
triggers the history action. A better approach is to directly
update the history tables, without SQL intervention.
Then the SQL history table is just a view over a few basic bats.
@c
		printf("#%s [parse %d]",be->qry,be->Tparse);
		printf("[engine %d]",be->Texec);
		printf("[total %d]\n",tot);
		if( be->qry) GDKfree(be->qry);
		be->qry= NULL;
		(void) stmt;
		/* DELAY SQLstatement(&ret,&stmt); */
	}
	return msg;
}
@-
The SQL front-end required some IO utilities, that may go beyond the
primitives avaiable in the io.mx module.
@c
str SQLheader(int *ret,int *i){
	/*return throwMessage("SQLheader","Not yet defined\n");*/
	(void)ret; (void)i; /* unused */
	return MAL_SUCCEED;
}

extern str BKCsetRole(int *r, int *bid, str *hname, str *tname);

str SQLcolumn(int *ret, int *bid, str *v, str *t, int *digits, int *scale){
	(void)digits; (void)scale; /* unused */
	BKCsetRole(ret,bid,t,v);
	return MAL_SUCCEED;
}
str SQLcolumnsingle(int *ret, int *cnr, str *v, str *t, int *digits, int *scale){
	(void)ret; (void)cnr; (void)v; (void)t; (void)digits; (void)scale;
	/* do nothing for the time being, later, package it as a table */
	return MAL_SUCCEED;
}

str SQLoutput(MalBlkPtr mb, MalStkPtr stk, InstrPtr p){
	int i;
	if( p->argc==2)
		IOprintBoth(mb,stk,p,1,"[ "," ]\n");
	else {
		IOprintBoth(mb,stk,p,1,"[ ",0);
		for(i=2; i<p->argc-2;i++)
			IOprintBoth(mb,stk,p,i,", ",0);
		IOprintBoth(mb,stk,p,i,", ", "]\n");
	}
	return MAL_SUCCEED;
}
str SQLoutputBats(MalBlkPtr mb, MalStkPtr stk, InstrPtr p){
        IOtableAll(GDKout,mb,stk,p,1,0,FALSE);
	return MAL_SUCCEED;
}
@-
Errors detected during the execution of a code block
raises an exception.
@c
str SQLerror(int *ret, int *bit, str *msg){
	(void) ret;
	if( *bit)
		return throwMessage("sqlerror",msg);
	return MAL_SUCCEED;
}
@mal
# nothing special to do
