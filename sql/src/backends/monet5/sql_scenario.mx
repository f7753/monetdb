@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2004 CWI.
@' All Rights Reserved.

@f sql_scenario
@t SQL catalog management
@a N. Nes, M.L. Kersten
@+ SQL scenario
The SQL scenario implementation is a derivative of the MAL session scenario.

It is also the first version that uses state records attached to
the client record. They are initialized as part of the initialization 
phase of the scenario.

@h
#ifndef _SQL_SCENARIO_H_
#define _SQL_SCENARIO_H_
#include "sql.h"

/* #define _SQL_SCENARIO_DEBUG */
/* #define _SQL_READER_DEBUG */
/* #define _SQL_PARSER_DEBUG  */

sql_export str SQLexitClient(Client c);
sql_export str SQLinitClient(Client c);
sql_export str SQLexit(Client c);
sql_export str SQLinit(Client c);

sql_export str SQLparser(Client c);
sql_export str SQLengine(Client c);

#endif /* _SQL_SCENARIO_H_ */

@+ Scenario routines
Before we are can process SQL statements the global catalog
should be initialized. Thereafter, each time a client enters
we update its context descriptor to denote an SQL scenario.
@c
#include "sql_scenario.h"
#include "sql_gencode.h"
#include "sql_optimizer.h"
#include "sql_cache.h"
#include "sql_env.h"
#include "io.h"
#include "mal_parser.h"

static void pushCatchDefault(MalBlkPtr mb, str nme,int autocommit);

static int SQLinitialized;

static void 
monet5_freestack( backend_stack stk)
{
	(void) stk;
#ifdef _SQL_SCENARIO_DEBUG
	stream_printf(GDKout,"#monet5_freestack\n");
#endif
}

static void 
monet5_parse( backend_stack stk, char *cmd)
{
	(void) stk; (void) cmd;
#ifdef _SQL_SCENARIO_DEBUG
	stream_printf(GDKout,"#monet5_parse:%s\n",cmd);
#endif
}

static void 
monet5_freecode(backend_code code, backend_stack stk, int nr)
{
	(void) code; (void) stk; (void)nr;
#ifdef _SQL_SCENARIO_DEBUG
	stream_printf(GDKout,"#monet5_free:%d\n",nr);
#endif
}
	
str SQLinit(Client c){
#ifdef _SQL_SCENARIO_DEBUG
	stream_printf(GDKout,"#SQLinit Monet 5\n");
#endif
	if( SQLinitialized ){
		return throwMessage("SQLinit",
			"Catalogue already available\n");
	}
	SQLinitialized= FALSE;
	(void)c; /* not used */
	backend_init( &monet5_freestack, &monet5_freecode, &monet5_parse );
	if( mvc_init(FALSE,0) <0) {
		return throwMessage("SQLinit", "Catalogue initialization failed\n");
	}
	SQLinitialized= TRUE;
	return MAL_SUCCEED;
}
str SQLexit(Client c){
#ifdef _SQL_SCENARIO_DEBUG
	stream_printf(GDKout,"#SQLexit\n");
#endif
	(void)c; /* not used */
	if( SQLinitialized == FALSE){
		return throwMessage("SQLexit",
			"Catalogue not available\n");
	}
	mvc_exit();
	SQLinitialized= FALSE;
	return MAL_SUCCEED;
}

static int
sendProperty(stream *out, char *name, char *value)
{
	if (stream_write(out, "[ \"", 1, 3) != 3)
		return 0;
	while (*name) {
		switch (*name) {
		case '"':
			if (stream_write(out, "\\\"", 1, 2) != 2)
				return 0;
			break;
		case '\\':
			if (stream_write(out, "\\\\", 1, 2) != 2)
				return 0;
			break;
		default:
			if (stream_write(out, name, 1, 1) != 1)
				return 0;
			break;
		}
		name++;
	}
	if (stream_write(out, "\", \"", 1, 4) != 4)
		return 0;
	while (*value) {
		switch (*value) {
		case '"':
			if (stream_write(out, "\\\"", 1, 2) != 2)
				return 0;
			break;
		case '\\':
			if (stream_write(out, "\\\\", 1, 2) != 2)
				return 0;
			break;
		default:
			if (stream_write(out, value, 1, 1) != 1)
				return 0;
			break;
		}
		value++;
	}
	if (stream_write(out, "\" ]\n", 1, 4) != 4)
		return 0;
	return 1;
}

str SQLinitClient(Client c){
	mvc *m;
	str schema;

	if (c->yycur) {
		c->fdin->pos += c->yycur;
		c->yycur = 0;
		c->fdin->buf[c->fdin->pos] = 0;
	}
		
#ifdef _SQL_SCENARIO_DEBUG
	stream_printf(GDKout,"#SQLinitClient\n");
#endif

	if( SQLinitialized == FALSE){
		return throwMessage("SQLinitClient",
			"Catalogue not available\n");
	}
	if( (backend*) c->state[PARSER] == 0){
		m = mvc_create(1, 0, c->fdin, c->fdout);
		/* replace user name with client record setting later on */
		schema = mvc_login(m, "monetdb", "monetdb");
		if( !schema){
			return throwMessage("SQLparser","No schema defined\n");
		} else {
			if (!sendProperty(c->fdout, "version", "4.3") ||
	    		!sendProperty(c->fdout, "language", "sql") ||
	    		!sendProperty(c->fdout, "schema", schema) ||
	    		stream_flush(c->fdout) < 0) {
				mvc_destroy(m);
				return throwMessage("SQLparser","Disconnected\n");
			}
			_DELETE(schema);
		}
		c->state[PARSER] = (void*) backend_create(0/*debug*/, m, c);
		c->state[OPTIMIZE] = m;
	} else {
		m = c->state[OPTIMIZE];
	}
	
	c->fdin->eof = 1;		/* force prompt on first iteration */
	return MAL_SUCCEED;
}

str SQLexitClient(Client c)
{
#ifdef _SQL_SCENARIO_DEBUG
	stream_printf(GDKout,"#SQLexitClient\n");
#endif
	if( SQLinitialized == FALSE){
		return throwMessage("SQLinitClient", "Catalogue not available\n");
	}
	if((backend*) c->state[PARSER] && (mvc *) c->state[OPTIMIZE]){
		mvc_destroy((mvc *) c->state[OPTIMIZE]);
		backend_destroy((backend*) c->state[PARSER]);
		/* files are already closed */
		c->state[OPTIMIZE]= NULL;
		c->state[PARSER]= NULL;
	}
	return MAL_SUCCEED;
}

str SQLlanguage(str *ret)
{
	str msg = MAL_SUCCEED;

	stream_printf(GDKout,"#Continue as SQL session\n");
	msg = setScenario(getClient(),"sql");
	*ret = 0;
	return msg;
}
@-
A statement received internally is simply appended for
execution
@c
str SQLstatement(int *ret, str *cmd){
	Client c;

	(void)cmd;
#ifdef _SQL_READER_DEBUG
	stream_printf(GDKout,"#SQLstatement:%s\n",*cmd);
#endif
	c = getClient();
	/*appendInput(c,*cmd);*/
	*ret= 0;
	return MAL_SUCCEED;
}
@-
The SQL reader collects a (sequence) of statements from the input
stream, but only when no unresolved 'nxt' character is visible.
In combination with SQLparser this ensures that all statements
are handled one by one.
@c
str SQLreader(Client c){
	int go = TRUE;
	lng T0;
	backend *be = ((backend*)c->state[PARSER]);
	bstream *in = c->fdin;
	mvc *m;
	int language; 

	assert(be);
	language = be->language; /* 'S' for SQL, 'D' from debugger */

#ifdef _SQL_READER_DEBUG
	stream_printf(GDKout,"#SQLparser: start reading SQL block\n");
#endif
	if (!be || c->mode <= FINISHING)
		return throwMessage("SQLreader","end of SQL input\n");

 	m = be->mvc;
@- 
Continue processing any left-over input from the previous round.
@c
	T0 = GDKusec();
	while (in->pos < in->len && (isspace((int)(in->buf[in->pos])) ||
		   in->buf[in->pos] == ';' ))
		in->pos++;

#ifdef _SQL_READER_DEBUG
	stream_printf(GDKout,"#pos %d len %d\n",in->pos, in->len);
#endif
	if (in->pos >= in->len) {
		ssize_t rd;
		assert(in->pos == in->len);

		if (in->eof || !isa_block_stream(in->s)) {
			language = 0;

			/* auto_commit on end of statement */
			if (m->auto_commit && m->trans) {
	   			if (m->cache && 
				   (m->type == Q_TRANS || 
				    m->type == Q_SCHEMA || 
				    m->qc->id > 100)) {
					if (m->qc) 
						qc_destroy(m->qc);
					m->qc = qc_create();
				}
				if (mvc_commit(m, 0, NULL) < 0) {
					/*
					go = handle_error(m, c->fdout, pstatus);
					*/
				}
			}

			if (go && 
				(stream_write(c->fdout,c->prompt,c->promptlength,1) != 1 ||
				stream_flush(c->fdout)) ) {
				go = FALSE;
			}
			in->eof = 0;
		}
		if (go && (rd = bstream_next(in)) <= 0) {
#ifdef _SQL_READER_DEBUG
	stream_printf(GDKout,"#rd %d  language %d eof %d\n",rd, language, in->eof);
#endif
			if( be->language=='D' && in->eof == 0){
				return 0;
			} 
			if (rd == 0 && language != 0 && in->eof ) {
				/* we hadn't seen the EOF before, so just try again
				(this time with prompt) */
				SQLreader(c);
			} else if( rd == 0 && in->eof==0 ){
                            return 0;
			} else {
				go = FALSE;
			}
		} else if (go && !be->console && language == 0) {
			language = in->buf[in->pos++];
		}
	}
	if( be->language=='D' )
		return 0;

#ifdef _SQL_READER_DEBUG
	stream_printf(GDKout,"#SQL blk:%s\n",in->buf+in->pos);
#endif
	if (!go || (strncmp(CURRENT(c), "quit", 4)==0)) {
		in->pos = in->len; /* skip rest of the input */
		c->mode= FINISHING;
		return throwMessage("SQLreader","end of SQL input\n");
	}
	if (be) 
		be->Tread= GDKusec()-T0;
	return 0;
}
@-
The SQL block is stored in the client input buffer, from which it
can be parsed by the SQL parser. The client structure contains
a small table of bounded tables. This should be reset before we
parse a new statement sequence.
@-
Before we parse the sql statement, we look for any variable settings
for specific commands.
The most important one is to prepare code to be handled by the debugger.
The current analysis is simple and fulfills our short-term needs.
A future version may analyze the parameter settings in more detail.
@c

void SQLsetDebugger(Client c, int onoff)
{
	InstrPtr q;
	mvc *m;

   m = ((mvc*)c->state[OPTIMIZE]);

	if(m == 0 || m->debug==0 )
		return;
	q= newInstruction(ASSIGNsymbol);
	functionId(q)= GDKstrdup("mdb");
	q= pushArgument(c->curprg->def,q, 
	newConstant(c->curprg->def,TYPE_bit,
		GDKstrdup(onoff? "true":"false"),0));
	pushInstruction(c->curprg->def,q);
}

void SQLsetTrace(Client c, int on){
	if(on)
		c->listing = (c->listing & LIST_INPUT) | LIST_MAL_INSTR;
	else	
		c->listing &= LIST_INPUT;
}

void SQLsetExplain(Client c){
	c->listing = (c->listing & LIST_INPUT) | LIST_MAL_ALL;
}

@-
The core part of the SQL interface, parse the query and
prepare the intermediate code.
@c

#define TRANS_ABORTED "!current transaction is aborted (please ROLLBACK)\n"

str SQLparser(Client c) {
	str msg=0;
	int err=0;
	backend *be;
	mvc *m;
	MalBlkRecord oldstate;
	lng T0 = 0;
	int pstatus = 0;

	oldstate= *c->curprg->def;
#ifdef _SQL_PARSER_DEBUG
	stream_printf(GDKout,"#SQL compilation %s\n",c->nxt);
#endif
	SQLsetDebugger(c,TRUE);
	be = ((backend*)c->state[PARSER]);
    if (be == 0) {
    	GDKerror("SQL state descriptor missing\n");
        return throwMessage("SQLparser","State decriptor missing\n");
    }
	m = be->mvc;
	assert(m);
	be->language ='S'; /* expect SQL text first */
	/* input string is copied to the SQL structure for parsing */
	/*
	scanner_reset(&m->scanner, _strdup(c->nxt));
	*/

	m->type = Q_PARSE;

	if (!m->trans)
		mvc_trans(m);

	if (explainPerformance())
		T0 = GDKusec();

	pstatus = m->status;
	if ((err = sqlparse(m)) ||
        /* Only forget old errors on transaction boundaries */
       	(mvc_status(m) && m->type != Q_TRANS) || !m->sym) {
   		if (!err)
        	err = mvc_status(m);
		if (m->type != Q_TRANS && pstatus < 0) {
			stream_write(c->fdout, TRANS_ABORTED, 
					sizeof(TRANS_ABORTED)-1, 1 );
		} else {
			stream_printf(c->fdout,"#%s\n", m->errstr);
		}
		*m->errstr=0;
		sqlcleanup(m, err);
		msg= throwMessage("SQLparser","Parser errors\n");
		goto finalize;
	}
@-
We have dealt with the first parsing step and advanced the input reader
to the next statement (if any).
Now is the time to also perform the semantic analysis, optimize and produce code.
@c
	if (err == 0 &&
	    (!(be->q = qc_match(m->qc, m->sym, m->args, m->scanner.key))) ) {
       stmt *s = sql_symbol2stmt(m);

       if (!s && (err = mvc_status(m)) ){
			stream_printf(c->fdout,"#%s\n", m->errstr);
			*m->errstr=0;
            sqlcleanup(m, err);
			msg= throwMessage("SQLparser","Semantic errors\n");
			goto finalize;
        }
        assert(s);
		/* generate MAL code */
		if (!m->cache) {
			backend_dumpstmt( be, c->curprg->def, s );
		} else {
			/* generate a factory instantiation */
			backend_dumpproc( be, c, m->qc->id, s );
			be->q = qc_insert(
				      m->qc, 
				      m->sym, 	/* the sql symbol tree */
				      m->args,	/* the argument list */
				      m->scanner.key,/* the statement hash key*/
				      m->type,	/* the type of the statement */
				      _strdup("the mal block?") );
			be->q->code = (backend_code)c->curprg;
			m->sym = NULL;
		}
	} 
#ifdef _SQL_PARSER_DEBUG
	else stream_printf(GDKout,"#parse result %d\n",err);
#endif
	if( be->q ) 
		backend_call(be, c, be->q->id, m->args );
@-
In the final phase we add any debugging control
@c
	/* turn off debugger */
	SQLsetDebugger(c,FALSE);

	if (explainPerformance()){
		be->qry= sql_escape(QUERY(m->scanner));
		be->Tparse= GDKusec()-T0;
	}
		
	sqlcleanup(m, err);
@-
During the execution of the query exceptions can be raised.
The default action is to print them out at the end of the
query block.
@c
	if( err ==0 ){
		pushCatchDefault(c->curprg->def,"sqlerror", m->auto_commit);
		pushEndInstruction(c->curprg->def);
		chkProgram(c->nspace, c->curprg->def);
		if( c->curprg->def->errors){
			showErrors(c);
			/* restore the state */
			if( c->listing || explainPlan())
				printFunction(c->fdout,c->curprg->def, c->listing);
			resetInstructions(c->curprg->def,oldstate.stop);
			resetVariables(c->curprg->def, c->glb, oldstate.vtop);
			c->curprg->def->errors=0;
			msg= throwMessage("SQLparser","Semantic errors\n");
		}
	}
finalize:
	if( explainPlan()){
		printFunction(c->fdout,c->curprg->def, c->listing);
	} 
#ifdef _SQL_PARSER_DEBUG
	else {
		stream_printf(GDKout,"#SQL finished:%s\n",msg);
		printFunction(c->fdout,c->curprg->def, c->listing);
	}
#endif
	stream_flush(c->fdout);
@-
Gather the statistics for post analysis. It should preferably
be stored in an SQL table
@c
	return msg;
}
@-
Execution of the SQL program is delegated to the MALengine.
@c
str SQLengine(Client c) {
	str msg =MAL_SUCCEED;
	MalStkPtr oldglb= c->glb;
	backend *be= ((backend*)c->state[PARSER]);
	mvc *m = be->mvc;
	lng T0;

	if( c->curprg->def->errors)
		return throwMessage("SQLengine","Program contains errors\n");
#ifdef SQL_SCENARIO_DEBUG
	stream_printf(GDKout,"#Ready to execute SQL statement\n");
#endif
	T0= GDKusec();
	c->glb= 0;
	be->language = 'D'; /* perhaps we need debugger commands */
	msg= MALengine(c);
@-
Any error encountered during execution should block further processing
unless auto_commit has been set.
@c
	if(c->curprg->def->errors){
		stream_printf(GDKout,"#Execution produced errors");
		sql_error(m,1,"Execution produced errors");
	}
	c->glb= oldglb;
	if( explainPerformance()){
		int ret;
		lng tot= be->Tparse;
		char buf[BUFSIZ], *qs, *stmt = buf;

		tot+= be->Texec = GDKusec()-T0;
		qs= sql_escape(be->qry);
		snprintf(buf, BUFSIZ, 
			"set explain = 'none';"
			"insert into sys.history " 
			"values(now,'%s',%lld,0,%lld,%lld,USER);\n"
			"set explain = 'performance';",
			qs, be->Tparse, be->Texec, tot);
		_DELETE(qs);
@-
This code causes a recursion, because the reset of the explain
triggers the history action. A better approach is to directly
update the history tables, without SQL intervention.
Then the SQL history table is just a view over a few basic bats.
@c
		stream_printf(GDKout,"#%s [parse %d]",be->qry,be->Tparse);
		stream_printf(GDKout,"[engine %d]",be->Texec);
		stream_printf(GDKout,"[total %d]\n",tot);
		if( be->qry) GDKfree(be->qry);
		be->qry= NULL;

		(void)SQLstatement(&ret, &stmt); 
	}

	/*
 	 * clear query cache after Transaction boundaries (commit/rollback)
	 * and on schema changes
	 */
	if (m->cache &&
	   ( m->type == Q_TRANS || m->type == Q_SCHEMA || m->qc->id > 100)) {
		if (m->qc){
			oid id;
			int ret = 0;

			for(id = 0; id < m->qc->id; id++){
				char buf[BUFSIZ], *nme = buf;
				snprintf(buf, BUFSIZ, "sql%d", id);
				SQLCacheRemove(&ret, &nme);
			}
			(void)ret;
			qc_destroy(m->qc);
		}
		m->qc = qc_create();
	}

	return msg;
}
@-
The SQL front-end required some IO utilities, that may go beyond the
primitives available in the io.mx module.
@c
str SQLheader(int *ret,int *i){
	/*return throwMessage("SQLheader","Not yet defined\n");*/
	(void)ret; (void)i; /* unused */
	return MAL_SUCCEED;
}

extern str BKCsetRole(int *r, int *bid, str *hname, str *tname);

str SQLcolumn(int *ret, int *bid, str *v, str *t, int *digits, int *scale){
	(void)digits; (void)scale; /* unused */
	BKCsetRole(ret,bid,t,v);
	return MAL_SUCCEED;
}
str SQLcolumnsingle(int *ret, int *cnr, str *v, str *t, int *digits, int *scale){
	(void)ret; (void)cnr; (void)v; (void)t; (void)digits; (void)scale;
	/* do nothing for the time being, later, package it as a table */
	return MAL_SUCCEED;
}

str SQLoutput(MalBlkPtr mb, MalStkPtr stk, InstrPtr p){
	int i;
	if( p->argc==2)
		IOprintBoth(mb,stk,p,1,"[ "," ]\n");
	else {
		IOprintBoth(mb,stk,p,1,"[ ",0);
		for(i=2; i<p->argc-1;i++)
			IOprintBoth(mb,stk,p,i,", ",0);
		IOprintBoth(mb,stk,p,i,", ", "]\n");
	}
	return MAL_SUCCEED;
}
str SQLoutputBats(MalBlkPtr mb, MalStkPtr stk, InstrPtr p){
        IOprint_tables(mb,stk,p);
	return MAL_SUCCEED;
}
@-
Assertion errors detected during the execution of a code block
raises an exception.
@c
str SQLassert(int *ret, bit *flg, str *msg){
	(void) ret;
	if( *flg)
		return throwException("SQLerror","assert",*msg);
	return MAL_SUCCEED;
}
str SQLassertInt(int *ret, int *flg, str *msg){
	(void) ret;
	if( *flg)
		return throwException("SQLerror","assert",*msg);
	return MAL_SUCCEED;
}
str SQLassertLng(int *ret, lng *flg, str *msg){
	(void) ret;
	if( *flg)
		return throwException("SQLerror","assert",*msg);
	return MAL_SUCCEED;
}
@- Utilities
Catching errors is a recurring situation. The block below 
generates the default code block, ie catch it and print
the error. It should also deal with the auto_commit
situation. [todo]
For the time being we do not catch errors. They are
passed to the environment.
@c
static
void pushCatchDefault(MalBlkPtr mb, str nme, int autocommit){
	InstrPtr p;
/*	int i;*/
        (void) nme;

	if(autocommit){
		p= newInstruction(ASSIGNsymbol);
		moduleId(p)= GDKstrdup("sql");
		functionId(p)= GDKstrdup("commit");
		pushInstruction(mb,p);
	}
/* no catch
	p= newInstruction(CATCHsymbol);
	i= findVariable(mb,nme);
	if( i< 0) i= newVariable(mb,GDKstrdup(nme),TYPE_str);
	getDestVar(p) = i;
	p->argc =1;
	p->retc = 1;
	pushInstruction(mb,p);

	p= newInstruction(ASSIGNsymbol);
	moduleId(p)= GDKstrdup("io");
	functionId(p)= GDKstrdup("print");
	pushArgumentId(mb, p, GDKstrdup(nme));
	pushInstruction(mb,p);
*/

	if(autocommit){
		p= newInstruction(ASSIGNsymbol);
		moduleId(p)= GDKstrdup("sql");
		functionId(p)= GDKstrdup("rollback");
		pushInstruction(mb,p);
	}
/*       else {
		p= newInstruction(RAISEsymbol);
		p->barrier= RAISEsymbol;
		p->argv[0] = findVariable(mb,GDKstrdup("sqlerror"));
		i= newConstant(mb,TYPE_str,GDKstrdup("Transaction abort"),0);
		p= pushArgument(mb,p,i);
		pushInstruction(mb,p);
	}

	p= newInstruction(EXITsymbol);
	p->argv[0] = findVariable(mb,GDKstrdup(nme));
	p->barrier= EXITsymbol;
	pushInstruction(mb,p);
*/
}
@mal
# nothing special to do
