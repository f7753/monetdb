@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2004 CWI.
@' All Rights Reserved.

@f sql_scenario
@t SQL catalog management
@a N. Nes, M.L. Kersten
@+ SQL scenario
The SQL scenario implementation is a derivative of the MAL session scenario.

It is also the first version that uses state records attached to
the client record. They are initialized as part of the initialization 
phase of the scenario.

@h
#ifndef _SQL_SCENARIO_H_
#define _SQL_SCENARIO_H_
#include "sql.h"

/* #define _SQL_SCENARIO_DEBUG */
/* #define _SQL_READER_DEBUG */
/* #define _SQL_PARSER_DEBUG  */

sql_export str SQLexitClient(Client c);
sql_export str SQLinitClient(Client c);
sql_export str SQLexit(Client c);
sql_export str SQLinit(Client c);

sql_export str SQLparser(Client c);
sql_export str SQLengine(Client c);

#endif /* _SQL_SCENARIO_H_ */

@+ Scenario routines
Before we are can process SQL statements the global catalog
should be initialized. Thereafter, each time a client enters
we update its context descriptor to denote an SQL scenario.
@c
#include "sql_scenario.h"
#include "sql_gencode.h"

static void pushCatchDefault(MalBlkPtr mb, str nme,int autocommit);

static int SQLinitialized;

str SQLinit(Client c){
#ifdef _SQL_SCENARIO_DEBUG
	stream_printf(GDKout,"SQLinit Monet 5\n");
#endif
	if( SQLinitialized ){
		return throwMessage("SQLinit",
			"Catalogue already available\n");
	}
	SQLinitialized= FALSE;
	(void)c; /* not used */
	if( mvc_init(FALSE,0) <0) {
		return throwMessage("SQLinit",
			"Catalogue initialization failed\n");
	}
	SQLinitialized= TRUE;
	return MAL_SUCCEED;
}
str SQLexit(Client c){
#ifdef _SQL_SCENARIO_DEBUG
	stream_printf(GDKout,"SQLexit\n");
#endif
	(void)c; /* not used */
	if( SQLinitialized == FALSE){
		return throwMessage("SQLexit",
			"Catalogue not available\n");
	}
	mvc_exit();
	SQLinitialized= FALSE;
	return MAL_SUCCEED;
}
str SQLinitClient(Client c){
	mvc *m;
	str schema;

#ifdef _SQL_SCENARIO_DEBUG
	stream_printf(GDKout,"SQLinitClient\n");
#endif
	if( SQLinitialized == FALSE){
		return throwMessage("SQLinitClient",
			"Catalogue not available\n");
	}
	if( (backend*) c->state[PARSER] == 0){
		/* currently disabled caching, first get simple stuff to work */
		m = mvc_create(0, 0, NULL, c->fdout);
		/* replace user name with client record setting later on */
		schema = mvc_login(m, "monetdb", "monetdb");
		if( !schema){
			return throwMessage("SQLparser","No schema defined\n");
		} else {
			_DELETE(schema);
		}
		c->state[PARSER] = (void*) backend_create(0/*debug*/, m);
		c->state[OPTIMIZE] = m;
	} else {
		m = c->state[OPTIMIZE];
	}
	
	return MAL_SUCCEED;
}
str SQLexitClient(Client c){
#ifdef _SQL_SCENARIO_DEBUG
	stream_printf(GDKout,"SQLexitClient\n");
#endif
	if( SQLinitialized == FALSE){
		return throwMessage("SQLinitClient",
			"Catalogue not available\n");
	}
	if((backend*) c->state[PARSER] && (mvc *) c->state[OPTIMIZE]){
		mvc_destroy((mvc *) c->state[OPTIMIZE]);
		backend_destroy((backend*) c->state[PARSER]);
		/* files are already closed */
		c->state[OPTIMIZE]= NULL;
		c->state[PARSER]= NULL;
	}
	return MAL_SUCCEED;
}
str SQLlanguage(str *ret){
        str msg= MAL_SUCCEED;
        stream_printf(GDKout,"#Continue as SQL session\n");
        msg= setScenario(getClient(),"sql");
        *ret = 0;
        return msg;
}
@-
A statement received internally is simply appended for
execution
@c
str SQLstatement(int *ret, str *cmd){
	Client c;

#ifdef _SQL_READER_DEBUG
	stream_printf(GDKout,"SQLstatement:%s\n",*cmd);
#endif
	c = getClient();
	appendInput(c,*cmd);
	*ret= 0;
	return MAL_SUCCEED;
}
@-
The SQL reader collects a (sequence) of statements from the input
stream, but only when no unresolved 'nxt' character is visible.
In combination with SQLparser this ensures that all statements
are handled one by one.
@c
str SQLreader(Client c){
	int cnt, oldcnt,eof=0;
	lng T0;
	backend *be = ((backend*)c->state[PARSER]);
#ifdef _SQL_READER_DEBUG
	stream_printf(GDKout,"SQLparser: start reading SQL block\n");
#endif
	if( c->mode <= FINISHING)
		return throwMessage("SQLreader","end of SQL input\n");
@- 
Continue processing any left-over input from the previous round.
@c
	while(c->nxt && *c->nxt && isspace((int)*c->nxt)) c->nxt++;
	if( c->nxt && *c->nxt) return 0;

	T0= GDKusec();
	c->prompt= GDKstrdup("sql>");
	c->promptlength= strlen(c->prompt);
	c->nxt=c->input;
	oldcnt= cnt=0;
	while( c->mode > FINISHING && (eof=readClient(c,c->prompt))){
		cnt +=strlen(c->input+oldcnt);
		if( cnt==oldcnt ) break;
		if( c->input[cnt-1]==';') break;
		/* add the newline before reading the next part */
		c->input[cnt]= '\n';
		c->input[++cnt]= 0;
		c->nxt= c->input+cnt;
		oldcnt=cnt;
	}
	c->input[cnt]= '\n';
	c->input[cnt+1]= 0;
	c->nxt=c->input;

#ifdef _SQL_READER_DEBUG
	stream_printf(GDKout,"SQL blk:%s\n",c->input);
#endif
	if(eof==0 || strncmp(c->nxt,"quit",4)==0) {
		c->mode= FINISHING;
		return throwMessage("SQLreader","end of SQL input\n");
	}
	be->Tread= GDKusec()-T0;
	return 0;
}
@-
The SQL block is stored in the client input buffer, from which it
can be parsed by the SQL parser. The client structure contains
a small table of bounded tables. This should be reset before we
parse a new statement sequence.
@-
Before we parse the sql statement, we look for any variable settings
for specific commands.
The most important one is to prepare code to be handled by the debugger.
The current analysis is simple and fulfills our short-term needs.
A future version may analyze the parameter settings in more detail.
@c

#define skip() while(*c->nxt && isspace(*c->nxt) ) c->nxt++;
#define tst(X) (strncmp(c->nxt,(X),strlen(X))==0 && isspace(c->nxt[strlen(X)]))

void SQLsetDebugger(Client c)
{
	InstrPtr q;
	q= newInstruction(ASSIGNsymbol);
	functionId(q)= GDKstrdup("showFunction");
	pushInstruction(c->curprg->def,q);
	q= newInstruction(ASSIGNsymbol);
	functionId(q)= GDKstrdup("mdb");
	q= pushArgument(c->curprg->def,q,
		     newConstant(c->curprg->def,TYPE_bit,
			       GDKstrdup("true"),0));
	pushInstruction(c->curprg->def,q);
}
void SQLsetTrace(Client c, int on){
	if(on)
		c->listing = (c->listing & LIST_INPUT) | LIST_MAL_INSTR;
	else	c->listing &= LIST_INPUT;
}
void SQLsetExplain(Client c){
	c->listing = (c->listing & LIST_INPUT) | LIST_MAL_ALL;
}
@-
Analyze the flags and prepare the execution context
@c
int SQLsetEnvironment(Client c){
        (void) c;
        /* test flags and react accordingly */
        return 0;
}
@-
The core part of the SQL interface, parse the query and
prepare the intermediate code.
@c
#define explainMAL() (be->mvc->explain && \
	strcmp(be->mvc->explain, "plan") == 0)
#define explainSQL() (be->mvc->explain && \
	strcmp(be->mvc->explain, "performance") == 0)

str SQLparser(Client c) {
	str msg=0;
	int debug=0, err=0,cache= 0,len;
	backend *be;
	mvc *m;
	MalBlkRecord oldstate;
	lng T0 = 0;
	InstrPtr q;

	oldstate= *c->curprg->def;
#ifdef _SQL_PARSER_DEBUG
	stream_printf(GDKout,"SQL compilation %s\n",c->nxt);
#endif
	debug= SQLsetEnvironment(c);
	be = ((backend*)c->state[PARSER]);
	m = be->mvc;
	/* input string is copied to the SQL structure for parsing */
	scanner_reset(&m->scanner, _strdup(c->nxt));

        m->type = Q_PARSE;

        cache = m->cache;

        if (!m->trans)
                mvc_trans(m);

        if (explainSQL())
		T0 = GDKusec();

        if ((err = sqlparse(m)) ||
            /* Only forget old errors on transaction boundaries */
            (mvc_status(m) && m->type != Q_TRANS) || !m->sym) {
                if (!err)
                        err = mvc_status(m);
		stream_printf(c->fdout,"#%s\n", m->errstr);
		*m->errstr=0;
		msg= throwMessage("SQLparser","Parser errors\n");
                sqlcleanup(m, err, cache);
        }
	len= strlen(m->scanner.buf);
	c->nxt +=len;
@-
We have dealt with the first parsing step and advanced the input reader
to the next statement (if any).
Now is the time to also perform the semantic analysis, optimize and produce code.
@c
	if( err == 0 &&
	    (!(be->q = qc_match(m->qc, m->sym, m->args, m->scanner.key))) ) {
                stmt *s = sql_symbol2stmt(m);

                if (!s && (err = mvc_status(m)) ){
			stream_printf(c->fdout,"#%s\n", m->errstr);
			*m->errstr=0;
                        sqlcleanup(m, err, cache);
			msg= throwMessage("SQLparser","Semantic errors\n");
			goto finalize;
                }
                assert(s);
		/* generate MAL code */
		if (!m->cache) {
			backend_dumpstmt( be, c->curprg->def, s );
		} else {
			printf("cached case!!\n");
			/* generate a factory instantiation */
			backend_dumpproc( be, c, m->qc->id, s );
			be->q = qc_insert(
				      m->qc, 
				      m->sym, 	/* the sql symbol tree */
				      m->args,	/* the argument list */
				      m->scanner.key,/* the statement hash key*/
				      m->type,	/* the type of the statement */
				      "the mal block?" );
			be->q->code = (backend_code)c->curprg;
			m->sym = NULL;
		}
	} 
#ifdef _SQL_PARSER_DEBUG
	else stream_printf(GDKout,"parse result %d\n",err);
#endif
@-
In the final phase we add any debugging control
@c
	/* turn off debugger */
	if(debug){
		q= newInstruction(ASSIGNsymbol);
		functionId(q)= GDKstrdup("mdb");
		q= pushArgument(c->curprg->def,q,
			     newConstant(c->curprg->def,TYPE_bit,
				       GDKstrdup("false"),0));
		pushInstruction(c->curprg->def,q);
	}
@-
During the execution of the query exceptions can be raised.
The default action is to print them out at the end of the
query block.
@c
	if( err ==0 ){
		pushCatchDefault(c->curprg->def,"sqlerror", m->auto_commit);
		pushEndInstruction(c->curprg->def);
		chkProgram(c->nspace, c->curprg->def);
		if( c->curprg->def->errors){
			showErrors(c);
			/* restore the state */
			if( c->listing || explainMAL())
				printFunction(c->fdout,c->curprg->def, c->listing);
			resetInstructions(c->curprg->def,oldstate.stop);
			resetVariables(c->curprg->def, c->glb, oldstate.vtop);
			c->curprg->def->errors=0;
			msg= throwMessage("SQLparser","Semantic errors\n");
			stream_flush(c->fdout);
			return msg;
		}
	}
finalize:
	if( explainMAL()){
		printFunction(c->fdout,c->curprg->def, c->listing);
	} 
#ifdef _SQL_PARSER_DEBUG
	else {
		printf("SQL finished:%s\n",msg);
		printFunction(c->fdout,c->curprg->def, c->listing);
	}
#endif
	stream_flush(c->fdout);
@-
Gather the statistics for post analysis. It should preferably
be stored in an SQL table
@c
        if (explainSQL()){
		char safe = *c->nxt;
		*c->nxt=0;
		be->qry= GDKstrdup(c->nxt-len);
		be->Tparse= GDKusec()-T0;
		*c->nxt=safe;
	}
		
	return msg;
}
@-
Execution of the SQL program is delegated to the MALengine.
@c
str SQLengine(Client c) {
	str msg =MAL_SUCCEED;
	MalStkPtr oldglb= c->glb;
	backend *be= ((backend*)c->state[PARSER]);
	lng T0;

	if( c->curprg->def->errors)
		return throwMessage("SQLengine","Program contains errors\n");
#ifdef SQL_SCENARIO_DEBUG
	stream_printf(GDKout,"Ready to execute SQL statement\n");
#endif
	T0= GDKusec();
	c->glb= 0;
	msg= MALengine(c);
@-
Any error encountered during execution should block further processing
unless auto_commit has been set.
@c
	if( msg != MAL_SUCCEED) stream_printf(GDKout,"error received %s\n",msg);
	if( c->curprg->def->errors){
		stream_printf(GDKout,"Execution produced errors");
		sql_error(be->mvc,1,"Execution produced errors");
	}
	c->glb= oldglb;
	if( explainSQL()){
		lng tot= be->Tparse;
		int ret;
		char buf[BUFSIZ], *stmt= buf, *qs, *t, *lim=buf+BUFSIZ;

		tot+= be->Texec = GDKusec()-T0;
		snprintf(buf, BUFSIZ, "%s","set explain='none';insert into history values(now,'");
		qs= be->qry;
		for(t= buf+strlen(buf);*qs &&  t<lim-4; t++){
			if( *qs== '\n') {qs++; continue;}
			if( *qs=='\'') { *t++= '\\'; *t++= '\\'; *t++= '\\';}
			*t= *qs++;
		}
		*t=0;
		ret= strlen(buf);
		snprintf(buf+ret, BUFSIZ-ret, "',%ld,0,%ld,%ld,USER);set explain='sql';\n", 
			be->Tparse, be->Texec, tot);
@-
This code causes a recursion, because the reset of the explain
triggers the history action. A better approach is to directly
update the history tables, without SQL intervention.
Then the SQL history table is just a view over a few basic bats.
@c
		printf("#%s [parse %d]",be->qry,be->Tparse);
		printf("[engine %d]",be->Texec);
		printf("[total %d]\n",tot);
		if( be->qry) GDKfree(be->qry);
		be->qry= NULL;
		(void) stmt;
		/* DELAY SQLstatement(&ret,&stmt); */
	}
	return msg;
}
@-
The SQL front-end required some IO utilities, that may go beyond the
primitives available in the io.mx module.
@c
str SQLheader(int *ret,int *i){
	/*return throwMessage("SQLheader","Not yet defined\n");*/
	(void)ret; (void)i; /* unused */
	return MAL_SUCCEED;
}

extern str BKCsetRole(int *r, int *bid, str *hname, str *tname);

str SQLcolumn(int *ret, int *bid, str *v, str *t, int *digits, int *scale){
	(void)digits; (void)scale; /* unused */
	BKCsetRole(ret,bid,t,v);
	return MAL_SUCCEED;
}
str SQLcolumnsingle(int *ret, int *cnr, str *v, str *t, int *digits, int *scale){
	(void)ret; (void)cnr; (void)v; (void)t; (void)digits; (void)scale;
	/* do nothing for the time being, later, package it as a table */
	return MAL_SUCCEED;
}

str SQLoutput(MalBlkPtr mb, MalStkPtr stk, InstrPtr p){
	int i;
	if( p->argc==2)
		IOprintBoth(mb,stk,p,1,"[ "," ]\n");
	else {
		IOprintBoth(mb,stk,p,1,"[ ",0);
		for(i=2; i<p->argc-1;i++)
			IOprintBoth(mb,stk,p,i,", ",0);
		IOprintBoth(mb,stk,p,i,", ", "]\n");
	}
	return MAL_SUCCEED;
}
str SQLoutputBats(MalBlkPtr mb, MalStkPtr stk, InstrPtr p){
        IOtableAll(GDKout,mb,stk,p,1,0,FALSE);
	return MAL_SUCCEED;
}
@-
Assertion errors detected during the execution of a code block
raises an exception.
@c
str SQLassert(int *ret, bit *flg, str *msg){
	(void) ret;
	if( *flg)
		return throwException("SQLerror","assert",*msg);
	return MAL_SUCCEED;
}
@- Utilities
Catching errors is a recurring situation. The block below 
generates the default code block, ie catch it and print
the error. It should also deal with the auto_commit
situation. [todo]
@c
static
void pushCatchDefault(MalBlkPtr mb, str nme, int autocommit){
	InstrPtr p;
	int i;

	if(autocommit){
		p= newInstruction(ASSIGNsymbol);
		moduleId(p)= GDKstrdup("sql");
		functionId(p)= GDKstrdup("commit");
		pushInstruction(mb,p);
	}
	p= newInstruction(CATCHsymbol);
	i= findVariable(mb,nme);
	if( i< 0) i= newVariable(mb,GDKstrdup(nme),TYPE_str);
	getDestVar(p) = i;
	p->argc =1;
	p->retc = 1;
	pushInstruction(mb,p);

	p= newInstruction(ASSIGNsymbol);
	moduleId(p)= GDKstrdup("io");
	functionId(p)= GDKstrdup("print");
	pushArgumentId(mb, p, GDKstrdup(nme));
	pushInstruction(mb,p);

	if(autocommit){
		p= newInstruction(ASSIGNsymbol);
		moduleId(p)= GDKstrdup("sql");
		functionId(p)= GDKstrdup("rollback");
		pushInstruction(mb,p);
	} else {
		p= newInstruction(RAISEsymbol);
		p->barrier= RAISEsymbol;
		p->argv[0] = findVariable(mb,GDKstrdup("sqlerror"));
		i= newConstant(mb,TYPE_str,GDKstrdup("Transaction abort"),0);
		p= pushArgument(mb,p,i);
		pushInstruction(mb,p);
	}

	p= newInstruction(EXITsymbol);
	p->argv[0] = findVariable(mb,GDKstrdup(nme));
	p->barrier= EXITsymbol;
	pushInstruction(mb,p);
}
@mal
# nothing special to do
