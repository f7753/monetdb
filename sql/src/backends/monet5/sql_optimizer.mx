@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2005 CWI.
@' All Rights Reserved.

@f sql_optimizer
@t SQL catalog management
@a N. Nes, M.L. Kersten
@+ SQL scenario
The SQL scenario implementation is a derivative of the MAL session scenario.

It is also the first version that uses state records attached to
the client record. They are initialized as part of the initialization 
phase of the scenario.

The SQL compiler uses only a small subset of the MAL language.
This involves ca 70 different operators, divided into the
catalog management (?) and query processing (?)
@{
[Make complete list of MAL instructions used in the compilation]
alarm.usec
algebra.count
algebra.ds_link
algebra.join
algebra.kunique
algebra.likeselect
algebra.tmark
algebra.outerjoin
algebra.semijoin
algebra.sintersect
algebra.slice
algebra.tunique
algebra.uselect
bat.append
batcalc.project
bat.insert
bat.mirror
bat.new
bat.replace
bat.reverse
bat.seqbase
bat.{setReadMode, setWriteMode}
bat.sort
bat.tsort
bbp.project
calc.{<,<=,=,!=,>,>=}
calc.{-.+.*,/,%}
calc.{oid,int,flt,dbl,str,chr,bit}
group.group 
group.refine
group.refine_reverse
io.printf
multiplex.tactics
sql.assert
sql.bind
sql.bind_dbat
sql.bind_idxbat
sql.bind_ubat
sql_cache.???
sql.clear_table
sql.column
sql.columnBind
sql.eval
sql.output
sql.print
sql.update_var
str.codeset
stream.close
stream.openRead
str.iconv
??.{sum,min,max,count}
@}
@h
#ifndef _SQL_OPTIMIZER_H_
#define _SQL_OPTIMIZER_H_
#include "sql.h"

/* #define _SQL_OPTIMIZER_DEBUG  */

sql_export void addQueryToCache(Client c);
sql_export void optimizeQueryInCache(Client c);
sql_export str SQLoptimizer(Client c);
sql_export void SQLsetAccessMode(Client c);


#endif /* _SQL_OPTIMIZER_H_ */

@-
The queries are stored in a cache after they have been
type checked and optimized.
@c
#include "mal_macro.h"
#include "mal_optimizer.h"
#include "sql_mvc.h"
#include "sql_optimizer.h"
#include "sql_scenario.h"
#include "sql_gencode.h"


void
addQueryToCache(Client c)
{
	Scope cache;
	backend *be = ((backend *) c->state[PARSER]);

	cache = findModule(c->nspace, "sql_cache");
	if (cache == 0) {
		return;
	}
	insertSymbol(cache, c->curprg);
	trimMalBlk(c->curprg->def);
	c->blkmode = 0;
	chkProgram(c->nspace, c->curprg->def);
#ifdef _SQL_OPTIMIZER_DEBUG
	printf("ADD QUERY TO CACHE\n");
	printFunction(GDKout,c->curprg->def,LIST_MAL_ALL);
#endif
@-
An error in the compilation should be reported to the user.
@c
	if (c->curprg->def->errors) {
		showErrors(c);
		if (c->listing)
			printFunction(c->fdout, c->curprg->def, c->listing);
		stream_flush(c->fdout);
		return;
	}
	if (be->mvc->factory)
		optimizeQueryInCache(c);
}

@-
The first step towards an SQL optimizer.
This version simply runs through the MAL script and re-orders the instructions
into catalog operations, query graph, and result preparation.
This distinction is used to turn the function into a factory, which would
enable re-entry when used as a cache-optimized query.
The second optimization is move access mode changes on the base tables
to the front of the plan.

We also apply the Alias Removal optimizer to trim the instruction list
by removing simple assignments.

@c
#define TOSMALL 3

str
SQLoptimizer(Client c)
{
	(void) c;
#ifdef _SQL_OPTIMIZER_DEBUG
	stream_printf(GDKout, "SQLoptimizer\n");
	printFunction(c->fdout, c->curprg->def, LIST_MAL_INSTR);
	stream_printf(GDKout, "done\n");
#endif
	return MAL_SUCCEED;
}

void
optimizeQueryInCache(Client c)
{
	MalBlkPtr mb;
	InstrPtr *ns, p;
	int t, v;
	int i, j, k, klim;
	MALfcn setWriteMode = 0;
	Symbol s;

#ifdef _SQL_OPTIMIZER_DEBUG
	stream_printf(GDKout, "First call to SQL optimizer\n");
	printf("ABOUT TO CHANGE\n");
	printFunction(GDKout,c->curprg->def,LIST_MAL_ALL);
#endif
@-
Reduce the program before other optimizations take place
@c
	MCoptimizer(c->curprg->def, 0, 0, "algebra", "joinPath");
	ARoptimizer(c->curprg->def, 0, 0);
	CXoptimizer(c->curprg->def, 0, 0);
	/* AMoptimizer(c->curprg->def, 0,0); */
	/*SQLsetAccessMode(c); done in libraries now */

	mb = c->curprg->def;
	if (mb->stop <= TOSMALL)
		return;

	s = findMALSymbol("bat", "setWriteMode");
	if (s)
		setWriteMode = getSignature(s)->fcn;

@-
The first step is to collect all the sql bind operations and
to extract some compiler relevant properties from the catalogue.
@c
	ns = (InstrPtr *) GDKmalloc(sizeof(InstrPtr) * (mb->stop * 2));
	k = 1;
	ns[0] = getInstrPtr(mb, 0);	/* its signature */
	ns[0]->token = FACTORYsymbol;
	for (i = 0; i < mb->stop; i++) {
		p = getInstrPtr(mb, i);
		if (functionName(p) && moduleName(p) && strncmp(functionName(p), "bind", 4) == 0 && strcmp(moduleName(p), "sql") == 0) {
			ns[k++] = p;
@-
At this stage of the implementation we experiment with collecting
information for a MAL specific optimizer. Aside from the size
of BATs, it is helpful to detect empty bats as early as possible.
The information is left behind as an ordinary call to an operator
supported by the cost model or optimizer.

@-
We use knowledge on generation of bind() instructions.
@c
			if (strcmp(functionName(p), "bind_dbat") == 0 || (strcmp(functionName(p), "bind") == 0)) {
				int l = 0;
				InstrPtr qc;
				BAT *b = NULL;

@-
Watch out bind_dbat needs different binding. [costed me a day]
@c
				backend *be = ((backend *) c->state[PARSER]);

				if (strcmp(functionName(p), "bind_dbat") == 0)
					b = mvc_bind_dbat(be->mvc, getVarLiteral(mb, p->argv[1]), getVarLiteral(mb, p->argv[2]), 0);

				else
					b = mvc_bind(be->mvc, getVarLiteral(mb, p->argv[1]), getVarLiteral(mb, p->argv[2]), getVarLiteral(mb, p->argv[3]), 0);

@-
Empty BATs can be symbolically optimized. Disabled for a while.
@c
				if (b == NULL /* || (l= BATcount(b)) == 0 */ ) {
					qc = newInstruction(ASSIGNsymbol);
					setModuleId(qc, GDKstrdup("optimizer"));
					setFunctionId(qc, GDKstrdup("RXemptyBAT"));
					qc->argv[0] = newTmpVariable(mb, TYPE_void);
					qc->argv[1] = p->argv[0];
					qc->argc = 2;
					ns[k++] = qc;

					continue;
				}
@-
Play around with setting a property. It should be extended
with setting the historgram property for the tail.
Such a histogram is nothing more then a BAT whose head is
an inclusive boundary value and the tail the corresponding
number of elements.
The kernel should provide some supportive routines for this
or the SQL catalogue manager could keep histograms
around for each column.
@c
				setVarProperty(mb, p->argv[0], "count", TYPE_int, &l);
				/* setVarProperty(mb,p->argv[0],"histogram", 
				   TYPE_str, "r_c_histogram"); */
			}
		}
@-
Check if the relation is already made write-enabled in the plan.
It uses the knowledge that at this stage the plan is still a linear
sequence of instructions.
@c
		if (setWriteMode && p->fcn == setWriteMode) {
			for (j = 0; j < k; j++)
				if (ns[j]->fcn == setWriteMode && ns[j]->argv[1] == p->argv[1])
					break;
				else if (ns[j]->argv[0] == p->argv[1]) {
					ns[k++] = p;
					break;
				}
		}
	}
	klim = k;		/* remember the head */
@-
The prelude code has been generated, now we can inject the remaining
instructions, producing a syntactic correct MAL program again.
@c
	t = newConstant(mb, TYPE_bit, GDKstrdup("true"), 0);
	v = newVariable(mb, GDKstrdup("always"), TYPE_bit);
	p = newInstruction(ASSIGNsymbol);
	p->barrier = BARRIERsymbol;
	p->argv[0] = v;
	pushArgument(mb, p, t);
	ns[k++] = p;

	for (i = 1; i < mb->stop - 1; i++) {
		int doit = 0;

		p = getInstrPtr(mb, i);
		if (!(functionName(p) && moduleName(p) && strncmp(functionName(p), "bind", 4) == 0 && strcmp(moduleName(p), "sql") == 0))
			doit = 1;
@-
Skip it if the writeMode relates to a base table
@c
		if (setWriteMode)
			for (j = 0; j < klim; j++)
				if (ns[j] == p)
					doit = 0;
		if (doit)
			ns[k++] = p;
	}
@-
Finalize the factory loop
@c
	p = newInstruction(ASSIGNsymbol);
	p->barrier = YIELDsymbol;
	p->argv[0] = v;
	ns[k++] = p;
	p = newInstruction(ASSIGNsymbol);
	p->barrier = REDOsymbol;
	p->argv[0] = v;
	ns[k++] = p;
	p = newInstruction(ASSIGNsymbol);
	p->barrier = EXITsymbol;
	p->argv[0] = v;
	ns[k++] = p;
	ns[k++] = getInstrPtr(mb, i);

	mb->stop = k;
	GDKfree(mb->stmt);
	mb->stmt = ns;

	chkProgram(c->nspace, mb);
@-
At this stage we can once call upon the optimizers to do their work.
Static known information is known and stored in constant variables,
which can be used by the rewrite rules.
This all works under the assumption that the SQL layer properly invalidates
the cache when the underlying table is changed.
@c
	CXoptimizer(c->curprg->def, 0, 0);

#ifdef _SQL_OPTIMIZER_DEBUG
	printf("DONE CHANGES\n");
	printFunction(c->fdout, c->curprg->def, LIST_MAL_INSTR);
#endif
}

@-
The code produced by the SQL front-end only sets the access mode
when a BAT will become updated. In all other cases, it relies
on the M4 policy that intermediate results are considered
readonly. Readonly mode often improves processing speed.

To compensate for this behaviour, a final pass is made 
to inject the access modes in all places relevant.
In this case, we start with the mark operations, which
will be faster when the operand is read only.
Likewise, an append or insert requires write access.
@= setAccess
	if (p->fcnname && strcmp(p->fcnname,@1)==0) {
		q = newInstruction(ASSIGNsymbol);
		q->modname = GDKstrdup("bat");
		q->fcnname = GDKstrdup(@2);
		q->argv[0] = newTmpVariable(mb,TYPE_any);
		q->argv[1] = p->argv[1];
		q->argc = 2;
		ns[k++] = q;
	}
@c
void
SQLsetAccessMode(Client c)
{
	MalBlkPtr mb;
	InstrPtr *ns, p, q;
	int k, i;

	mb = c->curprg->def;
	ns = (InstrPtr *) GDKmalloc(sizeof(InstrPtr) * mb->stop * 2);
	k = 0;
	for (i = 0; i < mb->stop; i++) {
		p = getInstrPtr(mb, i);
		@:setAccess("mark","setReadMode")@
		@:setAccess("append","setWriteMode")@
		@:setAccess("insert","setWriteMode")@
		@:setAccess("replace","setWriteMode")@
		ns[k++] = p;
	}
	mb->ssize = 2 * mb->stop;
	mb->stop = k;
	GDKfree(mb->stmt);
	mb->stmt = ns;
}
