@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2004 CWI.
@' All Rights Reserved.

@f sql
@t SQL Scenario implementation
@a M Kersten 
@v 0
@* SQL support implementation
This module contains the wrappers around the SQL 
multi-version-catalog and support routines copied
from the Version 4 code base.

@mal
module sql;

command sql():void 
address SQLlanguage
comment "Switch to processing SQL statements";

command eval(cmd:str):void 
address SQLstatement
comment "Execute a single sql statement";

command header(i:int) 
address SQLheader
comment "Generate a table header for an SQL frontend";
command column(i:any, v:str,t:str,digits:int,scale:int) 
address SQLcolumnsingle;
command column(b:bat, v:str,t:str,digits:int,scale:int) 
address SQLcolumn
comment "Rename a table column";

command assert(b:bit,msg:str):void
address SQLassert
comment "Generate an exception when b==true";

command assert(b:int,msg:str):void
address SQLassertInt
comment "Generate an exception when b!=0";
command assert(b:lng,msg:str):void
address SQLassertLng
comment "Generate an exception when b!=0";

pattern output(a:any...)
address SQLoutput;
pattern output(a:bat[:any,:any]...)
address SQLoutputBats
comment "Overloading of the core print routines to obtain proper layout";

@- The SQL multi-version catalog
This module also contains the definitions for managing an SQL database schema in
version 5.  It is an adaptation of the original V4.3 code base. 
A main difference is that the global catalog is obtained from
the client record, rather then lookup the variable in a context stack.

The MAL operations below are used in the SQL->MAL compiler and
can be (sparingly) used to inspect it from a MIL console.
The 'mvc_' header is removed, because all commands are already
prepended by the 'sql.' module name.
The original code is retained, because it makes it
easier to later re-use part of the catalog code in a separately.
@mal
command createCatalog( debug:int ) :void 
address mvc_create_wrap
comment "Create multi version catalog";

command destroyCatalog() 
address mvc_destroy_wrap
comment "Destroy multi version catalog";

command login( user:str, passwd:str ):str
address mvc_login_wrap
comment "Login to an SQL database";

command update_var( varname:str ):void
address mvc_update_var_wrap
comment "Update a session variable";

command bind_ubat(sname:str, tname:str, 
		cname:str, access:int ) 
	:bat[:any$1,:any$2] 
address mvc_bind_ubat_wrap
comment "Bind bat with the updates to tname.cname 
	with specific access mode";

command bind_dbat(sname:str, tname:str, access:int)
		:bat[:any$1,:any$2] 
address mvc_bind_dbat_wrap
comment "Bind the table deletes bat, tname.delete 
	with specific access modes";

command bind_idxbat(sname:str, tname:str, iname:str, access:int)
		:bat[:any$1,:any$2] 
address mvc_bind_idxbat_wrap
comment "Bind the idx bat, tname.idx
	with specific accsess modes";

command bind(sname:str, tname:str, 
		cname:str, access:int )
	:bat[:any$1,:any$2] 
address mvc_bind_wrap
comment "Bind the bat tname.cname into the 
	focus with specific access mode";

command bindColumn(b:bat[:str,:bat], nme:str) :bat[:any,:any] 
address mvc_bind_single_wrap
comment "Bind the column bat into the focus ";

@-
The Monet 5 code generator uses several SQL specific wrapper functions.
They are not present in V4
@mal
command exportTable(s:stream, res_id:int, 
		offset:int, nr:int ) 
address mvc_export_table
comment "Export a table (in order) to stream s 
	with the given tuple and record 
	seperators (sep/rsep)";

command exportResult(s:stream, res_id:int ) 
address mvc_export_result
comment "Export a table (in order) to stream s 
	with the given tuple and record 
	seperators (sep/rsep)";

command importTable( s:stream, tname:str, 
	sep:str, rsep:str, nr:int) :bat[:str,:bat] 
address mvc_import_table_wrap
comment "Import a table from stream s with the 
	given tuple and seperators (sep/rsep)";

command hash( v:any$1, sh:int ) :int 
address hash_wrap 
comment "calculate a hash value and shift left";

@= mal_round
command round( v:@1, r:@1 ) :@1 
address @1_round_wrap
comment "round off the value v to nearests multiple of r";
@mal

@:mal_round(sht)@
@:mal_round(int)@
@:mal_round(lng)@
@:mal_round(flt)@
@:mal_round(dbl)@

@-
Include the sql_cache functionality
@mal
include sql_cache;
@h
#ifndef _SQL_H
#define _SQL_H

#include <sql_mem.h>

#ifdef _MSC_VER
#ifndef LIBSQL
#define sql_export extern __declspec(dllimport)
#else
#define sql_export extern __declspec(dllexport)
#endif
#else
#define sql_export extern
#endif

#include "sql_mvc.h"
#include <sql_backend.h>
#include <mal_session.h>

#include <mal_function.h>
#include <mal_stack.h>
#include <mal_interpreter.h>
#include <mal_session.h>
#include <streams.h>
#include "sql_privileges.h"
#include "sql_semantic.h"
#include "sql_optimize.h"
#include "sql_rel2bin.h"
#include "sql_decimal.h"
#include "sql_string.h"
#include "sql_scope.h"
#include "sql_qc.h"
#include "sql_env.h"

#define explainPlan() (be->mvc->explain && \
        strcmp(be->mvc->explain, "plan") == 0)
#define explainPerformance() (be->mvc->explain && \
        strcmp(be->mvc->explain, "performance") == 0)

@-
The back end structure collects the information needed to support
compilation and execution of the SQL code against the Monet Version 5
back end. Note that the back-end can be called upon by the front-end
to handle specific tasks, such as catalog management (sql_mvc)
and query execution (sql_qc). For this purpose, the front-end needs
access to operations defined in the back-end, in particular for
freeing the stack and code segment.
@-
@h
typedef struct backend{
	int console;
	int debug;
	int trace;
	mvc	*mvc;
	buffer 	*outbuf;
	stream 	*out;
	sql_schema *currSchema;
	sql_table *currTable;
	sql_column *currColumn;
	sql_key *currKey;
	sql_idx *currIndex;
	MalBlkPtr code;
	cq *q;	/* pointer to the cached query */
@-
Some statistics are gathered during the execution of a query
and added to the SQL history table for post analysis when the
query has been successfully executed.
@h
	long Tread, Tparse, Toptimize, Tschedule, Texec;
	str qry;
} backend;

extern backend *backend_create( int trace, mvc *m, Client c );
extern void backend_destroy( backend *b );

extern int sqlcleanup( mvc *c, int err );
extern stmt *sql_symbol2stmt( mvc *c );
#endif /* _SQL_H */

@-
First introduce the routines to be called by the front-end.
@c
#include "sql.h"
#include "sql_gencode.h"

backend *backend_create( int trace, mvc *m, Client c )
{
	backend *b = NEW(backend);

	b->console = isAdministrator(c);
	b->debug=0;
	b->outbuf= NULL;
	b->out= NULL;
	b->trace = trace;
	b->mvc = m;
	b->currSchema = NULL;
	b->currTable = NULL;
	b->currColumn = NULL;
	b->currKey = NULL;
	b->currIndex = NULL;
	b->code= NULL;
	b->Tread= b->Tparse= b->Toptimize= b->Tschedule = b->Texec = 0;
	b->qry = NULL;
	b->q = NULL;
	return b;
}

void backend_destroy( backend *b )
{
	_DELETE(b);
}

@-
Stuff copied from the Monet 4 back end
Lookup the statement associated with a specific identifier
from the statement cache. Compile and optimize it for later
consumption, e.g. display
@c
stmt *sql_symbol2stmt( mvc *c ){
        stmt *s = semantic(c, c->sym);
        if (s){
                stmt *opt = optimize(c, s);
                stmt_destroy(s);
                s = rel2bin(c, opt);
                stmt_destroy(opt);
        }
        return s;
}
@-
After the SQL statement has been executed, its data structures
should be garbage collected. For successful actions we have to finish
the transaction as well, e.g. commit or rollback.
@c
int sqlcleanup( mvc *c, int err )
{
	sql_destroy_params(c);
	sql_destroy_args(c);

	/* some statements dynamically disable caching */
	if (c->sym) {
		symbol_destroy(c->sym);
		c->sym = NULL;
	}
	scanner_query_processed(&(c->scanner));
	return err;
}

@-
The internal administration of the SQL compilation and execution state
is administered by a state descriptor accessible in each phase.
Failure to find the state descriptor aborts the session.

@= getContext
{	
	Client _client = getClient();

	if(_client == NULL ){
		return throwMessage("mvc","Can not access client record");
	} 
	if( _client->state[PARSER] == NULL){
		return throwMessage("mvc","PARSER not initialized\n");
	}
	if( _client->state[OPTIMIZE] == NULL){
		str schema;
		backend *be = _client->state[PARSER];

		(void)be;
printf("Re-establish context for client not expected\n");
		_client->state[OPTIMIZE] == mvc_create(0,0,NULL,GDKout);
		schema = mvc_login( _client->state[OPTIMIZE], 
				GDKstrdup("monetdb"), GDKstrdup("monetdb") );
		if( !schema)
			return throwMessage("getContext","unknown schema for monetdb\n");
		else
			_DELETE(schema);
	}
	@1= ((mvc *) _client ->state[OPTIMIZE]);
}
@= setContext
{	Client _client = getClient();
	if(_client == NULL || _client ->state[OPTIMIZE]== 0 ){
		return throwMessage("mvc","Can not get access to @2 state");
	} 
	_client ->state[OPTIMIZE]= @1;
}
@= getBackend
{	Client _client= getClient();
	if(_client == NULL ){
		return throwMessage("be","Can not access client record");
	} 
	if( _client->state[PARSER] == NULL){
		return throwMessage("be","PARSER not initialized\n");
	}
	@1= ((backend*) _client->state[PARSER]);
}
@c

str mvc_create_wrap(int *ret, int *debug ){
	mvc *res = mvc_create( *debug,0, NULL,GDKout );
        (void) ret;
	@:setContext(res,mvc)@
	return MAL_SUCCEED;
}

str mvc_destroy_wrap(int *ret ){
	mvc *m;
        (void) ret;
	@:getContext(m)@
	mvc_destroy( m );
	@:setContext(NULL,mvc)@
	return MAL_SUCCEED;
}

str mvc_update_var_wrap( int *ret, str *varname ){
	mvc *m;
        (void) ret;
	@:getContext(m)@
	if ( sql_update_var( m, *varname ) != GDK_SUCCEED)
		return throwException(MALEXCEPTION,"mvc_update_var","error");
	return MAL_SUCCEED;
}


str mvc_login_wrap(str *r, str *user, str *passwd  ){
	mvc *m;
	@:getContext(m)@
	*r = mvc_login( m, *user, *passwd );
	if (*r != 0)
		return throwException(MALEXCEPTION,"mvc_login_wrap","error");
	return MAL_SUCCEED;
}

str mvc_bind_wrap(int *bid, str *sname, str *tname, str *cname, int *access){
	mvc *m;
	BAT *b;
	@:getContext(m)@

	b= mvc_bind( m, *sname, *tname, *cname, *access );
	if (b){
		*bid= b->batCacheid;
		return MAL_SUCCEED;
	}
	return throwException(MALEXCEPTION,"mvc_bind_wrap","error");
}
@-
Monet 5 extension 
@-
The Mx macro below is used in many places throughout the code base to
access the BAT descriptor.

@= getBATdescriptor
   if( BBPcheck(*@2,"@4")==0) 
        return throwMessage("@4","cannot access bat '@2' in bbp");
   if( *@2 < 0) {
        /* reverse descriptor should be explicitly loaded */
        @3=BATdescriptor(*@2); BBPunfix(*@2);
   } else @3= (BAT*) BBPgetdesc(*@2);
   if( @3 == NULL) { *@1 = 0;
         return throwMessage("@4",
                 "cannot access descriptor @2");
   }
@= chkIdentifier
    /* generate exception if string is not an identifier */
    if( isIdentifier(@1))
                return throwMessage( "@4","identifier expected");
@= Pseudo
    if (BBPindex("@1_@2_@3") <= 0)
            BATname(b, "@1_@2_@3");
    BATroles(b,"@1","@2");
    BATmode(b,TRANSIENT);
    BATfakeCommit(b);
    *ret = b->batCacheid;

@c

str mvc_bind_single_wrap(int *ret, int *bid, str *name){
	mvc *m;
	BAT *b,*bn;
        int r,res;

	@:getContext(m)@

        @:getBATdescriptor(&res,bid,bn,sql.bind)@

        r= *(int *) BUNfnd(bn,name);
printf("#bind_single:%d %s -> %d\n",*bid,*name,r);
        @:getBATdescriptor(&res,&r,b,sql.bind)@
        *ret = b->batCacheid;
        return MAL_SUCCEED;
}

str mvc_bind_ubat_wrap(int *ret, str *sname, str *tname, str *cname, int *access ){
	mvc *m;
	BAT *b;
	@:getContext(m)@
	b = mvc_bind_ubat( m, *sname, *tname, *cname, *access );
	if (b){
		*ret= b->batCacheid;
		return MAL_SUCCEED;
	}
	return throwException(MALEXCEPTION,"mvc_bind_ubat_wrap","error");
}

str mvc_bind_dbat_wrap(int *ret, str *sname, str *tname, int *access ){
	mvc *m;
	BAT *b;
	@:getContext(m)@
	b = mvc_bind_dbat( m, *sname, *tname, *access );
	if (b){
		*ret= b->batCacheid;
		return MAL_SUCCEED;
	}
	return throwException(MALEXCEPTION,"mvc_bind_dbat_wrap","error");
}

str mvc_bind_idxbat_wrap(int *ret, str *sname, str *tname, str *iname, int *access ){
	mvc *m;
	BAT *b;
	@:getContext(m)@
	b = mvc_bind_idxbat( m, *sname, *tname, *iname, *access );
	if (b){
		*ret= b->batCacheid;
		return MAL_SUCCEED;
	}
	return throwException(MALEXCEPTION,"mvc_bind_idxbat_wrap","error");
}

@-
@= dec_tostr
	char buf[32];
	@1 v = *(@1*)a;
	int scale = (int)(ptrdiff_t)extra, cur = 31, neg = (v<0)?1:0, i, done = 0;
	int l;

	if (v<0) v = -v;

	buf[cur--] = 0;
	if (scale){
		for(i=0; i<scale; i++){
			buf[cur--] = (v%10) + '0';
			v /= 10;
		}
		buf[cur--] = '.';
	}
	while(v){
		buf[cur--] = (v%10) + '0';
		v /= 10;
		done = 1;
	}
	if (!done)
		buf[cur--] = '0';
	if (neg)
		buf[cur--] = '-';
	l = (32-cur-1);
	if (*len < l){
		if (*Buf) GDKfree(*Buf);
		*len = l+1;
		*Buf = GDKmalloc(*len);
	}
	strcpy(*Buf, buf+cur+1);
	return l-1;
@c

int dec_tostr( void *extra, char **Buf, int *len, int type, ptr a){
	/* support dec map to sht, int and lng */
	if (type == TYPE_sht){
		@:dec_tostr(sht)@
	} else if (type == TYPE_int){
		@:dec_tostr(int)@
	} else if (type == TYPE_lng){
		@:dec_tostr(lng)@
	} else {
		GDKwarning("Decimal cannot be mapped to %s\n", ATOMname(type));
	}
	return 0;
}

@= dec_frstr
	sql_subtype *t = (sql_subtype*)extra;

	int i, neg = 0;
	char *p = s;
	@1 *r;
	@1 res = 0;
	if (*s == '-'){
		neg = 1;
		s++;
	} else if (*s == '+'){ 
		neg = 0;
		s++;
	}
	for( i = 0; i < (t->digits-t->scale) && *s != '.'; i++, s++){
		if (!*s || *s < '0' || *s > '9' ){
			GDKerror("decimal wrong format (%s)", p);
			return NULL;
		}
		res *= 10;
		res += (*s-'0');
	}
	if (*s){
		if (*s != '.'){
			GDKerror("decimal wrong format (%s)", p);
			return NULL;
		}
		s++;
		for( i = 0; *s && i < t->scale; i++, s++){
			if (*s < '0' || *s > '9' ){
				GDKerror("decimal wrong format (%s)", p);
				return NULL;
			}
			res *= 10;
			res += (*s-'0');
		}
	}
	if (*s){
		GDKerror("decimal wrong format (%s)", p);
		return NULL;
	}
 	r = (@1*)GDKmalloc(sizeof(@1));
	if (neg)
		*r = -res;
	else
		*r = res;
	return (ptr*)r;
@c

ptr *dec_frstr( void *extra, int type, char *s){
	/* support dec map to sht, int and lng */
	if (type == TYPE_sht){
		@:dec_frstr(sht)@
	} else if (type == TYPE_int){
		@:dec_frstr(int)@
	} else if (type == TYPE_lng){
		@:dec_frstr(lng)@
	} else {
		GDKwarning("Decimal cannot be mapped to %s\n", ATOMname(type));
	}
	return NULL;
}

str mvc_import_table_wrap( BAT **res, stream *s, char *tname, 
		char *sep, char *rsep, int sz)
{
	mvc *c;
	int cnt = 0;
	sql_trans *tr;
	sql_table *t;

	@:getContext(c)@
	tr = c->trans;
 	t = mvc_bind_table(c, tr->schema, tname);
	(void)s; (void)sep; (void)rsep; (void)sz; (void)t; (void)res;

	c->type = Q_UPDATE;
	c->status = cnt;
	return 0;
}

static res_table *find_export_table( mvc *m, int res_id ){
	res_table *r = m->results;

	for( ; r; r = r->next){
		if (r->id == res_id)
			return r;
	}
	return NULL;
}

str mvc_export_result( stream *s, int res_id )
{
	mvc *c;
	int i;
	res_table *t;
	
	@:getContext(c)@
 	t = find_export_table(c, res_id);
	c->type = Q_RESULT;

	stream_writeInt( s, Q_RESULT );
	stream_writeInt( s, t->nr_cols );
	stream_writeInt( s, t->id );
	
	for (i = 0; i < t->nr_cols; i++) 
	{
		res_col *c = t->cols+i;
		stream_write(s, c->name, strlen(c->name), 1);
		stream_write(s, ",", 1, 1);
		stream_write(s, c->type->type->sqlname, 
				strlen(c->type->type->sqlname), 1);
		stream_write(s, "\n", 1, 1);
	}
	stream_flush(s);
	return NULL;
}

static int mvc_export_row( mvc *m, stream *s, res_table *t ) 
{
	char *sep = "\t";
	char *rsep = "\n";

	int i;

	m->type = Q_RESULT;
	stream_writeInt( s, Q_TABLE );
	stream_writeInt( s, 1 );

	for (i = 0; i < t->nr_cols; i++) 
	{
		res_col *c = t->cols+i;
		if (i != 0)
			stream_write(s, sep, strlen(sep), 1);

		if (c->type->type->scale == SCALE_FIX){
			char *buf = NULL;
			int len = 0;
			int l = dec_tostr((void*)(ptrdiff_t)c->type->scale, &buf, &len,
					c->mtype, c->p);
			stream_write(s, buf, l, 1);
			_DELETE(buf);
		} else { 
			char *buf = NULL;
			int len = 0;
			int l = (*BATatoms[c->mtype].atomToStr)(&buf, &len, c->p);
			stream_write(s, buf, l, 1);
			_DELETE(buf);
		}
	}
	mvc_clean_result(m, t);
	stream_write(s, rsep, strlen(rsep), 1);
	stream_flush(s);
	return 0;
}

str mvc_export_table( stream *s, int res_id, int offset, int nr )
{
	mvc *c;
	char *sep = "\t";
	char *rsep = "\n";
	int clean = 0;
	res_table *t;

	@:getContext(c)@
 	t = find_export_table(c, res_id);
	(void)s; (void)offset; (void)nr;
	(void)sep; (void)rsep;
	if (clean)
		mvc_clean_result(c, t);
	return NULL;
}

str hash_wrap( int *res, ptr v, int tpe, int *sh )
{
	*res = (ATOMhash(tpe,v)<<(*sh))&0xEFFFFFFF;
	return NULL;
}
@-
The core modules of Monet provide just a limited set of
mathematical operators. The extensions required to support
SQL-99 are shown below. At some point they also should be
moved to module code base.
@= round
str @1_round_wrap( @1 *res, @1 *v, @1 *r )
{
	@1 val = *v;
	@1 add = *r;

	add >>=1;
	if (val < 0) 
		add = -add;
	val += add; 
	val /= *r;
	*res = val;
	return NULL;
}

str trunc2@1( @1 *res, str val, int *d, int *sc )
{
	char *s = strip_extra_zeros(val);
	char *dot = strchr(s, '.');
	int digits = strlen(s) - 1;
	int scale = digits - (dot-s);
	lng value = 0;

	if (!dot) {
		return throwException(MALEXCEPTION,"trunc2", 
		     "decimal (%s) doesn't have format (%d,%d)", val, *d, *sc);
	}
		
	value = decimal_from_str(s);
	if (*s == '+' || *s == '-')
		digits --;
	if (scale < *sc){
		while(scale < *sc) {
			value *= 10;
			scale ++;
			digits ++;
		}
	} else if (scale > *sc){
		while(scale > *sc) {
			value /= 10;
			scale --;
			digits --;
		}
	}
	if (digits > *d) {
		return throwException(MALEXCEPTION,"trunc2", 
		     "decimal (%s) doesn't have format (%d,%d)", val, *d, *sc);
	}
	*res = (@1) value;
	return MAL_SUCCEED;
}
@c

@:round(sht)@
@:round(int)@
@:round(lng)@

@= fround
str @1_round_wrap( @1 *res, @1 *v, @1 *r )
{
	@1 val = *v;
/* assume float does correct rounding 
	@1 add = *r;

	add /= 2;
	if (val < 0) 
		add = -add;
	val += add;
*/
	val /= *r;
	*res = val;
	return MAL_SUCCEED;
}

str trunc2@1( @1 *res, str val, int *d, int *s )
{
	ptr p = NULL;
	int len = 0;
	int e;
	int digits = *d - *s;
	lng value = 1;
	
 	e = ATOMfromstr(TYPE_@1, &p, &len, val);
	if (e < 0 || !p || 
	   (ATOMcmp(TYPE_@1, p, ATOMnilptr(TYPE_@1)) == 0 &&
	    ATOMcmp(TYPE_str, val, ATOMnilptr(TYPE_str)) != 0) ) {
		if (p)
			GDKfree(p);
		return throwMessage("trunc", "atom nil");
	}
	while(digits > 0) {
		digits--;
		value *= 10;
	}
	if (*(@1*)p > value) {
		return throwException(MALEXCEPTION,"trunc", 
			"double (%s) doesn't have format (%d,%d)", val, *d, *s);
		
	}
	*res = *(@1*)p;
	if (p)
		GDKfree(p);
	return MAL_SUCCEED;
}
@c

@:fround(flt)@
@:fround(dbl)@

@= cast
str cast2@1( @1 *res, str val )
{
	ptr p = NULL;
	int len = 0;
	int e; 
	
	e = ATOMfromstr(TYPE_@1, &p, &len, val);
	if (e < 0 || !p || 
	   (ATOMcmp(TYPE_@1, p, ATOMnilptr(TYPE_@1)) == 0 &&
	    ATOMcmp(TYPE_str, val, ATOMnilptr(TYPE_str)) != 0) ) {
		if (p)
			GDKfree(p);
		return throwMessage("cast", "atom nil");
	}
	*res = *(@1*)p;
	if (p)
		GDKfree(p);
	return MAL_SUCCEED;
}

@c

@:cast(sht)@
@:cast(int)@
@:cast(lng)@
@:cast(flt)@
@:cast(dbl)@

str str_cast( str *res, ptr v, int tpe, int *len ){
	int sz = *len + 1;
	char *r = GDKmalloc(sz);

	if (tpe != TYPE_str) {
		sz = BATatoms[tpe].atomToStr(&r, &sz, v); 
	} else {
		sz = strlen(v);
		if (sz <= *len) {
			strncpy(r, v, sz);
			r[sz] = 0;
		}
	}
	if (sz > *len){
		GDKfree(r);
		if (ATOMcmp(TYPE_str, ATOMnilptr(TYPE_str), v) != 0) {
			return throwException(MALEXCEPTION, "str_cast", 
				"value to long for type (var)char(%d)\n",*len);
		} else {
			*res = GDKstrdup(str_nil);
			return MAL_SUCCEED;
		}
	}
	*res = r;
	return MAL_SUCCEED;
}

@= str_cast
str str2@1( @1 *res, str v, int *len ){
	int slen = strlen(v); 

	if (slen > *len || slen > 5) {
		if (ATOMcmp(TYPE_str, ATOMnilptr(TYPE_str), v) != 0) {
			return throwException(MALEXCEPTION, "str2@1", 
				"value to long for type int(%d)\n",*len);
		} else {
			*res = @1_nil;
			return MAL_SUCCEED;
		}
	}
	if (ATOMfromstr(TYPE_@1, (ptr)res, &slen, v) <=0 || *res == @1_nil) {
		return throwException(MALEXCEPTION,"str2@1", "incorrect int(%d) value\n", *len);
	}
	return MAL_SUCCEED;
}

@c
@:str_cast(sht)@
@:str_cast(int)@
@:str_cast(lng)@

static lng max_values[20] =
{
	LL_CONSTANT(0),
	LL_CONSTANT(1),
	LL_CONSTANT(10),
	LL_CONSTANT(100),
	LL_CONSTANT(1000),
	LL_CONSTANT(10000),
	LL_CONSTANT(100000),
	LL_CONSTANT(1000000),
	LL_CONSTANT(10000000),
	LL_CONSTANT(100000000),
	LL_CONSTANT(1000000000),
	LL_CONSTANT(10000000000),
	LL_CONSTANT(100000000000),
	LL_CONSTANT(1000000000000),
	LL_CONSTANT(10000000000000),
	LL_CONSTANT(100000000000000),
	LL_CONSTANT(1000000000000000),
	LL_CONSTANT(10000000000000000),
	LL_CONSTANT(100000000000000000),
	LL_CONSTANT(1000000000000000000)
};

@= numcast
str @2_2_@1( @1 *res, @2 *v, int *len ){
	int p = *len;

	if (p > 19)
		p = 19;
	if (*v > max_values[p]){
		if (*v != @2_nil) {
			return throwException(MALEXCEPTION,"@2_2_@1", "value to long for type int(%d)\n",p);
		} else {
			*res = @1_nil;
			return MAL_SUCCEED;
		}
	}
	*res = *v;
	return MAL_SUCCEED;
}
@c
@:numcast(sht,sht)@
@:numcast(sht,int)@
@:numcast(sht,lng)@
@:numcast(sht,dbl)@
@:numcast(int,sht)@
@:numcast(int,int)@
@:numcast(int,lng)@
@:numcast(int,dbl)@
@:numcast(lng,sht)@
@:numcast(lng,int)@
@:numcast(lng,lng)@
@:numcast(lng,dbl)@
