@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2004 CWI.
@' All Rights Reserved.
@'
@' Contributor(s):
@'              Martin Kersten <Martin.Kersten@cwi.nl>
@'              Peter Boncz <Peter.Boncz@cwi.nl>
@'              Niels Nes <Niels.Nes@cwi.nl>
@'              Stefan Manegold  <Stefan.Manegold@cwi.nl>

@f sql
@t SQL Scenario implementation
@a M Kersten 
@v 0
@* SQL Scenario implementation
The SQL scenario imlementation is a derivative of the MAL session scenario.

It is also the first version that uses state records attached to
the client record.
They are initialized as part of the initialization phase of 
the scenario. 

@mal
module sql;

command sql():void 
address SQLlanguage
comment "Switch to processing SQL statements";

command sql(cmd:str):void 
address SQLstatement
comment "Execute a single sql statement";

command header(i:int) 
address SQLheader
comment "Generate a table header for an SQL frontend";
command column(i:any, v:str,t:str,digits:int,scale:int) 
address SQLcolumnsingle;
command column(b:bat, v:str,t:str,digits:int,scale:int) 
address SQLcolumn
comment "Rename a table column";

pattern output(a:any...)
address SQLoutput;
pattern output(a:bat[:any,:any]...)
address SQLoutputBats
comment "Overloading of the core print routines to obtain proper layout";

@- The SQL multi-version catalog
This module also contains the definitions for managing an SQL database schema in
version 5.  It is an adaptation of the original V4.3 code base. 
A main difference is that the global catalog is obtained from
the client record, rather then lookup the variable in a context stack.

The MAL operations below are used in the SQL->MAL compiler and
can be (spareingly) used to inspect it from a MIL console.
The 'mvc_' header is removed, because all commands are already
prepended by the 'sql.' module name.
The original code is retained, because it makes it
easier to later re-use part of the catalog code in a separately.
@mal
command createCatalog( debug:int ) :void 
address mvc_create_wrap
comment "Create multi version catalog";

command destroyCatalog() 
address mvc_destroy_wrap
comment "Destroy multi version catalog";

command login( user:str, passwd:str ):str
address mvc_login_wrap
comment "Login to an SQL database";

command status( ):int 
address mvc_status_wrap
comment "Return the status of the last 
	catalogue operation";

#command type( ) :int 
#address mvc_type_wrap
#comment "Return the type of the last 
#	catalogue operation";

command bindUbat(sname:str, tname:str, 
		cname:str, access:int ) 
	:bat[:any$1,:any$2] 
address mvc_bind_ubat_wrapREAD
comment "Bind bat with the updates to tname.cname 
	with specific access mode";

command bindDbat(sname:str, tname:str, access:int)
		:bat[:any$1,:any$2] 
address mvc_bind_dbat_wrap
comment "Bind the table deletes bat, tname.delete 
	with specific access modes";

command bind(sname:str, tname:str, 
		cname:str, access:int )
	:bat[:any$1,:any$2] 
address mvc_bind_wrap
comment "Bind the bat tname.cname into the 
	focus with specific access mode";

@-
The Monet 5 code generator uses several SQL specific wrapper functions.
They are not present in V4
@mal
command commit( chain:int, name:str) :int 
address mvc_commit_wrap
comment "Commit transaction/savepoint and chain";

command rollback( chain:int, name:str ):int 
address mvc_rollback_wrap
comment "Rollback transaction/savepoint and chain";

command release( name:str ) :int 
address mvc_release_wrap
comment "Release the savepoint";

command bindSchema( sname:str ) :void 
address mvc_bind_schema_wrap
comment "Locate the schema and make it 
	the current one";

command bindTable(tname:str ):void
address mvc_bind_table_wrap
comment "Locate the table in the current 
	schema and make it the focus";

command bindColumn( cname:str ) 
address mvc_bind_column_wrap
comment "Locate the column in the current 
	table and make it the focus";

command bindKey(s:str, kname:str ):ptr 
address mvc_bind_key_wrap
comment "Locate the key with kname";

command bindIndex(s:str, iname:str ):ptr 
address mvc_bind_idx_wrap
comment "Locate the index with iname";

command dropSchema( name:str ) 
address mvc_drop_schema_wrap
comment "Drop schema";

command createSchema( name:str, auth:str) :void 
address mvc_create_schema_wrap 
comment "Create schema";

command dropTable(name:str,  cascade:bit ) 
address mvc_drop_table_wrap 
comment "Drop table from a schema";

command createTable(name:str, temp:int, size:int):void 
address mvc_create_table_wrap
comment "Create table in current schema";

command createView( name:str, sql:str) 
address mvc_create_view_wrap 
comment "Create view within the current schema";

command dropColumn( name:str ) 
address mvc_drop_column_wrap 
comment "Drop column from a table in a schema";

command createColumn( name:str, type:str,
		digits:int,scale:int ) :int
address mvc_create_column_wrap
comment "Create column within the current table";

command setNotNull(flg:int) 
address mvc_null_wrap
comment "Set current column (not) null";

command default(val:str ) 
address mvc_default_wrap
comment "Set current column default value";

command createKey(name:str,kt:int):int 
address mvc_create_key_wrap
comment "Create a (compound) table key";

#command createForeignKey( nme:str, kt:str) 
		#= mvc_create_fkey_wrap
#comment "Create a table key";

#command keyAddColumn( s:str, t:str, k:sql_key, c:sql_column ) = mvc_key_add_column_wrap
#comment "Key add column";

command exportTable(s:stream, res_id:int, 
		offset:int, nr:int ) 
address mvc_export_table
comment "Export a table (in order) to stream s 
	with the given tuple and record 
	seperators (sep/rsep)";

command exportResult(s:stream, res_id:int ) 
address mvc_export_result
comment "Export a table (in order) to stream s 
	with the given tuple and record 
	seperators (sep/rsep)";

command importTable( s:stream, tname:str, 
	sep:str, rsep:str, nr:int) :bat[:str,:any] 
address mvc_import_table_wrap
comment "Import a table from stream s with the 
	given tuple and seperators (sep/rsep)";

#command renumber(b1:bat[oid,any::1],o:oid):bat[oid,any::1] 
#address CMDrenumber
#comment "renumber the bat using the offset o.";

#command insert(b:bat[void,any::1],u:bat[void,any::1]):bat[void,any::1] 
#address CMDbatappendoidbat 
#comment "append the contents of u to b.";
#command replace(b:bat[void,any::1],u:bat[void,any::1]):bat[void,any::1] =
	#CMDbatreplaceoidbat 
#comment "inplace replace values on the give locations.";
@h
#ifndef _SQL_H
#define _SQL_H

#include <sql_mem.h>

#ifdef _MSC_VER
#ifndef LIBSQL
#define sql_export extern __declspec(dllimport)
#else
#define sql_export extern __declspec(dllexport)
#endif
#else
#define sql_export extern
#endif

#include "sql_mvc.h"
#include <sql_backend.h>
#include <mal_session.h>

#include <mal_function.h>
#include <mal_stack.h>
#include <mal_interpreter.h>
#include <mal_session.h>
#include <streams.h>
#include "sql_privileges.h"
#include "sql_semantic.h"
#include "sql_optimize.h"
#include "sql_rel2bin.h"
#include "sql_decimal.h"
#include "sql_string.h"
#include "sql_scope.h"
#include "sql_qc.h"
#include "sql_env.h"
@-
The backend structure collects the information needed to support
compilation and execution of the SQL code against the Monet Version 5
backend. Note that the back-end can be called upon by the front-end
to handle specific tasks, such as catalogue management (sql_mvc)
and query execution (sql_qc). For this purpose, the front-end needs
access to operations defined in the back-end, in particular for
freeing the stack and code segment.
@-
@h
typedef struct backend{
	int debug;
	int trace;
	mvc	*context;
	buffer 	*outbuf;
	stream 	*out;
	sql_schema *currSchema;
	sql_table *currTable;
	sql_column *currColumn;
	sql_key *currKey;
	sql_idx *currIndex;
	MalBlkPtr code;
} backend;

#define _SQL_SCENARIO_DEBUG 
sql_export str SQLexitClient(Client c);
sql_export str SQLinitClient(Client c);
sql_export str SQLexit(Client c);
sql_export str SQLinit(Client c);

sql_export str SQLparser(Client c);
sql_export str SQLengine(Client c);

#endif /* _SQL_H */

@-
First introduce the routines to be called by the front-end.
@c
#include "sql.h"
#define DEBUG

static backend *backend_create( int trace, mvc *c )
{
#ifdef DEBUG
	printf("create backend\n");
#endif
	backend *b = NEW(backend);

	b->trace = trace;
	b->context= c;
	b->currSchema = NULL;
	b->currTable = NULL;
	b->currColumn = NULL;
	b->currKey = NULL;
	b->currIndex = NULL;
	return b;
}

void backend_destroy( backend *b )
{
	_DELETE(b);
}

void monet5_freestack( backend_stack stk){
	(void) stk;
#ifdef DEBUG
	printf("monet5_freestack\n");
#endif
}
void monet5_parse( backend_stack stk, char *cmd){
	(void) stk;
#ifdef DEBUG
	printf("monet5_parse:%s\n",cmd);
#endif
}
void monet5_freecode(backend_code code, backend_stack stk, int nr){
	(void) code; (void) stk; (void)nr;
#ifdef DEBUG
	printf("monet5_free:%d\n",nr);
#endif
}
	
@+ Scenario routines
Before we are can process SQL statements the global catalogue
should be initialized. Thereafter, each time a client enters
we update its context descriptor to denote an SQL scenario.
@c
str SQLinit(Client c){
	(void)c; /* not used */
	mvc_init(0,0);
	return MAL_SUCCEED;
}
str SQLexit(Client c){
	(void)c; /* not used */
	mvc_exit();
	return MAL_SUCCEED;
}
str SQLinitClient(Client c){
	backend *sql;
	mvc *m;
	str schema;

	sql = (backend*) c->state[PARSER];
	if( sql == 0){
		m = mvc_create(0, 0, NULL, c->fdout);
		/* replace user name with client record setting later on */
		schema = mvc_login(m, "monetdb", "monetdb");
		if( !schema){
			return throwMessage("SQLparser","No schema defined\n");
		} else {
			_DELETE(schema);
		}
		sql = backend_create(0/*debug*/, m);

		c->state[PARSER] = (void*) sql;
		c->state[OPTIMIZE] = m;
	} else {
		m = c->state[OPTIMIZE];
	}
	
	return MAL_SUCCEED;
}
str SQLexitClient(Client c){
	mvc *m;
	backend *sql;

	sql = (backend*) c->state[PARSER];
	m = (mvc *) c->state[OPTIMIZE];
	if(sql && m){
		mvc_destroy(m);
		backend_destroy(sql);
		/* files are already closed */
		
	}
	clrScenario(c);
	return MAL_SUCCEED;
}
str SQLlanguage(str *ret){
        str msg= MAL_SUCCEED;
        stream_printf(GDKout,"#Continue as SQL session\n");
        msg= setScenario(getClient(),"sql");
        *ret = 0;
        return msg;
}

str SQLstatement(int *ret, str *cmd){
#ifdef _SQL_SCENARIO_DEBUG
	stream_printf(GDKout,"execute sql:%s\n",*cmd);
#endif
	*ret= 0;
	return MAL_SUCCEED;
}
str SQLreader(Client c){
	int cnt, oldcnt,eof=0;
#ifdef _SQL_SCENARIO_DEBUG
	printf("SQLparser: start reading SQL block\n");
#endif
	if( c->mode <= FINISHING)
		return throwMessage("SQLreader","end of SQL input\n");
	c->prompt= GDKstrdup("sql>");
	c->promptlength= strlen(c->prompt);
	c->nxt=c->input;
	oldcnt= cnt=0;
	while( c->mode > FINISHING && (eof=readClient(c,c->prompt))){
		cnt +=strlen(c->input+oldcnt);
		if( cnt==oldcnt ) break;
		if( c->input[cnt-1]==';') break;
		/* add the newline before reading the next part */
		c->input[cnt]= '\n';
		c->input[cnt+1]= 0;
		c->nxt= c->input+cnt;
		oldcnt=cnt;
	}
	c->input[cnt]= '\n';
	c->input[cnt+1]= 0;
	c->nxt=c->input;

#ifdef _SQL_SCENARIO_DEBUG
	printf("SQL blk:%s\n",c->input);
#endif
	if(eof==0) {
		c->mode= FINISHING;
		return throwMessage("SQLreader","end of SQL input\n");
	}
	return 0;
}
@-
The SQL block is stored in the client input buffer, from which it
can be parsed by the SQL parser. The client structure contains
a small table of bounded tables. This should be reset before we
parse a new statement sequence.
@-
Before we parse the sql statement, we look for any variable settings
for specific commands.
The most important one is to prepare code to be handled by the debugger.
The current analysis is simple and fulfills our short-term needs.
A future version may analyse the parameter settings in more detail.
@c

#define skip() while(*c->nxt && isspace(*c->nxt) ) c->nxt++;
#define tst(X) (strncmp(c->nxt,(X),strlen(X))==0 && isspace(c->nxt[strlen(X)]))

int SQLsetEnvironment(Client c){
	do{
		skip();
		if( tst("quit") || tst("exit")){
			mvc_exit();
			InstrPtr q;
			c->nxt+= 5;
			q= newInstruction(ASSIGNsymbol);
			moduleId(q)= GDKstrdup("system");
			functionId(q)= GDKstrdup("quit");
			pushInstruction(c->curprg->def,q);
			return 0;
		} else
		if( tst("set")|| tst("SET") ){
			c->nxt += 3;
			skip();
			if(tst("debug") ){
				InstrPtr q;
				c->nxt+= 6;
				q= newInstruction(ASSIGNsymbol);
				functionId(q)= GDKstrdup("showFunction");
				pushInstruction(c->curprg->def,q);
				q= newInstruction(ASSIGNsymbol);
				functionId(q)= GDKstrdup("mdb");
				q= pushArgument(c->curprg->def,q,
					     newConstant(c->curprg->def,TYPE_bit,
						       GDKstrdup("true"),0));
				pushInstruction(c->curprg->def,q);
				return 1;
			}
			if(tst("trace") ){
				c->listing = (c->listing & LIST_INPUT) | LIST_MAL_INSTR;
				c->nxt+=6;
				return 0;
			}
			if(tst("explain") ){
				c->listing = (c->listing & LIST_INPUT) | LIST_MAL_ALL;
				c->nxt+=8;
				return 0;
			}
			if(tst("notrace") ){
				c->listing &= LIST_INPUT;
				c->nxt+=6;
				return 0;
			}
		} else break;
	} while(1);
	return 0;
}
@-
Stuff copied from the Monet 4 backend
@c

int sqlexecute(backend * be, stream *out )
{
	(void) be; (void) out;
#ifdef DEBUG
	printf("execute the query");
#endif
	return 0;
}

int sqlstatement(char *cmd)
{
	int err = 0;
	mvc *m;
        backend *sql;

	m= mvc_create(0, 0, NULL, GDKout );
        mvc_trans(m); /* start transaction */
        m->user_id = m->role_id = 0;
        m->user = _strdup("monetdb");
        m->trans->schema = mvc_bind_schema(m, "sys");
        sql = backend_create( 0, m );

/* OLD
	if ((err = sqlparse(c)) || c->mvc->status || !c->sym) {
		if (!err)
			err = c->mvc->status;
		return sqlcleanup(c, NULL, err);
	}
	
	if ( !(q = qc_find(c->qc, c->sym, c->params, c->key)) ){
		stmt *s = sql_symbol2stmt(c);

		if (!s && c->mvc->status){
			err = c->mvc->status;
			return sqlcleanup(c, NULL, err);
		}

		backend_dumpproc( be, mb, c->qc->id, s );
		stmt_destroy(s);
	
		c->sym = NULL;
		c->params = NULL;

		if (err)
			return sqlcleanup(c, NULL, err);
	}
	if (c->mvc->type == Q_TRANS || c->mvc->type == Q_SCHEMA){
		if (c->qc) qc_destroy(c->qc);
		c->qc = qc_create();
	}
*/
        err = sqlexecute(sql, GDKout);
        if (err)
                GDKerror(m->errstr);
        backend_destroy( sql );
        GDKfree(cmd);
        mvc_commit(m, 0, NULL);
        mvc_destroy(m);
	return err? GDK_FAIL: GDK_SUCCEED;
}


str SQLparser(Client c) {
	str msg=0;
	int debug=0, err=0;
	backend *be;
	MalBlkRecord oldstate;

	oldstate= *c->curprg->def;
#ifdef _SQL_SCENARIO_DEBUG
	printf("SQL start compilation \n");
#endif
	debug= SQLsetEnvironment(c);
	be = ((backend*)c->state[PARSER]);
	/* code should be in the be structure */
	if ( (err = sqlexecute(be, GDKout)) ){
#ifdef _SQL_SCENARIO_DEBUG
		printf("continue parser from:%s", c->nxt);
#endif
		stream_printf(c->fdout,"#%s\n", be->context->errstr);
		*be->context->errstr=0;
		msg= throwMessage("SQLparser","Parser errors\n");
	}

	/* turn off debugger */
	if(debug){
		InstrPtr q;
		q= newInstruction(ASSIGNsymbol);
		functionId(q)= GDKstrdup("mdb");
		q= pushArgument(c->curprg->def,q,
			     newConstant(c->curprg->def,TYPE_bit,
				       GDKstrdup("false"),0));
		pushInstruction(c->curprg->def,q);
	}
	pushEndInstruction(c->curprg->def);
	chkProgram(c->nspace, c->curprg->def);
	if( c->curprg->def->errors){
		showErrors(c);
		/* restore the state */
		if( c->listing)
			printFunction(c->fdout,c->curprg->def, c->listing);
		resetInstructions(c->curprg->def,oldstate.stop);
		resetVariables(c->curprg->def, c->glb, oldstate.vtop);
		c->curprg->def->errors=0;
		msg= throwMessage("SQLparser","Semantic errors\n");
	}
#ifdef _SQL_SCENARIO_DEBUG
	if(msg) printf("SQL finished:%s\n",msg);
#endif
	stream_flush(c->fdout);
		
	return msg;
}
@-
Execution of the SQL program is delegated to the MALengine.
@c
str SQLengine(Client c) {
	str msg =MAL_SUCCEED;
	MalStkPtr oldglb= c->glb;

	if( c->curprg->def->errors)
		return throwMessage("SQLengine","Program contains errors\n");
#ifdef SQL_SCENARIO_DEBUG
	printf("Ready to execute SQL statement\n");
#endif
	c->glb= 0;
	msg= MALengine(c);
	c->glb= oldglb;
	return msg;
}
@-
The SQL front-end required some IO utilities, that may go beyond the
primitives avaiable in the io.mx module.
@c
str SQLheader(int *ret,int *i){
	/*return throwMessage("SQLheader","Not yet defined\n");*/
	(void)ret; (void)i; /* unused */
	return MAL_SUCCEED;
}

extern str BKCsetRole(int *r, int *bid, str *hname, str *tname);

str SQLcolumn(int *ret, int *bid, str *v, str *t, int *digits, int *scale){
	(void)digits; (void)scale; /* unused */
	BKCsetRole(ret,bid,t,v);
	return MAL_SUCCEED;
}
str SQLcolumnsingle(int *ret, int *cnr, str *v, str *t, int *digits, int *scale){
	(void)ret; (void)cnr; (void)v; (void)t; (void)digits; (void)scale;
	/* do nothing for the time being, later, package it as a table */
	return MAL_SUCCEED;
}

str SQLoutput(MalBlkPtr mb, MalStkPtr stk, InstrPtr p){
	int i;
	if( p->argc==2)
		IOprintBoth(mb,stk,p,1,"[ "," ]\n");
	else {
		IOprintBoth(mb,stk,p,1,"[ ",0);
		for(i=2; i<p->argc-2;i++)
			IOprintBoth(mb,stk,p,i,", ",0);
		IOprintBoth(mb,stk,p,i,", ", "]\n");
	}
	return MAL_SUCCEED;
}
str SQLoutputBats(MalBlkPtr mb, MalStkPtr stk, InstrPtr p){
        IOtableAll(GDKout,mb,stk,p,1,0,FALSE);
	return MAL_SUCCEED;
}

@-
The internal administration of the SQL compilation and execution state
is administered by a state descriptor accessible in each phase.
Failure to find the state descriptor aborts the session.

@= getContext
{	Client _client = getClient();
	if(_client == NULL ){
		return throwMessage("mvc","Can not access client record");
	} 
	if( _client->state[PARSER] == NULL){
		return throwMessage("mvc","PARSER not initialized\n");
	}
	if( _client->state[OPTIMIZE] == NULL){
		str schema;
		backend *be = _client->state[PARSER];

		(void)be;
printf("Re-establish context for client not expected\n");
		_client->state[OPTIMIZE] == mvc_create(0,0,NULL,GDKout);
		schema = mvc_login( _client->state[OPTIMIZE], 
				"monetdb", "monetdb" );
		if( !schema)
			return throwMessage("getContext","unknown schema for monetdb\n");
		else
			_DELETE(schema);
	}
	@1= ((mvc *) _client ->state[OPTIMIZE]);
}
@= setContext
{	Client _client = getClient();
	if(_client == NULL || _client ->state[OPTIMIZE]== 0 ){
		return throwMessage("mvc","Can not get access to @2 state");
	} 
	((mvc *) _client ->state[OPTIMIZE])= @1;
}
@= getBackend
{	Client _client= getClient();
	if(_client == NULL ){
		return throwMessage("be","Can not access client record");
	} 
	if( _client->state[PARSER] == NULL){
		return throwMessage("be","PARSER not initialized\n");
	}
	@1= ((backend*) _client->state[PARSER]);
}
@c

str mvc_create_wrap(int *ret, int *debug ){
	mvc *res = mvc_create( *debug,0, NULL,GDKout );
	@:setContext(res,mvc)@
	*ret = 0;
	return MAL_SUCCEED;
}

str mvc_destroy_wrap(int *ret ){
	mvc *c;
	@:getContext(c,mvc)@
	mvc_destroy( c );
	@:setContext(NULL,mvc)@
	*ret = 0;
	return MAL_SUCCEED;
}

str mvc_login_wrap(str *r, str *user, str *passwd  ){
	mvc *c;
	@:getContext(c,mvc)@
	*r = mvc_login( c, *user, *passwd );
	if (*r != 0)
		return throwException(MALEXCEPTION,"mvc_login_wrap","error");
	return MAL_SUCCEED;
}

str mvc_status_wrap(int* res ){
	mvc *c;
	@:getContext(c,mvc)@
	*res = mvc_status( c );
	return MAL_SUCCEED;
}

str mvc_type_wrap(int *res ){
	mvc *m;
	@:getContext(m,mvc)@
	*res = mvc_type( m );
	return MAL_SUCCEED;
}

str mvc_commit_wrap(int* res, int* chain, str *name){
	mvc *m;
	@:getContext(m,mvc)@
	*res = mvc_commit( m, *chain, *name );
	return MAL_SUCCEED;
}

str mvc_rollback_wrap(int *res, int *chain, str *name ){
	mvc *m;
	@:getContext(m,mvc)@
	*res = mvc_rollback( m, *chain, *name );
	return MAL_SUCCEED;
}

str mvc_release_wrap(int *res, str *name ){
	mvc *m;
	@:getContext(m,mvc)@
	*res = mvc_release( m, *name );
	return MAL_SUCCEED;
}

str mvc_bind_wrap(int *bid, str *sname, str *tname, str *cname, int *access){
	mvc *c;
	BAT *b;
	@:getContext(c,mvc)@

	b= mvc_bind( c, *sname, *tname, *cname, *access );
	if (b){
		*bid= b->batCacheid;
		return MAL_SUCCEED;
	}
	return throwException(MALEXCEPTION,"mvc_bind_wrap","error");
}

str mvc_bind_ubat_wrap(int *ret, str *sname, str *tname, str *cname, int *access ){
	mvc *c;
	BAT *b;
	@:getContext(c,mvc)@
	b = mvc_bind_ubat( c, *sname, *tname, *cname, *access );
	if (b){
		*ret= b->batCacheid;
		return MAL_SUCCEED;
	}
	return throwException(MALEXCEPTION,"mvc_bind_ubat_wrap","error");
}
str mvc_bind_ubat_wrapWRITE(int *bid, str *sname, str *tname, str *cname){
	int i=1;
	return mvc_bind_ubat_wrap(bid, sname, tname, cname, &i);
}
str mvc_bind_ubat_wrapREAD(int *bid, str *sname, str *tname, str *cname){
	int i=0;
	return mvc_bind_ubat_wrap(bid, sname, tname, cname, &i);
}

str mvc_bind_dbat_wrap(int *ret, str *sname, str *tname, int *access ){
	mvc *c;
	BAT *b;
	@:getContext(c,mvc)@
	b = mvc_bind_dbat( c, *sname, *tname, *access );
	if (b){
		*ret= b->batCacheid;
		return MAL_SUCCEED;
	}
	return throwException(MALEXCEPTION,"mvc_bind_dbat_wrap","error");
}

str mvc_bind_schema_wrap(int *ret, str *sname){
	backend *be;
	mvc *c;
	@:getBackend(be)@
	@:getContext(c)@
	be->currSchema = mvc_bind_schema( c, *sname );
	*ret = 0;
	return MAL_SUCCEED;
}

str mvc_bind_table_wrap(int *ret, str *tname){
	backend *be;
	mvc *c;

	@:getBackend(be)@
	@:getContext(c)@
	if( be->currSchema == NULL) 
		return throwMessage("bindTable","Schema not in focus");
	be->currTable = mvc_bind_table( c, be->currSchema, *tname);
	*ret = 0;
	return MAL_SUCCEED;
}

str mvc_bind_column_wrap(int *ret, str *col){
	backend *be;
	mvc *c;

	@:getBackend(be)@
	@:getContext(c)@
	if( be->currTable == NULL) 
		return throwMessage("bindColumn","Table focus not found");
	be->currColumn = mvc_bind_column(c, be->currTable, *col);
	*ret = 0;
	return MAL_SUCCEED;
}

str mvc_bind_key_wrap(int *ret, str *kname){
	backend *be;
	mvc *c;

	@:getBackend(be)@
	@:getContext(c)@

	if( be->currSchema == NULL) 
		return throwMessage("bindKey","Schema not found");

	be->currKey = mvc_bind_key( c, be->currSchema, *kname);
	*ret = 0;
	return MAL_SUCCEED;
}

str mvc_bind_idx_wrap(int *ret, str *iname){
	backend *be;
	mvc *c;

	@:getBackend(be)@
	@:getContext(c)@

	if( be->currSchema == NULL) 
		return throwMessage("bindIndex","Schema not found");

	be->currIndex = mvc_bind_idx( c, be->currSchema, *iname);
	*ret = 0;
	return MAL_SUCCEED;
}


str mvc_create_schema_wrap(int *ret, str *name, str *auth){
	backend *be;
	mvc *c;

	@:getBackend(be)@
	@:getContext(c)@

	be->currSchema = mvc_create_schema( c, *name, *auth );
	*ret = 0;
	return MAL_SUCCEED;
}

str mvc_drop_schema_wrap(int *ret, str *name){
	backend *be;
	mvc *c;

	@:getBackend(be)@
	@:getContext(c)@
	mvc_drop_schema( c, *name );
	be->currSchema = NULL;
	be->currTable = NULL;
	be->currColumn = NULL;
	be->currKey = NULL;
	be->currIndex = NULL;
	*ret = 0;
	return MAL_SUCCEED;
}

str mvc_create_table_wrap(int *ret, str *name, bit* temp, int *size){
	backend *be;
	mvc *c;

	@:getBackend(be)@
	@:getContext(c)@

	if( be->currSchema == NULL) 
		return throwMessage("createTable","Schema not found");

	be->currTable = mvc_create_table( c, be->currSchema, *name, *temp, *size );
	*ret = 0;
	return MAL_SUCCEED;
}

str mvc_create_view_wrap(int *ret, str *name, str *sql){
	backend *be;
	mvc *c;

	@:getBackend(be)@
	@:getContext(c,mvc)@

	if( be->currSchema == NULL) 
		return throwMessage("createView","Schema not found");

	be->currTable = mvc_create_view( c, be->currSchema, *name, *sql );
	*ret = 0;
	return MAL_SUCCEED;
}

str mvc_drop_table_wrap(int *ret, str *name, bit* cascade){
	backend *be;
	mvc *c;

	@:getBackend(be)@
	@:getContext(c)@

	if( be->currSchema == NULL) 
		return throwMessage("dropTable","Schema not found");

	mvc_drop_table( c, be->currSchema, *name, *cascade );
	be->currTable = NULL;
	be->currColumn = NULL;
	*ret = 0;
	return MAL_SUCCEED;
}


str mvc_create_column_wrap(int *ret, str *name, str *tpe ){
	backend *be;
	mvc *c;

	@:getBackend(be)@
	@:getContext(c)@

	if( be->currTable == NULL) 
		return throwMessage("createColumn","Table not found");

	be->currColumn = mvc_create_column_( c, be->currTable, *name, *tpe);
	*ret = 0;
	return MAL_SUCCEED;
}

str mvc_drop_column_wrap(int *ret, str *name){
	backend *be;
	mvc *c;

	@:getBackend(be)@
	@:getContext(c)@

	if( be->currTable == NULL) 
		return throwMessage("createColumn","Table not found");

	mvc_drop_column( c, be->currTable, *name );
	be->currColumn = NULL;
	*ret = 0;
	return MAL_SUCCEED;
}

str mvc_null_wrap(int *ret, int *flg){
	backend *be;
	mvc *c;

	@:getBackend(be)@
	@:getContext(c)@

	if (be->currColumn == NULL) 
		return throwMessage("notNull","Column not found");

	mvc_null( c, be->currColumn, *flg);
	*ret = 0;
	return MAL_SUCCEED;
}

str mvc_default_wrap(int *ret, str *val){
	backend *be;
	mvc *c;

	@:getBackend(be)@
	@:getContext(c)@

	if (be->currColumn == NULL) 
		return throwMessage("notNull","Column not found");

	mvc_default( c, be->currColumn, *val );
	*ret = 0;
	return MAL_SUCCEED;
}
@-
The recurring structure to handle bat descriptors
@= getBATdescriptor
        if( BBPcheck(*@2,"@4")==0)
                return throwMessage("algebra.@4", "cannot access bat @2 in bbp");
        @3= (BAT*) BBPgetdesc(*@2);
        if( @3 == NULL) { *@1 = 0;
                return throwMessage("algebra.@4", "cannot access descriptor @2");
        }
        if( *@2 <0){ /* BAT reverse */ @3 = BATmirror(@3); }
@-
@c
str mvc_create_key_wrap( int *ret, str *name, int *kt){
	mvc *c;
	backend *be;
	sql_schema *s;
	sql_table *t;

	@:getBackend(be)@
	@:getContext(c)@

	s = be->currSchema;
	if( s == NULL) return throwMessage("notNull","Schema not found");
	t = be->currTable;
	if( t == NULL) return throwMessage("notNull","Table not found");

        be->currKey = mvc_create_key(c, t, *name, *kt, NULL);
	*ret =0;
        return MAL_SUCCEED;
}
str mvc_create_fkey_wrap( int *ret, str *name, int *kt){
	mvc *c;
	backend *be;
	sql_schema *s;
	sql_table *t;
	sql_key *fk;

	@:getBackend(be)@
	@:getContext(c)@

	s = be->currSchema;
	if( s == NULL) return throwMessage("notNull","Schema not found");
	t = be->currTable;
	if( t == NULL) return throwMessage("notNull","Table not found");
	fk = be->currKey;
	if( fk == NULL) return throwMessage("notNull","Key not found");

        be->currKey = mvc_create_key(c, t, *name, *kt, fk);
	*ret =0;
        return MAL_SUCCEED;
}


@= dec_tostr
	char buf[32];
	@1 v = *(@1*)a;
	int scale = (int)(ptrdiff_t)extra, cur = 31, neg = (v<0)?1:0, i, done = 0;
	int l;

	if (v<0) v = -v;

	buf[cur--] = 0;
	if (scale){
		for(i=0; i<scale; i++){
			buf[cur--] = (v%10) + '0';
			v /= 10;
		}
		buf[cur--] = '.';
	}
	while(v){
		buf[cur--] = (v%10) + '0';
		v /= 10;
		done = 1;
	}
	if (!done)
		buf[cur--] = '0';
	if (neg)
		buf[cur--] = '-';
	l = (32-cur-1);
	if (*len < l){
		if (*Buf) GDKfree(*Buf);
		*len = l+1;
		*Buf = GDKmalloc(*len);
	}
	strcpy(*Buf, buf+cur+1);
	return l-1;
@c

int dec_tostr( void *extra, char **Buf, int *len, int type, ptr a){
	/* support dec map to sht, int and lng */
	if (type == TYPE_sht){
		@:dec_tostr(sht)@
	} else if (type == TYPE_int){
		@:dec_tostr(int)@
	} else if (type == TYPE_lng){
		@:dec_tostr(lng)@
	} else {
		GDKwarning("Decimal cannot be mapped to %s\n", ATOMname(type));
	}
	return 0;
}

@= dec_frstr
	sql_subtype *t = (sql_subtype*)extra;

	int i, neg = 0;
	char *p = s;
	@1 *r;
	@1 res = 0;
	if (*s == '-'){
		neg = 1;
		s++;
	} else if (*s == '+'){ 
		neg = 0;
		s++;
	}
	for( i = 0; i < (t->digits-t->scale) && *s != '.'; i++, s++){
		if (!*s || *s < '0' || *s > '9' ){
			GDKerror("decimal wrong format (%s)", p);
			return NULL;
		}
		res *= 10;
		res += (*s-'0');
	}
	if (*s){
		if (*s != '.'){
			GDKerror("decimal wrong format (%s)", p);
			return NULL;
		}
		s++;
		for( i = 0; *s && i < t->scale; i++, s++){
			if (*s < '0' || *s > '9' ){
				GDKerror("decimal wrong format (%s)", p);
				return NULL;
			}
			res *= 10;
			res += (*s-'0');
		}
	}
	if (*s){
		GDKerror("decimal wrong format (%s)", p);
		return NULL;
	}
 	r = (@1*)GDKmalloc(sizeof(@1));
	if (neg)
		*r = -res;
	else
		*r = res;
	return (ptr*)r;
@c

ptr *dec_frstr( void *extra, int type, char *s){
	/* support dec map to sht, int and lng */
	if (type == TYPE_sht){
		@:dec_frstr(sht)@
	} else if (type == TYPE_int){
		@:dec_frstr(int)@
	} else if (type == TYPE_lng){
		@:dec_frstr(lng)@
	} else {
		GDKwarning("Decimal cannot be mapped to %s\n", ATOMname(type));
	}
	return NULL;
}

str mvc_import_table_wrap( BAT **res, stream *s, char *tname, 
		char *sep, char *rsep, int sz)
{
	mvc *c;
	int cnt = 0;
	sql_trans *tr;
	sql_table *t;

	@:getContext(c)@
	tr = c->trans;
 	t = mvc_bind_table(c, tr->schema, tname);
	(void)s; (void)sep; (void)rsep; (void)sz; (void)t; (void)res;

	c->type = Q_UPDATE;
	c->status = cnt;
	return 0;
}

static res_table *find_export_table( mvc *m, int res_id ){
	res_table *r = m->results;

	for( ; r; r = r->next){
		if (r->id == res_id)
			return r;
	}
	return NULL;
}

str mvc_export_result( stream *s, int res_id )
{
	mvc *c;
	int i;
	res_table *t;
	
	@:getContext(c)@
 	t = find_export_table(c, res_id);
	c->type = Q_RESULT;

	stream_writeInt( s, Q_RESULT );
	stream_writeInt( s, t->nr_cols );
	stream_writeInt( s, t->id );
	
	for (i = 0; i < t->nr_cols; i++) 
	{
		res_col *c = t->cols+i;
		stream_write(s, c->name, strlen(c->name), 1);
		stream_write(s, ",", 1, 1);
		stream_write(s, c->type->type->sqlname, 
				strlen(c->type->type->sqlname), 1);
		stream_write(s, "\n", 1, 1);
	}
	stream_flush(s);
	return NULL;
}

static int mvc_export_row( mvc *m, stream *s, res_table *t ) 
{
	char *sep = "\t";
	char *rsep = "\n";

	int i;

	m->type = Q_RESULT;
	stream_writeInt( s, Q_TABLE );
	stream_writeInt( s, 1 );

	for (i = 0; i < t->nr_cols; i++) 
	{
		res_col *c = t->cols+i;
		if (i != 0)
			stream_write(s, sep, strlen(sep), 1);

		if (c->type->type->scale == SCALE_FIX){
			char *buf = NULL;
			int len = 0;
			int l = dec_tostr((void*)(ptrdiff_t)c->type->scale, &buf, &len,
					c->mtype, c->p);
			stream_write(s, buf, l, 1);
			_DELETE(buf);
		} else { 
			char *buf = NULL;
			int len = 0;
			int l = (*BATatoms[c->mtype].atomToStr)(&buf, &len, c->p);
			stream_write(s, buf, l, 1);
			_DELETE(buf);
		}
	}
	mvc_clean_result(m, t);
	stream_write(s, rsep, strlen(rsep), 1);
	stream_flush(s);
	return 0;
}

str mvc_export_table( stream *s, int res_id, int offset, int nr )
{
	mvc *c;
	char *sep = "\t";
	char *rsep = "\n";
	int clean = 0;
	res_table *t;

	@:getContext(c)@
 	t = find_export_table(c, res_id);
	(void)s; (void)offset; (void)nr;
	(void)sep; (void)rsep;
	if (clean)
		mvc_clean_result(c, t);
	return NULL;
}
