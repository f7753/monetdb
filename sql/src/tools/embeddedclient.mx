@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2004 CWI.
@' All Rights Reserved.

@f embeddedclient
@a K.S. Mullender
@h
#ifndef _EMBEDDEDCLIENT_H_
#define _EMBEDDEDCLIENT_H_

#ifdef _MSC_VER
#ifndef LIBEMBEDDEDCLIENT
#define embeddedclient_export extern __declspec(dllimport)
#else
#define embeddedclient_export extern __declspec(dllexport)
#endif
#else
#define embeddedclient_export extern
#endif

#include <streams.h>
#include <Mapi.h>

embeddedclient_export Mapi embedded_sql(void);

#endif /* _EMBEDDEDCLIENT_H_ */
@c
#include "monet.h"
#include "monet_options.h"
#include "initmodules.h"
#include "Mapi.h"
#include <pthread.h>

static Client
Monet_init(opt *set, int setlen)
{
	char *p;
	opt *n = (opt *) GDKmalloc(setlen * sizeof(opt));
	int i, j, nlen = 0;

	char dbfarm[BUFSIZ];
	char *dbname = mo_find_option(set, setlen, "gdk_dbname");
	char *dbfarmval = mo_find_option(set, setlen, "gdk_dbfarm");
	char *alloc_map = mo_find_option(set, setlen, "gdk_alloc_map");

	if (n == NULL || dbname == NULL || dbfarmval == NULL ||
	    alloc_map == NULL) {
		if (n != NULL)
			GDKfree(n);
		return NULL;
	}

	strncpy(dbfarm, dbfarmval, sizeof(dbfarm));
	mo_substitute(set, setlen, dbfarm);

        /* determine Monet's kernel settings. */
	if (!GDKinit(dbname, dbfarm, strcasecmp(alloc_map, "yes") == 0)) {
		GDKfree(n);
		return NULL;
	}

	for (i = 0; i < setlen; i++) {
		int done = 0;

		for (j = 0; j < nlen; j++) {
			if (strcmp(n[j].name, set[i].name) == 0) {
			    	if (n[j].kind < set[i].kind)
					n[j] = set[i];
				done = 1;
				break;
			}
		}
		if (!done) {
			n[nlen] = set[i];
			nlen++;
		}
	}
	for (i = 0; i < nlen; i++) {
		char value[BUFSIZ];

		strncpy(value, n[i].value, BUFSIZ);
		mo_substitute(n, nlen, value);
		GDKsetenv(n[i].name, value);
	}
	GDKfree(n);

	if ((p = GDKgetenv("gdk_debug")) != NULL)
		GDKdebug = strtol(p, NULL, 10);

	if ((p = GDKgetenv("gdk_mem_bigsize")) != NULL)
		GDK_mem_bigsize = strtol(p, NULL, 10);
	if ((p = GDKgetenv("gdk_vm_minsize")) != NULL)
		GDK_vm_minsize = strtol(p, NULL, 10);

	if (GDKgetenv_isyes("monet_daemon"))
		monet_daemon=1;

	return monet_init();
}

static void *
start_sql_server(void *arg)
{
	static int initialized = 0;
	stream *in, *out;
	char buf[128];

	if (!initialized) {
		opt *set = NULL;
		int setlen = 0;
		Client c;

/* 		monet_singlethreaded = 1; */
		setlen = mo_builtin_settings(&set);
		setlen = mo_system_config(&set, setlen);
		c = Monet_init(set, setlen);
		mo_free_options(set, setlen);
		static_module_init();
		initialized = 1;
	}

	in = ((stream **) arg)[0];
	out = ((stream **) arg)[1];
	free(arg);
	snprintf(buf, sizeof(buf),
		 "SQLclient(Stream(\"" PTRFMT "\"), Stream(\"" PTRFMT "\"));",
		 PTRFMTCAST in, PTRFMTCAST out);
	monet_exec("module(sql_server);");
	monet_exec("mvc_init(int(monet_environment.find(\"sql_debug\")));");
	monet_exec(buf);
	return NULL;
}

Mapi
embedded_sql(void)
{
	Mapi mid;
	pthread_t sqlthread;
	stream **server;

	server = mapi_embedded_init(&mid);

	pthread_create(&sqlthread, NULL, start_sql_server, (void *) server);

	mapi_start_talking(mid);

	return mid;
}
