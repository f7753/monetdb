package nl.cwi.monetdb.jdbc;

import java.sql.*;
import java.util.Properties;
import java.net.*;

/**
 * A Driver suitable for the Monet database
 * <br /><br />
 * This driver will be used by the DriverManager to determine if an URL is to be
 * handled by this driver, and if it does, then this driver will supply a
 * Connection suitable for MonetDB.
 * <br /><br />
 * This class has no explicit constructor, the default constructor generated by
 * the Java compiler will be sufficient since nothing has to be set in order to
 * use this driver.
 * <br /><br />
 * This Driver supports Monet database URLs. MonetDB URLs are defined as:<br />
 * <tt>jdbc:monetdb://&lt;host&gt;[:&lt;port&gt]/&lt;database&gt;</tt><br />
 * where [:&lt;port&gt] denotes that a port is optional. If not given the default
 * (@JDBC_DEF_PORT@) will be used.
 *
 * @author Fabian Groffen <Fabian.Groffen@cwi.nl>
 * @version @JDBC_MAJOR@.@JDBC_MINOR@ (@JDBC_VER_SUFFIX@)
 */
public class MonetDriver implements Driver {
	// the url kind will be jdbc:monetdb://<host>[:<port>]/<database>
	// Chapter 9.2.1 from Sun JDBC 3.0 specification
	/** The prefix of a MonetDB url */
	private static final String MONETURL = "jdbc:monetdb://";
	// this is a real beta release (we decide not to follow Sun's rule here)
	/** Major version of this driver */
	private static final int DRIVERMAJOR = @JDBC_MAJOR@;
	/** Minor version of this driver */
	private static final int DRIVERMINOR = @JDBC_MINOR@;
	/** Version suffix string */
	private static final String DRIVERVERSIONSUFFIX = "@JDBC_VER_SUFFIX@";
	// I don't dare to even think of calling it compliant yet ;)
	/** Whether this driver is JDBC compliant or not */
	private static final boolean MONETJDBCCOMPLIANT = false;

	/** Monet default port to connect to */
	private static final String PORT = "@JDBC_DEF_PORT@";

	/** Do we connect with blockmode by default or not */
	private static final String BLOCKMODE = "@JDBC_DEF_BLOCKMODE@";

	// Monet prompts
	/** MAPI PROMPT1 */
	final static String prompt1 = "" + (char)1 + (char)1;
	/** MAPI PROMPT2 */
	final static String prompt2 = "" + (char)1 + (char)2;


	// initialize this class: register it at the DriverManager
	// Chapter 9.2 from Sun JDBC 3.0 specification
	static {
		try {
			DriverManager.registerDriver(new MonetDriver());
 		} catch (SQLException e) {
			e.printStackTrace();
		}
	}

	//== methods of interface Driver

	/**
	 * Retrieves whether the driver thinks that it can open a connection to the
	 * given URL. Typically drivers will return true if they understand the
	 * subprotocol specified in the URL and false if they do not.
	 *
	 * @param url the URL of the database
	 * @return true if this driver understands the given URL; false otherwise
	 */
	public boolean acceptsURL(String url) {
		return(url != null && url.startsWith(MONETURL));
	}

	/**
	 * Attempts to make a database connection to the given URL. The driver
	 * should return "null" if it realizes it is the wrong kind of driver to
	 * connect to the given URL. This will be common, as when the JDBC driver
	 * manager is asked to connect to a given URL it passes the URL to each
	 * loaded driver in turn.
	 * <br /><br />
	 * The driver should throw an SQLException if it is the right driver to
	 * connect to the given URL but has trouble connecting to the database.
	 * <br /><br />
	 * The java.util.Properties argument can be used to pass arbitrary string
	 * tag/value pairs as connection arguments. Normally at least "user" and
	 * "password" properties should be included in the Properties object.
	 *
	 * @param url the URL of the database to which to connect
	 * @param info a list of arbitrary string tag/value pairs as connection
	 *        arguments. Normally at least a "user" and "password" property
	 *        should be included
	 * @return a Connection object that represents a connection to the URL
	 * @throws SQLException if a database access error occurs
	 */
	public Connection connect(String url, Properties info)
		throws SQLException
	{
		int tmp;
		Properties props = new Properties();
		// set the optional properties and their defaults here
		props.put("port", PORT);
		props.put("blockmode", BLOCKMODE);
		props.put("debug", "false");
		props.put("language", "sql");	// mil, mal, sql, xquery, whatever

		props.putAll(info);
		info = props;

		// url should be of style jdbc:monetdb://<host>/<database>
		if (!acceptsURL(url)) return(null);
		// remove "jdbc:" so the rest is a valid hierarchical URI
		URI uri;
		try {
			uri = new URI(url.substring("jdbc:".length()));
		} catch (URISyntaxException e) {
			throw new SQLException(e.toString());
		}

		info.put("host", uri.getHost());
		if (uri.getPort() > 0) info.put("port", "" + uri.getPort());

		// check the database
		if (uri.getPath() == null ||
			uri.getPath().substring(1).trim().equals(""))
			throw new SQLException("Invalid URL: A database is required");
		info.put("database", uri.getPath().substring(1));

		if (uri.getQuery() != null) {
			// handle additional arguments
			String args[] = uri.getQuery().split("&");
			for (int i = 0; i < args.length; i++) {
				tmp = args[i].indexOf("=");
				if (tmp > 0) info.put(args[i].substring(0, tmp), args[i].substring(tmp + 1));
			}
		}

		// finally return the Connection as requested
		try {
			return(new MonetConnection(info));
		} catch (IllegalArgumentException e) {
			throw new SQLException(e.getMessage());
		}
	}

	/**
	 * Retrieves the driver's major version number. Initially this should be 1.
	 *
	 * @return this driver's major version number
	 */
	public int getMajorVersion() {
		return(DRIVERMAJOR);
	}

	/**
	 * Gets the driver's minor version number. Initially this should be 0.
	 *
	 * @return this driver's minor version number
	 */
	public int getMinorVersion() {
		return(DRIVERMINOR);
	}

	/**
	 * Gets information about the possible properties for this driver.
	 * <br /><br />
	 * The getPropertyInfo method is intended to allow a generic GUI tool to
	 * discover what properties it should prompt a human for in order to get
	 * enough information to connect to a database. Note that depending on the
	 * values the human has supplied so far, additional values may become
	 * necessary, so it may be necessary to iterate though several calls to the
	 * getPropertyInfo method.
	 *
	 * @param url the URL of the database to which to connect
	 * @param info a proposed list of tag/value pairs that will be sent on
	 *        connect open
	 * @return an array of DriverPropertyInfo objects describing possible
	 *         properties. This array may be an empty array if no properties
	 *         are required.
	 */
	public DriverPropertyInfo[] getPropertyInfo(String url, Properties info) {
		if (!acceptsURL(url)) return(null);

		DriverPropertyInfo[] dpi = new DriverPropertyInfo[2];
		dpi[0] = new DriverPropertyInfo("user", info.getProperty("user"));
		dpi[0].required = true;
		dpi[0].description = "The username to use when authenticating on the database";

		dpi[1] = new DriverPropertyInfo("password", info.getProperty("password"));
		dpi[1].required = true;
		dpi[1].description = "The password to use when authenticating on the database";

		dpi[2] = new DriverPropertyInfo("debug", "false");
		dpi[2].required = false;
		dpi[2].description = "Whether or not to create a log file for debugging purposes";

		dpi[3] = new DriverPropertyInfo("blockmode", "true");
		dpi[3].required = false;
		dpi[3].description = "Whether blockmode should be used, when false, linemode is used instead";

		dpi[4] = new DriverPropertyInfo("language", "sql");
		dpi[4].required = false;
		dpi[4].description = "What language to use for MonetDB conversations (SQL/MIL/MAL/XQuery/etc.) (not yet implemented)";

		return(dpi);
	}

	/**
	 * Reports whether this driver is a genuine JDBC Compliant&tm; driver. A
	 * driver may only report true here if it passes the JDBC compliance tests;
	 * otherwise it is required to return false.
	 * <br /><br />
	 * JDBC compliance requires full support for the JDBC API and full support
	 * for SQL 92 Entry Level. It is expected that JDBC compliant drivers will
	 * be available for all the major commercial databases.
	 * <br /><br />
	 * This method is not intended to encourage the development of non-JDBC
	 * compliant drivers, but is a recognition of the fact that some vendors are
	 * interested in using the JDBC API and framework for lightweight databases
	 * that do not support full database functionality, or for special databases
	 * such as document information retrieval where a SQL implementation may not
	 * be feasible.
	 *
	 * @return true if this driver is JDBC Compliant; false otherwise
	 */
	public boolean jdbcCompliant() {
		return(MONETJDBCCOMPLIANT);
	}

	//== end methods of interface driver

	/** A Map containing the mapping between MonetDB types and Java SQL types */
	static java.util.Map typeMap = new java.util.HashMap();
	static {
		// fill the typeMap once
		typeMap.put("table", new Integer(Types.ARRAY));
		typeMap.put("boolean", new Integer(Types.BOOLEAN));
		typeMap.put("bool", new Integer(Types.BOOLEAN));
		typeMap.put("ubyte", new Integer(Types.CHAR));
		typeMap.put("char", new Integer(Types.CHAR));
		typeMap.put("character", new Integer(Types.CHAR));
		typeMap.put("varchar", new Integer(Types.VARCHAR));
		typeMap.put("text", new Integer(Types.LONGVARCHAR));
		typeMap.put("tinytext", new Integer(Types.LONGVARCHAR));
		typeMap.put("string", new Integer(Types.LONGVARCHAR));
		typeMap.put("tinyint", new Integer(Types.TINYINT));
		typeMap.put("smallint", new Integer(Types.SMALLINT));
		typeMap.put("mediumint", new Integer(Types.INTEGER));
		typeMap.put("oid", new Integer(Types.OTHER));
		typeMap.put("int", new Integer(Types.INTEGER));
		typeMap.put("integer", new Integer(Types.INTEGER));
		typeMap.put("bigint", new Integer(Types.BIGINT));
		typeMap.put("number", new Integer(Types.INTEGER));
		typeMap.put("decimal", new Integer(Types.DECIMAL));
		typeMap.put("numeric", new Integer(Types.NUMERIC));
		typeMap.put("float", new Integer(Types.FLOAT));
		typeMap.put("double", new Integer(Types.DOUBLE));
		typeMap.put("real", new Integer(Types.DOUBLE));
		typeMap.put("month_interval", new Integer(Types.INTEGER));
		typeMap.put("sec_interval", new Integer(Types.BIGINT));
		typeMap.put("date", new Integer(Types.DATE));
		typeMap.put("time", new Integer(Types.TIME));
		typeMap.put("datetime", new Integer(Types.TIMESTAMP));
		typeMap.put("timestamp", new Integer(Types.TIMESTAMP));
		typeMap.put("blob", new Integer(Types.BLOB));
	}

	/**
	 * Returns the java.sql.Types equivalent of the given Monet type.
	 *
	 * @param type the type as used by Monet
	 * @return the mathing java.sql.Types constant or java.sql.Types.OTHER if
	 *         nothing matched on the given string
	 */
	static int getJavaType(String type) {
		// match the column type on a java.sql.Types constant
		Integer tp;
		if ((tp = (Integer)(typeMap.get(type.toLowerCase()))) != null) {
			return(tp.intValue());
		} else {
			// this should not be able to happen
			// do not assert, since maybe feature versions introduce
			// new types
			return(Types.OTHER);
		}
	}

	/**
	 * Returns a touched up identifying version string of this driver.
	 *
	 * @return the version string
	 */
	static String getDriverVersion() {
		return("" + DRIVERMAJOR + "." + DRIVERMINOR + " " + DRIVERVERSIONSUFFIX);
	}
}
