package nl.cwi.monetdb.jdbc;

import java.sql.*;
import java.util.Properties;

/**
 * A Driver suitable for the Monet database
 * <br /><br />
 * This driver will be used by the DriverManager to determine if an URL is to be
 * handled by this driver, and if it does, then this driver will supply a
 * Connection suitable for MonetDB.
 * <br /><br />
 * This class has no explicit constructor, the default constructor generated by
 * the Java compiler will be sufficient since nothing has to be set in order to
 * use this driver.
 * <br /><br />
 * This Driver supports Monet database URLs. MonetDB URLs are defined as:<br />
 * <tt>jdbc:monetdb://&lt;host&gt;[:&lt;port&gt]/&lt;database&gt;</tt><br />
 * where [:&lt;port&gt] denotes that a port is optional. If not given the default
 * of which @JDBC_DEF_PORT@ will be used.
 *
 * @author Fabian Groffen <Fabian.Groffen@cwi.nl>
 * @version @JDBC_MAJOR@.@JDBC_MINOR@ (@JDBC_VER_SUFFIX@)
 */
public class MonetDriver implements Driver {
	// the url kind will be jdbc:monetdb://<host>[:<port>]/<database>
	// Chapter 9.2.1 from Sun JDBC 3.0 specification
	private static final String MONETURL = "jdbc:monetdb://";
	// this is a real beta release (we decide not to follow Sun's rule here)
	private static final int DRIVERMAJOR = @JDBC_MAJOR@;
	private static final int DRIVERMINOR = @JDBC_MINOR@;
	private static final String DRIVERVERSIONSUFFIX = "@JDBC_VER_SUFFIX@";
	// I don't dare to even think of calling it compliant yet ;)
	private static final boolean MONETJDBCCOMPLIANT = false;

	// Monet default port to connect to
	private static final int PORT = @JDBC_DEF_PORT@;

	// Monet prompts
	final static String prompt1 = "" + (char)1 + (char)1;
	final static String prompt2 = "" + (char)1 + (char)2;

	// initialize this class: register it at the DriverManager
	// Chapter 9.2 from Sun JDBC 3.0 specification
	static {
		try {
			DriverManager.registerDriver(new MonetDriver());
 		} catch (SQLException e) {
			e.printStackTrace();
		}
	}

	//== methods of interface Driver

	/**
	 * Retrieves whether the driver thinks that it can open a connection to the
	 * given URL. Typically drivers will return true if they understand the
	 * subprotocol specified in the URL and false if they do not.
	 *
	 * @param url the URL of the database
	 * @return true if this driver understands the given URL; false otherwise
	 */
	public boolean acceptsURL(String url) {
		return(url != null && url.startsWith(MONETURL));
	}

	/**
	 * Attempts to make a database connection to the given URL. The driver
	 * should return "null" if it realizes it is the wrong kind of driver to
	 * connect to the given URL. This will be common, as when the JDBC driver
	 * manager is asked to connect to a given URL it passes the URL to each
	 * loaded driver in turn.
	 * <br /><br />
	 * The driver should throw an SQLException if it is the right driver to
	 * connect to the given URL but has trouble connecting to the database.
	 * <br /><br />
	 * The java.util.Properties argument can be used to pass arbitrary string
	 * tag/value pairs as connection arguments. Normally at least "user" and
	 * "password" properties should be included in the Properties object.
	 *
	 * @param url the URL of the database to which to connect
	 * @param info a list of arbitrary string tag/value pairs as connection
	 *        arguments. Normally at least a "user" and "password" property
	 *        should be included
	 * @return a Connection object that represents a connection to the URL
	 * @throws SQLException if a database access error occurs
	 */
	public Connection connect(String url, Properties info)
		throws SQLException
	{
		try {
			int tmp;

			// url should be of style jdbc:monetdb://<host>/<database>
			if (!acceptsURL(url)) return(null);
			// remove jdbc:monetdb:// part of url
			url = url.substring(MONETURL.length());
			// fetch hostname and database
			tmp = url.indexOf("/");
			// don't accept a hostless or host-only url
			if (tmp <= 0) return(null);
			String host = url.substring(0, tmp);
			String db = url.substring(tmp + 1);
			// find port in host
			int port = PORT;
			tmp = host.indexOf(":");
			if (tmp != -1) {
				port = Integer.parseInt(host.substring(tmp + 1));
				host = host.substring(0, tmp);
			}

			// convenience: temporarily store user and pass
			String user = info.getProperty("user");
			String pass = info.getProperty("password");

			// finally return the Connection as requested
			return(new MonetConnection(host, port, db, user, pass));
		} catch (SQLException e) {
			// This is probably an authentication error
			throw e;
		} catch (Throwable t) {	// catch also errors! (like index out of bounds)
			throw new SQLException("Could not parse URL: " + t.toString());
		}
	}

	/**
	 * Retrieves the driver's major version number. Initially this should be 1.
	 *
	 * @return this driver's major version number
	 */
	public int getMajorVersion() {
		return(DRIVERMAJOR);
	}

	/**
	 * Gets the driver's minor version number. Initially this should be 0.
	 *
	 * @return this driver's minor version number
	 */
	public int getMinorVersion() {
		return(DRIVERMINOR);
	}

	/**
	 * Gets information about the possible properties for this driver.
	 * <br /><br />
	 * The getPropertyInfo method is intended to allow a generic GUI tool to
	 * discover what properties it should prompt a human for in order to get
	 * enough information to connect to a database. Note that depending on the
	 * values the human has supplied so far, additional values may become
	 * necessary, so it may be necessary to iterate though several calls to the
	 * getPropertyInfo method.
	 *
	 * @param url the URL of the database to which to connect
	 * @param info a proposed list of tag/value pairs that will be sent on
	 *        connect open
	 * @return an array of DriverPropertyInfo objects describing possible
	 *         properties. This array may be an empty array if no properties
	 *         are required.
	 */
	public DriverPropertyInfo[] getPropertyInfo(String url, Properties info) {
		if (!acceptsURL(url)) return(null);

		DriverPropertyInfo[] dpi = new DriverPropertyInfo[2];
		dpi[0] = new DriverPropertyInfo("user", info.getProperty("user"));
		dpi[0].required = true;
		dpi[0].description = "The username to use when authenticating on the database";

		dpi[1] = new DriverPropertyInfo("password", info.getProperty("password"));
		dpi[1].required = true;
		dpi[1].description = "The password to use when authenticating on the database";

		return(dpi);
	}

	/**
	 * Reports whether this driver is a genuine JDBC Compliant&tm; driver. A
	 * driver may only report true here if it passes the JDBC compliance tests;
	 * otherwise it is required to return false.
	 * <br /><br />
	 * JDBC compliance requires full support for the JDBC API and full support
	 * for SQL 92 Entry Level. It is expected that JDBC compliant drivers will
	 * be available for all the major commercial databases.
	 * <br /><br />
	 * This method is not intended to encourage the development of non-JDBC
	 * compliant drivers, but is a recognition of the fact that some vendors are
	 * interested in using the JDBC API and framework for lightweight databases
	 * that do not support full database functionality, or for special databases
	 * such as document information retrieval where a SQL implementation may not
	 * be feasible.
	 *
	 * @return true if this driver is JDBC Compliant; false otherwise
	 */
	public boolean jdbcCompliant() {
		return(MONETJDBCCOMPLIANT);
	}

	//== end methods of interface driver

	static java.util.Map typeMap = new java.util.HashMap();
	static {
		// fill the typeMap once
		typeMap.put("table", new Integer(Types.ARRAY));
		typeMap.put("boolean", new Integer(Types.BOOLEAN));
		typeMap.put("bool", new Integer(Types.BOOLEAN));
		typeMap.put("ubyte", new Integer(Types.CHAR));
		typeMap.put("char", new Integer(Types.CHAR));
		typeMap.put("character", new Integer(Types.CHAR));
		typeMap.put("varchar", new Integer(Types.VARCHAR));
		typeMap.put("text", new Integer(Types.LONGVARCHAR));
		typeMap.put("tinytext", new Integer(Types.LONGVARCHAR));
		typeMap.put("string", new Integer(Types.LONGVARCHAR));
		typeMap.put("tinyint", new Integer(Types.TINYINT));
		typeMap.put("smallint", new Integer(Types.SMALLINT));
		typeMap.put("mediumint", new Integer(Types.INTEGER));
		typeMap.put("oid", new Integer(Types.OTHER));
		typeMap.put("int", new Integer(Types.INTEGER));
		typeMap.put("integer", new Integer(Types.INTEGER));
		typeMap.put("bigint", new Integer(Types.BIGINT));
		typeMap.put("number", new Integer(Types.INTEGER));
		typeMap.put("decimal", new Integer(Types.DECIMAL));
		typeMap.put("numeric", new Integer(Types.NUMERIC));
		typeMap.put("float", new Integer(Types.FLOAT));
		typeMap.put("double", new Integer(Types.DOUBLE));
		typeMap.put("real", new Integer(Types.DOUBLE));
		typeMap.put("month_interval", new Integer(Types.INTEGER));
		typeMap.put("sec_interval", new Integer(Types.BIGINT));
		typeMap.put("date", new Integer(Types.DATE));
		typeMap.put("time", new Integer(Types.TIME));
		typeMap.put("datetime", new Integer(Types.TIMESTAMP));
		typeMap.put("timestamp", new Integer(Types.TIMESTAMP));
		typeMap.put("blob", new Integer(Types.BLOB));
	}

	/**
	 * Returns the java.sql.Types equivalent of the given Monet type.
	 *
	 * @param type the type as used by Monet
	 * @return the mathing java.sql.Types constant or java.sql.Types.OTHER if
	 *         nothing matched on the given string
	 */
	static int getJavaType(String type) {
		// match the column type on a java.sql.Types constant
		Integer tp;
		if ((tp = (Integer)(typeMap.get(type.toLowerCase()))) != null) {
			return(tp.intValue());
		} else {
			// this should not be able to happen
			// do not assert, since maybe feature versions introduce
			// new types
			return(Types.OTHER);
		}
	}

	/**
	 * Returns a touched up identifying version string of this driver.
	 *
	 * @return the version string
	 */
	static String getDriverVersion() {
		return("" + DRIVERMAJOR + "." + DRIVERMINOR + " " + DRIVERVERSIONSUFFIX);
	}
}
