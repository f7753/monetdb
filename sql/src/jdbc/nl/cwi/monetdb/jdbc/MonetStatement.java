package nl.cwi.monetdb.jdbc;

import java.sql.*;
import java.io.*;
import java.util.*;
import java.util.regex.*;

/**
 * A Statement suitable for the Monet database
 * <br /><br />
 * The object used for executing a static SQL statement and returning the
 * results it produces.<br />
 * <br /><br />
 * By default, only one ResultSet object per Statement object can be open at the
 * same time. Therefore, if the reading of one ResultSet object is interleaved
 * with the reading of another, each must have been generated by different
 * Statement objects. All execution methods in the Statement interface implicitly
 * close a Statement's current ResultSet object if an open one exists.
 * <br /><br />
 * The current state of this Statement is that it only implements the
 * executeQuery() which returns a ResultSet where from results can be read
 * and executeUpdate() which doesn't return the affected rows. Commit and
 * rollback are implemented, as is the autoCommit mechanism which relies on
 * server side auto commit.<br />
 * Multi-result queries are supported using the getMoreResults() method.
 *
 * @author Fabian Groffen <Fabian.Groffen@cwi.nl>
 * @version 0.4 (beta release)
 */
public class MonetStatement implements Statement {
	/** the default number of rows that are (attempted to) read at once */
	static final int DEF_FETCHSIZE = 250;
	/** the default value of maxRows, 0 indicates unlimited */
	static final int DEF_MAXROWS = 0;

	/** the Thread that reads from the server in the background */
	final CacheThread cache;

	/** A socket connection to Mserver */
	private MonetSocket monet;
	/** The parental Connection object */
	private Connection connection;
	/** The last HeaderList object this Statement produced */
	private HeaderList lastHeaderList;
	/** The last Header that this object uses */
	private Header header;
	/** The warnings this Statement object generated */
	private SQLWarning warnings;
	/** Whether this Statement object is closed or not */
	private boolean closed;
	/** The size of the blocks of results to ask for at the server */
	private int fetchSize = DEF_FETCHSIZE;
	/** The maximum number of rows to return in a ResultSet */
	private int maxRows = DEF_MAXROWS;
	/** The suggested direction of fetching data (not really used) */
	private int fetchDirection = ResultSet.FETCH_FORWARD;
	/** The type of ResultSet to produce; i.e. forward only, random access */
	private int resultSetType = ResultSet.TYPE_FORWARD_ONLY;
	/** The concurrency of the ResultSet to produce */
	private int resultSetConcurrency = ResultSet.CONCUR_READ_ONLY;

	/**
	 * MonetStatement constructor which checks the arguments for validity, tries
	 * to set up a socket to Monet and attempts to login.
	 * This constructor is only accessible to classes from the jdbc package.
	 *
	 * @param monet the connection to Mserver to use
	 * @param connection the connection that created this Statement
	 * @param resultSetType type of ResultSet to produce
	 * @param resultSetConcurrency concurrency of ResultSet to produce
	 * @throws SQLException if an error occurs during login
	 * @throws IllegalArgumentException is one of the arguments is null or empty
	 */
	MonetStatement(
		MonetSocket monet,
		Connection connection,
		int resultSetType,
		int resultSetConcurrency)
		throws SQLException, IllegalArgumentException
	{
		if (connection == null) throw
			new IllegalArgumentException("No Connection given!");
		if (monet == null) throw
			new IllegalArgumentException("No connection with the server given!");

		this.monet = monet;
		this.connection = connection;
		this.resultSetType = resultSetType;
		this.resultSetConcurrency = resultSetConcurrency;

		// check our limits, and generate warnings as appropriate
		if (resultSetConcurrency != ResultSet.CONCUR_READ_ONLY) {
			addWarning("No concurrency mode other then read only is supported, continuing with concurrency level READ_ONLY");
			resultSetConcurrency = ResultSet.CONCUR_READ_ONLY;
		}

		// check type for supported mode
		if (resultSetType == ResultSet.TYPE_SCROLL_SENSITIVE) {
			addWarning("Change sensitive scrolling ResultSet objects are not supported, continuing with a change non-sensitive scrollable cursor.");
			resultSetType = ResultSet.TYPE_SCROLL_INSENSITIVE;
		}

		if (resultSetType == ResultSet.TYPE_FORWARD_ONLY) {
			setFetchSize(DEF_FETCHSIZE);
		} else {
			// use smaller blocks when doing scrollable resultsets
			setFetchSize(DEF_FETCHSIZE / 10);
		}

		cache = new CacheThread();
		// make the thread a little more important
		cache.setPriority(cache.getPriority() + 1);
		// quit the VM if it's waiting for this thread to end
		cache.setDaemon(true);
		cache.start();

		closed = false;
	}

	//== methods of interface Statement

	public void addBatch(String sql) {}
	public void cancel() {}
	public void clearBatch() {}

	/**
	 * Clears all warnings reported for this Statement object. After a call to
	 * this method, the method getWarnings returns null until a new warning is
	 * reported for this Statement object.
	 */
	public void clearWarnings() {
		warnings = null;
	}

	/**
	 * Releases this Statement object's database and JDBC resources immediately
	 * instead of waiting for this to happen when it is automatically closed. It
	 * is generally good practice to release resources as soon as you are
	 * finished with them to avoid tying up database resources.
	 * <br /><br />
	 * Calling the method close on a Statement object that is already closed has
	 * no effect.
	 * <br /><br />
	 * A Statement object is automatically closed when it is garbage collected.
	 * When a Statement object is closed, its current ResultSet object, if one
	 * exists, is also closed.
	 */
	public void close() {
		// close previous ResultSet, if not closed already
		if (lastHeaderList != null) lastHeaderList.close();
		cache.shutdown();
		closed = true;
	}

	// Chapter 13.1.2.3 of Sun's JDBC 3.0 Specification
	/**
	 * Executes the given SQL statement, which may return multiple results. In
	 * some (uncommon) situations, a single SQL statement may return multiple
	 * result sets and/or update counts. Normally you can ignore this unless
	 * you are (1) executing a stored procedure that you know may return
	 * multiple results or (2) you are dynamically executing an unknown SQL
	 * string.
	 * <br /><br />
	 * The execute method executes an SQL statement and indicates the form of
	 * the first result. You must then use the methods getResultSet or
	 * getUpdateCount to retrieve the result, and getMoreResults to move to any
	 * subsequent result(s).
	 *
	 * @param sql any SQL statement
	 * @return true if the first result is a ResultSet object; false if it is an
	 *         update count or there are no results
	 * @throws SQLException if a database access error occurs
	 */
	public boolean execute(String sql) throws SQLException {
		// close previous query, if not closed already
		if (lastHeaderList != null) {
			lastHeaderList.close();
			lastHeaderList = null;
		}

		// let the cache thread do it's work
		// use lowercase 's' in order to tell the server we don't want a
		// continuation prompt if it needs more to complete the query
		// always add ; since that doesn't hurt in any case
		lastHeaderList = cache.addQuery("s" + sql + ";");
		// give the cache thread a chance to run before we continue blocking
		// for it...
		Thread.yield();

		return(getMoreResults());
	}

	public boolean execute(String sql, int autoGeneratedKeys) {return(false);}
	public boolean execute(String sql, int[] columnIndexed) {return(false);}
	public boolean execute(String sql, String[] columnNames) {return(false);}
	public int[] executeBatch() {return(null);}

	/**
	 * Executes the given SQL statement, which returns a single ResultSet
	 * object.
	 *
	 * @param sql an SQL statement to be sent to the database, typically a
	 *        static SQL SELECT statement
	 * @return a ResultSet object that contains the data produced by the given
	 *         query; never null
	 * @throws SQLException if a database access error occurs or the given SQL
	 *         statement produces anything other than a single ResultSet object
	 */
	public ResultSet executeQuery(String sql) throws SQLException {
		if (execute(sql) != true)
			throw new SQLException("Query did not produce a result set");

		return(getResultSet());
	}

	/**
	 * Executes the given SQL statement, which may be an INSERT, UPDATE, or
	 * DELETE statement or an SQL statement that returns nothing, such as an
	 * SQL DDL statement.
	 * <br /><br />
	 * make an implementation which returns affected rows, need protocol
	 * modification for that!!!
	 *
	 * @param sql an SQL INSERT, UPDATE or DELETE statement or an SQL statement
	 *        that returns nothing
	 * @return either the row count for INSERT, UPDATE  or DELETE statements, or
	 *         0 for SQL statements that return nothing<br />
	 *         <b>currently always returns -1 since the mapi protocol doesn't
	 *         return the affected rows!!!</b>
	 * @throws SQLException if a database access error occurs or the given SQL
	 *         statement produces a ResultSet object
	 */
	public int executeUpdate(String sql) throws SQLException {
		if (execute(sql) != false)
			throw new SQLException("Query produced a result set");

		return(getUpdateCount());
	}

	public int executeUpdate(String sql, int autoGeneratedKeys) {return(-1);}
	public int executeUpdate(String sql, int[] columnIndexed) {return(-1);}
	public int executeUpdate(String sql, String[] columnNames) {return(-1);}

	/**
	 * Retrieves the Connection object that produced this Statement object.
	 *
	 * @return the connection that produced this statement
	 */
	public Connection getConnection() {
		return(connection);
	}

	/**
	 * Retrieves the direction for fetching rows from database tables that is
	 * the default for result sets generated from this Statement object. If
	 * this Statement object has not set a fetch direction by calling the
	 * method setFetchDirection, the return value is ResultSet.FETCH_FORWARD.
	 *
	 * @return the default fetch direction for result sets generated from this
	 *         Statement object
	 */
	public int getFetchDirection() {
		return(fetchDirection);
	}

	/**
	 * Retrieves the number of result set rows that is the default fetch size
	 * for ResultSet objects generated from this Statement object. If this
	 * Statement object has not set a fetch size by calling the method
	 * setFetchSize, the return value is DEF_FETCHSIZE.
	 *
	 * @return the default fetch size for result sets generated from this
	 *         Statement object
	 */
	public int getFetchSize() {
		return(fetchSize);
	}

	public ResultSet getGeneratedKeys() {return(null);}
	public int getMaxFieldSize() {return(-1);}

	/**
	 * Retrieves the maximum number of rows that a ResultSet object produced by
	 * this Statement object can contain. If this limit is exceeded, the excess
	 * rows are silently dropped.
	 *
	 * @return the current maximum number of rows for a ResultSet object
	 *         produced by this Statement object; zero means there is no limit
	 */
	public int getMaxRows() {
		return(maxRows);
	}

	/**
	 * Moves to this Statement object's next result, returns true if it is a
	 * ResultSet object, and implicitly closes any current ResultSet object(s)
	 * obtained with the method getResultSet.
	 * <br /><br />
	 * There are no more results when the following is true:<br />
	 * (!getMoreResults() && (getUpdateCount() == -1)
	 *
	 * @return true if the next result is a ResultSet object; false if it is
	 *              an update count or there are no more results
	 * @throws SQLException if a database access error occurs
	 * @see #getMoreResults(int current)
	 */
	public boolean getMoreResults() throws SQLException {
		return(getMoreResults(CLOSE_ALL_RESULTS));
	}

	/**
	 * Moves to this Statement object's next result, deals with any current
	 * ResultSet object(s) according to the instructions specified by the given
	 * flag, and returns true if the next result is a ResultSet object.
	 * <br /><br />
	 * There are no more results when the following is true:<br />
	 * (!getMoreResults() && (getUpdateCount() == -1)
	 *
	 * @param current one of the following Statement constants indicating what
	 *                should happen to current ResultSet objects obtained using
	 *                the method getResultSet: CLOSE_CURRENT_RESULT,
	 *                KEEP_CURRENT_RESULT, or CLOSE_ALL_RESULTS
	 * @return true if the next result is a ResultSet object; false if it is
	 *              an update count or there are no more results
	 * @throws SQLException if a database access error occurs
	 */
	public boolean getMoreResults(int current) throws SQLException {
		if (current == CLOSE_CURRENT_RESULT) {
			if (header != null) header.close();
		} else if (current == CLOSE_ALL_RESULTS) {
			/// todo: currently not supported
		}
		// we default to keep current result, which requires no action
		header = lastHeaderList.getNextHeader();

		if (header == null) {
			// no resultset
			return(false);
		} else {
			return(true);
		}
	}

	public int getQueryTimeout() {return(-1);}

	/**
	 * Retrieves the current result as a ResultSet object. This method should
	 * be called only once per result.
	 *
	 * @return the current result as a ResultSet object or null if the result
	 *         is an update count or there are no more results
	 * @throws SQLException if a database access error occurs
	 */
	public ResultSet getResultSet() throws SQLException{
		if (header == null) return(null);

		try {
			return(new MonetResultSet(
						this,
						header,
						resultSetType,
						resultSetConcurrency));
		} catch (IllegalArgumentException e) {
			throw new SQLException(e.toString());
		}
		// don't catch SQLException, it is declared to be thrown
	}

	/**
	 * Retrieves the result set concurrency for ResultSet objects generated
	 * by this Statement object.
	 *
	 * @return either ResultSet.CONCUR_READ_ONLY or ResultSet.CONCUR_UPDATABLE
	 */
	public int getResultSetConcurrency() {
		return(resultSetConcurrency);
	}

	public int getResultSetHoldability() {return(-1);}

	/**
	 * Retrieves the result set type for ResultSet objects generated by this
	 * Statement object.
	 *
	 * @return one of ResultSet.TYPE_FORWARD_ONLY,
	 *         ResultSet.TYPE_SCROLL_INSENSITIVE, or
	 *         ResultSet.TYPE_SCROLL_SENSITIVE
	 */
	public int getResultSetType() {
		return(resultSetType);
	}

	/**
	 * Retrieves the current result as an update count; if the result is a
	 * ResultSet object or there are no more results, -1 is returned. This
	 * method should be called only once per result.
	 *
	 * @return the current result as an update count; -1 if the current result
	 *         is a ResultSet object or there are no more results
	 */
	public int getUpdateCount() {
		// there is currently no way to get the update count, so this is fixed
		// on -1 for now :(
		return(-1);
	}

	/**
	 * Retrieves the first warning reported by calls on this Statement object.
	 * If there is more than one warning, subsequent warnings will be chained to
	 * the first one and can be retrieved by calling the method
	 * SQLWarning.getNextWarning on the warning that was retrieved previously.
	 * <br /><br />
	 * This method may not be called on a closed statement; doing so will cause
	 * an SQLException to be thrown.
	 * <br /><br />
	 * Note: Subsequent warnings will be chained to this SQLWarning.
	 *
	 * @return the first SQLWarning object or null if there are none
	 * @throws SQLException if a database access error occurs or this method is
	 *         called on a closed connection
	 */
	public SQLWarning getWarnings() throws SQLException {
		if (closed) throw new SQLException("Cannot call on closed Statement");

		// if there are no warnings, this will be null, which fits with the
		// specification.
		return(warnings);
	}

	public void setCursorName(String name) {}
	public void setEscapeProcessing(boolean enable) {}

	/**
	 * Gives the driver a hint as to the direction in which rows will be
	 * processed in ResultSet objects created using this Statement object.
	 * The default value is ResultSet.FETCH_FORWARD.
	 * <br /><br />
	 * Note that this method sets the default fetch direction for result sets
	 * generated by this Statement object. Each result set has its own methods
	 * for getting and setting its own fetch direction.
	 *
	 * @param direction the initial direction for processing rows
	 * @throws SQLException if a database access error occurs or the given
	 *         direction is not one of ResultSet.FETCH_FORWARD,
	 *         ResultSet.FETCH_REVERSE, or ResultSet.FETCH_UNKNOWN
	 */
	public void setFetchDirection(int direction) throws SQLException {
		if (direction == ResultSet.FETCH_FORWARD ||
		    direction == ResultSet.FETCH_REVERSE ||
			direction == ResultSet.FETCH_UNKNOWN)
		{
			fetchDirection = direction;
		} else {
			throw new SQLException("Illegal direction: " + direction);
		}
	}

	/**
	 * Gives the JDBC driver a hint as to the number of rows that should be
	 * fetched from the database when more rows are needed. The number of rows
	 * specified affects only result sets created using this statement. If the
	 * value specified is zero, then the hint is ignored. The default value is
	 * defined in DEF_FETCHSIZE.<br />
	 *
	 * @param rows the number of rows to fetch
	 * @throws SQLException if the condition 0 <= rows <= this.getMaxRows()
	 *         is not satisfied.
	 */
	public void setFetchSize(int rows) throws SQLException {
		if (rows == 0) {
			fetchSize = DEF_FETCHSIZE;
		} else if (rows > 0 && !(getMaxRows() != 0 && rows > getMaxRows())) {
			fetchSize = rows;
		} else {
			throw new SQLException("Illegal fetch size value: " + rows);
		}
	}

	public void setMaxFieldSize(int max) {}

	/**
	 * Sets the limit for the maximum number of rows that any ResultSet object
	 * can contain to the given number. If the limit is exceeded, the excess
	 * rows are silently dropped.
	 *
	 * @param max the new max rows limit; zero means there is no limit
	 * @throws SQLException if the condition max >= 0 is not satisfied
	 */
	public void setMaxRows(int max) throws SQLException {
		if (max < 0) throw new SQLException("Illegal max value: " + max);
		maxRows = max;
	}

	public void setQueryTimeout(int seconds) {}

	//== end methods of interface Statement

	protected void finalize() {
		close();
	}

	/**
	 * Adds a warning to the pile of warnings this Statement object has. If
	 * there were no warnings (or clearWarnings was called) this warning will
	 * be the first, otherwise this warning will get appended to the current
	 * warning.
	 *
	 * @param reason the warning message
	 */
	private void addWarning(String reason) {
		if (warnings == null) {
			warnings = new SQLWarning(reason);
		} else {
			warnings.setNextWarning(new SQLWarning(reason));
		}
	}


	/**
	 * The CacheThread represents a pseudo array holding all results. For real
	 * only a part of the complete result set is cached, but upon request for
	 * a result outside the actual cache, the cache is shuffled so the result
	 * comes available.
	 */
	class CacheThread extends Thread {
		/** the last error messages */
		private String error;

		/** A queue of queries that need to be executed by this Statement */
		private List queryQueue = new LinkedList();

		/** The state WAIT represents this thread to be waiting for something to do */
		private final static int WAIT = 0;
		/** The state QUERY represents this thread to be executing a query */
		private final static int QUERY = 1;
		/** The state DEAD represents this thread to be dead and unable to do anything */
		private final static int DEAD = 2;

		/** Whether this CacheThread is still running, executing or waiting */
		private int state = WAIT;

		public void run() {
			while(state != DEAD) {
				Object cur;
				synchronized(queryQueue) {
					cur = null;
					if (queryQueue.size() == 0) {
						try {
							state = WAIT;
							queryQueue.wait();
						} catch (InterruptedException e) {
							// possible shutdown of this thread?
							// next condition check will act appropriately
						}
						continue;
					} else {
						cur = queryQueue.remove(0);
					}
				}

				// at this point we have a valid cur, since the wait continues
				// and skips this part
				if (cur instanceof HeaderList) {
					processQuery((HeaderList)cur);
				} else if (cur instanceof RawResults) {
					fetchBlock((RawResults)cur);
				}
			}
		}

		/**
		 * Lets this thread terminate (die) so it turns into a normal object and
		 * can be garbage collected.
		 * A call to this function should be made when the parent Statement
		 * closes to let this thread disappear.
		 */
		void shutdown() {
			state = DEAD;
			// if the thread is blocking on a wait, break it out
			synchronized(queryQueue) {
				queryQueue.notify();
			}
		}

		/**
		 * Returns whether an error has occurred since the last call to
		 * getError() or not
		 *
		 * @return true if an error has occured
		 * @see #getError()
		 */
		synchronized boolean hasError() {
			return(error == null ? false : true);
		}

		/**
		 * Returns the last error since the last call to this function. On each
		 * call to this method the error message is cleared.
		 *
		 * @return the last error message
		 */
		synchronized String getError() {
			String ret = error;
			error = null;
			return(ret);
		}

		/**
		 * Adds a new query to the queue of queries that can and should be
		 * executed.  A HeaderList object is returned which is notified when a
		 * new Header is added to it.
		 *
		 * @param query the query to execute
		 * @return a HeaderList object which will get filled with Headers
		 * @throws IllegalStateException if this thread is not alive
		 * @see MonetStatement.HeaderList
		 */
		HeaderList addQuery(String query) throws IllegalStateException {
			if (state == DEAD) throw
				new IllegalStateException("CacheThread shutting down or not running");

			HeaderList hdrl;
			synchronized(queryQueue) {
				hdrl = new HeaderList(query);
				queryQueue.add(hdrl);
				queryQueue.notify();
			}

			return(hdrl);
		}

		RawResults addBlock(Header hdr, int block) throws IllegalStateException {
			if (state == DEAD) throw
				new IllegalStateException("CacheThread shutting down or not running");

			RawResults rawr;
			synchronized(queryQueue) {
				int cacheSize = hdr.getCacheSize();
				// get number of results to fetch
				int size = Math.min(cacheSize, hdr.getTupleCount() - (block * cacheSize));

				if (size == 0) throw
					new IllegalStateException("Should not fetch empty block!");

				rawr = new RawResults(size,
					"Xexport " + hdr.getID() + " " + block * cacheSize + " " + size);

				queryQueue.add(rawr);
				queryQueue.notify();
			}

			return(rawr);
		}

		/**
		 * Executes the query contained in the given HeaderList, and stores the
		 * Headers resulting from this query in the HeaderList.
		 *
		 * @param hdrl a HeaderList which contains the query to execute
		 */
		private void processQuery(HeaderList hdrl) {
			synchronized (monet) {
				try {
					// make sure we're ready to send query; read data till we have the
					// prompt it is possible (and most likely) that we already have
					// the prompt and do not have to skip any lines. Ignore errors from
					// previous result sets.
					monet.waitForPrompt();

					Header hdr = new Header(this);
					// set the reply size for this query. If it is set to 0 we get a
					// prompt after the server sent it's header
					try {
						((MonetConnection)connection).setReplySize(
							maxRows != 0 ? Math.min(maxRows, hdr.getCacheSize()) : hdr.getCacheSize());
					} catch (SQLException e) {
						hdrl.addError(e.getMessage());
						hdrl.setComplete();
						return;
					}

					// send the query
					monet.writeln(hdrl.getQuery());

					// go for new results
					String tmpLine;
					RawResults rawr = null;
					int lastState = MonetSocket.EMPTY;
					do {
						tmpLine = monet.readLine();
						if (monet.getLineType() == MonetSocket.ERROR) {
							// store the error message in the Header object
							hdrl.addError(tmpLine.substring(1));
						} else if (monet.getLineType() == MonetSocket.HEADER) {
							if (hdr == null) {
								hdr = new Header(this);
								rawr = null;
							}
							hdr.addHeader(tmpLine);
						} else if (monet.getLineType() == MonetSocket.RESULT) {
							// complete the header info and add to list
							if (lastState == MonetSocket.HEADER) {
								hdr.complete();
								rawr = new RawResults(Math.min(hdr.getCacheSize(), hdr.getTupleCount()), null);
								hdr.addRawResults(0, rawr);
								// a RawResults must be in hdr at this point!!!
								hdrl.addHeader(hdr);
								hdr = null;
							}
							rawr.addRow(tmpLine);
						} else if (monet.getLineType() == MonetSocket.EMPTY) {
							// empty, will mean Monet stopped somehow (crash?)
							hdrl.addError("Unexpected end of stream, Mserver still alive?");
						}
					} while ((lastState = monet.getLineType()) != MonetSocket.PROMPT1);
				} catch (SQLException e) {
					hdrl.addError(e.getMessage());
					// if Monet sent us an incomplete or malformed header, we have
					// big problems, thus discard the whole bunch and quit processing
					// this one
					try {
						monet.waitForPrompt();
					} catch (IOException ioe) {
						hdrl.addError(e.toString());
					}
				} catch (IOException e) {
					hdrl.addError(e.toString());
				}
				// close the header list, no more headers will follow
				hdrl.setComplete();
			}
		}

		/**
		 * Retrieves a continuation block of a previously (partly) fetched
		 * result.  The data is stored in the given RawResults which also
		 * holds the Xeport query to issue on the server.
		 *
		 * @param rawr a RawResults containing the Xexport to execute
		 */
		private void fetchBlock(RawResults rawr) {
			synchronized (monet) {
				try {
					// make sure we're ready to send query; read data till we have the
					// prompt it is possible (and most likely) that we already have
					// the prompt and do not have to skip any lines. Ignore errors from
					// previous result sets.
					monet.waitForPrompt();

					// send the query
					monet.writeln(rawr.getXexport());

					// go for new results, everything should be result (or error :( )
					String tmpLine;
					do {
						tmpLine = monet.readLine();
						if (monet.getLineType() == MonetSocket.RESULT) {
							rawr.addRow(tmpLine);
						} else if (monet.getLineType() == MonetSocket.ERROR) {
							rawr.addError(tmpLine.substring(1));
						} else if (monet.getLineType() == MonetSocket.HEADER) {
							rawr.addError("Unexpected header found");
						} else if (monet.getLineType() == MonetSocket.EMPTY) {
							rawr.addError("Unexpected end of stream, Mserver still alive?");
						}
					} while (monet.getLineType() != MonetSocket.PROMPT1);
				} catch (IOException e) {
					rawr.addError(e.toString());
				}
			}
		}
	}

	/**
	 * Inner class which holds the raw data as read from the server, and
	 * the associated header information, in a parsed manor, ready for easy
	 * retrieval.
	 * <br /><br />
	 * This object is not intended to be queried by multiple threads
	 * synchronously. It is designed to work for one thread retrieving rows
	 * from it. When multiple threads will retrieve rows from this object, it
	 * is likely for some threads to get locked forever.
	 */
	class RawResults {
		/** The String array to keep the data in */
		private String[] data;
		/** The Xexport query that results in this block */
		private String export;

		/** The counter which keeps the current position in the data array */
		private int pos;
		/** The line to watch for and notify upon when added */
		private int watch;
		/** The errors generated for this ResultBlock */
		private String error;

		/**
		 * Constructs a RawResults object
		 * @param size the size of the data array to create
		 */
		public RawResults(int size, String export) {
			pos = -1;
			data = new String[size];
			// a newly set watch will always be smaller than size
			watch = data.length;
			this.export = export;
			error = "";
		}


		/**
		 * addRow adds a String of data to this object's data array.
		 * Note that an IndexOutOfBoundsException can be thrown when an
		 * attempt is made to add more than the original construction size
		 * specified.
		 *
		 * @param line the String of data to add
		 */
		public synchronized void addRow(String line) {
			data[++pos] = line;
			if (pos >= watch) {
				// reset the watch
				watch = data.length;
				// notify listener for our lock object; we got it!
				this.notify();
			}
		}

		/**
		 * Retrieves the required row. If the row is not present, this method will
		 * block until the row is available. <br />
		 * <b>Do *NOT* use multiple threads synchronously on this method</b>
		 *
		 * @param line the row to retrieve
		 * @return the requested row as String
		 * @throws IllegalArgumentException if the row to watch for is not
		 *         within the possible range of values (0 - (size - 1))
		 */
		public synchronized String getRow(int line) throws IllegalArgumentException, SQLException {
			if (error != "") throw new SQLException(error);

			if (line >= data.length || line < 0)
				throw new IllegalArgumentException("Cannot get row outside data range (" + line + ")");

			while (setWatch(line)) {
				try {
					this.wait();
				} catch (InterruptedException e) {
					// recheck if we got the desired row
				}
			}
			return(data[line]);
		}

		/**
		 * Returns the Xexport query associated with this RawResults block.
		 *
		 * @return the Xexport query
		 */
		public String getXexport() {
			return(export);
		}

		/**
		 * Adds an error to this object's error queue
		 *
		 * @param error the error string to add
		 */
		public void addError(String error) {
			this.error += error + "\n";
		}


		/**
		 * Sets a watch for a certain row. When the row gets added, a notify
		 * will be performed on this object itself. The behaviour of this method
		 * is that it returns whether the row is already in the cache or not, so
		 * it can for example be used as:
		 * <pre>
		 *   while (rawr.setWatch(row)) {
		 *     try {
		 *       rawr.wait();
		 *     } catch (InterruptedException e) {
		 *       // recheck if we got the desired row
		 *     }
		 *   }
		 *   rawr.getLine(row);
		 * </pre>
		 *
		 * @param line the row to set the watch for
		 * @return true when the watch was set, false when the row is already
		 *         fetched and no need for wait/notify is there
		 */
		private synchronized boolean setWatch(int line) {
			boolean ret;
			if (line <= pos) {
				ret = false;
			} else {
				watch = line;
				ret = true;
			}
			return(ret);
		}
	}

	/**
	 * A Header represents a Mapi SQL header which looks like:
	 *
	 * <pre>
	 * # name,     value # name
	 * # varchar,  varchar # type
	 * # 28,    # tuplecount
	 * # 1,     # id
	 * </pre>
	 *
	 * This class does not check all arguments for null, size, etc. for
	 * performance sake!
	 */
	class Header {
		/** The names of the columns in this result */
		private String[] name;
		/** The types of the columns in this result */
		private String[] type;
		/** The number of rows this result has */
		private int tuplecount;
		/** The table ID of this result */
		private int id;
		/** A Map of result blocks (chunks of size fetchSize/cacheSize) */
		private Map resultBlocks;

		/** A bitmap telling whether the headers are set or not */
		private boolean[] isSet;
		/** Whether this Header is closed */
		private boolean closed;

		/** The CacheThread that we should use when requesting a new block */
		private CacheThread cachethread;
		// copy a few vars, so we are sure they don't change for this object
		/** A local copy of fetchSize, so its protected from changes made by
		 *  the Statement parent */
		private int cacheSize = fetchSize;
		/** A local copy of resultSetType, so its protected from changes made
		 *  by the Statement parent */
		private int rstype = resultSetType;

		/** a regular expression that we often use to split
		 *  the headers into an array (compile them once) */
		private final Pattern splitPattern = Pattern.compile(",\t");

		/**
		 * Sole constructor, which requires a CacheThread parent to be given.
		 *
		 * @param parent the CacheThread that created this Header and will
		 *               supply new result blocks
		 */
		public Header(CacheThread parent) {
			isSet = new boolean[4];
			resultBlocks = new HashMap();
			cachethread = parent;
			closed = false;
		}

		/**
		 * Parses the given string and changes the value of the matching
		 * header appropriately.
		 *
		 * @param tmpLine the string that contains the header
		 * @throws SQLException if the header cannot be parsed or is unknown
		 */
		public void addHeader(String tmpLine) throws SQLException {
			int pos = tmpLine.lastIndexOf("#");
			if (pos == -1) {
				throw new SQLException("Illegal header: " + tmpLine);
			}

			// split the header line into an array
			String[] values =
				splitPattern.split(tmpLine.substring(1, pos - 1));
			// remove whitespace from all the results
			for (int i = 0; i < values.length; i++) {
				values[i] = values[i].trim();
			}
			// add the header
			String name = tmpLine.substring(pos + 1).trim();
			if (name.equals("name")) {
				setNames(values);
			} else if (name.equals("type")) {
				setTypes(values);
			} else if (name.equals("tuplecount")) {
				setTupleCount(values[0]);
			} else if (name.equals("id")) {
				setID(values[0]);
			} else {
				throw new SQLException("Unknown header: " + name);
			}
		}

		/**
		 * Sets the name header and updates the bitmask
		 *
		 * @param name an array of Strings holding the column names
		 */
		private void setNames(String[] name) {
			this.name = name;
			isSet[0] = true;
		}

		/**
		 * Sets the type header and updates the bitmask
		 *
		 * @param type an array of Strings holding the column types
		 */
		private void setTypes(String[] type) {
			this.type = type;
			isSet[1] = true;
		}

		/**
		 * Sets the tuplecount header and updates the bitmask
		 *
		 * @param tuplecount a string representing the tuple count of
		 *                   this result
		 * @throws SQLException if the given string is not a parseable
		 *                      number
		 */
		private void setTupleCount(String tuplecount) throws SQLException {
			try {
				this.tuplecount = Integer.parseInt(tuplecount);
			} catch (NumberFormatException e) {
				throw new SQLException("tuplecount " + tuplecount + " is not a number!");
			}
			isSet[2] = true;
		}

		/**
		 * Sets the id header and updates the bitmask
		 *
		 * @param id a string representing the table id of
		 *           this result
		 * @throws SQLException if the given string is not a parseable
		 *                      number
		 */
		private void setID(String id) throws SQLException {
			try {
				this.id = Integer.parseInt(id);
			} catch (NumberFormatException e) {
				throw new SQLException("ID " + id + " is not a number!");
			}
			isSet[3] = true;
		}

		/**
		 * Adds the given RawResults to this Header at the given block
		 * position.
		 *
		 * @param block the result block the RawResults object represents
		 * @param rawr the RawResults to add
		 */
		public void addRawResults(int block, RawResults rr) {
			resultBlocks.put("" + block, rr);
		}

		/**
		 * Marks this Header as being completed.  A complete Header needs
		 * to be consistant with regards to its internal data.
		 *
		 * @throws SQLException if the data currently in this Header is not
		 *                      sufficient to be consistant
		 */
		public void complete() throws SQLException {
			boolean hasSome = isSet[0] || isSet[1] || isSet[2] || isSet[3];
			if (hasSome) {
				String error = "";
				if (!isSet[0]) error += "name header missing\n";
				if (!isSet[1]) error += "type header missing\n";
				if (!isSet[2]) error += "tuplecount header missing\n";
				if (!isSet[3]) error += "id header missing\n";
				if (!(isSet[0] && isSet[1] && isSet[2] && isSet[3]))
					throw new SQLException(error);

				if (maxRows != 0)
					tuplecount = Math.min(tuplecount, maxRows);

				// make sure the cache size is minimal to
				// reduce overhead and memory usage
				cacheSize = Math.min(tuplecount, cacheSize);
			} else {
				// a no header query (sigh, yes that can happen)
				// make sure there is NO RawResults
				resultBlocks.clear();
			}
		}


		/**
		 * Returns the names of the columns
		 *
		 * @return the names of the columns
		 */
		public String[] getNames() {
			return(name);
		}

		/**
		 * Returns the types of the columns
		 *
		 * @return the types of the columns
		 */
		public String[] getTypes() {
			return(type);
		}

		/**
		 * Returns the number of results for this result
		 *
		 * @return the number of results for this result
		 */
		public int getTupleCount() {
			return(tuplecount);
		}

		/**
		 * Returns the table id for this result
		 *
		 * @return the table id for this result
		 */
		public int getID() {
			return(id);
		}

		/**
		 * Returns the cache size used within this Header
		 *
		 * @return the cache size
		 */
		public int getCacheSize() {
			return(cacheSize);
		}


		/**
		 * Returns a line from the cache. If the line is already present in the
		 * cache, it is returned, if not apropriate actions are taken to make
		 * sure the right block is being fetched and as soon as the requested
		 * line is fetched it is returned.
		 *
		 * @param row the row in the result set to return
		 * @return the exact row read as requested or null if the requested row
		 *         is out of the scope of the result set
		 * @throws SQLException if an database error occurs
		 */
		String getLine(int row) throws SQLException {
			if (row >= tuplecount || row < 0) return null;

			int block = row / cacheSize;
			int blockLine = row % cacheSize;

			// do we have the right block (still) loaded?
			RawResults rawr;
			synchronized(resultBlocks) {
				rawr = (RawResults)(resultBlocks.get("" + block));
				if (rawr == null) {
					// if we're running forward only, we can discard the old
					// block loaded
					if (rstype == ResultSet.TYPE_FORWARD_ONLY) {
						resultBlocks.clear();
					}

					/// todo: ponder about a maximum number of blocks to keep
					///       in memory when dealing with random access to
					///       reduce memory blow-up

					// ok, need to fetch cache block first
					rawr = cachethread.addBlock(this, block);
					resultBlocks.put("" + block, rawr);
				}
			}

			try {
				return(rawr.getRow(blockLine));
			} catch (IllegalArgumentException e) {
				throw new SQLException(e.getMessage());
			}
		}

		/**
		 * Closes this Header by sending an Xclose to the server indicating
		 * that the result can be closed at the server side as well.
		 */
		public void close() {
			if (closed) return;
			try {
				// send command to server indicating we're done with this
				// result only if we had an ID in the header... Currently
				// on updates, inserts and deletes there is no header at all
				if (isSet[3]) {
					((MonetConnection)getConnection()).sendIndependantCommand("Xclose " + id);
				}
			} catch (SQLException e) {
				// too bad, we're probably closed already
			}
			closed = true;
		}

		/**
		 * Returns whether this Header is closed
		 *
		 * @return whether this Header is closed
		 */
		public boolean isClosed() {
			return(closed);
		}


		protected void finalize() throws Throwable {
			close();
			super.finalize();
		}
	}

	/**
	 * A list of Header objects.  Headers are added to this list till the
	 * setComplete() method is called.  This allows users of this HeaderList
	 * to determine whether more Headers can be added or not.  Upon add or
	 * completion, the object itself is notified, so a user can use this object
	 * to wait on when figuring out whether a new Header is available.
	 */
	private class HeaderList {
		/** The query that resulted in this HeaderList */
		private String query;
		/** Whether there are more Headers to come or not */
		private boolean complete;
		/** A list of the Headers associated with the query, in the right order */
		private List headers;

		/** The current header returned by getNextHeader() */
		private int curHeader;
		/** The errors produced by the query */
		private String error;

		/**
		 * Main constructor.
		 *
		 * @param query the query that is the 'cause' of this HeaderList
		 */
		public HeaderList(String query) {
			this.query = query;
			complete = false;
			headers = new ArrayList();
			curHeader = 0;
			error = "";
		}


		/** Sets the complete flag to true and notifies this object. */
		public synchronized void setComplete() {
			complete = true;
			this.notify();
		}

		/** Adds a Header to this object and notifies this object. */
		public synchronized void addHeader(Header header) {
			headers.add(header);
			this.notify();
		}

		/**
		 * Retrieves the query that was executed and resulted in this
		 * HeaderList.
		 *
		 * @return the query
		 */
		public String getQuery() {
			return(query);
		}

		/**
		 * Retrieves the number of Headers currently in this list.
		 *
		 * @return the number of Header objects in this list
		 */
		public synchronized int getSize() {
			return(headers.size());
		}

		/**
		 * Returns whether this HeaderList is completed.
		 *
		 * @return whether this HeaderList is completed
		 */
		public synchronized boolean isCompleted() {
			return(complete);
		}

		/**
		 * Retrieves the requested Header.
		 *
		 * @return the Header in this list at position i
		 */
		public synchronized Header getHeader(int i) {
			return((Header)(headers.get(i)));
		}

		/**
		 * Retrieves the next available header, or null if there are no next
		 * headers to come.
		 *
		 * @return the next Header available or null
		 */
		public synchronized Header getNextHeader() throws SQLException {
			if (error != "") throw new SQLException(error);

			while(curHeader >= getSize() && !isCompleted()) {
				try {
					this.wait();
				} catch (InterruptedException e) {
					// hmmm... recheck to see why we were woken up
				}
			}

			if (curHeader >= getSize()) {
				// header is obviously completed so, there are no more headers
				return(null);
			} else {
				// return this header, and increment the counter
				return(getHeader(curHeader++));
			}
		}

		/** Adds an error to the pile of errors for this object */
		public synchronized void addError(String error) {
			this.error += error + "\n";
		}

		/**
		 * Closes this HeaderList by closing all the Headers in this
		 * HeaderList.
		 */
		public synchronized void close() {
			for (int i = 0; i < headers.size(); i++) {
				getHeader(i).close();
			}
		}


		protected void finalize() throws Throwable {
			close();
			super.finalize();
		}
	}
}
