\documentclass[10pt,twocolumn,fleqn]{article}

%%\usepackage{a4wide}
%%\usepackage{amsthm}
\usepackage{times}
\usepackage{epsf}
\usepackage{graphicx}
\usepackage{epsfig}
\usepackage{graphics}
\usepackage{color}
\usepackage{url}
\begin{document}
\title{The MonetDB/SQL front-end}
\author{ Niels Nes, Martin Kersten, {\small \textsc{CWI}, Netherlands}}
\date{}
\maketitle

\section{Introduction}
The language intergalactica for database applications is SQL. It evolved
through several phases of standardization to the version known as SQL-2003.
The SQL standard provides an ideal language framework, 
in terms of standardization committee viewpoints, 
which is hardly met by any of the existing (commercial) implementations.
This is largely due to legacy of old software and backward compatability
requirements from their client base.
 
The MonetDB database system is originally developed as a database backend
kernel with its own, low-level algebraic interface and scripting language.
The development of a SQL frontend has been purposely postponed to the point
where the kernel code base was sufficiently mature and field tested in
large, mission critial applications in the financial sector.

In 2002 the first version of the SQL front-end emerged. 
This late development made it possible to immediately start from the SQL'99
definition. As soon as the SQL'03 spec became available, its content
was taken as the primary frame of reference.
The SQL development strategy is driven by immediate needs of the
user-base, such that less-frequently used features end up low on
the development stack.

This document has been written to give a quick introduction on the SQL
front-end, its limitations, and the way to use it. 
Proficiency in SQL is assumed.
Information on the architecture of MonetDB and the available programming
language interfaces can be found on the website http://monetdb.cwi.nl/.

\section{Getting started}
The MonetDB/SQL front-end can be used in different ways. 
A simple textual interface is described in Section \ref{mapi} and
using it in through a web-form in Section\ref{form}.
The ODBC and JDBC application interfaces provide the bridges
to externally developed products. The interaction with
a generic DBMS IDE is described in Section \ref{ide}.
MonetDB comes with a home-brewed GUI, called Mknife, which
is shortly introduced in Section \ref{mknife}

The examples are illustrated using the VOC database, shortly introduced
next.
\subsection{The (Dutch) East Indian Company (VOC)}
Exploring the wealth of functionality offered by MonetDB is best
started using a toy database being distributed with all packages.
This database provides a peephole view into the administrative
system of a multi-national company, the Verenigde Oostindische Companie (VOC).

The VOC was granted a monopoly on the trade in the East Indies on March 20, 1602
by the representatives of the provinces of the Dutch republic.
Attached to this monopoly was the duty to fight the enemies of the Republic and 
prevent other European nations to enter the East India trade.
During its history of 200 years, the VOC became the largest company of its kind, 
trading spices like nutmeg, cloves, cinnamon and pepper, and other consumer 
products like tea, silk and Chinese porcelain.
Her factories or trace centers were world famous: Desjima in Japan, 
Mokha in Yemen, Surat in Persia and of course Batavia, 
the Company's headquarters on Java.

The history of the VOC is an active area of research and
a focal point for multi-country heritage projects, e.g. 
TANAP\footnote{http://www.tanap.net/content/about/heritage.htm},
which includes a short historic overview of the VOC written by
world expert on the topic F. Gaastra.
The archives of the VOC are spread around the world, but a large
contingent still resides in the 
National Archive
\footnote{ http://www.nationaalarchief.nl/ }
, The Hague.

The archives comprise over 25 million historical records.
Much of which has not (yet) been digitized.

The MonetDB tutorial is based on the material published in the book 
J.R. Bruijn, F.S. Gaastra and I. Schaar, Dutch-Asiatic Shipping in the 17th and 18th Centuries</i>, which
gives an account of the trips made to the East and ships returned safely
(or wrecked on the way). A total of 8000 records are provided. 
They include information about ship name and type, captain,
the arrival/departure of harbors along the route, personnel accounts, 
and anecdotal information.

The VOC database containst a single SQL table:
{\footnotesize
\begin{verbatim}
create table voyage(
         number integer,
         trip   integer,
          boatname varchar(25),
         master varchar(25),
         tonnage integer,
         birth   varchar(10),
         acquired integer,
         yard    varchar(1),
         chamber varchar(1),
         departure       date,
         harbour varchar(12),
         cape_arrival date,
         cape_departure date,
         destination_arrival date,
         destination_harbour varchar(12) );
\end{verbatim}
}

\subsection{Textual interface}
\label{mapi}
In this section we illustrate the textual interface to MonetDB/SQL using the
MapiClient program. This combination is the baseline for all textual
interactions with a MonetDB server.
Failure to get it working often implies a wrong or inconsistent installation.

To start a session, you should have installed both the
MonetDB back-end and SQL front-end according to the 'HowToStart' descriptions.
\footnote{http://monetdb.cwi.nl/GetGoing/Download/index.html}
The next step is to start the MonetDB server.

The MonetDB server does not contain hardwired knowledge on its SQL frontend.
It must be initialized and told to accept SQL sessions. In a separate window
start the server to access the VOC database:

{\footnotesize
\begin{verbatim}
$ Mserver --dbname=VOC 
# Monet Database Server V4.3.19
# Copyright (c) 1993-2004, CWI. All rights reserved.
# Compiled for i686-pc-linux-gnu/32bit; dynamically linked.
# Visit http://monetdb.cwi.nl/ for further information.
monet>module(sql_server);
monet>
\end{verbatim}
}

The server is initialized by loading the SQL module. It will listen
to a default port for requests.
In case loading the SQL module ("sql\_server") fails, this might be caused by
the fact, that Mserver fails to find the module. There are two possible
reasons for this:

\begin{itemize}
\item
The SQL frontend it not installed properly.
Since the SQL frontend comes from a separate source repository,
it should be installed separately (unless you did install the binary package on Windows).
\item The SQL frontend is installed, but in a difference place, i.e., with a different 
PREFIX, than MonetDB.
In this case, you need to tell the Mserver, where to find the sql\_server module.
You can do this by adding the following switch when starting the Mserver:
\begin{verbatim}
--set monet_mod_path=$MONET_PREFIX/lib/MonetDB:\
\$SQL_PREFIX/lib/MonetDB
\end{verbatim}
\$MONET\_PREFIX and \$SQL\_PREFIX denote the pathes where MonetDB respectively SQL have
been installed.
Alternatively, you can add \$SQL\_PREFIX/lib/MonetDB to the monet\_mod\_path in your
 monet.conf file.
\end{itemize}
For further details see the installation notes for MonetDB.

If you get an error message, e.g. 'port already in use', you might have 
an Mserver process hanging around which should be terminated first.

The distribution comes with a simple textual interface with
command-line history features, called MapiClient.
To connect to the running MonetDB/SQL server using the
default user and authorization information, type:

\begin{verbatim}
$ MapiClient  -lsql 
sql>
\end{verbatim}
You can also identify the port listening to SQL requests using
the parameters '-p <sql\_port>'. Its default is obtained from
the configuration file.
To be assured of a proper SQL environment, you could inspect the catalog
tables as follows, the actual output may slightly differ in your version:
\begin{verbatim}
sql> select name from tables;
\#-
\# 3 \# querytype
\# tables \# table_name
\# name \# name
\# varchar \# type
\# 11 \# length
\# 17 \# tuplecount
\# 0 \# id
[ "modules"     ]
[ "schemas"     ]
[ "tables"      ]
[ "columns"     ]
[ "keys"        ]
[ "idxs"        ]
[ "keycolumns"  ]
[ "types"       ]
[ "tmp_tables"  ]
[ "tmp_columns" ]
[ "users"       ]
[ "user_role"   ]
[ "auths"       ]
[ "privileges"  ]
[ "history"     ]
[ "sessions"    ]
[ "env" ]
\end{verbatim}

If you do not see the sql$>$ prompt, or worse get an error
message 'connection refused' you may call for an expert.
It indicates use of an inconsistent MapiClient and Mserver,
or basic problems in setting up a TCP/IP connection.

The MapiClient provides a simple textual interface including
a command line history. A synopsis of the commands can be obtained
by typing '?'.

The next step is to initialize and load the VOC database, if such has
not been done before by your MonetDB system administrator. It involves
creation of the SQL table, loading the tuples, and committing the
transaction. All this is packaged in an SQL script file you should
be able to find in the distribution tree under the name voc\_dump.sql.
At the MapiClient console give the command to read sql statements
from the designated file.

\begin{verbatim}
sql> <voc_dump.sql
sql>
\end{verbatim}

The VOC database in its full incarnation contains over 8000
records. To retrieve part of it, you have to use selection and order
by predicates. A few illustrative SQL statements and snippets of
the answers are shown.
{\footnotesize
\begin{verbatim}
sql> select boatname,destination_arrival 
sql> from voyage 
sql> order by destination_arrival;
# boatname destination_arrival # name
# varchar date # type
# 5 # tuplecount
[ "LES DEUX SOEURS",           nil ]
[ "BRESLAU",            1783-08-06 ]
[ "POTSDAM",            1783-08-09 ]
[ "MAGDEBURG",          1783-09-05 ]
[ "GERECHTIGHEID",      1783-11-08 ]
sql> create view R as 
sql> select boatname as boot, tonnage as weight 
sql> from voyage;
sql> select * from R;
# boot weight # name
# varchar int # type
# 5 # tuplecount
[ "BRESLAU",            1150]
[ "LES DEUX SOEURS",     582]
[ "POTSDAM",            1150]
[ "GERECHTIGHEID",      1150]
[ "MAGDEBURG",          nil]
sql> select boatname 
sql> from voyage
sql> where tonnage between 0 and 1000;
# boatname # name
# varchar # type
# 1 # tuplecount
[ "LES DEUX SOEURS" ]
\end{verbatim}
}

\subsection{Simple web-form}
\label{form}
\subsection{A DBMS gui}
\label{ide}
\subsection{Mknife}
\label{mknife}
Mknife is a 'Swiss army knife' GUI to ease the interaction with a running 
MonetDB server. It provides a convenient setting to developed, test and 
tune queries. Although it is possible to compose rather complex applications,
including form-based data entry, its strength lies in supporting pre-cooked 
query scenarios. This requirement stems from our research activities in managing 
multimedia information in a database context. A setting where the database 
is a priori filled with a large collection of reference material, 
e.g. images or video keyframes, and automated tools enrich the database 
with derived features. Mknife is used here to ease experimentation and 
occasionally demonstrate insightful results.

Mknife comes along with a few examples based on the VOC
data. The screenshot below illustrates what you may expect.
For more details, we refer to the Mknife manual, hosted on
the
MonetDB website \footnote{http://monetdb.cwi.nl/GetGoing/Usage/Mknife/index.html}.

\begin{figure*}
\begin{center}
%include a picture
%\includegraphics[height=6cm,width=8cm]{mknife.jpg}
\caption{Mknife in action }
\end{center}
\end{figure*}


\section{Functional overview}
\label{Functionality}
The MonetDB/SQL front-end is designed with the SQL'03 standard as the reference
point. The primary goal is to provide Core SQL'03 conformance and
selectively add feature packages.

\subsection*{Session parameters}
A limited number of SQL session parameters can be set with the
statement {\sc set} {\em variable = expression}.
The setting can be inspected with the {\sc sql} statement
{\sc select} * {\sc from} env, which currently includes
the following parameters.
\begin{figure*}
\begin{tabular}{ll l}
auto\_commit & boolean & toggle auto commit transaction mode\\
reply\_size & integer & limit tuples returned by a query.\\
	&& (-1 implies everything )\\
explain & 'plan' & show MIL query plan\\
	& 'history' & keep a statement log \\
debug & integer & toggle debugging flags inside the system.\\
 && See for an overview the MonetDB configuration file\\
\end{tabular}
\caption{SQL session variables}
\end{figure*}

%Packages included
\subsection*{Packages}
The feature packages identified in the standard are often vendor specific
and their design reflect more the result of a democratic process then
the result of a scientific/engineering task.
Features may re-appear in multiple packages and vendors have a lot of
space to {\em enhance} the set.

The same holds for MonetDB, which is heavily based on an extensible 
infrastructure. Modules with novel functionality often grow out of
specific application needs. Once in a while some clean-up improves
the situation.
The feature package structure and its status is shortly described as follows
%check against standard for missing issues
[TODO check the package structure against SQL'03]
Abbreviations: TBT (ToBeTested), FS  (Fully Supported), NS (Not Supported)
UD (Under Development)

\onecolumn
\begin{tabular}{l | l | l| l |}\\
ID	&Name		&Features		&MonetDB/SQL	\\\hline
PKGOO1	&Datetime	&Interval datatype		& TBT\\
	&		&Time zone specification	& N\\
	&		&Full datetime			& TBT\\
	&		&Interval qualifier 		& TBT\\\hline
PKG002	&Enhanced 	&Assertions		& NS supported\\
	&Integrity	&Referential delete actions	& NS\\
	&Management	&Referential update actions	& NS\\
	&		&Constraint management		& FS\\
	&	 	&Subqueries in CHECK constraint	& NS \\
	&	 	&Triggers			& NS\\
	&	 	&FOR EACH STATEMENT triggers	& NS\\
	&	 	&Referential action RESTRICT	& NS\\\hline
PKG003	&OLAP capabilities&CUBE and ROLLER		& NS\\
	& 		&INTERSECT operator		& TBT\\
	&	 	&Row and table constructs	& NS\\
	&		&FULL OUTER JOIN		& FS\\
	&	 	&Scalar subquery values		& FS\\\hline
PKG004	&SQL Persistent	&A programmatic extension to SQL that makes it	& UD \\
	&Stored		&suitable for developing more functionally	& \\
	&Modules(PST)	&complete applications	& Not supported\\
	&	 	&The commands CASE, IF, WHILE, REPEAT,	& \\
	&	 	&LOOP, and FOR	& \\
	&	 	&Stored Modules	& \\
	&	 	&Computational completeness	& \\
	&	 	&INFORMATION SCHEMA views	& \\\hline
PKG005	&SQL Call-level	&SQL Call-level Interface support: an Application	& FS\\
&(CLI)	&Programming Interface (API) that enables SQL	& \\
	&Basic object support	&operations to he called that is very similar to the	& \\
	&	 & Open Database Connectivity (ODBC) standard	& \\\hline
PKG006	&Basic object support&Overloading SQL-invoked functions & NS\\
	&		& and procedures	& \\
	&	 	&User-defined types with single inheritance: basic	& \\
	&	&SQL routines on user-defined types (including	& \\
	&	&dynamic dispatch)	& \\
	&	 	&Reference types	& \\
	&	 	&CREATE TABLE	& \\
	&	 	&Array support: basic array support, array	& \\
	&	&expressions, array locators, user-datatype (DDT )	& \\
	&	&array support, reference-type array support, SQL	& \\
	&	&routine on arrays	& \\
	&	 	&Attribute and field reference	& \\
	&	 	&Reference and deference operations	& \\\hline
PKG007	& Enhanced object&ALTER TABLE, ADD COLUMN	& TBT \\
	& support	&Enhanced user-defined types (including	& NS\\
	&	&constructor options, attribute defaults, multiple	& NS\\
	&	&inheritance, and ordering clause)	& NS \\
	&	 	&SQL functions and type-name' resolution	& NS \\
	&	 	&Subtables	& NS \\
	&	 	&ONLY in queries	& NS \\
	&	 	&Type predicate	& NS \\
	&	 	&Subtype treatment	& NS \\
	&	 	&User-defined CAST functions	& NS \\
	&	 	&UDT locators	& NS \\
	&	 	&SQL routines on user-defined types such as	& NS \\
	&	&identity functions and generalized expressions	& NS \\
\end{tabular}	


\subsection{SQL Data types}
The datatypes supported by MonetDB/SQL are summarized below.
The MonetDB kernel supports extensibility with new atomic types.
They are not immediately visible at the SQL layer. It requires
patching the catalog initialization routine of the parser
and possibly the semantic analyzer.

\begin{tabular}{l |l | l | l}
Category	& SQL03 & MonetDB/SQL & Comments\\
		& type	& type	&	\\\hline
binary		& BLOB	& blob	& FS 	\\
boolean		& boolean& boolean& FS		\\
character	& char	& char	& FS	\\
		& VARCHAR &	& FS	\\
		& national char(NCHAR)&& FS utf8 supported\\
		& NVARCHAR&	& 	NS\\
		& CLOB	&	&	NS\\
		& NCLOB	&	&	NS\\
numeric		& integer& int/integer & FS\\
		& smallint&smallint& FS	\\
		&numeric &numeric& FS	\\
		& decimal&decimal& FS	 \\
		& float & float& FS	\\
		& double precision& double& FS	\\
temporal	& date & date& FS	\\
		& time & time& FS \\
		& time with time zone& NS\\
		& timestamp& timestamp& FS	\\
		& timestamp with time zone& NS\\
		& interval &	& TBT\\\hline
multiset	& table & & NS \\
{\em Additional}&	&	&	\\
		&	& oid	& TBT\\
		&	& url	& TBT\\
GIS & box	& & NS\\
		&circle	& & NS\\
		&line	& & NS\\
		&lseg	& & NS\\
		&point	& & NS\\
		&polygon & & NS\\
\end{tabular}

\subsection{Quick Reference}
The specifics of the MoneDB/SQL implementation are grossly organized
by category.

\subsubsection*{CASE}
The CASE function provides IF-THEN-ELSE functionality within
a SELECT or UPDATE statement. The constructs COALISCE and IF\_NULL are
not supported.

\subsubsection*{CAST}
The CAST operation  are implented except for CAST( NULL as datatype).
The conversions are derived from the underlying storage engine facilities,
which embody all reasonable coercions between basic data types.

\subsubsection*{COMMIT TRANSACTION/ROLLBACK }
Only strict serializable transactions are supported.
Transactions over both the catalog and database tables is supported.
The underlying store uses two facilities to ensure ACID properties.
First, a (binary) log table is maintained with all updates performed
on the database on behalf of a user. Second, base tables are assigned
a version number as part of the transaction initia
Recovery is initiated upon server re-start.
Managing the log-space and backups cre urrently a manual activity.

\subsubsection*{(DIS)CONNECT }

The CONNECT statement provides a mechanism to change the user role
for administrative actions or to overrule the default setting for
accessing the database server. [NOT SUPPORTED]

\subsubsection*{CREATE/DROP/USE DATABASE}
The databases are mapped to directories (maps) in a default location, as 
specified in the MonetDB initialization file. The current scheme is 
to simply allow any user to create a database by reserving a
directory to hold all information. The location of the database
log is similarly controlled.

\subsubsection*{CREATE/DROP FUNCTION}
Not yet implemented

\subsubsection*{CREATE/DROP INDEX}

The MonetDB kernel creates indices on the fly whenever profitable for
achieving good performance. Applying this statement is considered
an advice to create and maintain a hash index during a user session.
Creation of an index has only effect when used in combination
with keys. Other use of indices is left to the underlying DBMS kernel.

\subsubsection*{CREATE/DROP ROLE}
The SQL authorization scheme has been fully implemented.

\subsubsection*{CREATE/DROP SCHEMA}
The schema is a named collection if related objects under control of
a single authorization scheme. 

\subsubsection*{CREATE/DROP TABLE}
A table can be declared TEMPORARY. The standard table construction
facilities are supported. The integrity constraint REFERENCES is implemented
with the RESTRICT clause only.

\subsubsection*{CREATE/DROP VIEW}
Views definitions fully supported with CHECK OPTION as being the default.
No update through views are currently allowed.

\subsubsection*{GRANT/REVOKE}
The SQL authorization scheme has been implemented.

\subsubsection*{JOIN clause}
The LEFT/RIGHT OUTER joins are supported and also the NATURAL join.

\subsubsection*{LIKE operator}
The pattern matching facilities for strings should be extended and tested.

\subsubsection*{CONCAT operator}
To be tested.

\subsubsection*{SAVEPOINT}
Savepoints are fully implemented.

\subsubsection*{SET TRANSACTION}
Strict serializability is the sole isolation level supported.

\subsubsection*{START TRANSACTION}
\subsubsection*{TRUNCATE TABLE}

\section{Configuration files}
\label{configfile}

\section{The SQL todo-list}
SQL'99 and its successor SQL-2003 are extensive languages.
Several language constructs have been included/retained for
compatibility reasons, or a vendor pressing for it.
In the long run we intend to provide all functionality that
the standard pre-scribes. But, the road towards this holy grail
is long and should not be waited for.
The following table lists functionality that awaits an implementation
as of version MonetDB/SQL 1.0.16. It is more or less sorted by
our perception of need.

\begin{tabular}{l}
POSITION(str IN str)\\
SUBSTRING(str SIMILAR str ESCAPE chr)\\
OVERLAY function, i.e. substring replacment\
TRIM [BOTH|LEADING|TRAILING]( chr FROM str)\\
EXTRACT( datetimefile FROM interval)\\
WITH CHECK OPTION in view definitions\\
SYSTEM\_USER, CURRENT\_ROLE, CURRENT\_PATH\\
TIME ZONE manipulation and inspection (EXTRACT)\\
CAST (NULL AS <datatype>)\\
Column constraints: REFERENCES ARE [NOT] CHECKED [ON DELETE]\\
CREATE TEMPORARY TABLE which is autodropped \\
SQL functions \\
SQL client modules\\
OCTET\_LENGTH, BIT\_LENGTH, CARDINALITY functions\\
User defined types \\
Literal INTERVAL arithmetic, e.g. interval '6' day - interval '1' day\\
NATIONAL CHARACTER type and operators\\
CONVERT|TRANSLATE(str USING translation\_\\
DROP SCHEMA xx [CASCADE/RESTRICT]\\
CREATE LOCAL/GLOBAL TEMPORARY TABLE in procedures \\
CREATE DOMAIN\\
ARRAY type and operators\\
(Literal) ROW and reference type \\
Locator type for e.g. Blob\\
CONNECT statement to establish connections. \\
\end{tabular}

The short term priority list for development encompasses

\begin{tabular}{l}
SQL modules and external functions \\
GIS module re-vitalization\\
Inclusion of regexpr as a UDF \\
inclusion of the generated key functionality\\
ROLLUP, CUBE primitives\\
COPY into XML format\\
CORRESPONDING TO features\\
\end{tabular}
\end{document}
